<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>TRUST: SETS Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">TRUST&#160;<span id="projectnumber">1.8.4</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a>  </div>
  <div class="headertitle">
<div class="title">SETS Class Reference</div>  </div>
</div>
<div class="contents">
<!-- doxytag: class="SETS" --><!-- doxytag: inherits="Simpler" -->
<p><code>#include &lt;<a class="el" href="SETS_8h_source.html">SETS.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for SETS:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classSETS.png" usemap="#SETS_map" alt=""/>
  <map id="SETS_map" name="SETS_map">
<area href="classSimpler.html" alt="Simpler" shape="rect" coords="0,336,143,360"/>
<area href="classSimple.html" alt="Simple" shape="rect" coords="0,280,143,304"/>
<area href="classSimpler__Base.html" alt="Simpler_Base" shape="rect" coords="0,224,143,248"/>
<area href="classSolveur__non__lineaire.html" title="class Solveur_non_lineaire" alt="Solveur_non_lineaire" shape="rect" coords="0,168,143,192"/>
<area href="classSolveur__Implicite__Base.html" alt="Solveur_Implicite_Base" shape="rect" coords="0,112,143,136"/>
<area href="classObjet__U.html" title="classe Objet_U Cette classe est la classe de base des Objets de TRUST Dans les classes derivees de Ob..." alt="Objet_U" shape="rect" coords="0,56,143,80"/>
<area href="classProcess.html" title="Classe de base de TRUST (notamment Objet_U). Elle fournit quelques services de base accessibles de pa..." alt="Process" shape="rect" coords="0,0,143,24"/>
<area href="classICE.html" alt="ICE" shape="rect" coords="0,448,143,472"/>
</map>
 </div></div>

<p><a href="classSETS-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSETS.html#a0f76f0cb3170c06aecc4de223670a6a9">~SETS</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSETS.html#a944777cb20695d4fa729574ada7054cb">taille_memoire</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSETS.html#a43d8d8c22a759700d864566aaeb00658">duplique</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classType__info.html">Type_info</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSETS.html#aa3fb3b8fd11f67f72a7e93c80d969768">get_info</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Donne des informations sur le type de l'Objet_U.  <a href="#aa3fb3b8fd11f67f72a7e93c80d969768"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSETS.html#a18b50ad40531ec8d3b01fdf02bec2cb4">SETS</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classEntree.html">Entree</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSETS.html#a496bf32c88bdc0db99d03e6f925229a0">lire</a> (const <a class="el" href="classMotcle.html">Motcle</a> &amp;, <a class="el" href="classEntree.html">Entree</a> &amp;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSETS.html#aec401e12dff95162238c27ca913f0507">nb_valeurs_temporelles_pression</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSETS.html#a9836d357794031783bf88ed0c6c3efcf">iterer_eqn</a> (<a class="el" href="classEquation__base.html">Equation_base</a> &amp;equation, const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;inconnue, <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;result, double dt, int numero_iteration, int &amp;ok)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSETS.html#a0f22d8191523bca38ac875ca7e810cf0">iterer_NS</a> (<a class="el" href="classEquation__base.html">Equation_base</a> &amp;, <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;current, <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;pression, double, <a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;, double, <a class="el" href="classDoubleTrav.html">DoubleTrav</a> &amp;, int nb_iter, int &amp;converge, int &amp;ok)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSETS.html#a8f33aa634420d49c9ecdaa1f5ea140c8">get_default_growth_factor</a> () const </td></tr>
<tr><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classObjet__U.html">Objet_U</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSETS.html#aeae28bb29ca0bc249687f64a88a18096">cree_instance</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classType__info.html">Type_info</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSETS.html#a3a246bc2fc57303b38f9fc8af863a15a">info</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Donne des informations sur le type de l'Objet_U.  <a href="#a3a246bc2fc57303b38f9fc8af863a15a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSETS.html">SETS</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSETS.html#acd332834843a5735bec7008b15b4b4d2">self_cast</a> (<a class="el" href="classObjet__U.html">Objet_U</a> &amp;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classSETS.html">SETS</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSETS.html#ac4a714691f77b564b45046e2d7b786ae">self_cast</a> (const <a class="el" href="classObjet__U.html">Objet_U</a> &amp;)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">methode ajoutee pour caster en python  <a href="#ac4a714691f77b564b45046e2d7b786ae"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSETS.html#aa487da54eb9fd9c46cad4c7960c32344">eliminer</a> (const std::vector&lt; std::set&lt; std::pair&lt; std::string, int &gt;&gt;&gt; ordre, const std::string inco_p, const std::map&lt; std::string, <a class="el" href="Interface__blocs_8h.html#a68e4f5c4505f6b31305de844302660bb">matrices_t</a> &gt; &amp;<a class="el" href="classSETS.html#aa1512e2ef91bb2c9ab5968a69b54600a">mats</a>, const <a class="el" href="Interface__blocs_8h.html#a2d7480bf11fc9f791b1d2839fa30a5c3">tabs_t</a> &amp;sec, std::map&lt; std::string, <a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &gt; &amp;<a class="el" href="classSETS.html#a53cd8850df0e00210aa6c4cea0e978cd">A_p</a>, <a class="el" href="Interface__blocs_8h.html#a2d7480bf11fc9f791b1d2839fa30a5c3">tabs_t</a> &amp;b_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSETS.html#a6c7635065c4d8501c1048a2af972ae59">assembler</a> (const std::string inco_p, const std::vector&lt; std::string &gt; extra_eq, const std::map&lt; std::string, <a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &gt; &amp;<a class="el" href="classSETS.html#a53cd8850df0e00210aa6c4cea0e978cd">A_p</a>, const <a class="el" href="Interface__blocs_8h.html#a2d7480bf11fc9f791b1d2839fa30a5c3">tabs_t</a> &amp;b_p, const std::map&lt; std::string, <a class="el" href="Interface__blocs_8h.html#a68e4f5c4505f6b31305de844302660bb">matrices_t</a> &gt; &amp;<a class="el" href="classSETS.html#aa1512e2ef91bb2c9ab5968a69b54600a">mats</a>, const <a class="el" href="Interface__blocs_8h.html#a2d7480bf11fc9f791b1d2839fa30a5c3">tabs_t</a> &amp;sec, const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;inco_a, <a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;matrice, <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;secmem, int <a class="el" href="classSETS.html#a3ac3e326835cd7b7e65512befd351443">p_degen</a>)</td></tr>
<tr><td colspan="2"><h2><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSETS.html#a73c4e579bc537898da0bc707ac19fb3a">iteration</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSETS.html#a3ac3e326835cd7b7e65512befd351443">p_degen</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSETS.html#a037404a748a911b2e260905354a6c7f2">sets_</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">1 si on fait l'etape de prediction des vitesses  <a href="#a037404a748a911b2e260905354a6c7f2"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classType__info.html">Type_info</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSETS.html#a33754674a881c70726bd6b6267e0a18d">info_obj</a></td></tr>
<tr><td colspan="2"><h2><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classSortie.html">Sortie</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSETS.html#a2ad086699b67f2c4be9b94b886abadc9">printOn</a> (<a class="el" href="classSortie.html">Sortie</a> &amp;x) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Ecriture de l'objet sur un flot de sortie<br/>
Methode a surcharger.  <a href="#a2ad086699b67f2c4be9b94b886abadc9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classEntree.html">Entree</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSETS.html#a12e94bf4ecd4e24b8bd838c78df8004e">readOn</a> (<a class="el" href="classEntree.html">Entree</a> &amp;)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Lecture d'un <a class="el" href="classObjet__U.html" title="classe Objet_U Cette classe est la classe de base des Objets de TRUST Dans les classes derivees de Ob...">Objet_U</a> sur un flot d'entree<br/>
Methode a surcharger.  <a href="#a12e94bf4ecd4e24b8bd838c78df8004e"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSETS.html#a416660a4c6b560c16a63ef41bc99383f">iter_min_</a> = 1</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSETS.html#acf75db99aa6f39fb02552f774ac26d17">iter_max_</a> = 10</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSETS.html#abc7f91897922f8e62d9b9a181ff35f51">first_call_</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSETS.html#a2dc023a4074725a2d139135afb6859cf">crit_conv</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, <a class="el" href="Interface__blocs_8h.html#a68e4f5c4505f6b31305de844302660bb">matrices_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSETS.html#aa1512e2ef91bb2c9ab5968a69b54600a">mats</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">matrices : mats[nom de l'inconnue de l'equation][nom de l'autre inconnue] = matrice  <a href="#aa1512e2ef91bb2c9ab5968a69b54600a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMatrice__Bloc.html">Matrice_Bloc</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSETS.html#a8ee91bd4406997e979f5157a55749010">mat_semi_impl</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, <br class="typebreak"/>
<a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSETS.html#aa96e420735d53c9033c0031f4a02a379">mat_pred</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, <br class="typebreak"/>
<a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSETS.html#a53cd8850df0e00210aa6c4cea0e978cd">A_p</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMatrice__Morse.html">Matrice_Morse</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSETS.html#a344f98c5dfa364bc5e9c9c04ef7800ee">matrice_pression</a></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock">
<p>Definition at line <a class="el" href="SETS_8h_source.html#l00037">37</a> of file <a class="el" href="SETS_8h_source.html">SETS.h</a>.</p>
</div><hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a0f76f0cb3170c06aecc4de223670a6a9"></a><!-- doxytag: member="SETS::~SETS" ref="a0f76f0cb3170c06aecc4de223670a6a9" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SETS::~SETS </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="SETS_8cpp_source.html#l00057">57</a> of file <a class="el" href="SETS_8cpp_source.html">SETS.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a18b50ad40531ec8d3b01fdf02bec2cb4"></a><!-- doxytag: member="SETS::SETS" ref="a18b50ad40531ec8d3b01fdf02bec2cb4" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SETS::SETS </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="SETS_8cpp_source.html#l00061">61</a> of file <a class="el" href="SETS_8cpp_source.html">SETS.cpp</a>.</p>

<p>References <a class="el" href="SETS_8h_source.html#l00091">sets_</a>.</p>
<div class="fragment"><pre class="fragment">{
  <a class="code" href="classSETS.html#a037404a748a911b2e260905354a6c7f2" title="1 si on fait l&#39;etape de prediction des vitesses">sets_</a> = 1;
}
</pre></div>
</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a6c7635065c4d8501c1048a2af972ae59"></a><!-- doxytag: member="SETS::assembler" ref="a6c7635065c4d8501c1048a2af972ae59" args="(const std::string inco_p, const std::vector&lt; std::string &gt; extra_eq, const std::map&lt; std::string, Matrice_Morse &gt; &amp;A_p, const tabs_t &amp;b_p, const std::map&lt; std::string, matrices_t &gt; &amp;mats, const tabs_t &amp;sec, const DoubleTab &amp;inco_a, Matrice_Morse &amp;matrice, DoubleTab &amp;secmem, int p_degen)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SETS::assembler </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>inco_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>extra_eq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, <a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>A_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="Interface__blocs_8h.html#a2d7480bf11fc9f791b1d2839fa30a5c3">tabs_t</a> &amp;&#160;</td>
          <td class="paramname"><em>b_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, <a class="el" href="Interface__blocs_8h.html#a68e4f5c4505f6b31305de844302660bb">matrices_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>mats</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="Interface__blocs_8h.html#a2d7480bf11fc9f791b1d2839fa30a5c3">tabs_t</a> &amp;&#160;</td>
          <td class="paramname"><em>sec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>inco_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;&#160;</td>
          <td class="paramname"><em>matrice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>secmem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>p_degen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="SETS_8cpp_source.html#l00496">496</a> of file <a class="el" href="SETS_8cpp_source.html">SETS.cpp</a>.</p>

<p>References <a class="el" href="ArrOfInt_8h_source.html#l00371">ArrOfInt::addr()</a>, <a class="el" href="Matrix__tools_8cpp_source.html#l00112">Matrix_tools::allocate_morse_matrix()</a>, <a class="el" href="IntTab_8h_source.html#l00261">IntTab::append_line()</a>, <a class="el" href="EntreeSortie_8h_source.html#l00032">Cerr</a>, <a class="el" href="MD__Vector__tools_8cpp_source.html#l00109">MD_Vector_tools::creer_tableau_distribue()</a>, <a class="el" href="DoubleTab_8h_source.html#l00254">DoubleTab::dimension_tot()</a>, <a class="el" href="Process_8cpp_source.html#l00223">Process::exit()</a>, <a class="el" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>, <a class="el" href="Matrice__Morse_8h_source.html#l00142">Matrice_Morse::get_coeff()</a>, <a class="el" href="DoubleVect_8h_source.html#l00101">DoubleVect::get_md_vector()</a>, <a class="el" href="MD__Vector__tools_8cpp_source.html#l00275">MD_Vector_tools::get_sequential_items_flags()</a>, <a class="el" href="Matrice__Morse_8h_source.html#l00129">Matrice_Morse::get_set_coeff()</a>, <a class="el" href="Matrice__Morse_8h_source.html#l00134">Matrice_Morse::get_tab1()</a>, <a class="el" href="Matrice__Morse_8h_source.html#l00138">Matrice_Morse::get_tab2()</a>, <a class="el" href="DoubleVect_8h_source.html#l00164">DoubleVect::line_size()</a>, <a class="el" href="Process_8cpp_source.html#l00117">Process::me()</a>, <a class="el" href="Matrice__Morse_8h_source.html#l00103">Matrice_Morse::nb_colonnes()</a>, <a class="el" href="Array__base_8h_source.html#l00038">Array_base::NOCOPY_NOINIT</a>, <a class="el" href="MD__Vector_8h_source.html#l00063">MD_Vector::non_nul()</a>, <a class="el" href="DoubleTab_8cpp_source.html#l00335">DoubleTab::resize()</a>, and <a class="el" href="ArrOfInt_8cpp_source.html#l00443">ArrOfInt::set_smart_resize()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">int</span> i, ib, j, na = inco_a.<a class="code" href="classDoubleTab.html#a3eadd63f3ba20c1b454d760b430acbf7" title="Returns the total dimensions of the multi-dimensionnal array, including virtual items (used in parall...">dimension_tot</a>(0), m, M = inco_a.<a class="code" href="classDoubleVect.html#ab02d01cd1bdab66fbd66f9a47cc29e10">line_size</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> *deb, *fin; <span class="comment">//bornes pour chercher des indices avec lower_bound()</span>
  <span class="keywordflow">if</span> (extra_eq.size()) <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;SETS::assembler() : extra_eq pas encore code!&quot;</span> &lt;&lt; finl, <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">Process::exit</a>();
  <span class="keyword">const</span> <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; A = <a class="code" href="classSETS.html#a53cd8850df0e00210aa6c4cea0e978cd">A_p</a>.at(<span class="stringliteral">&quot;alpha&quot;</span>);

  <span class="comment">/* calc(i) = 1 si on doit remplir les lignes [N * i, (N + 1) * i[ de la matrice */</span>
  <a class="code" href="classArrOfBit.html">ArrOfBit</a> calc(na);
  <span class="keywordflow">if</span> (inco_a.<a class="code" href="classDoubleVect.html#a0d16d30580c90526e4895388fb44be5d">get_md_vector</a>().<a class="code" href="classMD__Vector.html#a4165c00904b7096274e38fdc7ca340f4">non_nul</a>()) <a class="code" href="classMD__Vector__tools.html#ad099d2407b0016920bd8c667a56fddd8">MD_Vector_tools::get_sequential_items_flags</a>(inco_a.<a class="code" href="classDoubleVect.html#a0d16d30580c90526e4895388fb44be5d">get_md_vector</a>(), calc);
  <span class="keywordflow">else</span> calc = 1;

  <span class="keywordflow">if</span> (!P.nb_colonnes()) <span class="comment">//dimensionnement au premier passage</span>
    {
      <a class="code" href="classIntTrav.html" title="Tableau de travail a n entrees pour n&lt;= 4 C&#39;est un IntTab avec allocation dans un pool de memoire gere...">IntTrav</a> stencil(0, 2);
      stencil.set_smart_resize(1);
      std::set&lt;int&gt; idx;
      <span class="keywordflow">for</span> (i = 0; i &lt; na; i++) <span class="keywordflow">if</span> (calc[i]) <span class="comment">//chaque</span>
          {
            <span class="keywordflow">if</span> (<a class="code" href="classSETS.html#a3ac3e326835cd7b7e65512befd351443">p_degen</a> &amp;&amp; !<a class="code" href="classProcess.html#ab55ba07167ec807ed3a145cac0f5dca4" title="renvoie mon rang dans le groupe de communication courant. Voir Comm_Group::rank() et PE_Groups::curre...">Process::me</a>() &amp;&amp; i == 0) <span class="keywordflow">for</span> (j = 0; j &lt; sec.at(inco_p).size_totale(); j++) idx.insert(j);
            <span class="keywordflow">else</span> <span class="keywordflow">for</span> (idx.clear(), m = 0, ib = M * i; m &lt; M; m++, ib++) <span class="keywordflow">for</span> (j = A.<a class="code" href="classMatrice__Morse.html#a79b4e334152850bd36e53478debf3061">get_tab1</a>()(ib) - 1; j &lt; A.<a class="code" href="classMatrice__Morse.html#a79b4e334152850bd36e53478debf3061">get_tab1</a>()(ib + 1) - 1; j++)
                  idx.insert(A.<a class="code" href="classMatrice__Morse.html#a787b5a63f27063f9c891243d8f188cda">get_tab2</a>()(j) - 1);
            <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;&amp; col : idx) stencil.append_line(i, col);
          }
      <a class="code" href="classMatrix__tools.html#a481961691c1dbee5372da25777e5c1e8">Matrix_tools::allocate_morse_matrix</a>(na, sec.at(inco_p).size_totale(), stencil, P);
    }

  <span class="comment">/* matrice */</span>
  <span class="keywordflow">for</span> (P.get_set_coeff() = 0, i = 0; i &lt; na; i++) <span class="keywordflow">if</span> (calc[i])
      <span class="keywordflow">for</span> (m = 0, ib = M * i, deb = P.get_tab2().addr() + P.get_tab1()(i) - 1, fin = P.get_tab2().addr() + P.get_tab1()(i + 1) - 1; m &lt; M; m++, ib++)
        <span class="keywordflow">for</span> (j = A.<a class="code" href="classMatrice__Morse.html#a79b4e334152850bd36e53478debf3061">get_tab1</a>()(ib) - 1; j &lt; A.<a class="code" href="classMatrice__Morse.html#a79b4e334152850bd36e53478debf3061">get_tab1</a>()(ib + 1) - 1; j++)
          P.get_set_coeff()(std::lower_bound(deb, fin, A.<a class="code" href="classMatrice__Morse.html#a787b5a63f27063f9c891243d8f188cda">get_tab2</a>()(j)) - &amp;P.get_tab2()(0)) += A.<a class="code" href="classMatrice__Morse.html#aacb80dd518dcc0812e3b34edac6ab67e">get_coeff</a>()(j);
  <span class="keywordtype">double</span> diag = P.get_coeff()(0);
  <span class="keywordflow">if</span> (<a class="code" href="classSETS.html#a3ac3e326835cd7b7e65512befd351443">p_degen</a> &amp;&amp; !<a class="code" href="classProcess.html#ab55ba07167ec807ed3a145cac0f5dca4" title="renvoie mon rang dans le groupe de communication courant. Voir Comm_Group::rank() et PE_Groups::curre...">Process::me</a>()) <span class="keywordflow">for</span> (i = 0; i &lt; P.get_tab1()(1) - 1; i++) P.get_set_coeff()(i) += diag; <span class="comment">//de-degeneration de la matrice</span>

  <span class="comment">/* second membre : meme structure que inco_a, mais une seule composante */</span>
  <span class="keywordflow">if</span> (inco_a.<a class="code" href="classDoubleVect.html#a0d16d30580c90526e4895388fb44be5d">get_md_vector</a>().<a class="code" href="classMD__Vector.html#a4165c00904b7096274e38fdc7ca340f4">non_nul</a>()) <a class="code" href="classMD__Vector__tools.html#aeac48ec589f525bafdfc83244a5d4dea" title="transforme v en un tableau parallele ayant la structure md. md doit est non nul ! Les dimension(i&gt;=1) ...">MD_Vector_tools::creer_tableau_distribue</a>(inco_a.<a class="code" href="classDoubleVect.html#a0d16d30580c90526e4895388fb44be5d">get_md_vector</a>(), secmem, <a class="code" href="classArray__base.html#abee342aa9ac59623c4c782dc9d7877ffaf6ae9ba7eb51c5f298ce693345b3ec68">Array_base::NOCOPY_NOINIT</a>);
  <span class="keywordflow">else</span> secmem.<a class="code" href="classDoubleTab.html#ae83b4d31205c53d9c8d2b43da178ce75" title="Change la taille du vecteur (identique a resize_array() pour le traitement des anciennes valeurs et d...">resize</a>(inco_a.<a class="code" href="classDoubleTab.html#a3eadd63f3ba20c1b454d760b430acbf7" title="Returns the total dimensions of the multi-dimensionnal array, including virtual items (used in parall...">dimension_tot</a>(0));

  <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; b = b_p.at(<span class="stringliteral">&quot;alpha&quot;</span>);
  <span class="keywordflow">for</span> (i = 0; i &lt; na; i++) <span class="keywordflow">if</span> (calc[i]) <span class="keywordflow">for</span> (secmem(i) = 1, m = 0; m &lt; M; m++)
        secmem(i) -= b(i, m) + inco_a(i, m);
}
</pre></div>
</div>
</div>
<a class="anchor" id="aeae28bb29ca0bc249687f64a88a18096"></a><!-- doxytag: member="SETS::cree_instance" ref="aeae28bb29ca0bc249687f64a88a18096" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classObjet__U.html">Objet_U</a> * SETS::cree_instance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="classSimpler.html#a02209fa096a9be0355d45b85b9d7a518">Simpler</a>.</p>

<p>Reimplemented in <a class="el" href="classICE.html#aff9cd77459de20a0b35c10e875eb6879">ICE</a>.</p>

<p>Definition at line <a class="el" href="SETS_8cpp_source.html#l00057">57</a> of file <a class="el" href="SETS_8cpp_source.html">SETS.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a43d8d8c22a759700d864566aaeb00658"></a><!-- doxytag: member="SETS::duplique" ref="a43d8d8c22a759700d864566aaeb00658" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SETS::duplique </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="classSimpler.html#a4c8f24a885835014b697969cd6038ed5">Simpler</a>.</p>

<p>Reimplemented in <a class="el" href="classICE.html#a9a4aa71a09d9c2ad2d79d54520d25237">ICE</a>.</p>

<p>Definition at line <a class="el" href="SETS_8cpp_source.html#l00057">57</a> of file <a class="el" href="SETS_8cpp_source.html">SETS.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa487da54eb9fd9c46cad4c7960c32344"></a><!-- doxytag: member="SETS::eliminer" ref="aa487da54eb9fd9c46cad4c7960c32344" args="(const std::vector&lt; std::set&lt; std::pair&lt; std::string, int &gt;&gt;&gt; ordre, const std::string inco_p, const std::map&lt; std::string, matrices_t &gt; &amp;mats, const tabs_t &amp;sec, std::map&lt; std::string, Matrice_Morse &gt; &amp;A_p, tabs_t &amp;b_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SETS::eliminer </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::set&lt; std::pair&lt; std::string, int &gt;&gt;&gt;&#160;</td>
          <td class="paramname"><em>ordre</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>inco_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, <a class="el" href="Interface__blocs_8h.html#a68e4f5c4505f6b31305de844302660bb">matrices_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>mats</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="Interface__blocs_8h.html#a2d7480bf11fc9f791b1d2839fa30a5c3">tabs_t</a> &amp;&#160;</td>
          <td class="paramname"><em>sec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; std::string, <a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>A_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="Interface__blocs_8h.html#a2d7480bf11fc9f791b1d2839fa30a5c3">tabs_t</a> &amp;&#160;</td>
          <td class="paramname"><em>b_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="SETS_8cpp_source.html#l00331">331</a> of file <a class="el" href="SETS_8cpp_source.html">SETS.cpp</a>.</p>

<p>References <a class="el" href="EntreeSortie_8h_source.html#l00032">Cerr</a>, <a class="el" href="Process_8cpp_source.html#l00223">Process::exit()</a>, <a class="el" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>, <a class="el" href="Matrice__Morse_8h_source.html#l00134">Matrice_Morse::get_tab1()</a>, <a class="el" href="Matrice__Morse_8h_source.html#l00138">Matrice_Morse::get_tab2()</a>, <a class="el" href="ConstDoubleTab__parts_8h_source.html#l00043">ConstDoubleTab_parts::size()</a>, and <a class="el" href="ArrOfInt_8h_source.html#l00342">ArrOfInt::size_array()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">int</span> i, j, jb, k, l, lb, m, oMl, oMg, M, n, oNl, oNg, N, prems = !<a class="code" href="classSETS.html#a53cd8850df0e00210aa6c4cea0e978cd">A_p</a>.size(), infoo = 0; <span class="comment">//si A_p est vide, premier passage -&gt; on doit dimensionner</span>
  <span class="keyword">const</span> <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a> * A;
  <span class="keywordtype">char</span> trans = <span class="charliteral">&#39;T&#39;</span>;

  <span class="comment">/* decoupage des inconnues de sec en parties par DoubleTab_parts */</span>
  std::map&lt;std::pair&lt;std::string, int&gt;, <span class="keywordtype">int</span>&gt; offs; <span class="comment">//offs[{inco, bloc}] : offset du bloc k de l&#39;inconnue inco</span>
  std::map&lt;std::pair&lt;std::string, int&gt;, std::array&lt;int, 2&gt;&gt; dims; <span class="comment">//dims[{inco, bloc}] : dimension 0/ line_size() du bloc k de inco</span>
  <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;&amp;n_v : sec)
    {
      <a class="code" href="classConstDoubleTab__parts.html" title="This class allows to acces to individual sub-parts of const DoubleTab objects that have a MD_Vector_c...">ConstDoubleTab_parts</a> part(n_v.second);
      <span class="keywordflow">for</span> (i = 0; i &lt; part.size(); i++)
        {
          offs[ {n_v.first, i}] = offs.count({ n_v.first, i - 1 }) ? offs[ { n_v.first, i - 1 }] + dims[ { n_v.first, i - 1 }][0] * dims[ { n_v.first, i - 1 }][1] : 0;
          dims[ {n_v.first, i}] = { part[i].dimension_tot(0), part[i].line_size() };
        }
    }

  <span class="comment">/* boucle sur les blocs */</span>
  std::set&lt;std::pair&lt;std::string, int&gt;&gt; e_ib; <span class="comment">//liste des { variable, bloc } deja elimines</span>
  std::set&lt;std::string&gt; e_i; <span class="comment">//liste des variables deja eliminees</span>
  <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;&amp;bloc : ordre)
    {
      std::set&lt;std::string&gt; i_bloc, dep; <span class="comment">//variables du bloc, variables deja eliminees dont le bloc depend</span>
      <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;&amp;i_b : bloc) i_bloc.insert(i_b.first);
      <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;&amp;i_b : bloc) <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;&amp; v_m : <a class="code" href="classSETS.html#aa1512e2ef91bb2c9ab5968a69b54600a" title="matrices : mats[nom de l&#39;inconnue de l&#39;equation][nom de l&#39;autre inconnue] = matrice">mats</a>.at(i_b.first)) <span class="keywordflow">if</span> (v_m.second-&gt;nb_colonnes() &amp;&amp; v_m.first != inco_p &amp;&amp; e_i.count(v_m.first) &amp;&amp; !i_bloc.count(v_m.first))
            dep.insert(v_m.first);

      <span class="comment">/* lignes du bloc a traiter */</span>
      std::pair&lt;std::string, int&gt; i_b0 = *bloc.begin();<span class="comment">//premiere inconnue du bloc</span>
      <a class="code" href="classIntTrav.html" title="Tableau de travail a n entrees pour n&lt;= 4 C&#39;est un IntTab avec allocation dans un pool de memoire gere...">IntTrav</a> calc(dims[i_b0][0]); <span class="comment">//calc[i] = 1 si on doit traiter l&#39;item i</span>
      <span class="keywordflow">for</span> (A = <a class="code" href="classSETS.html#aa1512e2ef91bb2c9ab5968a69b54600a" title="matrices : mats[nom de l&#39;inconnue de l&#39;equation][nom de l&#39;autre inconnue] = matrice">mats</a>.at(i_b0.first).at(i_b0.first), oMg = offs[i_b0], M = dims[i_b0][1], i = 0; i &lt; calc.size_array(); i++)
        <span class="keywordflow">if</span> (A-&gt;<a class="code" href="classMatrice__Morse.html#a79b4e334152850bd36e53478debf3061">get_tab1</a>()(oMg + M * i + 1) &gt; A-&gt;<a class="code" href="classMatrice__Morse.html#a79b4e334152850bd36e53478debf3061">get_tab1</a>()(oMg + M * i)) calc(i) = 1; <span class="comment">//on traite toutes les lignes dont la matrice est remplie</span>

      <span class="keywordflow">if</span> (prems) <span class="comment">//premier passage -&gt; dimensionnement des A_p</span>
        {
          <span class="comment">/* verification de la compatibilite des inconnues du bloc -&gt; avec les MD_Vector renseignes dans sec */</span>
          <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;&amp;i_b : bloc) <span class="keywordflow">if</span> (dims[i_b0][0] != dims[i_b][0])
              <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;SETS::eliminer() : discretisation des inconnues&quot;</span> &lt;&lt; i_b0.first.c_str() &lt;&lt; <span class="stringliteral">&quot;/&quot;</span> &lt;&lt; i_b0.second &lt;&lt; <span class="stringliteral">&quot; et &quot;</span> &lt;&lt; i_b.first.c_str()
                   &lt;&lt; <span class="stringliteral">&quot;/&quot;</span> &lt;&lt; i_b.second &lt;&lt; <span class="stringliteral">&quot; incompatibles!&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>, <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">Process::exit</a>();

          std::vector&lt;std::set&lt;int&gt;&gt; stencil(calc.size_array()); <span class="comment">//stencil[i] -&gt; stencil de l&#39;item i (a demultiplier par le line_size() de chaque variable)</span>
          <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;&amp;i_b : bloc) <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;&amp;v_m : <a class="code" href="classSETS.html#aa1512e2ef91bb2c9ab5968a69b54600a" title="matrices : mats[nom de l&#39;inconnue de l&#39;equation][nom de l&#39;autre inconnue] = matrice">mats</a>.at(i_b.first)) <span class="keywordflow">if</span> (v_m.second-&gt;nb_colonnes())
                {
                  oMg = offs[i_b], M = dims[i_b][1];
                  <span class="keywordflow">if</span> (v_m.first == inco_p) <span class="comment">//dependance directe en inco_p</span>
                    {
                      <span class="keywordflow">for</span> (i = 0; i &lt; calc.size_array(); i++) <span class="keywordflow">if</span> (calc[i])
                          <span class="keywordflow">for</span> (j = v_m.second-&gt;get_tab1()(oMg + M * i) - 1; j &lt; v_m.second-&gt;get_tab1()(oMg + M * (i + 1)) - 1; j++) <span class="comment">//dependances de toutes les lignes</span>
                            stencil[i].insert(v_m.second-&gt;get_tab2()(j) - 1);
                    }
                  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (e_i.count(v_m.first) || i_bloc.count(v_m.first)) <span class="comment">//dependance en une variable partiellement / totalement eliminee</span>
                    {
                      A = <a class="code" href="classSETS.html#a53cd8850df0e00210aa6c4cea0e978cd">A_p</a>.count(v_m.first) ? &amp;<a class="code" href="classSETS.html#a53cd8850df0e00210aa6c4cea0e978cd">A_p</a>.at(v_m.first) : NULL;
                      <span class="keywordflow">for</span> (i = 0; i &lt; calc.size_array(); i++) <span class="keywordflow">if</span> (calc[i])
                          <span class="keywordflow">for</span> (j = v_m.second-&gt;get_tab1()(oMg + M * i) - 1; j &lt; v_m.second-&gt;get_tab1()(oMg + M * (i + 1)) - 1; j++)
                            {
                              <span class="keywordflow">for</span> (jb = v_m.second-&gt;get_tab2()(j) - 1, k = 0; offs.count({ v_m.first, k + 1}) &amp;&amp; jb &gt;= offs.at({ v_m.first, k + 1 }); ) k++; <span class="comment">//l : bloc de l&#39;inconnue dont on depend</span>
                              oNg = offs[ { v_m.first, k }], N = dims[ { v_m.first, k }][1], n = jb - oNg - N * i;
                              <span class="keywordflow">if</span> (bloc.count({ v_m.first, k }) &amp;&amp; n &gt;= 0 &amp;&amp; n &lt; N) <span class="keywordflow">continue</span>; <span class="comment">//(variable, bloc) en cours d&#39;elimination et coeff bloc-diagonal -&gt; ok</span>
                              <span class="keywordflow">else</span> <span class="keywordflow">if</span> (e_ib.count({ v_m.first, k }))  <span class="comment">//(variable, bloc) elimine -&gt; dependance en inco_p dans A_p</span>
                                <span class="keywordflow">for</span> (l = A-&gt;<a class="code" href="classMatrice__Morse.html#a79b4e334152850bd36e53478debf3061">get_tab1</a>()(jb) - 1; l &lt; A-&gt;<a class="code" href="classMatrice__Morse.html#a79b4e334152850bd36e53478debf3061">get_tab1</a>()(jb + 1) - 1; l++)
                                  stencil[i].insert(A-&gt;<a class="code" href="classMatrice__Morse.html#a787b5a63f27063f9c891243d8f188cda">get_tab2</a>()(l) - 1);
                              <span class="keywordflow">else</span> <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;SETS::eliminer() : dependance ( &quot;</span> &lt;&lt; i_b.first.c_str() &lt;&lt; <span class="stringliteral">&quot;/&quot;</span> &lt;&lt; i_b.second &lt;&lt; <span class="stringliteral">&quot; , &quot;</span>
                                          &lt;&lt; v_m.first.c_str() &lt;&lt; <span class="stringliteral">&quot;/&quot;</span> &lt;&lt; k &lt;&lt; <span class="stringliteral">&quot; ) interdite!&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>, <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">Process::exit</a>();
                            }
                    }
                  <span class="keywordflow">else</span> <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;SETS::eliminer() : dependance ( &quot;</span> &lt;&lt; i_b.first.c_str() &lt;&lt; <span class="stringliteral">&quot;/&quot;</span> &lt;&lt; i_b.second &lt;&lt; <span class="stringliteral">&quot; , &quot;</span>
                              &lt;&lt; v_m.first.c_str() &lt;&lt; <span class="stringliteral">&quot; ) interdite!&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>, <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">Process::exit</a>();
                }

          <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;&amp;i_bl : bloc) <span class="comment">//stencil par inconnue -&gt; en demultipliant</span>
            {
              <a class="code" href="classIntTrav.html" title="Tableau de travail a n entrees pour n&lt;= 4 C&#39;est un IntTab avec allocation dans un pool de memoire gere...">IntTrav</a> sten(0, 2);
              sten.set_smart_resize(1);
              <span class="keywordflow">for</span> (oMg = offs[i_bl], M = dims[i_bl][1], i = 0; i &lt; calc.size_array(); i++) <span class="keywordflow">if</span> (calc[i])
                  <span class="keywordflow">for</span> (m = 0; m &lt; M; m++) <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;&amp;col : stencil[i]) sten.append_line(oMg + M * i + m, col);
              <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a> mat2;
              <a class="code" href="classMatrix__tools.html#a481961691c1dbee5372da25777e5c1e8">Matrix_tools::allocate_morse_matrix</a>(sec.at(i_bl.first).size_totale(), sec.at(inco_p).size_totale(), sten, mat2);
              <a class="code" href="classSETS.html#a53cd8850df0e00210aa6c4cea0e978cd">A_p</a>[i_bl.first].nb_colonnes() ? <a class="code" href="classSETS.html#a53cd8850df0e00210aa6c4cea0e978cd">A_p</a>[i_bl.first] += mat2 : <a class="code" href="classSETS.html#a53cd8850df0e00210aa6c4cea0e978cd">A_p</a>[i_bl.first] = mat2; <span class="comment">//A_p peut deja etre partiellement creee</span>
            }
        }

      std::vector&lt;std::string&gt; vbloc(i_bloc.begin(), i_bloc.end()), vdep(dep.begin(), dep.end()); <span class="comment">//sous forme de liste</span>
      <span class="keywordtype">int</span> nv = vbloc.size(), nd = vdep.size(), nb = 0; <span class="comment">//nombre de variables du bloc, de dependances, taille totale</span>
      std::vector&lt;int&gt; size, off_l, off_g; <span class="comment">//par (variable, bloc) : taille dans le systeme local, offset dans le systeme local, offset dans les systemes globaux</span>
      <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;&amp; i_b : bloc) off_l.push_back(nb), size.push_back(dims[i_b][1]), off_g.push_back(offs[i_b]), nb += size.back();

      std::vector&lt;const Matrice_Morse *&gt; pmat(nv), dAp(nd); <span class="comment">//par variable : dependance directe en inco_p, des variables du bloc / deja resolues</span>
      std::vector&lt;std::vector&lt;const Matrice_Morse *&gt;&gt; mat(nv), dmat(nv); <span class="comment">//matrices des variables du bloc, des dependances</span>
      std::vector&lt;const DoubleTab*&gt; vsec(nv), dbp(nd); <span class="comment">//seconds membres des variables, vecteurs b_p des variables / des dependances</span>

      std::vector&lt;Matrice_Morse *&gt; Ap(nv); <span class="comment">//resultats : d{inco} = A_p[inco].d{inco_p} + b_p[inco] pour les variables du bloc</span>
      std::vector&lt;DoubleTab*&gt; bp(nv);

      <span class="keywordflow">for</span> (i = 0; i &lt; nv; i++)
        {
          Ap[i] = &amp;<a class="code" href="classSETS.html#a53cd8850df0e00210aa6c4cea0e978cd">A_p</a>[vbloc[i]], vsec[i] = &amp;sec.at(vbloc[i]);
          <span class="keywordflow">if</span> (!b_p.count(vbloc[i])) b_p[vbloc[i]] = *vsec[i]; <span class="comment">//creation des b_p</span>
          bp[i] = &amp;b_p[vbloc[i]];
          <span class="keyword">const</span> <a class="code" href="Interface__blocs_8h.html#a68e4f5c4505f6b31305de844302660bb">matrices_t</a>&amp; line = <a class="code" href="classSETS.html#aa1512e2ef91bb2c9ab5968a69b54600a" title="matrices : mats[nom de l&#39;inconnue de l&#39;equation][nom de l&#39;autre inconnue] = matrice">mats</a>.at(vbloc[i]);
          pmat[i] = line.count(inco_p) &amp;&amp; line.at(inco_p)-&gt;nb_colonnes() ? line.at(inco_p) : NULL;
          <span class="keywordflow">for</span> ( mat[i].resize(nv), j = 0; j &lt; nv; j++)  mat[i][j] = line.count(vbloc[j]) &amp;&amp; line.at(vbloc[j])-&gt;nb_colonnes() ? line.at(vbloc[j]) : NULL;
          <span class="keywordflow">for</span> (dmat[i].resize(nd), j = 0; j &lt; nd; j++) dmat[i][j] = line.count(vdep[j]) &amp;&amp; line.at(vdep[j])-&gt;nb_colonnes() ? line.at(vdep[j]) : NULL;
        }
      <span class="keywordflow">for</span> (i = 0; i &lt; nd; i++) dbp[i] = &amp;b_p.at(vdep[i]), dAp[i] = &amp;<a class="code" href="classSETS.html#a53cd8850df0e00210aa6c4cea0e978cd">A_p</a>.at(vdep[i]); <span class="comment">//b_p / A_p des dependances</span>

      <a class="code" href="classDoubleTrav.html" title="Tableau de travail a n entrees pour n&lt;= 4 C&#39;est un DoubleTab avec allocation dans un pool de memoire g...">DoubleTrav</a> D(nb, nb), S; <span class="comment">//bloc diagonal, seconds membres</span>
      S.<a class="code" href="classArrOfDouble.html#ab49f6cae96be9d3f597468d8a53b67b6" title="Change le mode l&#39;allocation memoire: reallocation d&#39;un tableau a chaque changement de taille (flag = ...">set_smart_resize</a>(1);
      <a class="code" href="classIntTrav.html" title="Tableau de travail a n entrees pour n&lt;= 4 C&#39;est un IntTab avec allocation dans un pool de memoire gere...">IntTrav</a> piv(nb);
      <span class="keywordflow">for</span> (i = 0; i &lt; calc.size_array(); i++) <span class="keywordflow">if</span> (calc[i])
          {
            <span class="keyword">const</span> <span class="keywordtype">int</span> *deb = Ap[0]-&gt;get_tab2().addr() + Ap[0]-&gt;get_tab1()(off_g[0] + size[0] * i) - 1,
                       *fin = Ap[0]-&gt;get_tab2().addr() + Ap[0]-&gt;get_tab1()(off_g[0] + size[0] * i + 1) - 1,
                        ic = fin - deb, nc = ic + 1;
            S.<a class="code" href="classDoubleTab.html#ae83b4d31205c53d9c8d2b43da178ce75" title="Change la taille du vecteur (identique a resize_array() pour le traitement des anciennes valeurs et d...">resize</a>(nc, nb), S = 0; <span class="comment">//second membre : 5(i, .) -&gt; dependance en la i-eme colonne du stencil des Ap du bloc, S(ic, .) -&gt; partie constante</span>
<span class="comment">// partie &quot;second membre des equations&quot;</span>
            <span class="keywordflow">for</span> (j = 0; j &lt; nv; j++) <span class="keywordflow">for</span> (M = size[j], oMg = off_g[j], oMl = off_l[j], m = 0; m &lt; M; m++) S(ic, oMl + m) = vsec[j]-&gt;<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>()[oMg + M * i + m];

            <span class="comment">/* remplissage par les matrices du bloc : diagonale, second membre (si partie d&#39;une variable deja eliminee) */</span>
            <span class="keywordflow">for</span> (D = 0, j = 0; j &lt; nv; j++) <span class="keywordflow">for</span> (M = size[j], oMg = off_g[j], oMl = off_l[j], k = 0; k &lt; nv; k++) <span class="keywordflow">if</span> (mat[j][k])
                  {
                    <span class="keywordflow">for</span> (N = size[k], oNg = off_g[k], oNl = off_l[k], m = 0; m &lt; M; m++) <span class="keywordflow">for</span> (l = mat[j][k]-&gt;get_tab1()(oMg + M * i + m) - 1; l &lt; mat[j][k]-&gt;get_tab1()(oMg + M * i + m + 1) - 1; l++)
                        <span class="keywordflow">if</span> ((n = (jb = mat[j][k]-&gt;get_tab2()(l) - 1) - oNg - N * i) &gt;= 0 &amp;&amp; n &lt; N) <span class="comment">//on est dans le bloc diagonal</span>
                          D(oMl + m, oNl + n) = mat[j][k]-&gt;get_coeff()(l);
                        <span class="keywordflow">else</span> <span class="comment">//dependance en un bloc deja elimine</span>
                          {
                            <span class="keywordtype">double</span> <a class="code" href="Champ__P1iP1B__implementation_8cpp.html#aa8c8f49390c3cf7c702d71a71bc977e3">coeff</a> = mat[j][k]-&gt;get_coeff()(l);
                            S(ic, oMl + m) -= coeff * bp[k]-&gt;<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>()[jb];
                            <span class="keywordflow">for</span> (lb = Ap[k]-&gt;get_tab1()(jb) - 1; lb &lt; Ap[k]-&gt;get_tab1()(jb + 1) - 1; lb++)
                              S(std::lower_bound(deb, fin, Ap[k]-&gt;get_tab2()(lb)) - deb, oMl + m) -= coeff * Ap[k]-&gt;get_coeff()(lb);
                          }
                  }

<span class="comment">// partie &quot;dependance directe en inco_p&quot; -&gt; dans S([0, ic[, .)</span>
            <span class="keywordflow">for</span> (j = 0; j &lt; nv; j++) <span class="keywordflow">if</span> (pmat[j]) <span class="keywordflow">for</span> (M = size[j], oMg = off_g[j], oMl = off_l[j], m = 0; m &lt; M; m++)
                  <span class="keywordflow">for</span> (k = pmat[j]-&gt;get_tab1()(oMg + M * i + m) - 1; k &lt; pmat[j]-&gt;get_tab1()(oMg + M * i + m + 1) - 1; k++)
                    S(std::lower_bound(deb, fin, pmat[j]-&gt;get_tab2()(k)) - deb, oMl + m) -= pmat[j]-&gt;get_coeff()(k);
<span class="comment">// partie &quot;dependance en une variable hors bloc eliminee&quot; -&gt; b_p contribue a S(0, .), A_p contribue a S(1..nc, .)</span>
            <span class="keywordflow">for</span> (j = 0; j &lt; nv; j++) <span class="keywordflow">for</span> (k = 0; k &lt; nd; k++) <span class="keywordflow">if</span> (dmat[j][k]) <span class="keywordflow">for</span> (M = size[j], oMg = off_g[j], oMl = off_l[j], m = 0; m &lt; M; m++)
                    <span class="keywordflow">for</span> (l = dmat[j][k]-&gt;get_tab1()(oMg + M * i + m) - 1; l &lt; dmat[j][k]-&gt;get_tab1()(oMg + M * i + m + 1) - 1; l++)
                      {
                        <span class="keywordtype">double</span> coeff = dmat[j][k]-&gt;get_coeff()(l);
                        jb = dmat[j][k]-&gt;get_tab2()(l) - 1, S(ic, oMl + m) -= coeff * dbp[k]-&gt;<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>()[jb]; <span class="comment">//partie &quot;constante&quot;</span>
                        <span class="keywordflow">for</span> (lb = dAp[k]-&gt;get_tab1()(jb) - 1; lb &lt; dAp[k]-&gt;get_tab1()(jb + 1) - 1; lb++) <span class="comment">//partie &quot;dependance en inco_p&quot;</span>
                          S(std::lower_bound(deb, fin, dAp[k]-&gt;get_tab2()(lb)) - deb, oMl + m) -= coeff * dAp[k]-&gt;get_coeff()(lb);
                      }

            <span class="comment">/* factorisation et resolution */</span>
            <a class="code" href="classDoubleTrav.html" title="Tableau de travail a n entrees pour n&lt;= 4 C&#39;est un DoubleTab avec allocation dans un pool de memoire g...">DoubleTrav</a> D_back = D;
            <a class="code" href="arch_8h.html#a9b91c72ded7de2f0b393ea75de53929b">F77NAME</a>(dgetrf)(&amp;nb, &amp;nb, &amp;D(0, 0), &amp;nb, &amp;piv(0), &amp;infoo);
            <a class="code" href="arch_8h.html#a9b91c72ded7de2f0b393ea75de53929b">F77NAME</a>(dgetrs)(&amp;trans, &amp;nb, &amp;nc, &amp;D(0, 0), &amp;nb, &amp;piv(0), &amp;S(0, 0), &amp;nb, &amp;infoo);

            <span class="comment">/* stockage : S(0, .) dans b_p, S(1..nc, .) dans A_p */</span>
            <span class="keywordflow">for</span> (j = 0; j &lt; nv; j++) <span class="keywordflow">for</span> (M = size[j], oMg = off_g[j], oMl = off_l[j], m = 0; m &lt; M; m++)
                <span class="keywordflow">for</span> (bp[j]-&gt;addr()[oMg + M * i + m] = S(ic, oMl + m), k = 0, l = Ap[j]-&gt;get_tab1()(oMg + M * i + m) - 1; k &lt; ic; k++, l++)
                  Ap[j]-&gt;get_set_coeff()(l) = S(k, oMl + m);
          }

      <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;&amp;i_b : bloc) e_ib.insert(i_b), e_i.insert(i_b.first);
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a8f33aa634420d49c9ecdaa1f5ea140c8"></a><!-- doxytag: member="SETS::get_default_growth_factor" ref="a8f33aa634420d49c9ecdaa1f5ea140c8" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual double SETS::get_default_growth_factor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="classSolveur__Implicite__Base.html#ab985ae562930472ef685e2afe4128bcb">Solveur_Implicite_Base</a>.</p>

<p>Definition at line <a class="el" href="SETS_8h_source.html#l00084">84</a> of file <a class="el" href="SETS_8h_source.html">SETS.h</a>.</p>
<div class="fragment"><pre class="fragment">  {
    <span class="keywordflow">return</span> 1.2; <span class="comment">/* en cas de pas de temps rate, on remonte doucement */</span>
  }
</pre></div>
</div>
</div>
<a class="anchor" id="aa3fb3b8fd11f67f72a7e93c80d969768"></a><!-- doxytag: member="SETS::get_info" ref="aa3fb3b8fd11f67f72a7e93c80d969768" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classType__info.html">Type_info</a> * SETS::get_info </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Donne des informations sur le type de l'Objet_U. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>const Type_info*<br/>
 Signification: structure regroupant les informations sur le type de l'Objet_U<br/>
 Contraintes: </dd></dl>

<p>Reimplemented from <a class="el" href="classSimpler.html#a78f4835a9ed9db265d6502fa7f59b2f3">Simpler</a>.</p>

<p>Reimplemented in <a class="el" href="classICE.html#ae2542b5374df9a5cfd866d63f2654a16">ICE</a>.</p>

<p>Definition at line <a class="el" href="SETS_8cpp_source.html#l00057">57</a> of file <a class="el" href="SETS_8cpp_source.html">SETS.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3a246bc2fc57303b38f9fc8af863a15a"></a><!-- doxytag: member="SETS::info" ref="a3a246bc2fc57303b38f9fc8af863a15a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classType__info.html">Type_info</a> * SETS::info </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Donne des informations sur le type de l'Objet_U. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>const Type_info*<br/>
 Signification: structure regroupant les informations sur le type de l'Objet_U<br/>
 Contraintes: </dd></dl>

<p>Reimplemented from <a class="el" href="classSimpler.html#a657e4026343ae55532ef338a0bfb95d4">Simpler</a>.</p>

<p>Reimplemented in <a class="el" href="classICE.html#ac9b0326bfc9f17ca0324c44689c30298">ICE</a>.</p>

<p>Definition at line <a class="el" href="SETS_8cpp_source.html#l00057">57</a> of file <a class="el" href="SETS_8cpp_source.html">SETS.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9836d357794031783bf88ed0c6c3efcf"></a><!-- doxytag: member="SETS::iterer_eqn" ref="a9836d357794031783bf88ed0c6c3efcf" args="(Equation_base &amp;equation, const DoubleTab &amp;inconnue, DoubleTab &amp;result, double dt, int numero_iteration, int &amp;ok)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SETS::iterer_eqn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEquation__base.html">Equation_base</a> &amp;&#160;</td>
          <td class="paramname"><em>equation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>inconnue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numero_iteration</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>ok</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="classSimple.html#af657f8c2501bc6840ef151022cf70299">Simple</a>.</p>

<p>Definition at line <a class="el" href="SETS_8cpp_source.html#l00133">133</a> of file <a class="el" href="SETS_8cpp_source.html">SETS.cpp</a>.</p>

<p>References <a class="el" href="classEquation__base.html#a5ba7300a466493c7b41b739688d23887">Equation_base::dimensionner_blocs()</a>, <a class="el" href="MorEqn_8h_source.html#l00082">MorEqn::equation()</a>, <a class="el" href="Process_8cpp_source.html#l00223">Process::exit()</a>, <a class="el" href="Nom_8h_source.html#l00092">Nom::getString()</a>, <a class="el" href="classEquation__base.html#a5a1fce9487b9a8dd17020914100c2c89">Equation_base::inconnue()</a>, <a class="el" href="SETS_8cpp_source.html#l00181">iterer_NS()</a>, <a class="el" href="classOperateur.html#a1f3e24efd9b54d05821e731fe4bd6027">Operateur::l_op_base()</a>, <a class="el" href="O__U__Ptr_8cpp_source.html#l00179">O_U_Ptr::le_nom()</a>, <a class="el" href="Probleme__base_8h_source.html#l00295">Probleme_base::le_nom()</a>, <a class="el" href="SETS_8h_source.html#l00104">mat_pred</a>, <a class="el" href="Operateur__Diff__base_8h_source.html#l00054">Operateur_Diff_base::op_ext</a>, <a class="el" href="classEquation__base.html#a8406eaa10e61a27e9a2e1cacea253c3e">Equation_base::operateur()</a>, <a class="el" href="Equation__base_8cpp_source.html#l00964">Equation_base::probleme()</a>, <a class="el" href="Objet__U_8cpp_source.html#l00132">Objet_U::que_suis_je()</a>, <a class="el" href="Cast_8h_source.html#l00059">ref_cast</a>, <a class="el" href="SETS_8h_source.html#l00091">sets_</a>, and <a class="el" href="Cast_8h_source.html#l00054">sub_type</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">int</span> cv;
  <span class="comment">/* on ne traite que Pb_Multiphase ou Pb_conduction */</span>
  <span class="keywordflow">if</span> (!<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classPb__Multiphase.html" title="classe Pb_Multiphase Cette classe represente un probleme de thermohydraulique multiphase de type &quot;3*...">Pb_Multiphase</a>, eqn.probleme()) &amp;&amp; !<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classPb__Conduction.html" title="Classe Pb_Conduction Cette classe represente un probleme de conduction avec rho et Cp non uniformes :...">Pb_Conduction</a>, eqn.probleme()))
    <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">Process::exit</a>(<a class="code" href="classObjet__U.html#aa58e9a81c0ddc2c1149053b8f96698ac" title="renvoie la chaine identifiant la classe.">que_suis_je</a>() + <span class="stringliteral">&quot; cannot be applied to the problem &quot;</span> + eqn.probleme().<a class="code" href="classNom.html#a4fcffbaa80271df0d9674f2a2751efb9" title="Renvoie *this;.">le_nom</a>() + <span class="stringliteral">&quot; of type &quot;</span> + eqn.probleme().<a class="code" href="classObjet__U.html#aa58e9a81c0ddc2c1149053b8f96698ac" title="renvoie la chaine identifiant la classe.">que_suis_je</a>() + <span class="stringliteral">&quot;!&quot;</span>);

  <span class="comment">/* equations non resolues directement : Masse_Multiphase (toujours), Energie_Multiphase (en ICE) */</span>
  <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classMasse__Multiphase.html" title="classe Masse_Multiphase Cas particulier de Convection_Diffusion_std pour un fluide quasi conpressible...">Masse_Multiphase</a>, eqn) || (!<a class="code" href="classSETS.html#a037404a748a911b2e260905354a6c7f2" title="1 si on fait l&#39;etape de prediction des vitesses">sets_</a> &amp;&amp; <a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classEnergie__Multiphase.html" title="classe Energie_Multiphase Cas particulier de Convection_Diffusion_std pour un fluide quasi conpressib...">Energie_Multiphase</a>, eqn)))
    <span class="keywordflow">return</span> <span class="keyword">true</span>;

  <span class="comment">/* QDM_Multiphase: resolue par iterer_NS */</span>
  <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classQDM__Multiphase.html" title="classe QDM_Multiphase Cette classe porte les termes de l&#39;equation de la dynamique pour un fluide sans...">QDM_Multiphase</a>, eqn))
    {
      <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a> matrix_unused;
      <a class="code" href="classDoubleTrav.html" title="Tableau de travail a n entrees pour n&lt;= 4 C&#39;est un DoubleTab avec allocation dans un pool de memoire g...">DoubleTrav</a> secmem_unused;
      <a class="code" href="classSETS.html#a0f22d8191523bca38ac875ca7e810cf0">iterer_NS</a>(eqn, current, <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classQDM__Multiphase.html" title="classe QDM_Multiphase Cette classe porte les termes de l&#39;equation de la dynamique pour un fluide sans...">QDM_Multiphase</a>, eqn).pression().valeurs(), dt, matrix_unused, 0, secmem_unused, numero_iteration, cv, ok);
      <span class="keywordflow">return</span> cv;
    }

  <span class="comment">/* cas restant : equation thermique d&#39;un Pb_Multi ou d&#39;un Pb_conduction -&gt; on regle semi_impl si necessaire, puis on resout */</span>
  <span class="keyword">const</span> std::string&amp; nom_inco = eqn.inconnue().le_nom().getString();
  <a class="code" href="Interface__blocs_8h.html#a2d7480bf11fc9f791b1d2839fa30a5c3">tabs_t</a> semi_impl; <span class="comment">/* en ICE, les temperatures de tous les problemes sont explicites */</span>
  <span class="keyword">const</span> <a class="code" href="classOperateur__Diff__base.html" title="classe Operateur_Diff_base Cette classe est la base de la hierarchie des operateurs representant un t...">Operateur_Diff_base</a>&amp; op_diff = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classOperateur__Diff__base.html" title="classe Operateur_Diff_base Cette classe est la base de la hierarchie des operateurs representant un t...">Operateur_Diff_base</a>, eqn.operateur(0).l_op_base());
  <span class="keywordflow">if</span> (!<a class="code" href="classSETS.html#a037404a748a911b2e260905354a6c7f2" title="1 si on fait l&#39;etape de prediction des vitesses">sets_</a>) <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;&amp;op_ext : op_diff.<a class="code" href="classOperateur__Diff__base.html#a55bd9b2fad5e6ef816f89ea07371ddfc">op_ext</a>)
      semi_impl[nom_inco + (op_ext != &amp;op_diff ? <span class="stringliteral">&quot;_&quot;</span> + op_ext-&gt;<a class="code" href="classMorEqn.html#a615dd9abff96edcb625fa0424a489864" title="Renvoie la reference sur l&#39;equation pointe par MorEqn::mon_equation. (version const)">equation</a>().<a class="code" href="classEquation__base.html#aa8151a96f63719523bf50ddd832e0f8f" title="Renvoie le probleme associe a l&#39;equation.">probleme</a>().<a class="code" href="classProbleme__base.html#a58bc0b101f3f3f1d8522a9f41f1fad7b" title="surcharge Objet_U::le_nom() Renvoie le nom du probleme">le_nom</a>().<a class="code" href="classNom.html#a855d8cd96b5c73c2aa55cb7c0a870640">getString</a>() : <span class="stringliteral">&quot;&quot;</span>)] = op_ext-&gt;equation().inconnue().passe();

  <span class="keywordflow">if</span> (!<a class="code" href="classSETS.html#aa96e420735d53c9033c0031f4a02a379">mat_pred</a>.count(nom_inco)) <span class="comment">/* matrice : dimensionnement au premier passage */</span>
    eqn.dimensionner_blocs({{ nom_inco, &amp;<a class="code" href="classSETS.html#aa96e420735d53c9033c0031f4a02a379">mat_pred</a>[nom_inco]}}, semi_impl);

  <span class="comment">/* assemblage et resolution */</span>
  <a class="code" href="classDoubleTrav.html" title="Tableau de travail a n entrees pour n&lt;= 4 C&#39;est un DoubleTab avec allocation dans un pool de memoire g...">DoubleTrav</a> secmem(current);
  <a class="code" href="classSolveurSys.html">SolveurSys</a>&amp; solv = <a class="code" href="classSimpler__Base.html#a41cac35ea9df69f70075c3df820b96a3" title="retourne le parametre_implicte de l&#39;equation si il existe si il n&#39;existe pas le cree... si les params sont vides on copie ceux du simpler">get_and_set_parametre_implicite</a>(eqn).<a class="code" href="classParametre__implicite.html#a7e65b5960b6f41da7e586134f3462666">solveur</a>();
  eqn.assembler_blocs_avec_inertie({{ nom_inco, &amp;<a class="code" href="classSETS.html#aa96e420735d53c9033c0031f4a02a379">mat_pred</a>[nom_inco] }}, secmem, semi_impl);
  <a class="code" href="classSETS.html#aa96e420735d53c9033c0031f4a02a379">mat_pred</a>[nom_inco].ajouter_multvect(current, secmem); <span class="comment">//passage increment -&gt; variable</span>
  solv.<a class="code" href="classDeriv__SolveurSys__base.html#aa1f67fc10fc25960d05d484a67d1bb54">valeur</a>().<a class="code" href="classSolveurSys__base.html#a8737bd7292204c64e4b7bfe4c7bd88ef">reinit</a>();
  solv.<a class="code" href="classSolveurSys.html#a62ca198f0c5dc599e53b0535761e5138">resoudre_systeme</a>(<a class="code" href="classSETS.html#aa96e420735d53c9033c0031f4a02a379">mat_pred</a>[nom_inco], secmem, current);

  <span class="comment">/* mise a jour */</span>
  eqn.probleme().mettre_a_jour(eqn.schema_temps().temps_courant());
  eqn.inconnue().futur() = current;
  <span class="keywordflow">return</span> <span class="keyword">true</span>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a0f22d8191523bca38ac875ca7e810cf0"></a><!-- doxytag: member="SETS::iterer_NS" ref="a0f22d8191523bca38ac875ca7e810cf0" args="(Equation_base &amp;, DoubleTab &amp;current, DoubleTab &amp;pression, double, Matrice_Morse &amp;, double, DoubleTrav &amp;, int nb_iter, int &amp;converge, int &amp;ok)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SETS::iterer_NS </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEquation__base.html">Equation_base</a> &amp;&#160;</td>
          <td class="paramname"><em>eqn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>current</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>pression</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;&#160;</td>
          <td class="paramname"><em>matrice_unused</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>seuil_resol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDoubleTrav.html">DoubleTrav</a> &amp;&#160;</td>
          <td class="paramname"><em>secmem_unused</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nb_iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>converge</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>ok</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>&lt; On prend la pression minimale comme pression de reference afin d'avoir la meme pression de reference en sequentiel et parallele </p>
</p>

<p>Reimplemented from <a class="el" href="classSimpler.html#ae0048feb0d5e33700bd38626740fdbbf">Simpler</a>.</p>

<p>Definition at line <a class="el" href="SETS_8cpp_source.html#l00181">181</a> of file <a class="el" href="SETS_8cpp_source.html">SETS.cpp</a>.</p>

<p>References <a class="el" href="Op__Conv__EF__Stab__CoviMAC__Elem_8cpp_source.html#l00147">QDM_Multiphase::dimensionner_blocs()</a>, <a class="el" href="Pb__Multiphase_8h_source.html#l00093">Pb_Multiphase::eq_energie</a>, <a class="el" href="Pb__Multiphase_8h_source.html#l00094">Pb_Multiphase::eq_masse</a>, <a class="el" href="Pb__Multiphase_8h_source.html#l00092">Pb_Multiphase::eq_qdm</a>, <a class="el" href="SETS_8h_source.html#l00096">first_call_</a>, <a class="el" href="Nom_8h_source.html#l00092">Nom::getString()</a>, <a class="el" href="classEquation__base.html#a5a1fce9487b9a8dd17020914100c2c89">Equation_base::inconnue()</a>, <a class="el" href="SETS_8h_source.html#l00089">iteration</a>, <a class="el" href="O__U__Ptr_8cpp_source.html#l00179">O_U_Ptr::le_nom()</a>, <a class="el" href="SETS_8h_source.html#l00104">mat_pred</a>, <a class="el" href="Pb__Multiphase_8cpp_source.html#l00266">Pb_Multiphase::mettre_a_jour()</a>, <a class="el" href="Navier__Stokes__std_8h_source.html#l00268">Navier_Stokes_std::pression()</a>, <a class="el" href="Equation__base_8cpp_source.html#l00964">Equation_base::probleme()</a>, <a class="el" href="Cast_8h_source.html#l00059">ref_cast</a>, <a class="el" href="Equation__base_8cpp_source.html#l01120">Equation_base::schema_temps()</a>, <a class="el" href="SETS_8h_source.html#l00091">sets_</a>, <a class="el" href="Schema__Temps__base_8h_source.html#l00676">Schema_Temps_base::temps_courant()</a>, and <a class="el" href="Champ__Inc_8h_source.html#l00043">Deriv_Champ_Inc_base::valeur()</a>.</p>

<p>Referenced by <a class="el" href="SETS_8cpp_source.html#l00133">iterer_eqn()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">int</span> i, j, &amp;it = <a class="code" href="classSETS.html#a73c4e579bc537898da0bc707ac19fb3a">iteration</a>;
  <a class="code" href="classPb__Multiphase.html" title="classe Pb_Multiphase Cette classe represente un probleme de thermohydraulique multiphase de type &quot;3*...">Pb_Multiphase</a>&amp; pb = *(<a class="code" href="classPb__Multiphase.html" title="classe Pb_Multiphase Cette classe represente un probleme de thermohydraulique multiphase de type &quot;3*...">Pb_Multiphase</a> *) &amp;<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classPb__Multiphase.html" title="classe Pb_Multiphase Cette classe represente un probleme de thermohydraulique multiphase de type &quot;3*...">Pb_Multiphase</a>, eqn.<a class="code" href="classEquation__base.html#aa8151a96f63719523bf50ddd832e0f8f" title="Renvoie le probleme associe a l&#39;equation.">probleme</a>());
  <a class="code" href="classQDM__Multiphase.html" title="classe QDM_Multiphase Cette classe porte les termes de l&#39;equation de la dynamique pour un fluide sans...">QDM_Multiphase</a>&amp; eq_qdm = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classQDM__Multiphase.html" title="classe QDM_Multiphase Cette classe porte les termes de l&#39;equation de la dynamique pour un fluide sans...">QDM_Multiphase</a>, eqn);
  <span class="keywordtype">double</span> t = eqn.<a class="code" href="classEquation__base.html#abc11e51aa75b4c7aa55c27f71eb2f2c4" title="Renvoie le schema en temps associe a l&#39;equation.">schema_temps</a>().<a class="code" href="classSchema__Temps__base.html#a5054df01edb6d4f7baec7e612d423834" title="Renvoie le temps courant.">temps_courant</a>();

  <a class="code" href="classEquation__base.html">Equation_base</a> *eq_list[3] = { &amp;pb.<a class="code" href="classPb__Multiphase.html#affb5ae03eb9e469afd34b084cda27d95">eq_masse</a>, &amp;pb.<a class="code" href="classPb__Multiphase.html#a43dfdb9dff5fc80ed2d4adfc71e562bf">eq_energie</a>, &amp;eq_qdm }; <span class="comment">//ordre des 3 equations</span>
  std::map&lt;std::string, Equation_base *&gt; eqs; <span class="comment">//eqs[inconnue] = equation</span>
  std::vector&lt;std::string&gt; noms; <span class="comment">//ordre des inconnues : le meme que les equations, puis la pression</span>
  <span class="keywordflow">for</span> (i = 0; i &lt; 3; i++) noms.push_back(eq_list[i]-&gt;<a class="code" href="classEquation__base.html#a5a1fce9487b9a8dd17020914100c2c89">inconnue</a>().<a class="code" href="classO__U__Ptr.html#a5aae0c48048a40339f3847aa14109231" title="Renvoie ref_().le_nom() si le pointeur est non nul ou &quot;Pointeur Nul&quot;.">le_nom</a>().<a class="code" href="classNom.html#a855d8cd96b5c73c2aa55cb7c0a870640">getString</a>()), eqs[noms[i]] = eq_list[i];
  noms.push_back(<span class="stringliteral">&quot;pression&quot;</span>); <span class="comment">//pas d&#39;equation associee a la pression!</span>

  std::map&lt;std::string, Champ_Inc_base *&gt; inco; <span class="comment">//tous les Champ_Inc</span>
  <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;n_eq : eqs) inco[n_eq.first] = &amp;n_eq.second-&gt;<a class="code" href="classEquation__base.html#a5a1fce9487b9a8dd17020914100c2c89">inconnue</a>().<a class="code" href="classDeriv__Champ__Inc__base.html#a9e0b743a3e124e7114fa977b36b68225">valeur</a>();
  inco[<span class="stringliteral">&quot;pression&quot;</span>] = &amp;eq_qdm.<a class="code" href="classNavier__Stokes__std.html#afbb8f39bdfd70328dfad21bf2b9dd45a" title="Renvoie le champ de pression.">pression</a>().<a class="code" href="classDeriv__Champ__Inc__base.html#a9e0b743a3e124e7114fa977b36b68225">valeur</a>();
<span class="comment">// initialisation du Newton avec les valeurs presentes (stockees dans passe() en implicite), dimensionnement de incr / sec</span>
  pb.<a class="code" href="classPb__Multiphase.html#a33f18892177ebe6a32d41821b6752a35" title="Effectue une mise a jour en temps du probleme. Effectue la mise a jour sur toutes les equations du pr...">mettre_a_jour</a>(t); <span class="comment">//inconnues -&gt; milieu -&gt; champs conserves</span>

  <span class="comment">/* valeurs semi-implicites : inconnues (alpha, v, T) et champs conserves (alpha_rho, alpha_rho_e) */</span>
  <a class="code" href="Interface__blocs_8h.html#a2d7480bf11fc9f791b1d2839fa30a5c3">tabs_t</a> semi_impl;
  <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;&amp;n_eq : eqs) <span class="keywordflow">if</span> (n_eq.second != &amp;eq_qdm)
      {
        semi_impl[n_eq.first] = n_eq.second-&gt;inconnue().passe();
        semi_impl[n_eq.second-&gt;champ_conserve().le_nom().getString()] = n_eq.second-&gt;champ_conserve().passe();
        semi_impl[n_eq.second-&gt;champ_convecte().le_nom().getString()]  =n_eq.second-&gt;champ_convecte().passe();
      }
<span class="comment">// en SETS, on remplace la valeur passee de v par celle donnee par une etape de prediction</span>
  <span class="keywordflow">if</span> (<a class="code" href="classSETS.html#a037404a748a911b2e260905354a6c7f2" title="1 si on fait l&#39;etape de prediction des vitesses">sets_</a> &amp;&amp; !<a class="code" href="classSETS.html#abc7f91897922f8e62d9b9a181ff35f51">first_call_</a>)
    {
      <a class="code" href="classDoubleTrav.html" title="Tableau de travail a n entrees pour n&lt;= 4 C&#39;est un DoubleTab avec allocation dans un pool de memoire g...">DoubleTrav</a> secmem(current);
      <span class="comment">/* assemblage &quot;implicite, vitesses seulement&quot; */</span>
      <span class="keywordflow">if</span> (!<a class="code" href="classSETS.html#aa96e420735d53c9033c0031f4a02a379">mat_pred</a>.count(<span class="stringliteral">&quot;vitesse&quot;</span>)) eq_qdm.<a class="code" href="classQDM__Multiphase.html#a7485eb5c2efca9dca5b1385e99cd2c4a">dimensionner_blocs</a>({{<span class="stringliteral">&quot;vitesse&quot;</span>, &amp;<a class="code" href="classSETS.html#aa96e420735d53c9033c0031f4a02a379">mat_pred</a>[<span class="stringliteral">&quot;vitesse&quot;</span>] }}); <span class="comment">//premier passage : dimensionnement</span>
      eq_qdm.<a class="code" href="classQDM__Multiphase.html#adb75954515312e1b1afb90b7e86e3696">assembler_blocs_avec_inertie</a>({{<span class="stringliteral">&quot;vitesse&quot;</span>, &amp;<a class="code" href="classSETS.html#aa96e420735d53c9033c0031f4a02a379">mat_pred</a>[<span class="stringliteral">&quot;vitesse&quot;</span>] }}, secmem);

      <span class="comment">/* resolution et stockage de la vitesse pedite dans current */</span>
      <a class="code" href="classSolveurSys.html">SolveurSys</a>&amp; solv_qdm = <a class="code" href="classSimpler__Base.html#a41cac35ea9df69f70075c3df820b96a3" title="retourne le parametre_implicte de l&#39;equation si il existe si il n&#39;existe pas le cree... si les params sont vides on copie ceux du simpler">get_and_set_parametre_implicite</a>(eqn).<a class="code" href="classParametre__implicite.html#a7e65b5960b6f41da7e586134f3462666">solveur</a>();
      solv_qdm.<a class="code" href="classDeriv__SolveurSys__base.html#aa1f67fc10fc25960d05d484a67d1bb54">valeur</a>().<a class="code" href="classSolveurSys__base.html#a8737bd7292204c64e4b7bfe4c7bd88ef">reinit</a>();
      <a class="code" href="classSETS.html#aa96e420735d53c9033c0031f4a02a379">mat_pred</a>[<span class="stringliteral">&quot;vitesse&quot;</span>].ajouter_multvect(current, secmem); <span class="comment">//passage increment -&gt; variable pour faire plaisir aux solveurs iteratifs</span>
      solv_qdm.<a class="code" href="classSolveurSys.html#a62ca198f0c5dc599e53b0535761e5138">resoudre_systeme</a>(<a class="code" href="classSETS.html#aa96e420735d53c9033c0031f4a02a379">mat_pred</a>[<span class="stringliteral">&quot;vitesse&quot;</span>], secmem, current);
      semi_impl[<span class="stringliteral">&quot;vitesse&quot;</span>] = current;
    }
  <span class="keywordflow">else</span> semi_impl[<span class="stringliteral">&quot;vitesse&quot;</span>] = eq_qdm.<a class="code" href="classNavier__Stokes__std.html#a743b777e6185faee7837326844c8fca1" title="Renvoie la vitesse (champ inconnue de l&#39;equation) (version const)">inconnue</a>().<a class="code" href="classChamp__Inc.html#ad4e16720f4575dceb8536c9f09635a3c" title="Appel a l&#39;objet sous-jacent Renvoie le tableau des valeurs au temps t-i.">passe</a>();
  eqn.<a class="code" href="classEquation__base.html#adfedf474c07a92f6b2261ca2f1cee80e" title="Renvoie le solveur de masse associe a l&#39;equation.">solv_masse</a>().<a class="code" href="classSolveur__Masse.html#a328dc53fbe227ba188eaf55cd98474b8">corriger_solution</a>(current, current, 0); <span class="comment">//pour CoviMAC : vf -&gt; ve</span>

  <a class="code" href="classSETS.html#abc7f91897922f8e62d9b9a181ff35f51">first_call_</a> = 0;

<span class="comment">// premier passage : dimensionnement de mat_semi_impl, remplissage de p_degen_</span>
  <span class="keywordflow">if</span> (!<a class="code" href="classSETS.html#a8ee91bd4406997e979f5157a55749010">mat_semi_impl</a>.<a class="code" href="classMatrice__Bloc.html#aa282a8298b08603722d97704cf98c8cc">nb_lignes</a>())
    {
      <a class="code" href="classSETS.html#a8ee91bd4406997e979f5157a55749010">mat_semi_impl</a>.<a class="code" href="classMatrice__Bloc.html#a1db7c549cc1be958d5f00c29cd0f3a8c">dimensionner</a>(3, 4);
      <span class="keywordflow">for</span> (i = 0; i &lt; 3; i++) <span class="keywordflow">for</span> (j = 0; j &lt; 4; j++)
          <a class="code" href="classSETS.html#a8ee91bd4406997e979f5157a55749010">mat_semi_impl</a>.<a class="code" href="classMatrice__Bloc.html#a7ffa38f7b93454432b2df7c616ed0a4e">get_bloc</a>(i, j).<a class="code" href="classDeriv__.html#ad1d33400ed15b6ff96579ed82d9e2719" title="Essaie de creer une instance du type &quot;type&quot;. si type n&#39;est pas un type ou type n&#39;est pas instanciab...">typer</a>(<span class="stringliteral">&quot;Matrice_Morse&quot;</span>), <a class="code" href="classSETS.html#aa1512e2ef91bb2c9ab5968a69b54600a" title="matrices : mats[nom de l&#39;inconnue de l&#39;equation][nom de l&#39;autre inconnue] = matrice">mats</a>[noms[i]][noms[j]] = &amp;<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>, <a class="code" href="classSETS.html#a8ee91bd4406997e979f5157a55749010">mat_semi_impl</a>.<a class="code" href="classMatrice__Bloc.html#a7ffa38f7b93454432b2df7c616ed0a4e">get_bloc</a>(i, j).<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>());
      <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;&amp;n_eq : eqs) n_eq.second-&gt;dimensionner_blocs(<a class="code" href="classSETS.html#aa1512e2ef91bb2c9ab5968a69b54600a" title="matrices : mats[nom de l&#39;inconnue de l&#39;equation][nom de l&#39;autre inconnue] = matrice">mats</a>[n_eq.first], semi_impl); <span class="comment">//option semi-implicite</span>

      <span class="comment">/* si incompressible sans CLs de pression imposee, alors la pression est degeneree */</span>
      <a class="code" href="classSETS.html#a3ac3e326835cd7b7e65512befd351443">p_degen</a> = <a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classFluide__base.html" title="classe Fluide_base Cette classe represente un d&#39;un fluide incompressible ainsi que ses proprietes: - ...">Fluide_base</a>, eq_qdm.<a class="code" href="classNavier__Stokes__std.html#a442d8f1138c18da07aa895728b3e41f2" title="Renvoie le milieu physique de l&#39;equation (le Fluide_base upcaste en Milieu_base)">milieu</a>());
      <span class="keywordflow">for</span> (i = 0; i &lt; eq_qdm.<a class="code" href="classEquation__base.html#af265fe0ea30868eb2176a0c887e4efab" title="Renvoie la zone des conditions aux limite discretisee associee a l&#39;equation.">zone_Cl_dis</a>().<a class="code" href="classZone__Cl__dis.html#a7e0c9938057e7d427eea4954dd7bad58" title="Appel a l&#39;objet sous-jacent Renvoie le nombre de conditions aux limites.">nb_cond_lim</a>(); i++)
        <a class="code" href="classSETS.html#a3ac3e326835cd7b7e65512befd351443">p_degen</a> &amp;= !<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classNeumann__val__ext.html" title="Classe Neumann_val_ext Cette classe est la classe de base de la hierarchie des conditions aux limites...">Neumann_val_ext</a>, eq_qdm.<a class="code" href="classEquation__base.html#af265fe0ea30868eb2176a0c887e4efab" title="Renvoie la zone des conditions aux limite discretisee associee a l&#39;equation.">zone_Cl_dis</a>().<a class="code" href="classZone__Cl__dis.html#aafbd0525703e23200e31796bcd4fcac6" title="Appel a l&#39;objet sous-jacent Renvoie la i-ieme condition aux limites. (version const)">les_conditions_limites</a>(i).<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>());
    }



  <span class="comment">/* Newton : assemblage de mat_semi_impl -&gt; assemblage de la matrice en pression -&gt; resolution -&gt; substitution */</span>
  <a class="code" href="Interface__blocs_8h.html#a2d7480bf11fc9f791b1d2839fa30a5c3">tabs_t</a> incr, sec; <span class="comment">//increments / seconds membres associes</span>
  <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;&amp;n_i : inco) incr[n_i.first] = sec[n_i.first] = n_i.second-&gt;valeurs();

  <span class="keywordflow">if</span> (!<a class="code" href="classProcess.html#ab55ba07167ec807ed3a145cac0f5dca4" title="renvoie mon rang dans le groupe de communication courant. Voir Comm_Group::rank() et PE_Groups::curre...">Process::me</a>())
    {
      fprintf(stderr, <span class="stringliteral">&quot;Increments for semi-implicit method :\n  it&quot;</span>);
      <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;&amp;n_i : inco) fprintf(stderr, <span class="stringliteral">&quot; %11s&quot;</span>, n_i.first.c_str());
      fprintf(stderr, <span class="stringliteral">&quot;\n&quot;</span>);
    }

  <span class="keywordflow">for</span> (it = 0, cv = 0; it &lt; <a class="code" href="classSETS.html#a416660a4c6b560c16a63ef41bc99383f">iter_min_</a> || (!cv &amp;&amp; it &lt; <a class="code" href="classSETS.html#acf75db99aa6f39fb02552f774ac26d17">iter_max_</a>); it++)
    {
      <span class="comment">/* remplissage par assembler_blocs */</span>
      <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;&amp;n_eq : eqs) n_eq.second-&gt;assembler_blocs_avec_inertie(<a class="code" href="classSETS.html#aa1512e2ef91bb2c9ab5968a69b54600a" title="matrices : mats[nom de l&#39;inconnue de l&#39;equation][nom de l&#39;autre inconnue] = matrice">mats</a>[n_eq.first], sec[n_eq.first], semi_impl);

      <span class="comment">/* expression des autres inconnues (x) en fonction de p : vitesse, puis temperature / pression */</span>
      <a class="code" href="Interface__blocs_8h.html#a2d7480bf11fc9f791b1d2839fa30a5c3">tabs_t</a> b_p;
      <a class="code" href="classSETS.html#aa487da54eb9fd9c46cad4c7960c32344">eliminer</a>({{{ <span class="stringliteral">&quot;vitesse&quot;</span>, 1 }}, {{ <span class="stringliteral">&quot;vitesse&quot;</span>, 0 }}, {{ <span class="stringliteral">&quot;alpha&quot;</span>, 0 }, {<span class="stringliteral">&quot;temperature&quot;</span>, 0 }}}, <span class="stringliteral">&quot;pression&quot;</span>, <a class="code" href="classSETS.html#aa1512e2ef91bb2c9ab5968a69b54600a" title="matrices : mats[nom de l&#39;inconnue de l&#39;equation][nom de l&#39;autre inconnue] = matrice">mats</a>, sec, <a class="code" href="classSETS.html#a53cd8850df0e00210aa6c4cea0e978cd">A_p</a>, b_p);

      <span class="comment">/* assemblage du systeme en pression */</span>
      <a class="code" href="classDoubleTrav.html" title="Tableau de travail a n entrees pour n&lt;= 4 C&#39;est un DoubleTab avec allocation dans un pool de memoire g...">DoubleTrav</a> secmem_pression;
      <a class="code" href="classSETS.html#a6c7635065c4d8501c1048a2af972ae59">assembler</a>(<span class="stringliteral">&quot;pression&quot;</span>, {}, <a class="code" href="classSETS.html#a53cd8850df0e00210aa6c4cea0e978cd">A_p</a>, b_p, <a class="code" href="classSETS.html#aa1512e2ef91bb2c9ab5968a69b54600a" title="matrices : mats[nom de l&#39;inconnue de l&#39;equation][nom de l&#39;autre inconnue] = matrice">mats</a>, sec, inco[<span class="stringliteral">&quot;alpha&quot;</span>]-&gt;valeurs(), <a class="code" href="classSETS.html#a344f98c5dfa364bc5e9c9c04ef7800ee">matrice_pression</a>, secmem_pression, <a class="code" href="classSETS.html#a3ac3e326835cd7b7e65512befd351443">p_degen</a>);

      <span class="comment">/* resolution : seulement si l&#39;erreur en alpha (dans secmem_pression) depasse un seuil */</span>
      <span class="keywordflow">if</span> (<a class="code" href="DoubleVect_8cpp.html#acb21ec8c0b3909c26b20e3f3455e0289">mp_max_abs_vect</a>(secmem_pression) &gt; 1e-16)
        {
          <a class="code" href="classSETS.html#a344f98c5dfa364bc5e9c9c04ef7800ee">matrice_pression</a>.<a class="code" href="classMatrice__Base.html#a6ccb4d20d3877cf09f5178ff72af5406" title="Operation de multiplication-accumulation (saxpy) matrice vecteur. Operation: r = r + A*x...">ajouter_multvect</a>(inco[<span class="stringliteral">&quot;pression&quot;</span>]-&gt;valeurs(), secmem_pression); <span class="comment">//passage increment -&gt; variable pour faire plaisir aux solveurs iteratifs</span>
          <a class="code" href="classSolveurSys.html">SolveurSys</a>&amp; solv_p = eq_qdm.<a class="code" href="classNavier__Stokes__std.html#ae83d9f7a42531293583f32be1efd3d5f" title="Renvoie le solveur en pression&lt;br&gt;(version const)">solveur_pression</a>();
          solv_p.<a class="code" href="classDeriv__SolveurSys__base.html#aa1f67fc10fc25960d05d484a67d1bb54">valeur</a>().<a class="code" href="classSolveurSys__base.html#a8737bd7292204c64e4b7bfe4c7bd88ef">reinit</a>(), solv_p.<a class="code" href="classDeriv__SolveurSys__base.html#aa1f67fc10fc25960d05d484a67d1bb54">valeur</a>().<a class="code" href="classSolveurSys__base.html#a27067468cf159dc2e08c693ac7432685">set_return_on_error</a>(1); <span class="comment">/* pour eviter un exit() en cas d&#39;echec */</span>
          ok = (solv_p.<a class="code" href="classSolveurSys.html#a62ca198f0c5dc599e53b0535761e5138">resoudre_systeme</a>(<a class="code" href="classSETS.html#a344f98c5dfa364bc5e9c9c04ef7800ee">matrice_pression</a>, secmem_pression, incr[<span class="stringliteral">&quot;pression&quot;</span>]) &gt;= 0);
          <span class="keywordflow">if</span> (!ok) <span class="keywordflow">break</span>; <span class="comment">//le solveur a echoue -&gt; on sort</span>
          incr[<span class="stringliteral">&quot;pression&quot;</span>] -= inco[<span class="stringliteral">&quot;pression&quot;</span>]-&gt;valeurs();
        }
      <span class="keywordflow">else</span> incr[<span class="stringliteral">&quot;pression&quot;</span>] = 0;

<span class="comment">// increments des autres variables</span>
      <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;&amp;n_v : b_p)
        {
          incr[n_v.first] = n_v.second; <span class="comment">//partie constante</span>
          A_p[n_v.first].ajouter_multvect(incr[<span class="stringliteral">&quot;pression&quot;</span>], incr[n_v.first]); <span class="comment">//dependance en les increments de pression</span>
          incr[n_v.first].echange_espace_virtuel();
        }
      eqn.<a class="code" href="classEquation__base.html#adfedf474c07a92f6b2261ca2f1cee80e" title="Renvoie le solveur de masse associe a l&#39;equation.">solv_masse</a>().<a class="code" href="classSolveur__Masse.html#a328dc53fbe227ba188eaf55cd98474b8">corriger_solution</a>(incr[<span class="stringliteral">&quot;vitesse&quot;</span>], incr[<span class="stringliteral">&quot;vitesse&quot;</span>], 1); <span class="comment">//pour CoviMAC : sert a corriger ve</span>

      <span class="comment">/* convergence? */</span>
      cv = (<a class="code" href="SETS_8cpp.html#a5065e01b298005c425e8495ed7344c66">corriger_incr_alpha</a>(inco[<span class="stringliteral">&quot;alpha&quot;</span>]-&gt;valeurs(), incr[<span class="stringliteral">&quot;alpha&quot;</span>]) &lt; <a class="code" href="classSETS.html#a2dc023a4074725a2d139135afb6859cf">crit_conv</a>[<span class="stringliteral">&quot;alpha&quot;</span>]);
      <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;&amp; n_v : incr) cv &amp;= (<a class="code" href="DoubleVect_8cpp.html#acb21ec8c0b3909c26b20e3f3455e0289">mp_max_abs_vect</a>(n_v.second) &lt; <a class="code" href="classSETS.html#a2dc023a4074725a2d139135afb6859cf">crit_conv</a>.at(n_v.first));

      <span class="keywordflow">if</span> (!<a class="code" href="classProcess.html#ab55ba07167ec807ed3a145cac0f5dca4" title="renvoie mon rang dans le groupe de communication courant. Voir Comm_Group::rank() et PE_Groups::curre...">Process::me</a>())
#ifndef INT_is_64_
        fprintf(stderr, <span class="stringliteral">&quot;%4d&quot;</span>, it + 1);
<span class="preprocessor">#else</span>
<span class="preprocessor"></span>        fprintf(stderr, <span class="stringliteral">&quot;%4ld&quot;</span>, it + 1);
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>      <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;&amp;n_v : incr)
        {
          <span class="keywordtype">double</span> vm = <a class="code" href="DoubleVect_8cpp.html#a55e600bcf8a03e258531f83869c4d060">mp_min_vect</a>(n_v.second), vM = <a class="code" href="DoubleVect_8cpp.html#adcc29a107bd1ad77828da317da293203">mp_max_vect</a>(n_v.second), x = <a class="code" href="Double_8h.html#aaecd4ca8a2fe69cc6568af2938b94d2e">dabs</a>(vM) &gt; <a class="code" href="Double_8h.html#aaecd4ca8a2fe69cc6568af2938b94d2e">dabs</a>(vm) ? vM : vm;
          <span class="keywordflow">if</span> (!<a class="code" href="classProcess.html#ab55ba07167ec807ed3a145cac0f5dca4" title="renvoie mon rang dans le groupe de communication courant. Voir Comm_Group::rank() et PE_Groups::curre...">Process::me</a>()) fprintf(stderr, <span class="stringliteral">&quot; %11g&quot;</span>, x);
        }
      <span class="keywordflow">if</span> (!<a class="code" href="classProcess.html#ab55ba07167ec807ed3a145cac0f5dca4" title="renvoie mon rang dans le groupe de communication courant. Voir Comm_Group::rank() et PE_Groups::curre...">Process::me</a>()) fprintf(stderr, <span class="stringliteral">&quot;\n&quot;</span>);

      <span class="comment">/* mises a jour : inconnues -&gt; milieu -&gt; champs/conserves -&gt; sources */</span>
      <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;&amp; n_i : inco) n_i.second-&gt;valeurs() += incr[n_i.first];
      <span class="keywordflow">if</span> (<a class="code" href="classSETS.html#a3ac3e326835cd7b7e65512befd351443">p_degen</a>) inco[<span class="stringliteral">&quot;pression&quot;</span>]-&gt;valeurs() -= <a class="code" href="DoubleVect_8cpp.html#a55e600bcf8a03e258531f83869c4d060">mp_min_vect</a>(inco[<span class="stringliteral">&quot;pression&quot;</span>]-&gt;valeurs()); <span class="comment">//!&lt; On prend la pression minimale comme pression de reference afin d&#39;avoir la meme pression de reference en sequentiel et parallele</span>
<span class="comment"></span>      <span class="keywordflow">if</span> (!(ok = eq_qdm.<a class="code" href="classNavier__Stokes__std.html#a442d8f1138c18da07aa895728b3e41f2" title="Renvoie le milieu physique de l&#39;equation (le Fluide_base upcaste en Milieu_base)">milieu</a>().<a class="code" href="classMilieu__base.html#aaa77cfc752de073808514e1b99770e9b">check_unknown_range</a>())) <span class="keywordflow">break</span>; <span class="comment">//si on a depasse les bornes du milieu sur (p, T), on doit sortir</span>
      eq_qdm.<a class="code" href="classNavier__Stokes__std.html#a2233a18979d8e301c9d376d8639877ee">pression_pa</a>().<a class="code" href="classChamp__Inc.html#a28ef3d411d12cb5684ac5e799efb7d24" title="Appel a l&#39;objet sous-jacent Renvoie le tableau des valeurs au temps courant.">valeurs</a>() = inco[<span class="stringliteral">&quot;pression&quot;</span>]-&gt;valeurs(); <span class="comment">//en multiphase, la pression est deja en Pa</span>
      pb.<a class="code" href="classPb__Multiphase.html#a33f18892177ebe6a32d41821b6752a35" title="Effectue une mise a jour en temps du probleme. Effectue la mise a jour sur toutes les equations du pr...">mettre_a_jour</a>(t); <span class="comment">//inconnues -&gt; milieu -&gt; champs conserves</span>
    }

<span class="comment">// ha ha ha</span>
  <span class="keywordflow">if</span> (ok &amp;&amp; cv)
    {
      pb.<a class="code" href="classPb__Multiphase.html#a33f18892177ebe6a32d41821b6752a35" title="Effectue une mise a jour en temps du probleme. Effectue la mise a jour sur toutes les equations du pr...">mettre_a_jour</a>(t); <span class="comment">//inconnues -&gt; milieu -&gt; champs conserves</span>
      <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;&amp; n_i : inco) n_i.second-&gt;futur() = n_i.second-&gt;valeurs();
      eq_qdm.<a class="code" href="classNavier__Stokes__std.html#afbb8f39bdfd70328dfad21bf2b9dd45a" title="Renvoie le champ de pression.">pression</a>().<a class="code" href="classChamp__Inc.html#a518c3eb1e7a249ae0fc4d1a4e0d072d0" title="Appel a l&#39;objet sous-jacent Renvoie le tableau des valeurs au temps t+i.">futur</a>() = eq_qdm.<a class="code" href="classNavier__Stokes__std.html#afbb8f39bdfd70328dfad21bf2b9dd45a" title="Renvoie le champ de pression.">pression</a>().<a class="code" href="classChamp__Inc.html#a28ef3d411d12cb5684ac5e799efb7d24" title="Appel a l&#39;objet sous-jacent Renvoie le tableau des valeurs au temps courant.">valeurs</a>(), eq_qdm.<a class="code" href="classNavier__Stokes__std.html#a2233a18979d8e301c9d376d8639877ee">pression_pa</a>().<a class="code" href="classChamp__Inc.html#a518c3eb1e7a249ae0fc4d1a4e0d072d0" title="Appel a l&#39;objet sous-jacent Renvoie le tableau des valeurs au temps t+i.">futur</a>() = eq_qdm.<a class="code" href="classNavier__Stokes__std.html#a2233a18979d8e301c9d376d8639877ee">pression_pa</a>().<a class="code" href="classChamp__Inc.html#a28ef3d411d12cb5684ac5e799efb7d24" title="Appel a l&#39;objet sous-jacent Renvoie le tableau des valeurs au temps courant.">valeurs</a>();
    }
  <span class="keywordflow">else</span>
    {
      <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;&amp; n_i : inco)  n_i.second-&gt;futur() = n_i.second-&gt;valeurs() = n_i.second-&gt;passe();
      eq_qdm.<a class="code" href="classNavier__Stokes__std.html#a2233a18979d8e301c9d376d8639877ee">pression_pa</a>().<a class="code" href="classChamp__Inc.html#a518c3eb1e7a249ae0fc4d1a4e0d072d0" title="Appel a l&#39;objet sous-jacent Renvoie le tableau des valeurs au temps t+i.">futur</a>() = eq_qdm.<a class="code" href="classNavier__Stokes__std.html#a2233a18979d8e301c9d376d8639877ee">pression_pa</a>().<a class="code" href="classChamp__Inc.html#a28ef3d411d12cb5684ac5e799efb7d24" title="Appel a l&#39;objet sous-jacent Renvoie le tableau des valeurs au temps courant.">valeurs</a>() = inco[<span class="stringliteral">&quot;pression&quot;</span>]-&gt;passe();
      ok = 0;
    }
  <span class="keywordflow">return</span>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a496bf32c88bdc0db99d03e6f925229a0"></a><!-- doxytag: member="SETS::lire" ref="a496bf32c88bdc0db99d03e6f925229a0" args="(const Motcle &amp;, Entree &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEntree.html">Entree</a> &amp; SETS::lire </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMotcle.html">Motcle</a> &amp;&#160;</td>
          <td class="paramname"><em>mot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEntree.html">Entree</a> &amp;&#160;</td>
          <td class="paramname"><em>is</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="classSimple.html#af918c48d83767d5d76f720036bea5837">Simple</a>.</p>

<p>Definition at line <a class="el" href="SETS_8cpp_source.html#l00085">85</a> of file <a class="el" href="SETS_8cpp_source.html">SETS.cpp</a>.</p>

<p>References <a class="el" href="EntreeSortie_8h_source.html#l00032">Cerr</a>, <a class="el" href="SETS_8h_source.html#l00099">crit_conv</a>, <a class="el" href="Process_8cpp_source.html#l00223">Process::exit()</a>, <a class="el" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>, <a class="el" href="SETS_8h_source.html#l00095">iter_max_</a>, <a class="el" href="SETS_8h_source.html#l00095">iter_min_</a>, and <a class="el" href="Probleme__U_8h_source.html#l00100">Probleme_U::nom</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">if</span> (mot == <a class="code" href="classMotcle.html" title="Une chaine de caractere (Nom) en majuscules.">Motcle</a>(<span class="stringliteral">&quot;criteres_convergence&quot;</span>))
    {
      <a class="code" href="classNom.html" title="class Nom Une chaine de caractere pour nommer les objets de TRUST">Nom</a> nom;
      is &gt;&gt; nom;
      <span class="keywordflow">if</span> (nom != <span class="stringliteral">&quot;{&quot;</span>) <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;SETS::lire() : { expected instead of &quot;</span> &lt;&lt; nom &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>, <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">Process::exit</a>();
      <span class="keywordflow">for</span> (is &gt;&gt; nom; nom != <span class="stringliteral">&quot;}&quot;</span>; is &gt;&gt; nom)
        {
          <span class="keywordtype">double</span> val;
          is &gt;&gt; val;
          <a class="code" href="classSETS.html#a2dc023a4074725a2d139135afb6859cf">crit_conv</a>[nom.getString()] = val;
        }
    }
  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (mot == <span class="stringliteral">&quot;iter_min&quot;</span>) is &gt;&gt; <a class="code" href="classSETS.html#a416660a4c6b560c16a63ef41bc99383f">iter_min_</a>;
  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (mot == <span class="stringliteral">&quot;iter_max&quot;</span>) is &gt;&gt; <a class="code" href="classSETS.html#acf75db99aa6f39fb02552f774ac26d17">iter_max_</a>;
  <span class="keywordflow">else</span> <span class="keywordflow">return</span> <a class="code" href="classSETS.html#a496bf32c88bdc0db99d03e6f925229a0">Simpler::lire</a>(mot, is); <span class="comment">//la classe mere connait-elle ce mot cle?</span>
  <span class="keywordflow">return</span> is;
}
</pre></div>
</div>
</div>
<a class="anchor" id="aec401e12dff95162238c27ca913f0507"></a><!-- doxytag: member="SETS::nb_valeurs_temporelles_pression" ref="aec401e12dff95162238c27ca913f0507" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int SETS::nb_valeurs_temporelles_pression </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="classSolveur__Implicite__Base.html#a3a0ac7b322a4e2424eddc2a1a2d4b9b3">Solveur_Implicite_Base</a>.</p>

<p>Definition at line <a class="el" href="SETS_8h_source.html#l00046">46</a> of file <a class="el" href="SETS_8h_source.html">SETS.h</a>.</p>
<div class="fragment"><pre class="fragment">  {
    <span class="keywordflow">return</span> 3; <span class="comment">/* autant que les autres variables */</span>
  }
</pre></div>
</div>
</div>
<a class="anchor" id="a2ad086699b67f2c4be9b94b886abadc9"></a><!-- doxytag: member="SETS::printOn" ref="a2ad086699b67f2c4be9b94b886abadc9" args="(Sortie &amp;x) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSortie.html">Sortie</a> &amp; SETS::printOn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSortie.html">Sortie</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td> const<code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Ecriture de l'objet sur un flot de sortie<br/>
Methode a surcharger. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="classSortie.html" title="Classe de base des flux de sortie. Elle sait ecrire des types simples&lt;br&gt;(entiers, flottants) et des Ob...">Sortie</a>&amp;<br/>
 Signification: flot de sortie modifie<br/>
 Contraintes: </dd></dl>

<p>Reimplemented from <a class="el" href="classSimpler.html#a64a69011a71bb6d106fb73e8b57ad2ec">Simpler</a>.</p>

<p>Reimplemented in <a class="el" href="classICE.html#a6874576e991f661c0c68afb9493f7995">ICE</a>.</p>

<p>Definition at line <a class="el" href="SETS_8cpp_source.html#l00071">71</a> of file <a class="el" href="SETS_8cpp_source.html">SETS.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">return</span> <a class="code" href="classSETS.html#a2ad086699b67f2c4be9b94b886abadc9" title="Ecriture de l&#39;objet sur un flot de sortie Methode a surcharger.">Simpler::printOn</a>(os);
}
</pre></div>
</div>
</div>
<a class="anchor" id="a12e94bf4ecd4e24b8bd838c78df8004e"></a><!-- doxytag: member="SETS::readOn" ref="a12e94bf4ecd4e24b8bd838c78df8004e" args="(Entree &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEntree.html">Entree</a> &amp; SETS::readOn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEntree.html">Entree</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Lecture d'un <a class="el" href="classObjet__U.html" title="classe Objet_U Cette classe est la classe de base des Objets de TRUST Dans les classes derivees de Ob...">Objet_U</a> sur un flot d'entree<br/>
Methode a surcharger. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="classEntree.html" title="Classe de definition des operateurs et methodes pour toute lecture dans un flot d&#39;entree (fichier...">Entree</a>&amp; s<br/>
 Signification: flot d'entree modifie<br/>
 Contraintes: </dd></dl>

<p>Reimplemented from <a class="el" href="classSimpler.html#a3f6e11bc3a07e61728492d1f04f78ef6">Simpler</a>.</p>

<p>Reimplemented in <a class="el" href="classICE.html#a1dc1a3e445545c106b46f5a335ba2825">ICE</a>.</p>

<p>Definition at line <a class="el" href="SETS_8cpp_source.html#l00076">76</a> of file <a class="el" href="SETS_8cpp_source.html">SETS.cpp</a>.</p>

<p>References <a class="el" href="SETS_8h_source.html#l00099">crit_conv</a>, and <a class="el" href="SETS_8h_source.html#l00096">first_call_</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="comment">/* valeurs par defaut des criteres de convergence */</span>
  <a class="code" href="classSETS.html#a2dc023a4074725a2d139135afb6859cf">crit_conv</a> = { { <span class="stringliteral">&quot;alpha&quot;</span>, 1e-2 }, { <span class="stringliteral">&quot;temperature&quot;</span>, 1e-1 }, { <span class="stringliteral">&quot;vitesse&quot;</span>, 1e-2 }, { <span class="stringliteral">&quot;pression&quot;</span>, 100 } };
  <a class="code" href="classSETS.html#abc7f91897922f8e62d9b9a181ff35f51">first_call_</a> = 1;
  <a class="code" href="classSETS.html#a12e94bf4ecd4e24b8bd838c78df8004e" title="Lecture d&#39;un Objet_U sur un flot d&#39;entree Methode a surcharger.">Simpler::readOn</a>(is);
  <span class="keywordflow">return</span> is;
}
</pre></div>
</div>
</div>
<a class="anchor" id="ac4a714691f77b564b45046e2d7b786ae"></a><!-- doxytag: member="SETS::self_cast" ref="ac4a714691f77b564b45046e2d7b786ae" args="(const Objet_U &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSETS.html">SETS</a> &amp; SETS::self_cast </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classObjet__U.html">Objet_U</a> &amp;&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>methode ajoutee pour caster en python </p>

<p>Reimplemented from <a class="el" href="classSimpler.html#a724746a40770cda346569614602e455e">Simpler</a>.</p>

<p>Reimplemented in <a class="el" href="classICE.html#ae80c5214e0e5472ec4bf801b315176cd">ICE</a>.</p>

<p>Definition at line <a class="el" href="SETS_8cpp_source.html#l00057">57</a> of file <a class="el" href="SETS_8cpp_source.html">SETS.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="acd332834843a5735bec7008b15b4b4d2"></a><!-- doxytag: member="SETS::self_cast" ref="acd332834843a5735bec7008b15b4b4d2" args="(Objet_U &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSETS.html">SETS</a> &amp; SETS::self_cast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classObjet__U.html">Objet_U</a> &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="classSimpler.html#a8f8015bb4baa38191a3a5e30810677da">Simpler</a>.</p>

<p>Reimplemented in <a class="el" href="classICE.html#a9427597c7bc3a4357b3b37af7901473f">ICE</a>.</p>

<p>Definition at line <a class="el" href="SETS_8cpp_source.html#l00057">57</a> of file <a class="el" href="SETS_8cpp_source.html">SETS.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a944777cb20695d4fa729574ada7054cb"></a><!-- doxytag: member="SETS::taille_memoire" ref="a944777cb20695d4fa729574ada7054cb" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned SETS::taille_memoire </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="classSimpler.html#a0296e915186f4820a3df088a4a277a0f">Simpler</a>.</p>

<p>Reimplemented in <a class="el" href="classICE.html#a3f754ad3d3ed76cb409d75f145b7242a">ICE</a>.</p>

<p>Definition at line <a class="el" href="SETS_8cpp_source.html#l00057">57</a> of file <a class="el" href="SETS_8cpp_source.html">SETS.cpp</a>.</p>

</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="a53cd8850df0e00210aa6c4cea0e978cd"></a><!-- doxytag: member="SETS::A_p" ref="a53cd8850df0e00210aa6c4cea0e978cd" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;std::string, <a class="el" href="classMatrice__Morse.html">Matrice_Morse</a>&gt; <a class="el" href="classSETS.html#a53cd8850df0e00210aa6c4cea0e978cd">SETS::A_p</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="SETS_8h_source.html#l00107">107</a> of file <a class="el" href="SETS_8h_source.html">SETS.h</a>.</p>

</div>
</div>
<a class="anchor" id="a2dc023a4074725a2d139135afb6859cf"></a><!-- doxytag: member="SETS::crit_conv" ref="a2dc023a4074725a2d139135afb6859cf" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;std::string, double&gt; <a class="el" href="classSETS.html#a2dc023a4074725a2d139135afb6859cf">SETS::crit_conv</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="SETS_8h_source.html#l00099">99</a> of file <a class="el" href="SETS_8h_source.html">SETS.h</a>.</p>

<p>Referenced by <a class="el" href="SETS_8cpp_source.html#l00085">lire()</a>, and <a class="el" href="SETS_8cpp_source.html#l00076">readOn()</a>.</p>

</div>
</div>
<a class="anchor" id="abc7f91897922f8e62d9b9a181ff35f51"></a><!-- doxytag: member="SETS::first_call_" ref="abc7f91897922f8e62d9b9a181ff35f51" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classSETS.html#abc7f91897922f8e62d9b9a181ff35f51">SETS::first_call_</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="SETS_8h_source.html#l00096">96</a> of file <a class="el" href="SETS_8h_source.html">SETS.h</a>.</p>

<p>Referenced by <a class="el" href="SETS_8cpp_source.html#l00181">iterer_NS()</a>, and <a class="el" href="SETS_8cpp_source.html#l00076">readOn()</a>.</p>

</div>
</div>
<a class="anchor" id="a33754674a881c70726bd6b6267e0a18d"></a><!-- doxytag: member="SETS::info_obj" ref="a33754674a881c70726bd6b6267e0a18d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classType__info.html">Type_info</a> <a class="el" href="classSETS.html#a33754674a881c70726bd6b6267e0a18d">SETS::info_obj</a><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="classSimpler.html#a9893f5779c657bd604b1857888aeb753">Simpler</a>.</p>

<p>Reimplemented in <a class="el" href="classICE.html#a971e7e14b62d0d5e91c9daac53fcb760">ICE</a>.</p>

<p>Definition at line <a class="el" href="SETS_8h_source.html#l00040">40</a> of file <a class="el" href="SETS_8h_source.html">SETS.h</a>.</p>

</div>
</div>
<a class="anchor" id="acf75db99aa6f39fb02552f774ac26d17"></a><!-- doxytag: member="SETS::iter_max_" ref="acf75db99aa6f39fb02552f774ac26d17" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classSETS.html#acf75db99aa6f39fb02552f774ac26d17">SETS::iter_max_</a> = 10<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="SETS_8h_source.html#l00095">95</a> of file <a class="el" href="SETS_8h_source.html">SETS.h</a>.</p>

<p>Referenced by <a class="el" href="SETS_8cpp_source.html#l00085">lire()</a>.</p>

</div>
</div>
<a class="anchor" id="a416660a4c6b560c16a63ef41bc99383f"></a><!-- doxytag: member="SETS::iter_min_" ref="a416660a4c6b560c16a63ef41bc99383f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classSETS.html#a416660a4c6b560c16a63ef41bc99383f">SETS::iter_min_</a> = 1<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="SETS_8h_source.html#l00095">95</a> of file <a class="el" href="SETS_8h_source.html">SETS.h</a>.</p>

<p>Referenced by <a class="el" href="SETS_8cpp_source.html#l00085">lire()</a>.</p>

</div>
</div>
<a class="anchor" id="a73c4e579bc537898da0bc707ac19fb3a"></a><!-- doxytag: member="SETS::iteration" ref="a73c4e579bc537898da0bc707ac19fb3a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classSETS.html#a73c4e579bc537898da0bc707ac19fb3a">SETS::iteration</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="SETS_8h_source.html#l00089">89</a> of file <a class="el" href="SETS_8h_source.html">SETS.h</a>.</p>

<p>Referenced by <a class="el" href="SETS_8cpp_source.html#l00181">iterer_NS()</a>.</p>

</div>
</div>
<a class="anchor" id="aa96e420735d53c9033c0031f4a02a379"></a><!-- doxytag: member="SETS::mat_pred" ref="aa96e420735d53c9033c0031f4a02a379" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;std::string, <a class="el" href="classMatrice__Morse.html">Matrice_Morse</a>&gt; <a class="el" href="classSETS.html#aa96e420735d53c9033c0031f4a02a379">SETS::mat_pred</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="SETS_8h_source.html#l00104">104</a> of file <a class="el" href="SETS_8h_source.html">SETS.h</a>.</p>

<p>Referenced by <a class="el" href="SETS_8cpp_source.html#l00133">iterer_eqn()</a>, and <a class="el" href="SETS_8cpp_source.html#l00181">iterer_NS()</a>.</p>

</div>
</div>
<a class="anchor" id="a8ee91bd4406997e979f5157a55749010"></a><!-- doxytag: member="SETS::mat_semi_impl" ref="a8ee91bd4406997e979f5157a55749010" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMatrice__Bloc.html">Matrice_Bloc</a> <a class="el" href="classSETS.html#a8ee91bd4406997e979f5157a55749010">SETS::mat_semi_impl</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="SETS_8h_source.html#l00103">103</a> of file <a class="el" href="SETS_8h_source.html">SETS.h</a>.</p>

</div>
</div>
<a class="anchor" id="a344f98c5dfa364bc5e9c9c04ef7800ee"></a><!-- doxytag: member="SETS::matrice_pression" ref="a344f98c5dfa364bc5e9c9c04ef7800ee" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> <a class="el" href="classSETS.html#a344f98c5dfa364bc5e9c9c04ef7800ee">SETS::matrice_pression</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="SETS_8h_source.html#l00110">110</a> of file <a class="el" href="SETS_8h_source.html">SETS.h</a>.</p>

</div>
</div>
<a class="anchor" id="aa1512e2ef91bb2c9ab5968a69b54600a"></a><!-- doxytag: member="SETS::mats" ref="aa1512e2ef91bb2c9ab5968a69b54600a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;std::string, <a class="el" href="Interface__blocs_8h.html#a68e4f5c4505f6b31305de844302660bb">matrices_t</a>&gt; <a class="el" href="classSETS.html#aa1512e2ef91bb2c9ab5968a69b54600a">SETS::mats</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>matrices : mats[nom de l'inconnue de l'equation][nom de l'autre inconnue] = matrice </p>

<p>Definition at line <a class="el" href="SETS_8h_source.html#l00102">102</a> of file <a class="el" href="SETS_8h_source.html">SETS.h</a>.</p>

</div>
</div>
<a class="anchor" id="a3ac3e326835cd7b7e65512befd351443"></a><!-- doxytag: member="SETS::p_degen" ref="a3ac3e326835cd7b7e65512befd351443" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classSETS.html#a3ac3e326835cd7b7e65512befd351443">SETS::p_degen</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="SETS_8h_source.html#l00090">90</a> of file <a class="el" href="SETS_8h_source.html">SETS.h</a>.</p>

</div>
</div>
<a class="anchor" id="a037404a748a911b2e260905354a6c7f2"></a><!-- doxytag: member="SETS::sets_" ref="a037404a748a911b2e260905354a6c7f2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classSETS.html#a037404a748a911b2e260905354a6c7f2">SETS::sets_</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>1 si on fait l'etape de prediction des vitesses </p>

<p>Definition at line <a class="el" href="SETS_8h_source.html#l00091">91</a> of file <a class="el" href="SETS_8h_source.html">SETS.h</a>.</p>

<p>Referenced by <a class="el" href="SETS_8cpp_source.html#l00066">ICE::ICE()</a>, <a class="el" href="SETS_8cpp_source.html#l00133">iterer_eqn()</a>, <a class="el" href="SETS_8cpp_source.html#l00181">iterer_NS()</a>, and <a class="el" href="SETS_8cpp_source.html#l00061">SETS()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/ThHyd/Multiphase/Schemas_Temps/<a class="el" href="SETS_8h_source.html">SETS.h</a></li>
<li>src/ThHyd/Multiphase/Schemas_Temps/<a class="el" href="SETS_8cpp_source.html">SETS.cpp</a></li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Tue Dec 14 2021 19:37:51 for TRUST by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
