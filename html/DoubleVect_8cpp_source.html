<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>TRUST: src/Kernel/Math/DoubleVect.cpp Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">TRUST&#160;<span id="projectnumber">1.8.4</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
<div class="header">
  <div class="headertitle">
<div class="title">src/Kernel/Math/DoubleVect.cpp</div>  </div>
</div>
<div class="contents">
<a href="DoubleVect_8cpp.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/****************************************************************************</span>
<a name="l00002"></a>00002 <span class="comment">* Copyright (c) 2021, CEA</span>
<a name="l00003"></a>00003 <span class="comment">* All rights reserved.</span>
<a name="l00004"></a>00004 <span class="comment">*</span>
<a name="l00005"></a>00005 <span class="comment">* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</span>
<a name="l00006"></a>00006 <span class="comment">* 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.</span>
<a name="l00007"></a>00007 <span class="comment">* 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.</span>
<a name="l00008"></a>00008 <span class="comment">* 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.</span>
<a name="l00009"></a>00009 <span class="comment">*</span>
<a name="l00010"></a>00010 <span class="comment">* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.</span>
<a name="l00011"></a>00011 <span class="comment">* IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;</span>
<a name="l00012"></a>00012 <span class="comment">* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>
<a name="l00013"></a>00013 <span class="comment">*</span>
<a name="l00014"></a>00014 <span class="comment">*****************************************************************************/</span>
<a name="l00015"></a>00015 <span class="comment">//</span>
<a name="l00016"></a>00016 <span class="comment">// </span>
<a name="l00017"></a>00017 <span class="comment">// File:        DoubleVect.cpp</span>
<a name="l00018"></a>00018 <span class="comment">// Directory:   $TRUST_ROOT/src/Kernel/Math</span>
<a name="l00019"></a>00019 <span class="comment">// Version:     /main/v157_front_tracking/v157_ft_gbois/1</span>
<a name="l00020"></a>00020 <span class="comment">// </span>
<a name="l00021"></a>00021 <span class="comment">//</span>
<a name="l00022"></a>00022 <span class="comment">// </span>
<a name="l00023"></a>00023 <span class="comment">// WARNING: DO NOT EDIT THIS FILE! Only edit the template file DoubleVect.cpp.P</span>
<a name="l00024"></a>00024 <span class="comment">// </span>
<a name="l00025"></a>00025 <span class="comment">// </span>
<a name="l00026"></a>00026 <span class="preprocessor">#include &lt;<a class="code" href="DoubleVect_8h.html">DoubleVect.h</a>&gt;</span>
<a name="l00027"></a>00027 <span class="preprocessor">#include &lt;math.h&gt;</span>
<a name="l00028"></a>00028 <span class="preprocessor">#ifdef SGI_</span>
<a name="l00029"></a>00029 <span class="preprocessor"></span><span class="preprocessor">#include &lt;bstring.h&gt;</span>
<a name="l00030"></a>00030 <span class="preprocessor">#endif</span>
<a name="l00031"></a>00031 <span class="preprocessor"></span><span class="preprocessor">#include &lt;<a class="code" href="MD__Vector__base_8h.html">MD_Vector_base.h</a>&gt;</span>
<a name="l00032"></a>00032 <span class="preprocessor">#include &lt;<a class="code" href="MD__Vector__tools_8h.html">MD_Vector_tools.h</a>&gt;</span>
<a name="l00033"></a>00033 <span class="preprocessor">#include &lt;limits.h&gt;</span>
<a name="l00034"></a>00034 <span class="preprocessor">#include &lt;<a class="code" href="communications_8h.html">communications.h</a>&gt;</span>
<a name="l00035"></a>00035 
<a name="l00036"></a>00036 <span class="comment">// Pour la relecture des anciens fichiers de reprise, voir DoubleVect::lit()</span>
<a name="l00037"></a>00037 <span class="preprocessor">#include &lt;<a class="code" href="DescStructure_8h.html">DescStructure.h</a>&gt;</span>
<a name="l00038"></a>00038 
<a name="l00039"></a><a class="code" href="DoubleVect_8cpp.html#aa5f90454b861a6716c841961e6908ac3">00039</a> <a class="code" href="Declare__Inst_8h.html#a1a414570e3c7a7f9787a0eba4e9366e8">Implemente_instanciable_sans_constructeur_ni_destructeur</a>(<a class="code" href="classDoubleVect.html">DoubleVect</a>, <span class="stringliteral">&quot;DoubleVect&quot;</span>, <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a>);
<a name="l00040"></a>00040 
<a name="l00041"></a>00041 <span class="comment">//</span>
<a name="l00042"></a>00042 <span class="comment">//</span><span class="comment"></span>
<a name="l00043"></a>00043 <span class="comment">//! Ecriture d&#39;un vecteur sequentiel (sans descripteur parallele)&lt;br&gt;Pour l&#39;instant: erreur si presence d&#39;un md_vector_ (sinon quoi faire ?)&lt;br&gt;Pour les vecteurs paralleles, utiliser une methode de sauvegarde/reprise</span>
<a name="l00044"></a><a class="code" href="classDoubleVect.html#a621020bfecb3e6ad09afd47c99e1e48c">00044</a> <span class="comment"></span><a class="code" href="classSortie.html" title="Classe de base des flux de sortie. Elle sait ecrire des types simples&lt;br&gt;(entiers, flottants) et des Ob...">Sortie</a>&amp; <a class="code" href="classDoubleVect.html#a621020bfecb3e6ad09afd47c99e1e48c" title="Ecriture d&#39;un vecteur sequentiel (sans descripteur parallele) Pour l&#39;instant: erreur si presence d&#39;un...">DoubleVect::printOn</a>(<a class="code" href="classSortie.html" title="Classe de base des flux de sortie. Elle sait ecrire des types simples&lt;br&gt;(entiers, flottants) et des Ob...">Sortie</a>&amp; os)<span class="keyword"> const</span>
<a name="l00045"></a>00045 <span class="keyword"></span>{
<a name="l00046"></a>00046   <span class="keywordflow">if</span> (<a class="code" href="classProcess.html#a6bf692ce58d9578aa62ac3c07b8caaa1" title="renvoie le nombre de processeurs dans le groupe courant Voir Comm_Group::nproc() et PE_Groups::curren...">nproc</a>() &gt; 1 &amp;&amp; <a class="code" href="classDoubleVect.html#ab3344c5b93fc9fadfd54608897a9989e">md_vector_</a>.<a class="code" href="classMD__Vector.html#a4165c00904b7096274e38fdc7ca340f4">non_nul</a>())
<a name="l00047"></a>00047     {
<a name="l00048"></a>00048       <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Error in DoubleVect::printOn: try to print a parallel vector&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
<a name="l00049"></a>00049       <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">exit</a>();
<a name="l00050"></a>00050     }
<a name="l00051"></a>00051   <a class="code" href="classDoubleVect.html#a621020bfecb3e6ad09afd47c99e1e48c" title="Ecriture d&#39;un vecteur sequentiel (sans descripteur parallele) Pour l&#39;instant: erreur si presence d&#39;un...">ArrOfDouble::printOn</a>(os);
<a name="l00052"></a>00052   <span class="keywordflow">return</span> os;
<a name="l00053"></a>00053 }
<a name="l00054"></a>00054 
<a name="l00055"></a>00055 <span class="comment">//</span>
<a name="l00056"></a>00056 <span class="comment">//</span><span class="comment"></span>
<a name="l00057"></a>00057 <span class="comment">//! Lecture d&#39;un vecteur sequentiel (comme un ArrOfDouble)&lt;br&gt;Attention: appel invalide si le vecteur a un MD_Vector non nul.&lt;br&gt;(pour les vecteurs paralleles, utiliser une methode de sauvegarde/reprise)</span>
<a name="l00058"></a><a class="code" href="classDoubleVect.html#a75fc33dba77cd2c19512dfbd14ed53a4">00058</a> <span class="comment"></span><a class="code" href="classEntree.html" title="Classe de definition des operateurs et methodes pour toute lecture dans un flot d&#39;entree (fichier...">Entree</a>&amp; <a class="code" href="classDoubleVect.html#a75fc33dba77cd2c19512dfbd14ed53a4" title="Lecture d&#39;un vecteur sequentiel (comme un ArrOfDouble) Attention: appel invalide si le vecteur a un M...">DoubleVect::readOn</a>(<a class="code" href="classEntree.html" title="Classe de definition des operateurs et methodes pour toute lecture dans un flot d&#39;entree (fichier...">Entree</a>&amp; is)
<a name="l00059"></a>00059 {
<a name="l00060"></a>00060   <span class="keywordflow">if</span> (<a class="code" href="classDoubleVect.html#ab3344c5b93fc9fadfd54608897a9989e">md_vector_</a>.<a class="code" href="classMD__Vector.html#a4165c00904b7096274e38fdc7ca340f4">non_nul</a>())
<a name="l00061"></a>00061     {
<a name="l00062"></a>00062 <span class="comment">// Que veut-on faire si on lit dans un vecteur ayant deja une structure parallele ?</span>
<a name="l00063"></a>00063       <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Error in DoubleVect::readOn: vector has a parallel structure&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
<a name="l00064"></a>00064       <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">exit</a>();
<a name="l00065"></a>00065     }
<a name="l00066"></a>00066   <a class="code" href="classDoubleVect.html#a75fc33dba77cd2c19512dfbd14ed53a4" title="Lecture d&#39;un vecteur sequentiel (comme un ArrOfDouble) Attention: appel invalide si le vecteur a un M...">ArrOfDouble::readOn</a>(is);
<a name="l00067"></a>00067   <a class="code" href="classDoubleVect.html#ae50e9d1185479013c69f3d6e5df6e982">size_reelle_</a> = <a class="code" href="classArrOfDouble.html#a3c3b33bea0e88b87315c21ee94bee05f" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>();
<a name="l00068"></a>00068   <a class="code" href="classDoubleVect.html#adf655214bf244ad33c0b1be4730f1569">line_size_</a> = 1;
<a name="l00069"></a>00069   <span class="keywordflow">return</span> is;
<a name="l00070"></a>00070 }
<a name="l00071"></a>00071 
<a name="l00072"></a>00072 <span class="comment">//</span>
<a name="l00073"></a>00073 <span class="comment">//</span>
<a name="l00074"></a>00074 <span class="comment">//</span>
<a name="l00075"></a>00075 <span class="comment">//</span><span class="comment"></span>
<a name="l00076"></a>00076 <span class="comment">//! construction d&#39;un vecteur de taille n.&lt;br&gt;Les elements du vecteur sont initialises a zero par defaut.&lt;br&gt;Pour ne pas initialiser les valeurs, utiliser ceci:&lt;br&gt;DoubleVect toto;&lt;br&gt;toto.resize(n, NOCOPY_NOINIT);</span>
<a name="l00077"></a><a class="code" href="classDoubleVect.html#ac53d4f2cd5a9dd0fc98b984fd9ef25ec">00077</a> <span class="comment"></span><a class="code" href="classDoubleVect.html#a9d971d975d2b74a2078e031ca764348d">DoubleVect::DoubleVect</a>(<span class="keywordtype">int</span> n) :
<a name="l00078"></a>00078   <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a>(n),
<a name="l00079"></a>00079   size_reelle_(n),
<a name="l00080"></a>00080   line_size_(1)
<a name="l00081"></a>00081 {
<a name="l00082"></a>00082 }
<a name="l00083"></a>00083 <span class="comment">/*</span>
<a name="l00084"></a>00084 <span class="comment">// Description: construction d&#39;un vecteur de taille n.</span>
<a name="l00085"></a>00085 <span class="comment">//  Les elements du vecteur sont initialises avec la valeur x.</span>
<a name="l00086"></a>00086 <span class="comment">DoubleVect::DoubleVect(int n, double x) :</span>
<a name="l00087"></a>00087 <span class="comment">  ArrOfDouble(n, x),</span>
<a name="l00088"></a>00088 <span class="comment">  size_reelle_(n),</span>
<a name="l00089"></a>00089 <span class="comment">  line_size_(1)</span>
<a name="l00090"></a>00090 <span class="comment">{</span>
<a name="l00091"></a>00091 <span class="comment">}</span>
<a name="l00092"></a>00092 <span class="comment">*/</span>
<a name="l00093"></a>00093 <span class="comment">//</span>
<a name="l00094"></a>00094 <span class="comment">//</span>
<a name="l00095"></a>00095 <span class="comment">//</span>
<a name="l00096"></a>00096 <span class="comment">//</span>
<a name="l00097"></a>00097 <span class="comment">//</span>
<a name="l00098"></a>00098 <span class="comment">//</span>
<a name="l00099"></a>00099 <span class="comment">//</span><span class="comment"></span>
<a name="l00100"></a>00100 <span class="comment">//! Constructeur par copie. Il s&#39;agit d&#39;un &quot;deep copy&quot;&lt;br&gt;voir ArrOfDouble::ArrOfDouble(const ArrOfDouble \&amp;)&lt;br&gt;Remarque: il n&#39;y a pas de constructeur par copie a partir de ArrOfDouble&lt;br&gt;Ceci est volontaire, sinon on risque de grosses pertes de performances&lt;br&gt;par creation implicite d&#39;objets, difficile a trouver.&lt;br&gt;(exemple: appel d&#39;une methode toto(const IntVect \&amp;) avec un ArrOfInt&lt;br&gt;produit une copie du tableau !)&lt;br&gt;Utiliser copy() pour copier un ArrOfDouble dans un DoubleVect</span>
<a name="l00101"></a><a class="code" href="classDoubleVect.html#a814ad5ddc78df89c00bdf8ddf5f0d648">00101</a> <span class="comment"></span><a class="code" href="classDoubleVect.html#a9d971d975d2b74a2078e031ca764348d">DoubleVect::DoubleVect</a>(<span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; v) :
<a name="l00102"></a>00102   <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a>(v),
<a name="l00103"></a>00103   md_vector_(v.md_vector_),
<a name="l00104"></a>00104   size_reelle_(v.size_reelle_),
<a name="l00105"></a>00105   line_size_(v.line_size_)
<a name="l00106"></a>00106 {
<a name="l00107"></a>00107 }
<a name="l00108"></a>00108 
<a name="l00109"></a>00109 <span class="comment">//</span><span class="comment"></span>
<a name="l00110"></a>00110 <span class="comment">//! met l&#39;objet dans l&#39;etat obtenu par le constructeur par defaut.&lt;br&gt;(voir ArrOfDouble::reset())</span>
<a name="l00111"></a><a class="code" href="classDoubleVect.html#a990500e5bf63a8ca55fd833d111e135c">00111</a> <span class="comment"></span><span class="keywordtype">void</span> <a class="code" href="classDoubleVect.html#a990500e5bf63a8ca55fd833d111e135c" title="met l&#39;objet dans l&#39;etat obtenu par le constructeur par defaut. (voir ArrOfDouble::reset())">DoubleVect::reset</a>()
<a name="l00112"></a>00112 {
<a name="l00113"></a>00113   <a class="code" href="classDoubleVect.html#ab3344c5b93fc9fadfd54608897a9989e">md_vector_</a>.<a class="code" href="classMD__Vector.html#aa8b6d80c076feecf7373552d58489e22" title="Detache le pointeur de l&#39;objet pointe et decremente le compteur de ref. Si le compteur est nul...">detach</a>();
<a name="l00114"></a>00114   <a class="code" href="classDoubleVect.html#adf655214bf244ad33c0b1be4730f1569">line_size_</a> = 1;
<a name="l00115"></a>00115   <a class="code" href="classDoubleVect.html#ae50e9d1185479013c69f3d6e5df6e982">size_reelle_</a> = 0;
<a name="l00116"></a>00116   <a class="code" href="classDoubleVect.html#a990500e5bf63a8ca55fd833d111e135c" title="met l&#39;objet dans l&#39;etat obtenu par le constructeur par defaut. (voir ArrOfDouble::reset())">ArrOfDouble::reset</a>();
<a name="l00117"></a>00117 }
<a name="l00118"></a>00118 <span class="comment"></span>
<a name="l00119"></a>00119 <span class="comment">//! detach the vector.</span>
<a name="l00120"></a><a class="code" href="classDoubleVect.html#ac37a0acb8027d3e6740b39da7fb1c319">00120</a> <span class="comment"></span><span class="keywordtype">void</span> <a class="code" href="classDoubleVect.html#ac37a0acb8027d3e6740b39da7fb1c319" title="detach the vector.">DoubleVect::detach_vect</a>()
<a name="l00121"></a>00121 {
<a name="l00122"></a>00122   <a class="code" href="classDoubleVect.html#ab3344c5b93fc9fadfd54608897a9989e">md_vector_</a>.<a class="code" href="classMD__Vector.html#aa8b6d80c076feecf7373552d58489e22" title="Detache le pointeur de l&#39;objet pointe et decremente le compteur de ref. Si le compteur est nul...">detach</a>();
<a name="l00123"></a>00123 }
<a name="l00124"></a>00124 
<a name="l00125"></a>00125 <span class="comment">// Precondition:</span>
<a name="l00126"></a>00126 <span class="comment">// L&#39;objet ne doit pas etre un sous-type de DoubleVect (sinon mauvaise initialisation</span>
<a name="l00127"></a>00127 <span class="comment">// des dimensions.</span>
<a name="l00128"></a>00128 <span class="comment">//</span>
<a name="l00129"></a>00129 <span class="comment">//</span>
<a name="l00130"></a>00130 <span class="comment">//</span>
<a name="l00131"></a>00131 <span class="comment">//</span><span class="comment"></span>
<a name="l00132"></a>00132 <span class="comment">//! detache le tableau et l&#39;attache a v (sauf si v==*this, ne fait rien)&lt;br&gt;Fait pointer le tableau sur la meme zone de memoire que v et copie le MD_Vector&lt;br&gt;(utilise ArrOfDouble::attach_array())&lt;br&gt;Attention, il devient alors interdit de resizer le tableau v ainsi que *this&lt;br&gt;Methode virtuelle reimplementee dans DoubleTab</span>
<a name="l00133"></a><a class="code" href="classDoubleVect.html#a2b45ece955d7d57746fa32b5a6a89cc2">00133</a> <span class="comment"></span><span class="keywordtype">void</span> <a class="code" href="classDoubleVect.html#a2b45ece955d7d57746fa32b5a6a89cc2" title="detache le tableau et l&#39;attache a v (sauf si v==*this, ne fait rien) Fait pointer le tableau sur la m...">DoubleVect::ref</a>(<span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; v)
<a name="l00134"></a>00134 {
<a name="l00135"></a>00135   <span class="keywordflow">if</span> (&amp;v != <span class="keyword">this</span>)
<a name="l00136"></a>00136     {
<a name="l00137"></a>00137       <a class="code" href="classArrOfDouble.html#a30d7509eec18c3ef46cc0140bdcdc48f" title="Amene le tableau dans l&#39;etat &quot;detache&quot;. C&#39;est a dire: Si le tableau est &quot;detache&quot; : * ne rien faire...">detach_array</a>();
<a name="l00138"></a>00138       <a class="code" href="classArrOfDouble.html#af59467d8ccfc8e5cdac8e24e1c8a1e66" title="Amene le tableau dans l&#39;etat &quot;normal&quot;, &quot;detache&quot; ou &quot;ref_array&quot; en associant une sous-zone de m...">attach_array</a>(v);
<a name="l00139"></a>00139       <a class="code" href="classDoubleVect.html#ab3344c5b93fc9fadfd54608897a9989e">md_vector_</a> = v.<a class="code" href="classDoubleVect.html#ab3344c5b93fc9fadfd54608897a9989e">md_vector_</a>;
<a name="l00140"></a>00140       <a class="code" href="classDoubleVect.html#ae50e9d1185479013c69f3d6e5df6e982">size_reelle_</a> = v.<a class="code" href="classDoubleVect.html#ae50e9d1185479013c69f3d6e5df6e982">size_reelle_</a>;
<a name="l00141"></a>00141       <a class="code" href="classDoubleVect.html#adf655214bf244ad33c0b1be4730f1569">line_size_</a> = v.<a class="code" href="classDoubleVect.html#adf655214bf244ad33c0b1be4730f1569">line_size_</a>;
<a name="l00142"></a>00142     }
<a name="l00143"></a>00143 }
<a name="l00144"></a>00144 
<a name="l00145"></a>00145 <span class="comment">// Precondition: si le tableau *this doit etre resize, il doit etre de type DoubleVect</span>
<a name="l00146"></a>00146 <span class="comment">// (et pas d&#39;un type derive !)</span>
<a name="l00147"></a>00147 <span class="comment">// Si le tableau *this a deja une structure parallele, l&#39;appel n&#39;est autorise que les md_vector</span>
<a name="l00148"></a>00148 <span class="comment">// sont deja identiques, sinon il faut d&#39;abord faire un reset() du tableau (pour copier la structure),</span>
<a name="l00149"></a>00149 <span class="comment">// ou utiliser inject_array() (pour ne pas copier la structure).</span>
<a name="l00150"></a>00150 <span class="comment">// (ceci pour eviter d&#39;ecraser accidentellement une structure parallele alors qu&#39;on ne veut</span>
<a name="l00151"></a>00151 <span class="comment">// que copier les valeurs).</span>
<a name="l00152"></a>00152 <span class="comment">//</span>
<a name="l00153"></a>00153 <span class="comment">//</span><span class="comment"></span>
<a name="l00154"></a>00154 <span class="comment">//! copie la structure et les valeurs du tableau v dans *this avec ArrOfDouble::operator=()&lt;br&gt;(attention, si le tableau est de type ref_data ou ref, restrictions et cas particuliers !!!)&lt;br&gt;Attention: si on ne veut pas copier les structures paralleles, utiliser inject_array()</span>
<a name="l00155"></a><a class="code" href="classDoubleVect.html#a6c98f8cb9f2a079c8239ffe4932f8b92">00155</a> <span class="comment"></span><a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; <a class="code" href="classDoubleVect.html#a6c98f8cb9f2a079c8239ffe4932f8b92" title="copie la structure et les valeurs du tableau v dans *this avec ArrOfDouble::operator=() (attention...">DoubleVect::operator=</a>(<span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; v)
<a name="l00156"></a>00156 {
<a name="l00157"></a>00157   <a class="code" href="classDoubleVect.html#aaccfc72d49151e3105aba476fa9f414b" title="copie de la structure et des valeurs (si opt==COPY_INIT) du tableau v. Attention, v doit vraiment etr...">copy</a>(v);
<a name="l00158"></a>00158   <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00159"></a>00159 }
<a name="l00160"></a>00160 
<a name="l00161"></a>00161 <span class="comment">// Precondition: Le vecteur ne doit pas avoir de structure de tableau distribue</span>
<a name="l00162"></a>00162 <span class="comment">// et il doit vraiment etre de type DoubleVect.</span>
<a name="l00163"></a>00163 <span class="comment">//</span>
<a name="l00164"></a>00164 <span class="comment">//</span><span class="comment"></span>
<a name="l00165"></a>00165 <span class="comment">//! copie de la structure et des valeurs (si opt==COPY_INIT) du tableau v.&lt;br&gt;Attention, v doit vraiment etre de type ArrOfDouble, pas d&#39;un type derive&lt;br&gt;(sinon ambiguite: faut-il copier ou pas le MD_Vector ?)</span>
<a name="l00166"></a><a class="code" href="classDoubleVect.html#aaccfc72d49151e3105aba476fa9f414b">00166</a> <span class="comment"></span><span class="keywordtype">void</span> <a class="code" href="classDoubleVect.html#aaccfc72d49151e3105aba476fa9f414b" title="copie de la structure et des valeurs (si opt==COPY_INIT) du tableau v. Attention, v doit vraiment etr...">DoubleVect::copy</a>(<span class="keyword">const</span> <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a>&amp; v, <a class="code" href="classArray__base.html#abee342aa9ac59623c4c782dc9d7877ff">Array_base::Resize_Options</a> opt)
<a name="l00167"></a>00167 {
<a name="l00168"></a>00168   assert(<a class="code" href="classDoubleVect.html#a530ac863a73858ff1254f70de10b6348" title="Donne des informations sur le type de l&#39;Objet_U.">get_info</a>() == <a class="code" href="classDoubleVect.html#abd68c2dcd3230d422bf30045df688994" title="Donne des informations sur le type de l&#39;Objet_U.">DoubleVect::info</a>());
<a name="l00169"></a>00169   assert(v.<a class="code" href="classArrOfDouble.html#a4f370ec412709796eb51fef1d1f068ac" title="Donne des informations sur le type de l&#39;Objet_U.">get_info</a>() == <a class="code" href="classDoubleVect.html#abd68c2dcd3230d422bf30045df688994" title="Donne des informations sur le type de l&#39;Objet_U.">ArrOfDouble::info</a>());
<a name="l00170"></a>00170   assert(!<a class="code" href="classDoubleVect.html#ab3344c5b93fc9fadfd54608897a9989e">md_vector_</a>.<a class="code" href="classMD__Vector.html#a4165c00904b7096274e38fdc7ca340f4">non_nul</a>());
<a name="l00171"></a>00171   <a class="code" href="classDoubleVect.html#ac55a86eea7b2f06b084b88b16042b67b" title="Change la taille du vecteur (identique a resize_array() pour le traitement des anciennes valeurs et d...">resize</a>(v.<a class="code" href="classArrOfDouble.html#a3c3b33bea0e88b87315c21ee94bee05f" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>(), opt);
<a name="l00172"></a>00172   <span class="keywordflow">if</span> (opt != <a class="code" href="classArray__base.html#abee342aa9ac59623c4c782dc9d7877ffaf6ae9ba7eb51c5f298ce693345b3ec68">NOCOPY_NOINIT</a>)
<a name="l00173"></a>00173     <a class="code" href="classArrOfDouble.html#a2fcb2a2d3b59425c6cb37526ea6af6a3" title="Copie les elements source[first_element_source + i] dans les elements (*this)[first_element_dest + i]...">inject_array</a>(v);
<a name="l00174"></a>00174 }
<a name="l00175"></a>00175 
<a name="l00176"></a>00176 <span class="comment">// Precondition: idem que operator=(const DoubleVect &amp;)</span><span class="comment"></span>
<a name="l00177"></a>00177 <span class="comment">//! copie de la structure du vecteur v et des valeurs si opt==COPY_INIT.</span>
<a name="l00178"></a><a class="code" href="classDoubleVect.html#aa13ff1e582b78b449582263114d7a2a3">00178</a> <span class="comment"></span><span class="keywordtype">void</span> <a class="code" href="classDoubleVect.html#aaccfc72d49151e3105aba476fa9f414b" title="copie de la structure et des valeurs (si opt==COPY_INIT) du tableau v. Attention, v doit vraiment etr...">DoubleVect::copy</a>(<span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; v, <a class="code" href="classArray__base.html#abee342aa9ac59623c4c782dc9d7877ff">Array_base::Resize_Options</a> opt)
<a name="l00179"></a>00179 {
<a name="l00180"></a>00180   <span class="keywordflow">if</span> (&amp;v != <span class="keyword">this</span>)
<a name="l00181"></a>00181     {
<a name="l00182"></a>00182 <span class="comment">// Interdiction de resizer si l&#39;objet est d&#39;un type derive de DoubleVect</span>
<a name="l00183"></a>00183 <span class="comment">// (sinon mauvaise dimension(0) !)</span>
<a name="l00184"></a>00184       assert(v.<a class="code" href="classArrOfDouble.html#a3c3b33bea0e88b87315c21ee94bee05f" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() == <a class="code" href="classArrOfDouble.html#a3c3b33bea0e88b87315c21ee94bee05f" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() || <a class="code" href="classDoubleVect.html#a530ac863a73858ff1254f70de10b6348" title="Donne des informations sur le type de l&#39;Objet_U.">get_info</a>() == <a class="code" href="classDoubleVect.html#abd68c2dcd3230d422bf30045df688994" title="Donne des informations sur le type de l&#39;Objet_U.">DoubleVect::info</a>());
<a name="l00185"></a>00185       <a class="code" href="classDoubleVect.html#a02d4627cfaf3a58686a5dbfae22ee48b" title="methode protegee appelable depuis une classe derivee&lt;br&gt;(pas de precondition sur le type derive de *t...">copy_</a>(v, opt);
<a name="l00186"></a>00186     }
<a name="l00187"></a>00187 }
<a name="l00188"></a>00188 
<a name="l00189"></a>00189 <span class="comment">//</span><span class="comment"></span>
<a name="l00190"></a>00190 <span class="comment">//! methode protegee appelable depuis une classe derivee&lt;br&gt;(pas de precondition sur le type derive de *this)</span>
<a name="l00191"></a><a class="code" href="classDoubleVect.html#a02d4627cfaf3a58686a5dbfae22ee48b">00191</a> <span class="comment"></span><span class="keywordtype">void</span> <a class="code" href="classDoubleVect.html#a02d4627cfaf3a58686a5dbfae22ee48b" title="methode protegee appelable depuis une classe derivee&lt;br&gt;(pas de precondition sur le type derive de *t...">DoubleVect::copy_</a>(<span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; v, <a class="code" href="classArray__base.html#abee342aa9ac59623c4c782dc9d7877ff">Array_base::Resize_Options</a> opt)
<a name="l00192"></a>00192 {
<a name="l00193"></a>00193   assert(&amp;v != <span class="keyword">this</span>); <span class="comment">//!&lt; Il faut avoir fait le test avant ! Si le vecteur a deja une structure parallele, la copie n&#39;est autorisee que si le vecteur source a la meme structure. Si ce n&#39;est pas le cas, utiliser inject_array() pour copier uniquement les valeurs, ou faire d&#39;abord reset() si on veut ecraser la structure.</span>
<a name="l00194"></a>00194 <span class="comment"></span><span class="comment">//</span>
<a name="l00195"></a>00195 <span class="comment">//</span>
<a name="l00196"></a>00196 <span class="comment">//</span>
<a name="l00197"></a>00197   assert((!<a class="code" href="classDoubleVect.html#ab3344c5b93fc9fadfd54608897a9989e">md_vector_</a>.<a class="code" href="classMD__Vector.html#a4165c00904b7096274e38fdc7ca340f4">non_nul</a>()) || (<a class="code" href="classDoubleVect.html#ab3344c5b93fc9fadfd54608897a9989e">md_vector_</a> == v.<a class="code" href="classDoubleVect.html#ab3344c5b93fc9fadfd54608897a9989e">md_vector_</a>));
<a name="l00198"></a>00198   <a class="code" href="classArrOfDouble.html#af6aaac97844f02d467f6b84286e1cf1b" title="methode protegee de changement de taille, appelable par les classes derivees (idem que resize_array()...">resize_array_</a>(v.<a class="code" href="classArrOfDouble.html#a3c3b33bea0e88b87315c21ee94bee05f" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>(), <a class="code" href="classArray__base.html#abee342aa9ac59623c4c782dc9d7877ffaf6ae9ba7eb51c5f298ce693345b3ec68">NOCOPY_NOINIT</a>);
<a name="l00199"></a>00199   <span class="keywordflow">if</span> (opt != <a class="code" href="classArray__base.html#abee342aa9ac59623c4c782dc9d7877ffaf6ae9ba7eb51c5f298ce693345b3ec68">NOCOPY_NOINIT</a>)
<a name="l00200"></a>00200     <a class="code" href="classArrOfDouble.html#a2fcb2a2d3b59425c6cb37526ea6af6a3" title="Copie les elements source[first_element_source + i] dans les elements (*this)[first_element_dest + i]...">inject_array</a>(v);
<a name="l00201"></a>00201   <a class="code" href="classDoubleVect.html#ab3344c5b93fc9fadfd54608897a9989e">md_vector_</a> = v.<a class="code" href="classDoubleVect.html#ab3344c5b93fc9fadfd54608897a9989e">md_vector_</a>; <span class="comment">//!&lt; Pour le cas ou md_vector_ est nul et pas v.md_vector_</span>
<a name="l00202"></a>00202 <span class="comment"></span>  <a class="code" href="classDoubleVect.html#ae50e9d1185479013c69f3d6e5df6e982">size_reelle_</a> = v.<a class="code" href="classDoubleVect.html#ae50e9d1185479013c69f3d6e5df6e982">size_reelle_</a>;
<a name="l00203"></a>00203   <a class="code" href="classDoubleVect.html#adf655214bf244ad33c0b1be4730f1569">line_size_</a> = v.<a class="code" href="classDoubleVect.html#adf655214bf244ad33c0b1be4730f1569">line_size_</a>;
<a name="l00204"></a>00204 }
<a name="l00205"></a>00205 <span class="comment"></span>
<a name="l00206"></a>00206 <span class="comment">//! idem que ArrOfDouble::operator=(double)</span>
<a name="l00207"></a><a class="code" href="classDoubleVect.html#adb44f4edc6d90c74d0e6be2a662e60ca">00207</a> <span class="comment"></span><a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; <a class="code" href="classDoubleVect.html#a6c98f8cb9f2a079c8239ffe4932f8b92" title="copie la structure et les valeurs du tableau v dans *this avec ArrOfDouble::operator=() (attention...">DoubleVect::operator=</a>(<span class="keywordtype">double</span> x)
<a name="l00208"></a>00208 {
<a name="l00209"></a>00209   <a class="code" href="classDoubleVect.html#a6c98f8cb9f2a079c8239ffe4932f8b92" title="copie la structure et les valeurs du tableau v dans *this avec ArrOfDouble::operator=() (attention...">ArrOfDouble::operator=</a>(x);
<a name="l00210"></a>00210   <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00211"></a>00211 }
<a name="l00212"></a>00212 
<a name="l00213"></a>00213 <span class="comment">//</span>
<a name="l00214"></a>00214 <span class="comment">//</span>
<a name="l00215"></a>00215 <span class="comment">//</span>
<a name="l00216"></a>00216 <span class="comment">//</span><span class="comment"></span>
<a name="l00217"></a>00217 <span class="comment">//! methode virtuelle identique a resize_array(), permet de traiter&lt;br&gt;de facon generique les ArrOf, Vect et Tab.&lt;br&gt;Cree un tableau sequentiel...&lt;br&gt;Si l&#39;objet est de type DoubleVect, appel a resize(n)&lt;br&gt;Prerequis: voir resize()</span>
<a name="l00218"></a><a class="code" href="classDoubleVect.html#a4cc7c1dd4811f2461056e3ad14601adc">00218</a> <span class="comment"></span><span class="keywordtype">void</span> <a class="code" href="classDoubleVect.html#a4cc7c1dd4811f2461056e3ad14601adc" title="methode virtuelle identique a resize_array(), permet de traiter de facon generique les ArrOf...">DoubleVect::resize_tab</a>(<span class="keywordtype">int</span> n, <a class="code" href="classArray__base.html#abee342aa9ac59623c4c782dc9d7877ff">Array_base::Resize_Options</a> opt)
<a name="l00219"></a>00219 {
<a name="l00220"></a>00220   <a class="code" href="classDoubleVect.html#ac55a86eea7b2f06b084b88b16042b67b" title="Change la taille du vecteur (identique a resize_array() pour le traitement des anciennes valeurs et d...">resize</a>(n, opt);
<a name="l00221"></a>00221 }
<a name="l00222"></a>00222 
<a name="l00223"></a>00223 <span class="comment">//</span><span class="comment"></span>
<a name="l00224"></a>00224 <span class="comment">//! voir ArrOfDouble::ref_data().&lt;br&gt;(cree un tableau sans structure parallele)</span>
<a name="l00225"></a><a class="code" href="classDoubleVect.html#a4cc7c18df3f14857336aee6ff41f4f49">00225</a> <span class="comment"></span><span class="keywordtype">void</span> <a class="code" href="classDoubleVect.html#a4cc7c18df3f14857336aee6ff41f4f49" title="voir ArrOfDouble::ref_data(). (cree un tableau sans structure parallele)">DoubleVect::ref_data</a>(<span class="keywordtype">double</span>* ptr, <span class="keywordtype">int</span> new_size)
<a name="l00226"></a>00226 {
<a name="l00227"></a>00227   <a class="code" href="classDoubleVect.html#ab3344c5b93fc9fadfd54608897a9989e">md_vector_</a>.<a class="code" href="classMD__Vector.html#aa8b6d80c076feecf7373552d58489e22" title="Detache le pointeur de l&#39;objet pointe et decremente le compteur de ref. Si le compteur est nul...">detach</a>();
<a name="l00228"></a>00228   <a class="code" href="classDoubleVect.html#a4cc7c18df3f14857336aee6ff41f4f49" title="voir ArrOfDouble::ref_data(). (cree un tableau sans structure parallele)">ArrOfDouble::ref_data</a>(ptr, new_size);
<a name="l00229"></a>00229   <a class="code" href="classDoubleVect.html#ae50e9d1185479013c69f3d6e5df6e982">size_reelle_</a> = new_size;
<a name="l00230"></a>00230   <a class="code" href="classDoubleVect.html#adf655214bf244ad33c0b1be4730f1569">line_size_</a> = 1;
<a name="l00231"></a>00231 }
<a name="l00232"></a>00232 
<a name="l00233"></a>00233 <span class="comment">//</span><span class="comment"></span>
<a name="l00234"></a>00234 <span class="comment">//! voir ArrOfDouble::ref_array().&lt;br&gt;(cree un tableau sans structure parallele)</span>
<a name="l00235"></a><a class="code" href="classDoubleVect.html#a88bf18f58757b68e59fbabbb781d217f">00235</a> <span class="comment"></span><span class="keywordtype">void</span> <a class="code" href="classDoubleVect.html#a88bf18f58757b68e59fbabbb781d217f" title="voir ArrOfDouble::ref_array(). (cree un tableau sans structure parallele)">DoubleVect::ref_array</a>(<a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a>&amp; m, <span class="keywordtype">int</span> start, <span class="keywordtype">int</span> new_size)
<a name="l00236"></a>00236 {
<a name="l00237"></a>00237   <a class="code" href="classDoubleVect.html#ab3344c5b93fc9fadfd54608897a9989e">md_vector_</a>.<a class="code" href="classMD__Vector.html#aa8b6d80c076feecf7373552d58489e22" title="Detache le pointeur de l&#39;objet pointe et decremente le compteur de ref. Si le compteur est nul...">detach</a>();
<a name="l00238"></a>00238   <a class="code" href="classDoubleVect.html#a88bf18f58757b68e59fbabbb781d217f" title="voir ArrOfDouble::ref_array(). (cree un tableau sans structure parallele)">ArrOfDouble::ref_array</a>(m, start, new_size);
<a name="l00239"></a>00239   <a class="code" href="classDoubleVect.html#ae50e9d1185479013c69f3d6e5df6e982">size_reelle_</a> = <a class="code" href="classArrOfDouble.html#a3c3b33bea0e88b87315c21ee94bee05f" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>(); <span class="comment">//!&lt; pas size qui peut valoir -1</span>
<a name="l00240"></a>00240 <span class="comment"></span>  <a class="code" href="classDoubleVect.html#adf655214bf244ad33c0b1be4730f1569">line_size_</a> = 1;
<a name="l00241"></a>00241 }
<a name="l00242"></a>00242 
<a name="l00243"></a>00243 <span class="comment">// Precondition: le vecteur doit deja avoir la taille appropriee au nouveau md_vector,</span>
<a name="l00244"></a>00244 <span class="comment">// c&#39;est a dire md_vector...get_nb_items_tot() * line_size_</span>
<a name="l00245"></a>00245 <span class="comment">//</span>
<a name="l00246"></a>00246 <span class="comment">//</span><span class="comment"></span>
<a name="l00247"></a>00247 <span class="comment">//! associe le md_vector au vecteur et initialise l&#39;attribut size_reelle_&lt;br&gt;(voir methode size_reelle())&lt;br&gt;Si md_vector est nul, detache simplement le md_vector existant.</span>
<a name="l00248"></a><a class="code" href="classDoubleVect.html#a63f1c9da5548085b7b2f7a9e54611a0d">00248</a> <span class="comment"></span><span class="keywordtype">void</span> <a class="code" href="classDoubleVect.html#a63f1c9da5548085b7b2f7a9e54611a0d" title="associe le md_vector au vecteur et initialise l&#39;attribut size_reelle_ (voir methode size_reelle()) Si...">DoubleVect::set_md_vector</a>(<span class="keyword">const</span> <a class="code" href="classMD__Vector.html" title=": Cette classe est un DERIV mais l&#39;objet pointe est partage entre plusieurs instances de cette classe...">MD_Vector</a>&amp; md_vector)
<a name="l00249"></a>00249 {
<a name="l00250"></a>00250   <span class="keywordtype">int</span> size_r = <a class="code" href="classArrOfDouble.html#a3c3b33bea0e88b87315c21ee94bee05f" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>();
<a name="l00251"></a>00251   <span class="keywordflow">if</span> (md_vector.<a class="code" href="classMD__Vector.html#a4165c00904b7096274e38fdc7ca340f4">non_nul</a>())
<a name="l00252"></a>00252     {
<a name="l00253"></a>00253       size_r = md_vector.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#ade0ef13d456f8aa11d02f51fd7912145">get_nb_items_reels</a>();
<a name="l00254"></a>00254       <span class="keywordflow">if</span> (size_r &gt;= 0)
<a name="l00255"></a>00255         size_r *= <a class="code" href="classDoubleVect.html#adf655214bf244ad33c0b1be4730f1569">line_size_</a>;
<a name="l00256"></a>00256       <span class="keywordflow">else</span>
<a name="l00257"></a>00257         size_r = -1; <span class="comment">//!&lt; Cas particulier ou la size_reelle ne veut rien dire</span>
<a name="l00258"></a>00258 <span class="comment"></span>      <span class="keywordtype">int</span> size_tot = md_vector.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a27d5ace2aee5ecf1d78accb7b321108d">get_nb_items_tot</a>() * <a class="code" href="classDoubleVect.html#adf655214bf244ad33c0b1be4730f1569">line_size_</a>;
<a name="l00259"></a>00259       <span class="keywordflow">if</span> (size_tot != <a class="code" href="classArrOfDouble.html#a3c3b33bea0e88b87315c21ee94bee05f" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>())
<a name="l00260"></a>00260         {
<a name="l00261"></a>00261           <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Internal error in DoubleVect::set_md_vector(): wrong array size\n&quot;</span>
<a name="l00262"></a>00262                &lt;&lt; <span class="stringliteral">&quot; Needed size = &quot;</span> &lt;&lt; md_vector.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a27d5ace2aee5ecf1d78accb7b321108d">get_nb_items_tot</a>() &lt;&lt; <span class="stringliteral">&quot; x &quot;</span> &lt;&lt; <a class="code" href="classDoubleVect.html#adf655214bf244ad33c0b1be4730f1569">line_size_</a>
<a name="l00263"></a>00263                &lt;&lt; <span class="stringliteral">&quot;\n Actual size = &quot;</span> &lt;&lt; <a class="code" href="classArrOfDouble.html#a3c3b33bea0e88b87315c21ee94bee05f" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
<a name="l00264"></a>00264           <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">exit</a>();
<a name="l00265"></a>00265         }
<a name="l00266"></a>00266       <span class="keywordflow">if</span> (<a class="code" href="classDoubleVect.html#adf655214bf244ad33c0b1be4730f1569">line_size_</a> == 0)
<a name="l00267"></a>00267         {
<a name="l00268"></a>00268           <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Internal error in DoubleVect::set_md_vector():\n&quot;</span>
<a name="l00269"></a>00269                &lt;&lt; <span class="stringliteral">&quot; cannot attach descriptor to empty array (line_size_ is zero)&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
<a name="l00270"></a>00270           <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">exit</a>();
<a name="l00271"></a>00271         }
<a name="l00272"></a>00272     }
<a name="l00273"></a>00273   <a class="code" href="classDoubleVect.html#ae50e9d1185479013c69f3d6e5df6e982">size_reelle_</a> = size_r;
<a name="l00274"></a>00274   <a class="code" href="classDoubleVect.html#ab3344c5b93fc9fadfd54608897a9989e">md_vector_</a> = md_vector;
<a name="l00275"></a>00275 }
<a name="l00276"></a>00276 
<a name="l00277"></a><a class="code" href="classDoubleVect.html#abfebbc2f685ce7bc4b80c720d7da9bf3">00277</a> <span class="keywordtype">void</span> <a class="code" href="classDoubleVect.html#abfebbc2f685ce7bc4b80c720d7da9bf3">DoubleVect::echange_espace_virtuel</a>()
<a name="l00278"></a>00278 {
<a name="l00279"></a>00279   <a class="code" href="classDoubleVect.html#abfebbc2f685ce7bc4b80c720d7da9bf3">MD_Vector_tools::echange_espace_virtuel</a>(*<span class="keyword">this</span>);
<a name="l00280"></a>00280 }
<a name="l00281"></a>00281 <span class="comment"></span>
<a name="l00282"></a>00282 <span class="comment">//! ecriture des valeurs du tableau &quot;raw&quot; sans structure parallele</span>
<a name="l00283"></a><a class="code" href="classDoubleVect.html#ad55e6b8d8409ed1382d7cb83e0d311a8">00283</a> <span class="comment"></span><span class="keywordtype">void</span> <a class="code" href="classDoubleVect.html#ad55e6b8d8409ed1382d7cb83e0d311a8" title="ecriture des valeurs du tableau &quot;raw&quot; sans structure parallele">DoubleVect::ecrit</a>(<a class="code" href="classSortie.html" title="Classe de base des flux de sortie. Elle sait ecrire des types simples&lt;br&gt;(entiers, flottants) et des Ob...">Sortie</a>&amp; os)<span class="keyword"> const</span>
<a name="l00284"></a>00284 <span class="keyword"></span>{
<a name="l00285"></a>00285   <a class="code" href="classDoubleVect.html#a621020bfecb3e6ad09afd47c99e1e48c" title="Ecriture d&#39;un vecteur sequentiel (sans descripteur parallele) Pour l&#39;instant: erreur si presence d&#39;un...">ArrOfDouble::printOn</a>(os);
<a name="l00286"></a>00286   os &lt;&lt; (int)-1 &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>; <span class="comment">//!&lt; le marqueur -1 indique que c&#39;est le nouveau format &quot;ecrit&quot;, sans structure parallele</span>
<a name="l00287"></a>00287 <span class="comment"></span>}
<a name="l00288"></a>00288 
<a name="l00289"></a><a class="code" href="classDoubleVect.html#a4c2467f00f9da109335e46a5da840bdd">00289</a> <span class="keywordtype">void</span> <a class="code" href="classDoubleVect.html#a4c2467f00f9da109335e46a5da840bdd">DoubleVect::jump</a>(<a class="code" href="classEntree.html" title="Classe de definition des operateurs et methodes pour toute lecture dans un flot d&#39;entree (fichier...">Entree</a>&amp; is)
<a name="l00290"></a>00290 {
<a name="l00291"></a>00291   <a class="code" href="classDoubleVect.html#a7db32fb3a0df0e780d0b94a3c955db88" title="lecture d&#39;un tableau pour reprise de calcul. On lit les valeurs &quot;raw&quot;. Attention, si le tableau n&#39;est pas vide, il doit deja avoir la bonne taille et la bonne structure, sinon erreur ! Parameter resize_and_read if the array is sized AND read (by default, yes)">DoubleVect::lit</a>(is, 0 <span class="comment">/* Do not resize&amp;read the array */</span>);
<a name="l00292"></a>00292 }
<a name="l00293"></a>00293 
<a name="l00294"></a>00294 <span class="comment">//</span>
<a name="l00295"></a>00295 <span class="comment">//</span>
<a name="l00296"></a>00296 <span class="comment">//</span><span class="comment"></span>
<a name="l00297"></a>00297 <span class="comment">//! lecture d&#39;un tableau pour reprise de calcul. On lit les valeurs &quot;raw&quot;.&lt;br&gt;Attention, si le tableau n&#39;est pas vide, il doit deja avoir la bonne&lt;br&gt;taille et la bonne structure, sinon erreur !&lt;br&gt;Parameter resize_and_read if the array is sized AND read (by default, yes)</span>
<a name="l00298"></a><a class="code" href="classDoubleVect.html#a7db32fb3a0df0e780d0b94a3c955db88">00298</a> <span class="comment"></span><span class="keywordtype">void</span> <a class="code" href="classDoubleVect.html#a7db32fb3a0df0e780d0b94a3c955db88" title="lecture d&#39;un tableau pour reprise de calcul. On lit les valeurs &quot;raw&quot;. Attention, si le tableau n&#39;est pas vide, il doit deja avoir la bonne taille et la bonne structure, sinon erreur ! Parameter resize_and_read if the array is sized AND read (by default, yes)">DoubleVect::lit</a>(<a class="code" href="classEntree.html" title="Classe de definition des operateurs et methodes pour toute lecture dans un flot d&#39;entree (fichier...">Entree</a>&amp; is, <span class="keywordtype">int</span> resize_and_read)
<a name="l00299"></a>00299 {
<a name="l00300"></a>00300   <span class="keywordtype">int</span> <a class="code" href="Nom_8cpp.html#a0e1ea19fb9fa7881d15d84eff4c090e1">sz</a> = -1;
<a name="l00301"></a>00301   is &gt;&gt; <a class="code" href="Nom_8cpp.html#a0e1ea19fb9fa7881d15d84eff4c090e1">sz</a>;
<a name="l00302"></a>00302   <span class="keywordflow">if</span> (resize_and_read)
<a name="l00303"></a>00303     {
<a name="l00304"></a>00304       <span class="keywordflow">if</span> (<a class="code" href="classArrOfDouble.html#a3c3b33bea0e88b87315c21ee94bee05f" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() == 0 &amp;&amp; (!<a class="code" href="classDoubleVect.html#a0d16d30580c90526e4895388fb44be5d">get_md_vector</a>().non_nul()))
<a name="l00305"></a>00305         {
<a name="l00306"></a>00306           <a class="code" href="classDoubleVect.html#ac55a86eea7b2f06b084b88b16042b67b" title="Change la taille du vecteur (identique a resize_array() pour le traitement des anciennes valeurs et d...">resize</a>(sz, <a class="code" href="classArray__base.html#abee342aa9ac59623c4c782dc9d7877ffaf6ae9ba7eb51c5f298ce693345b3ec68">NOCOPY_NOINIT</a>);
<a name="l00307"></a>00307         }
<a name="l00308"></a>00308       <span class="keywordflow">else</span>
<a name="l00309"></a>00309         {
<a name="l00310"></a>00310           <span class="keywordflow">if</span> (sz != <a class="code" href="classArrOfDouble.html#a3c3b33bea0e88b87315c21ee94bee05f" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>())
<a name="l00311"></a>00311             {
<a name="l00312"></a>00312 <span class="comment">// Si on cherche a relire un tableau de taille inconnue, le tableau doit</span>
<a name="l00313"></a>00313 <span class="comment">// etre reset() a l&#39;entree. On n&#39;aura pas la structure parallele du tableau !</span>
<a name="l00314"></a>00314               <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Error in DoubleVect::lit(Entree &amp; is): array has already a structure with incorrect size&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
<a name="l00315"></a>00315               <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">exit</a>();
<a name="l00316"></a>00316             }
<a name="l00317"></a>00317         }
<a name="l00318"></a>00318       is.<a class="code" href="classEntree.html#aa434f5ceb8169e469613d1f6cd1fd99f" title="methode virtuelle pour lire un tableau d&#39;ints ou reels&lt;br&gt;(le tableau doit avoir la bonne dimension: ...">get</a>(<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>(), sz);
<a name="l00319"></a>00319     }
<a name="l00320"></a>00320   <span class="keywordflow">else</span>
<a name="l00321"></a>00321     {
<a name="l00322"></a>00322 <span class="comment">// May be slow if large chunks are read:</span>
<a name="l00323"></a>00323 <span class="comment">// Double tmp;</span>
<a name="l00324"></a>00324 <span class="comment">// for (int i=0;i&lt;sz;i++) is &gt;&gt; tmp;</span>
<a name="l00325"></a>00325 <span class="comment">// So we bufferize:</span>
<a name="l00326"></a>00326       <span class="keywordtype">int</span> buffer_size = <a class="code" href="Double_8h.html#a2f8edc4561e9744ed4233b205fa7ec32">min</a>(sz,128000);
<a name="l00327"></a>00327       <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a> tmp(buffer_size);
<a name="l00328"></a>00328       <span class="keywordflow">while</span>(sz&gt;buffer_size)
<a name="l00329"></a>00329         {
<a name="l00330"></a>00330           is.<a class="code" href="classEntree.html#aa434f5ceb8169e469613d1f6cd1fd99f" title="methode virtuelle pour lire un tableau d&#39;ints ou reels&lt;br&gt;(le tableau doit avoir la bonne dimension: ...">get</a>(tmp.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>(), buffer_size);
<a name="l00331"></a>00331           sz-=buffer_size;
<a name="l00332"></a>00332         }
<a name="l00333"></a>00333       is.<a class="code" href="classEntree.html#aa434f5ceb8169e469613d1f6cd1fd99f" title="methode virtuelle pour lire un tableau d&#39;ints ou reels&lt;br&gt;(le tableau doit avoir la bonne dimension: ...">get</a>(tmp.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>(), <a class="code" href="Nom_8cpp.html#a0e1ea19fb9fa7881d15d84eff4c090e1">sz</a>);
<a name="l00334"></a>00334     }
<a name="l00335"></a>00335   <span class="keywordtype">int</span> sz_reel = -2;
<a name="l00336"></a>00336   is &gt;&gt; sz_reel;
<a name="l00337"></a>00337   <span class="keywordflow">if</span> (sz_reel &gt;= 0)
<a name="l00338"></a>00338     {
<a name="l00339"></a>00339 <span class="comment">// Lecture de l&#39;ancien format. Ignore les valeurs lues.</span>
<a name="l00340"></a>00340       <span class="keywordtype">int</span> sz_virt;
<a name="l00341"></a>00341       is &gt;&gt; sz_virt;
<a name="l00342"></a>00342       <a class="code" href="classDescStructure.html" title="Sert a relire ancinne structure parallele.">DescStructure</a> toto;
<a name="l00343"></a>00343       is &gt;&gt; toto;
<a name="l00344"></a>00344       <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> it_communs;
<a name="l00345"></a>00345       is &gt;&gt; it_communs;
<a name="l00346"></a>00346       <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> it_communs_tot;
<a name="l00347"></a>00347       is &gt;&gt; it_communs_tot;
<a name="l00348"></a>00348     }
<a name="l00349"></a>00349 }
<a name="l00350"></a>00350 
<a name="l00351"></a>00351 <span class="comment">//</span>
<a name="l00352"></a>00352 <span class="comment">//</span>
<a name="l00353"></a>00353 <span class="comment">//</span><span class="comment"></span>
<a name="l00354"></a>00354 <span class="comment">//! renvoie 1 si meme strucuture parallele et egalite au sens ArrOfDouble&lt;br&gt;(y compris espaces virtuels)&lt;br&gt;BM: faut-il etre aussi strict, comparer uniquement size() elements ?</span>
<a name="l00355"></a><a class="code" href="DoubleVect_8h.html#a0b8b87386007101681576045bdf31c33">00355</a> <span class="comment"></span><span class="keywordtype">int</span> <a class="code" href="Ref__Champ__Face__CoviMAC_8cpp.html#a6f8a92408a5a8f1ef5479e7f3c4c63ec">operator==</a>(<span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; x, <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; y)
<a name="l00356"></a>00356 {
<a name="l00357"></a>00357   <span class="keywordflow">if</span> (!(x.<a class="code" href="classDoubleVect.html#a0d16d30580c90526e4895388fb44be5d">get_md_vector</a>() == y.<a class="code" href="classDoubleVect.html#a0d16d30580c90526e4895388fb44be5d">get_md_vector</a>()))
<a name="l00358"></a>00358     <span class="keywordflow">return</span> 0;
<a name="l00359"></a>00359   <span class="keyword">const</span> <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a>&amp; ax = x;
<a name="l00360"></a>00360   <span class="keyword">const</span> <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a>&amp; ay = y;
<a name="l00361"></a>00361   <span class="keywordflow">return</span> ax == ay;
<a name="l00362"></a>00362 }
<a name="l00363"></a>00363 
<a name="l00364"></a><a class="code" href="DoubleVect_8h.html#aa32e6a91569e34a88c9a2233e2c5ae9a">00364</a> <span class="keywordtype">int</span> <a class="code" href="DoubleVect_8cpp.html#aa32e6a91569e34a88c9a2233e2c5ae9a">operator!=</a>(<span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; x, <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; y)
<a name="l00365"></a>00365 {
<a name="l00366"></a>00366   <span class="keywordflow">return</span> !(x == y);
<a name="l00367"></a>00367 }
<a name="l00368"></a>00368 
<a name="l00369"></a>00369 
<a name="l00370"></a>00370 <span class="preprocessor">#ifdef MICROSOFT</span>
<a name="l00371"></a>00371 <span class="preprocessor"></span><span class="preprocessor">#define HUGE_VALL 1e99</span>
<a name="l00372"></a>00372 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00373"></a>00373 <span class="preprocessor"></span><span class="comment">// INVALID_SCALAR is used to fill arrays when values are not computed</span>
<a name="l00374"></a>00374 <span class="comment">// (virtual space might not be computed by operators).</span>
<a name="l00375"></a>00375 <span class="comment">// The value below probably triggers errors on parallel test cases but</span>
<a name="l00376"></a>00376 <span class="comment">// does not prevent from doing &quot;useless&quot; computations with it.</span>
<a name="l00377"></a>00377 
<a name="l00378"></a>00378 <span class="preprocessor">#ifndef NDEBUG</span>
<a name="l00379"></a><a class="code" href="DoubleVect_8cpp.html#ad4995bc506ff841ba67ce56a43886902">00379</a> <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="DoubleVect_8cpp.html#ad4995bc506ff841ba67ce56a43886902">invalidate_data</a>(<a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; resu, <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a> opt)
<a name="l00380"></a>00380 {
<a name="l00381"></a>00381   <span class="keyword">const</span> <span class="keywordtype">double</span> invalid = -987654.321;
<a name="l00382"></a>00382   <span class="keyword">const</span> <a class="code" href="classMD__Vector.html" title=": Cette classe est un DERIV mais l&#39;objet pointe est partage entre plusieurs instances de cette classe...">MD_Vector</a>&amp; md = resu.<a class="code" href="classDoubleVect.html#a0d16d30580c90526e4895388fb44be5d">get_md_vector</a>();
<a name="l00383"></a>00383   <span class="keyword">const</span> <span class="keywordtype">int</span> line_size = resu.<a class="code" href="classDoubleVect.html#ab02d01cd1bdab66fbd66f9a47cc29e10">line_size</a>();
<a name="l00384"></a>00384   <span class="keywordflow">if</span> (opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caad18680091a9f62247573cb3caa6450b9">VECT_ALL_ITEMS</a> || (!md.<a class="code" href="classMD__Vector.html#a4165c00904b7096274e38fdc7ca340f4">non_nul</a>()))
<a name="l00385"></a>00385     <span class="keywordflow">return</span>; <span class="comment">//!&lt; no invalid values</span>
<a name="l00386"></a>00386 <span class="comment"></span>  assert(opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a> || opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caab47906d8d2e6c20f8ba32e4acb6edbe0">VECT_REAL_ITEMS</a>);
<a name="l00387"></a>00387   <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; items_blocs = (opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a>) ? md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a7f6b6d0b7babfec0cce590cdea5bca53">get_items_to_sum</a>() : md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a99334ac2566d9457c8d4890ba20883ea">get_items_to_compute</a>();
<a name="l00388"></a>00388   <span class="keyword">const</span> <span class="keywordtype">int</span> blocs_size = items_blocs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>();
<a name="l00389"></a>00389   <span class="keywordtype">int</span> i = 0;
<a name="l00390"></a>00390   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> blocs_idx = 0; blocs_idx &lt; blocs_size; blocs_idx += 2)
<a name="l00391"></a>00391     {
<a name="l00392"></a>00392 <span class="comment">// process data until beginning of next bloc, or end of array</span>
<a name="l00393"></a>00393       <span class="keyword">const</span> <span class="keywordtype">int</span> bloc_end = line_size * items_blocs[blocs_idx];
<a name="l00394"></a>00394       <span class="keywordtype">double</span> *ptr = resu.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() + i;
<a name="l00395"></a>00395       <span class="keywordflow">for</span> (; i &lt; bloc_end; i++)
<a name="l00396"></a>00396         *(ptr++) = invalid;
<a name="l00397"></a>00397       i = items_blocs[blocs_idx+1] * line_size;
<a name="l00398"></a>00398     }
<a name="l00399"></a>00399 <span class="comment">// Process until end of vector</span>
<a name="l00400"></a>00400   <span class="keyword">const</span> <span class="keywordtype">int</span> bloc_end = resu.<a class="code" href="classArrOfDouble.html#a3c3b33bea0e88b87315c21ee94bee05f" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>();
<a name="l00401"></a>00401   <span class="keywordtype">double</span> *ptr = resu.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() + i;
<a name="l00402"></a>00402   <span class="keywordflow">for</span> (; i &lt; bloc_end; i++)
<a name="l00403"></a>00403     *(ptr++) = invalid;
<a name="l00404"></a>00404 }
<a name="l00405"></a>00405 <span class="preprocessor">#endif</span>
<a name="l00406"></a>00406 <span class="preprocessor"></span>
<a name="l00407"></a>00407 
<a name="l00408"></a>00408 
<a name="l00409"></a>00409 
<a name="l00410"></a>00410 <span class="comment">//</span>
<a name="l00411"></a>00411 <span class="comment">//</span><span class="comment"></span>
<a name="l00412"></a>00412 <span class="comment">//! Renvoie la somme des x[i]*y[i] pour les items sequentiels sur ce processeur.&lt;br&gt;(tous les items si pas de structure parallele, sinon voir MD_Vector_base::get_items_to_sum()</span>
<a name="l00413"></a>00413 <span class="comment"></span>
<a name="l00414"></a>00414 
<a name="l00415"></a>00415 
<a name="l00416"></a>00416 
<a name="l00417"></a>00417 
<a name="l00418"></a>00418 
<a name="l00419"></a><a class="code" href="DoubleVect_8h.html#a9fb932ffd4c01cb57ca6935c31a7b89c">00419</a> <span class="keywordtype">double</span> <a class="code" href="DoubleVect_8cpp.html#acbe5711639fbfe2e85d5f87bf81f851a" title="Renvoie la somme des x[i]*y[i] pour les items sequentiels sur ce processeur. (tous les items si pas d...">local_prodscal</a>(<span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; vx, <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; vy)
<a name="l00420"></a>00420 {
<a name="l00421"></a>00421   <span class="keywordtype">double</span> sum = 0;
<a name="l00422"></a>00422 <span class="comment">// Master vect donne la structure de reference, les autres vecteurs</span>
<a name="l00423"></a>00423 <span class="comment">// doivent avoir la meme structure.</span>
<a name="l00424"></a>00424   <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; master_vect = vx;
<a name="l00425"></a>00425   <span class="keywordtype">int</span> line_size = master_vect.<a class="code" href="classDoubleVect.html#ab02d01cd1bdab66fbd66f9a47cc29e10">line_size</a>();
<a name="l00426"></a>00426   <span class="keyword">const</span> <a class="code" href="classMD__Vector.html" title=": Cette classe est un DERIV mais l&#39;objet pointe est partage entre plusieurs instances de cette classe...">MD_Vector</a>&amp; md = master_vect.<a class="code" href="classDoubleVect.html#a0d16d30580c90526e4895388fb44be5d">get_md_vector</a>();
<a name="l00427"></a>00427   <span class="keyword">const</span> <span class="keywordtype">int</span> vect_size_tot = master_vect.<a class="code" href="classDoubleVect.html#ad2d21b364e1c6559771970596a25c006" title="Identique a size_array()">size_totale</a>();
<a name="l00428"></a>00428   assert(vx.<a class="code" href="classDoubleVect.html#ab02d01cd1bdab66fbd66f9a47cc29e10">line_size</a>() == line_size);
<a name="l00429"></a>00429   assert(vx.<a class="code" href="classDoubleVect.html#ad2d21b364e1c6559771970596a25c006" title="Identique a size_array()">size_totale</a>() == vect_size_tot); <span class="comment">//!&lt; this test is necessary if md is null</span>
<a name="l00430"></a>00430 <span class="comment"></span>  assert(vx.<a class="code" href="classDoubleVect.html#a0d16d30580c90526e4895388fb44be5d">get_md_vector</a>() == md);
<a name="l00431"></a>00431   assert(vy.<a class="code" href="classDoubleVect.html#ab02d01cd1bdab66fbd66f9a47cc29e10">line_size</a>() == line_size);
<a name="l00432"></a>00432   assert(vy.<a class="code" href="classDoubleVect.html#ad2d21b364e1c6559771970596a25c006" title="Identique a size_array()">size_totale</a>() == vect_size_tot); <span class="comment">//!&lt; this test is necessary if md is null</span>
<a name="l00433"></a>00433 <span class="comment"></span>  assert(vy.<a class="code" href="classDoubleVect.html#a0d16d30580c90526e4895388fb44be5d">get_md_vector</a>() == md);
<a name="l00434"></a>00434 <span class="comment">// Determine blocs of data to process, depending on &quot; VECT_SEQUENTIAL_ITEMS&quot;</span>
<a name="l00435"></a>00435   <span class="keywordtype">int</span> nblocs_left = 1;
<a name="l00436"></a>00436   <span class="keywordtype">int</span> one_bloc[2];
<a name="l00437"></a>00437   <span class="keyword">const</span> <span class="keywordtype">int</span> *bloc_ptr;
<a name="l00438"></a>00438   <span class="keywordflow">if</span> ( <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a> != <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caad18680091a9f62247573cb3caa6450b9">VECT_ALL_ITEMS</a> &amp;&amp; md.<a class="code" href="classMD__Vector.html#a4165c00904b7096274e38fdc7ca340f4">non_nul</a>())
<a name="l00439"></a>00439     {
<a name="l00440"></a>00440       assert( <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a> == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a> ||  <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a> == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caab47906d8d2e6c20f8ba32e4acb6edbe0">VECT_REAL_ITEMS</a>);
<a name="l00441"></a>00441       <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; items_blocs = ( <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a> == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a>) ? md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a7f6b6d0b7babfec0cce590cdea5bca53">get_items_to_sum</a>() : md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a99334ac2566d9457c8d4890ba20883ea">get_items_to_compute</a>();
<a name="l00442"></a>00442       assert(items_blocs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() % 2 == 0);
<a name="l00443"></a>00443       nblocs_left = items_blocs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() &gt;&gt; 1;
<a name="l00444"></a>00444       bloc_ptr = items_blocs.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
<a name="l00445"></a>00445     }
<a name="l00446"></a>00446   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (vect_size_tot &gt; 0)
<a name="l00447"></a>00447     {
<a name="l00448"></a>00448 <span class="comment">// attention, si vect_size_tot est nul, line_size a le droit d&#39;etre nul</span>
<a name="l00449"></a>00449 <span class="comment">// Compute all data, in the vector (including virtual data), build a big bloc:</span>
<a name="l00450"></a>00450       nblocs_left = 1;
<a name="l00451"></a>00451       bloc_ptr = one_bloc;
<a name="l00452"></a>00452       one_bloc[0] = 0;
<a name="l00453"></a>00453       one_bloc[1] = vect_size_tot / line_size;
<a name="l00454"></a>00454     }
<a name="l00455"></a>00455   <span class="keywordflow">else</span>
<a name="l00456"></a>00456     {
<a name="l00457"></a>00457 <span class="comment">// raccourci pour les tableaux vides (evite le cas particulier line_size == 0)</span>
<a name="l00458"></a>00458       <span class="keywordflow">return</span>  sum;
<a name="l00459"></a>00459     }
<a name="l00460"></a>00460   <span class="keyword">const</span> <span class="keywordtype">double</span> *x_base = vx.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
<a name="l00461"></a>00461   <span class="keyword">const</span> <span class="keywordtype">double</span> *y_base = vy.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
<a name="l00462"></a>00462   <span class="keywordflow">for</span> (; nblocs_left; nblocs_left--)
<a name="l00463"></a>00463     {
<a name="l00464"></a>00464 <span class="comment">// Get index of next bloc start:</span>
<a name="l00465"></a>00465       <span class="keyword">const</span> <span class="keywordtype">int</span> begin_bloc = (*(bloc_ptr++)) * line_size;
<a name="l00466"></a>00466       <span class="keyword">const</span> <span class="keywordtype">int</span> end_bloc = (*(bloc_ptr++)) * line_size;
<a name="l00467"></a>00467       assert(begin_bloc &gt;= 0 &amp;&amp; end_bloc &lt;= vect_size_tot &amp;&amp; end_bloc &gt;= begin_bloc);
<a name="l00468"></a>00468       <span class="keyword">const</span> <span class="keywordtype">double</span>* x_ptr = x_base + begin_bloc;
<a name="l00469"></a>00469       <span class="keyword">const</span> <span class="keywordtype">double</span>* y_ptr = y_base + begin_bloc;
<a name="l00470"></a>00470       <span class="keywordtype">int</span> count = end_bloc - begin_bloc;
<a name="l00471"></a>00471       <span class="keywordflow">for</span> (; count; count--)
<a name="l00472"></a>00472         {
<a name="l00473"></a>00473           <span class="keyword">const</span> <span class="keywordtype">double</span> x = *x_ptr;
<a name="l00474"></a>00474           <span class="keyword">const</span> <span class="keywordtype">double</span> y = *(y_ptr++);
<a name="l00475"></a>00475           sum += x * y;
<a name="l00476"></a>00476           x_ptr++;
<a name="l00477"></a>00477         }
<a name="l00478"></a>00478     }
<a name="l00479"></a>00479   <span class="keywordflow">return</span>  sum;
<a name="l00480"></a>00480 }
<a name="l00481"></a><a class="code" href="DoubleVect_8h.html#aec1f3fbee9c49f94ac517feea6a8d6ed">00481</a> <span class="keywordtype">double</span> <a class="code" href="DoubleVect_8cpp.html#aec1f3fbee9c49f94ac517feea6a8d6ed">local_carre_norme_vect</a>(<span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; vx)
<a name="l00482"></a>00482 {
<a name="l00483"></a>00483   <span class="keywordtype">double</span> sum = 0;
<a name="l00484"></a>00484 <span class="comment">// Master vect donne la structure de reference, les autres vecteurs</span>
<a name="l00485"></a>00485 <span class="comment">// doivent avoir la meme structure.</span>
<a name="l00486"></a>00486   <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; master_vect = vx;
<a name="l00487"></a>00487   <span class="keywordtype">int</span> line_size = master_vect.<a class="code" href="classDoubleVect.html#ab02d01cd1bdab66fbd66f9a47cc29e10">line_size</a>();
<a name="l00488"></a>00488   <span class="keyword">const</span> <a class="code" href="classMD__Vector.html" title=": Cette classe est un DERIV mais l&#39;objet pointe est partage entre plusieurs instances de cette classe...">MD_Vector</a>&amp; md = master_vect.<a class="code" href="classDoubleVect.html#a0d16d30580c90526e4895388fb44be5d">get_md_vector</a>();
<a name="l00489"></a>00489   <span class="keyword">const</span> <span class="keywordtype">int</span> vect_size_tot = master_vect.<a class="code" href="classDoubleVect.html#ad2d21b364e1c6559771970596a25c006" title="Identique a size_array()">size_totale</a>();
<a name="l00490"></a>00490   assert(vx.<a class="code" href="classDoubleVect.html#ab02d01cd1bdab66fbd66f9a47cc29e10">line_size</a>() == line_size);
<a name="l00491"></a>00491   assert(vx.<a class="code" href="classDoubleVect.html#ad2d21b364e1c6559771970596a25c006" title="Identique a size_array()">size_totale</a>() == vect_size_tot); <span class="comment">//!&lt; this test is necessary if md is null</span>
<a name="l00492"></a>00492 <span class="comment"></span>  assert(vx.<a class="code" href="classDoubleVect.html#a0d16d30580c90526e4895388fb44be5d">get_md_vector</a>() == md);
<a name="l00493"></a>00493 <span class="comment">// Determine blocs of data to process, depending on &quot; VECT_SEQUENTIAL_ITEMS&quot;</span>
<a name="l00494"></a>00494   <span class="keywordtype">int</span> nblocs_left = 1;
<a name="l00495"></a>00495   <span class="keywordtype">int</span> one_bloc[2];
<a name="l00496"></a>00496   <span class="keyword">const</span> <span class="keywordtype">int</span> *bloc_ptr;
<a name="l00497"></a>00497   <span class="keywordflow">if</span> ( <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a> != <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caad18680091a9f62247573cb3caa6450b9">VECT_ALL_ITEMS</a> &amp;&amp; md.<a class="code" href="classMD__Vector.html#a4165c00904b7096274e38fdc7ca340f4">non_nul</a>())
<a name="l00498"></a>00498     {
<a name="l00499"></a>00499       assert( <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a> == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a> ||  <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a> == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caab47906d8d2e6c20f8ba32e4acb6edbe0">VECT_REAL_ITEMS</a>);
<a name="l00500"></a>00500       <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; items_blocs = ( <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a> == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a>) ? md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a7f6b6d0b7babfec0cce590cdea5bca53">get_items_to_sum</a>() : md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a99334ac2566d9457c8d4890ba20883ea">get_items_to_compute</a>();
<a name="l00501"></a>00501       assert(items_blocs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() % 2 == 0);
<a name="l00502"></a>00502       nblocs_left = items_blocs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() &gt;&gt; 1;
<a name="l00503"></a>00503       bloc_ptr = items_blocs.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
<a name="l00504"></a>00504     }
<a name="l00505"></a>00505   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (vect_size_tot &gt; 0)
<a name="l00506"></a>00506     {
<a name="l00507"></a>00507 <span class="comment">// attention, si vect_size_tot est nul, line_size a le droit d&#39;etre nul</span>
<a name="l00508"></a>00508 <span class="comment">// Compute all data, in the vector (including virtual data), build a big bloc:</span>
<a name="l00509"></a>00509       nblocs_left = 1;
<a name="l00510"></a>00510       bloc_ptr = one_bloc;
<a name="l00511"></a>00511       one_bloc[0] = 0;
<a name="l00512"></a>00512       one_bloc[1] = vect_size_tot / line_size;
<a name="l00513"></a>00513     }
<a name="l00514"></a>00514   <span class="keywordflow">else</span>
<a name="l00515"></a>00515     {
<a name="l00516"></a>00516 <span class="comment">// raccourci pour les tableaux vides (evite le cas particulier line_size == 0)</span>
<a name="l00517"></a>00517       <span class="keywordflow">return</span>  sum;
<a name="l00518"></a>00518     }
<a name="l00519"></a>00519   <span class="keyword">const</span> <span class="keywordtype">double</span> *x_base = vx.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
<a name="l00520"></a>00520   <span class="keywordflow">for</span> (; nblocs_left; nblocs_left--)
<a name="l00521"></a>00521     {
<a name="l00522"></a>00522 <span class="comment">// Get index of next bloc start:</span>
<a name="l00523"></a>00523       <span class="keyword">const</span> <span class="keywordtype">int</span> begin_bloc = (*(bloc_ptr++)) * line_size;
<a name="l00524"></a>00524       <span class="keyword">const</span> <span class="keywordtype">int</span> end_bloc = (*(bloc_ptr++)) * line_size;
<a name="l00525"></a>00525       assert(begin_bloc &gt;= 0 &amp;&amp; end_bloc &lt;= vect_size_tot &amp;&amp; end_bloc &gt;= begin_bloc);
<a name="l00526"></a>00526       <span class="keyword">const</span> <span class="keywordtype">double</span>* x_ptr = x_base + begin_bloc;
<a name="l00527"></a>00527       <span class="keywordtype">int</span> count = end_bloc - begin_bloc;
<a name="l00528"></a>00528       <span class="keywordflow">for</span> (; count; count--)
<a name="l00529"></a>00529         {
<a name="l00530"></a>00530           <span class="keyword">const</span> <span class="keywordtype">double</span> x = *x_ptr;
<a name="l00531"></a>00531           sum += x * x;
<a name="l00532"></a>00532           x_ptr++;
<a name="l00533"></a>00533         }
<a name="l00534"></a>00534     }
<a name="l00535"></a>00535   <span class="keywordflow">return</span>  sum;
<a name="l00536"></a>00536 }
<a name="l00537"></a><a class="code" href="DoubleVect_8h.html#ab745de99f0f45fba28e5784a287cda44">00537</a> <span class="keywordtype">double</span> <a class="code" href="DoubleVect_8cpp.html#aab5110c88e5f7519eb6b7e603130b702">mp_carre_norme_vect</a>(<span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; vx)
<a name="l00538"></a>00538 {
<a name="l00539"></a>00539   <span class="keywordflow">return</span> <a class="code" href="classProcess.html#a7d23bc1ef94b3f0623fbc79d034c27fd" title="Calcule la somme de x sur tous les processeurs du groupe courant. Voir aussi mp_max()">Process::mp_sum</a>(<a class="code" href="DoubleVect_8cpp.html#aec1f3fbee9c49f94ac517feea6a8d6ed">local_carre_norme_vect</a>(vx));
<a name="l00540"></a>00540 }
<a name="l00541"></a><a class="code" href="DoubleVect_8cpp.html#aaaede7053cdab4cd6f12f0fa2c065e37">00541</a> <span class="keywordtype">double</span> <a class="code" href="DoubleVect_8cpp.html#aaaede7053cdab4cd6f12f0fa2c065e37">local_somme_vect</a>(<span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; vx)
<a name="l00542"></a>00542 {
<a name="l00543"></a>00543   <span class="keywordtype">double</span> sum = 0;
<a name="l00544"></a>00544 <span class="comment">// Master vect donne la structure de reference, les autres vecteurs</span>
<a name="l00545"></a>00545 <span class="comment">// doivent avoir la meme structure.</span>
<a name="l00546"></a>00546   <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; master_vect = vx;
<a name="l00547"></a>00547   <span class="keywordtype">int</span> line_size = master_vect.<a class="code" href="classDoubleVect.html#ab02d01cd1bdab66fbd66f9a47cc29e10">line_size</a>();
<a name="l00548"></a>00548   <span class="keyword">const</span> <a class="code" href="classMD__Vector.html" title=": Cette classe est un DERIV mais l&#39;objet pointe est partage entre plusieurs instances de cette classe...">MD_Vector</a>&amp; md = master_vect.<a class="code" href="classDoubleVect.html#a0d16d30580c90526e4895388fb44be5d">get_md_vector</a>();
<a name="l00549"></a>00549   <span class="keyword">const</span> <span class="keywordtype">int</span> vect_size_tot = master_vect.<a class="code" href="classDoubleVect.html#ad2d21b364e1c6559771970596a25c006" title="Identique a size_array()">size_totale</a>();
<a name="l00550"></a>00550   assert(vx.<a class="code" href="classDoubleVect.html#ab02d01cd1bdab66fbd66f9a47cc29e10">line_size</a>() == line_size);
<a name="l00551"></a>00551   assert(vx.<a class="code" href="classDoubleVect.html#ad2d21b364e1c6559771970596a25c006" title="Identique a size_array()">size_totale</a>() == vect_size_tot); <span class="comment">//!&lt; this test is necessary if md is null</span>
<a name="l00552"></a>00552 <span class="comment"></span>  assert(vx.<a class="code" href="classDoubleVect.html#a0d16d30580c90526e4895388fb44be5d">get_md_vector</a>() == md);
<a name="l00553"></a>00553 <span class="comment">// Determine blocs of data to process, depending on &quot; VECT_SEQUENTIAL_ITEMS&quot;</span>
<a name="l00554"></a>00554   <span class="keywordtype">int</span> nblocs_left = 1;
<a name="l00555"></a>00555   <span class="keywordtype">int</span> one_bloc[2];
<a name="l00556"></a>00556   <span class="keyword">const</span> <span class="keywordtype">int</span> *bloc_ptr;
<a name="l00557"></a>00557   <span class="keywordflow">if</span> ( <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a> != <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caad18680091a9f62247573cb3caa6450b9">VECT_ALL_ITEMS</a> &amp;&amp; md.<a class="code" href="classMD__Vector.html#a4165c00904b7096274e38fdc7ca340f4">non_nul</a>())
<a name="l00558"></a>00558     {
<a name="l00559"></a>00559       assert( <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a> == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a> ||  <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a> == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caab47906d8d2e6c20f8ba32e4acb6edbe0">VECT_REAL_ITEMS</a>);
<a name="l00560"></a>00560       <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; items_blocs = ( <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a> == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a>) ? md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a7f6b6d0b7babfec0cce590cdea5bca53">get_items_to_sum</a>() : md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a99334ac2566d9457c8d4890ba20883ea">get_items_to_compute</a>();
<a name="l00561"></a>00561       assert(items_blocs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() % 2 == 0);
<a name="l00562"></a>00562       nblocs_left = items_blocs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() &gt;&gt; 1;
<a name="l00563"></a>00563       bloc_ptr = items_blocs.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
<a name="l00564"></a>00564     }
<a name="l00565"></a>00565   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (vect_size_tot &gt; 0)
<a name="l00566"></a>00566     {
<a name="l00567"></a>00567 <span class="comment">// attention, si vect_size_tot est nul, line_size a le droit d&#39;etre nul</span>
<a name="l00568"></a>00568 <span class="comment">// Compute all data, in the vector (including virtual data), build a big bloc:</span>
<a name="l00569"></a>00569       nblocs_left = 1;
<a name="l00570"></a>00570       bloc_ptr = one_bloc;
<a name="l00571"></a>00571       one_bloc[0] = 0;
<a name="l00572"></a>00572       one_bloc[1] = vect_size_tot / line_size;
<a name="l00573"></a>00573     }
<a name="l00574"></a>00574   <span class="keywordflow">else</span>
<a name="l00575"></a>00575     {
<a name="l00576"></a>00576 <span class="comment">// raccourci pour les tableaux vides (evite le cas particulier line_size == 0)</span>
<a name="l00577"></a>00577       <span class="keywordflow">return</span>  sum;
<a name="l00578"></a>00578     }
<a name="l00579"></a>00579   <span class="keyword">const</span> <span class="keywordtype">double</span> *x_base = vx.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
<a name="l00580"></a>00580   <span class="keywordflow">for</span> (; nblocs_left; nblocs_left--)
<a name="l00581"></a>00581     {
<a name="l00582"></a>00582 <span class="comment">// Get index of next bloc start:</span>
<a name="l00583"></a>00583       <span class="keyword">const</span> <span class="keywordtype">int</span> begin_bloc = (*(bloc_ptr++)) * line_size;
<a name="l00584"></a>00584       <span class="keyword">const</span> <span class="keywordtype">int</span> end_bloc = (*(bloc_ptr++)) * line_size;
<a name="l00585"></a>00585       assert(begin_bloc &gt;= 0 &amp;&amp; end_bloc &lt;= vect_size_tot &amp;&amp; end_bloc &gt;= begin_bloc);
<a name="l00586"></a>00586       <span class="keyword">const</span> <span class="keywordtype">double</span>* x_ptr = x_base + begin_bloc;
<a name="l00587"></a>00587       <span class="keywordtype">int</span> count = end_bloc - begin_bloc;
<a name="l00588"></a>00588       <span class="keywordflow">for</span> (; count; count--)
<a name="l00589"></a>00589         {
<a name="l00590"></a>00590           <span class="keyword">const</span> <span class="keywordtype">double</span> x = *x_ptr;
<a name="l00591"></a>00591           sum += x;
<a name="l00592"></a>00592           x_ptr++;
<a name="l00593"></a>00593         }
<a name="l00594"></a>00594     }
<a name="l00595"></a>00595   <span class="keywordflow">return</span>  sum;
<a name="l00596"></a>00596 }
<a name="l00597"></a><a class="code" href="DoubleVect_8h.html#a9a8060a4026204e1dacc2f95cc10f9e4">00597</a> <span class="keywordtype">double</span> <a class="code" href="DoubleVect_8cpp.html#a07dd5e25d47ad3892ae0fa4e997ed011">mp_somme_vect</a>(<span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; vx)
<a name="l00598"></a>00598 {
<a name="l00599"></a>00599   <span class="keywordtype">double</span> x = <a class="code" href="DoubleVect_8cpp.html#aaaede7053cdab4cd6f12f0fa2c065e37">local_somme_vect</a>(vx);
<a name="l00600"></a>00600   <span class="keywordtype">double</span> y = <a class="code" href="classProcess.html#a7d23bc1ef94b3f0623fbc79d034c27fd" title="Calcule la somme de x sur tous les processeurs du groupe courant. Voir aussi mp_max()">Process::mp_sum</a>(x);
<a name="l00601"></a>00601   <span class="keywordflow">return</span> y;
<a name="l00602"></a>00602 }
<a name="l00603"></a><a class="code" href="DoubleVect_8h.html#a5a2e78375fa44b86801064bc642ebe0b">00603</a> <span class="keywordtype">int</span> <a class="code" href="DoubleVect_8cpp.html#a17e2ea0942d9a65192b220f00d974442">local_imin_vect</a>(<span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; vx, <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a> opt)
<a name="l00604"></a>00604 {
<a name="l00605"></a>00605   <span class="keywordtype">double</span> min_val = HUGE_VALL;
<a name="l00606"></a>00606   <span class="keywordtype">int</span> i_min = -1;
<a name="l00607"></a>00607 <span class="comment">// Master vect donne la structure de reference, les autres vecteurs</span>
<a name="l00608"></a>00608 <span class="comment">// doivent avoir la meme structure.</span>
<a name="l00609"></a>00609   <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; master_vect = vx;
<a name="l00610"></a>00610   <span class="keywordtype">int</span> line_size = master_vect.<a class="code" href="classDoubleVect.html#ab02d01cd1bdab66fbd66f9a47cc29e10">line_size</a>();
<a name="l00611"></a>00611   <span class="keyword">const</span> <a class="code" href="classMD__Vector.html" title=": Cette classe est un DERIV mais l&#39;objet pointe est partage entre plusieurs instances de cette classe...">MD_Vector</a>&amp; md = master_vect.<a class="code" href="classDoubleVect.html#a0d16d30580c90526e4895388fb44be5d">get_md_vector</a>();
<a name="l00612"></a>00612   <span class="keyword">const</span> <span class="keywordtype">int</span> vect_size_tot = master_vect.<a class="code" href="classDoubleVect.html#ad2d21b364e1c6559771970596a25c006" title="Identique a size_array()">size_totale</a>();
<a name="l00613"></a>00613   assert(vx.<a class="code" href="classDoubleVect.html#ab02d01cd1bdab66fbd66f9a47cc29e10">line_size</a>() == line_size);
<a name="l00614"></a>00614   assert(vx.<a class="code" href="classDoubleVect.html#ad2d21b364e1c6559771970596a25c006" title="Identique a size_array()">size_totale</a>() == vect_size_tot); <span class="comment">//!&lt; this test is necessary if md is null</span>
<a name="l00615"></a>00615 <span class="comment"></span>  assert(vx.<a class="code" href="classDoubleVect.html#a0d16d30580c90526e4895388fb44be5d">get_md_vector</a>() == md);
<a name="l00616"></a>00616 <span class="comment">// Determine blocs of data to process, depending on &quot; opt&quot;</span>
<a name="l00617"></a>00617   <span class="keywordtype">int</span> nblocs_left = 1;
<a name="l00618"></a>00618   <span class="keywordtype">int</span> one_bloc[2];
<a name="l00619"></a>00619   <span class="keyword">const</span> <span class="keywordtype">int</span> *bloc_ptr;
<a name="l00620"></a>00620   <span class="keywordflow">if</span> ( opt != <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caad18680091a9f62247573cb3caa6450b9">VECT_ALL_ITEMS</a> &amp;&amp; md.<a class="code" href="classMD__Vector.html#a4165c00904b7096274e38fdc7ca340f4">non_nul</a>())
<a name="l00621"></a>00621     {
<a name="l00622"></a>00622       assert( opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a> ||  opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caab47906d8d2e6c20f8ba32e4acb6edbe0">VECT_REAL_ITEMS</a>);
<a name="l00623"></a>00623       <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; items_blocs = ( opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a>) ? md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a7f6b6d0b7babfec0cce590cdea5bca53">get_items_to_sum</a>() : md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a99334ac2566d9457c8d4890ba20883ea">get_items_to_compute</a>();
<a name="l00624"></a>00624       assert(items_blocs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() % 2 == 0);
<a name="l00625"></a>00625       nblocs_left = items_blocs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() &gt;&gt; 1;
<a name="l00626"></a>00626       bloc_ptr = items_blocs.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
<a name="l00627"></a>00627     }
<a name="l00628"></a>00628   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (vect_size_tot &gt; 0)
<a name="l00629"></a>00629     {
<a name="l00630"></a>00630 <span class="comment">// attention, si vect_size_tot est nul, line_size a le droit d&#39;etre nul</span>
<a name="l00631"></a>00631 <span class="comment">// Compute all data, in the vector (including virtual data), build a big bloc:</span>
<a name="l00632"></a>00632       nblocs_left = 1;
<a name="l00633"></a>00633       bloc_ptr = one_bloc;
<a name="l00634"></a>00634       one_bloc[0] = 0;
<a name="l00635"></a>00635       one_bloc[1] = vect_size_tot / line_size;
<a name="l00636"></a>00636     }
<a name="l00637"></a>00637   <span class="keywordflow">else</span>
<a name="l00638"></a>00638     {
<a name="l00639"></a>00639 <span class="comment">// raccourci pour les tableaux vides (evite le cas particulier line_size == 0)</span>
<a name="l00640"></a>00640       <span class="keywordflow">return</span>  i_min;
<a name="l00641"></a>00641     }
<a name="l00642"></a>00642   <span class="keyword">const</span> <span class="keywordtype">double</span> *x_base = vx.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
<a name="l00643"></a>00643   <span class="keywordflow">for</span> (; nblocs_left; nblocs_left--)
<a name="l00644"></a>00644     {
<a name="l00645"></a>00645 <span class="comment">// Get index of next bloc start:</span>
<a name="l00646"></a>00646       <span class="keyword">const</span> <span class="keywordtype">int</span> begin_bloc = (*(bloc_ptr++)) * line_size;
<a name="l00647"></a>00647       <span class="keyword">const</span> <span class="keywordtype">int</span> end_bloc = (*(bloc_ptr++)) * line_size;
<a name="l00648"></a>00648       assert(begin_bloc &gt;= 0 &amp;&amp; end_bloc &lt;= vect_size_tot &amp;&amp; end_bloc &gt;= begin_bloc);
<a name="l00649"></a>00649       <span class="keyword">const</span> <span class="keywordtype">double</span>* x_ptr = x_base + begin_bloc;
<a name="l00650"></a>00650       <span class="keywordtype">int</span> count = end_bloc - begin_bloc;
<a name="l00651"></a>00651       <span class="keywordflow">for</span> (; count; count--)
<a name="l00652"></a>00652         {
<a name="l00653"></a>00653           <span class="keyword">const</span> <span class="keywordtype">double</span> x = *x_ptr;
<a name="l00654"></a>00654           <span class="keywordflow">if</span> (x &lt; min_val) { i_min = x_ptr - x_base; min_val = x; }
<a name="l00655"></a>00655           x_ptr++;
<a name="l00656"></a>00656         }
<a name="l00657"></a>00657     }
<a name="l00658"></a>00658   <span class="keywordflow">return</span>  i_min;
<a name="l00659"></a>00659 }
<a name="l00660"></a><a class="code" href="DoubleVect_8h.html#a6572d895c9b57a034d65d752f307c2be">00660</a> <span class="keywordtype">double</span> <a class="code" href="DoubleVect_8cpp.html#a17be200c713a7031ede99b28391daa52">local_min_vect</a>(<span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; vx, <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a> opt)
<a name="l00661"></a>00661 {
<a name="l00662"></a>00662   <span class="keywordtype">double</span> min_val = HUGE_VALL;
<a name="l00663"></a>00663 <span class="comment">// Master vect donne la structure de reference, les autres vecteurs</span>
<a name="l00664"></a>00664 <span class="comment">// doivent avoir la meme structure.</span>
<a name="l00665"></a>00665   <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; master_vect = vx;
<a name="l00666"></a>00666   <span class="keywordtype">int</span> line_size = master_vect.<a class="code" href="classDoubleVect.html#ab02d01cd1bdab66fbd66f9a47cc29e10">line_size</a>();
<a name="l00667"></a>00667   <span class="keyword">const</span> <a class="code" href="classMD__Vector.html" title=": Cette classe est un DERIV mais l&#39;objet pointe est partage entre plusieurs instances de cette classe...">MD_Vector</a>&amp; md = master_vect.<a class="code" href="classDoubleVect.html#a0d16d30580c90526e4895388fb44be5d">get_md_vector</a>();
<a name="l00668"></a>00668   <span class="keyword">const</span> <span class="keywordtype">int</span> vect_size_tot = master_vect.<a class="code" href="classDoubleVect.html#ad2d21b364e1c6559771970596a25c006" title="Identique a size_array()">size_totale</a>();
<a name="l00669"></a>00669   assert(vx.<a class="code" href="classDoubleVect.html#ab02d01cd1bdab66fbd66f9a47cc29e10">line_size</a>() == line_size);
<a name="l00670"></a>00670   assert(vx.<a class="code" href="classDoubleVect.html#ad2d21b364e1c6559771970596a25c006" title="Identique a size_array()">size_totale</a>() == vect_size_tot); <span class="comment">//!&lt; this test is necessary if md is null</span>
<a name="l00671"></a>00671 <span class="comment"></span>  assert(vx.<a class="code" href="classDoubleVect.html#a0d16d30580c90526e4895388fb44be5d">get_md_vector</a>() == md);
<a name="l00672"></a>00672 <span class="comment">// Determine blocs of data to process, depending on &quot; opt&quot;</span>
<a name="l00673"></a>00673   <span class="keywordtype">int</span> nblocs_left = 1;
<a name="l00674"></a>00674   <span class="keywordtype">int</span> one_bloc[2];
<a name="l00675"></a>00675   <span class="keyword">const</span> <span class="keywordtype">int</span> *bloc_ptr;
<a name="l00676"></a>00676   <span class="keywordflow">if</span> ( opt != <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caad18680091a9f62247573cb3caa6450b9">VECT_ALL_ITEMS</a> &amp;&amp; md.<a class="code" href="classMD__Vector.html#a4165c00904b7096274e38fdc7ca340f4">non_nul</a>())
<a name="l00677"></a>00677     {
<a name="l00678"></a>00678       assert( opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a> ||  opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caab47906d8d2e6c20f8ba32e4acb6edbe0">VECT_REAL_ITEMS</a>);
<a name="l00679"></a>00679       <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; items_blocs = ( opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a>) ? md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a7f6b6d0b7babfec0cce590cdea5bca53">get_items_to_sum</a>() : md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a99334ac2566d9457c8d4890ba20883ea">get_items_to_compute</a>();
<a name="l00680"></a>00680       assert(items_blocs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() % 2 == 0);
<a name="l00681"></a>00681       nblocs_left = items_blocs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() &gt;&gt; 1;
<a name="l00682"></a>00682       bloc_ptr = items_blocs.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
<a name="l00683"></a>00683     }
<a name="l00684"></a>00684   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (vect_size_tot &gt; 0)
<a name="l00685"></a>00685     {
<a name="l00686"></a>00686 <span class="comment">// attention, si vect_size_tot est nul, line_size a le droit d&#39;etre nul</span>
<a name="l00687"></a>00687 <span class="comment">// Compute all data, in the vector (including virtual data), build a big bloc:</span>
<a name="l00688"></a>00688       nblocs_left = 1;
<a name="l00689"></a>00689       bloc_ptr = one_bloc;
<a name="l00690"></a>00690       one_bloc[0] = 0;
<a name="l00691"></a>00691       one_bloc[1] = vect_size_tot / line_size;
<a name="l00692"></a>00692     }
<a name="l00693"></a>00693   <span class="keywordflow">else</span>
<a name="l00694"></a>00694     {
<a name="l00695"></a>00695 <span class="comment">// raccourci pour les tableaux vides (evite le cas particulier line_size == 0)</span>
<a name="l00696"></a>00696       <span class="keywordflow">return</span>  min_val;
<a name="l00697"></a>00697     }
<a name="l00698"></a>00698   <span class="keyword">const</span> <span class="keywordtype">double</span> *x_base = vx.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
<a name="l00699"></a>00699   <span class="keywordflow">for</span> (; nblocs_left; nblocs_left--)
<a name="l00700"></a>00700     {
<a name="l00701"></a>00701 <span class="comment">// Get index of next bloc start:</span>
<a name="l00702"></a>00702       <span class="keyword">const</span> <span class="keywordtype">int</span> begin_bloc = (*(bloc_ptr++)) * line_size;
<a name="l00703"></a>00703       <span class="keyword">const</span> <span class="keywordtype">int</span> end_bloc = (*(bloc_ptr++)) * line_size;
<a name="l00704"></a>00704       assert(begin_bloc &gt;= 0 &amp;&amp; end_bloc &lt;= vect_size_tot &amp;&amp; end_bloc &gt;= begin_bloc);
<a name="l00705"></a>00705       <span class="keyword">const</span> <span class="keywordtype">double</span>* x_ptr = x_base + begin_bloc;
<a name="l00706"></a>00706       <span class="keywordtype">int</span> count = end_bloc - begin_bloc;
<a name="l00707"></a>00707       <span class="keywordflow">for</span> (; count; count--)
<a name="l00708"></a>00708         {
<a name="l00709"></a>00709           <span class="keyword">const</span> <span class="keywordtype">double</span> x = *x_ptr;
<a name="l00710"></a>00710           min_val = (x &lt; min_val) ? x : min_val;
<a name="l00711"></a>00711           x_ptr++;
<a name="l00712"></a>00712         }
<a name="l00713"></a>00713     }
<a name="l00714"></a>00714   <span class="keywordflow">return</span>  min_val;
<a name="l00715"></a>00715 }
<a name="l00716"></a><a class="code" href="DoubleVect_8h.html#a132437a1ab5b126b0de5f4d616dd771c">00716</a> <span class="keywordtype">int</span> <a class="code" href="DoubleVect_8cpp.html#a4591588c1da575e4c11f33f71a741a83">local_imax_vect</a>(<span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; vx, <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a> opt)
<a name="l00717"></a>00717 {
<a name="l00718"></a>00718   <span class="keywordtype">double</span> max_val = (-HUGE_VALL);
<a name="l00719"></a>00719   <span class="keywordtype">int</span> i_max = -1;
<a name="l00720"></a>00720 <span class="comment">// Master vect donne la structure de reference, les autres vecteurs</span>
<a name="l00721"></a>00721 <span class="comment">// doivent avoir la meme structure.</span>
<a name="l00722"></a>00722   <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; master_vect = vx;
<a name="l00723"></a>00723   <span class="keywordtype">int</span> line_size = master_vect.<a class="code" href="classDoubleVect.html#ab02d01cd1bdab66fbd66f9a47cc29e10">line_size</a>();
<a name="l00724"></a>00724   <span class="keyword">const</span> <a class="code" href="classMD__Vector.html" title=": Cette classe est un DERIV mais l&#39;objet pointe est partage entre plusieurs instances de cette classe...">MD_Vector</a>&amp; md = master_vect.<a class="code" href="classDoubleVect.html#a0d16d30580c90526e4895388fb44be5d">get_md_vector</a>();
<a name="l00725"></a>00725   <span class="keyword">const</span> <span class="keywordtype">int</span> vect_size_tot = master_vect.<a class="code" href="classDoubleVect.html#ad2d21b364e1c6559771970596a25c006" title="Identique a size_array()">size_totale</a>();
<a name="l00726"></a>00726   assert(vx.<a class="code" href="classDoubleVect.html#ab02d01cd1bdab66fbd66f9a47cc29e10">line_size</a>() == line_size);
<a name="l00727"></a>00727   assert(vx.<a class="code" href="classDoubleVect.html#ad2d21b364e1c6559771970596a25c006" title="Identique a size_array()">size_totale</a>() == vect_size_tot); <span class="comment">//!&lt; this test is necessary if md is null</span>
<a name="l00728"></a>00728 <span class="comment"></span>  assert(vx.<a class="code" href="classDoubleVect.html#a0d16d30580c90526e4895388fb44be5d">get_md_vector</a>() == md);
<a name="l00729"></a>00729 <span class="comment">// Determine blocs of data to process, depending on &quot; opt&quot;</span>
<a name="l00730"></a>00730   <span class="keywordtype">int</span> nblocs_left = 1;
<a name="l00731"></a>00731   <span class="keywordtype">int</span> one_bloc[2];
<a name="l00732"></a>00732   <span class="keyword">const</span> <span class="keywordtype">int</span> *bloc_ptr;
<a name="l00733"></a>00733   <span class="keywordflow">if</span> ( opt != <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caad18680091a9f62247573cb3caa6450b9">VECT_ALL_ITEMS</a> &amp;&amp; md.<a class="code" href="classMD__Vector.html#a4165c00904b7096274e38fdc7ca340f4">non_nul</a>())
<a name="l00734"></a>00734     {
<a name="l00735"></a>00735       assert( opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a> ||  opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caab47906d8d2e6c20f8ba32e4acb6edbe0">VECT_REAL_ITEMS</a>);
<a name="l00736"></a>00736       <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; items_blocs = ( opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a>) ? md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a7f6b6d0b7babfec0cce590cdea5bca53">get_items_to_sum</a>() : md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a99334ac2566d9457c8d4890ba20883ea">get_items_to_compute</a>();
<a name="l00737"></a>00737       assert(items_blocs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() % 2 == 0);
<a name="l00738"></a>00738       nblocs_left = items_blocs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() &gt;&gt; 1;
<a name="l00739"></a>00739       bloc_ptr = items_blocs.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
<a name="l00740"></a>00740     }
<a name="l00741"></a>00741   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (vect_size_tot &gt; 0)
<a name="l00742"></a>00742     {
<a name="l00743"></a>00743 <span class="comment">// attention, si vect_size_tot est nul, line_size a le droit d&#39;etre nul</span>
<a name="l00744"></a>00744 <span class="comment">// Compute all data, in the vector (including virtual data), build a big bloc:</span>
<a name="l00745"></a>00745       nblocs_left = 1;
<a name="l00746"></a>00746       bloc_ptr = one_bloc;
<a name="l00747"></a>00747       one_bloc[0] = 0;
<a name="l00748"></a>00748       one_bloc[1] = vect_size_tot / line_size;
<a name="l00749"></a>00749     }
<a name="l00750"></a>00750   <span class="keywordflow">else</span>
<a name="l00751"></a>00751     {
<a name="l00752"></a>00752 <span class="comment">// raccourci pour les tableaux vides (evite le cas particulier line_size == 0)</span>
<a name="l00753"></a>00753       <span class="keywordflow">return</span>  i_max;
<a name="l00754"></a>00754     }
<a name="l00755"></a>00755   <span class="keyword">const</span> <span class="keywordtype">double</span> *x_base = vx.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
<a name="l00756"></a>00756   <span class="keywordflow">for</span> (; nblocs_left; nblocs_left--)
<a name="l00757"></a>00757     {
<a name="l00758"></a>00758 <span class="comment">// Get index of next bloc start:</span>
<a name="l00759"></a>00759       <span class="keyword">const</span> <span class="keywordtype">int</span> begin_bloc = (*(bloc_ptr++)) * line_size;
<a name="l00760"></a>00760       <span class="keyword">const</span> <span class="keywordtype">int</span> end_bloc = (*(bloc_ptr++)) * line_size;
<a name="l00761"></a>00761       assert(begin_bloc &gt;= 0 &amp;&amp; end_bloc &lt;= vect_size_tot &amp;&amp; end_bloc &gt;= begin_bloc);
<a name="l00762"></a>00762       <span class="keyword">const</span> <span class="keywordtype">double</span>* x_ptr = x_base + begin_bloc;
<a name="l00763"></a>00763       <span class="keywordtype">int</span> count = end_bloc - begin_bloc;
<a name="l00764"></a>00764       <span class="keywordflow">for</span> (; count; count--)
<a name="l00765"></a>00765         {
<a name="l00766"></a>00766           <span class="keyword">const</span> <span class="keywordtype">double</span> x = *x_ptr;
<a name="l00767"></a>00767           <span class="keywordflow">if</span> (x &gt; max_val) { i_max = x_ptr - x_base; max_val = x; }
<a name="l00768"></a>00768           x_ptr++;
<a name="l00769"></a>00769         }
<a name="l00770"></a>00770     }
<a name="l00771"></a>00771   <span class="keywordflow">return</span>  i_max;
<a name="l00772"></a>00772 }
<a name="l00773"></a><a class="code" href="DoubleVect_8h.html#aa4bbbb968a6b2606c6c528249283304c">00773</a> <span class="keywordtype">double</span> <a class="code" href="DoubleVect_8cpp.html#a6471e7e85cb0b00b67bd7ca9bb362371">local_max_vect</a>(<span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; vx, <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a> opt)
<a name="l00774"></a>00774 {
<a name="l00775"></a>00775   <span class="keywordtype">double</span> max_val = (-HUGE_VALL);
<a name="l00776"></a>00776 <span class="comment">// Master vect donne la structure de reference, les autres vecteurs</span>
<a name="l00777"></a>00777 <span class="comment">// doivent avoir la meme structure.</span>
<a name="l00778"></a>00778   <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; master_vect = vx;
<a name="l00779"></a>00779   <span class="keywordtype">int</span> line_size = master_vect.<a class="code" href="classDoubleVect.html#ab02d01cd1bdab66fbd66f9a47cc29e10">line_size</a>();
<a name="l00780"></a>00780   <span class="keyword">const</span> <a class="code" href="classMD__Vector.html" title=": Cette classe est un DERIV mais l&#39;objet pointe est partage entre plusieurs instances de cette classe...">MD_Vector</a>&amp; md = master_vect.<a class="code" href="classDoubleVect.html#a0d16d30580c90526e4895388fb44be5d">get_md_vector</a>();
<a name="l00781"></a>00781   <span class="keyword">const</span> <span class="keywordtype">int</span> vect_size_tot = master_vect.<a class="code" href="classDoubleVect.html#ad2d21b364e1c6559771970596a25c006" title="Identique a size_array()">size_totale</a>();
<a name="l00782"></a>00782   assert(vx.<a class="code" href="classDoubleVect.html#ab02d01cd1bdab66fbd66f9a47cc29e10">line_size</a>() == line_size);
<a name="l00783"></a>00783   assert(vx.<a class="code" href="classDoubleVect.html#ad2d21b364e1c6559771970596a25c006" title="Identique a size_array()">size_totale</a>() == vect_size_tot); <span class="comment">//!&lt; this test is necessary if md is null</span>
<a name="l00784"></a>00784 <span class="comment"></span>  assert(vx.<a class="code" href="classDoubleVect.html#a0d16d30580c90526e4895388fb44be5d">get_md_vector</a>() == md);
<a name="l00785"></a>00785 <span class="comment">// Determine blocs of data to process, depending on &quot; opt&quot;</span>
<a name="l00786"></a>00786   <span class="keywordtype">int</span> nblocs_left = 1;
<a name="l00787"></a>00787   <span class="keywordtype">int</span> one_bloc[2];
<a name="l00788"></a>00788   <span class="keyword">const</span> <span class="keywordtype">int</span> *bloc_ptr;
<a name="l00789"></a>00789   <span class="keywordflow">if</span> ( opt != <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caad18680091a9f62247573cb3caa6450b9">VECT_ALL_ITEMS</a> &amp;&amp; md.<a class="code" href="classMD__Vector.html#a4165c00904b7096274e38fdc7ca340f4">non_nul</a>())
<a name="l00790"></a>00790     {
<a name="l00791"></a>00791       assert( opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a> ||  opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caab47906d8d2e6c20f8ba32e4acb6edbe0">VECT_REAL_ITEMS</a>);
<a name="l00792"></a>00792       <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; items_blocs = ( opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a>) ? md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a7f6b6d0b7babfec0cce590cdea5bca53">get_items_to_sum</a>() : md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a99334ac2566d9457c8d4890ba20883ea">get_items_to_compute</a>();
<a name="l00793"></a>00793       assert(items_blocs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() % 2 == 0);
<a name="l00794"></a>00794       nblocs_left = items_blocs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() &gt;&gt; 1;
<a name="l00795"></a>00795       bloc_ptr = items_blocs.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
<a name="l00796"></a>00796     }
<a name="l00797"></a>00797   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (vect_size_tot &gt; 0)
<a name="l00798"></a>00798     {
<a name="l00799"></a>00799 <span class="comment">// attention, si vect_size_tot est nul, line_size a le droit d&#39;etre nul</span>
<a name="l00800"></a>00800 <span class="comment">// Compute all data, in the vector (including virtual data), build a big bloc:</span>
<a name="l00801"></a>00801       nblocs_left = 1;
<a name="l00802"></a>00802       bloc_ptr = one_bloc;
<a name="l00803"></a>00803       one_bloc[0] = 0;
<a name="l00804"></a>00804       one_bloc[1] = vect_size_tot / line_size;
<a name="l00805"></a>00805     }
<a name="l00806"></a>00806   <span class="keywordflow">else</span>
<a name="l00807"></a>00807     {
<a name="l00808"></a>00808 <span class="comment">// raccourci pour les tableaux vides (evite le cas particulier line_size == 0)</span>
<a name="l00809"></a>00809       <span class="keywordflow">return</span>  max_val;
<a name="l00810"></a>00810     }
<a name="l00811"></a>00811   <span class="keyword">const</span> <span class="keywordtype">double</span> *x_base = vx.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
<a name="l00812"></a>00812   <span class="keywordflow">for</span> (; nblocs_left; nblocs_left--)
<a name="l00813"></a>00813     {
<a name="l00814"></a>00814 <span class="comment">// Get index of next bloc start:</span>
<a name="l00815"></a>00815       <span class="keyword">const</span> <span class="keywordtype">int</span> begin_bloc = (*(bloc_ptr++)) * line_size;
<a name="l00816"></a>00816       <span class="keyword">const</span> <span class="keywordtype">int</span> end_bloc = (*(bloc_ptr++)) * line_size;
<a name="l00817"></a>00817       assert(begin_bloc &gt;= 0 &amp;&amp; end_bloc &lt;= vect_size_tot &amp;&amp; end_bloc &gt;= begin_bloc);
<a name="l00818"></a>00818       <span class="keyword">const</span> <span class="keywordtype">double</span>* x_ptr = x_base + begin_bloc;
<a name="l00819"></a>00819       <span class="keywordtype">int</span> count = end_bloc - begin_bloc;
<a name="l00820"></a>00820       <span class="keywordflow">for</span> (; count; count--)
<a name="l00821"></a>00821         {
<a name="l00822"></a>00822           <span class="keyword">const</span> <span class="keywordtype">double</span> x = *x_ptr;
<a name="l00823"></a>00823           max_val = (x &gt; max_val) ? x : max_val;
<a name="l00824"></a>00824           x_ptr++;
<a name="l00825"></a>00825         }
<a name="l00826"></a>00826     }
<a name="l00827"></a>00827   <span class="keywordflow">return</span>  max_val;
<a name="l00828"></a>00828 }
<a name="l00829"></a><a class="code" href="DoubleVect_8h.html#a637e2dd2b5ed34c74721dd9c4f8bbf40">00829</a> <span class="keywordtype">double</span> <a class="code" href="DoubleVect_8cpp.html#aad339141fa6027fa3b627825a2407c12">local_max_abs_vect</a>(<span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; vx, <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a> opt)
<a name="l00830"></a>00830 {
<a name="l00831"></a>00831   <span class="keywordtype">double</span> max_val = 0;
<a name="l00832"></a>00832 <span class="comment">// Master vect donne la structure de reference, les autres vecteurs</span>
<a name="l00833"></a>00833 <span class="comment">// doivent avoir la meme structure.</span>
<a name="l00834"></a>00834   <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; master_vect = vx;
<a name="l00835"></a>00835   <span class="keywordtype">int</span> line_size = master_vect.<a class="code" href="classDoubleVect.html#ab02d01cd1bdab66fbd66f9a47cc29e10">line_size</a>();
<a name="l00836"></a>00836   <span class="keyword">const</span> <a class="code" href="classMD__Vector.html" title=": Cette classe est un DERIV mais l&#39;objet pointe est partage entre plusieurs instances de cette classe...">MD_Vector</a>&amp; md = master_vect.<a class="code" href="classDoubleVect.html#a0d16d30580c90526e4895388fb44be5d">get_md_vector</a>();
<a name="l00837"></a>00837   <span class="keyword">const</span> <span class="keywordtype">int</span> vect_size_tot = master_vect.<a class="code" href="classDoubleVect.html#ad2d21b364e1c6559771970596a25c006" title="Identique a size_array()">size_totale</a>();
<a name="l00838"></a>00838   assert(vx.<a class="code" href="classDoubleVect.html#ab02d01cd1bdab66fbd66f9a47cc29e10">line_size</a>() == line_size);
<a name="l00839"></a>00839   assert(vx.<a class="code" href="classDoubleVect.html#ad2d21b364e1c6559771970596a25c006" title="Identique a size_array()">size_totale</a>() == vect_size_tot); <span class="comment">//!&lt; this test is necessary if md is null</span>
<a name="l00840"></a>00840 <span class="comment"></span>  assert(vx.<a class="code" href="classDoubleVect.html#a0d16d30580c90526e4895388fb44be5d">get_md_vector</a>() == md);
<a name="l00841"></a>00841 <span class="comment">// Determine blocs of data to process, depending on &quot; opt&quot;</span>
<a name="l00842"></a>00842   <span class="keywordtype">int</span> nblocs_left = 1;
<a name="l00843"></a>00843   <span class="keywordtype">int</span> one_bloc[2];
<a name="l00844"></a>00844   <span class="keyword">const</span> <span class="keywordtype">int</span> *bloc_ptr;
<a name="l00845"></a>00845   <span class="keywordflow">if</span> ( opt != <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caad18680091a9f62247573cb3caa6450b9">VECT_ALL_ITEMS</a> &amp;&amp; md.<a class="code" href="classMD__Vector.html#a4165c00904b7096274e38fdc7ca340f4">non_nul</a>())
<a name="l00846"></a>00846     {
<a name="l00847"></a>00847       assert( opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a> ||  opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caab47906d8d2e6c20f8ba32e4acb6edbe0">VECT_REAL_ITEMS</a>);
<a name="l00848"></a>00848       <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; items_blocs = ( opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a>) ? md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a7f6b6d0b7babfec0cce590cdea5bca53">get_items_to_sum</a>() : md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a99334ac2566d9457c8d4890ba20883ea">get_items_to_compute</a>();
<a name="l00849"></a>00849       assert(items_blocs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() % 2 == 0);
<a name="l00850"></a>00850       nblocs_left = items_blocs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() &gt;&gt; 1;
<a name="l00851"></a>00851       bloc_ptr = items_blocs.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
<a name="l00852"></a>00852     }
<a name="l00853"></a>00853   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (vect_size_tot &gt; 0)
<a name="l00854"></a>00854     {
<a name="l00855"></a>00855 <span class="comment">// attention, si vect_size_tot est nul, line_size a le droit d&#39;etre nul</span>
<a name="l00856"></a>00856 <span class="comment">// Compute all data, in the vector (including virtual data), build a big bloc:</span>
<a name="l00857"></a>00857       nblocs_left = 1;
<a name="l00858"></a>00858       bloc_ptr = one_bloc;
<a name="l00859"></a>00859       one_bloc[0] = 0;
<a name="l00860"></a>00860       one_bloc[1] = vect_size_tot / line_size;
<a name="l00861"></a>00861     }
<a name="l00862"></a>00862   <span class="keywordflow">else</span>
<a name="l00863"></a>00863     {
<a name="l00864"></a>00864 <span class="comment">// raccourci pour les tableaux vides (evite le cas particulier line_size == 0)</span>
<a name="l00865"></a>00865       <span class="keywordflow">return</span>  max_val;
<a name="l00866"></a>00866     }
<a name="l00867"></a>00867   <span class="keyword">const</span> <span class="keywordtype">double</span> *x_base = vx.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
<a name="l00868"></a>00868   <span class="keywordflow">for</span> (; nblocs_left; nblocs_left--)
<a name="l00869"></a>00869     {
<a name="l00870"></a>00870 <span class="comment">// Get index of next bloc start:</span>
<a name="l00871"></a>00871       <span class="keyword">const</span> <span class="keywordtype">int</span> begin_bloc = (*(bloc_ptr++)) * line_size;
<a name="l00872"></a>00872       <span class="keyword">const</span> <span class="keywordtype">int</span> end_bloc = (*(bloc_ptr++)) * line_size;
<a name="l00873"></a>00873       assert(begin_bloc &gt;= 0 &amp;&amp; end_bloc &lt;= vect_size_tot &amp;&amp; end_bloc &gt;= begin_bloc);
<a name="l00874"></a>00874       <span class="keyword">const</span> <span class="keywordtype">double</span>* x_ptr = x_base + begin_bloc;
<a name="l00875"></a>00875       <span class="keywordtype">int</span> count = end_bloc - begin_bloc;
<a name="l00876"></a>00876       <span class="keywordflow">for</span> (; count; count--)
<a name="l00877"></a>00877         {
<a name="l00878"></a>00878           <span class="keyword">const</span> <span class="keywordtype">double</span> x = *x_ptr;
<a name="l00879"></a>00879           <span class="keywordtype">double</span> xx = fabs(x);
<a name="l00880"></a>00880           max_val = (xx &gt; max_val) ? xx : max_val;
<a name="l00881"></a>00881           x_ptr++;
<a name="l00882"></a>00882         }
<a name="l00883"></a>00883     }
<a name="l00884"></a>00884   <span class="keywordflow">return</span>  max_val;
<a name="l00885"></a>00885 }
<a name="l00886"></a><a class="code" href="DoubleVect_8h.html#a53ce32b2e48a0d97c93916666c93bbe3">00886</a> <span class="keywordtype">double</span> <a class="code" href="DoubleVect_8cpp.html#abbb6099a23e2ab39b2308423112f6a67">local_min_abs_vect</a>(<span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; vx, <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a> opt)
<a name="l00887"></a>00887 {
<a name="l00888"></a>00888   <span class="keywordtype">double</span> min_val = HUGE_VALL;
<a name="l00889"></a>00889 <span class="comment">// Master vect donne la structure de reference, les autres vecteurs</span>
<a name="l00890"></a>00890 <span class="comment">// doivent avoir la meme structure.</span>
<a name="l00891"></a>00891   <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; master_vect = vx;
<a name="l00892"></a>00892   <span class="keywordtype">int</span> line_size = master_vect.<a class="code" href="classDoubleVect.html#ab02d01cd1bdab66fbd66f9a47cc29e10">line_size</a>();
<a name="l00893"></a>00893   <span class="keyword">const</span> <a class="code" href="classMD__Vector.html" title=": Cette classe est un DERIV mais l&#39;objet pointe est partage entre plusieurs instances de cette classe...">MD_Vector</a>&amp; md = master_vect.<a class="code" href="classDoubleVect.html#a0d16d30580c90526e4895388fb44be5d">get_md_vector</a>();
<a name="l00894"></a>00894   <span class="keyword">const</span> <span class="keywordtype">int</span> vect_size_tot = master_vect.<a class="code" href="classDoubleVect.html#ad2d21b364e1c6559771970596a25c006" title="Identique a size_array()">size_totale</a>();
<a name="l00895"></a>00895   assert(vx.<a class="code" href="classDoubleVect.html#ab02d01cd1bdab66fbd66f9a47cc29e10">line_size</a>() == line_size);
<a name="l00896"></a>00896   assert(vx.<a class="code" href="classDoubleVect.html#ad2d21b364e1c6559771970596a25c006" title="Identique a size_array()">size_totale</a>() == vect_size_tot); <span class="comment">//!&lt; this test is necessary if md is null</span>
<a name="l00897"></a>00897 <span class="comment"></span>  assert(vx.<a class="code" href="classDoubleVect.html#a0d16d30580c90526e4895388fb44be5d">get_md_vector</a>() == md);
<a name="l00898"></a>00898 <span class="comment">// Determine blocs of data to process, depending on &quot; opt&quot;</span>
<a name="l00899"></a>00899   <span class="keywordtype">int</span> nblocs_left = 1;
<a name="l00900"></a>00900   <span class="keywordtype">int</span> one_bloc[2];
<a name="l00901"></a>00901   <span class="keyword">const</span> <span class="keywordtype">int</span> *bloc_ptr;
<a name="l00902"></a>00902   <span class="keywordflow">if</span> ( opt != <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caad18680091a9f62247573cb3caa6450b9">VECT_ALL_ITEMS</a> &amp;&amp; md.<a class="code" href="classMD__Vector.html#a4165c00904b7096274e38fdc7ca340f4">non_nul</a>())
<a name="l00903"></a>00903     {
<a name="l00904"></a>00904       assert( opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a> ||  opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caab47906d8d2e6c20f8ba32e4acb6edbe0">VECT_REAL_ITEMS</a>);
<a name="l00905"></a>00905       <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; items_blocs = ( opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a>) ? md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a7f6b6d0b7babfec0cce590cdea5bca53">get_items_to_sum</a>() : md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a99334ac2566d9457c8d4890ba20883ea">get_items_to_compute</a>();
<a name="l00906"></a>00906       assert(items_blocs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() % 2 == 0);
<a name="l00907"></a>00907       nblocs_left = items_blocs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() &gt;&gt; 1;
<a name="l00908"></a>00908       bloc_ptr = items_blocs.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
<a name="l00909"></a>00909     }
<a name="l00910"></a>00910   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (vect_size_tot &gt; 0)
<a name="l00911"></a>00911     {
<a name="l00912"></a>00912 <span class="comment">// attention, si vect_size_tot est nul, line_size a le droit d&#39;etre nul</span>
<a name="l00913"></a>00913 <span class="comment">// Compute all data, in the vector (including virtual data), build a big bloc:</span>
<a name="l00914"></a>00914       nblocs_left = 1;
<a name="l00915"></a>00915       bloc_ptr = one_bloc;
<a name="l00916"></a>00916       one_bloc[0] = 0;
<a name="l00917"></a>00917       one_bloc[1] = vect_size_tot / line_size;
<a name="l00918"></a>00918     }
<a name="l00919"></a>00919   <span class="keywordflow">else</span>
<a name="l00920"></a>00920     {
<a name="l00921"></a>00921 <span class="comment">// raccourci pour les tableaux vides (evite le cas particulier line_size == 0)</span>
<a name="l00922"></a>00922       <span class="keywordflow">return</span>  min_val;
<a name="l00923"></a>00923     }
<a name="l00924"></a>00924   <span class="keyword">const</span> <span class="keywordtype">double</span> *x_base = vx.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
<a name="l00925"></a>00925   <span class="keywordflow">for</span> (; nblocs_left; nblocs_left--)
<a name="l00926"></a>00926     {
<a name="l00927"></a>00927 <span class="comment">// Get index of next bloc start:</span>
<a name="l00928"></a>00928       <span class="keyword">const</span> <span class="keywordtype">int</span> begin_bloc = (*(bloc_ptr++)) * line_size;
<a name="l00929"></a>00929       <span class="keyword">const</span> <span class="keywordtype">int</span> end_bloc = (*(bloc_ptr++)) * line_size;
<a name="l00930"></a>00930       assert(begin_bloc &gt;= 0 &amp;&amp; end_bloc &lt;= vect_size_tot &amp;&amp; end_bloc &gt;= begin_bloc);
<a name="l00931"></a>00931       <span class="keyword">const</span> <span class="keywordtype">double</span>* x_ptr = x_base + begin_bloc;
<a name="l00932"></a>00932       <span class="keywordtype">int</span> count = end_bloc - begin_bloc;
<a name="l00933"></a>00933       <span class="keywordflow">for</span> (; count; count--)
<a name="l00934"></a>00934         {
<a name="l00935"></a>00935           <span class="keyword">const</span> <span class="keywordtype">double</span> x = *x_ptr;
<a name="l00936"></a>00936           <span class="keywordtype">double</span> xx = fabs(x);
<a name="l00937"></a>00937           min_val = (xx &lt; min_val) ? xx : min_val;
<a name="l00938"></a>00938           x_ptr++;
<a name="l00939"></a>00939         }
<a name="l00940"></a>00940     }
<a name="l00941"></a>00941   <span class="keywordflow">return</span>  min_val;
<a name="l00942"></a>00942 }
<a name="l00943"></a><a class="code" href="DoubleVect_8h.html#ad644deff922d4a657a67ecf797f01839">00943</a> <span class="keywordtype">void</span> <a class="code" href="DoubleVect_8cpp.html#a0b4caded26dc4824771aedfe202d0cbd">operator_abs</a>(<a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; resu, <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a> opt)
<a name="l00944"></a>00944 {
<a name="l00945"></a>00945 
<a name="l00946"></a>00946 <span class="comment">// Master vect donne la structure de reference, les autres vecteurs</span>
<a name="l00947"></a>00947 <span class="comment">// doivent avoir la meme structure.</span>
<a name="l00948"></a>00948   <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; master_vect = resu;
<a name="l00949"></a>00949   <span class="keywordtype">int</span> line_size = master_vect.<a class="code" href="classDoubleVect.html#ab02d01cd1bdab66fbd66f9a47cc29e10">line_size</a>();
<a name="l00950"></a>00950   <span class="keyword">const</span> <a class="code" href="classMD__Vector.html" title=": Cette classe est un DERIV mais l&#39;objet pointe est partage entre plusieurs instances de cette classe...">MD_Vector</a>&amp; md = master_vect.<a class="code" href="classDoubleVect.html#a0d16d30580c90526e4895388fb44be5d">get_md_vector</a>();
<a name="l00951"></a>00951   <span class="keyword">const</span> <span class="keywordtype">int</span> vect_size_tot = master_vect.<a class="code" href="classDoubleVect.html#ad2d21b364e1c6559771970596a25c006" title="Identique a size_array()">size_totale</a>();
<a name="l00952"></a>00952 <span class="comment">// Determine blocs of data to process, depending on &quot; opt&quot;</span>
<a name="l00953"></a>00953   <span class="keywordtype">int</span> nblocs_left = 1;
<a name="l00954"></a>00954   <span class="keywordtype">int</span> one_bloc[2];
<a name="l00955"></a>00955   <span class="keyword">const</span> <span class="keywordtype">int</span> *bloc_ptr;
<a name="l00956"></a>00956   <span class="keywordflow">if</span> ( opt != <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caad18680091a9f62247573cb3caa6450b9">VECT_ALL_ITEMS</a> &amp;&amp; md.<a class="code" href="classMD__Vector.html#a4165c00904b7096274e38fdc7ca340f4">non_nul</a>())
<a name="l00957"></a>00957     {
<a name="l00958"></a>00958       assert( opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a> ||  opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caab47906d8d2e6c20f8ba32e4acb6edbe0">VECT_REAL_ITEMS</a>);
<a name="l00959"></a>00959       <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; items_blocs = ( opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a>) ? md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a7f6b6d0b7babfec0cce590cdea5bca53">get_items_to_sum</a>() : md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a99334ac2566d9457c8d4890ba20883ea">get_items_to_compute</a>();
<a name="l00960"></a>00960       assert(items_blocs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() % 2 == 0);
<a name="l00961"></a>00961       nblocs_left = items_blocs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() &gt;&gt; 1;
<a name="l00962"></a>00962       bloc_ptr = items_blocs.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
<a name="l00963"></a>00963     }
<a name="l00964"></a>00964   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (vect_size_tot &gt; 0)
<a name="l00965"></a>00965     {
<a name="l00966"></a>00966 <span class="comment">// attention, si vect_size_tot est nul, line_size a le droit d&#39;etre nul</span>
<a name="l00967"></a>00967 <span class="comment">// Compute all data, in the vector (including virtual data), build a big bloc:</span>
<a name="l00968"></a>00968       nblocs_left = 1;
<a name="l00969"></a>00969       bloc_ptr = one_bloc;
<a name="l00970"></a>00970       one_bloc[0] = 0;
<a name="l00971"></a>00971       one_bloc[1] = vect_size_tot / line_size;
<a name="l00972"></a>00972     }
<a name="l00973"></a>00973   <span class="keywordflow">else</span>
<a name="l00974"></a>00974     {
<a name="l00975"></a>00975 <span class="comment">// raccourci pour les tableaux vides (evite le cas particulier line_size == 0)</span>
<a name="l00976"></a>00976       return ;
<a name="l00977"></a>00977     }
<a name="l00978"></a>00978   <span class="keywordtype">double</span> *resu_base = resu.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
<a name="l00979"></a>00979   <span class="keywordflow">for</span> (; nblocs_left; nblocs_left--)
<a name="l00980"></a>00980     {
<a name="l00981"></a>00981 <span class="comment">// Get index of next bloc start:</span>
<a name="l00982"></a>00982       <span class="keyword">const</span> <span class="keywordtype">int</span> begin_bloc = (*(bloc_ptr++)) * line_size;
<a name="l00983"></a>00983       <span class="keyword">const</span> <span class="keywordtype">int</span> end_bloc = (*(bloc_ptr++)) * line_size;
<a name="l00984"></a>00984       assert(begin_bloc &gt;= 0 &amp;&amp; end_bloc &lt;= vect_size_tot &amp;&amp; end_bloc &gt;= begin_bloc);
<a name="l00985"></a>00985       <span class="keywordtype">double</span>* resu_ptr = resu_base + begin_bloc;
<a name="l00986"></a>00986       <span class="keywordtype">int</span> count = end_bloc - begin_bloc;
<a name="l00987"></a>00987       <span class="keywordflow">for</span> (; count; count--)
<a name="l00988"></a>00988         {
<a name="l00989"></a>00989           <span class="keywordtype">double</span>&amp; p_resu = *(resu_ptr++);
<a name="l00990"></a>00990           p_resu = fabs(p_resu);
<a name="l00991"></a>00991         }
<a name="l00992"></a>00992     }
<a name="l00993"></a>00993 <span class="comment">// In debug mode, put invalid values where data has not been computed</span>
<a name="l00994"></a>00994 <span class="preprocessor">#ifndef NDEBUG</span>
<a name="l00995"></a>00995 <span class="preprocessor"></span>  <a class="code" href="DoubleVect_8cpp.html#ad4995bc506ff841ba67ce56a43886902">invalidate_data</a>(resu,  opt);
<a name="l00996"></a>00996 <span class="preprocessor">#endif</span>
<a name="l00997"></a>00997 <span class="preprocessor"></span>  return ;
<a name="l00998"></a>00998 }
<a name="l00999"></a><a class="code" href="DoubleVect_8h.html#a2b2050de9e106e61abff20c7d582bae5">00999</a> <span class="keywordtype">void</span> <a class="code" href="DoubleVect_8cpp.html#a9dd7edead35e9d46fc6c8960f33e668a">operator_add</a>(<a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; resu, <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; vx, <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a> opt)
<a name="l01000"></a>01000 {
<a name="l01001"></a>01001 
<a name="l01002"></a>01002 <span class="comment">// Master vect donne la structure de reference, les autres vecteurs</span>
<a name="l01003"></a>01003 <span class="comment">// doivent avoir la meme structure.</span>
<a name="l01004"></a>01004   <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; master_vect = resu;
<a name="l01005"></a>01005   <span class="keywordtype">int</span> line_size = master_vect.<a class="code" href="classDoubleVect.html#ab02d01cd1bdab66fbd66f9a47cc29e10">line_size</a>();
<a name="l01006"></a>01006   <span class="keyword">const</span> <a class="code" href="classMD__Vector.html" title=": Cette classe est un DERIV mais l&#39;objet pointe est partage entre plusieurs instances de cette classe...">MD_Vector</a>&amp; md = master_vect.<a class="code" href="classDoubleVect.html#a0d16d30580c90526e4895388fb44be5d">get_md_vector</a>();
<a name="l01007"></a>01007   <span class="keyword">const</span> <span class="keywordtype">int</span> vect_size_tot = master_vect.<a class="code" href="classDoubleVect.html#ad2d21b364e1c6559771970596a25c006" title="Identique a size_array()">size_totale</a>();
<a name="l01008"></a>01008   assert(vx.<a class="code" href="classDoubleVect.html#ab02d01cd1bdab66fbd66f9a47cc29e10">line_size</a>() == line_size);
<a name="l01009"></a>01009   assert(vx.<a class="code" href="classDoubleVect.html#ad2d21b364e1c6559771970596a25c006" title="Identique a size_array()">size_totale</a>() == vect_size_tot); <span class="comment">//!&lt; this test is necessary if md is null</span>
<a name="l01010"></a>01010 <span class="comment"></span>  assert(vx.<a class="code" href="classDoubleVect.html#a0d16d30580c90526e4895388fb44be5d">get_md_vector</a>() == md);
<a name="l01011"></a>01011 <span class="comment">// Determine blocs of data to process, depending on &quot; opt&quot;</span>
<a name="l01012"></a>01012   <span class="keywordtype">int</span> nblocs_left = 1;
<a name="l01013"></a>01013   <span class="keywordtype">int</span> one_bloc[2];
<a name="l01014"></a>01014   <span class="keyword">const</span> <span class="keywordtype">int</span> *bloc_ptr;
<a name="l01015"></a>01015   <span class="keywordflow">if</span> ( opt != <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caad18680091a9f62247573cb3caa6450b9">VECT_ALL_ITEMS</a> &amp;&amp; md.<a class="code" href="classMD__Vector.html#a4165c00904b7096274e38fdc7ca340f4">non_nul</a>())
<a name="l01016"></a>01016     {
<a name="l01017"></a>01017       assert( opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a> ||  opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caab47906d8d2e6c20f8ba32e4acb6edbe0">VECT_REAL_ITEMS</a>);
<a name="l01018"></a>01018       <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; items_blocs = ( opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a>) ? md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a7f6b6d0b7babfec0cce590cdea5bca53">get_items_to_sum</a>() : md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a99334ac2566d9457c8d4890ba20883ea">get_items_to_compute</a>();
<a name="l01019"></a>01019       assert(items_blocs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() % 2 == 0);
<a name="l01020"></a>01020       nblocs_left = items_blocs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() &gt;&gt; 1;
<a name="l01021"></a>01021       bloc_ptr = items_blocs.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
<a name="l01022"></a>01022     }
<a name="l01023"></a>01023   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (vect_size_tot &gt; 0)
<a name="l01024"></a>01024     {
<a name="l01025"></a>01025 <span class="comment">// attention, si vect_size_tot est nul, line_size a le droit d&#39;etre nul</span>
<a name="l01026"></a>01026 <span class="comment">// Compute all data, in the vector (including virtual data), build a big bloc:</span>
<a name="l01027"></a>01027       nblocs_left = 1;
<a name="l01028"></a>01028       bloc_ptr = one_bloc;
<a name="l01029"></a>01029       one_bloc[0] = 0;
<a name="l01030"></a>01030       one_bloc[1] = vect_size_tot / line_size;
<a name="l01031"></a>01031     }
<a name="l01032"></a>01032   <span class="keywordflow">else</span>
<a name="l01033"></a>01033     {
<a name="l01034"></a>01034 <span class="comment">// raccourci pour les tableaux vides (evite le cas particulier line_size == 0)</span>
<a name="l01035"></a>01035       return ;
<a name="l01036"></a>01036     }
<a name="l01037"></a>01037   <span class="keywordtype">double</span> *resu_base = resu.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
<a name="l01038"></a>01038   <span class="keyword">const</span> <span class="keywordtype">double</span> *x_base = vx.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
<a name="l01039"></a>01039   <span class="keywordflow">for</span> (; nblocs_left; nblocs_left--)
<a name="l01040"></a>01040     {
<a name="l01041"></a>01041 <span class="comment">// Get index of next bloc start:</span>
<a name="l01042"></a>01042       <span class="keyword">const</span> <span class="keywordtype">int</span> begin_bloc = (*(bloc_ptr++)) * line_size;
<a name="l01043"></a>01043       <span class="keyword">const</span> <span class="keywordtype">int</span> end_bloc = (*(bloc_ptr++)) * line_size;
<a name="l01044"></a>01044       assert(begin_bloc &gt;= 0 &amp;&amp; end_bloc &lt;= vect_size_tot &amp;&amp; end_bloc &gt;= begin_bloc);
<a name="l01045"></a>01045       <span class="keywordtype">double</span>* resu_ptr = resu_base + begin_bloc;
<a name="l01046"></a>01046       <span class="keyword">const</span> <span class="keywordtype">double</span>* x_ptr = x_base + begin_bloc;
<a name="l01047"></a>01047       <span class="keywordtype">int</span> count = end_bloc - begin_bloc;
<a name="l01048"></a>01048       <span class="keywordflow">for</span> (; count; count--)
<a name="l01049"></a>01049         {
<a name="l01050"></a>01050           <span class="keyword">const</span> <span class="keywordtype">double</span> x = *x_ptr;
<a name="l01051"></a>01051           <span class="keywordtype">double</span>&amp; p_resu = *(resu_ptr++);
<a name="l01052"></a>01052           p_resu += x;
<a name="l01053"></a>01053           x_ptr++;
<a name="l01054"></a>01054         }
<a name="l01055"></a>01055     }
<a name="l01056"></a>01056 <span class="comment">// In debug mode, put invalid values where data has not been computed</span>
<a name="l01057"></a>01057 <span class="preprocessor">#ifndef NDEBUG</span>
<a name="l01058"></a>01058 <span class="preprocessor"></span>  <a class="code" href="DoubleVect_8cpp.html#ad4995bc506ff841ba67ce56a43886902">invalidate_data</a>(resu,  opt);
<a name="l01059"></a>01059 <span class="preprocessor">#endif</span>
<a name="l01060"></a>01060 <span class="preprocessor"></span>  return ;
<a name="l01061"></a>01061 }
<a name="l01062"></a><a class="code" href="DoubleVect_8h.html#ac385f0ae1bb529665dcf09eaad2d078f">01062</a> <span class="keywordtype">void</span> <a class="code" href="DoubleVect_8cpp.html#a9dd7edead35e9d46fc6c8960f33e668a">operator_add</a>(<a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; resu, <span class="keyword">const</span> <span class="keywordtype">double</span> x, <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a> opt)
<a name="l01063"></a>01063 {
<a name="l01064"></a>01064 
<a name="l01065"></a>01065 <span class="comment">// Master vect donne la structure de reference, les autres vecteurs</span>
<a name="l01066"></a>01066 <span class="comment">// doivent avoir la meme structure.</span>
<a name="l01067"></a>01067   <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; master_vect = resu;
<a name="l01068"></a>01068   <span class="keywordtype">int</span> line_size = master_vect.<a class="code" href="classDoubleVect.html#ab02d01cd1bdab66fbd66f9a47cc29e10">line_size</a>();
<a name="l01069"></a>01069   <span class="keyword">const</span> <a class="code" href="classMD__Vector.html" title=": Cette classe est un DERIV mais l&#39;objet pointe est partage entre plusieurs instances de cette classe...">MD_Vector</a>&amp; md = master_vect.<a class="code" href="classDoubleVect.html#a0d16d30580c90526e4895388fb44be5d">get_md_vector</a>();
<a name="l01070"></a>01070   <span class="keyword">const</span> <span class="keywordtype">int</span> vect_size_tot = master_vect.<a class="code" href="classDoubleVect.html#ad2d21b364e1c6559771970596a25c006" title="Identique a size_array()">size_totale</a>();
<a name="l01071"></a>01071 <span class="comment">// Determine blocs of data to process, depending on &quot; opt&quot;</span>
<a name="l01072"></a>01072   <span class="keywordtype">int</span> nblocs_left = 1;
<a name="l01073"></a>01073   <span class="keywordtype">int</span> one_bloc[2];
<a name="l01074"></a>01074   <span class="keyword">const</span> <span class="keywordtype">int</span> *bloc_ptr;
<a name="l01075"></a>01075   <span class="keywordflow">if</span> ( opt != <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caad18680091a9f62247573cb3caa6450b9">VECT_ALL_ITEMS</a> &amp;&amp; md.<a class="code" href="classMD__Vector.html#a4165c00904b7096274e38fdc7ca340f4">non_nul</a>())
<a name="l01076"></a>01076     {
<a name="l01077"></a>01077       assert( opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a> ||  opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caab47906d8d2e6c20f8ba32e4acb6edbe0">VECT_REAL_ITEMS</a>);
<a name="l01078"></a>01078       <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; items_blocs = ( opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a>) ? md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a7f6b6d0b7babfec0cce590cdea5bca53">get_items_to_sum</a>() : md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a99334ac2566d9457c8d4890ba20883ea">get_items_to_compute</a>();
<a name="l01079"></a>01079       assert(items_blocs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() % 2 == 0);
<a name="l01080"></a>01080       nblocs_left = items_blocs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() &gt;&gt; 1;
<a name="l01081"></a>01081       bloc_ptr = items_blocs.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
<a name="l01082"></a>01082     }
<a name="l01083"></a>01083   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (vect_size_tot &gt; 0)
<a name="l01084"></a>01084     {
<a name="l01085"></a>01085 <span class="comment">// attention, si vect_size_tot est nul, line_size a le droit d&#39;etre nul</span>
<a name="l01086"></a>01086 <span class="comment">// Compute all data, in the vector (including virtual data), build a big bloc:</span>
<a name="l01087"></a>01087       nblocs_left = 1;
<a name="l01088"></a>01088       bloc_ptr = one_bloc;
<a name="l01089"></a>01089       one_bloc[0] = 0;
<a name="l01090"></a>01090       one_bloc[1] = vect_size_tot / line_size;
<a name="l01091"></a>01091     }
<a name="l01092"></a>01092   <span class="keywordflow">else</span>
<a name="l01093"></a>01093     {
<a name="l01094"></a>01094 <span class="comment">// raccourci pour les tableaux vides (evite le cas particulier line_size == 0)</span>
<a name="l01095"></a>01095       return ;
<a name="l01096"></a>01096     }
<a name="l01097"></a>01097   <span class="keywordtype">double</span> *resu_base = resu.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
<a name="l01098"></a>01098   <span class="keywordflow">for</span> (; nblocs_left; nblocs_left--)
<a name="l01099"></a>01099     {
<a name="l01100"></a>01100 <span class="comment">// Get index of next bloc start:</span>
<a name="l01101"></a>01101       <span class="keyword">const</span> <span class="keywordtype">int</span> begin_bloc = (*(bloc_ptr++)) * line_size;
<a name="l01102"></a>01102       <span class="keyword">const</span> <span class="keywordtype">int</span> end_bloc = (*(bloc_ptr++)) * line_size;
<a name="l01103"></a>01103       assert(begin_bloc &gt;= 0 &amp;&amp; end_bloc &lt;= vect_size_tot &amp;&amp; end_bloc &gt;= begin_bloc);
<a name="l01104"></a>01104       <span class="keywordtype">double</span>* resu_ptr = resu_base + begin_bloc;
<a name="l01105"></a>01105       <span class="keywordtype">int</span> count = end_bloc - begin_bloc;
<a name="l01106"></a>01106       <span class="keywordflow">for</span> (; count; count--)
<a name="l01107"></a>01107         {
<a name="l01108"></a>01108           <span class="keywordtype">double</span>&amp; p_resu = *(resu_ptr++);
<a name="l01109"></a>01109           p_resu += x;
<a name="l01110"></a>01110         }
<a name="l01111"></a>01111     }
<a name="l01112"></a>01112 <span class="comment">// In debug mode, put invalid values where data has not been computed</span>
<a name="l01113"></a>01113 <span class="preprocessor">#ifndef NDEBUG</span>
<a name="l01114"></a>01114 <span class="preprocessor"></span>  <a class="code" href="DoubleVect_8cpp.html#ad4995bc506ff841ba67ce56a43886902">invalidate_data</a>(resu,  opt);
<a name="l01115"></a>01115 <span class="preprocessor">#endif</span>
<a name="l01116"></a>01116 <span class="preprocessor"></span>  return ;
<a name="l01117"></a>01117 }
<a name="l01118"></a><a class="code" href="DoubleVect_8h.html#a3f9457c6edd6d6946251ccab03ba358c">01118</a> <span class="keywordtype">void</span> <a class="code" href="DoubleVect_8cpp.html#a813958fe17f5746cc80e1e21d0b10a6a">operator_sub</a>(<a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; resu, <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; vx, <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a> opt)
<a name="l01119"></a>01119 {
<a name="l01120"></a>01120 
<a name="l01121"></a>01121 <span class="comment">// Master vect donne la structure de reference, les autres vecteurs</span>
<a name="l01122"></a>01122 <span class="comment">// doivent avoir la meme structure.</span>
<a name="l01123"></a>01123   <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; master_vect = resu;
<a name="l01124"></a>01124   <span class="keywordtype">int</span> line_size = master_vect.<a class="code" href="classDoubleVect.html#ab02d01cd1bdab66fbd66f9a47cc29e10">line_size</a>();
<a name="l01125"></a>01125   <span class="keyword">const</span> <a class="code" href="classMD__Vector.html" title=": Cette classe est un DERIV mais l&#39;objet pointe est partage entre plusieurs instances de cette classe...">MD_Vector</a>&amp; md = master_vect.<a class="code" href="classDoubleVect.html#a0d16d30580c90526e4895388fb44be5d">get_md_vector</a>();
<a name="l01126"></a>01126   <span class="keyword">const</span> <span class="keywordtype">int</span> vect_size_tot = master_vect.<a class="code" href="classDoubleVect.html#ad2d21b364e1c6559771970596a25c006" title="Identique a size_array()">size_totale</a>();
<a name="l01127"></a>01127   assert(vx.<a class="code" href="classDoubleVect.html#ab02d01cd1bdab66fbd66f9a47cc29e10">line_size</a>() == line_size);
<a name="l01128"></a>01128   assert(vx.<a class="code" href="classDoubleVect.html#ad2d21b364e1c6559771970596a25c006" title="Identique a size_array()">size_totale</a>() == vect_size_tot); <span class="comment">//!&lt; this test is necessary if md is null</span>
<a name="l01129"></a>01129 <span class="comment"></span>  assert(vx.<a class="code" href="classDoubleVect.html#a0d16d30580c90526e4895388fb44be5d">get_md_vector</a>() == md);
<a name="l01130"></a>01130 <span class="comment">// Determine blocs of data to process, depending on &quot; opt&quot;</span>
<a name="l01131"></a>01131   <span class="keywordtype">int</span> nblocs_left = 1;
<a name="l01132"></a>01132   <span class="keywordtype">int</span> one_bloc[2];
<a name="l01133"></a>01133   <span class="keyword">const</span> <span class="keywordtype">int</span> *bloc_ptr;
<a name="l01134"></a>01134   <span class="keywordflow">if</span> ( opt != <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caad18680091a9f62247573cb3caa6450b9">VECT_ALL_ITEMS</a> &amp;&amp; md.<a class="code" href="classMD__Vector.html#a4165c00904b7096274e38fdc7ca340f4">non_nul</a>())
<a name="l01135"></a>01135     {
<a name="l01136"></a>01136       assert( opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a> ||  opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caab47906d8d2e6c20f8ba32e4acb6edbe0">VECT_REAL_ITEMS</a>);
<a name="l01137"></a>01137       <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; items_blocs = ( opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a>) ? md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a7f6b6d0b7babfec0cce590cdea5bca53">get_items_to_sum</a>() : md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a99334ac2566d9457c8d4890ba20883ea">get_items_to_compute</a>();
<a name="l01138"></a>01138       assert(items_blocs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() % 2 == 0);
<a name="l01139"></a>01139       nblocs_left = items_blocs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() &gt;&gt; 1;
<a name="l01140"></a>01140       bloc_ptr = items_blocs.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
<a name="l01141"></a>01141     }
<a name="l01142"></a>01142   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (vect_size_tot &gt; 0)
<a name="l01143"></a>01143     {
<a name="l01144"></a>01144 <span class="comment">// attention, si vect_size_tot est nul, line_size a le droit d&#39;etre nul</span>
<a name="l01145"></a>01145 <span class="comment">// Compute all data, in the vector (including virtual data), build a big bloc:</span>
<a name="l01146"></a>01146       nblocs_left = 1;
<a name="l01147"></a>01147       bloc_ptr = one_bloc;
<a name="l01148"></a>01148       one_bloc[0] = 0;
<a name="l01149"></a>01149       one_bloc[1] = vect_size_tot / line_size;
<a name="l01150"></a>01150     }
<a name="l01151"></a>01151   <span class="keywordflow">else</span>
<a name="l01152"></a>01152     {
<a name="l01153"></a>01153 <span class="comment">// raccourci pour les tableaux vides (evite le cas particulier line_size == 0)</span>
<a name="l01154"></a>01154       return ;
<a name="l01155"></a>01155     }
<a name="l01156"></a>01156   <span class="keywordtype">double</span> *resu_base = resu.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
<a name="l01157"></a>01157   <span class="keyword">const</span> <span class="keywordtype">double</span> *x_base = vx.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
<a name="l01158"></a>01158   <span class="keywordflow">for</span> (; nblocs_left; nblocs_left--)
<a name="l01159"></a>01159     {
<a name="l01160"></a>01160 <span class="comment">// Get index of next bloc start:</span>
<a name="l01161"></a>01161       <span class="keyword">const</span> <span class="keywordtype">int</span> begin_bloc = (*(bloc_ptr++)) * line_size;
<a name="l01162"></a>01162       <span class="keyword">const</span> <span class="keywordtype">int</span> end_bloc = (*(bloc_ptr++)) * line_size;
<a name="l01163"></a>01163       assert(begin_bloc &gt;= 0 &amp;&amp; end_bloc &lt;= vect_size_tot &amp;&amp; end_bloc &gt;= begin_bloc);
<a name="l01164"></a>01164       <span class="keywordtype">double</span>* resu_ptr = resu_base + begin_bloc;
<a name="l01165"></a>01165       <span class="keyword">const</span> <span class="keywordtype">double</span>* x_ptr = x_base + begin_bloc;
<a name="l01166"></a>01166       <span class="keywordtype">int</span> count = end_bloc - begin_bloc;
<a name="l01167"></a>01167       <span class="keywordflow">for</span> (; count; count--)
<a name="l01168"></a>01168         {
<a name="l01169"></a>01169           <span class="keyword">const</span> <span class="keywordtype">double</span> x = *x_ptr;
<a name="l01170"></a>01170           <span class="keywordtype">double</span>&amp; p_resu = *(resu_ptr++);
<a name="l01171"></a>01171           p_resu -= x;
<a name="l01172"></a>01172           x_ptr++;
<a name="l01173"></a>01173         }
<a name="l01174"></a>01174     }
<a name="l01175"></a>01175 <span class="comment">// In debug mode, put invalid values where data has not been computed</span>
<a name="l01176"></a>01176 <span class="preprocessor">#ifndef NDEBUG</span>
<a name="l01177"></a>01177 <span class="preprocessor"></span>  <a class="code" href="DoubleVect_8cpp.html#ad4995bc506ff841ba67ce56a43886902">invalidate_data</a>(resu,  opt);
<a name="l01178"></a>01178 <span class="preprocessor">#endif</span>
<a name="l01179"></a>01179 <span class="preprocessor"></span>  return ;
<a name="l01180"></a>01180 }
<a name="l01181"></a><a class="code" href="DoubleVect_8h.html#a12df8cf71e9387bcbbfae989349c2b34">01181</a> <span class="keywordtype">void</span> <a class="code" href="DoubleVect_8cpp.html#a813958fe17f5746cc80e1e21d0b10a6a">operator_sub</a>(<a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; resu, <span class="keyword">const</span> <span class="keywordtype">double</span> x, <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a> opt)
<a name="l01182"></a>01182 {
<a name="l01183"></a>01183 
<a name="l01184"></a>01184 <span class="comment">// Master vect donne la structure de reference, les autres vecteurs</span>
<a name="l01185"></a>01185 <span class="comment">// doivent avoir la meme structure.</span>
<a name="l01186"></a>01186   <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; master_vect = resu;
<a name="l01187"></a>01187   <span class="keywordtype">int</span> line_size = master_vect.<a class="code" href="classDoubleVect.html#ab02d01cd1bdab66fbd66f9a47cc29e10">line_size</a>();
<a name="l01188"></a>01188   <span class="keyword">const</span> <a class="code" href="classMD__Vector.html" title=": Cette classe est un DERIV mais l&#39;objet pointe est partage entre plusieurs instances de cette classe...">MD_Vector</a>&amp; md = master_vect.<a class="code" href="classDoubleVect.html#a0d16d30580c90526e4895388fb44be5d">get_md_vector</a>();
<a name="l01189"></a>01189   <span class="keyword">const</span> <span class="keywordtype">int</span> vect_size_tot = master_vect.<a class="code" href="classDoubleVect.html#ad2d21b364e1c6559771970596a25c006" title="Identique a size_array()">size_totale</a>();
<a name="l01190"></a>01190 <span class="comment">// Determine blocs of data to process, depending on &quot; opt&quot;</span>
<a name="l01191"></a>01191   <span class="keywordtype">int</span> nblocs_left = 1;
<a name="l01192"></a>01192   <span class="keywordtype">int</span> one_bloc[2];
<a name="l01193"></a>01193   <span class="keyword">const</span> <span class="keywordtype">int</span> *bloc_ptr;
<a name="l01194"></a>01194   <span class="keywordflow">if</span> ( opt != <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caad18680091a9f62247573cb3caa6450b9">VECT_ALL_ITEMS</a> &amp;&amp; md.<a class="code" href="classMD__Vector.html#a4165c00904b7096274e38fdc7ca340f4">non_nul</a>())
<a name="l01195"></a>01195     {
<a name="l01196"></a>01196       assert( opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a> ||  opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caab47906d8d2e6c20f8ba32e4acb6edbe0">VECT_REAL_ITEMS</a>);
<a name="l01197"></a>01197       <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; items_blocs = ( opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a>) ? md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a7f6b6d0b7babfec0cce590cdea5bca53">get_items_to_sum</a>() : md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a99334ac2566d9457c8d4890ba20883ea">get_items_to_compute</a>();
<a name="l01198"></a>01198       assert(items_blocs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() % 2 == 0);
<a name="l01199"></a>01199       nblocs_left = items_blocs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() &gt;&gt; 1;
<a name="l01200"></a>01200       bloc_ptr = items_blocs.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
<a name="l01201"></a>01201     }
<a name="l01202"></a>01202   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (vect_size_tot &gt; 0)
<a name="l01203"></a>01203     {
<a name="l01204"></a>01204 <span class="comment">// attention, si vect_size_tot est nul, line_size a le droit d&#39;etre nul</span>
<a name="l01205"></a>01205 <span class="comment">// Compute all data, in the vector (including virtual data), build a big bloc:</span>
<a name="l01206"></a>01206       nblocs_left = 1;
<a name="l01207"></a>01207       bloc_ptr = one_bloc;
<a name="l01208"></a>01208       one_bloc[0] = 0;
<a name="l01209"></a>01209       one_bloc[1] = vect_size_tot / line_size;
<a name="l01210"></a>01210     }
<a name="l01211"></a>01211   <span class="keywordflow">else</span>
<a name="l01212"></a>01212     {
<a name="l01213"></a>01213 <span class="comment">// raccourci pour les tableaux vides (evite le cas particulier line_size == 0)</span>
<a name="l01214"></a>01214       return ;
<a name="l01215"></a>01215     }
<a name="l01216"></a>01216   <span class="keywordtype">double</span> *resu_base = resu.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
<a name="l01217"></a>01217   <span class="keywordflow">for</span> (; nblocs_left; nblocs_left--)
<a name="l01218"></a>01218     {
<a name="l01219"></a>01219 <span class="comment">// Get index of next bloc start:</span>
<a name="l01220"></a>01220       <span class="keyword">const</span> <span class="keywordtype">int</span> begin_bloc = (*(bloc_ptr++)) * line_size;
<a name="l01221"></a>01221       <span class="keyword">const</span> <span class="keywordtype">int</span> end_bloc = (*(bloc_ptr++)) * line_size;
<a name="l01222"></a>01222       assert(begin_bloc &gt;= 0 &amp;&amp; end_bloc &lt;= vect_size_tot &amp;&amp; end_bloc &gt;= begin_bloc);
<a name="l01223"></a>01223       <span class="keywordtype">double</span>* resu_ptr = resu_base + begin_bloc;
<a name="l01224"></a>01224       <span class="keywordtype">int</span> count = end_bloc - begin_bloc;
<a name="l01225"></a>01225       <span class="keywordflow">for</span> (; count; count--)
<a name="l01226"></a>01226         {
<a name="l01227"></a>01227           <span class="keywordtype">double</span>&amp; p_resu = *(resu_ptr++);
<a name="l01228"></a>01228           p_resu -= x;
<a name="l01229"></a>01229         }
<a name="l01230"></a>01230     }
<a name="l01231"></a>01231 <span class="comment">// In debug mode, put invalid values where data has not been computed</span>
<a name="l01232"></a>01232 <span class="preprocessor">#ifndef NDEBUG</span>
<a name="l01233"></a>01233 <span class="preprocessor"></span>  <a class="code" href="DoubleVect_8cpp.html#ad4995bc506ff841ba67ce56a43886902">invalidate_data</a>(resu,  opt);
<a name="l01234"></a>01234 <span class="preprocessor">#endif</span>
<a name="l01235"></a>01235 <span class="preprocessor"></span>  return ;
<a name="l01236"></a>01236 }
<a name="l01237"></a><a class="code" href="DoubleVect_8h.html#a10565642b9ebf320d150f70cb222cc17">01237</a> <span class="keywordtype">void</span> <a class="code" href="DoubleVect_8cpp.html#a2b776b5741992c8b6069737fe41b1298">operator_multiply</a>(<a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; resu, <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; vx, <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a> opt)
<a name="l01238"></a>01238 {
<a name="l01239"></a>01239 
<a name="l01240"></a>01240 <span class="comment">// Master vect donne la structure de reference, les autres vecteurs</span>
<a name="l01241"></a>01241 <span class="comment">// doivent avoir la meme structure.</span>
<a name="l01242"></a>01242   <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; master_vect = resu;
<a name="l01243"></a>01243   <span class="keywordtype">int</span> line_size = master_vect.<a class="code" href="classDoubleVect.html#ab02d01cd1bdab66fbd66f9a47cc29e10">line_size</a>();
<a name="l01244"></a>01244   <span class="keyword">const</span> <a class="code" href="classMD__Vector.html" title=": Cette classe est un DERIV mais l&#39;objet pointe est partage entre plusieurs instances de cette classe...">MD_Vector</a>&amp; md = master_vect.<a class="code" href="classDoubleVect.html#a0d16d30580c90526e4895388fb44be5d">get_md_vector</a>();
<a name="l01245"></a>01245   <span class="keyword">const</span> <span class="keywordtype">int</span> vect_size_tot = master_vect.<a class="code" href="classDoubleVect.html#ad2d21b364e1c6559771970596a25c006" title="Identique a size_array()">size_totale</a>();
<a name="l01246"></a>01246   assert(vx.<a class="code" href="classDoubleVect.html#ab02d01cd1bdab66fbd66f9a47cc29e10">line_size</a>() == line_size);
<a name="l01247"></a>01247   assert(vx.<a class="code" href="classDoubleVect.html#ad2d21b364e1c6559771970596a25c006" title="Identique a size_array()">size_totale</a>() == vect_size_tot); <span class="comment">//!&lt; this test is necessary if md is null</span>
<a name="l01248"></a>01248 <span class="comment"></span>  assert(vx.<a class="code" href="classDoubleVect.html#a0d16d30580c90526e4895388fb44be5d">get_md_vector</a>() == md);
<a name="l01249"></a>01249 <span class="comment">// Determine blocs of data to process, depending on &quot; opt&quot;</span>
<a name="l01250"></a>01250   <span class="keywordtype">int</span> nblocs_left = 1;
<a name="l01251"></a>01251   <span class="keywordtype">int</span> one_bloc[2];
<a name="l01252"></a>01252   <span class="keyword">const</span> <span class="keywordtype">int</span> *bloc_ptr;
<a name="l01253"></a>01253   <span class="keywordflow">if</span> ( opt != <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caad18680091a9f62247573cb3caa6450b9">VECT_ALL_ITEMS</a> &amp;&amp; md.<a class="code" href="classMD__Vector.html#a4165c00904b7096274e38fdc7ca340f4">non_nul</a>())
<a name="l01254"></a>01254     {
<a name="l01255"></a>01255       assert( opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a> ||  opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caab47906d8d2e6c20f8ba32e4acb6edbe0">VECT_REAL_ITEMS</a>);
<a name="l01256"></a>01256       <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; items_blocs = ( opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a>) ? md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a7f6b6d0b7babfec0cce590cdea5bca53">get_items_to_sum</a>() : md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a99334ac2566d9457c8d4890ba20883ea">get_items_to_compute</a>();
<a name="l01257"></a>01257       assert(items_blocs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() % 2 == 0);
<a name="l01258"></a>01258       nblocs_left = items_blocs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() &gt;&gt; 1;
<a name="l01259"></a>01259       bloc_ptr = items_blocs.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
<a name="l01260"></a>01260     }
<a name="l01261"></a>01261   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (vect_size_tot &gt; 0)
<a name="l01262"></a>01262     {
<a name="l01263"></a>01263 <span class="comment">// attention, si vect_size_tot est nul, line_size a le droit d&#39;etre nul</span>
<a name="l01264"></a>01264 <span class="comment">// Compute all data, in the vector (including virtual data), build a big bloc:</span>
<a name="l01265"></a>01265       nblocs_left = 1;
<a name="l01266"></a>01266       bloc_ptr = one_bloc;
<a name="l01267"></a>01267       one_bloc[0] = 0;
<a name="l01268"></a>01268       one_bloc[1] = vect_size_tot / line_size;
<a name="l01269"></a>01269     }
<a name="l01270"></a>01270   <span class="keywordflow">else</span>
<a name="l01271"></a>01271     {
<a name="l01272"></a>01272 <span class="comment">// raccourci pour les tableaux vides (evite le cas particulier line_size == 0)</span>
<a name="l01273"></a>01273       return ;
<a name="l01274"></a>01274     }
<a name="l01275"></a>01275   <span class="keywordtype">double</span> *resu_base = resu.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
<a name="l01276"></a>01276   <span class="keyword">const</span> <span class="keywordtype">double</span> *x_base = vx.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
<a name="l01277"></a>01277   <span class="keywordflow">for</span> (; nblocs_left; nblocs_left--)
<a name="l01278"></a>01278     {
<a name="l01279"></a>01279 <span class="comment">// Get index of next bloc start:</span>
<a name="l01280"></a>01280       <span class="keyword">const</span> <span class="keywordtype">int</span> begin_bloc = (*(bloc_ptr++)) * line_size;
<a name="l01281"></a>01281       <span class="keyword">const</span> <span class="keywordtype">int</span> end_bloc = (*(bloc_ptr++)) * line_size;
<a name="l01282"></a>01282       assert(begin_bloc &gt;= 0 &amp;&amp; end_bloc &lt;= vect_size_tot &amp;&amp; end_bloc &gt;= begin_bloc);
<a name="l01283"></a>01283       <span class="keywordtype">double</span>* resu_ptr = resu_base + begin_bloc;
<a name="l01284"></a>01284       <span class="keyword">const</span> <span class="keywordtype">double</span>* x_ptr = x_base + begin_bloc;
<a name="l01285"></a>01285       <span class="keywordtype">int</span> count = end_bloc - begin_bloc;
<a name="l01286"></a>01286       <span class="keywordflow">for</span> (; count; count--)
<a name="l01287"></a>01287         {
<a name="l01288"></a>01288           <span class="keyword">const</span> <span class="keywordtype">double</span> x = *x_ptr;
<a name="l01289"></a>01289           <span class="keywordtype">double</span>&amp; p_resu = *(resu_ptr++);
<a name="l01290"></a>01290           p_resu *= x;
<a name="l01291"></a>01291           x_ptr++;
<a name="l01292"></a>01292         }
<a name="l01293"></a>01293     }
<a name="l01294"></a>01294 <span class="comment">// In debug mode, put invalid values where data has not been computed</span>
<a name="l01295"></a>01295 <span class="preprocessor">#ifndef NDEBUG</span>
<a name="l01296"></a>01296 <span class="preprocessor"></span>  <a class="code" href="DoubleVect_8cpp.html#ad4995bc506ff841ba67ce56a43886902">invalidate_data</a>(resu,  opt);
<a name="l01297"></a>01297 <span class="preprocessor">#endif</span>
<a name="l01298"></a>01298 <span class="preprocessor"></span>  return ;
<a name="l01299"></a>01299 }
<a name="l01300"></a><a class="code" href="DoubleVect_8h.html#a56ffed735faba408ceac889d86fcc9c8">01300</a> <span class="keywordtype">void</span> <a class="code" href="DoubleVect_8cpp.html#a2b776b5741992c8b6069737fe41b1298">operator_multiply</a>(<a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; resu, <span class="keyword">const</span> <span class="keywordtype">double</span> x, <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a> opt)
<a name="l01301"></a>01301 {
<a name="l01302"></a>01302 
<a name="l01303"></a>01303 <span class="comment">// Master vect donne la structure de reference, les autres vecteurs</span>
<a name="l01304"></a>01304 <span class="comment">// doivent avoir la meme structure.</span>
<a name="l01305"></a>01305   <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; master_vect = resu;
<a name="l01306"></a>01306   <span class="keywordtype">int</span> line_size = master_vect.<a class="code" href="classDoubleVect.html#ab02d01cd1bdab66fbd66f9a47cc29e10">line_size</a>();
<a name="l01307"></a>01307   <span class="keyword">const</span> <a class="code" href="classMD__Vector.html" title=": Cette classe est un DERIV mais l&#39;objet pointe est partage entre plusieurs instances de cette classe...">MD_Vector</a>&amp; md = master_vect.<a class="code" href="classDoubleVect.html#a0d16d30580c90526e4895388fb44be5d">get_md_vector</a>();
<a name="l01308"></a>01308   <span class="keyword">const</span> <span class="keywordtype">int</span> vect_size_tot = master_vect.<a class="code" href="classDoubleVect.html#ad2d21b364e1c6559771970596a25c006" title="Identique a size_array()">size_totale</a>();
<a name="l01309"></a>01309 <span class="comment">// Determine blocs of data to process, depending on &quot; opt&quot;</span>
<a name="l01310"></a>01310   <span class="keywordtype">int</span> nblocs_left = 1;
<a name="l01311"></a>01311   <span class="keywordtype">int</span> one_bloc[2];
<a name="l01312"></a>01312   <span class="keyword">const</span> <span class="keywordtype">int</span> *bloc_ptr;
<a name="l01313"></a>01313   <span class="keywordflow">if</span> ( opt != <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caad18680091a9f62247573cb3caa6450b9">VECT_ALL_ITEMS</a> &amp;&amp; md.<a class="code" href="classMD__Vector.html#a4165c00904b7096274e38fdc7ca340f4">non_nul</a>())
<a name="l01314"></a>01314     {
<a name="l01315"></a>01315       assert( opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a> ||  opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caab47906d8d2e6c20f8ba32e4acb6edbe0">VECT_REAL_ITEMS</a>);
<a name="l01316"></a>01316       <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; items_blocs = ( opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a>) ? md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a7f6b6d0b7babfec0cce590cdea5bca53">get_items_to_sum</a>() : md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a99334ac2566d9457c8d4890ba20883ea">get_items_to_compute</a>();
<a name="l01317"></a>01317       assert(items_blocs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() % 2 == 0);
<a name="l01318"></a>01318       nblocs_left = items_blocs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() &gt;&gt; 1;
<a name="l01319"></a>01319       bloc_ptr = items_blocs.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
<a name="l01320"></a>01320     }
<a name="l01321"></a>01321   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (vect_size_tot &gt; 0)
<a name="l01322"></a>01322     {
<a name="l01323"></a>01323 <span class="comment">// attention, si vect_size_tot est nul, line_size a le droit d&#39;etre nul</span>
<a name="l01324"></a>01324 <span class="comment">// Compute all data, in the vector (including virtual data), build a big bloc:</span>
<a name="l01325"></a>01325       nblocs_left = 1;
<a name="l01326"></a>01326       bloc_ptr = one_bloc;
<a name="l01327"></a>01327       one_bloc[0] = 0;
<a name="l01328"></a>01328       one_bloc[1] = vect_size_tot / line_size;
<a name="l01329"></a>01329     }
<a name="l01330"></a>01330   <span class="keywordflow">else</span>
<a name="l01331"></a>01331     {
<a name="l01332"></a>01332 <span class="comment">// raccourci pour les tableaux vides (evite le cas particulier line_size == 0)</span>
<a name="l01333"></a>01333       return ;
<a name="l01334"></a>01334     }
<a name="l01335"></a>01335   <span class="keywordtype">double</span> *resu_base = resu.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
<a name="l01336"></a>01336   <span class="keywordflow">for</span> (; nblocs_left; nblocs_left--)
<a name="l01337"></a>01337     {
<a name="l01338"></a>01338 <span class="comment">// Get index of next bloc start:</span>
<a name="l01339"></a>01339       <span class="keyword">const</span> <span class="keywordtype">int</span> begin_bloc = (*(bloc_ptr++)) * line_size;
<a name="l01340"></a>01340       <span class="keyword">const</span> <span class="keywordtype">int</span> end_bloc = (*(bloc_ptr++)) * line_size;
<a name="l01341"></a>01341       assert(begin_bloc &gt;= 0 &amp;&amp; end_bloc &lt;= vect_size_tot &amp;&amp; end_bloc &gt;= begin_bloc);
<a name="l01342"></a>01342       <span class="keywordtype">double</span>* resu_ptr = resu_base + begin_bloc;
<a name="l01343"></a>01343       <span class="keywordtype">int</span> count = end_bloc - begin_bloc;
<a name="l01344"></a>01344       <span class="keywordflow">for</span> (; count; count--)
<a name="l01345"></a>01345         {
<a name="l01346"></a>01346           <span class="keywordtype">double</span>&amp; p_resu = *(resu_ptr++);
<a name="l01347"></a>01347           p_resu *= x;
<a name="l01348"></a>01348         }
<a name="l01349"></a>01349     }
<a name="l01350"></a>01350 <span class="comment">// In debug mode, put invalid values where data has not been computed</span>
<a name="l01351"></a>01351 <span class="preprocessor">#ifndef NDEBUG</span>
<a name="l01352"></a>01352 <span class="preprocessor"></span>  <a class="code" href="DoubleVect_8cpp.html#ad4995bc506ff841ba67ce56a43886902">invalidate_data</a>(resu,  opt);
<a name="l01353"></a>01353 <span class="preprocessor">#endif</span>
<a name="l01354"></a>01354 <span class="preprocessor"></span>  return ;
<a name="l01355"></a>01355 }
<a name="l01356"></a><a class="code" href="DoubleVect_8h.html#af2557f3c6aafa6b2953c27a533c98b74">01356</a> <span class="keywordtype">void</span> <a class="code" href="DoubleVect_8cpp.html#a037eedbd9167441dbd379675d4b2fe55">operator_negate</a>(<a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; resu, <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a> opt)
<a name="l01357"></a>01357 {
<a name="l01358"></a>01358 
<a name="l01359"></a>01359 <span class="comment">// Master vect donne la structure de reference, les autres vecteurs</span>
<a name="l01360"></a>01360 <span class="comment">// doivent avoir la meme structure.</span>
<a name="l01361"></a>01361   <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; master_vect = resu;
<a name="l01362"></a>01362   <span class="keywordtype">int</span> line_size = master_vect.<a class="code" href="classDoubleVect.html#ab02d01cd1bdab66fbd66f9a47cc29e10">line_size</a>();
<a name="l01363"></a>01363   <span class="keyword">const</span> <a class="code" href="classMD__Vector.html" title=": Cette classe est un DERIV mais l&#39;objet pointe est partage entre plusieurs instances de cette classe...">MD_Vector</a>&amp; md = master_vect.<a class="code" href="classDoubleVect.html#a0d16d30580c90526e4895388fb44be5d">get_md_vector</a>();
<a name="l01364"></a>01364   <span class="keyword">const</span> <span class="keywordtype">int</span> vect_size_tot = master_vect.<a class="code" href="classDoubleVect.html#ad2d21b364e1c6559771970596a25c006" title="Identique a size_array()">size_totale</a>();
<a name="l01365"></a>01365 <span class="comment">// Determine blocs of data to process, depending on &quot; opt&quot;</span>
<a name="l01366"></a>01366   <span class="keywordtype">int</span> nblocs_left = 1;
<a name="l01367"></a>01367   <span class="keywordtype">int</span> one_bloc[2];
<a name="l01368"></a>01368   <span class="keyword">const</span> <span class="keywordtype">int</span> *bloc_ptr;
<a name="l01369"></a>01369   <span class="keywordflow">if</span> ( opt != <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caad18680091a9f62247573cb3caa6450b9">VECT_ALL_ITEMS</a> &amp;&amp; md.<a class="code" href="classMD__Vector.html#a4165c00904b7096274e38fdc7ca340f4">non_nul</a>())
<a name="l01370"></a>01370     {
<a name="l01371"></a>01371       assert( opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a> ||  opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caab47906d8d2e6c20f8ba32e4acb6edbe0">VECT_REAL_ITEMS</a>);
<a name="l01372"></a>01372       <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; items_blocs = ( opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a>) ? md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a7f6b6d0b7babfec0cce590cdea5bca53">get_items_to_sum</a>() : md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a99334ac2566d9457c8d4890ba20883ea">get_items_to_compute</a>();
<a name="l01373"></a>01373       assert(items_blocs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() % 2 == 0);
<a name="l01374"></a>01374       nblocs_left = items_blocs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() &gt;&gt; 1;
<a name="l01375"></a>01375       bloc_ptr = items_blocs.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
<a name="l01376"></a>01376     }
<a name="l01377"></a>01377   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (vect_size_tot &gt; 0)
<a name="l01378"></a>01378     {
<a name="l01379"></a>01379 <span class="comment">// attention, si vect_size_tot est nul, line_size a le droit d&#39;etre nul</span>
<a name="l01380"></a>01380 <span class="comment">// Compute all data, in the vector (including virtual data), build a big bloc:</span>
<a name="l01381"></a>01381       nblocs_left = 1;
<a name="l01382"></a>01382       bloc_ptr = one_bloc;
<a name="l01383"></a>01383       one_bloc[0] = 0;
<a name="l01384"></a>01384       one_bloc[1] = vect_size_tot / line_size;
<a name="l01385"></a>01385     }
<a name="l01386"></a>01386   <span class="keywordflow">else</span>
<a name="l01387"></a>01387     {
<a name="l01388"></a>01388 <span class="comment">// raccourci pour les tableaux vides (evite le cas particulier line_size == 0)</span>
<a name="l01389"></a>01389       return ;
<a name="l01390"></a>01390     }
<a name="l01391"></a>01391   <span class="keywordtype">double</span> *resu_base = resu.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
<a name="l01392"></a>01392   <span class="keywordflow">for</span> (; nblocs_left; nblocs_left--)
<a name="l01393"></a>01393     {
<a name="l01394"></a>01394 <span class="comment">// Get index of next bloc start:</span>
<a name="l01395"></a>01395       <span class="keyword">const</span> <span class="keywordtype">int</span> begin_bloc = (*(bloc_ptr++)) * line_size;
<a name="l01396"></a>01396       <span class="keyword">const</span> <span class="keywordtype">int</span> end_bloc = (*(bloc_ptr++)) * line_size;
<a name="l01397"></a>01397       assert(begin_bloc &gt;= 0 &amp;&amp; end_bloc &lt;= vect_size_tot &amp;&amp; end_bloc &gt;= begin_bloc);
<a name="l01398"></a>01398       <span class="keywordtype">double</span>* resu_ptr = resu_base + begin_bloc;
<a name="l01399"></a>01399       <span class="keywordtype">int</span> count = end_bloc - begin_bloc;
<a name="l01400"></a>01400       <span class="keywordflow">for</span> (; count; count--)
<a name="l01401"></a>01401         {
<a name="l01402"></a>01402           <span class="keywordtype">double</span>&amp; p_resu = *(resu_ptr++);
<a name="l01403"></a>01403           p_resu = -p_resu;
<a name="l01404"></a>01404         }
<a name="l01405"></a>01405     }
<a name="l01406"></a>01406 <span class="comment">// In debug mode, put invalid values where data has not been computed</span>
<a name="l01407"></a>01407 <span class="preprocessor">#ifndef NDEBUG</span>
<a name="l01408"></a>01408 <span class="preprocessor"></span>  <a class="code" href="DoubleVect_8cpp.html#ad4995bc506ff841ba67ce56a43886902">invalidate_data</a>(resu,  opt);
<a name="l01409"></a>01409 <span class="preprocessor">#endif</span>
<a name="l01410"></a>01410 <span class="preprocessor"></span>  return ;
<a name="l01411"></a>01411 }
<a name="l01412"></a><a class="code" href="DoubleVect_8h.html#adc8293ea496f2e2aabbaa2c28e92ec8c">01412</a> <span class="keywordtype">void</span> <a class="code" href="DoubleVect_8cpp.html#ad0e13908fed9f476adc797982dce010a">operator_egal</a>(<a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; resu, <span class="keywordtype">double</span> x, <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a> opt)
<a name="l01413"></a>01413 {
<a name="l01414"></a>01414 
<a name="l01415"></a>01415 <span class="comment">// Master vect donne la structure de reference, les autres vecteurs</span>
<a name="l01416"></a>01416 <span class="comment">// doivent avoir la meme structure.</span>
<a name="l01417"></a>01417   <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; master_vect = resu;
<a name="l01418"></a>01418   <span class="keywordtype">int</span> line_size = master_vect.<a class="code" href="classDoubleVect.html#ab02d01cd1bdab66fbd66f9a47cc29e10">line_size</a>();
<a name="l01419"></a>01419   <span class="keyword">const</span> <a class="code" href="classMD__Vector.html" title=": Cette classe est un DERIV mais l&#39;objet pointe est partage entre plusieurs instances de cette classe...">MD_Vector</a>&amp; md = master_vect.<a class="code" href="classDoubleVect.html#a0d16d30580c90526e4895388fb44be5d">get_md_vector</a>();
<a name="l01420"></a>01420   <span class="keyword">const</span> <span class="keywordtype">int</span> vect_size_tot = master_vect.<a class="code" href="classDoubleVect.html#ad2d21b364e1c6559771970596a25c006" title="Identique a size_array()">size_totale</a>();
<a name="l01421"></a>01421 <span class="comment">// Determine blocs of data to process, depending on &quot; opt&quot;</span>
<a name="l01422"></a>01422   <span class="keywordtype">int</span> nblocs_left = 1;
<a name="l01423"></a>01423   <span class="keywordtype">int</span> one_bloc[2];
<a name="l01424"></a>01424   <span class="keyword">const</span> <span class="keywordtype">int</span> *bloc_ptr;
<a name="l01425"></a>01425   <span class="keywordflow">if</span> ( opt != <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caad18680091a9f62247573cb3caa6450b9">VECT_ALL_ITEMS</a> &amp;&amp; md.<a class="code" href="classMD__Vector.html#a4165c00904b7096274e38fdc7ca340f4">non_nul</a>())
<a name="l01426"></a>01426     {
<a name="l01427"></a>01427       assert( opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a> ||  opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caab47906d8d2e6c20f8ba32e4acb6edbe0">VECT_REAL_ITEMS</a>);
<a name="l01428"></a>01428       <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; items_blocs = ( opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a>) ? md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a7f6b6d0b7babfec0cce590cdea5bca53">get_items_to_sum</a>() : md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a99334ac2566d9457c8d4890ba20883ea">get_items_to_compute</a>();
<a name="l01429"></a>01429       assert(items_blocs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() % 2 == 0);
<a name="l01430"></a>01430       nblocs_left = items_blocs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() &gt;&gt; 1;
<a name="l01431"></a>01431       bloc_ptr = items_blocs.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
<a name="l01432"></a>01432     }
<a name="l01433"></a>01433   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (vect_size_tot &gt; 0)
<a name="l01434"></a>01434     {
<a name="l01435"></a>01435 <span class="comment">// attention, si vect_size_tot est nul, line_size a le droit d&#39;etre nul</span>
<a name="l01436"></a>01436 <span class="comment">// Compute all data, in the vector (including virtual data), build a big bloc:</span>
<a name="l01437"></a>01437       nblocs_left = 1;
<a name="l01438"></a>01438       bloc_ptr = one_bloc;
<a name="l01439"></a>01439       one_bloc[0] = 0;
<a name="l01440"></a>01440       one_bloc[1] = vect_size_tot / line_size;
<a name="l01441"></a>01441     }
<a name="l01442"></a>01442   <span class="keywordflow">else</span>
<a name="l01443"></a>01443     {
<a name="l01444"></a>01444 <span class="comment">// raccourci pour les tableaux vides (evite le cas particulier line_size == 0)</span>
<a name="l01445"></a>01445       return ;
<a name="l01446"></a>01446     }
<a name="l01447"></a>01447   <span class="keywordtype">double</span> *resu_base = resu.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
<a name="l01448"></a>01448   <span class="keywordflow">for</span> (; nblocs_left; nblocs_left--)
<a name="l01449"></a>01449     {
<a name="l01450"></a>01450 <span class="comment">// Get index of next bloc start:</span>
<a name="l01451"></a>01451       <span class="keyword">const</span> <span class="keywordtype">int</span> begin_bloc = (*(bloc_ptr++)) * line_size;
<a name="l01452"></a>01452       <span class="keyword">const</span> <span class="keywordtype">int</span> end_bloc = (*(bloc_ptr++)) * line_size;
<a name="l01453"></a>01453       assert(begin_bloc &gt;= 0 &amp;&amp; end_bloc &lt;= vect_size_tot &amp;&amp; end_bloc &gt;= begin_bloc);
<a name="l01454"></a>01454       <span class="keywordtype">double</span>* resu_ptr = resu_base + begin_bloc;
<a name="l01455"></a>01455       <span class="keywordtype">int</span> count = end_bloc - begin_bloc;
<a name="l01456"></a>01456       <span class="keywordflow">for</span> (; count; count--)
<a name="l01457"></a>01457         {
<a name="l01458"></a>01458           <span class="keywordtype">double</span>&amp; p_resu = *(resu_ptr++);
<a name="l01459"></a>01459           p_resu = x;
<a name="l01460"></a>01460         }
<a name="l01461"></a>01461     }
<a name="l01462"></a>01462 <span class="comment">// In debug mode, put invalid values where data has not been computed</span>
<a name="l01463"></a>01463 <span class="preprocessor">#ifndef NDEBUG</span>
<a name="l01464"></a>01464 <span class="preprocessor"></span>  <a class="code" href="DoubleVect_8cpp.html#ad4995bc506ff841ba67ce56a43886902">invalidate_data</a>(resu,  opt);
<a name="l01465"></a>01465 <span class="preprocessor">#endif</span>
<a name="l01466"></a>01466 <span class="preprocessor"></span>  return ;
<a name="l01467"></a>01467 }
<a name="l01468"></a><a class="code" href="DoubleVect_8h.html#a4341a66c222e0dde395713a05e4a9c62">01468</a> <span class="keywordtype">void</span> <a class="code" href="DoubleVect_8cpp.html#ad0e13908fed9f476adc797982dce010a">operator_egal</a>(<a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; resu, <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; vx, <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a> opt)
<a name="l01469"></a>01469 {
<a name="l01470"></a>01470 
<a name="l01471"></a>01471 <span class="comment">// Master vect donne la structure de reference, les autres vecteurs</span>
<a name="l01472"></a>01472 <span class="comment">// doivent avoir la meme structure.</span>
<a name="l01473"></a>01473   <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; master_vect = resu;
<a name="l01474"></a>01474   <span class="keywordtype">int</span> line_size = master_vect.<a class="code" href="classDoubleVect.html#ab02d01cd1bdab66fbd66f9a47cc29e10">line_size</a>();
<a name="l01475"></a>01475   <span class="keyword">const</span> <a class="code" href="classMD__Vector.html" title=": Cette classe est un DERIV mais l&#39;objet pointe est partage entre plusieurs instances de cette classe...">MD_Vector</a>&amp; md = master_vect.<a class="code" href="classDoubleVect.html#a0d16d30580c90526e4895388fb44be5d">get_md_vector</a>();
<a name="l01476"></a>01476   <span class="keyword">const</span> <span class="keywordtype">int</span> vect_size_tot = master_vect.<a class="code" href="classDoubleVect.html#ad2d21b364e1c6559771970596a25c006" title="Identique a size_array()">size_totale</a>();
<a name="l01477"></a>01477   assert(vx.<a class="code" href="classDoubleVect.html#ab02d01cd1bdab66fbd66f9a47cc29e10">line_size</a>() == line_size);
<a name="l01478"></a>01478   assert(vx.<a class="code" href="classDoubleVect.html#ad2d21b364e1c6559771970596a25c006" title="Identique a size_array()">size_totale</a>() == vect_size_tot); <span class="comment">//!&lt; this test is necessary if md is null</span>
<a name="l01479"></a>01479 <span class="comment"></span>  assert(vx.<a class="code" href="classDoubleVect.html#a0d16d30580c90526e4895388fb44be5d">get_md_vector</a>() == md);
<a name="l01480"></a>01480 <span class="comment">// Determine blocs of data to process, depending on &quot; opt&quot;</span>
<a name="l01481"></a>01481   <span class="keywordtype">int</span> nblocs_left = 1;
<a name="l01482"></a>01482   <span class="keywordtype">int</span> one_bloc[2];
<a name="l01483"></a>01483   <span class="keyword">const</span> <span class="keywordtype">int</span> *bloc_ptr;
<a name="l01484"></a>01484   <span class="keywordflow">if</span> ( opt != <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caad18680091a9f62247573cb3caa6450b9">VECT_ALL_ITEMS</a> &amp;&amp; md.<a class="code" href="classMD__Vector.html#a4165c00904b7096274e38fdc7ca340f4">non_nul</a>())
<a name="l01485"></a>01485     {
<a name="l01486"></a>01486       assert( opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a> ||  opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caab47906d8d2e6c20f8ba32e4acb6edbe0">VECT_REAL_ITEMS</a>);
<a name="l01487"></a>01487       <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; items_blocs = ( opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a>) ? md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a7f6b6d0b7babfec0cce590cdea5bca53">get_items_to_sum</a>() : md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a99334ac2566d9457c8d4890ba20883ea">get_items_to_compute</a>();
<a name="l01488"></a>01488       assert(items_blocs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() % 2 == 0);
<a name="l01489"></a>01489       nblocs_left = items_blocs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() &gt;&gt; 1;
<a name="l01490"></a>01490       bloc_ptr = items_blocs.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
<a name="l01491"></a>01491     }
<a name="l01492"></a>01492   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (vect_size_tot &gt; 0)
<a name="l01493"></a>01493     {
<a name="l01494"></a>01494 <span class="comment">// attention, si vect_size_tot est nul, line_size a le droit d&#39;etre nul</span>
<a name="l01495"></a>01495 <span class="comment">// Compute all data, in the vector (including virtual data), build a big bloc:</span>
<a name="l01496"></a>01496       nblocs_left = 1;
<a name="l01497"></a>01497       bloc_ptr = one_bloc;
<a name="l01498"></a>01498       one_bloc[0] = 0;
<a name="l01499"></a>01499       one_bloc[1] = vect_size_tot / line_size;
<a name="l01500"></a>01500     }
<a name="l01501"></a>01501   <span class="keywordflow">else</span>
<a name="l01502"></a>01502     {
<a name="l01503"></a>01503 <span class="comment">// raccourci pour les tableaux vides (evite le cas particulier line_size == 0)</span>
<a name="l01504"></a>01504       return ;
<a name="l01505"></a>01505     }
<a name="l01506"></a>01506   <span class="keywordtype">double</span> *resu_base = resu.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
<a name="l01507"></a>01507   <span class="keyword">const</span> <span class="keywordtype">double</span> *x_base = vx.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
<a name="l01508"></a>01508   <span class="keywordflow">for</span> (; nblocs_left; nblocs_left--)
<a name="l01509"></a>01509     {
<a name="l01510"></a>01510 <span class="comment">// Get index of next bloc start:</span>
<a name="l01511"></a>01511       <span class="keyword">const</span> <span class="keywordtype">int</span> begin_bloc = (*(bloc_ptr++)) * line_size;
<a name="l01512"></a>01512       <span class="keyword">const</span> <span class="keywordtype">int</span> end_bloc = (*(bloc_ptr++)) * line_size;
<a name="l01513"></a>01513       assert(begin_bloc &gt;= 0 &amp;&amp; end_bloc &lt;= vect_size_tot &amp;&amp; end_bloc &gt;= begin_bloc);
<a name="l01514"></a>01514       <span class="keywordtype">double</span>* resu_ptr = resu_base + begin_bloc;
<a name="l01515"></a>01515       <span class="keyword">const</span> <span class="keywordtype">double</span>* x_ptr = x_base + begin_bloc;
<a name="l01516"></a>01516       <span class="keywordtype">int</span> count = end_bloc - begin_bloc;
<a name="l01517"></a>01517       <span class="keywordflow">for</span> (; count; count--)
<a name="l01518"></a>01518         {
<a name="l01519"></a>01519           <span class="keyword">const</span> <span class="keywordtype">double</span> x = *x_ptr;
<a name="l01520"></a>01520           <span class="keywordtype">double</span>&amp; p_resu = *(resu_ptr++);
<a name="l01521"></a>01521           p_resu = x;
<a name="l01522"></a>01522           x_ptr++;
<a name="l01523"></a>01523         }
<a name="l01524"></a>01524     }
<a name="l01525"></a>01525 <span class="comment">// In debug mode, put invalid values where data has not been computed</span>
<a name="l01526"></a>01526 <span class="preprocessor">#ifndef NDEBUG</span>
<a name="l01527"></a>01527 <span class="preprocessor"></span>  <a class="code" href="DoubleVect_8cpp.html#ad4995bc506ff841ba67ce56a43886902">invalidate_data</a>(resu,  opt);
<a name="l01528"></a>01528 <span class="preprocessor">#endif</span>
<a name="l01529"></a>01529 <span class="preprocessor"></span>  return ;
<a name="l01530"></a>01530 }
<a name="l01531"></a><a class="code" href="DoubleVect_8h.html#ac26a99ec20ecdc679cfa11ef7a7d7b40">01531</a> <span class="keywordtype">void</span> <a class="code" href="DoubleVect_8cpp.html#a3cf7911dc14efcacd03f9915978b2b88">ajoute_alpha_v</a>(<a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; resu, <span class="keywordtype">double</span> alpha, <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; vx, <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a> opt)
<a name="l01532"></a>01532 {
<a name="l01533"></a>01533 
<a name="l01534"></a>01534 <span class="comment">// Master vect donne la structure de reference, les autres vecteurs</span>
<a name="l01535"></a>01535 <span class="comment">// doivent avoir la meme structure.</span>
<a name="l01536"></a>01536   <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; master_vect = resu;
<a name="l01537"></a>01537   <span class="keywordtype">int</span> line_size = master_vect.<a class="code" href="classDoubleVect.html#ab02d01cd1bdab66fbd66f9a47cc29e10">line_size</a>();
<a name="l01538"></a>01538   <span class="keyword">const</span> <a class="code" href="classMD__Vector.html" title=": Cette classe est un DERIV mais l&#39;objet pointe est partage entre plusieurs instances de cette classe...">MD_Vector</a>&amp; md = master_vect.<a class="code" href="classDoubleVect.html#a0d16d30580c90526e4895388fb44be5d">get_md_vector</a>();
<a name="l01539"></a>01539   <span class="keyword">const</span> <span class="keywordtype">int</span> vect_size_tot = master_vect.<a class="code" href="classDoubleVect.html#ad2d21b364e1c6559771970596a25c006" title="Identique a size_array()">size_totale</a>();
<a name="l01540"></a>01540   assert(vx.<a class="code" href="classDoubleVect.html#ab02d01cd1bdab66fbd66f9a47cc29e10">line_size</a>() == line_size);
<a name="l01541"></a>01541   assert(vx.<a class="code" href="classDoubleVect.html#ad2d21b364e1c6559771970596a25c006" title="Identique a size_array()">size_totale</a>() == vect_size_tot); <span class="comment">//!&lt; this test is necessary if md is null</span>
<a name="l01542"></a>01542 <span class="comment"></span>  assert(vx.<a class="code" href="classDoubleVect.html#a0d16d30580c90526e4895388fb44be5d">get_md_vector</a>() == md);
<a name="l01543"></a>01543 <span class="comment">// Determine blocs of data to process, depending on &quot; opt&quot;</span>
<a name="l01544"></a>01544   <span class="keywordtype">int</span> nblocs_left = 1;
<a name="l01545"></a>01545   <span class="keywordtype">int</span> one_bloc[2];
<a name="l01546"></a>01546   <span class="keyword">const</span> <span class="keywordtype">int</span> *bloc_ptr;
<a name="l01547"></a>01547   <span class="keywordflow">if</span> ( opt != <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caad18680091a9f62247573cb3caa6450b9">VECT_ALL_ITEMS</a> &amp;&amp; md.<a class="code" href="classMD__Vector.html#a4165c00904b7096274e38fdc7ca340f4">non_nul</a>())
<a name="l01548"></a>01548     {
<a name="l01549"></a>01549       assert( opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a> ||  opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caab47906d8d2e6c20f8ba32e4acb6edbe0">VECT_REAL_ITEMS</a>);
<a name="l01550"></a>01550       <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; items_blocs = ( opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a>) ? md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a7f6b6d0b7babfec0cce590cdea5bca53">get_items_to_sum</a>() : md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a99334ac2566d9457c8d4890ba20883ea">get_items_to_compute</a>();
<a name="l01551"></a>01551       assert(items_blocs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() % 2 == 0);
<a name="l01552"></a>01552       nblocs_left = items_blocs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() &gt;&gt; 1;
<a name="l01553"></a>01553       bloc_ptr = items_blocs.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
<a name="l01554"></a>01554     }
<a name="l01555"></a>01555   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (vect_size_tot &gt; 0)
<a name="l01556"></a>01556     {
<a name="l01557"></a>01557 <span class="comment">// attention, si vect_size_tot est nul, line_size a le droit d&#39;etre nul</span>
<a name="l01558"></a>01558 <span class="comment">// Compute all data, in the vector (including virtual data), build a big bloc:</span>
<a name="l01559"></a>01559       nblocs_left = 1;
<a name="l01560"></a>01560       bloc_ptr = one_bloc;
<a name="l01561"></a>01561       one_bloc[0] = 0;
<a name="l01562"></a>01562       one_bloc[1] = vect_size_tot / line_size;
<a name="l01563"></a>01563     }
<a name="l01564"></a>01564   <span class="keywordflow">else</span>
<a name="l01565"></a>01565     {
<a name="l01566"></a>01566 <span class="comment">// raccourci pour les tableaux vides (evite le cas particulier line_size == 0)</span>
<a name="l01567"></a>01567       return ;
<a name="l01568"></a>01568     }
<a name="l01569"></a>01569   <span class="keywordtype">double</span> *resu_base = resu.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
<a name="l01570"></a>01570   <span class="keyword">const</span> <span class="keywordtype">double</span> *x_base = vx.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
<a name="l01571"></a>01571   <span class="keywordflow">for</span> (; nblocs_left; nblocs_left--)
<a name="l01572"></a>01572     {
<a name="l01573"></a>01573 <span class="comment">// Get index of next bloc start:</span>
<a name="l01574"></a>01574       <span class="keyword">const</span> <span class="keywordtype">int</span> begin_bloc = (*(bloc_ptr++)) * line_size;
<a name="l01575"></a>01575       <span class="keyword">const</span> <span class="keywordtype">int</span> end_bloc = (*(bloc_ptr++)) * line_size;
<a name="l01576"></a>01576       assert(begin_bloc &gt;= 0 &amp;&amp; end_bloc &lt;= vect_size_tot &amp;&amp; end_bloc &gt;= begin_bloc);
<a name="l01577"></a>01577       <span class="keywordtype">double</span>* resu_ptr = resu_base + begin_bloc;
<a name="l01578"></a>01578       <span class="keyword">const</span> <span class="keywordtype">double</span>* x_ptr = x_base + begin_bloc;
<a name="l01579"></a>01579       <span class="keywordtype">int</span> count = end_bloc - begin_bloc;
<a name="l01580"></a>01580       <span class="keywordflow">for</span> (; count; count--)
<a name="l01581"></a>01581         {
<a name="l01582"></a>01582           <span class="keyword">const</span> <span class="keywordtype">double</span> x = *x_ptr;
<a name="l01583"></a>01583           <span class="keywordtype">double</span>&amp; p_resu = *(resu_ptr++);
<a name="l01584"></a>01584           p_resu += alpha * x;
<a name="l01585"></a>01585           x_ptr++;
<a name="l01586"></a>01586         }
<a name="l01587"></a>01587     }
<a name="l01588"></a>01588 <span class="comment">// In debug mode, put invalid values where data has not been computed</span>
<a name="l01589"></a>01589 <span class="preprocessor">#ifndef NDEBUG</span>
<a name="l01590"></a>01590 <span class="preprocessor"></span>  <a class="code" href="DoubleVect_8cpp.html#ad4995bc506ff841ba67ce56a43886902">invalidate_data</a>(resu,  opt);
<a name="l01591"></a>01591 <span class="preprocessor">#endif</span>
<a name="l01592"></a>01592 <span class="preprocessor"></span>  return ;
<a name="l01593"></a>01593 }
<a name="l01594"></a><a class="code" href="DoubleVect_8h.html#a0620ee5cba3997d8ee47f8db2019a32b">01594</a> <span class="keywordtype">void</span> <a class="code" href="DoubleVect_8cpp.html#a8ef4dfed1a15fd7c7552b78c5ae31292">ajoute_carre</a>(<a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; resu, <span class="keywordtype">double</span> alpha, <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; vx, <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a> opt)
<a name="l01595"></a>01595 {
<a name="l01596"></a>01596 
<a name="l01597"></a>01597 <span class="comment">// Master vect donne la structure de reference, les autres vecteurs</span>
<a name="l01598"></a>01598 <span class="comment">// doivent avoir la meme structure.</span>
<a name="l01599"></a>01599   <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; master_vect = resu;
<a name="l01600"></a>01600   <span class="keywordtype">int</span> line_size = master_vect.<a class="code" href="classDoubleVect.html#ab02d01cd1bdab66fbd66f9a47cc29e10">line_size</a>();
<a name="l01601"></a>01601   <span class="keyword">const</span> <a class="code" href="classMD__Vector.html" title=": Cette classe est un DERIV mais l&#39;objet pointe est partage entre plusieurs instances de cette classe...">MD_Vector</a>&amp; md = master_vect.<a class="code" href="classDoubleVect.html#a0d16d30580c90526e4895388fb44be5d">get_md_vector</a>();
<a name="l01602"></a>01602   <span class="keyword">const</span> <span class="keywordtype">int</span> vect_size_tot = master_vect.<a class="code" href="classDoubleVect.html#ad2d21b364e1c6559771970596a25c006" title="Identique a size_array()">size_totale</a>();
<a name="l01603"></a>01603   assert(vx.<a class="code" href="classDoubleVect.html#ab02d01cd1bdab66fbd66f9a47cc29e10">line_size</a>() == line_size);
<a name="l01604"></a>01604   assert(vx.<a class="code" href="classDoubleVect.html#ad2d21b364e1c6559771970596a25c006" title="Identique a size_array()">size_totale</a>() == vect_size_tot); <span class="comment">//!&lt; this test is necessary if md is null</span>
<a name="l01605"></a>01605 <span class="comment"></span>  assert(vx.<a class="code" href="classDoubleVect.html#a0d16d30580c90526e4895388fb44be5d">get_md_vector</a>() == md);
<a name="l01606"></a>01606 <span class="comment">// Determine blocs of data to process, depending on &quot; opt&quot;</span>
<a name="l01607"></a>01607   <span class="keywordtype">int</span> nblocs_left = 1;
<a name="l01608"></a>01608   <span class="keywordtype">int</span> one_bloc[2];
<a name="l01609"></a>01609   <span class="keyword">const</span> <span class="keywordtype">int</span> *bloc_ptr;
<a name="l01610"></a>01610   <span class="keywordflow">if</span> ( opt != <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caad18680091a9f62247573cb3caa6450b9">VECT_ALL_ITEMS</a> &amp;&amp; md.<a class="code" href="classMD__Vector.html#a4165c00904b7096274e38fdc7ca340f4">non_nul</a>())
<a name="l01611"></a>01611     {
<a name="l01612"></a>01612       assert( opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a> ||  opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caab47906d8d2e6c20f8ba32e4acb6edbe0">VECT_REAL_ITEMS</a>);
<a name="l01613"></a>01613       <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; items_blocs = ( opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a>) ? md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a7f6b6d0b7babfec0cce590cdea5bca53">get_items_to_sum</a>() : md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a99334ac2566d9457c8d4890ba20883ea">get_items_to_compute</a>();
<a name="l01614"></a>01614       assert(items_blocs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() % 2 == 0);
<a name="l01615"></a>01615       nblocs_left = items_blocs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() &gt;&gt; 1;
<a name="l01616"></a>01616       bloc_ptr = items_blocs.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
<a name="l01617"></a>01617     }
<a name="l01618"></a>01618   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (vect_size_tot &gt; 0)
<a name="l01619"></a>01619     {
<a name="l01620"></a>01620 <span class="comment">// attention, si vect_size_tot est nul, line_size a le droit d&#39;etre nul</span>
<a name="l01621"></a>01621 <span class="comment">// Compute all data, in the vector (including virtual data), build a big bloc:</span>
<a name="l01622"></a>01622       nblocs_left = 1;
<a name="l01623"></a>01623       bloc_ptr = one_bloc;
<a name="l01624"></a>01624       one_bloc[0] = 0;
<a name="l01625"></a>01625       one_bloc[1] = vect_size_tot / line_size;
<a name="l01626"></a>01626     }
<a name="l01627"></a>01627   <span class="keywordflow">else</span>
<a name="l01628"></a>01628     {
<a name="l01629"></a>01629 <span class="comment">// raccourci pour les tableaux vides (evite le cas particulier line_size == 0)</span>
<a name="l01630"></a>01630       return ;
<a name="l01631"></a>01631     }
<a name="l01632"></a>01632   <span class="keywordtype">double</span> *resu_base = resu.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
<a name="l01633"></a>01633   <span class="keyword">const</span> <span class="keywordtype">double</span> *x_base = vx.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
<a name="l01634"></a>01634   <span class="keywordflow">for</span> (; nblocs_left; nblocs_left--)
<a name="l01635"></a>01635     {
<a name="l01636"></a>01636 <span class="comment">// Get index of next bloc start:</span>
<a name="l01637"></a>01637       <span class="keyword">const</span> <span class="keywordtype">int</span> begin_bloc = (*(bloc_ptr++)) * line_size;
<a name="l01638"></a>01638       <span class="keyword">const</span> <span class="keywordtype">int</span> end_bloc = (*(bloc_ptr++)) * line_size;
<a name="l01639"></a>01639       assert(begin_bloc &gt;= 0 &amp;&amp; end_bloc &lt;= vect_size_tot &amp;&amp; end_bloc &gt;= begin_bloc);
<a name="l01640"></a>01640       <span class="keywordtype">double</span>* resu_ptr = resu_base + begin_bloc;
<a name="l01641"></a>01641       <span class="keyword">const</span> <span class="keywordtype">double</span>* x_ptr = x_base + begin_bloc;
<a name="l01642"></a>01642       <span class="keywordtype">int</span> count = end_bloc - begin_bloc;
<a name="l01643"></a>01643       <span class="keywordflow">for</span> (; count; count--)
<a name="l01644"></a>01644         {
<a name="l01645"></a>01645           <span class="keyword">const</span> <span class="keywordtype">double</span> x = *x_ptr;
<a name="l01646"></a>01646           <span class="keywordtype">double</span>&amp; p_resu = *(resu_ptr++);
<a name="l01647"></a>01647           p_resu += alpha * x * x;
<a name="l01648"></a>01648           x_ptr++;
<a name="l01649"></a>01649         }
<a name="l01650"></a>01650     }
<a name="l01651"></a>01651 <span class="comment">// In debug mode, put invalid values where data has not been computed</span>
<a name="l01652"></a>01652 <span class="preprocessor">#ifndef NDEBUG</span>
<a name="l01653"></a>01653 <span class="preprocessor"></span>  <a class="code" href="DoubleVect_8cpp.html#ad4995bc506ff841ba67ce56a43886902">invalidate_data</a>(resu,  opt);
<a name="l01654"></a>01654 <span class="preprocessor">#endif</span>
<a name="l01655"></a>01655 <span class="preprocessor"></span>  return ;
<a name="l01656"></a>01656 }
<a name="l01657"></a><a class="code" href="DoubleVect_8h.html#a12d70201be38e8c4357a4df892dc21df">01657</a> <span class="keywordtype">void</span> <a class="code" href="DoubleVect_8cpp.html#a87c5696ea45f767c0b4800efc44455e4">ajoute_produit_scalaire</a>(<a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; resu, <span class="keywordtype">double</span> alpha, <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; vx, <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; vy, <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a> opt)
<a name="l01658"></a>01658 {
<a name="l01659"></a>01659 
<a name="l01660"></a>01660 <span class="comment">// Master vect donne la structure de reference, les autres vecteurs</span>
<a name="l01661"></a>01661 <span class="comment">// doivent avoir la meme structure.</span>
<a name="l01662"></a>01662   <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; master_vect = resu;
<a name="l01663"></a>01663   <span class="keywordtype">int</span> line_size = master_vect.<a class="code" href="classDoubleVect.html#ab02d01cd1bdab66fbd66f9a47cc29e10">line_size</a>();
<a name="l01664"></a>01664   <span class="keyword">const</span> <a class="code" href="classMD__Vector.html" title=": Cette classe est un DERIV mais l&#39;objet pointe est partage entre plusieurs instances de cette classe...">MD_Vector</a>&amp; md = master_vect.<a class="code" href="classDoubleVect.html#a0d16d30580c90526e4895388fb44be5d">get_md_vector</a>();
<a name="l01665"></a>01665   <span class="keyword">const</span> <span class="keywordtype">int</span> vect_size_tot = master_vect.<a class="code" href="classDoubleVect.html#ad2d21b364e1c6559771970596a25c006" title="Identique a size_array()">size_totale</a>();
<a name="l01666"></a>01666   assert(vx.<a class="code" href="classDoubleVect.html#ab02d01cd1bdab66fbd66f9a47cc29e10">line_size</a>() == line_size);
<a name="l01667"></a>01667   assert(vx.<a class="code" href="classDoubleVect.html#ad2d21b364e1c6559771970596a25c006" title="Identique a size_array()">size_totale</a>() == vect_size_tot); <span class="comment">//!&lt; this test is necessary if md is null</span>
<a name="l01668"></a>01668 <span class="comment"></span>  assert(vx.<a class="code" href="classDoubleVect.html#a0d16d30580c90526e4895388fb44be5d">get_md_vector</a>() == md);
<a name="l01669"></a>01669   assert(vy.<a class="code" href="classDoubleVect.html#ab02d01cd1bdab66fbd66f9a47cc29e10">line_size</a>() == line_size);
<a name="l01670"></a>01670   assert(vy.<a class="code" href="classDoubleVect.html#ad2d21b364e1c6559771970596a25c006" title="Identique a size_array()">size_totale</a>() == vect_size_tot); <span class="comment">//!&lt; this test is necessary if md is null</span>
<a name="l01671"></a>01671 <span class="comment"></span>  assert(vy.<a class="code" href="classDoubleVect.html#a0d16d30580c90526e4895388fb44be5d">get_md_vector</a>() == md);
<a name="l01672"></a>01672 <span class="comment">// Determine blocs of data to process, depending on &quot; opt&quot;</span>
<a name="l01673"></a>01673   <span class="keywordtype">int</span> nblocs_left = 1;
<a name="l01674"></a>01674   <span class="keywordtype">int</span> one_bloc[2];
<a name="l01675"></a>01675   <span class="keyword">const</span> <span class="keywordtype">int</span> *bloc_ptr;
<a name="l01676"></a>01676   <span class="keywordflow">if</span> ( opt != <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caad18680091a9f62247573cb3caa6450b9">VECT_ALL_ITEMS</a> &amp;&amp; md.<a class="code" href="classMD__Vector.html#a4165c00904b7096274e38fdc7ca340f4">non_nul</a>())
<a name="l01677"></a>01677     {
<a name="l01678"></a>01678       assert( opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a> ||  opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caab47906d8d2e6c20f8ba32e4acb6edbe0">VECT_REAL_ITEMS</a>);
<a name="l01679"></a>01679       <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; items_blocs = ( opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a>) ? md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a7f6b6d0b7babfec0cce590cdea5bca53">get_items_to_sum</a>() : md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a99334ac2566d9457c8d4890ba20883ea">get_items_to_compute</a>();
<a name="l01680"></a>01680       assert(items_blocs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() % 2 == 0);
<a name="l01681"></a>01681       nblocs_left = items_blocs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() &gt;&gt; 1;
<a name="l01682"></a>01682       bloc_ptr = items_blocs.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
<a name="l01683"></a>01683     }
<a name="l01684"></a>01684   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (vect_size_tot &gt; 0)
<a name="l01685"></a>01685     {
<a name="l01686"></a>01686 <span class="comment">// attention, si vect_size_tot est nul, line_size a le droit d&#39;etre nul</span>
<a name="l01687"></a>01687 <span class="comment">// Compute all data, in the vector (including virtual data), build a big bloc:</span>
<a name="l01688"></a>01688       nblocs_left = 1;
<a name="l01689"></a>01689       bloc_ptr = one_bloc;
<a name="l01690"></a>01690       one_bloc[0] = 0;
<a name="l01691"></a>01691       one_bloc[1] = vect_size_tot / line_size;
<a name="l01692"></a>01692     }
<a name="l01693"></a>01693   <span class="keywordflow">else</span>
<a name="l01694"></a>01694     {
<a name="l01695"></a>01695 <span class="comment">// raccourci pour les tableaux vides (evite le cas particulier line_size == 0)</span>
<a name="l01696"></a>01696       return ;
<a name="l01697"></a>01697     }
<a name="l01698"></a>01698   <span class="keywordtype">double</span> *resu_base = resu.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
<a name="l01699"></a>01699   <span class="keyword">const</span> <span class="keywordtype">double</span> *x_base = vx.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
<a name="l01700"></a>01700   <span class="keyword">const</span> <span class="keywordtype">double</span> *y_base = vy.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
<a name="l01701"></a>01701   <span class="keywordflow">for</span> (; nblocs_left; nblocs_left--)
<a name="l01702"></a>01702     {
<a name="l01703"></a>01703 <span class="comment">// Get index of next bloc start:</span>
<a name="l01704"></a>01704       <span class="keyword">const</span> <span class="keywordtype">int</span> begin_bloc = (*(bloc_ptr++)) * line_size;
<a name="l01705"></a>01705       <span class="keyword">const</span> <span class="keywordtype">int</span> end_bloc = (*(bloc_ptr++)) * line_size;
<a name="l01706"></a>01706       assert(begin_bloc &gt;= 0 &amp;&amp; end_bloc &lt;= vect_size_tot &amp;&amp; end_bloc &gt;= begin_bloc);
<a name="l01707"></a>01707       <span class="keywordtype">double</span>* resu_ptr = resu_base + begin_bloc;
<a name="l01708"></a>01708       <span class="keyword">const</span> <span class="keywordtype">double</span>* x_ptr = x_base + begin_bloc;
<a name="l01709"></a>01709       <span class="keyword">const</span> <span class="keywordtype">double</span>* y_ptr = y_base + begin_bloc;
<a name="l01710"></a>01710       <span class="keywordtype">int</span> count = end_bloc - begin_bloc;
<a name="l01711"></a>01711       <span class="keywordflow">for</span> (; count; count--)
<a name="l01712"></a>01712         {
<a name="l01713"></a>01713           <span class="keyword">const</span> <span class="keywordtype">double</span> x = *x_ptr;
<a name="l01714"></a>01714           <span class="keyword">const</span> <span class="keywordtype">double</span> y = *(y_ptr++);
<a name="l01715"></a>01715           <span class="keywordtype">double</span>&amp; p_resu = *(resu_ptr++);
<a name="l01716"></a>01716           p_resu += alpha * x * y;
<a name="l01717"></a>01717           x_ptr++;
<a name="l01718"></a>01718         }
<a name="l01719"></a>01719     }
<a name="l01720"></a>01720 <span class="comment">// In debug mode, put invalid values where data has not been computed</span>
<a name="l01721"></a>01721 <span class="preprocessor">#ifndef NDEBUG</span>
<a name="l01722"></a>01722 <span class="preprocessor"></span>  <a class="code" href="DoubleVect_8cpp.html#ad4995bc506ff841ba67ce56a43886902">invalidate_data</a>(resu,  opt);
<a name="l01723"></a>01723 <span class="preprocessor">#endif</span>
<a name="l01724"></a>01724 <span class="preprocessor"></span>  return ;
<a name="l01725"></a>01725 }
<a name="l01726"></a><a class="code" href="DoubleVect_8h.html#aad3042f6dfe021b4808b5167c1ab563a">01726</a> <span class="keywordtype">void</span> <a class="code" href="DoubleVect_8cpp.html#a3dd82f36d4b858c23167eb2a2f3632d7">racine_carree</a>(<a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; resu, <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a> opt)
<a name="l01727"></a>01727 {
<a name="l01728"></a>01728 
<a name="l01729"></a>01729 <span class="comment">// Master vect donne la structure de reference, les autres vecteurs</span>
<a name="l01730"></a>01730 <span class="comment">// doivent avoir la meme structure.</span>
<a name="l01731"></a>01731   <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; master_vect = resu;
<a name="l01732"></a>01732   <span class="keywordtype">int</span> line_size = master_vect.<a class="code" href="classDoubleVect.html#ab02d01cd1bdab66fbd66f9a47cc29e10">line_size</a>();
<a name="l01733"></a>01733   <span class="keyword">const</span> <a class="code" href="classMD__Vector.html" title=": Cette classe est un DERIV mais l&#39;objet pointe est partage entre plusieurs instances de cette classe...">MD_Vector</a>&amp; md = master_vect.<a class="code" href="classDoubleVect.html#a0d16d30580c90526e4895388fb44be5d">get_md_vector</a>();
<a name="l01734"></a>01734   <span class="keyword">const</span> <span class="keywordtype">int</span> vect_size_tot = master_vect.<a class="code" href="classDoubleVect.html#ad2d21b364e1c6559771970596a25c006" title="Identique a size_array()">size_totale</a>();
<a name="l01735"></a>01735 <span class="comment">// Determine blocs of data to process, depending on &quot; opt&quot;</span>
<a name="l01736"></a>01736   <span class="keywordtype">int</span> nblocs_left = 1;
<a name="l01737"></a>01737   <span class="keywordtype">int</span> one_bloc[2];
<a name="l01738"></a>01738   <span class="keyword">const</span> <span class="keywordtype">int</span> *bloc_ptr;
<a name="l01739"></a>01739   <span class="keywordflow">if</span> ( opt != <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caad18680091a9f62247573cb3caa6450b9">VECT_ALL_ITEMS</a> &amp;&amp; md.<a class="code" href="classMD__Vector.html#a4165c00904b7096274e38fdc7ca340f4">non_nul</a>())
<a name="l01740"></a>01740     {
<a name="l01741"></a>01741       assert( opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a> ||  opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caab47906d8d2e6c20f8ba32e4acb6edbe0">VECT_REAL_ITEMS</a>);
<a name="l01742"></a>01742       <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; items_blocs = ( opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a>) ? md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a7f6b6d0b7babfec0cce590cdea5bca53">get_items_to_sum</a>() : md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a99334ac2566d9457c8d4890ba20883ea">get_items_to_compute</a>();
<a name="l01743"></a>01743       assert(items_blocs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() % 2 == 0);
<a name="l01744"></a>01744       nblocs_left = items_blocs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() &gt;&gt; 1;
<a name="l01745"></a>01745       bloc_ptr = items_blocs.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
<a name="l01746"></a>01746     }
<a name="l01747"></a>01747   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (vect_size_tot &gt; 0)
<a name="l01748"></a>01748     {
<a name="l01749"></a>01749 <span class="comment">// attention, si vect_size_tot est nul, line_size a le droit d&#39;etre nul</span>
<a name="l01750"></a>01750 <span class="comment">// Compute all data, in the vector (including virtual data), build a big bloc:</span>
<a name="l01751"></a>01751       nblocs_left = 1;
<a name="l01752"></a>01752       bloc_ptr = one_bloc;
<a name="l01753"></a>01753       one_bloc[0] = 0;
<a name="l01754"></a>01754       one_bloc[1] = vect_size_tot / line_size;
<a name="l01755"></a>01755     }
<a name="l01756"></a>01756   <span class="keywordflow">else</span>
<a name="l01757"></a>01757     {
<a name="l01758"></a>01758 <span class="comment">// raccourci pour les tableaux vides (evite le cas particulier line_size == 0)</span>
<a name="l01759"></a>01759       return ;
<a name="l01760"></a>01760     }
<a name="l01761"></a>01761   <span class="keywordtype">double</span> *resu_base = resu.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
<a name="l01762"></a>01762   <span class="keywordflow">for</span> (; nblocs_left; nblocs_left--)
<a name="l01763"></a>01763     {
<a name="l01764"></a>01764 <span class="comment">// Get index of next bloc start:</span>
<a name="l01765"></a>01765       <span class="keyword">const</span> <span class="keywordtype">int</span> begin_bloc = (*(bloc_ptr++)) * line_size;
<a name="l01766"></a>01766       <span class="keyword">const</span> <span class="keywordtype">int</span> end_bloc = (*(bloc_ptr++)) * line_size;
<a name="l01767"></a>01767       assert(begin_bloc &gt;= 0 &amp;&amp; end_bloc &lt;= vect_size_tot &amp;&amp; end_bloc &gt;= begin_bloc);
<a name="l01768"></a>01768       <span class="keywordtype">double</span>* resu_ptr = resu_base + begin_bloc;
<a name="l01769"></a>01769       <span class="keywordtype">int</span> count = end_bloc - begin_bloc;
<a name="l01770"></a>01770       <span class="keywordflow">for</span> (; count; count--)
<a name="l01771"></a>01771         {
<a name="l01772"></a>01772           <span class="keywordtype">double</span>&amp; p_resu = *(resu_ptr++);
<a name="l01773"></a>01773           p_resu = sqrt(p_resu);
<a name="l01774"></a>01774         }
<a name="l01775"></a>01775     }
<a name="l01776"></a>01776 <span class="comment">// In debug mode, put invalid values where data has not been computed</span>
<a name="l01777"></a>01777 <span class="preprocessor">#ifndef NDEBUG</span>
<a name="l01778"></a>01778 <span class="preprocessor"></span>  <a class="code" href="DoubleVect_8cpp.html#ad4995bc506ff841ba67ce56a43886902">invalidate_data</a>(resu,  opt);
<a name="l01779"></a>01779 <span class="preprocessor">#endif</span>
<a name="l01780"></a>01780 <span class="preprocessor"></span>  return ;
<a name="l01781"></a>01781 }
<a name="l01782"></a><a class="code" href="DoubleVect_8h.html#a844f83e5b5299a74a936db6385c8efe7">01782</a> <span class="keywordtype">void</span> <a class="code" href="Double_8h.html#aa4be1ab61f49e9ebb241ed3f4957fd4a" title="fonctions utiles sur les double">carre</a>(<a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; resu, <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a> opt)
<a name="l01783"></a>01783 {
<a name="l01784"></a>01784 
<a name="l01785"></a>01785 <span class="comment">// Master vect donne la structure de reference, les autres vecteurs</span>
<a name="l01786"></a>01786 <span class="comment">// doivent avoir la meme structure.</span>
<a name="l01787"></a>01787   <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; master_vect = resu;
<a name="l01788"></a>01788   <span class="keywordtype">int</span> line_size = master_vect.<a class="code" href="classDoubleVect.html#ab02d01cd1bdab66fbd66f9a47cc29e10">line_size</a>();
<a name="l01789"></a>01789   <span class="keyword">const</span> <a class="code" href="classMD__Vector.html" title=": Cette classe est un DERIV mais l&#39;objet pointe est partage entre plusieurs instances de cette classe...">MD_Vector</a>&amp; md = master_vect.<a class="code" href="classDoubleVect.html#a0d16d30580c90526e4895388fb44be5d">get_md_vector</a>();
<a name="l01790"></a>01790   <span class="keyword">const</span> <span class="keywordtype">int</span> vect_size_tot = master_vect.<a class="code" href="classDoubleVect.html#ad2d21b364e1c6559771970596a25c006" title="Identique a size_array()">size_totale</a>();
<a name="l01791"></a>01791 <span class="comment">// Determine blocs of data to process, depending on &quot; opt&quot;</span>
<a name="l01792"></a>01792   <span class="keywordtype">int</span> nblocs_left = 1;
<a name="l01793"></a>01793   <span class="keywordtype">int</span> one_bloc[2];
<a name="l01794"></a>01794   <span class="keyword">const</span> <span class="keywordtype">int</span> *bloc_ptr;
<a name="l01795"></a>01795   <span class="keywordflow">if</span> ( opt != <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caad18680091a9f62247573cb3caa6450b9">VECT_ALL_ITEMS</a> &amp;&amp; md.<a class="code" href="classMD__Vector.html#a4165c00904b7096274e38fdc7ca340f4">non_nul</a>())
<a name="l01796"></a>01796     {
<a name="l01797"></a>01797       assert( opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a> ||  opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caab47906d8d2e6c20f8ba32e4acb6edbe0">VECT_REAL_ITEMS</a>);
<a name="l01798"></a>01798       <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; items_blocs = ( opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a>) ? md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a7f6b6d0b7babfec0cce590cdea5bca53">get_items_to_sum</a>() : md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a99334ac2566d9457c8d4890ba20883ea">get_items_to_compute</a>();
<a name="l01799"></a>01799       assert(items_blocs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() % 2 == 0);
<a name="l01800"></a>01800       nblocs_left = items_blocs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() &gt;&gt; 1;
<a name="l01801"></a>01801       bloc_ptr = items_blocs.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
<a name="l01802"></a>01802     }
<a name="l01803"></a>01803   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (vect_size_tot &gt; 0)
<a name="l01804"></a>01804     {
<a name="l01805"></a>01805 <span class="comment">// attention, si vect_size_tot est nul, line_size a le droit d&#39;etre nul</span>
<a name="l01806"></a>01806 <span class="comment">// Compute all data, in the vector (including virtual data), build a big bloc:</span>
<a name="l01807"></a>01807       nblocs_left = 1;
<a name="l01808"></a>01808       bloc_ptr = one_bloc;
<a name="l01809"></a>01809       one_bloc[0] = 0;
<a name="l01810"></a>01810       one_bloc[1] = vect_size_tot / line_size;
<a name="l01811"></a>01811     }
<a name="l01812"></a>01812   <span class="keywordflow">else</span>
<a name="l01813"></a>01813     {
<a name="l01814"></a>01814 <span class="comment">// raccourci pour les tableaux vides (evite le cas particulier line_size == 0)</span>
<a name="l01815"></a>01815       return ;
<a name="l01816"></a>01816     }
<a name="l01817"></a>01817   <span class="keywordtype">double</span> *resu_base = resu.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
<a name="l01818"></a>01818   <span class="keywordflow">for</span> (; nblocs_left; nblocs_left--)
<a name="l01819"></a>01819     {
<a name="l01820"></a>01820 <span class="comment">// Get index of next bloc start:</span>
<a name="l01821"></a>01821       <span class="keyword">const</span> <span class="keywordtype">int</span> begin_bloc = (*(bloc_ptr++)) * line_size;
<a name="l01822"></a>01822       <span class="keyword">const</span> <span class="keywordtype">int</span> end_bloc = (*(bloc_ptr++)) * line_size;
<a name="l01823"></a>01823       assert(begin_bloc &gt;= 0 &amp;&amp; end_bloc &lt;= vect_size_tot &amp;&amp; end_bloc &gt;= begin_bloc);
<a name="l01824"></a>01824       <span class="keywordtype">double</span>* resu_ptr = resu_base + begin_bloc;
<a name="l01825"></a>01825       <span class="keywordtype">int</span> count = end_bloc - begin_bloc;
<a name="l01826"></a>01826       <span class="keywordflow">for</span> (; count; count--)
<a name="l01827"></a>01827         {
<a name="l01828"></a>01828           <span class="keywordtype">double</span>&amp; p_resu = *(resu_ptr++);
<a name="l01829"></a>01829           p_resu *= p_resu;
<a name="l01830"></a>01830         }
<a name="l01831"></a>01831     }
<a name="l01832"></a>01832 <span class="comment">// In debug mode, put invalid values where data has not been computed</span>
<a name="l01833"></a>01833 <span class="preprocessor">#ifndef NDEBUG</span>
<a name="l01834"></a>01834 <span class="preprocessor"></span>  <a class="code" href="DoubleVect_8cpp.html#ad4995bc506ff841ba67ce56a43886902">invalidate_data</a>(resu,  opt);
<a name="l01835"></a>01835 <span class="preprocessor">#endif</span>
<a name="l01836"></a>01836 <span class="preprocessor"></span>  return ;
<a name="l01837"></a>01837 }
<a name="l01838"></a><a class="code" href="DoubleVect_8h.html#abd6228a44f138993e02c5689e3f4fad9">01838</a> <span class="keywordtype">void</span> <a class="code" href="DoubleVect_8cpp.html#a57c531f3142293f375a0cc2f61d7b949">operator_divide</a>(<a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; resu, <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; vx, <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a> opt)
<a name="l01839"></a>01839 {
<a name="l01840"></a>01840 
<a name="l01841"></a>01841 <span class="comment">// Master vect donne la structure de reference, les autres vecteurs</span>
<a name="l01842"></a>01842 <span class="comment">// doivent avoir la meme structure.</span>
<a name="l01843"></a>01843   <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; master_vect = resu;
<a name="l01844"></a>01844   <span class="keywordtype">int</span> line_size = master_vect.<a class="code" href="classDoubleVect.html#ab02d01cd1bdab66fbd66f9a47cc29e10">line_size</a>();
<a name="l01845"></a>01845   <span class="keyword">const</span> <a class="code" href="classMD__Vector.html" title=": Cette classe est un DERIV mais l&#39;objet pointe est partage entre plusieurs instances de cette classe...">MD_Vector</a>&amp; md = master_vect.<a class="code" href="classDoubleVect.html#a0d16d30580c90526e4895388fb44be5d">get_md_vector</a>();
<a name="l01846"></a>01846   <span class="keyword">const</span> <span class="keywordtype">int</span> vect_size_tot = master_vect.<a class="code" href="classDoubleVect.html#ad2d21b364e1c6559771970596a25c006" title="Identique a size_array()">size_totale</a>();
<a name="l01847"></a>01847   assert(vx.<a class="code" href="classDoubleVect.html#ab02d01cd1bdab66fbd66f9a47cc29e10">line_size</a>() == line_size);
<a name="l01848"></a>01848   assert(vx.<a class="code" href="classDoubleVect.html#ad2d21b364e1c6559771970596a25c006" title="Identique a size_array()">size_totale</a>() == vect_size_tot); <span class="comment">//!&lt; this test is necessary if md is null</span>
<a name="l01849"></a>01849 <span class="comment"></span>  assert(vx.<a class="code" href="classDoubleVect.html#a0d16d30580c90526e4895388fb44be5d">get_md_vector</a>() == md);
<a name="l01850"></a>01850 <span class="comment">// Determine blocs of data to process, depending on &quot; opt&quot;</span>
<a name="l01851"></a>01851   <span class="keywordtype">int</span> nblocs_left = 1;
<a name="l01852"></a>01852   <span class="keywordtype">int</span> one_bloc[2];
<a name="l01853"></a>01853   <span class="keyword">const</span> <span class="keywordtype">int</span> *bloc_ptr;
<a name="l01854"></a>01854   <span class="keywordflow">if</span> ( opt != <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caad18680091a9f62247573cb3caa6450b9">VECT_ALL_ITEMS</a> &amp;&amp; md.<a class="code" href="classMD__Vector.html#a4165c00904b7096274e38fdc7ca340f4">non_nul</a>())
<a name="l01855"></a>01855     {
<a name="l01856"></a>01856       assert( opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a> ||  opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caab47906d8d2e6c20f8ba32e4acb6edbe0">VECT_REAL_ITEMS</a>);
<a name="l01857"></a>01857       <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; items_blocs = ( opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a>) ? md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a7f6b6d0b7babfec0cce590cdea5bca53">get_items_to_sum</a>() : md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a99334ac2566d9457c8d4890ba20883ea">get_items_to_compute</a>();
<a name="l01858"></a>01858       assert(items_blocs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() % 2 == 0);
<a name="l01859"></a>01859       nblocs_left = items_blocs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() &gt;&gt; 1;
<a name="l01860"></a>01860       bloc_ptr = items_blocs.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
<a name="l01861"></a>01861     }
<a name="l01862"></a>01862   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (vect_size_tot &gt; 0)
<a name="l01863"></a>01863     {
<a name="l01864"></a>01864 <span class="comment">// attention, si vect_size_tot est nul, line_size a le droit d&#39;etre nul</span>
<a name="l01865"></a>01865 <span class="comment">// Compute all data, in the vector (including virtual data), build a big bloc:</span>
<a name="l01866"></a>01866       nblocs_left = 1;
<a name="l01867"></a>01867       bloc_ptr = one_bloc;
<a name="l01868"></a>01868       one_bloc[0] = 0;
<a name="l01869"></a>01869       one_bloc[1] = vect_size_tot / line_size;
<a name="l01870"></a>01870     }
<a name="l01871"></a>01871   <span class="keywordflow">else</span>
<a name="l01872"></a>01872     {
<a name="l01873"></a>01873 <span class="comment">// raccourci pour les tableaux vides (evite le cas particulier line_size == 0)</span>
<a name="l01874"></a>01874       return ;
<a name="l01875"></a>01875     }
<a name="l01876"></a>01876   <span class="keywordtype">double</span> *resu_base = resu.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
<a name="l01877"></a>01877   <span class="keyword">const</span> <span class="keywordtype">double</span> *x_base = vx.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
<a name="l01878"></a>01878   <span class="keywordflow">for</span> (; nblocs_left; nblocs_left--)
<a name="l01879"></a>01879     {
<a name="l01880"></a>01880 <span class="comment">// Get index of next bloc start:</span>
<a name="l01881"></a>01881       <span class="keyword">const</span> <span class="keywordtype">int</span> begin_bloc = (*(bloc_ptr++)) * line_size;
<a name="l01882"></a>01882       <span class="keyword">const</span> <span class="keywordtype">int</span> end_bloc = (*(bloc_ptr++)) * line_size;
<a name="l01883"></a>01883       assert(begin_bloc &gt;= 0 &amp;&amp; end_bloc &lt;= vect_size_tot &amp;&amp; end_bloc &gt;= begin_bloc);
<a name="l01884"></a>01884       <span class="keywordtype">double</span>* resu_ptr = resu_base + begin_bloc;
<a name="l01885"></a>01885       <span class="keyword">const</span> <span class="keywordtype">double</span>* x_ptr = x_base + begin_bloc;
<a name="l01886"></a>01886       <span class="keywordtype">int</span> count = end_bloc - begin_bloc;
<a name="l01887"></a>01887       <span class="keywordflow">for</span> (; count; count--)
<a name="l01888"></a>01888         {
<a name="l01889"></a>01889           <span class="keyword">const</span> <span class="keywordtype">double</span> x = *x_ptr;
<a name="l01890"></a>01890           <span class="keywordtype">double</span>&amp; p_resu = *(resu_ptr++);
<a name="l01891"></a>01891           <span class="keywordflow">if</span> (x==0) { <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Divide by 0 in DoubleVect::operator_divide()&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>; <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">Process::exit</a>();};
<a name="l01892"></a>01892           p_resu /= x;
<a name="l01893"></a>01893           x_ptr++;
<a name="l01894"></a>01894         }
<a name="l01895"></a>01895     }
<a name="l01896"></a>01896 <span class="comment">// In debug mode, put invalid values where data has not been computed</span>
<a name="l01897"></a>01897 <span class="preprocessor">#ifndef NDEBUG</span>
<a name="l01898"></a>01898 <span class="preprocessor"></span>  <a class="code" href="DoubleVect_8cpp.html#ad4995bc506ff841ba67ce56a43886902">invalidate_data</a>(resu,  opt);
<a name="l01899"></a>01899 <span class="preprocessor">#endif</span>
<a name="l01900"></a>01900 <span class="preprocessor"></span>  return ;
<a name="l01901"></a>01901 }
<a name="l01902"></a><a class="code" href="DoubleVect_8h.html#a3003383542201279e78ebcc2474c1e04">01902</a> <span class="keywordtype">void</span> <a class="code" href="DoubleVect_8cpp.html#abefc2bb157b0e152861b44098edb2c11">operator_inverse</a>(<a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; resu, <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a> opt)
<a name="l01903"></a>01903 {
<a name="l01904"></a>01904 
<a name="l01905"></a>01905 <span class="comment">// Master vect donne la structure de reference, les autres vecteurs</span>
<a name="l01906"></a>01906 <span class="comment">// doivent avoir la meme structure.</span>
<a name="l01907"></a>01907   <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; master_vect = resu;
<a name="l01908"></a>01908   <span class="keywordtype">int</span> line_size = master_vect.<a class="code" href="classDoubleVect.html#ab02d01cd1bdab66fbd66f9a47cc29e10">line_size</a>();
<a name="l01909"></a>01909   <span class="keyword">const</span> <a class="code" href="classMD__Vector.html" title=": Cette classe est un DERIV mais l&#39;objet pointe est partage entre plusieurs instances de cette classe...">MD_Vector</a>&amp; md = master_vect.<a class="code" href="classDoubleVect.html#a0d16d30580c90526e4895388fb44be5d">get_md_vector</a>();
<a name="l01910"></a>01910   <span class="keyword">const</span> <span class="keywordtype">int</span> vect_size_tot = master_vect.<a class="code" href="classDoubleVect.html#ad2d21b364e1c6559771970596a25c006" title="Identique a size_array()">size_totale</a>();
<a name="l01911"></a>01911 <span class="comment">// Determine blocs of data to process, depending on &quot; opt&quot;</span>
<a name="l01912"></a>01912   <span class="keywordtype">int</span> nblocs_left = 1;
<a name="l01913"></a>01913   <span class="keywordtype">int</span> one_bloc[2];
<a name="l01914"></a>01914   <span class="keyword">const</span> <span class="keywordtype">int</span> *bloc_ptr;
<a name="l01915"></a>01915   <span class="keywordflow">if</span> ( opt != <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caad18680091a9f62247573cb3caa6450b9">VECT_ALL_ITEMS</a> &amp;&amp; md.<a class="code" href="classMD__Vector.html#a4165c00904b7096274e38fdc7ca340f4">non_nul</a>())
<a name="l01916"></a>01916     {
<a name="l01917"></a>01917       assert( opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a> ||  opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caab47906d8d2e6c20f8ba32e4acb6edbe0">VECT_REAL_ITEMS</a>);
<a name="l01918"></a>01918       <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; items_blocs = ( opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a>) ? md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a7f6b6d0b7babfec0cce590cdea5bca53">get_items_to_sum</a>() : md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a99334ac2566d9457c8d4890ba20883ea">get_items_to_compute</a>();
<a name="l01919"></a>01919       assert(items_blocs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() % 2 == 0);
<a name="l01920"></a>01920       nblocs_left = items_blocs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() &gt;&gt; 1;
<a name="l01921"></a>01921       bloc_ptr = items_blocs.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
<a name="l01922"></a>01922     }
<a name="l01923"></a>01923   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (vect_size_tot &gt; 0)
<a name="l01924"></a>01924     {
<a name="l01925"></a>01925 <span class="comment">// attention, si vect_size_tot est nul, line_size a le droit d&#39;etre nul</span>
<a name="l01926"></a>01926 <span class="comment">// Compute all data, in the vector (including virtual data), build a big bloc:</span>
<a name="l01927"></a>01927       nblocs_left = 1;
<a name="l01928"></a>01928       bloc_ptr = one_bloc;
<a name="l01929"></a>01929       one_bloc[0] = 0;
<a name="l01930"></a>01930       one_bloc[1] = vect_size_tot / line_size;
<a name="l01931"></a>01931     }
<a name="l01932"></a>01932   <span class="keywordflow">else</span>
<a name="l01933"></a>01933     {
<a name="l01934"></a>01934 <span class="comment">// raccourci pour les tableaux vides (evite le cas particulier line_size == 0)</span>
<a name="l01935"></a>01935       return ;
<a name="l01936"></a>01936     }
<a name="l01937"></a>01937   <span class="keywordtype">double</span> *resu_base = resu.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
<a name="l01938"></a>01938   <span class="keywordflow">for</span> (; nblocs_left; nblocs_left--)
<a name="l01939"></a>01939     {
<a name="l01940"></a>01940 <span class="comment">// Get index of next bloc start:</span>
<a name="l01941"></a>01941       <span class="keyword">const</span> <span class="keywordtype">int</span> begin_bloc = (*(bloc_ptr++)) * line_size;
<a name="l01942"></a>01942       <span class="keyword">const</span> <span class="keywordtype">int</span> end_bloc = (*(bloc_ptr++)) * line_size;
<a name="l01943"></a>01943       assert(begin_bloc &gt;= 0 &amp;&amp; end_bloc &lt;= vect_size_tot &amp;&amp; end_bloc &gt;= begin_bloc);
<a name="l01944"></a>01944       <span class="keywordtype">double</span>* resu_ptr = resu_base + begin_bloc;
<a name="l01945"></a>01945       <span class="keywordtype">int</span> count = end_bloc - begin_bloc;
<a name="l01946"></a>01946       <span class="keywordflow">for</span> (; count; count--)
<a name="l01947"></a>01947         {
<a name="l01948"></a>01948           <span class="keywordtype">double</span>&amp; p_resu = *(resu_ptr++);
<a name="l01949"></a>01949           <span class="keywordflow">if</span> (p_resu==0) { <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Divide by 0 in DoubleVect::operateur_inverse()&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>; <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">Process::exit</a>();};
<a name="l01950"></a>01950           p_resu = 1. / p_resu;
<a name="l01951"></a>01951         }
<a name="l01952"></a>01952     }
<a name="l01953"></a>01953 <span class="comment">// In debug mode, put invalid values where data has not been computed</span>
<a name="l01954"></a>01954 <span class="preprocessor">#ifndef NDEBUG</span>
<a name="l01955"></a>01955 <span class="preprocessor"></span>  <a class="code" href="DoubleVect_8cpp.html#ad4995bc506ff841ba67ce56a43886902">invalidate_data</a>(resu,  opt);
<a name="l01956"></a>01956 <span class="preprocessor">#endif</span>
<a name="l01957"></a>01957 <span class="preprocessor"></span>  return ;
<a name="l01958"></a>01958 }
<a name="l01959"></a><a class="code" href="DoubleVect_8cpp.html#afbe9258caf70f44a5efec3fb1d5d6001">01959</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="DoubleVect_8cpp.html#afbe9258caf70f44a5efec3fb1d5d6001">tab_multiply_any_shape_</a>(<a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; resu, <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; vx, <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a> opt)
<a name="l01960"></a>01960 {
<a name="l01961"></a>01961 
<a name="l01962"></a>01962 <span class="comment">// Master vect donne la structure de reference, les autres vecteurs</span>
<a name="l01963"></a>01963 <span class="comment">// doivent avoir la meme structure.</span>
<a name="l01964"></a>01964   <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; master_vect = resu;
<a name="l01965"></a>01965   <span class="keywordtype">int</span> line_size = master_vect.<a class="code" href="classDoubleVect.html#ab02d01cd1bdab66fbd66f9a47cc29e10">line_size</a>();
<a name="l01966"></a>01966   <span class="keywordtype">int</span> line_size_vx = vx.<a class="code" href="classDoubleVect.html#ab02d01cd1bdab66fbd66f9a47cc29e10">line_size</a>();
<a name="l01967"></a>01967   <span class="keyword">const</span> <a class="code" href="classMD__Vector.html" title=": Cette classe est un DERIV mais l&#39;objet pointe est partage entre plusieurs instances de cette classe...">MD_Vector</a>&amp; md = master_vect.<a class="code" href="classDoubleVect.html#a0d16d30580c90526e4895388fb44be5d">get_md_vector</a>();
<a name="l01968"></a>01968   <span class="keyword">const</span> <span class="keywordtype">int</span> vect_size_tot = master_vect.<a class="code" href="classDoubleVect.html#ad2d21b364e1c6559771970596a25c006" title="Identique a size_array()">size_totale</a>();
<a name="l01969"></a>01969 <span class="comment">// Le line_size du vecteur resu doit etre un multiple du line_size du vecteur vx</span>
<a name="l01970"></a>01970   assert(line_size &gt; 0 &amp;&amp; line_size_vx &gt; 0 &amp;&amp; line_size % line_size_vx == 0);
<a name="l01971"></a>01971   <span class="keyword">const</span> <span class="keywordtype">int</span> delta_line_size = line_size / line_size_vx;
<a name="l01972"></a>01972   assert(vx.<a class="code" href="classDoubleVect.html#ad2d21b364e1c6559771970596a25c006" title="Identique a size_array()">size_totale</a>() * delta_line_size == vect_size_tot); <span class="comment">//!&lt; this test is necessary if md is null</span>
<a name="l01973"></a>01973 <span class="comment"></span>  assert(vx.<a class="code" href="classDoubleVect.html#a0d16d30580c90526e4895388fb44be5d">get_md_vector</a>() == md);
<a name="l01974"></a>01974 <span class="comment">// Determine blocs of data to process, depending on &quot; opt&quot;</span>
<a name="l01975"></a>01975   <span class="keywordtype">int</span> nblocs_left = 1;
<a name="l01976"></a>01976   <span class="keywordtype">int</span> one_bloc[2];
<a name="l01977"></a>01977   <span class="keyword">const</span> <span class="keywordtype">int</span> *bloc_ptr;
<a name="l01978"></a>01978   <span class="keywordflow">if</span> ( opt != <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caad18680091a9f62247573cb3caa6450b9">VECT_ALL_ITEMS</a> &amp;&amp; md.<a class="code" href="classMD__Vector.html#a4165c00904b7096274e38fdc7ca340f4">non_nul</a>())
<a name="l01979"></a>01979     {
<a name="l01980"></a>01980       assert( opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a> ||  opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caab47906d8d2e6c20f8ba32e4acb6edbe0">VECT_REAL_ITEMS</a>);
<a name="l01981"></a>01981       <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; items_blocs = ( opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a>) ? md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a7f6b6d0b7babfec0cce590cdea5bca53">get_items_to_sum</a>() : md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a99334ac2566d9457c8d4890ba20883ea">get_items_to_compute</a>();
<a name="l01982"></a>01982       assert(items_blocs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() % 2 == 0);
<a name="l01983"></a>01983       nblocs_left = items_blocs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() &gt;&gt; 1;
<a name="l01984"></a>01984       bloc_ptr = items_blocs.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
<a name="l01985"></a>01985     }
<a name="l01986"></a>01986   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (vect_size_tot &gt; 0)
<a name="l01987"></a>01987     {
<a name="l01988"></a>01988 <span class="comment">// attention, si vect_size_tot est nul, line_size a le droit d&#39;etre nul</span>
<a name="l01989"></a>01989 <span class="comment">// Compute all data, in the vector (including virtual data), build a big bloc:</span>
<a name="l01990"></a>01990       nblocs_left = 1;
<a name="l01991"></a>01991       bloc_ptr = one_bloc;
<a name="l01992"></a>01992       one_bloc[0] = 0;
<a name="l01993"></a>01993       one_bloc[1] = vect_size_tot / line_size;
<a name="l01994"></a>01994     }
<a name="l01995"></a>01995   <span class="keywordflow">else</span>
<a name="l01996"></a>01996     {
<a name="l01997"></a>01997 <span class="comment">// raccourci pour les tableaux vides (evite le cas particulier line_size == 0)</span>
<a name="l01998"></a>01998       return ;
<a name="l01999"></a>01999     }
<a name="l02000"></a>02000   <span class="keywordtype">double</span> *resu_base = resu.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
<a name="l02001"></a>02001   <span class="keyword">const</span> <span class="keywordtype">double</span> *x_base = vx.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
<a name="l02002"></a>02002   <span class="keywordflow">for</span> (; nblocs_left; nblocs_left--)
<a name="l02003"></a>02003     {
<a name="l02004"></a>02004 <span class="comment">// Get index of next bloc start:</span>
<a name="l02005"></a>02005       <span class="keyword">const</span> <span class="keywordtype">int</span> begin_bloc = (*(bloc_ptr++)) * line_size_vx;
<a name="l02006"></a>02006       <span class="keyword">const</span> <span class="keywordtype">int</span> end_bloc = (*(bloc_ptr++)) * line_size_vx;
<a name="l02007"></a>02007       assert(begin_bloc &gt;= 0 &amp;&amp; end_bloc &lt;= vect_size_tot &amp;&amp; end_bloc &gt;= begin_bloc);
<a name="l02008"></a>02008       <span class="keywordtype">double</span>* resu_ptr = resu_base + begin_bloc * delta_line_size;
<a name="l02009"></a>02009       <span class="keyword">const</span> <span class="keywordtype">double</span>* x_ptr = x_base + begin_bloc;
<a name="l02010"></a>02010       <span class="keywordtype">int</span> count = end_bloc - begin_bloc;
<a name="l02011"></a>02011       <span class="keywordflow">for</span> (; count; count--)
<a name="l02012"></a>02012         {
<a name="l02013"></a>02013           <span class="keyword">const</span> <span class="keywordtype">double</span> x = *x_ptr;
<a name="l02014"></a>02014 <span class="comment">// Any shape: pour chaque item de vx, on a delta_line_size items de resu a traiter</span>
<a name="l02015"></a>02015           <span class="keywordflow">for</span>(<span class="keywordtype">int</span> count2 = delta_line_size; count2; count2--)
<a name="l02016"></a>02016             {
<a name="l02017"></a>02017               <span class="keywordtype">double</span>&amp; p_resu = *(resu_ptr++);
<a name="l02018"></a>02018               p_resu *= x;
<a name="l02019"></a>02019             }
<a name="l02020"></a>02020           x_ptr++;
<a name="l02021"></a>02021         }
<a name="l02022"></a>02022     }
<a name="l02023"></a>02023 <span class="comment">// In debug mode, put invalid values where data has not been computed</span>
<a name="l02024"></a>02024 <span class="preprocessor">#ifndef NDEBUG</span>
<a name="l02025"></a>02025 <span class="preprocessor"></span>  <a class="code" href="DoubleVect_8cpp.html#ad4995bc506ff841ba67ce56a43886902">invalidate_data</a>(resu,  opt);
<a name="l02026"></a>02026 <span class="preprocessor">#endif</span>
<a name="l02027"></a>02027 <span class="preprocessor"></span>  return ;
<a name="l02028"></a>02028 }
<a name="l02029"></a><a class="code" href="DoubleVect_8cpp.html#a88505992fa9b63ac41d37e84e1d5efdb">02029</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="DoubleVect_8cpp.html#a88505992fa9b63ac41d37e84e1d5efdb">tab_divide_any_shape_</a>(<a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; resu, <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; vx, <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a> opt)
<a name="l02030"></a>02030 {
<a name="l02031"></a>02031 
<a name="l02032"></a>02032 <span class="comment">// Master vect donne la structure de reference, les autres vecteurs</span>
<a name="l02033"></a>02033 <span class="comment">// doivent avoir la meme structure.</span>
<a name="l02034"></a>02034   <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; master_vect = resu;
<a name="l02035"></a>02035   <span class="keywordtype">int</span> line_size = master_vect.<a class="code" href="classDoubleVect.html#ab02d01cd1bdab66fbd66f9a47cc29e10">line_size</a>();
<a name="l02036"></a>02036   <span class="keywordtype">int</span> line_size_vx = vx.<a class="code" href="classDoubleVect.html#ab02d01cd1bdab66fbd66f9a47cc29e10">line_size</a>();
<a name="l02037"></a>02037   <span class="keyword">const</span> <a class="code" href="classMD__Vector.html" title=": Cette classe est un DERIV mais l&#39;objet pointe est partage entre plusieurs instances de cette classe...">MD_Vector</a>&amp; md = master_vect.<a class="code" href="classDoubleVect.html#a0d16d30580c90526e4895388fb44be5d">get_md_vector</a>();
<a name="l02038"></a>02038   <span class="keyword">const</span> <span class="keywordtype">int</span> vect_size_tot = master_vect.<a class="code" href="classDoubleVect.html#ad2d21b364e1c6559771970596a25c006" title="Identique a size_array()">size_totale</a>();
<a name="l02039"></a>02039 <span class="comment">// Le line_size du vecteur resu doit etre un multiple du line_size du vecteur vx</span>
<a name="l02040"></a>02040   assert(line_size &gt; 0 &amp;&amp; line_size_vx &gt; 0 &amp;&amp; line_size % line_size_vx == 0);
<a name="l02041"></a>02041   <span class="keyword">const</span> <span class="keywordtype">int</span> delta_line_size = line_size / line_size_vx;
<a name="l02042"></a>02042   assert(vx.<a class="code" href="classDoubleVect.html#ad2d21b364e1c6559771970596a25c006" title="Identique a size_array()">size_totale</a>() * delta_line_size == vect_size_tot); <span class="comment">//!&lt; this test is necessary if md is null</span>
<a name="l02043"></a>02043 <span class="comment"></span>  assert(vx.<a class="code" href="classDoubleVect.html#a0d16d30580c90526e4895388fb44be5d">get_md_vector</a>() == md);
<a name="l02044"></a>02044 <span class="comment">// Determine blocs of data to process, depending on &quot; opt&quot;</span>
<a name="l02045"></a>02045   <span class="keywordtype">int</span> nblocs_left = 1;
<a name="l02046"></a>02046   <span class="keywordtype">int</span> one_bloc[2];
<a name="l02047"></a>02047   <span class="keyword">const</span> <span class="keywordtype">int</span> *bloc_ptr;
<a name="l02048"></a>02048   <span class="keywordflow">if</span> ( opt != <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caad18680091a9f62247573cb3caa6450b9">VECT_ALL_ITEMS</a> &amp;&amp; md.<a class="code" href="classMD__Vector.html#a4165c00904b7096274e38fdc7ca340f4">non_nul</a>())
<a name="l02049"></a>02049     {
<a name="l02050"></a>02050       assert( opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a> ||  opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caab47906d8d2e6c20f8ba32e4acb6edbe0">VECT_REAL_ITEMS</a>);
<a name="l02051"></a>02051       <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; items_blocs = ( opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a>) ? md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a7f6b6d0b7babfec0cce590cdea5bca53">get_items_to_sum</a>() : md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a99334ac2566d9457c8d4890ba20883ea">get_items_to_compute</a>();
<a name="l02052"></a>02052       assert(items_blocs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() % 2 == 0);
<a name="l02053"></a>02053       nblocs_left = items_blocs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() &gt;&gt; 1;
<a name="l02054"></a>02054       bloc_ptr = items_blocs.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
<a name="l02055"></a>02055     }
<a name="l02056"></a>02056   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (vect_size_tot &gt; 0)
<a name="l02057"></a>02057     {
<a name="l02058"></a>02058 <span class="comment">// attention, si vect_size_tot est nul, line_size a le droit d&#39;etre nul</span>
<a name="l02059"></a>02059 <span class="comment">// Compute all data, in the vector (including virtual data), build a big bloc:</span>
<a name="l02060"></a>02060       nblocs_left = 1;
<a name="l02061"></a>02061       bloc_ptr = one_bloc;
<a name="l02062"></a>02062       one_bloc[0] = 0;
<a name="l02063"></a>02063       one_bloc[1] = vect_size_tot / line_size;
<a name="l02064"></a>02064     }
<a name="l02065"></a>02065   <span class="keywordflow">else</span>
<a name="l02066"></a>02066     {
<a name="l02067"></a>02067 <span class="comment">// raccourci pour les tableaux vides (evite le cas particulier line_size == 0)</span>
<a name="l02068"></a>02068       return ;
<a name="l02069"></a>02069     }
<a name="l02070"></a>02070   <span class="keywordtype">double</span> *resu_base = resu.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
<a name="l02071"></a>02071   <span class="keyword">const</span> <span class="keywordtype">double</span> *x_base = vx.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
<a name="l02072"></a>02072   <span class="keywordflow">for</span> (; nblocs_left; nblocs_left--)
<a name="l02073"></a>02073     {
<a name="l02074"></a>02074 <span class="comment">// Get index of next bloc start:</span>
<a name="l02075"></a>02075       <span class="keyword">const</span> <span class="keywordtype">int</span> begin_bloc = (*(bloc_ptr++)) * line_size_vx;
<a name="l02076"></a>02076       <span class="keyword">const</span> <span class="keywordtype">int</span> end_bloc = (*(bloc_ptr++)) * line_size_vx;
<a name="l02077"></a>02077       assert(begin_bloc &gt;= 0 &amp;&amp; end_bloc &lt;= vect_size_tot &amp;&amp; end_bloc &gt;= begin_bloc);
<a name="l02078"></a>02078       <span class="keywordtype">double</span>* resu_ptr = resu_base + begin_bloc * delta_line_size;
<a name="l02079"></a>02079       <span class="keyword">const</span> <span class="keywordtype">double</span>* x_ptr = x_base + begin_bloc;
<a name="l02080"></a>02080       <span class="keywordtype">int</span> count = end_bloc - begin_bloc;
<a name="l02081"></a>02081       <span class="keywordflow">for</span> (; count; count--)
<a name="l02082"></a>02082         {
<a name="l02083"></a>02083           <span class="keyword">const</span> <span class="keywordtype">double</span> x = *x_ptr;
<a name="l02084"></a>02084 <span class="comment">// Any shape: pour chaque item de vx, on a delta_line_size items de resu a traiter</span>
<a name="l02085"></a>02085           <span class="keywordflow">for</span>(<span class="keywordtype">int</span> count2 = delta_line_size; count2; count2--)
<a name="l02086"></a>02086             {
<a name="l02087"></a>02087               <span class="keywordtype">double</span>&amp; p_resu = *(resu_ptr++);
<a name="l02088"></a>02088               <span class="keywordflow">if</span> (x==0) { <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Divide by 0 in DoubleVect::tab_divide_any_shape_()&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>; <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">Process::exit</a>();};
<a name="l02089"></a>02089               p_resu *= (1. / x);
<a name="l02090"></a>02090             }
<a name="l02091"></a>02091           x_ptr++;
<a name="l02092"></a>02092         }
<a name="l02093"></a>02093     }
<a name="l02094"></a>02094 <span class="comment">// In debug mode, put invalid values where data has not been computed</span>
<a name="l02095"></a>02095 <span class="preprocessor">#ifndef NDEBUG</span>
<a name="l02096"></a>02096 <span class="preprocessor"></span>  <a class="code" href="DoubleVect_8cpp.html#ad4995bc506ff841ba67ce56a43886902">invalidate_data</a>(resu,  opt);
<a name="l02097"></a>02097 <span class="preprocessor">#endif</span>
<a name="l02098"></a>02098 <span class="preprocessor"></span>  return ;
<a name="l02099"></a>02099 }
<a name="l02100"></a>02100 <span class="comment">// Cette methode permettent de multiplier un tableau a plusieurs dimensions par un tableau</span>
<a name="l02101"></a>02101 <span class="comment">// de dimension inferieure (par exemple un tableau a trois composantes par un tableau a une composante).</span>
<a name="l02102"></a>02102 <span class="comment">// Chaque valeur du tableau vx est utilisee pour plusieurs items consecutifs du tableau resu</span>
<a name="l02103"></a>02103 <span class="comment">// (le nombre de fois est le rapport des line_size() des deux tableaux).</span>
<a name="l02104"></a>02104 <span class="comment">// resu.line_size() doit etre un multiple int de vx.line_size() et les descripteurs doivent etre identiques.</span>
<a name="l02105"></a>02105 <span class="comment">// Cas particulier: vx peut contenir une constante unique (size_array() == 1 et descripteur nul),</span>
<a name="l02106"></a>02106 <span class="comment">// dans ce cas c&#39;est un simple produit par la constante</span>
<a name="l02107"></a><a class="code" href="DoubleVect_8h.html#ae49210269147af1f1b5260d97b52af0b">02107</a> <span class="keywordtype">void</span> <a class="code" href="DoubleVect_8cpp.html#ae2081ab8f1947e8400a928ca3b172e29">tab_multiply_any_shape</a>(<a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; resu, <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; vx, <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a> opt)
<a name="l02108"></a>02108 {
<a name="l02109"></a>02109   <span class="keywordflow">if</span> (vx.<a class="code" href="classArrOfDouble.html#a3c3b33bea0e88b87315c21ee94bee05f" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() == 1 &amp;&amp; !vx.<a class="code" href="classDoubleVect.html#a0d16d30580c90526e4895388fb44be5d">get_md_vector</a>().<a class="code" href="classMD__Vector.html#a4165c00904b7096274e38fdc7ca340f4">non_nul</a>())
<a name="l02110"></a>02110     {
<a name="l02111"></a>02111 <span class="comment">// Produit par une constante</span>
<a name="l02112"></a>02112       <span class="keywordtype">double</span> x = vx[0];
<a name="l02113"></a>02113       <a class="code" href="DoubleVect_8cpp.html#a2b776b5741992c8b6069737fe41b1298">operator_multiply</a>(resu, x, opt);
<a name="l02114"></a>02114     }
<a name="l02115"></a>02115   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (vx.<a class="code" href="classDoubleVect.html#ab02d01cd1bdab66fbd66f9a47cc29e10">line_size</a>() == resu.<a class="code" href="classDoubleVect.html#ab02d01cd1bdab66fbd66f9a47cc29e10">line_size</a>())
<a name="l02116"></a>02116     {
<a name="l02117"></a>02117 <span class="comment">// Produit membre a membre</span>
<a name="l02118"></a>02118       <a class="code" href="DoubleVect_8cpp.html#a2b776b5741992c8b6069737fe41b1298">operator_multiply</a>(resu, vx, opt);
<a name="l02119"></a>02119     }
<a name="l02120"></a>02120   <span class="keywordflow">else</span>
<a name="l02121"></a>02121     {
<a name="l02122"></a>02122 <span class="comment">// Cas general</span>
<a name="l02123"></a>02123       <a class="code" href="DoubleVect_8cpp.html#afbe9258caf70f44a5efec3fb1d5d6001">tab_multiply_any_shape_</a>(resu, vx, opt);
<a name="l02124"></a>02124     }
<a name="l02125"></a>02125 }
<a name="l02126"></a>02126 <span class="comment">// Idem que tab_multiply_any_shape() mais avec une division</span>
<a name="l02127"></a><a class="code" href="DoubleVect_8h.html#adf24341d6901f984f55d2f6389629f72">02127</a> <span class="keywordtype">void</span> <a class="code" href="DoubleVect_8cpp.html#ae32dfb1215a618568590133af120c286">tab_divide_any_shape</a>(<a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; resu, <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; vx, <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a> opt)
<a name="l02128"></a>02128 {
<a name="l02129"></a>02129   <span class="keywordflow">if</span> (vx.<a class="code" href="classArrOfDouble.html#a3c3b33bea0e88b87315c21ee94bee05f" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() == 1 &amp;&amp; !vx.<a class="code" href="classDoubleVect.html#a0d16d30580c90526e4895388fb44be5d">get_md_vector</a>().<a class="code" href="classMD__Vector.html#a4165c00904b7096274e38fdc7ca340f4">non_nul</a>())
<a name="l02130"></a>02130     {
<a name="l02131"></a>02131 <span class="comment">// Produit par une constante</span>
<a name="l02132"></a>02132       <span class="keywordflow">if</span> (vx[0]==0)
<a name="l02133"></a>02133         {
<a name="l02134"></a>02134           <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Divide by 0 in DoubleVect::tab_divide_any_shape()&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
<a name="l02135"></a>02135           <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">Process::exit</a>();
<a name="l02136"></a>02136         }
<a name="l02137"></a>02137       <span class="keywordtype">double</span> x = 1. / vx[0];
<a name="l02138"></a>02138       <a class="code" href="DoubleVect_8cpp.html#a2b776b5741992c8b6069737fe41b1298">operator_multiply</a>(resu, x, opt);
<a name="l02139"></a>02139     }
<a name="l02140"></a>02140   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (vx.<a class="code" href="classDoubleVect.html#ab02d01cd1bdab66fbd66f9a47cc29e10">line_size</a>() == resu.<a class="code" href="classDoubleVect.html#ab02d01cd1bdab66fbd66f9a47cc29e10">line_size</a>())
<a name="l02141"></a>02141     {
<a name="l02142"></a>02142 <span class="comment">// Produit membre a membre</span>
<a name="l02143"></a>02143       <a class="code" href="DoubleVect_8cpp.html#a57c531f3142293f375a0cc2f61d7b949">operator_divide</a>(resu, vx, opt);
<a name="l02144"></a>02144     }
<a name="l02145"></a>02145   <span class="keywordflow">else</span>
<a name="l02146"></a>02146     {
<a name="l02147"></a>02147 <span class="comment">// Cas general</span>
<a name="l02148"></a>02148       <a class="code" href="DoubleVect_8cpp.html#a88505992fa9b63ac41d37e84e1d5efdb">tab_divide_any_shape_</a>(resu, vx, opt);
<a name="l02149"></a>02149     }
<a name="l02150"></a>02150 }
<a name="l02151"></a><a class="code" href="DoubleVect_8h.html#a1542d5db03f44ec6cfb02c412d00bade">02151</a> <span class="keywordtype">void</span> <a class="code" href="DoubleVect_8cpp.html#a57c531f3142293f375a0cc2f61d7b949">operator_divide</a>(<a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; resu, <span class="keyword">const</span> <span class="keywordtype">double</span> x, <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a> opt)
<a name="l02152"></a>02152 {
<a name="l02153"></a>02153 
<a name="l02154"></a>02154 <span class="comment">// Master vect donne la structure de reference, les autres vecteurs</span>
<a name="l02155"></a>02155 <span class="comment">// doivent avoir la meme structure.</span>
<a name="l02156"></a>02156   <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; master_vect = resu;
<a name="l02157"></a>02157   <span class="keywordtype">int</span> line_size = master_vect.<a class="code" href="classDoubleVect.html#ab02d01cd1bdab66fbd66f9a47cc29e10">line_size</a>();
<a name="l02158"></a>02158   <span class="keyword">const</span> <a class="code" href="classMD__Vector.html" title=": Cette classe est un DERIV mais l&#39;objet pointe est partage entre plusieurs instances de cette classe...">MD_Vector</a>&amp; md = master_vect.<a class="code" href="classDoubleVect.html#a0d16d30580c90526e4895388fb44be5d">get_md_vector</a>();
<a name="l02159"></a>02159   <span class="keyword">const</span> <span class="keywordtype">int</span> vect_size_tot = master_vect.<a class="code" href="classDoubleVect.html#ad2d21b364e1c6559771970596a25c006" title="Identique a size_array()">size_totale</a>();
<a name="l02160"></a>02160 <span class="comment">// Determine blocs of data to process, depending on &quot; opt&quot;</span>
<a name="l02161"></a>02161   <span class="keywordtype">int</span> nblocs_left = 1;
<a name="l02162"></a>02162   <span class="keywordtype">int</span> one_bloc[2];
<a name="l02163"></a>02163   <span class="keyword">const</span> <span class="keywordtype">int</span> *bloc_ptr;
<a name="l02164"></a>02164   <span class="keywordflow">if</span> ( opt != <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caad18680091a9f62247573cb3caa6450b9">VECT_ALL_ITEMS</a> &amp;&amp; md.<a class="code" href="classMD__Vector.html#a4165c00904b7096274e38fdc7ca340f4">non_nul</a>())
<a name="l02165"></a>02165     {
<a name="l02166"></a>02166       assert( opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a> ||  opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caab47906d8d2e6c20f8ba32e4acb6edbe0">VECT_REAL_ITEMS</a>);
<a name="l02167"></a>02167       <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; items_blocs = ( opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a>) ? md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a7f6b6d0b7babfec0cce590cdea5bca53">get_items_to_sum</a>() : md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a99334ac2566d9457c8d4890ba20883ea">get_items_to_compute</a>();
<a name="l02168"></a>02168       assert(items_blocs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() % 2 == 0);
<a name="l02169"></a>02169       nblocs_left = items_blocs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() &gt;&gt; 1;
<a name="l02170"></a>02170       bloc_ptr = items_blocs.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
<a name="l02171"></a>02171     }
<a name="l02172"></a>02172   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (vect_size_tot &gt; 0)
<a name="l02173"></a>02173     {
<a name="l02174"></a>02174 <span class="comment">// attention, si vect_size_tot est nul, line_size a le droit d&#39;etre nul</span>
<a name="l02175"></a>02175 <span class="comment">// Compute all data, in the vector (including virtual data), build a big bloc:</span>
<a name="l02176"></a>02176       nblocs_left = 1;
<a name="l02177"></a>02177       bloc_ptr = one_bloc;
<a name="l02178"></a>02178       one_bloc[0] = 0;
<a name="l02179"></a>02179       one_bloc[1] = vect_size_tot / line_size;
<a name="l02180"></a>02180     }
<a name="l02181"></a>02181   <span class="keywordflow">else</span>
<a name="l02182"></a>02182     {
<a name="l02183"></a>02183 <span class="comment">// raccourci pour les tableaux vides (evite le cas particulier line_size == 0)</span>
<a name="l02184"></a>02184       return ;
<a name="l02185"></a>02185     }
<a name="l02186"></a>02186   <span class="keywordtype">double</span> *resu_base = resu.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
<a name="l02187"></a>02187   <span class="keywordflow">for</span> (; nblocs_left; nblocs_left--)
<a name="l02188"></a>02188     {
<a name="l02189"></a>02189 <span class="comment">// Get index of next bloc start:</span>
<a name="l02190"></a>02190       <span class="keyword">const</span> <span class="keywordtype">int</span> begin_bloc = (*(bloc_ptr++)) * line_size;
<a name="l02191"></a>02191       <span class="keyword">const</span> <span class="keywordtype">int</span> end_bloc = (*(bloc_ptr++)) * line_size;
<a name="l02192"></a>02192       assert(begin_bloc &gt;= 0 &amp;&amp; end_bloc &lt;= vect_size_tot &amp;&amp; end_bloc &gt;= begin_bloc);
<a name="l02193"></a>02193       <span class="keywordtype">double</span>* resu_ptr = resu_base + begin_bloc;
<a name="l02194"></a>02194       <span class="keywordtype">int</span> count = end_bloc - begin_bloc;
<a name="l02195"></a>02195       <span class="keywordflow">for</span> (; count; count--)
<a name="l02196"></a>02196         {
<a name="l02197"></a>02197           <span class="keywordtype">double</span>&amp; p_resu = *(resu_ptr++);
<a name="l02198"></a>02198           <span class="keywordflow">if</span>(x==0.) { <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Error: divide by 0 in operator_divide.&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>; <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">Process::exit</a>();};
<a name="l02199"></a>02199           p_resu /= x;
<a name="l02200"></a>02200         }
<a name="l02201"></a>02201     }
<a name="l02202"></a>02202 <span class="comment">// In debug mode, put invalid values where data has not been computed</span>
<a name="l02203"></a>02203 <span class="preprocessor">#ifndef NDEBUG</span>
<a name="l02204"></a>02204 <span class="preprocessor"></span>  <a class="code" href="DoubleVect_8cpp.html#ad4995bc506ff841ba67ce56a43886902">invalidate_data</a>(resu,  opt);
<a name="l02205"></a>02205 <span class="preprocessor">#endif</span>
<a name="l02206"></a>02206 <span class="preprocessor"></span>  return ;
<a name="l02207"></a>02207 }
<a name="l02208"></a>02208 
<a name="l02209"></a><a class="code" href="classDoubleVect.html#aec279fd0cfc79028bdce65e268e01ee3">02209</a> <span class="keywordtype">double</span> <a class="code" href="classDoubleVect.html#aec279fd0cfc79028bdce65e268e01ee3">DoubleVect::local_min_vect</a>(<a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a> opt)<span class="keyword"> const</span>
<a name="l02210"></a>02210 <span class="keyword"></span>{
<a name="l02211"></a>02211   <a class="code" href="classDoubleVect.html#aec279fd0cfc79028bdce65e268e01ee3">return ::local_min_vect</a>(*<span class="keyword">this</span>, opt);
<a name="l02212"></a>02212 }
<a name="l02213"></a><a class="code" href="classDoubleVect.html#af10827062cb14cfc197464910eeb40cf">02213</a> <span class="keywordtype">double</span> <a class="code" href="classDoubleVect.html#af10827062cb14cfc197464910eeb40cf">DoubleVect::local_max_vect</a>(<a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a> opt)<span class="keyword"> const</span>
<a name="l02214"></a>02214 <span class="keyword"></span>{
<a name="l02215"></a>02215   <a class="code" href="classDoubleVect.html#af10827062cb14cfc197464910eeb40cf">return ::local_max_vect</a>(*<span class="keyword">this</span>, opt);
<a name="l02216"></a>02216 }
<a name="l02217"></a><a class="code" href="classDoubleVect.html#abdefeb5d940e66320adc0b9b11309737">02217</a> <span class="keywordtype">double</span> <a class="code" href="classDoubleVect.html#abdefeb5d940e66320adc0b9b11309737">DoubleVect::local_max_abs_vect</a>(<a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a> opt)<span class="keyword"> const</span>
<a name="l02218"></a>02218 <span class="keyword"></span>{
<a name="l02219"></a>02219   <a class="code" href="classDoubleVect.html#abdefeb5d940e66320adc0b9b11309737">return ::local_max_abs_vect</a>(*<span class="keyword">this</span>, opt);
<a name="l02220"></a>02220 }
<a name="l02221"></a><a class="code" href="classDoubleVect.html#ac18afa10729c2a7fe78960d1a73d449b">02221</a> <span class="keywordtype">double</span> <a class="code" href="classDoubleVect.html#ac18afa10729c2a7fe78960d1a73d449b">DoubleVect::local_min_abs_vect</a>(<a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a> opt)<span class="keyword"> const</span>
<a name="l02222"></a>02222 <span class="keyword"></span>{
<a name="l02223"></a>02223   <a class="code" href="classDoubleVect.html#ac18afa10729c2a7fe78960d1a73d449b">return ::local_min_abs_vect</a>(*<span class="keyword">this</span>, opt);
<a name="l02224"></a>02224 }
<a name="l02225"></a><a class="code" href="classDoubleVect.html#a191c38d08569c85a5d1f3d62adb7b6b0">02225</a> <span class="keywordtype">double</span> <a class="code" href="classDoubleVect.html#a191c38d08569c85a5d1f3d62adb7b6b0">DoubleVect::mp_max_vect</a>(<a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a> opt)<span class="keyword"> const</span>
<a name="l02226"></a>02226 <span class="keyword"></span>{
<a name="l02227"></a>02227   <a class="code" href="classDoubleVect.html#a191c38d08569c85a5d1f3d62adb7b6b0">return ::mp_max_vect</a>(*<span class="keyword">this</span>, opt);
<a name="l02228"></a>02228 }
<a name="l02229"></a><a class="code" href="classDoubleVect.html#a7b957db42076f2748265521dbb97c150">02229</a> <span class="keywordtype">double</span> <a class="code" href="classDoubleVect.html#a7b957db42076f2748265521dbb97c150">DoubleVect::mp_min_vect</a>(<a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a> opt)<span class="keyword"> const</span>
<a name="l02230"></a>02230 <span class="keyword"></span>{
<a name="l02231"></a>02231   <a class="code" href="classDoubleVect.html#a7b957db42076f2748265521dbb97c150">return ::mp_min_vect</a>(*<span class="keyword">this</span>, opt);
<a name="l02232"></a>02232 }
<a name="l02233"></a><a class="code" href="classDoubleVect.html#a461fddb9456562779ce10f709ece6807">02233</a> <span class="keywordtype">double</span> <a class="code" href="classDoubleVect.html#a461fddb9456562779ce10f709ece6807">DoubleVect::mp_max_abs_vect</a>(<a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a> opt)<span class="keyword"> const</span>
<a name="l02234"></a>02234 <span class="keyword"></span>{
<a name="l02235"></a>02235   <a class="code" href="classDoubleVect.html#a461fddb9456562779ce10f709ece6807">return ::mp_max_abs_vect</a>(*<span class="keyword">this</span>, opt);
<a name="l02236"></a>02236 }
<a name="l02237"></a><a class="code" href="classDoubleVect.html#afc8f5a22c95a75c43ff735b0e255fff4">02237</a> <span class="keywordtype">double</span> <a class="code" href="classDoubleVect.html#afc8f5a22c95a75c43ff735b0e255fff4">DoubleVect::mp_min_abs_vect</a>(<a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a> opt)<span class="keyword"> const</span>
<a name="l02238"></a>02238 <span class="keyword"></span>{
<a name="l02239"></a>02239   <a class="code" href="classDoubleVect.html#afc8f5a22c95a75c43ff735b0e255fff4">return ::mp_min_abs_vect</a>(*<span class="keyword">this</span>, opt);
<a name="l02240"></a>02240 }
<a name="l02241"></a><a class="code" href="classDoubleVect.html#aa38975e7386cc18c0d85c7a223543694">02241</a> <span class="keywordtype">void</span> <a class="code" href="classDoubleVect.html#aa38975e7386cc18c0d85c7a223543694">DoubleVect::operator+=</a>(<span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; v)
<a name="l02242"></a>02242 {
<a name="l02243"></a>02243   <a class="code" href="DoubleVect_8cpp.html#a9dd7edead35e9d46fc6c8960f33e668a">operator_add</a>(*<span class="keyword">this</span>, v);
<a name="l02244"></a>02244 }
<a name="l02245"></a><a class="code" href="classDoubleVect.html#ad3b17030f825e805be8c8cb373227cc6">02245</a> <span class="keywordtype">void</span> <a class="code" href="classDoubleVect.html#ad3b17030f825e805be8c8cb373227cc6">DoubleVect::operator-=</a>(<span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; v)
<a name="l02246"></a>02246 {
<a name="l02247"></a>02247   <a class="code" href="DoubleVect_8cpp.html#a813958fe17f5746cc80e1e21d0b10a6a">operator_sub</a>(*<span class="keyword">this</span>, v);
<a name="l02248"></a>02248 }
<a name="l02249"></a><a class="code" href="classDoubleVect.html#a5812d60d122e8f55bccd4e29d40fbe14">02249</a> <span class="keywordtype">void</span> <a class="code" href="classDoubleVect.html#a5812d60d122e8f55bccd4e29d40fbe14">DoubleVect::operator*=</a>(<span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; v)
<a name="l02250"></a>02250 {
<a name="l02251"></a>02251   <a class="code" href="DoubleVect_8cpp.html#a2b776b5741992c8b6069737fe41b1298">operator_multiply</a>(*<span class="keyword">this</span>, v);
<a name="l02252"></a>02252 }
<a name="l02253"></a><a class="code" href="classDoubleVect.html#a4b639a09dba0f4bd8ebfdfe8ac6b1085">02253</a> <span class="keywordtype">void</span> <a class="code" href="classDoubleVect.html#aa38975e7386cc18c0d85c7a223543694">DoubleVect::operator+=</a>(<span class="keyword">const</span> <span class="keywordtype">double</span> x)
<a name="l02254"></a>02254 {
<a name="l02255"></a>02255   <a class="code" href="DoubleVect_8cpp.html#a9dd7edead35e9d46fc6c8960f33e668a">operator_add</a>(*<span class="keyword">this</span>, x);
<a name="l02256"></a>02256 }
<a name="l02257"></a><a class="code" href="classDoubleVect.html#ac872b1bef0a267d6930eb45b479eee58">02257</a> <span class="keywordtype">void</span> <a class="code" href="classDoubleVect.html#ad3b17030f825e805be8c8cb373227cc6">DoubleVect::operator-=</a>(<span class="keyword">const</span> <span class="keywordtype">double</span> x)
<a name="l02258"></a>02258 {
<a name="l02259"></a>02259   <a class="code" href="DoubleVect_8cpp.html#a813958fe17f5746cc80e1e21d0b10a6a">operator_sub</a>(*<span class="keyword">this</span>, x);
<a name="l02260"></a>02260 }
<a name="l02261"></a><a class="code" href="classDoubleVect.html#acecc46ec6cbbd6aa9e36172b15d3601a">02261</a> <span class="keywordtype">void</span> <a class="code" href="classDoubleVect.html#a5812d60d122e8f55bccd4e29d40fbe14">DoubleVect::operator*=</a>(<span class="keyword">const</span> <span class="keywordtype">double</span> x)
<a name="l02262"></a>02262 {
<a name="l02263"></a>02263   <a class="code" href="DoubleVect_8cpp.html#a2b776b5741992c8b6069737fe41b1298">operator_multiply</a>(*<span class="keyword">this</span>, x);
<a name="l02264"></a>02264 }
<a name="l02265"></a><a class="code" href="DoubleVect_8h.html#a1e2b6d58614bdc45bb6c54c5e3287ed8">02265</a> <span class="keywordtype">double</span> <a class="code" href="DoubleVect_8cpp.html#adcc29a107bd1ad77828da317da293203">mp_max_vect</a>(<span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; x, <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a> opt)
<a name="l02266"></a>02266 {
<a name="l02267"></a>02267   <span class="keywordtype">double</span> s = <a class="code" href="DoubleVect_8cpp.html#a6471e7e85cb0b00b67bd7ca9bb362371">local_max_vect</a>(x, opt);
<a name="l02268"></a>02268   s =  <a class="code" href="classProcess.html#a1e9d9f9899b71927cfafae14c7bd048d" title="Calcule le max de x sur tous les processeurs du groupe courant. Remarques : Cette methode doit etre a...">Process::mp_max</a>(s);
<a name="l02269"></a>02269   <span class="keywordflow">return</span> s;
<a name="l02270"></a>02270 }
<a name="l02271"></a><a class="code" href="DoubleVect_8h.html#a72e19ba68d4882194517978396f77fc0">02271</a> <span class="keywordtype">double</span> <a class="code" href="DoubleVect_8cpp.html#a55e600bcf8a03e258531f83869c4d060">mp_min_vect</a>(<span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; x, <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a> opt)
<a name="l02272"></a>02272 {
<a name="l02273"></a>02273   <span class="keywordtype">double</span> s = <a class="code" href="DoubleVect_8cpp.html#a17be200c713a7031ede99b28391daa52">local_min_vect</a>(x, opt);
<a name="l02274"></a>02274   s =  <a class="code" href="classProcess.html#a05de57db7288d95f9e67046af585d5ff" title="Calcule le min de x sur tous les processeurs du groupe courant. Voir aussi mp_max()">Process::mp_min</a>(s);
<a name="l02275"></a>02275   <span class="keywordflow">return</span> s;
<a name="l02276"></a>02276 }
<a name="l02277"></a><a class="code" href="DoubleVect_8h.html#ae5449e885515e2c70a37894fcff91745">02277</a> <span class="keywordtype">double</span> <a class="code" href="DoubleVect_8cpp.html#acb21ec8c0b3909c26b20e3f3455e0289">mp_max_abs_vect</a>(<span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; x, <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a> opt)
<a name="l02278"></a>02278 {
<a name="l02279"></a>02279   <span class="keywordtype">double</span> s = <a class="code" href="DoubleVect_8cpp.html#aad339141fa6027fa3b627825a2407c12">local_max_abs_vect</a>(x, opt);
<a name="l02280"></a>02280   s = <a class="code" href="classProcess.html#a1e9d9f9899b71927cfafae14c7bd048d" title="Calcule le max de x sur tous les processeurs du groupe courant. Remarques : Cette methode doit etre a...">Process::mp_max</a>(s);
<a name="l02281"></a>02281   <span class="keywordflow">return</span> s;
<a name="l02282"></a>02282 }
<a name="l02283"></a><a class="code" href="DoubleVect_8h.html#a43c0f69cb4609fdea0fe9e4c35e4925d">02283</a> <span class="keywordtype">double</span> <a class="code" href="DoubleVect_8cpp.html#ab6ebf19fc9a9d820100d7f526f5cb62b">mp_min_abs_vect</a>(<span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; x, <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a> opt)
<a name="l02284"></a>02284 {
<a name="l02285"></a>02285   <span class="keywordtype">double</span> s = <a class="code" href="DoubleVect_8cpp.html#abbb6099a23e2ab39b2308423112f6a67">local_min_abs_vect</a>(x, opt);
<a name="l02286"></a>02286   s = <a class="code" href="classProcess.html#a05de57db7288d95f9e67046af585d5ff" title="Calcule le min de x sur tous les processeurs du groupe courant. Voir aussi mp_max()">Process::mp_min</a>(s);
<a name="l02287"></a>02287   <span class="keywordflow">return</span> s;
<a name="l02288"></a>02288 }
<a name="l02289"></a><a class="code" href="classDoubleVect.html#a70ae7c84bf8a19861de96d9908fe0402">02289</a> <span class="keywordtype">void</span> <a class="code" href="classDoubleVect.html#aeb0c434a31c5231398a7c7f6c69fe07a">DoubleVect::operator/=</a>(<span class="keyword">const</span> <span class="keywordtype">double</span> x)
<a name="l02290"></a>02290 {
<a name="l02291"></a>02291   <a class="code" href="DoubleVect_8cpp.html#a57c531f3142293f375a0cc2f61d7b949">operator_divide</a>(*<span class="keyword">this</span>, x);
<a name="l02292"></a>02292 }
<a name="l02293"></a><a class="code" href="classDoubleVect.html#aeb0c434a31c5231398a7c7f6c69fe07a">02293</a> <span class="keywordtype">void</span> <a class="code" href="classDoubleVect.html#aeb0c434a31c5231398a7c7f6c69fe07a">DoubleVect::operator/=</a>(<span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; v)
<a name="l02294"></a>02294 {
<a name="l02295"></a>02295   <a class="code" href="DoubleVect_8cpp.html#a57c531f3142293f375a0cc2f61d7b949">operator_divide</a>(*<span class="keyword">this</span>, v);
<a name="l02296"></a>02296 }
<a name="l02297"></a><a class="code" href="classDoubleVect.html#af869759bfef35ebcbdf76a65ca95cbb5">02297</a> <span class="keywordtype">void</span> <a class="code" href="classDoubleVect.html#af869759bfef35ebcbdf76a65ca95cbb5">DoubleVect::abs</a>(<a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a> opt)
<a name="l02298"></a>02298 {
<a name="l02299"></a>02299   <a class="code" href="DoubleVect_8cpp.html#a0b4caded26dc4824771aedfe202d0cbd">operator_abs</a>(*<span class="keyword">this</span>, opt);
<a name="l02300"></a>02300 }
<a name="l02301"></a><a class="code" href="classDoubleVect.html#a99d65efd0458ee09e8a0f7e76914ee67">02301</a> <span class="keywordtype">void</span> <a class="code" href="classDoubleVect.html#a99d65efd0458ee09e8a0f7e76914ee67">DoubleVect::carre</a>(<a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a> opt)
<a name="l02302"></a>02302 {<a class="code" href="classDoubleVect.html#a99d65efd0458ee09e8a0f7e76914ee67"></a>
<a name="l02303"></a>02303 <a class="code" href="classDoubleVect.html#a99d65efd0458ee09e8a0f7e76914ee67">  ::carre</a>(*<span class="keyword">this</span>, opt);
<a name="l02304"></a>02304 }
<a name="l02305"></a><a class="code" href="classDoubleVect.html#a73771aaca87707d3dfcbea0ed79d0751">02305</a> <span class="keywordtype">void</span> <a class="code" href="classDoubleVect.html#a73771aaca87707d3dfcbea0ed79d0751">DoubleVect::racine_carree</a>(<a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a> opt)
<a name="l02306"></a>02306 {<a class="code" href="classDoubleVect.html#a73771aaca87707d3dfcbea0ed79d0751"></a>
<a name="l02307"></a>02307 <a class="code" href="classDoubleVect.html#a73771aaca87707d3dfcbea0ed79d0751">  ::racine_carree</a>(*<span class="keyword">this</span>, opt);
<a name="l02308"></a>02308 }
<a name="l02309"></a><a class="code" href="classDoubleVect.html#a4da8824015866b68783677b1e80f1f9a">02309</a> <span class="keywordtype">void</span> <a class="code" href="classDoubleVect.html#a4da8824015866b68783677b1e80f1f9a" title="x+=alpha*y">DoubleVect::ajoute</a>(<span class="keywordtype">double</span> alpha, <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; y, <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a> opt)
<a name="l02310"></a>02310 {
<a name="l02311"></a>02311   <a class="code" href="DoubleVect_8cpp.html#a3cf7911dc14efcacd03f9915978b2b88">ajoute_alpha_v</a>(*<span class="keyword">this</span>, alpha, y, opt);
<a name="l02312"></a>02312   <span class="keywordflow">if</span> (opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caad18680091a9f62247573cb3caa6450b9">VECT_ALL_ITEMS</a>)
<a name="l02313"></a>02313     <a class="code" href="classDoubleVect.html#abfebbc2f685ce7bc4b80c720d7da9bf3">echange_espace_virtuel</a>();
<a name="l02314"></a>02314 }
<a name="l02315"></a><a class="code" href="classDoubleVect.html#a87fba260b7a2a4a051d7a591d19ac11d">02315</a> <span class="keywordtype">void</span> <a class="code" href="classDoubleVect.html#a87fba260b7a2a4a051d7a591d19ac11d" title="x+=alpha*y sans echange_espace_virtuel">DoubleVect::ajoute_sans_ech_esp_virt</a>(<span class="keywordtype">double</span> alpha, <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; y, <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a> opt)
<a name="l02316"></a>02316 {
<a name="l02317"></a>02317   <a class="code" href="DoubleVect_8cpp.html#a3cf7911dc14efcacd03f9915978b2b88">ajoute_alpha_v</a>(*<span class="keyword">this</span>, alpha, y, opt);
<a name="l02318"></a>02318 }
<a name="l02319"></a><a class="code" href="classDoubleVect.html#a6f579057ae7d51f335efa2d60f387f63">02319</a> <span class="keywordtype">void</span> <a class="code" href="classDoubleVect.html#a6f579057ae7d51f335efa2d60f387f63" title="z+=alpha*x*y;">DoubleVect::ajoute_produit_scalaire</a>(<span class="keywordtype">double</span> alpha, <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; x, <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; y, <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a> opt)
<a name="l02320"></a>02320 {<a class="code" href="classDoubleVect.html#a6f579057ae7d51f335efa2d60f387f63" title="z+=alpha*x*y;"></a>
<a name="l02321"></a>02321 <a class="code" href="classDoubleVect.html#a6f579057ae7d51f335efa2d60f387f63" title="z+=alpha*x*y;">  ::ajoute_produit_scalaire</a>(*<span class="keyword">this</span>, alpha, x, y, opt);
<a name="l02322"></a>02322 }
<a name="l02323"></a><a class="code" href="classDoubleVect.html#a17cf741bc1912936e3c4e5fb2780be78">02323</a> <span class="keywordtype">void</span> <a class="code" href="classDoubleVect.html#a17cf741bc1912936e3c4e5fb2780be78">DoubleVect::ajoute_carre</a>(<span class="keywordtype">double</span> alpha, <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; y, <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a> opt)
<a name="l02324"></a>02324 {<a class="code" href="classDoubleVect.html#a17cf741bc1912936e3c4e5fb2780be78"></a>
<a name="l02325"></a>02325 <a class="code" href="classDoubleVect.html#a17cf741bc1912936e3c4e5fb2780be78">  ::ajoute_carre</a>(*<span class="keyword">this</span>, alpha, y, opt);
<a name="l02326"></a>02326 }
<a name="l02327"></a><a class="code" href="DoubleVect_8h.html#ab273872cd90578d4513fffa27888735d">02327</a> <span class="keywordtype">double</span> <a class="code" href="DoubleVect_8cpp.html#a71135d1749309bf589342004b76df614">mp_moyenne_vect</a>(<span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; x)
<a name="l02328"></a>02328 {
<a name="l02329"></a>02329   <span class="keywordtype">double</span> s = <a class="code" href="DoubleVect_8cpp.html#a07dd5e25d47ad3892ae0fa4e997ed011">mp_somme_vect</a>(x);
<a name="l02330"></a>02330   <span class="keywordtype">double</span> n;
<a name="l02331"></a>02331   <span class="keyword">const</span> <a class="code" href="classMD__Vector.html" title=": Cette classe est un DERIV mais l&#39;objet pointe est partage entre plusieurs instances de cette classe...">MD_Vector</a>&amp; md = x.<a class="code" href="classDoubleVect.html#a0d16d30580c90526e4895388fb44be5d">get_md_vector</a>();
<a name="l02332"></a>02332   <span class="keywordflow">if</span> (md.<a class="code" href="classMD__Vector.html#a4165c00904b7096274e38fdc7ca340f4">non_nul</a>())
<a name="l02333"></a>02333     n = md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a47d5867ac692b62645169eae6e2cafa0">nb_items_seq_tot</a>() * x.<a class="code" href="classDoubleVect.html#ab02d01cd1bdab66fbd66f9a47cc29e10">line_size</a>();
<a name="l02334"></a>02334   <span class="keywordflow">else</span>
<a name="l02335"></a>02335     {
<a name="l02336"></a>02336 <span class="comment">// Coding error: mp_moyenne_vect is used on a not distributed DoubleVect !</span>
<a name="l02337"></a>02337       assert(<a class="code" href="classProcess.html#a6bf692ce58d9578aa62ac3c07b8caaa1" title="renvoie le nombre de processeurs dans le groupe courant Voir Comm_Group::nproc() et PE_Groups::curren...">Process::nproc</a>()==1);
<a name="l02338"></a>02338       n = x.<a class="code" href="classDoubleVect.html#ad2d21b364e1c6559771970596a25c006" title="Identique a size_array()">size_totale</a>();
<a name="l02339"></a>02339     }
<a name="l02340"></a>02340   <span class="keywordflow">return</span> s / n;
<a name="l02341"></a>02341 }
<a name="l02342"></a><a class="code" href="DoubleVect_8h.html#a5cf8fe0db2156b6499eec2a4b0d52b3f">02342</a> <span class="keywordtype">double</span> <a class="code" href="DoubleVect_8cpp.html#a07d13cbdadca6b60d5e128653f52a4bb">mp_prodscal</a>(<span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; x, <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; y)
<a name="l02343"></a>02343 {
<a name="l02344"></a>02344   <span class="keywordflow">return</span> <a class="code" href="classProcess.html#a7d23bc1ef94b3f0623fbc79d034c27fd" title="Calcule la somme de x sur tous les processeurs du groupe courant. Voir aussi mp_max()">Process::mp_sum</a>(<a class="code" href="DoubleVect_8cpp.html#acbe5711639fbfe2e85d5f87bf81f851a" title="Renvoie la somme des x[i]*y[i] pour les items sequentiels sur ce processeur. (tous les items si pas d...">local_prodscal</a>(x, y));
<a name="l02345"></a>02345 }
<a name="l02346"></a>02346 
<a name="l02347"></a>02347 
<a name="l02348"></a>02348 
<a name="l02349"></a><a class="code" href="classDoubleVect.html#a8ba82792b50147850f205387324bc3c0">02349</a> <span class="keywordtype">double</span> <a class="code" href="classDoubleVect.html#a8ba82792b50147850f205387324bc3c0">DoubleVect::mp_norme_vect</a>()<span class="keyword"> const</span>
<a name="l02350"></a>02350 <span class="keyword"></span>{
<a name="l02351"></a>02351   <a class="code" href="classDoubleVect.html#a8ba82792b50147850f205387324bc3c0">return ::mp_norme_vect</a>(*<span class="keyword">this</span>);
<a name="l02352"></a>02352 }
<a name="l02353"></a><a class="code" href="DoubleVect_8h.html#a6bef75df40b6fa1068f4206aed4a7cfe">02353</a> <span class="keywordtype">double</span> <a class="code" href="DoubleVect_8cpp.html#afaa33f0032aa927d8d54ff9fb002b749">mp_norme_vect</a>(<span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; vx)
<a name="l02354"></a>02354 {
<a name="l02355"></a>02355   <span class="keywordtype">double</span> x = <a class="code" href="DoubleVect_8cpp.html#aab5110c88e5f7519eb6b7e603130b702">mp_carre_norme_vect</a>(vx);
<a name="l02356"></a>02356   x = sqrt(x);
<a name="l02357"></a>02357   <span class="keywordflow">return</span> x;
<a name="l02358"></a>02358 }
<a name="l02359"></a>02359 
<a name="l02360"></a>02360 
<a name="l02361"></a>02361 
</pre></div></div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Tue Dec 14 2021 19:35:22 for TRUST by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
