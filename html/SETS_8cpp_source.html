<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>TRUST: src/ThHyd/Multiphase/Schemas_Temps/SETS.cpp Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">TRUST&#160;<span id="projectnumber">1.8.4</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
<div class="header">
  <div class="headertitle">
<div class="title">src/ThHyd/Multiphase/Schemas_Temps/SETS.cpp</div>  </div>
</div>
<div class="contents">
<a href="SETS_8cpp.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/****************************************************************************</span>
<a name="l00002"></a>00002 <span class="comment">* Copyright (c) 2021, CEA</span>
<a name="l00003"></a>00003 <span class="comment">* All rights reserved.</span>
<a name="l00004"></a>00004 <span class="comment">*</span>
<a name="l00005"></a>00005 <span class="comment">* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</span>
<a name="l00006"></a>00006 <span class="comment">* 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.</span>
<a name="l00007"></a>00007 <span class="comment">* 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.</span>
<a name="l00008"></a>00008 <span class="comment">* 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.</span>
<a name="l00009"></a>00009 <span class="comment">*</span>
<a name="l00010"></a>00010 <span class="comment">* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.</span>
<a name="l00011"></a>00011 <span class="comment">* IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;</span>
<a name="l00012"></a>00012 <span class="comment">* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>
<a name="l00013"></a>00013 <span class="comment">*</span>
<a name="l00014"></a>00014 <span class="comment">*****************************************************************************/</span>
<a name="l00015"></a>00015 <span class="comment">//</span>
<a name="l00016"></a>00016 <span class="comment">// </span>
<a name="l00017"></a>00017 <span class="comment">// File:        SETS.cpp</span>
<a name="l00018"></a>00018 <span class="comment">// Directory:   $TRUST_ROOT/src/ThHyd/Multiphase/Schemas_Temps</span>
<a name="l00019"></a>00019 <span class="comment">// Version:     /main/29</span>
<a name="l00020"></a>00020 <span class="comment">// </span>
<a name="l00021"></a>00021 <span class="comment">//</span>
<a name="l00022"></a>00022 
<a name="l00023"></a>00023 <span class="preprocessor">#include &lt;<a class="code" href="SETS_8h.html">SETS.h</a>&gt;</span>
<a name="l00024"></a>00024 <span class="preprocessor">#include &lt;<a class="code" href="Zone__VF_8h.html">Zone_VF.h</a>&gt;</span>
<a name="l00025"></a>00025 <span class="preprocessor">#include &lt;<a class="code" href="EChaine_8h.html">EChaine.h</a>&gt;</span>
<a name="l00026"></a>00026 <span class="preprocessor">#include &lt;<a class="code" href="Debog_8h.html">Debog.h</a>&gt;</span>
<a name="l00027"></a>00027 <span class="preprocessor">#include &lt;<a class="code" href="Matrice__Bloc_8h.html">Matrice_Bloc.h</a>&gt;</span>
<a name="l00028"></a>00028 <span class="preprocessor">#include &lt;<a class="code" href="Assembleur__base_8h.html">Assembleur_base.h</a>&gt;</span>
<a name="l00029"></a>00029 <span class="preprocessor">#include &lt;<a class="code" href="Statistiques_8h.html">Statistiques.h</a>&gt;</span>
<a name="l00030"></a>00030 <span class="preprocessor">#include &lt;<a class="code" href="Schema__Temps__base_8h.html">Schema_Temps_base.h</a>&gt;</span>
<a name="l00031"></a>00031 <span class="preprocessor">#include &lt;<a class="code" href="DoubleTrav_8h.html">DoubleTrav.h</a>&gt;</span>
<a name="l00032"></a>00032 <span class="preprocessor">#include &lt;<a class="code" href="Dirichlet_8h.html">Dirichlet.h</a>&gt;</span>
<a name="l00033"></a>00033 <span class="preprocessor">#include &lt;<a class="code" href="Probleme__base_8h.html">Probleme_base.h</a>&gt;</span>
<a name="l00034"></a>00034 <span class="preprocessor">#include &lt;<a class="code" href="Pb__Multiphase_8h.html">Pb_Multiphase.h</a>&gt;</span>
<a name="l00035"></a>00035 <span class="preprocessor">#include &lt;<a class="code" href="QDM__Multiphase_8h.html">QDM_Multiphase.h</a>&gt;</span>
<a name="l00036"></a>00036 <span class="preprocessor">#include &lt;<a class="code" href="Pb__Conduction_8h.html">Pb_Conduction.h</a>&gt;</span>
<a name="l00037"></a>00037 <span class="preprocessor">#include &lt;<a class="code" href="Masse__Multiphase_8h.html">Masse_Multiphase.h</a>&gt;</span>
<a name="l00038"></a>00038 <span class="preprocessor">#include &lt;<a class="code" href="Energie__Multiphase_8h.html">Energie_Multiphase.h</a>&gt;</span>
<a name="l00039"></a>00039 <span class="preprocessor">#include &lt;<a class="code" href="Neumann__val__ext_8h.html">Neumann_val_ext.h</a>&gt;</span>
<a name="l00040"></a>00040 <span class="preprocessor">#include &lt;<a class="code" href="MD__Vector__std_8h.html">MD_Vector_std.h</a>&gt;</span>
<a name="l00041"></a>00041 <span class="preprocessor">#include &lt;<a class="code" href="MD__Vector__composite_8h.html">MD_Vector_composite.h</a>&gt;</span>
<a name="l00042"></a>00042 <span class="preprocessor">#include &lt;<a class="code" href="MD__Vector__tools_8h.html">MD_Vector_tools.h</a>&gt;</span>
<a name="l00043"></a>00043 <span class="preprocessor">#include &lt;<a class="code" href="ConstDoubleTab__parts_8h.html">ConstDoubleTab_parts.h</a>&gt;</span>
<a name="l00044"></a>00044 <span class="preprocessor">#include &lt;<a class="code" href="Discretisation__base_8h.html">Discretisation_base.h</a>&gt;</span>
<a name="l00045"></a>00045 <span class="preprocessor">#include &lt;<a class="code" href="Operateur__Diff__base_8h.html">Operateur_Diff_base.h</a>&gt;</span>
<a name="l00046"></a>00046 
<a name="l00047"></a>00047 <span class="preprocessor">#include &lt;<a class="code" href="IntTrav_8h.html">IntTrav.h</a>&gt;</span>
<a name="l00048"></a>00048 <span class="preprocessor">#include &lt;<a class="code" href="Matrix__tools_8h.html">Matrix_tools.h</a>&gt;</span>
<a name="l00049"></a>00049 <span class="preprocessor">#include &lt;<a class="code" href="Lapack_8h.html">Lapack.h</a>&gt;</span>
<a name="l00050"></a>00050 <span class="preprocessor">#include &lt;cfloat&gt;</span>
<a name="l00051"></a>00051 
<a name="l00052"></a>00052 <span class="preprocessor">#ifndef NDEBUG</span>
<a name="l00053"></a>00053 <span class="preprocessor"></span><span class="keyword">template</span> <span class="keyword">class </span>std::map&lt;std::string, matrices_t&gt;;
<a name="l00054"></a>00054 <span class="keyword">template</span> <span class="keyword">class </span>std::map&lt;std::string, Matrice_Morse&gt;;
<a name="l00055"></a>00055 <span class="preprocessor">#endif</span>
<a name="l00056"></a>00056 <span class="preprocessor"></span>
<a name="l00057"></a><a class="code" href="SETS_8cpp.html#a77dea85d3f6c73b7ab09a8741c4ba89e">00057</a> <a class="code" href="Declare__Inst_8h.html#afcab3f7633508e92f2077d767e19bc60">Implemente_instanciable_sans_constructeur</a>(<a class="code" href="classSETS.html">SETS</a>,<span class="stringliteral">&quot;SETS&quot;</span>,<a class="code" href="classSimpler.html">Simpler</a>);
<a name="l00058"></a>00058 
<a name="l00059"></a><a class="code" href="SETS_8cpp.html#a64c9e7e8a18adc394d769ec0b802eec5">00059</a> <a class="code" href="Declare__Inst_8h.html#afcab3f7633508e92f2077d767e19bc60">Implemente_instanciable_sans_constructeur</a>(<a class="code" href="classICE.html">ICE</a>,<span class="stringliteral">&quot;ICE&quot;</span>,<a class="code" href="classSETS.html">SETS</a>);
<a name="l00060"></a>00060 
<a name="l00061"></a><a class="code" href="classSETS.html#a18b50ad40531ec8d3b01fdf02bec2cb4">00061</a> <a class="code" href="classSETS.html#a18b50ad40531ec8d3b01fdf02bec2cb4">SETS::SETS</a>()
<a name="l00062"></a>00062 {
<a name="l00063"></a>00063   <a class="code" href="classSETS.html#a037404a748a911b2e260905354a6c7f2" title="1 si on fait l&#39;etape de prediction des vitesses">sets_</a> = 1;
<a name="l00064"></a>00064 }
<a name="l00065"></a>00065 
<a name="l00066"></a><a class="code" href="classICE.html#a12220fedf13f3909a1638f526c978e0f">00066</a> <a class="code" href="classICE.html#a12220fedf13f3909a1638f526c978e0f">ICE::ICE</a>()
<a name="l00067"></a>00067 {
<a name="l00068"></a>00068   <a class="code" href="classSETS.html#a037404a748a911b2e260905354a6c7f2" title="1 si on fait l&#39;etape de prediction des vitesses">sets_</a> = 0;
<a name="l00069"></a>00069 }
<a name="l00070"></a>00070 
<a name="l00071"></a><a class="code" href="classSETS.html#a2ad086699b67f2c4be9b94b886abadc9">00071</a> <a class="code" href="classSortie.html" title="Classe de base des flux de sortie. Elle sait ecrire des types simples&lt;br&gt;(entiers, flottants) et des Ob...">Sortie</a>&amp; <a class="code" href="classSETS.html#a2ad086699b67f2c4be9b94b886abadc9" title="Ecriture de l&#39;objet sur un flot de sortie Methode a surcharger.">SETS::printOn</a>(<a class="code" href="classSortie.html" title="Classe de base des flux de sortie. Elle sait ecrire des types simples&lt;br&gt;(entiers, flottants) et des Ob...">Sortie</a>&amp; os )<span class="keyword"> const</span>
<a name="l00072"></a>00072 <span class="keyword"></span>{
<a name="l00073"></a>00073   <span class="keywordflow">return</span> <a class="code" href="classSETS.html#a2ad086699b67f2c4be9b94b886abadc9" title="Ecriture de l&#39;objet sur un flot de sortie Methode a surcharger.">Simpler::printOn</a>(os);
<a name="l00074"></a>00074 }
<a name="l00075"></a>00075 
<a name="l00076"></a><a class="code" href="classSETS.html#a12e94bf4ecd4e24b8bd838c78df8004e">00076</a> <a class="code" href="classEntree.html" title="Classe de definition des operateurs et methodes pour toute lecture dans un flot d&#39;entree (fichier...">Entree</a>&amp; <a class="code" href="classSETS.html#a12e94bf4ecd4e24b8bd838c78df8004e" title="Lecture d&#39;un Objet_U sur un flot d&#39;entree Methode a surcharger.">SETS::readOn</a>(<a class="code" href="classEntree.html" title="Classe de definition des operateurs et methodes pour toute lecture dans un flot d&#39;entree (fichier...">Entree</a>&amp; is )
<a name="l00077"></a>00077 {
<a name="l00078"></a>00078   <span class="comment">/* valeurs par defaut des criteres de convergence */</span>
<a name="l00079"></a>00079   <a class="code" href="classSETS.html#a2dc023a4074725a2d139135afb6859cf">crit_conv</a> = { { <span class="stringliteral">&quot;alpha&quot;</span>, 1e-2 }, { <span class="stringliteral">&quot;temperature&quot;</span>, 1e-1 }, { <span class="stringliteral">&quot;vitesse&quot;</span>, 1e-2 }, { <span class="stringliteral">&quot;pression&quot;</span>, 100 } };
<a name="l00080"></a>00080   <a class="code" href="classSETS.html#abc7f91897922f8e62d9b9a181ff35f51">first_call_</a> = 1;
<a name="l00081"></a>00081   <a class="code" href="classSETS.html#a12e94bf4ecd4e24b8bd838c78df8004e" title="Lecture d&#39;un Objet_U sur un flot d&#39;entree Methode a surcharger.">Simpler::readOn</a>(is);
<a name="l00082"></a>00082   <span class="keywordflow">return</span> is;
<a name="l00083"></a>00083 }
<a name="l00084"></a>00084 
<a name="l00085"></a><a class="code" href="classSETS.html#a496bf32c88bdc0db99d03e6f925229a0">00085</a> <a class="code" href="classEntree.html" title="Classe de definition des operateurs et methodes pour toute lecture dans un flot d&#39;entree (fichier...">Entree</a>&amp; <a class="code" href="classSETS.html#a496bf32c88bdc0db99d03e6f925229a0">SETS::lire</a>(<span class="keyword">const</span> <a class="code" href="classMotcle.html" title="Une chaine de caractere (Nom) en majuscules.">Motcle</a>&amp; mot, <a class="code" href="classEntree.html" title="Classe de definition des operateurs et methodes pour toute lecture dans un flot d&#39;entree (fichier...">Entree</a>&amp; is)
<a name="l00086"></a>00086 {
<a name="l00087"></a>00087   <span class="keywordflow">if</span> (mot == <a class="code" href="classMotcle.html" title="Une chaine de caractere (Nom) en majuscules.">Motcle</a>(<span class="stringliteral">&quot;criteres_convergence&quot;</span>))
<a name="l00088"></a>00088     {
<a name="l00089"></a>00089       <a class="code" href="classNom.html" title="class Nom Une chaine de caractere pour nommer les objets de TRUST">Nom</a> <a class="code" href="classProbleme__U.html#a540cb8b6e3ce96127df02c6b2aff0668">nom</a>;
<a name="l00090"></a>00090       is &gt;&gt; <a class="code" href="classProbleme__U.html#a540cb8b6e3ce96127df02c6b2aff0668">nom</a>;
<a name="l00091"></a>00091       <span class="keywordflow">if</span> (nom != <span class="stringliteral">&quot;{&quot;</span>) <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;SETS::lire() : { expected instead of &quot;</span> &lt;&lt; nom &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>, <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">Process::exit</a>();
<a name="l00092"></a>00092       <span class="keywordflow">for</span> (is &gt;&gt; nom; nom != <span class="stringliteral">&quot;}&quot;</span>; is &gt;&gt; <a class="code" href="classProbleme__U.html#a540cb8b6e3ce96127df02c6b2aff0668">nom</a>)
<a name="l00093"></a>00093         {
<a name="l00094"></a>00094           <span class="keywordtype">double</span> val;
<a name="l00095"></a>00095           is &gt;&gt; val;
<a name="l00096"></a>00096           <a class="code" href="classSETS.html#a2dc023a4074725a2d139135afb6859cf">crit_conv</a>[nom.getString()] = val;
<a name="l00097"></a>00097         }
<a name="l00098"></a>00098     }
<a name="l00099"></a>00099   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (mot == <span class="stringliteral">&quot;iter_min&quot;</span>) is &gt;&gt; <a class="code" href="classSETS.html#a416660a4c6b560c16a63ef41bc99383f">iter_min_</a>;
<a name="l00100"></a>00100   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (mot == <span class="stringliteral">&quot;iter_max&quot;</span>) is &gt;&gt; <a class="code" href="classSETS.html#acf75db99aa6f39fb02552f774ac26d17">iter_max_</a>;
<a name="l00101"></a>00101   <span class="keywordflow">else</span> <span class="keywordflow">return</span> <a class="code" href="classSETS.html#a496bf32c88bdc0db99d03e6f925229a0">Simpler::lire</a>(mot, is); <span class="comment">//la classe mere connait-elle ce mot cle?</span>
<a name="l00102"></a>00102   <span class="keywordflow">return</span> is;
<a name="l00103"></a>00103 }
<a name="l00104"></a>00104 
<a name="l00105"></a>00105 
<a name="l00106"></a><a class="code" href="classICE.html#a6874576e991f661c0c68afb9493f7995">00106</a> <a class="code" href="classSortie.html" title="Classe de base des flux de sortie. Elle sait ecrire des types simples&lt;br&gt;(entiers, flottants) et des Ob...">Sortie</a>&amp; <a class="code" href="classICE.html#a6874576e991f661c0c68afb9493f7995" title="Ecriture de l&#39;objet sur un flot de sortie Methode a surcharger.">ICE::printOn</a>(<a class="code" href="classSortie.html" title="Classe de base des flux de sortie. Elle sait ecrire des types simples&lt;br&gt;(entiers, flottants) et des Ob...">Sortie</a>&amp; os )<span class="keyword"> const</span>
<a name="l00107"></a>00107 <span class="keyword"></span>{
<a name="l00108"></a>00108   <span class="keywordflow">return</span> <a class="code" href="classICE.html#a6874576e991f661c0c68afb9493f7995" title="Ecriture de l&#39;objet sur un flot de sortie Methode a surcharger.">SETS::printOn</a>(os);
<a name="l00109"></a>00109 }
<a name="l00110"></a>00110 
<a name="l00111"></a><a class="code" href="classICE.html#a1dc1a3e445545c106b46f5a335ba2825">00111</a> <a class="code" href="classEntree.html" title="Classe de definition des operateurs et methodes pour toute lecture dans un flot d&#39;entree (fichier...">Entree</a>&amp; <a class="code" href="classICE.html#a1dc1a3e445545c106b46f5a335ba2825" title="Lecture d&#39;un Objet_U sur un flot d&#39;entree Methode a surcharger.">ICE::readOn</a>(<a class="code" href="classEntree.html" title="Classe de definition des operateurs et methodes pour toute lecture dans un flot d&#39;entree (fichier...">Entree</a>&amp; is )
<a name="l00112"></a>00112 {
<a name="l00113"></a>00113   <a class="code" href="classICE.html#a1dc1a3e445545c106b46f5a335ba2825" title="Lecture d&#39;un Objet_U sur un flot d&#39;entree Methode a surcharger.">SETS::readOn</a>(is);
<a name="l00114"></a>00114   <span class="keywordflow">return</span> is;
<a name="l00115"></a>00115 }
<a name="l00116"></a>00116 
<a name="l00117"></a><a class="code" href="SETS_8cpp.html#a5065e01b298005c425e8495ed7344c66">00117</a> <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">double</span> <a class="code" href="SETS_8cpp.html#a5065e01b298005c425e8495ed7344c66">corriger_incr_alpha</a>(<span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; alpha, <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; incr)
<a name="l00118"></a>00118 {
<a name="l00119"></a>00119   <span class="keywordtype">int</span> i, n, N = alpha.<a class="code" href="classDoubleVect.html#ab02d01cd1bdab66fbd66f9a47cc29e10">line_size</a>();
<a name="l00120"></a>00120   <span class="keywordtype">double</span> a_sum, corr_max = 0;
<a name="l00121"></a>00121   <a class="code" href="classDoubleTrav.html" title="Tableau de travail a n entrees pour n&lt;= 4 C&#39;est un DoubleTab avec allocation dans un pool de memoire g...">DoubleTrav</a> n_a(N);
<a name="l00122"></a>00122   <span class="keywordflow">for</span> (i = 0; i &lt; alpha.<a class="code" href="classDoubleTab.html#a3eadd63f3ba20c1b454d760b430acbf7" title="Returns the total dimensions of the multi-dimensionnal array, including virtual items (used in parall...">dimension_tot</a>(0); i++)
<a name="l00123"></a>00123     {
<a name="l00124"></a>00124       <span class="keywordflow">for</span> (n = 0; n &lt; N; n++) n_a(n) = alpha(i, n) + incr(i, n);
<a name="l00125"></a>00125       <span class="keywordflow">for</span> (a_sum = 0, n = 0; n &lt; N; n++) n_a(n) = <a class="code" href="Double_8h.html#a1c45761573e6cbc97cfacac78d905016">max</a>(n_a(n), 0.), a_sum += n_a(n);
<a name="l00126"></a>00126       <span class="keywordflow">if</span> (a_sum) <span class="keywordflow">for</span> (n = 0; n &lt; N; n++) n_a(n) /= a_sum;
<a name="l00127"></a>00127       <span class="keywordflow">else</span> <span class="keywordflow">for</span> (n = 0; n &lt; N; n++) n_a(n) = 1. / N;
<a name="l00128"></a>00128       <span class="keywordflow">for</span> (n = 0; n &lt; N; n++) corr_max = <a class="code" href="Double_8h.html#a1c45761573e6cbc97cfacac78d905016">max</a>(corr_max, <a class="code" href="Double_8h.html#aaecd4ca8a2fe69cc6568af2938b94d2e">dabs</a>(alpha(i, n) + incr(i, n) - n_a(n))), incr(i, n) = n_a(n) - alpha(i, n);
<a name="l00129"></a>00129     }
<a name="l00130"></a>00130   <span class="keywordflow">return</span> <a class="code" href="classProcess.html#a1e9d9f9899b71927cfafae14c7bd048d" title="Calcule le max de x sur tous les processeurs du groupe courant. Remarques : Cette methode doit etre a...">Process::mp_max</a>(corr_max);
<a name="l00131"></a>00131 }
<a name="l00132"></a>00132 
<a name="l00133"></a><a class="code" href="classSETS.html#a9836d357794031783bf88ed0c6c3efcf">00133</a> <span class="keywordtype">bool</span> <a class="code" href="classSETS.html#a9836d357794031783bf88ed0c6c3efcf">SETS::iterer_eqn</a>(<a class="code" href="classEquation__base.html">Equation_base</a>&amp; eqn, <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; inut, <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; current, <span class="keywordtype">double</span> dt, <span class="keywordtype">int</span> numero_iteration, <span class="keywordtype">int</span>&amp; ok)
<a name="l00134"></a>00134 {
<a name="l00135"></a>00135   <span class="keywordtype">int</span> cv;
<a name="l00136"></a>00136   <span class="comment">/* on ne traite que Pb_Multiphase ou Pb_conduction */</span>
<a name="l00137"></a>00137   <span class="keywordflow">if</span> (!<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classPb__Multiphase.html" title="classe Pb_Multiphase Cette classe represente un probleme de thermohydraulique multiphase de type &quot;3*...">Pb_Multiphase</a>, eqn.<a class="code" href="classEquation__base.html#aa8151a96f63719523bf50ddd832e0f8f" title="Renvoie le probleme associe a l&#39;equation.">probleme</a>()) &amp;&amp; !<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classPb__Conduction.html" title="Classe Pb_Conduction Cette classe represente un probleme de conduction avec rho et Cp non uniformes :...">Pb_Conduction</a>, eqn.<a class="code" href="classEquation__base.html#aa8151a96f63719523bf50ddd832e0f8f" title="Renvoie le probleme associe a l&#39;equation.">probleme</a>()))
<a name="l00138"></a>00138     <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">Process::exit</a>(<a class="code" href="classObjet__U.html#aa58e9a81c0ddc2c1149053b8f96698ac" title="renvoie la chaine identifiant la classe.">que_suis_je</a>() + <span class="stringliteral">&quot; cannot be applied to the problem &quot;</span> + eqn.<a class="code" href="classEquation__base.html#aa8151a96f63719523bf50ddd832e0f8f" title="Renvoie le probleme associe a l&#39;equation.">probleme</a>().<a class="code" href="classProbleme__base.html#a58bc0b101f3f3f1d8522a9f41f1fad7b" title="surcharge Objet_U::le_nom() Renvoie le nom du probleme">le_nom</a>() + <span class="stringliteral">&quot; of type &quot;</span> + eqn.<a class="code" href="classEquation__base.html#aa8151a96f63719523bf50ddd832e0f8f" title="Renvoie le probleme associe a l&#39;equation.">probleme</a>().<a class="code" href="classObjet__U.html#aa58e9a81c0ddc2c1149053b8f96698ac" title="renvoie la chaine identifiant la classe.">que_suis_je</a>() + <span class="stringliteral">&quot;!&quot;</span>);
<a name="l00139"></a>00139 
<a name="l00140"></a>00140   <span class="comment">/* equations non resolues directement : Masse_Multiphase (toujours), Energie_Multiphase (en ICE) */</span>
<a name="l00141"></a>00141   <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classMasse__Multiphase.html" title="classe Masse_Multiphase Cas particulier de Convection_Diffusion_std pour un fluide quasi conpressible...">Masse_Multiphase</a>, eqn) || (!<a class="code" href="classSETS.html#a037404a748a911b2e260905354a6c7f2" title="1 si on fait l&#39;etape de prediction des vitesses">sets_</a> &amp;&amp; <a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classEnergie__Multiphase.html" title="classe Energie_Multiphase Cas particulier de Convection_Diffusion_std pour un fluide quasi conpressib...">Energie_Multiphase</a>, eqn)))
<a name="l00142"></a>00142     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00143"></a>00143 
<a name="l00144"></a>00144   <span class="comment">/* QDM_Multiphase: resolue par iterer_NS */</span>
<a name="l00145"></a>00145   <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classQDM__Multiphase.html" title="classe QDM_Multiphase Cette classe porte les termes de l&#39;equation de la dynamique pour un fluide sans...">QDM_Multiphase</a>, eqn))
<a name="l00146"></a>00146     {
<a name="l00147"></a>00147       <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a> matrix_unused;
<a name="l00148"></a>00148       <a class="code" href="classDoubleTrav.html" title="Tableau de travail a n entrees pour n&lt;= 4 C&#39;est un DoubleTab avec allocation dans un pool de memoire g...">DoubleTrav</a> secmem_unused;
<a name="l00149"></a>00149       <a class="code" href="classSETS.html#a0f22d8191523bca38ac875ca7e810cf0">iterer_NS</a>(eqn, current, <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classQDM__Multiphase.html" title="classe QDM_Multiphase Cette classe porte les termes de l&#39;equation de la dynamique pour un fluide sans...">QDM_Multiphase</a>, eqn).pression().valeurs(), dt, matrix_unused, 0, secmem_unused, numero_iteration, cv, ok);
<a name="l00150"></a>00150       <span class="keywordflow">return</span> cv;
<a name="l00151"></a>00151     }
<a name="l00152"></a>00152 
<a name="l00153"></a>00153   <span class="comment">/* cas restant : equation thermique d&#39;un Pb_Multi ou d&#39;un Pb_conduction -&gt; on regle semi_impl si necessaire, puis on resout */</span>
<a name="l00154"></a>00154   <span class="keyword">const</span> std::string&amp; nom_inco = eqn.<a class="code" href="classEquation__base.html#a5a1fce9487b9a8dd17020914100c2c89">inconnue</a>().<a class="code" href="classO__U__Ptr.html#a5aae0c48048a40339f3847aa14109231" title="Renvoie ref_().le_nom() si le pointeur est non nul ou &quot;Pointeur Nul&quot;.">le_nom</a>().<a class="code" href="classNom.html#a855d8cd96b5c73c2aa55cb7c0a870640">getString</a>();
<a name="l00155"></a>00155   <a class="code" href="Interface__blocs_8h.html#a2d7480bf11fc9f791b1d2839fa30a5c3">tabs_t</a> semi_impl; <span class="comment">/* en ICE, les temperatures de tous les problemes sont explicites */</span>
<a name="l00156"></a>00156   <span class="keyword">const</span> <a class="code" href="classOperateur__Diff__base.html" title="classe Operateur_Diff_base Cette classe est la base de la hierarchie des operateurs representant un t...">Operateur_Diff_base</a>&amp; op_diff = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classOperateur__Diff__base.html" title="classe Operateur_Diff_base Cette classe est la base de la hierarchie des operateurs representant un t...">Operateur_Diff_base</a>, eqn.<a class="code" href="classEquation__base.html#a8406eaa10e61a27e9a2e1cacea253c3e">operateur</a>(0).<a class="code" href="classOperateur.html#a1f3e24efd9b54d05821e731fe4bd6027">l_op_base</a>());
<a name="l00157"></a>00157   <span class="keywordflow">if</span> (!<a class="code" href="classSETS.html#a037404a748a911b2e260905354a6c7f2" title="1 si on fait l&#39;etape de prediction des vitesses">sets_</a>) <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;&amp;op_ext : op_diff.<a class="code" href="classOperateur__Diff__base.html#a55bd9b2fad5e6ef816f89ea07371ddfc">op_ext</a>)
<a name="l00158"></a>00158       semi_impl[nom_inco + (op_ext != &amp;op_diff ? <span class="stringliteral">&quot;_&quot;</span> + op_ext-&gt;<a class="code" href="classMorEqn.html#a615dd9abff96edcb625fa0424a489864" title="Renvoie la reference sur l&#39;equation pointe par MorEqn::mon_equation. (version const)">equation</a>().<a class="code" href="classEquation__base.html#aa8151a96f63719523bf50ddd832e0f8f" title="Renvoie le probleme associe a l&#39;equation.">probleme</a>().<a class="code" href="classProbleme__base.html#a58bc0b101f3f3f1d8522a9f41f1fad7b" title="surcharge Objet_U::le_nom() Renvoie le nom du probleme">le_nom</a>().<a class="code" href="classNom.html#a855d8cd96b5c73c2aa55cb7c0a870640">getString</a>() : <span class="stringliteral">&quot;&quot;</span>)] = op_ext-&gt;equation().inconnue().passe();
<a name="l00159"></a>00159 
<a name="l00160"></a>00160   <span class="keywordflow">if</span> (!<a class="code" href="classSETS.html#aa96e420735d53c9033c0031f4a02a379">mat_pred</a>.count(nom_inco)) <span class="comment">/* matrice : dimensionnement au premier passage */</span>
<a name="l00161"></a>00161     eqn.<a class="code" href="classEquation__base.html#a5ba7300a466493c7b41b739688d23887">dimensionner_blocs</a>({{ nom_inco, &amp;<a class="code" href="classSETS.html#aa96e420735d53c9033c0031f4a02a379">mat_pred</a>[nom_inco]}}, semi_impl);
<a name="l00162"></a>00162 
<a name="l00163"></a>00163   <span class="comment">/* assemblage et resolution */</span>
<a name="l00164"></a>00164   <a class="code" href="classDoubleTrav.html" title="Tableau de travail a n entrees pour n&lt;= 4 C&#39;est un DoubleTab avec allocation dans un pool de memoire g...">DoubleTrav</a> secmem(current);
<a name="l00165"></a>00165   <a class="code" href="classSolveurSys.html">SolveurSys</a>&amp; solv = get_and_set_parametre_implicite(eqn).solveur();
<a name="l00166"></a>00166   eqn.assembler_blocs_avec_inertie({{ nom_inco, &amp;mat_pred[nom_inco] }}, secmem, semi_impl);
<a name="l00167"></a>00167   mat_pred[nom_inco].ajouter_multvect(current, secmem); <span class="comment">//passage increment -&gt; variable</span>
<a name="l00168"></a>00168   solv.<a class="code" href="classDeriv__SolveurSys__base.html#aa1f67fc10fc25960d05d484a67d1bb54">valeur</a>().<a class="code" href="classSolveurSys__base.html#a8737bd7292204c64e4b7bfe4c7bd88ef">reinit</a>();
<a name="l00169"></a>00169   solv.<a class="code" href="classSolveurSys.html#a62ca198f0c5dc599e53b0535761e5138">resoudre_systeme</a>(mat_pred[nom_inco], secmem, current);
<a name="l00170"></a>00170 
<a name="l00171"></a>00171   <span class="comment">/* mise a jour */</span>
<a name="l00172"></a>00172   eqn.probleme().mettre_a_jour(eqn.schema_temps().temps_courant());
<a name="l00173"></a>00173   eqn.inconnue().futur() = current;
<a name="l00174"></a>00174   <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00175"></a>00175 }
<a name="l00176"></a>00176 
<a name="l00177"></a>00177 <span class="comment">// Entree Un ; Pn</span>
<a name="l00178"></a>00178 <span class="comment">// Sortie Un+1 = U***_k ; Pn+1 = P**_k</span>
<a name="l00179"></a>00179 <span class="comment">// n designe une etape temporelle</span>
<a name="l00180"></a>00180 
<a name="l00181"></a><a class="code" href="classSETS.html#a0f22d8191523bca38ac875ca7e810cf0">00181</a> <span class="keywordtype">void</span> <a class="code" href="classSETS.html#a0f22d8191523bca38ac875ca7e810cf0">SETS::iterer_NS</a>(<a class="code" href="classEquation__base.html">Equation_base</a>&amp; eqn,<a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; current,<a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; pression,
<a name="l00182"></a>00182                      <span class="keywordtype">double</span> dt,<a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; matrice_unused,<span class="keywordtype">double</span> seuil_resol,<a class="code" href="classDoubleTrav.html" title="Tableau de travail a n entrees pour n&lt;= 4 C&#39;est un DoubleTab avec allocation dans un pool de memoire g...">DoubleTrav</a>&amp; secmem_unused,<span class="keywordtype">int</span> nb_ite,<span class="keywordtype">int</span>&amp; cv, <span class="keywordtype">int</span>&amp; ok)
<a name="l00183"></a>00183 {
<a name="l00184"></a>00184   <span class="keywordtype">int</span> i, j, &amp;it = <a class="code" href="classSETS.html#a73c4e579bc537898da0bc707ac19fb3a">iteration</a>;
<a name="l00185"></a>00185   <a class="code" href="classPb__Multiphase.html" title="classe Pb_Multiphase Cette classe represente un probleme de thermohydraulique multiphase de type &quot;3*...">Pb_Multiphase</a>&amp; pb = *(<a class="code" href="classPb__Multiphase.html" title="classe Pb_Multiphase Cette classe represente un probleme de thermohydraulique multiphase de type &quot;3*...">Pb_Multiphase</a> *) &amp;<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classPb__Multiphase.html" title="classe Pb_Multiphase Cette classe represente un probleme de thermohydraulique multiphase de type &quot;3*...">Pb_Multiphase</a>, eqn.<a class="code" href="classEquation__base.html#aa8151a96f63719523bf50ddd832e0f8f" title="Renvoie le probleme associe a l&#39;equation.">probleme</a>());
<a name="l00186"></a>00186   <a class="code" href="classQDM__Multiphase.html" title="classe QDM_Multiphase Cette classe porte les termes de l&#39;equation de la dynamique pour un fluide sans...">QDM_Multiphase</a>&amp; <a class="code" href="classPb__Multiphase.html#adf2872b95eb3bdb1a22e6d3c55bda061">eq_qdm</a> = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classQDM__Multiphase.html" title="classe QDM_Multiphase Cette classe porte les termes de l&#39;equation de la dynamique pour un fluide sans...">QDM_Multiphase</a>, eqn);
<a name="l00187"></a>00187   <span class="keywordtype">double</span> t = eqn.<a class="code" href="classEquation__base.html#abc11e51aa75b4c7aa55c27f71eb2f2c4" title="Renvoie le schema en temps associe a l&#39;equation.">schema_temps</a>().<a class="code" href="classSchema__Temps__base.html#a5054df01edb6d4f7baec7e612d423834" title="Renvoie le temps courant.">temps_courant</a>();
<a name="l00188"></a>00188 
<a name="l00189"></a>00189   <a class="code" href="classEquation__base.html">Equation_base</a> *eq_list[3] = { &amp;pb.<a class="code" href="classPb__Multiphase.html#affb5ae03eb9e469afd34b084cda27d95">eq_masse</a>, &amp;pb.<a class="code" href="classPb__Multiphase.html#a43dfdb9dff5fc80ed2d4adfc71e562bf">eq_energie</a>, &amp;eq_qdm }; <span class="comment">//ordre des 3 equations</span>
<a name="l00190"></a>00190   std::map&lt;std::string, Equation_base *&gt; eqs; <span class="comment">//eqs[inconnue] = equation</span>
<a name="l00191"></a>00191   std::vector&lt;std::string&gt; noms; <span class="comment">//ordre des inconnues : le meme que les equations, puis la pression</span>
<a name="l00192"></a>00192   <span class="keywordflow">for</span> (i = 0; i &lt; 3; i++) noms.push_back(eq_list[i]-&gt;<a class="code" href="classEquation__base.html#a5a1fce9487b9a8dd17020914100c2c89">inconnue</a>().<a class="code" href="classO__U__Ptr.html#a5aae0c48048a40339f3847aa14109231" title="Renvoie ref_().le_nom() si le pointeur est non nul ou &quot;Pointeur Nul&quot;.">le_nom</a>().<a class="code" href="classNom.html#a855d8cd96b5c73c2aa55cb7c0a870640">getString</a>()), eqs[noms[i]] = eq_list[i];
<a name="l00193"></a>00193   noms.push_back(<span class="stringliteral">&quot;pression&quot;</span>); <span class="comment">//pas d&#39;equation associee a la pression!</span>
<a name="l00194"></a>00194 
<a name="l00195"></a>00195   std::map&lt;std::string, Champ_Inc_base *&gt; inco; <span class="comment">//tous les Champ_Inc</span>
<a name="l00196"></a>00196   <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;n_eq : eqs) inco[n_eq.first] = &amp;n_eq.second-&gt;<a class="code" href="classEquation__base.html#a5a1fce9487b9a8dd17020914100c2c89">inconnue</a>().<a class="code" href="classDeriv__Champ__Inc__base.html#a9e0b743a3e124e7114fa977b36b68225">valeur</a>();
<a name="l00197"></a>00197   inco[<span class="stringliteral">&quot;pression&quot;</span>] = &amp;eq_qdm.<a class="code" href="classNavier__Stokes__std.html#afbb8f39bdfd70328dfad21bf2b9dd45a" title="Renvoie le champ de pression.">pression</a>().<a class="code" href="classDeriv__Champ__Inc__base.html#a9e0b743a3e124e7114fa977b36b68225">valeur</a>();
<a name="l00198"></a>00198 <span class="comment">// initialisation du Newton avec les valeurs presentes (stockees dans passe() en implicite), dimensionnement de incr / sec</span>
<a name="l00199"></a>00199   pb.<a class="code" href="classPb__Multiphase.html#a33f18892177ebe6a32d41821b6752a35" title="Effectue une mise a jour en temps du probleme. Effectue la mise a jour sur toutes les equations du pr...">mettre_a_jour</a>(t); <span class="comment">//inconnues -&gt; milieu -&gt; champs conserves</span>
<a name="l00200"></a>00200 
<a name="l00201"></a>00201   <span class="comment">/* valeurs semi-implicites : inconnues (alpha, v, T) et champs conserves (alpha_rho, alpha_rho_e) */</span>
<a name="l00202"></a>00202   <a class="code" href="Interface__blocs_8h.html#a2d7480bf11fc9f791b1d2839fa30a5c3">tabs_t</a> semi_impl;
<a name="l00203"></a>00203   <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;&amp;n_eq : eqs) <span class="keywordflow">if</span> (n_eq.second != &amp;eq_qdm)
<a name="l00204"></a>00204       {
<a name="l00205"></a>00205         semi_impl[n_eq.first] = n_eq.second-&gt;inconnue().passe();
<a name="l00206"></a>00206         semi_impl[n_eq.second-&gt;champ_conserve().le_nom().getString()] = n_eq.second-&gt;champ_conserve().passe();
<a name="l00207"></a>00207         semi_impl[n_eq.second-&gt;champ_convecte().le_nom().getString()]  =n_eq.second-&gt;champ_convecte().passe();
<a name="l00208"></a>00208       }
<a name="l00209"></a>00209 <span class="comment">// en SETS, on remplace la valeur passee de v par celle donnee par une etape de prediction</span>
<a name="l00210"></a>00210   <span class="keywordflow">if</span> (<a class="code" href="classSETS.html#a037404a748a911b2e260905354a6c7f2" title="1 si on fait l&#39;etape de prediction des vitesses">sets_</a> &amp;&amp; !<a class="code" href="classSETS.html#abc7f91897922f8e62d9b9a181ff35f51">first_call_</a>)
<a name="l00211"></a>00211     {
<a name="l00212"></a>00212       <a class="code" href="classDoubleTrav.html" title="Tableau de travail a n entrees pour n&lt;= 4 C&#39;est un DoubleTab avec allocation dans un pool de memoire g...">DoubleTrav</a> secmem(current);
<a name="l00213"></a>00213       <span class="comment">/* assemblage &quot;implicite, vitesses seulement&quot; */</span>
<a name="l00214"></a>00214       <span class="keywordflow">if</span> (!<a class="code" href="classSETS.html#aa96e420735d53c9033c0031f4a02a379">mat_pred</a>.count(<span class="stringliteral">&quot;vitesse&quot;</span>)) eq_qdm.<a class="code" href="classQDM__Multiphase.html#a7485eb5c2efca9dca5b1385e99cd2c4a">dimensionner_blocs</a>({{<span class="stringliteral">&quot;vitesse&quot;</span>, &amp;<a class="code" href="classSETS.html#aa96e420735d53c9033c0031f4a02a379">mat_pred</a>[<span class="stringliteral">&quot;vitesse&quot;</span>] }}); <span class="comment">//premier passage : dimensionnement</span>
<a name="l00215"></a>00215       <a class="code" href="classPb__Multiphase.html#adf2872b95eb3bdb1a22e6d3c55bda061">eq_qdm</a>.<a class="code" href="classQDM__Multiphase.html#adb75954515312e1b1afb90b7e86e3696">assembler_blocs_avec_inertie</a>({{<span class="stringliteral">&quot;vitesse&quot;</span>, &amp;mat_pred[<span class="stringliteral">&quot;vitesse&quot;</span>] }}, secmem);
<a name="l00216"></a>00216 
<a name="l00217"></a>00217       <span class="comment">/* resolution et stockage de la vitesse pedite dans current */</span>
<a name="l00218"></a>00218       <a class="code" href="classSolveurSys.html">SolveurSys</a>&amp; solv_qdm = get_and_set_parametre_implicite(eqn).solveur();
<a name="l00219"></a>00219       solv_qdm.<a class="code" href="classDeriv__SolveurSys__base.html#aa1f67fc10fc25960d05d484a67d1bb54">valeur</a>().<a class="code" href="classSolveurSys__base.html#a8737bd7292204c64e4b7bfe4c7bd88ef">reinit</a>();
<a name="l00220"></a>00220       mat_pred[<span class="stringliteral">&quot;vitesse&quot;</span>].ajouter_multvect(current, secmem); <span class="comment">//passage increment -&gt; variable pour faire plaisir aux solveurs iteratifs</span>
<a name="l00221"></a>00221       solv_qdm.<a class="code" href="classSolveurSys.html#a62ca198f0c5dc599e53b0535761e5138">resoudre_systeme</a>(mat_pred[<span class="stringliteral">&quot;vitesse&quot;</span>], secmem, current);
<a name="l00222"></a>00222       semi_impl[<span class="stringliteral">&quot;vitesse&quot;</span>] = current;
<a name="l00223"></a>00223     }
<a name="l00224"></a>00224   <span class="keywordflow">else</span> semi_impl[<span class="stringliteral">&quot;vitesse&quot;</span>] = <a class="code" href="classPb__Multiphase.html#adf2872b95eb3bdb1a22e6d3c55bda061">eq_qdm</a>.<a class="code" href="classNavier__Stokes__std.html#a743b777e6185faee7837326844c8fca1" title="Renvoie la vitesse (champ inconnue de l&#39;equation) (version const)">inconnue</a>().<a class="code" href="classChamp__Inc.html#ad4e16720f4575dceb8536c9f09635a3c" title="Appel a l&#39;objet sous-jacent Renvoie le tableau des valeurs au temps t-i.">passe</a>();
<a name="l00225"></a>00225   eqn.solv_masse().corriger_solution(current, current, 0); <span class="comment">//pour CoviMAC : vf -&gt; ve</span>
<a name="l00226"></a>00226 
<a name="l00227"></a>00227   first_call_ = 0;
<a name="l00228"></a>00228 
<a name="l00229"></a>00229 <span class="comment">// premier passage : dimensionnement de mat_semi_impl, remplissage de p_degen_</span>
<a name="l00230"></a>00230   <span class="keywordflow">if</span> (!mat_semi_impl.nb_lignes())
<a name="l00231"></a>00231     {
<a name="l00232"></a>00232       mat_semi_impl.dimensionner(3, 4);
<a name="l00233"></a>00233       <span class="keywordflow">for</span> (i = 0; i &lt; 3; i++) <span class="keywordflow">for</span> (j = 0; j &lt; 4; j++)
<a name="l00234"></a>00234           mat_semi_impl.get_bloc(i, j).typer(<span class="stringliteral">&quot;Matrice_Morse&quot;</span>), mats[noms[i]][noms[j]] = &amp;<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>, mat_semi_impl.get_bloc(i, j).valeur());
<a name="l00235"></a>00235       <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;&amp;n_eq : eqs) n_eq.second-&gt;dimensionner_blocs(mats[n_eq.first], semi_impl); <span class="comment">//option semi-implicite</span>
<a name="l00236"></a>00236 
<a name="l00237"></a>00237       <span class="comment">/* si incompressible sans CLs de pression imposee, alors la pression est degeneree */</span>
<a name="l00238"></a>00238       p_degen = <a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classFluide__base.html" title="classe Fluide_base Cette classe represente un d&#39;un fluide incompressible ainsi que ses proprietes: - ...">Fluide_base</a>, <a class="code" href="classPb__Multiphase.html#adf2872b95eb3bdb1a22e6d3c55bda061">eq_qdm</a>.<a class="code" href="classNavier__Stokes__std.html#a442d8f1138c18da07aa895728b3e41f2" title="Renvoie le milieu physique de l&#39;equation (le Fluide_base upcaste en Milieu_base)">milieu</a>());
<a name="l00239"></a>00239       <span class="keywordflow">for</span> (i = 0; i &lt; <a class="code" href="classPb__Multiphase.html#adf2872b95eb3bdb1a22e6d3c55bda061">eq_qdm</a>.<a class="code" href="classEquation__base.html#af265fe0ea30868eb2176a0c887e4efab" title="Renvoie la zone des conditions aux limite discretisee associee a l&#39;equation.">zone_Cl_dis</a>().<a class="code" href="classZone__Cl__dis.html#a7e0c9938057e7d427eea4954dd7bad58" title="Appel a l&#39;objet sous-jacent Renvoie le nombre de conditions aux limites.">nb_cond_lim</a>(); i++)
<a name="l00240"></a>00240         p_degen &amp;= !<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classNeumann__val__ext.html" title="Classe Neumann_val_ext Cette classe est la classe de base de la hierarchie des conditions aux limites...">Neumann_val_ext</a>, <a class="code" href="classPb__Multiphase.html#adf2872b95eb3bdb1a22e6d3c55bda061">eq_qdm</a>.<a class="code" href="classEquation__base.html#af265fe0ea30868eb2176a0c887e4efab" title="Renvoie la zone des conditions aux limite discretisee associee a l&#39;equation.">zone_Cl_dis</a>().<a class="code" href="classZone__Cl__dis.html#aafbd0525703e23200e31796bcd4fcac6" title="Appel a l&#39;objet sous-jacent Renvoie la i-ieme condition aux limites. (version const)">les_conditions_limites</a>(i).<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>());
<a name="l00241"></a>00241     }
<a name="l00242"></a>00242 
<a name="l00243"></a>00243 
<a name="l00244"></a>00244 
<a name="l00245"></a>00245   <span class="comment">/* Newton : assemblage de mat_semi_impl -&gt; assemblage de la matrice en pression -&gt; resolution -&gt; substitution */</span>
<a name="l00246"></a>00246   <a class="code" href="Interface__blocs_8h.html#a2d7480bf11fc9f791b1d2839fa30a5c3">tabs_t</a> incr, sec; <span class="comment">//increments / seconds membres associes</span>
<a name="l00247"></a>00247   <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;&amp;n_i : inco) incr[n_i.first] = sec[n_i.first] = n_i.second-&gt;valeurs();
<a name="l00248"></a>00248 
<a name="l00249"></a>00249   <span class="keywordflow">if</span> (!<a class="code" href="classProcess.html#ab55ba07167ec807ed3a145cac0f5dca4" title="renvoie mon rang dans le groupe de communication courant. Voir Comm_Group::rank() et PE_Groups::curre...">Process::me</a>())
<a name="l00250"></a>00250     {
<a name="l00251"></a>00251       fprintf(stderr, <span class="stringliteral">&quot;Increments for semi-implicit method :\n  it&quot;</span>);
<a name="l00252"></a>00252       <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;&amp;n_i : inco) fprintf(stderr, <span class="stringliteral">&quot; %11s&quot;</span>, n_i.first.c_str());
<a name="l00253"></a>00253       fprintf(stderr, <span class="stringliteral">&quot;\n&quot;</span>);
<a name="l00254"></a>00254     }
<a name="l00255"></a>00255 
<a name="l00256"></a>00256   <span class="keywordflow">for</span> (it = 0, cv = 0; it &lt; iter_min_ || (!cv &amp;&amp; it &lt; iter_max_); it++)
<a name="l00257"></a>00257     {
<a name="l00258"></a>00258       <span class="comment">/* remplissage par assembler_blocs */</span>
<a name="l00259"></a>00259       <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;&amp;n_eq : eqs) n_eq.second-&gt;assembler_blocs_avec_inertie(mats[n_eq.first], sec[n_eq.first], semi_impl);
<a name="l00260"></a>00260 
<a name="l00261"></a>00261       <span class="comment">/* expression des autres inconnues (x) en fonction de p : vitesse, puis temperature / pression */</span>
<a name="l00262"></a>00262       <a class="code" href="Interface__blocs_8h.html#a2d7480bf11fc9f791b1d2839fa30a5c3">tabs_t</a> b_p;
<a name="l00263"></a>00263       eliminer({{{ <span class="stringliteral">&quot;vitesse&quot;</span>, 1 }}, {{ <span class="stringliteral">&quot;vitesse&quot;</span>, 0 }}, {{ <span class="stringliteral">&quot;alpha&quot;</span>, 0 }, {<span class="stringliteral">&quot;temperature&quot;</span>, 0 }}}, <span class="stringliteral">&quot;pression&quot;</span>, mats, sec, A_p, b_p);
<a name="l00264"></a>00264 
<a name="l00265"></a>00265       <span class="comment">/* assemblage du systeme en pression */</span>
<a name="l00266"></a>00266       <a class="code" href="classDoubleTrav.html" title="Tableau de travail a n entrees pour n&lt;= 4 C&#39;est un DoubleTab avec allocation dans un pool de memoire g...">DoubleTrav</a> secmem_pression;
<a name="l00267"></a>00267       <a class="code" href="Champ__P1iP1B__implementation_8cpp.html#a66b05ebb3893c77d400802a0828ab94d">assembler</a>(<span class="stringliteral">&quot;pression&quot;</span>, {}, A_p, b_p, mats, sec, inco[<span class="stringliteral">&quot;alpha&quot;</span>]-&gt;valeurs(), matrice_pression, secmem_pression, p_degen);
<a name="l00268"></a>00268 
<a name="l00269"></a>00269       <span class="comment">/* resolution : seulement si l&#39;erreur en alpha (dans secmem_pression) depasse un seuil */</span>
<a name="l00270"></a>00270       <span class="keywordflow">if</span> (<a class="code" href="DoubleVect_8cpp.html#acb21ec8c0b3909c26b20e3f3455e0289">mp_max_abs_vect</a>(secmem_pression) &gt; 1e-16)
<a name="l00271"></a>00271         {
<a name="l00272"></a>00272           matrice_pression.ajouter_multvect(inco[<span class="stringliteral">&quot;pression&quot;</span>]-&gt;valeurs(), secmem_pression); <span class="comment">//passage increment -&gt; variable pour faire plaisir aux solveurs iteratifs</span>
<a name="l00273"></a>00273           <a class="code" href="classSolveurSys.html">SolveurSys</a>&amp; solv_p = <a class="code" href="classPb__Multiphase.html#adf2872b95eb3bdb1a22e6d3c55bda061">eq_qdm</a>.<a class="code" href="classNavier__Stokes__std.html#ae83d9f7a42531293583f32be1efd3d5f" title="Renvoie le solveur en pression&lt;br&gt;(version const)">solveur_pression</a>();
<a name="l00274"></a>00274           solv_p.<a class="code" href="classDeriv__SolveurSys__base.html#aa1f67fc10fc25960d05d484a67d1bb54">valeur</a>().<a class="code" href="classSolveurSys__base.html#a8737bd7292204c64e4b7bfe4c7bd88ef">reinit</a>(), solv_p.<a class="code" href="classDeriv__SolveurSys__base.html#aa1f67fc10fc25960d05d484a67d1bb54">valeur</a>().<a class="code" href="classSolveurSys__base.html#a27067468cf159dc2e08c693ac7432685">set_return_on_error</a>(1); <span class="comment">/* pour eviter un exit() en cas d&#39;echec */</span>
<a name="l00275"></a>00275           ok = (solv_p.<a class="code" href="classSolveurSys.html#a62ca198f0c5dc599e53b0535761e5138">resoudre_systeme</a>(matrice_pression, secmem_pression, incr[<span class="stringliteral">&quot;pression&quot;</span>]) &gt;= 0);
<a name="l00276"></a>00276           <span class="keywordflow">if</span> (!ok) <span class="keywordflow">break</span>; <span class="comment">//le solveur a echoue -&gt; on sort</span>
<a name="l00277"></a>00277           incr[<span class="stringliteral">&quot;pression&quot;</span>] -= inco[<span class="stringliteral">&quot;pression&quot;</span>]-&gt;valeurs();
<a name="l00278"></a>00278         }
<a name="l00279"></a>00279       <span class="keywordflow">else</span> incr[<span class="stringliteral">&quot;pression&quot;</span>] = 0;
<a name="l00280"></a>00280 
<a name="l00281"></a>00281 <span class="comment">// increments des autres variables</span>
<a name="l00282"></a>00282       <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;&amp;n_v : b_p)
<a name="l00283"></a>00283         {
<a name="l00284"></a>00284           incr[n_v.first] = n_v.second; <span class="comment">//partie constante</span>
<a name="l00285"></a>00285           A_p[n_v.first].ajouter_multvect(incr[<span class="stringliteral">&quot;pression&quot;</span>], incr[n_v.first]); <span class="comment">//dependance en les increments de pression</span>
<a name="l00286"></a>00286           incr[n_v.first].echange_espace_virtuel();
<a name="l00287"></a>00287         }
<a name="l00288"></a>00288       eqn.solv_masse().corriger_solution(incr[<span class="stringliteral">&quot;vitesse&quot;</span>], incr[<span class="stringliteral">&quot;vitesse&quot;</span>], 1); <span class="comment">//pour CoviMAC : sert a corriger ve</span>
<a name="l00289"></a>00289 
<a name="l00290"></a>00290       <span class="comment">/* convergence? */</span>
<a name="l00291"></a>00291       cv = (<a class="code" href="SETS_8cpp.html#a5065e01b298005c425e8495ed7344c66">corriger_incr_alpha</a>(inco[<span class="stringliteral">&quot;alpha&quot;</span>]-&gt;valeurs(), incr[<span class="stringliteral">&quot;alpha&quot;</span>]) &lt; crit_conv[<span class="stringliteral">&quot;alpha&quot;</span>]);
<a name="l00292"></a>00292       <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;&amp; n_v : incr) cv &amp;= (<a class="code" href="DoubleVect_8cpp.html#acb21ec8c0b3909c26b20e3f3455e0289">mp_max_abs_vect</a>(n_v.second) &lt; crit_conv.at(n_v.first));
<a name="l00293"></a>00293 
<a name="l00294"></a>00294       <span class="keywordflow">if</span> (!<a class="code" href="classProcess.html#ab55ba07167ec807ed3a145cac0f5dca4" title="renvoie mon rang dans le groupe de communication courant. Voir Comm_Group::rank() et PE_Groups::curre...">Process::me</a>())
<a name="l00295"></a>00295 #ifndef INT_is_64_
<a name="l00296"></a>00296         fprintf(stderr, <span class="stringliteral">&quot;%4d&quot;</span>, it + 1);
<a name="l00297"></a>00297 <span class="preprocessor">#else</span>
<a name="l00298"></a>00298 <span class="preprocessor"></span>        fprintf(stderr, <span class="stringliteral">&quot;%4ld&quot;</span>, it + 1);
<a name="l00299"></a>00299 <span class="preprocessor">#endif</span>
<a name="l00300"></a>00300 <span class="preprocessor"></span>      <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;&amp;n_v : incr)
<a name="l00301"></a>00301         {
<a name="l00302"></a>00302           <span class="keywordtype">double</span> vm = <a class="code" href="DoubleVect_8cpp.html#a55e600bcf8a03e258531f83869c4d060">mp_min_vect</a>(n_v.second), vM = <a class="code" href="DoubleVect_8cpp.html#adcc29a107bd1ad77828da317da293203">mp_max_vect</a>(n_v.second), x = <a class="code" href="Double_8h.html#aaecd4ca8a2fe69cc6568af2938b94d2e">dabs</a>(vM) &gt; <a class="code" href="Double_8h.html#aaecd4ca8a2fe69cc6568af2938b94d2e">dabs</a>(vm) ? vM : vm;
<a name="l00303"></a>00303           <span class="keywordflow">if</span> (!<a class="code" href="classProcess.html#ab55ba07167ec807ed3a145cac0f5dca4" title="renvoie mon rang dans le groupe de communication courant. Voir Comm_Group::rank() et PE_Groups::curre...">Process::me</a>()) fprintf(stderr, <span class="stringliteral">&quot; %11g&quot;</span>, x);
<a name="l00304"></a>00304         }
<a name="l00305"></a>00305       <span class="keywordflow">if</span> (!<a class="code" href="classProcess.html#ab55ba07167ec807ed3a145cac0f5dca4" title="renvoie mon rang dans le groupe de communication courant. Voir Comm_Group::rank() et PE_Groups::curre...">Process::me</a>()) fprintf(stderr, <span class="stringliteral">&quot;\n&quot;</span>);
<a name="l00306"></a>00306 
<a name="l00307"></a>00307       <span class="comment">/* mises a jour : inconnues -&gt; milieu -&gt; champs/conserves -&gt; sources */</span>
<a name="l00308"></a>00308       <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;&amp; n_i : inco) n_i.second-&gt;valeurs() += incr[n_i.first];
<a name="l00309"></a>00309       <span class="keywordflow">if</span> (p_degen) inco[<span class="stringliteral">&quot;pression&quot;</span>]-&gt;valeurs() -= <a class="code" href="DoubleVect_8cpp.html#a55e600bcf8a03e258531f83869c4d060">mp_min_vect</a>(inco[<span class="stringliteral">&quot;pression&quot;</span>]-&gt;valeurs()); <span class="comment">//!&lt; On prend la pression minimale comme pression de reference afin d&#39;avoir la meme pression de reference en sequentiel et parallele</span>
<a name="l00310"></a>00310 <span class="comment"></span>      <span class="keywordflow">if</span> (!(ok = <a class="code" href="classPb__Multiphase.html#adf2872b95eb3bdb1a22e6d3c55bda061">eq_qdm</a>.<a class="code" href="classNavier__Stokes__std.html#a442d8f1138c18da07aa895728b3e41f2" title="Renvoie le milieu physique de l&#39;equation (le Fluide_base upcaste en Milieu_base)">milieu</a>().<a class="code" href="classMilieu__base.html#aaa77cfc752de073808514e1b99770e9b">check_unknown_range</a>())) <span class="keywordflow">break</span>; <span class="comment">//si on a depasse les bornes du milieu sur (p, T), on doit sortir</span>
<a name="l00311"></a>00311       <a class="code" href="classPb__Multiphase.html#adf2872b95eb3bdb1a22e6d3c55bda061">eq_qdm</a>.<a class="code" href="classNavier__Stokes__std.html#a2233a18979d8e301c9d376d8639877ee">pression_pa</a>().<a class="code" href="classChamp__Inc.html#a28ef3d411d12cb5684ac5e799efb7d24" title="Appel a l&#39;objet sous-jacent Renvoie le tableau des valeurs au temps courant.">valeurs</a>() = inco[<span class="stringliteral">&quot;pression&quot;</span>]-&gt;valeurs(); <span class="comment">//en multiphase, la pression est deja en Pa</span>
<a name="l00312"></a>00312       pb.mettre_a_jour(t); <span class="comment">//inconnues -&gt; milieu -&gt; champs conserves</span>
<a name="l00313"></a>00313     }
<a name="l00314"></a>00314 
<a name="l00315"></a>00315 <span class="comment">// ha ha ha</span>
<a name="l00316"></a>00316   <span class="keywordflow">if</span> (ok &amp;&amp; cv)
<a name="l00317"></a>00317     {
<a name="l00318"></a>00318       pb.mettre_a_jour(t); <span class="comment">//inconnues -&gt; milieu -&gt; champs conserves</span>
<a name="l00319"></a>00319       <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;&amp; n_i : inco) n_i.second-&gt;futur() = n_i.second-&gt;valeurs();
<a name="l00320"></a>00320       <a class="code" href="classPb__Multiphase.html#adf2872b95eb3bdb1a22e6d3c55bda061">eq_qdm</a>.<a class="code" href="classNavier__Stokes__std.html#afbb8f39bdfd70328dfad21bf2b9dd45a" title="Renvoie le champ de pression.">pression</a>().<a class="code" href="classChamp__Inc.html#a518c3eb1e7a249ae0fc4d1a4e0d072d0" title="Appel a l&#39;objet sous-jacent Renvoie le tableau des valeurs au temps t+i.">futur</a>() = <a class="code" href="classPb__Multiphase.html#adf2872b95eb3bdb1a22e6d3c55bda061">eq_qdm</a>.<a class="code" href="classNavier__Stokes__std.html#afbb8f39bdfd70328dfad21bf2b9dd45a" title="Renvoie le champ de pression.">pression</a>().<a class="code" href="classChamp__Inc.html#a28ef3d411d12cb5684ac5e799efb7d24" title="Appel a l&#39;objet sous-jacent Renvoie le tableau des valeurs au temps courant.">valeurs</a>(), <a class="code" href="classPb__Multiphase.html#adf2872b95eb3bdb1a22e6d3c55bda061">eq_qdm</a>.<a class="code" href="classNavier__Stokes__std.html#a2233a18979d8e301c9d376d8639877ee">pression_pa</a>().<a class="code" href="classChamp__Inc.html#a518c3eb1e7a249ae0fc4d1a4e0d072d0" title="Appel a l&#39;objet sous-jacent Renvoie le tableau des valeurs au temps t+i.">futur</a>() = <a class="code" href="classPb__Multiphase.html#adf2872b95eb3bdb1a22e6d3c55bda061">eq_qdm</a>.<a class="code" href="classNavier__Stokes__std.html#a2233a18979d8e301c9d376d8639877ee">pression_pa</a>().<a class="code" href="classChamp__Inc.html#a28ef3d411d12cb5684ac5e799efb7d24" title="Appel a l&#39;objet sous-jacent Renvoie le tableau des valeurs au temps courant.">valeurs</a>();
<a name="l00321"></a>00321     }
<a name="l00322"></a>00322   <span class="keywordflow">else</span>
<a name="l00323"></a>00323     {
<a name="l00324"></a>00324       <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;&amp; n_i : inco)  n_i.second-&gt;futur() = n_i.second-&gt;valeurs() = n_i.second-&gt;passe();
<a name="l00325"></a>00325       <a class="code" href="classPb__Multiphase.html#adf2872b95eb3bdb1a22e6d3c55bda061">eq_qdm</a>.<a class="code" href="classNavier__Stokes__std.html#a2233a18979d8e301c9d376d8639877ee">pression_pa</a>().<a class="code" href="classChamp__Inc.html#a518c3eb1e7a249ae0fc4d1a4e0d072d0" title="Appel a l&#39;objet sous-jacent Renvoie le tableau des valeurs au temps t+i.">futur</a>() = <a class="code" href="classPb__Multiphase.html#adf2872b95eb3bdb1a22e6d3c55bda061">eq_qdm</a>.<a class="code" href="classNavier__Stokes__std.html#a2233a18979d8e301c9d376d8639877ee">pression_pa</a>().<a class="code" href="classChamp__Inc.html#a28ef3d411d12cb5684ac5e799efb7d24" title="Appel a l&#39;objet sous-jacent Renvoie le tableau des valeurs au temps courant.">valeurs</a>() = inco[<span class="stringliteral">&quot;pression&quot;</span>]-&gt;passe();
<a name="l00326"></a>00326       ok = 0;
<a name="l00327"></a>00327     }
<a name="l00328"></a>00328   <span class="keywordflow">return</span>;
<a name="l00329"></a>00329 }
<a name="l00330"></a>00330 
<a name="l00331"></a><a class="code" href="classSETS.html#aa487da54eb9fd9c46cad4c7960c32344">00331</a> <span class="keywordtype">void</span> <a class="code" href="classSETS.html#aa487da54eb9fd9c46cad4c7960c32344">SETS::eliminer</a>(<span class="keyword">const</span> std::vector&lt;std::set&lt;std::pair&lt;std::string, int&gt;&gt;&gt; ordre, <span class="keyword">const</span> std::string inco_p, <span class="keyword">const</span> std::map&lt;std::string, matrices_t&gt;&amp; mats,
<a name="l00332"></a>00332                     <span class="keyword">const</span> <a class="code" href="Interface__blocs_8h.html#a2d7480bf11fc9f791b1d2839fa30a5c3">tabs_t</a>&amp; sec, std::map&lt;std::string, Matrice_Morse&gt;&amp; A_p, <a class="code" href="Interface__blocs_8h.html#a2d7480bf11fc9f791b1d2839fa30a5c3">tabs_t</a>&amp; b_p)
<a name="l00333"></a>00333 {
<a name="l00334"></a>00334   <span class="keywordtype">int</span> i, j, jb, k, l, lb, m, oMl, oMg, M, n, oNl, oNg, N, prems = !A_p.size(), infoo = 0; <span class="comment">//si A_p est vide, premier passage -&gt; on doit dimensionner</span>
<a name="l00335"></a>00335   <span class="keyword">const</span> <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a> * A;
<a name="l00336"></a>00336   <span class="keywordtype">char</span> trans = <span class="charliteral">&#39;T&#39;</span>;
<a name="l00337"></a>00337 
<a name="l00338"></a>00338   <span class="comment">/* decoupage des inconnues de sec en parties par DoubleTab_parts */</span>
<a name="l00339"></a>00339   std::map&lt;std::pair&lt;std::string, int&gt;, <span class="keywordtype">int</span>&gt; offs; <span class="comment">//offs[{inco, bloc}] : offset du bloc k de l&#39;inconnue inco</span>
<a name="l00340"></a>00340   std::map&lt;std::pair&lt;std::string, int&gt;, std::array&lt;int, 2&gt;&gt; dims; <span class="comment">//dims[{inco, bloc}] : dimension 0/ line_size() du bloc k de inco</span>
<a name="l00341"></a>00341   <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;&amp;n_v : sec)
<a name="l00342"></a>00342     {
<a name="l00343"></a>00343       <a class="code" href="classConstDoubleTab__parts.html" title="This class allows to acces to individual sub-parts of const DoubleTab objects that have a MD_Vector_c...">ConstDoubleTab_parts</a> part(n_v.second);
<a name="l00344"></a>00344       <span class="keywordflow">for</span> (i = 0; i &lt; part.<a class="code" href="classConstDoubleTab__parts.html#a9c573a25a8c3cf148c914bd7a00b52c0">size</a>(); i++)
<a name="l00345"></a>00345         {
<a name="l00346"></a>00346           offs[ {n_v.first, i}] = offs.count({ n_v.first, i - 1 }) ? offs[ { n_v.first, i - 1 }] + dims[ { n_v.first, i - 1 }][0] * dims[ { n_v.first, i - 1 }][1] : 0;
<a name="l00347"></a>00347           dims[ {n_v.first, i}] = { part[i].dimension_tot(0), part[i].line_size() };
<a name="l00348"></a>00348         }
<a name="l00349"></a>00349     }
<a name="l00350"></a>00350 
<a name="l00351"></a>00351   <span class="comment">/* boucle sur les blocs */</span>
<a name="l00352"></a>00352   std::set&lt;std::pair&lt;std::string, int&gt;&gt; e_ib; <span class="comment">//liste des { variable, bloc } deja elimines</span>
<a name="l00353"></a>00353   std::set&lt;std::string&gt; e_i; <span class="comment">//liste des variables deja eliminees</span>
<a name="l00354"></a>00354   <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;&amp;bloc : ordre)
<a name="l00355"></a>00355     {
<a name="l00356"></a>00356       std::set&lt;std::string&gt; i_bloc, dep; <span class="comment">//variables du bloc, variables deja eliminees dont le bloc depend</span>
<a name="l00357"></a>00357       <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;&amp;i_b : bloc) i_bloc.insert(i_b.first);
<a name="l00358"></a>00358       <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;&amp;i_b : bloc) <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;&amp; v_m : mats.at(i_b.first)) <span class="keywordflow">if</span> (v_m.second-&gt;nb_colonnes() &amp;&amp; v_m.first != inco_p &amp;&amp; e_i.count(v_m.first) &amp;&amp; !i_bloc.count(v_m.first))
<a name="l00359"></a>00359             dep.insert(v_m.first);
<a name="l00360"></a>00360 
<a name="l00361"></a>00361       <span class="comment">/* lignes du bloc a traiter */</span>
<a name="l00362"></a>00362       std::pair&lt;std::string, int&gt; i_b0 = *bloc.begin();<span class="comment">//premiere inconnue du bloc</span>
<a name="l00363"></a>00363       <a class="code" href="classIntTrav.html" title="Tableau de travail a n entrees pour n&lt;= 4 C&#39;est un IntTab avec allocation dans un pool de memoire gere...">IntTrav</a> calc(dims[i_b0][0]); <span class="comment">//calc[i] = 1 si on doit traiter l&#39;item i</span>
<a name="l00364"></a>00364       <span class="keywordflow">for</span> (A = mats.at(i_b0.first).at(i_b0.first), oMg = offs[i_b0], M = dims[i_b0][1], i = 0; i &lt; calc.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>(); i++)
<a name="l00365"></a>00365         <span class="keywordflow">if</span> (A-&gt;<a class="code" href="classMatrice__Morse.html#a79b4e334152850bd36e53478debf3061">get_tab1</a>()(oMg + M * i + 1) &gt; A-&gt;<a class="code" href="classMatrice__Morse.html#a79b4e334152850bd36e53478debf3061">get_tab1</a>()(oMg + M * i)) calc(i) = 1; <span class="comment">//on traite toutes les lignes dont la matrice est remplie</span>
<a name="l00366"></a>00366 
<a name="l00367"></a>00367       <span class="keywordflow">if</span> (prems) <span class="comment">//premier passage -&gt; dimensionnement des A_p</span>
<a name="l00368"></a>00368         {
<a name="l00369"></a>00369           <span class="comment">/* verification de la compatibilite des inconnues du bloc -&gt; avec les MD_Vector renseignes dans sec */</span>
<a name="l00370"></a>00370           <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;&amp;i_b : bloc) <span class="keywordflow">if</span> (dims[i_b0][0] != dims[i_b][0])
<a name="l00371"></a>00371               <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;SETS::eliminer() : discretisation des inconnues&quot;</span> &lt;&lt; i_b0.first.c_str() &lt;&lt; <span class="stringliteral">&quot;/&quot;</span> &lt;&lt; i_b0.second &lt;&lt; <span class="stringliteral">&quot; et &quot;</span> &lt;&lt; i_b.first.c_str()
<a name="l00372"></a>00372                    &lt;&lt; <span class="stringliteral">&quot;/&quot;</span> &lt;&lt; i_b.second &lt;&lt; <span class="stringliteral">&quot; incompatibles!&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>, <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">Process::exit</a>();
<a name="l00373"></a>00373 
<a name="l00374"></a>00374           std::vector&lt;std::set&lt;int&gt;&gt; stencil(calc.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>()); <span class="comment">//stencil[i] -&gt; stencil de l&#39;item i (a demultiplier par le line_size() de chaque variable)</span>
<a name="l00375"></a>00375           <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;&amp;i_b : bloc) <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;&amp;v_m : mats.at(i_b.first)) <span class="keywordflow">if</span> (v_m.second-&gt;nb_colonnes())
<a name="l00376"></a>00376                 {
<a name="l00377"></a>00377                   oMg = offs[i_b], M = dims[i_b][1];
<a name="l00378"></a>00378                   <span class="keywordflow">if</span> (v_m.first == inco_p) <span class="comment">//dependance directe en inco_p</span>
<a name="l00379"></a>00379                     {
<a name="l00380"></a>00380                       <span class="keywordflow">for</span> (i = 0; i &lt; calc.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>(); i++) <span class="keywordflow">if</span> (calc[i])
<a name="l00381"></a>00381                           <span class="keywordflow">for</span> (j = v_m.second-&gt;get_tab1()(oMg + M * i) - 1; j &lt; v_m.second-&gt;get_tab1()(oMg + M * (i + 1)) - 1; j++) <span class="comment">//dependances de toutes les lignes</span>
<a name="l00382"></a>00382                             stencil[i].insert(v_m.second-&gt;get_tab2()(j) - 1);
<a name="l00383"></a>00383                     }
<a name="l00384"></a>00384                   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (e_i.count(v_m.first) || i_bloc.count(v_m.first)) <span class="comment">//dependance en une variable partiellement / totalement eliminee</span>
<a name="l00385"></a>00385                     {
<a name="l00386"></a>00386                       A = A_p.count(v_m.first) ? &amp;A_p.at(v_m.first) : NULL;
<a name="l00387"></a>00387                       <span class="keywordflow">for</span> (i = 0; i &lt; calc.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>(); i++) <span class="keywordflow">if</span> (calc[i])
<a name="l00388"></a>00388                           <span class="keywordflow">for</span> (j = v_m.second-&gt;get_tab1()(oMg + M * i) - 1; j &lt; v_m.second-&gt;get_tab1()(oMg + M * (i + 1)) - 1; j++)
<a name="l00389"></a>00389                             {
<a name="l00390"></a>00390                               <span class="keywordflow">for</span> (jb = v_m.second-&gt;get_tab2()(j) - 1, k = 0; offs.count({ v_m.first, k + 1}) &amp;&amp; jb &gt;= offs.at({ v_m.first, k + 1 }); ) k++; <span class="comment">//l : bloc de l&#39;inconnue dont on depend</span>
<a name="l00391"></a>00391                               oNg = offs[ { v_m.first, k }], N = dims[ { v_m.first, k }][1], n = jb - oNg - N * i;
<a name="l00392"></a>00392                               <span class="keywordflow">if</span> (bloc.count({ v_m.first, k }) &amp;&amp; n &gt;= 0 &amp;&amp; n &lt; N) <span class="keywordflow">continue</span>; <span class="comment">//(variable, bloc) en cours d&#39;elimination et coeff bloc-diagonal -&gt; ok</span>
<a name="l00393"></a>00393                               <span class="keywordflow">else</span> <span class="keywordflow">if</span> (e_ib.count({ v_m.first, k }))  <span class="comment">//(variable, bloc) elimine -&gt; dependance en inco_p dans A_p</span>
<a name="l00394"></a>00394                                 <span class="keywordflow">for</span> (l = A-&gt;<a class="code" href="classMatrice__Morse.html#a79b4e334152850bd36e53478debf3061">get_tab1</a>()(jb) - 1; l &lt; A-&gt;<a class="code" href="classMatrice__Morse.html#a79b4e334152850bd36e53478debf3061">get_tab1</a>()(jb + 1) - 1; l++)
<a name="l00395"></a>00395                                   stencil[i].insert(A-&gt;<a class="code" href="classMatrice__Morse.html#a787b5a63f27063f9c891243d8f188cda">get_tab2</a>()(l) - 1);
<a name="l00396"></a>00396                               <span class="keywordflow">else</span> <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;SETS::eliminer() : dependance ( &quot;</span> &lt;&lt; i_b.first.c_str() &lt;&lt; <span class="stringliteral">&quot;/&quot;</span> &lt;&lt; i_b.second &lt;&lt; <span class="stringliteral">&quot; , &quot;</span>
<a name="l00397"></a>00397                                           &lt;&lt; v_m.first.c_str() &lt;&lt; <span class="stringliteral">&quot;/&quot;</span> &lt;&lt; k &lt;&lt; <span class="stringliteral">&quot; ) interdite!&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>, <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">Process::exit</a>();
<a name="l00398"></a>00398                             }
<a name="l00399"></a>00399                     }
<a name="l00400"></a>00400                   <span class="keywordflow">else</span> <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;SETS::eliminer() : dependance ( &quot;</span> &lt;&lt; i_b.first.c_str() &lt;&lt; <span class="stringliteral">&quot;/&quot;</span> &lt;&lt; i_b.second &lt;&lt; <span class="stringliteral">&quot; , &quot;</span>
<a name="l00401"></a>00401                               &lt;&lt; v_m.first.c_str() &lt;&lt; <span class="stringliteral">&quot; ) interdite!&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>, <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">Process::exit</a>();
<a name="l00402"></a>00402                 }
<a name="l00403"></a>00403 
<a name="l00404"></a>00404           <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;&amp;i_bl : bloc) <span class="comment">//stencil par inconnue -&gt; en demultipliant</span>
<a name="l00405"></a>00405             {
<a name="l00406"></a>00406               <a class="code" href="classIntTrav.html" title="Tableau de travail a n entrees pour n&lt;= 4 C&#39;est un IntTab avec allocation dans un pool de memoire gere...">IntTrav</a> sten(0, 2);
<a name="l00407"></a>00407               sten.set_smart_resize(1);
<a name="l00408"></a>00408               <span class="keywordflow">for</span> (oMg = offs[i_bl], M = dims[i_bl][1], i = 0; i &lt; calc.size_array(); i++) <span class="keywordflow">if</span> (calc[i])
<a name="l00409"></a>00409                   <span class="keywordflow">for</span> (m = 0; m &lt; M; m++) <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;&amp;col : stencil[i]) sten.append_line(oMg + M * i + m, col);
<a name="l00410"></a>00410               <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a> mat2;
<a name="l00411"></a>00411               <a class="code" href="classMatrix__tools.html#a481961691c1dbee5372da25777e5c1e8">Matrix_tools::allocate_morse_matrix</a>(sec.at(i_bl.first).size_totale(), sec.at(inco_p).size_totale(), sten, mat2);
<a name="l00412"></a>00412               A_p[i_bl.first].nb_colonnes() ? A_p[i_bl.first] += mat2 : A_p[i_bl.first] = mat2; <span class="comment">//A_p peut deja etre partiellement creee</span>
<a name="l00413"></a>00413             }
<a name="l00414"></a>00414         }
<a name="l00415"></a>00415 
<a name="l00416"></a>00416       std::vector&lt;std::string&gt; vbloc(i_bloc.begin(), i_bloc.end()), vdep(dep.begin(), dep.end()); <span class="comment">//sous forme de liste</span>
<a name="l00417"></a>00417       <span class="keywordtype">int</span> nv = vbloc.size(), nd = vdep.size(), nb = 0; <span class="comment">//nombre de variables du bloc, de dependances, taille totale</span>
<a name="l00418"></a>00418       std::vector&lt;int&gt; size, off_l, off_g; <span class="comment">//par (variable, bloc) : taille dans le systeme local, offset dans le systeme local, offset dans les systemes globaux</span>
<a name="l00419"></a>00419       <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;&amp; i_b : bloc) off_l.push_back(nb), size.push_back(dims[i_b][1]), off_g.push_back(offs[i_b]), nb += size.back();
<a name="l00420"></a>00420 
<a name="l00421"></a>00421       std::vector&lt;const Matrice_Morse *&gt; pmat(nv), dAp(nd); <span class="comment">//par variable : dependance directe en inco_p, des variables du bloc / deja resolues</span>
<a name="l00422"></a>00422       std::vector&lt;std::vector&lt;const Matrice_Morse *&gt;&gt; mat(nv), dmat(nv); <span class="comment">//matrices des variables du bloc, des dependances</span>
<a name="l00423"></a>00423       std::vector&lt;const DoubleTab*&gt; vsec(nv), dbp(nd); <span class="comment">//seconds membres des variables, vecteurs b_p des variables / des dependances</span>
<a name="l00424"></a>00424 
<a name="l00425"></a>00425       std::vector&lt;Matrice_Morse *&gt; Ap(nv); <span class="comment">//resultats : d{inco} = A_p[inco].d{inco_p} + b_p[inco] pour les variables du bloc</span>
<a name="l00426"></a>00426       std::vector&lt;DoubleTab*&gt; bp(nv);
<a name="l00427"></a>00427 
<a name="l00428"></a>00428       <span class="keywordflow">for</span> (i = 0; i &lt; nv; i++)
<a name="l00429"></a>00429         {
<a name="l00430"></a>00430           Ap[i] = &amp;A_p[vbloc[i]], vsec[i] = &amp;sec.at(vbloc[i]);
<a name="l00431"></a>00431           <span class="keywordflow">if</span> (!b_p.count(vbloc[i])) b_p[vbloc[i]] = *vsec[i]; <span class="comment">//creation des b_p</span>
<a name="l00432"></a>00432           bp[i] = &amp;b_p[vbloc[i]];
<a name="l00433"></a>00433           <span class="keyword">const</span> <a class="code" href="Interface__blocs_8h.html#a68e4f5c4505f6b31305de844302660bb">matrices_t</a>&amp; line = mats.at(vbloc[i]);
<a name="l00434"></a>00434           pmat[i] = line.count(inco_p) &amp;&amp; line.at(inco_p)-&gt;nb_colonnes() ? line.at(inco_p) : NULL;
<a name="l00435"></a>00435           <span class="keywordflow">for</span> ( mat[i].resize(nv), j = 0; j &lt; nv; j++)  mat[i][j] = line.count(vbloc[j]) &amp;&amp; line.at(vbloc[j])-&gt;nb_colonnes() ? line.at(vbloc[j]) : NULL;
<a name="l00436"></a>00436           <span class="keywordflow">for</span> (dmat[i].resize(nd), j = 0; j &lt; nd; j++) dmat[i][j] = line.count(vdep[j]) &amp;&amp; line.at(vdep[j])-&gt;nb_colonnes() ? line.at(vdep[j]) : NULL;
<a name="l00437"></a>00437         }
<a name="l00438"></a>00438       <span class="keywordflow">for</span> (i = 0; i &lt; nd; i++) dbp[i] = &amp;b_p.at(vdep[i]), dAp[i] = &amp;A_p.at(vdep[i]); <span class="comment">//b_p / A_p des dependances</span>
<a name="l00439"></a>00439 
<a name="l00440"></a>00440       <a class="code" href="classDoubleTrav.html" title="Tableau de travail a n entrees pour n&lt;= 4 C&#39;est un DoubleTab avec allocation dans un pool de memoire g...">DoubleTrav</a> D(nb, nb), S; <span class="comment">//bloc diagonal, seconds membres</span>
<a name="l00441"></a>00441       S.<a class="code" href="classArrOfDouble.html#ab49f6cae96be9d3f597468d8a53b67b6" title="Change le mode l&#39;allocation memoire: reallocation d&#39;un tableau a chaque changement de taille (flag = ...">set_smart_resize</a>(1);
<a name="l00442"></a>00442       <a class="code" href="classIntTrav.html" title="Tableau de travail a n entrees pour n&lt;= 4 C&#39;est un IntTab avec allocation dans un pool de memoire gere...">IntTrav</a> piv(nb);
<a name="l00443"></a>00443       <span class="keywordflow">for</span> (i = 0; i &lt; calc.size_array(); i++) <span class="keywordflow">if</span> (calc[i])
<a name="l00444"></a>00444           {
<a name="l00445"></a>00445             <span class="keyword">const</span> <span class="keywordtype">int</span> *deb = Ap[0]-&gt;get_tab2().addr() + Ap[0]-&gt;get_tab1()(off_g[0] + size[0] * i) - 1,
<a name="l00446"></a>00446                        *fin = Ap[0]-&gt;get_tab2().addr() + Ap[0]-&gt;get_tab1()(off_g[0] + size[0] * i + 1) - 1,
<a name="l00447"></a>00447                         ic = fin - deb, nc = ic + 1;
<a name="l00448"></a>00448             S.<a class="code" href="classDoubleTab.html#ae83b4d31205c53d9c8d2b43da178ce75" title="Change la taille du vecteur (identique a resize_array() pour le traitement des anciennes valeurs et d...">resize</a>(nc, nb), S = 0; <span class="comment">//second membre : 5(i, .) -&gt; dependance en la i-eme colonne du stencil des Ap du bloc, S(ic, .) -&gt; partie constante</span>
<a name="l00449"></a>00449 <span class="comment">// partie &quot;second membre des equations&quot;</span>
<a name="l00450"></a>00450             <span class="keywordflow">for</span> (j = 0; j &lt; nv; j++) <span class="keywordflow">for</span> (M = size[j], oMg = off_g[j], oMl = off_l[j], m = 0; m &lt; M; m++) S(ic, oMl + m) = vsec[j]-&gt;<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>()[oMg + M * i + m];
<a name="l00451"></a>00451 
<a name="l00452"></a>00452             <span class="comment">/* remplissage par les matrices du bloc : diagonale, second membre (si partie d&#39;une variable deja eliminee) */</span>
<a name="l00453"></a>00453             <span class="keywordflow">for</span> (D = 0, j = 0; j &lt; nv; j++) <span class="keywordflow">for</span> (M = size[j], oMg = off_g[j], oMl = off_l[j], k = 0; k &lt; nv; k++) <span class="keywordflow">if</span> (mat[j][k])
<a name="l00454"></a>00454                   {
<a name="l00455"></a>00455                     <span class="keywordflow">for</span> (N = size[k], oNg = off_g[k], oNl = off_l[k], m = 0; m &lt; M; m++) <span class="keywordflow">for</span> (l = mat[j][k]-&gt;get_tab1()(oMg + M * i + m) - 1; l &lt; mat[j][k]-&gt;get_tab1()(oMg + M * i + m + 1) - 1; l++)
<a name="l00456"></a>00456                         <span class="keywordflow">if</span> ((n = (jb = mat[j][k]-&gt;get_tab2()(l) - 1) - oNg - N * i) &gt;= 0 &amp;&amp; n &lt; N) <span class="comment">//on est dans le bloc diagonal</span>
<a name="l00457"></a>00457                           D(oMl + m, oNl + n) = mat[j][k]-&gt;get_coeff()(l);
<a name="l00458"></a>00458                         <span class="keywordflow">else</span> <span class="comment">//dependance en un bloc deja elimine</span>
<a name="l00459"></a>00459                           {
<a name="l00460"></a>00460                             <span class="keywordtype">double</span> <a class="code" href="Champ__P1iP1B__implementation_8cpp.html#aa8c8f49390c3cf7c702d71a71bc977e3">coeff</a> = mat[j][k]-&gt;get_coeff()(l);
<a name="l00461"></a>00461                             S(ic, oMl + m) -= coeff * bp[k]-&gt;<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>()[jb];
<a name="l00462"></a>00462                             <span class="keywordflow">for</span> (lb = Ap[k]-&gt;get_tab1()(jb) - 1; lb &lt; Ap[k]-&gt;get_tab1()(jb + 1) - 1; lb++)
<a name="l00463"></a>00463                               S(std::lower_bound(deb, fin, Ap[k]-&gt;get_tab2()(lb)) - deb, oMl + m) -= coeff * Ap[k]-&gt;get_coeff()(lb);
<a name="l00464"></a>00464                           }
<a name="l00465"></a>00465                   }
<a name="l00466"></a>00466 
<a name="l00467"></a>00467 <span class="comment">// partie &quot;dependance directe en inco_p&quot; -&gt; dans S([0, ic[, .)</span>
<a name="l00468"></a>00468             <span class="keywordflow">for</span> (j = 0; j &lt; nv; j++) <span class="keywordflow">if</span> (pmat[j]) <span class="keywordflow">for</span> (M = size[j], oMg = off_g[j], oMl = off_l[j], m = 0; m &lt; M; m++)
<a name="l00469"></a>00469                   <span class="keywordflow">for</span> (k = pmat[j]-&gt;get_tab1()(oMg + M * i + m) - 1; k &lt; pmat[j]-&gt;get_tab1()(oMg + M * i + m + 1) - 1; k++)
<a name="l00470"></a>00470                     S(std::lower_bound(deb, fin, pmat[j]-&gt;get_tab2()(k)) - deb, oMl + m) -= pmat[j]-&gt;get_coeff()(k);
<a name="l00471"></a>00471 <span class="comment">// partie &quot;dependance en une variable hors bloc eliminee&quot; -&gt; b_p contribue a S(0, .), A_p contribue a S(1..nc, .)</span>
<a name="l00472"></a>00472             <span class="keywordflow">for</span> (j = 0; j &lt; nv; j++) <span class="keywordflow">for</span> (k = 0; k &lt; nd; k++) <span class="keywordflow">if</span> (dmat[j][k]) <span class="keywordflow">for</span> (M = size[j], oMg = off_g[j], oMl = off_l[j], m = 0; m &lt; M; m++)
<a name="l00473"></a>00473                     <span class="keywordflow">for</span> (l = dmat[j][k]-&gt;get_tab1()(oMg + M * i + m) - 1; l &lt; dmat[j][k]-&gt;get_tab1()(oMg + M * i + m + 1) - 1; l++)
<a name="l00474"></a>00474                       {
<a name="l00475"></a>00475                         <span class="keywordtype">double</span> coeff = dmat[j][k]-&gt;get_coeff()(l);
<a name="l00476"></a>00476                         jb = dmat[j][k]-&gt;get_tab2()(l) - 1, S(ic, oMl + m) -= coeff * dbp[k]-&gt;<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>()[jb]; <span class="comment">//partie &quot;constante&quot;</span>
<a name="l00477"></a>00477                         <span class="keywordflow">for</span> (lb = dAp[k]-&gt;get_tab1()(jb) - 1; lb &lt; dAp[k]-&gt;get_tab1()(jb + 1) - 1; lb++) <span class="comment">//partie &quot;dependance en inco_p&quot;</span>
<a name="l00478"></a>00478                           S(std::lower_bound(deb, fin, dAp[k]-&gt;get_tab2()(lb)) - deb, oMl + m) -= coeff * dAp[k]-&gt;get_coeff()(lb);
<a name="l00479"></a>00479                       }
<a name="l00480"></a>00480 
<a name="l00481"></a>00481             <span class="comment">/* factorisation et resolution */</span>
<a name="l00482"></a>00482             <a class="code" href="classDoubleTrav.html" title="Tableau de travail a n entrees pour n&lt;= 4 C&#39;est un DoubleTab avec allocation dans un pool de memoire g...">DoubleTrav</a> D_back = D;
<a name="l00483"></a>00483             <a class="code" href="arch_8h.html#a9b91c72ded7de2f0b393ea75de53929b">F77NAME</a>(dgetrf)(&amp;nb, &amp;nb, &amp;D(0, 0), &amp;nb, &amp;piv(0), &amp;infoo);
<a name="l00484"></a>00484             <a class="code" href="arch_8h.html#a9b91c72ded7de2f0b393ea75de53929b">F77NAME</a>(dgetrs)(&amp;trans, &amp;nb, &amp;nc, &amp;D(0, 0), &amp;nb, &amp;piv(0), &amp;S(0, 0), &amp;nb, &amp;infoo);
<a name="l00485"></a>00485 
<a name="l00486"></a>00486             <span class="comment">/* stockage : S(0, .) dans b_p, S(1..nc, .) dans A_p */</span>
<a name="l00487"></a>00487             <span class="keywordflow">for</span> (j = 0; j &lt; nv; j++) <span class="keywordflow">for</span> (M = size[j], oMg = off_g[j], oMl = off_l[j], m = 0; m &lt; M; m++)
<a name="l00488"></a>00488                 <span class="keywordflow">for</span> (bp[j]-&gt;addr()[oMg + M * i + m] = S(ic, oMl + m), k = 0, l = Ap[j]-&gt;get_tab1()(oMg + M * i + m) - 1; k &lt; ic; k++, l++)
<a name="l00489"></a>00489                   Ap[j]-&gt;get_set_coeff()(l) = S(k, oMl + m);
<a name="l00490"></a>00490           }
<a name="l00491"></a>00491 
<a name="l00492"></a>00492       <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;&amp;i_b : bloc) e_ib.insert(i_b), e_i.insert(i_b.first);
<a name="l00493"></a>00493     }
<a name="l00494"></a>00494 }
<a name="l00495"></a>00495 
<a name="l00496"></a><a class="code" href="classSETS.html#a6c7635065c4d8501c1048a2af972ae59">00496</a> <span class="keywordtype">void</span> <a class="code" href="classSETS.html#a6c7635065c4d8501c1048a2af972ae59">SETS::assembler</a>(<span class="keyword">const</span> std::string inco_p, <span class="keyword">const</span> std::vector&lt;std::string&gt; extra_eq, <span class="keyword">const</span> std::map&lt;std::string, Matrice_Morse&gt;&amp; A_p, <span class="keyword">const</span> <a class="code" href="Interface__blocs_8h.html#a2d7480bf11fc9f791b1d2839fa30a5c3">tabs_t</a>&amp; b_p,
<a name="l00497"></a>00497                      <span class="keyword">const</span> std::map&lt;std::string, matrices_t&gt;&amp; mats, <span class="keyword">const</span> <a class="code" href="Interface__blocs_8h.html#a2d7480bf11fc9f791b1d2839fa30a5c3">tabs_t</a>&amp; sec, <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; inco_a, <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; P, <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; secmem, <span class="keywordtype">int</span> p_degen)
<a name="l00498"></a>00498 {
<a name="l00499"></a>00499   <span class="keywordtype">int</span> i, ib, j, na = inco_a.<a class="code" href="classDoubleTab.html#a3eadd63f3ba20c1b454d760b430acbf7" title="Returns the total dimensions of the multi-dimensionnal array, including virtual items (used in parall...">dimension_tot</a>(0), m, M = inco_a.<a class="code" href="classDoubleVect.html#ab02d01cd1bdab66fbd66f9a47cc29e10">line_size</a>();
<a name="l00500"></a>00500   <span class="keyword">const</span> <span class="keywordtype">int</span> *deb, *fin; <span class="comment">//bornes pour chercher des indices avec lower_bound()</span>
<a name="l00501"></a>00501   <span class="keywordflow">if</span> (extra_eq.size()) <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;SETS::assembler() : extra_eq pas encore code!&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>, <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">Process::exit</a>();
<a name="l00502"></a>00502   <span class="keyword">const</span> <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; A = A_p.at(<span class="stringliteral">&quot;alpha&quot;</span>);
<a name="l00503"></a>00503 
<a name="l00504"></a>00504   <span class="comment">/* calc(i) = 1 si on doit remplir les lignes [N * i, (N + 1) * i[ de la matrice */</span>
<a name="l00505"></a>00505   <a class="code" href="classArrOfBit.html">ArrOfBit</a> calc(na);
<a name="l00506"></a>00506   <span class="keywordflow">if</span> (inco_a.<a class="code" href="classDoubleVect.html#a0d16d30580c90526e4895388fb44be5d">get_md_vector</a>().<a class="code" href="classMD__Vector.html#a4165c00904b7096274e38fdc7ca340f4">non_nul</a>()) <a class="code" href="classMD__Vector__tools.html#ad099d2407b0016920bd8c667a56fddd8">MD_Vector_tools::get_sequential_items_flags</a>(inco_a.<a class="code" href="classDoubleVect.html#a0d16d30580c90526e4895388fb44be5d">get_md_vector</a>(), calc);
<a name="l00507"></a>00507   <span class="keywordflow">else</span> calc = 1;
<a name="l00508"></a>00508 
<a name="l00509"></a>00509   <span class="keywordflow">if</span> (!P.<a class="code" href="classMatrice__Morse.html#a94caf9937bc5a110a7179cb3e9eaa9d9">nb_colonnes</a>()) <span class="comment">//dimensionnement au premier passage</span>
<a name="l00510"></a>00510     {
<a name="l00511"></a>00511       <a class="code" href="classIntTrav.html" title="Tableau de travail a n entrees pour n&lt;= 4 C&#39;est un IntTab avec allocation dans un pool de memoire gere...">IntTrav</a> stencil(0, 2);
<a name="l00512"></a>00512       stencil.<a class="code" href="classArrOfInt.html#a22d744bcd452d039580d1d9186f02b4e" title="Change le mode l&#39;allocation memoire: reallocation d&#39;un tableau a chaque changement de taille (flag = ...">set_smart_resize</a>(1);
<a name="l00513"></a>00513       std::set&lt;int&gt; idx;
<a name="l00514"></a>00514       <span class="keywordflow">for</span> (i = 0; i &lt; na; i++) <span class="keywordflow">if</span> (calc[i]) <span class="comment">//chaque</span>
<a name="l00515"></a>00515           {
<a name="l00516"></a>00516             <span class="keywordflow">if</span> (p_degen &amp;&amp; !<a class="code" href="classProcess.html#ab55ba07167ec807ed3a145cac0f5dca4" title="renvoie mon rang dans le groupe de communication courant. Voir Comm_Group::rank() et PE_Groups::curre...">Process::me</a>() &amp;&amp; i == 0) <span class="keywordflow">for</span> (j = 0; j &lt; sec.at(inco_p).size_totale(); j++) idx.insert(j);
<a name="l00517"></a>00517             <span class="keywordflow">else</span> <span class="keywordflow">for</span> (idx.clear(), m = 0, ib = M * i; m &lt; M; m++, ib++) <span class="keywordflow">for</span> (j = A.<a class="code" href="classMatrice__Morse.html#a79b4e334152850bd36e53478debf3061">get_tab1</a>()(ib) - 1; j &lt; A.<a class="code" href="classMatrice__Morse.html#a79b4e334152850bd36e53478debf3061">get_tab1</a>()(ib + 1) - 1; j++)
<a name="l00518"></a>00518                   idx.insert(A.<a class="code" href="classMatrice__Morse.html#a787b5a63f27063f9c891243d8f188cda">get_tab2</a>()(j) - 1);
<a name="l00519"></a>00519             <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;&amp; col : idx) stencil.<a class="code" href="classIntTab.html#ac0af4eac42ca46facc05f985c3ef05c6" title="Adds 1 to dimension_tot(0) and puts a in the added line.">append_line</a>(i, col);
<a name="l00520"></a>00520           }
<a name="l00521"></a>00521       <a class="code" href="classMatrix__tools.html#a481961691c1dbee5372da25777e5c1e8">Matrix_tools::allocate_morse_matrix</a>(na, sec.at(inco_p).size_totale(), stencil, P);
<a name="l00522"></a>00522     }
<a name="l00523"></a>00523 
<a name="l00524"></a>00524   <span class="comment">/* matrice */</span>
<a name="l00525"></a>00525   <span class="keywordflow">for</span> (P.<a class="code" href="classMatrice__Morse.html#acd067e8514e5741f52b18a1d99746d11">get_set_coeff</a>() = 0, i = 0; i &lt; na; i++) <span class="keywordflow">if</span> (calc[i])
<a name="l00526"></a>00526       <span class="keywordflow">for</span> (m = 0, ib = M * i, deb = P.<a class="code" href="classMatrice__Morse.html#a787b5a63f27063f9c891243d8f188cda">get_tab2</a>().<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() + P.<a class="code" href="classMatrice__Morse.html#a79b4e334152850bd36e53478debf3061">get_tab1</a>()(i) - 1, fin = P.<a class="code" href="classMatrice__Morse.html#a787b5a63f27063f9c891243d8f188cda">get_tab2</a>().<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() + P.<a class="code" href="classMatrice__Morse.html#a79b4e334152850bd36e53478debf3061">get_tab1</a>()(i + 1) - 1; m &lt; M; m++, ib++)
<a name="l00527"></a>00527         <span class="keywordflow">for</span> (j = A.<a class="code" href="classMatrice__Morse.html#a79b4e334152850bd36e53478debf3061">get_tab1</a>()(ib) - 1; j &lt; A.<a class="code" href="classMatrice__Morse.html#a79b4e334152850bd36e53478debf3061">get_tab1</a>()(ib + 1) - 1; j++)
<a name="l00528"></a>00528           P.<a class="code" href="classMatrice__Morse.html#acd067e8514e5741f52b18a1d99746d11">get_set_coeff</a>()(std::lower_bound(deb, fin, A.<a class="code" href="classMatrice__Morse.html#a787b5a63f27063f9c891243d8f188cda">get_tab2</a>()(j)) - &amp;P.<a class="code" href="classMatrice__Morse.html#a787b5a63f27063f9c891243d8f188cda">get_tab2</a>()(0)) += A.<a class="code" href="classMatrice__Morse.html#aacb80dd518dcc0812e3b34edac6ab67e">get_coeff</a>()(j);
<a name="l00529"></a>00529   <span class="keywordtype">double</span> diag = P.<a class="code" href="classMatrice__Morse.html#aacb80dd518dcc0812e3b34edac6ab67e">get_coeff</a>()(0);
<a name="l00530"></a>00530   <span class="keywordflow">if</span> (p_degen &amp;&amp; !<a class="code" href="classProcess.html#ab55ba07167ec807ed3a145cac0f5dca4" title="renvoie mon rang dans le groupe de communication courant. Voir Comm_Group::rank() et PE_Groups::curre...">Process::me</a>()) <span class="keywordflow">for</span> (i = 0; i &lt; P.<a class="code" href="classMatrice__Morse.html#a79b4e334152850bd36e53478debf3061">get_tab1</a>()(1) - 1; i++) P.<a class="code" href="classMatrice__Morse.html#acd067e8514e5741f52b18a1d99746d11">get_set_coeff</a>()(i) += diag; <span class="comment">//de-degeneration de la matrice</span>
<a name="l00531"></a>00531 
<a name="l00532"></a>00532   <span class="comment">/* second membre : meme structure que inco_a, mais une seule composante */</span>
<a name="l00533"></a>00533   <span class="keywordflow">if</span> (inco_a.<a class="code" href="classDoubleVect.html#a0d16d30580c90526e4895388fb44be5d">get_md_vector</a>().<a class="code" href="classMD__Vector.html#a4165c00904b7096274e38fdc7ca340f4">non_nul</a>()) <a class="code" href="classMD__Vector__tools.html#aeac48ec589f525bafdfc83244a5d4dea" title="transforme v en un tableau parallele ayant la structure md. md doit est non nul ! Les dimension(i&gt;=1) ...">MD_Vector_tools::creer_tableau_distribue</a>(inco_a.<a class="code" href="classDoubleVect.html#a0d16d30580c90526e4895388fb44be5d">get_md_vector</a>(), secmem, <a class="code" href="classArray__base.html#abee342aa9ac59623c4c782dc9d7877ffaf6ae9ba7eb51c5f298ce693345b3ec68">Array_base::NOCOPY_NOINIT</a>);
<a name="l00534"></a>00534   <span class="keywordflow">else</span> secmem.<a class="code" href="classDoubleTab.html#ae83b4d31205c53d9c8d2b43da178ce75" title="Change la taille du vecteur (identique a resize_array() pour le traitement des anciennes valeurs et d...">resize</a>(inco_a.<a class="code" href="classDoubleTab.html#a3eadd63f3ba20c1b454d760b430acbf7" title="Returns the total dimensions of the multi-dimensionnal array, including virtual items (used in parall...">dimension_tot</a>(0));
<a name="l00535"></a>00535 
<a name="l00536"></a>00536   <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; b = b_p.at(<span class="stringliteral">&quot;alpha&quot;</span>);
<a name="l00537"></a>00537   <span class="keywordflow">for</span> (i = 0; i &lt; na; i++) <span class="keywordflow">if</span> (calc[i]) <span class="keywordflow">for</span> (secmem(i) = 1, m = 0; m &lt; M; m++)
<a name="l00538"></a>00538         secmem(i) -= b(i, m) + inco_a(i, m);
<a name="l00539"></a>00539 }
<a name="l00540"></a>00540 
</pre></div></div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Tue Dec 14 2021 19:35:36 for TRUST by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
