<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>TRUST: src/Kernel/Math/SolvSys/Solv_AMGX.cpp Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">TRUST&#160;<span id="projectnumber">1.8.4</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
<div class="header">
  <div class="headertitle">
<div class="title">src/Kernel/Math/SolvSys/Solv_AMGX.cpp</div>  </div>
</div>
<div class="contents">
<a href="Solv__AMGX_8cpp.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/****************************************************************************</span>
<a name="l00002"></a>00002 <span class="comment">* Copyright (c) 2021, CEA</span>
<a name="l00003"></a>00003 <span class="comment">* All rights reserved.</span>
<a name="l00004"></a>00004 <span class="comment">*</span>
<a name="l00005"></a>00005 <span class="comment">* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</span>
<a name="l00006"></a>00006 <span class="comment">* 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.</span>
<a name="l00007"></a>00007 <span class="comment">* 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.</span>
<a name="l00008"></a>00008 <span class="comment">* 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.</span>
<a name="l00009"></a>00009 <span class="comment">*</span>
<a name="l00010"></a>00010 <span class="comment">* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.</span>
<a name="l00011"></a>00011 <span class="comment">* IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;</span>
<a name="l00012"></a>00012 <span class="comment">* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>
<a name="l00013"></a>00013 <span class="comment">*</span>
<a name="l00014"></a>00014 <span class="comment">*****************************************************************************/</span>
<a name="l00015"></a>00015 <span class="comment">//</span>
<a name="l00016"></a>00016 <span class="comment">// </span>
<a name="l00017"></a>00017 <span class="comment">// File:        Solv_AMGX.cpp</span>
<a name="l00018"></a>00018 <span class="comment">// Directory:   $TRUST_ROOT/src/Kernel/Math/SolvSys</span>
<a name="l00019"></a>00019 <span class="comment">// Version:     /main/95</span>
<a name="l00020"></a>00020 <span class="comment">// </span>
<a name="l00021"></a>00021 <span class="comment">//</span>
<a name="l00022"></a>00022 
<a name="l00023"></a>00023 <span class="preprocessor">#include &lt;<a class="code" href="Solv__AMGX_8h.html">Solv_AMGX.h</a>&gt;</span>
<a name="l00024"></a>00024 <span class="preprocessor">#include &lt;<a class="code" href="Matrice__Morse_8h.html">Matrice_Morse.h</a>&gt;</span>
<a name="l00025"></a>00025 <span class="preprocessor">#include &lt;ctime&gt;</span>
<a name="l00026"></a>00026 <span class="preprocessor">#include &lt;<a class="code" href="communications_8h.html">communications.h</a>&gt;</span>
<a name="l00027"></a>00027 
<a name="l00028"></a><a class="code" href="Solv__AMGX_8cpp.html#a51aca53f9f3b657ceca48ddc3bc52ea0">00028</a> <a class="code" href="Declare__Inst_8h.html#afcab3f7633508e92f2077d767e19bc60">Implemente_instanciable_sans_constructeur</a>(<a class="code" href="classSolv__AMGX.html">Solv_AMGX</a>,<span class="stringliteral">&quot;Solv_AMGX&quot;</span>,<a class="code" href="classSolv__Petsc.html">Solv_Petsc</a>);
<a name="l00029"></a>00029 <span class="comment">// printOn</span>
<a name="l00030"></a><a class="code" href="classSolv__AMGX.html#a4819ec8e97d758e6e1ead157bf208161">00030</a> <a class="code" href="classSortie.html" title="Classe de base des flux de sortie. Elle sait ecrire des types simples&lt;br&gt;(entiers, flottants) et des Ob...">Sortie</a>&amp; <a class="code" href="classSolv__AMGX.html#a4819ec8e97d758e6e1ead157bf208161" title="Ecriture de l&#39;objet sur un flot de sortie Methode a surcharger.">Solv_AMGX::printOn</a>(<a class="code" href="classSortie.html" title="Classe de base des flux de sortie. Elle sait ecrire des types simples&lt;br&gt;(entiers, flottants) et des Ob...">Sortie</a>&amp; s )<span class="keyword"> const</span>
<a name="l00031"></a>00031 <span class="keyword"></span>{
<a name="l00032"></a>00032   s &lt;&lt; <a class="code" href="classSolv__Petsc.html#a7a8cc27d5092ae780209ddb0059a2e29" title="Chaine des mots cles lus.">chaine_lue_</a>;
<a name="l00033"></a>00033   <span class="keywordflow">return</span> s;
<a name="l00034"></a>00034 }
<a name="l00035"></a>00035 <span class="comment">// readOn</span>
<a name="l00036"></a><a class="code" href="classSolv__AMGX.html#a1bc14743947df209e3eb50f53d612c96">00036</a> <a class="code" href="classEntree.html" title="Classe de definition des operateurs et methodes pour toute lecture dans un flot d&#39;entree (fichier...">Entree</a>&amp; <a class="code" href="classSolv__AMGX.html#a1bc14743947df209e3eb50f53d612c96" title="Lecture d&#39;un Objet_U sur un flot d&#39;entree Methode a surcharger.">Solv_AMGX::readOn</a>(<a class="code" href="classEntree.html" title="Classe de definition des operateurs et methodes pour toute lecture dans un flot d&#39;entree (fichier...">Entree</a>&amp; is)
<a name="l00037"></a>00037 {
<a name="l00038"></a>00038   <a class="code" href="classSolv__Petsc.html#a35a8ad922fb450f5b693f9ce1e31875c">create_solver</a>(is);
<a name="l00039"></a>00039   <span class="keywordflow">return</span> is;
<a name="l00040"></a>00040 }
<a name="l00041"></a>00041 
<a name="l00042"></a>00042 <span class="preprocessor">#ifdef PETSCKSP_H</span>
<a name="l00043"></a>00043 <span class="preprocessor"></span><span class="preprocessor">#ifdef PETSC_HAVE_CUDA</span>
<a name="l00044"></a>00044 <span class="preprocessor"></span><span class="keywordtype">void</span> Solv_AMGX::initialize()
<a name="l00045"></a>00045 {
<a name="l00046"></a>00046   <span class="keywordflow">if</span> (amgx_initialized()) <span class="keywordflow">return</span>;
<a name="l00047"></a>00047   <span class="comment">/* Possible de jouer avec simple precision peut etre:</span>
<a name="l00048"></a>00048 <span class="comment">  1. (lowercase) letter: whether the code will run on the host (h) or device (d).</span>
<a name="l00049"></a>00049 <span class="comment">  2. (uppercase) letter: whether the matrix precision is float (F) or double (D).</span>
<a name="l00050"></a>00050 <span class="comment">  3. (uppercase) letter: whether the vector precision is float (F) or double (D).</span>
<a name="l00051"></a>00051 <span class="comment">  4. (uppercase) letter: whether the index type is 32-bit int (I) or else (not currently supported).</span>
<a name="l00052"></a>00052 <span class="comment">  Nom AmgXmode = &quot;dDDI&quot;; //!&lt; dDDI:GPU hDDI:CPU (not supported yet by AmgXWrapper)</span>
<a name="l00053"></a>00053 <span class="comment">  typedef enum { AMGX_mode_hDDI, AMGX_mode_hDFI, AMGX_mode_hFFI, AMGX_mode_dDDI, AMGX_mode_dDFI, AMGX_mode_dFFI } AMGX_Mode; */</span>
<a name="l00054"></a>00054   <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Initializing Amgx and reading the &quot;</span> &lt;&lt; <a class="code" href="classSolv__Petsc.html#af626ce7ac5babfaf8333057766ac15cf" title="Nom du fichier de config eventuel.">config</a>() &lt;&lt; <span class="stringliteral">&quot; file.&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
<a name="l00055"></a>00055   std::clock_t start = std::clock();
<a name="l00056"></a>00056   SolveurAmgX_.initialize(PETSC_COMM_WORLD, AmgXmode.getString(), <a class="code" href="classSolv__Petsc.html#af626ce7ac5babfaf8333057766ac15cf" title="Nom du fichier de config eventuel.">config</a>().<a class="code" href="classNom.html#a855d8cd96b5c73c2aa55cb7c0a870640">getString</a>());
<a name="l00057"></a>00057   <a class="code" href="EntreeSortie_8h.html#a1007c2f57f1c8fc7334a3f62aab08414">Cout</a> &lt;&lt; <span class="stringliteral">&quot;[AmgX] Time to initialize: &quot;</span> &lt;&lt; ( std::clock() - start ) / (<span class="keywordtype">double</span>) CLOCKS_PER_SEC &lt;&lt; finl;
<a name="l00058"></a>00058   <a class="code" href="classSolv__Petsc.html#a7244784294055ac6cd06c16d5d7264e7" title="Amgx initialise Options dev:">amgx_initialized_</a> = true;
<a name="l00059"></a>00059 <span class="comment">// MPI_Barrier(PETSC_COMM_WORLD); Voir dans https://github.com/barbagroup/AmgXWrapper/pull/30/commits/1554808a3689f51fa43ab81a35c47a9a1525939a</span>
<a name="l00060"></a>00060 }
<a name="l00061"></a>00061 
<a name="l00062"></a>00062 <span class="comment">// Creation des objets</span>
<a name="l00063"></a>00063 <span class="keywordtype">void</span> <a class="code" href="classSolv__AMGX.html">Solv_AMGX</a>::Create_objects(const <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; mat_morse)
<a name="l00064"></a>00064 {
<a name="l00065"></a>00065   initialize();
<a name="l00066"></a>00066   <span class="keywordflow">if</span> (<a class="code" href="classSolv__Petsc.html#a9c92c7b3025ccb3f301489141a442211" title="Read constant matrix in a file.">read_matrix_</a>)
<a name="l00067"></a>00067     {
<a name="l00068"></a>00068       <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Read_matrix not supported on GPU yet.&quot;</span> &lt;&lt; finl;
<a name="l00069"></a>00069       <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">Process::exit</a>();
<a name="l00070"></a>00070     }
<a name="l00071"></a>00071 <span class="comment">// Creation de la matrice Petsc (CSR pointeurs dessus)</span>
<a name="l00072"></a>00072   <span class="keywordflow">if</span> (MatricePetsc_ != NULL) MatDestroy(&amp;MatricePetsc_);
<a name="l00073"></a>00073 
<a name="l00074"></a>00074   Create_MatricePetsc(MatricePetsc_, mataij_, mat_morse);
<a name="l00075"></a>00075   std::clock_t start = std::clock();
<a name="l00076"></a>00076   petscToCSR(MatricePetsc_, SolutionPetsc_, SecondMembrePetsc_);
<a name="l00077"></a>00077   <a class="code" href="EntreeSortie_8h.html#a1007c2f57f1c8fc7334a3f62aab08414">Cout</a> &lt;&lt; <span class="stringliteral">&quot;[AmgX] Time to create CSR pointers: &quot;</span> &lt;&lt; (std::clock() - start) / (<span class="keywordtype">double</span>) CLOCKS_PER_SEC &lt;&lt; finl;
<a name="l00078"></a>00078   start = std::clock();
<a name="l00079"></a>00079   SolveurAmgX_.setA(nRowsGlobal, nRowsLocal, nNz, rowOffsets, colIndices, values, nullptr);
<a name="l00080"></a>00080   <a class="code" href="EntreeSortie_8h.html#a1007c2f57f1c8fc7334a3f62aab08414">Cout</a> &lt;&lt; &quot;[AmgX] <a class="code" href="classTime.html">Time</a> to set matrix (copy+setup) on GPU: &quot; &lt;&lt; (std::clock() - start) / (<span class="keywordtype">double</span>) CLOCKS_PER_SEC &lt;&lt; finl; <span class="comment">//!&lt; Attention balise lue par fiche de validation</span>
<a name="l00081"></a>00081 <span class="comment"></span>}
<a name="l00082"></a>00082 
<a name="l00083"></a>00083 <span class="comment">// Fonction de conversion Petsc -&gt;CSR</span>
<a name="l00084"></a>00084 PetscErrorCode <a class="code" href="classSolv__AMGX.html">Solv_AMGX</a>::petscToCSR(Mat&amp; A, Vec&amp; lhs_petsc, Vec&amp; rhs_petsc)
<a name="l00085"></a>00085 {
<a name="l00086"></a>00086   PetscFunctionBeginUser;
<a name="l00087"></a>00087   PetscBool done;
<a name="l00088"></a>00088   MatType type;
<a name="l00089"></a>00089 
<a name="l00090"></a>00090 <span class="comment">// Get the Mat type</span>
<a name="l00091"></a>00091   PetscErrorCode ierr = MatGetType(A, &amp;type);
<a name="l00092"></a>00092   CHKERRQ(ierr);
<a name="l00093"></a>00093 
<a name="l00094"></a>00094 <span class="comment">// Check whether the Mat type is supported</span>
<a name="l00095"></a>00095   <span class="keywordflow">if</span> (std::strcmp(type, MATSEQAIJ) == 0) <span class="comment">//!&lt; sequential AIJ</span>
<a name="l00096"></a>00096 <span class="comment"></span>    {
<a name="l00097"></a>00097 <span class="comment">// Make localA point to the same memory space as A does</span>
<a name="l00098"></a>00098       localA = A;
<a name="l00099"></a>00099     }
<a name="l00100"></a>00100   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (std::strcmp(type, MATMPIAIJ) == 0)
<a name="l00101"></a>00101     {
<a name="l00102"></a>00102 <span class="comment">// Get local matrix from redistributed matrix</span>
<a name="l00103"></a>00103       <span class="keywordflow">if</span> (localA!=NULL) MatDestroy(&amp;localA); <span class="comment">//!&lt; Suite accroissement memoire !</span>
<a name="l00104"></a>00104 <span class="comment"></span>      ierr = MatMPIAIJGetLocalMat(A, MAT_INITIAL_MATRIX, &amp;localA);
<a name="l00105"></a>00105       CHKERRQ(ierr);
<a name="l00106"></a>00106     }
<a name="l00107"></a>00107   <span class="keywordflow">else</span>
<a name="l00108"></a>00108     {
<a name="l00109"></a>00109       SETERRQ1(PETSC_COMM_WORLD, PETSC_ERR_ARG_WRONG,<span class="stringliteral">&quot;Mat type %s is not supported!\n&quot;</span>, type);
<a name="l00110"></a>00110     }
<a name="l00111"></a>00111 
<a name="l00112"></a>00112 <span class="comment">// Get row and column indices in compressed row format</span>
<a name="l00113"></a>00113   ierr = MatGetRowIJ(localA, 0, PETSC_FALSE, PETSC_FALSE, &amp;nRowsLocal, &amp;rowOffsets, &amp;colIndices, &amp;done);
<a name="l00114"></a>00114   <span class="keywordflow">if</span> (done==PETSC_FALSE) <a class="code" href="classProcess.html#a6a4b64571b10f150a70db229b839e881" title="Routine de sortie de Trio-U sur une erreur abort()">Process::abort</a>();
<a name="l00115"></a>00115   CHKERRQ(ierr);
<a name="l00116"></a>00116 
<a name="l00117"></a>00117   ierr = MatSeqAIJGetArray(localA, &amp;values);
<a name="l00118"></a>00118   CHKERRQ(ierr);
<a name="l00119"></a>00119 
<a name="l00120"></a>00120 <span class="comment">// Get pointers to the raw data of local vectors</span>
<a name="l00121"></a>00121   ierr = VecGetArray(lhs_petsc, &amp;lhs);
<a name="l00122"></a>00122   CHKERRQ(ierr);
<a name="l00123"></a>00123   ierr = VecGetArray(rhs_petsc, &amp;rhs);
<a name="l00124"></a>00124   CHKERRQ(ierr);
<a name="l00125"></a>00125 
<a name="l00126"></a>00126 <span class="comment">// Calculate the number of rows in nRowsGlobal</span>
<a name="l00127"></a>00127   ierr = MPI_Allreduce(&amp;nRowsLocal, &amp;nRowsGlobal, 1, MPI_INT, MPI_SUM, PETSC_COMM_WORLD);
<a name="l00128"></a>00128   CHKERRQ(ierr);
<a name="l00129"></a>00129 
<a name="l00130"></a>00130 <span class="comment">// Store the number of non-zeros</span>
<a name="l00131"></a>00131   nNz = rowOffsets[nRowsLocal];
<a name="l00132"></a>00132   PetscFunctionReturn(0);
<a name="l00133"></a>00133 }
<a name="l00134"></a>00134 
<a name="l00135"></a>00135 <span class="keywordtype">void</span> Solv_AMGX::Update_matrix(Mat&amp; MatricePetsc, <span class="keyword">const</span> <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; mat_morse)
<a name="l00136"></a>00136 {
<a name="l00137"></a>00137 <span class="comment">// La matrice CSR de PETSc a ete mise a jour dans check_stencil</span>
<a name="l00138"></a>00138   std::clock_t start = std::clock();
<a name="l00139"></a>00139   SolveurAmgX_.updateA(nRowsLocal, nNz, values);  <span class="comment">//!&lt; ToDo erreur valgrind au premier appel de updateA...</span>
<a name="l00140"></a>00140 <span class="comment"></span>  <a class="code" href="EntreeSortie_8h.html#a1007c2f57f1c8fc7334a3f62aab08414">Cout</a> &lt;&lt; <span class="stringliteral">&quot;[AmgX] Time to update matrix (copy+resetup) on GPU: &quot;</span> &lt;&lt; (std::clock() - start) / (<span class="keywordtype">double</span>) CLOCKS_PER_SEC &lt;&lt; finl; <span class="comment">//!&lt; Attention balise lue par fiche de validation</span>
<a name="l00141"></a>00141 <span class="comment"></span>}
<a name="l00142"></a>00142 
<a name="l00143"></a>00143 <span class="comment">// Check and return true if new stencil</span>
<a name="l00144"></a>00144 <span class="keywordtype">bool</span> <a class="code" href="classSolv__AMGX.html">Solv_AMGX</a>::check_stencil(const <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; mat_morse)
<a name="l00145"></a>00145 {
<a name="l00146"></a>00146   std::clock_t start = std::clock();
<a name="l00147"></a>00147 <span class="comment">// Parcours de la matrice_morse (qui peut contenir des 0 et qui n&#39;est pas triee par colonnes croissantes)</span>
<a name="l00148"></a>00148 <span class="comment">// si matrice sur le GPU deja construite (qui est sans 0 et qui est triee par colonnes croissantes):</span>
<a name="l00149"></a>00149   <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; tab1 = mat_morse.get_tab1();
<a name="l00150"></a>00150   <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; tab2 = mat_morse.get_tab2();
<a name="l00151"></a>00151   <span class="keyword">const</span> <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a>&amp; <a class="code" href="Champ__P1iP1B__implementation_8cpp.html#aa8c8f49390c3cf7c702d71a71bc977e3">coeff</a> = mat_morse.get_coeff();
<a name="l00152"></a>00152   <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; renum_array = renum_;
<a name="l00153"></a>00153   <span class="keywordtype">int</span> new_stencil = 0, RowLocal = 0;
<a name="l00154"></a>00154   <a class="code" href="classProcess.html#a57e0f54b11e6eaadbea224fa904b18dd" title="Renvoie un objet statique de type Sortie qui sert de journal d&#39;evenements. Si message_level &lt;= verbose...">Journal</a>() &lt;&lt; <span class="stringliteral">&quot;Provisoire: nb_rows_=&quot;</span> &lt;&lt; nb_rows_ &lt;&lt; <span class="stringliteral">&quot; nb_rows_tot_=&quot;</span> &lt;&lt; nb_rows_tot_ &lt;&lt; finl;
<a name="l00155"></a>00155   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; tab1.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() - 1; i++)
<a name="l00156"></a>00156     {
<a name="l00157"></a>00157       <span class="keywordflow">if</span> (items_to_keep_[i])
<a name="l00158"></a>00158         {
<a name="l00159"></a>00159           <span class="keywordtype">int</span> nnz_row = 0;
<a name="l00160"></a>00160           <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k = tab1(i) - 1; k &lt; tab1(i + 1) - 1; k++)
<a name="l00161"></a>00161             <span class="keywordflow">if</span> (<a class="code" href="Champ__P1iP1B__implementation_8cpp.html#aa8c8f49390c3cf7c702d71a71bc977e3">coeff</a>(k) != 0) nnz_row++;
<a name="l00162"></a>00162           <span class="keywordflow">if</span> (nnz_row != rowOffsets[RowLocal + 1] - rowOffsets[RowLocal])
<a name="l00163"></a>00163             {
<a name="l00164"></a>00164               <a class="code" href="classProcess.html#a57e0f54b11e6eaadbea224fa904b18dd" title="Renvoie un objet statique de type Sortie qui sert de journal d&#39;evenements. Si message_level &lt;= verbose...">Journal</a>() &lt;&lt; <span class="stringliteral">&quot;Provisoire: Number of non-zero on GPU will change from &quot;</span> &lt;&lt; rowOffsets[RowLocal + 1] - rowOffsets[RowLocal] &lt;&lt; <span class="stringliteral">&quot; to &quot;</span> &lt;&lt; nnz_row &lt;&lt; <span class="stringliteral">&quot; on row &quot;</span> &lt;&lt; RowLocal &lt;&lt; finl;
<a name="l00165"></a>00165               new_stencil = 1;
<a name="l00166"></a>00166               <span class="keywordflow">break</span>;
<a name="l00167"></a>00167             }
<a name="l00168"></a>00168           <span class="keywordflow">else</span>
<a name="l00169"></a>00169             {
<a name="l00170"></a>00170               <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k = tab1(i) - 1; k &lt; tab1(i + 1) - 1; k++)
<a name="l00171"></a>00171                 {
<a name="l00172"></a>00172                   <span class="keywordflow">if</span> (<a class="code" href="Champ__P1iP1B__implementation_8cpp.html#aa8c8f49390c3cf7c702d71a71bc977e3">coeff</a>(k) != 0)
<a name="l00173"></a>00173                     {
<a name="l00174"></a>00174                       <span class="keywordtype">bool</span> found = <span class="keyword">false</span>;
<a name="l00175"></a>00175                       <span class="keywordtype">int</span> col = renum_array[tab2(k) - 1];
<a name="l00176"></a>00176 <span class="comment">// Boucle pour voir si le coeff est sur le GPU:</span>
<a name="l00177"></a>00177                       <span class="keywordtype">int</span> RowGlobal = decalage_local_global_+RowLocal;
<a name="l00178"></a>00178                       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> kk = rowOffsets[RowLocal]; kk &lt; rowOffsets[RowLocal + 1]; kk++)
<a name="l00179"></a>00179                         {
<a name="l00180"></a>00180                           <span class="keywordflow">if</span> (colIndices[kk] == col)
<a name="l00181"></a>00181                             {
<a name="l00182"></a>00182                               values[kk] = <a class="code" href="Champ__P1iP1B__implementation_8cpp.html#aa8c8f49390c3cf7c702d71a71bc977e3">coeff</a>(k); <span class="comment">//!&lt; On met a jour le coefficient</span>
<a name="l00183"></a>00183 <span class="comment"></span>                              found = <span class="keyword">true</span>;
<a name="l00184"></a>00184                               <span class="keywordflow">break</span>;
<a name="l00185"></a>00185                             }
<a name="l00186"></a>00186                         }
<a name="l00187"></a>00187                       <span class="keywordflow">if</span> (!found)
<a name="l00188"></a>00188                         {
<a name="l00189"></a>00189                           <a class="code" href="classProcess.html#a57e0f54b11e6eaadbea224fa904b18dd" title="Renvoie un objet statique de type Sortie qui sert de journal d&#39;evenements. Si message_level &lt;= verbose...">Journal</a>() &lt;&lt; <span class="stringliteral">&quot;Provisoire: mat_morse(&quot;</span> &lt;&lt; RowGlobal &lt;&lt; <span class="stringliteral">&quot;,&quot;</span> &lt;&lt; col &lt;&lt; <span class="stringliteral">&quot;)!=0 new on GPU &quot;</span> &lt;&lt; finl;
<a name="l00190"></a>00190                           new_stencil = 1;
<a name="l00191"></a>00191                           <span class="keywordflow">break</span>;
<a name="l00192"></a>00192                         }
<a name="l00193"></a>00193                     }
<a name="l00194"></a>00194                 }
<a name="l00195"></a>00195             }
<a name="l00196"></a>00196           RowLocal++;
<a name="l00197"></a>00197         }
<a name="l00198"></a>00198     }
<a name="l00199"></a>00199   new_stencil = <a class="code" href="classProcess.html#a1e9d9f9899b71927cfafae14c7bd048d" title="Calcule le max de x sur tous les processeurs du groupe courant. Remarques : Cette methode doit etre a...">mp_max</a>(new_stencil);
<a name="l00200"></a>00200   <a class="code" href="EntreeSortie_8h.html#a1007c2f57f1c8fc7334a3f62aab08414">Cout</a> &lt;&lt; <span class="stringliteral">&quot;[AmgX] Time to check stencil: &quot;</span> &lt;&lt; (std::clock() - start) / (<span class="keywordtype">double</span>) CLOCKS_PER_SEC &lt;&lt; finl;
<a name="l00201"></a>00201   return new_stencil;
<a name="l00202"></a>00202 }
<a name="l00203"></a>00203 
<a name="l00204"></a>00204 <span class="comment">// Resolution</span>
<a name="l00205"></a>00205 <span class="keywordtype">int</span> <a class="code" href="classSolv__AMGX.html">Solv_AMGX</a>::solve(<a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a>&amp; residu)
<a name="l00206"></a>00206 {
<a name="l00207"></a>00207   <span class="keywordflow">if</span> (seuil_relatif_==0)
<a name="l00208"></a>00208     {
<a name="l00209"></a>00209 <span class="comment">// Crash d&#39;AmgX (non reproduit sur les cas poisson d&#39;AmgXWrapper), peut etre a cause d&#39;une creation differente</span>
<a name="l00210"></a>00210 <span class="comment">// des vecteurs PETSc (via DM) par rapport a la notre (VecCreate), si deja converge a cause d&#39;un seuil absolu trop haut (nbiter=0)</span>
<a name="l00211"></a>00211 <span class="comment">// Contournement en calculant le residu avant le solve et on ne resout pas si inferieur au seuil:</span>
<a name="l00212"></a>00212       Vec ResidualPetsc_;
<a name="l00213"></a>00213       VecDuplicate(SolutionPetsc_, &amp;ResidualPetsc_);
<a name="l00214"></a>00214       MatResidual(MatricePetsc_, SecondMembrePetsc_, SolutionPetsc_, ResidualPetsc_);
<a name="l00215"></a>00215       VecNorm(ResidualPetsc_, NORM_2, &amp;residu(0));
<a name="l00216"></a>00216       VecDestroy(&amp;ResidualPetsc_);
<a name="l00217"></a>00217       <span class="keywordflow">if</span> (residu(0) &lt; seuil_)
<a name="l00218"></a>00218         {
<a name="l00219"></a>00219           <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;[AmgX] The residual seems to small to be solved on GPU: ||Ax-b||=&quot;</span>&lt;&lt;residu(0)&lt;&lt;<span class="stringliteral">&quot;&lt;&quot;</span>&lt;&lt;seuil_&lt;&lt; finl;
<a name="l00220"></a>00220           <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Please, try to use a relative tolerance, with rtol option or lower the absolute tolerance atol.&quot;</span> &lt;&lt; finl;
<a name="l00221"></a>00221           <span class="keywordflow">return</span> 0;
<a name="l00222"></a>00222 <span class="comment">// Process::exit();</span>
<a name="l00223"></a>00223         }
<a name="l00224"></a>00224     }
<a name="l00225"></a>00225   std::clock_t start = std::clock();
<a name="l00226"></a>00226   SolveurAmgX_.solve(lhs, rhs, nRowsLocal);
<a name="l00227"></a>00227   <a class="code" href="EntreeSortie_8h.html#a1007c2f57f1c8fc7334a3f62aab08414">Cout</a> &lt;&lt; <span class="stringliteral">&quot;[AmgX] Time to solve system on GPU: &quot;</span> &lt;&lt; ( std::clock() - start ) / (<span class="keywordtype">double</span>) CLOCKS_PER_SEC &lt;&lt; finl;
<a name="l00228"></a>00228   return nbiter(residu);
<a name="l00229"></a>00229 }
<a name="l00230"></a>00230 
<a name="l00231"></a>00231 <span class="keywordtype">int</span> <a class="code" href="classSolv__AMGX.html">Solv_AMGX</a>::nbiter(<a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a>&amp; residu)
<a name="l00232"></a>00232 {
<a name="l00233"></a>00233   <span class="keywordtype">int</span> nbiter = -1;
<a name="l00234"></a>00234   SolveurAmgX_.getIters(nbiter);
<a name="l00235"></a>00235 <span class="comment">// Bug AmgX, seul le process 0 renvoie correctement nbiter...</span>
<a name="l00236"></a>00236   <a class="code" href="communications_8cpp.html#a2335b36078ae87e23dab400a6e129a3c">envoyer_broadcast</a>(nbiter, 0);
<a name="l00237"></a>00237   <span class="keywordflow">if</span> (<a class="code" href="classSolveurSys__base.html#ab3ef68bcf4e1b402c52905aa78728aef">limpr</a>() &gt; -1)
<a name="l00238"></a>00238     {
<a name="l00239"></a>00239       SolveurAmgX_.getResidual(0, residu(0));
<a name="l00240"></a>00240       SolveurAmgX_.getResidual(nbiter - 1, residu(nbiter));
<a name="l00241"></a>00241     }
<a name="l00242"></a>00242   <span class="keywordflow">return</span> nbiter;
<a name="l00243"></a>00243 }
<a name="l00244"></a>00244 <span class="preprocessor">#endif</span>
<a name="l00245"></a>00245 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00246"></a>00246 <span class="preprocessor"></span>
</pre></div></div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Tue Dec 14 2021 19:35:23 for TRUST by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
