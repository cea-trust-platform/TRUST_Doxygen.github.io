<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>TRUST: Op_VEF_Face Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">TRUST&#160;<span id="projectnumber">1.8.4</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a>  </div>
  <div class="headertitle">
<div class="title">Op_VEF_Face Class Reference</div>  </div>
</div>
<div class="contents">
<!-- doxytag: class="Op_VEF_Face" -->
<p><code>#include &lt;<a class="el" href="Op__VEF__Face_8h_source.html">Op_VEF_Face.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Op_VEF_Face:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classOp__VEF__Face.png" usemap="#Op_VEF_Face_map" alt=""/>
  <map id="Op_VEF_Face_map" name="Op_VEF_Face_map">
<area href="classOp__Conv__VEF__base.html" title="class Op_Conv_VEF_base Classe de base des operateurs de convection VEF" alt="Op_Conv_VEF_base" shape="rect" coords="0,56,203,80"/>
<area href="classOp__Diff__P1NC__barprim.html" title="class Op_Diff_VEF_Face Cette classe represente l&#39;operateur de diffusion La discretisation est VEF Le ..." alt="Op_Diff_P1NC_barprim" shape="rect" coords="213,56,416,80"/>
<area href="classOp__Diff__VEF__base.html" title="class Op_Diff_VEF_base Classe de base des operateurs de convection VEF" alt="Op_Diff_VEF_base" shape="rect" coords="426,56,629,80"/>
<area href="classOp__Conv__Amont__old__VEF__Face.html" title="class Op_Conv_Amont_old_VEF_Face Cette classe represente l&#39;operateur de convection associe a une equa..." alt="Op_Conv_Amont_old_VEF_Face" shape="rect" coords="213,112,416,136"/>
<area href="classOp__Conv__AmontNew__VEF__Face.html" title="class Op_Conv_AmontNew_VEF_Face Cette classe represente l&#39;operateur de convection associe a une equat..." alt="Op_Conv_AmontNew_VEF_Face" shape="rect" coords="213,168,416,192"/>
<area href="classOp__Conv__Centre__EF__VEF__Face.html" title="class Op_Conv_Centre_EF_VEF_Face Cette classe represente l&#39;operateur de convection associe a une equa..." alt="Op_Conv_Centre_EF_VEF_Face" shape="rect" coords="213,224,416,248"/>
<area href="classOp__Conv__Centre__old__VEF__Face.html" title="class Op_Conv_Centre_old_VEF_Face Cette classe represente l&#39;operateur de convection associe a une equ..." alt="Op_Conv_Centre_old_VEF_Face" shape="rect" coords="213,280,416,304"/>
<area href="classOp__Conv__DI__L2__VEF__Face.html" title="class Op_Conv_DI_L2_VEF_Face Cette classe represente l&#39;operateur de convection associe a une equation..." alt="Op_Conv_DI_L2_VEF_Face" shape="rect" coords="213,336,416,360"/>
<area href="classOp__Conv__EF__VEF__P1NC.html" title="class Op_Conv_EF_VEF_P1NC Cette classe represente l&#39;operateur de convection associe a une equation de..." alt="Op_Conv_EF_VEF_P1NC" shape="rect" coords="213,392,416,416"/>
<area href="classOp__Conv__kschemas__centre__VEF.html" title="class Op_Conv_kschemas_centre_VEF Cette classe represente l&#39;operateur de convection associe a une equ..." alt="Op_Conv_kschemas_centre_VEF" shape="rect" coords="213,448,416,472"/>
<area href="classOp__Conv__kschemas__VEF.html" title="class Op_Conv_kschemas_VEF Cette classe represente l&#39;operateur de convection associe a une equation d..." alt="Op_Conv_kschemas_VEF" shape="rect" coords="213,504,416,528"/>
<area href="classOp__Conv__Muscl__old__VEF__Face.html" title="class Op_Conv_Muscl_old_VEF_Face Cette classe represente l&#39;operateur de convection associe a une equa..." alt="Op_Conv_Muscl_old_VEF_Face" shape="rect" coords="213,560,416,584"/>
<area href="classOp__Conv__VEF__Face.html" title="class Op_Conv_VEF_Face Cette classe represente l&#39;operateur de convection associe a une equation de tr..." alt="Op_Conv_VEF_Face" shape="rect" coords="213,616,416,640"/>
<area href="classOp__Conv__Vort__VEF__Face.html" title="class Op_Conv_Vort_VEF_Face Cette classe represente l&#39;operateur de convection associe a une equation ..." alt="Op_Conv_Vort_VEF_Face" shape="rect" coords="213,672,416,696"/>
<area href="classOp__Diff__VEF__Anisotrope__Face.html" title=": class Op_Diff_VEF_Anisotrope_Face &lt;Description of class Op_Diff_VEF_Anisotrope_Face&gt;" alt="Op_Diff_VEF_Anisotrope_Face" shape="rect" coords="639,112,842,136"/>
<area href="classOp__Diff__VEF__Face.html" title="class Op_Diff_VEF_Face Cette classe represente l&#39;operateur de diffusion La discretisation est VEF Le ..." alt="Op_Diff_VEF_Face" shape="rect" coords="639,168,842,192"/>
<area href="classOp__Diff__VEF__Face__Q1.html" title="class Op_Diff_VEF_Face_Q1_Q1 Cette classe represente l&#39;operateur de diffusion La discretisation est V..." alt="Op_Diff_VEF_Face_Q1" shape="rect" coords="639,224,842,248"/>
<area href="classOp__Dift__VEF__base.html" title="class Op_Dift_VEF_base" alt="Op_Dift_VEF_base" shape="rect" coords="639,280,842,304"/>
</map>
 </div></div>

<p><a href="classOp__VEF__Face-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOp__VEF__Face.html#af3ee6351574bb55da43c3721b8b8d9a5">Op_VEF_Face</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOp__VEF__Face.html#ac4907925da4d8dc1a4244b38ef39b702">dimensionner</a> (const <a class="el" href="classZone__VEF.html">Zone_VEF</a> &amp;, const <a class="el" href="classZone__Cl__VEF.html">Zone_Cl_VEF</a> &amp;, <a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOp__VEF__Face.html#a102d8127171d25eb197fc70e710790ea">modifier_pour_Cl</a> (const <a class="el" href="classZone__VEF.html">Zone_VEF</a> &amp;, const <a class="el" href="classZone__Cl__VEF.html">Zone_Cl_VEF</a> &amp;, <a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;, <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOp__VEF__Face.html#a4198ff4473d6fb7f79449e3009fa4957">impr</a> (<a class="el" href="classSortie.html">Sortie</a> &amp;, const <a class="el" href="classOperateur__base.html">Operateur_base</a> &amp;) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOp__VEF__Face.html#a6c8ce571769b4f2e20b07cbb7a6944f2">modifier_flux</a> (const <a class="el" href="classOperateur__base.html">Operateur_base</a> &amp;) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOp__VEF__Face.html#ab66c49a837d41ba7e304a0efc484a5d5">modifier_matrice_pour_periodique_avant_contribuer</a> (<a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;matrice, const <a class="el" href="classEquation__base.html">Equation_base</a> &amp;) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">divise les coefficients sur les ligne des faces periodiques par 2 en prevision<br/>
de l'application modifier_matrice_pour_periodique_apres_contribuer qui va sommer les 2 lignes des faces periodiques associees  <a href="#ab66c49a837d41ba7e304a0efc484a5d5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOp__VEF__Face.html#a00a9703ef92c279f100fa3872cc8ec09">modifier_matrice_pour_periodique_apres_contribuer</a> (<a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;matrice, const <a class="el" href="classEquation__base.html">Equation_base</a> &amp;) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Somme les 2 lignes des faces periodiques associees<br/>
permet de calculer dans le code sans se poser de question pour retrouver la face_associee<br/>
on ne parcourt que la moitiee des faces periodiques dans contribuer_a_avec (en general).  <a href="#a00a9703ef92c279f100fa3872cc8ec09"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOp__VEF__Face.html#a74453359874aa3d466f3df50684236a3">controle_modifier_flux_</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSFichier.html">SFichier</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOp__VEF__Face.html#af92615c52cc45fd48d495802fd2ba02f">Flux</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSFichier.html">SFichier</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOp__VEF__Face.html#a426500a12aa34bc34e10dd494d0701b3">Flux_moment</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSFichier.html">SFichier</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOp__VEF__Face.html#a44c07f75ad3edafd7f840cfa4d2b92a9">Flux_sum</a></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock">
<p>Definition at line <a class="el" href="Op__VEF__Face_8h_source.html#l00036">36</a> of file <a class="el" href="Op__VEF__Face_8h_source.html">Op_VEF_Face.h</a>.</p>
</div><hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="af3ee6351574bb55da43c3721b8b8d9a5"></a><!-- doxytag: member="Op_VEF_Face::Op_VEF_Face" ref="af3ee6351574bb55da43c3721b8b8d9a5" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Op_VEF_Face::Op_VEF_Face </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Op__VEF__Face_8h_source.html#l00039">39</a> of file <a class="el" href="Op__VEF__Face_8h_source.html">Op_VEF_Face.h</a>.</p>
<div class="fragment"><pre class="fragment">:<a class="code" href="classOp__VEF__Face.html#a74453359874aa3d466f3df50684236a3">controle_modifier_flux_</a>(0) { };
</pre></div>
</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="ac4907925da4d8dc1a4244b38ef39b702"></a><!-- doxytag: member="Op_VEF_Face::dimensionner" ref="ac4907925da4d8dc1a4244b38ef39b702" args="(const Zone_VEF &amp;, const Zone_Cl_VEF &amp;, Matrice_Morse &amp;) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Op_VEF_Face::dimensionner </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classZone__VEF.html">Zone_VEF</a> &amp;&#160;</td>
          <td class="paramname"><em>la_zone</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classZone__Cl__VEF.html">Zone_Cl_VEF</a> &amp;&#160;</td>
          <td class="paramname"><em>la_zone_cl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;&#160;</td>
          <td class="paramname"><em>la_matrice</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Op__VEF__Face_8cpp_source.html#l00050">50</a> of file <a class="el" href="Op__VEF__Face_8cpp_source.html">Op_VEF_Face.cpp</a>.</p>

<p>References <a class="el" href="Champ__P1iP1B__implementation_8cpp_source.html#l00331">coeff</a>, <a class="el" href="Matrice__Morse_8cpp_source.html#l00346">Matrice_Morse::dimensionner()</a>, <a class="el" href="Zone__VF_8h_source.html#l00574">Zone_VF::elem_faces()</a>, <a class="el" href="MorEqn_8h_source.html#l00082">MorEqn::equation()</a>, <a class="el" href="Zone__VF_8h_source.html#l00458">Zone_VF::face_voisins()</a>, <a class="el" href="Matrice__Morse_8h_source.html#l00129">Matrice_Morse::get_set_coeff()</a>, <a class="el" href="Matrice__Morse_8h_source.html#l00119">Matrice_Morse::get_set_tab1()</a>, <a class="el" href="Matrice__Morse_8h_source.html#l00124">Matrice_Morse::get_set_tab2()</a>, <a class="el" href="classEquation__base.html#a5a1fce9487b9a8dd17020914100c2c89">Equation_base::inconnue()</a>, <a class="el" href="DoubleVect_8h_source.html#l00164">DoubleVect::line_size()</a>, <a class="el" href="Zone__VF_8h_source.html#l00519">Zone_VF::nb_faces()</a>, <a class="el" href="Zone_8h_source.html#l00469">Zone::nb_faces_elem()</a>, <a class="el" href="Zone__VF_8h_source.html#l00527">Zone_VF::nb_faces_tot()</a>, <a class="el" href="Champ__Inc_8cpp_source.html#l00245">Champ_Inc::valeurs()</a>, and <a class="el" href="Zone__dis__base_8h_source.html#l00106">Zone_dis_base::zone()</a>.</p>
<div class="fragment"><pre class="fragment">{
<span class="comment">// Dimensionnement de la matrice qui devra recevoir les coefficients provenant de</span>
<span class="comment">// la convection, de la diffusion pour le cas des faces.</span>
<span class="comment">// Cette matrice a une structure de matrice morse.</span>
<span class="comment">// Nous commencons par calculer les tailles des tableaux tab1 et tab2.</span>
<span class="comment">// Pour ce faire il faut chercher les faces voisines de la face consideree.</span>

  <span class="keywordtype">int</span> num_face;
  <span class="keywordtype">int</span> ndeb = 0;
  <span class="keywordtype">int</span> nfin = la_zone.<a class="code" href="classZone__VF.html#aede27992d9f2eedd52c24d4a80ff7ffb" title="renvoie le nombre global de faces.">nb_faces</a>();
  <span class="keywordtype">int</span> nnnn = la_zone.<a class="code" href="classZone__VF.html#a50fd21c9535680489015a3c8b88c685a" title="renvoie le nombre total de faces. C&#39;est-a-dire faces reelles + faces virtuelles">nb_faces_tot</a>();
  nfin=nnnn;
  <span class="keywordtype">int</span> i,j,k,kk;
  <span class="keywordtype">int</span> elem1,elem2;
  <span class="keywordtype">int</span> nb_faces_elem = la_zone.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#a548fbc7518be2f122b1a5c9589a443c2" title="Renvoie le nombre de face de type i des elements geometriques constituants la zone. Ex: les objets de la classe Prisme ont 2 types de faces: triangle ou quadrangle.">nb_faces_elem</a>();
<span class="comment">// const Conds_lim&amp; les_cl = la_zone_cl.les_conditions_limites();</span>
  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_comp = la_zone_cl.<a class="code" href="classMorEqn.html#a615dd9abff96edcb625fa0424a489864" title="Renvoie la reference sur l&#39;equation pointe par MorEqn::mon_equation. (version const)">equation</a>().<a class="code" href="classEquation__base.html#a5a1fce9487b9a8dd17020914100c2c89">inconnue</a>().<a class="code" href="classChamp__Inc.html#a28ef3d411d12cb5684ac5e799efb7d24" title="Appel a l&#39;objet sous-jacent Renvoie le tableau des valeurs au temps courant.">valeurs</a>().<a class="code" href="classDoubleVect.html#ab02d01cd1bdab66fbd66f9a47cc29e10">line_size</a>();
  la_matrice.<a class="code" href="classMatrice__Morse.html#ae95f9ed88a8a3fc637cd2a705cead9c8" title="Size the matrix with n lines and n columns and nnz zero-values coefficients.">dimensionner</a>(nfin*nb_comp,nfin*nb_comp,0);

  <a class="code" href="classIntVect.html">IntVect</a>&amp; tab1=la_matrice.<a class="code" href="classMatrice__Morse.html#a7a49c763706dcfaed900f9d2cbb68716">get_set_tab1</a>();
  <a class="code" href="classIntVect.html">IntVect</a>&amp; tab2=la_matrice.<a class="code" href="classMatrice__Morse.html#af11c5853518e9e6db4c7e6e6acc8d7fd">get_set_tab2</a>();
  <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; <a class="code" href="Champ__P1iP1B__implementation_8cpp.html#aa8c8f49390c3cf7c702d71a71bc977e3">coeff</a> = la_matrice.<a class="code" href="classMatrice__Morse.html#acd067e8514e5741f52b18a1d99746d11">get_set_coeff</a>();
  coeff=0;


  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; elem_faces = la_zone.<a class="code" href="classZone__VF.html#a067e462dcd3ab92b0f6d945b19e4eb37" title="renvoie le numero de le ieme face de la maille num_elem la facon dont ces faces sont numerotees est l...">elem_faces</a>();
  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; face_voisins = la_zone.<a class="code" href="classZone__VF.html#a49d4322f5585a8fa95748ca785b70702" title="renvoie l&#39;element voisin de numface dans la direction i. i=0 : dans le sens oppose de l&#39;axe orthogona...">face_voisins</a>();

<span class="comment">// A chaque face on associe un tableau d&#39;entiers et une liste de reels:</span>
<span class="comment">// voisines[i] = {j t.q j&gt;i et M(i,j) est non nul }</span>

<span class="comment">// IntVect rang_voisin(nfin*nb_comp);</span>
  <a class="code" href="classIntVect.html">IntVect</a> rang_voisin(nnnn*nb_comp);
  rang_voisin=nb_comp;


<span class="comment">// On traite toutes les faces</span>

  <span class="keywordflow">for</span> (num_face= 0; num_face&lt;nfin; num_face++)
    {
      elem1 = face_voisins(num_face,0);
      elem2 = face_voisins(num_face,1);

      <span class="keywordflow">for</span> (i=0; i&lt;nb_faces_elem; i++)
        {
          <span class="keywordflow">if</span> ( (j=elem_faces(elem1,i)) != num_face )
            {
              <span class="keywordflow">for</span> (k=0; k&lt;nb_comp; k++)
                {
                  rang_voisin(num_face*nb_comp+k)+=nb_comp;
                }
            }
          <span class="keywordflow">if</span> (elem2!=-1)
            <span class="keywordflow">if</span> ( (j=elem_faces(elem2,i)) != num_face )
              {
                <span class="keywordflow">for</span> (k=0; k&lt;nb_comp; k++)
                  {
                    rang_voisin(num_face*nb_comp+k)+=nb_comp;
                  }
              }
        }
    }


<span class="comment">// les faces voisines de num_face etant desormais comtabilisees</span>
<span class="comment">// nous dimensionnons tab1 et tab2 au nombre de faces</span>

  tab1(0)=1;
  <span class="keywordflow">for</span> (num_face=ndeb; num_face&lt;nfin; num_face++)
    {
      <span class="keywordflow">for</span> (k=0; k&lt; nb_comp; k++)
        {
          tab1(num_face*nb_comp+1+k)=rang_voisin(num_face*nb_comp+k)+tab1(num_face*nb_comp+k);
        }
    }
  la_matrice.<a class="code" href="classMatrice__Morse.html#ae95f9ed88a8a3fc637cd2a705cead9c8" title="Size the matrix with n lines and n columns and nnz zero-values coefficients.">dimensionner</a>(nfin*nb_comp,tab1(nfin*nb_comp)-1);

  <span class="keywordflow">for</span> (num_face = 0; num_face &lt; nfin;  num_face++ )
    {
      <span class="keywordflow">for</span> (k=0; k&lt; nb_comp; k++)
        {
          <span class="keywordflow">for</span> (kk=0; kk&lt;nb_comp; kk++)
            {
              <span class="keywordtype">int</span> modulo = (k+kk)%nb_comp;
              tab2[tab1[num_face*nb_comp+k]-1+kk]=num_face*nb_comp+1+modulo;
            }
          rang_voisin[num_face*nb_comp+k]=tab1[num_face*nb_comp+k]+nb_comp-1;
        }
    }


<span class="comment">// On traite toutes les faces</span>
  <span class="keywordflow">for</span> (num_face= 0; num_face&lt;nfin; num_face++)
    {
      elem1 = face_voisins(num_face,0);
      elem2 = face_voisins(num_face,1);

      <span class="keywordflow">for</span> (i=0; i&lt;nb_faces_elem; i++)
        {
          <span class="keywordflow">if</span> ( (j=elem_faces(elem1,i)) != num_face )
            {
              <span class="keywordflow">for</span> (k=0; k&lt;nb_comp; k++)
                {
                  <span class="keywordflow">for</span> (kk=0; kk&lt;nb_comp; kk++)
                    {
                      <span class="keywordtype">int</span> modulo = (k+kk)%nb_comp;
                      tab2[rang_voisin[num_face*nb_comp+k]+kk]=j*nb_comp+1+modulo;
                    }
                  rang_voisin[num_face*nb_comp+k]+=nb_comp;
                }
            }
          <span class="keywordflow">if</span> (elem2!=-1)
            <span class="keywordflow">if</span> ( (j=elem_faces(elem2,i)) != num_face )
              {
                <span class="keywordflow">for</span> (k=0; k&lt;nb_comp; k++)
                  {
                    <span class="keywordflow">for</span> (kk=0; kk&lt;nb_comp; kk++)
                      {
                        <span class="keywordtype">int</span> modulo = (k+kk)%nb_comp;
                        tab2[rang_voisin[num_face*nb_comp+k]+kk]=j*nb_comp+1+modulo;
                      }
                    rang_voisin[num_face*nb_comp+k]+=nb_comp;
                  }
              }
        }
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a4198ff4473d6fb7f79449e3009fa4957"></a><!-- doxytag: member="Op_VEF_Face::impr" ref="a4198ff4473d6fb7f79449e3009fa4957" args="(Sortie &amp;, const Operateur_base &amp;) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Op_VEF_Face::impr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSortie.html">Sortie</a> &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classOperateur__base.html">Operateur_base</a> &amp;&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Op__VEF__Face_8cpp_source.html#l00456">456</a> of file <a class="el" href="Op__VEF__Face_8cpp_source.html">Op_VEF_Face.cpp</a>.</p>

<p>References <a class="el" href="Sortie_8cpp_source.html#l00126">Sortie::add_col()</a>, <a class="el" href="Zone_8h_source.html#l00265">Zone::Bords_a_imprimer()</a>, <a class="el" href="Zone_8h_source.html#l00270">Zone::Bords_a_imprimer_sum()</a>, <a class="el" href="EntreeSortie_8h_source.html#l00032">Cerr</a>, <a class="el" href="Zone_8h_source.html#l00174">Zone::cg_moments()</a>, <a class="el" href="List__Nom_8h_source.html#l00027">List_Nom::contient()</a>, <a class="el" href="Op__VEF__Face_8h_source.html#l00047">controle_modifier_flux_</a>, <a class="el" href="EntreeSortie_8h_source.html#l00033">Cout</a>, <a class="el" href="Objet__U_8h_source.html#l00079">Objet_U::dimension</a>, <a class="el" href="MorEqn_8h_source.html#l00082">MorEqn::equation()</a>, <a class="el" href="liste_8h_source.html#l00199">liste::est_vide()</a>, <a class="el" href="Process_8cpp_source.html#l00223">Process::exit()</a>, <a class="el" href="Zone__VF_8h_source.html#l00054">Zone_VF::face_surfaces()</a>, <a class="el" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>, <a class="el" href="Op__VEF__Face_8h_source.html#l00048">Flux</a>, <a class="el" href="Operateur__base_8h_source.html#l00130">Operateur_base::flux_bords()</a>, <a class="el" href="Op__VEF__Face_8h_source.html#l00048">Flux_moment</a>, <a class="el" href="Op__VEF__Face_8h_source.html#l00048">Flux_sum</a>, <a class="el" href="Cond__lim_8h_source.html#l00130">Cond_lim::frontiere_dis()</a>, <a class="el" href="Schema__Temps__base_8cpp_source.html#l01127">Schema_Temps_base::imprimer_temps_courant()</a>, <a class="el" href="classEquation__base.html#a5a1fce9487b9a8dd17020914100c2c89">Equation_base::inconnue()</a>, <a class="el" href="Sortie__Fichier__base_8cpp_source.html#l00258">Sortie_Fichier_base::is_open()</a>, <a class="el" href="Process_8cpp_source.html#l00095">Process::je_suis_maitre()</a>, <a class="el" href="Frontiere__dis__base_8cpp_source.html#l00146">Frontiere_dis_base::le_nom()</a>, <a class="el" href="O__U__Ptr_8cpp_source.html#l00179">O_U_Ptr::le_nom()</a>, <a class="el" href="Zone__Cl__dis_8h_source.html#l00130">Zone_Cl_dis::les_conditions_limites()</a>, <a class="el" href="List_8h_source.html#l00026">LIST</a>, <a class="el" href="ArrOfDouble_8cpp_source.html#l00848">max_abs_array()</a>, <a class="el" href="Zone_8h_source.html#l00166">Zone::Moments_a_imprimer()</a>, <a class="el" href="communications_8cpp_source.html#l00659">mp_sum_for_each_item()</a>, <a class="el" href="Front__VF_8h_source.html#l00061">Front_VF::nb_faces()</a>, <a class="el" href="Zone__VF_8h_source.html#l00527">Zone_VF::nb_faces_tot()</a>, <a class="el" href="Zone__dis__base_8h_source.html#l00156">Zone_dis_base::nb_front_Cl()</a>, <a class="el" href="Front__VF_8h_source.html#l00071">Front_VF::num_premiere_face()</a>, <a class="el" href="Operateur__base_8cpp_source.html#l00409">Operateur_base::ouvrir_fichier()</a>, <a class="el" href="Operateur__base_8cpp_source.html#l00528">Operateur_base::ouvrir_fichier_partage()</a>, <a class="el" href="Equation__base_8cpp_source.html#l00964">Equation_base::probleme()</a>, <a class="el" href="Objet__U_8cpp_source.html#l00132">Objet_U::que_suis_je()</a>, <a class="el" href="Cast_8h_source.html#l00059">ref_cast</a>, <a class="el" href="Probleme__base_8cpp_source.html#l01342">Probleme_base::schema_temps()</a>, <a class="el" href="Cast_8h_source.html#l00054">sub_type</a>, <a class="el" href="EcrFicPartage_8cpp_source.html#l00216">EcrFicPartage::syncfile()</a>, <a class="el" href="Schema__Temps__base_8h_source.html#l00676">Schema_Temps_base::temps_courant()</a>, <a class="el" href="Cond__lim_8h_source.html#l00031">Deriv_Cond_lim_base::valeur()</a>, <a class="el" href="Zone__dis_8h_source.html#l00029">Deriv_Zone_dis_base::valeur()</a>, <a class="el" href="Zone__VF_8h_source.html#l00650">Zone_VF::xv()</a>, <a class="el" href="Zone__dis__base_8h_source.html#l00106">Zone_dis_base::zone()</a>, <a class="el" href="Equation__base_8h_source.html#l00391">Equation_base::zone_Cl_dis()</a>, and <a class="el" href="Equation__base_8cpp_source.html#l00091">Equation_base::zone_dis()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">const</span> <a class="code" href="classZone__VEF.html" title="class Zone_VEF Classe instanciable qui derive de Zone_VF. Cette classe contient les informations geom...">Zone_VEF</a>&amp; la_zone_vef=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classZone__VEF.html" title="class Zone_VEF Classe instanciable qui derive de Zone_VF. Cette classe contient les informations geom...">Zone_VEF</a>,op.<a class="code" href="classMorEqn.html#a615dd9abff96edcb625fa0424a489864" title="Renvoie la reference sur l&#39;equation pointe par MorEqn::mon_equation. (version const)">equation</a>().<a class="code" href="classEquation__base.html#a12d97ae801edc18f614523677921346e" title="Renvoie la zone discretisee associee a l&#39;equation.">zone_dis</a>().<a class="code" href="classDeriv__Zone__dis__base.html#a30ff47fc0684fe134e8c74c35b268941">valeur</a>());
  <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; flux_bords_=op.<a class="code" href="classOperateur__base.html#ab547b37ace0f04931f6f09fcfa8fae0c">flux_bords</a>();
  <span class="keywordflow">if</span> (flux_bords_.nb_dim()!=2)
    {
      <a class="code" href="EntreeSortie_8h.html#a1007c2f57f1c8fc7334a3f62aab08414">Cout</a> &lt;&lt; <span class="stringliteral">&quot;L&#39;impression des flux n&#39;est pas codee pour l&#39;operateur &quot;</span> &lt;&lt; op.<a class="code" href="classObjet__U.html#aa58e9a81c0ddc2c1149053b8f96698ac" title="renvoie la chaine identifiant la classe.">que_suis_je</a>() &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
      <span class="keywordflow">return</span> 1;
    }
  <span class="keywordflow">if</span> (<a class="code" href="classOp__VEF__Face.html#a74453359874aa3d466f3df50684236a3">controle_modifier_flux_</a>==0)
    <span class="keywordflow">if</span> (<a class="code" href="ArrOfDouble_8cpp.html#a22ce24a1e68db94b2e023b6eb200c92b" title="Retourne le max des abs(i)">max_abs_array</a>(flux_bords_)!=0)
      {
        <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a>&lt;&lt;op.<a class="code" href="classObjet__U.html#aa58e9a81c0ddc2c1149053b8f96698ac" title="renvoie la chaine identifiant la classe.">que_suis_je</a>()&lt;&lt;<span class="stringliteral">&quot; appelle  Op_VEF_Face::impr sans avoir appeler  Op_VEF_Face::modifier_flux, on arrete tout &quot;</span>&lt;&lt;<a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
        <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">Process::exit</a>();
      }
  <span class="keywordtype">int</span> nb_compo=flux_bords_.dimension(1);
  <span class="keyword">const</span> <a class="code" href="classProbleme__base.html" title="classe Probleme_base C&#39;est un Probleme_U qui n&#39;est pas un couplage. Le role d&#39;un Probleme_base est la...">Probleme_base</a>&amp; pb=op.<a class="code" href="classMorEqn.html#a615dd9abff96edcb625fa0424a489864" title="Renvoie la reference sur l&#39;equation pointe par MorEqn::mon_equation. (version const)">equation</a>().<a class="code" href="classEquation__base.html#aa8151a96f63719523bf50ddd832e0f8f" title="Renvoie le probleme associe a l&#39;equation.">probleme</a>();
  <span class="keyword">const</span> <a class="code" href="classSchema__Temps__base.html" title="classe Schema_Temps_base">Schema_Temps_base</a>&amp; sch=pb.<a class="code" href="classProbleme__base.html#a0cf6c541e30cd21c3da32fc122cb0e2b" title="Renvoie le schema en temps associe au probleme. (si il est non nul) (version const)">schema_temps</a>();
<span class="comment">// On n&#39;imprime les moments que si demande et si on traite l&#39;operateur de diffusion de la vitesse</span>
  <span class="keywordtype">int</span> impr_mom=0;
  <span class="keywordflow">if</span> (la_zone_vef.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#a1147c5a9ff1ba84a899979712734cb28">Moments_a_imprimer</a>() &amp;&amp; <a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classOperateur__Diff__base.html" title="classe Operateur_Diff_base Cette classe est la base de la hierarchie des operateurs representant un t...">Operateur_Diff_base</a>,op) &amp;&amp; op.<a class="code" href="classMorEqn.html#a615dd9abff96edcb625fa0424a489864" title="Renvoie la reference sur l&#39;equation pointe par MorEqn::mon_equation. (version const)">equation</a>().<a class="code" href="classEquation__base.html#a5a1fce9487b9a8dd17020914100c2c89">inconnue</a>().<a class="code" href="classO__U__Ptr.html#a5aae0c48048a40339f3847aa14109231" title="Renvoie ref_().le_nom() si le pointeur est non nul ou &quot;Pointeur Nul&quot;.">le_nom</a>()==<span class="stringliteral">&quot;vitesse&quot;</span>)
    impr_mom=1;

  <span class="keyword">const</span> <span class="keywordtype">int</span> impr_sum=(la_zone_vef.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#aa5780fa644b13f8172c4805336846dec">Bords_a_imprimer_sum</a>().<a class="code" href="classliste.html#a68a1377a9c67f05e76638da8d93e2d5a" title="Teste si la liste est vide.">est_vide</a>() ? 0:1);
  <span class="keyword">const</span> <span class="keywordtype">int</span> impr_bord=(la_zone_vef.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#a2e4f80965f20d39334b470af7aec494a">Bords_a_imprimer</a>().<a class="code" href="classliste.html#a68a1377a9c67f05e76638da8d93e2d5a" title="Teste si la liste est vide.">est_vide</a>() ? 0:1);

<span class="comment">// Calcul des moments</span>
  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_faces =  la_zone_vef.<a class="code" href="classZone__VF.html#a50fd21c9535680489015a3c8b88c685a" title="renvoie le nombre total de faces. C&#39;est-a-dire faces reelles + faces virtuelles">nb_faces_tot</a>();
  <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a> xgr(nb_faces,<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>);
  xgr=0.;
  <span class="keywordflow">if</span> (impr_mom)
    {
      <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; xgrav = la_zone_vef.<a class="code" href="classZone__VF.html#a918c0885a9b67317fcce3a0535306542">xv</a>();
      <span class="keyword">const</span> <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a>&amp; c_grav=la_zone_vef.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#ab6b13609a679b31cc3a6931362490e2a">cg_moments</a>();
      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> num_face=0; num_face &lt;nb_faces; num_face++)
        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>; i++)
          xgr(num_face,i)=xgrav(num_face,i)-c_grav(i);
    }

<span class="comment">// On parcours les frontieres pour sommer les flux par frontiere dans le tableau flux_bord</span>
  <a class="code" href="classDoubleVect.html">DoubleVect</a> bilan(nb_compo);
  bilan = 0;
  <span class="keywordtype">int</span> nb_cl = la_zone_vef.<a class="code" href="classZone__dis__base.html#af22167d614644f55591a29c77eb1c009">nb_front_Cl</a>();
  <a class="code" href="classDoubleTrav.html" title="Tableau de travail a n entrees pour n&lt;= 4 C&#39;est un DoubleTab avec allocation dans un pool de memoire g...">DoubleTrav</a> flux_bords(4,nb_cl,nb_compo);
  flux_bords=0.;
  <span class="comment">/*</span>
<span class="comment">     flux_bord(k)             -&gt;     flux_bords(0,num_cl,k)</span>
<span class="comment">     flux_bord_perio1(k)      -&gt;     flux_bords(1,num_cl,k)</span>
<span class="comment">     flux_bord_perio2(k)      -&gt;     flux_bords(2,num_cl,k)</span>
<span class="comment">     moment(k)                -&gt;     flux_bords(3,num_cl,k)</span>
<span class="comment">  */</span>
  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> num_cl=0; num_cl&lt;nb_cl; num_cl++)
    {
      <span class="keyword">const</span> <a class="code" href="classCond__lim.html" title="classe Cond_lim Classe generique servant a representer n&#39;importe quelle classe derivee de la classe C...">Cond_lim</a>&amp; la_cl = op.<a class="code" href="classMorEqn.html#a615dd9abff96edcb625fa0424a489864" title="Renvoie la reference sur l&#39;equation pointe par MorEqn::mon_equation. (version const)">equation</a>().<a class="code" href="classEquation__base.html#af265fe0ea30868eb2176a0c887e4efab" title="Renvoie la zone des conditions aux limite discretisee associee a l&#39;equation.">zone_Cl_dis</a>().<a class="code" href="classZone__Cl__dis.html#aafbd0525703e23200e31796bcd4fcac6" title="Appel a l&#39;objet sous-jacent Renvoie la i-ieme condition aux limites. (version const)">les_conditions_limites</a>(num_cl);
      <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp; frontiere_dis = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>,la_cl.<a class="code" href="classCond__lim.html#a5b2d24809cee07727006a891d4ce8d22" title="Appel a l&#39;objet sous-jacent Renvoie la frontiere discretisee associee a la condition aux limites...">frontiere_dis</a>());
      <span class="keywordtype">int</span> ndeb = frontiere_dis.<a class="code" href="classFront__VF.html#a4986f0c65653fe9eb40bbbff5a97bf16" title="Numero de la premiere face du bord dans la liste des faces.">num_premiere_face</a>();
      <span class="keywordtype">int</span> nfin = ndeb + frontiere_dis.<a class="code" href="classFront__VF.html#a341e2fcb5117b96e745fd7078ba86bab" title="Nombre de faces reelles du bord.">nb_faces</a>();
      <span class="keywordtype">int</span> perio = (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>())?1:0);
      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> face=ndeb; face&lt;nfin; face++)
        {
          <span class="keywordflow">for</span>(<span class="keywordtype">int</span> k=0; k&lt;nb_compo; k++)
            {
              flux_bords(0,num_cl,k)+=flux_bords_(face, k);
              <span class="keywordflow">if</span>(perio)
                {
                  <span class="keywordflow">if</span>(face&lt;(ndeb+frontiere_dis.<a class="code" href="classFront__VF.html#a341e2fcb5117b96e745fd7078ba86bab" title="Nombre de faces reelles du bord.">nb_faces</a>()/2))
                    flux_bords(1,num_cl,k)+=flux_bords_(face, k);
                  <span class="keywordflow">else</span>
                    flux_bords(2,num_cl,k)+=flux_bords_(face, k);
                }
            }
          <span class="keywordflow">if</span> (impr_mom)
            {
<span class="comment">// Calcul du moment exerce par le fluide sur le bord (OM/\F)</span>
              <span class="keywordflow">if</span> (Objet_U::dimension==2)
                flux_bords(3,num_cl,0)+=flux_bords_(face,1)*xgr(face,0)-flux_bords_(face,0)*xgr(face,1);
              <span class="keywordflow">else</span>
                {
                  flux_bords(3,num_cl,0)+=flux_bords_(face,2)*xgr(face,1)-flux_bords_(face,1)*xgr(face,2);
                  flux_bords(3,num_cl,1)+=flux_bords_(face,0)*xgr(face,2)-flux_bords_(face,2)*xgr(face,0);
                  flux_bords(3,num_cl,2)+=flux_bords_(face,1)*xgr(face,0)-flux_bords_(face,0)*xgr(face,1);
                }
            }
        } <span class="comment">//!&lt; fin for face</span>
<span class="comment"></span>    } <span class="comment">//!&lt; fin for num_cl</span>
<span class="comment"></span>
<span class="comment">// On somme les contributions de chaque processeur</span>
  <a class="code" href="communications_8cpp.html#a5f15b8a5c15449d3277ff3cde06fa68a">mp_sum_for_each_item</a>(flux_bords);

<span class="comment">// Ecriture dans les fichiers</span>
  <span class="keywordflow">if</span> (<a class="code" href="classProcess.html#acd052b99706c577f8a5b6656217cf4c2" title="renvoie 1 si on est sur le processeur maitre du groupe courant (c&#39;est a dire me() == 0)...">Process::je_suis_maitre</a>())
    {
<span class="comment">// Open files if needed</span>
<span class="comment">// SFichier Flux;</span>
      <span class="keywordflow">if</span> (!<a class="code" href="classOp__VEF__Face.html#af92615c52cc45fd48d495802fd2ba02f">Flux</a>.<a class="code" href="classSortie__Fichier__base.html#acc0244cc2feedba886b643e9b3c295db">is_open</a>()) op.<a class="code" href="classOperateur__base.html#a163b8e77d9ad86d8c0cdd28d29903538" title="Ouverture/creation d&#39;un fichier d&#39;impression d&#39;un operateur A surcharger dans les classes derivees...">ouvrir_fichier</a>(<a class="code" href="classOp__VEF__Face.html#af92615c52cc45fd48d495802fd2ba02f">Flux</a>,<span class="stringliteral">&quot;&quot;</span>,1);
<span class="comment">// SFichier Flux_moment;</span>
      <span class="keywordflow">if</span> (!<a class="code" href="classOp__VEF__Face.html#a426500a12aa34bc34e10dd494d0701b3">Flux_moment</a>.<a class="code" href="classSortie__Fichier__base.html#acc0244cc2feedba886b643e9b3c295db">is_open</a>()) op.<a class="code" href="classOperateur__base.html#a163b8e77d9ad86d8c0cdd28d29903538" title="Ouverture/creation d&#39;un fichier d&#39;impression d&#39;un operateur A surcharger dans les classes derivees...">ouvrir_fichier</a>(<a class="code" href="classOp__VEF__Face.html#a426500a12aa34bc34e10dd494d0701b3">Flux_moment</a>,<span class="stringliteral">&quot;moment&quot;</span>,impr_mom);
<span class="comment">// SFichier Flux_sum;</span>
      <span class="keywordflow">if</span> (!<a class="code" href="classOp__VEF__Face.html#a44c07f75ad3edafd7f840cfa4d2b92a9">Flux_sum</a>.<a class="code" href="classSortie__Fichier__base.html#acc0244cc2feedba886b643e9b3c295db">is_open</a>()) op.<a class="code" href="classOperateur__base.html#a163b8e77d9ad86d8c0cdd28d29903538" title="Ouverture/creation d&#39;un fichier d&#39;impression d&#39;un operateur A surcharger dans les classes derivees...">ouvrir_fichier</a>(<a class="code" href="classOp__VEF__Face.html#a44c07f75ad3edafd7f840cfa4d2b92a9">Flux_sum</a>,<span class="stringliteral">&quot;sum&quot;</span>,impr_sum);

<span class="comment">// Write time</span>
      <a class="code" href="classOp__VEF__Face.html#af92615c52cc45fd48d495802fd2ba02f">Flux</a>.<a class="code" href="classSortie.html#aed397f2acfa499f2c34be9657a724de0">add_col</a>(sch.<a class="code" href="classSchema__Temps__base.html#a5054df01edb6d4f7baec7e612d423834" title="Renvoie le temps courant.">temps_courant</a>());
      <span class="keywordflow">if</span> (impr_mom) <a class="code" href="classOp__VEF__Face.html#a426500a12aa34bc34e10dd494d0701b3">Flux_moment</a>.<a class="code" href="classSortie.html#aed397f2acfa499f2c34be9657a724de0">add_col</a>(sch.<a class="code" href="classSchema__Temps__base.html#a5054df01edb6d4f7baec7e612d423834" title="Renvoie le temps courant.">temps_courant</a>());
      <span class="keywordflow">if</span> (impr_sum) <a class="code" href="classOp__VEF__Face.html#a44c07f75ad3edafd7f840cfa4d2b92a9">Flux_sum</a>.<a class="code" href="classSortie.html#aed397f2acfa499f2c34be9657a724de0">add_col</a>(sch.<a class="code" href="classSchema__Temps__base.html#a5054df01edb6d4f7baec7e612d423834" title="Renvoie le temps courant.">temps_courant</a>());

<span class="comment">// Write flux on boundaries</span>
      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> num_cl=0; num_cl&lt;nb_cl; num_cl++)
        {
          <span class="keyword">const</span> <a class="code" href="classFrontiere__dis__base.html" title="classe Frontiere_dis_base Classe representant une frontiere discretisee. Les objets Frontiere_dis_bas...">Frontiere_dis_base</a>&amp; la_fr = op.<a class="code" href="classMorEqn.html#a615dd9abff96edcb625fa0424a489864" title="Renvoie la reference sur l&#39;equation pointe par MorEqn::mon_equation. (version const)">equation</a>().<a class="code" href="classEquation__base.html#af265fe0ea30868eb2176a0c887e4efab" title="Renvoie la zone des conditions aux limite discretisee associee a l&#39;equation.">zone_Cl_dis</a>().<a class="code" href="classZone__Cl__dis.html#aafbd0525703e23200e31796bcd4fcac6" title="Appel a l&#39;objet sous-jacent Renvoie la i-ieme condition aux limites. (version const)">les_conditions_limites</a>(num_cl).<a class="code" href="classCond__lim.html#a5b2d24809cee07727006a891d4ce8d22" title="Appel a l&#39;objet sous-jacent Renvoie la frontiere discretisee associee a la condition aux limites...">frontiere_dis</a>();
          <span class="keyword">const</span> <a class="code" href="classCond__lim.html" title="classe Cond_lim Classe generique servant a representer n&#39;importe quelle classe derivee de la classe C...">Cond_lim</a>&amp; la_cl = op.<a class="code" href="classMorEqn.html#a615dd9abff96edcb625fa0424a489864" title="Renvoie la reference sur l&#39;equation pointe par MorEqn::mon_equation. (version const)">equation</a>().<a class="code" href="classEquation__base.html#af265fe0ea30868eb2176a0c887e4efab" title="Renvoie la zone des conditions aux limite discretisee associee a l&#39;equation.">zone_Cl_dis</a>().<a class="code" href="classZone__Cl__dis.html#aafbd0525703e23200e31796bcd4fcac6" title="Appel a l&#39;objet sous-jacent Renvoie la i-ieme condition aux limites. (version const)">les_conditions_limites</a>(num_cl);
          <span class="keywordtype">int</span> perio = (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>())?1:0);
          <span class="keywordflow">for</span>(<span class="keywordtype">int</span> k=0; k&lt;nb_compo; k++)
            {
              <span class="keywordflow">if</span>(perio)
                {
                  <a class="code" href="classOp__VEF__Face.html#af92615c52cc45fd48d495802fd2ba02f">Flux</a>.<a class="code" href="classSortie.html#aed397f2acfa499f2c34be9657a724de0">add_col</a>(flux_bords(1,num_cl,k));
                  <a class="code" href="classOp__VEF__Face.html#af92615c52cc45fd48d495802fd2ba02f">Flux</a>.<a class="code" href="classSortie.html#aed397f2acfa499f2c34be9657a724de0">add_col</a>(flux_bords(2,num_cl,k));
                }
              <span class="keywordflow">else</span>
                <a class="code" href="classOp__VEF__Face.html#af92615c52cc45fd48d495802fd2ba02f">Flux</a>.<a class="code" href="classSortie.html#aed397f2acfa499f2c34be9657a724de0">add_col</a>(flux_bords(0,num_cl,k));
              <span class="keywordflow">if</span> (impr_mom) <a class="code" href="classOp__VEF__Face.html#a426500a12aa34bc34e10dd494d0701b3">Flux_moment</a>.<a class="code" href="classSortie.html#aed397f2acfa499f2c34be9657a724de0">add_col</a>(flux_bords(3,num_cl,k));
              <span class="keywordflow">if</span> (la_zone_vef.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#aa5780fa644b13f8172c4805336846dec">Bords_a_imprimer_sum</a>().<a class="code" href="classList__Nom.html#aafe66fe06c0dd82cb2641fcaf774db07">contient</a>(la_fr.<a class="code" href="classFrontiere__dis__base.html#a5a7eb46dc3af8a7d4225adc1814845d8" title="Renvoie le nom de la frontiere geometrique.">le_nom</a>())) <a class="code" href="classOp__VEF__Face.html#a44c07f75ad3edafd7f840cfa4d2b92a9">Flux_sum</a>.<a class="code" href="classSortie.html#aed397f2acfa499f2c34be9657a724de0">add_col</a>(flux_bords(0,num_cl,k));

<span class="comment">// On somme les flux de toutes les frontieres pour mettre dans le tableau bilan</span>
              bilan(k)+=flux_bords(0,num_cl,k);
            }
        }

<span class="comment">// On imprime les bilans et on va a la ligne</span>
      <span class="keywordflow">for</span>(<span class="keywordtype">int</span> k=0; k&lt;nb_compo; k++)
        <a class="code" href="classOp__VEF__Face.html#af92615c52cc45fd48d495802fd2ba02f">Flux</a>.<a class="code" href="classSortie.html#aed397f2acfa499f2c34be9657a724de0">add_col</a>(bilan(k));
      <a class="code" href="classOp__VEF__Face.html#af92615c52cc45fd48d495802fd2ba02f">Flux</a> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
      <span class="keywordflow">if</span> (impr_mom) <a class="code" href="classOp__VEF__Face.html#a426500a12aa34bc34e10dd494d0701b3">Flux_moment</a> &lt;&lt; finl;
      <span class="keywordflow">if</span> (impr_sum) <a class="code" href="classOp__VEF__Face.html#a44c07f75ad3edafd7f840cfa4d2b92a9">Flux_sum</a> &lt;&lt; finl;
    }

  <span class="keyword">const</span> <a class="code" href="List_8h.html#a3149526fb499ddb08728c87daa32c5ad">LIST</a>(<a class="code" href="classNom.html" title="class Nom Une chaine de caractere pour nommer les objets de TRUST">Nom</a>)&amp; Liste_Bords_a_imprimer = la_zone_vef.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#a2e4f80965f20d39334b470af7aec494a">Bords_a_imprimer</a>();
  <span class="keywordflow">if</span> (!Liste_Bords_a_imprimer.est_vide())
    {
      <a class="code" href="classEcrFicPartage.html">EcrFicPartage</a> Flux_face;
      op.<a class="code" href="classOperateur__base.html#a75f3b320ba6d2b58ab1a43a10f317de4" title="Ouverture/creation d&#39;un fichier d&#39;impression d&#39;un operateur A surcharger dans les classes derivees...">ouvrir_fichier_partage</a>(Flux_face,<span class="stringliteral">&quot;&quot;</span>,impr_bord);
<span class="comment">// Impression sur chaque face si demande</span>
      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> num_cl=0; num_cl&lt;nb_cl; num_cl++)
        {
          <span class="keyword">const</span> <a class="code" href="classFrontiere__dis__base.html" title="classe Frontiere_dis_base Classe representant une frontiere discretisee. Les objets Frontiere_dis_bas...">Frontiere_dis_base</a>&amp; la_fr = op.<a class="code" href="classMorEqn.html#a615dd9abff96edcb625fa0424a489864" title="Renvoie la reference sur l&#39;equation pointe par MorEqn::mon_equation. (version const)">equation</a>().<a class="code" href="classEquation__base.html#af265fe0ea30868eb2176a0c887e4efab" title="Renvoie la zone des conditions aux limite discretisee associee a l&#39;equation.">zone_Cl_dis</a>().<a class="code" href="classZone__Cl__dis.html#aafbd0525703e23200e31796bcd4fcac6" title="Appel a l&#39;objet sous-jacent Renvoie la i-ieme condition aux limites. (version const)">les_conditions_limites</a>(num_cl).<a class="code" href="classCond__lim.html#a5b2d24809cee07727006a891d4ce8d22" title="Appel a l&#39;objet sous-jacent Renvoie la frontiere discretisee associee a la condition aux limites...">frontiere_dis</a>();
          <span class="keyword">const</span> <a class="code" href="classCond__lim.html" title="classe Cond_lim Classe generique servant a representer n&#39;importe quelle classe derivee de la classe C...">Cond_lim</a>&amp; la_cl = op.<a class="code" href="classMorEqn.html#a615dd9abff96edcb625fa0424a489864" title="Renvoie la reference sur l&#39;equation pointe par MorEqn::mon_equation. (version const)">equation</a>().<a class="code" href="classEquation__base.html#af265fe0ea30868eb2176a0c887e4efab" title="Renvoie la zone des conditions aux limite discretisee associee a l&#39;equation.">zone_Cl_dis</a>().<a class="code" href="classZone__Cl__dis.html#aafbd0525703e23200e31796bcd4fcac6" title="Appel a l&#39;objet sous-jacent Renvoie la i-ieme condition aux limites. (version const)">les_conditions_limites</a>(num_cl);
          <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp; frontiere_dis = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>,la_cl.<a class="code" href="classCond__lim.html#a5b2d24809cee07727006a891d4ce8d22" title="Appel a l&#39;objet sous-jacent Renvoie la frontiere discretisee associee a la condition aux limites...">frontiere_dis</a>());
          <span class="keywordtype">int</span> ndeb = frontiere_dis.<a class="code" href="classFront__VF.html#a4986f0c65653fe9eb40bbbff5a97bf16" title="Numero de la premiere face du bord dans la liste des faces.">num_premiere_face</a>();
          <span class="keywordtype">int</span> nfin = ndeb + frontiere_dis.<a class="code" href="classFront__VF.html#a341e2fcb5117b96e745fd7078ba86bab" title="Nombre de faces reelles du bord.">nb_faces</a>();
<span class="comment">// Impression sur chaque face</span>
          <span class="keywordflow">if</span> (Liste_Bords_a_imprimer.contient(la_fr.<a class="code" href="classFrontiere__dis__base.html#a5a7eb46dc3af8a7d4225adc1814845d8" title="Renvoie le nom de la frontiere geometrique.">le_nom</a>()))
            {
              Flux_face &lt;&lt; <span class="stringliteral">&quot;# Flux par face sur &quot;</span> &lt;&lt; la_fr.<a class="code" href="classFrontiere__dis__base.html#a5a7eb46dc3af8a7d4225adc1814845d8" title="Renvoie le nom de la frontiere geometrique.">le_nom</a>() &lt;&lt; <span class="stringliteral">&quot; au temps &quot;</span>;
              sch.<a class="code" href="classSchema__Temps__base.html#afb4a13da2e8149defb5339ef005ef231">imprimer_temps_courant</a>(Flux_face);
              Flux_face &lt;&lt; <span class="stringliteral">&quot; : &quot;</span> &lt;&lt; finl;
              <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; xv=la_zone_vef.<a class="code" href="classZone__VF.html#a918c0885a9b67317fcce3a0535306542">xv</a>();
              <span class="keywordflow">for</span> (<span class="keywordtype">int</span> face=ndeb; face&lt;nfin; face++)
                {
                  <span class="keywordflow">if</span> (Objet_U::dimension==2)
                    Flux_face &lt;&lt; <span class="stringliteral">&quot;# Face a x= &quot;</span> &lt;&lt; xv(face,0) &lt;&lt; <span class="stringliteral">&quot; y= &quot;</span> &lt;&lt; xv(face,1) ;
                  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (Objet_U::dimension==3)
                    Flux_face &lt;&lt; <span class="stringliteral">&quot;# Face a x= &quot;</span> &lt;&lt; xv(face,0) &lt;&lt; <span class="stringliteral">&quot; y= &quot;</span> &lt;&lt; xv(face,1) &lt;&lt; <span class="stringliteral">&quot; z= &quot;</span> &lt;&lt; xv(face,2) ;
                  <span class="keywordflow">for</span>(<span class="keywordtype">int</span> k=0; k&lt;nb_compo; k++)
                    Flux_face &lt;&lt; <span class="stringliteral">&quot; surface_face(m2)= &quot;</span> &lt;&lt; la_zone_vef.<a class="code" href="classZone__VF.html#a40c3382b189a4fc508cf1c3e37b04b21">face_surfaces</a>(face) &lt;&lt; <span class="stringliteral">&quot; flux_par_surface(W/m2)= &quot;</span>  &lt;&lt; flux_bords_(face, k)/la_zone_vef.<a class="code" href="classZone__VF.html#a40c3382b189a4fc508cf1c3e37b04b21">face_surfaces</a>(face) &lt;&lt; <span class="stringliteral">&quot; flux(W)= &quot;</span> &lt;&lt; flux_bords_(face, k)  ;
                  Flux_face &lt;&lt; finl;
                }
              Flux_face.<a class="code" href="classEcrFicPartage.html#a76131150f8293c86eb36f4b45125183d" title="Provoque l&#39;ecriture sur disque des donnees accumulees sur les differents processeurs depuis le dernie...">syncfile</a>();
            }
        }
    }
  <span class="keywordflow">return</span> 1;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a6c8ce571769b4f2e20b07cbb7a6944f2"></a><!-- doxytag: member="Op_VEF_Face::modifier_flux" ref="a6c8ce571769b4f2e20b07cbb7a6944f2" args="(const Operateur_base &amp;) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Op_VEF_Face::modifier_flux </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOperateur__base.html">Operateur_base</a> &amp;&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Op__VEF__Face_8cpp_source.html#l00384">384</a> of file <a class="el" href="Op__VEF__Face_8cpp_source.html">Op_VEF_Face.cpp</a>.</p>

<p>References <a class="el" href="Op__VEF__Face_8h_source.html#l00047">controle_modifier_flux_</a>, <a class="el" href="Nom_8cpp_source.html#l00453">Nom::debute_par()</a>, <a class="el" href="DoubleTab_8h_source.html#l00243">DoubleTab::dimension()</a>, <a class="el" href="MorEqn_8h_source.html#l00082">MorEqn::equation()</a>, <a class="el" href="Operateur__base_8h_source.html#l00130">Operateur_base::flux_bords()</a>, <a class="el" href="classEquation__base.html#a5a1fce9487b9a8dd17020914100c2c89">Equation_base::inconnue()</a>, <a class="el" href="Probleme__base_8cpp_source.html#l01914">Probleme_base::is_dilatable()</a>, <a class="el" href="O__U__Ptr_8cpp_source.html#l00179">O_U_Ptr::le_nom()</a>, <a class="el" href="Milieu__base_8cpp_source.html#l00560">Milieu_base::masse_volumique()</a>, <a class="el" href="classEquation__base.html#a181e9899e2d927eb14c835d9d9334f46">Equation_base::milieu()</a>, <a class="el" href="Probleme__base_8cpp_source.html#l01493">Probleme_base::milieu()</a>, <a class="el" href="Field__base_8h_source.html#l00119">Field_base::nb_comp()</a>, <a class="el" href="Champ__Don_8h_source.html#l00183">Champ_Don::nb_comp()</a>, <a class="el" href="DoubleTab_8h_source.html#l00264">DoubleTab::nb_dim()</a>, <a class="el" href="Zone__VF_8h_source.html#l00547">Zone_VF::nb_faces_bord()</a>, <a class="el" href="Equation__base_8cpp_source.html#l00964">Equation_base::probleme()</a>, <a class="el" href="Objet__U_8cpp_source.html#l00132">Objet_U::que_suis_je()</a>, <a class="el" href="Cast_8h_source.html#l00059">ref_cast</a>, <a class="el" href="Cast_8h_source.html#l00054">sub_type</a>, <a class="el" href="Champ__Don_8h_source.html#l00030">Deriv_Champ_Don_base::valeur()</a>, <a class="el" href="Zone__dis_8h_source.html#l00029">Deriv_Zone_dis_base::valeur()</a>, and <a class="el" href="Equation__base_8cpp_source.html#l00091">Equation_base::zone_dis()</a>.</p>

<p>Referenced by <a class="el" href="Op__Dift__VEF__Face__Q1_8cpp_source.html#l00143">Op_Dift_VEF_Face_Q1::ajouter()</a>, <a class="el" href="Op__Dift__VEF__Face_8cpp_source.html#l00951">Op_Dift_VEF_Face::ajouter()</a>, <a class="el" href="Op__Dift__standard__VEF__Face_8cpp_source.html#l00323">Op_Dift_standard_VEF_Face::ajouter()</a>, <a class="el" href="Op__Dift__Stab__VEF__Face_8cpp_source.html#l00170">Op_Dift_Stab_VEF_Face::ajouter()</a>, <a class="el" href="Op__Diff__VEF__Face__Stab_8cpp_source.html#l00145">Op_Diff_VEF_Face_Stab::ajouter()</a>, <a class="el" href="Op__Diff__VEF__Face__Q1_8cpp_source.html#l00114">Op_Diff_VEF_Face_Q1::ajouter()</a>, <a class="el" href="Op__Diff__VEF__Face_8cpp_source.html#l00616">Op_Diff_VEF_Face::ajouter()</a>, <a class="el" href="Op__Diff__VEF__Anisotrope__Face_8cpp_source.html#l00492">Op_Diff_VEF_Anisotrope_Face::ajouter()</a>, <a class="el" href="Op__Conv__Vort__VEF__Face_8cpp_source.html#l00046">Op_Conv_Vort_VEF_Face::ajouter()</a>, <a class="el" href="Op__Conv__VEF__Face_8cpp_source.html#l00121">Op_Conv_VEF_Face::ajouter()</a>, <a class="el" href="Op__Conv__Muscl__old__VEF__Face_8cpp_source.html#l00081">Op_Conv_Muscl_old_VEF_Face::ajouter()</a>, <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8cpp_source.html#l01029">Op_Conv_Muscl_New_VEF_Face::ajouter()</a>, <a class="el" href="Op__Conv__kschemas__VEF_8cpp_source.html#l00173">Op_Conv_kschemas_VEF::ajouter()</a>, <a class="el" href="Op__Conv__kschemas__centre__VEF_8cpp_source.html#l00175">Op_Conv_kschemas_centre_VEF::ajouter()</a>, <a class="el" href="Op__Conv__EF__VEF__P1NC__Stab_8cpp_source.html#l00551">Op_Conv_EF_VEF_P1NC_Stab::ajouter()</a>, <a class="el" href="Op__Conv__EF__VEF__P1NC_8cpp_source.html#l00109">Op_Conv_EF_VEF_P1NC::ajouter()</a>, <a class="el" href="Op__Conv__DI__L2__VEF__Face_8cpp_source.html#l00409">Op_Conv_DI_L2_VEF_Face::ajouter()</a>, <a class="el" href="Op__Conv__Centre__old__VEF__Face_8cpp_source.html#l00063">Op_Conv_Centre_old_VEF_Face::ajouter()</a>, <a class="el" href="Op__Conv__Centre__EF__VEF__Face_8cpp_source.html#l00056">Op_Conv_Centre_EF_VEF_Face::ajouter()</a>, <a class="el" href="Op__Conv__AmontNew__VEF__Face_8cpp_source.html#l00083">Op_Conv_AmontNew_VEF_Face::ajouter()</a>, <a class="el" href="Op__Conv__Amont__old__VEF__Face_8cpp_source.html#l00113">Op_Conv_Amont_old_VEF_Face::ajouter()</a>, <a class="el" href="Op__Dift__VEF__P1NCP1B__Face_8cpp_source.html#l00537">Op_Dift_VEF_P1NCP1B_Face::ajouter()</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l01002">Op_Diff_VEFP1NCP1B_Face::ajouter()</a>, and <a class="el" href="Op__Diff__P1NC__barprim_8cpp_source.html#l00200">Op_Diff_P1NC_barprim::calculer()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <a class="code" href="classOp__VEF__Face.html#a74453359874aa3d466f3df50684236a3">controle_modifier_flux_</a>=1;
  <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; flux_bords_=op.<a class="code" href="classOperateur__base.html#ab547b37ace0f04931f6f09fcfa8fae0c">flux_bords</a>();
  <span class="keywordflow">if</span> (flux_bords_.<a class="code" href="classDoubleTab.html#ae6dda48778e7107e1beb723beef1f75b" title="Returns the number of dimensions of the array (&gt;= 1)">nb_dim</a>()!=2)
    <span class="keywordflow">return</span>;
  <span class="keyword">const</span> <a class="code" href="classProbleme__base.html" title="classe Probleme_base C&#39;est un Probleme_U qui n&#39;est pas un couplage. Le role d&#39;un Probleme_base est la...">Probleme_base</a>&amp; pb=op.<a class="code" href="classMorEqn.html#a615dd9abff96edcb625fa0424a489864" title="Renvoie la reference sur l&#39;equation pointe par MorEqn::mon_equation. (version const)">equation</a>().<a class="code" href="classEquation__base.html#aa8151a96f63719523bf50ddd832e0f8f" title="Renvoie le probleme associe a l&#39;equation.">probleme</a>();

  <span class="keyword">const</span> <a class="code" href="classZone__VEF.html" title="class Zone_VEF Classe instanciable qui derive de Zone_VF. Cette classe contient les informations geom...">Zone_VEF</a>&amp; la_zone_vef=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classZone__VEF.html" title="class Zone_VEF Classe instanciable qui derive de Zone_VF. Cette classe contient les informations geom...">Zone_VEF</a>,op.<a class="code" href="classMorEqn.html#a615dd9abff96edcb625fa0424a489864" title="Renvoie la reference sur l&#39;equation pointe par MorEqn::mon_equation. (version const)">equation</a>().<a class="code" href="classEquation__base.html#a12d97ae801edc18f614523677921346e" title="Renvoie la zone discretisee associee a l&#39;equation.">zone_dis</a>().<a class="code" href="classDeriv__Zone__dis__base.html#a30ff47fc0684fe134e8c74c35b268941">valeur</a>());
  <span class="keywordtype">int</span> nb_compo=flux_bords_.<a class="code" href="classDoubleTab.html#ac3805e2637a3b880ba2d3e650c69dac4" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(1);
<span class="comment">// On multiplie le flux au bord par rho*Cp sauf si c&#39;est un operateur de diffusion avec la conductivite comme champ</span>
  <span class="keywordflow">if</span> (op.<a class="code" href="classMorEqn.html#a615dd9abff96edcb625fa0424a489864" title="Renvoie la reference sur l&#39;equation pointe par MorEqn::mon_equation. (version const)">equation</a>().<a class="code" href="classEquation__base.html#a5a1fce9487b9a8dd17020914100c2c89">inconnue</a>().<a class="code" href="classO__U__Ptr.html#a5aae0c48048a40339f3847aa14109231" title="Renvoie ref_().le_nom() si le pointeur est non nul ou &quot;Pointeur Nul&quot;.">le_nom</a>()==<span class="stringliteral">&quot;temperature&quot;</span>
      &amp;&amp; !( <a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classOperateur__Diff__base.html" title="classe Operateur_Diff_base Cette classe est la base de la hierarchie des operateurs representant un t...">Operateur_Diff_base</a>,op) &amp;&amp; <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classOperateur__Diff__base.html" title="classe Operateur_Diff_base Cette classe est la base de la hierarchie des operateurs representant un t...">Operateur_Diff_base</a>,op).diffusivite().le_nom() == <span class="stringliteral">&quot;conductivite&quot;</span> ) )
    {
      <span class="keyword">const</span> <a class="code" href="classChamp__base.html" title="classe Champ_base Cette classe est la base de la hierarchie des champs. Ses membres sont les attribut...">Champ_base</a>&amp; rho = (op.<a class="code" href="classMorEqn.html#a615dd9abff96edcb625fa0424a489864" title="Renvoie la reference sur l&#39;equation pointe par MorEqn::mon_equation. (version const)">equation</a>()).milieu().masse_volumique();
      <span class="keyword">const</span> <a class="code" href="classChamp__Don.html" title="classe Champ_Don Classe generique de la hierarchie des champs donnes, un objet Champ_Don peut referen...">Champ_Don</a>&amp; Cp = (op.<a class="code" href="classMorEqn.html#a615dd9abff96edcb625fa0424a489864" title="Renvoie la reference sur l&#39;equation pointe par MorEqn::mon_equation. (version const)">equation</a>()).milieu().capacite_calorifique();
      <span class="keywordtype">int</span> rho_uniforme=(<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classChamp__Uniforme.html" title="classe Champ_Uniforme Represente un champ constant dans l&#39;espace et dans le temps.">Champ_Uniforme</a>,rho) ? 1:0);
      <span class="keywordtype">int</span> cp_uniforme=(<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classChamp__Uniforme.html" title="classe Champ_Uniforme Represente un champ constant dans l&#39;espace et dans le temps.">Champ_Uniforme</a>,Cp.<a class="code" href="classDeriv__Champ__Don__base.html#ae16e7e2a7a706352781c5ecc7764703d">valeur</a>()) ? 1:0);
      <span class="keywordtype">double</span> Cp_=0,rho_=0;
      <span class="keywordtype">int</span> is_rho_u=pb.<a class="code" href="classProbleme__base.html#a4ef1cb4c4eed0aab75358ab7a91e29db">is_dilatable</a>();
      <span class="keywordflow">if</span> (is_rho_u)
        {
          is_rho_u=0;
          <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classOp__Conv__VEF__base.html" title="class Op_Conv_VEF_base Classe de base des operateurs de convection VEF">Op_Conv_VEF_base</a>,op))
            {
              <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classOp__Conv__VEF__base.html" title="class Op_Conv_VEF_base Classe de base des operateurs de convection VEF">Op_Conv_VEF_base</a>,op).vitesse().le_nom()==<span class="stringliteral">&quot;rho_u&quot;</span>)
                is_rho_u=1;
            }
        }
      <span class="keyword">const</span> <span class="keywordtype">int</span>&amp; nb_faces_bords=la_zone_vef.<a class="code" href="classZone__VF.html#a8815e2276637c0db23868f043dc43e58" title="renvoie le nombre de faces sur lesquelles sont appliquees les conditions limites : bords...">nb_faces_bord</a>();
      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> face=0; face&lt;nb_faces_bords; face++)
        {
          <span class="keywordflow">if</span> (cp_uniforme) Cp_=Cp(0,0);
          <span class="keywordflow">else</span>
            {
              <span class="keywordflow">if</span> (Cp.<a class="code" href="classChamp__Don.html#aa0b82f09287c5934333d540ef77e0059" title="Appel a l&#39;objet sous-jacent Renvoie le nombre de composantes du champ.">nb_comp</a>()==1) Cp_=Cp(face);
              <span class="keywordflow">else</span> Cp_=Cp(face,0);
            }
          <span class="keywordflow">if</span> (rho_uniforme) rho_=rho(0,0);
          <span class="keywordflow">else</span>
            {
              <span class="keywordflow">if</span> (rho.<a class="code" href="classField__base.html#a16e3abfebaaf9b7ef83acb936c872a91" title="Renvoie le nombre de composantes du champ.">nb_comp</a>()==1) rho_=rho(face);
              <span class="keywordflow">else</span> rho_=rho(face,0);
            }
<span class="comment">// si on est en QC temperature et si on a calcule div(rhou * T)</span>
<span class="comment">// il ne faut pas remultiplier par rho</span>
          <span class="keywordflow">if</span> (is_rho_u) rho_=1;
          flux_bords_(face,0) *= (rho_*Cp_);
        }
    }


<span class="comment">// On multiplie par rho si Navier Stokes incompressible</span>
  <a class="code" href="classNom.html" title="class Nom Une chaine de caractere pour nommer les objets de TRUST">Nom</a> nom_eqn=op.<a class="code" href="classMorEqn.html#a615dd9abff96edcb625fa0424a489864" title="Renvoie la reference sur l&#39;equation pointe par MorEqn::mon_equation. (version const)">equation</a>().<a class="code" href="classObjet__U.html#aa58e9a81c0ddc2c1149053b8f96698ac" title="renvoie la chaine identifiant la classe.">que_suis_je</a>();
  <span class="keywordflow">if</span> (nom_eqn.<a class="code" href="classNom.html#a41b0ba18fb90d481c0828ed4372de8ee">debute_par</a>(<span class="stringliteral">&quot;Navier_Stokes&quot;</span>) &amp;&amp; pb.<a class="code" href="classProbleme__base.html#aa51e16d0fb82fdce0019358267307d18" title="Renvoie le milieu physique associe au probleme. (version const) On renvoie le milieu associe a la pre...">milieu</a>().<a class="code" href="classObjet__U.html#aa58e9a81c0ddc2c1149053b8f96698ac" title="renvoie la chaine identifiant la classe.">que_suis_je</a>()==<span class="stringliteral">&quot;Fluide_Incompressible&quot;</span>)
    {
      <span class="keyword">const</span> <a class="code" href="classChamp__base.html" title="classe Champ_base Cette classe est la base de la hierarchie des champs. Ses membres sont les attribut...">Champ_base</a>&amp; rho = op.<a class="code" href="classMorEqn.html#a615dd9abff96edcb625fa0424a489864" title="Renvoie la reference sur l&#39;equation pointe par MorEqn::mon_equation. (version const)">equation</a>().<a class="code" href="classEquation__base.html#a181e9899e2d927eb14c835d9d9334f46">milieu</a>().<a class="code" href="classMilieu__base.html#a46a9a4bfb046ed22d0f267b6c052889f" title="Renvoie la masse volumique du milieu. (version const)">masse_volumique</a>();
      <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classChamp__Uniforme.html" title="classe Champ_Uniforme Represente un champ constant dans l&#39;espace et dans le temps.">Champ_Uniforme</a>,rho))
        {
          <span class="keywordtype">double</span> coef = rho(0,0);
          <span class="keywordtype">int</span> nb_faces_bord=la_zone_vef.<a class="code" href="classZone__VF.html#a8815e2276637c0db23868f043dc43e58" title="renvoie le nombre de faces sur lesquelles sont appliquees les conditions limites : bords...">nb_faces_bord</a>();
          <span class="keywordflow">for</span> (<span class="keywordtype">int</span> face=0; face&lt;nb_faces_bord; face++)
            <span class="keywordflow">for</span>(<span class="keywordtype">int</span> k=0; k&lt;nb_compo; k++)
              flux_bords_(face,k) *= coef;
        }
    }

}
</pre></div>
</div>
</div>
<a class="anchor" id="a00a9703ef92c279f100fa3872cc8ec09"></a><!-- doxytag: member="Op_VEF_Face::modifier_matrice_pour_periodique_apres_contribuer" ref="a00a9703ef92c279f100fa3872cc8ec09" args="(Matrice_Morse &amp;matrice, const Equation_base &amp;) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Op_VEF_Face::modifier_matrice_pour_periodique_apres_contribuer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;&#160;</td>
          <td class="paramname"><em>matrice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEquation__base.html">Equation_base</a> &amp;&#160;</td>
          <td class="paramname"><em>eqn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Somme les 2 lignes des faces periodiques associees<br/>
permet de calculer dans le code sans se poser de question pour retrouver la face_associee<br/>
on ne parcourt que la moitiee des faces periodiques dans contribuer_a_avec (en general). </p>

<p>Definition at line <a class="el" href="Op__VEF__Face_8cpp_source.html#l00792">792</a> of file <a class="el" href="Op__VEF__Face_8cpp_source.html">Op_VEF_Face.cpp</a>.</p>

<p>References <a class="el" href="EntreeSortie_8h_source.html#l00032">Cerr</a>, <a class="el" href="Process_8cpp_source.html#l00223">Process::exit()</a>, <a class="el" href="Periodique_8h_source.html#l00056">Periodique::face_associee()</a>, <a class="el" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>, <a class="el" href="Cond__lim_8h_source.html#l00130">Cond_lim::frontiere_dis()</a>, <a class="el" href="Matrice__Morse_8h_source.html#l00134">Matrice_Morse::get_tab1()</a>, <a class="el" href="Matrice__Morse_8h_source.html#l00138">Matrice_Morse::get_tab2()</a>, <a class="el" href="classEquation__base.html#a5a1fce9487b9a8dd17020914100c2c89">Equation_base::inconnue()</a>, <a class="el" href="Zone__Cl__dis__base_8cpp_source.html#l00522">Zone_Cl_dis_base::les_conditions_limites()</a>, <a class="el" href="DoubleVect_8h_source.html#l00164">DoubleVect::line_size()</a>, <a class="el" href="Op__VEF__Face_8cpp_source.html#l00698">modif_matrice_pour_periodique_apres_contribuer()</a>, <a class="el" href="Front__VF_8h_source.html#l00061">Front_VF::nb_faces()</a>, <a class="el" href="Zone__dis__base_8h_source.html#l00156">Zone_dis_base::nb_front_Cl()</a>, <a class="el" href="Front__VF_8h_source.html#l00071">Front_VF::num_premiere_face()</a>, <a class="el" href="Cast_8h_source.html#l00059">ref_cast</a>, <a class="el" href="Cast_8h_source.html#l00054">sub_type</a>, <a class="el" href="Op__Grad__EF_8cpp_source.html#l00099">test()</a>, <a class="el" href="Cond__lim_8h_source.html#l00031">Deriv_Cond_lim_base::valeur()</a>, <a class="el" href="Zone__dis_8h_source.html#l00029">Deriv_Zone_dis_base::valeur()</a>, <a class="el" href="Zone__Cl__dis_8h_source.html#l00032">Deriv_Zone_Cl_dis_base::valeur()</a>, <a class="el" href="Champ__Inc_8cpp_source.html#l00245">Champ_Inc::valeurs()</a>, <a class="el" href="Equation__base_8h_source.html#l00391">Equation_base::zone_Cl_dis()</a>, and <a class="el" href="Equation__base_8cpp_source.html#l00091">Equation_base::zone_dis()</a>.</p>

<p>Referenced by <a class="el" href="Op__Dift__VEF__Face_8cpp_source.html#l01256">Op_Dift_VEF_Face::ajouter_contribution()</a>, <a class="el" href="Op__Dift__Stab__VEF__Face_8cpp_source.html#l01479">Op_Dift_Stab_VEF_Face::ajouter_contribution()</a>, <a class="el" href="Op__Diff__VEF__Face__Stab_8cpp_source.html#l00868">Op_Diff_VEF_Face_Stab::ajouter_contribution()</a>, <a class="el" href="Op__Diff__VEF__Face_8cpp_source.html#l00658">Op_Diff_VEF_Face::ajouter_contribution()</a>, <a class="el" href="Op__Diff__VEF__Anisotrope__Face_8cpp_source.html#l00532">Op_Diff_VEF_Anisotrope_Face::ajouter_contribution()</a>, <a class="el" href="Op__Conv__VEF__Face_8cpp_source.html#l00798">Op_Conv_VEF_Face::ajouter_contribution()</a>, <a class="el" href="Op__Dift__VEF__Face_8cpp_source.html#l01366">Op_Dift_VEF_Face::ajouter_contribution_multi_scalaire()</a>, <a class="el" href="Op__Dift__Stab__VEF__Face_8cpp_source.html#l01583">Op_Dift_Stab_VEF_Face::ajouter_contribution_multi_scalaire()</a>, <a class="el" href="Op__Diff__VEF__Face__Stab_8cpp_source.html#l01041">Op_Diff_VEF_Face_Stab::ajouter_contribution_multi_scalaire()</a>, <a class="el" href="Op__Diff__VEF__Face_8cpp_source.html#l00848">Op_Diff_VEF_Face::ajouter_contribution_multi_scalaire()</a>, and <a class="el" href="Op__Diff__VEF__Anisotrope__Face_8cpp_source.html#l00722">Op_Diff_VEF_Anisotrope_Face::ajouter_contribution_multi_scalaire()</a>.</p>
<div class="fragment"><pre class="fragment">{
<span class="comment">// si matrice_morse_diag pas de contribution n0 n0perio</span>
  <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classMatrice__Morse__Diag.html" title="Classe Matrice_Morse_Diag Represente une matrice M (creuse) symetrique stockee au format Morse Diaget...">Matrice_Morse_Diag</a>,matrice))
    <span class="keywordflow">return</span>;

  <a class="code" href="Op__VEF__Face_8cpp.html#a391616a83ba95e1cdf87f824a4aee93a">modif_matrice_pour_periodique_apres_contribuer</a>(matrice,eqn);

<span class="comment">// verification que la matrice est bien periodique</span>
<span class="preprocessor">#ifndef  NDEBUG</span>
<span class="preprocessor"></span>
  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_comp = eqn.<a class="code" href="classEquation__base.html#a5a1fce9487b9a8dd17020914100c2c89">inconnue</a>().<a class="code" href="classChamp__Inc.html#a28ef3d411d12cb5684ac5e799efb7d24" title="Appel a l&#39;objet sous-jacent Renvoie le tableau des valeurs au temps courant.">valeurs</a>().<a class="code" href="classDoubleVect.html#ab02d01cd1bdab66fbd66f9a47cc29e10">line_size</a>();

  <span class="keyword">const</span> <a class="code" href="classZone__Cl__dis__base.html" title="classe Zone_Cl_dis_base Les objets Zone_Cl_dis_base representent les conditions aux limites discretis...">Zone_Cl_dis_base</a>&amp; zone_Cl_VEF=eqn.<a class="code" href="classEquation__base.html#af265fe0ea30868eb2176a0c887e4efab" title="Renvoie la zone des conditions aux limite discretisee associee a l&#39;equation.">zone_Cl_dis</a>().<a class="code" href="classDeriv__Zone__Cl__dis__base.html#a6b56880f00b604e1f13970ec6d5bc077">valeur</a>();
  <span class="keyword">const</span> <a class="code" href="classZone__VF.html" title="class Zone_VF Cette classe abstraite contient les informations geometriques communes aux methodes de ...">Zone_VF</a>&amp; zone_VEF= <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classZone__VF.html" title="class Zone_VF Cette classe abstraite contient les informations geometriques communes aux methodes de ...">Zone_VF</a>,eqn.<a class="code" href="classEquation__base.html#a12d97ae801edc18f614523677921346e" title="Renvoie la zone discretisee associee a l&#39;equation.">zone_dis</a>().<a class="code" href="classDeriv__Zone__dis__base.html#a30ff47fc0684fe134e8c74c35b268941">valeur</a>());
  <span class="keywordtype">int</span> nb_bords=zone_VEF.<a class="code" href="classZone__dis__base.html#af22167d614644f55591a29c77eb1c009">nb_front_Cl</a>();

  <span class="keyword">const</span> <a class="code" href="classIntVect.html">IntVect</a>&amp; tab1=matrice.<a class="code" href="classMatrice__Morse.html#a79b4e334152850bd36e53478debf3061">get_tab1</a>();
  <span class="keyword">const</span> <a class="code" href="classIntVect.html">IntVect</a>&amp; tab2=matrice.<a class="code" href="classMatrice__Morse.html#a787b5a63f27063f9c891243d8f188cda">get_tab2</a>();

  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> n_bord=0; n_bord&lt;nb_bords; n_bord++)
    {
      <span class="keyword">const</span> <a class="code" href="classCond__lim.html" title="classe Cond_lim Classe generique servant a representer n&#39;importe quelle classe derivee de la classe C...">Cond_lim</a>&amp; la_cl = zone_Cl_VEF.<a class="code" href="classZone__Cl__dis__base.html#af75e0ed7786863e4d333bfb29d67c323" title="Renvoie la i-ieme condition aux limites. (version const)">les_conditions_limites</a>(n_bord);
      <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp; le_bord = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>,la_cl.<a class="code" href="classCond__lim.html#a5b2d24809cee07727006a891d4ce8d22" title="Appel a l&#39;objet sous-jacent Renvoie la frontiere discretisee associee a la condition aux limites...">frontiere_dis</a>());
      <span class="keywordtype">int</span> num1 = le_bord.<a class="code" href="classFront__VF.html#a4986f0c65653fe9eb40bbbff5a97bf16" title="Numero de la premiere face du bord dans la liste des faces.">num_premiere_face</a>();
<span class="comment">// int num2 = num1 + le_bord.nb_faces();</span>

      <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>()))
        {
          <span class="keyword">const</span> <a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>&amp; la_cl_perio = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>());
          <span class="keywordtype">int</span> fac_asso;
<span class="comment">// on ne parcourt que la moitie des faces periodiques</span>
<span class="comment">// on copiera a la fin le resultat dans la face associe..</span>
          <span class="keywordtype">int</span> num2=num1+le_bord.<a class="code" href="classFront__VF.html#a341e2fcb5117b96e745fd7078ba86bab" title="Nombre de faces reelles du bord.">nb_faces</a>()/2;
          <span class="keywordflow">for</span> (<span class="keywordtype">int</span> num_face=num1; num_face&lt;num2; num_face++)
            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> nc=0; nc&lt;nb_comp; nc++)
              {
                fac_asso = la_cl_perio.<a class="code" href="classPeriodique.html#a207b86556f199a63ea059b841851ca6a">face_associee</a>(num_face-num1)+num1;
                <span class="keywordtype">int</span>  n0=num_face*nb_comp+nc;
                <span class="keywordtype">int</span> n0perio=fac_asso*nb_comp+nc;
<span class="comment">// on verifie que les 2 lignes sont identiques ( sauf la case diagonale qui n&#39;est pas au meme endroit)</span>
                <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j=tab1[n0]-1; j&lt;tab1[n0+1]-1; j++)
                  {
                    <span class="keywordtype">int</span> c=tab2[j]-1;
                    <span class="keywordflow">if</span> ((c!=n0)&amp;&amp;(c!=n0perio))
                      {
                        <span class="keywordtype">double</span> <a class="code" href="Op__Grad__EF_8cpp.html#abc0897c211f7aa4541da5833388f868b">test</a>=matrice(n0,c)-matrice(n0perio,c);
                        <span class="keywordflow">if</span> (test!=0)
                          {
                            <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a>&lt;&lt; <span class="stringliteral">&quot;Pb matrice non periodique face&quot;</span>&lt;&lt;num_face&lt;&lt;<span class="stringliteral">&quot; composante &quot;</span>&lt;&lt;nc&lt;&lt;<span class="stringliteral">&quot; colonne &quot;</span> &lt;&lt;c&lt;&lt;<a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
                            <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a>&lt;&lt;<span class="stringliteral">&quot; diff &quot;</span>&lt;&lt;test&lt;&lt;<span class="stringliteral">&quot; coef1 &quot;</span>&lt;&lt;matrice(n0,c)&lt;&lt;<span class="stringliteral">&quot; coef2 &quot;</span>&lt;&lt;matrice(n0perio,c)&lt;&lt;finl;
                            <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">Process::exit</a>();
                          }
                      }
                  }
                <span class="keywordflow">if</span> ((matrice(n0,n0perio)!=0)||(matrice(n0perio,n0)!=0))
                  {
                    <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a>&lt;&lt; <span class="stringliteral">&quot;Pb matrice non periodique face&quot;</span>&lt;&lt;num_face&lt;&lt;<span class="stringliteral">&quot; composante &quot;</span>&lt;&lt;nc&lt;&lt;<a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
                    <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a>&lt;&lt;<span class="stringliteral">&quot; coef  non nul&quot;</span>&lt;&lt;matrice(n0,n0perio)&lt;&lt;<span class="stringliteral">&quot; &quot;</span>&lt;&lt;matrice(n0perio,n0)&lt;&lt;finl;
                    <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">Process::exit</a>();
                  }
                <span class="keywordflow">if</span> (matrice(n0,n0)!=matrice(n0perio,n0perio))
                  {
                    <span class="keywordtype">double</span> <a class="code" href="Op__Grad__EF_8cpp.html#abc0897c211f7aa4541da5833388f868b">test</a>= matrice(n0,n0perio)-matrice(n0perio,n0);
                    <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a>&lt;&lt; <span class="stringliteral">&quot;Pb matrice non periodique face&quot;</span>&lt;&lt;num_face&lt;&lt;<span class="stringliteral">&quot; composante &quot;</span>&lt;&lt;nc&lt;&lt;<a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
                    <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a>&lt;&lt;<span class="stringliteral">&quot; diff &quot;</span>&lt;&lt;test&lt;&lt;<span class="stringliteral">&quot; coef  different &quot;</span>&lt;&lt;matrice(n0,n0)&lt;&lt;<span class="stringliteral">&quot; &quot;</span>&lt;&lt;matrice(n0perio,n0perio)&lt;&lt;finl;
                    <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">Process::exit</a>();
                  }
              }
        }
    }

  <span class="comment">/*</span>
<span class="comment">    Matrice_Morse es(matrice);</span>
<span class="comment">    modif_matrice_pour_periodique_avant_contribuer(es,eqn);</span>
<span class="comment">    modif_matrice_pour_periodique_apres_contribuer(es,eqn);</span>
<span class="comment">    es.coeff_-=(matrice.coeff_);</span>
<span class="comment">    Cerr&lt;&lt;&quot; erreur apres modifier_matrice_pour_periodique_apres_contribuer&quot;&lt;&lt; mp_max_abs_vect(es.coeff_)&lt;&lt;finl;</span>
<span class="comment">    assert(mp_max_abs_vect(es.coeff_)&lt;1e-9);</span>
<span class="comment">  */</span>

<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>}
</pre></div>
</div>
</div>
<a class="anchor" id="ab66c49a837d41ba7e304a0efc484a5d5"></a><!-- doxytag: member="Op_VEF_Face::modifier_matrice_pour_periodique_avant_contribuer" ref="ab66c49a837d41ba7e304a0efc484a5d5" args="(Matrice_Morse &amp;matrice, const Equation_base &amp;) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Op_VEF_Face::modifier_matrice_pour_periodique_avant_contribuer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;&#160;</td>
          <td class="paramname"><em>matrice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEquation__base.html">Equation_base</a> &amp;&#160;</td>
          <td class="paramname"><em>eqn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>divise les coefficients sur les ligne des faces periodiques par 2 en prevision<br/>
de l'application modifier_matrice_pour_periodique_apres_contribuer qui va sommer les 2 lignes des faces periodiques associees </p>

<p>Definition at line <a class="el" href="Op__VEF__Face_8cpp_source.html#l00780">780</a> of file <a class="el" href="Op__VEF__Face_8cpp_source.html">Op_VEF_Face.cpp</a>.</p>

<p>References <a class="el" href="Op__VEF__Face_8cpp_source.html#l00634">modif_matrice_pour_periodique_avant_contribuer()</a>, and <a class="el" href="Cast_8h_source.html#l00054">sub_type</a>.</p>

<p>Referenced by <a class="el" href="Op__Dift__VEF__Face_8cpp_source.html#l01256">Op_Dift_VEF_Face::ajouter_contribution()</a>, <a class="el" href="Op__Dift__Stab__VEF__Face_8cpp_source.html#l01479">Op_Dift_Stab_VEF_Face::ajouter_contribution()</a>, <a class="el" href="Op__Diff__VEF__Face__Stab_8cpp_source.html#l00868">Op_Diff_VEF_Face_Stab::ajouter_contribution()</a>, <a class="el" href="Op__Diff__VEF__Face_8cpp_source.html#l00658">Op_Diff_VEF_Face::ajouter_contribution()</a>, <a class="el" href="Op__Diff__VEF__Anisotrope__Face_8cpp_source.html#l00532">Op_Diff_VEF_Anisotrope_Face::ajouter_contribution()</a>, <a class="el" href="Op__Conv__VEF__Face_8cpp_source.html#l00798">Op_Conv_VEF_Face::ajouter_contribution()</a>, <a class="el" href="Op__Dift__VEF__Face_8cpp_source.html#l01366">Op_Dift_VEF_Face::ajouter_contribution_multi_scalaire()</a>, <a class="el" href="Op__Dift__Stab__VEF__Face_8cpp_source.html#l01583">Op_Dift_Stab_VEF_Face::ajouter_contribution_multi_scalaire()</a>, <a class="el" href="Op__Diff__VEF__Face__Stab_8cpp_source.html#l01041">Op_Diff_VEF_Face_Stab::ajouter_contribution_multi_scalaire()</a>, <a class="el" href="Op__Diff__VEF__Face_8cpp_source.html#l00848">Op_Diff_VEF_Face::ajouter_contribution_multi_scalaire()</a>, and <a class="el" href="Op__Diff__VEF__Anisotrope__Face_8cpp_source.html#l00722">Op_Diff_VEF_Anisotrope_Face::ajouter_contribution_multi_scalaire()</a>.</p>
<div class="fragment"><pre class="fragment">{
<span class="comment">// si matrice_morse_diag pas de contribution n0 n0perio</span>
  <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classMatrice__Morse__Diag.html" title="Classe Matrice_Morse_Diag Represente une matrice M (creuse) symetrique stockee au format Morse Diaget...">Matrice_Morse_Diag</a>,matrice))
    <span class="keywordflow">return</span>;
  <a class="code" href="Op__VEF__Face_8cpp.html#ae97f4d93d8832fbe585efe7a040ad6d5">modif_matrice_pour_periodique_avant_contribuer</a>(matrice,eqn);
}
</pre></div>
</div>
</div>
<a class="anchor" id="a102d8127171d25eb197fc70e710790ea"></a><!-- doxytag: member="Op_VEF_Face::modifier_pour_Cl" ref="a102d8127171d25eb197fc70e710790ea" args="(const Zone_VEF &amp;, const Zone_Cl_VEF &amp;, Matrice_Morse &amp;, DoubleTab &amp;) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Op_VEF_Face::modifier_pour_Cl </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classZone__VEF.html">Zone_VEF</a> &amp;&#160;</td>
          <td class="paramname"><em>la_zone</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classZone__Cl__VEF.html">Zone_Cl_VEF</a> &amp;&#160;</td>
          <td class="paramname"><em>la_zone_cl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;&#160;</td>
          <td class="paramname"><em>la_matrice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>secmem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>&lt; On dimensionne au plus grand </p>
</p>

<p>Definition at line <a class="el" href="Op__VEF__Face_8cpp_source.html#l00185">185</a> of file <a class="el" href="Op__VEF__Face_8cpp_source.html">Op_VEF_Face.cpp</a>.</p>

<p>References <a class="el" href="Champ__P1iP1B__implementation_8cpp_source.html#l00331">coeff</a>, <a class="el" href="Double_8h_source.html#l00255">dabs()</a>, <a class="el" href="MorEqn_8h_source.html#l00082">MorEqn::equation()</a>, <a class="el" href="Double_8h_source.html#l00273">est_egal()</a>, <a class="el" href="Zone__VEF_8h_source.html#l00145">Zone_VEF::face_normales()</a>, <a class="el" href="Cond__lim_8h_source.html#l00130">Cond_lim::frontiere_dis()</a>, <a class="el" href="Matrice__Morse_8h_source.html#l00129">Matrice_Morse::get_set_coeff()</a>, <a class="el" href="Matrice__Morse_8h_source.html#l00134">Matrice_Morse::get_tab1()</a>, <a class="el" href="Matrice__Morse_8h_source.html#l00138">Matrice_Morse::get_tab2()</a>, <a class="el" href="classEquation__base.html#a5a1fce9487b9a8dd17020914100c2c89">Equation_base::inconnue()</a>, <a class="el" href="Zone__Cl__dis__base_8cpp_source.html#l00522">Zone_Cl_dis_base::les_conditions_limites()</a>, <a class="el" href="DoubleVect_8h_source.html#l00164">DoubleVect::line_size()</a>, <a class="el" href="Field__base_8h_source.html#l00138">Field_base::nature_du_champ()</a>, <a class="el" href="Matrice__Morse_8h_source.html#l00103">Matrice_Morse::nb_colonnes()</a>, <a class="el" href="Front__VF_8h_source.html#l00066">Front_VF::nb_faces_tot()</a>, <a class="el" href="Front__VF_8h_source.html#l00076">Front_VF::num_face()</a>, <a class="el" href="Cast_8h_source.html#l00059">ref_cast</a>, <a class="el" href="vect__impl_8h_source.html#l00057">vect_impl::size()</a>, <a class="el" href="Cast_8h_source.html#l00054">sub_type</a>, <a class="el" href="Dirichlet__homogene_8h_source.html#l00072">Dirichlet_homogene::val_imp()</a>, <a class="el" href="Dirichlet_8cpp_source.html#l00085">Dirichlet::val_imp()</a>, <a class="el" href="Champ__Inc_8h_source.html#l00043">Deriv_Champ_Inc_base::valeur()</a>, <a class="el" href="Cond__lim_8h_source.html#l00031">Deriv_Cond_lim_base::valeur()</a>, <a class="el" href="Champ__Inc_8cpp_source.html#l00245">Champ_Inc::valeurs()</a>, and <a class="el" href="Field__base_8h_source.html#l00044">vectoriel</a>.</p>
<div class="fragment"><pre class="fragment">{
<span class="comment">// Dimensionnement de la matrice qui devra recevoir les coefficients provenant de</span>
<span class="comment">// la convection, de la diffusion pour le cas des faces.</span>
<span class="comment">// Cette matrice a une structure de matrice morse.</span>
<span class="comment">// Nous commencons par calculer les tailles des tableaux tab1 et tab2.</span>
  <span class="keyword">const</span> <a class="code" href="classConds__lim.html">Conds_lim</a>&amp; les_cl = la_zone_cl.<a class="code" href="classZone__Cl__dis__base.html#af75e0ed7786863e4d333bfb29d67c323" title="Renvoie la i-ieme condition aux limites. (version const)">les_conditions_limites</a>();
  <span class="keyword">const</span> <a class="code" href="classIntVect.html">IntVect</a>&amp; tab1=la_matrice.<a class="code" href="classMatrice__Morse.html#a79b4e334152850bd36e53478debf3061">get_tab1</a>();
  <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; <a class="code" href="Champ__P1iP1B__implementation_8cpp.html#aa8c8f49390c3cf7c702d71a71bc977e3">coeff</a> = la_matrice.<a class="code" href="classMatrice__Morse.html#acd067e8514e5741f52b18a1d99746d11">get_set_coeff</a>();
  <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; champ_inconnue = la_zone_cl.<a class="code" href="classMorEqn.html#a615dd9abff96edcb625fa0424a489864" title="Renvoie la reference sur l&#39;equation pointe par MorEqn::mon_equation. (version const)">equation</a>().<a class="code" href="classEquation__base.html#a5a1fce9487b9a8dd17020914100c2c89">inconnue</a>().<a class="code" href="classChamp__Inc.html#a28ef3d411d12cb5684ac5e799efb7d24" title="Appel a l&#39;objet sous-jacent Renvoie le tableau des valeurs au temps courant.">valeurs</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_comp = champ_inconnue.<a class="code" href="classDoubleVect.html#ab02d01cd1bdab66fbd66f9a47cc29e10">line_size</a>();
  <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a> normale(nb_comp);
  <span class="keywordtype">int</span> size = les_cl.<a class="code" href="classvect__impl.html#a78155bfbd6b61f4710b9830641ed1694">size</a>();
  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;size; i++)
    {
      <span class="keyword">const</span> <a class="code" href="classCond__lim.html" title="classe Cond_lim Classe generique servant a representer n&#39;importe quelle classe derivee de la classe C...">Cond_lim</a>&amp; la_cl = les_cl[i];
      <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classDirichlet.html" title="classe Dirichlet Cette classe est la classe de base de la hierarchie des conditions aux limites de ty...">Dirichlet</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>()))
        {
          <span class="keyword">const</span> <a class="code" href="classDirichlet.html" title="classe Dirichlet Cette classe est la classe de base de la hierarchie des conditions aux limites de ty...">Dirichlet</a>&amp; la_cl_Dirichlet = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classDirichlet.html" title="classe Dirichlet Cette classe est la classe de base de la hierarchie des conditions aux limites de ty...">Dirichlet</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>());
          <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp; la_front_dis = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>,la_cl.<a class="code" href="classCond__lim.html#a5b2d24809cee07727006a891d4ce8d22" title="Appel a l&#39;objet sous-jacent Renvoie la frontiere discretisee associee a la condition aux limites...">frontiere_dis</a>());
          <span class="keywordtype">int</span> nfaces = la_front_dis.nb_faces();
          <span class="keywordflow">for</span> (<span class="keywordtype">int</span> ind_face=0; ind_face &lt; nfaces; ind_face++)
            {
              <span class="keywordtype">int</span> face = la_front_dis.num_face(ind_face);
              <span class="keywordflow">for</span> (<span class="keywordtype">int</span> comp=0; comp&lt;nb_comp; comp++)
                {
                  <span class="keywordtype">int</span> idiag = tab1[face*nb_comp+comp]-1;
                  coeff[idiag]=1;
<span class="comment">// pour les voisins</span>
                  <span class="keywordtype">int</span> nbvois = tab1[face*nb_comp+1+comp] - tab1[face*nb_comp+comp];
                  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k=1; k &lt; nbvois; k++)
                    {
                      coeff[idiag+k]=0;
                    }
<span class="comment">// pour le second membre</span>
                  <span class="keywordflow">if</span> (nb_comp == 1)
                    secmem(face) = la_cl_Dirichlet.<a class="code" href="classDirichlet.html#ab59a2214e3208ac45048a2232c132803" title="Renvoie la valeur imposee sur la i-eme composante du champ a la frontiere au temps par defaut du cham...">val_imp</a>(ind_face,0);
                  <span class="keywordflow">else</span>
                    secmem(face,comp)= la_cl_Dirichlet.<a class="code" href="classDirichlet.html#ab59a2214e3208ac45048a2232c132803" title="Renvoie la valeur imposee sur la i-eme composante du champ a la frontiere au temps par defaut du cham...">val_imp</a>(ind_face,comp);
                }
            }
        }
      <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classDirichlet__homogene.html" title="Classe Dirichlet_homogene Cette classe est la classe de base de la hierarchie des conditions aux limi...">Dirichlet_homogene</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>()))
        {
          <span class="keyword">const</span> <a class="code" href="classDirichlet__homogene.html" title="Classe Dirichlet_homogene Cette classe est la classe de base de la hierarchie des conditions aux limi...">Dirichlet_homogene</a>&amp; la_cl_Dirichlet_homogene = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classDirichlet__homogene.html" title="Classe Dirichlet_homogene Cette classe est la classe de base de la hierarchie des conditions aux limi...">Dirichlet_homogene</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>());
          <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp; la_front_dis = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>,la_cl.<a class="code" href="classCond__lim.html#a5b2d24809cee07727006a891d4ce8d22" title="Appel a l&#39;objet sous-jacent Renvoie la frontiere discretisee associee a la condition aux limites...">frontiere_dis</a>());
          <span class="keywordtype">int</span> nfaces = la_front_dis.nb_faces_tot();
          <span class="keywordflow">for</span> (<span class="keywordtype">int</span> ind_face=0; ind_face &lt; nfaces; ind_face++)
            {
              <span class="keywordtype">int</span> face = la_front_dis.num_face(ind_face);
              <span class="keywordflow">for</span> (<span class="keywordtype">int</span> comp=0; comp&lt;nb_comp; comp++)
                {
                  <span class="keywordtype">int</span> idiag = tab1[face*nb_comp+comp]-1;
                  coeff[idiag]=1;
<span class="comment">// pour les voisins</span>
                  <span class="keywordtype">int</span> nbvois = tab1[face*nb_comp+1+comp] - tab1[face*nb_comp+comp];
                  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k=1; k &lt; nbvois; k++)
                    {
                      coeff[idiag+k]=0;
                    }
<span class="comment">// pour le second membre</span>
                  <span class="keywordflow">if</span> (nb_comp == 1)
                    secmem(face) = la_cl_Dirichlet_homogene.<a class="code" href="classDirichlet__homogene.html#a79fd7fbac0243313b42a2c6b79eb546a" title="Renvoie la valeur imposee sur la i-eme composante du champ a la frontiere. Toujours 0 pour Dirichlet ...">val_imp</a>(ind_face,0);
                  <span class="keywordflow">else</span>
                    secmem(face,comp)= la_cl_Dirichlet_homogene.<a class="code" href="classDirichlet__homogene.html#a79fd7fbac0243313b42a2c6b79eb546a" title="Renvoie la valeur imposee sur la i-eme composante du champ a la frontiere. Toujours 0 pour Dirichlet ...">val_imp</a>(ind_face,comp);
                }
            }
        }
      <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classSymetrie.html" title="classe Symetrie Sur les faces de symetrie on a les proprietes suivantes: - composante normale de la v...">Symetrie</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>()))
        <span class="keywordflow">if</span> (la_zone_cl.<a class="code" href="classMorEqn.html#a615dd9abff96edcb625fa0424a489864" title="Renvoie la reference sur l&#39;equation pointe par MorEqn::mon_equation. (version const)">equation</a>().<a class="code" href="classEquation__base.html#a5a1fce9487b9a8dd17020914100c2c89">inconnue</a>().<a class="code" href="classDeriv__Champ__Inc__base.html#a9e0b743a3e124e7114fa977b36b68225">valeur</a>().<a class="code" href="classField__base.html#a75bf4e0a6258589a83801c0383d049cc" title="Renvoie la nature d&#39;un champ (scalaire, multiscalaire, vectoriel).">nature_du_champ</a>()==<a class="code" href="Field__base_8h.html#a1b86c8f670a9b34da7f628a821fb646ba66d795f4e2fbb5636a3966c73964c5e7">vectoriel</a>)
          {
            <span class="keyword">const</span> <a class="code" href="classIntVect.html">IntVect</a>&amp; tab2=la_matrice.<a class="code" href="classMatrice__Morse.html#a787b5a63f27063f9c891243d8f188cda">get_tab2</a>();
            <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp; la_front_dis = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>,la_cl.<a class="code" href="classCond__lim.html#a5b2d24809cee07727006a891d4ce8d22" title="Appel a l&#39;objet sous-jacent Renvoie la frontiere discretisee associee a la condition aux limites...">frontiere_dis</a>());
            <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; face_normales = la_zone.<a class="code" href="classZone__VEF.html#a5742d75972e4846bf9fbb6ed5715053e">face_normales</a>();
            <span class="keywordtype">int</span> nfaces = la_front_dis.<a class="code" href="classFront__VF.html#aed4006d91bf2ef3af2b9f7933d863a09" title="Nombre de faces reelles et virtuelles du bord.">nb_faces_tot</a>();
            <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a> somme(la_matrice.<a class="code" href="classMatrice__Morse.html#a94caf9937bc5a110a7179cb3e9eaa9d9">nb_colonnes</a>()); <span class="comment">//!&lt; On dimensionne au plus grand</span>
<span class="comment"></span>            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> ind_face=0; ind_face &lt; nfaces; ind_face++)
              {
                <span class="keywordtype">int</span> face = la_front_dis.<a class="code" href="classFront__VF.html#a3402a19d7e54ed797d2b18e9a47ead1e" title="Renvoie le numero de face de la ieme face du bord.">num_face</a>(ind_face);
                <span class="keywordtype">double</span> max_coef=0;
                <span class="keywordtype">int</span> ind_max=-1;
                <span class="keywordtype">double</span> n2=0;
                <span class="keywordflow">for</span> (<span class="keywordtype">int</span> comp=0; comp&lt;nb_comp; comp++)
                  {
                    normale[comp]=face_normales(face,comp);
                    <span class="keywordflow">if</span> (<a class="code" href="Double_8h.html#aaecd4ca8a2fe69cc6568af2938b94d2e">dabs</a>(normale[comp])&gt;<a class="code" href="Double_8h.html#aaecd4ca8a2fe69cc6568af2938b94d2e">dabs</a>(max_coef))
                      {
                        max_coef=normale[comp];
                        ind_max=comp;
                      }
                    n2+=normale[comp]*normale[comp];
                  }
                normale/=sqrt(n2);
                max_coef=normale[ind_max];

<span class="comment">// On commence par recalculer secmem=secmem-A *present pour pouvoir modifier A (on en profite pour projeter)</span>
                <span class="keywordtype">int</span> nb_coeff_ligne=tab1[face*nb_comp+1] - tab1[face*nb_comp];
                <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k=0; k&lt;nb_coeff_ligne; k++)
                  {
                    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> comp=0; comp&lt;nb_comp; comp++)
                      {
                        <span class="keywordtype">int</span> j=tab2[tab1[face*nb_comp+comp]-1+k]-1;
<span class="comment">// assert(j!=(face*nb_comp+comp));</span>
<span class="comment">// if ((j&gt;=(face*nb_comp))&amp;&amp;(j&lt;(face*nb_comp+nb_comp)))</span>
                        <span class="keyword">const</span>    <span class="keywordtype">double</span>&amp; coef_ij=la_matrice(face*nb_comp+comp,j);
                        <span class="keywordtype">int</span> face2=j/nb_comp;
                        <span class="keywordtype">int</span> comp2=j-face2*nb_comp;
                        secmem(face,comp)-=coef_ij*champ_inconnue(face2,comp2);
                      }
                  }
                <span class="keywordtype">double</span> somme_b=0;

                <span class="keywordflow">for</span> (<span class="keywordtype">int</span> comp=0; comp&lt;nb_comp; comp++)
                  somme_b+=secmem(face,comp)*normale[comp];

<span class="comment">// on retire secmem.n n</span>
                <span class="keywordflow">for</span> (<span class="keywordtype">int</span> comp=0; comp&lt;nb_comp; comp++)
                  secmem(face,comp)-=somme_b*normale[comp];

<span class="comment">// on doit remettre la meme diagonale partout on prend la moyenne</span>
                <span class="keywordtype">double</span> ref=0;
                <span class="keywordflow">for</span> (<span class="keywordtype">int</span> comp=0; comp&lt;nb_comp; comp++)
                  {
                    <span class="keywordtype">int</span> j0=face*nb_comp+comp;
                    ref+=la_matrice(j0,j0);
                  }
                ref/=nb_comp;

                <span class="keywordflow">for</span> (<span class="keywordtype">int</span> comp=0; comp&lt;nb_comp; comp++)
                  {
                    <span class="keywordtype">int</span> j0=face*nb_comp+comp;
                    <span class="keywordtype">double</span> rap=ref/la_matrice(j0,j0);
                    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k=0; k&lt;nb_coeff_ligne; k++)
                      {
                        <span class="keywordtype">int</span> j=tab2[tab1[j0]-1+k]-1;
                        la_matrice(j0,j)*=rap;
                      }
                    assert(<a class="code" href="Double_8h.html#ac86f5f350b0f95fd8c34b0ac8d720f6f">est_egal</a>(la_matrice(j0,j0),ref));
                  }
<span class="comment">// on annule tous les coef extra diagonaux du bloc</span>
<span class="comment">// </span>
                <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k=1; k&lt;nb_coeff_ligne; k++)
                  {
                    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> comp=0; comp&lt;nb_comp; comp++)
                      {
                        <span class="keywordtype">int</span> j=tab2[tab1[face*nb_comp+comp]-1+k]-1;
                        assert(j!=(face*nb_comp+comp));
                        <span class="keywordflow">if</span> ((j&gt;=(face*nb_comp))&amp;&amp;(j&lt;(face*nb_comp+nb_comp)))
                          la_matrice(face*nb_comp+comp,j)=0;
                      }
                  }

<span class="comment">// pour les blocs extra diagonaux on assure que Aij.ni=0</span>
<span class="comment">// ArrOfDouble somme(nb_coeff_ligne);</span>
                <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k=0; k&lt;nb_coeff_ligne; k++)
                  {
                    somme(k)=0;
                    <span class="keywordtype">int</span> j=tab2[tab1[face*nb_comp]-1+k]-1;

<span class="comment">// le coeff j doit exister sur les nb_comp lignes</span>
                    <span class="keywordtype">double</span> dsomme=0;
                    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> comp=0; comp&lt;nb_comp; comp++)
                      dsomme+=la_matrice(face*nb_comp+comp,j)*normale[comp];

<span class="comment">// on retire somme ni</span>

                    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> comp=0; comp&lt;nb_comp; comp++)
<span class="comment">// on modifie que les coefficients ne faisant pas intervenir u(face,comp)</span>
                      <span class="keywordflow">if</span> ((j&lt;(face*nb_comp))||(j&gt;=(face*nb_comp+nb_comp)))
                        la_matrice(face*nb_comp+comp,j)-=(dsomme)*normale[comp];
                  }
<span class="comment">// Finalement on recalcule secmem=secmem+A*champ_inconnue (A a ete beaucoup modiife)</span>
                <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k=0; k&lt;nb_coeff_ligne; k++)
                  {
                    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> comp=0; comp&lt;nb_comp; comp++)
                      {
                        <span class="keywordtype">int</span> j=tab2[tab1[face*nb_comp+comp]-1+k]-1;
                        <span class="keywordtype">int</span> face2=j/nb_comp;
                        <span class="keywordtype">int</span> comp2=j-face2*nb_comp;
                        <span class="keyword">const</span> <span class="keywordtype">double</span>&amp; coef_ij=la_matrice(face*nb_comp+comp,j);
                        secmem(face,comp)+=coef_ij*champ_inconnue(face2,comp2);
                      }
                  }
                {
<span class="comment">// verification</span>
                  <span class="keywordtype">double</span> somme_c=0;
                  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> comp=0; comp&lt;nb_comp; comp++)
                    somme_c+=secmem(face,comp)*normale[comp];
<span class="comment">// on retire secmem.n n</span>
                  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> comp=0; comp&lt;nb_comp; comp++)
                    secmem(face,comp)-=somme_c*normale[comp];
                }
              }
          }
    }
}
</pre></div>
</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="a74453359874aa3d466f3df50684236a3"></a><!-- doxytag: member="Op_VEF_Face::controle_modifier_flux_" ref="a74453359874aa3d466f3df50684236a3" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classOp__VEF__Face.html#a74453359874aa3d466f3df50684236a3">Op_VEF_Face::controle_modifier_flux_</a><code> [mutable, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Op__VEF__Face_8h_source.html#l00047">47</a> of file <a class="el" href="Op__VEF__Face_8h_source.html">Op_VEF_Face.h</a>.</p>

<p>Referenced by <a class="el" href="Op__VEF__Face_8cpp_source.html#l00456">impr()</a>, and <a class="el" href="Op__VEF__Face_8cpp_source.html#l00384">modifier_flux()</a>.</p>

</div>
</div>
<a class="anchor" id="af92615c52cc45fd48d495802fd2ba02f"></a><!-- doxytag: member="Op_VEF_Face::Flux" ref="af92615c52cc45fd48d495802fd2ba02f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSFichier.html">SFichier</a> <a class="el" href="classOp__VEF__Face.html#af92615c52cc45fd48d495802fd2ba02f">Op_VEF_Face::Flux</a><code> [mutable, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Op__VEF__Face_8h_source.html#l00048">48</a> of file <a class="el" href="Op__VEF__Face_8h_source.html">Op_VEF_Face.h</a>.</p>

<p>Referenced by <a class="el" href="Op__VEF__Face_8cpp_source.html#l00456">impr()</a>.</p>

</div>
</div>
<a class="anchor" id="a426500a12aa34bc34e10dd494d0701b3"></a><!-- doxytag: member="Op_VEF_Face::Flux_moment" ref="a426500a12aa34bc34e10dd494d0701b3" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSFichier.html">SFichier</a> <a class="el" href="classOp__VEF__Face.html#a426500a12aa34bc34e10dd494d0701b3">Op_VEF_Face::Flux_moment</a><code> [mutable, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Op__VEF__Face_8h_source.html#l00048">48</a> of file <a class="el" href="Op__VEF__Face_8h_source.html">Op_VEF_Face.h</a>.</p>

<p>Referenced by <a class="el" href="Op__VEF__Face_8cpp_source.html#l00456">impr()</a>.</p>

</div>
</div>
<a class="anchor" id="a44c07f75ad3edafd7f840cfa4d2b92a9"></a><!-- doxytag: member="Op_VEF_Face::Flux_sum" ref="a44c07f75ad3edafd7f840cfa4d2b92a9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSFichier.html">SFichier</a> <a class="el" href="classOp__VEF__Face.html#a44c07f75ad3edafd7f840cfa4d2b92a9">Op_VEF_Face::Flux_sum</a><code> [mutable, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Op__VEF__Face_8h_source.html#l00048">48</a> of file <a class="el" href="Op__VEF__Face_8h_source.html">Op_VEF_Face.h</a>.</p>

<p>Referenced by <a class="el" href="Op__VEF__Face_8cpp_source.html#l00456">impr()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/VEF/Operateurs/<a class="el" href="Op__VEF__Face_8h_source.html">Op_VEF_Face.h</a></li>
<li>src/VEF/Operateurs/<a class="el" href="Op__VEF__Face_8cpp_source.html">Op_VEF_Face.cpp</a></li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Tue Dec 14 2021 19:37:28 for TRUST by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
