<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>TRUST: src/Kernel/Geometrie/Decoupeur/Domain_Graph.cpp Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">TRUST&#160;<span id="projectnumber">1.8.4</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
<div class="header">
  <div class="headertitle">
<div class="title">src/Kernel/Geometrie/Decoupeur/Domain_Graph.cpp</div>  </div>
</div>
<div class="contents">
<a href="Domain__Graph_8cpp.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/****************************************************************************</span>
<a name="l00002"></a>00002 <span class="comment">* Copyright (c) 2021, CEA</span>
<a name="l00003"></a>00003 <span class="comment">* All rights reserved.</span>
<a name="l00004"></a>00004 <span class="comment">*</span>
<a name="l00005"></a>00005 <span class="comment">* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</span>
<a name="l00006"></a>00006 <span class="comment">* 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.</span>
<a name="l00007"></a>00007 <span class="comment">* 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.</span>
<a name="l00008"></a>00008 <span class="comment">* 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.</span>
<a name="l00009"></a>00009 <span class="comment">*</span>
<a name="l00010"></a>00010 <span class="comment">* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.</span>
<a name="l00011"></a>00011 <span class="comment">* IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;</span>
<a name="l00012"></a>00012 <span class="comment">* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>
<a name="l00013"></a>00013 <span class="comment">*</span>
<a name="l00014"></a>00014 <span class="comment">*****************************************************************************/</span>
<a name="l00015"></a>00015 <span class="comment">//</span>
<a name="l00016"></a>00016 <span class="comment">// </span>
<a name="l00017"></a>00017 <span class="comment">// File:        Domain_Graph.cpp</span>
<a name="l00018"></a>00018 <span class="comment">// Directory:   $TRUST_ROOT/src/Kernel/Geometrie/Decoupeur</span>
<a name="l00019"></a>00019 <span class="comment">// Version:     /main/20</span>
<a name="l00020"></a>00020 <span class="comment">// </span>
<a name="l00021"></a>00021 <span class="comment">//</span>
<a name="l00022"></a>00022 <span class="preprocessor">#include &lt;<a class="code" href="Domaine_8h.html">Domaine.h</a>&gt;</span>
<a name="l00023"></a>00023 <span class="preprocessor">#include &lt;<a class="code" href="Static__Int__Lists_8h.html">Static_Int_Lists.h</a>&gt;</span>
<a name="l00024"></a>00024 <span class="preprocessor">#include &lt;<a class="code" href="Connectivite__som__elem_8h.html">Connectivite_som_elem.h</a>&gt;</span>
<a name="l00025"></a>00025 <span class="preprocessor">#include &lt;<a class="code" href="Poly__geom__base_8h.html">Poly_geom_base.h</a>&gt;</span>
<a name="l00026"></a>00026 <span class="preprocessor">#include &lt;<a class="code" href="Matrix__tools_8h.html">Matrix_tools.h</a>&gt;</span>
<a name="l00027"></a>00027 <span class="preprocessor">#include &lt;<a class="code" href="Matrice__Morse_8h.html">Matrice_Morse.h</a>&gt;</span>
<a name="l00028"></a>00028 <span class="preprocessor">#include &lt;<a class="code" href="Array__tools_8h.html">Array_tools.h</a>&gt;</span>
<a name="l00029"></a>00029 <span class="preprocessor">#include &lt;<a class="code" href="communications_8h.html">communications.h</a>&gt;</span>
<a name="l00030"></a>00030 <span class="preprocessor">#include &lt;<a class="code" href="Domain__Graph_8h.html">Domain_Graph.h</a>&gt;</span>
<a name="l00031"></a>00031 <span class="preprocessor">#include &lt;<a class="code" href="Partitionneur__base_8h.html">Partitionneur_base.h</a>&gt;</span>
<a name="l00032"></a>00032 <span class="preprocessor">#include &lt;map&gt;</span>
<a name="l00033"></a>00033 
<a name="l00034"></a><a class="code" href="Domain__Graph_8cpp.html#a59f2c95ce088a2f16d969d2dc7954375">00034</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="Domain__Graph_8cpp.html#a59f2c95ce088a2f16d969d2dc7954375">construire_connectivite_real_som_virtual_elem</a>(<span class="keyword">const</span> <span class="keywordtype">int</span>       nb_sommets,
<a name="l00035"></a>00035                                                           <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp;      les_elems,
<a name="l00036"></a>00036                                                           <a class="code" href="classStatic__Int__Lists.html" title="Cette classe permet de stocker des listes d&#39;entiers accessibles en temps constant. La taille des listes ne peut pas changer sans perdre le contenu (ce sont des listes statiques). Exemple: Static_Int_List l; ArrOfInt tailles(3); tailles[0] = 2; tailles[1] = 3; tailles[2] = 0; // On reserve la memoire pour trois listes de taille 2, 3 et 0: l.set_list_sizes(tailles); // On affecte une valeur au deuxieme element de la premiere liste: l.set_value(0,1,765); // Affiche la valeur Cout &lt;&lt; l(0,1);.">Static_Int_Lists</a>&amp; som_elem,
<a name="l00037"></a>00037                                                           <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; elem_virt_pe_num,
<a name="l00038"></a>00038                                                           <span class="keyword">const</span>  <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; offsets)
<a name="l00039"></a>00039 {
<a name="l00040"></a>00040 <span class="comment">// Nombre d&#39;elements du domaine</span>
<a name="l00041"></a>00041   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_elem = les_elems.<a class="code" href="classIntTab.html#a71e9b9ddc1793094b1b3f109377952b1" title="Returns the total dimensions of the multi-dimensionnal array, including virtual items (used in parall...">dimension_tot</a>(0);
<a name="l00042"></a>00042   <span class="keyword">const</span> <span class="keywordtype">int</span> local_nb_elem = les_elems.<a class="code" href="classIntTab.html#abc3b32c94925a82f69d5b153a356e359" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(0);
<a name="l00043"></a>00043 <span class="comment">// Nombre de sommets par element</span>
<a name="l00044"></a>00044   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_sommets_par_element = les_elems.<a class="code" href="classIntTab.html#abc3b32c94925a82f69d5b153a356e359" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(1);
<a name="l00045"></a>00045 
<a name="l00046"></a>00046 <span class="comment">// Construction d&#39;un tableau initialise a zero : pour chaque sommet,</span>
<a name="l00047"></a>00047 <span class="comment">// nombre d&#39;elements voisins de ce sommet</span>
<a name="l00048"></a>00048   <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> nb_elements_voisins(nb_sommets);
<a name="l00049"></a>00049 
<a name="l00050"></a>00050 <span class="comment">// Premier passage : on calcule le nombre d&#39;elements voisins de chaque</span>
<a name="l00051"></a>00051 <span class="comment">// sommet pour creer la structure de donnees</span>
<a name="l00052"></a>00052   <span class="keywordtype">int</span> elem, i;
<a name="l00053"></a>00053 
<a name="l00054"></a>00054 <span class="comment">// real elements</span>
<a name="l00055"></a>00055   <span class="keywordflow">for</span> (elem = 0; elem &lt; nb_elem; elem++)
<a name="l00056"></a>00056     {
<a name="l00057"></a>00057       <span class="keywordflow">for</span> (i = 0; i &lt; nb_sommets_par_element; i++)
<a name="l00058"></a>00058         {
<a name="l00059"></a>00059           <span class="keywordtype">int</span> sommet = les_elems(elem, i);
<a name="l00060"></a>00060           <span class="keywordflow">if</span>(sommet &gt;= nb_sommets) <span class="keywordflow">continue</span>; <span class="comment">//skipping virtual node</span>
<a name="l00061"></a>00061 <span class="comment">// GF cas des polyedres</span>
<a name="l00062"></a>00062           <span class="keywordflow">if</span> (sommet==-1) <span class="keywordflow">break</span>;
<a name="l00063"></a>00063           nb_elements_voisins[sommet]++;
<a name="l00064"></a>00064         }
<a name="l00065"></a>00065     }
<a name="l00066"></a>00066 
<a name="l00067"></a>00067   som_elem.<a class="code" href="classStatic__Int__Lists.html#a60da63cb1970f5b87d1e1fdf6d65dcb2" title="detruit les listes existantes et en cree de nouvelles. On cree autant de listes que d&#39;elements dans l...">set_list_sizes</a>(nb_elements_voisins);
<a name="l00068"></a>00068 
<a name="l00069"></a>00069 <span class="comment">// On reutilise le tableau pour stocker le nombre d&#39;elements dans</span>
<a name="l00070"></a>00070 <span class="comment">// chaque liste pendant qu&#39;on la remplit</span>
<a name="l00071"></a>00071   nb_elements_voisins = 0;
<a name="l00072"></a>00072 
<a name="l00073"></a>00073 <span class="comment">// Remplissage du tableau des elements voisins.</span>
<a name="l00074"></a>00074   <span class="keywordflow">for</span> (elem = 0; elem &lt; nb_elem; elem++)
<a name="l00075"></a>00075     {
<a name="l00076"></a>00076       <span class="keywordflow">for</span> (i = 0; i &lt; nb_sommets_par_element; i++)
<a name="l00077"></a>00077         {
<a name="l00078"></a>00078           <span class="keywordtype">int</span> sommet = les_elems(elem, i);
<a name="l00079"></a>00079           <span class="keywordflow">if</span>(sommet &gt;= nb_sommets) <span class="keywordflow">continue</span>;
<a name="l00080"></a>00080 <span class="comment">// GF cas des polyedres</span>
<a name="l00081"></a>00081           <span class="keywordflow">if</span> (sommet==-1) <span class="keywordflow">break</span>;
<a name="l00082"></a>00082           <span class="keywordtype">int</span> n = (nb_elements_voisins[sommet])++;
<a name="l00083"></a>00083 
<a name="l00084"></a>00084           <span class="keywordtype">int</span> elem_num_global = -1;
<a name="l00085"></a>00085           <span class="keywordflow">if</span>(elem&gt;= local_nb_elem)
<a name="l00086"></a>00086             {
<a name="l00087"></a>00087               <span class="keywordtype">int</span> proc_of_elem = elem_virt_pe_num(elem-local_nb_elem, 0);
<a name="l00088"></a>00088               <span class="keywordtype">int</span> elem_number_on_local_proc = elem_virt_pe_num(elem-local_nb_elem, 1);
<a name="l00089"></a>00089               elem_num_global = elem_number_on_local_proc + offsets[proc_of_elem];
<a name="l00090"></a>00090             }
<a name="l00091"></a>00091           <span class="keywordflow">else</span>
<a name="l00092"></a>00092             elem_num_global = elem + offsets[<a class="code" href="classProcess.html#ab55ba07167ec807ed3a145cac0f5dca4" title="renvoie mon rang dans le groupe de communication courant. Voir Comm_Group::rank() et PE_Groups::curre...">Process::me</a>()];
<a name="l00093"></a>00093 
<a name="l00094"></a>00094           som_elem.<a class="code" href="classStatic__Int__Lists.html#ab56f42945e3057185cc1086e1cbc1bbb" title="affecte la &quot;valeur&quot; au j-ieme element de la i-ieme liste avec 0 &lt;= i &lt; get_nb_lists() et 0 &lt;= j &lt; get...">set_value</a>(sommet, n, elem_num_global);
<a name="l00095"></a>00095         }
<a name="l00096"></a>00096     }
<a name="l00097"></a>00097 
<a name="l00098"></a>00098 <span class="comment">// Tri de toutes les listes dans l&#39;ordre croissant</span>
<a name="l00099"></a>00099   som_elem.<a class="code" href="classStatic__Int__Lists.html#ac6174c2ad8e64329eb7a90538cdf8c9c" title="tri par ordre croissant des valeurs de la i-ieme liste. Si num_liste &lt; 0, on trie toutes les listes...">trier_liste</a>(-1);
<a name="l00100"></a>00100 }
<a name="l00101"></a>00101 
<a name="l00102"></a><a class="code" href="classDomain__Graph.html#acc11973f649e67cc5d0297b2a1462e65">00102</a> <span class="keywordtype">void</span> <a class="code" href="classDomain__Graph.html#acc11973f649e67cc5d0297b2a1462e65">Domain_Graph::construire_graph_from_segment</a>(<span class="keyword">const</span> <a class="code" href="classDomaine.html" title="Classe Domaine Un Domaine represente le domaine (spatial) de resolution d&#39;un Probleme. Un Domaine a un Nom, il est constitue d&#39;une ou plusieurs Zone qui peuvent etre eventuellement decoupees en Sous_Zone. Un Domaine porte l&#39;ensemble des sommets utilises par ses Zones. On peut vouloir resoudre des problemes de type different sur plusieurs domaines, geometriquement les domaines sont alors couples par des surfaces qu&#39;on appelle Raccord.">Domaine</a>&amp; dom,
<a name="l00103"></a>00103                                                  <span class="keyword">const</span> <span class="keywordtype">int</span> use_weights)
<a name="l00104"></a>00104 {
<a name="l00105"></a>00105   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; liaisons = dom.<a class="code" href="classDomaine.html#a0e62f2bc829542fafa29e3f2c614159c" title="Renvoie la i-ieme zone du domaine. (version const)">zone</a>(0).<a class="code" href="classZone.html#ac115e8342be89afb882b7b61cc343267" title="Renvoie le tableau des sommets des elements.">les_elems</a>();
<a name="l00106"></a>00106 
<a name="l00107"></a>00107 <span class="comment">// ****************************************************************</span>
<a name="l00108"></a>00108 <span class="comment">// PREMIERE ETAPE: calcul du nombre de vertex et edges du graph:</span>
<a name="l00109"></a>00109   <span class="keywordtype">int</span> nb_edges = liaisons.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>(); <span class="comment">//!&lt; 2 liens par liaison</span>
<a name="l00110"></a>00110 <span class="comment"></span>  <span class="keywordtype">int</span> nb_elem=liaisons.<a class="code" href="classIntVect.html#a71df51f4f83be94f9ea9b5eaad7298a5">local_max_vect</a>()+1;  <span class="comment">//!&lt; mouif</span>
<a name="l00111"></a>00111 <span class="comment"></span>  <a class="code" href="classDomain__Graph.html#af9e2729c1801be23ecf1237370a9b97c">nvtxs</a> = nb_elem;
<a name="l00112"></a>00112   <a class="code" href="classDomain__Graph.html#ace9fd4d5cc1ff127e4c7ed2f8d189e4a">xadj</a>.<a class="code" href="classArrOfInt.html#a9b3afbb46b16870dbd36236c8935b535">resize_array</a>(nb_elem+1);
<a name="l00113"></a>00113   <a class="code" href="classDomain__Graph.html#a59235e5ba7a37abd767bb8c18c5a3338">vwgts</a>.<a class="code" href="classArrOfInt.html#a9b3afbb46b16870dbd36236c8935b535">resize_array</a>(0);
<a name="l00114"></a>00114   <span class="keywordflow">if</span> (! use_weights)
<a name="l00115"></a>00115     {
<a name="l00116"></a>00116       <a class="code" href="classDomain__Graph.html#ad5c25a0bfc7f12a6f18d146ea624b1ec">weightflag</a> = 0;
<a name="l00117"></a>00117       <a class="code" href="classDomain__Graph.html#a16341c1f48e745c57d5b5ad8955a9427">ewgts</a>.<a class="code" href="classArrOfInt.html#a9b3afbb46b16870dbd36236c8935b535">resize_array</a>(0);
<a name="l00118"></a>00118     }
<a name="l00119"></a>00119   <span class="keywordflow">else</span>
<a name="l00120"></a>00120     {
<a name="l00121"></a>00121       abort();
<a name="l00122"></a>00122       <a class="code" href="classDomain__Graph.html#ad5c25a0bfc7f12a6f18d146ea624b1ec">weightflag</a> = 1;
<a name="l00123"></a>00123       <a class="code" href="classDomain__Graph.html#a16341c1f48e745c57d5b5ad8955a9427">ewgts</a>.<a class="code" href="classArrOfInt.html#a9b3afbb46b16870dbd36236c8935b535">resize_array</a>(nb_edges);
<a name="l00124"></a>00124     }
<a name="l00125"></a>00125 
<a name="l00126"></a>00126 <span class="comment">// on construit connectivite item item</span>
<a name="l00127"></a>00127   <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a> stencyl(0,2);
<a name="l00128"></a>00128   stencyl.<a class="code" href="classArrOfInt.html#a22d744bcd452d039580d1d9186f02b4e" title="Change le mode l&#39;allocation memoire: reallocation d&#39;un tableau a chaque changement de taille (flag = ...">set_smart_resize</a>(1);
<a name="l00129"></a>00129   <span class="keywordtype">int</span> size=0;
<a name="l00130"></a>00130   <span class="keywordtype">int</span> nbl=liaisons.<a class="code" href="classIntTab.html#abc3b32c94925a82f69d5b153a356e359" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(0);
<a name="l00131"></a>00131   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;nbl; i++)
<a name="l00132"></a>00132     {
<a name="l00133"></a>00133       stencyl.<a class="code" href="classIntTab.html#a22e6bed6826b3688d4d0181cbf3b7a38" title="Change la taille du vecteur (identique a resize_array() pour le traitement des anciennes valeurs et d...">resize</a>(size+2,2);
<a name="l00134"></a>00134       <span class="keywordtype">int</span> n1=liaisons(i,0);
<a name="l00135"></a>00135       <span class="keywordtype">int</span> n2=liaisons(i,1);
<a name="l00136"></a>00136       {
<a name="l00137"></a>00137         stencyl(size,0)=n1;
<a name="l00138"></a>00138         stencyl(size,1)=n2;
<a name="l00139"></a>00139 
<a name="l00140"></a>00140         size++;
<a name="l00141"></a>00141         stencyl(size,0)=n2;
<a name="l00142"></a>00142         stencyl(size,1)=n1;
<a name="l00143"></a>00143 
<a name="l00144"></a>00144         size++;
<a name="l00145"></a>00145       }
<a name="l00146"></a>00146     }
<a name="l00147"></a>00147   <a class="code" href="Array__tools_8cpp.html#a07eed4c823b0632bdbf353fdab2a3c6b" title="Trie le tableau tab dans l&#39;ordre lexicographique et retire les doublons (attention [1...">tableau_trier_retirer_doublons</a>(stencyl);
<a name="l00148"></a>00148   <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a> A;
<a name="l00149"></a>00149   <a class="code" href="classMatrix__tools.html#a481961691c1dbee5372da25777e5c1e8">Matrix_tools::allocate_morse_matrix</a>(nb_elem,nb_elem,stencyl,A);
<a name="l00150"></a>00150 
<a name="l00151"></a>00151   nb_edges=A.<a class="code" href="classMatrice__Morse.html#a787b5a63f27063f9c891243d8f188cda">get_tab2</a>().<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>(); <span class="comment">//!&lt; des liens peuvent etre doubles</span>
<a name="l00152"></a>00152 <span class="comment"></span>  <a class="code" href="classDomain__Graph.html#a5adfd8eda78ca66bd99c1a675b573810">nedges</a> = nb_edges;
<a name="l00153"></a>00153   <a class="code" href="classDomain__Graph.html#ab9d17a6424dcbf4c43a138c19aaf8016">adjncy</a>.<a class="code" href="classArrOfInt.html#a9b3afbb46b16870dbd36236c8935b535">resize_array</a>(nb_edges);
<a name="l00154"></a>00154 <span class="comment">// </span>
<a name="l00155"></a>00155   assert(A.<a class="code" href="classMatrice__Morse.html#a79b4e334152850bd36e53478debf3061">get_tab1</a>().<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>()==<a class="code" href="classDomain__Graph.html#af9e2729c1801be23ecf1237370a9b97c">nvtxs</a>+1);
<a name="l00156"></a>00156   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> c=0; c&lt;<a class="code" href="classDomain__Graph.html#af9e2729c1801be23ecf1237370a9b97c">nvtxs</a>+1; c++)
<a name="l00157"></a>00157     {
<a name="l00158"></a>00158       <a class="code" href="classDomain__Graph.html#ace9fd4d5cc1ff127e4c7ed2f8d189e4a">xadj</a>[c]=A.<a class="code" href="classMatrice__Morse.html#a79b4e334152850bd36e53478debf3061">get_tab1</a>()(c)-1;
<a name="l00159"></a>00159     }
<a name="l00160"></a>00160   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> c=0; c&lt;<a class="code" href="classDomain__Graph.html#a5adfd8eda78ca66bd99c1a675b573810">nedges</a>; c++)
<a name="l00161"></a>00161     {
<a name="l00162"></a>00162       <a class="code" href="classDomain__Graph.html#ab9d17a6424dcbf4c43a138c19aaf8016">adjncy</a>[c]=A.<a class="code" href="classMatrice__Morse.html#a787b5a63f27063f9c891243d8f188cda">get_tab2</a>()(c)-1;
<a name="l00163"></a>00163     }
<a name="l00164"></a>00164 
<a name="l00165"></a>00165 }
<a name="l00166"></a>00166 
<a name="l00167"></a>00167 <span class="comment">// Si use_weights, on pondere les liens entre les elements periodiques</span>
<a name="l00168"></a>00168 <span class="comment">// pour les forcer a etre sur le meme processeur. Cela diminue le nombre</span>
<a name="l00169"></a>00169 <span class="comment">// de corrections a faire ensuite (voir (***))</span>
<a name="l00170"></a><a class="code" href="classDomain__Graph.html#a182aaf66fe5c9451d0c6b309a1289b86">00170</a> <span class="keywordtype">void</span> <a class="code" href="classDomain__Graph.html#a182aaf66fe5c9451d0c6b309a1289b86">Domain_Graph::construire_graph_elem_elem</a>(<span class="keyword">const</span> <a class="code" href="classDomaine.html" title="Classe Domaine Un Domaine represente le domaine (spatial) de resolution d&#39;un Probleme. Un Domaine a un Nom, il est constitue d&#39;une ou plusieurs Zone qui peuvent etre eventuellement decoupees en Sous_Zone. Un Domaine porte l&#39;ensemble des sommets utilises par ses Zones. On peut vouloir resoudre des problemes de type different sur plusieurs domaines, geometriquement les domaines sont alors couples par des surfaces qu&#39;on appelle Raccord.">Domaine</a>&amp; dom,
<a name="l00171"></a>00171                                               <span class="keyword">const</span> <a class="code" href="classNoms.html" title="Un tableau de chaine de caracteres (VECT(Nom))">Noms</a>&amp; liste_bords_periodiques,
<a name="l00172"></a>00172                                               <span class="keyword">const</span> <span class="keywordtype">int</span> use_weights,
<a name="l00173"></a>00173                                               <a class="code" href="classStatic__Int__Lists.html" title="Cette classe permet de stocker des listes d&#39;entiers accessibles en temps constant. La taille des listes ne peut pas changer sans perdre le contenu (ce sont des listes statiques). Exemple: Static_Int_List l; ArrOfInt tailles(3); tailles[0] = 2; tailles[1] = 3; tailles[2] = 0; // On reserve la memoire pour trois listes de taille 2, 3 et 0: l.set_list_sizes(tailles); // On affecte une valeur au deuxieme element de la premiere liste: l.set_value(0,1,765); // Affiche la valeur Cout &lt;&lt; l(0,1);.">Static_Int_Lists</a>&amp; graph_elements_perio)
<a name="l00174"></a>00174 {
<a name="l00175"></a>00175   <a class="code" href="classStatic__Int__Lists.html" title="Cette classe permet de stocker des listes d&#39;entiers accessibles en temps constant. La taille des listes ne peut pas changer sans perdre le contenu (ce sont des listes statiques). Exemple: Static_Int_List l; ArrOfInt tailles(3); tailles[0] = 2; tailles[1] = 3; tailles[2] = 0; // On reserve la memoire pour trois listes de taille 2, 3 et 0: l.set_list_sizes(tailles); // On affecte une valeur au deuxieme element de la premiere liste: l.set_value(0,1,765); // Affiche la valeur Cout &lt;&lt; l(0,1);.">Static_Int_Lists</a> som_elem;
<a name="l00176"></a>00176   <span class="keyword">const</span> <a class="code" href="classZone.html" title="classe Zone Une Zone est un maillage compose d&#39;un ensemble d&#39;elements geometriques de meme type...">Zone</a>&amp; zone = dom.<a class="code" href="classDomaine.html#a0e62f2bc829542fafa29e3f2c614159c" title="Renvoie la i-ieme zone du domaine. (version const)">zone</a>(0);
<a name="l00177"></a>00177   <span class="keyword">const</span> <a class="code" href="classElem__geom__base.html" title="Classe Elem_geom_base Cette classe est la classe de base pour la definition d&#39;elements geometriques c...">Elem_geom_base</a>&amp; <a class="code" href="Raffiner__Simplexes_8cpp.html#a358dc168d8905bbafc12587204bc9fb8">type_elem</a> = zone.<a class="code" href="classZone.html#a18cf83cd0f9c368dcfa32fb802a0ac94" title="Renvoie un element geometrique du type de ceux qui constituent la zone. (version const)">type_elem</a>().<a class="code" href="classDeriv__Elem__geom__base.html#a384b487459a33f9f521fb16539ec81de">valeur</a>();
<a name="l00178"></a>00178   <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a> faces_element_reference;
<a name="l00179"></a>00179   <span class="keyword">const</span> <span class="keywordtype">int</span> is_regular =
<a name="l00180"></a>00180     type_elem.<a class="code" href="classElem__geom__base.html#a9993267e98ef97472d3a5ef9c3c67882" title="remplit le tableau faces_som_local(i,j) qui donne pour 0 &lt;= i &lt; nb_faces() et 0 &lt;= j &lt; nb_som_face(i) le ...">get_tab_faces_sommets_locaux</a>(faces_element_reference);
<a name="l00181"></a>00181   <span class="keywordflow">if</span> (! is_regular)
<a name="l00182"></a>00182     {
<a name="l00183"></a>00183       <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Error in Domain_Graph::construire_graph_elem_elem\n&quot;</span>
<a name="l00184"></a>00184            &lt;&lt; <span class="stringliteral">&quot; The type of element is not supported&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
<a name="l00185"></a>00185       <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classPoly__geom__base.html" title=": class Poly_geom_base &lt;Description of class Poly_geom_base&gt;">Poly_geom_base</a>,type_elem).get_tab_faces_sommets_locaux(faces_element_reference,0);
<a name="l00186"></a>00186     }
<a name="l00187"></a>00187   <span class="keywordtype">int</span> nb_faces_par_element = faces_element_reference.<a class="code" href="classIntTab.html#abc3b32c94925a82f69d5b153a356e359" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(0);
<a name="l00188"></a>00188   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_sommets_par_face = faces_element_reference.<a class="code" href="classIntTab.html#abc3b32c94925a82f69d5b153a356e359" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(1);
<a name="l00189"></a>00189 
<a name="l00190"></a>00190   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; elem_som = zone.<a class="code" href="classZone.html#ac115e8342be89afb882b7b61cc343267" title="Renvoie le tableau des sommets des elements.">les_elems</a>();
<a name="l00191"></a>00191   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_elem = zone.<a class="code" href="classZone.html#a7f249429803b27139a1c54436f6164a5" title="Renvoie le nombre d&#39;elements de la zone.">nb_elem</a>();
<a name="l00192"></a>00192 
<a name="l00193"></a>00193   <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> offsets(<a class="code" href="classProcess.html#a6bf692ce58d9578aa62ac3c07b8caaa1" title="renvoie le nombre de processeurs dans le groupe courant Voir Comm_Group::nproc() et PE_Groups::curren...">Process::nproc</a>());
<a name="l00194"></a>00194   offsets = <a class="code" href="communications_8cpp.html#a13b5bdc7cfe14771b52a033b1ecbc071" title="Calul de la somme partielle de i sur les processeurs 0 a me()-1 (renvoie 0 sur le processeur 0)...">mppartial_sum</a>(nb_elem);
<a name="l00195"></a>00195   <a class="code" href="communications_8cpp.html#a5ceda011ec527d63b691f62cd2fb61c8">envoyer_all_to_all</a>(offsets, offsets);
<a name="l00196"></a>00196   <span class="keywordtype">int</span> my_offset = offsets[<a class="code" href="classProcess.html#ab55ba07167ec807ed3a145cac0f5dca4" title="renvoie mon rang dans le groupe de communication courant. Voir Comm_Group::rank() et PE_Groups::curre...">Process::me</a>()];
<a name="l00197"></a>00197 
<a name="l00198"></a>00198   <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot; Construction of the som_elem connectivity&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
<a name="l00199"></a>00199   <span class="keywordflow">if</span>(<a class="code" href="classProcess.html#a6bf692ce58d9578aa62ac3c07b8caaa1" title="renvoie le nombre de processeurs dans le groupe courant Voir Comm_Group::nproc() et PE_Groups::curren...">Process::nproc</a>() &gt; 1)
<a name="l00200"></a>00200     {
<a name="l00201"></a>00201 <span class="comment">// what we&#39;re doing here is not equivalent to construire_connectivite_som_elem with virtual elements set to 1</span>
<a name="l00202"></a>00202 <span class="comment">// in the latter, we also build the connectivity for virtual nodes</span>
<a name="l00203"></a>00203 <span class="comment">// here, we add the connectivity of real nodes only with virtual elements</span>
<a name="l00204"></a>00204 <span class="comment">// + we want som_elem to contain global numerotation for elements</span>
<a name="l00205"></a>00205       <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a> elem_virt_pe_num;
<a name="l00206"></a>00206       zone.<a class="code" href="classZone.html#a5a8e81b23354f7080912cf6113a4740c">construire_elem_virt_pe_num</a>(elem_virt_pe_num);
<a name="l00207"></a>00207       <a class="code" href="Domain__Graph_8cpp.html#a59f2c95ce088a2f16d969d2dc7954375">construire_connectivite_real_som_virtual_elem</a>(dom.<a class="code" href="classDomaine.html#abc4abc8b8db5bebeb161fae4162a89ce" title="Renvoie le nombre de sommets.">nb_som</a>(),
<a name="l00208"></a>00208                                                     elem_som,
<a name="l00209"></a>00209                                                     som_elem,
<a name="l00210"></a>00210                                                     elem_virt_pe_num,
<a name="l00211"></a>00211                                                     offsets);
<a name="l00212"></a>00212 
<a name="l00213"></a>00213     }
<a name="l00214"></a>00214   <span class="keywordflow">else</span>
<a name="l00215"></a>00215     <a class="code" href="Connectivite__som__elem_8cpp.html#a82161461a228e43ae236c31101ff3ce6" title="construction de la structure som_elem pour la zone donnee On cree pour chaque sommet i la liste des e...">construire_connectivite_som_elem</a>(dom.<a class="code" href="classDomaine.html#abc4abc8b8db5bebeb161fae4162a89ce" title="Renvoie le nombre de sommets.">nb_som</a>(),
<a name="l00216"></a>00216                                      elem_som,
<a name="l00217"></a>00217                                      som_elem,
<a name="l00218"></a>00218                                      0 <span class="comment">/* ne pas inclure les elements virtuels */</span>);
<a name="l00219"></a>00219 
<a name="l00220"></a>00220 
<a name="l00221"></a>00221   <span class="keywordtype">int</span> nb_connexions_perio = 0;
<a name="l00222"></a>00222   <span class="keywordflow">if</span> (liste_bords_periodiques.<a class="code" href="classvect__impl.html#a78155bfbd6b61f4710b9830641ed1694">size</a>() &gt; 0)
<a name="l00223"></a>00223     {
<a name="l00224"></a>00224       <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot; Construction of graph connectivity for periodic boundaries&quot;</span> &lt;&lt; finl;
<a name="l00225"></a>00225       nb_connexions_perio = <a class="code" href="classPartitionneur__base.html#ae4bf98b6e5948e2b368d5b1525d73b76" title="Calcul d&#39;un graphe de connectivite entre les elements lies par des faces periodiques. Si l&#39;element i est voisin de l&#39;element j par une face periodique, alors il existe k tel que graph(i,k)==j et il existe k2 tel que graph(j,k2)==i. Parametre: zone Signification: la zone a traiter Parametre: liste_bords_periodiques Signification: liste des noms des bords periodiques. ATTENTION: on suppose que les faces des bords periodiques sont rangees selon la convention des bords periodiques. Voir check_faces_periodiques(). Parametre: som_elem Signification: la connectivite sommets-elements pour la zone donnee. Parametre: graph Signification: On y stocke le resultat. Valeur de retour: nombre d&#39;elements dans le graphe (egal au nombre de faces periodiques)">Partitionneur_base::calculer_graphe_connexions_periodiques</a>(dom.<a class="code" href="classDomaine.html#a0e62f2bc829542fafa29e3f2c614159c" title="Renvoie la i-ieme zone du domaine. (version const)">zone</a>(0),
<a name="l00226"></a>00226                                                                                        liste_bords_periodiques,
<a name="l00227"></a>00227                                                                                        som_elem,
<a name="l00228"></a>00228                                                                                        my_offset,
<a name="l00229"></a>00229                                                                                        graph_elements_perio);
<a name="l00230"></a>00230     }
<a name="l00231"></a>00231 
<a name="l00232"></a>00232 <span class="comment">// ****************************************************************</span>
<a name="l00233"></a>00233 <span class="comment">// PREMIERE ETAPE: calcul du nombre de vertex et edges du graph:</span>
<a name="l00234"></a>00234 
<a name="l00235"></a>00235 <span class="comment">// Nombre total de faces de bord:</span>
<a name="l00236"></a>00236   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_faces_bord = zone.<a class="code" href="classZone.html#adb3970b0289aa1b0a38772011fd5d915" title="Renvoie le nombre de faces frontiere de la zone du type specifie. C&#39;est la somme des nombres de bords...">nb_faces_frontiere</a>();
<a name="l00237"></a>00237 
<a name="l00238"></a>00238 <span class="comment">// Chaque element du maillage est un &quot;vertex&quot; du graph.</span>
<a name="l00239"></a>00239 <span class="comment">// Les &quot;edges&quot; du graph relient chaque element a ses voisins par une face.</span>
<a name="l00240"></a>00240 <span class="comment">// Il y a autant d&#39;edges que de faces ayant deux voisins, fois 2</span>
<a name="l00241"></a>00241 <span class="comment">// Formule classique: nb_faces internes = nnn/2 avec :</span>
<a name="l00242"></a>00242   <span class="keywordtype">int</span> nnn = nb_elem * nb_faces_par_element - nb_faces_bord + nb_connexions_perio;
<a name="l00243"></a>00243   <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classPoly__geom__base.html" title=": class Poly_geom_base &lt;Description of class Poly_geom_base&gt;">Poly_geom_base</a>,zone.<a class="code" href="classZone.html#a18cf83cd0f9c368dcfa32fb802a0ac94" title="Renvoie un element geometrique du type de ceux qui constituent la zone. (version const)">type_elem</a>().<a class="code" href="classDeriv__Elem__geom__base.html#a384b487459a33f9f521fb16539ec81de">valeur</a>()))
<a name="l00244"></a>00244     {
<a name="l00245"></a>00245       <span class="keyword">const</span> <a class="code" href="classPoly__geom__base.html" title=": class Poly_geom_base &lt;Description of class Poly_geom_base&gt;">Poly_geom_base</a>&amp; poly=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classPoly__geom__base.html" title=": class Poly_geom_base &lt;Description of class Poly_geom_base&gt;">Poly_geom_base</a>,zone.<a class="code" href="classZone.html#a18cf83cd0f9c368dcfa32fb802a0ac94" title="Renvoie un element geometrique du type de ceux qui constituent la zone. (version const)">type_elem</a>().<a class="code" href="classDeriv__Elem__geom__base.html#a384b487459a33f9f521fb16539ec81de">valeur</a>());
<a name="l00246"></a>00246       nnn= poly.<a class="code" href="classPoly__geom__base.html#aa5aae399947d9858e81d2bd6c4edf812">get_somme_nb_faces_elem</a>() - nb_faces_bord + nb_connexions_perio;
<a name="l00247"></a>00247     }
<a name="l00248"></a>00248 
<a name="l00249"></a>00249   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_edges = nnn + nb_faces_bord;
<a name="l00250"></a>00250 
<a name="l00251"></a>00251   <a class="code" href="classDomain__Graph.html#af9e2729c1801be23ecf1237370a9b97c">nvtxs</a> = nb_elem + zone.<a class="code" href="classZone.html#aff77b437f8c58064cc80a3221a0b6130" title="Renvoie le nombre de joints de la zone.">nb_faces_joint</a>(); <span class="comment">//each joint face is linked to a virtual element</span>
<a name="l00252"></a>00252   <a class="code" href="classDomain__Graph.html#ace9fd4d5cc1ff127e4c7ed2f8d189e4a">xadj</a>.<a class="code" href="classArrOfInt.html#a9b3afbb46b16870dbd36236c8935b535">resize_array</a>(nb_elem+1);
<a name="l00253"></a>00253   <a class="code" href="classDomain__Graph.html#ace9fd4d5cc1ff127e4c7ed2f8d189e4a">xadj</a> = -1;
<a name="l00254"></a>00254   <a class="code" href="classDomain__Graph.html#ab9d17a6424dcbf4c43a138c19aaf8016">adjncy</a>.<a class="code" href="classArrOfInt.html#a9b3afbb46b16870dbd36236c8935b535">resize_array</a>(nb_edges+nb_faces_bord);
<a name="l00255"></a>00255   <a class="code" href="classDomain__Graph.html#ab9d17a6424dcbf4c43a138c19aaf8016">adjncy</a> = -1;
<a name="l00256"></a>00256   <a class="code" href="classDomain__Graph.html#ab143b875d41dc9757e8b2472c31efa72">edgegsttab</a>.<a class="code" href="classArrOfInt.html#a9b3afbb46b16870dbd36236c8935b535">resize_array</a>(nb_edges+nb_faces_bord);
<a name="l00257"></a>00257   <a class="code" href="classDomain__Graph.html#ab143b875d41dc9757e8b2472c31efa72">edgegsttab</a> = -1;
<a name="l00258"></a>00258 
<a name="l00259"></a>00259   <a class="code" href="classDomain__Graph.html#a59235e5ba7a37abd767bb8c18c5a3338">vwgts</a>.<a class="code" href="classArrOfInt.html#a9b3afbb46b16870dbd36236c8935b535">resize_array</a>(0); <span class="comment">//NULL</span>
<a name="l00260"></a>00260   <span class="keywordflow">if</span> (! use_weights)
<a name="l00261"></a>00261     {
<a name="l00262"></a>00262       <a class="code" href="classDomain__Graph.html#ad5c25a0bfc7f12a6f18d146ea624b1ec">weightflag</a> = 0;
<a name="l00263"></a>00263       <a class="code" href="classDomain__Graph.html#a16341c1f48e745c57d5b5ad8955a9427">ewgts</a>.<a class="code" href="classArrOfInt.html#a9b3afbb46b16870dbd36236c8935b535">resize_array</a>(0); <span class="comment">//NULL</span>
<a name="l00264"></a>00264     }
<a name="l00265"></a>00265   <span class="keywordflow">else</span>
<a name="l00266"></a>00266     {
<a name="l00267"></a>00267       <a class="code" href="classDomain__Graph.html#ad5c25a0bfc7f12a6f18d146ea624b1ec">weightflag</a> = 1;
<a name="l00268"></a>00268       <a class="code" href="classDomain__Graph.html#a16341c1f48e745c57d5b5ad8955a9427">ewgts</a>.<a class="code" href="classArrOfInt.html#a9b3afbb46b16870dbd36236c8935b535">resize_array</a>(nb_edges + nb_faces_bord);
<a name="l00269"></a>00269     }
<a name="l00270"></a>00270 
<a name="l00271"></a>00271   <a class="code" href="classDomain__Graph.html#ad0879da629d9df6707b70ca0e7030b19">vtxdist</a>.<a class="code" href="classArrOfInt.html#a9b3afbb46b16870dbd36236c8935b535">resize_array</a>(<a class="code" href="classProcess.html#a6bf692ce58d9578aa62ac3c07b8caaa1" title="renvoie le nombre de processeurs dans le groupe courant Voir Comm_Group::nproc() et PE_Groups::curren...">Process::nproc</a>()+1);
<a name="l00272"></a>00272   <span class="keywordflow">for</span>(<span class="keywordtype">int</span> p = 0; p &lt; <a class="code" href="classProcess.html#a6bf692ce58d9578aa62ac3c07b8caaa1" title="renvoie le nombre de processeurs dans le groupe courant Voir Comm_Group::nproc() et PE_Groups::curren...">Process::nproc</a>(); p++)
<a name="l00273"></a>00273     <a class="code" href="classDomain__Graph.html#ad0879da629d9df6707b70ca0e7030b19">vtxdist</a>[p] = offsets[p];
<a name="l00274"></a>00274   <a class="code" href="classDomain__Graph.html#ad0879da629d9df6707b70ca0e7030b19">vtxdist</a>[Process::nproc()] = <a class="code" href="classProcess.html#a7d23bc1ef94b3f0623fbc79d034c27fd" title="Calcule la somme de x sur tous les processeurs du groupe courant. Voir aussi mp_max()">Process::mp_sum</a>(nb_elem);
<a name="l00275"></a>00275 
<a name="l00276"></a>00276   <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot; Construction of the elem_elem connectivity&quot;</span> &lt;&lt; finl;
<a name="l00277"></a>00277 <span class="comment">// ***************************************************************</span>
<a name="l00278"></a>00278 <span class="comment">// DEUXIEME ETAPE: remplissage du graph</span>
<a name="l00279"></a>00279 <span class="comment">// Algorithme: Pour chaque element, boucle sur les faces de l&#39;element</span>
<a name="l00280"></a>00280 <span class="comment">// et on ajoute un &quot;edge&quot; entre l&#39;element et ses voisins. On cherche</span>
<a name="l00281"></a>00281 <span class="comment">// l&#39;element voisin par une face a l&#39;aide de la fonction find_adjacent_elements.</span>
<a name="l00282"></a>00282 <span class="comment">// </span>
<a name="l00283"></a>00283 <span class="comment">// Deux tableaux de travail:</span>
<a name="l00284"></a>00284   <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> une_face(nb_sommets_par_face); <span class="comment">//!&lt; Les sommets de la face en cours</span>
<a name="l00285"></a>00285 <span class="comment"></span>  <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> voisins; <span class="comment">//!&lt; Les elements voisins d&#39;une_face</span>
<a name="l00286"></a>00286 <span class="comment"></span>  voisins.<a class="code" href="classArrOfInt.html#a22d744bcd452d039580d1d9186f02b4e" title="Change le mode l&#39;allocation memoire: reallocation d&#39;un tableau a chaque changement de taille (flag = ...">set_smart_resize</a>(1);
<a name="l00287"></a>00287 
<a name="l00288"></a>00288   <span class="keywordtype">int</span> error = 0;
<a name="l00289"></a>00289   <span class="keywordtype">int</span> edge_count = 0;
<a name="l00290"></a>00290   <span class="keywordtype">int</span> i_elem;
<a name="l00291"></a>00291   <span class="keywordflow">for</span> (i_elem = 0; i_elem &lt; nb_elem; i_elem++)
<a name="l00292"></a>00292     {
<a name="l00293"></a>00293       <a class="code" href="classDomain__Graph.html#ace9fd4d5cc1ff127e4c7ed2f8d189e4a">xadj</a>[i_elem] = edge_count;
<a name="l00294"></a>00294       <span class="keywordtype">int</span> i_face;
<a name="l00295"></a>00295 
<a name="l00296"></a>00296       <span class="keywordflow">if</span> (!is_regular)
<a name="l00297"></a>00297         {
<a name="l00298"></a>00298           <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classPoly__geom__base.html" title=": class Poly_geom_base &lt;Description of class Poly_geom_base&gt;">Poly_geom_base</a>,type_elem).get_tab_faces_sommets_locaux(faces_element_reference,i_elem);
<a name="l00299"></a>00299           <span class="keywordtype">int</span> nb_faces_elem       = faces_element_reference.<a class="code" href="classIntTab.html#abc3b32c94925a82f69d5b153a356e359" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(0);
<a name="l00300"></a>00300           <span class="keywordflow">while</span> ( faces_element_reference(nb_faces_elem-1,0)==-1)
<a name="l00301"></a>00301             nb_faces_elem--;
<a name="l00302"></a>00302           nb_faces_par_element= nb_faces_elem;
<a name="l00303"></a>00303         }
<a name="l00304"></a>00304       <span class="keywordflow">for</span> (i_face = 0; i_face &lt; nb_faces_par_element; i_face++)
<a name="l00305"></a>00305         {
<a name="l00306"></a>00306 <span class="comment">// Construction de cette face de l&#39;element:</span>
<a name="l00307"></a>00307 <span class="comment">// (indice des sommets de la face dans le domaine)</span>
<a name="l00308"></a>00308           {
<a name="l00309"></a>00309             <span class="keywordtype">int</span> i;
<a name="l00310"></a>00310             <span class="keywordflow">for</span> (i = 0; i &lt; nb_sommets_par_face; i++)
<a name="l00311"></a>00311               {
<a name="l00312"></a>00312                 <span class="keyword">const</span> <span class="keywordtype">int</span> i_som = faces_element_reference(i_face, i);
<a name="l00313"></a>00313                 <span class="keywordflow">if</span> (i_som&lt;0)
<a name="l00314"></a>00314                   une_face[i] = i_som;
<a name="l00315"></a>00315                 <span class="keywordflow">else</span>
<a name="l00316"></a>00316                   {
<a name="l00317"></a>00317                     <span class="keyword">const</span> <span class="keywordtype">int</span> sommet = elem_som(i_elem, i_som);
<a name="l00318"></a>00318                     une_face[i] = sommet;
<a name="l00319"></a>00319                   }
<a name="l00320"></a>00320               }
<a name="l00321"></a>00321           }
<a name="l00322"></a>00322 <span class="comment">// Recherche des elements voisins de cette face:</span>
<a name="l00323"></a>00323 <span class="comment">// (indices des elements contenant les sommets de la face)</span>
<a name="l00324"></a>00324           <a class="code" href="Connectivite__som__elem_8cpp.html#afccbadf5344a16154a56b33dbddf88c1" title="Cherche les elements qui contiennent tous les sommets du tableau sommets_to_find (permet de trouver l...">find_adjacent_elements</a>(som_elem, une_face, voisins);
<a name="l00325"></a>00325 
<a name="l00326"></a>00326           <span class="keyword">const</span> <span class="keywordtype">int</span> nb_voisins = voisins.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>();
<a name="l00327"></a>00327           <span class="keywordtype">int</span> elem_voisin = -1;
<a name="l00328"></a>00328           <span class="keywordflow">switch</span> (nb_voisins)
<a name="l00329"></a>00329             {
<a name="l00330"></a>00330             <span class="keywordflow">case</span> 0:
<a name="l00331"></a>00331               {
<a name="l00332"></a>00332 <span class="comment">// Aucun voisin: erreur interne</span>
<a name="l00333"></a>00333                 error = 3;
<a name="l00334"></a>00334                 <span class="keywordflow">break</span>;
<a name="l00335"></a>00335               }
<a name="l00336"></a>00336             <span class="keywordflow">case</span> 1:
<a name="l00337"></a>00337               {
<a name="l00338"></a>00338 <span class="comment">// Un seul voisin, c&#39;est une face frontiere</span>
<a name="l00339"></a>00339                 <span class="keyword">const</span> <span class="keywordtype">int</span> elem = voisins[0];
<a name="l00340"></a>00340                 <span class="keywordflow">if</span> (elem != i_elem + my_offset)
<a name="l00341"></a>00341                   error = 3; <span class="comment">//!&lt; l&#39;element i_elem n&#39;est pas voisin: erreur interne</span>
<a name="l00342"></a>00342 <span class="comment"></span>                <span class="keywordflow">else</span>
<a name="l00343"></a>00343                   elem_voisin = -1;
<a name="l00344"></a>00344                 <span class="keywordflow">break</span>;
<a name="l00345"></a>00345               }
<a name="l00346"></a>00346             <span class="keywordflow">case</span> 2:
<a name="l00347"></a>00347               {
<a name="l00348"></a>00348 <span class="comment">// Le cas le plus courant:</span>
<a name="l00349"></a>00349                 <span class="keyword">const</span> <span class="keywordtype">int</span> elem0 = voisins[0];
<a name="l00350"></a>00350                 <span class="keyword">const</span> <span class="keywordtype">int</span> elem1 = voisins[1];
<a name="l00351"></a>00351                 <span class="keywordflow">if</span> (elem0 == i_elem + my_offset) <span class="comment">//neighbours contain global numerotation</span>
<a name="l00352"></a>00352                   elem_voisin = elem1;
<a name="l00353"></a>00353                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (elem1 == i_elem + my_offset)
<a name="l00354"></a>00354                   elem_voisin = elem0;
<a name="l00355"></a>00355                 <span class="keywordflow">else</span>
<a name="l00356"></a>00356                   error = 3; <span class="comment">//!&lt; l&#39;element i_elem n&#39;est pas voisin: erreur interne</span>
<a name="l00357"></a>00357 <span class="comment"></span>                <span class="keywordflow">break</span>;
<a name="l00358"></a>00358               }
<a name="l00359"></a>00359             <span class="keywordflow">default</span>:
<a name="l00360"></a>00360               {
<a name="l00361"></a>00361 <span class="comment">// Plus de deux voisins</span>
<a name="l00362"></a>00362                 error = 2;
<a name="l00363"></a>00363               }
<a name="l00364"></a>00364             }
<a name="l00365"></a>00365 
<a name="l00366"></a>00366           <span class="keywordflow">if</span> (error)
<a name="l00367"></a>00367             <span class="keywordflow">break</span>;
<a name="l00368"></a>00368 
<a name="l00369"></a>00369           <span class="keywordflow">if</span> (elem_voisin &gt;= 0)
<a name="l00370"></a>00370             {
<a name="l00371"></a>00371               <span class="keywordflow">if</span> (edge_count &gt;= nb_edges)
<a name="l00372"></a>00372                 {
<a name="l00373"></a>00373                   error = 1;
<a name="l00374"></a>00374                   <span class="keywordflow">break</span>;
<a name="l00375"></a>00375                 }
<a name="l00376"></a>00376               <a class="code" href="classDomain__Graph.html#ab9d17a6424dcbf4c43a138c19aaf8016">adjncy</a>[edge_count] = elem_voisin;
<a name="l00377"></a>00377 
<a name="l00378"></a>00378               <span class="keywordflow">if</span> (use_weights)
<a name="l00379"></a>00379                 {
<a name="l00380"></a>00380 <span class="comment">// internal connection have more weight:</span>
<a name="l00381"></a>00381 <span class="comment">// it&#39;s better if the generated partition is not dispatched on several processors</span>
<a name="l00382"></a>00382                   <span class="keywordflow">if</span>( my_offset &lt;= elem_voisin &amp;&amp; elem_voisin &lt; nb_elem+my_offset) <span class="comment">//neighbour belongs to me = strong connection</span>
<a name="l00383"></a>00383                     <a class="code" href="classDomain__Graph.html#a16341c1f48e745c57d5b5ad8955a9427">ewgts</a>[edge_count] = 4;
<a name="l00384"></a>00384                   <span class="keywordflow">else</span>
<a name="l00385"></a>00385                     <a class="code" href="classDomain__Graph.html#a16341c1f48e745c57d5b5ad8955a9427">ewgts</a>[edge_count] = 1; <span class="comment">//!&lt; -1 peut faire des partitions discontinues ou pas equilibrees du tout</span>
<a name="l00386"></a>00386 <span class="comment"></span>
<a name="l00387"></a>00387                 }
<a name="l00388"></a>00388 
<a name="l00389"></a>00389               edge_count++;
<a name="l00390"></a>00390             }
<a name="l00391"></a>00391         }
<a name="l00392"></a>00392 <span class="comment">// Ajout des connexions supplementaires pour les faces periodiques</span>
<a name="l00393"></a>00393       <span class="keywordflow">if</span> (nb_connexions_perio &gt; 0)
<a name="l00394"></a>00394         {
<a name="l00395"></a>00395           <span class="keyword">const</span> <span class="keywordtype">int</span> n = graph_elements_perio.<a class="code" href="classStatic__Int__Lists.html#adbf6903737c3c30bf87e05b29f5a5b56" title="renvoie le nombre d&#39;elements de la liste i">get_list_size</a>(i_elem);
<a name="l00396"></a>00396           <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; n; i++)
<a name="l00397"></a>00397             {
<a name="l00398"></a>00398               <span class="keyword">const</span> <span class="keywordtype">int</span> elem_voisin = graph_elements_perio(i_elem, i);
<a name="l00399"></a>00399               <span class="keywordflow">if</span> (edge_count &gt;= nb_edges)
<a name="l00400"></a>00400                 {
<a name="l00401"></a>00401                   error = 1;
<a name="l00402"></a>00402                   <span class="keywordflow">break</span>;
<a name="l00403"></a>00403                 }
<a name="l00404"></a>00404               <a class="code" href="classDomain__Graph.html#ab9d17a6424dcbf4c43a138c19aaf8016">adjncy</a>[edge_count] = elem_voisin;
<a name="l00405"></a>00405 <span class="comment">// Les connexions entre faces periodiques sont fortes:</span>
<a name="l00406"></a>00406 <span class="comment">// on veut que ces elements soient sur le meme processeur</span>
<a name="l00407"></a>00407 <span class="comment">// Attention, si on met un poids nettement plus eleve que les autres</span>
<a name="l00408"></a>00408 <span class="comment">// edges, on degrade la qualite du decoupage !</span>
<a name="l00409"></a>00409               <span class="keywordflow">if</span> (use_weights)
<a name="l00410"></a>00410                 {
<a name="l00411"></a>00411                   <a class="code" href="classDomain__Graph.html#a16341c1f48e745c57d5b5ad8955a9427">ewgts</a>[edge_count] = 4;
<a name="l00412"></a>00412                 }
<a name="l00413"></a>00413               edge_count++;
<a name="l00414"></a>00414             }
<a name="l00415"></a>00415         }
<a name="l00416"></a>00416       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (use_weights)
<a name="l00417"></a>00417         {
<a name="l00418"></a>00418           <span class="keywordflow">if</span>(Process::nproc() == 1)
<a name="l00419"></a>00419             {
<a name="l00420"></a>00420               <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Warning: You specify use_weights option with Metis but you didn&#39;t use Periodique keyword&quot;</span> &lt;&lt; finl;
<a name="l00421"></a>00421               <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;to define the boundary where periodicity apply.&quot;</span> &lt;&lt; finl;
<a name="l00422"></a>00422               <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Either suppress use_weight or add Periodique keyword.&quot;</span> &lt;&lt; finl;
<a name="l00423"></a>00423               <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">Process::exit</a>();
<a name="l00424"></a>00424             }
<a name="l00425"></a>00425         }
<a name="l00426"></a>00426       <span class="keywordflow">if</span> (error &gt; 0)
<a name="l00427"></a>00427         <span class="keywordflow">break</span>;
<a name="l00428"></a>00428     }
<a name="l00429"></a>00429   <a class="code" href="classDomain__Graph.html#ace9fd4d5cc1ff127e4c7ed2f8d189e4a">xadj</a>[nb_elem] = edge_count;
<a name="l00430"></a>00430   <a class="code" href="classDomain__Graph.html#a5adfd8eda78ca66bd99c1a675b573810">nedges</a> = edge_count;
<a name="l00431"></a>00431 
<a name="l00432"></a>00432   std::map&lt;int,int&gt; global_to_local_index;
<a name="l00433"></a>00433   <span class="keywordtype">int</span> cnt=nb_elem;
<a name="l00434"></a>00434   <span class="keywordflow">for</span>(<span class="keywordtype">int</span> e=0; e&lt;nb_edges + nb_faces_bord; e++)
<a name="l00435"></a>00435     {
<a name="l00436"></a>00436       <span class="keywordtype">int</span> vertex = <a class="code" href="classDomain__Graph.html#ab9d17a6424dcbf4c43a138c19aaf8016">adjncy</a>[e];
<a name="l00437"></a>00437       <span class="keywordflow">if</span>( my_offset &lt;= vertex &amp;&amp; vertex &lt; nb_elem+my_offset) <span class="comment">//neighbour belongs to me</span>
<a name="l00438"></a>00438         {
<a name="l00439"></a>00439           <a class="code" href="classDomain__Graph.html#ab143b875d41dc9757e8b2472c31efa72">edgegsttab</a>[e] = vertex - my_offset;
<a name="l00440"></a>00440         }
<a name="l00441"></a>00441       <span class="keywordflow">else</span>
<a name="l00442"></a>00442         {
<a name="l00443"></a>00443           std::map&lt;int,int&gt;::iterator it = global_to_local_index.find(vertex);
<a name="l00444"></a>00444           <span class="keywordflow">if</span>(it != global_to_local_index.end())
<a name="l00445"></a>00445             {
<a name="l00446"></a>00446               <a class="code" href="classDomain__Graph.html#ab143b875d41dc9757e8b2472c31efa72">edgegsttab</a>[e] = global_to_local_index[vertex];
<a name="l00447"></a>00447 
<a name="l00448"></a>00448             }
<a name="l00449"></a>00449           <span class="keywordflow">else</span>
<a name="l00450"></a>00450             {
<a name="l00451"></a>00451               global_to_local_index[vertex] =cnt++;
<a name="l00452"></a>00452               <a class="code" href="classDomain__Graph.html#ab143b875d41dc9757e8b2472c31efa72">edgegsttab</a>[e] = global_to_local_index[vertex];
<a name="l00453"></a>00453             }
<a name="l00454"></a>00454 
<a name="l00455"></a>00455         }
<a name="l00456"></a>00456     }
<a name="l00457"></a>00457 
<a name="l00458"></a>00458   <span class="keywordflow">if</span> (error == 1)
<a name="l00459"></a>00459     {
<a name="l00460"></a>00460       <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Error in Domaine_Graph::construire_graph_elem_elem\n&quot;</span>
<a name="l00461"></a>00461            &lt;&lt; <span class="stringliteral">&quot; The number of element-element connections is greater than expected\n&quot;</span>
<a name="l00462"></a>00462            &lt;&lt; <span class="stringliteral">&quot; The number of boundary faces is wrong.\n&quot;</span>
<a name="l00463"></a>00463            &lt;&lt; <span class="stringliteral">&quot; You must discretize the domain to check.&quot;</span> &lt;&lt; finl;
<a name="l00464"></a>00464       <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">Process::exit</a>();
<a name="l00465"></a>00465     }
<a name="l00466"></a>00466   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (error == 2)
<a name="l00467"></a>00467     {
<a name="l00468"></a>00468       <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Error in Domain_Graph::construire_graph_elem_elem\n&quot;</span>
<a name="l00469"></a>00469            &lt;&lt; <span class="stringliteral">&quot; Problem in the mesh: one internal face has more than two neighboring elements\n&quot;</span>
<a name="l00470"></a>00470            &lt;&lt; <span class="stringliteral">&quot; List of neighboring elements:&quot;</span> &lt;&lt; voisins
<a name="l00471"></a>00471            &lt;&lt; <span class="stringliteral">&quot;\n Nodes of the face:&quot;</span> &lt;&lt; une_face;
<a name="l00472"></a>00472       <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">Process::exit</a>();
<a name="l00473"></a>00473     }
<a name="l00474"></a>00474   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (error)
<a name="l00475"></a>00475     {
<a name="l00476"></a>00476       <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Internal error in Domain_Graph::construire_graph_elem_elem\n&quot;</span>
<a name="l00477"></a>00477            &lt;&lt; <span class="stringliteral">&quot; (error &quot;</span> &lt;&lt; error &lt;&lt; <span class="stringliteral">&quot;) Problem in neighborhood algorithms&quot;</span>
<a name="l00478"></a>00478            &lt;&lt; finl;
<a name="l00479"></a>00479       <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">Process::exit</a>();
<a name="l00480"></a>00480     }
<a name="l00481"></a>00481 
<a name="l00482"></a>00482 }
<a name="l00483"></a>00483 
</pre></div></div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Tue Dec 14 2021 19:35:17 for TRUST by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
