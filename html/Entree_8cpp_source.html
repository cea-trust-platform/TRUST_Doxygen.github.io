<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>TRUST: src/Kernel/Utilitaires/Entree.cpp Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">TRUST&#160;<span id="projectnumber">1.8.4</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
<div class="header">
  <div class="headertitle">
<div class="title">src/Kernel/Utilitaires/Entree.cpp</div>  </div>
</div>
<div class="contents">
<a href="Entree_8cpp.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/****************************************************************************</span>
<a name="l00002"></a>00002 <span class="comment">* Copyright (c) 2015 - 2016, CEA</span>
<a name="l00003"></a>00003 <span class="comment">* All rights reserved.</span>
<a name="l00004"></a>00004 <span class="comment">*</span>
<a name="l00005"></a>00005 <span class="comment">* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</span>
<a name="l00006"></a>00006 <span class="comment">* 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.</span>
<a name="l00007"></a>00007 <span class="comment">* 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.</span>
<a name="l00008"></a>00008 <span class="comment">* 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.</span>
<a name="l00009"></a>00009 <span class="comment">*</span>
<a name="l00010"></a>00010 <span class="comment">* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.</span>
<a name="l00011"></a>00011 <span class="comment">* IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;</span>
<a name="l00012"></a>00012 <span class="comment">* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>
<a name="l00013"></a>00013 <span class="comment">*</span>
<a name="l00014"></a>00014 <span class="comment">*****************************************************************************/</span>
<a name="l00015"></a>00015 <span class="comment">//</span>
<a name="l00016"></a>00016 <span class="comment">// </span>
<a name="l00017"></a>00017 <span class="comment">// File:        Entree.cpp</span>
<a name="l00018"></a>00018 <span class="comment">// Directory:   $TRUST_ROOT/src/Kernel/Utilitaires</span>
<a name="l00019"></a>00019 <span class="comment">// Version:     /main/Evolutions_166/1</span>
<a name="l00020"></a>00020 <span class="comment">// </span>
<a name="l00021"></a>00021 <span class="comment">//</span>
<a name="l00022"></a>00022 <span class="comment">// </span>
<a name="l00023"></a>00023 <span class="comment">// WARNING: DO NOT EDIT THIS FILE! Only edit the template file Entree.cpp.P</span>
<a name="l00024"></a>00024 <span class="comment">// </span>
<a name="l00025"></a>00025 
<a name="l00026"></a>00026 <span class="preprocessor">#include &lt;<a class="code" href="Entree_8h.html">Entree.h</a>&gt;</span>
<a name="l00027"></a>00027 <span class="preprocessor">#include &lt;<a class="code" href="Objet__U_8h.html">Objet_U.h</a>&gt;</span>
<a name="l00028"></a>00028 <span class="preprocessor">#include &lt;<a class="code" href="Nom_8h.html">Nom.h</a>&gt;</span>
<a name="l00029"></a>00029 <span class="preprocessor">#include &lt;errno.h&gt;</span>
<a name="l00030"></a>00030 <span class="preprocessor">#include &lt;iostream&gt;</span> <span class="comment">//!&lt; Necessaire sur AIX/xlC</span>
<a name="l00031"></a>00031 <span class="comment"></span><span class="preprocessor">#include &lt;fstream&gt;</span>
<a name="l00032"></a>00032 
<a name="l00033"></a>00033 <span class="keyword">using</span> std::ifstream;
<a name="l00034"></a>00034 
<a name="l00035"></a><a class="code" href="classEntree.html#abea15d57ebdf63f78c4b4a1285b1e896">00035</a> istream&amp; <a class="code" href="classEntree.html#abea15d57ebdf63f78c4b4a1285b1e896">Entree::get_istream</a>()
<a name="l00036"></a>00036 {
<a name="l00037"></a>00037   <span class="keywordflow">return</span> *<a class="code" href="classEntree.html#ade65f6710b43ff4d3f4ab683dc538ea7">istream_</a>;
<a name="l00038"></a>00038 }
<a name="l00039"></a>00039 
<a name="l00040"></a><a class="code" href="classEntree.html#a46c0d46a1e76c43caec5e8a142f1683e">00040</a> <span class="keyword">const</span> istream&amp; <a class="code" href="classEntree.html#abea15d57ebdf63f78c4b4a1285b1e896">Entree::get_istream</a>()<span class="keyword"> const</span>
<a name="l00041"></a>00041 <span class="keyword"></span>{
<a name="l00042"></a>00042   <span class="keywordflow">return</span> *<a class="code" href="classEntree.html#ade65f6710b43ff4d3f4ab683dc538ea7">istream_</a>;
<a name="l00043"></a>00043 }
<a name="l00044"></a><a class="code" href="classEntree.html#ac6838cc31c7408ab3e170aa8955e5f85">00044</a> <span class="keywordtype">void</span> <a class="code" href="classEntree.html#ac6838cc31c7408ab3e170aa8955e5f85">Entree::set_istream</a>(istream* is)
<a name="l00045"></a>00045 {
<a name="l00046"></a>00046   <a class="code" href="classEntree.html#ade65f6710b43ff4d3f4ab683dc538ea7">istream_</a> = is;
<a name="l00047"></a>00047 }
<a name="l00048"></a>00048 
<a name="l00049"></a><a class="code" href="classEntree.html#ab03c14526336f31e4691b85617e49873">00049</a> <a class="code" href="classEntree.html" title="Classe de definition des operateurs et methodes pour toute lecture dans un flot d&#39;entree (fichier...">Entree</a>&amp; <a class="code" href="classEntree.html#ab03c14526336f31e4691b85617e49873">Entree::operator &gt;&gt;</a>(<a class="code" href="classEntree.html" title="Classe de definition des operateurs et methodes pour toute lecture dans un flot d&#39;entree (fichier...">Entree</a>&amp; (*f)(<a class="code" href="classEntree.html" title="Classe de definition des operateurs et methodes pour toute lecture dans un flot d&#39;entree (fichier...">Entree</a>&amp;))
<a name="l00050"></a>00050 {
<a name="l00051"></a>00051   (*f)(*this);
<a name="l00052"></a>00052   <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00053"></a>00053 }
<a name="l00054"></a><a class="code" href="classEntree.html#aa0ccc48dad7d914e803b92aaad079b06">00054</a> <a class="code" href="classEntree.html" title="Classe de definition des operateurs et methodes pour toute lecture dans un flot d&#39;entree (fichier...">Entree</a>&amp; <a class="code" href="classEntree.html#ab03c14526336f31e4691b85617e49873">Entree::operator &gt;&gt;</a>(istream&amp; (*f)(istream&amp;))
<a name="l00055"></a>00055 {
<a name="l00056"></a>00056   (*f)(*istream_);
<a name="l00057"></a>00057   <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00058"></a>00058 }
<a name="l00059"></a><a class="code" href="classEntree.html#af07c6f4c56b17826b1944b3d687a45b2">00059</a> <a class="code" href="classEntree.html" title="Classe de definition des operateurs et methodes pour toute lecture dans un flot d&#39;entree (fichier...">Entree</a>&amp; <a class="code" href="classEntree.html#ab03c14526336f31e4691b85617e49873">Entree::operator &gt;&gt;</a>(ios&amp; (*f)(ios&amp;))
<a name="l00060"></a>00060 {
<a name="l00061"></a>00061   (*f)(*istream_);
<a name="l00062"></a>00062   <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00063"></a>00063 }
<a name="l00064"></a>00064 
<a name="l00065"></a><a class="code" href="classEntree.html#a1d7d765ff974d3e6f26398a11ef4a72b">00065</a> <a class="code" href="classEntree.html#a1d7d765ff974d3e6f26398a11ef4a72b">Entree::Entree</a>()
<a name="l00066"></a>00066 {
<a name="l00067"></a>00067   <a class="code" href="classEntree.html#abfecba6a0869b6593bf8ad753f8c53c7">bin_</a>=0;
<a name="l00068"></a>00068   <a class="code" href="classEntree.html#a6e671ed777e5305caa22d8820de500fe" title="File with int32 (or int64) whereas version is int64 (or int32à">is_different_int_size_</a>=<span class="keyword">false</span>;
<a name="l00069"></a>00069   <a class="code" href="classEntree.html#ade65f6710b43ff4d3f4ab683dc538ea7">istream_</a> = 0;
<a name="l00070"></a>00070   <a class="code" href="classEntree.html#aaf7cb8edc33dc7e5e9849f8c6e6bd935">check_types_</a> = 0;
<a name="l00071"></a>00071   <a class="code" href="classEntree.html#a9c2846af38c76af98d064e665c964b20">error_action_</a> = <a class="code" href="classEntree.html#a92919bfab8dfa0cfdf8cf8e3dc13b078a88176e2e0001a6717ea71baa58bea2a6">ERROR_CONTINUE</a>;
<a name="l00072"></a>00072   <a class="code" href="classEntree.html#a06ff6db21997af440f1e977673fea6d0" title="By default 1, but some child classes (eg: LecFicDiffuse) could set temporary to 0 to not diffuse to o...">diffuse_</a> = 1;
<a name="l00073"></a>00073 }
<a name="l00074"></a>00074 
<a name="l00075"></a><a class="code" href="classEntree.html#a7ce0d95383baef0a8dc4b944f8f14a6e">00075</a> <a class="code" href="classEntree.html#a1d7d765ff974d3e6f26398a11ef4a72b">Entree::Entree</a>(istream&amp; is)
<a name="l00076"></a>00076 {
<a name="l00077"></a>00077   <a class="code" href="classEntree.html#abfecba6a0869b6593bf8ad753f8c53c7">bin_</a>=0;
<a name="l00078"></a>00078   <a class="code" href="classEntree.html#a6e671ed777e5305caa22d8820de500fe" title="File with int32 (or int64) whereas version is int64 (or int32à">is_different_int_size_</a>=<span class="keyword">false</span>;
<a name="l00079"></a>00079   <a class="code" href="classEntree.html#ade65f6710b43ff4d3f4ab683dc538ea7">istream_</a> = <span class="keyword">new</span> istream(is.rdbuf());
<a name="l00080"></a>00080   <a class="code" href="classEntree.html#aaf7cb8edc33dc7e5e9849f8c6e6bd935">check_types_</a> = 0;
<a name="l00081"></a>00081   <a class="code" href="classEntree.html#a9c2846af38c76af98d064e665c964b20">error_action_</a> = <a class="code" href="classEntree.html#a92919bfab8dfa0cfdf8cf8e3dc13b078a88176e2e0001a6717ea71baa58bea2a6">ERROR_CONTINUE</a>;
<a name="l00082"></a>00082   <a class="code" href="classEntree.html#a06ff6db21997af440f1e977673fea6d0" title="By default 1, but some child classes (eg: LecFicDiffuse) could set temporary to 0 to not diffuse to o...">diffuse_</a> = 1;
<a name="l00083"></a>00083 }
<a name="l00084"></a>00084 
<a name="l00085"></a><a class="code" href="classEntree.html#ae07ade952f330d2f788d285cf4c3986e">00085</a> <a class="code" href="classEntree.html#a1d7d765ff974d3e6f26398a11ef4a72b">Entree::Entree</a>(<span class="keyword">const</span> <a class="code" href="classEntree.html" title="Classe de definition des operateurs et methodes pour toute lecture dans un flot d&#39;entree (fichier...">Entree</a>&amp; is)
<a name="l00086"></a>00086 {
<a name="l00087"></a>00087   <a class="code" href="classEntree.html#abfecba6a0869b6593bf8ad753f8c53c7">bin_</a>=0;
<a name="l00088"></a>00088   <a class="code" href="classEntree.html#a6e671ed777e5305caa22d8820de500fe" title="File with int32 (or int64) whereas version is int64 (or int32à">is_different_int_size_</a>=<span class="keyword">false</span>;
<a name="l00089"></a>00089   <a class="code" href="classEntree.html#ade65f6710b43ff4d3f4ab683dc538ea7">istream_</a> = <span class="keyword">new</span> istream(is.<a class="code" href="classEntree.html#abea15d57ebdf63f78c4b4a1285b1e896">get_istream</a>().rdbuf());
<a name="l00090"></a>00090   <a class="code" href="classEntree.html#aaf7cb8edc33dc7e5e9849f8c6e6bd935">check_types_</a> = 0;
<a name="l00091"></a>00091   <a class="code" href="classEntree.html#a9c2846af38c76af98d064e665c964b20">error_action_</a> = <a class="code" href="classEntree.html#a92919bfab8dfa0cfdf8cf8e3dc13b078a88176e2e0001a6717ea71baa58bea2a6">ERROR_CONTINUE</a>;
<a name="l00092"></a>00092   <a class="code" href="classEntree.html#a06ff6db21997af440f1e977673fea6d0" title="By default 1, but some child classes (eg: LecFicDiffuse) could set temporary to 0 to not diffuse to o...">diffuse_</a> = 1;
<a name="l00093"></a>00093 }
<a name="l00094"></a>00094 
<a name="l00095"></a>00095 <span class="comment">// Operateurs d&#39;affectation</span>
<a name="l00096"></a><a class="code" href="classEntree.html#a399b182f8e686f269f0278c0bb1978ec">00096</a> <a class="code" href="classEntree.html" title="Classe de definition des operateurs et methodes pour toute lecture dans un flot d&#39;entree (fichier...">Entree</a>&amp; <a class="code" href="classEntree.html#a399b182f8e686f269f0278c0bb1978ec">Entree::operator=</a>(istream&amp; is)
<a name="l00097"></a>00097 {
<a name="l00098"></a>00098   <span class="keywordflow">if</span>(<a class="code" href="classEntree.html#ade65f6710b43ff4d3f4ab683dc538ea7">istream_</a>)
<a name="l00099"></a>00099     <span class="keyword">delete</span> <a class="code" href="classEntree.html#ade65f6710b43ff4d3f4ab683dc538ea7">istream_</a>;
<a name="l00100"></a>00100   <a class="code" href="classEntree.html#ade65f6710b43ff4d3f4ab683dc538ea7">istream_</a> = <span class="keyword">new</span> istream(is.rdbuf());
<a name="l00101"></a>00101   <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00102"></a>00102 }
<a name="l00103"></a>00103 
<a name="l00104"></a><a class="code" href="classEntree.html#a4cf042a24d91bd3c7bb3d35e3aebb814">00104</a> <a class="code" href="classEntree.html" title="Classe de definition des operateurs et methodes pour toute lecture dans un flot d&#39;entree (fichier...">Entree</a>&amp; <a class="code" href="classEntree.html#a399b182f8e686f269f0278c0bb1978ec">Entree::operator=</a>(<a class="code" href="classEntree.html" title="Classe de definition des operateurs et methodes pour toute lecture dans un flot d&#39;entree (fichier...">Entree</a>&amp; is)
<a name="l00105"></a>00105 {
<a name="l00106"></a>00106   <span class="keywordflow">if</span>(<a class="code" href="classEntree.html#ade65f6710b43ff4d3f4ab683dc538ea7">istream_</a>)
<a name="l00107"></a>00107     <span class="keyword">delete</span> <a class="code" href="classEntree.html#ade65f6710b43ff4d3f4ab683dc538ea7">istream_</a>;
<a name="l00108"></a>00108   <a class="code" href="classEntree.html#ade65f6710b43ff4d3f4ab683dc538ea7">istream_</a> = <span class="keyword">new</span> istream(is.<a class="code" href="classEntree.html#abea15d57ebdf63f78c4b4a1285b1e896">get_istream</a>().rdbuf());
<a name="l00109"></a>00109   <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00110"></a>00110 }
<a name="l00111"></a>00111 
<a name="l00112"></a>00112 <span class="comment">//</span>
<a name="l00113"></a>00113 <span class="comment">//</span>
<a name="l00114"></a>00114 <span class="comment">//</span>
<a name="l00115"></a>00115 <span class="comment">//</span>
<a name="l00116"></a>00116 <span class="comment">//</span>
<a name="l00117"></a>00117 <span class="comment">//</span>
<a name="l00118"></a>00118 <span class="comment">//</span>
<a name="l00119"></a>00119 <span class="comment">//</span>
<a name="l00120"></a>00120 <span class="comment">//</span>
<a name="l00121"></a>00121 <span class="comment">//</span>
<a name="l00122"></a>00122 <span class="comment">//</span>
<a name="l00123"></a>00123 <span class="comment">//</span><span class="comment"></span>
<a name="l00124"></a>00124 <span class="comment">//! Lecture d&#39;une chaine dans ostream_&lt;br&gt;bufsize est la taille du buffer alloue pour ob (y compris&lt;br&gt;le caractere 0 final).&lt;br&gt;La chaine contient toujours un 0 meme en cas d&#39;echec.&lt;br&gt;La methode renvoie 1 si la lecture est bonne, 0 sinon.&lt;br&gt;Si le buffer est trop petit, pour l&#39;instant on fait exit() mais&lt;br&gt;par la suite on pourra tester: si strlen(ob)==bufsize-1, alors&lt;br&gt;refaire lire() jusqu&#39;a arriver au bout. Si le lire() suivant&lt;br&gt;renvoie une chaine de longueur nulle, cela signifie que la taille de la&lt;br&gt;chaine etait exactement bufsize-1.&lt;br&gt;Attention: le comportement est different en binaire et en ascii.&lt;br&gt;En binaire, on lit la chaine jusqu&#39;au prochain &#39;\\0&#39;.&lt;br&gt;En ascii, on lit la chaine jusqu&#39;au prochain separateur (espace, tab, fin ligne)</span>
<a name="l00125"></a><a class="code" href="classEntree.html#ab9fef2894aec030749940508694e258c">00125</a> <span class="comment"></span><span class="keywordtype">int</span> <a class="code" href="classEntree.html#aa434f5ceb8169e469613d1f6cd1fd99f" title="methode virtuelle pour lire un tableau d&#39;ints ou reels&lt;br&gt;(le tableau doit avoir la bonne dimension: ...">Entree::get</a>(<span class="keywordtype">char</span>* ob, <span class="keywordtype">int</span> bufsize)
<a name="l00126"></a>00126 {
<a name="l00127"></a>00127   assert(<a class="code" href="classEntree.html#ade65f6710b43ff4d3f4ab683dc538ea7">istream_</a>!=0);
<a name="l00128"></a>00128   assert(bufsize &gt; 0);
<a name="l00129"></a>00129   ob[bufsize-1] = 1;
<a name="l00130"></a>00130   <span class="keywordflow">if</span>(<a class="code" href="classEntree.html#abfecba6a0869b6593bf8ad753f8c53c7">bin_</a>)
<a name="l00131"></a>00131     {
<a name="l00132"></a>00132 <span class="comment">// En binaire, on lit jusqu&#39;au prochain caractere 0</span>
<a name="l00133"></a>00133 <span class="comment">// (y compris espaces, retours a la ligne etc)</span>
<a name="l00134"></a>00134       <span class="keywordtype">int</span> i;
<a name="l00135"></a>00135       <span class="keywordflow">for</span> (i = 0; i &lt; bufsize-1; i++)
<a name="l00136"></a>00136         {
<a name="l00137"></a>00137           (*istream_).read(ob+i, <span class="keyword">sizeof</span>(<span class="keywordtype">char</span>));
<a name="l00138"></a>00138           <span class="keywordflow">if</span> (!<a class="code" href="classEntree.html#a11dc4a4e2ae1fbf9c0ba1da1cfa157c8" title="methode inline pour traiter rapidement le cas trivial. Sinon, appel a la methode virtuelle error_hand...">error_handle</a>(<a class="code" href="classEntree.html#ade65f6710b43ff4d3f4ab683dc538ea7">istream_</a>-&gt;fail()))
<a name="l00139"></a>00139             ob[i] = 0;
<a name="l00140"></a>00140           <span class="keywordflow">if</span> (ob[i] == 0)
<a name="l00141"></a>00141             <span class="keywordflow">break</span>;
<a name="l00142"></a>00142         }
<a name="l00143"></a>00143       ob[i] = 0;
<a name="l00144"></a>00144     }
<a name="l00145"></a>00145   <span class="keywordflow">else</span>
<a name="l00146"></a>00146     {
<a name="l00147"></a>00147 <span class="comment">// L&#39;appel suivant permet a l&#39;operateur&gt;&gt; de limiter le nombre</span>
<a name="l00148"></a>00148 <span class="comment">// de caracteres lus. On lira au maximum bufsize-1 caracteres.</span>
<a name="l00149"></a>00149       <a class="code" href="classEntree.html#ade65f6710b43ff4d3f4ab683dc538ea7">istream_</a>-&gt;width(bufsize);
<a name="l00150"></a>00150       (*istream_) &gt;&gt; ob;
<a name="l00151"></a>00151       <span class="keywordflow">if</span> (!<a class="code" href="classEntree.html#a11dc4a4e2ae1fbf9c0ba1da1cfa157c8" title="methode inline pour traiter rapidement le cas trivial. Sinon, appel a la methode virtuelle error_hand...">error_handle</a>(<a class="code" href="classEntree.html#ade65f6710b43ff4d3f4ab683dc538ea7">istream_</a>-&gt;fail()))
<a name="l00152"></a>00152         ob[0] = 0;
<a name="l00153"></a>00153     }
<a name="l00154"></a>00154   <span class="keywordflow">if</span> (ob[bufsize-1] == 0)
<a name="l00155"></a>00155     {
<a name="l00156"></a>00156 <span class="comment">// Note Benoit Mathieu:</span>
<a name="l00157"></a>00157 <span class="comment">// Si on a rempli le buffer jusqu&#39;au bout, c&#39;est qu&#39;il est probablement</span>
<a name="l00158"></a>00158 <span class="comment">// trop petit. Lire la suite est dangereux car en ascii on ne sait pas</span>
<a name="l00159"></a>00159 <span class="comment">// si on a pu lire pile poil la chaine (donc c&#39;est ok), ou si la chaine</span>
<a name="l00160"></a>00160 <span class="comment">// n&#39;a pas ete lue en int. Il faut tester tres serieusement la stl et</span>
<a name="l00161"></a>00161 <span class="comment">// ca depend sans doute de l&#39;implementation. Donc, si le buffer est plein,</span>
<a name="l00162"></a>00162 <span class="comment">// on plante le code et tant pis.</span>
<a name="l00163"></a>00163       <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Error in Entree::lire(char* ob, int bufsize) : buffer too small&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
<a name="l00164"></a>00164       <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">Process::exit</a>();
<a name="l00165"></a>00165     }
<a name="l00166"></a>00166   <span class="keywordflow">return</span> (!<a class="code" href="classEntree.html#ade65f6710b43ff4d3f4ab683dc538ea7">istream_</a>-&gt;fail());
<a name="l00167"></a>00167 }
<a name="l00168"></a>00168 
<a name="l00169"></a>00169 <span class="comment"></span>
<a name="l00170"></a>00170 <span class="comment">//! methode de conversion</span>
<a name="l00171"></a><a class="code" href="Entree_8cpp.html#adab26b7ff2235f272ceadea720b4a65e">00171</a> <span class="comment"></span><span class="keywordtype">void</span> <a class="code" href="Avanc_8cpp.html#a98c8f11a2783c4bdf1a9484db0dc3c3b">convert_to</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *s, <span class="keywordtype">int</span>&amp; ob)
<a name="l00172"></a>00172 {
<a name="l00173"></a>00173   errno = 0;
<a name="l00174"></a>00174   <span class="keywordtype">char</span> * errorptr = 0;
<a name="l00175"></a>00175   ob = strtol(s, &amp;errorptr, 0 <span class="comment">/* base 10 par defaut */</span>);
<a name="l00176"></a>00176   <span class="keywordflow">if</span> (errno || *errorptr != 0)
<a name="l00177"></a>00177     {
<a name="l00178"></a>00178       <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Error converting a string to type long : string = &quot;</span> &lt;&lt; s &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
<a name="l00179"></a>00179       <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">Process::exit</a>();
<a name="l00180"></a>00180     }
<a name="l00181"></a>00181 }
<a name="l00182"></a>00182 <span class="preprocessor">#ifndef INT_is_64_</span>
<a name="l00183"></a><a class="code" href="Entree_8cpp.html#a5cd71730f9a555a36aeac15cca7bc4f3">00183</a> <span class="preprocessor"></span><span class="keywordtype">void</span> <a class="code" href="Avanc_8cpp.html#a98c8f11a2783c4bdf1a9484db0dc3c3b">convert_to</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *s, <span class="keywordtype">long</span>&amp; ob)
<a name="l00184"></a>00184 {
<a name="l00185"></a>00185   errno = 0;
<a name="l00186"></a>00186   <span class="keywordtype">char</span> * errorptr = 0;
<a name="l00187"></a>00187   ob = strtol(s, &amp;errorptr, 0 <span class="comment">/* base 10 par defaut */</span>);
<a name="l00188"></a>00188   <span class="keywordflow">if</span> (errno || *errorptr != 0)
<a name="l00189"></a>00189     {
<a name="l00190"></a>00190       <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Error converting a string to type long : string = &quot;</span> &lt;&lt; s &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
<a name="l00191"></a>00191       <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">Process::exit</a>();
<a name="l00192"></a>00192     }
<a name="l00193"></a>00193 }
<a name="l00194"></a>00194 <span class="preprocessor">#endif</span>
<a name="l00195"></a><a class="code" href="Entree_8cpp.html#ab51b1eff053896f2bb3b78754900539a">00195</a> <span class="preprocessor"></span><span class="keywordtype">void</span> <a class="code" href="Avanc_8cpp.html#a98c8f11a2783c4bdf1a9484db0dc3c3b">convert_to</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *s, <span class="keywordtype">long</span> <span class="keywordtype">long</span>&amp; ob)
<a name="l00196"></a>00196 {
<a name="l00197"></a>00197   errno = 0;
<a name="l00198"></a>00198   <span class="keywordtype">char</span> * errorptr = 0;
<a name="l00199"></a>00199 <span class="preprocessor">#ifdef HPPA_11 </span><span class="comment">/* NO_PROCESS */</span>
<a name="l00200"></a>00200   ob = strtol(s, &amp;errorptr, 0 <span class="comment">/* base 10 par defaut */</span>);
<a name="l00201"></a>00201 <span class="preprocessor">#else </span><span class="comment">/* NO_PROCESS */</span>
<a name="l00202"></a>00202 <span class="preprocessor">#ifdef MICROSOFT</span>
<a name="l00203"></a>00203 <span class="preprocessor"></span>  ob = _strtoi64(s, &amp;errorptr, 0 <span class="comment">/* base 10 par defaut */</span>);
<a name="l00204"></a>00204 <span class="preprocessor">#else</span>
<a name="l00205"></a>00205 <span class="preprocessor"></span>  ob = strtoll(s, &amp;errorptr, 0 <span class="comment">/* base 10 par defaut */</span>);
<a name="l00206"></a>00206 <span class="preprocessor">#endif</span>
<a name="l00207"></a>00207 <span class="preprocessor"></span><span class="preprocessor">#endif </span><span class="comment">/* NO_PROCESS */</span>
<a name="l00208"></a>00208   <span class="keywordflow">if</span> (errno || *errorptr != 0)
<a name="l00209"></a>00209     {
<a name="l00210"></a>00210       <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Error converting a string to type long long : string = &quot;</span> &lt;&lt; s &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
<a name="l00211"></a>00211       <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">Process::exit</a>();
<a name="l00212"></a>00212     }
<a name="l00213"></a>00213 }
<a name="l00214"></a><a class="code" href="Entree_8cpp.html#ab2e4cc3700ece1f3f8b5669b98bdd85d">00214</a> <span class="keywordtype">void</span> <a class="code" href="Avanc_8cpp.html#a98c8f11a2783c4bdf1a9484db0dc3c3b">convert_to</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *s, <span class="keywordtype">float</span>&amp; ob)
<a name="l00215"></a>00215 {
<a name="l00216"></a>00216   errno = 0;
<a name="l00217"></a>00217   <span class="keywordtype">char</span> * errorptr = 0;
<a name="l00218"></a>00218 <span class="preprocessor">#ifndef _COMPILE_AVEC_GCC_ </span><span class="comment">/* NO_PROCESS */</span>
<a name="l00219"></a>00219 <span class="comment">// PL: strtof n&#39;existe pas semble t&#39;il qu&#39;avec gcc. pour le reste on utiliser strtod</span>
<a name="l00220"></a>00220 <span class="comment">// BM: le risque, c&#39;est qu&#39;on ait un overflow qu&#39;on ne detectera pas avec stdtod</span>
<a name="l00221"></a>00221   ob = strtod(s, &amp;errorptr);
<a name="l00222"></a>00222 <span class="preprocessor">#else </span><span class="comment">/* NO_PROCESS */</span>
<a name="l00223"></a>00223   ob = strtof(s, &amp;errorptr);
<a name="l00224"></a>00224 <span class="preprocessor">#endif </span><span class="comment">/* NO_PROCESS */</span>
<a name="l00225"></a>00225   <span class="keywordflow">if</span> (errno || *errorptr != 0)
<a name="l00226"></a>00226     {
<a name="l00227"></a>00227       <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Error converting a string to type float : string = &quot;</span> &lt;&lt; s &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
<a name="l00228"></a>00228       <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">Process::exit</a>();
<a name="l00229"></a>00229     }
<a name="l00230"></a>00230 }
<a name="l00231"></a>00231 
<a name="l00232"></a><a class="code" href="Perte__Charge__Singuliere_8cpp.html#a98c8f11a2783c4bdf1a9484db0dc3c3b">00232</a> <span class="keywordtype">void</span> <a class="code" href="Avanc_8cpp.html#a98c8f11a2783c4bdf1a9484db0dc3c3b">convert_to</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *s, <span class="keywordtype">double</span>&amp; ob)
<a name="l00233"></a>00233 {
<a name="l00234"></a>00234   errno = 0;
<a name="l00235"></a>00235   <span class="keywordtype">char</span> * errorptr = 0;
<a name="l00236"></a>00236   ob = strtod(s, &amp;errorptr);
<a name="l00237"></a>00237   <span class="keywordflow">if</span> (errno || *errorptr != 0)
<a name="l00238"></a>00238     {
<a name="l00239"></a>00239       <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Error converting a string to type float : string = &quot;</span> &lt;&lt; s &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
<a name="l00240"></a>00240       <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">Process::exit</a>();
<a name="l00241"></a>00241     }
<a name="l00242"></a>00242 }
<a name="l00243"></a>00243 
<a name="l00244"></a>00244 
<a name="l00245"></a>00245 <span class="comment">//</span>
<a name="l00246"></a>00246 <span class="comment">//</span>
<a name="l00247"></a>00247 <span class="comment">//</span>
<a name="l00248"></a>00248 <span class="comment">//</span>
<a name="l00249"></a>00249 <span class="comment">//</span>
<a name="l00250"></a>00250 <span class="comment">//</span>
<a name="l00251"></a>00251 <span class="comment">//</span>
<a name="l00252"></a>00252 <span class="comment">//</span><span class="comment"></span>
<a name="l00253"></a>00253 <span class="comment">//! methode virtuelle pour lire un int ou un reel.&lt;br&gt;Dans cette classe de base, on lit dans le istream avec read() (si is_bin() == 1)&lt;br&gt;ou avec operator&gt;&gt;() (si is_bin() == 0). Si le drapeau check_types est mis,&lt;br&gt;on appelle convert_to() pour verifier les types des objets lus.&lt;br&gt;Dans ce cas, pour les ints on comprend les formats 123 (decimal),&lt;br&gt;0xa345 (hexa) et autres.&lt;br&gt;Si une erreur se produit, on appelle error_handle_()&lt;br&gt;Note pour les programmeurs des classes derivees:&lt;br&gt;L&#39;implementation de cette methode doit toujours passer par hande_error()</span>
<a name="l00254"></a><a class="code" href="classEntree.html#a18e251a8186bd7f5df18a3d69c068aca">00254</a> <span class="comment"></span><a class="code" href="classEntree.html" title="Classe de definition des operateurs et methodes pour toute lecture dans un flot d&#39;entree (fichier...">Entree</a>&amp; <a class="code" href="classEntree.html#ab03c14526336f31e4691b85617e49873">Entree::operator&gt;&gt;</a>(<span class="keywordtype">int</span>&amp; ob)
<a name="l00255"></a>00255 {
<a name="l00256"></a>00256   assert(<a class="code" href="classEntree.html#ade65f6710b43ff4d3f4ab683dc538ea7">istream_</a>!=0);
<a name="l00257"></a>00257   <span class="keywordflow">if</span> (<a class="code" href="classEntree.html#abfecba6a0869b6593bf8ad753f8c53c7">bin_</a>)
<a name="l00258"></a>00258     {
<a name="l00259"></a>00259       <span class="keywordflow">if</span> (<a class="code" href="classEntree.html#a6e671ed777e5305caa22d8820de500fe" title="File with int32 (or int64) whereas version is int64 (or int32à">is_different_int_size_</a>)
<a name="l00260"></a>00260         {
<a name="l00261"></a>00261 <span class="preprocessor">#ifdef INT_is_64_</span>
<a name="l00262"></a>00262 <span class="preprocessor"></span>          <a class="code" href="arch_8h.html#a1caaf369d9c5f0817dbaa76b43b8d87b">True_int</a> pr;
<a name="l00263"></a>00263           <span class="keywordtype">char</span> * ptr = (<span class="keywordtype">char</span>*) &amp;pr;
<a name="l00264"></a>00264           <a class="code" href="classEntree.html#ade65f6710b43ff4d3f4ab683dc538ea7">istream_</a>-&gt;read(ptr, <span class="keyword">sizeof</span>(<a class="code" href="arch_8h.html#a1caaf369d9c5f0817dbaa76b43b8d87b">True_int</a>));
<a name="l00265"></a>00265           ob=pr;
<a name="l00266"></a>00266 <span class="preprocessor">#else</span>
<a name="l00267"></a>00267 <span class="preprocessor"></span>          <span class="keywordtype">long</span> pr;
<a name="l00268"></a>00268           <span class="keywordtype">char</span> * ptr = (<span class="keywordtype">char</span>*) &amp;pr;
<a name="l00269"></a>00269           <a class="code" href="classEntree.html#ade65f6710b43ff4d3f4ab683dc538ea7">istream_</a>-&gt;read(ptr, <span class="keyword">sizeof</span>(<span class="keywordtype">long</span>));
<a name="l00270"></a>00270           <span class="keywordflow">if</span> (pr&gt;INT32_MAX) <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">Process::exit</a>(<span class="stringliteral">&quot;Can&#39;t read this int64 binary file with an int32 binary: overflow.&quot;</span>);
<a name="l00271"></a>00271           ob=pr;
<a name="l00272"></a>00272 <span class="preprocessor">#endif</span>
<a name="l00273"></a>00273 <span class="preprocessor"></span>        }
<a name="l00274"></a>00274       <span class="keywordflow">else</span>
<a name="l00275"></a>00275         {
<a name="l00276"></a>00276           <span class="keywordtype">char</span> * ptr = (<span class="keywordtype">char</span>*) &amp;ob;
<a name="l00277"></a>00277           <a class="code" href="classEntree.html#ade65f6710b43ff4d3f4ab683dc538ea7">istream_</a>-&gt;read(ptr, <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>));
<a name="l00278"></a>00278           <a class="code" href="classEntree.html#a11dc4a4e2ae1fbf9c0ba1da1cfa157c8" title="methode inline pour traiter rapidement le cas trivial. Sinon, appel a la methode virtuelle error_hand...">error_handle</a>(<a class="code" href="classEntree.html#ade65f6710b43ff4d3f4ab683dc538ea7">istream_</a>-&gt;fail());
<a name="l00279"></a>00279         }
<a name="l00280"></a>00280     }
<a name="l00281"></a>00281   <span class="keywordflow">else</span>
<a name="l00282"></a>00282     {
<a name="l00283"></a>00283       <span class="keywordflow">if</span> (<a class="code" href="classEntree.html#aaf7cb8edc33dc7e5e9849f8c6e6bd935">check_types_</a>)
<a name="l00284"></a>00284         {
<a name="l00285"></a>00285           <span class="keywordtype">char</span> buffer[100];
<a name="l00286"></a>00286           <span class="keywordtype">int</span> ok = <a class="code" href="classEntree.html#aa434f5ceb8169e469613d1f6cd1fd99f" title="methode virtuelle pour lire un tableau d&#39;ints ou reels&lt;br&gt;(le tableau doit avoir la bonne dimension: ...">Entree::get</a>(buffer, 100); <span class="comment">//!&lt; Bien appeler get de cette classe</span>
<a name="l00287"></a>00287 <span class="comment"></span>          <span class="keywordflow">if</span> (ok)
<a name="l00288"></a>00288             <a class="code" href="Avanc_8cpp.html#a98c8f11a2783c4bdf1a9484db0dc3c3b">convert_to</a>(buffer, ob);
<a name="l00289"></a>00289         }
<a name="l00290"></a>00290       <span class="keywordflow">else</span>
<a name="l00291"></a>00291         {
<a name="l00292"></a>00292           (*istream_) &gt;&gt; ob;
<a name="l00293"></a>00293           <a class="code" href="classEntree.html#a11dc4a4e2ae1fbf9c0ba1da1cfa157c8" title="methode inline pour traiter rapidement le cas trivial. Sinon, appel a la methode virtuelle error_hand...">error_handle</a>(<a class="code" href="classEntree.html#ade65f6710b43ff4d3f4ab683dc538ea7">istream_</a>-&gt;fail());
<a name="l00294"></a>00294         }
<a name="l00295"></a>00295     }
<a name="l00296"></a>00296   <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00297"></a>00297 }
<a name="l00298"></a>00298 
<a name="l00299"></a>00299 <span class="comment">//</span>
<a name="l00300"></a>00300 <span class="comment">//</span><span class="comment"></span>
<a name="l00301"></a>00301 <span class="comment">//! methode virtuelle pour lire un tableau d&#39;ints ou reels&lt;br&gt;(le tableau doit avoir la bonne dimension: attention pas de verification possible)&lt;br&gt;Voir aussi operator&gt;&gt;()</span>
<a name="l00302"></a><a class="code" href="classEntree.html#aa434f5ceb8169e469613d1f6cd1fd99f">00302</a> <span class="comment"></span><span class="keywordtype">int</span> <a class="code" href="classEntree.html#aa434f5ceb8169e469613d1f6cd1fd99f" title="methode virtuelle pour lire un tableau d&#39;ints ou reels&lt;br&gt;(le tableau doit avoir la bonne dimension: ...">Entree::get</a>(<span class="keywordtype">int</span> * ob, <span class="keywordtype">int</span> n)
<a name="l00303"></a>00303 {
<a name="l00304"></a>00304   assert(<a class="code" href="classEntree.html#ade65f6710b43ff4d3f4ab683dc538ea7">istream_</a>!=0);
<a name="l00305"></a>00305   assert(n &gt;= 0);
<a name="l00306"></a>00306   <span class="keywordflow">if</span> (<a class="code" href="classEntree.html#abfecba6a0869b6593bf8ad753f8c53c7">bin_</a>)
<a name="l00307"></a>00307     {
<a name="l00308"></a>00308       <span class="keywordflow">if</span> (<a class="code" href="classEntree.html#a6e671ed777e5305caa22d8820de500fe" title="File with int32 (or int64) whereas version is int64 (or int32à">is_different_int_size_</a>)
<a name="l00309"></a>00309         {
<a name="l00310"></a>00310           <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;n; i++)
<a name="l00311"></a>00311             (*<span class="keyword">this</span>)&gt;&gt; ob[i];
<a name="l00312"></a>00312         }
<a name="l00313"></a>00313       <span class="keywordflow">else</span>
<a name="l00314"></a>00314         {
<a name="l00315"></a>00315           <span class="keywordtype">char</span> * ptr = (<span class="keywordtype">char</span>*) ob;
<a name="l00316"></a>00316 <span class="comment">// En binaire: lecture optimisee en bloc:</span>
<a name="l00317"></a>00317           std::streamsize <a class="code" href="Nom_8cpp.html#a0e1ea19fb9fa7881d15d84eff4c090e1">sz</a> = <span class="keyword">sizeof</span>(int);
<a name="l00318"></a>00318           sz *= n;
<a name="l00319"></a>00319 <span class="comment">// Overflow checking :</span>
<a name="l00320"></a>00320           assert(sz / (std::streamsize)<span class="keyword">sizeof</span>(<span class="keywordtype">int</span>) == (std::streamsize)n);
<a name="l00321"></a>00321           <a class="code" href="classEntree.html#ade65f6710b43ff4d3f4ab683dc538ea7">istream_</a>-&gt;read(ptr, sz);
<a name="l00322"></a>00322           <a class="code" href="classEntree.html#a11dc4a4e2ae1fbf9c0ba1da1cfa157c8" title="methode inline pour traiter rapidement le cas trivial. Sinon, appel a la methode virtuelle error_hand...">error_handle</a>(<a class="code" href="classEntree.html#ade65f6710b43ff4d3f4ab683dc538ea7">istream_</a>-&gt;fail());
<a name="l00323"></a>00323         }
<a name="l00324"></a>00324     }
<a name="l00325"></a>00325   <span class="keywordflow">else</span>
<a name="l00326"></a>00326     {
<a name="l00327"></a>00327 <span class="comment">// En ascii : on passe par operator&gt;&gt; pour verifier les conversions</span>
<a name="l00328"></a>00328 <span class="comment">// Attention : on appelle celui de cette classe, pas de la classe derivee</span>
<a name="l00329"></a>00329       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; n; i++)
<a name="l00330"></a>00330         Entree::operator&gt;&gt;(ob[i]);
<a name="l00331"></a>00331     }
<a name="l00332"></a>00332   <span class="keywordflow">return</span> (!<a class="code" href="classEntree.html#ade65f6710b43ff4d3f4ab683dc538ea7">istream_</a>-&gt;fail());
<a name="l00333"></a>00333 }
<a name="l00334"></a>00334 <span class="preprocessor">#ifndef INT_is_64_</span>
<a name="l00335"></a>00335 <span class="preprocessor"></span><span class="comment">//</span>
<a name="l00336"></a>00336 <span class="comment">//</span>
<a name="l00337"></a>00337 <span class="comment">//</span>
<a name="l00338"></a>00338 <span class="comment">//</span>
<a name="l00339"></a>00339 <span class="comment">//</span>
<a name="l00340"></a>00340 <span class="comment">//</span>
<a name="l00341"></a>00341 <span class="comment">//</span>
<a name="l00342"></a>00342 <span class="comment">//</span><span class="comment"></span>
<a name="l00343"></a>00343 <span class="comment">//! methode virtuelle pour lire un int ou un reel.&lt;br&gt;Dans cette classe de base, on lit dans le istream avec read() (si is_bin() == 1)&lt;br&gt;ou avec operator&gt;&gt;() (si is_bin() == 0). Si le drapeau check_types est mis,&lt;br&gt;on appelle convert_to() pour verifier les types des objets lus.&lt;br&gt;Dans ce cas, pour les ints on comprend les formats 123 (decimal),&lt;br&gt;0xa345 (hexa) et autres.&lt;br&gt;Si une erreur se produit, on appelle error_handle_()&lt;br&gt;Note pour les programmeurs des classes derivees:&lt;br&gt;L&#39;implementation de cette methode doit toujours passer par hande_error()</span>
<a name="l00344"></a><a class="code" href="classEntree.html#ac216ef036c2b13ec4dd2d0cd36d6f643">00344</a> <span class="comment"></span><a class="code" href="classEntree.html" title="Classe de definition des operateurs et methodes pour toute lecture dans un flot d&#39;entree (fichier...">Entree</a>&amp; <a class="code" href="classEntree.html#ab03c14526336f31e4691b85617e49873">Entree::operator&gt;&gt;</a>(<span class="keywordtype">long</span>&amp; ob)
<a name="l00345"></a>00345 {
<a name="l00346"></a>00346   assert(<a class="code" href="classEntree.html#ade65f6710b43ff4d3f4ab683dc538ea7">istream_</a>!=0);
<a name="l00347"></a>00347   <span class="keywordflow">if</span> (<a class="code" href="classEntree.html#abfecba6a0869b6593bf8ad753f8c53c7">bin_</a>)
<a name="l00348"></a>00348     {
<a name="l00349"></a>00349       {
<a name="l00350"></a>00350         <span class="keywordtype">char</span> * ptr = (<span class="keywordtype">char</span>*) &amp;ob;
<a name="l00351"></a>00351         <a class="code" href="classEntree.html#ade65f6710b43ff4d3f4ab683dc538ea7">istream_</a>-&gt;read(ptr, <span class="keyword">sizeof</span>(<span class="keywordtype">long</span>));
<a name="l00352"></a>00352         <a class="code" href="classEntree.html#a11dc4a4e2ae1fbf9c0ba1da1cfa157c8" title="methode inline pour traiter rapidement le cas trivial. Sinon, appel a la methode virtuelle error_hand...">error_handle</a>(<a class="code" href="classEntree.html#ade65f6710b43ff4d3f4ab683dc538ea7">istream_</a>-&gt;fail());
<a name="l00353"></a>00353       }
<a name="l00354"></a>00354     }
<a name="l00355"></a>00355   <span class="keywordflow">else</span>
<a name="l00356"></a>00356     {
<a name="l00357"></a>00357       <span class="keywordflow">if</span> (<a class="code" href="classEntree.html#aaf7cb8edc33dc7e5e9849f8c6e6bd935">check_types_</a>)
<a name="l00358"></a>00358         {
<a name="l00359"></a>00359           <span class="keywordtype">char</span> buffer[100];
<a name="l00360"></a>00360           <span class="keywordtype">int</span> ok = <a class="code" href="classEntree.html#aa434f5ceb8169e469613d1f6cd1fd99f" title="methode virtuelle pour lire un tableau d&#39;ints ou reels&lt;br&gt;(le tableau doit avoir la bonne dimension: ...">Entree::get</a>(buffer, 100); <span class="comment">//!&lt; Bien appeler get de cette classe</span>
<a name="l00361"></a>00361 <span class="comment"></span>          <span class="keywordflow">if</span> (ok)
<a name="l00362"></a>00362             <a class="code" href="Avanc_8cpp.html#a98c8f11a2783c4bdf1a9484db0dc3c3b">convert_to</a>(buffer, ob);
<a name="l00363"></a>00363         }
<a name="l00364"></a>00364       <span class="keywordflow">else</span>
<a name="l00365"></a>00365         {
<a name="l00366"></a>00366           (*istream_) &gt;&gt; ob;
<a name="l00367"></a>00367           <a class="code" href="classEntree.html#a11dc4a4e2ae1fbf9c0ba1da1cfa157c8" title="methode inline pour traiter rapidement le cas trivial. Sinon, appel a la methode virtuelle error_hand...">error_handle</a>(<a class="code" href="classEntree.html#ade65f6710b43ff4d3f4ab683dc538ea7">istream_</a>-&gt;fail());
<a name="l00368"></a>00368         }
<a name="l00369"></a>00369     }
<a name="l00370"></a>00370   <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00371"></a>00371 }
<a name="l00372"></a>00372 
<a name="l00373"></a>00373 <span class="comment">//</span>
<a name="l00374"></a>00374 <span class="comment">//</span><span class="comment"></span>
<a name="l00375"></a>00375 <span class="comment">//! methode virtuelle pour lire un tableau d&#39;ints ou reels&lt;br&gt;(le tableau doit avoir la bonne dimension: attention pas de verification possible)&lt;br&gt;Voir aussi operator&gt;&gt;()</span>
<a name="l00376"></a><a class="code" href="classEntree.html#a775cd63c3f4e9b37f95b6904d80c7d57">00376</a> <span class="comment"></span><span class="keywordtype">int</span> <a class="code" href="classEntree.html#aa434f5ceb8169e469613d1f6cd1fd99f" title="methode virtuelle pour lire un tableau d&#39;ints ou reels&lt;br&gt;(le tableau doit avoir la bonne dimension: ...">Entree::get</a>(<span class="keywordtype">long</span> * ob, <span class="keywordtype">int</span> n)
<a name="l00377"></a>00377 {
<a name="l00378"></a>00378   assert(<a class="code" href="classEntree.html#ade65f6710b43ff4d3f4ab683dc538ea7">istream_</a>!=0);
<a name="l00379"></a>00379   assert(n &gt;= 0);
<a name="l00380"></a>00380   <span class="keywordflow">if</span> (<a class="code" href="classEntree.html#abfecba6a0869b6593bf8ad753f8c53c7">bin_</a>)
<a name="l00381"></a>00381     {
<a name="l00382"></a>00382       {
<a name="l00383"></a>00383         <span class="keywordtype">char</span> * ptr = (<span class="keywordtype">char</span>*) ob;
<a name="l00384"></a>00384 <span class="comment">// En binaire: lecture optimisee en bloc:</span>
<a name="l00385"></a>00385         std::streamsize <a class="code" href="Nom_8cpp.html#a0e1ea19fb9fa7881d15d84eff4c090e1">sz</a> = <span class="keyword">sizeof</span>(long);
<a name="l00386"></a>00386         sz *= n;
<a name="l00387"></a>00387 <span class="comment">// Overflow checking :</span>
<a name="l00388"></a>00388         assert(sz / (std::streamsize)<span class="keyword">sizeof</span>(<span class="keywordtype">long</span>) == (std::streamsize)n);
<a name="l00389"></a>00389         <a class="code" href="classEntree.html#ade65f6710b43ff4d3f4ab683dc538ea7">istream_</a>-&gt;read(ptr, sz);
<a name="l00390"></a>00390         <a class="code" href="classEntree.html#a11dc4a4e2ae1fbf9c0ba1da1cfa157c8" title="methode inline pour traiter rapidement le cas trivial. Sinon, appel a la methode virtuelle error_hand...">error_handle</a>(<a class="code" href="classEntree.html#ade65f6710b43ff4d3f4ab683dc538ea7">istream_</a>-&gt;fail());
<a name="l00391"></a>00391       }
<a name="l00392"></a>00392     }
<a name="l00393"></a>00393   <span class="keywordflow">else</span>
<a name="l00394"></a>00394     {
<a name="l00395"></a>00395 <span class="comment">// En ascii : on passe par operator&gt;&gt; pour verifier les conversions</span>
<a name="l00396"></a>00396 <span class="comment">// Attention : on appelle celui de cette classe, pas de la classe derivee</span>
<a name="l00397"></a>00397       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; n; i++)
<a name="l00398"></a>00398         Entree::operator&gt;&gt;(ob[i]);
<a name="l00399"></a>00399     }
<a name="l00400"></a>00400   <span class="keywordflow">return</span> (!<a class="code" href="classEntree.html#ade65f6710b43ff4d3f4ab683dc538ea7">istream_</a>-&gt;fail());
<a name="l00401"></a>00401 }
<a name="l00402"></a>00402 <span class="preprocessor">#endif</span>
<a name="l00403"></a>00403 <span class="preprocessor"></span><span class="comment">//</span>
<a name="l00404"></a>00404 <span class="comment">//</span>
<a name="l00405"></a>00405 <span class="comment">//</span>
<a name="l00406"></a>00406 <span class="comment">//</span>
<a name="l00407"></a>00407 <span class="comment">//</span>
<a name="l00408"></a>00408 <span class="comment">//</span>
<a name="l00409"></a>00409 <span class="comment">//</span>
<a name="l00410"></a>00410 <span class="comment">//</span><span class="comment"></span>
<a name="l00411"></a>00411 <span class="comment">//! methode virtuelle pour lire un int ou un reel.&lt;br&gt;Dans cette classe de base, on lit dans le istream avec read() (si is_bin() == 1)&lt;br&gt;ou avec operator&gt;&gt;() (si is_bin() == 0). Si le drapeau check_types est mis,&lt;br&gt;on appelle convert_to() pour verifier les types des objets lus.&lt;br&gt;Dans ce cas, pour les ints on comprend les formats 123 (decimal),&lt;br&gt;0xa345 (hexa) et autres.&lt;br&gt;Si une erreur se produit, on appelle error_handle_()&lt;br&gt;Note pour les programmeurs des classes derivees:&lt;br&gt;L&#39;implementation de cette methode doit toujours passer par hande_error()</span>
<a name="l00412"></a><a class="code" href="classEntree.html#a89a1be191d7591e56022ab821d258fcb">00412</a> <span class="comment"></span><a class="code" href="classEntree.html" title="Classe de definition des operateurs et methodes pour toute lecture dans un flot d&#39;entree (fichier...">Entree</a>&amp; <a class="code" href="classEntree.html#ab03c14526336f31e4691b85617e49873">Entree::operator&gt;&gt;</a>(<span class="keywordtype">float</span>&amp; ob)
<a name="l00413"></a>00413 {
<a name="l00414"></a>00414   assert(<a class="code" href="classEntree.html#ade65f6710b43ff4d3f4ab683dc538ea7">istream_</a>!=0);
<a name="l00415"></a>00415   <span class="keywordflow">if</span> (<a class="code" href="classEntree.html#abfecba6a0869b6593bf8ad753f8c53c7">bin_</a>)
<a name="l00416"></a>00416     {
<a name="l00417"></a>00417       {
<a name="l00418"></a>00418         <span class="keywordtype">char</span> * ptr = (<span class="keywordtype">char</span>*) &amp;ob;
<a name="l00419"></a>00419         <a class="code" href="classEntree.html#ade65f6710b43ff4d3f4ab683dc538ea7">istream_</a>-&gt;read(ptr, <span class="keyword">sizeof</span>(<span class="keywordtype">float</span>));
<a name="l00420"></a>00420         <a class="code" href="classEntree.html#a11dc4a4e2ae1fbf9c0ba1da1cfa157c8" title="methode inline pour traiter rapidement le cas trivial. Sinon, appel a la methode virtuelle error_hand...">error_handle</a>(<a class="code" href="classEntree.html#ade65f6710b43ff4d3f4ab683dc538ea7">istream_</a>-&gt;fail());
<a name="l00421"></a>00421       }
<a name="l00422"></a>00422     }
<a name="l00423"></a>00423   <span class="keywordflow">else</span>
<a name="l00424"></a>00424     {
<a name="l00425"></a>00425       <span class="keywordflow">if</span> (<a class="code" href="classEntree.html#aaf7cb8edc33dc7e5e9849f8c6e6bd935">check_types_</a>)
<a name="l00426"></a>00426         {
<a name="l00427"></a>00427           <span class="keywordtype">char</span> buffer[100];
<a name="l00428"></a>00428           <span class="keywordtype">int</span> ok = <a class="code" href="classEntree.html#aa434f5ceb8169e469613d1f6cd1fd99f" title="methode virtuelle pour lire un tableau d&#39;ints ou reels&lt;br&gt;(le tableau doit avoir la bonne dimension: ...">Entree::get</a>(buffer, 100); <span class="comment">//!&lt; Bien appeler get de cette classe</span>
<a name="l00429"></a>00429 <span class="comment"></span>          <span class="keywordflow">if</span> (ok)
<a name="l00430"></a>00430             <a class="code" href="Avanc_8cpp.html#a98c8f11a2783c4bdf1a9484db0dc3c3b">convert_to</a>(buffer, ob);
<a name="l00431"></a>00431         }
<a name="l00432"></a>00432       <span class="keywordflow">else</span>
<a name="l00433"></a>00433         {
<a name="l00434"></a>00434           (*istream_) &gt;&gt; ob;
<a name="l00435"></a>00435           <a class="code" href="classEntree.html#a11dc4a4e2ae1fbf9c0ba1da1cfa157c8" title="methode inline pour traiter rapidement le cas trivial. Sinon, appel a la methode virtuelle error_hand...">error_handle</a>(<a class="code" href="classEntree.html#ade65f6710b43ff4d3f4ab683dc538ea7">istream_</a>-&gt;fail());
<a name="l00436"></a>00436         }
<a name="l00437"></a>00437     }
<a name="l00438"></a>00438   <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00439"></a>00439 }
<a name="l00440"></a>00440 
<a name="l00441"></a>00441 <span class="comment">//</span>
<a name="l00442"></a>00442 <span class="comment">//</span><span class="comment"></span>
<a name="l00443"></a>00443 <span class="comment">//! methode virtuelle pour lire un tableau d&#39;ints ou reels&lt;br&gt;(le tableau doit avoir la bonne dimension: attention pas de verification possible)&lt;br&gt;Voir aussi operator&gt;&gt;()</span>
<a name="l00444"></a><a class="code" href="classEntree.html#a0bd851956391e896bcb2c8f03ee6eefe">00444</a> <span class="comment"></span><span class="keywordtype">int</span> <a class="code" href="classEntree.html#aa434f5ceb8169e469613d1f6cd1fd99f" title="methode virtuelle pour lire un tableau d&#39;ints ou reels&lt;br&gt;(le tableau doit avoir la bonne dimension: ...">Entree::get</a>(<span class="keywordtype">float</span> * ob, <span class="keywordtype">int</span> n)
<a name="l00445"></a>00445 {
<a name="l00446"></a>00446   assert(<a class="code" href="classEntree.html#ade65f6710b43ff4d3f4ab683dc538ea7">istream_</a>!=0);
<a name="l00447"></a>00447   assert(n &gt;= 0);
<a name="l00448"></a>00448   <span class="keywordflow">if</span> (<a class="code" href="classEntree.html#abfecba6a0869b6593bf8ad753f8c53c7">bin_</a>)
<a name="l00449"></a>00449     {
<a name="l00450"></a>00450       {
<a name="l00451"></a>00451         <span class="keywordtype">char</span> * ptr = (<span class="keywordtype">char</span>*) ob;
<a name="l00452"></a>00452 <span class="comment">// En binaire: lecture optimisee en bloc:</span>
<a name="l00453"></a>00453         std::streamsize <a class="code" href="Nom_8cpp.html#a0e1ea19fb9fa7881d15d84eff4c090e1">sz</a> = <span class="keyword">sizeof</span>(float);
<a name="l00454"></a>00454         sz *= n;
<a name="l00455"></a>00455 <span class="comment">// Overflow checking :</span>
<a name="l00456"></a>00456         assert(sz / (std::streamsize)<span class="keyword">sizeof</span>(<span class="keywordtype">float</span>) == (std::streamsize)n);
<a name="l00457"></a>00457         <a class="code" href="classEntree.html#ade65f6710b43ff4d3f4ab683dc538ea7">istream_</a>-&gt;read(ptr, sz);
<a name="l00458"></a>00458         <a class="code" href="classEntree.html#a11dc4a4e2ae1fbf9c0ba1da1cfa157c8" title="methode inline pour traiter rapidement le cas trivial. Sinon, appel a la methode virtuelle error_hand...">error_handle</a>(<a class="code" href="classEntree.html#ade65f6710b43ff4d3f4ab683dc538ea7">istream_</a>-&gt;fail());
<a name="l00459"></a>00459       }
<a name="l00460"></a>00460     }
<a name="l00461"></a>00461   <span class="keywordflow">else</span>
<a name="l00462"></a>00462     {
<a name="l00463"></a>00463 <span class="comment">// En ascii : on passe par operator&gt;&gt; pour verifier les conversions</span>
<a name="l00464"></a>00464 <span class="comment">// Attention : on appelle celui de cette classe, pas de la classe derivee</span>
<a name="l00465"></a>00465       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; n; i++)
<a name="l00466"></a>00466         Entree::operator&gt;&gt;(ob[i]);
<a name="l00467"></a>00467     }
<a name="l00468"></a>00468   <span class="keywordflow">return</span> (!<a class="code" href="classEntree.html#ade65f6710b43ff4d3f4ab683dc538ea7">istream_</a>-&gt;fail());
<a name="l00469"></a>00469 }
<a name="l00470"></a>00470 <span class="comment">//</span>
<a name="l00471"></a>00471 <span class="comment">//</span>
<a name="l00472"></a>00472 <span class="comment">//</span>
<a name="l00473"></a>00473 <span class="comment">//</span>
<a name="l00474"></a>00474 <span class="comment">//</span>
<a name="l00475"></a>00475 <span class="comment">//</span>
<a name="l00476"></a>00476 <span class="comment">//</span>
<a name="l00477"></a>00477 <span class="comment">//</span><span class="comment"></span>
<a name="l00478"></a>00478 <span class="comment">//! methode virtuelle pour lire un int ou un reel.&lt;br&gt;Dans cette classe de base, on lit dans le istream avec read() (si is_bin() == 1)&lt;br&gt;ou avec operator&gt;&gt;() (si is_bin() == 0). Si le drapeau check_types est mis,&lt;br&gt;on appelle convert_to() pour verifier les types des objets lus.&lt;br&gt;Dans ce cas, pour les ints on comprend les formats 123 (decimal),&lt;br&gt;0xa345 (hexa) et autres.&lt;br&gt;Si une erreur se produit, on appelle error_handle_()&lt;br&gt;Note pour les programmeurs des classes derivees:&lt;br&gt;L&#39;implementation de cette methode doit toujours passer par hande_error()</span>
<a name="l00479"></a><a class="code" href="classEntree.html#a5ce75316664b2a116523bd30b2c48964">00479</a> <span class="comment"></span><a class="code" href="classEntree.html" title="Classe de definition des operateurs et methodes pour toute lecture dans un flot d&#39;entree (fichier...">Entree</a>&amp; <a class="code" href="classEntree.html#ab03c14526336f31e4691b85617e49873">Entree::operator&gt;&gt;</a>(<span class="keywordtype">double</span>&amp; ob)
<a name="l00480"></a>00480 {
<a name="l00481"></a>00481   assert(<a class="code" href="classEntree.html#ade65f6710b43ff4d3f4ab683dc538ea7">istream_</a>!=0);
<a name="l00482"></a>00482   <span class="keywordflow">if</span> (<a class="code" href="classEntree.html#abfecba6a0869b6593bf8ad753f8c53c7">bin_</a>)
<a name="l00483"></a>00483     {
<a name="l00484"></a>00484       {
<a name="l00485"></a>00485         <span class="keywordtype">char</span> * ptr = (<span class="keywordtype">char</span>*) &amp;ob;
<a name="l00486"></a>00486         <a class="code" href="classEntree.html#ade65f6710b43ff4d3f4ab683dc538ea7">istream_</a>-&gt;read(ptr, <span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));
<a name="l00487"></a>00487         <a class="code" href="classEntree.html#a11dc4a4e2ae1fbf9c0ba1da1cfa157c8" title="methode inline pour traiter rapidement le cas trivial. Sinon, appel a la methode virtuelle error_hand...">error_handle</a>(<a class="code" href="classEntree.html#ade65f6710b43ff4d3f4ab683dc538ea7">istream_</a>-&gt;fail());
<a name="l00488"></a>00488       }
<a name="l00489"></a>00489     }
<a name="l00490"></a>00490   <span class="keywordflow">else</span>
<a name="l00491"></a>00491     {
<a name="l00492"></a>00492       <span class="keywordflow">if</span> (<a class="code" href="classEntree.html#aaf7cb8edc33dc7e5e9849f8c6e6bd935">check_types_</a>)
<a name="l00493"></a>00493         {
<a name="l00494"></a>00494           <span class="keywordtype">char</span> buffer[100];
<a name="l00495"></a>00495           <span class="keywordtype">int</span> ok = <a class="code" href="classEntree.html#aa434f5ceb8169e469613d1f6cd1fd99f" title="methode virtuelle pour lire un tableau d&#39;ints ou reels&lt;br&gt;(le tableau doit avoir la bonne dimension: ...">Entree::get</a>(buffer, 100); <span class="comment">//!&lt; Bien appeler get de cette classe</span>
<a name="l00496"></a>00496 <span class="comment"></span>          <span class="keywordflow">if</span> (ok)
<a name="l00497"></a>00497             <a class="code" href="Avanc_8cpp.html#a98c8f11a2783c4bdf1a9484db0dc3c3b">convert_to</a>(buffer, ob);
<a name="l00498"></a>00498         }
<a name="l00499"></a>00499       <span class="keywordflow">else</span>
<a name="l00500"></a>00500         {
<a name="l00501"></a>00501           (*istream_) &gt;&gt; ob;
<a name="l00502"></a>00502           <a class="code" href="classEntree.html#a11dc4a4e2ae1fbf9c0ba1da1cfa157c8" title="methode inline pour traiter rapidement le cas trivial. Sinon, appel a la methode virtuelle error_hand...">error_handle</a>(<a class="code" href="classEntree.html#ade65f6710b43ff4d3f4ab683dc538ea7">istream_</a>-&gt;fail());
<a name="l00503"></a>00503         }
<a name="l00504"></a>00504     }
<a name="l00505"></a>00505   <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00506"></a>00506 }
<a name="l00507"></a>00507 
<a name="l00508"></a>00508 <span class="comment">//</span>
<a name="l00509"></a>00509 <span class="comment">//</span><span class="comment"></span>
<a name="l00510"></a>00510 <span class="comment">//! methode virtuelle pour lire un tableau d&#39;ints ou reels&lt;br&gt;(le tableau doit avoir la bonne dimension: attention pas de verification possible)&lt;br&gt;Voir aussi operator&gt;&gt;()</span>
<a name="l00511"></a><a class="code" href="classEntree.html#a72fad759a69296883dfbc645f183c824">00511</a> <span class="comment"></span><span class="keywordtype">int</span> <a class="code" href="classEntree.html#aa434f5ceb8169e469613d1f6cd1fd99f" title="methode virtuelle pour lire un tableau d&#39;ints ou reels&lt;br&gt;(le tableau doit avoir la bonne dimension: ...">Entree::get</a>(<span class="keywordtype">double</span> * ob, <span class="keywordtype">int</span> n)
<a name="l00512"></a>00512 {
<a name="l00513"></a>00513   assert(<a class="code" href="classEntree.html#ade65f6710b43ff4d3f4ab683dc538ea7">istream_</a>!=0);
<a name="l00514"></a>00514   assert(n &gt;= 0);
<a name="l00515"></a>00515   <span class="keywordflow">if</span> (<a class="code" href="classEntree.html#abfecba6a0869b6593bf8ad753f8c53c7">bin_</a>)
<a name="l00516"></a>00516     {
<a name="l00517"></a>00517       {
<a name="l00518"></a>00518         <span class="keywordtype">char</span> * ptr = (<span class="keywordtype">char</span>*) ob;
<a name="l00519"></a>00519 <span class="comment">// En binaire: lecture optimisee en bloc:</span>
<a name="l00520"></a>00520         std::streamsize <a class="code" href="Nom_8cpp.html#a0e1ea19fb9fa7881d15d84eff4c090e1">sz</a> = <span class="keyword">sizeof</span>(double);
<a name="l00521"></a>00521         sz *= n;
<a name="l00522"></a>00522 <span class="comment">// Overflow checking :</span>
<a name="l00523"></a>00523         assert(sz / (std::streamsize)<span class="keyword">sizeof</span>(<span class="keywordtype">double</span>) == (std::streamsize)n);
<a name="l00524"></a>00524         <a class="code" href="classEntree.html#ade65f6710b43ff4d3f4ab683dc538ea7">istream_</a>-&gt;read(ptr, sz);
<a name="l00525"></a>00525         <a class="code" href="classEntree.html#a11dc4a4e2ae1fbf9c0ba1da1cfa157c8" title="methode inline pour traiter rapidement le cas trivial. Sinon, appel a la methode virtuelle error_hand...">error_handle</a>(<a class="code" href="classEntree.html#ade65f6710b43ff4d3f4ab683dc538ea7">istream_</a>-&gt;fail());
<a name="l00526"></a>00526       }
<a name="l00527"></a>00527     }
<a name="l00528"></a>00528   <span class="keywordflow">else</span>
<a name="l00529"></a>00529     {
<a name="l00530"></a>00530 <span class="comment">// En ascii : on passe par operator&gt;&gt; pour verifier les conversions</span>
<a name="l00531"></a>00531 <span class="comment">// Attention : on appelle celui de cette classe, pas de la classe derivee</span>
<a name="l00532"></a>00532       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; n; i++)
<a name="l00533"></a>00533         Entree::operator&gt;&gt;(ob[i]);
<a name="l00534"></a>00534     }
<a name="l00535"></a>00535   <span class="keywordflow">return</span> (!<a class="code" href="classEntree.html#ade65f6710b43ff4d3f4ab683dc538ea7">istream_</a>-&gt;fail());
<a name="l00536"></a>00536 }
<a name="l00537"></a>00537 
<a name="l00538"></a>00538 <span class="comment">// Description</span>
<a name="l00539"></a>00539 <span class="comment">// Operateur hors classe permettant de lire un Objet_U dans une Entree.</span>
<a name="l00540"></a>00540 <span class="comment">// Cet operateur appelle ob.readOn(is).</span>
<a name="l00541"></a>00541 <span class="comment">// S&#39;il fallait un jour implementer une methode particuliere pour lire</span>
<a name="l00542"></a>00542 <span class="comment">// un objet par une classe derivee de Entree particuliere, il faudrait</span>
<a name="l00543"></a>00543 <span class="comment">// deplacer cet operateur dans Entree et le rendre virtuel.</span>
<a name="l00544"></a><a class="code" href="Entree_8h.html#a250c7cb42dee3d48de7e100058198bb9">00544</a> <a class="code" href="classEntree.html" title="Classe de definition des operateurs et methodes pour toute lecture dans un flot d&#39;entree (fichier...">Entree</a>&amp; <a class="code" href="Entree_8cpp.html#af72214500262081c7d2830da9a1b847f">operator &gt;&gt;</a>(<a class="code" href="classEntree.html" title="Classe de definition des operateurs et methodes pour toute lecture dans un flot d&#39;entree (fichier...">Entree</a>&amp; is, <a class="code" href="classObjet__U.html" title="classe Objet_U Cette classe est la classe de base des Objets de TRUST Dans les classes derivees de Ob...">Objet_U</a>&amp; ob)
<a name="l00545"></a>00545 {
<a name="l00546"></a>00546   <span class="keywordflow">return</span> ob.<a class="code" href="classObjet__U.html#a6f4c7788efee2dce629ebd1628b73288" title="Lecture d&#39;un Objet_U sur un flot d&#39;entree Methode a surcharger.">readOn</a>(is);
<a name="l00547"></a>00547 }
<a name="l00548"></a>00548 
<a name="l00549"></a><a class="code" href="classEntree.html#abcd397cb0b99fbe7c6f01047d8cec89c">00549</a> <span class="keywordtype">int</span> <a class="code" href="classEntree.html#abcd397cb0b99fbe7c6f01047d8cec89c">Entree::eof</a>()
<a name="l00550"></a>00550 {
<a name="l00551"></a>00551   <span class="keywordflow">if</span>(<a class="code" href="classEntree.html#ade65f6710b43ff4d3f4ab683dc538ea7">istream_</a>)
<a name="l00552"></a>00552     <span class="keywordflow">return</span> (<a class="code" href="classEntree.html#ade65f6710b43ff4d3f4ab683dc538ea7">istream_</a>-&gt;eof());
<a name="l00553"></a>00553   <span class="keywordflow">else</span>
<a name="l00554"></a>00554     <span class="keywordflow">return</span> -1;
<a name="l00555"></a>00555 }
<a name="l00556"></a><a class="code" href="classEntree.html#a2c87d3acdad4e3c226c4b8ad4b1fd9a7">00556</a> <span class="keywordtype">int</span> <a class="code" href="classEntree.html#a2c87d3acdad4e3c226c4b8ad4b1fd9a7">Entree::fail</a>()
<a name="l00557"></a>00557 {
<a name="l00558"></a>00558   <span class="keywordflow">if</span>(<a class="code" href="classEntree.html#ade65f6710b43ff4d3f4ab683dc538ea7">istream_</a>)
<a name="l00559"></a>00559     <span class="keywordflow">return</span> (<a class="code" href="classEntree.html#ade65f6710b43ff4d3f4ab683dc538ea7">istream_</a>-&gt;fail());
<a name="l00560"></a>00560   <span class="keywordflow">else</span>
<a name="l00561"></a>00561     <span class="keywordflow">return</span> -1;
<a name="l00562"></a>00562 }
<a name="l00563"></a><a class="code" href="classEntree.html#a031cbbd83a3acd74b6d16496602fd941">00563</a> <span class="keywordtype">int</span> <a class="code" href="classEntree.html#a031cbbd83a3acd74b6d16496602fd941">Entree::good</a>()
<a name="l00564"></a>00564 {
<a name="l00565"></a>00565   <span class="keywordflow">if</span>(<a class="code" href="classEntree.html#ade65f6710b43ff4d3f4ab683dc538ea7">istream_</a>)
<a name="l00566"></a>00566     <span class="keywordflow">return</span> (<a class="code" href="classEntree.html#ade65f6710b43ff4d3f4ab683dc538ea7">istream_</a>-&gt;good());
<a name="l00567"></a>00567   <span class="keywordflow">else</span>
<a name="l00568"></a>00568     <span class="keywordflow">return</span> -1;
<a name="l00569"></a>00569 }
<a name="l00570"></a><a class="code" href="classEntree.html#a7dd15a82ec07774056a99152fbbd2d4b">00570</a> <a class="code" href="classEntree.html#a7dd15a82ec07774056a99152fbbd2d4b">Entree::~Entree</a>()
<a name="l00571"></a>00571 {
<a name="l00572"></a>00572   <span class="keywordflow">if</span>(<a class="code" href="classEntree.html#ade65f6710b43ff4d3f4ab683dc538ea7">istream_</a>)
<a name="l00573"></a>00573     <span class="keyword">delete</span> <a class="code" href="classEntree.html#ade65f6710b43ff4d3f4ab683dc538ea7">istream_</a>;
<a name="l00574"></a>00574   <a class="code" href="classEntree.html#ade65f6710b43ff4d3f4ab683dc538ea7">istream_</a>=0;
<a name="l00575"></a>00575 }
<a name="l00576"></a>00576 
<a name="l00577"></a>00577 <span class="comment">//</span>
<a name="l00578"></a>00578 <span class="comment">//</span><span class="comment"></span>
<a name="l00579"></a>00579 <span class="comment">//! Change le mode d&#39;ecriture du fichier.&lt;br&gt;Cette methode peut etre appelee n&#39;importe quand.</span>
<a name="l00580"></a><a class="code" href="classEntree.html#a423a8b547335af7d31a2516eb452d936">00580</a> <span class="comment"></span><span class="keywordtype">int</span> <a class="code" href="classEntree.html#a423a8b547335af7d31a2516eb452d936" title="Change le mode d&#39;ecriture du fichier. Cette methode peut etre appelee n&#39;importe quand.">Entree::set_bin</a>(<span class="keywordtype">int</span> bin)
<a name="l00581"></a>00581 {
<a name="l00582"></a>00582   assert(bin==0 || bin==1);
<a name="l00583"></a>00583   <a class="code" href="classEntree.html#abfecba6a0869b6593bf8ad753f8c53c7">bin_</a> = bin;
<a name="l00584"></a>00584   <span class="keywordflow">if</span> (<a class="code" href="classEntree.html#ade65f6710b43ff4d3f4ab683dc538ea7">istream_</a>)
<a name="l00585"></a>00585     {
<a name="l00586"></a>00586       <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a>&lt;&lt;<span class="stringliteral">&quot;Error you cant change binary format after open &quot;</span>&lt;&lt;<a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
<a name="l00587"></a>00587       assert(0);
<a name="l00588"></a>00588       <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">Process::exit</a>();
<a name="l00589"></a>00589     }
<a name="l00590"></a>00590   <span class="keywordflow">return</span> <a class="code" href="classEntree.html#abfecba6a0869b6593bf8ad753f8c53c7">bin_</a>;
<a name="l00591"></a>00591 }
<a name="l00592"></a>00592 
<a name="l00593"></a><a class="code" href="classEntree.html#af94f1a7192fb6f8c655cde66986d16e5">00593</a> <span class="keywordtype">int</span> <a class="code" href="classEntree.html#af94f1a7192fb6f8c655cde66986d16e5">Entree::is_bin</a>()<span class="keyword"> const</span>
<a name="l00594"></a>00594 <span class="keyword"></span>{
<a name="l00595"></a>00595   <span class="keywordflow">return</span> <a class="code" href="classEntree.html#abfecba6a0869b6593bf8ad753f8c53c7">bin_</a>;
<a name="l00596"></a>00596 }
<a name="l00597"></a>00597 
<a name="l00598"></a>00598 <span class="comment">//</span>
<a name="l00599"></a>00599 <span class="comment">//</span>
<a name="l00600"></a>00600 <span class="comment">//</span>
<a name="l00601"></a>00601 <span class="comment">//</span>
<a name="l00602"></a>00602 <span class="comment">//</span>
<a name="l00603"></a>00603 <span class="comment">//</span>
<a name="l00604"></a>00604 <span class="comment">//</span><span class="comment"></span>
<a name="l00605"></a>00605 <span class="comment">//! indique si le stream doit verifier les types des objets lus&lt;br&gt;(ints et nombres flottants). Exemple : l&#39;entree contient 123.456 123.456&lt;br&gt;int i;&lt;br&gt;check_types(0);&lt;br&gt;is &gt;&gt; i;   // i contient 123&lt;br&gt;check_types(1);&lt;br&gt;is &gt;&gt; i;   // Erreur : on lit la chaine 123.456 et on essaye de la convertir en int&lt;br&gt;Voir operator&gt;&gt;(int \&amp;)</span>
<a name="l00606"></a><a class="code" href="classEntree.html#a8eb17df69e13b62024c8783f0dd99565">00606</a> <span class="comment"></span><span class="keywordtype">void</span> <a class="code" href="classEntree.html#a8eb17df69e13b62024c8783f0dd99565" title="indique si le stream doit verifier les types des objets lus&lt;br&gt;(ints et nombres flottants). Exemple : l&#39;entree contient 123.456 123.456 int i; check_types(0); is &gt;&gt; i; // i contient 123 check_types(1); is &gt;&gt; i; // Erreur : on lit la chaine 123.456 et on essaye de la convertir en int Voir operator&gt;&gt;(int &amp;)">Entree::set_check_types</a>(<span class="keywordtype">int</span> flag)
<a name="l00607"></a>00607 {
<a name="l00608"></a>00608   <a class="code" href="classEntree.html#aaf7cb8edc33dc7e5e9849f8c6e6bd935">check_types_</a> = flag;
<a name="l00609"></a>00609 }
<a name="l00610"></a>00610 <span class="comment"></span>
<a name="l00611"></a>00611 <span class="comment">//! renvoie la valeur actuelle du drapeau, voir set_check_types()</span>
<a name="l00612"></a><a class="code" href="classEntree.html#a55fcc271b89dfecd3d49436eb037604c">00612</a> <span class="comment"></span><span class="keywordtype">int</span> <a class="code" href="classEntree.html#a55fcc271b89dfecd3d49436eb037604c" title="renvoie la valeur actuelle du drapeau, voir set_check_types()">Entree::check_types</a>()<span class="keyword"> const</span>
<a name="l00613"></a>00613 <span class="keyword"></span>{
<a name="l00614"></a>00614   <span class="keywordflow">return</span> <a class="code" href="classEntree.html#aaf7cb8edc33dc7e5e9849f8c6e6bd935">check_types_</a>;
<a name="l00615"></a>00615 }
<a name="l00616"></a>00616 
<a name="l00617"></a>00617 
<a name="l00618"></a>00618 <span class="comment">//</span>
<a name="l00619"></a>00619 <span class="comment">//</span>
<a name="l00620"></a>00620 <span class="comment">//</span>
<a name="l00621"></a>00621 <span class="comment">//</span>
<a name="l00622"></a>00622 <span class="comment">//</span>
<a name="l00623"></a>00623 <span class="comment">//</span>
<a name="l00624"></a>00624 <span class="comment">//</span>
<a name="l00625"></a>00625 <span class="comment">//</span>
<a name="l00626"></a>00626 <span class="comment">//</span>
<a name="l00627"></a>00627 <span class="comment">//</span>
<a name="l00628"></a>00628 <span class="comment">//</span>
<a name="l00629"></a>00629 <span class="comment">//</span>
<a name="l00630"></a>00630 <span class="comment">//</span>
<a name="l00631"></a>00631 <span class="comment">//</span>
<a name="l00632"></a>00632 <span class="comment">//</span>
<a name="l00633"></a>00633 <span class="comment">//</span>
<a name="l00634"></a>00634 <span class="comment">//</span>
<a name="l00635"></a>00635 <span class="comment">//</span><span class="comment"></span>
<a name="l00636"></a>00636 <span class="comment">//! Cette fonction est appellee par operateur&gt;&gt;, get, get_nom&lt;br&gt;ouvrir, fermer, lire, etc... en cas d&#39;echec (lorsque fail() est mis)&lt;br&gt;Elle renvoie 0 s&#39;il y a eu une erreur (passer par error_handle() qui&lt;br&gt;traite en inline le cas ou il n&#39;y a pas d&#39;erreur), et 1 s&#39;il n&#39;y a pas&lt;br&gt;d&#39;erreur.&lt;br&gt;(par commodite de codage des methodes qui l&#39;utilisent, on&lt;br&gt;ecrira &quot;return error_handle(fail());&quot;&lt;br&gt;Elle peut etre configuree pour&lt;br&gt;- renvoyer &quot;0&quot; en cas d&#39;erreur et continuer l&#39;execution du code&lt;br&gt;(cas d&#39;un ancien code qui ne gere pas les exceptions mais teste&lt;br&gt;le drapeau fail() de temps en temps)&lt;br&gt;Dans ce cas les methodes operator&gt;&gt; continuent l&#39;execution du code&lt;br&gt;meme en cas d&#39;echec, le contenu des variables lues est indefini !&lt;br&gt;- faire Process::exit() (cas d&#39;une portion de code dans laquelle&lt;br&gt;on ne veut pas faire de gestion d&#39;erreur du tout et ou on suppose&lt;br&gt;que tout va toujours bien)&lt;br&gt;- lever une exception (permet une gestion rigoureuse des erreurs&lt;br&gt;et une information utilisateur optimale en fonction du contexte)&lt;br&gt;Voir aussi set_error_action()</span>
<a name="l00637"></a><a class="code" href="classEntree.html#a062ae8270bdc5ace59aae564699a16f8">00637</a> <span class="comment"></span><span class="keywordtype">int</span> <a class="code" href="classEntree.html#a062ae8270bdc5ace59aae564699a16f8" title="Cette fonction est appellee par operateur&gt;&gt;, get, get_nom ouvrir, fermer, lire, etc...">Entree::error_handle_</a>(<span class="keywordtype">int</span> fail_flag)
<a name="l00638"></a>00638 {
<a name="l00639"></a>00639   <span class="keywordflow">if</span> (!fail_flag)
<a name="l00640"></a>00640     <span class="keywordflow">return</span> 1;
<a name="l00641"></a>00641 
<a name="l00642"></a>00642   <span class="keywordflow">switch</span>(<a class="code" href="classEntree.html#a9c2846af38c76af98d064e665c964b20">error_action_</a>)
<a name="l00643"></a>00643     {
<a name="l00644"></a>00644     <span class="keywordflow">case</span> <a class="code" href="classEntree.html#a92919bfab8dfa0cfdf8cf8e3dc13b078a88176e2e0001a6717ea71baa58bea2a6">ERROR_CONTINUE</a>:
<a name="l00645"></a>00645       <span class="keywordflow">break</span>;
<a name="l00646"></a>00646     <span class="keywordflow">case</span> <a class="code" href="classEntree.html#a92919bfab8dfa0cfdf8cf8e3dc13b078a3680fe7027fd3fe92932f46bd8967fba">ERROR_EXIT</a>:
<a name="l00647"></a>00647       <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Error while reading in Entree object. Exiting.\n&quot;</span>;
<a name="l00648"></a>00648       <span class="keywordflow">if</span> (<a class="code" href="classEntree.html#ade65f6710b43ff4d3f4ab683dc538ea7">istream_</a>)
<a name="l00649"></a>00649         {
<a name="l00650"></a>00650 <span class="comment">// On n&#39;utilise pas Entree::eof() car dans le cas d&#39;un Lec_Fic_Dif</span>
<a name="l00651"></a>00651 <span class="comment">// eof() est parallele et ca peut bloquer.</span>
<a name="l00652"></a>00652           <span class="keywordflow">if</span> (<a class="code" href="classEntree.html#abea15d57ebdf63f78c4b4a1285b1e896">get_istream</a>().<a class="code" href="classEntree.html#abcd397cb0b99fbe7c6f01047d8cec89c">eof</a>())
<a name="l00653"></a>00653             <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot; End of file reached.&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
<a name="l00654"></a>00654           <span class="keywordflow">else</span>
<a name="l00655"></a>00655             <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot; IO error (not an EOF error).&quot;</span> &lt;&lt; finl;
<a name="l00656"></a>00656         }
<a name="l00657"></a>00657       <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">Process::exit</a>();
<a name="l00658"></a>00658       <span class="keywordflow">break</span>;
<a name="l00659"></a>00659     <span class="keywordflow">case</span> <a class="code" href="classEntree.html#a92919bfab8dfa0cfdf8cf8e3dc13b078a088520a49895e1e1fb6c59bc3b5b8c84">ERROR_EXCEPTION</a>:
<a name="l00660"></a>00660       <a class="code" href="classEntree__Sortie__Error.html">Entree_Sortie_Error</a> e;
<a name="l00661"></a>00661       <span class="keywordflow">throw</span> (e);
<a name="l00662"></a>00662     }
<a name="l00663"></a>00663   <span class="keywordflow">return</span> 0;
<a name="l00664"></a>00664 }
<a name="l00665"></a>00665 
<a name="l00666"></a>00666 <span class="comment">//</span><span class="comment"></span>
<a name="l00667"></a>00667 <span class="comment">//! renvoie error_action_ pour cette entree&lt;br&gt;(permet de la modifier et de restaurer ensuite la valeur anterieure)</span>
<a name="l00668"></a><a class="code" href="classEntree.html#adf2eefe2c6cc6cb4bd658054ea788688">00668</a> <span class="comment"></span><a class="code" href="classEntree.html#a92919bfab8dfa0cfdf8cf8e3dc13b078">Entree::Error_Action</a> <a class="code" href="classEntree.html#adf2eefe2c6cc6cb4bd658054ea788688" title="renvoie error_action_ pour cette entree&lt;br&gt;(permet de la modifier et de restaurer ensuite la valeur a...">Entree::get_error_action</a>()
<a name="l00669"></a>00669 {
<a name="l00670"></a>00670   <span class="keywordflow">return</span> <a class="code" href="classEntree.html#a9c2846af38c76af98d064e665c964b20">error_action_</a>;
<a name="l00671"></a>00671 }
<a name="l00672"></a>00672 
<a name="l00673"></a>00673 <span class="comment">//</span><span class="comment"></span>
<a name="l00674"></a>00674 <span class="comment">//! Change le comportement en cas d&#39;erreur de l&#39;entree,&lt;br&gt;voir error_handle_() et get_error_action()</span>
<a name="l00675"></a><a class="code" href="classEntree.html#a955e06069e0554f46804134964371716">00675</a> <span class="comment"></span><span class="keywordtype">void</span> <a class="code" href="classEntree.html#a955e06069e0554f46804134964371716" title="Change le comportement en cas d&#39;erreur de l&#39;entree, voir error_handle_() et get_error_action()">Entree::set_error_action</a>(<a class="code" href="classEntree.html#a92919bfab8dfa0cfdf8cf8e3dc13b078">Entree::Error_Action</a> action)
<a name="l00676"></a>00676 {
<a name="l00677"></a>00677   <a class="code" href="classEntree.html#a9c2846af38c76af98d064e665c964b20">error_action_</a> = action;
<a name="l00678"></a>00678 }
<a name="l00679"></a>00679 
<a name="l00680"></a>00680 <span class="comment">// Detection sur un fichier de nom filename</span>
<a name="l00681"></a>00681 <span class="comment">// est de type binaire</span>
<a name="l00682"></a><a class="code" href="Entree_8h.html#a632dc61a0f48189b93ec2c441cbfc6e8">00682</a> <span class="keywordtype">int</span> <a class="code" href="Entree_8cpp.html#ab880c34b560e4c400889fca06290df22">is_a_binary_file</a>(<a class="code" href="classNom.html" title="class Nom Une chaine de caractere pour nommer les objets de TRUST">Nom</a>&amp; filename)
<a name="l00683"></a>00683 {
<a name="l00684"></a>00684 <span class="comment">// On parcourt les 1000 premiers octets</span>
<a name="l00685"></a>00685 <span class="comment">// Detection tres imparfaite donc limite</span>
<a name="l00686"></a>00686 <span class="comment">// aux fichiers geom de TRUST</span>
<a name="l00687"></a>00687   <span class="keywordtype">int</span> n=0;
<a name="l00688"></a>00688   <span class="keywordtype">int</span> c;
<a name="l00689"></a>00689   std::ifstream fic(filename.<a class="code" href="classNom.html#aa9f24bd3370b5f1c66666e65252eea05">getChar</a>());
<a name="l00690"></a>00690 <span class="comment">// Si on rencontre un caractere ASCII&gt;127</span>
<a name="l00691"></a>00691 <span class="comment">// alors le fichier est de type binaire</span>
<a name="l00692"></a>00692   <span class="keywordflow">while</span>((c = fic.get()) != EOF &amp;&amp; n++&lt;1000)
<a name="l00693"></a>00693     <span class="keywordflow">if</span> ((c&gt;127)||(c&lt;9))
<a name="l00694"></a>00694       <span class="keywordflow">return</span> 1;
<a name="l00695"></a>00695 <span class="comment">// GF sous windows les caracteres binaire sont surtout &lt;9</span>
<a name="l00696"></a>00696 <span class="comment">// else printf(&quot;ici %d %c \n&quot;,c,c);</span>
<a name="l00697"></a>00697   <span class="keywordflow">return</span> 0;
<a name="l00698"></a>00698 }
<a name="l00699"></a>00699 
<a name="l00700"></a>00700 <span class="comment">//</span><span class="comment"></span>
<a name="l00701"></a>00701 <span class="comment">//! ToDo TMA : commenter</span>
<a name="l00702"></a><a class="code" href="classEntree.html#a858bb1a4594186c0d3b99fb2cb6dcf64">00702</a> <span class="comment"></span><span class="keywordtype">void</span> <a class="code" href="classEntree.html#a858bb1a4594186c0d3b99fb2cb6dcf64" title="ToDo TMA : commenter.">Entree::set_diffuse</a>(<span class="keywordtype">int</span> diffuse)
<a name="l00703"></a>00703 {
<a name="l00704"></a>00704 <span class="comment">// virtual method does nothing ; cf Lec_Diffuse_base</span>
<a name="l00705"></a>00705   <a class="code" href="classEntree.html#a06ff6db21997af440f1e977673fea6d0" title="By default 1, but some child classes (eg: LecFicDiffuse) could set temporary to 0 to not diffuse to o...">diffuse_</a> = 1;
<a name="l00706"></a>00706 }
<a name="l00707"></a>00707 
</pre></div></div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Tue Dec 14 2021 19:35:26 for TRUST by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
