<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>TRUST: src/VEF/Operateurs/Op_Conv_Amont_old_VEF_Face.cpp Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">TRUST&#160;<span id="projectnumber">1.8.4</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
<div class="header">
  <div class="headertitle">
<div class="title">src/VEF/Operateurs/Op_Conv_Amont_old_VEF_Face.cpp</div>  </div>
</div>
<div class="contents">
<a href="Op__Conv__Amont__old__VEF__Face_8cpp.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/****************************************************************************</span>
<a name="l00002"></a>00002 <span class="comment">* Copyright (c) 2021, CEA</span>
<a name="l00003"></a>00003 <span class="comment">* All rights reserved.</span>
<a name="l00004"></a>00004 <span class="comment">*</span>
<a name="l00005"></a>00005 <span class="comment">* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</span>
<a name="l00006"></a>00006 <span class="comment">* 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.</span>
<a name="l00007"></a>00007 <span class="comment">* 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.</span>
<a name="l00008"></a>00008 <span class="comment">* 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.</span>
<a name="l00009"></a>00009 <span class="comment">*</span>
<a name="l00010"></a>00010 <span class="comment">* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.</span>
<a name="l00011"></a>00011 <span class="comment">* IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;</span>
<a name="l00012"></a>00012 <span class="comment">* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>
<a name="l00013"></a>00013 <span class="comment">*</span>
<a name="l00014"></a>00014 <span class="comment">*****************************************************************************/</span>
<a name="l00015"></a>00015 <span class="comment">//</span>
<a name="l00016"></a>00016 <span class="comment">// </span>
<a name="l00017"></a>00017 <span class="comment">// File:        Op_Conv_Amont_old_VEF_Face.cpp</span>
<a name="l00018"></a>00018 <span class="comment">// Directory:   $TRUST_ROOT/src/VEF/Operateurs</span>
<a name="l00019"></a>00019 <span class="comment">// Version:     /main/27</span>
<a name="l00020"></a>00020 <span class="comment">// </span>
<a name="l00021"></a>00021 <span class="comment">//</span>
<a name="l00022"></a>00022 
<a name="l00023"></a>00023 <span class="preprocessor">#include &lt;<a class="code" href="Op__Conv__Amont__old__VEF__Face_8h.html">Op_Conv_Amont_old_VEF_Face.h</a>&gt;</span>
<a name="l00024"></a>00024 <span class="preprocessor">#include &lt;<a class="code" href="Hexaedre__VEF_8h.html">Hexaedre_VEF.h</a>&gt;</span>
<a name="l00025"></a>00025 
<a name="l00026"></a><a class="code" href="Op__Conv__Amont__old__VEF__Face_8cpp.html#a5dbcaf742484fa0b2f9190e0e3aed13f">00026</a> <a class="code" href="Op__Diff__CoviMAC__Face_8cpp.html#aa86ec8ba612a969d9b4370b775037144">Implemente_instanciable</a>(<a class="code" href="classOp__Conv__Amont__old__VEF__Face.html" title="class Op_Conv_Amont_old_VEF_Face Cette classe represente l&#39;operateur de convection associe a une equa...">Op_Conv_Amont_old_VEF_Face</a>,<span class="stringliteral">&quot;Op_Conv_Amont_old_VEF_P1NC&quot;</span>,<a class="code" href="classOp__Conv__VEF__base.html" title="class Op_Conv_VEF_base Classe de base des operateurs de convection VEF">Op_Conv_VEF_base</a>);
<a name="l00027"></a>00027 
<a name="l00028"></a>00028 <span class="comment"></span>
<a name="l00029"></a>00029 <span class="comment">////!&lt; printOn </span>
<a name="l00030"></a>00030 <span class="comment"></span><span class="comment">//</span>
<a name="l00031"></a>00031 
<a name="l00032"></a><a class="code" href="classOp__Conv__Amont__old__VEF__Face.html#affca2ee4e536c47484b66cadf3e6b9ee">00032</a> <a class="code" href="classSortie.html" title="Classe de base des flux de sortie. Elle sait ecrire des types simples&lt;br&gt;(entiers, flottants) et des Ob...">Sortie</a>&amp; <a class="code" href="classOp__Conv__Amont__old__VEF__Face.html#affca2ee4e536c47484b66cadf3e6b9ee" title="NE FAIT RIEN A surcharger dans les classes derivees.">Op_Conv_Amont_old_VEF_Face::printOn</a>(<a class="code" href="classSortie.html" title="Classe de base des flux de sortie. Elle sait ecrire des types simples&lt;br&gt;(entiers, flottants) et des Ob...">Sortie</a>&amp; s )<span class="keyword"> const</span>
<a name="l00033"></a>00033 <span class="keyword"></span>{
<a name="l00034"></a>00034   <span class="keywordflow">return</span> s &lt;&lt; <a class="code" href="classObjet__U.html#aa58e9a81c0ddc2c1149053b8f96698ac" title="renvoie la chaine identifiant la classe.">que_suis_je</a>() ;
<a name="l00035"></a>00035 }
<a name="l00036"></a>00036 <span class="comment"></span>
<a name="l00037"></a>00037 <span class="comment">////!&lt; readOn </span>
<a name="l00038"></a>00038 <span class="comment"></span><span class="comment">//</span>
<a name="l00039"></a>00039 
<a name="l00040"></a><a class="code" href="classOp__Conv__Amont__old__VEF__Face.html#acef7e85a6a28e97377920964c297f2e1">00040</a> <a class="code" href="classEntree.html" title="Classe de definition des operateurs et methodes pour toute lecture dans un flot d&#39;entree (fichier...">Entree</a>&amp; <a class="code" href="classOp__Conv__Amont__old__VEF__Face.html#acef7e85a6a28e97377920964c297f2e1" title="NE FAIT RIEN A surcharger dans les classes derivees.">Op_Conv_Amont_old_VEF_Face::readOn</a>(<a class="code" href="classEntree.html" title="Classe de definition des operateurs et methodes pour toute lecture dans un flot d&#39;entree (fichier...">Entree</a>&amp; s )
<a name="l00041"></a>00041 {
<a name="l00042"></a>00042   <span class="keywordflow">return</span> s ;
<a name="l00043"></a>00043 }
<a name="l00044"></a>00044 
<a name="l00045"></a>00045 <span class="comment"></span>
<a name="l00046"></a>00046 <span class="comment">////!&lt; convbis correspond au calcul de -1*terme_convection </span>
<a name="l00047"></a>00047 <span class="comment"></span><span class="comment">//</span>
<a name="l00048"></a><a class="code" href="Op__Conv__Amont__old__VEF__Face_8cpp.html#ad96c48dab9735a2ebd000a39571790ad">00048</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="Op__Conv__Amont__old__VEF__Face_8cpp.html#ad96c48dab9735a2ebd000a39571790ad">convbis</a>(<span class="keyword">const</span> <span class="keywordtype">double</span>&amp; psc,<span class="keyword">const</span> <span class="keywordtype">int</span> num1,<span class="keyword">const</span> <span class="keywordtype">int</span> num2,
<a name="l00049"></a>00049                     <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; transporte,<span class="keyword">const</span> <span class="keywordtype">int</span> ncomp,
<a name="l00050"></a>00050                     <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; resu, <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; fluent)
<a name="l00051"></a>00051 {
<a name="l00052"></a>00052   <span class="keywordtype">int</span> comp,amont;
<a name="l00053"></a>00053   <span class="keywordtype">double</span> flux;
<a name="l00054"></a>00054 
<a name="l00055"></a>00055   <span class="keywordflow">if</span> (psc &gt;= 0)
<a name="l00056"></a>00056     {
<a name="l00057"></a>00057       amont = num1;
<a name="l00058"></a>00058       fluent[num2] += psc;
<a name="l00059"></a>00059     }
<a name="l00060"></a>00060   <span class="keywordflow">else</span>
<a name="l00061"></a>00061     {
<a name="l00062"></a>00062       amont = num2;
<a name="l00063"></a>00063       fluent[num1] -= psc;
<a name="l00064"></a>00064     }
<a name="l00065"></a>00065 
<a name="l00066"></a>00066   <span class="keywordflow">for</span> (comp=0; comp&lt;ncomp; comp++)
<a name="l00067"></a>00067     {
<a name="l00068"></a>00068       flux = transporte(amont,comp)*psc;
<a name="l00069"></a>00069       resu(num1,comp) -= flux;
<a name="l00070"></a>00070       resu(num2,comp) += flux;
<a name="l00071"></a>00071     }
<a name="l00072"></a>00072 }
<a name="l00073"></a><a class="code" href="Op__Conv__Amont__old__VEF__Face_8cpp.html#a85fe279a21bc306b225539a1527ad453">00073</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="Op__Conv__Amont__old__VEF__Face_8cpp.html#a85fe279a21bc306b225539a1527ad453">convbisimplicite</a>(<span class="keyword">const</span> <span class="keywordtype">double</span>&amp; psc,<span class="keyword">const</span> <span class="keywordtype">int</span> num1,<span class="keyword">const</span> <span class="keywordtype">int</span> num2,
<a name="l00074"></a>00074                              <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; transporte,<span class="keyword">const</span> <span class="keywordtype">int</span> ncomp,
<a name="l00075"></a>00075                              <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; <a class="code" href="Champ__P1iP1B__implementation_8cpp.html#aa8c8f49390c3cf7c702d71a71bc977e3">coeff</a>, <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; matrice)
<a name="l00076"></a>00076 {
<a name="l00077"></a>00077   <span class="keywordtype">int</span> comp,k;
<a name="l00078"></a>00078   <a class="code" href="classIntVect.html">IntVect</a>&amp; tab1 = matrice.<a class="code" href="classMatrice__Morse.html#a7a49c763706dcfaed900f9d2cbb68716">get_set_tab1</a>();
<a name="l00079"></a>00079   <a class="code" href="classIntVect.html">IntVect</a>&amp; tab2 = matrice.<a class="code" href="classMatrice__Morse.html#af11c5853518e9e6db4c7e6e6acc8d7fd">get_set_tab2</a>();
<a name="l00080"></a>00080 
<a name="l00081"></a>00081   <span class="keywordflow">for</span> (comp=0; comp&lt;ncomp; comp++)
<a name="l00082"></a>00082     {
<a name="l00083"></a>00083       <span class="keywordflow">if</span> (psc &gt;=0)
<a name="l00084"></a>00084         {
<a name="l00085"></a>00085           <span class="keywordflow">for</span> (k=tab1[num1*ncomp+comp]-1; k&lt;tab1[num1*ncomp+comp+1]-1; k++)
<a name="l00086"></a>00086             {
<a name="l00087"></a>00087               <span class="keywordflow">if</span> (tab2[k]-1== num1*ncomp+comp)
<a name="l00088"></a>00088                 <a class="code" href="Champ__P1iP1B__implementation_8cpp.html#aa8c8f49390c3cf7c702d71a71bc977e3">coeff</a>(k) += psc;
<a name="l00089"></a>00089             }
<a name="l00090"></a>00090           <span class="keywordflow">for</span> (k=tab1[num2*ncomp+comp]-1; k&lt;tab1[num2*ncomp+comp+1]-1; k++)
<a name="l00091"></a>00091             {
<a name="l00092"></a>00092               <span class="keywordflow">if</span> (tab2[k]-1== num1*ncomp+comp)
<a name="l00093"></a>00093                 <a class="code" href="Champ__P1iP1B__implementation_8cpp.html#aa8c8f49390c3cf7c702d71a71bc977e3">coeff</a>(k) -= psc;
<a name="l00094"></a>00094             }
<a name="l00095"></a>00095         }
<a name="l00096"></a>00096       <span class="keywordflow">else</span>
<a name="l00097"></a>00097         {
<a name="l00098"></a>00098           <span class="keywordflow">for</span> (k=tab1[num1*ncomp+comp]-1; k&lt;tab1[num1*ncomp+comp+1]-1; k++)
<a name="l00099"></a>00099             {
<a name="l00100"></a>00100               <span class="keywordflow">if</span> (tab2[k]-1== num2*ncomp+comp)
<a name="l00101"></a>00101                 <a class="code" href="Champ__P1iP1B__implementation_8cpp.html#aa8c8f49390c3cf7c702d71a71bc977e3">coeff</a>(k) += psc;
<a name="l00102"></a>00102             }
<a name="l00103"></a>00103           <span class="keywordflow">for</span> (k=tab1[num2*ncomp+comp]-1; k&lt;tab1[num2*ncomp+comp+1]-1; k++)
<a name="l00104"></a>00104             {
<a name="l00105"></a>00105               <span class="keywordflow">if</span> (tab2[k]-1== num2*ncomp+comp)
<a name="l00106"></a>00106                 <a class="code" href="Champ__P1iP1B__implementation_8cpp.html#aa8c8f49390c3cf7c702d71a71bc977e3">coeff</a>(k) -= psc;
<a name="l00107"></a>00107             }
<a name="l00108"></a>00108         }
<a name="l00109"></a>00109     }
<a name="l00110"></a>00110 }
<a name="l00111"></a>00111 
<a name="l00112"></a>00112 
<a name="l00113"></a><a class="code" href="classOp__Conv__Amont__old__VEF__Face.html#aaa53e8fc98b2156aafb3aba65511cf66">00113</a> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; <a class="code" href="classOp__Conv__Amont__old__VEF__Face.html#aaa53e8fc98b2156aafb3aba65511cf66">Op_Conv_Amont_old_VEF_Face::ajouter</a>(<span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; transporte,
<a name="l00114"></a>00114                                                <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; resu)<span class="keyword"> const</span>
<a name="l00115"></a>00115 <span class="keyword"></span>{
<a name="l00116"></a>00116 <span class="comment">// Cerr&lt;&lt;&quot;Op_Conv_Amont_old_VEF_Face::ajouter&quot;&lt;&lt;finl;</span>
<a name="l00117"></a>00117   <span class="keyword">const</span> <a class="code" href="classZone__Cl__VEF.html">Zone_Cl_VEF</a>&amp; zone_Cl_VEF = <a class="code" href="classOp__Conv__VEF__base.html#a03f677ee7911706a4f85cd37e0ca4535">la_zcl_vef</a>.<a class="code" href="classRef__Zone__Cl__VEF.html#a0970d7253def65ad4f0c5ce1830fd243">valeur</a>();
<a name="l00118"></a>00118   <span class="keyword">const</span> <a class="code" href="classZone__VEF.html" title="class Zone_VEF Classe instanciable qui derive de Zone_VF. Cette classe contient les informations geom...">Zone_VEF</a>&amp; zone_VEF = <a class="code" href="classOp__Conv__VEF__base.html#a6c29a488a6805ba4a9f2f059cdba77ae">la_zone_vef</a>.<a class="code" href="classRef__Zone__VEF.html#aafd9a5ee1a76f290c9c6b5447b0c8d30">valeur</a>();
<a name="l00119"></a>00119   <span class="keyword">const</span> <a class="code" href="classChamp__Inc__base.html" title="Classe Champ_Inc_base Classe de base des champs inconnues qui sont les champs calcules par une equati...">Champ_Inc_base</a>&amp; la_vitesse=<a class="code" href="classOp__Conv__VEF__base.html#a5547875832fb45e09b1115372fb76ffd">vitesse_</a>.<a class="code" href="classRef__Champ__Inc__base.html#a17553641a4c06730e1562125e07b3490">valeur</a>();
<a name="l00120"></a>00120   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; elem_faces = zone_VEF.<a class="code" href="classZone__VF.html#a067e462dcd3ab92b0f6d945b19e4eb37" title="renvoie le numero de le ieme face de la maille num_elem la facon dont ces faces sont numerotees est l...">elem_faces</a>();
<a name="l00121"></a>00121   <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; face_normales = zone_VEF.<a class="code" href="classZone__VEF.html#a5742d75972e4846bf9fbb6ed5715053e">face_normales</a>();
<a name="l00122"></a>00122   <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; facette_normales = zone_VEF.<a class="code" href="classZone__VEF.html#a581b1ca0e62c668c92f104351d19fda6">facette_normales</a>();
<a name="l00123"></a>00123   <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; porosite_face = zone_VEF.<a class="code" href="classZone__VF.html#ad9d74d1d9da9f50ab26768dbbca7711b">porosite_face</a>();
<a name="l00124"></a>00124   <span class="keyword">const</span> <a class="code" href="classZone.html" title="classe Zone Une Zone est un maillage compose d&#39;un ensemble d&#39;elements geometriques de meme type...">Zone</a>&amp; zone = zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>();
<a name="l00125"></a>00125   <span class="keyword">const</span> <a class="code" href="classElem__VEF.html">Elem_VEF</a>&amp; <a class="code" href="Raffiner__Simplexes_8cpp.html#a358dc168d8905bbafc12587204bc9fb8">type_elem</a>=zone_VEF.<a class="code" href="classZone__VEF.html#a46693c060b8096fb2595ca72192eea2a">type_elem</a>();
<a name="l00126"></a>00126   <span class="keyword">const</span> <span class="keywordtype">int</span> nfa7 = type_elem.<a class="code" href="classElem__VEF.html#a4a34777c0083b38dd34c8a400d5b4e90">nb_facette</a>();
<a name="l00127"></a>00127   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_elem_tot = zone_VEF.<a class="code" href="classZone__dis__base.html#a4d6aa445f152aa6dc54d66ea7a071147">nb_elem_tot</a>();
<a name="l00128"></a>00128   <span class="keyword">const</span> <a class="code" href="classIntVect.html">IntVect</a>&amp; rang_elem_non_std = zone_VEF.<a class="code" href="classZone__VEF.html#a4b2171a85e5fc33663a3366acb713584">rang_elem_non_std</a>();
<a name="l00129"></a>00129   <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; normales_facettes_Cl = zone_Cl_VEF.<a class="code" href="classZone__Cl__VEF.html#a83c05e82370553470ed05f10932e0f3f">normales_facettes_Cl</a>();
<a name="l00130"></a>00130   <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; fluent_ = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classDoubleVect.html">DoubleVect</a>, <a class="code" href="classOp__Conv__VEF__base.html#a32b54e8fd5340e238cf4f28ff6e743ec" title="tableau qui sert pour le calcul du pas de temps de stabilite">fluent</a>);
<a name="l00131"></a>00131   <span class="keywordtype">int</span> nfac = zone.<a class="code" href="classZone.html#a548fbc7518be2f122b1a5c9589a443c2" title="Renvoie le nombre de face de type i des elements geometriques constituants la zone. Ex: les objets de la classe Prisme ont 2 types de faces: triangle ou quadrangle.">nb_faces_elem</a>();
<a name="l00132"></a>00132   <span class="keywordtype">int</span> nsom = zone.<a class="code" href="classZone.html#ae0b34a93b9ae8146df2d1884157afe9f" title="Renvoie le nombre de sommets des elements geometriques constituants la zone. Tous les elements de la ...">nb_som_elem</a>();
<a name="l00133"></a>00133   <span class="keywordtype">int</span> nb_som_facette = zone.<a class="code" href="classZone.html#a18cf83cd0f9c368dcfa32fb802a0ac94" title="Renvoie un element geometrique du type de ceux qui constituent la zone. (version const)">type_elem</a>().<a class="code" href="classElem__geom.html#ab55aa8b4ec6aa60cfde5d5fc134c5333" title="Appel a l&#39;objet sous-jacent Renvoie le nombre de sommets des faces du type specifie.">nb_som_face</a>();
<a name="l00134"></a>00134   <span class="keyword">const</span> <a class="code" href="classElem__geom__base.html" title="Classe Elem_geom_base Cette classe est la classe de base pour la definition d&#39;elements geometriques c...">Elem_geom_base</a>&amp; elem_geom = zone.<a class="code" href="classZone.html#a18cf83cd0f9c368dcfa32fb802a0ac94" title="Renvoie un element geometrique du type de ceux qui constituent la zone. (version const)">type_elem</a>().<a class="code" href="classDeriv__Elem__geom__base.html#a384b487459a33f9f521fb16539ec81de">valeur</a>();
<a name="l00135"></a>00135   <span class="keywordflow">if</span> ( <a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classHexaedre__VEF.html" title="Classe Hexaedre_VEF Cette classe represente l&#39;element geometrique Hexaedre_VEF. Un Hexaedre_VEF est u...">Hexaedre_VEF</a>,elem_geom))
<a name="l00136"></a>00136     {
<a name="l00137"></a>00137       nb_som_facette--;
<a name="l00138"></a>00138     }
<a name="l00139"></a>00139 
<a name="l00140"></a>00140   <span class="keyword">const</span> <a class="code" href="classElem__VEF__base.html">Elem_VEF_base</a>&amp; type_elemvef= zone_VEF.<a class="code" href="classZone__VEF.html#a46693c060b8096fb2595ca72192eea2a">type_elem</a>().<a class="code" href="classDeriv__Elem__VEF__base.html#a2886905d5071be902c77248b69ca0b7b">valeur</a>();
<a name="l00141"></a>00141 
<a name="l00142"></a>00142 <span class="comment">// MODIF SB su 10/09/03</span>
<a name="l00143"></a>00143 <span class="comment">// Pour les 3 elements suivants, il y a autant de sommets que de face</span>
<a name="l00144"></a>00144 <span class="comment">// constituant l&#39;element geometrique</span>
<a name="l00145"></a>00145 <span class="comment">// PB avec les hexa, 8 sommets et 6 faces, donc l&#39;utilisation du tableau</span>
<a name="l00146"></a>00146 <span class="comment">// face[i] ne fonctionne plus</span>
<a name="l00147"></a>00147 <span class="comment">// la methode retenue pour eviter de calculer la vitesse aux sommets sans</span>
<a name="l00148"></a>00148 <span class="comment">// les fonctions de forme n&#39;est donc pas utilisable,</span>
<a name="l00149"></a>00149 <span class="comment">// pour l&#39;hexa on n&#39;a pas acces a la face.</span>
<a name="l00150"></a>00150 <span class="comment">// il existe le tableau Face=&gt;sommets mais pas l&#39;inverse.</span>
<a name="l00151"></a>00151 <span class="comment">// trop couteux et pour le moment on n&#39;etend pas les porosites aux hexa</span>
<a name="l00152"></a>00152 <span class="comment">// ||(nom_elem==&quot;Quadri_VEF&quot;)</span>
<a name="l00153"></a>00153   <span class="keywordtype">int</span> istetra=0;
<a name="l00154"></a>00154   <a class="code" href="classNom.html" title="class Nom Une chaine de caractere pour nommer les objets de TRUST">Nom</a> nom_elem=type_elemvef.<a class="code" href="classObjet__U.html#aa58e9a81c0ddc2c1149053b8f96698ac" title="renvoie la chaine identifiant la classe.">que_suis_je</a>();
<a name="l00155"></a>00155   <span class="keywordflow">if</span> ((nom_elem==<span class="stringliteral">&quot;Tetra_VEF&quot;</span>)||(nom_elem==<span class="stringliteral">&quot;Tri_VEF&quot;</span>))
<a name="l00156"></a>00156     istetra=1;
<a name="l00157"></a>00157 
<a name="l00158"></a>00158 <span class="comment">// Pour le traitement de la convection on distingue les polyedres</span>
<a name="l00159"></a>00159 <span class="comment">// standard qui ne &quot;voient&quot; pas les conditions aux limites et les</span>
<a name="l00160"></a>00160 <span class="comment">// polyedres non standard qui ont au moins une face sur le bord.</span>
<a name="l00161"></a>00161 <span class="comment">// Un polyedre standard a n facettes sur lesquelles on applique le</span>
<a name="l00162"></a>00162 <span class="comment">// schema de convection.</span>
<a name="l00163"></a>00163 <span class="comment">// Pour un polyedre non standard qui porte des conditions aux limites</span>
<a name="l00164"></a>00164 <span class="comment">// de Dirichlet, une partie des facettes sont portees par les faces.</span>
<a name="l00165"></a>00165 <span class="comment">// En bref pour un polyedre le traitement de la convection depend</span>
<a name="l00166"></a>00166 <span class="comment">// du type (triangle, tetraedre ...) et du nombre de faces de Dirichlet.</span>
<a name="l00167"></a>00167 
<a name="l00168"></a>00168   <span class="keywordtype">double</span> psc;
<a name="l00169"></a>00169   <span class="keywordtype">int</span> poly,face_adj,fa7,i,j,n_bord,num_face, rang ,itypcl, num10,num20,num_som;
<a name="l00170"></a>00170   <span class="keyword">const</span> <span class="keywordtype">int</span> ncomp_ch_transporte = transporte.<a class="code" href="classDoubleVect.html#ab02d01cd1bdab66fbd66f9a47cc29e10">line_size</a>();
<a name="l00171"></a>00171 
<a name="l00172"></a>00172   <a class="code" href="classIntVect.html">IntVect</a> face(nfac);
<a name="l00173"></a>00173   <a class="code" href="classDoubleVect.html">DoubleVect</a> vs(<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>);
<a name="l00174"></a>00174   <a class="code" href="classDoubleVect.html">DoubleVect</a> vc(<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>);
<a name="l00175"></a>00175   <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a> vsom(nsom,<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>);
<a name="l00176"></a>00176   <a class="code" href="classDoubleVect.html">DoubleVect</a> cc(<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>);
<a name="l00177"></a>00177 
<a name="l00178"></a>00178 <span class="comment">// On remet a zero le tableau qui sert pour</span>
<a name="l00179"></a>00179 <span class="comment">// le calcul du pas de temps de stabilite</span>
<a name="l00180"></a>00180   fluent_ = 0;
<a name="l00181"></a>00181 
<a name="l00182"></a>00182 <span class="comment">// Traitement particulier pour les faces de periodicite</span>
<a name="l00183"></a>00183 
<a name="l00184"></a>00184   <span class="keywordtype">int</span> nb_faces_perio = 0;
<a name="l00185"></a>00185 <span class="comment">// Boucle pour compter le nombre de faces de periodicite</span>
<a name="l00186"></a>00186   <span class="keywordflow">for</span> (n_bord=0; n_bord&lt;zone_VEF.<a class="code" href="classZone__dis__base.html#af22167d614644f55591a29c77eb1c009">nb_front_Cl</a>(); n_bord++)
<a name="l00187"></a>00187     {
<a name="l00188"></a>00188       <span class="keyword">const</span> <a class="code" href="classCond__lim.html" title="classe Cond_lim Classe generique servant a representer n&#39;importe quelle classe derivee de la classe C...">Cond_lim</a>&amp; la_cl = zone_Cl_VEF.<a class="code" href="classZone__Cl__dis__base.html#af75e0ed7786863e4d333bfb29d67c323" title="Renvoie la i-ieme condition aux limites. (version const)">les_conditions_limites</a>(n_bord);
<a name="l00189"></a>00189       <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>()))
<a name="l00190"></a>00190         {
<a name="l00191"></a>00191           <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp; le_bord = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>,la_cl.<a class="code" href="classCond__lim.html#a5b2d24809cee07727006a891d4ce8d22" title="Appel a l&#39;objet sous-jacent Renvoie la frontiere discretisee associee a la condition aux limites...">frontiere_dis</a>());
<a name="l00192"></a>00192           nb_faces_perio += le_bord.<a class="code" href="classFront__VF.html#a341e2fcb5117b96e745fd7078ba86bab" title="Nombre de faces reelles du bord.">nb_faces</a>();
<a name="l00193"></a>00193         }
<a name="l00194"></a>00194     }
<a name="l00195"></a>00195 
<a name="l00196"></a>00196   <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a> tab(nb_faces_perio,ncomp_ch_transporte);
<a name="l00197"></a>00197 <span class="comment">// Boucle pour remplir tab</span>
<a name="l00198"></a>00198   nb_faces_perio=0;
<a name="l00199"></a>00199   <span class="keywordflow">for</span> (n_bord=0; n_bord&lt;zone_VEF.<a class="code" href="classZone__dis__base.html#af22167d614644f55591a29c77eb1c009">nb_front_Cl</a>(); n_bord++)
<a name="l00200"></a>00200     {
<a name="l00201"></a>00201       <span class="keyword">const</span> <a class="code" href="classCond__lim.html" title="classe Cond_lim Classe generique servant a representer n&#39;importe quelle classe derivee de la classe C...">Cond_lim</a>&amp; la_cl = zone_Cl_VEF.<a class="code" href="classZone__Cl__dis__base.html#af75e0ed7786863e4d333bfb29d67c323" title="Renvoie la i-ieme condition aux limites. (version const)">les_conditions_limites</a>(n_bord);
<a name="l00202"></a>00202       <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>()))
<a name="l00203"></a>00203         {
<a name="l00204"></a>00204 <span class="comment">// const Periodique&amp; la_cl_perio = ref_cast(Periodique, la_cl.valeur());</span>
<a name="l00205"></a>00205           <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp; le_bord = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>,la_cl.<a class="code" href="classCond__lim.html#a5b2d24809cee07727006a891d4ce8d22" title="Appel a l&#39;objet sous-jacent Renvoie la frontiere discretisee associee a la condition aux limites...">frontiere_dis</a>());
<a name="l00206"></a>00206           <span class="keywordtype">int</span> num1 = le_bord.<a class="code" href="classFront__VF.html#a4986f0c65653fe9eb40bbbff5a97bf16" title="Numero de la premiere face du bord dans la liste des faces.">num_premiere_face</a>();
<a name="l00207"></a>00207           <span class="keywordtype">int</span> num2 = num1 + le_bord.<a class="code" href="classFront__VF.html#a341e2fcb5117b96e745fd7078ba86bab" title="Nombre de faces reelles du bord.">nb_faces</a>();
<a name="l00208"></a>00208           <span class="keywordflow">for</span> (num_face=num1; num_face&lt;num2; num_face++)
<a name="l00209"></a>00209             {
<a name="l00210"></a>00210               <span class="keywordflow">for</span> (<span class="keywordtype">int</span> comp=0; comp&lt;ncomp_ch_transporte; comp++)
<a name="l00211"></a>00211                 tab(nb_faces_perio,comp) = resu(num_face,comp);
<a name="l00212"></a>00212               nb_faces_perio++;
<a name="l00213"></a>00213             }
<a name="l00214"></a>00214         }
<a name="l00215"></a>00215     }
<a name="l00216"></a>00216 
<a name="l00217"></a>00217   <a class="code" href="classIntVect.html">IntVect</a> <a class="code" href="Memoire_8cpp.html#ade857a99d48bcb8cfaa57c4cd8d7d2e8">compteur</a>(nsom);
<a name="l00218"></a>00218   compteur = 0;
<a name="l00219"></a>00219   vsom=0.;
<a name="l00220"></a>00220 
<a name="l00221"></a>00221 <span class="comment">// Les polyedres non standard sont ranges en 2 groupes dans la Zone_VEF:</span>
<a name="l00222"></a>00222 <span class="comment">// - polyedres bords et joints</span>
<a name="l00223"></a>00223 <span class="comment">// - polyedres bords et non joints</span>
<a name="l00224"></a>00224 <span class="comment">// On traite les polyedres en suivant l&#39;ordre dans lequel ils figurent</span>
<a name="l00225"></a>00225 <span class="comment">// dans la zone</span>
<a name="l00226"></a>00226 
<a name="l00227"></a>00227 <span class="comment">// boucle sur les polys</span>
<a name="l00228"></a>00228   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; KEL=zone_VEF.<a class="code" href="classZone__VEF.html#a46693c060b8096fb2595ca72192eea2a">type_elem</a>().<a class="code" href="classDeriv__Elem__VEF__base.html#a2886905d5071be902c77248b69ca0b7b">valeur</a>().<a class="code" href="classElem__VEF__base.html#ab129610ef702aa8c9c98dcb4c7551172">KEL</a>();
<a name="l00229"></a>00229   <span class="keywordflow">for</span> (poly=0; poly&lt;nb_elem_tot; poly++)
<a name="l00230"></a>00230     {
<a name="l00231"></a>00231       rang = rang_elem_non_std(poly);
<a name="l00232"></a>00232       <span class="keywordflow">if</span> (rang==-1)
<a name="l00233"></a>00233         itypcl=0;
<a name="l00234"></a>00234       <span class="keywordflow">else</span>
<a name="l00235"></a>00235         itypcl=zone_Cl_VEF.<a class="code" href="classZone__Cl__VEF.html#a483bdab7690f844ed04e3defe04ec70a">type_elem_Cl</a>(rang);
<a name="l00236"></a>00236 
<a name="l00237"></a>00237 <span class="comment">// calcul des numeros des faces du polyedre</span>
<a name="l00238"></a>00238       <span class="keywordflow">for</span> (face_adj=0; face_adj&lt;nfac; face_adj++)
<a name="l00239"></a>00239         face[face_adj]= elem_faces(poly,face_adj);
<a name="l00240"></a>00240 <span class="comment">// on conserve cette partie</span>
<a name="l00241"></a>00241       <span class="keywordflow">for</span> (j=0; j&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; j++)
<a name="l00242"></a>00242         {
<a name="l00243"></a>00243           vs[j] = la_vitesse(face[0],j)*porosite_face(face[0]);
<a name="l00244"></a>00244           <span class="keywordflow">for</span> (i=1; i&lt;nfac; i++)
<a name="l00245"></a>00245             vs[j]+= la_vitesse(face[i],j)*porosite_face(face[i]);
<a name="l00246"></a>00246         }
<a name="l00247"></a>00247 
<a name="l00248"></a>00248 <span class="comment">// calcul de la vitesse aux sommets des polyedres</span>
<a name="l00249"></a>00249 <span class="comment">// int ncomp;</span>
<a name="l00250"></a>00250       <span class="keywordflow">if</span> (istetra==1)
<a name="l00251"></a>00251         {
<a name="l00252"></a>00252           <span class="keywordflow">for</span> (j=0; j&lt;nsom; j++)
<a name="l00253"></a>00253             <span class="keywordflow">for</span> (<span class="keywordtype">int</span> ncomp=0; ncomp&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>; ncomp++)
<a name="l00254"></a>00254               vsom(j,ncomp) =vs[ncomp] - Objet_U::dimension*la_vitesse(face[j],ncomp)*porosite_face(face[j]);
<a name="l00255"></a>00255         }
<a name="l00256"></a>00256       <span class="keywordflow">else</span>
<a name="l00257"></a>00257         {
<a name="l00258"></a>00258 <span class="comment">// pour que cela soit valide avec les hexa</span>
<a name="l00259"></a>00259 <span class="comment">// On va utliser les fonctions de forme implementees dans la classe Champs_P1_impl ou Champs_Q1_impl</span>
<a name="l00260"></a>00260 <span class="comment">// int ncomp;</span>
<a name="l00261"></a>00261           <span class="keywordflow">for</span> (j=0; j&lt;nsom; j++)
<a name="l00262"></a>00262             {
<a name="l00263"></a>00263               num_som = zone.<a class="code" href="classZone.html#aa164c00997bc77a365a6da57bbec29ce" title="Renvoie le numero (global) j-ieme sommet du i-ieme element.">sommet_elem</a>(poly,j);
<a name="l00264"></a>00264               <span class="keywordflow">for</span> (<span class="keywordtype">int</span> ncomp=0; ncomp&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; ncomp++)
<a name="l00265"></a>00265                 vsom(j,ncomp) = la_vitesse.<a class="code" href="classChamp__base.html#ad78f84c898b6fca623a30a9ae665c269" title="renvoi la compo eme corrdonne des valeurs a l&#39;element le_poly au sommet sommet">valeur_a_sommet_compo</a>(num_som,poly,ncomp);
<a name="l00266"></a>00266             }
<a name="l00267"></a>00267         }
<a name="l00268"></a>00268 
<a name="l00269"></a>00269       type_elem.<a class="code" href="classElem__VEF.html#ab0be052b1bfa6135cb9b8288086f098e">calcul_vc</a>(face,vc,vs,vsom,<a class="code" href="classOp__Conv__VEF__base.html#a4872ffd7c638ecc415191d92d7f5f507">vitesse</a>(),itypcl,porosite_face);
<a name="l00270"></a>00270 
<a name="l00271"></a>00271 <span class="comment">// Boucle sur les facettes du polyedre</span>
<a name="l00272"></a>00272       <span class="keywordflow">for</span> (fa7=0; fa7&lt;nfa7; fa7++)
<a name="l00273"></a>00273         {
<a name="l00274"></a>00274           <span class="keywordflow">if</span> (rang==-1)
<a name="l00275"></a>00275             <span class="keywordflow">for</span> (i=0; i&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; i++)
<a name="l00276"></a>00276               cc[i] = facette_normales(poly,fa7,i);
<a name="l00277"></a>00277           <span class="keywordflow">else</span>
<a name="l00278"></a>00278             <span class="keywordflow">for</span> (i=0; i&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; i++)
<a name="l00279"></a>00279               cc[i] = normales_facettes_Cl(rang,fa7,i);
<a name="l00280"></a>00280 
<a name="l00281"></a>00281 <span class="comment">// On applique le schema de convection a chaque sommet de la facette</span>
<a name="l00282"></a>00282 <span class="comment">// On traite le ou les sommets qui sont aussi des sommets du polyedre</span>
<a name="l00283"></a>00283           <span class="keywordflow">for</span> (i=0; i&lt;nb_som_facette-1; i++)
<a name="l00284"></a>00284             {
<a name="l00285"></a>00285               psc =0;
<a name="l00286"></a>00286               <span class="keywordflow">for</span> (j=0; j&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; j++)
<a name="l00287"></a>00287                 psc+= vsom(KEL(i+2,fa7),j)*cc[j];
<a name="l00288"></a>00288 
<a name="l00289"></a>00289 <span class="comment">// Boucle sur les facettes du polyedre</span>
<a name="l00290"></a>00290               psc /= nb_som_facette;
<a name="l00291"></a>00291               num10 = face[KEL(0,fa7)];
<a name="l00292"></a>00292               num20 = face[KEL(1,fa7)];
<a name="l00293"></a>00293 <span class="comment">// psc *= (porosite_face(num1)+porosite_face(num2))/2. ;</span>
<a name="l00294"></a>00294 
<a name="l00295"></a>00295               <a class="code" href="Op__Conv__Amont__old__VEF__Face_8cpp.html#ad96c48dab9735a2ebd000a39571790ad">convbis</a>(psc,num10,num20,transporte,ncomp_ch_transporte,resu,fluent_);
<a name="l00296"></a>00296             }
<a name="l00297"></a>00297 <span class="comment">// On traite le sommet confondu avec le centre de gravite du polyedre</span>
<a name="l00298"></a>00298           psc=0;
<a name="l00299"></a>00299           <span class="keywordflow">for</span> (j=0; j&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; j++)
<a name="l00300"></a>00300             psc += vc[j]*cc[j];
<a name="l00301"></a>00301           psc /= nb_som_facette;
<a name="l00302"></a>00302           num10 = face[KEL(0,fa7)];
<a name="l00303"></a>00303           num20 = face[KEL(1,fa7)];
<a name="l00304"></a>00304 <span class="comment">// psc *= (porosite_face(num1)+porosite_face(num2))/2. ;</span>
<a name="l00305"></a>00305 
<a name="l00306"></a>00306           <a class="code" href="Op__Conv__Amont__old__VEF__Face_8cpp.html#ad96c48dab9735a2ebd000a39571790ad">convbis</a>(psc,num10,num20,transporte,ncomp_ch_transporte,resu,fluent_);
<a name="l00307"></a>00307         }
<a name="l00308"></a>00308 
<a name="l00309"></a>00309     } <span class="comment">//!&lt; fin de la boucle   if(Process::nproc()==1)     Process::Journal()&lt;&lt;&quot;OpVEFFaAmont ap interne resu[8]=&quot;&lt;&lt;resu(8,0)&lt;&lt;&quot;,&quot;&lt;&lt;resu(8,1)&lt;&lt;finl;   if((Process::nproc()==2)&amp;&amp;(Process::me()==0))     Process::Journal()&lt;&lt;&quot;OpVEFFaAmont ap interne resu[4]=&quot;&lt;&lt;resu(4,0)&lt;&lt;&quot;,&quot;&lt;&lt;resu(4,1)&lt;&lt;finl;</span>
<a name="l00310"></a>00310 <span class="comment"></span><span class="comment">//</span>
<a name="l00311"></a>00311 <span class="comment">//</span>
<a name="l00312"></a>00312 <span class="comment">//</span>
<a name="l00313"></a>00313 <span class="comment">//</span>
<a name="l00314"></a>00314 
<a name="l00315"></a>00315   <span class="keywordtype">int</span> voisine;
<a name="l00316"></a>00316   nb_faces_perio = 0;
<a name="l00317"></a>00317   <span class="keywordtype">double</span> diff1,diff2;
<a name="l00318"></a>00318 
<a name="l00319"></a>00319 <span class="comment">// Dimensionnement du tableau des flux convectifs au bord du domaine</span>
<a name="l00320"></a>00320 <span class="comment">// de calcul</span>
<a name="l00321"></a>00321   <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; flux_b = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>,<a class="code" href="classOperateur__base.html#a451f51b41518ddbc0d3f586a8177d319" title="Tableau contenant les flux sur les bords de l&#39;operateur.">flux_bords_</a>);
<a name="l00322"></a>00322   flux_b.<a class="code" href="classDoubleTab.html#ae83b4d31205c53d9c8d2b43da178ce75" title="Change la taille du vecteur (identique a resize_array() pour le traitement des anciennes valeurs et d...">resize</a>(zone_VEF.<a class="code" href="classZone__VF.html#a8815e2276637c0db23868f043dc43e58" title="renvoie le nombre de faces sur lesquelles sont appliquees les conditions limites : bords...">nb_faces_bord</a>(),ncomp_ch_transporte);
<a name="l00323"></a>00323   flux_b = 0.;
<a name="l00324"></a>00324 
<a name="l00325"></a>00325 <span class="comment">// Boucle sur les bords pour traiter les conditions aux limites</span>
<a name="l00326"></a>00326 <span class="comment">// il y a prise en compte d&#39;un terme de convection pour les</span>
<a name="l00327"></a>00327 <span class="comment">// conditions aux limites de Neumann_sortie_libre seulement</span>
<a name="l00328"></a>00328 
<a name="l00329"></a>00329   <span class="keywordflow">for</span> (n_bord=0; n_bord&lt;zone_VEF.<a class="code" href="classZone__dis__base.html#af22167d614644f55591a29c77eb1c009">nb_front_Cl</a>(); n_bord++)
<a name="l00330"></a>00330     {
<a name="l00331"></a>00331 
<a name="l00332"></a>00332       <span class="keyword">const</span> <a class="code" href="classCond__lim.html" title="classe Cond_lim Classe generique servant a representer n&#39;importe quelle classe derivee de la classe C...">Cond_lim</a>&amp; la_cl = zone_Cl_VEF.<a class="code" href="classZone__Cl__dis__base.html#af75e0ed7786863e4d333bfb29d67c323" title="Renvoie la i-ieme condition aux limites. (version const)">les_conditions_limites</a>(n_bord);
<a name="l00333"></a>00333 
<a name="l00334"></a>00334       <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classNeumann__sortie__libre.html" title="classe Neumann_sortie_libre Cette classe represente une frontiere ouverte sans vitesse imposee Pour l...">Neumann_sortie_libre</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>()))
<a name="l00335"></a>00335         {
<a name="l00336"></a>00336           <span class="keyword">const</span> <a class="code" href="classNeumann__sortie__libre.html" title="classe Neumann_sortie_libre Cette classe represente une frontiere ouverte sans vitesse imposee Pour l...">Neumann_sortie_libre</a>&amp; la_sortie_libre = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classNeumann__sortie__libre.html" title="classe Neumann_sortie_libre Cette classe represente une frontiere ouverte sans vitesse imposee Pour l...">Neumann_sortie_libre</a>, la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>());
<a name="l00337"></a>00337           <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp; le_bord = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>,la_cl.<a class="code" href="classCond__lim.html#a5b2d24809cee07727006a891d4ce8d22" title="Appel a l&#39;objet sous-jacent Renvoie la frontiere discretisee associee a la condition aux limites...">frontiere_dis</a>());
<a name="l00338"></a>00338           <span class="keywordtype">int</span> num1 = le_bord.num_premiere_face();
<a name="l00339"></a>00339           <span class="keywordtype">int</span> num2 = num1 + le_bord.nb_faces();
<a name="l00340"></a>00340           <span class="keywordflow">for</span> (num_face=num1; num_face&lt;num2; num_face++)
<a name="l00341"></a>00341             {
<a name="l00342"></a>00342               psc =0;
<a name="l00343"></a>00343               <span class="keywordflow">for</span> (i=0; i&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; i++)
<a name="l00344"></a>00344                 psc += la_vitesse(num_face,i)*face_normales(num_face,i)*porosite_face(num_face);
<a name="l00345"></a>00345               <span class="keywordflow">if</span> (psc&gt;0)
<a name="l00346"></a>00346                 {
<a name="l00347"></a>00347                   <span class="keywordflow">for</span> (i=0; i&lt;ncomp_ch_transporte; i++)
<a name="l00348"></a>00348                     {
<a name="l00349"></a>00349                       resu(num_face,i) -= psc*transporte(num_face,i);
<a name="l00350"></a>00350                       flux_b(num_face,i) -= psc*transporte(num_face,i);
<a name="l00351"></a>00351                     }
<a name="l00352"></a>00352                 }
<a name="l00353"></a>00353               <span class="keywordflow">else</span>
<a name="l00354"></a>00354                 {
<a name="l00355"></a>00355                   <span class="keywordflow">for</span> (i=0; i&lt;ncomp_ch_transporte; i++)
<a name="l00356"></a>00356                     {
<a name="l00357"></a>00357                       resu(num_face,i) -= psc*la_sortie_libre.<a class="code" href="classNeumann__sortie__libre.html#a886f1804fa2a9028fc56a0778a72a75d" title="Renvoie la valeur de la i-eme composante du champ impose a l&#39;exterieur de la frontiere.">val_ext</a>(num_face-num1,i);
<a name="l00358"></a>00358                       flux_b(num_face,i) -= psc*la_sortie_libre.<a class="code" href="classNeumann__sortie__libre.html#a886f1804fa2a9028fc56a0778a72a75d" title="Renvoie la valeur de la i-eme composante du champ impose a l&#39;exterieur de la frontiere.">val_ext</a>(num_face-num1,i);
<a name="l00359"></a>00359                     }
<a name="l00360"></a>00360                   fluent_[num_face] -= psc;
<a name="l00361"></a>00361                 }
<a name="l00362"></a>00362             }
<a name="l00363"></a>00363         }
<a name="l00364"></a>00364       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>()))
<a name="l00365"></a>00365         {
<a name="l00366"></a>00366           <span class="keyword">const</span> <a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>&amp; la_cl_perio = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>, la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>());
<a name="l00367"></a>00367           <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp; le_bord = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>,la_cl.<a class="code" href="classCond__lim.html#a5b2d24809cee07727006a891d4ce8d22" title="Appel a l&#39;objet sous-jacent Renvoie la frontiere discretisee associee a la condition aux limites...">frontiere_dis</a>());
<a name="l00368"></a>00368           <span class="keywordtype">int</span> num1 = le_bord.num_premiere_face(), num2 = num1 + le_bord.nb_faces();
<a name="l00369"></a>00369           <a class="code" href="classIntVect.html">IntVect</a> fait(le_bord.nb_faces());
<a name="l00370"></a>00370           fait = 0;
<a name="l00371"></a>00371           <span class="keywordflow">for</span> (num_face=num1; num_face&lt;num2; num_face++)
<a name="l00372"></a>00372             {
<a name="l00373"></a>00373               <span class="keywordflow">if</span> (fait[num_face-num1] == 0)
<a name="l00374"></a>00374                 {
<a name="l00375"></a>00375                   voisine = la_cl_perio.<a class="code" href="classPeriodique.html#a207b86556f199a63ea059b841851ca6a">face_associee</a>(num_face-num1) + num1;
<a name="l00376"></a>00376                   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> comp=0; comp&lt;ncomp_ch_transporte; comp++)
<a name="l00377"></a>00377                     {
<a name="l00378"></a>00378                       diff1 = resu(num_face,comp)-tab(nb_faces_perio,comp);
<a name="l00379"></a>00379                       diff2 = resu(voisine,comp)-tab(nb_faces_perio+voisine-num_face,comp);
<a name="l00380"></a>00380                       resu(voisine,comp)  += diff1;
<a name="l00381"></a>00381                       resu(num_face,comp) += diff2;
<a name="l00382"></a>00382                       flux_b(voisine,comp) += diff1;
<a name="l00383"></a>00383                       flux_b(num_face,comp) += diff2;
<a name="l00384"></a>00384                     }
<a name="l00385"></a>00385 
<a name="l00386"></a>00386                   fait[num_face-num1]= 1;
<a name="l00387"></a>00387                   fait[voisine-num1] = 1;
<a name="l00388"></a>00388                 }
<a name="l00389"></a>00389               nb_faces_perio++;
<a name="l00390"></a>00390             }
<a name="l00391"></a>00391         }
<a name="l00392"></a>00392     }
<a name="l00393"></a>00393   <a class="code" href="classOp__VEF__Face.html#a6c8ce571769b4f2e20b07cbb7a6944f2">modifier_flux</a>(*<span class="keyword">this</span>);
<a name="l00394"></a>00394   <span class="keywordflow">return</span> resu;
<a name="l00395"></a>00395 
<a name="l00396"></a>00396 }
<a name="l00397"></a>00397 
<a name="l00398"></a>00398 
<a name="l00399"></a><a class="code" href="classOp__Conv__Amont__old__VEF__Face.html#a8279d162c7b802807190abb25273673d">00399</a> <span class="keywordtype">void</span> <a class="code" href="classOp__Conv__Amont__old__VEF__Face.html#a8279d162c7b802807190abb25273673d">Op_Conv_Amont_old_VEF_Face::ajouter_contribution</a>(<span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; transporte, <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; matrice )<span class="keyword"> const</span>
<a name="l00400"></a>00400 <span class="keyword"></span>{
<a name="l00401"></a>00401   <span class="keyword">const</span> <a class="code" href="classZone__Cl__VEF.html">Zone_Cl_VEF</a>&amp; zone_Cl_VEF = <a class="code" href="classOp__Conv__VEF__base.html#a03f677ee7911706a4f85cd37e0ca4535">la_zcl_vef</a>.<a class="code" href="classRef__Zone__Cl__VEF.html#a0970d7253def65ad4f0c5ce1830fd243">valeur</a>();
<a name="l00402"></a>00402   <span class="keyword">const</span> <a class="code" href="classZone__VEF.html" title="class Zone_VEF Classe instanciable qui derive de Zone_VF. Cette classe contient les informations geom...">Zone_VEF</a>&amp; zone_VEF = <a class="code" href="classOp__Conv__VEF__base.html#a6c29a488a6805ba4a9f2f059cdba77ae">la_zone_vef</a>.<a class="code" href="classRef__Zone__VEF.html#aafd9a5ee1a76f290c9c6b5447b0c8d30">valeur</a>();
<a name="l00403"></a>00403   <span class="keyword">const</span> <a class="code" href="classChamp__Inc__base.html" title="Classe Champ_Inc_base Classe de base des champs inconnues qui sont les champs calcules par une equati...">Champ_Inc_base</a>&amp; la_vitesse=<a class="code" href="classOp__Conv__VEF__base.html#a5547875832fb45e09b1115372fb76ffd">vitesse_</a>.<a class="code" href="classRef__Champ__Inc__base.html#a17553641a4c06730e1562125e07b3490">valeur</a>();
<a name="l00404"></a>00404   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; elem_faces = zone_VEF.<a class="code" href="classZone__VF.html#a067e462dcd3ab92b0f6d945b19e4eb37" title="renvoie le numero de le ieme face de la maille num_elem la facon dont ces faces sont numerotees est l...">elem_faces</a>();
<a name="l00405"></a>00405   <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; face_normales = zone_VEF.<a class="code" href="classZone__VEF.html#a5742d75972e4846bf9fbb6ed5715053e">face_normales</a>();
<a name="l00406"></a>00406   <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; facette_normales = zone_VEF.<a class="code" href="classZone__VEF.html#a581b1ca0e62c668c92f104351d19fda6">facette_normales</a>();
<a name="l00407"></a>00407   <span class="keyword">const</span> <a class="code" href="classZone.html" title="classe Zone Une Zone est un maillage compose d&#39;un ensemble d&#39;elements geometriques de meme type...">Zone</a>&amp; zone = zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>();
<a name="l00408"></a>00408   <span class="keyword">const</span> <a class="code" href="classElem__VEF.html">Elem_VEF</a>&amp; <a class="code" href="Raffiner__Simplexes_8cpp.html#a358dc168d8905bbafc12587204bc9fb8">type_elem</a> = zone_VEF.<a class="code" href="classZone__VEF.html#a46693c060b8096fb2595ca72192eea2a">type_elem</a>();
<a name="l00409"></a>00409   <span class="keyword">const</span> <span class="keywordtype">int</span> nfa7 = type_elem.<a class="code" href="classElem__VEF.html#a4a34777c0083b38dd34c8a400d5b4e90">nb_facette</a>();
<a name="l00410"></a>00410   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_elem_tot = zone_VEF.<a class="code" href="classZone__dis__base.html#a4d6aa445f152aa6dc54d66ea7a071147">nb_elem_tot</a>();
<a name="l00411"></a>00411   <span class="keyword">const</span> <a class="code" href="classIntVect.html">IntVect</a>&amp; rang_elem_non_std = zone_VEF.<a class="code" href="classZone__VEF.html#a4b2171a85e5fc33663a3366acb713584">rang_elem_non_std</a>();
<a name="l00412"></a>00412   <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; porosite_face = zone_VEF.<a class="code" href="classZone__VF.html#ad9d74d1d9da9f50ab26768dbbca7711b">porosite_face</a>();
<a name="l00413"></a>00413   <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; normales_facettes_Cl = zone_Cl_VEF.<a class="code" href="classZone__Cl__VEF.html#a83c05e82370553470ed05f10932e0f3f">normales_facettes_Cl</a>();
<a name="l00414"></a>00414   <span class="keywordtype">int</span> nfac = zone.<a class="code" href="classZone.html#a548fbc7518be2f122b1a5c9589a443c2" title="Renvoie le nombre de face de type i des elements geometriques constituants la zone. Ex: les objets de la classe Prisme ont 2 types de faces: triangle ou quadrangle.">nb_faces_elem</a>(), nsom = zone.<a class="code" href="classZone.html#ae0b34a93b9ae8146df2d1884157afe9f" title="Renvoie le nombre de sommets des elements geometriques constituants la zone. Tous les elements de la ...">nb_som_elem</a>(), nb_som_facette = zone.<a class="code" href="classZone.html#a18cf83cd0f9c368dcfa32fb802a0ac94" title="Renvoie un element geometrique du type de ceux qui constituent la zone. (version const)">type_elem</a>().<a class="code" href="classElem__geom.html#ab55aa8b4ec6aa60cfde5d5fc134c5333" title="Appel a l&#39;objet sous-jacent Renvoie le nombre de sommets des faces du type specifie.">nb_som_face</a>();
<a name="l00415"></a>00415 
<a name="l00416"></a>00416 <span class="comment">// Pour le traitement de la convection on distingue les polyedres</span>
<a name="l00417"></a>00417 <span class="comment">// standard qui ne &quot;voient&quot; pas les conditions aux limites et les</span>
<a name="l00418"></a>00418 <span class="comment">// polyedres non standard qui ont au moins une face sur le bord.</span>
<a name="l00419"></a>00419 <span class="comment">// Un polyedre standard a n facettes sur lesquelles on applique le</span>
<a name="l00420"></a>00420 <span class="comment">// schema de convection.</span>
<a name="l00421"></a>00421 <span class="comment">// Pour un polyedre non standard qui porte des conditions aux limites</span>
<a name="l00422"></a>00422 <span class="comment">// de Dirichlet, une partie des facettes sont portees par les faces.</span>
<a name="l00423"></a>00423 <span class="comment">// En bref pour un polyedre le traitement de la convection depend</span>
<a name="l00424"></a>00424 <span class="comment">// du type (triangle, tetraedre ...) et du nombre de faces de Dirichlet.</span>
<a name="l00425"></a>00425 
<a name="l00426"></a>00426   <span class="keywordtype">double</span> psc;
<a name="l00427"></a>00427   <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a> pscl=0;
<a name="l00428"></a>00428   <span class="keywordtype">int</span> poly,face_adj,fa7,i,j,k,n_bord, num_face, rang ,itypcl, num10,num20,num_som;
<a name="l00429"></a>00429   <span class="keyword">const</span> <span class="keywordtype">int</span> ncomp_ch_transporte = transporte.<a class="code" href="classDoubleVect.html#ab02d01cd1bdab66fbd66f9a47cc29e10">line_size</a>();
<a name="l00430"></a>00430 
<a name="l00431"></a>00431   <a class="code" href="classIntVect.html">IntVect</a> face(nfac);
<a name="l00432"></a>00432   <a class="code" href="classDoubleVect.html">DoubleVect</a> vs(<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>);
<a name="l00433"></a>00433   <a class="code" href="classDoubleVect.html">DoubleVect</a> vc(<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>);
<a name="l00434"></a>00434   <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a> vsom(nsom,<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>);
<a name="l00435"></a>00435   <a class="code" href="classDoubleVect.html">DoubleVect</a> cc(<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>);
<a name="l00436"></a>00436   <a class="code" href="classIntVect.html">IntVect</a>&amp; tab1 = matrice.<a class="code" href="classMatrice__Morse.html#a7a49c763706dcfaed900f9d2cbb68716">get_set_tab1</a>();
<a name="l00437"></a>00437   <a class="code" href="classIntVect.html">IntVect</a>&amp; tab2 = matrice.<a class="code" href="classMatrice__Morse.html#af11c5853518e9e6db4c7e6e6acc8d7fd">get_set_tab2</a>();
<a name="l00438"></a>00438   <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; <a class="code" href="Champ__P1iP1B__implementation_8cpp.html#aa8c8f49390c3cf7c702d71a71bc977e3">coeff</a> = matrice.<a class="code" href="classMatrice__Morse.html#acd067e8514e5741f52b18a1d99746d11">get_set_coeff</a>();
<a name="l00439"></a>00439 
<a name="l00440"></a>00440 <span class="comment">// Traitement particulier pour les faces de periodicite</span>
<a name="l00441"></a>00441   <span class="keywordtype">int</span> voisine, nb_faces_perio = 0;
<a name="l00442"></a>00442   <span class="keywordtype">double</span> diff1,diff2;
<a name="l00443"></a>00443 
<a name="l00444"></a>00444 <span class="comment">// Boucle pour compter le nombre de faces de periodicite</span>
<a name="l00445"></a>00445   <span class="keywordflow">for</span> (n_bord=0; n_bord&lt;zone_VEF.<a class="code" href="classZone__dis__base.html#af22167d614644f55591a29c77eb1c009">nb_front_Cl</a>(); n_bord++)
<a name="l00446"></a>00446     {
<a name="l00447"></a>00447       <span class="keyword">const</span> <a class="code" href="classCond__lim.html" title="classe Cond_lim Classe generique servant a representer n&#39;importe quelle classe derivee de la classe C...">Cond_lim</a>&amp; la_cl = zone_Cl_VEF.<a class="code" href="classZone__Cl__dis__base.html#af75e0ed7786863e4d333bfb29d67c323" title="Renvoie la i-ieme condition aux limites. (version const)">les_conditions_limites</a>(n_bord);
<a name="l00448"></a>00448       <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>()))
<a name="l00449"></a>00449         {
<a name="l00450"></a>00450           <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp; le_bord = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>,la_cl.<a class="code" href="classCond__lim.html#a5b2d24809cee07727006a891d4ce8d22" title="Appel a l&#39;objet sous-jacent Renvoie la frontiere discretisee associee a la condition aux limites...">frontiere_dis</a>());
<a name="l00451"></a>00451           nb_faces_perio += le_bord.<a class="code" href="classFront__VF.html#a341e2fcb5117b96e745fd7078ba86bab" title="Nombre de faces reelles du bord.">nb_faces</a>();
<a name="l00452"></a>00452         }
<a name="l00453"></a>00453     }
<a name="l00454"></a>00454 
<a name="l00455"></a>00455   <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a> tab(nb_faces_perio,ncomp_ch_transporte);
<a name="l00456"></a>00456 
<a name="l00457"></a>00457 <span class="comment">// Boucle pour remplir tab</span>
<a name="l00458"></a>00458   nb_faces_perio=0;
<a name="l00459"></a>00459   <span class="keywordflow">for</span> (n_bord=0; n_bord&lt;zone_VEF.<a class="code" href="classZone__dis__base.html#af22167d614644f55591a29c77eb1c009">nb_front_Cl</a>(); n_bord++)
<a name="l00460"></a>00460     {
<a name="l00461"></a>00461       <span class="keyword">const</span> <a class="code" href="classCond__lim.html" title="classe Cond_lim Classe generique servant a representer n&#39;importe quelle classe derivee de la classe C...">Cond_lim</a>&amp; la_cl = zone_Cl_VEF.<a class="code" href="classZone__Cl__dis__base.html#af75e0ed7786863e4d333bfb29d67c323" title="Renvoie la i-ieme condition aux limites. (version const)">les_conditions_limites</a>(n_bord);
<a name="l00462"></a>00462       <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>()))
<a name="l00463"></a>00463         {
<a name="l00464"></a>00464           <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp; le_bord = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>,la_cl.<a class="code" href="classCond__lim.html#a5b2d24809cee07727006a891d4ce8d22" title="Appel a l&#39;objet sous-jacent Renvoie la frontiere discretisee associee a la condition aux limites...">frontiere_dis</a>());
<a name="l00465"></a>00465           <span class="keywordtype">int</span> num1 = le_bord.<a class="code" href="classFront__VF.html#a4986f0c65653fe9eb40bbbff5a97bf16" title="Numero de la premiere face du bord dans la liste des faces.">num_premiere_face</a>();
<a name="l00466"></a>00466           <span class="keywordtype">int</span> num2 = num1 + le_bord.<a class="code" href="classFront__VF.html#a341e2fcb5117b96e745fd7078ba86bab" title="Nombre de faces reelles du bord.">nb_faces</a>();
<a name="l00467"></a>00467           <span class="keywordflow">for</span> (num_face=num1; num_face&lt;num2; num_face++)
<a name="l00468"></a>00468             {
<a name="l00469"></a>00469               <span class="keywordflow">for</span> (<span class="keywordtype">int</span> comp=0; comp&lt;ncomp_ch_transporte; comp++)
<a name="l00470"></a>00470                 tab(nb_faces_perio,comp) = <a class="code" href="Champ__P1iP1B__implementation_8cpp.html#aa8c8f49390c3cf7c702d71a71bc977e3">coeff</a>(num_face*ncomp_ch_transporte+comp);
<a name="l00471"></a>00471               nb_faces_perio++;
<a name="l00472"></a>00472             }
<a name="l00473"></a>00473         }
<a name="l00474"></a>00474     }
<a name="l00475"></a>00475 
<a name="l00476"></a>00476 <span class="comment">// Les polyedres non standard sont ranges en 2 groupes dans la Zone_VEF:</span>
<a name="l00477"></a>00477 <span class="comment">// - polyedres bords et joints</span>
<a name="l00478"></a>00478 <span class="comment">// - polyedres bords et non joints</span>
<a name="l00479"></a>00479 <span class="comment">// On traite les polyedres en suivant l&#39;ordre dans lequel ils figurent</span>
<a name="l00480"></a>00480 <span class="comment">// dans la zone</span>
<a name="l00481"></a>00481 
<a name="l00482"></a>00482 <span class="comment">// boucle sur les polys</span>
<a name="l00483"></a>00483   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; KEL=zone_VEF.<a class="code" href="classZone__VEF.html#a46693c060b8096fb2595ca72192eea2a">type_elem</a>().<a class="code" href="classDeriv__Elem__VEF__base.html#a2886905d5071be902c77248b69ca0b7b">valeur</a>().<a class="code" href="classElem__VEF__base.html#ab129610ef702aa8c9c98dcb4c7551172">KEL</a>();
<a name="l00484"></a>00484   <span class="keywordflow">for</span> (poly=0; poly&lt;nb_elem_tot; poly++)
<a name="l00485"></a>00485     {
<a name="l00486"></a>00486 
<a name="l00487"></a>00487       rang = rang_elem_non_std(poly);
<a name="l00488"></a>00488       <span class="keywordflow">if</span> (rang==-1)
<a name="l00489"></a>00489         itypcl=0;
<a name="l00490"></a>00490       <span class="keywordflow">else</span>
<a name="l00491"></a>00491         itypcl=zone_Cl_VEF.<a class="code" href="classZone__Cl__VEF.html#a483bdab7690f844ed04e3defe04ec70a">type_elem_Cl</a>(rang);
<a name="l00492"></a>00492 
<a name="l00493"></a>00493 <span class="comment">// calcul des numeros des faces du polyedre</span>
<a name="l00494"></a>00494       <span class="keywordflow">for</span> (face_adj=0; face_adj&lt;nfac; face_adj++)
<a name="l00495"></a>00495         face[face_adj]= elem_faces(poly,face_adj);
<a name="l00496"></a>00496 
<a name="l00497"></a>00497 <span class="comment">// calcul de la vitesse aux sommets des polyedres</span>
<a name="l00498"></a>00498       <span class="keywordflow">for</span> (j=0; j&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; j++)
<a name="l00499"></a>00499         {
<a name="l00500"></a>00500           vs[j] = la_vitesse(face[0],j);
<a name="l00501"></a>00501           <span class="keywordflow">for</span> (i=1; i&lt;nfac; i++)
<a name="l00502"></a>00502             vs[j]+= la_vitesse(face[i],j);
<a name="l00503"></a>00503         }
<a name="l00504"></a>00504 
<a name="l00505"></a>00505 <span class="comment">// calcul de la vitesse aux sommets des polyedres</span>
<a name="l00506"></a>00506 <span class="comment">// On va utliser les fonctions de forme implementees dans la classe Champs_P1_impl ou Champs_Q1_impl</span>
<a name="l00507"></a>00507 
<a name="l00508"></a>00508       <span class="keywordtype">int</span> ncomp;
<a name="l00509"></a>00509       <span class="keywordflow">for</span> (j=0; j&lt;nsom; j++)
<a name="l00510"></a>00510         {
<a name="l00511"></a>00511           num_som = zone.<a class="code" href="classZone.html#aa164c00997bc77a365a6da57bbec29ce" title="Renvoie le numero (global) j-ieme sommet du i-ieme element.">sommet_elem</a>(poly,j);
<a name="l00512"></a>00512           <span class="keywordflow">for</span>(<span class="keywordtype">int</span> kk=0; kk&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>; kk++)
<a name="l00513"></a>00513             <span class="keywordflow">for</span> (ncomp=0; ncomp&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; ncomp++)
<a name="l00514"></a>00514               vsom(j,ncomp) = la_vitesse.<a class="code" href="classChamp__base.html#ad78f84c898b6fca623a30a9ae665c269" title="renvoi la compo eme corrdonne des valeurs a l&#39;element le_poly au sommet sommet">valeur_a_sommet_compo</a>(num_som,poly,ncomp);
<a name="l00515"></a>00515         }
<a name="l00516"></a>00516 
<a name="l00517"></a>00517 <span class="comment">// calcul de vc</span>
<a name="l00518"></a>00518       type_elem.<a class="code" href="classElem__VEF.html#ab0be052b1bfa6135cb9b8288086f098e">calcul_vc</a>(face,vc,vs,vsom,<a class="code" href="classOp__Conv__VEF__base.html#a4872ffd7c638ecc415191d92d7f5f507">vitesse</a>(),itypcl,porosite_face);
<a name="l00519"></a>00519 
<a name="l00520"></a>00520 <span class="comment">// Boucle sur les facettes du polyedre</span>
<a name="l00521"></a>00521 
<a name="l00522"></a>00522       <span class="keywordflow">for</span> (fa7=0; fa7&lt;nfa7; fa7++)
<a name="l00523"></a>00523         {
<a name="l00524"></a>00524           <span class="keywordflow">if</span> (rang==-1)
<a name="l00525"></a>00525             <span class="keywordflow">for</span> (i=0; i&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; i++)
<a name="l00526"></a>00526               cc[i] = facette_normales(poly,fa7,i);
<a name="l00527"></a>00527           <span class="keywordflow">else</span>
<a name="l00528"></a>00528             <span class="keywordflow">for</span> (i=0; i&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; i++)
<a name="l00529"></a>00529               cc[i] = normales_facettes_Cl(rang,fa7,i);
<a name="l00530"></a>00530 
<a name="l00531"></a>00531 <span class="comment">// On applique le schema de convection a chaque sommet de la facette</span>
<a name="l00532"></a>00532 <span class="comment">// On traite le ou les sommets qui sont aussi des sommets du polyedre</span>
<a name="l00533"></a>00533 
<a name="l00534"></a>00534           <span class="keywordflow">for</span> (i=0; i&lt;nb_som_facette-1; i++)
<a name="l00535"></a>00535             {
<a name="l00536"></a>00536               psc =0;
<a name="l00537"></a>00537 
<a name="l00538"></a>00538 <span class="comment">//</span>
<a name="l00539"></a>00539 <span class="comment">// Remplissage du tableau de coefficients correspondant a convbis</span>
<a name="l00540"></a>00540 <span class="comment">//</span>
<a name="l00541"></a>00541 
<a name="l00542"></a>00542               <span class="keywordflow">for</span> (j=0; j&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; j++)
<a name="l00543"></a>00543                 psc += vsom(KEL(i+2,fa7),j)*cc[j];
<a name="l00544"></a>00544               psc/= nb_som_facette;
<a name="l00545"></a>00545               num10 = face[KEL(0,fa7)];
<a name="l00546"></a>00546               num20 = face[KEL(1,fa7)];
<a name="l00547"></a>00547               <a class="code" href="Op__Conv__Amont__old__VEF__Face_8cpp.html#a85fe279a21bc306b225539a1527ad453">convbisimplicite</a>(psc,num10,num20,transporte,ncomp_ch_transporte,coeff,matrice);
<a name="l00548"></a>00548 
<a name="l00549"></a>00549             } <span class="comment">//!&lt; fin de boucle sur les sommets des facettes.</span>
<a name="l00550"></a>00550 <span class="comment"></span>
<a name="l00551"></a>00551 <span class="comment">// on traite le sommet confondu avec le centre de gravite du polyedre</span>
<a name="l00552"></a>00552           psc=0;
<a name="l00553"></a>00553           <span class="keywordflow">for</span> (j=0; j&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; j++)
<a name="l00554"></a>00554             psc += vc[j]*cc[j];
<a name="l00555"></a>00555           psc /= nb_som_facette;
<a name="l00556"></a>00556           num10 = face[KEL(0,fa7)];
<a name="l00557"></a>00557           num20 = face[KEL(1,fa7)];
<a name="l00558"></a>00558           <a class="code" href="Op__Conv__Amont__old__VEF__Face_8cpp.html#a85fe279a21bc306b225539a1527ad453">convbisimplicite</a>(psc,num10,num20,transporte,ncomp_ch_transporte,coeff,matrice);
<a name="l00559"></a>00559 
<a name="l00560"></a>00560         } <span class="comment">//!&lt; fin de boucle sur les facettes.</span>
<a name="l00561"></a>00561 <span class="comment"></span>
<a name="l00562"></a>00562     } <span class="comment">//!&lt; fin de boucle sur les polyedres.</span>
<a name="l00563"></a>00563 <span class="comment"></span>
<a name="l00564"></a>00564 <span class="comment">// Boucle sur les bords pour traiter les conditions aux limites</span>
<a name="l00565"></a>00565 <span class="comment">// il y a prise en compte d&#39;un terme de convection pour les</span>
<a name="l00566"></a>00566 <span class="comment">// conditions aux limites de Neumann_sortie_libre seulement</span>
<a name="l00567"></a>00567 
<a name="l00568"></a>00568   <span class="keywordflow">for</span> (n_bord=0; n_bord&lt;zone_VEF.<a class="code" href="classZone__dis__base.html#af22167d614644f55591a29c77eb1c009">nb_front_Cl</a>(); n_bord++)
<a name="l00569"></a>00569     {
<a name="l00570"></a>00570       <span class="keyword">const</span> <a class="code" href="classCond__lim.html" title="classe Cond_lim Classe generique servant a representer n&#39;importe quelle classe derivee de la classe C...">Cond_lim</a>&amp; la_cl = zone_Cl_VEF.<a class="code" href="classZone__Cl__dis__base.html#af75e0ed7786863e4d333bfb29d67c323" title="Renvoie la i-ieme condition aux limites. (version const)">les_conditions_limites</a>(n_bord);
<a name="l00571"></a>00571       <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classNeumann__sortie__libre.html" title="classe Neumann_sortie_libre Cette classe represente une frontiere ouverte sans vitesse imposee Pour l...">Neumann_sortie_libre</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>()))
<a name="l00572"></a>00572         {
<a name="l00573"></a>00573 <span class="comment">// const Neumann_sortie_libre&amp; la_sortie_libre = ref_cast(Neumann_sortie_libre, la_cl.valeur());</span>
<a name="l00574"></a>00574           <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp; le_bord = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>,la_cl.<a class="code" href="classCond__lim.html#a5b2d24809cee07727006a891d4ce8d22" title="Appel a l&#39;objet sous-jacent Renvoie la frontiere discretisee associee a la condition aux limites...">frontiere_dis</a>());
<a name="l00575"></a>00575           <span class="keywordtype">int</span> num1 = le_bord.<a class="code" href="classFront__VF.html#a4986f0c65653fe9eb40bbbff5a97bf16" title="Numero de la premiere face du bord dans la liste des faces.">num_premiere_face</a>();
<a name="l00576"></a>00576           <span class="keywordtype">int</span> num2 = num1 + le_bord.<a class="code" href="classFront__VF.html#a341e2fcb5117b96e745fd7078ba86bab" title="Nombre de faces reelles du bord.">nb_faces</a>();
<a name="l00577"></a>00577           <span class="keywordflow">for</span> (num_face=num1; num_face&lt;num2; num_face++)
<a name="l00578"></a>00578             {
<a name="l00579"></a>00579               psc =0;
<a name="l00580"></a>00580               <span class="keywordflow">for</span> (i=0; i&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; i++)
<a name="l00581"></a>00581                 psc += la_vitesse(num_face,i)*face_normales(num_face,i);
<a name="l00582"></a>00582               <span class="keywordflow">if</span> (psc&gt;0)
<a name="l00583"></a>00583                 {
<a name="l00584"></a>00584                   <span class="keywordflow">for</span> (j=0; j&lt;ncomp_ch_transporte; j++)
<a name="l00585"></a>00585                     {
<a name="l00586"></a>00586                       <span class="keywordflow">for</span> (k=tab1[num_face*ncomp_ch_transporte+j]-1; k&lt;tab1[num_face*ncomp_ch_transporte+j+1]-1; k++)
<a name="l00587"></a>00587                         {
<a name="l00588"></a>00588                           <span class="keywordflow">if</span> (tab2[k]-1==num_face*ncomp_ch_transporte+j)
<a name="l00589"></a>00589                             <a class="code" href="Champ__P1iP1B__implementation_8cpp.html#aa8c8f49390c3cf7c702d71a71bc977e3">coeff</a>(k) += psc;
<a name="l00590"></a>00590                         }
<a name="l00591"></a>00591                     }
<a name="l00592"></a>00592                 }
<a name="l00593"></a>00593               <span class="keywordflow">else</span> <span class="comment">/*psc &lt; 0 */</span>
<a name="l00594"></a>00594                 {
<a name="l00595"></a>00595                   <span class="keywordflow">for</span> (j=0; j&lt;ncomp_ch_transporte; j++)
<a name="l00596"></a>00596                     {
<a name="l00597"></a>00597                       <span class="keywordflow">for</span> (k=tab1[num_face*ncomp_ch_transporte+j]-1; k&lt;tab1[num_face*ncomp_ch_transporte+j+1]-1; k++)
<a name="l00598"></a>00598                         {
<a name="l00599"></a>00599                           <span class="keywordflow">if</span> (tab2[k]-1==num_face*ncomp_ch_transporte+j)
<a name="l00600"></a>00600                             <a class="code" href="Champ__P1iP1B__implementation_8cpp.html#aa8c8f49390c3cf7c702d71a71bc977e3">coeff</a>(k) += 0;
<a name="l00601"></a>00601                         }
<a name="l00602"></a>00602                     }
<a name="l00603"></a>00603                 }
<a name="l00604"></a>00604             }
<a name="l00605"></a>00605         }
<a name="l00606"></a>00606       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>()))
<a name="l00607"></a>00607         {
<a name="l00608"></a>00608           <span class="keyword">const</span> <a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>&amp; la_cl_perio = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>, la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>());
<a name="l00609"></a>00609           <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp; le_bord = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>,la_cl.<a class="code" href="classCond__lim.html#a5b2d24809cee07727006a891d4ce8d22" title="Appel a l&#39;objet sous-jacent Renvoie la frontiere discretisee associee a la condition aux limites...">frontiere_dis</a>());
<a name="l00610"></a>00610           <span class="keywordtype">int</span> num1 = le_bord.num_premiere_face();
<a name="l00611"></a>00611           <span class="keywordtype">int</span> num2 = num1 + le_bord.nb_faces();
<a name="l00612"></a>00612           <a class="code" href="classIntVect.html">IntVect</a> fait(le_bord.nb_faces());
<a name="l00613"></a>00613           fait = 0;
<a name="l00614"></a>00614           <span class="keywordflow">for</span> (num_face=num1; num_face&lt;num2; num_face++)
<a name="l00615"></a>00615             {
<a name="l00616"></a>00616               <span class="keywordflow">if</span> (fait[num_face-num1] == 0)
<a name="l00617"></a>00617                 {
<a name="l00618"></a>00618                   voisine = la_cl_perio.<a class="code" href="classPeriodique.html#a207b86556f199a63ea059b841851ca6a">face_associee</a>(num_face-num1) + num1;
<a name="l00619"></a>00619                   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> comp=0; comp&lt;ncomp_ch_transporte; comp++)
<a name="l00620"></a>00620                     {
<a name="l00621"></a>00621                       diff1 = -1*tab(nb_faces_perio,comp);
<a name="l00622"></a>00622                       diff2 = -1*tab(nb_faces_perio+voisine-num_face,comp);
<a name="l00623"></a>00623 
<a name="l00624"></a>00624                       <span class="keywordflow">for</span> (k=tab1[num_face*ncomp_ch_transporte+comp]-1; k&lt;tab1[num_face*ncomp_ch_transporte+1+comp]-1; k++)
<a name="l00625"></a>00625                         <span class="keywordflow">if</span> (tab2[k]-1==num_face*ncomp_ch_transporte+comp)
<a name="l00626"></a>00626                           <a class="code" href="Champ__P1iP1B__implementation_8cpp.html#aa8c8f49390c3cf7c702d71a71bc977e3">coeff</a>(k) += diff2;
<a name="l00627"></a>00627 
<a name="l00628"></a>00628                       <span class="keywordflow">for</span> (k=tab1[voisine*ncomp_ch_transporte+comp]-1; k&lt;tab1[voisine*ncomp_ch_transporte+1+comp]-1; k++)
<a name="l00629"></a>00629                         <span class="keywordflow">if</span> (tab2[k]-1==voisine*ncomp_ch_transporte+comp)
<a name="l00630"></a>00630                           <a class="code" href="Champ__P1iP1B__implementation_8cpp.html#aa8c8f49390c3cf7c702d71a71bc977e3">coeff</a>(k) += diff1;
<a name="l00631"></a>00631                     }
<a name="l00632"></a>00632 
<a name="l00633"></a>00633                   fait[num_face-num1]= 1;
<a name="l00634"></a>00634                   fait[voisine-num1] = 1;
<a name="l00635"></a>00635                 }
<a name="l00636"></a>00636               nb_faces_perio++;
<a name="l00637"></a>00637             }
<a name="l00638"></a>00638         }
<a name="l00639"></a>00639     }
<a name="l00640"></a>00640 }
<a name="l00641"></a>00641 
<a name="l00642"></a><a class="code" href="classOp__Conv__Amont__old__VEF__Face.html#a040a45c00b826bca608c3cdd88a99299">00642</a> <span class="keywordtype">void</span> <a class="code" href="classOp__Conv__Amont__old__VEF__Face.html#a040a45c00b826bca608c3cdd88a99299">Op_Conv_Amont_old_VEF_Face::contribue_au_second_membre</a>(<a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; resu )<span class="keyword"> const</span>
<a name="l00643"></a>00643 <span class="keyword"></span>{
<a name="l00644"></a>00644   <span class="keyword">const</span> <a class="code" href="classZone__Cl__VEF.html">Zone_Cl_VEF</a>&amp; zone_Cl_VEF = <a class="code" href="classOp__Conv__VEF__base.html#a03f677ee7911706a4f85cd37e0ca4535">la_zcl_vef</a>.<a class="code" href="classRef__Zone__Cl__VEF.html#a0970d7253def65ad4f0c5ce1830fd243">valeur</a>();
<a name="l00645"></a>00645   <span class="keyword">const</span> <a class="code" href="classZone__VEF.html" title="class Zone_VEF Classe instanciable qui derive de Zone_VF. Cette classe contient les informations geom...">Zone_VEF</a>&amp; zone_VEF = <a class="code" href="classOp__Conv__VEF__base.html#a6c29a488a6805ba4a9f2f059cdba77ae">la_zone_vef</a>.<a class="code" href="classRef__Zone__VEF.html#aafd9a5ee1a76f290c9c6b5447b0c8d30">valeur</a>();
<a name="l00646"></a>00646   <span class="keyword">const</span> <a class="code" href="classChamp__Inc__base.html" title="Classe Champ_Inc_base Classe de base des champs inconnues qui sont les champs calcules par une equati...">Champ_Inc_base</a>&amp; la_vitesse=<a class="code" href="classOp__Conv__VEF__base.html#a5547875832fb45e09b1115372fb76ffd">vitesse_</a>.<a class="code" href="classRef__Champ__Inc__base.html#a17553641a4c06730e1562125e07b3490">valeur</a>();
<a name="l00647"></a>00647   <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; face_normales = zone_VEF.<a class="code" href="classZone__VEF.html#a5742d75972e4846bf9fbb6ed5715053e">face_normales</a>();
<a name="l00648"></a>00648   <span class="keyword">const</span> <a class="code" href="classZone.html" title="classe Zone Une Zone est un maillage compose d&#39;un ensemble d&#39;elements geometriques de meme type...">Zone</a>&amp; zone = zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>();
<a name="l00649"></a>00649   <span class="keywordtype">int</span> nfac = zone.<a class="code" href="classZone.html#a548fbc7518be2f122b1a5c9589a443c2" title="Renvoie le nombre de face de type i des elements geometriques constituants la zone. Ex: les objets de la classe Prisme ont 2 types de faces: triangle ou quadrangle.">nb_faces_elem</a>();
<a name="l00650"></a>00650   <span class="keywordtype">double</span> psc;
<a name="l00651"></a>00651   <span class="keywordtype">int</span> i,n_bord, num_face;
<a name="l00652"></a>00652   <span class="keyword">const</span> <span class="keywordtype">int</span> ncomp = resu.<a class="code" href="classDoubleVect.html#ab02d01cd1bdab66fbd66f9a47cc29e10">line_size</a>();
<a name="l00653"></a>00653 
<a name="l00654"></a>00654   <a class="code" href="classIntVect.html">IntVect</a> face(nfac);
<a name="l00655"></a>00655 
<a name="l00656"></a>00656 <span class="comment">// Traitement particulier pour les faces de periodicite</span>
<a name="l00657"></a>00657   <span class="keywordtype">int</span> voisine, nb_faces_perio = 0;
<a name="l00658"></a>00658   <span class="keywordtype">double</span> diff1,diff2;
<a name="l00659"></a>00659 
<a name="l00660"></a>00660 <span class="comment">// Boucle pour compter le nombre de faces de periodicite</span>
<a name="l00661"></a>00661   <span class="keywordflow">for</span> (n_bord=0; n_bord&lt;zone_VEF.<a class="code" href="classZone__dis__base.html#af22167d614644f55591a29c77eb1c009">nb_front_Cl</a>(); n_bord++)
<a name="l00662"></a>00662     {
<a name="l00663"></a>00663       <span class="keyword">const</span> <a class="code" href="classCond__lim.html" title="classe Cond_lim Classe generique servant a representer n&#39;importe quelle classe derivee de la classe C...">Cond_lim</a>&amp; la_cl = zone_Cl_VEF.<a class="code" href="classZone__Cl__dis__base.html#af75e0ed7786863e4d333bfb29d67c323" title="Renvoie la i-ieme condition aux limites. (version const)">les_conditions_limites</a>(n_bord);
<a name="l00664"></a>00664       <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>()))
<a name="l00665"></a>00665         {
<a name="l00666"></a>00666           <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp; le_bord = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>,la_cl.<a class="code" href="classCond__lim.html#a5b2d24809cee07727006a891d4ce8d22" title="Appel a l&#39;objet sous-jacent Renvoie la frontiere discretisee associee a la condition aux limites...">frontiere_dis</a>());
<a name="l00667"></a>00667           nb_faces_perio += le_bord.<a class="code" href="classFront__VF.html#a341e2fcb5117b96e745fd7078ba86bab" title="Nombre de faces reelles du bord.">nb_faces</a>();
<a name="l00668"></a>00668         }
<a name="l00669"></a>00669     }
<a name="l00670"></a>00670 
<a name="l00671"></a>00671   <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a> tab(nb_faces_perio,ncomp);
<a name="l00672"></a>00672 <span class="comment">// Boucle pour remplir tab</span>
<a name="l00673"></a>00673   nb_faces_perio=0;
<a name="l00674"></a>00674   <span class="keywordflow">for</span> (n_bord=0; n_bord&lt;zone_VEF.<a class="code" href="classZone__dis__base.html#af22167d614644f55591a29c77eb1c009">nb_front_Cl</a>(); n_bord++)
<a name="l00675"></a>00675     {
<a name="l00676"></a>00676       <span class="keyword">const</span> <a class="code" href="classCond__lim.html" title="classe Cond_lim Classe generique servant a representer n&#39;importe quelle classe derivee de la classe C...">Cond_lim</a>&amp; la_cl = zone_Cl_VEF.<a class="code" href="classZone__Cl__dis__base.html#af75e0ed7786863e4d333bfb29d67c323" title="Renvoie la i-ieme condition aux limites. (version const)">les_conditions_limites</a>(n_bord);
<a name="l00677"></a>00677       <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>()))
<a name="l00678"></a>00678         {
<a name="l00679"></a>00679           <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp; le_bord = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>,la_cl.<a class="code" href="classCond__lim.html#a5b2d24809cee07727006a891d4ce8d22" title="Appel a l&#39;objet sous-jacent Renvoie la frontiere discretisee associee a la condition aux limites...">frontiere_dis</a>());
<a name="l00680"></a>00680           <span class="keywordtype">int</span> num1 = le_bord.<a class="code" href="classFront__VF.html#a4986f0c65653fe9eb40bbbff5a97bf16" title="Numero de la premiere face du bord dans la liste des faces.">num_premiere_face</a>();
<a name="l00681"></a>00681           <span class="keywordtype">int</span> num2 = num1 + le_bord.<a class="code" href="classFront__VF.html#a341e2fcb5117b96e745fd7078ba86bab" title="Nombre de faces reelles du bord.">nb_faces</a>();
<a name="l00682"></a>00682           <span class="keywordflow">for</span> (num_face=num1; num_face&lt;num2; num_face++)
<a name="l00683"></a>00683             {
<a name="l00684"></a>00684               <span class="keywordflow">for</span> (<span class="keywordtype">int</span> comp=0; comp&lt;ncomp; comp++)
<a name="l00685"></a>00685                 tab(nb_faces_perio,comp) = resu(num_face,comp);
<a name="l00686"></a>00686 
<a name="l00687"></a>00687               nb_faces_perio++;
<a name="l00688"></a>00688             }
<a name="l00689"></a>00689         }
<a name="l00690"></a>00690     }
<a name="l00691"></a>00691 <span class="comment">// Boucle sur les bords pour traiter les conditions aux limites</span>
<a name="l00692"></a>00692 <span class="comment">// il y a prise en compte d&#39;un terme de convection pour les</span>
<a name="l00693"></a>00693 <span class="comment">// conditions aux limites de Neumann_sortie_libre seulement</span>
<a name="l00694"></a>00694 
<a name="l00695"></a>00695   <span class="keywordflow">for</span> (n_bord=0; n_bord&lt;zone_VEF.<a class="code" href="classZone__dis__base.html#af22167d614644f55591a29c77eb1c009">nb_front_Cl</a>(); n_bord++)
<a name="l00696"></a>00696     {
<a name="l00697"></a>00697       <span class="keyword">const</span> <a class="code" href="classCond__lim.html" title="classe Cond_lim Classe generique servant a representer n&#39;importe quelle classe derivee de la classe C...">Cond_lim</a>&amp; la_cl = zone_Cl_VEF.<a class="code" href="classZone__Cl__dis__base.html#af75e0ed7786863e4d333bfb29d67c323" title="Renvoie la i-ieme condition aux limites. (version const)">les_conditions_limites</a>(n_bord);
<a name="l00698"></a>00698       <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classNeumann__sortie__libre.html" title="classe Neumann_sortie_libre Cette classe represente une frontiere ouverte sans vitesse imposee Pour l...">Neumann_sortie_libre</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>()))
<a name="l00699"></a>00699         {
<a name="l00700"></a>00700           <span class="keyword">const</span> <a class="code" href="classNeumann__sortie__libre.html" title="classe Neumann_sortie_libre Cette classe represente une frontiere ouverte sans vitesse imposee Pour l...">Neumann_sortie_libre</a>&amp; la_sortie_libre = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classNeumann__sortie__libre.html" title="classe Neumann_sortie_libre Cette classe represente une frontiere ouverte sans vitesse imposee Pour l...">Neumann_sortie_libre</a>, la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>());
<a name="l00701"></a>00701           <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp; le_bord = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>,la_cl.<a class="code" href="classCond__lim.html#a5b2d24809cee07727006a891d4ce8d22" title="Appel a l&#39;objet sous-jacent Renvoie la frontiere discretisee associee a la condition aux limites...">frontiere_dis</a>());
<a name="l00702"></a>00702           <span class="keywordtype">int</span> num1 = le_bord.num_premiere_face();
<a name="l00703"></a>00703           <span class="keywordtype">int</span> num2 = num1 + le_bord.nb_faces();
<a name="l00704"></a>00704           <span class="keywordflow">for</span> (num_face=num1; num_face&lt;num2; num_face++)
<a name="l00705"></a>00705             {
<a name="l00706"></a>00706               psc =0;
<a name="l00707"></a>00707               <span class="keywordflow">for</span> (i=0; i&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; i++)
<a name="l00708"></a>00708                 psc += la_vitesse(num_face,i)*face_normales(num_face,i);
<a name="l00709"></a>00709               <span class="keywordflow">if</span> (psc&gt;0)
<a name="l00710"></a>00710                 <span class="keywordflow">for</span> (i=0; i&lt;ncomp; i++)
<a name="l00711"></a>00711                   resu(num_face,i) += 0;
<a name="l00712"></a>00712               <span class="keywordflow">else</span>
<a name="l00713"></a>00713                 <span class="keywordflow">for</span> (i=0; i&lt;ncomp; i++)
<a name="l00714"></a>00714                   resu(num_face,i) -= psc*la_sortie_libre.<a class="code" href="classNeumann__sortie__libre.html#a886f1804fa2a9028fc56a0778a72a75d" title="Renvoie la valeur de la i-eme composante du champ impose a l&#39;exterieur de la frontiere.">val_ext</a>(num_face-num1,i);
<a name="l00715"></a>00715             }
<a name="l00716"></a>00716         }
<a name="l00717"></a>00717       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>()))
<a name="l00718"></a>00718         {
<a name="l00719"></a>00719           <span class="keyword">const</span> <a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>&amp; la_cl_perio = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>, la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>());
<a name="l00720"></a>00720           <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp; le_bord = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>,la_cl.<a class="code" href="classCond__lim.html#a5b2d24809cee07727006a891d4ce8d22" title="Appel a l&#39;objet sous-jacent Renvoie la frontiere discretisee associee a la condition aux limites...">frontiere_dis</a>());
<a name="l00721"></a>00721           <span class="keywordtype">int</span> num1 = le_bord.num_premiere_face();
<a name="l00722"></a>00722           <span class="keywordtype">int</span> num2 = num1 + le_bord.nb_faces();
<a name="l00723"></a>00723           <a class="code" href="classIntVect.html">IntVect</a> fait(le_bord.nb_faces());
<a name="l00724"></a>00724           fait = 0;
<a name="l00725"></a>00725           <span class="keywordflow">for</span> (num_face=num1; num_face&lt;num2; num_face++)
<a name="l00726"></a>00726             {
<a name="l00727"></a>00727               <span class="keywordflow">if</span> (fait[num_face-num1] == 0)
<a name="l00728"></a>00728                 {
<a name="l00729"></a>00729                   voisine = la_cl_perio.<a class="code" href="classPeriodique.html#a207b86556f199a63ea059b841851ca6a">face_associee</a>(num_face-num1) + num1;
<a name="l00730"></a>00730                   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> comp=0; comp&lt;ncomp; comp++)
<a name="l00731"></a>00731                     {
<a name="l00732"></a>00732                       diff1 = resu(num_face,comp)-tab(nb_faces_perio,comp);
<a name="l00733"></a>00733                       diff2 = resu(voisine,comp)-tab(nb_faces_perio+voisine-num_face,comp);
<a name="l00734"></a>00734                       resu(voisine,comp)  += diff1;
<a name="l00735"></a>00735                       resu(num_face,comp) += diff2;
<a name="l00736"></a>00736                     }
<a name="l00737"></a>00737 
<a name="l00738"></a>00738                   fait[num_face-num1]= 1;
<a name="l00739"></a>00739                   fait[voisine-num1] = 1;
<a name="l00740"></a>00740                 }
<a name="l00741"></a>00741               nb_faces_perio++;
<a name="l00742"></a>00742             }
<a name="l00743"></a>00743         }
<a name="l00744"></a>00744     }
<a name="l00745"></a>00745 }
<a name="l00746"></a>00746 
</pre></div></div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Tue Dec 14 2021 19:35:42 for TRUST by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
