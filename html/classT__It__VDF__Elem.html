<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>TRUST: T_It_VDF_Elem&lt; _TYPE_ &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">TRUST&#160;<span id="projectnumber">1.8.4</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pri-methods">Private Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">T_It_VDF_Elem&lt; _TYPE_ &gt; Class Template Reference</div>  </div>
</div>
<div class="contents">
<!-- doxytag: class="T_It_VDF_Elem" --><!-- doxytag: inherits="Iterateur_VDF_base" -->
<p><code>#include &lt;<a class="el" href="T__It__VDF__Elem_8h_source.html">T_It_VDF_Elem.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for T_It_VDF_Elem&lt; _TYPE_ &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classT__It__VDF__Elem.png" usemap="#T_It_VDF_Elem&lt; _TYPE_ &gt;_map" alt=""/>
  <map id="T_It_VDF_Elem&lt; _TYPE_ &gt;_map" name="T_It_VDF_Elem&lt; _TYPE_ &gt;_map">
<area href="classIterateur__VDF__base.html" alt="Iterateur_VDF_base" shape="rect" coords="0,112,169,136"/>
<area href="classObjet__U.html" title="classe Objet_U Cette classe est la classe de base des Objets de TRUST Dans les classes derivees de Ob..." alt="Objet_U" shape="rect" coords="0,56,169,80"/>
<area href="classProcess.html" title="Classe de base de TRUST (notamment Objet_U). Elle fournit quelques services de base accessibles de pa..." alt="Process" shape="rect" coords="0,0,169,24"/>
</map>
 </div></div>

<p><a href="classT__It__VDF__Elem-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classT__It__VDF__Elem.html#a0f6e7990b43d9aa236c8883058b327dc">T_It_VDF_Elem</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classT__It__VDF__Elem.html#a16a428a0049524394b77439a046b6347">T_It_VDF_Elem</a> (const <a class="el" href="classT__It__VDF__Elem.html">T_It_VDF_Elem</a>&lt; _TYPE_ &gt; &amp;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEvaluateur__VDF.html">Evaluateur_VDF</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classT__It__VDF__Elem.html#a4937ea2745a85911d44f0d8a0c0b0dcb">evaluateur</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEvaluateur__VDF.html">Evaluateur_VDF</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classT__It__VDF__Elem.html#a1bc39b8215edd7886446c930aeb9c2e7">evaluateur</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classT__It__VDF__Elem.html#aebb1435185a41a57d65bbc647c2cd864">calculer</a> (const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;, <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classT__It__VDF__Elem.html#ac8cf5ddb45fc2de559e28ef15e304a07">ajouter</a> (const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;, <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classT__It__VDF__Elem.html#a854af77a4cce0e2deeff69f4bce88c21">calculer_flux_bord</a> (const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classT__It__VDF__Elem.html#ae6c075c1c484a6fb44bc0451c79f6b29">contribuer_au_second_membre</a> (<a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classT__It__VDF__Elem.html#a81a6d79a10b9317cfa92b93dccd41b0f">ajouter_contribution</a> (const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;, <a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classT__It__VDF__Elem.html#ad4071d7d498524ba686fdf3a3fe2fd0d">ajouter_contribution_vitesse</a> (const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;, <a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classT__It__VDF__Elem.html#a1d0df1533727ebd0e9f455f466c82b01">completer_</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classT__It__VDF__Elem.html#a7eda6d967c50c9843d43e1cbe72a1afd">impr</a> (<a class="el" href="classSortie.html">Sortie</a> &amp;os) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classT__It__VDF__Elem.html#ab3efc8b1a81fa3eb613f850dc2498edf">modifier_flux</a> () const </td></tr>
<tr><td colspan="2"><h2><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classT__It__VDF__Elem.html#a5648f59099343727831e87ae671e3d8e">ajouter_bords</a> (const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;, <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classT__It__VDF__Elem.html#a8fc65edb5f401e6e9fac46666467b82d">ajouter_interne</a> (const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;, <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classT__It__VDF__Elem.html#a6d0871f9825679d4ce6382ba88d7d8e6">contribuer_au_second_membre_bords</a> (<a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classT__It__VDF__Elem.html#a67c535d1963fe3f0b19a9e42d515fb10">contribuer_au_second_membre_interne</a> (<a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classT__It__VDF__Elem.html#a5a4f3009b36687e4dd7fa1f33ab541ce">ajouter_contribution_bords</a> (const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;, <a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classT__It__VDF__Elem.html#a5ab524280db69182287cbe3f25666f9b">ajouter_contribution_interne</a> (const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;, <a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classT__It__VDF__Elem.html#a961776f7de2967cf58f1cc8e51ef0463">ajouter_contribution_interne_vitesse</a> (const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;, <a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classT__It__VDF__Elem.html#ae7a38e26b2d63f9d0df4561c73289011">ajouter_contribution_bords_vitesse</a> (const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;, <a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classT__It__VDF__Elem.html#a4e06ea2303d06f5d88619dfde55e280c">ajouter_contribution_autre_pb</a> (const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;inco, <a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;matrice, const <a class="el" href="classCond__lim.html">Cond_lim</a> &amp;la_cl, std::map&lt; int, std::pair&lt; int, int &gt;&gt; &amp;) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classMilieu__base.html">Milieu_base</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classT__It__VDF__Elem.html#add22ff724d5064affef48e034eb26cc6">milieu</a> () const </td></tr>
<tr><td colspan="2"><h2><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">_TYPE_&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classT__It__VDF__Elem.html#ae1fc0535bed05926b790dd398811b036">flux_evaluateur</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIntTab.html">IntTab</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classT__It__VDF__Elem.html#a1c6facf0ffcf4a16a8d81d090a7fc1e8">elem</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSFichier.html">SFichier</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classT__It__VDF__Elem.html#aa9e60b7897f03897d207b0e976dacb59">Flux</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSFichier.html">SFichier</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classT__It__VDF__Elem.html#a2bdd758add883f6ad6e9029cb1664a32">Flux_moment</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSFichier.html">SFichier</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classT__It__VDF__Elem.html#af07213914efa02ff865b0d3e01020be5">Flux_sum</a></td></tr>
<tr><td colspan="2"><h2><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classT__It__VDF__Elem.html#a99f48d16ca0cd64b2bbe6a1e92f299ee">duplique</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classT__It__VDF__Elem.html#a0b4d2acc1a454dd05c99abc596f3ca2c">taille_memoire</a> () const </td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><h3>template&lt;class _TYPE_&gt;<br/>
class T_It_VDF_Elem&lt; _TYPE_ &gt;</h3>


<p>Definition at line <a class="el" href="T__It__VDF__Elem_8h_source.html#l00049">49</a> of file <a class="el" href="T__It__VDF__Elem_8h_source.html">T_It_VDF_Elem.h</a>.</p>
</div><hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a0f6e7990b43d9aa236c8883058b327dc"></a><!-- doxytag: member="T_It_VDF_Elem::T_It_VDF_Elem" ref="a0f6e7990b43d9aa236c8883058b327dc" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class _TYPE_&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classT__It__VDF__Elem.html">T_It_VDF_Elem</a>&lt; _TYPE_ &gt;::<a class="el" href="classT__It__VDF__Elem.html">T_It_VDF_Elem</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="T__It__VDF__Elem_8h_source.html#l00067">67</a> of file <a class="el" href="T__It__VDF__Elem_8h_source.html">T_It_VDF_Elem.h</a>.</p>

<p>Referenced by <a class="el" href="T__It__VDF__Elem_8h_source.html#l00052">T_It_VDF_Elem&lt; _TYPE_ &gt;::duplique()</a>.</p>
<div class="fragment"><pre class="fragment">{ } ;
</pre></div>
</div>
</div>
<a class="anchor" id="a16a428a0049524394b77439a046b6347"></a><!-- doxytag: member="T_It_VDF_Elem::T_It_VDF_Elem" ref="a16a428a0049524394b77439a046b6347" args="(const T_It_VDF_Elem&lt; _TYPE_ &gt; &amp;)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class _TYPE_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classT__It__VDF__Elem.html">T_It_VDF_Elem</a>&lt; _TYPE_ &gt;::<a class="el" href="classT__It__VDF__Elem.html">T_It_VDF_Elem</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classT__It__VDF__Elem.html">T_It_VDF_Elem</a>&lt; _TYPE_ &gt; &amp;&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="T__It__VDF__Elem_8h_source.html#l00095">95</a> of file <a class="el" href="T__It__VDF__Elem_8h_source.html">T_It_VDF_Elem.h</a>.</p>

<p>References <a class="el" href="T__It__VDF__Elem_8h_source.html#l00092">T_It_VDF_Elem&lt; _TYPE_ &gt;::elem</a>, and <a class="el" href="IntTab_8cpp_source.html#l00229">IntTab::ref()</a>.</p>
<div class="fragment"><pre class="fragment">  :<a class="code" href="classIterateur__VDF__base.html#a3edd68cb9c22ab461da3add23216c503">Iterateur_VDF_base</a>(iter),
   <a class="code" href="classT__It__VDF__Elem.html#ae1fc0535bed05926b790dd398811b036">flux_evaluateur</a>(iter.<a class="code" href="classT__It__VDF__Elem.html#ae1fc0535bed05926b790dd398811b036">flux_evaluateur</a>)
{
  <a class="code" href="classT__It__VDF__Elem.html#a1c6facf0ffcf4a16a8d81d090a7fc1e8">elem</a>.<a class="code" href="classIntTab.html#ae9ae8fefb1fda4a5c035229ab420a96d" title="fait pointer le tableau sur le vecteur v et en associant la meme structure parallele. Attention, si line_size du vecteur v est different de 1, on cree un tableau bidimensionnel (on peut avoir un vecteur de ce type si on copie un Tab dans un Vect puis on prend une ref sur ce Vect).">ref</a>(iter.<a class="code" href="classT__It__VDF__Elem.html#a1c6facf0ffcf4a16a8d81d090a7fc1e8">elem</a>);
}
</pre></div>
</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="ac8cf5ddb45fc2de559e28ef15e304a07"></a><!-- doxytag: member="T_It_VDF_Elem::ajouter" ref="ac8cf5ddb45fc2de559e28ef15e304a07" args="(const DoubleTab &amp;, DoubleTab &amp;) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class _TYPE_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDoubleTab.html">DoubleTab</a> &amp; <a class="el" href="classT__It__VDF__Elem.html">T_It_VDF_Elem</a>&lt; _TYPE_ &gt;::ajouter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>donne</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>resu</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implements <a class="el" href="classIterateur__VDF__base.html#a23e92c2d0c98f736454e10c0ec14c9dc">Iterateur_VDF_base</a>.</p>

<p>Definition at line <a class="el" href="T__It__VDF__Elem_8h_source.html#l00130">130</a> of file <a class="el" href="T__It__VDF__Elem_8h_source.html">T_It_VDF_Elem.h</a>.</p>

<p>References <a class="el" href="ArrOfDouble_8h_source.html#l00379">ArrOfDouble::addr()</a>, <a class="el" href="DoubleVect_8h_source.html#l00164">DoubleVect::line_size()</a>, <a class="el" href="DoubleTab_8h_source.html#l00264">DoubleTab::nb_dim()</a>, <a class="el" href="DoubleTab_8cpp_source.html#l00335">DoubleTab::resize()</a>, <a class="el" href="DoubleVect_8h_source.html#l00153">DoubleVect::size()</a>, and <a class="el" href="ArrOfDouble_8h_source.html#l00350">ArrOfDouble::size_array()</a>.</p>
<div class="fragment"><pre class="fragment">{
  ((_TYPE_&amp;) <a class="code" href="classT__It__VDF__Elem.html#ae1fc0535bed05926b790dd398811b036">flux_evaluateur</a>).mettre_a_jour();
  assert(donne.<a class="code" href="classDoubleTab.html#ae6dda48778e7107e1beb723beef1f75b" title="Returns the number of dimensions of the array (&gt;= 1)">nb_dim</a>() &lt; 3);
  assert(<a class="code" href="classIterateur__VDF__base.html#a7434e3782850ec5f73ae8c6e9772f94c">la_zcl</a>.<a class="code" href="classO__U__Ptr.html#a16f216b2d169e885876419182658ddcc" title="Renvoie 1 si le pointeur est non_nul Renvoie 0 sinon.">non_nul</a>());
  assert(<a class="code" href="classIterateur__VDF__base.html#af3f849b64b981589db0fd68c83893246">la_zone</a>.<a class="code" href="classO__U__Ptr.html#a16f216b2d169e885876419182658ddcc" title="Renvoie 1 si le pointeur est non_nul Renvoie 0 sinon.">non_nul</a>());
  <span class="keyword">const</span> <span class="keywordtype">int</span> ncomp = donne.<a class="code" href="classDoubleVect.html#ab02d01cd1bdab66fbd66f9a47cc29e10">line_size</a>();
  <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; flux_bords=<a class="code" href="classIterateur__VDF__base.html#afb3094769ccf45ba34cbab5b80725636">op_base</a>-&gt;flux_bords();
  flux_bords.<a class="code" href="classDoubleTab.html#ae83b4d31205c53d9c8d2b43da178ce75" title="Change la taille du vecteur (identique a resize_array() pour le traitement des anciennes valeurs et d...">resize</a>(<a class="code" href="classIterateur__VDF__base.html#af3f849b64b981589db0fd68c83893246">la_zone</a>-&gt;nb_faces_bord(),ncomp);
  flux_bords=0;
  <span class="comment">/* modif b.m.: on va faire += sur des items virtuels, initialiser les cases */</span>
  <span class="comment">/* sinon risque que les cases soient invalides ou non initialisees */</span>
  {
    <span class="keywordtype">int</span> n = resu.<a class="code" href="classArrOfDouble.html#a3c3b33bea0e88b87315c21ee94bee05f" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() - resu.<a class="code" href="classDoubleVect.html#a392c1f20b462563365389d28e0853867" title="Identique a size_reelle()">size</a>();
    <span class="keywordtype">double</span> *data = resu.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() + resu.<a class="code" href="classDoubleVect.html#a392c1f20b462563365389d28e0853867" title="Identique a size_reelle()">size</a>();
    <span class="keywordflow">for</span> (; n; n--, data++)
      *data = 0.;
  }
  <a class="code" href="classT__It__VDF__Elem.html#a5648f59099343727831e87ae671e3d8e">ajouter_bords</a>(donne, resu) ;
  <a class="code" href="classT__It__VDF__Elem.html#a8fc65edb5f401e6e9fac46666467b82d">ajouter_interne</a>(donne, resu) ;
  <a class="code" href="classT__It__VDF__Elem.html#ab3efc8b1a81fa3eb613f850dc2498edf">modifier_flux</a>() ;
  <span class="keywordflow">return</span> resu;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a5648f59099343727831e87ae671e3d8e"></a><!-- doxytag: member="T_It_VDF_Elem::ajouter_bords" ref="a5648f59099343727831e87ae671e3d8e" args="(const DoubleTab &amp;, DoubleTab &amp;) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class _TYPE_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDoubleTab.html">DoubleTab</a> &amp; <a class="el" href="classT__It__VDF__Elem.html">T_It_VDF_Elem</a>&lt; _TYPE_ &gt;::ajouter_bords </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>donnee</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>resu</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>&lt; codage avec flux en <a class="el" href="classDoubleVect.html">DoubleVect</a> auquel on assigne la valeur de la fonction scalaire (pas de codage vectoriel de nscbc) </p>
</p>

<p>Definition at line <a class="el" href="T__It__VDF__Elem_8h_source.html#l00155">155</a> of file <a class="el" href="T__It__VDF__Elem_8h_source.html">T_It_VDF_Elem.h</a>.</p>

<p>References <a class="el" href="EntreeSortie_8h_source.html#l00032">Cerr</a>, <a class="el" href="Iterateur__PolyMAC__base_8h_source.html#l00062">echange_externe_impose</a>, <a class="el" href="Iterateur__PolyMAC__base_8h_source.html#l00063">echange_global_impose</a>, <a class="el" href="Iterateur__PolyMAC__base_8h_source.html#l00057">entree_fluide</a>, <a class="el" href="Double_8h_source.html#l00273">est_egal()</a>, <a class="el" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>, <a class="el" href="Cond__lim_8h_source.html#l00130">Cond_lim::frontiere_dis()</a>, <a class="el" href="Frontiere__dis__base_8cpp_source.html#l00146">Frontiere_dis_base::le_nom()</a>, <a class="el" href="DoubleVect_8h_source.html#l00164">DoubleVect::line_size()</a>, <a class="el" href="Front__VF_8h_source.html#l00061">Front_VF::nb_faces()</a>, <a class="el" href="Iterateur__PolyMAC__base_8h_source.html#l00065">nscbc</a>, <a class="el" href="Front__VF_8h_source.html#l00071">Front_VF::num_premiere_face()</a>, <a class="el" href="Iterateur__PolyMAC__base_8h_source.html#l00061">paroi</a>, <a class="el" href="Iterateur__PolyMAC__base_8h_source.html#l00059">paroi_defilante</a>, <a class="el" href="Iterateur__PolyMAC__base_8h_source.html#l00058">paroi_fixe</a>, <a class="el" href="Iterateur__PolyMAC__base_8h_source.html#l00064">periodique</a>, <a class="el" href="Cast_8h_source.html#l00059">ref_cast</a>, <a class="el" href="Iterateur__PolyMAC__base_8h_source.html#l00056">sortie_libre</a>, <a class="el" href="Cast_8h_source.html#l00054">sub_type</a>, <a class="el" href="Iterateur__PolyMAC__base_8h_source.html#l00055">symetrie</a>, and <a class="el" href="Cond__lim_8h_source.html#l00031">Deriv_Cond_lim_base::valeur()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">const</span> <span class="keywordtype">int</span> ncomp = resu.<a class="code" href="classDoubleVect.html#ab02d01cd1bdab66fbd66f9a47cc29e10">line_size</a>();
  <span class="keywordtype">int</span> elem1, elem2;
  <span class="keywordtype">int</span> ndeb, nfin;
  <span class="keywordtype">int</span> face,k;
  <a class="code" href="classDoubleVect.html">DoubleVect</a> flux(ncomp);
  <span class="keywordtype">int</span> num_cl=0;
  <span class="keywordtype">int</span> nb_front_Cl=<a class="code" href="classIterateur__VDF__base.html#af3f849b64b981589db0fd68c83893246">la_zone</a>-&gt;nb_front_Cl();
  <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; flux_bords=<a class="code" href="classIterateur__VDF__base.html#afb3094769ccf45ba34cbab5b80725636">op_base</a>-&gt;flux_bords();
  <span class="keywordflow">for</span> (; num_cl&lt;nb_front_Cl; num_cl++)
    {
      <span class="keyword">const</span> <a class="code" href="classCond__lim.html" title="classe Cond_lim Classe generique servant a representer n&#39;importe quelle classe derivee de la classe C...">Cond_lim</a>&amp; la_cl = <a class="code" href="classIterateur__VDF__base.html#a7434e3782850ec5f73ae8c6e9772f94c">la_zcl</a>-&gt;les_conditions_limites(num_cl);
      <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp; frontiere_dis = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>,la_cl.<a class="code" href="classCond__lim.html#a5b2d24809cee07727006a891d4ce8d22" title="Appel a l&#39;objet sous-jacent Renvoie la frontiere discretisee associee a la condition aux limites...">frontiere_dis</a>());
      ndeb = frontiere_dis.<a class="code" href="classFront__VF.html#a4986f0c65653fe9eb40bbbff5a97bf16" title="Numero de la premiere face du bord dans la liste des faces.">num_premiere_face</a>();
      nfin = ndeb + frontiere_dis.<a class="code" href="classFront__VF.html#a341e2fcb5117b96e745fd7078ba86bab" title="Nombre de faces reelles du bord.">nb_faces</a>();
      <span class="comment">/* Test en bidim axi */</span>
      <span class="keywordflow">if</span> (<a class="code" href="classObjet__U.html#a9a47c1add9760324894500792c17a178">bidim_axi</a> &amp;&amp; !<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classSymetrie.html" title="classe Symetrie Sur les faces de symetrie on a les proprietes suivantes: - composante normale de la v...">Symetrie</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>()))
        {
          <span class="keywordflow">if</span> (nfin&gt;ndeb &amp;&amp; <a class="code" href="Double_8h.html#ac86f5f350b0f95fd8c34b0ac8d720f6f">est_egal</a>(<a class="code" href="classIterateur__VDF__base.html#af3f849b64b981589db0fd68c83893246">la_zone</a>.<a class="code" href="classRef__Zone__VDF.html#a84151da4db745d02791d6246e3682b67">valeur</a>().<a class="code" href="classZone__VF.html#a40c3382b189a4fc508cf1c3e37b04b21">face_surfaces</a>()[ndeb],0))
            {
              <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Error in the definition of the boundary conditions.&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
              <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;The axis of revolution for this 2D calculation is along Y.&quot;</span> &lt;&lt; finl;
              <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;So you must specify symmetry boundary condition (symetrie keyword) for the boundary &quot;</span> &lt;&lt; frontiere_dis.<a class="code" href="classFrontiere__dis__base.html#a5a7eb46dc3af8a7d4225adc1814845d8" title="Renvoie le nom de la frontiere geometrique.">le_nom</a>() &lt;&lt; finl;
              <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">exit</a>();
            }
        }
      <span class="keywordflow">switch</span>(<a class="code" href="classIterateur__VDF__base.html#ae7e13026a533fe31c54526a7ba7bbaaf">type_cl</a>(la_cl))
        {
        <span class="keywordflow">case</span> <a class="code" href="Iterateur__PolyMAC__base_8h.html#adda1d69a86f9e3be7366c5f4c6ace649ac938491055e13993f3eed68c989f90b0" title="Symetrie.">symetrie</a> :
          <span class="keywordflow">if</span> (<a class="code" href="classT__It__VDF__Elem.html#ae1fc0535bed05926b790dd398811b036">flux_evaluateur</a>.calculer_flux_faces_symetrie())
            {
              <span class="keyword">const</span> <a class="code" href="classSymetrie.html" title="classe Symetrie Sur les faces de symetrie on a les proprietes suivantes: - composante normale de la v...">Symetrie</a>&amp; cl =(<span class="keyword">const</span> <a class="code" href="classSymetrie.html" title="classe Symetrie Sur les faces de symetrie on a les proprietes suivantes: - composante normale de la v...">Symetrie</a>&amp;) (la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>());
              <span class="keywordflow">for</span> (face=ndeb; face&lt;nfin; face++)
                {
                  <a class="code" href="classT__It__VDF__Elem.html#ae1fc0535bed05926b790dd398811b036">flux_evaluateur</a>.flux_face(donnee, face, cl, ndeb, flux);
                  <span class="keywordflow">if</span> ( (elem1=<a class="code" href="classT__It__VDF__Elem.html#a1c6facf0ffcf4a16a8d81d090a7fc1e8">elem</a>(face,0)) &gt; -1)
                    <span class="keywordflow">for</span> (k=0; k&lt;ncomp; k++)
                      {
                        resu(elem1,k) +=flux(k);
                        flux_bords(face,k)+=flux(k);
                      }
                  <span class="keywordflow">if</span> ( (elem2=<a class="code" href="classT__It__VDF__Elem.html#a1c6facf0ffcf4a16a8d81d090a7fc1e8">elem</a>(face,1)) &gt; -1)
                    <span class="keywordflow">for</span> (k=0; k&lt;ncomp; k++)
                      {
                        resu(elem2,k) -=flux(k);
                        flux_bords(face,k)-=flux(k);
                      }
                }
            }
          <span class="keywordflow">break</span>;
        <span class="keywordflow">case</span> <a class="code" href="Iterateur__PolyMAC__base_8h.html#adda1d69a86f9e3be7366c5f4c6ace649ac4317ef27513bbab3cd0ccfd0d9ed199" title="Neumann_sortie_libre ou derivees.">sortie_libre</a> :
          <span class="keywordflow">if</span> (<a class="code" href="classT__It__VDF__Elem.html#ae1fc0535bed05926b790dd398811b036">flux_evaluateur</a>.calculer_flux_faces_sortie_libre())
            {
              <span class="keyword">const</span> <a class="code" href="classNeumann__sortie__libre.html" title="classe Neumann_sortie_libre Cette classe represente une frontiere ouverte sans vitesse imposee Pour l...">Neumann_sortie_libre</a>&amp; cl =(<span class="keyword">const</span> <a class="code" href="classNeumann__sortie__libre.html" title="classe Neumann_sortie_libre Cette classe represente une frontiere ouverte sans vitesse imposee Pour l...">Neumann_sortie_libre</a>&amp;) (la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>());
              <span class="keywordflow">for</span> (face=ndeb; face&lt;nfin; face++)
                {
                  <a class="code" href="classT__It__VDF__Elem.html#ae1fc0535bed05926b790dd398811b036">flux_evaluateur</a>.flux_face(donnee, face, cl, ndeb, flux);
                  <span class="keywordflow">if</span> ( (elem1=<a class="code" href="classT__It__VDF__Elem.html#a1c6facf0ffcf4a16a8d81d090a7fc1e8">elem</a>(face,0)) &gt; -1)
                    <span class="keywordflow">for</span> (k=0; k&lt;ncomp; k++)
                      {
                        resu(elem1,k) +=flux(k);
                        flux_bords(face,k)+=flux(k);
                      }
                  <span class="keywordflow">if</span> ( (elem2=<a class="code" href="classT__It__VDF__Elem.html#a1c6facf0ffcf4a16a8d81d090a7fc1e8">elem</a>(face,1)) &gt; -1)
                    <span class="keywordflow">for</span> (k=0; k&lt;ncomp; k++)
                      {
                        resu(elem2,k) -=flux(k);
                        flux_bords(face,k)-=flux(k);
                      }
                }
            }
          <span class="keywordflow">break</span>;
        <span class="keywordflow">case</span> <a class="code" href="Iterateur__PolyMAC__base_8h.html#adda1d69a86f9e3be7366c5f4c6ace649a594fd60a4576f47654eed7df53dee9be" title="Dirichlet_entree_fluide.">entree_fluide</a> :
          <span class="keywordflow">if</span> (<a class="code" href="classT__It__VDF__Elem.html#ae1fc0535bed05926b790dd398811b036">flux_evaluateur</a>.calculer_flux_faces_entree_fluide())
            {
              <span class="keyword">const</span> <a class="code" href="classDirichlet__entree__fluide.html" title="classe Dirichlet_entree_fluide Cette classe represente une condition aux limite imposant une grandeur...">Dirichlet_entree_fluide</a>&amp; cl =(<span class="keyword">const</span> <a class="code" href="classDirichlet__entree__fluide.html" title="classe Dirichlet_entree_fluide Cette classe represente une condition aux limite imposant une grandeur...">Dirichlet_entree_fluide</a>&amp;) (la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>());
              <span class="keywordflow">for</span> (face=ndeb; face&lt;nfin; face++)
                {
                  <a class="code" href="classT__It__VDF__Elem.html#ae1fc0535bed05926b790dd398811b036">flux_evaluateur</a>.flux_face(donnee, face, cl, ndeb, flux);
                  <span class="keywordflow">if</span> ( (elem1=<a class="code" href="classT__It__VDF__Elem.html#a1c6facf0ffcf4a16a8d81d090a7fc1e8">elem</a>(face,0)) &gt; -1)
                    <span class="keywordflow">for</span> (k=0; k&lt;ncomp; k++)
                      {
                        resu(elem1,k) +=flux(k);
                        flux_bords(face,k)+=flux(k);
                      }
                  <span class="keywordflow">if</span> ( (elem2=<a class="code" href="classT__It__VDF__Elem.html#a1c6facf0ffcf4a16a8d81d090a7fc1e8">elem</a>(face,1)) &gt; -1)
                    <span class="keywordflow">for</span> (k=0; k&lt;ncomp; k++)
                      {
                        resu(elem2,k) -=flux(k);
                        flux_bords(face,k)-=flux(k);
                      }
                }
            }
          <span class="keywordflow">break</span>;
        <span class="keywordflow">case</span> <a class="code" href="Iterateur__PolyMAC__base_8h.html#adda1d69a86f9e3be7366c5f4c6ace649a497d92e00f36c1c7ec874c0a318db91e" title="Dirichlet_paroi_fixe.">paroi_fixe</a> :
          <span class="keywordflow">if</span> (<a class="code" href="classT__It__VDF__Elem.html#ae1fc0535bed05926b790dd398811b036">flux_evaluateur</a>.calculer_flux_faces_paroi_fixe())
            {
              <span class="keyword">const</span> <a class="code" href="classDirichlet__paroi__fixe.html" title="classe Dirichlet_paroi_fixe Represente une paroi immobile dans une equation de type Navier_Stokes...">Dirichlet_paroi_fixe</a>&amp; cl =(<span class="keyword">const</span> <a class="code" href="classDirichlet__paroi__fixe.html" title="classe Dirichlet_paroi_fixe Represente une paroi immobile dans une equation de type Navier_Stokes...">Dirichlet_paroi_fixe</a>&amp;) (la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>());
              <span class="keywordflow">for</span> (face=ndeb; face&lt;nfin; face++)
                {
                  <a class="code" href="classT__It__VDF__Elem.html#ae1fc0535bed05926b790dd398811b036">flux_evaluateur</a>.flux_face(donnee, face, cl, ndeb, flux);
                  <span class="keywordflow">if</span> ( (elem1=<a class="code" href="classT__It__VDF__Elem.html#a1c6facf0ffcf4a16a8d81d090a7fc1e8">elem</a>(face,0)) &gt; -1)
                    <span class="keywordflow">for</span> (k=0; k&lt;ncomp; k++)
                      {
                        resu(elem1,k) +=flux(k);
                        flux_bords(face,k)+=flux(k);
                      }
                  <span class="keywordflow">if</span> ( (elem2=<a class="code" href="classT__It__VDF__Elem.html#a1c6facf0ffcf4a16a8d81d090a7fc1e8">elem</a>(face,1)) &gt; -1)
                    <span class="keywordflow">for</span> (k=0; k&lt;ncomp; k++)
                      {
                        resu(elem2,k) -=flux(k);
                        flux_bords(face,k)-=flux(k);
                      }
                }
            }
          <span class="keywordflow">break</span>;
        <span class="keywordflow">case</span> <a class="code" href="Iterateur__PolyMAC__base_8h.html#adda1d69a86f9e3be7366c5f4c6ace649acdd1bf461cb105b93d5a9b003ce33141" title="Dirichlet_paroi_defilante.">paroi_defilante</a> :
          <span class="keywordflow">if</span> (<a class="code" href="classT__It__VDF__Elem.html#ae1fc0535bed05926b790dd398811b036">flux_evaluateur</a>.calculer_flux_faces_paroi_defilante())
            {
              <span class="keyword">const</span> <a class="code" href="classDirichlet__paroi__defilante.html" title="classe Dirichlet_paroi_defilante Impose la vitesse de paroi dnas une equation de type Navier_Stokes...">Dirichlet_paroi_defilante</a>&amp; cl =(<span class="keyword">const</span> <a class="code" href="classDirichlet__paroi__defilante.html" title="classe Dirichlet_paroi_defilante Impose la vitesse de paroi dnas une equation de type Navier_Stokes...">Dirichlet_paroi_defilante</a>&amp;) (la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>());
              <span class="keywordflow">for</span> (face=ndeb; face&lt;nfin; face++)
                {
                  <a class="code" href="classT__It__VDF__Elem.html#ae1fc0535bed05926b790dd398811b036">flux_evaluateur</a>.flux_face(donnee, face, cl, ndeb, flux);
                  <span class="keywordflow">if</span> ( (elem1=<a class="code" href="classT__It__VDF__Elem.html#a1c6facf0ffcf4a16a8d81d090a7fc1e8">elem</a>(face,0)) &gt; -1)
                    <span class="keywordflow">for</span> (k=0; k&lt;ncomp; k++)
                      {
                        resu(elem1,k) +=flux(k);
                        flux_bords(face,k)+=flux(k);
                      }
                  <span class="keywordflow">if</span> ( (elem2=<a class="code" href="classT__It__VDF__Elem.html#a1c6facf0ffcf4a16a8d81d090a7fc1e8">elem</a>(face,1)) &gt; -1)
                    <span class="keywordflow">for</span> (k=0; k&lt;ncomp; k++)
                      {
                        resu(elem2,k) -=flux(k);
                        flux_bords(face,k)-=flux(k);
                      }
                }
            }
          <span class="keywordflow">break</span>;
        <span class="keywordflow">case</span> <a class="code" href="classparoi__adiabatique.html">paroi_adiabatique</a> :
          <span class="keywordflow">if</span> (<a class="code" href="classT__It__VDF__Elem.html#ae1fc0535bed05926b790dd398811b036">flux_evaluateur</a>.calculer_flux_faces_paroi_adiabatique())
            {
              <span class="keyword">const</span> <a class="code" href="classNeumann__paroi__adiabatique.html" title="Classe Neumann_paroi_adiabatique Cette condition limite correspond a une paroi adiabatique dans une e...">Neumann_paroi_adiabatique</a>&amp; cl =(<span class="keyword">const</span> <a class="code" href="classNeumann__paroi__adiabatique.html" title="Classe Neumann_paroi_adiabatique Cette condition limite correspond a une paroi adiabatique dans une e...">Neumann_paroi_adiabatique</a>&amp;) (la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>());
              <span class="keywordflow">for</span> (face=ndeb; face&lt;nfin; face++)
                {
                  <span class="comment">/* on initialise elem1 elem2 et on fait planter */</span>
                  elem1=-1;
                  elem2=-1;
                  assert(0);
                  <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">exit</a>();
                  <a class="code" href="classT__It__VDF__Elem.html#ae1fc0535bed05926b790dd398811b036">flux_evaluateur</a>.flux_face(donnee, face, cl, ndeb, flux);
                  <span class="keywordflow">if</span> ( (elem1=<a class="code" href="classT__It__VDF__Elem.html#a1c6facf0ffcf4a16a8d81d090a7fc1e8">elem</a>(face,0)) &gt; -1)
                    <span class="keywordflow">for</span> (k=0; k&lt;ncomp; k++)
                      {
                        resu(elem1,k) +=flux(k);
                        flux_bords(face,k)+=flux(k);
                      }
                  <span class="keywordflow">if</span> ( (elem2=<a class="code" href="classT__It__VDF__Elem.html#a1c6facf0ffcf4a16a8d81d090a7fc1e8">elem</a>(face,1)) &gt; -1)
                    <span class="keywordflow">for</span> (k=0; k&lt;ncomp; k++)
                      {
                        resu(elem2,k) -=flux(k);
                        flux_bords(face,k)-=flux(k);
                      }
                }
            }
          <span class="keywordflow">break</span>;
        <span class="keywordflow">case</span> <a class="code" href="Iterateur__PolyMAC__base_8h.html#adda1d69a86f9e3be7366c5f4c6ace649af695f3ba17490e07dc3259c85875d8d6" title="Neumann_paroi.">paroi</a> :
          <span class="keywordflow">if</span> (<a class="code" href="classT__It__VDF__Elem.html#ae1fc0535bed05926b790dd398811b036">flux_evaluateur</a>.calculer_flux_faces_paroi())
            {
              <span class="keyword">const</span> <a class="code" href="classNeumann__paroi.html" title="Classe Neumann_paroi Cette condition limite correspond a un flux impose pour l&#39;equation de transport ...">Neumann_paroi</a>&amp; cl =(<span class="keyword">const</span> <a class="code" href="classNeumann__paroi.html" title="Classe Neumann_paroi Cette condition limite correspond a un flux impose pour l&#39;equation de transport ...">Neumann_paroi</a>&amp;) (la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>());
              <span class="keywordflow">for</span> (face=ndeb; face&lt;nfin; face++)
                {
                  <a class="code" href="classT__It__VDF__Elem.html#ae1fc0535bed05926b790dd398811b036">flux_evaluateur</a>.flux_face(donnee, face, cl, ndeb, flux);
                  <span class="keywordflow">if</span> ( (elem1=<a class="code" href="classT__It__VDF__Elem.html#a1c6facf0ffcf4a16a8d81d090a7fc1e8">elem</a>(face,0)) &gt; -1)
                    <span class="keywordflow">for</span> (k=0; k&lt;ncomp; k++)
                      {
                        resu(elem1, k)+=flux(k);
                        flux_bords(face, k)+=flux(k);
                      }
                  <span class="keywordflow">if</span> ( (elem2=<a class="code" href="classT__It__VDF__Elem.html#a1c6facf0ffcf4a16a8d81d090a7fc1e8">elem</a>(face,1)) &gt; -1)
                    <span class="keywordflow">for</span> (k=0; k&lt;ncomp; k++)
                      {
                        resu(elem2, k)-=flux(k);
                        flux_bords(face,k)-=flux(k);
                      }
                }
            }
          <span class="keywordflow">break</span>;
        <span class="keywordflow">case</span> <a class="code" href="Iterateur__PolyMAC__base_8h.html#adda1d69a86f9e3be7366c5f4c6ace649a38f997f881a13a46f2d06012162cf833" title="Echange_externe_impose.">echange_externe_impose</a> :
          <span class="keywordflow">if</span> (<a class="code" href="classT__It__VDF__Elem.html#ae1fc0535bed05926b790dd398811b036">flux_evaluateur</a>.calculer_flux_faces_echange_externe_impose())
            {
              <span class="keyword">const</span> <a class="code" href="classEchange__externe__impose.html" title="Classe Echange_externe_impose: Cette classe represente le cas particulier de la classe Echange_impose...">Echange_externe_impose</a>&amp; cl =(<span class="keyword">const</span> <a class="code" href="classEchange__externe__impose.html" title="Classe Echange_externe_impose: Cette classe represente le cas particulier de la classe Echange_impose...">Echange_externe_impose</a>&amp;) (la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>());

              <span class="keywordtype">int</span> boundary_index=-1;
              <span class="keywordflow">if</span> (<a class="code" href="classIterateur__VDF__base.html#af3f849b64b981589db0fd68c83893246">la_zone</a>.<a class="code" href="classRef__Zone__VDF.html#a84151da4db745d02791d6246e3682b67">valeur</a>().<a class="code" href="classZone__VF.html#a45e54622328fcf035535edf96172c1e4" title="renvoie la ieme frontiere_discrete.">front_VF</a>(num_cl).<a class="code" href="classFrontiere__dis__base.html#a5a7eb46dc3af8a7d4225adc1814845d8" title="Renvoie le nom de la frontiere geometrique.">le_nom</a>() == frontiere_dis.<a class="code" href="classFrontiere__dis__base.html#a5a7eb46dc3af8a7d4225adc1814845d8" title="Renvoie le nom de la frontiere geometrique.">le_nom</a>())
                boundary_index=num_cl;

              <span class="keywordflow">for</span> (face=ndeb; face&lt;nfin; face++)
                {
                  <span class="keywordtype">int</span> local_face=<a class="code" href="classIterateur__VDF__base.html#af3f849b64b981589db0fd68c83893246">la_zone</a>.<a class="code" href="classRef__Zone__VDF.html#a84151da4db745d02791d6246e3682b67">valeur</a>().<a class="code" href="classZone__VF.html#a45e54622328fcf035535edf96172c1e4" title="renvoie la ieme frontiere_discrete.">front_VF</a>(boundary_index).<a class="code" href="classFront__VF.html#a8b34de011799509c228146cea1abaaab">num_local_face</a>(face);
                  <a class="code" href="classT__It__VDF__Elem.html#ae1fc0535bed05926b790dd398811b036">flux_evaluateur</a>.flux_face(donnee, boundary_index, face, local_face, cl, ndeb, flux);
                  <span class="keywordflow">if</span> ( (elem1=<a class="code" href="classT__It__VDF__Elem.html#a1c6facf0ffcf4a16a8d81d090a7fc1e8">elem</a>(face,0)) &gt; -1)
                    <span class="keywordflow">for</span> (k=0; k&lt;ncomp; k++)
                      {
                        resu(elem1,k) +=flux(k);
                        flux_bords(face,k)+=flux(k);
                      }
                  <span class="keywordflow">if</span> ( (elem2=<a class="code" href="classT__It__VDF__Elem.html#a1c6facf0ffcf4a16a8d81d090a7fc1e8">elem</a>(face,1)) &gt; -1)
                    <span class="keywordflow">for</span> (k=0; k&lt;ncomp; k++)
                      {
                        resu(elem2,k) -=flux(k);
                        flux_bords(face,k)-=flux(k);
                      }
                }
            }
          <span class="keywordflow">break</span>;
        <span class="keywordflow">case</span> <a class="code" href="Iterateur__PolyMAC__base_8h.html#adda1d69a86f9e3be7366c5f4c6ace649a9201b83c6fe44d3928abbe5f73364323" title="Echange_global_impose.">echange_global_impose</a> :
          <span class="keywordflow">if</span> (<a class="code" href="classT__It__VDF__Elem.html#ae1fc0535bed05926b790dd398811b036">flux_evaluateur</a>.calculer_flux_faces_echange_global_impose())
            {
              <span class="keyword">const</span> <a class="code" href="classEchange__global__impose.html" title="Classe Echange_global_impose Cette classe represente le cas particulier de la classe Echange_impose_b...">Echange_global_impose</a>&amp; cl =(<span class="keyword">const</span> <a class="code" href="classEchange__global__impose.html" title="Classe Echange_global_impose Cette classe represente le cas particulier de la classe Echange_impose_b...">Echange_global_impose</a>&amp;) (la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>());
              <span class="keywordflow">for</span> (face=ndeb; face&lt;nfin; face++)
                {
                  <a class="code" href="classT__It__VDF__Elem.html#ae1fc0535bed05926b790dd398811b036">flux_evaluateur</a>.flux_face(donnee, face, cl, ndeb, flux);
                  <span class="keywordflow">if</span> ( (elem1=<a class="code" href="classT__It__VDF__Elem.html#a1c6facf0ffcf4a16a8d81d090a7fc1e8">elem</a>(face,0)) &gt; -1)
                    <span class="keywordflow">for</span> (k=0; k&lt;ncomp; k++)
                      {
                        resu(elem1,k) +=flux(k);
                        flux_bords(face,k)+=flux(k);
                      }
                  <span class="keywordflow">if</span> ( (elem2=<a class="code" href="classT__It__VDF__Elem.html#a1c6facf0ffcf4a16a8d81d090a7fc1e8">elem</a>(face,1)) &gt; -1)
                    <span class="keywordflow">for</span> (k=0; k&lt;ncomp; k++)
                      {
                        resu(elem2,k) -=flux(k);
                        flux_bords(face,k)-=flux(k);
                      }
                }
            }
          <span class="keywordflow">break</span>;
        <span class="keywordflow">case</span> <a class="code" href="Iterateur__PolyMAC__base_8h.html#adda1d69a86f9e3be7366c5f4c6ace649adbce3cca9532937c741ae3ac77dc2d54" title="NSCBC.">nscbc</a> :
          <span class="keywordflow">if</span> (<a class="code" href="classT__It__VDF__Elem.html#ae1fc0535bed05926b790dd398811b036">flux_evaluateur</a>.calculer_flux_faces_NSCBC())
            {
              <span class="keyword">const</span> <a class="code" href="classNSCBC.html" title="classe">NSCBC</a>&amp; cl =(<span class="keyword">const</span> <a class="code" href="classNSCBC.html" title="classe">NSCBC</a>&amp;) (la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>());
              <span class="keywordflow">for</span> (face=ndeb; face&lt;nfin; face++)
                {
                  assert(ncomp == 1); <span class="comment">//!&lt; codage avec flux en DoubleVect auquel on assigne la valeur de la fonction scalaire (pas de codage vectoriel de nscbc)</span>
<span class="comment"></span>                  flux = <a class="code" href="classT__It__VDF__Elem.html#ae1fc0535bed05926b790dd398811b036">flux_evaluateur</a>.flux_face(donnee, face, cl, ndeb);
<span class="comment">// flux_evaluateur.flux_face(donnee, face, cl, ndeb, flux);</span>
                  <span class="keywordflow">if</span> ( (elem1=<a class="code" href="classT__It__VDF__Elem.html#a1c6facf0ffcf4a16a8d81d090a7fc1e8">elem</a>(face,0)) &gt; -1)
                    <span class="keywordflow">for</span> (k=0; k&lt;ncomp; k++)
                      {
                        resu(elem1,k) +=flux(k);
                        flux_bords(face,k)+=flux(k);
                      }
                  <span class="keywordflow">if</span> ( (elem2=<a class="code" href="classT__It__VDF__Elem.html#a1c6facf0ffcf4a16a8d81d090a7fc1e8">elem</a>(face,1)) &gt; -1)
                    <span class="keywordflow">for</span> (k=0; k&lt;ncomp; k++)
                      {
                        resu(elem2,k) -=flux(k);
                        flux_bords(face,k)-=flux(k);
                      }
                }
            }
          <span class="keywordflow">break</span>;
        <span class="keywordflow">case</span> <a class="code" href="Iterateur__PolyMAC__base_8h.html#adda1d69a86f9e3be7366c5f4c6ace649ab83c671c148d8664c5c87f343d2ab9fd" title="periodique">periodique</a> :
          <span class="keywordflow">if</span> (<a class="code" href="classT__It__VDF__Elem.html#ae1fc0535bed05926b790dd398811b036">flux_evaluateur</a>.calculer_flux_faces_periodique())
            {
              <span class="keyword">const</span> <a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>&amp; cl =(<span class="keyword">const</span> <a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>&amp;) (la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>());
              <span class="keywordflow">for</span> (face=ndeb; face&lt;nfin; face++)
                {
                  <a class="code" href="classT__It__VDF__Elem.html#ae1fc0535bed05926b790dd398811b036">flux_evaluateur</a>.flux_face(donnee, face, cl, ndeb, flux);
                  <span class="keywordflow">if</span> ( (elem1=<a class="code" href="classT__It__VDF__Elem.html#a1c6facf0ffcf4a16a8d81d090a7fc1e8">elem</a>(face,0)) &gt; -1)
                    <span class="keywordflow">for</span> (k=0; k&lt;ncomp; k++)
                      {
                        resu(elem1,k) +=0.5*flux(k);
                        <span class="keywordflow">if</span> ( face &lt; (ndeb+frontiere_dis.<a class="code" href="classFront__VF.html#a341e2fcb5117b96e745fd7078ba86bab" title="Nombre de faces reelles du bord.">nb_faces</a>()/2) )
                          flux_bords(face,k)+=flux(k);
                      }
                  <span class="keywordflow">if</span> ( (elem2=<a class="code" href="classT__It__VDF__Elem.html#a1c6facf0ffcf4a16a8d81d090a7fc1e8">elem</a>(face,1)) &gt; -1)
                    <span class="keywordflow">for</span> (k=0; k&lt;ncomp; k++)
                      {
                        resu(elem2,k) -=0.5*flux(k);
                        <span class="keywordflow">if</span> ( (ndeb+frontiere_dis.<a class="code" href="classFront__VF.html#a341e2fcb5117b96e745fd7078ba86bab" title="Nombre de faces reelles du bord.">nb_faces</a>()/2) &lt;= face )
                          flux_bords(face,k)-=flux(k);
                      }
                }
            }
          <span class="keywordflow">break</span>;
          <span class="comment">/*</span>
<span class="comment">                                                                            case nouvelle_Cl_VDF :</span>
<span class="comment">                                                                            if (flux_evaluateur.calculer_flux_faces_echange_global_impose()){</span>
<span class="comment">                                                                            const Nouvelle_Cl_VDF&amp; cl =(const Nouvelle_Cl_VDF&amp;) (la_cl.valeur());</span>
<span class="comment">                                                                            for (face=ndeb; face&lt;nfin; face++) {</span>
<span class="comment">                                                                            flux_evaluateur.flux_face(donnee, face, cl, ndeb, flux);</span>
<span class="comment">                                                                            if ( (elem1=elem(face,0)) &gt; -1)</span>
<span class="comment">                                                                            for (k=0; k&lt;ncomp; k++)</span>
<span class="comment">                                                                            resu(elem1,k) +=flux(k);</span>
<span class="comment">                                                                            if ( (elem2=elem(face,1)) &gt; -1)</span>
<span class="comment">                                                                            for (k=0; k&lt;ncomp; k++)</span>
<span class="comment">                                                                            resu(elem2,k) -=flux(k);</span>
<span class="comment">                                                                            }</span>
<span class="comment">                                                                            }</span>
<span class="comment">                                                                            break;</span>
<span class="comment">          */</span>
        <span class="keywordflow">default</span> :
          <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;On ne reconnait pas la condition limite : &quot;</span> &lt;&lt; la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>();
          <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">exit</a>();
          <span class="keywordflow">break</span>;
        }
    }
  <span class="keywordflow">return</span> resu;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a81a6d79a10b9317cfa92b93dccd41b0f"></a><!-- doxytag: member="T_It_VDF_Elem::ajouter_contribution" ref="a81a6d79a10b9317cfa92b93dccd41b0f" args="(const DoubleTab &amp;, Matrice_Morse &amp;) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class _TYPE_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classT__It__VDF__Elem.html">T_It_VDF_Elem</a>&lt; _TYPE_ &gt;::ajouter_contribution </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>inco</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;&#160;</td>
          <td class="paramname"><em>matrice</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implements <a class="el" href="classIterateur__VDF__base.html#a058683fe3326dec667a7b0dbae1c4dfb">Iterateur_VDF_base</a>.</p>

<p>Definition at line <a class="el" href="T__It__VDF__Elem_8h_source.html#l01225">1225</a> of file <a class="el" href="T__It__VDF__Elem_8h_source.html">T_It_VDF_Elem.h</a>.</p>

<p>References <a class="el" href="DoubleVect_8h_source.html#l00164">DoubleVect::line_size()</a>, <a class="el" href="DoubleTab_8h_source.html#l00264">DoubleTab::nb_dim()</a>, and <a class="el" href="DoubleTab_8cpp_source.html#l00335">DoubleTab::resize()</a>.</p>
<div class="fragment"><pre class="fragment">{
  ((_TYPE_&amp;) <a class="code" href="classT__It__VDF__Elem.html#ae1fc0535bed05926b790dd398811b036">flux_evaluateur</a>).mettre_a_jour();
  assert(inco.<a class="code" href="classDoubleTab.html#ae6dda48778e7107e1beb723beef1f75b" title="Returns the number of dimensions of the array (&gt;= 1)">nb_dim</a>() &lt; 3);
  assert(<a class="code" href="classIterateur__VDF__base.html#a7434e3782850ec5f73ae8c6e9772f94c">la_zcl</a>.<a class="code" href="classO__U__Ptr.html#a16f216b2d169e885876419182658ddcc" title="Renvoie 1 si le pointeur est non_nul Renvoie 0 sinon.">non_nul</a>());
  assert(<a class="code" href="classIterateur__VDF__base.html#af3f849b64b981589db0fd68c83893246">la_zone</a>.<a class="code" href="classO__U__Ptr.html#a16f216b2d169e885876419182658ddcc" title="Renvoie 1 si le pointeur est non_nul Renvoie 0 sinon.">non_nul</a>());
  <span class="keyword">const</span> <span class="keywordtype">int</span> ncomp = inco.<a class="code" href="classDoubleVect.html#ab02d01cd1bdab66fbd66f9a47cc29e10">line_size</a>();
  <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; flux_bords=<a class="code" href="classIterateur__VDF__base.html#afb3094769ccf45ba34cbab5b80725636">op_base</a>-&gt;flux_bords();
  flux_bords.<a class="code" href="classDoubleTab.html#ae83b4d31205c53d9c8d2b43da178ce75" title="Change la taille du vecteur (identique a resize_array() pour le traitement des anciennes valeurs et d...">resize</a>(<a class="code" href="classIterateur__VDF__base.html#af3f849b64b981589db0fd68c83893246">la_zone</a>-&gt;nb_faces_bord(),ncomp);
  flux_bords=0;
  <a class="code" href="classT__It__VDF__Elem.html#a5a4f3009b36687e4dd7fa1f33ab541ce">ajouter_contribution_bords</a>(inco, matrice) ;
  <a class="code" href="classT__It__VDF__Elem.html#a5ab524280db69182287cbe3f25666f9b">ajouter_contribution_interne</a>(inco, matrice) ;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a4e06ea2303d06f5d88619dfde55e280c"></a><!-- doxytag: member="T_It_VDF_Elem::ajouter_contribution_autre_pb" ref="a4e06ea2303d06f5d88619dfde55e280c" args="(const DoubleTab &amp;inco, Matrice_Morse &amp;matrice, const Cond_lim &amp;la_cl, std::map&lt; int, std::pair&lt; int, int &gt;&gt; &amp;) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class _TYPE_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classT__It__VDF__Elem.html">T_It_VDF_Elem</a>&lt; _TYPE_ &gt;::ajouter_contribution_autre_pb </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>inco</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;&#160;</td>
          <td class="paramname"><em>matrice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCond__lim.html">Cond_lim</a> &amp;&#160;</td>
          <td class="paramname"><em>la_cl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; int, std::pair&lt; int, int &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>f2e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="classIterateur__VDF__base.html#a8516f9138cace5122862902e15fb25ba">Iterateur_VDF_base</a>.</p>

<p>Definition at line <a class="el" href="T__It__VDF__Elem_8h_source.html#l01690">1690</a> of file <a class="el" href="T__It__VDF__Elem_8h_source.html">T_It_VDF_Elem.h</a>.</p>

<p>References <a class="el" href="Cond__lim_8h_source.html#l00130">Cond_lim::frontiere_dis()</a>, <a class="el" href="Front__VF_8h_source.html#l00061">Front_VF::nb_faces()</a>, <a class="el" href="Front__VF_8h_source.html#l00071">Front_VF::num_premiere_face()</a>, <a class="el" href="Cast_8h_source.html#l00059">ref_cast</a>, and <a class="el" href="Cond__lim_8h_source.html#l00031">Deriv_Cond_lim_base::valeur()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">double</span> aii=0, ajj=0;
  <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp; frontiere_dis = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>, la_cl.<a class="code" href="classCond__lim.html#a5b2d24809cee07727006a891d4ce8d22" title="Appel a l&#39;objet sous-jacent Renvoie la frontiere discretisee associee a la condition aux limites...">frontiere_dis</a>());
  <span class="keyword">const</span> <span class="keywordtype">int</span> ndeb = frontiere_dis.<a class="code" href="classFront__VF.html#a4986f0c65653fe9eb40bbbff5a97bf16" title="Numero de la premiere face du bord dans la liste des faces.">num_premiere_face</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> nfin = ndeb + frontiere_dis.<a class="code" href="classFront__VF.html#a341e2fcb5117b96e745fd7078ba86bab" title="Nombre de faces reelles du bord.">nb_faces</a>();
<span class="comment">// assert(cl est bien paroi contact)</span>
  <span class="keywordflow">if</span> (<a class="code" href="classT__It__VDF__Elem.html#ae1fc0535bed05926b790dd398811b036">flux_evaluateur</a>.calculer_flux_faces_echange_global_impose())
    {
      <span class="keyword">const</span> <a class="code" href="classEchange__global__impose.html" title="Classe Echange_global_impose Cette classe represente le cas particulier de la classe Echange_impose_b...">Echange_global_impose</a>&amp; cl =(<span class="keyword">const</span> <a class="code" href="classEchange__global__impose.html" title="Classe Echange_global_impose Cette classe represente le cas particulier de la classe Echange_impose_b...">Echange_global_impose</a>&amp;) (la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>());
      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> f = ndeb; f &lt; nfin; f++)
        {
          <a class="code" href="classT__It__VDF__Elem.html#ae1fc0535bed05926b790dd398811b036">flux_evaluateur</a>.coeffs_face(f, ndeb, cl, aii, ajj);
          <span class="keyword">const</span> <span class="keywordtype">int</span> e1 = f2e[f].first, e2 = f2e[f].second;
          matrice(e1, e2) = -(<a class="code" href="classT__It__VDF__Elem.html#a1c6facf0ffcf4a16a8d81d090a7fc1e8">elem</a>(f, 0) &gt; -1 ? aii : ajj);
        }
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a5a4f3009b36687e4dd7fa1f33ab541ce"></a><!-- doxytag: member="T_It_VDF_Elem::ajouter_contribution_bords" ref="a5a4f3009b36687e4dd7fa1f33ab541ce" args="(const DoubleTab &amp;, Matrice_Morse &amp;) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class _TYPE_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classT__It__VDF__Elem.html">T_It_VDF_Elem</a>&lt; _TYPE_ &gt;::ajouter_contribution_bords </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>inco</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;&#160;</td>
          <td class="paramname"><em>matrice</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="T__It__VDF__Elem_8h_source.html#l01264">1264</a> of file <a class="el" href="T__It__VDF__Elem_8h_source.html">T_It_VDF_Elem.h</a>.</p>

<p>References <a class="el" href="EntreeSortie_8h_source.html#l00032">Cerr</a>, <a class="el" href="Iterateur__PolyMAC__base_8h_source.html#l00062">echange_externe_impose</a>, <a class="el" href="Iterateur__PolyMAC__base_8h_source.html#l00063">echange_global_impose</a>, <a class="el" href="Iterateur__PolyMAC__base_8h_source.html#l00057">entree_fluide</a>, <a class="el" href="Cond__lim_8h_source.html#l00130">Cond_lim::frontiere_dis()</a>, <a class="el" href="Frontiere__dis__base_8cpp_source.html#l00146">Frontiere_dis_base::le_nom()</a>, <a class="el" href="DoubleVect_8h_source.html#l00164">DoubleVect::line_size()</a>, <a class="el" href="Front__VF_8h_source.html#l00061">Front_VF::nb_faces()</a>, <a class="el" href="Iterateur__PolyMAC__base_8h_source.html#l00065">nscbc</a>, <a class="el" href="Front__VF_8h_source.html#l00071">Front_VF::num_premiere_face()</a>, <a class="el" href="Iterateur__PolyMAC__base_8h_source.html#l00061">paroi</a>, <a class="el" href="Iterateur__PolyMAC__base_8h_source.html#l00059">paroi_defilante</a>, <a class="el" href="Iterateur__PolyMAC__base_8h_source.html#l00058">paroi_fixe</a>, <a class="el" href="Iterateur__PolyMAC__base_8h_source.html#l00064">periodique</a>, <a class="el" href="Cast_8h_source.html#l00059">ref_cast</a>, <a class="el" href="Iterateur__PolyMAC__base_8h_source.html#l00056">sortie_libre</a>, <a class="el" href="Iterateur__PolyMAC__base_8h_source.html#l00055">symetrie</a>, and <a class="el" href="Cond__lim_8h_source.html#l00031">Deriv_Cond_lim_base::valeur()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">const</span> <span class="keywordtype">int</span> ncomp = inco.<a class="code" href="classDoubleVect.html#ab02d01cd1bdab66fbd66f9a47cc29e10">line_size</a>();
  <span class="keywordtype">int</span> elem1, elem2;
  <a class="code" href="classDoubleVect.html">DoubleVect</a> aii(ncomp), ajj(ncomp);
  <span class="keywordtype">int</span> ndeb, nfin;
  <span class="keywordtype">int</span> face;
  <span class="keywordtype">int</span> num_cl=0;
  <span class="keywordtype">int</span> nb_front_Cl=<a class="code" href="classIterateur__VDF__base.html#af3f849b64b981589db0fd68c83893246">la_zone</a>-&gt;nb_front_Cl();
  <span class="keywordflow">for</span> (; num_cl&lt;nb_front_Cl; num_cl++)
    {
      <span class="keyword">const</span> <a class="code" href="classCond__lim.html" title="classe Cond_lim Classe generique servant a representer n&#39;importe quelle classe derivee de la classe C...">Cond_lim</a>&amp; la_cl = <a class="code" href="classIterateur__VDF__base.html#a7434e3782850ec5f73ae8c6e9772f94c">la_zcl</a>-&gt;les_conditions_limites(num_cl);
      <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp; frontiere_dis = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>,la_cl.<a class="code" href="classCond__lim.html#a5b2d24809cee07727006a891d4ce8d22" title="Appel a l&#39;objet sous-jacent Renvoie la frontiere discretisee associee a la condition aux limites...">frontiere_dis</a>());
      ndeb = frontiere_dis.<a class="code" href="classFront__VF.html#a4986f0c65653fe9eb40bbbff5a97bf16" title="Numero de la premiere face du bord dans la liste des faces.">num_premiere_face</a>();
      nfin = ndeb + frontiere_dis.<a class="code" href="classFront__VF.html#a341e2fcb5117b96e745fd7078ba86bab" title="Nombre de faces reelles du bord.">nb_faces</a>();
      <span class="keywordflow">switch</span>(<a class="code" href="classIterateur__VDF__base.html#ae7e13026a533fe31c54526a7ba7bbaaf">type_cl</a>(la_cl))
        {
        <span class="keywordflow">case</span> <a class="code" href="Iterateur__PolyMAC__base_8h.html#adda1d69a86f9e3be7366c5f4c6ace649ac938491055e13993f3eed68c989f90b0" title="Symetrie.">symetrie</a> :
          <span class="keywordflow">if</span> (<a class="code" href="classT__It__VDF__Elem.html#ae1fc0535bed05926b790dd398811b036">flux_evaluateur</a>.calculer_flux_faces_symetrie())
            {
              <span class="keyword">const</span> <a class="code" href="classSymetrie.html" title="classe Symetrie Sur les faces de symetrie on a les proprietes suivantes: - composante normale de la v...">Symetrie</a>&amp; cl =(<span class="keyword">const</span> <a class="code" href="classSymetrie.html" title="classe Symetrie Sur les faces de symetrie on a les proprietes suivantes: - composante normale de la v...">Symetrie</a>&amp;) (la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>());
              <span class="keywordflow">for</span> (face=ndeb; face&lt;nfin; face++)
                {
                  <a class="code" href="classT__It__VDF__Elem.html#ae1fc0535bed05926b790dd398811b036">flux_evaluateur</a>.coeffs_face(face,ndeb, cl, aii, ajj);
                  <span class="keywordflow">if</span> ( (elem1=<a class="code" href="classT__It__VDF__Elem.html#a1c6facf0ffcf4a16a8d81d090a7fc1e8">elem</a>(face,0)) &gt; -1)
                    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; ncomp; i++)
                      matrice(elem1*ncomp+i,elem1*ncomp+i)+=aii(i);
                  <span class="keywordflow">if</span> ( (elem2=<a class="code" href="classT__It__VDF__Elem.html#a1c6facf0ffcf4a16a8d81d090a7fc1e8">elem</a>(face,1)) &gt; -1)
                    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; ncomp; i++)
                      matrice(elem2*ncomp+i,elem2*ncomp+i)+=ajj(i);
                }
            }
          <span class="keywordflow">break</span>;
        <span class="keywordflow">case</span> <a class="code" href="Iterateur__PolyMAC__base_8h.html#adda1d69a86f9e3be7366c5f4c6ace649ac4317ef27513bbab3cd0ccfd0d9ed199" title="Neumann_sortie_libre ou derivees.">sortie_libre</a> :
          <span class="keywordflow">if</span> (<a class="code" href="classT__It__VDF__Elem.html#ae1fc0535bed05926b790dd398811b036">flux_evaluateur</a>.calculer_flux_faces_sortie_libre())
            {
              <span class="keyword">const</span> <a class="code" href="classNeumann__sortie__libre.html" title="classe Neumann_sortie_libre Cette classe represente une frontiere ouverte sans vitesse imposee Pour l...">Neumann_sortie_libre</a>&amp; cl =(<span class="keyword">const</span> <a class="code" href="classNeumann__sortie__libre.html" title="classe Neumann_sortie_libre Cette classe represente une frontiere ouverte sans vitesse imposee Pour l...">Neumann_sortie_libre</a>&amp;) (la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>());
              <span class="keywordflow">for</span> (face=ndeb; face&lt;nfin; face++)
                {
                  <a class="code" href="classT__It__VDF__Elem.html#ae1fc0535bed05926b790dd398811b036">flux_evaluateur</a>.coeffs_face(face,ndeb, cl, aii, ajj);
                  <span class="keywordflow">if</span> ( (elem1=<a class="code" href="classT__It__VDF__Elem.html#a1c6facf0ffcf4a16a8d81d090a7fc1e8">elem</a>(face,0)) &gt; -1)
                    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; ncomp; i++)
                      matrice(elem1*ncomp+i,elem1*ncomp+i)+=aii(i);
                  <span class="keywordflow">if</span> ( (elem2=<a class="code" href="classT__It__VDF__Elem.html#a1c6facf0ffcf4a16a8d81d090a7fc1e8">elem</a>(face,1)) &gt; -1)
                    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; ncomp; i++)
                      matrice(elem2*ncomp+i,elem2*ncomp+i)+=ajj(i);
                }
            }
          <span class="keywordflow">break</span>;
        <span class="keywordflow">case</span> <a class="code" href="Iterateur__PolyMAC__base_8h.html#adda1d69a86f9e3be7366c5f4c6ace649a594fd60a4576f47654eed7df53dee9be" title="Dirichlet_entree_fluide.">entree_fluide</a> :
          <span class="keywordflow">if</span> (<a class="code" href="classT__It__VDF__Elem.html#ae1fc0535bed05926b790dd398811b036">flux_evaluateur</a>.calculer_flux_faces_entree_fluide())
            {
              <span class="keyword">const</span> <a class="code" href="classDirichlet__entree__fluide.html" title="classe Dirichlet_entree_fluide Cette classe represente une condition aux limite imposant une grandeur...">Dirichlet_entree_fluide</a>&amp; cl =(<span class="keyword">const</span> <a class="code" href="classDirichlet__entree__fluide.html" title="classe Dirichlet_entree_fluide Cette classe represente une condition aux limite imposant une grandeur...">Dirichlet_entree_fluide</a>&amp;) (la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>());
              <span class="keywordflow">for</span> (face=ndeb; face&lt;nfin; face++)
                {
                  <a class="code" href="classT__It__VDF__Elem.html#ae1fc0535bed05926b790dd398811b036">flux_evaluateur</a>.coeffs_face(face,ndeb, cl, aii, ajj);
                  <span class="keywordflow">if</span> ( (elem1=<a class="code" href="classT__It__VDF__Elem.html#a1c6facf0ffcf4a16a8d81d090a7fc1e8">elem</a>(face,0)) &gt; -1)
                    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; ncomp; i++)
                      matrice(elem1*ncomp+i,elem1*ncomp+i)+=aii(i);
                  <span class="keywordflow">if</span> ( (elem2=<a class="code" href="classT__It__VDF__Elem.html#a1c6facf0ffcf4a16a8d81d090a7fc1e8">elem</a>(face,1)) &gt; -1)
                    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; ncomp; i++)
                      matrice(elem2*ncomp+i,elem2*ncomp+i)+=ajj(i);
                }
            }
          <span class="keywordflow">break</span>;
        <span class="keywordflow">case</span> <a class="code" href="Iterateur__PolyMAC__base_8h.html#adda1d69a86f9e3be7366c5f4c6ace649a497d92e00f36c1c7ec874c0a318db91e" title="Dirichlet_paroi_fixe.">paroi_fixe</a> :
          <span class="keywordflow">if</span> (<a class="code" href="classT__It__VDF__Elem.html#ae1fc0535bed05926b790dd398811b036">flux_evaluateur</a>.calculer_flux_faces_paroi_fixe())
            {
              <span class="keyword">const</span> <a class="code" href="classDirichlet__paroi__fixe.html" title="classe Dirichlet_paroi_fixe Represente une paroi immobile dans une equation de type Navier_Stokes...">Dirichlet_paroi_fixe</a>&amp; cl =(<span class="keyword">const</span> <a class="code" href="classDirichlet__paroi__fixe.html" title="classe Dirichlet_paroi_fixe Represente une paroi immobile dans une equation de type Navier_Stokes...">Dirichlet_paroi_fixe</a>&amp;) (la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>());
              <span class="keywordflow">for</span> (face=ndeb; face&lt;nfin; face++)
                {
                  <a class="code" href="classT__It__VDF__Elem.html#ae1fc0535bed05926b790dd398811b036">flux_evaluateur</a>.coeffs_face(face,ndeb, cl, aii, ajj);
                  <span class="keywordflow">if</span> ( (elem1=<a class="code" href="classT__It__VDF__Elem.html#a1c6facf0ffcf4a16a8d81d090a7fc1e8">elem</a>(face,0)) &gt; -1)
                    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; ncomp; i++)
                      matrice(elem1*ncomp+i,elem1*ncomp+i)+=aii(i);
                  <span class="keywordflow">if</span> ( (elem2=<a class="code" href="classT__It__VDF__Elem.html#a1c6facf0ffcf4a16a8d81d090a7fc1e8">elem</a>(face,1)) &gt; -1)
                    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; ncomp; i++)
                      matrice(elem2*ncomp+i,elem2*ncomp+i)+=ajj(i);
                }
            }
          <span class="keywordflow">break</span>;
        <span class="keywordflow">case</span> <a class="code" href="Iterateur__PolyMAC__base_8h.html#adda1d69a86f9e3be7366c5f4c6ace649acdd1bf461cb105b93d5a9b003ce33141" title="Dirichlet_paroi_defilante.">paroi_defilante</a> :
          <span class="keywordflow">if</span> (<a class="code" href="classT__It__VDF__Elem.html#ae1fc0535bed05926b790dd398811b036">flux_evaluateur</a>.calculer_flux_faces_paroi_defilante())
            {
              <span class="keyword">const</span> <a class="code" href="classDirichlet__paroi__defilante.html" title="classe Dirichlet_paroi_defilante Impose la vitesse de paroi dnas une equation de type Navier_Stokes...">Dirichlet_paroi_defilante</a>&amp; cl =(<span class="keyword">const</span> <a class="code" href="classDirichlet__paroi__defilante.html" title="classe Dirichlet_paroi_defilante Impose la vitesse de paroi dnas une equation de type Navier_Stokes...">Dirichlet_paroi_defilante</a>&amp;) (la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>());
              <span class="keywordflow">for</span> (face=ndeb; face&lt;nfin; face++)
                {
                  <a class="code" href="classT__It__VDF__Elem.html#ae1fc0535bed05926b790dd398811b036">flux_evaluateur</a>.coeffs_face(face,ndeb, cl, aii, ajj);
                  <span class="keywordflow">if</span> ( (elem1=<a class="code" href="classT__It__VDF__Elem.html#a1c6facf0ffcf4a16a8d81d090a7fc1e8">elem</a>(face,0)) &gt; -1)
                    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; ncomp; i++)
                      matrice(elem1*ncomp+i,elem1*ncomp+i)+=aii(i);
                  <span class="keywordflow">if</span> ( (elem2=<a class="code" href="classT__It__VDF__Elem.html#a1c6facf0ffcf4a16a8d81d090a7fc1e8">elem</a>(face,1)) &gt; -1)
                    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; ncomp; i++)
                      matrice(elem2*ncomp+i,elem2*ncomp+i)+=ajj(i);
                }
            }
          <span class="keywordflow">break</span>;
        <span class="keywordflow">case</span> <a class="code" href="classparoi__adiabatique.html">paroi_adiabatique</a> :
          <span class="keywordflow">if</span> (<a class="code" href="classT__It__VDF__Elem.html#ae1fc0535bed05926b790dd398811b036">flux_evaluateur</a>.calculer_flux_faces_paroi_adiabatique())
            {
              <span class="keyword">const</span> <a class="code" href="classNeumann__paroi__adiabatique.html" title="Classe Neumann_paroi_adiabatique Cette condition limite correspond a une paroi adiabatique dans une e...">Neumann_paroi_adiabatique</a>&amp; cl =(<span class="keyword">const</span> <a class="code" href="classNeumann__paroi__adiabatique.html" title="Classe Neumann_paroi_adiabatique Cette condition limite correspond a une paroi adiabatique dans une e...">Neumann_paroi_adiabatique</a>&amp;) (la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>());
              <span class="keywordflow">for</span> (face=ndeb; face&lt;nfin; face++)
                {
                  <a class="code" href="classT__It__VDF__Elem.html#ae1fc0535bed05926b790dd398811b036">flux_evaluateur</a>.coeffs_face(face,ndeb, cl, aii, ajj);
                  <span class="keywordflow">if</span> ( (elem1=<a class="code" href="classT__It__VDF__Elem.html#a1c6facf0ffcf4a16a8d81d090a7fc1e8">elem</a>(face,0)) &gt; -1)
                    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; ncomp; i++)
                      matrice(elem1*ncomp+i,elem1*ncomp+i)+=aii(i);
                  <span class="keywordflow">if</span> ( (elem2=<a class="code" href="classT__It__VDF__Elem.html#a1c6facf0ffcf4a16a8d81d090a7fc1e8">elem</a>(face,1)) &gt; -1)
                    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; ncomp; i++)
                      matrice(elem2*ncomp+i,elem2*ncomp+i)+=ajj(i);
                }
            }
          <span class="keywordflow">break</span>;
        <span class="keywordflow">case</span> <a class="code" href="Iterateur__PolyMAC__base_8h.html#adda1d69a86f9e3be7366c5f4c6ace649af695f3ba17490e07dc3259c85875d8d6" title="Neumann_paroi.">paroi</a> :
          <span class="keywordflow">if</span> (<a class="code" href="classT__It__VDF__Elem.html#ae1fc0535bed05926b790dd398811b036">flux_evaluateur</a>.calculer_flux_faces_paroi())
            {
              <span class="keyword">const</span> <a class="code" href="classNeumann__paroi.html" title="Classe Neumann_paroi Cette condition limite correspond a un flux impose pour l&#39;equation de transport ...">Neumann_paroi</a>&amp; cl =(<span class="keyword">const</span> <a class="code" href="classNeumann__paroi.html" title="Classe Neumann_paroi Cette condition limite correspond a un flux impose pour l&#39;equation de transport ...">Neumann_paroi</a>&amp;) (la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>());
              <span class="keywordflow">for</span> (face=ndeb; face&lt;nfin; face++)
                {
                  <a class="code" href="classT__It__VDF__Elem.html#ae1fc0535bed05926b790dd398811b036">flux_evaluateur</a>.coeffs_face(face,ndeb, cl, aii, ajj);
                  <span class="keywordflow">if</span> ( (elem1=<a class="code" href="classT__It__VDF__Elem.html#a1c6facf0ffcf4a16a8d81d090a7fc1e8">elem</a>(face,0)) &gt; -1)
                    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; ncomp; i++)
                      matrice(elem1*ncomp+i,elem1*ncomp+i)+=aii(i);
                  <span class="keywordflow">if</span> ( (elem2=<a class="code" href="classT__It__VDF__Elem.html#a1c6facf0ffcf4a16a8d81d090a7fc1e8">elem</a>(face,1)) &gt; -1)
                    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; ncomp; i++)
                      matrice(elem2*ncomp+i,elem2*ncomp+i)+=ajj(i);
                }
            }
          <span class="keywordflow">break</span>;
        <span class="keywordflow">case</span> <a class="code" href="Iterateur__PolyMAC__base_8h.html#adda1d69a86f9e3be7366c5f4c6ace649a38f997f881a13a46f2d06012162cf833" title="Echange_externe_impose.">echange_externe_impose</a> :
          <span class="keywordflow">if</span> (<a class="code" href="classT__It__VDF__Elem.html#ae1fc0535bed05926b790dd398811b036">flux_evaluateur</a>.calculer_flux_faces_echange_externe_impose())
            {
              <span class="keyword">const</span> <a class="code" href="classEchange__externe__impose.html" title="Classe Echange_externe_impose: Cette classe represente le cas particulier de la classe Echange_impose...">Echange_externe_impose</a>&amp; cl =(<span class="keyword">const</span> <a class="code" href="classEchange__externe__impose.html" title="Classe Echange_externe_impose: Cette classe represente le cas particulier de la classe Echange_impose...">Echange_externe_impose</a>&amp;) (la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>());

              <span class="keywordtype">int</span> boundary_index=-1;
              <span class="keywordflow">if</span> (<a class="code" href="classIterateur__VDF__base.html#af3f849b64b981589db0fd68c83893246">la_zone</a>.<a class="code" href="classRef__Zone__VDF.html#a84151da4db745d02791d6246e3682b67">valeur</a>().<a class="code" href="classZone__VF.html#a45e54622328fcf035535edf96172c1e4" title="renvoie la ieme frontiere_discrete.">front_VF</a>(num_cl).<a class="code" href="classFrontiere__dis__base.html#a5a7eb46dc3af8a7d4225adc1814845d8" title="Renvoie le nom de la frontiere geometrique.">le_nom</a>() == frontiere_dis.<a class="code" href="classFrontiere__dis__base.html#a5a7eb46dc3af8a7d4225adc1814845d8" title="Renvoie le nom de la frontiere geometrique.">le_nom</a>())
                boundary_index=num_cl;

              <span class="keywordflow">for</span> (face=ndeb; face&lt;nfin; face++)
                {
                  <span class="keywordtype">int</span> local_face=<a class="code" href="classIterateur__VDF__base.html#af3f849b64b981589db0fd68c83893246">la_zone</a>.<a class="code" href="classRef__Zone__VDF.html#a84151da4db745d02791d6246e3682b67">valeur</a>().<a class="code" href="classZone__VF.html#a45e54622328fcf035535edf96172c1e4" title="renvoie la ieme frontiere_discrete.">front_VF</a>(boundary_index).<a class="code" href="classFront__VF.html#a8b34de011799509c228146cea1abaaab">num_local_face</a>(face);
                  <a class="code" href="classT__It__VDF__Elem.html#ae1fc0535bed05926b790dd398811b036">flux_evaluateur</a>.coeffs_face(boundary_index,face,local_face,ndeb, cl, aii, ajj);
                  <span class="keywordflow">if</span> ( (elem1=<a class="code" href="classT__It__VDF__Elem.html#a1c6facf0ffcf4a16a8d81d090a7fc1e8">elem</a>(face,0)) &gt; -1)
                    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; ncomp; i++)
                      matrice(elem1*ncomp+i,elem1*ncomp+i)+=aii(i);
                  <span class="keywordflow">if</span> ( (elem2=<a class="code" href="classT__It__VDF__Elem.html#a1c6facf0ffcf4a16a8d81d090a7fc1e8">elem</a>(face,1)) &gt; -1)
                    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; ncomp; i++)
                      matrice(elem2*ncomp+i,elem2*ncomp+i)+=ajj(i);
                }
            }
          <span class="keywordflow">break</span>;
        <span class="keywordflow">case</span> <a class="code" href="Iterateur__PolyMAC__base_8h.html#adda1d69a86f9e3be7366c5f4c6ace649a9201b83c6fe44d3928abbe5f73364323" title="Echange_global_impose.">echange_global_impose</a> :
          <span class="keywordflow">if</span> (<a class="code" href="classT__It__VDF__Elem.html#ae1fc0535bed05926b790dd398811b036">flux_evaluateur</a>.calculer_flux_faces_echange_global_impose())
            {
              <span class="keyword">const</span> <a class="code" href="classEchange__global__impose.html" title="Classe Echange_global_impose Cette classe represente le cas particulier de la classe Echange_impose_b...">Echange_global_impose</a>&amp; cl =(<span class="keyword">const</span> <a class="code" href="classEchange__global__impose.html" title="Classe Echange_global_impose Cette classe represente le cas particulier de la classe Echange_impose_b...">Echange_global_impose</a>&amp;) (la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>());
              <span class="keywordflow">for</span> (face=ndeb; face&lt;nfin; face++)
                {
                  <a class="code" href="classT__It__VDF__Elem.html#ae1fc0535bed05926b790dd398811b036">flux_evaluateur</a>.coeffs_face(face,ndeb, cl, aii, ajj);
                  <span class="keywordflow">if</span> ( (elem1=<a class="code" href="classT__It__VDF__Elem.html#a1c6facf0ffcf4a16a8d81d090a7fc1e8">elem</a>(face,0)) &gt; -1)
                    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; ncomp; i++)
                      matrice(elem1*ncomp+i,elem1*ncomp+i)+=aii(i);
                  <span class="keywordflow">if</span> ( (elem2=<a class="code" href="classT__It__VDF__Elem.html#a1c6facf0ffcf4a16a8d81d090a7fc1e8">elem</a>(face,1)) &gt; -1)
                    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; ncomp; i++)
                      matrice(elem2*ncomp+i,elem2*ncomp+i)+=ajj(i);
                }
            }
          <span class="keywordflow">break</span>;
        <span class="keywordflow">case</span> <a class="code" href="Iterateur__PolyMAC__base_8h.html#adda1d69a86f9e3be7366c5f4c6ace649adbce3cca9532937c741ae3ac77dc2d54" title="NSCBC.">nscbc</a> :
          <span class="keywordflow">if</span> (<a class="code" href="classT__It__VDF__Elem.html#ae1fc0535bed05926b790dd398811b036">flux_evaluateur</a>.calculer_flux_faces_NSCBC())
            {
              <span class="keyword">const</span> <a class="code" href="classNSCBC.html" title="classe">NSCBC</a>&amp; cl =(<span class="keyword">const</span> <a class="code" href="classNSCBC.html" title="classe">NSCBC</a>&amp;) (la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>());
              <span class="keywordflow">for</span> (face=ndeb; face&lt;nfin; face++)
                {
<span class="comment">// codage scalaire applique aux DoubleVect</span>
                  assert(ncomp == 1);
                  <span class="keywordtype">double</span> aii_ = 0., ajj_ = 0.;
                  <a class="code" href="classT__It__VDF__Elem.html#ae1fc0535bed05926b790dd398811b036">flux_evaluateur</a>.coeffs_face(face,ndeb, cl, aii_, ajj_);
                  aii = aii_, ajj = ajj_;
                  <span class="keywordflow">if</span> ( (elem1=<a class="code" href="classT__It__VDF__Elem.html#a1c6facf0ffcf4a16a8d81d090a7fc1e8">elem</a>(face,0)) &gt; -1)
                    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; ncomp; i++)
                      matrice(elem1*ncomp+i,elem1*ncomp+i)+=aii(i);
                  <span class="keywordflow">if</span> ( (elem2=<a class="code" href="classT__It__VDF__Elem.html#a1c6facf0ffcf4a16a8d81d090a7fc1e8">elem</a>(face,1)) &gt; -1)
                    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; ncomp; i++)
                      matrice(elem2*ncomp+i,elem2*ncomp+i)+=ajj(i);
                }
            }
          <span class="keywordflow">break</span>;
        <span class="keywordflow">case</span> <a class="code" href="Iterateur__PolyMAC__base_8h.html#adda1d69a86f9e3be7366c5f4c6ace649ab83c671c148d8664c5c87f343d2ab9fd" title="periodique">periodique</a> :
          <span class="keywordflow">if</span> (<a class="code" href="classT__It__VDF__Elem.html#ae1fc0535bed05926b790dd398811b036">flux_evaluateur</a>.calculer_flux_faces_periodique())
            {
              <span class="keyword">const</span> <a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>&amp; cl =(<span class="keyword">const</span> <a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>&amp;) (la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>());
              <span class="keywordflow">for</span> (face=ndeb; face&lt;nfin; face++)
                {
                  <a class="code" href="classT__It__VDF__Elem.html#ae1fc0535bed05926b790dd398811b036">flux_evaluateur</a>.coeffs_face(face,ndeb, cl, aii, ajj);
                  elem1 = <a class="code" href="classT__It__VDF__Elem.html#a1c6facf0ffcf4a16a8d81d090a7fc1e8">elem</a>(face,0);
                  elem2 = <a class="code" href="classT__It__VDF__Elem.html#a1c6facf0ffcf4a16a8d81d090a7fc1e8">elem</a>(face,1);
                  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; ncomp; i++)
                    {
                      <span class="keywordtype">int</span> n1=elem1*ncomp+i;
                      <span class="keywordtype">int</span> n2=elem2*ncomp+i;
                      matrice(n1,n1)+=0.5*aii(i);
                      matrice(n1,n2)-=0.5*ajj(i);
                      matrice(n2,n2)+=0.5*ajj(i);
                      matrice(n2,n1)-=0.5*aii(i);
                    }
                }
            }
          <span class="keywordflow">break</span>;
        <span class="keywordflow">default</span> :
          <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;On ne reconnait pas la condition limite : &quot;</span> &lt;&lt; la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>();
          <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">exit</a>();
          <span class="keywordflow">break</span>;
        }
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="ae7a38e26b2d63f9d0df4561c73289011"></a><!-- doxytag: member="T_It_VDF_Elem::ajouter_contribution_bords_vitesse" ref="ae7a38e26b2d63f9d0df4561c73289011" args="(const DoubleTab &amp;, Matrice_Morse &amp;) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class _TYPE_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classT__It__VDF__Elem.html">T_It_VDF_Elem</a>&lt; _TYPE_ &gt;::ajouter_contribution_bords_vitesse </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>inco</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;&#160;</td>
          <td class="paramname"><em>matrice</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="T__It__VDF__Elem_8h_source.html#l01521">1521</a> of file <a class="el" href="T__It__VDF__Elem_8h_source.html">T_It_VDF_Elem.h</a>.</p>

<p>References <a class="el" href="EntreeSortie_8h_source.html#l00032">Cerr</a>, <a class="el" href="Iterateur__PolyMAC__base_8h_source.html#l00062">echange_externe_impose</a>, <a class="el" href="Iterateur__PolyMAC__base_8h_source.html#l00063">echange_global_impose</a>, <a class="el" href="Iterateur__PolyMAC__base_8h_source.html#l00057">entree_fluide</a>, <a class="el" href="Cond__lim_8h_source.html#l00130">Cond_lim::frontiere_dis()</a>, <a class="el" href="Frontiere__dis__base_8cpp_source.html#l00146">Frontiere_dis_base::le_nom()</a>, <a class="el" href="Front__VF_8h_source.html#l00061">Front_VF::nb_faces()</a>, <a class="el" href="Iterateur__PolyMAC__base_8h_source.html#l00065">nscbc</a>, <a class="el" href="Front__VF_8h_source.html#l00071">Front_VF::num_premiere_face()</a>, <a class="el" href="Iterateur__PolyMAC__base_8h_source.html#l00061">paroi</a>, <a class="el" href="Iterateur__PolyMAC__base_8h_source.html#l00059">paroi_defilante</a>, <a class="el" href="Iterateur__PolyMAC__base_8h_source.html#l00058">paroi_fixe</a>, <a class="el" href="Iterateur__PolyMAC__base_8h_source.html#l00064">periodique</a>, <a class="el" href="Cast_8h_source.html#l00059">ref_cast</a>, <a class="el" href="Iterateur__PolyMAC__base_8h_source.html#l00056">sortie_libre</a>, <a class="el" href="Iterateur__PolyMAC__base_8h_source.html#l00055">symetrie</a>, and <a class="el" href="Cond__lim_8h_source.html#l00031">Deriv_Cond_lim_base::valeur()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">int</span> e1, e2;
  <span class="keywordtype">double</span> aef=0;
  <span class="keywordtype">int</span> ndeb, nfin;
  <span class="keywordtype">int</span> nb_front_Cl=<a class="code" href="classIterateur__VDF__base.html#af3f849b64b981589db0fd68c83893246">la_zone</a>-&gt;nb_front_Cl();
  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> num_cl = 0; num_cl&lt;nb_front_Cl; num_cl++)
    {
      <span class="comment">/* pour chaque Condition Limite on regarde son type */</span>
      <span class="keyword">const</span> <a class="code" href="classCond__lim.html" title="classe Cond_lim Classe generique servant a representer n&#39;importe quelle classe derivee de la classe C...">Cond_lim</a>&amp; la_cl = <a class="code" href="classIterateur__VDF__base.html#a7434e3782850ec5f73ae8c6e9772f94c">la_zcl</a>-&gt;les_conditions_limites(num_cl);
      <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp; frontiere_dis = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>,la_cl.<a class="code" href="classCond__lim.html#a5b2d24809cee07727006a891d4ce8d22" title="Appel a l&#39;objet sous-jacent Renvoie la frontiere discretisee associee a la condition aux limites...">frontiere_dis</a>());
      ndeb = frontiere_dis.<a class="code" href="classFront__VF.html#a4986f0c65653fe9eb40bbbff5a97bf16" title="Numero de la premiere face du bord dans la liste des faces.">num_premiere_face</a>();
      nfin = ndeb + frontiere_dis.<a class="code" href="classFront__VF.html#a341e2fcb5117b96e745fd7078ba86bab" title="Nombre de faces reelles du bord.">nb_faces</a>();
      <span class="keywordflow">switch</span>(<a class="code" href="classIterateur__VDF__base.html#ae7e13026a533fe31c54526a7ba7bbaaf">type_cl</a>(la_cl))
        {
        <span class="keywordflow">case</span> <a class="code" href="Iterateur__PolyMAC__base_8h.html#adda1d69a86f9e3be7366c5f4c6ace649ac938491055e13993f3eed68c989f90b0" title="Symetrie.">symetrie</a> :
          <span class="keywordflow">if</span> (<a class="code" href="classT__It__VDF__Elem.html#ae1fc0535bed05926b790dd398811b036">flux_evaluateur</a>.calculer_flux_faces_symetrie())
            {
              <span class="keyword">const</span> <a class="code" href="classSymetrie.html" title="classe Symetrie Sur les faces de symetrie on a les proprietes suivantes: - composante normale de la v...">Symetrie</a>&amp; cl =(<span class="keyword">const</span> <a class="code" href="classSymetrie.html" title="classe Symetrie Sur les faces de symetrie on a les proprietes suivantes: - composante normale de la v...">Symetrie</a>&amp;) (la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>());
              <span class="keywordflow">for</span> (<span class="keywordtype">int</span> f = ndeb; f &lt; nfin; f++)
                {
                  aef = <a class="code" href="classT__It__VDF__Elem.html#ae1fc0535bed05926b790dd398811b036">flux_evaluateur</a>.coeffs_face_bloc_vitesse(inco, f, cl, ndeb);
                  <span class="keywordflow">if</span> ( (e1 = <a class="code" href="classT__It__VDF__Elem.html#a1c6facf0ffcf4a16a8d81d090a7fc1e8">elem</a>(f, 0)) &gt; -1) matrice(e1, f) += aef;
                  <span class="keywordflow">if</span> ( (e2 = <a class="code" href="classT__It__VDF__Elem.html#a1c6facf0ffcf4a16a8d81d090a7fc1e8">elem</a>(f, 1)) &gt; -1) matrice(e2, f) -= aef;
                }
            }
          <span class="keywordflow">break</span>;
        <span class="keywordflow">case</span> <a class="code" href="Iterateur__PolyMAC__base_8h.html#adda1d69a86f9e3be7366c5f4c6ace649ac4317ef27513bbab3cd0ccfd0d9ed199" title="Neumann_sortie_libre ou derivees.">sortie_libre</a> :
          <span class="keywordflow">if</span> (<a class="code" href="classT__It__VDF__Elem.html#ae1fc0535bed05926b790dd398811b036">flux_evaluateur</a>.calculer_flux_faces_sortie_libre())
            {
              <span class="keyword">const</span> <a class="code" href="classNeumann__sortie__libre.html" title="classe Neumann_sortie_libre Cette classe represente une frontiere ouverte sans vitesse imposee Pour l...">Neumann_sortie_libre</a>&amp; cl =(<span class="keyword">const</span> <a class="code" href="classNeumann__sortie__libre.html" title="classe Neumann_sortie_libre Cette classe represente une frontiere ouverte sans vitesse imposee Pour l...">Neumann_sortie_libre</a>&amp;) (la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>());
              <span class="keywordflow">for</span> (<span class="keywordtype">int</span> f = ndeb; f &lt; nfin; f++)
                {
                  aef = <a class="code" href="classT__It__VDF__Elem.html#ae1fc0535bed05926b790dd398811b036">flux_evaluateur</a>.coeffs_face_bloc_vitesse(inco, f, cl, ndeb);
                  <span class="keywordflow">if</span> ( (e1 = <a class="code" href="classT__It__VDF__Elem.html#a1c6facf0ffcf4a16a8d81d090a7fc1e8">elem</a>(f, 0)) &gt; -1) matrice(e1, f) += aef;
                  <span class="keywordflow">if</span> ( (e2 = <a class="code" href="classT__It__VDF__Elem.html#a1c6facf0ffcf4a16a8d81d090a7fc1e8">elem</a>(f, 1)) &gt; -1) matrice(e2, f) -= aef;
                }
            }
          <span class="keywordflow">break</span>;
        <span class="keywordflow">case</span> <a class="code" href="Iterateur__PolyMAC__base_8h.html#adda1d69a86f9e3be7366c5f4c6ace649a594fd60a4576f47654eed7df53dee9be" title="Dirichlet_entree_fluide.">entree_fluide</a> :
          <span class="keywordflow">if</span> (<a class="code" href="classT__It__VDF__Elem.html#ae1fc0535bed05926b790dd398811b036">flux_evaluateur</a>.calculer_flux_faces_entree_fluide())
            {
              <span class="keyword">const</span> <a class="code" href="classDirichlet__entree__fluide.html" title="classe Dirichlet_entree_fluide Cette classe represente une condition aux limite imposant une grandeur...">Dirichlet_entree_fluide</a>&amp; cl =(<span class="keyword">const</span> <a class="code" href="classDirichlet__entree__fluide.html" title="classe Dirichlet_entree_fluide Cette classe represente une condition aux limite imposant une grandeur...">Dirichlet_entree_fluide</a>&amp;) (la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>());
              <span class="keywordflow">for</span> (<span class="keywordtype">int</span> f = ndeb; f &lt; nfin; f++)
                {
                  aef = <a class="code" href="classT__It__VDF__Elem.html#ae1fc0535bed05926b790dd398811b036">flux_evaluateur</a>.coeffs_face_bloc_vitesse(inco, f, cl, ndeb);
                  <span class="keywordflow">if</span> ( (e1 = <a class="code" href="classT__It__VDF__Elem.html#a1c6facf0ffcf4a16a8d81d090a7fc1e8">elem</a>(f, 0)) &gt; -1) matrice(e1, f) += aef;
                  <span class="keywordflow">if</span> ( (e2 = <a class="code" href="classT__It__VDF__Elem.html#a1c6facf0ffcf4a16a8d81d090a7fc1e8">elem</a>(f, 1)) &gt; -1) matrice(e2, f) -= aef;
                }
            }
          <span class="keywordflow">break</span>;
        <span class="keywordflow">case</span> <a class="code" href="Iterateur__PolyMAC__base_8h.html#adda1d69a86f9e3be7366c5f4c6ace649a497d92e00f36c1c7ec874c0a318db91e" title="Dirichlet_paroi_fixe.">paroi_fixe</a> :
          <span class="keywordflow">if</span> (<a class="code" href="classT__It__VDF__Elem.html#ae1fc0535bed05926b790dd398811b036">flux_evaluateur</a>.calculer_flux_faces_paroi_fixe())
            {
              <span class="keyword">const</span> <a class="code" href="classDirichlet__paroi__fixe.html" title="classe Dirichlet_paroi_fixe Represente une paroi immobile dans une equation de type Navier_Stokes...">Dirichlet_paroi_fixe</a>&amp; cl =(<span class="keyword">const</span> <a class="code" href="classDirichlet__paroi__fixe.html" title="classe Dirichlet_paroi_fixe Represente une paroi immobile dans une equation de type Navier_Stokes...">Dirichlet_paroi_fixe</a>&amp;) (la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>());
              <span class="keywordflow">for</span> (<span class="keywordtype">int</span> f = ndeb; f &lt; nfin; f++)
                {
                  aef = <a class="code" href="classT__It__VDF__Elem.html#ae1fc0535bed05926b790dd398811b036">flux_evaluateur</a>.coeffs_face_bloc_vitesse(inco, f, cl, ndeb);
                  <span class="keywordflow">if</span> ( (e1 = <a class="code" href="classT__It__VDF__Elem.html#a1c6facf0ffcf4a16a8d81d090a7fc1e8">elem</a>(f, 0)) &gt; -1) matrice(e1, f) += aef;
                  <span class="keywordflow">if</span> ( (e2 = <a class="code" href="classT__It__VDF__Elem.html#a1c6facf0ffcf4a16a8d81d090a7fc1e8">elem</a>(f, 1)) &gt; -1) matrice(e2, f) -= aef;
                }
            }
          <span class="keywordflow">break</span>;
        <span class="keywordflow">case</span> <a class="code" href="Iterateur__PolyMAC__base_8h.html#adda1d69a86f9e3be7366c5f4c6ace649acdd1bf461cb105b93d5a9b003ce33141" title="Dirichlet_paroi_defilante.">paroi_defilante</a> :
          <span class="keywordflow">if</span> (<a class="code" href="classT__It__VDF__Elem.html#ae1fc0535bed05926b790dd398811b036">flux_evaluateur</a>.calculer_flux_faces_paroi_defilante())
            {
              <span class="keyword">const</span> <a class="code" href="classDirichlet__paroi__defilante.html" title="classe Dirichlet_paroi_defilante Impose la vitesse de paroi dnas une equation de type Navier_Stokes...">Dirichlet_paroi_defilante</a>&amp; cl =(<span class="keyword">const</span> <a class="code" href="classDirichlet__paroi__defilante.html" title="classe Dirichlet_paroi_defilante Impose la vitesse de paroi dnas une equation de type Navier_Stokes...">Dirichlet_paroi_defilante</a>&amp;) (la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>());
              <span class="keywordflow">for</span> (<span class="keywordtype">int</span> f = ndeb; f &lt; nfin; f++)
                {
                  aef = <a class="code" href="classT__It__VDF__Elem.html#ae1fc0535bed05926b790dd398811b036">flux_evaluateur</a>.coeffs_face_bloc_vitesse(inco, f, cl, ndeb);
                  <span class="keywordflow">if</span> ( (e1 = <a class="code" href="classT__It__VDF__Elem.html#a1c6facf0ffcf4a16a8d81d090a7fc1e8">elem</a>(f, 0)) &gt; -1) matrice(e1, f) += aef;
                  <span class="keywordflow">if</span> ( (e2 = <a class="code" href="classT__It__VDF__Elem.html#a1c6facf0ffcf4a16a8d81d090a7fc1e8">elem</a>(f, 1)) &gt; -1) matrice(e2, f) -= aef;
                }
            }
          <span class="keywordflow">break</span>;
        <span class="keywordflow">case</span> <a class="code" href="classparoi__adiabatique.html">paroi_adiabatique</a> :
          <span class="keywordflow">if</span> (<a class="code" href="classT__It__VDF__Elem.html#ae1fc0535bed05926b790dd398811b036">flux_evaluateur</a>.calculer_flux_faces_paroi_adiabatique())
            {
              <span class="keyword">const</span> <a class="code" href="classNeumann__paroi__adiabatique.html" title="Classe Neumann_paroi_adiabatique Cette condition limite correspond a une paroi adiabatique dans une e...">Neumann_paroi_adiabatique</a>&amp; cl =(<span class="keyword">const</span> <a class="code" href="classNeumann__paroi__adiabatique.html" title="Classe Neumann_paroi_adiabatique Cette condition limite correspond a une paroi adiabatique dans une e...">Neumann_paroi_adiabatique</a>&amp;) (la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>());
              <span class="keywordflow">for</span> (<span class="keywordtype">int</span> f = ndeb; f &lt; nfin; f++)
                {
                  aef = <a class="code" href="classT__It__VDF__Elem.html#ae1fc0535bed05926b790dd398811b036">flux_evaluateur</a>.coeffs_face_bloc_vitesse(inco, f, cl, ndeb);
                  <span class="keywordflow">if</span> ( (e1 = <a class="code" href="classT__It__VDF__Elem.html#a1c6facf0ffcf4a16a8d81d090a7fc1e8">elem</a>(f, 0)) &gt; -1) matrice(e1, f) += aef;
                  <span class="keywordflow">if</span> ( (e2 = <a class="code" href="classT__It__VDF__Elem.html#a1c6facf0ffcf4a16a8d81d090a7fc1e8">elem</a>(f, 1)) &gt; -1) matrice(e2, f) -= aef;
                }
            }
          <span class="keywordflow">break</span>;
        <span class="keywordflow">case</span> <a class="code" href="Iterateur__PolyMAC__base_8h.html#adda1d69a86f9e3be7366c5f4c6ace649af695f3ba17490e07dc3259c85875d8d6" title="Neumann_paroi.">paroi</a> :
          <span class="keywordflow">if</span> (<a class="code" href="classT__It__VDF__Elem.html#ae1fc0535bed05926b790dd398811b036">flux_evaluateur</a>.calculer_flux_faces_paroi())
            {
              <span class="keyword">const</span> <a class="code" href="classNeumann__paroi.html" title="Classe Neumann_paroi Cette condition limite correspond a un flux impose pour l&#39;equation de transport ...">Neumann_paroi</a>&amp; cl =(<span class="keyword">const</span> <a class="code" href="classNeumann__paroi.html" title="Classe Neumann_paroi Cette condition limite correspond a un flux impose pour l&#39;equation de transport ...">Neumann_paroi</a>&amp;) (la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>());
              <span class="keywordflow">for</span> (<span class="keywordtype">int</span> f = ndeb; f &lt; nfin; f++)
                {
                  aef = <a class="code" href="classT__It__VDF__Elem.html#ae1fc0535bed05926b790dd398811b036">flux_evaluateur</a>.coeffs_face_bloc_vitesse(inco, f, cl, ndeb);
                  <span class="keywordflow">if</span> ( (e1 = <a class="code" href="classT__It__VDF__Elem.html#a1c6facf0ffcf4a16a8d81d090a7fc1e8">elem</a>(f, 0)) &gt; -1) matrice(e1, f) += aef;
                  <span class="keywordflow">if</span> ( (e2 = <a class="code" href="classT__It__VDF__Elem.html#a1c6facf0ffcf4a16a8d81d090a7fc1e8">elem</a>(f, 1)) &gt; -1) matrice(e2, f) -= aef;
                }
            }
          <span class="keywordflow">break</span>;
        <span class="keywordflow">case</span> <a class="code" href="Iterateur__PolyMAC__base_8h.html#adda1d69a86f9e3be7366c5f4c6ace649a38f997f881a13a46f2d06012162cf833" title="Echange_externe_impose.">echange_externe_impose</a> :
          <span class="keywordflow">if</span> (<a class="code" href="classT__It__VDF__Elem.html#ae1fc0535bed05926b790dd398811b036">flux_evaluateur</a>.calculer_flux_faces_echange_externe_impose())
            {
              <span class="keyword">const</span> <a class="code" href="classEchange__externe__impose.html" title="Classe Echange_externe_impose: Cette classe represente le cas particulier de la classe Echange_impose...">Echange_externe_impose</a>&amp; cl =(<span class="keyword">const</span> <a class="code" href="classEchange__externe__impose.html" title="Classe Echange_externe_impose: Cette classe represente le cas particulier de la classe Echange_impose...">Echange_externe_impose</a>&amp;) (la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>());
              <span class="keywordtype">int</span> boundary_index=-1;
              <span class="keywordflow">if</span> (<a class="code" href="classIterateur__VDF__base.html#af3f849b64b981589db0fd68c83893246">la_zone</a>.<a class="code" href="classRef__Zone__VDF.html#a84151da4db745d02791d6246e3682b67">valeur</a>().<a class="code" href="classZone__VF.html#a45e54622328fcf035535edf96172c1e4" title="renvoie la ieme frontiere_discrete.">front_VF</a>(num_cl).<a class="code" href="classFrontiere__dis__base.html#a5a7eb46dc3af8a7d4225adc1814845d8" title="Renvoie le nom de la frontiere geometrique.">le_nom</a>() == frontiere_dis.<a class="code" href="classFrontiere__dis__base.html#a5a7eb46dc3af8a7d4225adc1814845d8" title="Renvoie le nom de la frontiere geometrique.">le_nom</a>())
                boundary_index=num_cl;

              <span class="keywordflow">for</span> (<span class="keywordtype">int</span> f = ndeb; f &lt; nfin; f++)
                {
                  <span class="keywordtype">int</span> local_face=<a class="code" href="classIterateur__VDF__base.html#af3f849b64b981589db0fd68c83893246">la_zone</a>.<a class="code" href="classRef__Zone__VDF.html#a84151da4db745d02791d6246e3682b67">valeur</a>().<a class="code" href="classZone__VF.html#a45e54622328fcf035535edf96172c1e4" title="renvoie la ieme frontiere_discrete.">front_VF</a>(boundary_index).<a class="code" href="classFront__VF.html#a8b34de011799509c228146cea1abaaab">num_local_face</a>(f);
                  aef = <a class="code" href="classT__It__VDF__Elem.html#ae1fc0535bed05926b790dd398811b036">flux_evaluateur</a>.coeffs_face_bloc_vitesse(inco, boundary_index, f, local_face, cl, ndeb);
                  <span class="keywordflow">if</span> ( (e1 = <a class="code" href="classT__It__VDF__Elem.html#a1c6facf0ffcf4a16a8d81d090a7fc1e8">elem</a>(f, 0)) &gt; -1) matrice(e1, f) += aef;
                  <span class="keywordflow">if</span> ( (e2 = <a class="code" href="classT__It__VDF__Elem.html#a1c6facf0ffcf4a16a8d81d090a7fc1e8">elem</a>(f, 1)) &gt; -1) matrice(e1, f) -= aef;
                }
            }
          <span class="keywordflow">break</span>;
        <span class="keywordflow">case</span> <a class="code" href="Iterateur__PolyMAC__base_8h.html#adda1d69a86f9e3be7366c5f4c6ace649a9201b83c6fe44d3928abbe5f73364323" title="Echange_global_impose.">echange_global_impose</a> :
          <span class="keywordflow">if</span> (<a class="code" href="classT__It__VDF__Elem.html#ae1fc0535bed05926b790dd398811b036">flux_evaluateur</a>.calculer_flux_faces_echange_global_impose())
            {
              <span class="keyword">const</span> <a class="code" href="classEchange__global__impose.html" title="Classe Echange_global_impose Cette classe represente le cas particulier de la classe Echange_impose_b...">Echange_global_impose</a>&amp; cl =(<span class="keyword">const</span> <a class="code" href="classEchange__global__impose.html" title="Classe Echange_global_impose Cette classe represente le cas particulier de la classe Echange_impose_b...">Echange_global_impose</a>&amp;) (la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>());
              <span class="keywordflow">for</span> (<span class="keywordtype">int</span> f = ndeb; f &lt; nfin; f++)
                {
                  aef = <a class="code" href="classT__It__VDF__Elem.html#ae1fc0535bed05926b790dd398811b036">flux_evaluateur</a>.coeffs_face_bloc_vitesse(inco, f, cl, ndeb);
                  <span class="keywordflow">if</span> ( (e1 = <a class="code" href="classT__It__VDF__Elem.html#a1c6facf0ffcf4a16a8d81d090a7fc1e8">elem</a>(f, 0)) &gt; -1) matrice(e1, f) += aef;
                  <span class="keywordflow">if</span> ( (e2 = <a class="code" href="classT__It__VDF__Elem.html#a1c6facf0ffcf4a16a8d81d090a7fc1e8">elem</a>(f, 1)) &gt; -1) matrice(e2, f) -= aef;
                }
            }
          <span class="keywordflow">break</span>;
        <span class="keywordflow">case</span> <a class="code" href="Iterateur__PolyMAC__base_8h.html#adda1d69a86f9e3be7366c5f4c6ace649adbce3cca9532937c741ae3ac77dc2d54" title="NSCBC.">nscbc</a> :
          <span class="keywordflow">if</span> (<a class="code" href="classT__It__VDF__Elem.html#ae1fc0535bed05926b790dd398811b036">flux_evaluateur</a>.calculer_flux_faces_NSCBC())
            {
              <span class="keyword">const</span> <a class="code" href="classNSCBC.html" title="classe">NSCBC</a>&amp; cl =(<span class="keyword">const</span> <a class="code" href="classNSCBC.html" title="classe">NSCBC</a>&amp;) (la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>());
              <span class="keywordflow">for</span> (<span class="keywordtype">int</span> f = ndeb; f &lt; nfin; f++)
                {
                  aef = <a class="code" href="classT__It__VDF__Elem.html#ae1fc0535bed05926b790dd398811b036">flux_evaluateur</a>.coeffs_face_bloc_vitesse(inco, f, cl, ndeb);
                  <span class="keywordflow">if</span> ( (e1 = <a class="code" href="classT__It__VDF__Elem.html#a1c6facf0ffcf4a16a8d81d090a7fc1e8">elem</a>(f, 0)) &gt; -1) matrice(e1, f) += aef;
                  <span class="keywordflow">if</span> ( (e2 = <a class="code" href="classT__It__VDF__Elem.html#a1c6facf0ffcf4a16a8d81d090a7fc1e8">elem</a>(f, 1)) &gt; -1) matrice(e2, f) -= aef;
                }
            }
          <span class="keywordflow">break</span>;
        <span class="keywordflow">case</span> <a class="code" href="Iterateur__PolyMAC__base_8h.html#adda1d69a86f9e3be7366c5f4c6ace649ab83c671c148d8664c5c87f343d2ab9fd" title="periodique">periodique</a> :
          <span class="keywordflow">if</span> (<a class="code" href="classT__It__VDF__Elem.html#ae1fc0535bed05926b790dd398811b036">flux_evaluateur</a>.calculer_flux_faces_periodique())
            {
              <span class="keyword">const</span> <a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>&amp; cl =(<span class="keyword">const</span> <a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>&amp;) (la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>());
              <span class="keywordflow">for</span> (<span class="keywordtype">int</span> f = ndeb; f &lt; nfin; f++)
                {
                  aef = <a class="code" href="classT__It__VDF__Elem.html#ae1fc0535bed05926b790dd398811b036">flux_evaluateur</a>.coeffs_face_bloc_vitesse(inco, f, cl, ndeb);
                  <span class="keywordflow">if</span> ( (e1 = <a class="code" href="classT__It__VDF__Elem.html#a1c6facf0ffcf4a16a8d81d090a7fc1e8">elem</a>(f, 0)) &gt; -1)
                    {
                      <span class="keywordflow">if</span> ( f &lt; (ndeb+frontiere_dis.<a class="code" href="classFront__VF.html#a341e2fcb5117b96e745fd7078ba86bab" title="Nombre de faces reelles du bord.">nb_faces</a>()/2) )
                        matrice(e1, f) += aef;
                    }
                  <span class="keywordflow">if</span> ( (e2 = <a class="code" href="classT__It__VDF__Elem.html#a1c6facf0ffcf4a16a8d81d090a7fc1e8">elem</a>(f, 1)) &gt; -1)
                    {
                      <span class="keywordflow">if</span> ( (ndeb+frontiere_dis.<a class="code" href="classFront__VF.html#a341e2fcb5117b96e745fd7078ba86bab" title="Nombre de faces reelles du bord.">nb_faces</a>()/2) &lt;= f )
                        matrice(e2, f) -= aef;
                    }
                }
            }
          <span class="keywordflow">break</span>;
        <span class="keywordflow">default</span> :
          <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;On ne reconnait pas la condition limite : &quot;</span> &lt;&lt; la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>();
          <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">exit</a>();
          <span class="keywordflow">break</span>;
        }

    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a5ab524280db69182287cbe3f25666f9b"></a><!-- doxytag: member="T_It_VDF_Elem::ajouter_contribution_interne" ref="a5ab524280db69182287cbe3f25666f9b" args="(const DoubleTab &amp;, Matrice_Morse &amp;) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class _TYPE_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classT__It__VDF__Elem.html">T_It_VDF_Elem</a>&lt; _TYPE_ &gt;::ajouter_contribution_interne </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>inco</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;&#160;</td>
          <td class="paramname"><em>matrice</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="T__It__VDF__Elem_8h_source.html#l01480">1480</a> of file <a class="el" href="T__It__VDF__Elem_8h_source.html">T_It_VDF_Elem.h</a>.</p>

<p>References <a class="el" href="DoubleVect_8h_source.html#l00164">DoubleVect::line_size()</a>, <a class="el" href="Zone__VF_8h_source.html#l00519">Zone_VF::nb_faces()</a>, and <a class="el" href="Zone__VF_8h_source.html#l00512">Zone_VF::premiere_face_int()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">const</span> <span class="keywordtype">int</span> ncomp = inco.<a class="code" href="classDoubleVect.html#ab02d01cd1bdab66fbd66f9a47cc29e10">line_size</a>();
  <span class="keyword">const</span> <a class="code" href="classZone__VDF.html" title="class Zone_VDF Classe instanciable qui derive de Zone_VF. Cette classe contient les informations geom...">Zone_VDF</a>&amp; zone_VDF = <a class="code" href="classIterateur__VDF__base.html#af3f849b64b981589db0fd68c83893246">la_zone</a>.<a class="code" href="classRef__Zone__VDF.html#a84151da4db745d02791d6246e3682b67">valeur</a>();
  <span class="keywordtype">int</span> face,i;
  <a class="code" href="classDoubleVect.html">DoubleVect</a> aii(ncomp), ajj(ncomp);
  <span class="keywordtype">int</span> elem1,elem2;
  <span class="keywordtype">int</span> ndeb=zone_VDF.<a class="code" href="classZone__VF.html#a12869806fa4834aca8f2964e16509dfd" title="une face est interne ssi elle separe deux elements. renvoie le numero de la premiere face interne...">premiere_face_int</a>();
  <span class="keywordtype">int</span> nfin=zone_VDF.<a class="code" href="classZone__VF.html#aede27992d9f2eedd52c24d4a80ff7ffb" title="renvoie le nombre global de faces.">nb_faces</a>();
  <span class="keywordflow">for</span> (face=ndeb; face&lt;nfin; face++)
    {
      elem1 = <a class="code" href="classT__It__VDF__Elem.html#a1c6facf0ffcf4a16a8d81d090a7fc1e8">elem</a>(face,0);
      elem2 = <a class="code" href="classT__It__VDF__Elem.html#a1c6facf0ffcf4a16a8d81d090a7fc1e8">elem</a>(face,1);
      <a class="code" href="classT__It__VDF__Elem.html#ae1fc0535bed05926b790dd398811b036">flux_evaluateur</a>.coeffs_faces_interne(face, aii, ajj);
      <span class="keywordflow">for</span> (i=0; i&lt;ncomp; i++)
        {
          <span class="keywordtype">int</span> i0=elem1*ncomp+i,j0=elem2*ncomp+i;
          matrice(i0,i0)+=aii(i) ;
          matrice(i0,j0)-=ajj(i) ;
          matrice(j0,j0)+=ajj(i) ;
          matrice(j0,i0)-=aii(i) ;
        }
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a961776f7de2967cf58f1cc8e51ef0463"></a><!-- doxytag: member="T_It_VDF_Elem::ajouter_contribution_interne_vitesse" ref="a961776f7de2967cf58f1cc8e51ef0463" args="(const DoubleTab &amp;, Matrice_Morse &amp;) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class _TYPE_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classT__It__VDF__Elem.html">T_It_VDF_Elem</a>&lt; _TYPE_ &gt;::ajouter_contribution_interne_vitesse </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>inco</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;&#160;</td>
          <td class="paramname"><em>matrice</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="T__It__VDF__Elem_8h_source.html#l01505">1505</a> of file <a class="el" href="T__It__VDF__Elem_8h_source.html">T_It_VDF_Elem.h</a>.</p>

<p>References <a class="el" href="Zone__VF_8h_source.html#l00519">Zone_VF::nb_faces()</a>, and <a class="el" href="Zone__VF_8h_source.html#l00512">Zone_VF::premiere_face_int()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">const</span> <a class="code" href="classZone__VDF.html" title="class Zone_VDF Classe instanciable qui derive de Zone_VF. Cette classe contient les informations geom...">Zone_VDF</a>&amp; zone_VDF = <a class="code" href="classIterateur__VDF__base.html#af3f849b64b981589db0fd68c83893246">la_zone</a>.<a class="code" href="classRef__Zone__VDF.html#a84151da4db745d02791d6246e3682b67">valeur</a>();
  <span class="keywordtype">double</span> aef = 0;
  <span class="keyword">const</span> <span class="keywordtype">int</span> ndeb = zone_VDF.<a class="code" href="classZone__VF.html#a12869806fa4834aca8f2964e16509dfd" title="une face est interne ssi elle separe deux elements. renvoie le numero de la premiere face interne...">premiere_face_int</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> nfin = zone_VDF.<a class="code" href="classZone__VF.html#aede27992d9f2eedd52c24d4a80ff7ffb" title="renvoie le nombre global de faces.">nb_faces</a>();
  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> f = ndeb; f &lt; nfin; f++)
    {
      <span class="keyword">const</span> <span class="keywordtype">int</span> e1 = <a class="code" href="classT__It__VDF__Elem.html#a1c6facf0ffcf4a16a8d81d090a7fc1e8">elem</a>(f, 0);
      <span class="keyword">const</span> <span class="keywordtype">int</span> e2 = <a class="code" href="classT__It__VDF__Elem.html#a1c6facf0ffcf4a16a8d81d090a7fc1e8">elem</a>(f, 1);
      aef = <a class="code" href="classT__It__VDF__Elem.html#ae1fc0535bed05926b790dd398811b036">flux_evaluateur</a>.coeffs_faces_interne_bloc_vitesse(inco, f);
      matrice(e1, f) += aef;
      matrice(e2, f) -= aef;
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="ad4071d7d498524ba686fdf3a3fe2fd0d"></a><!-- doxytag: member="T_It_VDF_Elem::ajouter_contribution_vitesse" ref="ad4071d7d498524ba686fdf3a3fe2fd0d" args="(const DoubleTab &amp;, Matrice_Morse &amp;) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class _TYPE_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classT__It__VDF__Elem.html">T_It_VDF_Elem</a>&lt; _TYPE_ &gt;::ajouter_contribution_vitesse </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>inco</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;&#160;</td>
          <td class="paramname"><em>matrice</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implements <a class="el" href="classIterateur__VDF__base.html#a7234f402cb828834026b69df5e9e65b4">Iterateur_VDF_base</a>.</p>

<p>Definition at line <a class="el" href="T__It__VDF__Elem_8h_source.html#l01239">1239</a> of file <a class="el" href="T__It__VDF__Elem_8h_source.html">T_It_VDF_Elem.h</a>.</p>

<p>References <a class="el" href="DoubleTab_8h_source.html#l00243">DoubleTab::dimension()</a>, and <a class="el" href="DoubleTab_8h_source.html#l00264">DoubleTab::nb_dim()</a>.</p>
<div class="fragment"><pre class="fragment">{
  ((_TYPE_&amp;) <a class="code" href="classT__It__VDF__Elem.html#ae1fc0535bed05926b790dd398811b036">flux_evaluateur</a>).mettre_a_jour();
  assert(inco.<a class="code" href="classDoubleTab.html#ae6dda48778e7107e1beb723beef1f75b" title="Returns the number of dimensions of the array (&gt;= 1)">nb_dim</a>() &lt; 3);
  assert(<a class="code" href="classIterateur__VDF__base.html#a7434e3782850ec5f73ae8c6e9772f94c">la_zcl</a>.<a class="code" href="classO__U__Ptr.html#a16f216b2d169e885876419182658ddcc" title="Renvoie 1 si le pointeur est non_nul Renvoie 0 sinon.">non_nul</a>());
  assert(<a class="code" href="classIterateur__VDF__base.html#af3f849b64b981589db0fd68c83893246">la_zone</a>.<a class="code" href="classO__U__Ptr.html#a16f216b2d169e885876419182658ddcc" title="Renvoie 1 si le pointeur est non_nul Renvoie 0 sinon.">non_nul</a>());
  <span class="keywordtype">int</span> ncomp=1;
  <span class="keywordflow">if</span> (inco.<a class="code" href="classDoubleTab.html#ae6dda48778e7107e1beb723beef1f75b" title="Returns the number of dimensions of the array (&gt;= 1)">nb_dim</a>() == 2)
    ncomp=inco.<a class="code" href="classDoubleTab.html#ac3805e2637a3b880ba2d3e650c69dac4" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(1);
<span class="comment">// DoubleTab&amp; flux_bords=op_base-&gt;flux_bords();</span>
<span class="comment">// flux_bords.resize(la_zone-&gt;nb_faces_bord(),ncomp);</span>
<span class="comment">// flux_bords=0;</span>
  <span class="keywordflow">if</span>( ncomp == 1) <span class="comment">/* cas scalaire */</span>
    {
      <a class="code" href="classT__It__VDF__Elem.html#ae7a38e26b2d63f9d0df4561c73289011">ajouter_contribution_bords_vitesse</a>(inco, matrice);
      <a class="code" href="classT__It__VDF__Elem.html#a961776f7de2967cf58f1cc8e51ef0463">ajouter_contribution_interne_vitesse</a>(inco, matrice);
    }
  <span class="keywordflow">else</span> <span class="comment">/* cas vectoriel */</span>
    {
      <a class="code" href="classProcess.html#a6a4b64571b10f150a70db229b839e881" title="Routine de sortie de Trio-U sur une erreur abort()">abort</a>();
<span class="comment">// ajouter_contribution_bords(inco, matrice, ncomp) ;</span>
<span class="comment">// ajouter_contribution_interne(inco, matrice, ncomp) ;</span>
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a8fc65edb5f401e6e9fac46666467b82d"></a><!-- doxytag: member="T_It_VDF_Elem::ajouter_interne" ref="a8fc65edb5f401e6e9fac46666467b82d" args="(const DoubleTab &amp;, DoubleTab &amp;) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class _TYPE_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDoubleTab.html">DoubleTab</a> &amp; <a class="el" href="classT__It__VDF__Elem.html">T_It_VDF_Elem</a>&lt; _TYPE_ &gt;::ajouter_interne </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>donnee</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>resu</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="T__It__VDF__Elem_8h_source.html#l00731">731</a> of file <a class="el" href="T__It__VDF__Elem_8h_source.html">T_It_VDF_Elem.h</a>.</p>

<p>References <a class="el" href="DoubleVect_8h_source.html#l00164">DoubleVect::line_size()</a>, <a class="el" href="Zone__VF_8h_source.html#l00519">Zone_VF::nb_faces()</a>, and <a class="el" href="Zone__VF_8h_source.html#l00512">Zone_VF::premiere_face_int()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">const</span> <span class="keywordtype">int</span> ncomp = resu.<a class="code" href="classDoubleVect.html#ab02d01cd1bdab66fbd66f9a47cc29e10">line_size</a>();
  <span class="keyword">const</span> <a class="code" href="classZone__VDF.html" title="class Zone_VDF Classe instanciable qui derive de Zone_VF. Cette classe contient les informations geom...">Zone_VDF</a>&amp; zone_VDF = <a class="code" href="classIterateur__VDF__base.html#af3f849b64b981589db0fd68c83893246">la_zone</a>.<a class="code" href="classRef__Zone__VDF.html#a84151da4db745d02791d6246e3682b67">valeur</a>();
  <a class="code" href="classDoubleVect.html">DoubleVect</a> flux(ncomp);
  <span class="keywordtype">int</span> face,k;
  <span class="keywordtype">int</span> elem0,elem1;
  <span class="keywordtype">int</span> ndeb = zone_VDF.<a class="code" href="classZone__VF.html#a12869806fa4834aca8f2964e16509dfd" title="une face est interne ssi elle separe deux elements. renvoie le numero de la premiere face interne...">premiere_face_int</a>();
  <span class="keywordtype">int</span> nfin = zone_VDF.<a class="code" href="classZone__VF.html#aede27992d9f2eedd52c24d4a80ff7ffb" title="renvoie le nombre global de faces.">nb_faces</a>();
  <span class="keywordflow">for</span> (face=ndeb; face&lt;nfin; face++)
    {
      <a class="code" href="classT__It__VDF__Elem.html#ae1fc0535bed05926b790dd398811b036">flux_evaluateur</a>.flux_faces_interne(donnee, face, flux);
      elem0 = <a class="code" href="classT__It__VDF__Elem.html#a1c6facf0ffcf4a16a8d81d090a7fc1e8">elem</a>(face,0);
      elem1 = <a class="code" href="classT__It__VDF__Elem.html#a1c6facf0ffcf4a16a8d81d090a7fc1e8">elem</a>(face,1);
      <span class="keywordflow">for</span> (k=0; k&lt;ncomp; k++)
        {
          resu(elem0,k)+=flux(k);
          resu(elem1,k)-=flux(k);
        }
    }
  <span class="keywordflow">return</span> resu;
}
</pre></div>
</div>
</div>
<a class="anchor" id="aebb1435185a41a57d65bbc647c2cd864"></a><!-- doxytag: member="T_It_VDF_Elem::calculer" ref="aebb1435185a41a57d65bbc647c2cd864" args="(const DoubleTab &amp;, DoubleTab &amp;) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class _TYPE_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDoubleTab.html">DoubleTab</a> &amp; <a class="el" href="classT__It__VDF__Elem.html">T_It_VDF_Elem</a>&lt; _TYPE_ &gt;::calculer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>inco</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>resu</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implements <a class="el" href="classIterateur__VDF__base.html#a03a66be1b760c4022a4e5e8a39a5fcc8">Iterateur_VDF_base</a>.</p>

<p>Definition at line <a class="el" href="T__It__VDF__Elem_8h_source.html#l00754">754</a> of file <a class="el" href="T__It__VDF__Elem_8h_source.html">T_It_VDF_Elem.h</a>.</p>

<p>References <a class="el" href="Faces2_8cpp_source.html#l00152">ajouter()</a>, <a class="el" href="DoubleVect_8cpp_source.html#l01412">operator_egal()</a>, and <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_REAL_ITEMS</a>.</p>
<div class="fragment"><pre class="fragment">{
  <a class="code" href="DoubleVect_8cpp.html#ad0e13908fed9f476adc797982dce010a">operator_egal</a>(resu, 0., <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caab47906d8d2e6c20f8ba32e4acb6edbe0">VECT_REAL_ITEMS</a>);
  <span class="keywordflow">return</span> <a class="code" href="classT__It__VDF__Elem.html#ac8cf5ddb45fc2de559e28ef15e304a07">ajouter</a>(inco,resu);
}
</pre></div>
</div>
</div>
<a class="anchor" id="a854af77a4cce0e2deeff69f4bce88c21"></a><!-- doxytag: member="T_It_VDF_Elem::calculer_flux_bord" ref="a854af77a4cce0e2deeff69f4bce88c21" args="(const DoubleTab &amp;) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class _TYPE_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classT__It__VDF__Elem.html">T_It_VDF_Elem</a>&lt; _TYPE_ &gt;::calculer_flux_bord </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>donnee</em></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="classIterateur__VDF__base.html#ab0aa398038867916516c352ebe1f5b4a">Iterateur_VDF_base</a>.</p>

<p>Definition at line <a class="el" href="T__It__VDF__Elem_8h_source.html#l00467">467</a> of file <a class="el" href="T__It__VDF__Elem_8h_source.html">T_It_VDF_Elem.h</a>.</p>

<p>References <a class="el" href="EntreeSortie_8h_source.html#l00032">Cerr</a>, <a class="el" href="Iterateur__PolyMAC__base_8h_source.html#l00062">echange_externe_impose</a>, <a class="el" href="Iterateur__PolyMAC__base_8h_source.html#l00063">echange_global_impose</a>, <a class="el" href="Iterateur__PolyMAC__base_8h_source.html#l00057">entree_fluide</a>, <a class="el" href="Double_8h_source.html#l00273">est_egal()</a>, <a class="el" href="Process_8cpp_source.html#l00223">Process::exit()</a>, <a class="el" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>, <a class="el" href="Cond__lim_8h_source.html#l00130">Cond_lim::frontiere_dis()</a>, <a class="el" href="Frontiere__dis__base_8cpp_source.html#l00146">Frontiere_dis_base::le_nom()</a>, <a class="el" href="DoubleVect_8h_source.html#l00164">DoubleVect::line_size()</a>, <a class="el" href="DoubleTab_8h_source.html#l00264">DoubleTab::nb_dim()</a>, <a class="el" href="Front__VF_8h_source.html#l00061">Front_VF::nb_faces()</a>, <a class="el" href="Iterateur__PolyMAC__base_8h_source.html#l00065">nscbc</a>, <a class="el" href="Front__VF_8h_source.html#l00071">Front_VF::num_premiere_face()</a>, <a class="el" href="Iterateur__PolyMAC__base_8h_source.html#l00061">paroi</a>, <a class="el" href="Iterateur__PolyMAC__base_8h_source.html#l00059">paroi_defilante</a>, <a class="el" href="Iterateur__PolyMAC__base_8h_source.html#l00058">paroi_fixe</a>, <a class="el" href="Iterateur__PolyMAC__base_8h_source.html#l00064">periodique</a>, <a class="el" href="Cast_8h_source.html#l00059">ref_cast</a>, <a class="el" href="DoubleTab_8cpp_source.html#l00335">DoubleTab::resize()</a>, <a class="el" href="Iterateur__PolyMAC__base_8h_source.html#l00056">sortie_libre</a>, <a class="el" href="Cast_8h_source.html#l00054">sub_type</a>, <a class="el" href="Iterateur__PolyMAC__base_8h_source.html#l00055">symetrie</a>, and <a class="el" href="Cond__lim_8h_source.html#l00031">Deriv_Cond_lim_base::valeur()</a>.</p>
<div class="fragment"><pre class="fragment">{
  ((_TYPE_&amp;) <a class="code" href="classT__It__VDF__Elem.html#ae1fc0535bed05926b790dd398811b036">flux_evaluateur</a>).mettre_a_jour();
  assert(donnee.<a class="code" href="classDoubleTab.html#ae6dda48778e7107e1beb723beef1f75b" title="Returns the number of dimensions of the array (&gt;= 1)">nb_dim</a>() &lt; 3);
  assert(<a class="code" href="classIterateur__VDF__base.html#a7434e3782850ec5f73ae8c6e9772f94c">la_zcl</a>.<a class="code" href="classO__U__Ptr.html#a16f216b2d169e885876419182658ddcc" title="Renvoie 1 si le pointeur est non_nul Renvoie 0 sinon.">non_nul</a>());
  assert(<a class="code" href="classIterateur__VDF__base.html#af3f849b64b981589db0fd68c83893246">la_zone</a>.<a class="code" href="classO__U__Ptr.html#a16f216b2d169e885876419182658ddcc" title="Renvoie 1 si le pointeur est non_nul Renvoie 0 sinon.">non_nul</a>());
  <span class="keyword">const</span> <span class="keywordtype">int</span> ncomp = donnee.<a class="code" href="classDoubleVect.html#ab02d01cd1bdab66fbd66f9a47cc29e10">line_size</a>();
  <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; flux_bords=<a class="code" href="classIterateur__VDF__base.html#afb3094769ccf45ba34cbab5b80725636">op_base</a>-&gt;flux_bords();
  flux_bords.<a class="code" href="classDoubleTab.html#ae83b4d31205c53d9c8d2b43da178ce75" title="Change la taille du vecteur (identique a resize_array() pour le traitement des anciennes valeurs et d...">resize</a>(<a class="code" href="classIterateur__VDF__base.html#af3f849b64b981589db0fd68c83893246">la_zone</a>-&gt;nb_faces_bord(),ncomp);
  flux_bords=0;

  <span class="keywordflow">if</span>( ncomp != 1) <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">Process ::exit</a>();<span class="comment">/* cas scalaire */</span>


  <span class="keywordtype">int</span> ndeb, nfin;
  <span class="keywordtype">int</span> face;
  <span class="keywordtype">int</span> num_cl=0;
  <span class="keywordtype">double</span> flux;
  <span class="keywordtype">int</span> nb_front_Cl=<a class="code" href="classIterateur__VDF__base.html#af3f849b64b981589db0fd68c83893246">la_zone</a>-&gt;nb_front_Cl();
  <span class="keywordflow">for</span> (; num_cl&lt;nb_front_Cl; num_cl++)
    {
      <span class="comment">/* pour chaque Condition Limite on regarde son type */</span>
      <span class="keyword">const</span> <a class="code" href="classCond__lim.html" title="classe Cond_lim Classe generique servant a representer n&#39;importe quelle classe derivee de la classe C...">Cond_lim</a>&amp; la_cl = <a class="code" href="classIterateur__VDF__base.html#a7434e3782850ec5f73ae8c6e9772f94c">la_zcl</a>-&gt;les_conditions_limites(num_cl);
      <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp; frontiere_dis = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>,la_cl.<a class="code" href="classCond__lim.html#a5b2d24809cee07727006a891d4ce8d22" title="Appel a l&#39;objet sous-jacent Renvoie la frontiere discretisee associee a la condition aux limites...">frontiere_dis</a>());
      ndeb = frontiere_dis.<a class="code" href="classFront__VF.html#a4986f0c65653fe9eb40bbbff5a97bf16" title="Numero de la premiere face du bord dans la liste des faces.">num_premiere_face</a>();
      nfin = ndeb + frontiere_dis.<a class="code" href="classFront__VF.html#a341e2fcb5117b96e745fd7078ba86bab" title="Nombre de faces reelles du bord.">nb_faces</a>();
      <span class="comment">/* Test en bidim axi */</span>
      <span class="keywordflow">if</span> (<a class="code" href="classObjet__U.html#a9a47c1add9760324894500792c17a178">bidim_axi</a> &amp;&amp; !<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classSymetrie.html" title="classe Symetrie Sur les faces de symetrie on a les proprietes suivantes: - composante normale de la v...">Symetrie</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>()))
        {
          <span class="keywordflow">if</span> (nfin&gt;ndeb &amp;&amp; <a class="code" href="Double_8h.html#ac86f5f350b0f95fd8c34b0ac8d720f6f">est_egal</a>(<a class="code" href="classIterateur__VDF__base.html#af3f849b64b981589db0fd68c83893246">la_zone</a>.<a class="code" href="classRef__Zone__VDF.html#a84151da4db745d02791d6246e3682b67">valeur</a>().<a class="code" href="classZone__VF.html#a40c3382b189a4fc508cf1c3e37b04b21">face_surfaces</a>()[ndeb],0))
            {
              <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Error in the definition of the boundary conditions.&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
              <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;The axis of revolution for this 2D calculation is along Y.&quot;</span> &lt;&lt; finl;
              <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;So you must specify symmetry boundary condition (symetrie keyword) for the boundary &quot;</span> &lt;&lt; frontiere_dis.<a class="code" href="classFrontiere__dis__base.html#a5a7eb46dc3af8a7d4225adc1814845d8" title="Renvoie le nom de la frontiere geometrique.">le_nom</a>() &lt;&lt; finl;
              <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">exit</a>();
            }
        }
      <span class="keywordflow">switch</span>(<a class="code" href="classIterateur__VDF__base.html#ae7e13026a533fe31c54526a7ba7bbaaf">type_cl</a>(la_cl))
        {
        <span class="keywordflow">case</span> <a class="code" href="Iterateur__PolyMAC__base_8h.html#adda1d69a86f9e3be7366c5f4c6ace649ac938491055e13993f3eed68c989f90b0" title="Symetrie.">symetrie</a> :
          <span class="keywordflow">if</span> (flux_evaluateur.calculer_flux_faces_symetrie())
            {
              <span class="keyword">const</span> <a class="code" href="classSymetrie.html" title="classe Symetrie Sur les faces de symetrie on a les proprietes suivantes: - composante normale de la v...">Symetrie</a>&amp; cl =(<span class="keyword">const</span> <a class="code" href="classSymetrie.html" title="classe Symetrie Sur les faces de symetrie on a les proprietes suivantes: - composante normale de la v...">Symetrie</a>&amp;) (la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>());
              <span class="keywordflow">for</span> (face=ndeb; face&lt;nfin; face++)
                {
                  flux = flux_evaluateur.flux_face(donnee, face, cl, ndeb);
                  <span class="keywordflow">if</span> ( (<a class="code" href="classT__It__VDF__Elem.html#a1c6facf0ffcf4a16a8d81d090a7fc1e8">elem</a>(face,0)) &gt; -1)
                    {
                      flux_bords(face,0)+=flux;
                    }
                  <span class="keywordflow">if</span> ( (<a class="code" href="classT__It__VDF__Elem.html#a1c6facf0ffcf4a16a8d81d090a7fc1e8">elem</a>(face,1)) &gt; -1)
                    {
                      flux_bords(face,0)-=flux;
                    }
                }
            }
          <span class="keywordflow">break</span>;
        <span class="keywordflow">case</span> <a class="code" href="Iterateur__PolyMAC__base_8h.html#adda1d69a86f9e3be7366c5f4c6ace649ac4317ef27513bbab3cd0ccfd0d9ed199" title="Neumann_sortie_libre ou derivees.">sortie_libre</a> :
          <span class="keywordflow">if</span> (flux_evaluateur.calculer_flux_faces_sortie_libre())
            {
              <span class="keyword">const</span> <a class="code" href="classNeumann__sortie__libre.html" title="classe Neumann_sortie_libre Cette classe represente une frontiere ouverte sans vitesse imposee Pour l...">Neumann_sortie_libre</a>&amp; cl =(<span class="keyword">const</span> <a class="code" href="classNeumann__sortie__libre.html" title="classe Neumann_sortie_libre Cette classe represente une frontiere ouverte sans vitesse imposee Pour l...">Neumann_sortie_libre</a>&amp;) (la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>());
              <span class="keywordflow">for</span> (face=ndeb; face&lt;nfin; face++)
                {
                  flux = flux_evaluateur.flux_face(donnee, face, cl, ndeb);
                  <span class="keywordflow">if</span> ( (<a class="code" href="classT__It__VDF__Elem.html#a1c6facf0ffcf4a16a8d81d090a7fc1e8">elem</a>(face,0)) &gt; -1)
                    {
                      flux_bords(face,0)+=flux;
                    }
                  <span class="keywordflow">if</span> ( (<a class="code" href="classT__It__VDF__Elem.html#a1c6facf0ffcf4a16a8d81d090a7fc1e8">elem</a>(face,1)) &gt; -1)
                    {
                      flux_bords(face,0)-=flux;
                    }
                }
            }
          <span class="keywordflow">break</span>;
        <span class="keywordflow">case</span> <a class="code" href="Iterateur__PolyMAC__base_8h.html#adda1d69a86f9e3be7366c5f4c6ace649a594fd60a4576f47654eed7df53dee9be" title="Dirichlet_entree_fluide.">entree_fluide</a> :
          <span class="keywordflow">if</span> (flux_evaluateur.calculer_flux_faces_entree_fluide())
            {
              <span class="keyword">const</span> <a class="code" href="classDirichlet__entree__fluide.html" title="classe Dirichlet_entree_fluide Cette classe represente une condition aux limite imposant une grandeur...">Dirichlet_entree_fluide</a>&amp; cl =(<span class="keyword">const</span> <a class="code" href="classDirichlet__entree__fluide.html" title="classe Dirichlet_entree_fluide Cette classe represente une condition aux limite imposant une grandeur...">Dirichlet_entree_fluide</a>&amp;) (la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>());
              <span class="keywordflow">for</span> (face=ndeb; face&lt;nfin; face++)
                {
                  flux = flux_evaluateur.flux_face(donnee, face, cl, ndeb);
                  <span class="keywordflow">if</span> ( (<a class="code" href="classT__It__VDF__Elem.html#a1c6facf0ffcf4a16a8d81d090a7fc1e8">elem</a>(face,0)) &gt; -1)
                    {
                      flux_bords(face,0)+=flux;
                    }
                  <span class="keywordflow">if</span> ( (<a class="code" href="classT__It__VDF__Elem.html#a1c6facf0ffcf4a16a8d81d090a7fc1e8">elem</a>(face,1)) &gt; -1)
                    {
                      flux_bords(face,0)-=flux;
                    }
                }
            }
          <span class="keywordflow">break</span>;
        <span class="keywordflow">case</span> <a class="code" href="Iterateur__PolyMAC__base_8h.html#adda1d69a86f9e3be7366c5f4c6ace649a497d92e00f36c1c7ec874c0a318db91e" title="Dirichlet_paroi_fixe.">paroi_fixe</a> :
          <span class="keywordflow">if</span> (flux_evaluateur.calculer_flux_faces_paroi_fixe())
            {
              <span class="keyword">const</span> <a class="code" href="classDirichlet__paroi__fixe.html" title="classe Dirichlet_paroi_fixe Represente une paroi immobile dans une equation de type Navier_Stokes...">Dirichlet_paroi_fixe</a>&amp; cl =(<span class="keyword">const</span> <a class="code" href="classDirichlet__paroi__fixe.html" title="classe Dirichlet_paroi_fixe Represente une paroi immobile dans une equation de type Navier_Stokes...">Dirichlet_paroi_fixe</a>&amp;) (la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>());
              <span class="keywordflow">for</span> (face=ndeb; face&lt;nfin; face++)
                {
                  flux = flux_evaluateur.flux_face(donnee, face, cl, ndeb);
                  <span class="keywordflow">if</span> ( (<a class="code" href="classT__It__VDF__Elem.html#a1c6facf0ffcf4a16a8d81d090a7fc1e8">elem</a>(face,0)) &gt; -1)
                    {
                      flux_bords(face,0)+=flux;
                    }
                  <span class="keywordflow">if</span> ( (<a class="code" href="classT__It__VDF__Elem.html#a1c6facf0ffcf4a16a8d81d090a7fc1e8">elem</a>(face,1)) &gt; -1)
                    {
                      flux_bords(face,0)-=flux;
                    }
                }
            }
          <span class="keywordflow">break</span>;
        <span class="keywordflow">case</span> <a class="code" href="Iterateur__PolyMAC__base_8h.html#adda1d69a86f9e3be7366c5f4c6ace649acdd1bf461cb105b93d5a9b003ce33141" title="Dirichlet_paroi_defilante.">paroi_defilante</a> :
          <span class="keywordflow">if</span> (flux_evaluateur.calculer_flux_faces_paroi_defilante())
            {
              <span class="keyword">const</span> <a class="code" href="classDirichlet__paroi__defilante.html" title="classe Dirichlet_paroi_defilante Impose la vitesse de paroi dnas une equation de type Navier_Stokes...">Dirichlet_paroi_defilante</a>&amp; cl =(<span class="keyword">const</span> <a class="code" href="classDirichlet__paroi__defilante.html" title="classe Dirichlet_paroi_defilante Impose la vitesse de paroi dnas une equation de type Navier_Stokes...">Dirichlet_paroi_defilante</a>&amp;) (la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>());
              <span class="keywordflow">for</span> (face=ndeb; face&lt;nfin; face++)
                {
                  flux = flux_evaluateur.flux_face(donnee, face, cl, ndeb);
                  <span class="keywordflow">if</span> ( (<a class="code" href="classT__It__VDF__Elem.html#a1c6facf0ffcf4a16a8d81d090a7fc1e8">elem</a>(face,0)) &gt; -1)
                    {
                      flux_bords(face,0)+=flux;
                    }
                  <span class="keywordflow">if</span> ( (<a class="code" href="classT__It__VDF__Elem.html#a1c6facf0ffcf4a16a8d81d090a7fc1e8">elem</a>(face,1)) &gt; -1)
                    {
                      flux_bords(face,0)-=flux;
                    }
                }
            }
          <span class="keywordflow">break</span>;
        <span class="keywordflow">case</span> <a class="code" href="classparoi__adiabatique.html">paroi_adiabatique</a> :
          <span class="keywordflow">if</span> (flux_evaluateur.calculer_flux_faces_paroi_adiabatique())
            {
              <span class="keyword">const</span> <a class="code" href="classNeumann__paroi__adiabatique.html" title="Classe Neumann_paroi_adiabatique Cette condition limite correspond a une paroi adiabatique dans une e...">Neumann_paroi_adiabatique</a>&amp; cl =(<span class="keyword">const</span> <a class="code" href="classNeumann__paroi__adiabatique.html" title="Classe Neumann_paroi_adiabatique Cette condition limite correspond a une paroi adiabatique dans une e...">Neumann_paroi_adiabatique</a>&amp;) (la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>());
              <span class="keywordflow">for</span> (face=ndeb; face&lt;nfin; face++)
                {
                  assert(0);
                  <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">exit</a>();
                  flux = flux_evaluateur.flux_face(donnee, face, cl, ndeb);
                  flux_bords(face,0)+=flux;
                  flux_bords(face,0)-=flux;
                }
            }
          <span class="keywordflow">break</span>;
        <span class="keywordflow">case</span> <a class="code" href="Iterateur__PolyMAC__base_8h.html#adda1d69a86f9e3be7366c5f4c6ace649af695f3ba17490e07dc3259c85875d8d6" title="Neumann_paroi.">paroi</a> :
          <span class="keywordflow">if</span> (flux_evaluateur.calculer_flux_faces_paroi())
            {
              <span class="keyword">const</span> <a class="code" href="classNeumann__paroi.html" title="Classe Neumann_paroi Cette condition limite correspond a un flux impose pour l&#39;equation de transport ...">Neumann_paroi</a>&amp; cl =(<span class="keyword">const</span> <a class="code" href="classNeumann__paroi.html" title="Classe Neumann_paroi Cette condition limite correspond a un flux impose pour l&#39;equation de transport ...">Neumann_paroi</a>&amp;) (la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>());
              <span class="keywordflow">for</span> (face=ndeb; face&lt;nfin; face++)
                {
                  flux = flux_evaluateur.flux_face(donnee, face, cl, ndeb);
                  <span class="keywordflow">if</span> ( (<a class="code" href="classT__It__VDF__Elem.html#a1c6facf0ffcf4a16a8d81d090a7fc1e8">elem</a>(face,0)) &gt; -1)
                    {
                      flux_bords(face,0)+=flux;
                    }
                  <span class="keywordflow">if</span> ( (<a class="code" href="classT__It__VDF__Elem.html#a1c6facf0ffcf4a16a8d81d090a7fc1e8">elem</a>(face,1)) &gt; -1)
                    {
                      flux_bords(face,0)-=flux;
                    }
                }
            }
          <span class="keywordflow">break</span>;
        <span class="keywordflow">case</span> <a class="code" href="Iterateur__PolyMAC__base_8h.html#adda1d69a86f9e3be7366c5f4c6ace649a38f997f881a13a46f2d06012162cf833" title="Echange_externe_impose.">echange_externe_impose</a> :
          <span class="keywordflow">if</span> (flux_evaluateur.calculer_flux_faces_echange_externe_impose())
            {
              <span class="keyword">const</span> <a class="code" href="classEchange__externe__impose.html" title="Classe Echange_externe_impose: Cette classe represente le cas particulier de la classe Echange_impose...">Echange_externe_impose</a>&amp; cl =(<span class="keyword">const</span> <a class="code" href="classEchange__externe__impose.html" title="Classe Echange_externe_impose: Cette classe represente le cas particulier de la classe Echange_impose...">Echange_externe_impose</a>&amp;) (la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>());

              <span class="keywordtype">int</span> boundary_index=-1;
              <span class="keywordflow">if</span> (<a class="code" href="classIterateur__VDF__base.html#af3f849b64b981589db0fd68c83893246">la_zone</a>.<a class="code" href="classRef__Zone__VDF.html#a84151da4db745d02791d6246e3682b67">valeur</a>().<a class="code" href="classZone__VF.html#a45e54622328fcf035535edf96172c1e4" title="renvoie la ieme frontiere_discrete.">front_VF</a>(num_cl).<a class="code" href="classFrontiere__dis__base.html#a5a7eb46dc3af8a7d4225adc1814845d8" title="Renvoie le nom de la frontiere geometrique.">le_nom</a>() == frontiere_dis.<a class="code" href="classFrontiere__dis__base.html#a5a7eb46dc3af8a7d4225adc1814845d8" title="Renvoie le nom de la frontiere geometrique.">le_nom</a>())
                boundary_index=num_cl;

              <span class="keywordflow">for</span> (face=ndeb; face&lt;nfin; face++)
                {
                  <span class="keywordtype">int</span> local_face=<a class="code" href="classIterateur__VDF__base.html#af3f849b64b981589db0fd68c83893246">la_zone</a>.<a class="code" href="classRef__Zone__VDF.html#a84151da4db745d02791d6246e3682b67">valeur</a>().<a class="code" href="classZone__VF.html#a45e54622328fcf035535edf96172c1e4" title="renvoie la ieme frontiere_discrete.">front_VF</a>(boundary_index).<a class="code" href="classFront__VF.html#a8b34de011799509c228146cea1abaaab">num_local_face</a>(face);
                  flux = flux_evaluateur.flux_face(donnee, boundary_index,face,local_face, cl, ndeb);
                  <span class="keywordflow">if</span> ( (<a class="code" href="classT__It__VDF__Elem.html#a1c6facf0ffcf4a16a8d81d090a7fc1e8">elem</a>(face,0)) &gt; -1)
                    {
                      flux_bords(face,0)+=flux;
                    }
                  <span class="keywordflow">if</span> ( (<a class="code" href="classT__It__VDF__Elem.html#a1c6facf0ffcf4a16a8d81d090a7fc1e8">elem</a>(face,1)) &gt; -1)
                    {
                      flux_bords(face,0)-=flux;
                    }
                }
            }
          <span class="keywordflow">break</span>;
        <span class="keywordflow">case</span> <a class="code" href="Iterateur__PolyMAC__base_8h.html#adda1d69a86f9e3be7366c5f4c6ace649a9201b83c6fe44d3928abbe5f73364323" title="Echange_global_impose.">echange_global_impose</a> :
          <span class="keywordflow">if</span> (flux_evaluateur.calculer_flux_faces_echange_global_impose())
            {
              <span class="keyword">const</span> <a class="code" href="classEchange__global__impose.html" title="Classe Echange_global_impose Cette classe represente le cas particulier de la classe Echange_impose_b...">Echange_global_impose</a>&amp; cl =(<span class="keyword">const</span> <a class="code" href="classEchange__global__impose.html" title="Classe Echange_global_impose Cette classe represente le cas particulier de la classe Echange_impose_b...">Echange_global_impose</a>&amp;) (la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>());
              <span class="keywordflow">for</span> (face=ndeb; face&lt;nfin; face++)
                {
                  flux = flux_evaluateur.flux_face(donnee, face, cl, ndeb);
                  <span class="keywordflow">if</span> ( (<a class="code" href="classT__It__VDF__Elem.html#a1c6facf0ffcf4a16a8d81d090a7fc1e8">elem</a>(face,0)) &gt; -1)
                    {
                      flux_bords(face,0)+=flux;
                    }
                  <span class="keywordflow">if</span> ( (<a class="code" href="classT__It__VDF__Elem.html#a1c6facf0ffcf4a16a8d81d090a7fc1e8">elem</a>(face,1)) &gt; -1)
                    {
                      flux_bords(face,0)-=flux;
                    }
                }
            }
          <span class="keywordflow">break</span>;
        <span class="keywordflow">case</span> <a class="code" href="Iterateur__PolyMAC__base_8h.html#adda1d69a86f9e3be7366c5f4c6ace649adbce3cca9532937c741ae3ac77dc2d54" title="NSCBC.">nscbc</a> :
          <span class="keywordflow">if</span> (flux_evaluateur.calculer_flux_faces_NSCBC())
            {
              <span class="keyword">const</span> <a class="code" href="classNSCBC.html" title="classe">NSCBC</a>&amp; cl =(<span class="keyword">const</span> <a class="code" href="classNSCBC.html" title="classe">NSCBC</a>&amp;) (la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>());
              <span class="keywordflow">for</span> (face=ndeb; face&lt;nfin; face++)
                {
                  flux = flux_evaluateur.flux_face(donnee, face, cl, ndeb);
                  <span class="keywordflow">if</span> ( (<a class="code" href="classT__It__VDF__Elem.html#a1c6facf0ffcf4a16a8d81d090a7fc1e8">elem</a>(face,0)) &gt; -1)
                    {
                      flux_bords(face,0)+=flux;
                    }
                  <span class="keywordflow">if</span> ( (<a class="code" href="classT__It__VDF__Elem.html#a1c6facf0ffcf4a16a8d81d090a7fc1e8">elem</a>(face,1)) &gt; -1)
                    {
                      flux_bords(face,0)-=flux;
                    }
                }
            }
          <span class="keywordflow">break</span>;
        <span class="keywordflow">case</span> <a class="code" href="Iterateur__PolyMAC__base_8h.html#adda1d69a86f9e3be7366c5f4c6ace649ab83c671c148d8664c5c87f343d2ab9fd" title="periodique">periodique</a> :
          <span class="keywordflow">if</span> (flux_evaluateur.calculer_flux_faces_periodique())
            {
              <span class="keyword">const</span> <a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>&amp; cl =(<span class="keyword">const</span> <a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>&amp;) (la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>());
              <span class="keywordflow">for</span> (face=ndeb; face&lt;nfin; face++)
                {
                  flux = flux_evaluateur.flux_face(donnee, face, cl, ndeb);
                  <span class="keywordflow">if</span> ( (<a class="code" href="classT__It__VDF__Elem.html#a1c6facf0ffcf4a16a8d81d090a7fc1e8">elem</a>(face,0)) &gt; -1)
                    {
                      <span class="keywordflow">if</span> ( face &lt; (ndeb+frontiere_dis.<a class="code" href="classFront__VF.html#a341e2fcb5117b96e745fd7078ba86bab" title="Nombre de faces reelles du bord.">nb_faces</a>()/2) )
                        flux_bords(face,0)+=flux;
                    }
                  <span class="keywordflow">if</span> ( (<a class="code" href="classT__It__VDF__Elem.html#a1c6facf0ffcf4a16a8d81d090a7fc1e8">elem</a>(face,1)) &gt; -1)
                    {
                      <span class="keywordflow">if</span> ( (ndeb+frontiere_dis.<a class="code" href="classFront__VF.html#a341e2fcb5117b96e745fd7078ba86bab" title="Nombre de faces reelles du bord.">nb_faces</a>()/2) &lt;= face )
                        flux_bords(face,0)-=flux;
                    }
                }
            }
          <span class="keywordflow">break</span>;
          <span class="comment">/*</span>
<span class="comment">                                                                            case nouvelle_Cl_VDF :</span>
<span class="comment">                                                                            if (flux_evaluateur.calculer_flux_faces_echange_global_impose()){</span>
<span class="comment">                                                                            const Nouvelle_Cl_VDF&amp; cl =(const Nouvelle_Cl_VDF&amp;) (la_cl.valeur());</span>
<span class="comment">                                                                            for (face=ndeb; face&lt;nfin; face++) {</span>
<span class="comment">                                                                            if ( (int elem1=elem(face,0)) &gt; -1)</span>
<span class="comment">                                                                            resu[elem1]+=flux_evaluateur.flux_face(donnee, face, cl, ndeb);</span>
<span class="comment">                                                                            if ( (int elem2=elem(face,1)) &gt; -1)</span>
<span class="comment">                                                                            resu[elem2]-=flux_evaluateur.flux_face(donnee, face, cl, ndeb);</span>
<span class="comment">                                                                            }</span>
<span class="comment">                                                                            }</span>
<span class="comment">                                                                            break;</span>
<span class="comment">          */</span>
        <span class="keywordflow">default</span> :
          <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;On ne reconnait pas la condition limite : &quot;</span> &lt;&lt; la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>();
          <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Dans T_It_VDF_Elem&lt;_TYPE_&gt;::ajouter_bords&quot;</span>&lt;&lt;<a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
          <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">exit</a>();
          <span class="keywordflow">break</span>;
        }
    }
  <a class="code" href="classT__It__VDF__Elem.html#ab3efc8b1a81fa3eb613f850dc2498edf">modifier_flux</a>() ;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a1d0df1533727ebd0e9f455f466c82b01"></a><!-- doxytag: member="T_It_VDF_Elem::completer_" ref="a1d0df1533727ebd0e9f455f466c82b01" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class _TYPE_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classT__It__VDF__Elem.html">T_It_VDF_Elem</a>&lt; _TYPE_ &gt;::completer_ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implements <a class="el" href="classIterateur__VDF__base.html#a917601f7148361fc1fb8737f14509f95">Iterateur_VDF_base</a>.</p>

<p>Definition at line <a class="el" href="T__It__VDF__Elem_8h_source.html#l00120">120</a> of file <a class="el" href="T__It__VDF__Elem_8h_source.html">T_It_VDF_Elem.h</a>.</p>
<div class="fragment"><pre class="fragment">{
  <a class="code" href="classT__It__VDF__Elem.html#a1c6facf0ffcf4a16a8d81d090a7fc1e8">elem</a>.<a class="code" href="classIntTab.html#ae9ae8fefb1fda4a5c035229ab420a96d" title="fait pointer le tableau sur le vecteur v et en associant la meme structure parallele. Attention, si line_size du vecteur v est different de 1, on cree un tableau bidimensionnel (on peut avoir un vecteur de ce type si on copie un Tab dans un Vect puis on prend une ref sur ce Vect).">ref</a>(<a class="code" href="classIterateur__VDF__base.html#af3f849b64b981589db0fd68c83893246">la_zone</a>-&gt;face_voisins());
}
</pre></div>
</div>
</div>
<a class="anchor" id="ae6c075c1c484a6fb44bc0451c79f6b29"></a><!-- doxytag: member="T_It_VDF_Elem::contribuer_au_second_membre" ref="ae6c075c1c484a6fb44bc0451c79f6b29" args="(DoubleTab &amp;) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class _TYPE_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classT__It__VDF__Elem.html">T_It_VDF_Elem</a>&lt; _TYPE_ &gt;::contribuer_au_second_membre </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>resu</em></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implements <a class="el" href="classIterateur__VDF__base.html#aee6374881144c58f1b338ad3fa9f2dc2">Iterateur_VDF_base</a>.</p>

<p>Definition at line <a class="el" href="T__It__VDF__Elem_8h_source.html#l00900">900</a> of file <a class="el" href="T__It__VDF__Elem_8h_source.html">T_It_VDF_Elem.h</a>.</p>

<p>References <a class="el" href="DoubleTab_8h_source.html#l00264">DoubleTab::nb_dim()</a>.</p>
<div class="fragment"><pre class="fragment">{
  ((_TYPE_&amp;) <a class="code" href="classT__It__VDF__Elem.html#ae1fc0535bed05926b790dd398811b036">flux_evaluateur</a>).mettre_a_jour();
  assert(resu.<a class="code" href="classDoubleTab.html#ae6dda48778e7107e1beb723beef1f75b" title="Returns the number of dimensions of the array (&gt;= 1)">nb_dim</a>() &lt; 3);
  assert(<a class="code" href="classIterateur__VDF__base.html#a7434e3782850ec5f73ae8c6e9772f94c">la_zcl</a>.<a class="code" href="classO__U__Ptr.html#a16f216b2d169e885876419182658ddcc" title="Renvoie 1 si le pointeur est non_nul Renvoie 0 sinon.">non_nul</a>());
  assert(<a class="code" href="classIterateur__VDF__base.html#af3f849b64b981589db0fd68c83893246">la_zone</a>.<a class="code" href="classO__U__Ptr.html#a16f216b2d169e885876419182658ddcc" title="Renvoie 1 si le pointeur est non_nul Renvoie 0 sinon.">non_nul</a>());
  assert(<a class="code" href="classIterateur__VDF__base.html#afb3094769ccf45ba34cbab5b80725636">op_base</a>-&gt;flux_bords().<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>(0)==<a class="code" href="classIterateur__VDF__base.html#af3f849b64b981589db0fd68c83893246">la_zone</a>-&gt;nb_faces_bord()); <span class="comment">/* resize deja fait */</span>
  <a class="code" href="classT__It__VDF__Elem.html#a6d0871f9825679d4ce6382ba88d7d8e6">contribuer_au_second_membre_bords</a>(resu) ;
  <a class="code" href="classT__It__VDF__Elem.html#a67c535d1963fe3f0b19a9e42d515fb10">contribuer_au_second_membre_interne</a>(resu) ;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a6d0871f9825679d4ce6382ba88d7d8e6"></a><!-- doxytag: member="T_It_VDF_Elem::contribuer_au_second_membre_bords" ref="a6d0871f9825679d4ce6382ba88d7d8e6" args="(DoubleTab &amp;) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class _TYPE_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classT__It__VDF__Elem.html">T_It_VDF_Elem</a>&lt; _TYPE_ &gt;::contribuer_au_second_membre_bords </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>resu</em></td><td>)</td>
          <td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>&lt; codage avec flux en <a class="el" href="classDoubleVect.html">DoubleVect</a> auquel on assigne la valeur de la fonction scalaire (pas de codage vectoriel de nscbc) </p>
</p>

<p>Definition at line <a class="el" href="T__It__VDF__Elem_8h_source.html#l00910">910</a> of file <a class="el" href="T__It__VDF__Elem_8h_source.html">T_It_VDF_Elem.h</a>.</p>

<p>References <a class="el" href="EntreeSortie_8h_source.html#l00032">Cerr</a>, <a class="el" href="Iterateur__PolyMAC__base_8h_source.html#l00062">echange_externe_impose</a>, <a class="el" href="Iterateur__PolyMAC__base_8h_source.html#l00063">echange_global_impose</a>, <a class="el" href="Iterateur__PolyMAC__base_8h_source.html#l00057">entree_fluide</a>, <a class="el" href="Cond__lim_8h_source.html#l00130">Cond_lim::frontiere_dis()</a>, <a class="el" href="Frontiere__dis__base_8cpp_source.html#l00146">Frontiere_dis_base::le_nom()</a>, <a class="el" href="DoubleVect_8h_source.html#l00164">DoubleVect::line_size()</a>, <a class="el" href="Front__VF_8h_source.html#l00061">Front_VF::nb_faces()</a>, <a class="el" href="Iterateur__PolyMAC__base_8h_source.html#l00065">nscbc</a>, <a class="el" href="Front__VF_8h_source.html#l00071">Front_VF::num_premiere_face()</a>, <a class="el" href="Iterateur__PolyMAC__base_8h_source.html#l00061">paroi</a>, <a class="el" href="Iterateur__PolyMAC__base_8h_source.html#l00059">paroi_defilante</a>, <a class="el" href="Iterateur__PolyMAC__base_8h_source.html#l00058">paroi_fixe</a>, <a class="el" href="Iterateur__PolyMAC__base_8h_source.html#l00064">periodique</a>, <a class="el" href="Cast_8h_source.html#l00059">ref_cast</a>, <a class="el" href="Iterateur__PolyMAC__base_8h_source.html#l00056">sortie_libre</a>, <a class="el" href="Iterateur__PolyMAC__base_8h_source.html#l00055">symetrie</a>, and <a class="el" href="Cond__lim_8h_source.html#l00031">Deriv_Cond_lim_base::valeur()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">const</span> <span class="keywordtype">int</span> ncomp = resu.<a class="code" href="classDoubleVect.html#ab02d01cd1bdab66fbd66f9a47cc29e10">line_size</a>();
  <span class="keywordtype">int</span> elem1, elem2;
  <span class="keywordtype">int</span> ndeb, nfin;
  <span class="keywordtype">int</span> face,k;
  <a class="code" href="classDoubleVect.html">DoubleVect</a> flux(ncomp);
  <span class="keywordtype">int</span> num_cl=0;
  <span class="keywordtype">int</span> nb_front_Cl=<a class="code" href="classIterateur__VDF__base.html#af3f849b64b981589db0fd68c83893246">la_zone</a>-&gt;nb_front_Cl();
  <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; flux_bords=<a class="code" href="classIterateur__VDF__base.html#afb3094769ccf45ba34cbab5b80725636">op_base</a>-&gt;flux_bords();
  <span class="keywordflow">for</span> (; num_cl&lt;nb_front_Cl; num_cl++)
    {
      <span class="keyword">const</span> <a class="code" href="classCond__lim.html" title="classe Cond_lim Classe generique servant a representer n&#39;importe quelle classe derivee de la classe C...">Cond_lim</a>&amp; la_cl = <a class="code" href="classIterateur__VDF__base.html#a7434e3782850ec5f73ae8c6e9772f94c">la_zcl</a>-&gt;les_conditions_limites(num_cl);
      <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp; frontiere_dis = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>,la_cl.<a class="code" href="classCond__lim.html#a5b2d24809cee07727006a891d4ce8d22" title="Appel a l&#39;objet sous-jacent Renvoie la frontiere discretisee associee a la condition aux limites...">frontiere_dis</a>());
      ndeb = frontiere_dis.<a class="code" href="classFront__VF.html#a4986f0c65653fe9eb40bbbff5a97bf16" title="Numero de la premiere face du bord dans la liste des faces.">num_premiere_face</a>();
      nfin = ndeb + frontiere_dis.<a class="code" href="classFront__VF.html#a341e2fcb5117b96e745fd7078ba86bab" title="Nombre de faces reelles du bord.">nb_faces</a>();
      <span class="keywordflow">switch</span>(<a class="code" href="classIterateur__VDF__base.html#ae7e13026a533fe31c54526a7ba7bbaaf">type_cl</a>(la_cl))
        {
        <span class="keywordflow">case</span> <a class="code" href="Iterateur__PolyMAC__base_8h.html#adda1d69a86f9e3be7366c5f4c6ace649ac938491055e13993f3eed68c989f90b0" title="Symetrie.">symetrie</a> :
          <span class="keywordflow">if</span> (<a class="code" href="classT__It__VDF__Elem.html#ae1fc0535bed05926b790dd398811b036">flux_evaluateur</a>.calculer_flux_faces_symetrie())
            {
              <span class="keyword">const</span> <a class="code" href="classSymetrie.html" title="classe Symetrie Sur les faces de symetrie on a les proprietes suivantes: - composante normale de la v...">Symetrie</a>&amp; cl =(<span class="keyword">const</span> <a class="code" href="classSymetrie.html" title="classe Symetrie Sur les faces de symetrie on a les proprietes suivantes: - composante normale de la v...">Symetrie</a>&amp;) (la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>());
              <span class="keywordflow">for</span> (face=ndeb; face&lt;nfin; face++)
                {
                  <a class="code" href="classT__It__VDF__Elem.html#ae1fc0535bed05926b790dd398811b036">flux_evaluateur</a>.secmem_face(face, cl, ndeb, flux);
                  <span class="keywordflow">if</span> ( (elem1=<a class="code" href="classT__It__VDF__Elem.html#a1c6facf0ffcf4a16a8d81d090a7fc1e8">elem</a>(face,0)) &gt; -1)
                    <span class="keywordflow">for</span> (k=0; k&lt;ncomp; k++)
                      {
                        resu(elem1,k) +=flux(k);
                        flux_bords(face,k)+=flux(k);
                      }
                  <span class="keywordflow">if</span> ( (elem2=<a class="code" href="classT__It__VDF__Elem.html#a1c6facf0ffcf4a16a8d81d090a7fc1e8">elem</a>(face,1)) &gt; -1)
                    <span class="keywordflow">for</span> (k=0; k&lt;ncomp; k++)
                      {
                        resu(elem2,k) -=flux(k);
                        flux_bords(face,k)-=flux(k);
                      }
                }
            }
          <span class="keywordflow">break</span>;
        <span class="keywordflow">case</span> <a class="code" href="Iterateur__PolyMAC__base_8h.html#adda1d69a86f9e3be7366c5f4c6ace649ac4317ef27513bbab3cd0ccfd0d9ed199" title="Neumann_sortie_libre ou derivees.">sortie_libre</a> :
          <span class="keywordflow">if</span> (<a class="code" href="classT__It__VDF__Elem.html#ae1fc0535bed05926b790dd398811b036">flux_evaluateur</a>.calculer_flux_faces_sortie_libre())
            {
              <span class="keyword">const</span> <a class="code" href="classNeumann__sortie__libre.html" title="classe Neumann_sortie_libre Cette classe represente une frontiere ouverte sans vitesse imposee Pour l...">Neumann_sortie_libre</a>&amp; cl =(<span class="keyword">const</span> <a class="code" href="classNeumann__sortie__libre.html" title="classe Neumann_sortie_libre Cette classe represente une frontiere ouverte sans vitesse imposee Pour l...">Neumann_sortie_libre</a>&amp;) (la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>());
              <span class="keywordflow">for</span> (face=ndeb; face&lt;nfin; face++)
                {
                  <a class="code" href="classT__It__VDF__Elem.html#ae1fc0535bed05926b790dd398811b036">flux_evaluateur</a>.secmem_face(face, cl, ndeb, flux);
                  <span class="keywordflow">if</span> ( (elem1=<a class="code" href="classT__It__VDF__Elem.html#a1c6facf0ffcf4a16a8d81d090a7fc1e8">elem</a>(face,0)) &gt; -1)
                    <span class="keywordflow">for</span> (k=0; k&lt;ncomp; k++)
                      {
                        resu(elem1,k) +=flux(k);
                        flux_bords(face,k)+=flux(k);
                      }
                  <span class="keywordflow">if</span> ( (elem2=<a class="code" href="classT__It__VDF__Elem.html#a1c6facf0ffcf4a16a8d81d090a7fc1e8">elem</a>(face,1)) &gt; -1)
                    <span class="keywordflow">for</span> (k=0; k&lt;ncomp; k++)
                      {
                        resu(elem2,k) -=flux(k);
                        flux_bords(face,k)-=flux(k);
                      }
                }
            }
          <span class="keywordflow">break</span>;
        <span class="keywordflow">case</span> <a class="code" href="Iterateur__PolyMAC__base_8h.html#adda1d69a86f9e3be7366c5f4c6ace649a594fd60a4576f47654eed7df53dee9be" title="Dirichlet_entree_fluide.">entree_fluide</a> :
          <span class="keywordflow">if</span> (<a class="code" href="classT__It__VDF__Elem.html#ae1fc0535bed05926b790dd398811b036">flux_evaluateur</a>.calculer_flux_faces_entree_fluide())
            {
              <span class="keyword">const</span> <a class="code" href="classDirichlet__entree__fluide.html" title="classe Dirichlet_entree_fluide Cette classe represente une condition aux limite imposant une grandeur...">Dirichlet_entree_fluide</a>&amp; cl =(<span class="keyword">const</span> <a class="code" href="classDirichlet__entree__fluide.html" title="classe Dirichlet_entree_fluide Cette classe represente une condition aux limite imposant une grandeur...">Dirichlet_entree_fluide</a>&amp;) (la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>());
              <span class="keywordflow">for</span> (face=ndeb; face&lt;nfin; face++)
                {
                  <a class="code" href="classT__It__VDF__Elem.html#ae1fc0535bed05926b790dd398811b036">flux_evaluateur</a>.secmem_face(face, cl, ndeb, flux);
                  <span class="keywordflow">if</span> ( (elem1=<a class="code" href="classT__It__VDF__Elem.html#a1c6facf0ffcf4a16a8d81d090a7fc1e8">elem</a>(face,0)) &gt; -1)
                    <span class="keywordflow">for</span> (k=0; k&lt;ncomp; k++)
                      {
                        resu(elem1,k) +=flux(k);
                        flux_bords(face,k)+=flux(k);
                      }
                  <span class="keywordflow">if</span> ( (elem2=<a class="code" href="classT__It__VDF__Elem.html#a1c6facf0ffcf4a16a8d81d090a7fc1e8">elem</a>(face,1)) &gt; -1)
                    <span class="keywordflow">for</span> (k=0; k&lt;ncomp; k++)
                      {
                        resu(elem2,k) -=flux(k);
                        flux_bords(face,k)-=flux(k);
                      }
                }
            }
          <span class="keywordflow">break</span>;
        <span class="keywordflow">case</span> <a class="code" href="Iterateur__PolyMAC__base_8h.html#adda1d69a86f9e3be7366c5f4c6ace649a497d92e00f36c1c7ec874c0a318db91e" title="Dirichlet_paroi_fixe.">paroi_fixe</a> :
          <span class="keywordflow">if</span> (<a class="code" href="classT__It__VDF__Elem.html#ae1fc0535bed05926b790dd398811b036">flux_evaluateur</a>.calculer_flux_faces_paroi_fixe())
            {
              <span class="keyword">const</span> <a class="code" href="classDirichlet__paroi__fixe.html" title="classe Dirichlet_paroi_fixe Represente une paroi immobile dans une equation de type Navier_Stokes...">Dirichlet_paroi_fixe</a>&amp; cl =(<span class="keyword">const</span> <a class="code" href="classDirichlet__paroi__fixe.html" title="classe Dirichlet_paroi_fixe Represente une paroi immobile dans une equation de type Navier_Stokes...">Dirichlet_paroi_fixe</a>&amp;) (la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>());
              <span class="keywordflow">for</span> (face=ndeb; face&lt;nfin; face++)
                {
                  <a class="code" href="classT__It__VDF__Elem.html#ae1fc0535bed05926b790dd398811b036">flux_evaluateur</a>.secmem_face(face, cl, ndeb, flux);
                  <span class="keywordflow">if</span> ( (elem1=<a class="code" href="classT__It__VDF__Elem.html#a1c6facf0ffcf4a16a8d81d090a7fc1e8">elem</a>(face,0)) &gt; -1)
                    <span class="keywordflow">for</span> (k=0; k&lt;ncomp; k++)
                      {
                        resu(elem1,k) +=flux(k);
                        flux_bords(face,k)+=flux(k);
                      }
                  <span class="keywordflow">if</span> ( (elem2=<a class="code" href="classT__It__VDF__Elem.html#a1c6facf0ffcf4a16a8d81d090a7fc1e8">elem</a>(face,1)) &gt; -1)
                    <span class="keywordflow">for</span> (k=0; k&lt;ncomp; k++)
                      {
                        resu(elem2,k) -=flux(k);
                        flux_bords(face,k)-=flux(k);
                      }
                }
            }
          <span class="keywordflow">break</span>;
        <span class="keywordflow">case</span> <a class="code" href="Iterateur__PolyMAC__base_8h.html#adda1d69a86f9e3be7366c5f4c6ace649acdd1bf461cb105b93d5a9b003ce33141" title="Dirichlet_paroi_defilante.">paroi_defilante</a> :
          <span class="keywordflow">if</span> (<a class="code" href="classT__It__VDF__Elem.html#ae1fc0535bed05926b790dd398811b036">flux_evaluateur</a>.calculer_flux_faces_paroi_defilante())
            {
              <span class="keyword">const</span> <a class="code" href="classDirichlet__paroi__defilante.html" title="classe Dirichlet_paroi_defilante Impose la vitesse de paroi dnas une equation de type Navier_Stokes...">Dirichlet_paroi_defilante</a>&amp; cl =(<span class="keyword">const</span> <a class="code" href="classDirichlet__paroi__defilante.html" title="classe Dirichlet_paroi_defilante Impose la vitesse de paroi dnas une equation de type Navier_Stokes...">Dirichlet_paroi_defilante</a>&amp;) (la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>());
              <span class="keywordflow">for</span> (face=ndeb; face&lt;nfin; face++)
                {
                  <a class="code" href="classT__It__VDF__Elem.html#ae1fc0535bed05926b790dd398811b036">flux_evaluateur</a>.secmem_face(face, cl, ndeb, flux);
                  <span class="keywordflow">if</span> ( (elem1=<a class="code" href="classT__It__VDF__Elem.html#a1c6facf0ffcf4a16a8d81d090a7fc1e8">elem</a>(face,0)) &gt; -1)
                    <span class="keywordflow">for</span> (k=0; k&lt;ncomp; k++)
                      {
                        resu(elem1,k) +=flux(k);
                        flux_bords(face,k)+=flux(k);
                      }
                  <span class="keywordflow">if</span> ( (elem2=<a class="code" href="classT__It__VDF__Elem.html#a1c6facf0ffcf4a16a8d81d090a7fc1e8">elem</a>(face,1)) &gt; -1)
                    <span class="keywordflow">for</span> (k=0; k&lt;ncomp; k++)
                      {
                        resu(elem2,k) -=flux(k);
                        flux_bords(face,k)-=flux(k);
                      }
                }
            }
          <span class="keywordflow">break</span>;
        <span class="keywordflow">case</span> <a class="code" href="classparoi__adiabatique.html">paroi_adiabatique</a> :
          <span class="keywordflow">if</span> (<a class="code" href="classT__It__VDF__Elem.html#ae1fc0535bed05926b790dd398811b036">flux_evaluateur</a>.calculer_flux_faces_paroi_adiabatique())
            {
              <span class="keyword">const</span> <a class="code" href="classNeumann__paroi__adiabatique.html" title="Classe Neumann_paroi_adiabatique Cette condition limite correspond a une paroi adiabatique dans une e...">Neumann_paroi_adiabatique</a>&amp; cl =(<span class="keyword">const</span> <a class="code" href="classNeumann__paroi__adiabatique.html" title="Classe Neumann_paroi_adiabatique Cette condition limite correspond a une paroi adiabatique dans une e...">Neumann_paroi_adiabatique</a>&amp;) (la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>());
              <span class="keywordflow">for</span> (face=ndeb; face&lt;nfin; face++)
                {
                  <a class="code" href="classT__It__VDF__Elem.html#ae1fc0535bed05926b790dd398811b036">flux_evaluateur</a>.secmem_face(face, cl, ndeb, flux);
                  <span class="keywordflow">if</span> ( (elem1=<a class="code" href="classT__It__VDF__Elem.html#a1c6facf0ffcf4a16a8d81d090a7fc1e8">elem</a>(face,0)) &gt; -1)
                    <span class="keywordflow">for</span> (k=0; k&lt;ncomp; k++)
                      {
                        resu(elem1,k) +=flux(k);
                        flux_bords(face,k)+=flux(k);
                      }
                  <span class="keywordflow">if</span> ( (elem2=<a class="code" href="classT__It__VDF__Elem.html#a1c6facf0ffcf4a16a8d81d090a7fc1e8">elem</a>(face,1)) &gt; -1)
                    <span class="keywordflow">for</span> (k=0; k&lt;ncomp; k++)
                      {
                        resu(elem2,k) -=flux(k);
                        flux_bords(face,k)-=flux(k);
                      }
                }
            }
          <span class="keywordflow">break</span>;
        <span class="keywordflow">case</span> <a class="code" href="Iterateur__PolyMAC__base_8h.html#adda1d69a86f9e3be7366c5f4c6ace649af695f3ba17490e07dc3259c85875d8d6" title="Neumann_paroi.">paroi</a> :
          <span class="keywordflow">if</span> (<a class="code" href="classT__It__VDF__Elem.html#ae1fc0535bed05926b790dd398811b036">flux_evaluateur</a>.calculer_flux_faces_paroi())
            {
              <span class="keyword">const</span> <a class="code" href="classNeumann__paroi.html" title="Classe Neumann_paroi Cette condition limite correspond a un flux impose pour l&#39;equation de transport ...">Neumann_paroi</a>&amp; cl =(<span class="keyword">const</span> <a class="code" href="classNeumann__paroi.html" title="Classe Neumann_paroi Cette condition limite correspond a un flux impose pour l&#39;equation de transport ...">Neumann_paroi</a>&amp;) (la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>());
              <span class="keywordflow">for</span> (face=ndeb; face&lt;nfin; face++)
                {
                  <a class="code" href="classT__It__VDF__Elem.html#ae1fc0535bed05926b790dd398811b036">flux_evaluateur</a>.secmem_face(face, cl, ndeb, flux);
                  <span class="keywordflow">if</span> ( (elem1=<a class="code" href="classT__It__VDF__Elem.html#a1c6facf0ffcf4a16a8d81d090a7fc1e8">elem</a>(face,0)) &gt; -1)
                    <span class="keywordflow">for</span> (k=0; k&lt;ncomp; k++)
                      {
                        resu(elem1,k) +=flux(k);
                        flux_bords(face,k)+=flux(k);
                      }
                  <span class="keywordflow">if</span> ( (elem2=<a class="code" href="classT__It__VDF__Elem.html#a1c6facf0ffcf4a16a8d81d090a7fc1e8">elem</a>(face,1)) &gt; -1)
                    <span class="keywordflow">for</span> (k=0; k&lt;ncomp; k++)
                      {
                        resu(elem2,k) -=flux(k);
                        flux_bords(face,k)-=flux(k);
                      }
                }
            }
          <span class="keywordflow">break</span>;
        <span class="keywordflow">case</span> <a class="code" href="Iterateur__PolyMAC__base_8h.html#adda1d69a86f9e3be7366c5f4c6ace649a38f997f881a13a46f2d06012162cf833" title="Echange_externe_impose.">echange_externe_impose</a> :
          <span class="keywordflow">if</span> (<a class="code" href="classT__It__VDF__Elem.html#ae1fc0535bed05926b790dd398811b036">flux_evaluateur</a>.calculer_flux_faces_echange_externe_impose())
            {
              <span class="keyword">const</span> <a class="code" href="classEchange__externe__impose.html" title="Classe Echange_externe_impose: Cette classe represente le cas particulier de la classe Echange_impose...">Echange_externe_impose</a>&amp; cl =(<span class="keyword">const</span> <a class="code" href="classEchange__externe__impose.html" title="Classe Echange_externe_impose: Cette classe represente le cas particulier de la classe Echange_impose...">Echange_externe_impose</a>&amp;) (la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>());

              <span class="keywordtype">int</span> boundary_index=-1;
              <span class="keywordflow">if</span> (<a class="code" href="classIterateur__VDF__base.html#af3f849b64b981589db0fd68c83893246">la_zone</a>.<a class="code" href="classRef__Zone__VDF.html#a84151da4db745d02791d6246e3682b67">valeur</a>().<a class="code" href="classZone__VF.html#a45e54622328fcf035535edf96172c1e4" title="renvoie la ieme frontiere_discrete.">front_VF</a>(num_cl).<a class="code" href="classFrontiere__dis__base.html#a5a7eb46dc3af8a7d4225adc1814845d8" title="Renvoie le nom de la frontiere geometrique.">le_nom</a>() == frontiere_dis.<a class="code" href="classFrontiere__dis__base.html#a5a7eb46dc3af8a7d4225adc1814845d8" title="Renvoie le nom de la frontiere geometrique.">le_nom</a>())
                boundary_index=num_cl;

              <span class="keywordflow">for</span> (face=ndeb; face&lt;nfin; face++)
                {
                  <span class="keywordtype">int</span> local_face=<a class="code" href="classIterateur__VDF__base.html#af3f849b64b981589db0fd68c83893246">la_zone</a>.<a class="code" href="classRef__Zone__VDF.html#a84151da4db745d02791d6246e3682b67">valeur</a>().<a class="code" href="classZone__VF.html#a45e54622328fcf035535edf96172c1e4" title="renvoie la ieme frontiere_discrete.">front_VF</a>(boundary_index).<a class="code" href="classFront__VF.html#a8b34de011799509c228146cea1abaaab">num_local_face</a>(face);
                  <a class="code" href="classT__It__VDF__Elem.html#ae1fc0535bed05926b790dd398811b036">flux_evaluateur</a>.secmem_face(boundary_index,face,local_face, cl, ndeb, flux);
                  <span class="keywordflow">if</span> ( (elem1=<a class="code" href="classT__It__VDF__Elem.html#a1c6facf0ffcf4a16a8d81d090a7fc1e8">elem</a>(face,0)) &gt; -1)
                    <span class="keywordflow">for</span> (k=0; k&lt;ncomp; k++)
                      {
                        resu(elem1,k) +=flux(k);
                        flux_bords(face,k)+=flux(k);
                      }
                  <span class="keywordflow">if</span> ( (elem2=<a class="code" href="classT__It__VDF__Elem.html#a1c6facf0ffcf4a16a8d81d090a7fc1e8">elem</a>(face,1)) &gt; -1)
                    <span class="keywordflow">for</span> (k=0; k&lt;ncomp; k++)
                      {
                        resu(elem2,k) -=flux(k);
                        flux_bords(face,k)-=flux(k);
                      }
                }
            }
          <span class="keywordflow">break</span>;
        <span class="keywordflow">case</span> <a class="code" href="Iterateur__PolyMAC__base_8h.html#adda1d69a86f9e3be7366c5f4c6ace649a9201b83c6fe44d3928abbe5f73364323" title="Echange_global_impose.">echange_global_impose</a> :
          <span class="keywordflow">if</span> (<a class="code" href="classT__It__VDF__Elem.html#ae1fc0535bed05926b790dd398811b036">flux_evaluateur</a>.calculer_flux_faces_echange_global_impose())
            {
              <span class="keyword">const</span> <a class="code" href="classEchange__global__impose.html" title="Classe Echange_global_impose Cette classe represente le cas particulier de la classe Echange_impose_b...">Echange_global_impose</a>&amp; cl =(<span class="keyword">const</span> <a class="code" href="classEchange__global__impose.html" title="Classe Echange_global_impose Cette classe represente le cas particulier de la classe Echange_impose_b...">Echange_global_impose</a>&amp;) (la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>());
              <span class="keywordflow">for</span> (face=ndeb; face&lt;nfin; face++)
                {
                  <a class="code" href="classT__It__VDF__Elem.html#ae1fc0535bed05926b790dd398811b036">flux_evaluateur</a>.secmem_face(face, cl, ndeb, flux);
                  <span class="keywordflow">if</span> ( (elem1=<a class="code" href="classT__It__VDF__Elem.html#a1c6facf0ffcf4a16a8d81d090a7fc1e8">elem</a>(face,0)) &gt; -1)
                    <span class="keywordflow">for</span> (k=0; k&lt;ncomp; k++)
                      {
                        resu(elem1,k) +=flux(k);
                        flux_bords(face,k)+=flux(k);
                      }
                  <span class="keywordflow">if</span> ( (elem2=<a class="code" href="classT__It__VDF__Elem.html#a1c6facf0ffcf4a16a8d81d090a7fc1e8">elem</a>(face,1)) &gt; -1)
                    <span class="keywordflow">for</span> (k=0; k&lt;ncomp; k++)
                      {
                        resu(elem2,k) -=flux(k);
                        flux_bords(face,k)-=flux(k);
                      }
                }
            }
          <span class="keywordflow">break</span>;
        <span class="keywordflow">case</span> <a class="code" href="Iterateur__PolyMAC__base_8h.html#adda1d69a86f9e3be7366c5f4c6ace649adbce3cca9532937c741ae3ac77dc2d54" title="NSCBC.">nscbc</a> :
          <span class="keywordflow">if</span> (<a class="code" href="classT__It__VDF__Elem.html#ae1fc0535bed05926b790dd398811b036">flux_evaluateur</a>.calculer_flux_faces_NSCBC())
            {
              <span class="keyword">const</span> <a class="code" href="classNSCBC.html" title="classe">NSCBC</a>&amp; cl =(<span class="keyword">const</span> <a class="code" href="classNSCBC.html" title="classe">NSCBC</a>&amp;) (la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>());
              <span class="keywordflow">for</span> (face=ndeb; face&lt;nfin; face++)
                {
                  assert(ncomp == 1); <span class="comment">//!&lt; codage avec flux en DoubleVect auquel on assigne la valeur de la fonction scalaire (pas de codage vectoriel de nscbc)</span>
<span class="comment"></span>                  flux = <a class="code" href="classT__It__VDF__Elem.html#ae1fc0535bed05926b790dd398811b036">flux_evaluateur</a>.secmem_face(face, cl, ndeb);
<span class="comment">// flux_evaluateur.secmem_face(face, cl, ndeb, flux);</span>
                  <span class="keywordflow">if</span> ( (elem1=<a class="code" href="classT__It__VDF__Elem.html#a1c6facf0ffcf4a16a8d81d090a7fc1e8">elem</a>(face,0)) &gt; -1)
                    <span class="keywordflow">for</span> (k=0; k&lt;ncomp; k++)
                      {
                        resu(elem1,k) +=flux(k);
                        flux_bords(face,k)+=flux(k);
                      }
                  <span class="keywordflow">if</span> ( (elem2=<a class="code" href="classT__It__VDF__Elem.html#a1c6facf0ffcf4a16a8d81d090a7fc1e8">elem</a>(face,1)) &gt; -1)
                    <span class="keywordflow">for</span> (k=0; k&lt;ncomp; k++)
                      {
                        resu(elem2,k) -=flux(k);
                        flux_bords(face,k)-=flux(k);
                      }
                }
            }
          <span class="keywordflow">break</span>;
        <span class="keywordflow">case</span> <a class="code" href="Iterateur__PolyMAC__base_8h.html#adda1d69a86f9e3be7366c5f4c6ace649ab83c671c148d8664c5c87f343d2ab9fd" title="periodique">periodique</a> :
          <span class="keywordflow">if</span> (<a class="code" href="classT__It__VDF__Elem.html#ae1fc0535bed05926b790dd398811b036">flux_evaluateur</a>.calculer_flux_faces_periodique())
            {
              <span class="keyword">const</span> <a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>&amp; cl =(<span class="keyword">const</span> <a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>&amp;) (la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>());
              <span class="keywordflow">for</span> (face=ndeb; face&lt;nfin; face++)
                {
                  <a class="code" href="classT__It__VDF__Elem.html#ae1fc0535bed05926b790dd398811b036">flux_evaluateur</a>.secmem_face(face, cl, ndeb, flux);
                  <span class="keywordflow">if</span> ( (elem1=<a class="code" href="classT__It__VDF__Elem.html#a1c6facf0ffcf4a16a8d81d090a7fc1e8">elem</a>(face,0)) &gt; -1)
                    <span class="keywordflow">for</span> (k=0; k&lt;ncomp; k++)
                      {
                        resu(elem1,k) +=0.5*flux(k);
                        flux_bords(face,k)+=0.5*flux(k);
                      }
                  <span class="keywordflow">if</span> ( (elem2=<a class="code" href="classT__It__VDF__Elem.html#a1c6facf0ffcf4a16a8d81d090a7fc1e8">elem</a>(face,1)) &gt; -1)
                    <span class="keywordflow">for</span> (k=0; k&lt;ncomp; k++)
                      {
                        resu(elem2,k) -=0.5*flux(k);
                        flux_bords(face,k)-=0.5*flux(k);
                      }
                }
            }
          <span class="keywordflow">break</span>;
          <span class="comment">/*</span>
<span class="comment">                                                                            case nouvelle_Cl_VDF :</span>
<span class="comment">                                                                            if (flux_evaluateur.calculer_flux_faces_echange_global_impose()){</span>
<span class="comment">                                                                            const Nouvelle_Cl_VDF&amp; cl =(const Nouvelle_Cl_VDF&amp;) (la_cl.valeur());</span>
<span class="comment">                                                                            for (face=ndeb; face&lt;nfin; face++) {</span>
<span class="comment">                                                                            flux_evaluateur.secmem_face(face, cl, ndeb, flux);</span>
<span class="comment">                                                                            if ( (elem1=elem(face,0)) &gt; -1)</span>
<span class="comment">                                                                            for (k=0; k&lt;ncomp; k++)</span>
<span class="comment">                                                                            resu(elem1,k) +=flux(k);</span>
<span class="comment">                                                                            if ( (elem2=elem(face,1)) &gt; -1)</span>
<span class="comment">                                                                            for (k=0; k&lt;ncomp; k++)</span>
<span class="comment">                                                                            resu(elem2,k) -=flux(k);</span>
<span class="comment">                                                                            }</span>
<span class="comment">                                                                            }</span>
<span class="comment">                                                                            break;</span>
<span class="comment">          */</span>
        <span class="keywordflow">default</span> :
          <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;On ne reconnait pas la condition limite : &quot;</span> &lt;&lt; la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>();
          <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">exit</a>();
          <span class="keywordflow">break</span>;
        }
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a67c535d1963fe3f0b19a9e42d515fb10"></a><!-- doxytag: member="T_It_VDF_Elem::contribuer_au_second_membre_interne" ref="a67c535d1963fe3f0b19a9e42d515fb10" args="(DoubleTab &amp;) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class _TYPE_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classT__It__VDF__Elem.html">T_It_VDF_Elem</a>&lt; _TYPE_ &gt;::contribuer_au_second_membre_interne </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>resu</em></td><td>)</td>
          <td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="T__It__VDF__Elem_8h_source.html#l01202">1202</a> of file <a class="el" href="T__It__VDF__Elem_8h_source.html">T_It_VDF_Elem.h</a>.</p>

<p>References <a class="el" href="DoubleVect_8h_source.html#l00164">DoubleVect::line_size()</a>, <a class="el" href="Zone__VF_8h_source.html#l00519">Zone_VF::nb_faces()</a>, and <a class="el" href="Zone__VF_8h_source.html#l00512">Zone_VF::premiere_face_int()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">const</span> <span class="keywordtype">int</span> ncomp = resu.<a class="code" href="classDoubleVect.html#ab02d01cd1bdab66fbd66f9a47cc29e10">line_size</a>();
  <span class="keyword">const</span> <a class="code" href="classZone__VDF.html" title="class Zone_VDF Classe instanciable qui derive de Zone_VF. Cette classe contient les informations geom...">Zone_VDF</a>&amp; zone_VDF = <a class="code" href="classIterateur__VDF__base.html#af3f849b64b981589db0fd68c83893246">la_zone</a>.<a class="code" href="classRef__Zone__VDF.html#a84151da4db745d02791d6246e3682b67">valeur</a>();
  <a class="code" href="classDoubleVect.html">DoubleVect</a> flux(ncomp);
  <span class="keywordtype">int</span> face,k;
  <span class="keywordtype">int</span> elem0,elem1;
  <span class="keywordtype">int</span> ndeb=zone_VDF.<a class="code" href="classZone__VF.html#a12869806fa4834aca8f2964e16509dfd" title="une face est interne ssi elle separe deux elements. renvoie le numero de la premiere face interne...">premiere_face_int</a>();
  <span class="keywordtype">int</span> nfin=zone_VDF.<a class="code" href="classZone__VF.html#aede27992d9f2eedd52c24d4a80ff7ffb" title="renvoie le nombre global de faces.">nb_faces</a>();
  <span class="keywordflow">for</span> (face=ndeb; face&lt;nfin; face++)
    {
      <a class="code" href="classT__It__VDF__Elem.html#ae1fc0535bed05926b790dd398811b036">flux_evaluateur</a>.secmem_faces_interne(face, flux);
      elem0 = <a class="code" href="classT__It__VDF__Elem.html#a1c6facf0ffcf4a16a8d81d090a7fc1e8">elem</a>(face,0);
      elem1 = <a class="code" href="classT__It__VDF__Elem.html#a1c6facf0ffcf4a16a8d81d090a7fc1e8">elem</a>(face,1);
      <span class="keywordflow">for</span> (k=0; k&lt;ncomp; k++)
        {
          resu(elem0,k)+=flux(k);
          resu(elem1,k)-=flux(k);
        }
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a99f48d16ca0cd64b2bbe6a1e92f299ee"></a><!-- doxytag: member="T_It_VDF_Elem::duplique" ref="a99f48d16ca0cd64b2bbe6a1e92f299ee" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class _TYPE_&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classT__It__VDF__Elem.html">T_It_VDF_Elem</a>&lt; _TYPE_ &gt;::duplique </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline, private, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implements <a class="el" href="classIterateur__VDF__base.html#ae3679966e754b7190cc2f380e873068d">Iterateur_VDF_base</a>.</p>

<p>Definition at line <a class="el" href="T__It__VDF__Elem_8h_source.html#l00052">52</a> of file <a class="el" href="T__It__VDF__Elem_8h_source.html">T_It_VDF_Elem.h</a>.</p>

<p>References <a class="el" href="EntreeSortie_8h_source.html#l00032">Cerr</a>, <a class="el" href="Process_8cpp_source.html#l00223">Process::exit()</a>, <a class="el" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>, <a class="el" href="Objet__U_8cpp_source.html#l00106">Objet_U::numero()</a>, and <a class="el" href="T__It__VDF__Elem_8h_source.html#l00067">T_It_VDF_Elem&lt; _TYPE_ &gt;::T_It_VDF_Elem()</a>.</p>
<div class="fragment"><pre class="fragment">  {
    <a class="code" href="classT__It__VDF__Elem.html">T_It_VDF_Elem</a>* xxx = <span class="keyword">new</span>  <a class="code" href="classT__It__VDF__Elem.html#a0f6e7990b43d9aa236c8883058b327dc">T_It_VDF_Elem</a>(*<span class="keyword">this</span>);
    <span class="keywordflow">if</span>(!xxx)
      {
        <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Not enough memory &quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
        <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">exit</a>();
      }
    <span class="keywordflow">return</span> xxx-&gt;<a class="code" href="classObjet__U.html#a299d10d1be93af1c2b9f2f43f50141f5" title="Renvoie l&#39;indice de l&#39;objet dans Memoire::data.">numero</a>();
  };
</pre></div>
</div>
</div>
<a class="anchor" id="a1bc39b8215edd7886446c930aeb9c2e7"></a><!-- doxytag: member="T_It_VDF_Elem::evaluateur" ref="a1bc39b8215edd7886446c930aeb9c2e7" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class _TYPE_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEvaluateur__VDF.html">Evaluateur_VDF</a> &amp; <a class="el" href="classT__It__VDF__Elem.html">T_It_VDF_Elem</a>&lt; _TYPE_ &gt;::evaluateur </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implements <a class="el" href="classIterateur__VDF__base.html#a4fa529691768bbe7fc2a41fba3404a1d">Iterateur_VDF_base</a>.</p>

<p>Definition at line <a class="el" href="T__It__VDF__Elem_8h_source.html#l00106">106</a> of file <a class="el" href="T__It__VDF__Elem_8h_source.html">T_It_VDF_Elem.h</a>.</p>
<div class="fragment"><pre class="fragment">{
  <a class="code" href="classEvaluateur__VDF.html" title="class Evaluateur_VDF Classe de base des evaluateurs VDF. Cette classe n&#39;appartient pas a la hierarchi...">Evaluateur_VDF</a>&amp; eval = (<a class="code" href="classEvaluateur__VDF.html" title="class Evaluateur_VDF Classe de base des evaluateurs VDF. Cette classe n&#39;appartient pas a la hierarchi...">Evaluateur_VDF</a>&amp;) <a class="code" href="classT__It__VDF__Elem.html#ae1fc0535bed05926b790dd398811b036">flux_evaluateur</a>;
  <span class="keywordflow">return</span> eval;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a4937ea2745a85911d44f0d8a0c0b0dcb"></a><!-- doxytag: member="T_It_VDF_Elem::evaluateur" ref="a4937ea2745a85911d44f0d8a0c0b0dcb" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class _TYPE_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEvaluateur__VDF.html">Evaluateur_VDF</a> &amp; <a class="el" href="classT__It__VDF__Elem.html">T_It_VDF_Elem</a>&lt; _TYPE_ &gt;::evaluateur </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implements <a class="el" href="classIterateur__VDF__base.html#a8ed6bcf9c7bf22312c43b6ca241170fb">Iterateur_VDF_base</a>.</p>

<p>Definition at line <a class="el" href="T__It__VDF__Elem_8h_source.html#l00101">101</a> of file <a class="el" href="T__It__VDF__Elem_8h_source.html">T_It_VDF_Elem.h</a>.</p>
<div class="fragment"><pre class="fragment">{
  <a class="code" href="classEvaluateur__VDF.html" title="class Evaluateur_VDF Classe de base des evaluateurs VDF. Cette classe n&#39;appartient pas a la hierarchi...">Evaluateur_VDF</a>&amp; eval = (<a class="code" href="classEvaluateur__VDF.html" title="class Evaluateur_VDF Classe de base des evaluateurs VDF. Cette classe n&#39;appartient pas a la hierarchi...">Evaluateur_VDF</a>&amp;) <a class="code" href="classT__It__VDF__Elem.html#ae1fc0535bed05926b790dd398811b036">flux_evaluateur</a>;
  <span class="keywordflow">return</span> eval;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a7eda6d967c50c9843d43e1cbe72a1afd"></a><!-- doxytag: member="T_It_VDF_Elem::impr" ref="a7eda6d967c50c9843d43e1cbe72a1afd" args="(Sortie &amp;os) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class _TYPE_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classT__It__VDF__Elem.html">T_It_VDF_Elem</a>&lt; _TYPE_ &gt;::impr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSortie.html">Sortie</a> &amp;&#160;</td>
          <td class="paramname"><em>os</em></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implements <a class="el" href="classIterateur__VDF__base.html#a876d2de3edea701b22bef3bfb8e3036c">Iterateur_VDF_base</a>.</p>

<p>Definition at line <a class="el" href="T__It__VDF__Elem_8h_source.html#l00800">800</a> of file <a class="el" href="T__It__VDF__Elem_8h_source.html">T_It_VDF_Elem.h</a>.</p>

<p>References <a class="el" href="DoubleTab_8h_source.html#l00243">DoubleTab::dimension()</a>, <a class="el" href="Double_8h_source.html#l00273">est_egal()</a>, <a class="el" href="Zone__VF_8h_source.html#l00054">Zone_VF::face_surfaces()</a>, <a class="el" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>, <a class="el" href="Cond__lim_8h_source.html#l00130">Cond_lim::frontiere_dis()</a>, <a class="el" href="Frontiere__dis__base_8cpp_source.html#l00146">Frontiere_dis_base::le_nom()</a>, <a class="el" href="List_8h_source.html#l00026">LIST</a>, <a class="el" href="communications_8cpp_source.html#l00659">mp_sum_for_each_item()</a>, <a class="el" href="Front__VF_8h_source.html#l00061">Front_VF::nb_faces()</a>, <a class="el" href="Front__VF_8h_source.html#l00071">Front_VF::num_premiere_face()</a>, <a class="el" href="Iterateur__PolyMAC__base_8h_source.html#l00064">periodique</a>, <a class="el" href="Cast_8h_source.html#l00059">ref_cast</a>, <a class="el" href="EcrFicPartage_8cpp_source.html#l00216">EcrFicPartage::syncfile()</a>, and <a class="el" href="Schema__Temps__base_8h_source.html#l00676">Schema_Temps_base::temps_courant()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">const</span> <a class="code" href="classZone__VDF.html" title="class Zone_VDF Classe instanciable qui derive de Zone_VF. Cette classe contient les informations geom...">Zone_VDF</a>&amp; la_zone_vdf=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classZone__VDF.html" title="class Zone_VDF Classe instanciable qui derive de Zone_VF. Cette classe contient les informations geom...">Zone_VDF</a>,<a class="code" href="classIterateur__VDF__base.html#afb3094769ccf45ba34cbab5b80725636">op_base</a>.<a class="code" href="classRef__Operateur__base.html#aa3584f6e713395baa64e3d87b562d91f">valeur</a>().<a class="code" href="classMorEqn.html#a615dd9abff96edcb625fa0424a489864" title="Renvoie la reference sur l&#39;equation pointe par MorEqn::mon_equation. (version const)">equation</a>().<a class="code" href="classEquation__base.html#a12d97ae801edc18f614523677921346e" title="Renvoie la zone discretisee associee a l&#39;equation.">zone_dis</a>().<a class="code" href="classDeriv__Zone__dis__base.html#a30ff47fc0684fe134e8c74c35b268941">valeur</a>());
  <span class="keyword">const</span> <a class="code" href="classZone.html" title="classe Zone Une Zone est un maillage compose d&#39;un ensemble d&#39;elements geometriques de meme type...">Zone</a>&amp; mazone=<a class="code" href="classIterateur__VDF__base.html#af3f849b64b981589db0fd68c83893246">la_zone</a>-&gt;zone();
  <span class="keyword">const</span> <span class="keywordtype">int</span> impr_bord=(mazone.Bords_a_imprimer().est_vide() ? 0:1);
  <span class="keyword">const</span> <a class="code" href="classSchema__Temps__base.html" title="classe Schema_Temps_base">Schema_Temps_base</a>&amp; sch = <a class="code" href="classIterateur__VDF__base.html#a7434e3782850ec5f73ae8c6e9772f94c">la_zcl</a>-&gt;equation().probleme().schema_temps();
  <span class="keywordtype">double</span> temps = sch.<a class="code" href="classSchema__Temps__base.html#a5054df01edb6d4f7baec7e612d423834" title="Renvoie le temps courant.">temps_courant</a>();
  <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; flux_bords=<a class="code" href="classIterateur__VDF__base.html#afb3094769ccf45ba34cbab5b80725636">op_base</a>-&gt;flux_bords();
  <a class="code" href="classDoubleVect.html">DoubleVect</a> bilan(flux_bords.<a class="code" href="classDoubleTab.html#ac3805e2637a3b880ba2d3e650c69dac4" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(1));
  <span class="keywordtype">int</span> k,face;
  <span class="keywordtype">int</span> nb_front_Cl=<a class="code" href="classIterateur__VDF__base.html#af3f849b64b981589db0fd68c83893246">la_zone</a>-&gt;nb_front_Cl();
  <a class="code" href="classDoubleTrav.html" title="Tableau de travail a n entrees pour n&lt;= 4 C&#39;est un DoubleTab avec allocation dans un pool de memoire g...">DoubleTrav</a> flux_bords2( 3, nb_front_Cl , flux_bords.<a class="code" href="classDoubleTab.html#ac3805e2637a3b880ba2d3e650c69dac4" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(1)) ;
  flux_bords2=0;
  <span class="comment">/*flux_bord(k)          -&gt;   flux_bords2(0,num_cl,k) */</span>
  <span class="comment">/*flux_bord_perio1(k)   -&gt;   flux_bords2(1,num_cl,k) */</span>
  <span class="comment">/*flux_bord_perio2(k)   -&gt;   flux_bords2(2,num_cl,k) */</span>
  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> num_cl=0; num_cl&lt;nb_front_Cl; num_cl++)
    {
      <span class="keyword">const</span> <a class="code" href="classCond__lim.html" title="classe Cond_lim Classe generique servant a representer n&#39;importe quelle classe derivee de la classe C...">Cond_lim</a>&amp; la_cl = <a class="code" href="classIterateur__VDF__base.html#a7434e3782850ec5f73ae8c6e9772f94c">la_zcl</a>-&gt;les_conditions_limites(num_cl);
      <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp; frontiere_dis = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>,la_cl.<a class="code" href="classCond__lim.html#a5b2d24809cee07727006a891d4ce8d22" title="Appel a l&#39;objet sous-jacent Renvoie la frontiere discretisee associee a la condition aux limites...">frontiere_dis</a>());
      <span class="keywordtype">int</span> ndeb = frontiere_dis.<a class="code" href="classFront__VF.html#a4986f0c65653fe9eb40bbbff5a97bf16" title="Numero de la premiere face du bord dans la liste des faces.">num_premiere_face</a>();
      <span class="keywordtype">int</span> nfin = ndeb + frontiere_dis.<a class="code" href="classFront__VF.html#a341e2fcb5117b96e745fd7078ba86bab" title="Nombre de faces reelles du bord.">nb_faces</a>();
      <span class="keywordtype">int</span> periodicite = (<a class="code" href="classIterateur__VDF__base.html#ae7e13026a533fe31c54526a7ba7bbaaf">type_cl</a>(la_cl)==<a class="code" href="Iterateur__PolyMAC__base_8h.html#adda1d69a86f9e3be7366c5f4c6ace649ab83c671c148d8664c5c87f343d2ab9fd" title="periodique">periodique</a>?1:0);
      <span class="keywordflow">for</span> (face=ndeb; face&lt;nfin; face++)
        <span class="keywordflow">for</span>(k=0; k&lt;flux_bords.<a class="code" href="classDoubleTab.html#ac3805e2637a3b880ba2d3e650c69dac4" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(1); k++)
          {
            flux_bords2(0,num_cl,k)+=flux_bords(face, k);
            <span class="keywordflow">if</span>(periodicite)
              {
                <span class="keywordflow">if</span>( face &lt; (ndeb+frontiere_dis.<a class="code" href="classFront__VF.html#a341e2fcb5117b96e745fd7078ba86bab" title="Nombre de faces reelles du bord.">nb_faces</a>()/2) )
                  flux_bords2(1,num_cl,k)+=flux_bords(face, k);
                <span class="keywordflow">else</span>
                  flux_bords2(2,num_cl,k)+=flux_bords(face, k);
              }
          }
    } <span class="comment">/* fin for num_cl */</span>
  <a class="code" href="communications_8cpp.html#a5f15b8a5c15449d3277ff3cde06fa68a">mp_sum_for_each_item</a>(flux_bords2);
  <span class="keywordflow">if</span> (<a class="code" href="classProcess.html#acd052b99706c577f8a5b6656217cf4c2" title="renvoie 1 si on est sur le processeur maitre du groupe courant (c&#39;est a dire me() == 0)...">je_suis_maitre</a>())
    {
      <a class="code" href="classIterateur__VDF__base.html#afb3094769ccf45ba34cbab5b80725636">op_base</a>-&gt;ouvrir_fichier(<a class="code" href="classT__It__VDF__Elem.html#aa9e60b7897f03897d207b0e976dacb59">Flux</a>,<span class="stringliteral">&quot;&quot;</span>,1);
      <a class="code" href="classT__It__VDF__Elem.html#aa9e60b7897f03897d207b0e976dacb59">Flux</a>.<a class="code" href="classSortie.html#aed397f2acfa499f2c34be9657a724de0">add_col</a>(temps);
      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> num_cl=0; num_cl&lt;nb_front_Cl; num_cl++)
        {
          <span class="keyword">const</span> <a class="code" href="classCond__lim.html" title="classe Cond_lim Classe generique servant a representer n&#39;importe quelle classe derivee de la classe C...">Cond_lim</a>&amp; la_cl = <a class="code" href="classIterateur__VDF__base.html#a7434e3782850ec5f73ae8c6e9772f94c">la_zcl</a>-&gt;les_conditions_limites(num_cl);
          <span class="keywordtype">int</span> periodicite = (<a class="code" href="classIterateur__VDF__base.html#ae7e13026a533fe31c54526a7ba7bbaaf">type_cl</a>(la_cl)==<a class="code" href="Iterateur__PolyMAC__base_8h.html#adda1d69a86f9e3be7366c5f4c6ace649ab83c671c148d8664c5c87f343d2ab9fd" title="periodique">periodique</a>?1:0);
          <span class="keywordflow">for</span>(k=0; k&lt;flux_bords.<a class="code" href="classDoubleTab.html#ac3805e2637a3b880ba2d3e650c69dac4" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(1); k++)
            {
              bilan(k)+=flux_bords2(0,num_cl,k);
              <span class="keywordflow">if</span>(periodicite)
                {
                  <a class="code" href="classT__It__VDF__Elem.html#aa9e60b7897f03897d207b0e976dacb59">Flux</a>.<a class="code" href="classSortie.html#aed397f2acfa499f2c34be9657a724de0">add_col</a>(flux_bords2(1,num_cl,k));
                  <a class="code" href="classT__It__VDF__Elem.html#aa9e60b7897f03897d207b0e976dacb59">Flux</a>.<a class="code" href="classSortie.html#aed397f2acfa499f2c34be9657a724de0">add_col</a>(flux_bords2(2,num_cl,k));
                }
              <span class="keywordflow">else</span>
                <a class="code" href="classT__It__VDF__Elem.html#aa9e60b7897f03897d207b0e976dacb59">Flux</a>.<a class="code" href="classSortie.html#aed397f2acfa499f2c34be9657a724de0">add_col</a>(flux_bords2(0,num_cl,k));
            }
        }
      <span class="keywordflow">for</span>(k=0; k&lt;flux_bords.<a class="code" href="classDoubleTab.html#ac3805e2637a3b880ba2d3e650c69dac4" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(1); k++)
        <a class="code" href="classT__It__VDF__Elem.html#aa9e60b7897f03897d207b0e976dacb59">Flux</a>.<a class="code" href="classSortie.html#aed397f2acfa499f2c34be9657a724de0">add_col</a>(bilan(k));
      <a class="code" href="classT__It__VDF__Elem.html#aa9e60b7897f03897d207b0e976dacb59">Flux</a> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
    }
  <span class="keyword">const</span> <a class="code" href="List_8h.html#a3149526fb499ddb08728c87daa32c5ad">LIST</a>(<a class="code" href="classNom.html" title="class Nom Une chaine de caractere pour nommer les objets de TRUST">Nom</a>)&amp; Liste_Bords_a_imprimer = <a class="code" href="classIterateur__VDF__base.html#af3f849b64b981589db0fd68c83893246">la_zone</a>-&gt;zone().Bords_a_imprimer();
  <span class="keywordflow">if</span> (!Liste_Bords_a_imprimer.est_vide())
    {
      <a class="code" href="classEcrFicPartage.html">EcrFicPartage</a> Flux_face;
      <a class="code" href="classIterateur__VDF__base.html#afb3094769ccf45ba34cbab5b80725636">op_base</a>-&gt;ouvrir_fichier_partage(Flux_face,<span class="stringliteral">&quot;&quot;</span>,impr_bord);
      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> num_cl=0; num_cl&lt;nb_front_Cl; num_cl++)
        {
          <span class="keyword">const</span> <a class="code" href="classFrontiere__dis__base.html" title="classe Frontiere_dis_base Classe representant une frontiere discretisee. Les objets Frontiere_dis_bas...">Frontiere_dis_base</a>&amp; la_fr = <a class="code" href="classIterateur__VDF__base.html#a7434e3782850ec5f73ae8c6e9772f94c">la_zcl</a>-&gt;les_conditions_limites(num_cl).frontiere_dis();
          <span class="keyword">const</span> <a class="code" href="classCond__lim.html" title="classe Cond_lim Classe generique servant a representer n&#39;importe quelle classe derivee de la classe C...">Cond_lim</a>&amp; la_cl = <a class="code" href="classIterateur__VDF__base.html#a7434e3782850ec5f73ae8c6e9772f94c">la_zcl</a>-&gt;les_conditions_limites(num_cl);
          <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp; frontiere_dis = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>,la_cl.<a class="code" href="classCond__lim.html#a5b2d24809cee07727006a891d4ce8d22" title="Appel a l&#39;objet sous-jacent Renvoie la frontiere discretisee associee a la condition aux limites...">frontiere_dis</a>());
          <span class="keywordtype">int</span> ndeb = frontiere_dis.<a class="code" href="classFront__VF.html#a4986f0c65653fe9eb40bbbff5a97bf16" title="Numero de la premiere face du bord dans la liste des faces.">num_premiere_face</a>();
          <span class="keywordtype">int</span> nfin = ndeb + frontiere_dis.<a class="code" href="classFront__VF.html#a341e2fcb5117b96e745fd7078ba86bab" title="Nombre de faces reelles du bord.">nb_faces</a>();
          <span class="keywordflow">if</span> (mazone.Bords_a_imprimer().contient(la_fr.<a class="code" href="classFrontiere__dis__base.html#a5a7eb46dc3af8a7d4225adc1814845d8" title="Renvoie le nom de la frontiere geometrique.">le_nom</a>()))
            {
              Flux_face &lt;&lt; <span class="stringliteral">&quot;# Flux par face sur &quot;</span> &lt;&lt; la_fr.<a class="code" href="classFrontiere__dis__base.html#a5a7eb46dc3af8a7d4225adc1814845d8" title="Renvoie le nom de la frontiere geometrique.">le_nom</a>() &lt;&lt; <span class="stringliteral">&quot; au temps &quot;</span> &lt;&lt; temps &lt;&lt; <span class="stringliteral">&quot; : &quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
              <span class="keywordflow">for</span> (face=ndeb; face&lt;nfin; face++)
                {
                  <span class="keywordflow">if</span> (<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a> == 2)
                    Flux_face &lt;&lt; <span class="stringliteral">&quot;# Face a x= &quot;</span> &lt;&lt; <a class="code" href="classIterateur__VDF__base.html#af3f849b64b981589db0fd68c83893246">la_zone</a>-&gt;xv(face,0) &lt;&lt; <span class="stringliteral">&quot; y= &quot;</span> &lt;&lt; <a class="code" href="classIterateur__VDF__base.html#af3f849b64b981589db0fd68c83893246">la_zone</a>-&gt;xv(face,1);
                  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a> == 3)
                    Flux_face &lt;&lt; <span class="stringliteral">&quot;# Face a x= &quot;</span> &lt;&lt; <a class="code" href="classIterateur__VDF__base.html#af3f849b64b981589db0fd68c83893246">la_zone</a>-&gt;xv(face,0) &lt;&lt; <span class="stringliteral">&quot; y= &quot;</span> &lt;&lt; <a class="code" href="classIterateur__VDF__base.html#af3f849b64b981589db0fd68c83893246">la_zone</a>-&gt;xv(face,1) &lt;&lt; <span class="stringliteral">&quot; z= &quot;</span> &lt;&lt; <a class="code" href="classIterateur__VDF__base.html#af3f849b64b981589db0fd68c83893246">la_zone</a>-&gt;xv(face,2);
                  <span class="keywordflow">for</span>(k=0; k&lt;flux_bords.<a class="code" href="classDoubleTab.html#ac3805e2637a3b880ba2d3e650c69dac4" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(1); k++)
                    {
                      <span class="keywordflow">if</span> (!<a class="code" href="Double_8h.html#ac86f5f350b0f95fd8c34b0ac8d720f6f">est_egal</a>(la_zone_vdf.<a class="code" href="classZone__VF.html#a40c3382b189a4fc508cf1c3e37b04b21">face_surfaces</a>(face),0., 1.e-20))
                        {
                          Flux_face &lt;&lt; <span class="stringliteral">&quot; surface_face(m2)= &quot;</span> &lt;&lt; la_zone_vdf.<a class="code" href="classZone__VF.html#a40c3382b189a4fc508cf1c3e37b04b21">face_surfaces</a>(face) ;
                          Flux_face &lt;&lt; <span class="stringliteral">&quot; flux_par_surface(W/m2)= &quot;</span>  &lt;&lt; flux_bords(face, k)/la_zone_vdf.<a class="code" href="classZone__VF.html#a40c3382b189a4fc508cf1c3e37b04b21">face_surfaces</a>(face) ;
                        }
                      Flux_face &lt;&lt; <span class="stringliteral">&quot; flux(W)= &quot;</span> &lt;&lt; flux_bords(face, k) ;
                    }
                  Flux_face &lt;&lt; finl;
                }
              Flux_face.<a class="code" href="classEcrFicPartage.html#a76131150f8293c86eb36f4b45125183d" title="Provoque l&#39;ecriture sur disque des donnees accumulees sur les differents processeurs depuis le dernie...">syncfile</a>();
            }
        }
    }
  <span class="keywordflow">return</span> 1;
}
</pre></div>
</div>
</div>
<a class="anchor" id="add22ff724d5064affef48e034eb26cc6"></a><!-- doxytag: member="T_It_VDF_Elem::milieu" ref="add22ff724d5064affef48e034eb26cc6" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class _TYPE_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classMilieu__base.html">Milieu_base</a> &amp; <a class="el" href="classT__It__VDF__Elem.html">T_It_VDF_Elem</a>&lt; _TYPE_ &gt;::milieu </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="T__It__VDF__Elem_8h_source.html#l00125">125</a> of file <a class="el" href="T__It__VDF__Elem_8h_source.html">T_It_VDF_Elem.h</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">return</span> (<a class="code" href="classIterateur__VDF__base.html#a7434e3782850ec5f73ae8c6e9772f94c">la_zcl</a>-&gt;equation()).<a class="code" href="classT__It__VDF__Elem.html#add22ff724d5064affef48e034eb26cc6">milieu</a>();
}
</pre></div>
</div>
</div>
<a class="anchor" id="ab3efc8b1a81fa3eb613f850dc2498edf"></a><!-- doxytag: member="T_It_VDF_Elem::modifier_flux" ref="ab3efc8b1a81fa3eb613f850dc2498edf" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class _TYPE_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classT__It__VDF__Elem.html">T_It_VDF_Elem</a>&lt; _TYPE_ &gt;::modifier_flux </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="T__It__VDF__Elem_8h_source.html#l00759">759</a> of file <a class="el" href="T__It__VDF__Elem_8h_source.html">T_It_VDF_Elem.h</a>.</p>

<p>References <a class="el" href="Zone__VF_8h_source.html#l00458">Zone_VF::face_voisins()</a>, <a class="el" href="Champ__Don_8h_source.html#l00183">Champ_Don::nb_comp()</a>, <a class="el" href="Zone__VF_8h_source.html#l00547">Zone_VF::nb_faces_bord()</a>, <a class="el" href="Cast_8h_source.html#l00059">ref_cast</a>, <a class="el" href="Cast_8h_source.html#l00054">sub_type</a>, and <a class="el" href="Champ__Don_8h_source.html#l00030">Deriv_Champ_Don_base::valeur()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">if</span> (<a class="code" href="classIterateur__VDF__base.html#afb3094769ccf45ba34cbab5b80725636">op_base</a>-&gt;equation().inconnue().<a class="code" href="classO__U__Ptr.html#a5aae0c48048a40339f3847aa14109231" title="Renvoie ref_().le_nom() si le pointeur est non nul ou &quot;Pointeur Nul&quot;.">le_nom</a>().<a class="code" href="classNom.html#a41b0ba18fb90d481c0828ed4372de8ee">debute_par</a>(<span class="stringliteral">&quot;temperature&quot;</span>)
      &amp;&amp; !( <a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classOperateur__Diff__base.html" title="classe Operateur_Diff_base Cette classe est la base de la hierarchie des operateurs representant un t...">Operateur_Diff_base</a>,<a class="code" href="classIterateur__VDF__base.html#afb3094769ccf45ba34cbab5b80725636">op_base</a>.<a class="code" href="classRef__Operateur__base.html#aa3584f6e713395baa64e3d87b562d91f">valeur</a>()) &amp;&amp; <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classOperateur__Diff__base.html" title="classe Operateur_Diff_base Cette classe est la base de la hierarchie des operateurs representant un t...">Operateur_Diff_base</a>,<a class="code" href="classIterateur__VDF__base.html#afb3094769ccf45ba34cbab5b80725636">op_base</a>.<a class="code" href="classRef__Operateur__base.html#aa3584f6e713395baa64e3d87b562d91f">valeur</a>()).diffusivite().le_nom() == <span class="stringliteral">&quot;conductivite&quot;</span> ) )
    {
      <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; flux_bords=<a class="code" href="classIterateur__VDF__base.html#afb3094769ccf45ba34cbab5b80725636">op_base</a>-&gt;flux_bords();
      <span class="keyword">const</span> <a class="code" href="classZone__VDF.html" title="class Zone_VDF Classe instanciable qui derive de Zone_VF. Cette classe contient les informations geom...">Zone_VDF</a>&amp; la_zone_vdf=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classZone__VDF.html" title="class Zone_VDF Classe instanciable qui derive de Zone_VF. Cette classe contient les informations geom...">Zone_VDF</a>,<a class="code" href="classIterateur__VDF__base.html#afb3094769ccf45ba34cbab5b80725636">op_base</a>-&gt;equation().zone_dis().<a class="code" href="classRef__Operateur__base.html#aa3584f6e713395baa64e3d87b562d91f">valeur</a>());
      <span class="keyword">const</span> <a class="code" href="classChamp__base.html" title="classe Champ_base Cette classe est la base de la hierarchie des champs. Ses membres sont les attribut...">Champ_base</a>&amp; rho = (<a class="code" href="classIterateur__VDF__base.html#afb3094769ccf45ba34cbab5b80725636">op_base</a>-&gt;equation()).<a class="code" href="classT__It__VDF__Elem.html#add22ff724d5064affef48e034eb26cc6">milieu</a>().<a class="code" href="classMilieu__base.html#a46a9a4bfb046ed22d0f267b6c052889f" title="Renvoie la masse volumique du milieu. (version const)">masse_volumique</a>();
      <span class="keyword">const</span> <a class="code" href="classChamp__Don.html" title="classe Champ_Don Classe generique de la hierarchie des champs donnes, un objet Champ_Don peut referen...">Champ_Don</a>&amp; Cp = (<a class="code" href="classIterateur__VDF__base.html#afb3094769ccf45ba34cbab5b80725636">op_base</a>-&gt;equation()).<a class="code" href="classT__It__VDF__Elem.html#add22ff724d5064affef48e034eb26cc6">milieu</a>().<a class="code" href="classMilieu__base.html#a174d49eab1db7dfce83578b227f4e702" title="Renvoie la capacite calorifique du milieu. (version const)">capacite_calorifique</a>();
      <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; face_voisins=la_zone_vdf.<a class="code" href="classZone__VF.html#a49d4322f5585a8fa95748ca785b70702" title="renvoie l&#39;element voisin de numface dans la direction i. i=0 : dans le sens oppose de l&#39;axe orthogona...">face_voisins</a>();
      <span class="keywordtype">int</span> rho_uniforme=(<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classChamp__Uniforme.html" title="classe Champ_Uniforme Represente un champ constant dans l&#39;espace et dans le temps.">Champ_Uniforme</a>,rho) ? 1:0);
      <span class="keywordtype">int</span> cp_uniforme=(<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classChamp__Uniforme.html" title="classe Champ_Uniforme Represente un champ constant dans l&#39;espace et dans le temps.">Champ_Uniforme</a>,Cp.<a class="code" href="classDeriv__Champ__Don__base.html#ae16e7e2a7a706352781c5ecc7764703d">valeur</a>()) ? 1:0);
      <span class="keywordtype">int</span> is_rho_u=<a class="code" href="classIterateur__VDF__base.html#afb3094769ccf45ba34cbab5b80725636">op_base</a>-&gt;equation().probleme().is_dilatable();
      <span class="keywordflow">if</span> (is_rho_u)
        {
          <span class="keyword">const</span> <a class="code" href="classOperateur__base.html" title="classe Operateur_base Classe est la base de la hierarchie des objets representant un operateur utilis...">Operateur_base</a>&amp; op=<a class="code" href="classIterateur__VDF__base.html#afb3094769ccf45ba34cbab5b80725636">op_base</a>.<a class="code" href="classRef__Operateur__base.html#aa3584f6e713395baa64e3d87b562d91f">valeur</a>();
          is_rho_u=0;
          <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classOp__Conv__VDF__base.html" title="class Op_Conv_VDF_base Classe de base des operateurs de convection VDF">Op_Conv_VDF_base</a>,op))
            <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classOp__Conv__VDF__base.html" title="class Op_Conv_VDF_base Classe de base des operateurs de convection VDF">Op_Conv_VDF_base</a>,op).vitesse().<a class="code" href="classObjet__U.html#a70413a8785d36bf5105fced1c89d0d2b" title="Donne le nom de l&#39;Objet_U Methode a surcharger : renvoie &quot;neant&quot; dans cette implementation.">le_nom</a>()==<span class="stringliteral">&quot;rho_u&quot;</span>)
              is_rho_u=1;
        }
      <span class="keywordtype">double</span> Cp_=0,rho_=0;
      <span class="keyword">const</span> <span class="keywordtype">int</span>&amp; nb_faces_bords=la_zone_vdf.<a class="code" href="classZone__VF.html#a8815e2276637c0db23868f043dc43e58" title="renvoie le nombre de faces sur lesquelles sont appliquees les conditions limites : bords...">nb_faces_bord</a>();
      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> face=0; face&lt;nb_faces_bords; face++)
        {
          <span class="keywordtype">int</span> num_elem=face_voisins(face,0);
          <span class="keywordflow">if</span> (num_elem == -1) num_elem = face_voisins(face,1);
          <span class="keywordflow">if</span> (cp_uniforme) Cp_=Cp(0,0);
          <span class="keywordflow">else</span> <span class="keywordflow">if</span> (Cp.<a class="code" href="classChamp__Don.html#aa0b82f09287c5934333d540ef77e0059" title="Appel a l&#39;objet sous-jacent Renvoie le nombre de composantes du champ.">nb_comp</a>()==1) Cp_=Cp(num_elem);
          <span class="keywordflow">else</span> Cp_=Cp(num_elem,0);
          <span class="keywordflow">if</span> (rho_uniforme) rho_=rho(0,0);
          <span class="keywordflow">else</span> <span class="keywordflow">if</span> (rho.nb_comp()==1) rho_=rho(num_elem);
          <span class="keywordflow">else</span> rho_=rho(num_elem,0);
          <span class="comment">/* si on est en QC temperature on a calcule div(rhou * T) */</span>
          <span class="comment">/* il ne faut pas remultiplier par rho */</span>
          <span class="keywordflow">if</span> (is_rho_u) rho_=1;
          flux_bords(face,0) *= (rho_*Cp_);
        }
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a0b4d2acc1a454dd05c99abc596f3ca2c"></a><!-- doxytag: member="T_It_VDF_Elem::taille_memoire" ref="a0b4d2acc1a454dd05c99abc596f3ca2c" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class _TYPE_&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classT__It__VDF__Elem.html">T_It_VDF_Elem</a>&lt; _TYPE_ &gt;::taille_memoire </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline, private, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implements <a class="el" href="classObjet__U.html#a0ee0946339f09a2c73c09fcda71c3be2">Objet_U</a>.</p>

<p>Definition at line <a class="el" href="T__It__VDF__Elem_8h_source.html#l00062">62</a> of file <a class="el" href="T__It__VDF__Elem_8h_source.html">T_It_VDF_Elem.h</a>.</p>
<div class="fragment"><pre class="fragment">  {
    <span class="keywordflow">throw</span>;
  };
</pre></div>
</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="a1c6facf0ffcf4a16a8d81d090a7fc1e8"></a><!-- doxytag: member="T_It_VDF_Elem::elem" ref="a1c6facf0ffcf4a16a8d81d090a7fc1e8" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class _TYPE_&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIntTab.html">IntTab</a> <a class="el" href="classT__It__VDF__Elem.html">T_It_VDF_Elem</a>&lt; _TYPE_ &gt;::<a class="el" href="classT__It__VDF__Elem.html#a1c6facf0ffcf4a16a8d81d090a7fc1e8">elem</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="T__It__VDF__Elem_8h_source.html#l00092">92</a> of file <a class="el" href="T__It__VDF__Elem_8h_source.html">T_It_VDF_Elem.h</a>.</p>

<p>Referenced by <a class="el" href="T__It__VDF__Elem_8h_source.html#l00095">T_It_VDF_Elem&lt; _TYPE_ &gt;::T_It_VDF_Elem()</a>.</p>

</div>
</div>
<a class="anchor" id="aa9e60b7897f03897d207b0e976dacb59"></a><!-- doxytag: member="T_It_VDF_Elem::Flux" ref="aa9e60b7897f03897d207b0e976dacb59" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class _TYPE_&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSFichier.html">SFichier</a> <a class="el" href="classT__It__VDF__Elem.html">T_It_VDF_Elem</a>&lt; _TYPE_ &gt;::<a class="el" href="classT__It__VDF__Elem.html#aa9e60b7897f03897d207b0e976dacb59">Flux</a><code> [mutable, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="T__It__VDF__Elem_8h_source.html#l00093">93</a> of file <a class="el" href="T__It__VDF__Elem_8h_source.html">T_It_VDF_Elem.h</a>.</p>

</div>
</div>
<a class="anchor" id="ae1fc0535bed05926b790dd398811b036"></a><!-- doxytag: member="T_It_VDF_Elem::flux_evaluateur" ref="ae1fc0535bed05926b790dd398811b036" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class _TYPE_&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">_TYPE_ <a class="el" href="classT__It__VDF__Elem.html">T_It_VDF_Elem</a>&lt; _TYPE_ &gt;::<a class="el" href="classT__It__VDF__Elem.html#ae1fc0535bed05926b790dd398811b036">flux_evaluateur</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="T__It__VDF__Elem_8h_source.html#l00081">81</a> of file <a class="el" href="T__It__VDF__Elem_8h_source.html">T_It_VDF_Elem.h</a>.</p>

</div>
</div>
<a class="anchor" id="a2bdd758add883f6ad6e9029cb1664a32"></a><!-- doxytag: member="T_It_VDF_Elem::Flux_moment" ref="a2bdd758add883f6ad6e9029cb1664a32" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class _TYPE_&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSFichier.html">SFichier</a> <a class="el" href="classT__It__VDF__Elem.html">T_It_VDF_Elem</a>&lt; _TYPE_ &gt;::<a class="el" href="classT__It__VDF__Elem.html#a2bdd758add883f6ad6e9029cb1664a32">Flux_moment</a><code> [mutable, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="T__It__VDF__Elem_8h_source.html#l00093">93</a> of file <a class="el" href="T__It__VDF__Elem_8h_source.html">T_It_VDF_Elem.h</a>.</p>

</div>
</div>
<a class="anchor" id="af07213914efa02ff865b0d3e01020be5"></a><!-- doxytag: member="T_It_VDF_Elem::Flux_sum" ref="af07213914efa02ff865b0d3e01020be5" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class _TYPE_&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSFichier.html">SFichier</a> <a class="el" href="classT__It__VDF__Elem.html">T_It_VDF_Elem</a>&lt; _TYPE_ &gt;::<a class="el" href="classT__It__VDF__Elem.html#af07213914efa02ff865b0d3e01020be5">Flux_sum</a><code> [mutable, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="T__It__VDF__Elem_8h_source.html#l00093">93</a> of file <a class="el" href="T__It__VDF__Elem_8h_source.html">T_It_VDF_Elem.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/VDF/Operateurs/Iterateurs/<a class="el" href="T__It__VDF__Elem_8h_source.html">T_It_VDF_Elem.h</a></li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Tue Dec 14 2021 19:37:59 for TRUST by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
