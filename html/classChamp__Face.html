<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>TRUST: Champ_Face Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">TRUST&#160;<span id="projectnumber">1.8.4</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a>  </div>
  <div class="headertitle">
<div class="title">Champ_Face Class Reference</div>  </div>
</div>
<div class="contents">
<!-- doxytag: class="Champ_Face" --><!-- doxytag: inherits="Champ_Inc_base,Champ_Face_implementation" -->
<p>class <a class="el" href="classChamp__Face.html" title="class Champ_Face Cette classe sert a representer un champ vectoriel dont on ne calcule que les compos...">Champ_Face</a><br/>
Cette classe sert a representer un champ vectoriel dont on ne calcule<br/>
que les composantes normales aux faces.Il n'y a donc qu'un degre de<br/>
liberte par face et l'attribut nb_comp_ d'un objet de type <a class="el" href="classChamp__Face.html" title="class Champ_Face Cette classe sert a representer un champ vectoriel dont on ne calcule que les compos...">Champ_Face</a><br/>
vaut 1. On peut neammoins imposer toutes les composantes du champ sur<br/>
le bord. Si n est le nombre de faces total de la zone et nb_faces_bord<br/>
le nombre de faces de bord le tableau de valeurs associe au champ<br/>
est construit comme suit:<br/>
- n valeurs pour representer les composantes normales aux faces<br/>
- nb_faces_bord*dimension pour stocker les valeurs imposees<br/>
sur les faces de bord<br/>
Rq : cette classe est specifique au module VDF  
 <a href="classChamp__Face.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="Champ__Face_8h_source.html">Champ_Face.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Champ_Face:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classChamp__Face.png" usemap="#Champ_Face_map" alt=""/>
  <map id="Champ_Face_map" name="Champ_Face_map">
<area href="classChamp__Inc__base.html" title="Classe Champ_Inc_base Classe de base des champs inconnues qui sont les champs calcules par une equati..." alt="Champ_Inc_base" shape="rect" coords="186,224,362,248"/>
<area href="classChamp__Face__implementation.html" alt="Champ_Face_implementation" shape="rect" coords="465,224,641,248"/>
<area href="classChamp__base.html" title="classe Champ_base Cette classe est la base de la hierarchie des champs. Ses membres sont les attribut..." alt="Champ_base" shape="rect" coords="93,168,269,192"/>
<area href="classMorEqn.html" title="classe MorEqn Classe qui regroupe les fonctionnalites de liaison avec une Equation. Le membre MorEqn::mon_equation contient une reference vers un objet Equation_base. Les classes qui sont des &quot;Morceaux d&#39;equation&quot; sont associe par une liaison 1-1 a leur equation en heritant de MorEqn, par exemple: Operateur_base, Solveur_Masse, Source_base ..." alt="MorEqn" shape="rect" coords="279,168,455,192"/>
<area href="classChamp__implementation.html" alt="Champ_implementation" shape="rect" coords="465,168,641,192"/>
<area href="classField__base.html" alt="Field_base" shape="rect" coords="0,112,176,136"/>
<area href="classChamp__Proto.html" title="classe Champ_Proto Classe representant un prototype de Champ. Tous les classes representant des champ..." alt="Champ_Proto" shape="rect" coords="186,112,362,136"/>
<area href="classObjet__U.html" title="classe Objet_U Cette classe est la classe de base des Objets de TRUST Dans les classes derivees de Ob..." alt="Objet_U" shape="rect" coords="0,56,176,80"/>
<area href="classProcess.html" title="Classe de base de TRUST (notamment Objet_U). Elle fournit quelques services de base accessibles de pa..." alt="Process" shape="rect" coords="0,0,176,24"/>
</map>
 </div></div>

<p><a href="classChamp__Face-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChamp__Face.html#ad3d651c5792ececc7a5067b04d417a41">Champ_Face</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChamp__Face.html#a4fd6a24a13f2bd1effe8ad8b752e6efe">~Champ_Face</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChamp__Face.html#a9d33ac16144201cf6fff2a60b54b39fb">taille_memoire</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChamp__Face.html#a74ec98f7a58b69091373be671f98e366">duplique</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classType__info.html">Type_info</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChamp__Face.html#a38759cc7da50a5c3005b95e2f14de0f7">get_info</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Donne des informations sur le type de l'Objet_U.  <a href="#a38759cc7da50a5c3005b95e2f14de0f7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChamp__Face.html#acfcd683e75696521ed496974360e2ee5">associer_zone_dis_base</a> (const <a class="el" href="classZone__dis__base.html">Zone_dis_base</a> &amp;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChamp__Face.html#a818d58bf8925c14f14951cb19794f051">fixer_nb_valeurs_nodales</a> (int)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classZone__dis__base.html">Zone_dis_base</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChamp__Face.html#a7e818c86cac3e4325f35d19b0416b006">zone_dis_base</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classZone__VDF.html">Zone_VDF</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChamp__Face.html#a3afc1887ea97d1cdde9dcbdb01ea77fc">zone_vdf</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classChamp__base.html">Champ_base</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChamp__Face.html#ad350dcd0be4a2f55c9f08a2fb0531f50">affecter_</a> (const <a class="el" href="classChamp__base.html">Champ_base</a> &amp;)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Affectation d'un <a class="el" href="classChamp.html" title="class Champ Cette classe sert a representer n&#39;importe quelle classe derivee de la classe Champ_base...">Champ</a> generique (<a class="el" href="classChamp__base.html" title="classe Champ_base Cette classe est la base de la hierarchie des champs. Ses membres sont les attribut...">Champ_base</a>) dans<br/>
un champ inconnue.  <a href="#ad350dcd0be4a2f55c9f08a2fb0531f50"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classChamp__Proto.html">Champ_Proto</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChamp__Face.html#a5976224e10b64eb2623b70eea55ea6b2">affecter</a> (const double x1, const double x2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classChamp__Proto.html">Champ_Proto</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChamp__Face.html#aa2a91aac7ee95298e2d418e1185850fc">affecter</a> (const double x1, const double x2, const double x3)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classChamp__Proto.html">Champ_Proto</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChamp__Face.html#ab012b4aa21c863d44f160cbea84b4c38">affecter</a> (const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChamp__Face.html#a3c08f436f3733745a93a5e0526002353">verifie_valeurs_cl</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChamp__Face.html#a9bdb53d9eb1ef6875b248ede05f64d9d">compo_normale_sortante</a> (int) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChamp__Face.html#a302f5648e19635a74624c91f5ce344b5">tau_diag</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChamp__Face.html#a3244d90446ab0d8020d646ef186d3cb0">tau_croises</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChamp__Face.html#a64637803a2a1396ec3d5af58fcc11a60">tau_diag</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChamp__Face.html#af3ec71e3c73ac3151bca5b0b5e3b4378">tau_croises</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChamp__Face.html#a162a801021b0a2b56da18301d490f715">dimensionner_tenseur_Grad</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChamp__Face.html#a0e6b34d29948c240cff8b96d0510ab6d">calculer_dercov_axi</a> (const <a class="el" href="classZone__Cl__VDF.html">Zone_Cl_VDF</a> &amp;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChamp__Face.html#a571ff22af5c4c516d6497521acc85b78">calculer_rotationnel_ordre2_centre_element</a> (<a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChamp__Face.html#acf53603772c19f139b42df93d48c5032">imprime</a> (<a class="el" href="classSortie.html">Sortie</a> &amp;, int) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChamp__Face.html#a1261277b8f21a6056c0416dc3d5adb50">trace</a> (const <a class="el" href="classFrontiere__dis__base.html">Frontiere_dis_base</a> &amp;, <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;, double, int distant) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">voir <a class="el" href="classChamp__base.html" title="classe Champ_base Cette classe est la base de la hierarchie des champs. Ses membres sont les attribut...">Champ_base</a><br/>
Cas particulier (malheureusement) du <a class="el" href="classChamp__P0__VDF.html" title="classe Champ_P0_VDF Classe qui represente un champ discret P0 par element associe a une zone discreti...">Champ_P0_VDF</a> :<br/>
Si la frontiere est un raccord, le resultat est calcule sur le<br/>
raccord associe. Dans ce cas, le <a class="el" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a> x doit etre<br/>
dimensionne sur le raccord associe.  <a href="#a1261277b8f21a6056c0416dc3d5adb50"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChamp__Face.html#a2e18df0106fd4b4d163aac9383b75199">mettre_a_jour</a> (double temps)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Effectue une mise a jour en temps du champ inconnue.<br/>
WEC : Maintenant si on l'appelle 2 fois de suite avec le meme<br/>
argument, la 2eme ne fait rien.  <a href="#a2e18df0106fd4b4d163aac9383b75199"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChamp__Face.html#af122a6bd447d0191e0d202f3ae63e8fa">valeur_a_elem</a> (const <a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;position, <a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;val, int le_poly) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChamp__Face.html#a7aff65902f0ae74526949169ac5123c4">valeur_a_elem_compo</a> (const <a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;position, int le_poly, int ncomp) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChamp__Face.html#abb03975827b95a953c16521e9fe57382">valeur_aux_elems</a> (const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;positions, const <a class="el" href="classIntVect.html">IntVect</a> &amp;les_polys, <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;tab_valeurs) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChamp__Face.html#a6b1315a936bafd41e2e4f690c7422a91">valeur_aux_elems_compo</a> (const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;positions, const <a class="el" href="classIntVect.html">IntVect</a> &amp;les_polys, <a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;tab_valeurs, int ncomp) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChamp__Face.html#a30969ce8042663c28ee77087bb714df8">valeur_aux_sommets</a> (const <a class="el" href="classDomaine.html">Domaine</a> &amp;, <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChamp__Face.html#a8295648faf26571b0de56ca395b042ef">valeur_aux_sommets_compo</a> (const <a class="el" href="classDomaine.html">Domaine</a> &amp;, <a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;, int) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChamp__Face.html#ae407d3f7ffbf5d1992c6aecf50aa7165">remplir_coord_noeuds</a> (<a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;positions) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChamp__Face.html#a634857fa8a67e5459e9816a51cd25614">remplir_coord_noeuds_et_polys</a> (<a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;positions, <a class="el" href="classIntVect.html">IntVect</a> &amp;polys) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">NE FAIT RIEN<br/>
Methode a surcharger.  <a href="#a634857fa8a67e5459e9816a51cd25614"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChamp__Face.html#aacfc1c3c1cb21054b55f5d8da33b4367">calculer_dscald_centre_element</a> (<a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChamp__Face.html#a30c21c0f12fe00680722fc07cc3d54be">calcul_critere_Q</a> (<a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;, const <a class="el" href="classZone__Cl__VDF.html">Zone_Cl_VDF</a> &amp;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChamp__Face.html#ad4426ef99f2611353a16a374a5c2c2fb">calcul_grad_u</a> (const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;, <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;, const <a class="el" href="classZone__Cl__VDF.html">Zone_Cl_VDF</a> &amp;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChamp__Face.html#a7c36a9d06fd62b53ce2fe1d778f33128">calcul_y_plus</a> (<a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;, const <a class="el" href="classZone__Cl__VDF.html">Zone_Cl_VDF</a> &amp;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChamp__Face.html#a97fa360dcacec544bd83d2da89a7769c">calcul_duidxj</a> (const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;, <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChamp__Face.html#aa9df636d19ddaaefc669ba3a26a0e561">calcul_duidxj</a> (const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;, <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;, const <a class="el" href="classZone__Cl__VDF.html">Zone_Cl_VDF</a> &amp;) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChamp__Face.html#a08f4717bc89dc38dfb7b9e3627ab5592">calcul_S_barre</a> (const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;, <a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;, const <a class="el" href="classZone__Cl__VDF.html">Zone_Cl_VDF</a> &amp;) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChamp__Face.html#a00a53900838fa2618886381781fe6d6f">calcul_S_barre_sans_contrib_paroi</a> (const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;, <a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;, const <a class="el" href="classZone__Cl__VDF.html">Zone_Cl_VDF</a> &amp;) const </td></tr>
<tr><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classObjet__U.html">Objet_U</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChamp__Face.html#a325d8e642516d69382ae04dcbe3c22af">cree_instance</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classType__info.html">Type_info</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChamp__Face.html#a682b8b85ec7f1a648373b524efe2bb01">info</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Donne des informations sur le type de l'Objet_U.  <a href="#a682b8b85ec7f1a648373b524efe2bb01"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classChamp__Face.html">Champ_Face</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChamp__Face.html#a41ddd8ea4bef77c6aca3e05a718c2959">self_cast</a> (<a class="el" href="classObjet__U.html">Objet_U</a> &amp;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classChamp__Face.html">Champ_Face</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChamp__Face.html#ad9b93b28dc4564cc3d1b1c466e0b2db3">self_cast</a> (const <a class="el" href="classObjet__U.html">Objet_U</a> &amp;)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">methode ajoutee pour caster en python  <a href="#ad9b93b28dc4564cc3d1b1c466e0b2db3"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classType__info.html">Type_info</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChamp__Face.html#a3441ef57d0e159b60960b9536803e3b9">info_obj</a></td></tr>
<tr><td colspan="2"><h2><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classSortie.html">Sortie</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChamp__Face.html#a411e7859c59d7b4fcea226ae11a5e524">printOn</a> (<a class="el" href="classSortie.html">Sortie</a> &amp;x) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Surcharge <a class="el" href="classChamp__base.html#a6c0aa36a76a7e02cdda4b1ea80e829e1" title="Surcharge Objet_U::printOn(Sortie&amp;) Imprime le nom du champ sur un flot de sortie.">Champ_base::printOn</a>(<a class="el" href="classSortie.html" title="Classe de base des flux de sortie. Elle sait ecrire des types simples&lt;br&gt;(entiers, flottants) et des Ob...">Sortie</a>&amp;) const<br/>
Imprime le champ sur un flot de sortie.<br/>
<a class="el" href="classSimple.html">Simple</a> appel a <a class="el" href="classChamp__base.html#a6c0aa36a76a7e02cdda4b1ea80e829e1" title="Surcharge Objet_U::printOn(Sortie&amp;) Imprime le nom du champ sur un flot de sortie.">Champ_base::printOn</a>(<a class="el" href="classSortie.html" title="Classe de base des flux de sortie. Elle sait ecrire des types simples&lt;br&gt;(entiers, flottants) et des Ob...">Sortie</a>&amp;) const.  <a href="#a411e7859c59d7b4fcea226ae11a5e524"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classEntree.html">Entree</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChamp__Face.html#a3a2e5693cd58d8ae85dc961fa1f76766">readOn</a> (<a class="el" href="classEntree.html">Entree</a> &amp;)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Lit un champ inconnue sur un flot d'entree.<br/>
<a class="el" href="classSimple.html">Simple</a> appel a <a class="el" href="classChamp__base.html#aee31c8232c1001c4af5a91d9a74b2b90" title="Lecture du nom d&#39;un champ sur un flot d&#39;entree. Format: nom_du_champ.">Champ_base::readOn</a>(<a class="el" href="classEntree.html" title="Classe de definition des operateurs et methodes pour toute lecture dans un flot d&#39;entree (fichier...">Entree</a>&amp;)  <a href="#a3a2e5693cd58d8ae85dc961fa1f76766"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChamp__Face.html#a613ea150dbc6a9b5f288011f90484381">val_imp_face_bord_private</a> (int face, int comp) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChamp__Face.html#abcb111d6380ec932756b32ab9ba561f3">val_imp_face_bord_private</a> (int face, int comp1, int comp2) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classChamp__base.html">Champ_base</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChamp__Face.html#a394f04bfb5202a3146f16e695e40bc12">le_champ</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classChamp__base.html">Champ_base</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChamp__Face.html#ac61e60fdc66ae99410f1b53abd1b4b7c">le_champ</a> ()</td></tr>
<tr><td colspan="2"><h2><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRef__Zone__VDF.html">Ref_Zone_VDF</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChamp__Face.html#a84b6abcd128000e1d5759caaa7ae0dee">la_zone_VDF</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDoubleTab.html">DoubleTab</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChamp__Face.html#a6438021756713a2835a461188753f9cc">tau_diag_</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">termes diagonaux du tenseur Grad  <a href="#a6438021756713a2835a461188753f9cc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDoubleTab.html">DoubleTab</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChamp__Face.html#a5706b082facc8da2b44e61d89d36f151">tau_croises_</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">termes extradiagonaux du tenseur Grad  <a href="#a5706b082facc8da2b44e61d89d36f151"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>class <a class="el" href="classChamp__Face.html" title="class Champ_Face Cette classe sert a representer un champ vectoriel dont on ne calcule que les compos...">Champ_Face</a><br/>
Cette classe sert a representer un champ vectoriel dont on ne calcule<br/>
que les composantes normales aux faces.Il n'y a donc qu'un degre de<br/>
liberte par face et l'attribut nb_comp_ d'un objet de type <a class="el" href="classChamp__Face.html" title="class Champ_Face Cette classe sert a representer un champ vectoriel dont on ne calcule que les compos...">Champ_Face</a><br/>
vaut 1. On peut neammoins imposer toutes les composantes du champ sur<br/>
le bord. Si n est le nombre de faces total de la zone et nb_faces_bord<br/>
le nombre de faces de bord le tableau de valeurs associe au champ<br/>
est construit comme suit:<br/>
- n valeurs pour representer les composantes normales aux faces<br/>
- nb_faces_bord*dimension pour stocker les valeurs imposees<br/>
sur les faces de bord<br/>
Rq : cette classe est specifique au module VDF </p>

<p>Definition at line <a class="el" href="Champ__Face_8h_source.html#l00050">50</a> of file <a class="el" href="Champ__Face_8h_source.html">Champ_Face.h</a>.</p>
</div><hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ad3d651c5792ececc7a5067b04d417a41"></a><!-- doxytag: member="Champ_Face::Champ_Face" ref="ad3d651c5792ececc7a5067b04d417a41" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Champ_Face::Champ_Face </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Champ__Face_8cpp_source.html#l00039">39</a> of file <a class="el" href="Champ__Face_8cpp_source.html">Champ_Face.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4fd6a24a13f2bd1effe8ad8b752e6efe"></a><!-- doxytag: member="Champ_Face::~Champ_Face" ref="a4fd6a24a13f2bd1effe8ad8b752e6efe" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Champ_Face::~Champ_Face </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Champ__Face_8cpp_source.html#l00039">39</a> of file <a class="el" href="Champ__Face_8cpp_source.html">Champ_Face.cpp</a>.</p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a5976224e10b64eb2623b70eea55ea6b2"></a><!-- doxytag: member="Champ_Face::affecter" ref="a5976224e10b64eb2623b70eea55ea6b2" args="(const double x1, const double x2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classChamp__Proto.html">Champ_Proto</a> &amp; Champ_Face::affecter </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>x2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Champ__Face_8cpp_source.html#l00196">196</a> of file <a class="el" href="Champ__Face_8cpp_source.html">Champ_Face.cpp</a>.</p>

<p>References <a class="el" href="Champ__Face_8h_source.html#l00119">la_zone_VDF</a>, <a class="el" href="Zone__VDF_8h_source.html#l00266">Zone_VDF::orientation()</a>, <a class="el" href="DoubleVect_8h_source.html#l00153">DoubleVect::size()</a>, <a class="el" href="Ref__Zone__VDF_8h_source.html#l00028">Ref_Zone_VDF::valeur()</a>, and <a class="el" href="Champ__Inc__base_8cpp_source.html#l00221">Champ_Inc_base::valeurs()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">const</span> <a class="code" href="classZone__VDF.html" title="class Zone_VDF Classe instanciable qui derive de Zone_VF. Cette classe contient les informations geom...">Zone_VDF</a>&amp; zone_VDF = <a class="code" href="classChamp__Face.html#a84b6abcd128000e1d5759caaa7ae0dee">la_zone_VDF</a>.<a class="code" href="classRef__Zone__VDF.html#a84151da4db745d02791d6246e3682b67">valeur</a>();
  <span class="keyword">const</span> <a class="code" href="classIntVect.html">IntVect</a>&amp; orientation = zone_VDF.<a class="code" href="classZone__VDF.html#a9a9bd747218e463b3408a3590c12814c" title="inline DoubleVect&amp; Zone_VDF::porosite_face() { return porosite_face_; }">orientation</a>();
  <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; val = <a class="code" href="classChamp__Inc__base.html#adb537f43f1649e103a8980314c7ed175" title="Renvoie le tableau des valeurs du champ au temps courant.">valeurs</a>();
  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> num_face=0; num_face&lt;val.<a class="code" href="classDoubleVect.html#a392c1f20b462563365389d28e0853867" title="Identique a size_reelle()">size</a>(); num_face++)
    {
      <span class="keywordtype">int</span> ori = orientation(num_face);
      <span class="keywordflow">switch</span>(ori)
        {
        <span class="keywordflow">case</span> 0 :
          val(num_face)=x1;
          <span class="keywordflow">break</span>;
        <span class="keywordflow">case</span> 1 :
          val(num_face)=x2;
          <span class="keywordflow">break</span>;
        }
    }
  <span class="keywordflow">return</span> *<span class="keyword">this</span>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="aa2a91aac7ee95298e2d418e1185850fc"></a><!-- doxytag: member="Champ_Face::affecter" ref="aa2a91aac7ee95298e2d418e1185850fc" args="(const double x1, const double x2, const double x3)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classChamp__Proto.html">Champ_Proto</a> &amp; Champ_Face::affecter </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>x2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>x3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Champ__Face_8cpp_source.html#l00217">217</a> of file <a class="el" href="Champ__Face_8cpp_source.html">Champ_Face.cpp</a>.</p>

<p>References <a class="el" href="Champ__Face_8h_source.html#l00119">la_zone_VDF</a>, <a class="el" href="Zone__VDF_8h_source.html#l00266">Zone_VDF::orientation()</a>, <a class="el" href="DoubleVect_8h_source.html#l00153">DoubleVect::size()</a>, <a class="el" href="Ref__Zone__VDF_8h_source.html#l00028">Ref_Zone_VDF::valeur()</a>, and <a class="el" href="Champ__Inc__base_8cpp_source.html#l00221">Champ_Inc_base::valeurs()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">const</span> <a class="code" href="classZone__VDF.html" title="class Zone_VDF Classe instanciable qui derive de Zone_VF. Cette classe contient les informations geom...">Zone_VDF</a>&amp; zone_VDF = <a class="code" href="classChamp__Face.html#a84b6abcd128000e1d5759caaa7ae0dee">la_zone_VDF</a>.<a class="code" href="classRef__Zone__VDF.html#a84151da4db745d02791d6246e3682b67">valeur</a>();
  <span class="keyword">const</span> <a class="code" href="classIntVect.html">IntVect</a>&amp; orientation = zone_VDF.<a class="code" href="classZone__VDF.html#a9a9bd747218e463b3408a3590c12814c" title="inline DoubleVect&amp; Zone_VDF::porosite_face() { return porosite_face_; }">orientation</a>();
  <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; val = <a class="code" href="classChamp__Inc__base.html#adb537f43f1649e103a8980314c7ed175" title="Renvoie le tableau des valeurs du champ au temps courant.">valeurs</a>();
  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> num_face=0; num_face&lt;val.<a class="code" href="classDoubleVect.html#a392c1f20b462563365389d28e0853867" title="Identique a size_reelle()">size</a>(); num_face++)
    {
      <span class="keywordtype">int</span> ori = orientation(num_face);
      <span class="keywordflow">switch</span>(ori)
        {
        <span class="keywordflow">case</span> 0 :
          val(num_face)=x1;
          <span class="keywordflow">break</span>;
        <span class="keywordflow">case</span> 1 :
          val(num_face)=x2;
          <span class="keywordflow">break</span>;
        <span class="keywordflow">case</span> 2 :
          val(num_face)=x3;
          <span class="keywordflow">break</span>;
        }
    }
  <span class="keywordflow">return</span> *<span class="keyword">this</span>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="ab012b4aa21c863d44f160cbea84b4c38"></a><!-- doxytag: member="Champ_Face::affecter" ref="ab012b4aa21c863d44f160cbea84b4c38" args="(const DoubleTab &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classChamp__Proto.html">Champ_Proto</a> &amp; Champ_Face::affecter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Champ__Face_8cpp_source.html#l00242">242</a> of file <a class="el" href="Champ__Face_8cpp_source.html">Champ_Face.cpp</a>.</p>

<p>References <a class="el" href="EntreeSortie_8h_source.html#l00032">Cerr</a>, <a class="el" href="Objet__U_8h_source.html#l00079">Objet_U::dimension</a>, <a class="el" href="DoubleTab_8h_source.html#l00243">DoubleTab::dimension()</a>, <a class="el" href="Process_8cpp_source.html#l00223">Process::exit()</a>, <a class="el" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>, <a class="el" href="Champ__Face_8h_source.html#l00119">la_zone_VDF</a>, <a class="el" href="DoubleTab_8h_source.html#l00264">DoubleTab::nb_dim()</a>, <a class="el" href="Zone__VDF_8h_source.html#l00266">Zone_VDF::orientation()</a>, <a class="el" href="DoubleVect_8h_source.html#l00153">DoubleVect::size()</a>, <a class="el" href="Ref__Zone__VDF_8h_source.html#l00028">Ref_Zone_VDF::valeur()</a>, and <a class="el" href="Champ__Inc__base_8cpp_source.html#l00221">Champ_Inc_base::valeurs()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">const</span> <a class="code" href="classZone__VDF.html" title="class Zone_VDF Classe instanciable qui derive de Zone_VF. Cette classe contient les informations geom...">Zone_VDF</a>&amp; zone_VDF = <a class="code" href="classChamp__Face.html#a84b6abcd128000e1d5759caaa7ae0dee">la_zone_VDF</a>.<a class="code" href="classRef__Zone__VDF.html#a84151da4db745d02791d6246e3682b67">valeur</a>();
  <span class="keyword">const</span> <a class="code" href="classIntVect.html">IntVect</a>&amp; orientation = zone_VDF.<a class="code" href="classZone__VDF.html#a9a9bd747218e463b3408a3590c12814c" title="inline DoubleVect&amp; Zone_VDF::porosite_face() { return porosite_face_; }">orientation</a>();
  <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; val = <a class="code" href="classChamp__Inc__base.html#adb537f43f1649e103a8980314c7ed175" title="Renvoie le tableau des valeurs du champ au temps courant.">valeurs</a>();

  <span class="keywordflow">if</span> (v.<a class="code" href="classDoubleTab.html#ae6dda48778e7107e1beb723beef1f75b" title="Returns the number of dimensions of the array (&gt;= 1)">nb_dim</a>() == 2)
    {
      <span class="keywordflow">if</span> (v.<a class="code" href="classDoubleTab.html#ac3805e2637a3b880ba2d3e650c69dac4" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(1) == <a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>)
        {
          <span class="keywordflow">if</span> (v.<a class="code" href="classDoubleTab.html#ac3805e2637a3b880ba2d3e650c69dac4" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(0) == val.<a class="code" href="classDoubleVect.html#a392c1f20b462563365389d28e0853867" title="Identique a size_reelle()">size</a>())
            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> num_face=0; num_face&lt;val.<a class="code" href="classDoubleVect.html#a392c1f20b462563365389d28e0853867" title="Identique a size_reelle()">size</a>(); num_face++)
              val(num_face)=v(num_face,orientation(num_face));
          <span class="keywordflow">else</span>
            {
              <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Erreur TRUST dans Champ_Face::affecter(const DoubleTab&amp; )&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
              <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;les dimensions du DoubleTab passe en parametre sont incompatibles &quot;</span> &lt;&lt; finl;
              <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;avec celles du Champ_Face &quot;</span> &lt;&lt; finl;
              <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">exit</a>();
            }
        }
      <span class="keywordflow">else</span>
        {
          <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Erreur TRUST dans Champ_Face::affecter(const DoubleTab&amp; )&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
          <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;les dimensions du DoubleTab passe en parametre sont incompatibles &quot;</span> &lt;&lt; finl;
          <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;avec celles du Champ_Face &quot;</span> &lt;&lt; finl;
          <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">exit</a>();
        }
    }
  <span class="keywordflow">return</span> *<span class="keyword">this</span>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="ad350dcd0be4a2f55c9f08a2fb0531f50"></a><!-- doxytag: member="Champ_Face::affecter_" ref="ad350dcd0be4a2f55c9f08a2fb0531f50" args="(const Champ_base &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classChamp__base.html">Champ_base</a> &amp; Champ_Face::affecter_ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classChamp__base.html">Champ_base</a> &amp;&#160;</td>
          <td class="paramname"><em>ch</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Affectation d'un <a class="el" href="classChamp.html" title="class Champ Cette classe sert a representer n&#39;importe quelle classe derivee de la classe Champ_base...">Champ</a> generique (<a class="el" href="classChamp__base.html" title="classe Champ_base Cette classe est la base de la hierarchie des champs. Ses membres sont les attribut...">Champ_base</a>) dans<br/>
un champ inconnue. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="classChamp__base.html" title="classe Champ_base Cette classe est la base de la hierarchie des champs. Ses membres sont les attribut...">Champ_base</a>&amp;<br/>
 Signification: le resultat de l'affectation (*this)<br/>
 Contraintes: </dd></dl>

<p>Reimplemented from <a class="el" href="classChamp__Inc__base.html#a26d0e60ee38972c757be99a8f9a88bd8">Champ_Inc_base</a>.</p>

<p>Definition at line <a class="el" href="Champ__Face_8cpp_source.html#l00093">93</a> of file <a class="el" href="Champ__Face_8cpp_source.html">Champ_Face.cpp</a>.</p>

<p>References <a class="el" href="Objet__U_8h_source.html#l00079">Objet_U::dimension</a>, <a class="el" href="Zone__VF_8h_source.html#l00458">Zone_VF::face_voisins()</a>, <a class="el" href="Champ__Face_8h_source.html#l00119">la_zone_VDF</a>, <a class="el" href="Zone__VF_8h_source.html#l00519">Zone_VF::nb_faces()</a>, <a class="el" href="Zone__VDF_8h_source.html#l00194">Zone_VDF::nb_faces_X()</a>, <a class="el" href="Zone__VDF_8h_source.html#l00200">Zone_VDF::nb_faces_Y()</a>, <a class="el" href="Zone__VDF_8h_source.html#l00206">Zone_VDF::nb_faces_Z()</a>, <a class="el" href="Zone__VDF_8h_source.html#l00266">Zone_VDF::orientation()</a>, <a class="el" href="Zone__VF_8h_source.html#l00512">Zone_VF::premiere_face_int()</a>, <a class="el" href="Cast_8h_source.html#l00054">sub_type</a>, <a class="el" href="Ref__Zone__VDF_8h_source.html#l00028">Ref_Zone_VDF::valeur()</a>, <a class="el" href="Champ__base_8cpp_source.html#l00258">Champ_base::valeur_aux_compo()</a>, <a class="el" href="Champ__Inc__base_8cpp_source.html#l00221">Champ_Inc_base::valeurs()</a>, <a class="el" href="classChamp__Proto.html#a9d8c69f11d1b0a8e378cc6ca41793614">Champ_Proto::valeurs()</a>, and <a class="el" href="Zone__VF_8h_source.html#l00650">Zone_VF::xv()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; v = ch.<a class="code" href="classChamp__Proto.html#a9d8c69f11d1b0a8e378cc6ca41793614">valeurs</a>();
  <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; val = <a class="code" href="classChamp__Inc__base.html#adb537f43f1649e103a8980314c7ed175" title="Renvoie le tableau des valeurs du champ au temps courant.">valeurs</a>();
  <span class="keyword">const</span> <a class="code" href="classZone__VDF.html" title="class Zone_VDF Classe instanciable qui derive de Zone_VF. Cette classe contient les informations geom...">Zone_VDF</a>&amp; zone_VDF = <a class="code" href="classChamp__Face.html#a84b6abcd128000e1d5759caaa7ae0dee">la_zone_VDF</a>.<a class="code" href="classRef__Zone__VDF.html#a84151da4db745d02791d6246e3682b67">valeur</a>();
  <span class="keywordtype">int</span> nb_faces = zone_VDF.<a class="code" href="classZone__VF.html#aede27992d9f2eedd52c24d4a80ff7ffb" title="renvoie le nombre global de faces.">nb_faces</a>();
  <span class="keyword">const</span> <a class="code" href="classIntVect.html">IntVect</a>&amp; orientation = zone_VDF.<a class="code" href="classZone__VDF.html#a9a9bd747218e463b3408a3590c12814c" title="inline DoubleVect&amp; Zone_VDF::porosite_face() { return porosite_face_; }">orientation</a>();
  <span class="keywordtype">int</span> ori, n0, n1;

  <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classChamp__Uniforme.html" title="classe Champ_Uniforme Represente un champ constant dans l&#39;espace et dans le temps.">Champ_Uniforme</a>,ch))
    {
      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> num_face=0; num_face&lt;nb_faces; num_face++)
        val(num_face) = v(0,orientation(num_face));
    }
  <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classChamp__Uniforme__Morceaux.html" title="classe Champ_Uniforme_Morceaux Cette classe represente champ constant par morceaux dans l&#39;espace et c...">Champ_Uniforme_Morceaux</a>,ch))
            || (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classChamp__Don__lu.html" title="class Champ_Don_lu Cette classe represente un champ de donnees que l&#39;on lit dans un fichier avec les ...">Champ_Don_lu</a>,ch)) )
    {
      <span class="keywordtype">int</span> ndeb_int = zone_VDF.<a class="code" href="classZone__VF.html#a12869806fa4834aca8f2964e16509dfd" title="une face est interne ssi elle separe deux elements. renvoie le numero de la premiere face interne...">premiere_face_int</a>();
      <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; face_voisins = zone_VDF.<a class="code" href="classZone__VF.html#a49d4322f5585a8fa95748ca785b70702" title="renvoie l&#39;element voisin de numface dans la direction i. i=0 : dans le sens oppose de l&#39;axe orthogona...">face_voisins</a>();
      <span class="keywordtype">int</span> num_face;

      <span class="keywordflow">for</span> (num_face=0; num_face&lt;ndeb_int; num_face++)
        {
          ori = orientation(num_face);
          n0 = face_voisins(num_face,0);
          <span class="keywordflow">if</span> (n0 != -1)
            val(num_face) = v(n0,ori);
          <span class="keywordflow">else</span>
            val(num_face) = v(face_voisins(num_face,1),ori);
        }

      <span class="keywordflow">for</span> (num_face=ndeb_int; num_face&lt;nb_faces; num_face++)
        {
          ori = orientation(num_face);
          n0 = face_voisins(num_face,0);
          n1 = face_voisins(num_face,1);
          val(num_face) = 0.5*(v(n0,ori)+v(n1,ori));
        }
    }
  <span class="keywordflow">else</span>
    {
<span class="comment">// int ndeb_int = zone_VDF.premiere_face_int();</span>
<span class="comment">// const IntTab&amp; face_voisins = zone_VDF.face_voisins();</span>
      <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a> positionX(zone_VDF.<a class="code" href="classZone__VDF.html#ae69566ee592ac9d4b7cd268e1d86c643">nb_faces_X</a>() ,<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>);
      <a class="code" href="classDoubleVect.html">DoubleVect</a> U(zone_VDF.<a class="code" href="classZone__VDF.html#ae69566ee592ac9d4b7cd268e1d86c643">nb_faces_X</a>());
      <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a> positionY(zone_VDF.<a class="code" href="classZone__VDF.html#ac6a57a9fef1d936831c092a36ef998f1">nb_faces_Y</a>() ,<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>);
      <a class="code" href="classDoubleVect.html">DoubleVect</a> V(zone_VDF.<a class="code" href="classZone__VDF.html#ac6a57a9fef1d936831c092a36ef998f1">nb_faces_Y</a>());
      <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a> positionZ(zone_VDF.<a class="code" href="classZone__VDF.html#ae689971be4b223f991c2b0e5584c6f3d">nb_faces_Z</a>() ,<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>);
      <a class="code" href="classDoubleVect.html">DoubleVect</a> W(zone_VDF.<a class="code" href="classZone__VDF.html#ae689971be4b223f991c2b0e5584c6f3d">nb_faces_Z</a>());
      <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; xv=zone_VDF.<a class="code" href="classZone__VF.html#a918c0885a9b67317fcce3a0535306542">xv</a>();
      <span class="keywordtype">int</span> nbx=0;
      <span class="keywordtype">int</span> nby=0;
      <span class="keywordtype">int</span> nbz=0;
      <span class="keywordtype">int</span> num_face, k;

      <span class="keywordflow">for</span> (num_face=0; num_face&lt;nb_faces; num_face++)
        {
          ori = orientation(num_face);
          <span class="keywordflow">switch</span>(ori)
            {
            <span class="keywordflow">case</span> 0:
              <span class="keywordflow">for</span>(k=0; k&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; k++)
                positionX(nbx, k)=xv(num_face, k);
              nbx++;
              <span class="keywordflow">break</span>;
            <span class="keywordflow">case</span> 1:
              <span class="keywordflow">for</span>(k=0; k&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; k++)
                positionY(nby, k)=xv(num_face, k);
              nby++;
              <span class="keywordflow">break</span>;
            <span class="keywordflow">case</span> 2:
              <span class="keywordflow">for</span>(k=0; k&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; k++)
                positionZ(nbz, k)=xv(num_face, k);
              nbz++;
              <span class="keywordflow">break</span>;
            }
        }

      ch.<a class="code" href="classChamp__base.html#a19223e49e04226a25264ac573ab390e2" title="Idem que valeur_aux(const DoubleTab &amp;, DoubleTab &amp;), mais calcule uniquement la composante compo du c...">valeur_aux_compo</a>(positionX, U, 0);
      ch.<a class="code" href="classChamp__base.html#a19223e49e04226a25264ac573ab390e2" title="Idem que valeur_aux(const DoubleTab &amp;, DoubleTab &amp;), mais calcule uniquement la composante compo du c...">valeur_aux_compo</a>(positionY, V, 1);
      <span class="keywordflow">if</span>(dimension == 3)
        ch.<a class="code" href="classChamp__base.html#a19223e49e04226a25264ac573ab390e2" title="Idem que valeur_aux(const DoubleTab &amp;, DoubleTab &amp;), mais calcule uniquement la composante compo du c...">valeur_aux_compo</a>(positionZ, W, 2);
      nbx=nby=nbz=0;
      <span class="keywordflow">for</span> (num_face=0; num_face&lt;nb_faces; num_face++)
        {
          ori = orientation(num_face);
          <span class="keywordflow">switch</span>(ori)
            {
            <span class="keywordflow">case</span> 0:
              val(num_face) = U(nbx++);
              <span class="keywordflow">break</span>;
            <span class="keywordflow">case</span> 1:
              val(num_face) = V(nby++);
              <span class="keywordflow">break</span>;
            <span class="keywordflow">case</span> 2:
              val(num_face) = W(nbz++);
              <span class="keywordflow">break</span>;
            }
        }
    }
  <span class="keywordflow">return</span> *<span class="keyword">this</span>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="acfcd683e75696521ed496974360e2ee5"></a><!-- doxytag: member="Champ_Face::associer_zone_dis_base" ref="acfcd683e75696521ed496974360e2ee5" args="(const Zone_dis_base &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Champ_Face::associer_zone_dis_base </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classZone__dis__base.html">Zone_dis_base</a> &amp;&#160;</td>
          <td class="paramname"><em>z_dis</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="classChamp__base.html#aa7eeff006a19043329b9e4a20913345d">Champ_base</a>.</p>

<p>Definition at line <a class="el" href="Champ__Face_8cpp_source.html#l00069">69</a> of file <a class="el" href="Champ__Face_8cpp_source.html">Champ_Face.cpp</a>.</p>

<p>References <a class="el" href="Champ__Face_8h_source.html#l00119">la_zone_VDF</a>, and <a class="el" href="Cast_8h_source.html#l00059">ref_cast</a>.</p>

<p>Referenced by <a class="el" href="EOS__Tools__VDF_8cpp_source.html#l00046">EOS_Tools_VDF::associer_zones()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <a class="code" href="classChamp__Face.html#a84b6abcd128000e1d5759caaa7ae0dee">la_zone_VDF</a>=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classZone__VDF.html" title="class Zone_VDF Classe instanciable qui derive de Zone_VF. Cette classe contient les informations geom...">Zone_VDF</a>, z_dis);
}
</pre></div>
</div>
</div>
<a class="anchor" id="a30c21c0f12fe00680722fc07cc3d54be"></a><!-- doxytag: member="Champ_Face::calcul_critere_Q" ref="a30c21c0f12fe00680722fc07cc3d54be" args="(DoubleTab &amp;, const Zone_Cl_VDF &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Champ_Face::calcul_critere_Q </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classZone__Cl__VDF.html">Zone_Cl_VDF</a> &amp;&#160;</td>
          <td class="paramname"><em>zone_Cl_VDF</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Champ__Face3_8cpp_source.html#l00519">519</a> of file <a class="el" href="Champ__Face3_8cpp_source.html">Champ_Face3.cpp</a>.</p>

<p>References <a class="el" href="Champ__Face3_8cpp_source.html#l00994">calcul_duidxj()</a>, <a class="el" href="Objet__U_8h_source.html#l00079">Objet_U::dimension</a>, <a class="el" href="Champ__Face_8h_source.html#l00119">la_zone_VDF</a>, <a class="el" href="Zone__dis__base_8h_source.html#l00140">Zone_dis_base::nb_elem()</a>, <a class="el" href="Zone__dis__base_8h_source.html#l00144">Zone_dis_base::nb_elem_tot()</a>, <a class="el" href="Ref__Zone__VDF_8h_source.html#l00028">Ref_Zone_VDF::valeur()</a>, and <a class="el" href="Champ__Inc__base_8cpp_source.html#l00221">Champ_Inc_base::valeurs()</a>.</p>
<div class="fragment"><pre class="fragment">{
<span class="comment">// Q=0.5*(\Omega_{ij}*\Omega_{ij}-S_{ij}*S_{ij})=-0.25*du_i/dx_j*du_j/dx_i</span>

  <span class="keyword">const</span> <a class="code" href="classZone__VDF.html" title="class Zone_VDF Classe instanciable qui derive de Zone_VF. Cette classe contient les informations geom...">Zone_VDF</a>&amp; zone_VDF = <a class="code" href="classChamp__Face.html#a84b6abcd128000e1d5759caaa7ae0dee">la_zone_VDF</a>.<a class="code" href="classRef__Zone__VDF.html#a84151da4db745d02791d6246e3682b67">valeur</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_elem = zone_VDF.<a class="code" href="classZone__dis__base.html#a790cb2f6bc2928518799e748313d0eb3">nb_elem</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_elem_tot = zone_VDF.<a class="code" href="classZone__dis__base.html#a4d6aa445f152aa6dc54d66ea7a071147">nb_elem_tot</a>();
  <span class="keywordtype">int</span> num_elem,i,j;
  <span class="keywordtype">double</span> crit,deriv1,deriv2;

  <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a> gradient_elem(nb_elem_tot,<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>,<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>);
  gradient_elem=0.;

  <a class="code" href="classChamp__Face.html" title="class Champ_Face Cette classe sert a representer un champ vectoriel dont on ne calcule que les compos...">Champ_Face</a>&amp; vit = *<span class="keyword">this</span>;
  <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; vitesse = <a class="code" href="classChamp__Inc__base.html#adb537f43f1649e103a8980314c7ed175" title="Renvoie le tableau des valeurs du champ au temps courant.">valeurs</a>();

  vit.<a class="code" href="classChamp__Face.html#a97fa360dcacec544bd83d2da89a7769c">calcul_duidxj</a>(vitesse,gradient_elem,zone_Cl_VDF);

  <span class="keywordflow">for</span> (num_elem=0; num_elem&lt;nb_elem; num_elem++)
    {
      crit = 0.;
      <span class="keywordflow">for</span> (i=0; i&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; i++)
        <span class="keywordflow">for</span>(j=0; j&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; j++)
          {
            deriv1 = gradient_elem(num_elem,i,j);
            deriv2 = gradient_elem(num_elem,j,i);

            crit += -0.25*deriv1*deriv2;
          }
      Q[num_elem] = crit;
    }

}
</pre></div>
</div>
</div>
<a class="anchor" id="a97fa360dcacec544bd83d2da89a7769c"></a><!-- doxytag: member="Champ_Face::calcul_duidxj" ref="a97fa360dcacec544bd83d2da89a7769c" args="(const DoubleTab &amp;, DoubleTab &amp;) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDoubleTab.html">DoubleTab</a> &amp; Champ_Face::calcul_duidxj </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>in_vel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>gij</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Champ__Face3_8cpp_source.html#l00994">994</a> of file <a class="el" href="Champ__Face3_8cpp_source.html">Champ_Face3.cpp</a>.</p>

<p>References <a class="el" href="Zone__VDF_8h_source.html#l00558">Zone_VDF::dim_elem()</a>, <a class="el" href="Objet__U_8h_source.html#l00079">Objet_U::dimension</a>, <a class="el" href="Zone__VF_8h_source.html#l00574">Zone_VF::elem_faces()</a>, <a class="el" href="Lois__sodium_8h_source.html#l00183">f1</a>, <a class="el" href="Lois__sodium_8h_source.html#l00185">f2</a>, <a class="el" href="Zone__VF_8h_source.html#l00458">Zone_VF::face_voisins()</a>, <a class="el" href="Champ__Face_8h_source.html#l00119">la_zone_VDF</a>, <a class="el" href="Zone_8h_source.html#l00319">Zone::nb_elem_tot()</a>, <a class="el" href="Ref__Zone__VDF_8h_source.html#l00028">Ref_Zone_VDF::valeur()</a>, and <a class="el" href="Zone__dis__base_8h_source.html#l00106">Zone_dis_base::zone()</a>.</p>

<p>Referenced by <a class="el" href="Champ__Face3_8cpp_source.html#l00519">calcul_critere_Q()</a>, <a class="el" href="Champ__Face3_8cpp_source.html#l01457">calcul_grad_u()</a>, and <a class="el" href="Champ__Face3_8cpp_source.html#l01427">calcul_S_barre()</a>.</p>
<div class="fragment"><pre class="fragment">{

  <span class="keyword">const</span> <a class="code" href="classZone__VDF.html" title="class Zone_VDF Classe instanciable qui derive de Zone_VF. Cette classe contient les informations geom...">Zone_VDF</a>&amp; zone_VDF = <a class="code" href="classChamp__Face.html#a84b6abcd128000e1d5759caaa7ae0dee">la_zone_VDF</a>.<a class="code" href="classRef__Zone__VDF.html#a84151da4db745d02791d6246e3682b67">valeur</a>();
  <span class="keywordtype">int</span> nb_elem_tot = zone_VDF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#aa3a33e8b723618b9092460007153e42d" title="Renvoie le nombre total d&#39;elements de la zone.">nb_elem_tot</a>();
  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; face_voisins = zone_VDF.<a class="code" href="classZone__VF.html#a49d4322f5585a8fa95748ca785b70702" title="renvoie l&#39;element voisin de numface dans la direction i. i=0 : dans le sens oppose de l&#39;axe orthogona...">face_voisins</a>();
  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; elem_faces = zone_VDF.<a class="code" href="classZone__VF.html#a067e462dcd3ab92b0f6d945b19e4eb37" title="renvoie le numero de le ieme face de la maille num_elem la facon dont ces faces sont numerotees est l...">elem_faces</a>();

  <span class="keywordtype">int</span> element_number;
  <span class="keywordtype">int</span> num0,num1,num2,num3,num4,num5;
  <span class="keywordtype">int</span> f0,<a class="code" href="Lois__sodium_8h.html#a3034a1fb8c782842a2b9473c0f02a448">f1</a>,<a class="code" href="Lois__sodium_8h.html#a23f45359b08cb1d0538697b4f2d3dbbe">f2</a>,f3,f4,f5;


  <span class="comment">//</span>
  <span class="comment">// Calculate the Sij tensor</span>
  <span class="comment">//</span>
  <span class="keywordflow">if</span> (<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a> ==2)
    {
      <span class="keywordflow">for</span> (element_number=0 ; element_number&lt;nb_elem_tot ; element_number ++)
        {
          f0 = elem_faces(element_number,0);
          num0 = face_voisins(f0,0);
          <span class="keywordflow">if</span> (num0 == -1)
            num0 = element_number;
          f1 = elem_faces(element_number,1);
          num1 = face_voisins(f1,0);
          <span class="keywordflow">if</span> (num1 == -1)
            num1 = element_number;
          f2 = elem_faces(element_number,2);
          num2 = face_voisins(f2,1);
          <span class="keywordflow">if</span> (num2 == -1)
            num2 = element_number;
          f3 = elem_faces(element_number,3);
          num3 = face_voisins(f3,1);
          <span class="keywordflow">if</span> (num3 == -1)
            num3 = element_number;

          gij(element_number,0,0)=0.5*((in_vel(num2,0)-in_vel(num0,0))/
                                       zone_VDF.<a class="code" href="classZone__VDF.html#a16d2b5b0bd1f52fa6aed11d2e59a10b0">dim_elem</a>(element_number,0));
          gij(element_number,0,1) = 0.5*((in_vel(num3,0)-in_vel(num1,0))/zone_VDF.<a class="code" href="classZone__VDF.html#a16d2b5b0bd1f52fa6aed11d2e59a10b0">dim_elem</a>(element_number,1));
          gij(element_number,1,0) = 0.5*((in_vel(num2,1)-in_vel(num0,1))/zone_VDF.<a class="code" href="classZone__VDF.html#a16d2b5b0bd1f52fa6aed11d2e59a10b0">dim_elem</a>(element_number,0));
          gij(element_number,1,1)=0.5*((in_vel(num3,1)-in_vel(num1,1))/
                                       zone_VDF.<a class="code" href="classZone__VDF.html#a16d2b5b0bd1f52fa6aed11d2e59a10b0">dim_elem</a>(element_number,1));
        }
    }
  <span class="keywordflow">else</span>
    {
      <span class="keywordflow">for</span> (element_number=0 ; element_number&lt;nb_elem_tot ; element_number ++)
        {
          f0 = elem_faces(element_number,0);
          num0 = face_voisins(f0,0);
          <span class="keywordflow">if</span> (num0 == -1)
            num0 = element_number;
          f1 = elem_faces(element_number,1);
          num1 = face_voisins(f1,0);
          <span class="keywordflow">if</span> (num1 == -1)
            num1 = element_number;
          f2 = elem_faces(element_number,2);
          num2 = face_voisins(f2,0);
          <span class="keywordflow">if</span> (num2 == -1)
            num2 = element_number;
          f3 = elem_faces(element_number,3);
          num3 = face_voisins(f3,1);
          <span class="keywordflow">if</span> (num3 == -1)
            num3 = element_number;
          f4 = elem_faces(element_number,4);
          num4 = face_voisins(f4,1);
          <span class="keywordflow">if</span> (num4 == -1)
            num4 = element_number;
          f5 = elem_faces(element_number,5);
          num5 = face_voisins(f5,1);
          <span class="keywordflow">if</span> (num5 == -1)
            num5 = element_number;

          gij(element_number,0,0)=0.5*((in_vel(num3,0)-in_vel(num0,0))/
                                       zone_VDF.<a class="code" href="classZone__VDF.html#a16d2b5b0bd1f52fa6aed11d2e59a10b0">dim_elem</a>(element_number,0));

          gij(element_number,0,1) = 0.5*((in_vel(num4,0)-in_vel(num1,0))/
                                         zone_VDF.<a class="code" href="classZone__VDF.html#a16d2b5b0bd1f52fa6aed11d2e59a10b0">dim_elem</a>(element_number,1));
          gij(element_number,1,0) = 0.5*((in_vel(num3,1)-in_vel(num0,1))/
                                         zone_VDF.<a class="code" href="classZone__VDF.html#a16d2b5b0bd1f52fa6aed11d2e59a10b0">dim_elem</a>(element_number,0));

          gij(element_number,0,2) =  0.5*((in_vel(num5,0)-in_vel(num2,0))/
                                          zone_VDF.<a class="code" href="classZone__VDF.html#a16d2b5b0bd1f52fa6aed11d2e59a10b0">dim_elem</a>(element_number,2));

          gij(element_number,2,0) = 0.5*((in_vel(num3,2)-in_vel(num0,2))/
                                         zone_VDF.<a class="code" href="classZone__VDF.html#a16d2b5b0bd1f52fa6aed11d2e59a10b0">dim_elem</a>(element_number,0));

          gij(element_number,1,1)=0.5*((in_vel(num4,1)-in_vel(num1,1))/
                                       zone_VDF.<a class="code" href="classZone__VDF.html#a16d2b5b0bd1f52fa6aed11d2e59a10b0">dim_elem</a>(element_number,1));

          gij(element_number,1,2) = 0.5*((in_vel(num5,1)-in_vel(num2,1))/
                                         zone_VDF.<a class="code" href="classZone__VDF.html#a16d2b5b0bd1f52fa6aed11d2e59a10b0">dim_elem</a>(element_number,2));
          gij(element_number,2,1) = 0.5*((in_vel(num4,2)-in_vel(num1,2))/
                                         zone_VDF.<a class="code" href="classZone__VDF.html#a16d2b5b0bd1f52fa6aed11d2e59a10b0">dim_elem</a>(element_number,1));

          gij(element_number,2,2)=0.5*((in_vel(num5,2)-in_vel(num2,2))/
                                       zone_VDF.<a class="code" href="classZone__VDF.html#a16d2b5b0bd1f52fa6aed11d2e59a10b0">dim_elem</a>(element_number,2));

        }
    }

  <span class="keywordflow">return</span> gij;

}
</pre></div>
</div>
</div>
<a class="anchor" id="aa9df636d19ddaaefc669ba3a26a0e561"></a><!-- doxytag: member="Champ_Face::calcul_duidxj" ref="aa9df636d19ddaaefc669ba3a26a0e561" args="(const DoubleTab &amp;, DoubleTab &amp;, const Zone_Cl_VDF &amp;) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDoubleTab.html">DoubleTab</a> &amp; Champ_Face::calcul_duidxj </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>vitesse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>gij</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classZone__Cl__VDF.html">Zone_Cl_VDF</a> &amp;&#160;</td>
          <td class="paramname"><em>zone_Cl_VDF</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>&lt; arete de type periodicite</p>
<p>&lt; dui/dxj</p>
<p>&lt; duj/dxi</p>
<p>&lt; dui/dxj</p>
<p>&lt; vitesse tangentielle Dans cette partie, on conserve le codage de Hyd_SGE_Wale_VDF (num1 et non num2) pour calculer la distance entre le centre de la maille et le bord. </p>
</p>

<p>Definition at line <a class="el" href="Champ__Face3_8cpp_source.html#l00682">682</a> of file <a class="el" href="Champ__Face3_8cpp_source.html">Champ_Face3.cpp</a>.</p>

<p>References <a class="el" href="Objet__U_8h_source.html#l00079">Objet_U::dimension</a>, <a class="el" href="Double_8h_source.html#l00273">est_egal()</a>, <a class="el" href="Champ__Face_8h_source.html#l00119">la_zone_VDF</a>, <a class="el" href="MorEqn_8h_source.html#l00060">MorEqn::mon_equation</a>, <a class="el" href="Zone_8h_source.html#l00319">Zone::nb_elem_tot()</a>, <a class="el" href="Cast_8h_source.html#l00059">ref_cast</a>, <a class="el" href="Zone__Cl__VDF_8h_source.html#l00124">Zone_Cl_VDF::type_arete_bord()</a>, <a class="el" href="Zone__Cl__VDF_8h_source.html#l00134">Zone_Cl_VDF::type_arete_coin()</a>, <a class="el" href="Champ__Face_8cpp_source.html#l00317">val_imp_face_bord_private()</a>, <a class="el" href="Ref__Zone__VDF_8h_source.html#l00028">Ref_Zone_VDF::valeur()</a>, <a class="el" href="Ref__Equation__base_8h_source.html#l00028">Ref_Equation_base::valeur()</a>, and <a class="el" href="Zone__dis__base_8h_source.html#l00106">Zone_dis_base::zone()</a>.</p>
<div class="fragment"><pre class="fragment">{

  <span class="keyword">const</span> <a class="code" href="classChamp__Face.html" title="class Champ_Face Cette classe sert a representer un champ vectoriel dont on ne calcule que les compos...">Champ_Face</a>&amp; vit = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classChamp__Face.html" title="class Champ_Face Cette classe sert a representer un champ vectoriel dont on ne calcule que les compos...">Champ_Face</a>, <a class="code" href="classMorEqn.html#a47b12fa29b57783a8a5897f7611e2176">mon_equation</a>-&gt;inconnue().<a class="code" href="classRef__Equation__base.html#a7bb6fb60cb55bef0eef1b0e8718300a4">valeur</a>());
  <span class="keyword">const</span> <a class="code" href="classZone__VDF.html" title="class Zone_VDF Classe instanciable qui derive de Zone_VF. Cette classe contient les informations geom...">Zone_VDF</a>&amp; zone_VDF = <a class="code" href="classChamp__Face.html#a84b6abcd128000e1d5759caaa7ae0dee">la_zone_VDF</a>.<a class="code" href="classRef__Zone__VDF.html#a84151da4db745d02791d6246e3682b67">valeur</a>();
  <span class="keywordtype">int</span> nb_elem = zone_VDF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#aa3a33e8b723618b9092460007153e42d" title="Renvoie le nombre total d&#39;elements de la zone.">nb_elem_tot</a>();
  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; face_voisins = zone_VDF.face_voisins();
  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; elem_faces = zone_VDF.elem_faces();
  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; Qdm = zone_VDF.Qdm();
  <span class="keyword">const</span> <a class="code" href="classIntVect.html">IntVect</a>&amp; orientation = zone_VDF.orientation();

  <span class="keywordtype">int</span> premiere_arete_mixte = zone_VDF.premiere_arete_mixte();
  <span class="keywordtype">int</span> premiere_arete_interne =  zone_VDF.premiere_arete_interne();
  <span class="keywordtype">int</span> derniere_arete_mixte = premiere_arete_mixte+zone_VDF.nb_aretes_mixtes();
  <span class="keywordtype">int</span> derniere_arete_interne = premiere_arete_interne+zone_VDF.nb_aretes_internes();
  <span class="keywordtype">int</span> elem;
  <span class="keywordtype">int</span> num_arete;
  <a class="code" href="classIntVect.html">IntVect</a> element(4);

  <span class="keywordtype">int</span> num0,num1,num2,num3,signe;
  <span class="keywordtype">int</span> ndeb = zone_VDF.premiere_arete_bord();
  <span class="keywordtype">int</span> nfin = ndeb + zone_VDF.nb_aretes_bord();
  <span class="keywordtype">int</span> n_type;

  gij = 0.;


<span class="comment">//</span>
<span class="comment">// On parcourt toutes les aretes qui permettent</span>
<span class="comment">// de calculer les termes croises dui/dxj.</span>
<span class="comment">// </span>
<span class="comment">// (les termes non-croises sont calcules</span>
<span class="comment">// en bouclant sur les elements)</span>
<span class="comment">//</span>

  <span class="keywordflow">for</span> (num_arete=ndeb; num_arete&lt;nfin; num_arete++)
    {
      n_type=zone_Cl_VDF.<a class="code" href="classZone__Cl__VDF.html#ae99f1fd7eda112296855c945b44aa85c">type_arete_bord</a>(num_arete-ndeb);

      <span class="keywordflow">if</span> (n_type == 4) <span class="comment">//!&lt; arete de type periodicite</span>
<span class="comment"></span>        {
          num0 = Qdm(num_arete,0);
          num1 = Qdm(num_arete,1);
          num2 = Qdm(num_arete,2);
          num3 = Qdm(num_arete,3);
          <span class="keywordtype">int</span> i=0;
          <span class="keywordtype">int</span> j=0;
          i=orientation(num0);
          j=orientation(num2);

          <span class="keywordtype">double</span> temp1 = (vitesse[num1]-vitesse[num0])
                         /zone_VDF.dist_face_period(num0,num1,j);            <span class="comment">//!&lt; dui/dxj</span>
<span class="comment"></span>          <span class="keywordtype">double</span> temp2 = (vitesse[num3]-vitesse[num2])
                         /zone_VDF.dist_face_period(num2,num3,i);            <span class="comment">//!&lt; duj/dxi</span>
<span class="comment"></span>          element(0) = face_voisins(num0,0);
          element(1) = face_voisins(num0,1);
          element(2) = face_voisins(num1,0);
          element(3) = face_voisins(num1,1);
          <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k=0 ; k&lt;4 ; k++)
            {
              gij(element(k),i,j)+=temp1*0.5*0.25;
              gij(element(k),j,i)+=temp2*0.5*0.25;

<span class="comment">// Justification des coeff derriere :</span>
<span class="comment">// 1) 0.5 : pour la periodicite,</span>
<span class="comment">// car on distribuera deux fois sur</span>
<span class="comment">// les elements qui &quot;touchent&quot; cette arete</span>
<span class="comment">// puisqu&#39;elle existe en double.</span>
<span class="comment">// 2) 0.25 : on distribue le gradient de vitesse</span>
<span class="comment">// sur les 4 elements qui l&#39;entourent.</span>
            }        <span class="comment">//!&lt; fin du for k</span>
<span class="comment"></span>        }
      <span class="keywordflow">else</span>
        {
          num0 = Qdm(num_arete,0);
          num1 = Qdm(num_arete,1);
          num2 = Qdm(num_arete,2);
          signe = Qdm(num_arete,3);
          <span class="keywordtype">int</span> j=0;
          j=orientation(num2);

          <span class="keywordtype">double</span> temp2;
          <span class="keywordtype">double</span> temp1 = (vitesse[num1]-vitesse[num0])
                         /zone_VDF.dist_face_period(num0,num1,j);        <span class="comment">//!&lt; dui/dxj</span>
<span class="comment"></span>          <span class="keywordtype">double</span> vit_imp = 0.5*(vit.<a class="code" href="classChamp__Face.html#a613ea150dbc6a9b5f288011f90484381">val_imp_face_bord_private</a>(num0,j)+
                                vit.<a class="code" href="classChamp__Face.html#a613ea150dbc6a9b5f288011f90484381">val_imp_face_bord_private</a>(num1,j));                <span class="comment">//!&lt; vitesse tangentielle Dans cette partie, on conserve le codage de Hyd_SGE_Wale_VDF (num1 et non num2) pour calculer la distance entre le centre de la maille et le bord.</span>
<span class="comment"></span><span class="comment">//</span>
<span class="comment">//</span>

          temp2 = -signe*(vitesse[num2]-vit_imp)/zone_VDF.dist_norm_bord(num1);

          element(0) = face_voisins(num2,0);
          element(1) = face_voisins(num2,1);

          <span class="keywordtype">int</span> i=orientation(num0);

          <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k=0 ; k&lt;2 ; k++)
            {
              gij(element(k),i,j)+=temp1*0.25;
              gij(element(k),j,i)+=temp2*0.25;

<span class="comment">// Justification des coeff derriere :</span>
<span class="comment">// 1) 0.25 : on distribue le gradient de vitesse</span>
<span class="comment">// sur les 4 elements qui l&#39;entourent.</span>
            } <span class="comment">//!&lt; fin du for k</span>
<span class="comment"></span>        }
    }


  <span class="comment">//*******************************</span>
  <span class="comment">//On parcourt les aretes coins</span>
  <span class="comment">//*******************************</span>

  ndeb = zone_VDF.premiere_arete_coin();
  nfin = ndeb + zone_VDF.nb_aretes_coin();

  <span class="keywordflow">for</span> (num_arete=ndeb; num_arete&lt;nfin; num_arete++)
    {
      n_type=zone_Cl_VDF.<a class="code" href="classZone__Cl__VDF.html#ae0bee7198d75e43dbc46a5b4e181b736">type_arete_coin</a>(num_arete-ndeb);
      <span class="comment">//***************************************</span>
      <span class="comment">// Traitement des aretes coin perio-perio</span>
      <span class="comment">//***************************************</span>

      <span class="keywordflow">if</span> (n_type == 0) <span class="comment">// arete de type periodicite-periodicite</span>
        {
          num0 = Qdm(num_arete,0);
          num1 = Qdm(num_arete,1);
          num2 = Qdm(num_arete,2);
          num3 = Qdm(num_arete,3);
          <span class="keywordtype">int</span> i=0;
          <span class="keywordtype">int</span> j=0;
          i=orientation(num0);
          j=orientation(num2);

          <span class="keywordtype">double</span> temp1 = (vitesse[num1]-vitesse[num0])
                         /zone_VDF.dist_face_period(num0,num1,j);        <span class="comment">// dui/dxj</span>
          <span class="keywordtype">double</span> temp2 = (vitesse[num3]-vitesse[num2])
                         /zone_VDF.dist_face_period(num2,num3,i);        <span class="comment">// duj/dxi</span>
          element(0) = face_voisins(num0,0);
          element(1) = face_voisins(num0,1);
          element(2) = face_voisins(num1,0);
          element(3) = face_voisins(num1,1);
          <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k=0 ; k&lt;4 ; k++)
            {
              gij(element(k),i,j)+=temp1*0.5*0.5*0.25;
              gij(element(k),j,i)+=temp2*0.5*0.5*0.25;

              <span class="comment">// Justification des coeff derriere :</span>
              <span class="comment">// 1) 0.5 : pour la periodicite,</span>
              <span class="comment">//           car on distribuera deux fois sur</span>
              <span class="comment">//           les elements qui &quot;touchent&quot; cette arete</span>
              <span class="comment">//           puisqu&#39;elle existe en double.</span>
              <span class="comment">// 2) 0.5 : idem ci-dessus, car cette fois-ci on a</span>
              <span class="comment">//           un coin perio-perio.</span>
              <span class="comment">// 3) 0.25 : on distribue le gradient de vitesse</span>
              <span class="comment">//            sur les 4 elements qui l&#39;entourent.</span>
            } <span class="comment">// fin du for k</span>

        }

      <span class="comment">//***************************************</span>
      <span class="comment">// Traitement des aretes coin perio-paroi</span>
      <span class="comment">//***************************************</span>
      <span class="keywordflow">if</span> (n_type == 1) <span class="comment">// arete de type periodicite-paroi</span>
        {
          num0 = Qdm(num_arete,0);
          num1 = Qdm(num_arete,1);
          num2 = Qdm(num_arete,2);
          signe = Qdm(num_arete,3);
          <span class="keywordtype">int</span> j=0;
          j=orientation(num2);

          <span class="keywordtype">double</span> temp2;
          <span class="keywordtype">double</span> temp1 = (vitesse[num1]-vitesse[num0])
                         /zone_VDF.dist_face_period(num0,num1,j);                <span class="comment">// dui/dxj</span>
          <span class="keywordtype">double</span> vit_imp = 0.5*(vit.<a class="code" href="classChamp__Face.html#a613ea150dbc6a9b5f288011f90484381">val_imp_face_bord_private</a>(num0,j)+
                                vit.<a class="code" href="classChamp__Face.html#a613ea150dbc6a9b5f288011f90484381">val_imp_face_bord_private</a>(num1,j));        <span class="comment">// vitesse tangentielle</span>

          temp2  = -signe*(vitesse[num2]-vit_imp)/zone_VDF.dist_norm_bord(num1);

          element(0) = face_voisins(num2,0);
          element(1) = face_voisins(num2,1);

          <span class="keywordtype">int</span> i=orientation(num1);

          <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k=0 ; k&lt;2 ; k++)
            {
              gij(element(k),i,j)+=temp1*0.5*0.25;
              gij(element(k),j,i)+=temp2*0.5*0.25;

              <span class="comment">// Justification des coeff derriere :</span>
              <span class="comment">// 1) 0.5 : pour la periodicite,</span>
              <span class="comment">//           car on distribuera deux fois sur</span>
              <span class="comment">//           les elements qui &quot;touchent&quot; cette arete</span>
              <span class="comment">//           puisqu&#39;elle existe en double.</span>
              <span class="comment">// 2) 0.25 : on distribue le gradient de vitesse</span>
              <span class="comment">//            sur les 4 elements qui l&#39;entourent.</span>
            } <span class="comment">// fin du for k</span>
        }
    }


  <span class="comment">// 1ere partie:boucles sur les aretes et remplissage de Sij pour la partie</span>
  <span class="comment">// derivees croisees (dui/dxj)</span>
  <span class="comment">// vitesse[face] renvoie la vitesse NORMALE a la face</span>
  <span class="comment">//   for (num_arete = premiere_arete_bord ; num_arete&lt;derniere_arete_bord ; num_arete ++)</span>
  <span class="comment">//     {</span>
  <span class="comment">//       const IntVect&amp; type_arete_bord = zone_Cl_VDF.type_arete_bord();</span>


  <span class="keywordflow">for</span>(num_arete=premiere_arete_mixte ; num_arete&lt;derniere_arete_mixte ; num_arete ++)
    {
      num0 = Qdm(num_arete,0);
      num1 = Qdm(num_arete,1);
      num2 = Qdm(num_arete,2);
      num3 = Qdm(num_arete,3);
      <span class="keywordtype">int</span> i=0;
      <span class="keywordtype">int</span> j=0;
      i=orientation(num0);
      j=orientation(num2);

      <span class="keywordtype">double</span> temp1 = (vitesse[num1]-vitesse[num0])
                     /zone_VDF.dist_face_period(num0,num1,j);        <span class="comment">// dui/dxj</span>
      <span class="keywordtype">double</span> temp2 = (vitesse[num3]-vitesse[num2])
                     /zone_VDF.dist_face_period(num2,num3,i);        <span class="comment">// duj/dxi</span>

      element(0) = face_voisins(num0,0);
      element(1) = face_voisins(num0,1);
      element(2) = face_voisins(num1,0);
      element(3) = face_voisins(num1,1);

      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k=0 ; k&lt;4 ; k++)
        {
          <span class="keywordflow">if</span> (element(k)!=-1)
            {
              gij(element(k),i,j)+=temp1*0.25;
              gij(element(k),j,i)+=temp2*0.25;

              <span class="comment">// Justification des coeff derriere :</span>
              <span class="comment">// 1) 0.25 : on distribue le gradient de vitesse</span>
              <span class="comment">//            sur les 3 elements qui l&#39;entourent.</span>
              <span class="comment">//            C&#39;est pour cela que l&#39;on regarde si element(k)!=-1,</span>
              <span class="comment">//            car dans ce cas la, c&#39;est qu&#39;il s&#39;agit de &quot;la case qui manque&quot; !</span>
            } <span class="comment">// fin de else if</span>
        } <span class="comment">// fin du for k</span>
    } <span class="comment">// fin de la boucle sur les aretes mixtes</span>


  <span class="keywordflow">for</span> (num_arete=premiere_arete_interne ; num_arete&lt;derniere_arete_interne ; num_arete ++)
    {
      num0 = Qdm(num_arete,0);
      num1 = Qdm(num_arete,1);
      num2 = Qdm(num_arete,2);
      num3 = Qdm(num_arete,3);
      <span class="keywordtype">int</span> i=0;
      <span class="keywordtype">int</span> j=0;
      i=orientation(num0);
      j=orientation(num2);

      <span class="keywordtype">double</span> temp1 = (vitesse[num1]-vitesse[num0])
                     /zone_VDF.dist_face_period(num0,num1,j);        <span class="comment">// dui/dxj</span>
      assert(<a class="code" href="Double_8h.html#ac86f5f350b0f95fd8c34b0ac8d720f6f">est_egal</a>(zone_VDF.dist_face_period(num0,num1,j),zone_VDF.dist_face(num0,num1,j)));
      <span class="keywordtype">double</span> temp2 = (vitesse[num3]-vitesse[num2])
                     /zone_VDF.dist_face_period(num2,num3,i);        <span class="comment">// duj/dxi</span>
      assert(<a class="code" href="Double_8h.html#ac86f5f350b0f95fd8c34b0ac8d720f6f">est_egal</a>(zone_VDF.dist_face_period(num2,num3,j),zone_VDF.dist_face(num2,num3,j)));
      element(0) = face_voisins(num0,0);
      element(1) = face_voisins(num0,1);
      element(2) = face_voisins(num1,0);
      element(3) = face_voisins(num1,1);
      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k=0 ; k&lt;4 ; k++)
        {
          gij(element(k),i,j)+=temp1*0.25;
          gij(element(k),j,i)+=temp2*0.25;

          <span class="comment">// Justification des coeff :</span>
          <span class="comment">// 1) 0.25 : on distribue le gradient de vitesse</span>
          <span class="comment">//            sur les 4 elements qui l&#39;entourent.</span>
        } <span class="comment">// fin du for k</span>
    } <span class="comment">// fin de la boucle sur les aretes internes</span>



  <span class="comment">// 2eme partie: boucle sur les elements et remplissage de Sij pour les</span>
  <span class="comment">//  derivees non croisees (dui/dxi).</span>
  <span class="comment">// En fait dans ces cas la, on calcul directement le gradient dans l&#39;element</span>
  <span class="comment">//  et on ne redistribue pas.</span>

  <span class="keywordflow">for</span>(elem=0 ; elem&lt;nb_elem ; elem ++)
    {
      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0 ; i&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a> ; i++)
        {
          <span class="keywordtype">double</span> temp1 = (vitesse[elem_faces(elem,i)]
                          -vitesse[elem_faces(elem,i+dimension)])
                         /zone_VDF.dim_elem(elem,orientation(elem_faces(elem,i)));

          gij(elem,i,i)=-temp1;

        }
    }

  <span class="keywordflow">return</span> gij;
}
</pre></div>
</div>
</div>
<a class="anchor" id="ad4426ef99f2611353a16a374a5c2c2fb"></a><!-- doxytag: member="Champ_Face::calcul_grad_u" ref="ad4426ef99f2611353a16a374a5c2c2fb" args="(const DoubleTab &amp;, DoubleTab &amp;, const Zone_Cl_VDF &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Champ_Face::calcul_grad_u </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>vitesse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>grad_u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classZone__Cl__VDF.html">Zone_Cl_VDF</a> &amp;&#160;</td>
          <td class="paramname"><em>zone_Cl_VDF</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Champ__Face3_8cpp_source.html#l01457">1457</a> of file <a class="el" href="Champ__Face3_8cpp_source.html">Champ_Face3.cpp</a>.</p>

<p>References <a class="el" href="Champ__Face3_8cpp_source.html#l00994">calcul_duidxj()</a>, <a class="el" href="Objet__U_8h_source.html#l00079">Objet_U::dimension</a>, <a class="el" href="Champ__Face_8h_source.html#l00119">la_zone_VDF</a>, <a class="el" href="Zone__dis__base_8h_source.html#l00140">Zone_dis_base::nb_elem()</a>, <a class="el" href="Zone__dis__base_8h_source.html#l00144">Zone_dis_base::nb_elem_tot()</a>, and <a class="el" href="Ref__Zone__VDF_8h_source.html#l00028">Ref_Zone_VDF::valeur()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">const</span> <a class="code" href="classZone__VDF.html" title="class Zone_VDF Classe instanciable qui derive de Zone_VF. Cette classe contient les informations geom...">Zone_VDF</a>&amp; zone_VDF = <a class="code" href="classChamp__Face.html#a84b6abcd128000e1d5759caaa7ae0dee">la_zone_VDF</a>.<a class="code" href="classRef__Zone__VDF.html#a84151da4db745d02791d6246e3682b67">valeur</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_elem = zone_VDF.<a class="code" href="classZone__dis__base.html#a790cb2f6bc2928518799e748313d0eb3">nb_elem</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_elem_tot = zone_VDF.<a class="code" href="classZone__dis__base.html#a4d6aa445f152aa6dc54d66ea7a071147">nb_elem_tot</a>();

  <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a> gradient_elem(nb_elem_tot,<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>,<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>);
  gradient_elem=0.;

  <a class="code" href="classChamp__Face.html#a97fa360dcacec544bd83d2da89a7769c">calcul_duidxj</a>(vitesse,gradient_elem,zone_Cl_VDF);

  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> elem=0; elem&lt;nb_elem; elem++)
    {
      <span class="keywordtype">int</span> comp=0;
      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; i++)
        <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j=0; j&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; j++)
          {
            grad_u(elem,comp) = gradient_elem(elem,i,j);
            comp++;
          }
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a08f4717bc89dc38dfb7b9e3627ab5592"></a><!-- doxytag: member="Champ_Face::calcul_S_barre" ref="a08f4717bc89dc38dfb7b9e3627ab5592" args="(const DoubleTab &amp;, DoubleVect &amp;, const Zone_Cl_VDF &amp;) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDoubleVect.html">DoubleVect</a> &amp; Champ_Face::calcul_S_barre </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>vitesse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;&#160;</td>
          <td class="paramname"><em>SMA_barre</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classZone__Cl__VDF.html">Zone_Cl_VDF</a> &amp;&#160;</td>
          <td class="paramname"><em>zone_Cl_VDF</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Champ__Face3_8cpp_source.html#l01427">1427</a> of file <a class="el" href="Champ__Face3_8cpp_source.html">Champ_Face3.cpp</a>.</p>

<p>References <a class="el" href="Champ__Face3_8cpp_source.html#l00994">calcul_duidxj()</a>, <a class="el" href="Objet__U_8h_source.html#l00079">Objet_U::dimension</a>, <a class="el" href="Champ__Face_8h_source.html#l00119">la_zone_VDF</a>, <a class="el" href="Zone__dis__base_8h_source.html#l00140">Zone_dis_base::nb_elem()</a>, <a class="el" href="Zone__dis__base_8h_source.html#l00144">Zone_dis_base::nb_elem_tot()</a>, and <a class="el" href="Ref__Zone__VDF_8h_source.html#l00028">Ref_Zone_VDF::valeur()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">const</span> <a class="code" href="classZone__VDF.html" title="class Zone_VDF Classe instanciable qui derive de Zone_VF. Cette classe contient les informations geom...">Zone_VDF</a>&amp; zone_VDF = <a class="code" href="classChamp__Face.html#a84b6abcd128000e1d5759caaa7ae0dee">la_zone_VDF</a>.<a class="code" href="classRef__Zone__VDF.html#a84151da4db745d02791d6246e3682b67">valeur</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_elem_tot = zone_VDF.<a class="code" href="classZone__dis__base.html#a4d6aa445f152aa6dc54d66ea7a071147">nb_elem_tot</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_elem = zone_VDF.<a class="code" href="classZone__dis__base.html#a790cb2f6bc2928518799e748313d0eb3">nb_elem</a>();

  <span class="keywordtype">int</span> i,j;
  <span class="keywordtype">int</span> elem;
  <span class="keywordtype">double</span> Sij,temp;

  <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a> duidxj(nb_elem_tot,<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>,<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>);

  <a class="code" href="classChamp__Face.html#a97fa360dcacec544bd83d2da89a7769c">calcul_duidxj</a>(vitesse,duidxj,zone_Cl_VDF);

  <span class="keywordflow">for</span> (elem=0 ; elem&lt;nb_elem; elem++)
    {
      temp = 0.;
      <span class="keywordflow">for</span> ( i=0 ; i&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a> ; i++)
        <span class="keywordflow">for</span> ( j=0 ; j&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a> ; j++)
          {
            Sij=0.5*(duidxj(elem,i,j) + duidxj(elem,j,i));
            temp+=Sij*Sij;
          }
      SMA_barre(elem)=2.*temp;
    }

  <span class="keywordflow">return</span> SMA_barre;

}
</pre></div>
</div>
</div>
<a class="anchor" id="a00a53900838fa2618886381781fe6d6f"></a><!-- doxytag: member="Champ_Face::calcul_S_barre_sans_contrib_paroi" ref="a00a53900838fa2618886381781fe6d6f" args="(const DoubleTab &amp;, DoubleVect &amp;, const Zone_Cl_VDF &amp;) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDoubleVect.html">DoubleVect</a> &amp; Champ_Face::calcul_S_barre_sans_contrib_paroi </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>vitesse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;&#160;</td>
          <td class="paramname"><em>SMA_barre</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classZone__Cl__VDF.html">Zone_Cl_VDF</a> &amp;&#160;</td>
          <td class="paramname"><em>zone_Cl_VDF</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Champ__Face3_8cpp_source.html#l01128">1128</a> of file <a class="el" href="Champ__Face3_8cpp_source.html">Champ_Face3.cpp</a>.</p>

<p>References <a class="el" href="Objet__U_8h_source.html#l00079">Objet_U::dimension</a>, <a class="el" href="Champ__Face_8h_source.html#l00119">la_zone_VDF</a>, <a class="el" href="MorEqn_8h_source.html#l00060">MorEqn::mon_equation</a>, <a class="el" href="Zone_8h_source.html#l00300">Zone::nb_elem()</a>, <a class="el" href="Cast_8h_source.html#l00059">ref_cast</a>, <a class="el" href="Zone__Cl__VDF_8h_source.html#l00124">Zone_Cl_VDF::type_arete_bord()</a>, <a class="el" href="Zone__Cl__VDF_8h_source.html#l00134">Zone_Cl_VDF::type_arete_coin()</a>, <a class="el" href="Champ__Face_8cpp_source.html#l00317">val_imp_face_bord_private()</a>, <a class="el" href="Ref__Zone__VDF_8h_source.html#l00028">Ref_Zone_VDF::valeur()</a>, <a class="el" href="Ref__Equation__base_8h_source.html#l00028">Ref_Equation_base::valeur()</a>, and <a class="el" href="Zone__dis__base_8h_source.html#l00106">Zone_dis_base::zone()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="comment">// On calcule directement S_barre(num_elem)!!!!!!!!!!</span>
  <span class="comment">// Le parametre contribution_paroi (ici fixe a 0) permet de ne pas prendre en compte</span>
  <span class="comment">// la contribution de la paroi au produit SMA_barre = Sij*Sij</span>

  <span class="keywordtype">int</span> contribution_paroi;
  contribution_paroi=0;

  <span class="keyword">const</span> <a class="code" href="classChamp__Face.html" title="class Champ_Face Cette classe sert a representer un champ vectoriel dont on ne calcule que les compos...">Champ_Face</a>&amp; vit = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classChamp__Face.html" title="class Champ_Face Cette classe sert a representer un champ vectoriel dont on ne calcule que les compos...">Champ_Face</a>, <a class="code" href="classMorEqn.html#a47b12fa29b57783a8a5897f7611e2176">mon_equation</a>-&gt;inconnue().<a class="code" href="classRef__Equation__base.html#a7bb6fb60cb55bef0eef1b0e8718300a4">valeur</a>());
  <span class="keyword">const</span> <a class="code" href="classZone__VDF.html" title="class Zone_VDF Classe instanciable qui derive de Zone_VF. Cette classe contient les informations geom...">Zone_VDF</a>&amp; zone_VDF = <a class="code" href="classChamp__Face.html#a84b6abcd128000e1d5759caaa7ae0dee">la_zone_VDF</a>.<a class="code" href="classRef__Zone__VDF.html#a84151da4db745d02791d6246e3682b67">valeur</a>();

  <span class="keywordtype">int</span> nb_elem = zone_VDF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#a7f249429803b27139a1c54436f6164a5" title="Renvoie le nombre d&#39;elements de la zone.">nb_elem</a>();
  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; face_voisins = zone_VDF.face_voisins();
  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; elem_faces = zone_VDF.elem_faces();
  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; Qdm = zone_VDF.Qdm();
  <span class="keyword">const</span> <a class="code" href="classIntVect.html">IntVect</a>&amp; orientation = zone_VDF.orientation();

  <span class="keywordtype">int</span> premiere_arete_mixte = zone_VDF.premiere_arete_mixte();
  <span class="keywordtype">int</span> premiere_arete_interne =  zone_VDF.premiere_arete_interne();
  <span class="keywordtype">int</span> derniere_arete_mixte = premiere_arete_mixte+zone_VDF.nb_aretes_mixtes();
  <span class="keywordtype">int</span> derniere_arete_interne = premiere_arete_interne+zone_VDF.nb_aretes_internes();
  <span class="keywordtype">int</span> elem;
  <span class="keywordtype">int</span> num_arete;
  <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> element(4);

  <span class="keywordtype">int</span> num0,num1,num2,num3,signe;
  <span class="keywordtype">int</span> ndeb = zone_VDF.premiere_arete_bord();
  <span class="keywordtype">int</span> nfin = ndeb + zone_VDF.nb_aretes_bord();
  <span class="keywordtype">int</span> n_type;

  <span class="keywordflow">for</span> (num_arete=ndeb; num_arete&lt;nfin; num_arete++)
    {
      n_type=zone_Cl_VDF.<a class="code" href="classZone__Cl__VDF.html#ae99f1fd7eda112296855c945b44aa85c">type_arete_bord</a>(num_arete-ndeb);

      <span class="keywordflow">if</span> (n_type == 4) <span class="comment">// arete de type periodicite</span>
        {
          num0 = Qdm(num_arete,0);
          num1 = Qdm(num_arete,1);
          num2 = Qdm(num_arete,2);
          num3 = Qdm(num_arete,3);
          <span class="keywordtype">int</span> i=0;
          <span class="keywordtype">int</span> j=0;
          i=orientation(num0);
          j=orientation(num2);

          <span class="keywordtype">double</span> temp1 = (vitesse[num1]-vitesse[num0])
                         /zone_VDF.dist_face_period(num0,num1,j);            <span class="comment">// dv/dx</span>
          <span class="keywordtype">double</span> temp2 = (vitesse[num3]-vitesse[num2])
                         /zone_VDF.dist_face_period(num2,num3,i);            <span class="comment">// du/dy</span>
          element(0) = face_voisins(num0,0);
          element(1) = face_voisins(num0,1);
          element(2) = face_voisins(num1,0);
          element(3) = face_voisins(num1,1);
          <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k=0 ; k&lt;4 ; k++)
            {
              SMA_barre(element(k))+=0.5*(temp1+temp2)*(temp1+temp2)*0.25;
              <span class="comment">// Justification du coeff :</span>
              <span class="comment">// on calcule la somme des termes croises :</span>
              <span class="comment">// 2*( (0.5*Sij)^2+(0.5*Sji)^2)</span>
              <span class="comment">// Comme on est sur les aretes et qu on distribue sur l&#39;element</span>
              <span class="comment">// il faut multiplier par 0.25</span>
              <span class="comment">// d ou : 0.25*(2*(2*0.5^2))=0.25*4*0.25=0.25!!!!!!</span>
              <span class="comment">// le 0.5 devant vient du fait que nous parcourons les faces de periodicite</span>
              <span class="comment">// comme les aretes periodiques sont les &quot;memes&quot;, on ajoute deux fois ce qu il faut</span>
              <span class="comment">// aux elements -&gt; 0.5!!!</span>
            }        <span class="comment">// fin du for k</span>
        }
      <span class="keywordflow">else</span>
        {
          num0 = Qdm(num_arete,0);
          num1 = Qdm(num_arete,1);
          num2 = Qdm(num_arete,2);
          signe = Qdm(num_arete,3);
          <span class="keywordtype">int</span> j=0;
          j=orientation(num2);

          <span class="keywordtype">double</span> temp2;
          <span class="keywordtype">double</span> temp1 = (vitesse[num1]-vitesse[num0])
                         /zone_VDF.dist_face_period(num0,num1,j);        <span class="comment">// dv/dx</span>
          <span class="keywordtype">double</span> vit_imp = 0.5*(vit.<a class="code" href="classChamp__Face.html#a613ea150dbc6a9b5f288011f90484381">val_imp_face_bord_private</a>(num0,j)+
                                vit.<a class="code" href="classChamp__Face.html#a613ea150dbc6a9b5f288011f90484381">val_imp_face_bord_private</a>(num1,j));                <span class="comment">// vitesse tangentielle</span>

          <span class="keywordflow">if</span> ( n_type == 0 &amp;&amp; contribution_paroi == 0 )
            temp2 = 0;
          <span class="keywordflow">else</span>
            temp2  = -signe*(vitesse[num2]-vit_imp)/zone_VDF.dist_norm_bord(num1);

          element(0) = face_voisins(num2,0);
          element(1) = face_voisins(num2,1);

          <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k=0 ; k&lt;2 ; k++)
            {
              SMA_barre(element(k))+=(temp1+temp2)*(temp1+temp2)*0.25;
              <span class="comment">// Justification du coeff :</span>
              <span class="comment">// on calcule la somme des termes croises :</span>
              <span class="comment">// 2*( (0.5*Sij)^2+(0.5*Sji)^2)</span>
              <span class="comment">// Comme on est sur les aretes et qu on distribue sur l&#39;element</span>
              <span class="comment">// il faut multiplier par 0.25</span>
              <span class="comment">// d ou : 0.25*(2*(2*0.5^2))=0.25*4*0.25=0.25!!!!!!</span>
              <span class="comment">// Prise en compte des 2 termes symetriques : SijSij+SjiSji</span>
            }                <span class="comment">// fin du for k</span>
        }
    }

<span class="comment"></span>
<span class="comment">  /////////////////////////////////</span>
<span class="comment"></span>  <span class="comment">//On parcourt les aretes coins</span><span class="comment"></span>
<span class="comment">  ////////////////////////////////</span>
<span class="comment"></span>
  ndeb = zone_VDF.premiere_arete_coin();
  nfin = ndeb + zone_VDF.nb_aretes_coin();

  <span class="keywordflow">for</span> (num_arete=ndeb; num_arete&lt;nfin; num_arete++)
    {
      n_type=zone_Cl_VDF.<a class="code" href="classZone__Cl__VDF.html#ae0bee7198d75e43dbc46a5b4e181b736">type_arete_coin</a>(num_arete-ndeb);<span class="comment"></span>
<span class="comment">      //////////////////////////////////////////</span>
<span class="comment"></span>      <span class="comment">// Traitement des aretes coin perio-perio</span><span class="comment"></span>
<span class="comment">      //////////////////////////////////////////</span>
<span class="comment"></span>
      <span class="keywordflow">if</span> (n_type == 0) <span class="comment">// arete de type periodicite-periodicite</span>
        {
          num0 = Qdm(num_arete,0);
          num1 = Qdm(num_arete,1);
          num2 = Qdm(num_arete,2);
          num3 = Qdm(num_arete,3);
          <span class="keywordtype">int</span> i=0;
          <span class="keywordtype">int</span> j=0;
          i=orientation(num0);
          j=orientation(num2);

          <span class="keywordtype">double</span> temp1 = (vitesse[num1]-vitesse[num0])
                         /zone_VDF.dist_face_period(num0,num1,j);            <span class="comment">// dv/dx</span>
          <span class="keywordtype">double</span> temp2 = (vitesse[num3]-vitesse[num2])
                         /zone_VDF.dist_face_period(num2,num3,i);            <span class="comment">// du/dy</span>
          element(0) = face_voisins(num0,0);
          element(1) = face_voisins(num0,1);
          element(2) = face_voisins(num1,0);
          element(3) = face_voisins(num1,1);
          <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k=0 ; k&lt;4 ; k++)
            {
              SMA_barre(element(k))+=0.5*0.5*(temp1+temp2)*(temp1+temp2)*0.25;
              <span class="comment">// Justification du coeff :</span>
              <span class="comment">// on calcule la somme des termes croises :</span>
              <span class="comment">// 2*( (0.5*Sij)^2+(0.5*Sji)^2)</span>
              <span class="comment">// Comme on est sur les aretes et qu on distribue sur l&#39;element</span>
              <span class="comment">// il faut multiplier par 0.25</span>
              <span class="comment">// d ou : 0.25*(2*(2*0.5^2))=0.25*4*0.25=0.25!!!!!!</span>
              <span class="comment">// le 0.5 devant vient du fait que nous parcourons les faces de periodicite</span>
              <span class="comment">// comme les aretes periodiques sont les &quot;memes&quot;, on ajoute deux fois ce qu il faut</span>
              <span class="comment">// aux elements -&gt; 0.5!!!</span>
              <span class="comment">// encore un *0.5 car ce sont des aretes perio perio donc que l on parcourt 4 fois!!!!</span>
            }        <span class="comment">// fin du for k</span>

        }
<span class="comment"></span>
<span class="comment">      //////////////////////////////////////////</span>
<span class="comment"></span>      <span class="comment">// Traitement des aretes coin perio-paroi</span><span class="comment"></span>
<span class="comment">      //////////////////////////////////////////</span>
<span class="comment"></span>      <span class="keywordflow">if</span> (n_type == 1) <span class="comment">// arete de type periodicite-paroi</span>
        {
          num0 = Qdm(num_arete,0);
          num1 = Qdm(num_arete,1);
          num2 = Qdm(num_arete,2);
          signe = Qdm(num_arete,3);
          <span class="keywordtype">int</span> j=0;
          j=orientation(num2);

          <span class="keywordtype">double</span> temp2;
          <span class="keywordtype">double</span> temp1 = (vitesse[num1]-vitesse[num0])
                         /zone_VDF.dist_face_period(num0,num1,j);        <span class="comment">// dv/dx</span>
          <span class="keywordtype">double</span> vit_imp = 0.5*(vit.<a class="code" href="classChamp__Face.html#a613ea150dbc6a9b5f288011f90484381">val_imp_face_bord_private</a>(num0,j)+
                                vit.<a class="code" href="classChamp__Face.html#a613ea150dbc6a9b5f288011f90484381">val_imp_face_bord_private</a>(num1,j));             <span class="comment">// vitesse tangentielle</span>

          <span class="keywordflow">if</span> ( contribution_paroi == 0 )
            temp2 = 0;
          <span class="keywordflow">else</span>
            temp2  = -signe*(vitesse[num2]-vit_imp)/zone_VDF.dist_norm_bord(num1);

          element(0) = face_voisins(num2,0);
          element(1) = face_voisins(num2,1);

          <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k=0 ; k&lt;2 ; k++)
            {
              SMA_barre(element(k))+=0.5*(temp1+temp2)*(temp1+temp2)*0.25;
              <span class="comment">// Justification du coeff :</span>
              <span class="comment">// on calcule la somme des termes croises :</span>
              <span class="comment">// 2*( (0.5*Sij)^2+(0.5*Sji)^2)</span>
              <span class="comment">// Comme on est sur les aretes et qu on distribue sur l&#39;element</span>
              <span class="comment">// il faut multiplier par 0.25</span>
              <span class="comment">// d ou : 0.25*(2*(2*0.5^2))=0.25*4*0.25=0.25!!!!!!</span>
              <span class="comment">// Prise en compte des 2 termes symetriques : SijSij+SjiSji</span>
              <span class="comment">// encore un *0.5 car ce sont des aretes perio perio donc que l on parcourt 2 fois!!!!</span>

            }                <span class="comment">// fin du for k</span>
        }
    }


  <span class="comment">// 1ere partie:boucles sur les aretes et remplissage de Sij pour la partie</span>
  <span class="comment">// derivees croisees (dv/dx+du/dy)</span>
  <span class="comment">// vitesse[face] renvoie la vitesse NORMALE a la face</span>
  <span class="comment">//   for (num_arete = premiere_arete_bord ; num_arete&lt;derniere_arete_bord ; num_arete ++)</span>
  <span class="comment">//     {</span>
  <span class="comment">//       const IntVect&amp; type_arete_bord = zone_Cl_VDF.type_arete_bord();</span>


  <span class="keywordflow">for</span>(num_arete=premiere_arete_mixte ; num_arete&lt;derniere_arete_mixte ; num_arete ++)
    {
      num0 = Qdm(num_arete,0);
      num1 = Qdm(num_arete,1);
      num2 = Qdm(num_arete,2);
      num3 = Qdm(num_arete,3);
      <span class="keywordtype">int</span> i=0;
      <span class="keywordtype">int</span> j=0;
      i=orientation(num0);
      j=orientation(num2);

      <span class="keywordtype">double</span> temp1 = (vitesse[num1]-vitesse[num0])
                     /zone_VDF.dist_face_period(num0,num1,j);          <span class="comment">// dv/dx</span>
      <span class="keywordtype">double</span> temp2 = (vitesse[num3]-vitesse[num2])
                     /zone_VDF.dist_face_period(num2,num3,i);          <span class="comment">// du/dy</span>

      element(0) = face_voisins(num0,0);
      element(1) = face_voisins(num0,1);
      element(2) = face_voisins(num1,0);
      element(3) = face_voisins(num1,1);

      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k=0 ; k&lt;4 ; k++)
        {
          <span class="keywordflow">if</span> (element(k)!=-1)
            {
              SMA_barre(element(k))+=(temp1+temp2)*(temp1+temp2)*0.25;
              <span class="comment">// Justification du coeff :</span>
              <span class="comment">// on calcule la somme des termes croises :</span>
              <span class="comment">// 2*( (0.5*Sij)^2+(0.5*Sji)^2)</span>
              <span class="comment">// Comme on est sur les aretes et qu on distribue sur l&#39;element</span>
              <span class="comment">// il faut multiplier par 0.25</span>
              <span class="comment">// d ou : 0.25*(2*(2*0.5^2))=0.25*4*0.25=0.25!!!!!!</span>
              <span class="comment">// Prise en compte des 2 termes symetriques : SijSij+SjiSji</span>
            }        <span class="comment">// fin de else if</span>
        }                <span class="comment">// fin du for k</span>
    }                <span class="comment">// fin de la boucle sur les aretes mixtes</span>


  <span class="keywordflow">for</span> (num_arete=premiere_arete_interne ; num_arete&lt;derniere_arete_interne ; num_arete ++)
    {
      num0 = Qdm(num_arete,0);
      num1 = Qdm(num_arete,1);
      num2 = Qdm(num_arete,2);
      num3 = Qdm(num_arete,3);
      <span class="keywordtype">int</span> i=0;
      <span class="keywordtype">int</span> j=0;
      i=orientation(num0);
      j=orientation(num2);

      <span class="keywordtype">double</span> temp1 = (vitesse[num1]-vitesse[num0])
                     /zone_VDF.dist_face_period(num0,num1,j);            <span class="comment">// dv/dx</span>
      <span class="keywordtype">double</span> temp2 = (vitesse[num3]-vitesse[num2])
                     /zone_VDF.dist_face_period(num2,num3,i);            <span class="comment">// du/dy</span>
      element(0) = face_voisins(num0,0);
      element(1) = face_voisins(num0,1);
      element(2) = face_voisins(num1,0);
      element(3) = face_voisins(num1,1);
      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k=0 ; k&lt;4 ; k++)
        {
          SMA_barre(element(k))+=(temp1+temp2)*(temp1+temp2)*0.25;
          <span class="comment">// Justification du coeff :</span>
          <span class="comment">// on calcule la somme des termes croises :</span>
          <span class="comment">// 2*( (0.5*Sij)^2+(0.5*Sji)^2)</span>
          <span class="comment">// Comme on est sur les aretes et qu on distribue sur l&#39;element</span>
          <span class="comment">// il faut multiplier par 0.25</span>
          <span class="comment">// d ou : 0.25*(2*(2*0.5^2))=0.25*4*0.25=0.25!!!!!!</span>
          <span class="comment">// Prise en compte des 2 termes symetriques : SijSij+SjiSji</span>
        }        <span class="comment">// fin du for k</span>
    }        <span class="comment">// fin de la boucle sur les aretes internes</span>


  <span class="comment">// 2eme partie: boucle sur les elements et remplissage de Sij pour les</span>
  <span class="comment">// derivees non croisees (du/dx et dv/dy)</span>

  <span class="keywordflow">for</span>(elem=0 ; elem&lt;nb_elem ; elem ++)
    {
      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0 ; i&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a> ; i++)
        {
          <span class="keywordtype">double</span> temp1 = (vitesse[elem_faces(elem,i)]
                          -vitesse[elem_faces(elem,i+dimension)])
                         /zone_VDF.dim_elem(elem,orientation(elem_faces(elem,i)));
          SMA_barre(elem)+=2.0*temp1*temp1;
        }
    }

  <span class="comment">// On prend la racine carre!!!!!  ATTENTION SMA_barre=invariant au carre!!!</span>
  <span class="comment">//  racine_carree(SMA_barre)</span>


  <span class="keywordflow">return</span> SMA_barre;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a7c36a9d06fd62b53ce2fe1d778f33128"></a><!-- doxytag: member="Champ_Face::calcul_y_plus" ref="a7c36a9d06fd62b53ce2fe1d778f33128" args="(DoubleTab &amp;, const Zone_Cl_VDF &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Champ_Face::calcul_y_plus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>y_plus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classZone__Cl__VDF.html">Zone_Cl_VDF</a> &amp;&#160;</td>
          <td class="paramname"><em>zone_Cl_VDF</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>&lt; will contain yplus values if available</p>
<p>&lt; flag </p>
</p>

<p>Definition at line <a class="el" href="Champ__Face3_8cpp_source.html#l00555">555</a> of file <a class="el" href="Champ__Face3_8cpp_source.html">Champ_Face3.cpp</a>.</p>

<p>References <a class="el" href="Objet__U_8h_source.html#l00082">Objet_U::axi</a>, <a class="el" href="Objet__U_8h_source.html#l00079">Objet_U::dimension</a>, <a class="el" href="Zone__VDF_8h_source.html#l00351">Zone_VDF::dist_norm_bord()</a>, <a class="el" href="Zone__VDF_8h_source.html#l00367">Zone_VDF::dist_norm_bord_axi()</a>, <a class="el" href="MorEqn_8h_source.html#l00082">MorEqn::equation()</a>, <a class="el" href="Zone__VF_8h_source.html#l00458">Zone_VF::face_voisins()</a>, <a class="el" href="Cond__lim_8h_source.html#l00130">Cond_lim::frontiere_dis()</a>, <a class="el" href="Equation__base_8cpp_source.html#l02174">Equation_base::get_modele()</a>, <a class="el" href="Champ__Face_8h_source.html#l00119">la_zone_VDF</a>, <a class="el" href="Zone__Cl__dis__base_8cpp_source.html#l00522">Zone_Cl_dis_base::les_conditions_limites()</a>, <a class="el" href="Mod__turb__hyd__base_8h_source.html#l00073">Mod_turb_hyd_base::loi_paroi()</a>, <a class="el" href="classEquation__base.html#a181e9899e2d927eb14c835d9d9334f46">Equation_base::milieu()</a>, <a class="el" href="Front__VF_8h_source.html#l00061">Front_VF::nb_faces()</a>, <a class="el" href="Zone__dis__base_8h_source.html#l00156">Zone_dis_base::nb_front_Cl()</a>, <a class="el" href="O__U__Ptr_8cpp_source.html#l00098">O_U_Ptr::non_nul()</a>, <a class="el" href="distances__VDF_8cpp_source.html#l00046">norm_2D_vit()</a>, <a class="el" href="distances__VDF_8cpp_source.html#l00128">norm_3D_vit()</a>, <a class="el" href="Front__VF_8h_source.html#l00071">Front_VF::num_premiere_face()</a>, <a class="el" href="Zone__VDF_8h_source.html#l00266">Zone_VDF::orientation()</a>, <a class="el" href="DoubleTab_8cpp_source.html#l00211">DoubleTab::ref()</a>, <a class="el" href="Cast_8h_source.html#l00059">ref_cast</a>, <a class="el" href="DoubleTab_8cpp_source.html#l00335">DoubleTab::resize()</a>, <a class="el" href="Cast_8h_source.html#l00054">sub_type</a>, <a class="el" href="Equation__base_8h_source.html#l00052">TURBULENCE</a>, <a class="el" href="Cond__lim_8h_source.html#l00031">Deriv_Cond_lim_base::valeur()</a>, <a class="el" href="Ref__Objet__U_8h_source.html#l00092">Ref_Objet_U::valeur()</a>, <a class="el" href="Ref__Zone__VDF_8h_source.html#l00028">Ref_Zone_VDF::valeur()</a>, and <a class="el" href="Fluide__base_8h_source.html#l00169">Fluide_base::viscosite_cinematique()</a>.</p>
<div class="fragment"><pre class="fragment">{
<span class="comment">// On initialise le champ y_plus avec une valeur negative,</span>
<span class="comment">// comme ca lorsqu&#39;on veut visualiser le champ pres de la paroi,</span>
<span class="comment">// on n&#39;a qu&#39;a supprimer les valeurs negatives et n&#39;apparaissent</span>
<span class="comment">// que les valeurs aux parois.</span>

  <span class="keywordtype">int</span> ndeb,nfin,elem,ori,l_unif;
  <span class="keywordtype">double</span> norm_tau,u_etoile,norm_v=0, dist, val0, val1, val2, d_visco=0, visco=1.;
  y_plus=-1.;

  <span class="keyword">const</span> <a class="code" href="classChamp__Face.html" title="class Champ_Face Cette classe sert a representer un champ vectoriel dont on ne calcule que les compos...">Champ_Face</a>&amp; vit = *<span class="keyword">this</span>;
  <span class="keyword">const</span> <a class="code" href="classZone__VDF.html" title="class Zone_VDF Classe instanciable qui derive de Zone_VF. Cette classe contient les informations geom...">Zone_VDF</a>&amp; zone_VDF = <a class="code" href="classChamp__Face.html#a84b6abcd128000e1d5759caaa7ae0dee">la_zone_VDF</a>.<a class="code" href="classRef__Zone__VDF.html#a84151da4db745d02791d6246e3682b67">valeur</a>();
  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; face_voisins = zone_VDF.<a class="code" href="classZone__VF.html#a49d4322f5585a8fa95748ca785b70702" title="renvoie l&#39;element voisin de numface dans la direction i. i=0 : dans le sens oppose de l&#39;axe orthogona...">face_voisins</a>();
  <span class="keyword">const</span> <a class="code" href="classIntVect.html">IntVect</a>&amp; orientation = zone_VDF.<a class="code" href="classZone__VDF.html#a9a9bd747218e463b3408a3590c12814c" title="inline DoubleVect&amp; Zone_VDF::porosite_face() { return porosite_face_; }">orientation</a>();
  <span class="keyword">const</span> <a class="code" href="classEquation__base.html">Equation_base</a>&amp; eqn_hydr = <a class="code" href="classMorEqn.html#a615dd9abff96edcb625fa0424a489864" title="Renvoie la reference sur l&#39;equation pointe par MorEqn::mon_equation. (version const)">equation</a>();
  <span class="keyword">const</span> <a class="code" href="classFluide__base.html" title="classe Fluide_base Cette classe represente un d&#39;un fluide incompressible ainsi que ses proprietes: - ...">Fluide_base</a>&amp; le_fluide = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFluide__base.html" title="classe Fluide_base Cette classe represente un d&#39;un fluide incompressible ainsi que ses proprietes: - ...">Fluide_base</a>, eqn_hydr.<a class="code" href="classEquation__base.html#a181e9899e2d927eb14c835d9d9334f46">milieu</a>());
  <span class="keyword">const</span> <a class="code" href="classChamp__Don.html" title="classe Champ_Don Classe generique de la hierarchie des champs donnes, un objet Champ_Don peut referen...">Champ_Don</a>&amp; ch_visco_cin = le_fluide.<a class="code" href="classFluide__base.html#a37eb07407d8aa121049355ecc4f8c8dd" title="Renvoie la viscosite cinematique, nu. (vesrion const)">viscosite_cinematique</a>();
  <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; tab_visco = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>,ch_visco_cin-&gt;valeurs());
<span class="comment">// DoubleTab&amp; tab_visco = ch_visco_cin.valeur().valeurs();</span>

  <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classChamp__Uniforme.html" title="classe Champ_Uniforme Represente un champ constant dans l&#39;espace et dans le temps.">Champ_Uniforme</a>, ch_visco_cin.valeur()))
    {
      visco = tab_visco(0,0);
      l_unif = 1;
    }
  <span class="keywordflow">else</span>
    l_unif = 0;

  <span class="comment">/* GF on a pas a change tab_visco ici !</span>
<span class="comment">  if (!l_unif)</span>
<span class="comment">    {</span>
<span class="comment">      const int n = tab_visco.size_array();</span>
<span class="comment">      ArrOfDouble&amp; v = tab_visco;</span>
<span class="comment">      for (int i = 0; i &lt; n; i++)</span>
<span class="comment">        if (v[i] &lt; DMINFLOAT)</span>
<span class="comment">          v[i] = DMINFLOAT;</span>
<span class="comment">    }</span>
<span class="comment">// Changer uniquement les valeurs &lt; DMINFLOAT (l&#39;ancien code n&#39;est pas parallele)</span>
<span class="comment">  */</span>

  <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a> yplus_faces( 1, 1 ); <span class="comment">//!&lt; will contain yplus values if available</span>
<span class="comment"></span>  <span class="keywordtype">int</span> yplus_already_computed=0; <span class="comment">//!&lt; flag</span>
<span class="comment"></span>
  <span class="keyword">const</span> <a class="code" href="classRef__Objet__U.html">RefObjU</a>&amp; modele_turbulence = eqn_hydr.<a class="code" href="classEquation__base.html#ab0bb5d06bdc91e131dc9d5f9d7b57095">get_modele</a>(<a class="code" href="Equation__base_8h.html#a2c9d34b2cc47e5b2b18347de20a77db5a0fecbd75e0b8b4c37ffd696e173a14c7">TURBULENCE</a>);
  <span class="keywordflow">if</span> (modele_turbulence.<a class="code" href="classO__U__Ptr.html#a16f216b2d169e885876419182658ddcc" title="Renvoie 1 si le pointeur est non_nul Renvoie 0 sinon.">non_nul</a>() &amp;&amp; <a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classMod__turb__hyd__base.html" title="Classe Mod_turb_hyd_base Cette classe sert de base a la hierarchie des classes qui representent un mo...">Mod_turb_hyd_base</a>,modele_turbulence.<a class="code" href="classRef__Objet__U.html#ad875112c0fd275aa0c0aa710481ab11e">valeur</a>()))
    {
      <span class="keyword">const</span> <a class="code" href="classMod__turb__hyd__base.html" title="Classe Mod_turb_hyd_base Cette classe sert de base a la hierarchie des classes qui representent un mo...">Mod_turb_hyd_base</a>&amp; mod_turb = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMod__turb__hyd__base.html" title="Classe Mod_turb_hyd_base Cette classe sert de base a la hierarchie des classes qui representent un mo...">Mod_turb_hyd_base</a>,modele_turbulence.<a class="code" href="classRef__Objet__U.html#ad875112c0fd275aa0c0aa710481ab11e">valeur</a>());
      <span class="keyword">const</span> <a class="code" href="classTurbulence__paroi__base.html" title="Classe Turbulence_paroi_base Classe de base pour la hierarchie des classes representant les modeles d...">Turbulence_paroi_base</a>&amp; loipar = mod_turb.<a class="code" href="classMod__turb__hyd__base.html#ac9de8c2c64dcf77d28790e021c07c61e">loi_paroi</a>();
      <span class="keywordflow">if</span>( loipar.use_shear( ) )
        {
          yplus_faces.resize( <a class="code" href="classChamp__Face.html#a84b6abcd128000e1d5759caaa7ae0dee">la_zone_VDF</a>-&gt;nb_faces_tot( ) );
          yplus_faces.ref( loipar.tab_d_plus( ) );
          yplus_already_computed = 1;
        }
    }

  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> n_bord=0; n_bord&lt;zone_VDF.<a class="code" href="classZone__dis__base.html#af22167d614644f55591a29c77eb1c009">nb_front_Cl</a>(); n_bord++)
    {
      <span class="keyword">const</span> <a class="code" href="classCond__lim.html" title="classe Cond_lim Classe generique servant a representer n&#39;importe quelle classe derivee de la classe C...">Cond_lim</a>&amp; la_cl = zone_Cl_VDF.<a class="code" href="classZone__Cl__dis__base.html#af75e0ed7786863e4d333bfb29d67c323" title="Renvoie la i-ieme condition aux limites. (version const)">les_conditions_limites</a>(n_bord);

      <span class="keywordflow">if</span> ( <a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classDirichlet__paroi__fixe.html" title="classe Dirichlet_paroi_fixe Represente une paroi immobile dans une equation de type Navier_Stokes...">Dirichlet_paroi_fixe</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>()))
        {
          <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp; le_bord = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>,la_cl.<a class="code" href="classCond__lim.html#a5b2d24809cee07727006a891d4ce8d22" title="Appel a l&#39;objet sous-jacent Renvoie la frontiere discretisee associee a la condition aux limites...">frontiere_dis</a>());
          ndeb = le_bord.<a class="code" href="classFront__VF.html#a4986f0c65653fe9eb40bbbff5a97bf16" title="Numero de la premiere face du bord dans la liste des faces.">num_premiere_face</a>();
          nfin = ndeb + le_bord.<a class="code" href="classFront__VF.html#a341e2fcb5117b96e745fd7078ba86bab" title="Nombre de faces reelles du bord.">nb_faces</a>();


          <span class="keywordflow">for</span> (<span class="keywordtype">int</span> num_face=ndeb; num_face&lt;nfin; num_face++)
            {

              <span class="keywordflow">if</span>( face_voisins( num_face, 0 ) != -1 )
                elem = face_voisins( num_face, 0 ) ;
              <span class="keywordflow">else</span>
                elem = face_voisins( num_face, 1 ) ;

              <span class="keywordflow">if</span>( yplus_already_computed )
                {
<span class="comment">// y+ is only defined on faces so we take the face value to put in the element</span>
                  y_plus( elem ) = yplus_faces( num_face );
                }
              <span class="keywordflow">else</span>
                {

                  <span class="keywordflow">if</span> ( <a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a> == 2 )
                    {
                      ori = orientation(num_face);
                      norm_v=<a class="code" href="distances__VDF_8cpp.html#af3a381c8e91b87fe5405eefe7df5c5e3">norm_2D_vit</a>(vit,elem,ori,zone_VDF,val0);
                    }
                  <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( <a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a> == 3)
                    {
                      ori = orientation(num_face);
                      norm_v=<a class="code" href="distances__VDF_8cpp.html#a15f59f570345b3bba6c96f78698709df">norm_3D_vit</a>(vit,elem,ori,zone_VDF,val1,val2);
                    } <span class="comment">//!&lt; dim 3</span>
<span class="comment"></span>
                  <span class="keywordflow">if</span> ( <a class="code" href="classObjet__U.html#ad9b82ace9d4c7902ec704b6a78f76991">axi</a> )
                    dist=zone_VDF.<a class="code" href="classZone__VDF.html#ad0dad29b88fed624a33187ba9aad15c2">dist_norm_bord_axi</a>(num_face);
                  <span class="keywordflow">else</span>
                    dist=zone_VDF.<a class="code" href="classZone__VDF.html#a369e50f57ce994a9afe43ff2e3ff813b">dist_norm_bord</a>(num_face);
                  <span class="keywordflow">if</span> ( l_unif )
                    d_visco = visco;
                  <span class="keywordflow">else</span>
                    d_visco = tab_visco[elem];

<span class="comment">// PQ : 01/10/03 : corrections par rapport a la version premiere</span>
                  norm_tau = d_visco*norm_v/dist;

                  u_etoile = sqrt(norm_tau);
                  y_plus(elem) = dist*u_etoile/d_visco;

                } <span class="comment">//!&lt; else yplus already computed</span>
<span class="comment"></span>
            } <span class="comment">//!&lt; loop on faces</span>
<span class="comment"></span>
        } <span class="comment">//!&lt; Fin paroi fixe</span>
<span class="comment"></span>
    } <span class="comment">//!&lt; Fin boucle sur les bords</span>
<span class="comment"></span>}
</pre></div>
</div>
</div>
<a class="anchor" id="a0e6b34d29948c240cff8b96d0510ab6d"></a><!-- doxytag: member="Champ_Face::calculer_dercov_axi" ref="a0e6b34d29948c240cff8b96d0510ab6d" args="(const Zone_Cl_VDF &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Champ_Face::calculer_dercov_axi </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classZone__Cl__VDF.html">Zone_Cl_VDF</a> &amp;&#160;</td>
          <td class="paramname"><em>zone_Cl_VDF</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>&lt; bord d'equation R = cte</p>
<p>&lt; bord d'equation teta = cte</p>
<p>&lt; (ori1 == 2) bord d'equation Z = cte</p>
<p>&lt; (seule possibilite : ori3 =0) Arete XY</p>
<p>&lt; (seule possibilite ori1 = 2) arete YZ</p>
<p>&lt; seule possibilite ori1 = 2 et ori3 = 0: arete XZ </p>
</p>

<p>Definition at line <a class="el" href="Champ__Face2_8cpp_source.html#l00031">31</a> of file <a class="el" href="Champ__Face2_8cpp_source.html">Champ_Face2.cpp</a>.</p>

<p>References <a class="el" href="EntreeSortie_8h_source.html#l00032">Cerr</a>, <a class="el" href="Objet__U_8h_source.html#l00079">Objet_U::dimension</a>, <a class="el" href="Zone__VF_8h_source.html#l00574">Zone_VF::elem_faces()</a>, <a class="el" href="Double_8h_source.html#l00273">est_egal()</a>, <a class="el" href="Process_8cpp_source.html#l00223">Process::exit()</a>, <a class="el" href="Zone__Cl__VDF_8h_source.html#l00052">TypeAreteBordVDF::FLUIDE_FLUIDE</a>, <a class="el" href="Champ__Face_8h_source.html#l00119">la_zone_VDF</a>, <a class="el" href="Double_8h_source.html#l00048">M_PI</a>, <a class="el" href="Zone__VDF_8h_source.html#l00515">Zone_VDF::nb_aretes()</a>, <a class="el" href="Zone__VDF_8h_source.html#l00485">Zone_VDF::nb_aretes_bord()</a>, <a class="el" href="Zone__dis__base_8h_source.html#l00140">Zone_dis_base::nb_elem()</a>, <a class="el" href="Zone__VDF_8h_source.html#l00266">Zone_VDF::orientation()</a>, <a class="el" href="Zone__Cl__VDF_8h_source.html#l00053">TypeAreteBordVDF::PAROI_FLUIDE</a>, <a class="el" href="Zone__Cl__VDF_8h_source.html#l00051">TypeAreteBordVDF::PAROI_PAROI</a>, <a class="el" href="Zone__VDF_8h_source.html#l00491">Zone_VDF::premiere_arete_bord()</a>, <a class="el" href="Zone__VDF_8h_source.html#l00503">Zone_VDF::premiere_arete_mixte()</a>, <a class="el" href="Zone__VF_8h_source.html#l00557">Zone_VF::premiere_face_bord()</a>, <a class="el" href="Zone__VDF_8h_source.html#l00212">Zone_VDF::Qdm()</a>, <a class="el" href="Champ__Face_8h_source.html#l00122">tau_croises_</a>, <a class="el" href="Champ__Face_8h_source.html#l00121">tau_diag_</a>, <a class="el" href="Zone__Cl__VDF_8h_source.html#l00124">Zone_Cl_VDF::type_arete_bord()</a>, <a class="el" href="Champ__Face_8cpp_source.html#l00317">val_imp_face_bord_private()</a>, <a class="el" href="Ref__Zone__VDF_8h_source.html#l00028">Ref_Zone_VDF::valeur()</a>, <a class="el" href="Champ__Inc__base_8cpp_source.html#l00221">Champ_Inc_base::valeurs()</a>, <a class="el" href="Zone__VF_8h_source.html#l00700">Zone_VF::xp()</a>, and <a class="el" href="Zone__VF_8h_source.html#l00650">Zone_VF::xv()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">const</span> <a class="code" href="classZone__VDF.html" title="class Zone_VDF Classe instanciable qui derive de Zone_VF. Cette classe contient les informations geom...">Zone_VDF</a>&amp; zone_VDF = <a class="code" href="classChamp__Face.html#a84b6abcd128000e1d5759caaa7ae0dee">la_zone_VDF</a>.<a class="code" href="classRef__Zone__VDF.html#a84151da4db745d02791d6246e3682b67">valeur</a>();
  <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; inco = <a class="code" href="classChamp__Inc__base.html#adb537f43f1649e103a8980314c7ed175" title="Renvoie le tableau des valeurs du champ au temps courant.">valeurs</a>();
  <span class="keyword">const</span> <a class="code" href="classIntVect.html">IntVect</a>&amp; orientation = zone_VDF.<a class="code" href="classZone__VDF.html#a9a9bd747218e463b3408a3590c12814c" title="inline DoubleVect&amp; Zone_VDF::porosite_face() { return porosite_face_; }">orientation</a>();
  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; elem_faces = zone_VDF.<a class="code" href="classZone__VF.html#a067e462dcd3ab92b0f6d945b19e4eb37" title="renvoie le numero de le ieme face de la maille num_elem la facon dont ces faces sont numerotees est l...">elem_faces</a>();
  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; Qdm = zone_VDF.<a class="code" href="classZone__VDF.html#a5383bb6bad103f0b37e3862e112f9370">Qdm</a>();
  <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; xv = zone_VDF.<a class="code" href="classZone__VF.html#a918c0885a9b67317fcce3a0535306542">xv</a>();
  <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; xp = zone_VDF.<a class="code" href="classZone__VF.html#a87a29f0223c71256a25ee343c9277599">xp</a>();
  <span class="keyword">const</span> <a class="code" href="classIntVect.html">IntVect</a>&amp; type_arete_bord = zone_Cl_VDF.<a class="code" href="classZone__Cl__VDF.html#ae99f1fd7eda112296855c945b44aa85c">type_arete_bord</a>();

  <span class="keywordtype">double</span> d_teta,R;
  <span class="keywordtype">double</span> deux_pi = <a class="code" href="Double_8h.html#ae71449b1cc6e6250b91f539153a7a0d3">M_PI</a>*2.0;

<span class="comment">// Remplissage de tau_diag_ : termes diagonaux du tenseur GradU</span>

  <span class="keywordtype">int</span> fx0,fx1,fy0,fy1;
  <span class="keywordtype">int</span> num_elem;
  <span class="keywordflow">for</span> (num_elem=0; num_elem&lt;zone_VDF.<a class="code" href="classZone__dis__base.html#a790cb2f6bc2928518799e748313d0eb3">nb_elem</a>(); num_elem++)
    {
      fx0 = elem_faces(num_elem,0);
      fx1 = elem_faces(num_elem,<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>);
      fy0 = elem_faces(num_elem,1);
      fy1 = elem_faces(num_elem,1+<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>);

<span class="comment">// Calcul de tau11</span>
      <a class="code" href="classChamp__Face.html#a6438021756713a2835a461188753f9cc" title="termes diagonaux du tenseur Grad">tau_diag_</a>(num_elem,0) = (inco[fx1]-inco[fx0])/(xv(fx1,0) - xv(fx0,0));

<span class="comment">// Calcul de tau22</span>
      R = xp(num_elem,0);
      d_teta = xv(fy1,1) - xv(fy0,1);
      <span class="keywordflow">if</span> (d_teta &lt; 0)
        d_teta += deux_pi;
      <a class="code" href="classChamp__Face.html#a6438021756713a2835a461188753f9cc" title="termes diagonaux du tenseur Grad">tau_diag_</a>(num_elem,1) =     (inco[fy1]-inco[fy0])/(R*d_teta)
                                  + 0.5*(inco[fx0]+inco[fx1])/R;

    }

  <span class="keywordflow">if</span> (<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a> == 3)
    {
      <span class="keywordtype">int</span> fz0,fz1;
      <span class="keywordflow">for</span> (num_elem=0; num_elem&lt;zone_VDF.<a class="code" href="classZone__dis__base.html#a790cb2f6bc2928518799e748313d0eb3">nb_elem</a>(); num_elem++)
        {
          fz0 = elem_faces(num_elem,2);
          fz1 = elem_faces(num_elem,2+<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>);

<span class="comment">// Calcul de tau33</span>
          <a class="code" href="classChamp__Face.html#a6438021756713a2835a461188753f9cc" title="termes diagonaux du tenseur Grad">tau_diag_</a>(num_elem,2) = (inco[fz1]-inco[fz0])/(xv(fz1,2) - xv(fz0,2));

        }
    }

<span class="comment">// Remplissage de tau_croises_ : termes extradiagonaux du tenseur GradU</span>
<span class="comment">// Les derivees croisees de la vitesse (termes extradiagonaux du tenseur</span>
<span class="comment">// GradU) sont calculees sur les aretes.</span>
<span class="comment">// Il y a deux derivees par arete:</span>
<span class="comment">// Pour une arete XY : tau12 et tau21</span>
<span class="comment">// Pour une arete YZ : tau23 et tau32</span>
<span class="comment">// Pour une arete XZ : tau13 et tau31</span>

<span class="comment">// Boucle sur les aretes bord</span>

  <span class="keywordtype">int</span> n_arete;
  <span class="keywordtype">int</span> ndeb = zone_VDF.<a class="code" href="classZone__VDF.html#aa272d66cc2d519b88c3d5e8f0f70d700">premiere_arete_bord</a>();
  <span class="keywordtype">int</span> nfin = ndeb + zone_VDF.<a class="code" href="classZone__VDF.html#a88b3380a8314d855c0f30a138efd834c">nb_aretes_bord</a>();
  <span class="keywordtype">int</span> ori1,ori3;
  <span class="keywordtype">int</span> fac1,fac2,fac3,fac4,signe;
  <span class="keywordtype">double</span> dist3;

  <span class="keywordtype">int</span> n_type;

  <span class="keywordflow">for</span> (n_arete=ndeb; n_arete&lt;nfin; n_arete++)
    {
      n_type=type_arete_bord(n_arete-ndeb);

      <span class="keywordflow">switch</span>(n_type)
        {
        <span class="keywordflow">case</span> <a class="code" href="namespaceTypeAreteBordVDF.html#a7b1d67e793ce350d614ac4eb9966c515aa9710a2d7c9e127d8251241d728dbeca">TypeAreteBordVDF::PAROI_PAROI</a> :
<span class="comment">// paroi-paroi</span>
        <span class="keywordflow">case</span> <a class="code" href="namespaceTypeAreteBordVDF.html#a7b1d67e793ce350d614ac4eb9966c515a656b9604972e0a5da058bdc15ee527eb">TypeAreteBordVDF::FLUIDE_FLUIDE</a>:
<span class="comment">// fluide-fluide</span>
        <span class="keywordflow">case</span> <a class="code" href="namespaceTypeAreteBordVDF.html#a7b1d67e793ce350d614ac4eb9966c515ac8b6b758ccba8044caff44a9d35859aa">TypeAreteBordVDF::PAROI_FLUIDE</a>:
<span class="comment">// paroi-fluide</span>
          {
            fac1 = Qdm(n_arete,0);
            fac2 = Qdm(n_arete,1);
            fac3 = Qdm(n_arete,2);
            signe  = Qdm(n_arete,3);
            ori1 = orientation(fac1);
            ori3 = orientation(fac3);
            <span class="keywordtype">int</span> rang1 = fac1 - zone_VDF.<a class="code" href="classZone__VF.html#a9571f861dfb23f699da7042773644a42" title="renvoie le numero de la premiere des faces sur lesquelles sont appliquees les conditions limites : bo...">premiere_face_bord</a>();
            <span class="keywordtype">int</span> rang2 = fac2 - zone_VDF.<a class="code" href="classZone__VF.html#a9571f861dfb23f699da7042773644a42" title="renvoie le numero de la premiere des faces sur lesquelles sont appliquees les conditions limites : bo...">premiere_face_bord</a>();
            <span class="keywordtype">double</span> vit_imp;

            <span class="keywordflow">if</span> (n_type == <a class="code" href="namespaceTypeAreteBordVDF.html#a7b1d67e793ce350d614ac4eb9966c515ac8b6b758ccba8044caff44a9d35859aa">TypeAreteBordVDF::PAROI_FLUIDE</a>)
<span class="comment">// arete paroi_fluide :il faut determiner qui est la face fluide</span>
              {
                <span class="keywordflow">if</span> (<a class="code" href="Double_8h.html#ac86f5f350b0f95fd8c34b0ac8d720f6f">est_egal</a>(inco[fac1],0))
                  vit_imp = <a class="code" href="classChamp__Face.html#a613ea150dbc6a9b5f288011f90484381">val_imp_face_bord_private</a>(rang2,ori3);
                <span class="keywordflow">else</span>
                  vit_imp = <a class="code" href="classChamp__Face.html#a613ea150dbc6a9b5f288011f90484381">val_imp_face_bord_private</a>(rang1,ori3);
              }
            <span class="keywordflow">else</span>
              vit_imp = 0.5*(<a class="code" href="classChamp__Face.html#a613ea150dbc6a9b5f288011f90484381">val_imp_face_bord_private</a>(rang1,ori3)+
                             <a class="code" href="classChamp__Face.html#a613ea150dbc6a9b5f288011f90484381">val_imp_face_bord_private</a>(rang2,ori3));

            <span class="keywordflow">if</span> (ori1 == 0) <span class="comment">//!&lt; bord d&#39;equation R = cte</span>
<span class="comment"></span>              {
                dist3 = xv(fac3,0) - xv(fac1,0);
                <span class="keywordflow">if</span> (n_type != <a class="code" href="namespaceTypeAreteBordVDF.html#a7b1d67e793ce350d614ac4eb9966c515aa9710a2d7c9e127d8251241d728dbeca">TypeAreteBordVDF::PAROI_PAROI</a>)
                  dist3 *= 2;

                <span class="keywordflow">if</span> (ori3 == 1)
                  {
<span class="comment">// calcul de tau12</span>
                    <a class="code" href="classChamp__Face.html#a5706b082facc8da2b44e61d89d36f151" title="termes extradiagonaux du tenseur Grad">tau_croises_</a>(n_arete,0) = signe*(vit_imp-inco[fac3])/dist3;

<span class="comment">// calcul de tau21</span>
                    R = xv(fac1,0);
                    d_teta = xv(fac2,1) - xv(fac1,1);
                    <span class="keywordflow">if</span>  (d_teta &lt; 0)
                      d_teta += deux_pi;
                    <a class="code" href="classChamp__Face.html#a5706b082facc8da2b44e61d89d36f151" title="termes extradiagonaux du tenseur Grad">tau_croises_</a>(n_arete,1) = (inco[fac2]-inco[fac1])/(R*d_teta);
                  }
                <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ori3 == 2)
                  {
<span class="comment">// calcul de tau13</span>
                    <a class="code" href="classChamp__Face.html#a5706b082facc8da2b44e61d89d36f151" title="termes extradiagonaux du tenseur Grad">tau_croises_</a>(n_arete,0) = signe*(vit_imp-inco[fac3])/dist3;

<span class="comment">// calcul de tau31</span>
                    <a class="code" href="classChamp__Face.html#a5706b082facc8da2b44e61d89d36f151" title="termes extradiagonaux du tenseur Grad">tau_croises_</a>(n_arete,1) = (inco[fac2]-inco[fac1])/(xv(fac2,2)-xv(fac1,2));

                  }

              }

            <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ori1 == 1) <span class="comment">//!&lt; bord d&#39;equation teta = cte</span>
<span class="comment"></span>              {
                R = xv(fac3,0);
                d_teta = xv(fac3,1) - xv(fac1,1);
                <span class="keywordflow">if</span> (d_teta &lt; 0)
                  d_teta += deux_pi;
                dist3  = R*d_teta;
                <span class="keywordflow">if</span> (n_type != <a class="code" href="namespaceTypeAreteBordVDF.html#a7b1d67e793ce350d614ac4eb9966c515aa9710a2d7c9e127d8251241d728dbeca">TypeAreteBordVDF::PAROI_PAROI</a>)
                  dist3 *= 2;

                <span class="keywordflow">if</span> (ori3 == 0)
                  {
<span class="comment">// calcul de tau21</span>
                    <a class="code" href="classChamp__Face.html#a5706b082facc8da2b44e61d89d36f151" title="termes extradiagonaux du tenseur Grad">tau_croises_</a>(n_arete,0) = signe*(vit_imp-inco[fac3])/dist3
                                              - 0.5*(inco[fac1]+inco[fac2])/R;
<span class="comment">// calcul de tau12</span>
                    <a class="code" href="classChamp__Face.html#a5706b082facc8da2b44e61d89d36f151" title="termes extradiagonaux du tenseur Grad">tau_croises_</a>(n_arete,1) = (inco[fac2]-inco[fac1])/(xv(fac2,0) - xv(fac1,0));

                  }
                <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ori3 == 2)
                  {
<span class="comment">// calcul de tau23</span>
                    <a class="code" href="classChamp__Face.html#a5706b082facc8da2b44e61d89d36f151" title="termes extradiagonaux du tenseur Grad">tau_croises_</a>(n_arete,0) = signe*(vit_imp-inco[fac3])/dist3;
<span class="comment">// calcul de tau32</span>
                    <a class="code" href="classChamp__Face.html#a5706b082facc8da2b44e61d89d36f151" title="termes extradiagonaux du tenseur Grad">tau_croises_</a>(n_arete,1) = (inco[fac2]-inco[fac1])/(xv(fac2,2) - xv(fac1,2));
                  }
              }
            <span class="keywordflow">else</span> <span class="comment">//!&lt; (ori1 == 2) bord d&#39;equation Z = cte</span>
<span class="comment"></span>              {
                dist3 = xv(fac3,2)-xv(fac1,2);
                <span class="keywordflow">if</span> (n_type != <a class="code" href="namespaceTypeAreteBordVDF.html#a7b1d67e793ce350d614ac4eb9966c515aa9710a2d7c9e127d8251241d728dbeca">TypeAreteBordVDF::PAROI_PAROI</a>)
                  dist3 *= 2;

                <span class="keywordflow">if</span> (ori3 == <a class="code" href="namespaceTypeAreteBordVDF.html#a7b1d67e793ce350d614ac4eb9966c515aa9710a2d7c9e127d8251241d728dbeca">TypeAreteBordVDF::PAROI_PAROI</a>)
                  {
<span class="comment">// calcul de tau31</span>
                    <a class="code" href="classChamp__Face.html#a5706b082facc8da2b44e61d89d36f151" title="termes extradiagonaux du tenseur Grad">tau_croises_</a>(n_arete,0) = signe*(vit_imp-inco[fac3])/dist3;
<span class="comment">// calcul de tau13</span>
                    <a class="code" href="classChamp__Face.html#a5706b082facc8da2b44e61d89d36f151" title="termes extradiagonaux du tenseur Grad">tau_croises_</a>(n_arete,1) = (inco[fac2]-inco[fac1])/(xv(fac2,0) - xv(fac1,0));
                  }
                <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ori3 == 1)
                  {
<span class="comment">// calcul de tau32</span>
                    <a class="code" href="classChamp__Face.html#a5706b082facc8da2b44e61d89d36f151" title="termes extradiagonaux du tenseur Grad">tau_croises_</a>(n_arete,0) = signe*(vit_imp-inco[fac3])/dist3;

<span class="comment">// calcul de tau23</span>
                    R = xv(fac1,0);
                    d_teta = xv(fac2,1) - xv(fac1,1);
                    <span class="keywordflow">if</span>  (d_teta &lt; 0)
                      d_teta += deux_pi;
                    <a class="code" href="classChamp__Face.html#a5706b082facc8da2b44e61d89d36f151" title="termes extradiagonaux du tenseur Grad">tau_croises_</a>(n_arete,1) = (inco[fac2]-inco[fac1])/(R*d_teta);
                  }

              }
            <span class="keywordflow">break</span>;
          }
        <span class="keywordflow">case</span> 3:
          {
<span class="comment">// symetrie-symetrie</span>
<span class="comment">// pas de flux diffusif calcule</span>
            <span class="keywordflow">break</span>;
          }
        <span class="keywordflow">default</span> :
          {
            <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;On a rencontre un type d&#39;arete non prevu\n&quot;</span>;
            <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;num arete : &quot;</span> &lt;&lt; n_arete;
            <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot; type : &quot;</span> &lt;&lt; n_type;
            <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">exit</a>();
            <span class="keywordflow">break</span>;
          }
        }
    }

<span class="comment">// Boucle sur les aretes mixtes et internes</span>

  ndeb = zone_VDF.<a class="code" href="classZone__VDF.html#a1197e179e848063721cdf2121837bbc6">premiere_arete_mixte</a>();
  nfin = zone_VDF.<a class="code" href="classZone__VDF.html#add0341183f527326bc526c92bbb19225">nb_aretes</a>();

  <span class="keywordflow">for</span> (n_arete=ndeb; n_arete&lt;nfin; n_arete++)
    {

      fac1=Qdm(n_arete,0);
      fac2=Qdm(n_arete,1);
      fac3=Qdm(n_arete,2);
      fac4=Qdm(n_arete,3);
      ori1 = orientation(fac1);
      ori3 = orientation(fac3);

      <span class="keywordflow">if</span> (ori1 == 1)  <span class="comment">//!&lt; (seule possibilite : ori3 =0)  Arete XY</span>
<span class="comment"></span>        {
<span class="comment">// Calcul de tau21</span>
          R = xv(fac3,0);
          d_teta = xv(fac4,1) - xv(fac3,1);
          <span class="keywordflow">if</span> (d_teta &lt; 0)
            d_teta += deux_pi;
          <a class="code" href="classChamp__Face.html#a5706b082facc8da2b44e61d89d36f151" title="termes extradiagonaux du tenseur Grad">tau_croises_</a>(n_arete,1) = (inco(fac4)-inco(fac3))/(R*d_teta) - 0.5*(inco[fac1]+inco[fac2])/R;

<span class="comment">// Calcul de tau12</span>
          <a class="code" href="classChamp__Face.html#a5706b082facc8da2b44e61d89d36f151" title="termes extradiagonaux du tenseur Grad">tau_croises_</a>(n_arete,0) = (inco(fac2)-inco(fac1))/(xv(fac2,0) - xv(fac1,0));

        }
      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ori3 == 1) <span class="comment">//!&lt; (seule possibilite ori1 = 2) arete YZ</span>
<span class="comment"></span>        {

<span class="comment">// Calcul de tau32</span>
          <a class="code" href="classChamp__Face.html#a5706b082facc8da2b44e61d89d36f151" title="termes extradiagonaux du tenseur Grad">tau_croises_</a>(n_arete,1) = (inco(fac4)-inco(fac3))/(xv(fac4,2) - xv(fac3,2));

<span class="comment">// Calcul de tau23</span>
          R = xv(fac1,0);
          d_teta = xv(fac2,1) - xv(fac1,1);
          <span class="keywordflow">if</span> (d_teta &lt; 0)
            d_teta += deux_pi;
          <a class="code" href="classChamp__Face.html#a5706b082facc8da2b44e61d89d36f151" title="termes extradiagonaux du tenseur Grad">tau_croises_</a>(n_arete,0) = (inco(fac2)-inco(fac1))/(R*d_teta);

        }
      <span class="keywordflow">else</span> <span class="comment">//!&lt; seule possibilite ori1 = 2 et ori3 = 0:  arete XZ</span>
<span class="comment"></span>        {

<span class="comment">// Calcul de tau31</span>
          <a class="code" href="classChamp__Face.html#a5706b082facc8da2b44e61d89d36f151" title="termes extradiagonaux du tenseur Grad">tau_croises_</a>(n_arete,1) = (inco(fac4)-inco(fac3))/(xv(fac4,2) - xv(fac3,2));

<span class="comment">// Calcul de tau13</span>
          <a class="code" href="classChamp__Face.html#a5706b082facc8da2b44e61d89d36f151" title="termes extradiagonaux du tenseur Grad">tau_croises_</a>(n_arete,0) = (inco(fac2)-inco(fac1))/(xv(fac2,0) - xv(fac1,0));

        }

    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="aacfc1c3c1cb21054b55f5d8da33b4367"></a><!-- doxytag: member="Champ_Face::calculer_dscald_centre_element" ref="aacfc1c3c1cb21054b55f5d8da33b4367" args="(DoubleTab &amp;) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Champ_Face::calculer_dscald_centre_element </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>dscald</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Champ__Face4_8cpp_source.html#l00800">800</a> of file <a class="el" href="Champ__Face4_8cpp_source.html">Champ_Face4.cpp</a>.</p>

<p>References <a class="el" href="Champ__Face4_8cpp_source.html#l00743">caldscaldcentelemdim2()</a>, <a class="el" href="Champ__Face4_8cpp_source.html#l00771">caldscaldcentelemdim3()</a>, <a class="el" href="Objet__U_8h_source.html#l00079">Objet_U::dimension</a>, <a class="el" href="Zone__VF_8h_source.html#l00574">Zone_VF::elem_faces()</a>, <a class="el" href="Zone__VF_8h_source.html#l00458">Zone_VF::face_voisins()</a>, <a class="el" href="Champ__Face_8h_source.html#l00119">la_zone_VDF</a>, <a class="el" href="Zone__dis__base_8h_source.html#l00140">Zone_dis_base::nb_elem()</a>, <a class="el" href="Ref__Zone__VDF_8h_source.html#l00028">Ref_Zone_VDF::valeur()</a>, and <a class="el" href="Champ__Inc__base_8cpp_source.html#l00221">Champ_Inc_base::valeurs()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; val = <a class="code" href="classChamp__Inc__base.html#adb537f43f1649e103a8980314c7ed175" title="Renvoie le tableau des valeurs du champ au temps courant.">valeurs</a>();
  <span class="keyword">const</span> <a class="code" href="classZone__VDF.html" title="class Zone_VDF Classe instanciable qui derive de Zone_VF. Cette classe contient les informations geom...">Zone_VDF</a>&amp; zone_VDF = <a class="code" href="classChamp__Face.html#a84b6abcd128000e1d5759caaa7ae0dee">la_zone_VDF</a>.<a class="code" href="classRef__Zone__VDF.html#a84151da4db745d02791d6246e3682b67">valeur</a>();
  <span class="keywordtype">int</span> nb_elem = zone_VDF.<a class="code" href="classZone__dis__base.html#a790cb2f6bc2928518799e748313d0eb3">nb_elem</a>();
  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; face_voisins = zone_VDF.<a class="code" href="classZone__VF.html#a49d4322f5585a8fa95748ca785b70702" title="renvoie l&#39;element voisin de numface dans la direction i. i=0 : dans le sens oppose de l&#39;axe orthogona...">face_voisins</a>();
  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; elem_faces = zone_VDF.<a class="code" href="classZone__VF.html#a067e462dcd3ab92b0f6d945b19e4eb37" title="renvoie le numero de le ieme face de la maille num_elem la facon dont ces faces sont numerotees est l...">elem_faces</a>();

  <span class="keywordflow">if</span> (<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a> == 2 )
    <a class="code" href="Champ__Face4_8cpp.html#acdbf7783e03d00af97e972d84567f857">caldscaldcentelemdim2</a>(dscald, val, zone_VDF, nb_elem, face_voisins, elem_faces);
  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a> == 3)
    <a class="code" href="Champ__Face4_8cpp.html#a46481e302798100e13f6a288ce49625a">caldscaldcentelemdim3</a>(dscald, val, zone_VDF, nb_elem, face_voisins, elem_faces);
}
</pre></div>
</div>
</div>
<a class="anchor" id="a571ff22af5c4c516d6497521acc85b78"></a><!-- doxytag: member="Champ_Face::calculer_rotationnel_ordre2_centre_element" ref="a571ff22af5c4c516d6497521acc85b78" args="(DoubleTab &amp;) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Champ_Face::calculer_rotationnel_ordre2_centre_element </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>rot</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Champ__Face3_8cpp_source.html#l00498">498</a> of file <a class="el" href="Champ__Face3_8cpp_source.html">Champ_Face3.cpp</a>.</p>

<p>References <a class="el" href="Champ__Face2_8cpp_source.html#l00434">calrotord2centelemdim2()</a>, <a class="el" href="Champ__Face3_8cpp_source.html#l00469">calrotord2centelemdim3()</a>, <a class="el" href="Objet__U_8h_source.html#l00079">Objet_U::dimension</a>, <a class="el" href="Zone__VF_8h_source.html#l00574">Zone_VF::elem_faces()</a>, <a class="el" href="Zone__VF_8h_source.html#l00458">Zone_VF::face_voisins()</a>, <a class="el" href="Champ__Face_8h_source.html#l00119">la_zone_VDF</a>, <a class="el" href="Zone__dis__base_8h_source.html#l00140">Zone_dis_base::nb_elem()</a>, <a class="el" href="Ref__Zone__VDF_8h_source.html#l00028">Ref_Zone_VDF::valeur()</a>, and <a class="el" href="Champ__Inc__base_8cpp_source.html#l00221">Champ_Inc_base::valeurs()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; val = <a class="code" href="classChamp__Inc__base.html#adb537f43f1649e103a8980314c7ed175" title="Renvoie le tableau des valeurs du champ au temps courant.">valeurs</a>();
  <span class="keyword">const</span> <a class="code" href="classZone__VDF.html" title="class Zone_VDF Classe instanciable qui derive de Zone_VF. Cette classe contient les informations geom...">Zone_VDF</a>&amp; zone_VDF = <a class="code" href="classChamp__Face.html#a84b6abcd128000e1d5759caaa7ae0dee">la_zone_VDF</a>.<a class="code" href="classRef__Zone__VDF.html#a84151da4db745d02791d6246e3682b67">valeur</a>();
  <span class="keywordtype">int</span> nb_elem = zone_VDF.<a class="code" href="classZone__dis__base.html#a790cb2f6bc2928518799e748313d0eb3">nb_elem</a>();
  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; face_voisins = zone_VDF.<a class="code" href="classZone__VF.html#a49d4322f5585a8fa95748ca785b70702" title="renvoie l&#39;element voisin de numface dans la direction i. i=0 : dans le sens oppose de l&#39;axe orthogona...">face_voisins</a>();
  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; elem_faces = zone_VDF.<a class="code" href="classZone__VF.html#a067e462dcd3ab92b0f6d945b19e4eb37" title="renvoie le numero de le ieme face de la maille num_elem la facon dont ces faces sont numerotees est l...">elem_faces</a>();

  <span class="keywordflow">if</span> (<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a> == 2 )
    <a class="code" href="Champ__Face2_8cpp.html#a55b486be8c7ed3ced7518eb23eb1a2a7">calrotord2centelemdim2</a>(rot, val, zone_VDF, nb_elem, face_voisins, elem_faces);
  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a> == 3)
    <a class="code" href="Champ__Face3_8cpp.html#ad6f2d561a2b01a55d910955d7b4964a9">calrotord2centelemdim3</a>(rot, val, zone_VDF, nb_elem, face_voisins, elem_faces);
}
</pre></div>
</div>
</div>
<a class="anchor" id="a9bdb53d9eb1ef6875b248ede05f64d9d"></a><!-- doxytag: member="Champ_Face::compo_normale_sortante" ref="a9bdb53d9eb1ef6875b248ede05f64d9d" args="(int) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Champ_Face::compo_normale_sortante </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_face</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Champ__Face_8cpp_source.html#l00453">453</a> of file <a class="el" href="Champ__Face_8cpp_source.html">Champ_Face.cpp</a>.</p>

<p>References <a class="el" href="Zone__VF_8h_source.html#l00458">Zone_VF::face_voisins()</a>, <a class="el" href="Champ__Face_8h_source.html#l00119">la_zone_VDF</a>, and <a class="el" href="Ref__Zone__VDF_8h_source.html#l00028">Ref_Zone_VDF::valeur()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">const</span> <a class="code" href="classZone__VDF.html" title="class Zone_VDF Classe instanciable qui derive de Zone_VF. Cette classe contient les informations geom...">Zone_VDF</a>&amp; zone_VDF = <a class="code" href="classChamp__Face.html#a84b6abcd128000e1d5759caaa7ae0dee">la_zone_VDF</a>.<a class="code" href="classRef__Zone__VDF.html#a84151da4db745d02791d6246e3682b67">valeur</a>();
  <span class="keywordtype">int</span> signe =1;
  <span class="keywordtype">double</span> vit_norm;
<span class="comment">// signe vaut -1 si face_voisins(num_face,0) est a l&#39;exterieur</span>
<span class="comment">// signe vaut  1 si face_voisins(num_face,1) est a l&#39;exterieur</span>
  <span class="keywordflow">if</span> (zone_VDF.<a class="code" href="classZone__VF.html#a49d4322f5585a8fa95748ca785b70702" title="renvoie l&#39;element voisin de numface dans la direction i. i=0 : dans le sens oppose de l&#39;axe orthogona...">face_voisins</a>(num_face,0) == -1)
    signe = -1;
  vit_norm= (*this)(num_face)*signe;
  <span class="keywordflow">return</span> (vit_norm &gt; 0);
}
</pre></div>
</div>
</div>
<a class="anchor" id="a325d8e642516d69382ae04dcbe3c22af"></a><!-- doxytag: member="Champ_Face::cree_instance" ref="a325d8e642516d69382ae04dcbe3c22af" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classObjet__U.html">Objet_U</a> * Champ_Face::cree_instance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Champ__Face_8cpp_source.html#l00039">39</a> of file <a class="el" href="Champ__Face_8cpp_source.html">Champ_Face.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a162a801021b0a2b56da18301d490f715"></a><!-- doxytag: member="Champ_Face::dimensionner_tenseur_Grad" ref="a162a801021b0a2b56da18301d490f715" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Champ_Face::dimensionner_tenseur_Grad </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Champ__Face_8cpp_source.html#l00087">87</a> of file <a class="el" href="Champ__Face_8cpp_source.html">Champ_Face.cpp</a>.</p>

<p>References <a class="el" href="Objet__U_8h_source.html#l00079">Objet_U::dimension</a>, <a class="el" href="Champ__Face_8h_source.html#l00119">la_zone_VDF</a>, <a class="el" href="DoubleTab_8cpp_source.html#l00335">DoubleTab::resize()</a>, <a class="el" href="Champ__Face_8h_source.html#l00122">tau_croises_</a>, and <a class="el" href="Champ__Face_8h_source.html#l00121">tau_diag_</a>.</p>

<p>Referenced by <a class="el" href="Op__Dift__VDF__var__Face__Axi_8cpp_source.html#l00064">Op_Dift_VDF_var_Face_Axi::completer()</a>, and <a class="el" href="Op__Dift__VDF__Face__Axi_8cpp_source.html#l00064">Op_Dift_VDF_Face_Axi::completer()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <a class="code" href="classChamp__Face.html#a6438021756713a2835a461188753f9cc" title="termes diagonaux du tenseur Grad">tau_diag_</a>.<a class="code" href="classDoubleTab.html#ae83b4d31205c53d9c8d2b43da178ce75" title="Change la taille du vecteur (identique a resize_array() pour le traitement des anciennes valeurs et d...">resize</a>(<a class="code" href="classChamp__Face.html#a84b6abcd128000e1d5759caaa7ae0dee">la_zone_VDF</a>-&gt;nb_elem(),<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>);
  <a class="code" href="classChamp__Face.html#a5706b082facc8da2b44e61d89d36f151" title="termes extradiagonaux du tenseur Grad">tau_croises_</a>.<a class="code" href="classDoubleTab.html#ae83b4d31205c53d9c8d2b43da178ce75" title="Change la taille du vecteur (identique a resize_array() pour le traitement des anciennes valeurs et d...">resize</a>(<a class="code" href="classChamp__Face.html#a84b6abcd128000e1d5759caaa7ae0dee">la_zone_VDF</a>-&gt;nb_aretes(),2);
}
</pre></div>
</div>
</div>
<a class="anchor" id="a74ec98f7a58b69091373be671f98e366"></a><!-- doxytag: member="Champ_Face::duplique" ref="a74ec98f7a58b69091373be671f98e366" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Champ_Face::duplique </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implements <a class="el" href="classChamp__Inc__base.html#a7081ef1a9b4e0b425a71109c3637c409">Champ_Inc_base</a>.</p>

<p>Definition at line <a class="el" href="Champ__Face_8cpp_source.html#l00039">39</a> of file <a class="el" href="Champ__Face_8cpp_source.html">Champ_Face.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a818d58bf8925c14f14951cb19794f051"></a><!-- doxytag: member="Champ_Face::fixer_nb_valeurs_nodales" ref="a818d58bf8925c14f14951cb19794f051" args="(int)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Champ_Face::fixer_nb_valeurs_nodales </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nb_noeuds</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="classChamp__Inc__base.html#aa3b4f82104ff7f2009ebfe14f1884d0d">Champ_Inc_base</a>.</p>

<p>Definition at line <a class="el" href="Champ__Face_8cpp_source.html#l00074">74</a> of file <a class="el" href="Champ__Face_8cpp_source.html">Champ_Face.cpp</a>.</p>

<p>References <a class="el" href="Champ__Inc__base_8cpp_source.html#l00166">Champ_Inc_base::creer_tableau_distribue()</a>, <a class="el" href="Zone__VF_8h_source.html#l00200">Zone_VF::md_vector_faces()</a>, <a class="el" href="Field__base_8h_source.html#l00091">Field_base::nb_compo_</a>, and <a class="el" href="Champ__Face_8h_source.html#l00213">zone_vdf()</a>.</p>

<p>Referenced by <a class="el" href="EOS__Tools__VDF_8cpp_source.html#l00046">EOS_Tools_VDF::associer_zones()</a>.</p>
<div class="fragment"><pre class="fragment">{
  assert(nb_noeuds == <a class="code" href="classChamp__Face.html#a3afc1887ea97d1cdde9dcbdb01ea77fc">zone_vdf</a>().nb_faces());
  <span class="keyword">const</span> <a class="code" href="classMD__Vector.html" title=": Cette classe est un DERIV mais l&#39;objet pointe est partage entre plusieurs instances de cette classe...">MD_Vector</a>&amp; md = <a class="code" href="classChamp__Face.html#a3afc1887ea97d1cdde9dcbdb01ea77fc">zone_vdf</a>().<a class="code" href="classZone__VF.html#abe1f45dce7441b402b8c54b5a407367b">md_vector_faces</a>();
<span class="comment">// Probleme: nb_comp vaut 2 mais on ne veut qu&#39;une dimension !!!</span>
<span class="comment">// HACK :</span>
  <span class="keywordtype">int</span> old_nb_compo = <a class="code" href="classField__base.html#ac3539c9ffa67a0b2abe334607c61664f">nb_compo_</a>;
  <a class="code" href="classField__base.html#ac3539c9ffa67a0b2abe334607c61664f">nb_compo_</a> = 1;
  <a class="code" href="classChamp__Inc__base.html#a55f4227a5319c7537e72e45cb8ec8e7f">creer_tableau_distribue</a>(md);
  <a class="code" href="classField__base.html#ac3539c9ffa67a0b2abe334607c61664f">nb_compo_</a> = old_nb_compo;
  <span class="keywordflow">return</span> nb_noeuds;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a38759cc7da50a5c3005b95e2f14de0f7"></a><!-- doxytag: member="Champ_Face::get_info" ref="a38759cc7da50a5c3005b95e2f14de0f7" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classType__info.html">Type_info</a> * Champ_Face::get_info </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Donne des informations sur le type de l'Objet_U. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>const Type_info*<br/>
 Signification: structure regroupant les informations sur le type de l'Objet_U<br/>
 Contraintes: </dd></dl>

<p>Reimplemented from <a class="el" href="classChamp__Inc__base.html#a1a685ec101a4264b79a96559e661dd50">Champ_Inc_base</a>.</p>

<p>Definition at line <a class="el" href="Champ__Face_8cpp_source.html#l00039">39</a> of file <a class="el" href="Champ__Face_8cpp_source.html">Champ_Face.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="acf53603772c19f139b42df93d48c5032"></a><!-- doxytag: member="Champ_Face::imprime" ref="acf53603772c19f139b42df93d48c5032" args="(Sortie &amp;, int) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Champ_Face::imprime </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSortie.html">Sortie</a> &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ncomp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="classChamp__Inc__base.html#a05a9ba4d1fbc9ad4ce58a9c1550927d1">Champ_Inc_base</a>.</p>

<p>Definition at line <a class="el" href="Champ__Face3_8cpp_source.html#l00512">512</a> of file <a class="el" href="Champ__Face3_8cpp_source.html">Champ_Face3.cpp</a>.</p>

<p>References <a class="el" href="Champ__Face__implementation_8cpp_source.html#l00387">Champ_Face_implementation::imprime_Face()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <a class="code" href="classChamp__Face__implementation.html#a3cd1b0b8e7cf82f417bd3414efcf3ec7">imprime_Face</a>(os,ncomp);
  <span class="keywordflow">return</span> 1;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a682b8b85ec7f1a648373b524efe2bb01"></a><!-- doxytag: member="Champ_Face::info" ref="a682b8b85ec7f1a648373b524efe2bb01" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classType__info.html">Type_info</a> * Champ_Face::info </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Donne des informations sur le type de l'Objet_U. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>const Type_info*<br/>
 Signification: structure regroupant les informations sur le type de l'Objet_U<br/>
 Contraintes: </dd></dl>

<p>Reimplemented from <a class="el" href="classChamp__Inc__base.html#ad5b0769bf059d694900b446c692ded4f">Champ_Inc_base</a>.</p>

<p>Definition at line <a class="el" href="Champ__Face_8cpp_source.html#l00039">39</a> of file <a class="el" href="Champ__Face_8cpp_source.html">Champ_Face.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac61e60fdc66ae99410f1b53abd1b4b7c"></a><!-- doxytag: member="Champ_Face::le_champ" ref="ac61e60fdc66ae99410f1b53abd1b4b7c" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classChamp__base.html">Champ_base</a> &amp; Champ_Face::le_champ </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline, private, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implements <a class="el" href="classChamp__implementation.html#af3622959577930b165f17511ff382404">Champ_implementation</a>.</p>

<p>Definition at line <a class="el" href="Champ__Face_8h_source.html#l00143">143</a> of file <a class="el" href="Champ__Face_8h_source.html">Champ_Face.h</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">return</span> *<span class="keyword">this</span>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a394f04bfb5202a3146f16e695e40bc12"></a><!-- doxytag: member="Champ_Face::le_champ" ref="a394f04bfb5202a3146f16e695e40bc12" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classChamp__base.html">Champ_base</a> &amp; Champ_Face::le_champ </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline, private, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implements <a class="el" href="classChamp__implementation.html#acef977877647c519ea01aa4b19ba6613">Champ_implementation</a>.</p>

<p>Definition at line <a class="el" href="Champ__Face_8h_source.html#l00138">138</a> of file <a class="el" href="Champ__Face_8h_source.html">Champ_Face.h</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">return</span> *<span class="keyword">this</span>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a2e18df0106fd4b4d163aac9383b75199"></a><!-- doxytag: member="Champ_Face::mettre_a_jour" ref="a2e18df0106fd4b4d163aac9383b75199" args="(double temps)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Champ_Face::mettre_a_jour </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>temps</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Effectue une mise a jour en temps du champ inconnue.<br/>
WEC : Maintenant si on l'appelle 2 fois de suite avec le meme<br/>
argument, la 2eme ne fait rien. </p>

<p>Reimplemented from <a class="el" href="classChamp__Inc__base.html#ae6b476949137e79e5d40d1c4aadb811b">Champ_Inc_base</a>.</p>

<p>Definition at line <a class="el" href="Champ__Face_8cpp_source.html#l00471">471</a> of file <a class="el" href="Champ__Face_8cpp_source.html">Champ_Face.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{
  <a class="code" href="classChamp__Face.html#a2e18df0106fd4b4d163aac9383b75199" title="Effectue une mise a jour en temps du champ inconnue. WEC : Maintenant si on l&#39;appelle 2 fois de suite...">Champ_Inc_base::mettre_a_jour</a>(un_temps);
}
</pre></div>
</div>
</div>
<a class="anchor" id="a411e7859c59d7b4fcea226ae11a5e524"></a><!-- doxytag: member="Champ_Face::printOn" ref="a411e7859c59d7b4fcea226ae11a5e524" args="(Sortie &amp;x) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSortie.html">Sortie</a> &amp; Champ_Face::printOn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSortie.html">Sortie</a> &amp;&#160;</td>
          <td class="paramname"><em>os</em></td><td>)</td>
          <td> const<code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Surcharge <a class="el" href="classChamp__base.html#a6c0aa36a76a7e02cdda4b1ea80e829e1" title="Surcharge Objet_U::printOn(Sortie&amp;) Imprime le nom du champ sur un flot de sortie.">Champ_base::printOn</a>(<a class="el" href="classSortie.html" title="Classe de base des flux de sortie. Elle sait ecrire des types simples&lt;br&gt;(entiers, flottants) et des Ob...">Sortie</a>&amp;) const<br/>
Imprime le champ sur un flot de sortie.<br/>
<a class="el" href="classSimple.html">Simple</a> appel a <a class="el" href="classChamp__base.html#a6c0aa36a76a7e02cdda4b1ea80e829e1" title="Surcharge Objet_U::printOn(Sortie&amp;) Imprime le nom du champ sur un flot de sortie.">Champ_base::printOn</a>(<a class="el" href="classSortie.html" title="Classe de base des flux de sortie. Elle sait ecrire des types simples&lt;br&gt;(entiers, flottants) et des Ob...">Sortie</a>&amp;) const. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="classSortie.html" title="Classe de base des flux de sortie. Elle sait ecrire des types simples&lt;br&gt;(entiers, flottants) et des Ob...">Sortie</a>&amp;<br/>
 Signification: le flot de sortie modifie<br/>
 Contraintes: </dd></dl>

<p>Reimplemented from <a class="el" href="classChamp__Inc__base.html#af919b2ed62091385eb82bb2cc630cd3d">Champ_Inc_base</a>.</p>

<p>Definition at line <a class="el" href="Champ__Face_8cpp_source.html#l00044">44</a> of file <a class="el" href="Champ__Face_8cpp_source.html">Champ_Face.cpp</a>.</p>

<p>References <a class="el" href="Field__base_8cpp_source.html#l00056">Field_base::le_nom()</a>, and <a class="el" href="Objet__U_8cpp_source.html#l00132">Objet_U::que_suis_je()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">return</span> s &lt;&lt; <a class="code" href="classObjet__U.html#aa58e9a81c0ddc2c1149053b8f96698ac" title="renvoie la chaine identifiant la classe.">que_suis_je</a>() &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; <a class="code" href="classField__base.html#ae1377124eabe8387aced762115b062bb" title="Renvoie le nom du champ.">le_nom</a>();
}
</pre></div>
</div>
</div>
<a class="anchor" id="a3a2e5693cd58d8ae85dc961fa1f76766"></a><!-- doxytag: member="Champ_Face::readOn" ref="a3a2e5693cd58d8ae85dc961fa1f76766" args="(Entree &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEntree.html">Entree</a> &amp; Champ_Face::readOn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEntree.html">Entree</a> &amp;&#160;</td>
          <td class="paramname"><em>is</em></td><td>)</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Lit un champ inconnue sur un flot d'entree.<br/>
<a class="el" href="classSimple.html">Simple</a> appel a <a class="el" href="classChamp__base.html#aee31c8232c1001c4af5a91d9a74b2b90" title="Lecture du nom d&#39;un champ sur un flot d&#39;entree. Format: nom_du_champ.">Champ_base::readOn</a>(<a class="el" href="classEntree.html" title="Classe de definition des operateurs et methodes pour toute lecture dans un flot d&#39;entree (fichier...">Entree</a>&amp;) </p>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="classEntree.html" title="Classe de definition des operateurs et methodes pour toute lecture dans un flot d&#39;entree (fichier...">Entree</a>&amp;<br/>
 Signification: le flot d'entree modifie<br/>
 Contraintes: </dd></dl>

<p>Reimplemented from <a class="el" href="classChamp__Inc__base.html#a447d1e0033a950faf417275d29278f8b">Champ_Inc_base</a>.</p>

<p>Definition at line <a class="el" href="Champ__Face_8cpp_source.html#l00052">52</a> of file <a class="el" href="Champ__Face_8cpp_source.html">Champ_Face.cpp</a>.</p>

<p>References <a class="el" href="Champ__Inc__base_8cpp_source.html#l00143">Champ_Inc_base::lire_donnees()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <a class="code" href="classChamp__Inc__base.html#a2f96f82f25f751bdfb52a6d0044069e7" title="Lit les valeurs du champs a partir d&#39;un flot d&#39;entree. Format de lecture: int [LE NOMBRE DE VALEURS A...">lire_donnees</a> (s) ;
  <span class="keywordflow">return</span> s ;
}
</pre></div>
</div>
</div>
<a class="anchor" id="ae407d3f7ffbf5d1992c6aecf50aa7165"></a><!-- doxytag: member="Champ_Face::remplir_coord_noeuds" ref="ae407d3f7ffbf5d1992c6aecf50aa7165" args="(DoubleTab &amp;positions) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDoubleTab.html">DoubleTab</a> &amp; Champ_Face::remplir_coord_noeuds </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>positions</em></td><td>)</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implements <a class="el" href="classChamp__Inc__base.html#a0b451dee1be0d033664bbe75b2aaccc7">Champ_Inc_base</a>.</p>

<p>Definition at line <a class="el" href="Champ__Face_8h_source.html#l00182">182</a> of file <a class="el" href="Champ__Face_8h_source.html">Champ_Face.h</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">return</span> <a class="code" href="classChamp__Face.html#ae407d3f7ffbf5d1992c6aecf50aa7165">Champ_Face_implementation::remplir_coord_noeuds</a>(positions);
}
</pre></div>
</div>
</div>
<a class="anchor" id="a634857fa8a67e5459e9816a51cd25614"></a><!-- doxytag: member="Champ_Face::remplir_coord_noeuds_et_polys" ref="a634857fa8a67e5459e9816a51cd25614" args="(DoubleTab &amp;positions, IntVect &amp;polys) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Champ_Face::remplir_coord_noeuds_et_polys </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classIntVect.html">IntVect</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>NE FAIT RIEN<br/>
Methode a surcharger. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>int<br/>
 Signification: renvoie toujours 0<br/>
 Contraintes: </dd></dl>

<p>Reimplemented from <a class="el" href="classChamp__Inc__base.html#ae5866b794850a0aa61c09b836339312b">Champ_Inc_base</a>.</p>

<p>Definition at line <a class="el" href="Champ__Face_8h_source.html#l00186">186</a> of file <a class="el" href="Champ__Face_8h_source.html">Champ_Face.h</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">return</span> <a class="code" href="classChamp__Face.html#a634857fa8a67e5459e9816a51cd25614" title="NE FAIT RIEN Methode a surcharger.">Champ_Face_implementation::remplir_coord_noeuds_et_polys</a>(positions,
                                                                  polys);
}
</pre></div>
</div>
</div>
<a class="anchor" id="a41ddd8ea4bef77c6aca3e05a718c2959"></a><!-- doxytag: member="Champ_Face::self_cast" ref="a41ddd8ea4bef77c6aca3e05a718c2959" args="(Objet_U &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classChamp__Face.html">Champ_Face</a> &amp; Champ_Face::self_cast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classObjet__U.html">Objet_U</a> &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="classChamp__Inc__base.html#aaed55a54da8228857704ba5584afab14">Champ_Inc_base</a>.</p>

<p>Definition at line <a class="el" href="Champ__Face_8cpp_source.html#l00039">39</a> of file <a class="el" href="Champ__Face_8cpp_source.html">Champ_Face.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad9b93b28dc4564cc3d1b1c466e0b2db3"></a><!-- doxytag: member="Champ_Face::self_cast" ref="ad9b93b28dc4564cc3d1b1c466e0b2db3" args="(const Objet_U &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classChamp__Face.html">Champ_Face</a> &amp; Champ_Face::self_cast </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classObjet__U.html">Objet_U</a> &amp;&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>methode ajoutee pour caster en python </p>

<p>Reimplemented from <a class="el" href="classChamp__Inc__base.html#a6ae1a1c5f5508d6ae56151f3d4751d97">Champ_Inc_base</a>.</p>

<p>Definition at line <a class="el" href="Champ__Face_8cpp_source.html#l00039">39</a> of file <a class="el" href="Champ__Face_8cpp_source.html">Champ_Face.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9d33ac16144201cf6fff2a60b54b39fb"></a><!-- doxytag: member="Champ_Face::taille_memoire" ref="a9d33ac16144201cf6fff2a60b54b39fb" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned Champ_Face::taille_memoire </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implements <a class="el" href="classObjet__U.html#a0ee0946339f09a2c73c09fcda71c3be2">Objet_U</a>.</p>

<p>Definition at line <a class="el" href="Champ__Face_8cpp_source.html#l00039">39</a> of file <a class="el" href="Champ__Face_8cpp_source.html">Champ_Face.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3244d90446ab0d8020d646ef186d3cb0"></a><!-- doxytag: member="Champ_Face::tau_croises" ref="a3244d90446ab0d8020d646ef186d3cb0" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp; Champ_Face::tau_croises </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Champ__Face_8h_source.html#l00198">198</a> of file <a class="el" href="Champ__Face_8h_source.html">Champ_Face.h</a>.</p>

<p>References <a class="el" href="Champ__Face_8h_source.html#l00122">tau_croises_</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">return</span> <a class="code" href="classChamp__Face.html#a5706b082facc8da2b44e61d89d36f151" title="termes extradiagonaux du tenseur Grad">tau_croises_</a>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="af3ec71e3c73ac3151bca5b0b5e3b4378"></a><!-- doxytag: member="Champ_Face::tau_croises" ref="af3ec71e3c73ac3151bca5b0b5e3b4378" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDoubleTab.html">DoubleTab</a> &amp; Champ_Face::tau_croises </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Champ__Face_8h_source.html#l00208">208</a> of file <a class="el" href="Champ__Face_8h_source.html">Champ_Face.h</a>.</p>

<p>References <a class="el" href="Champ__Face_8h_source.html#l00122">tau_croises_</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">return</span> <a class="code" href="classChamp__Face.html#a5706b082facc8da2b44e61d89d36f151" title="termes extradiagonaux du tenseur Grad">tau_croises_</a>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a64637803a2a1396ec3d5af58fcc11a60"></a><!-- doxytag: member="Champ_Face::tau_diag" ref="a64637803a2a1396ec3d5af58fcc11a60" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDoubleTab.html">DoubleTab</a> &amp; Champ_Face::tau_diag </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Champ__Face_8h_source.html#l00203">203</a> of file <a class="el" href="Champ__Face_8h_source.html">Champ_Face.h</a>.</p>

<p>References <a class="el" href="Champ__Face_8h_source.html#l00121">tau_diag_</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">return</span> <a class="code" href="classChamp__Face.html#a6438021756713a2835a461188753f9cc" title="termes diagonaux du tenseur Grad">tau_diag_</a>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a302f5648e19635a74624c91f5ce344b5"></a><!-- doxytag: member="Champ_Face::tau_diag" ref="a302f5648e19635a74624c91f5ce344b5" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp; Champ_Face::tau_diag </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Champ__Face_8h_source.html#l00193">193</a> of file <a class="el" href="Champ__Face_8h_source.html">Champ_Face.h</a>.</p>

<p>References <a class="el" href="Champ__Face_8h_source.html#l00121">tau_diag_</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">return</span> <a class="code" href="classChamp__Face.html#a6438021756713a2835a461188753f9cc" title="termes diagonaux du tenseur Grad">tau_diag_</a>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a1261277b8f21a6056c0416dc3d5adb50"></a><!-- doxytag: member="Champ_Face::trace" ref="a1261277b8f21a6056c0416dc3d5adb50" args="(const Frontiere_dis_base &amp;, DoubleTab &amp;, double, int distant) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDoubleTab.html">DoubleTab</a> &amp; Champ_Face::trace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFrontiere__dis__base.html">Frontiere_dis_base</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>distant</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>voir <a class="el" href="classChamp__base.html" title="classe Champ_base Cette classe est la base de la hierarchie des champs. Ses membres sont les attribut...">Champ_base</a><br/>
Cas particulier (malheureusement) du <a class="el" href="classChamp__P0__VDF.html" title="classe Champ_P0_VDF Classe qui represente un champ discret P0 par element associe a une zone discreti...">Champ_P0_VDF</a> :<br/>
Si la frontiere est un raccord, le resultat est calcule sur le<br/>
raccord associe. Dans ce cas, le <a class="el" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a> x doit etre<br/>
dimensionne sur le raccord associe. </p>

<p>Reimplemented from <a class="el" href="classChamp__Inc__base.html#a26adc77c8d8c13ce7739b4781dcf5549">Champ_Inc_base</a>.</p>

<p>Definition at line <a class="el" href="Champ__Face_8cpp_source.html#l00466">466</a> of file <a class="el" href="Champ__Face_8cpp_source.html">Champ_Face.cpp</a>.</p>

<p>References <a class="el" href="Champ__Inc__base_8cpp_source.html#l00221">Champ_Inc_base::valeurs()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">return</span> <a class="code" href="classChamp__Face.html#a1261277b8f21a6056c0416dc3d5adb50" title="voir Champ_base Cas particulier (malheureusement) du Champ_P0_VDF : Si la frontiere est un raccord...">Champ_Face_implementation::trace</a>(fr, <a class="code" href="classChamp__Inc__base.html#adb537f43f1649e103a8980314c7ed175" title="Renvoie le tableau des valeurs du champ au temps courant.">valeurs</a>(tps), x,distant);
}
</pre></div>
</div>
</div>
<a class="anchor" id="a613ea150dbc6a9b5f288011f90484381"></a><!-- doxytag: member="Champ_Face::val_imp_face_bord_private" ref="a613ea150dbc6a9b5f288011f90484381" args="(int face, int comp) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Champ_Face::val_imp_face_bord_private </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Champ__Face_8cpp_source.html#l00317">317</a> of file <a class="el" href="Champ__Face_8cpp_source.html">Champ_Face.cpp</a>.</p>

<p>References <a class="el" href="Champ__Face_8cpp_source.html#l00374">Champ_Face_get_val_imp_face_bord_sym()</a>, <a class="el" href="MorEqn_8h_source.html#l00082">MorEqn::equation()</a>, <a class="el" href="Cast_8h_source.html#l00059">ref_cast</a>, <a class="el" href="Champ__base_8cpp_source.html#l01116">Champ_base::temps()</a>, <a class="el" href="Source__Generique__Face__PolyMAC_8cpp_source.html#l00045">valeur()</a>, <a class="el" href="Champ__Inc__base_8cpp_source.html#l00221">Champ_Inc_base::valeurs()</a>, and <a class="el" href="Champ__Inc__base_8cpp_source.html#l01122">Champ_Inc_base::zone_Cl_dis()</a>.</p>

<p>Referenced by <a class="el" href="Champ__Face3_8cpp_source.html#l00682">calcul_duidxj()</a>, <a class="el" href="Champ__Face3_8cpp_source.html#l01128">calcul_S_barre_sans_contrib_paroi()</a>, and <a class="el" href="Champ__Face2_8cpp_source.html#l00031">calculer_dercov_axi()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">const</span> <a class="code" href="classZone__Cl__VDF.html" title="&lt; namespace TypeAreteCoinVDF">Zone_Cl_VDF</a>&amp; zclo=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classZone__Cl__VDF.html" title="&lt; namespace TypeAreteCoinVDF">Zone_Cl_VDF</a>,<a class="code" href="classMorEqn.html#a615dd9abff96edcb625fa0424a489864" title="Renvoie la reference sur l&#39;equation pointe par MorEqn::mon_equation. (version const)">equation</a>().<a class="code" href="classChamp__Inc__base.html#a8d729b89f1854471101bd0a47ddaf45a">zone_Cl_dis</a>().<a class="code" href="Source__Generique__Face__PolyMAC_8cpp.html#a7d7b5d77a3caa1af70f5e1c9108de5a1">valeur</a>());
  <span class="keywordflow">return</span> <a class="code" href="Champ__Face_8cpp.html#a0617d2fcb58972d0f1387287591ad483">Champ_Face_get_val_imp_face_bord_sym</a>(<a class="code" href="classChamp__Inc__base.html#adb537f43f1649e103a8980314c7ed175" title="Renvoie le tableau des valeurs du champ au temps courant.">valeurs</a>(),<a class="code" href="classChamp__base.html#ada7350aecb7b6f20dcaee2d1106ab1a0" title="Renvoie le temps du champ.">temps</a>(), face,comp,  zclo);
}
</pre></div>
</div>
</div>
<a class="anchor" id="abcb111d6380ec932756b32ab9ba561f3"></a><!-- doxytag: member="Champ_Face::val_imp_face_bord_private" ref="abcb111d6380ec932756b32ab9ba561f3" args="(int face, int comp1, int comp2) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Champ_Face::val_imp_face_bord_private </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>comp1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>comp2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>&lt; For compilers </p>
</p>

<p>Definition at line <a class="el" href="Champ__Face_8cpp_source.html#l00436">436</a> of file <a class="el" href="Champ__Face_8cpp_source.html">Champ_Face.cpp</a>.</p>

<p>References <a class="el" href="EntreeSortie_8h_source.html#l00032">Cerr</a>, <a class="el" href="Process_8cpp_source.html#l00223">Process::exit()</a>, and <a class="el" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>.</p>
<div class="fragment"><pre class="fragment">{
  <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Champ_Face::val_imp_face_bord(,,) exit&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
  <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">exit</a>();
  <span class="keywordflow">return</span> 0; <span class="comment">//!&lt; For compilers</span>
<span class="comment"></span>}
</pre></div>
</div>
</div>
<a class="anchor" id="af122a6bd447d0191e0d202f3ae63e8fa"></a><!-- doxytag: member="Champ_Face::valeur_a_elem" ref="af122a6bd447d0191e0d202f3ae63e8fa" args="(const DoubleVect &amp;position, DoubleVect &amp;val, int le_poly) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDoubleVect.html">DoubleVect</a> &amp; Champ_Face::valeur_a_elem </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>le_poly</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="classChamp__Face__implementation.html#adb4fe3c2c2549b9705b14c9370e0c301">Champ_Face_implementation</a>.</p>

<p>Definition at line <a class="el" href="Champ__Face_8h_source.html#l00148">148</a> of file <a class="el" href="Champ__Face_8h_source.html">Champ_Face.h</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">return</span> <a class="code" href="classChamp__Face.html#af122a6bd447d0191e0d202f3ae63e8fa">Champ_Face_implementation::valeur_a_elem</a>(position, val, le_poly);
}
</pre></div>
</div>
</div>
<a class="anchor" id="a7aff65902f0ae74526949169ac5123c4"></a><!-- doxytag: member="Champ_Face::valeur_a_elem_compo" ref="a7aff65902f0ae74526949169ac5123c4" args="(const DoubleVect &amp;position, int le_poly, int ncomp) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Champ_Face::valeur_a_elem_compo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>le_poly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ncomp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="classChamp__Face__implementation.html#a4342a5570de6192b34831ed7398f1f88">Champ_Face_implementation</a>.</p>

<p>Definition at line <a class="el" href="Champ__Face_8h_source.html#l00154">154</a> of file <a class="el" href="Champ__Face_8h_source.html">Champ_Face.h</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">return</span> <a class="code" href="classChamp__Face.html#a7aff65902f0ae74526949169ac5123c4">Champ_Face_implementation::valeur_a_elem_compo</a>(position, le_poly, ncomp);
}
</pre></div>
</div>
</div>
<a class="anchor" id="abb03975827b95a953c16521e9fe57382"></a><!-- doxytag: member="Champ_Face::valeur_aux_elems" ref="abb03975827b95a953c16521e9fe57382" args="(const DoubleTab &amp;positions, const IntVect &amp;les_polys, DoubleTab &amp;tab_valeurs) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDoubleTab.html">DoubleTab</a> &amp; Champ_Face::valeur_aux_elems </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>positions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIntVect.html">IntVect</a> &amp;&#160;</td>
          <td class="paramname"><em>les_polys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>tab_valeurs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="classChamp__Face__implementation.html#a0232f9b81e7ad90c536fc6e98ee7db06">Champ_Face_implementation</a>.</p>

<p>Definition at line <a class="el" href="Champ__Face_8h_source.html#l00159">159</a> of file <a class="el" href="Champ__Face_8h_source.html">Champ_Face.h</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">return</span> <a class="code" href="classChamp__Face.html#abb03975827b95a953c16521e9fe57382">Champ_Face_implementation::valeur_aux_elems</a>(positions, les_polys, tab_valeurs);
}
</pre></div>
</div>
</div>
<a class="anchor" id="a6b1315a936bafd41e2e4f690c7422a91"></a><!-- doxytag: member="Champ_Face::valeur_aux_elems_compo" ref="a6b1315a936bafd41e2e4f690c7422a91" args="(const DoubleTab &amp;positions, const IntVect &amp;les_polys, DoubleVect &amp;tab_valeurs, int ncomp) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDoubleVect.html">DoubleVect</a> &amp; Champ_Face::valeur_aux_elems_compo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>positions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIntVect.html">IntVect</a> &amp;&#160;</td>
          <td class="paramname"><em>les_polys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;&#160;</td>
          <td class="paramname"><em>tab_valeurs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ncomp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="classChamp__Face__implementation.html#ad53abeb8ac22090e4c3045d955a19067">Champ_Face_implementation</a>.</p>

<p>Definition at line <a class="el" href="Champ__Face_8h_source.html#l00165">165</a> of file <a class="el" href="Champ__Face_8h_source.html">Champ_Face.h</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">return</span> <a class="code" href="classChamp__Face.html#a6b1315a936bafd41e2e4f690c7422a91">Champ_Face_implementation::valeur_aux_elems_compo</a>(positions, les_polys,
                                                           tab_valeurs, ncomp);
}
</pre></div>
</div>
</div>
<a class="anchor" id="a30969ce8042663c28ee77087bb714df8"></a><!-- doxytag: member="Champ_Face::valeur_aux_sommets" ref="a30969ce8042663c28ee77087bb714df8" args="(const Domaine &amp;, DoubleTab &amp;) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDoubleTab.html">DoubleTab</a> &amp; Champ_Face::valeur_aux_sommets </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDomaine.html">Domaine</a> &amp;&#160;</td>
          <td class="paramname"><em>dom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="classChamp__Face__implementation.html#a59ed479416365c37f24fa9e74053406c">Champ_Face_implementation</a>.</p>

<p>Definition at line <a class="el" href="Champ__Face_8h_source.html#l00173">173</a> of file <a class="el" href="Champ__Face_8h_source.html">Champ_Face.h</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">return</span> <a class="code" href="classChamp__Face.html#a30969ce8042663c28ee77087bb714df8">Champ_Face_implementation::valeur_aux_sommets</a>(dom, val);
}
</pre></div>
</div>
</div>
<a class="anchor" id="a8295648faf26571b0de56ca395b042ef"></a><!-- doxytag: member="Champ_Face::valeur_aux_sommets_compo" ref="a8295648faf26571b0de56ca395b042ef" args="(const Domaine &amp;, DoubleVect &amp;, int) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDoubleVect.html">DoubleVect</a> &amp; Champ_Face::valeur_aux_sommets_compo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDomaine.html">Domaine</a> &amp;&#160;</td>
          <td class="paramname"><em>dom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="classChamp__Face__implementation.html#aee6ad96b765346ce81c006575eebe6a8">Champ_Face_implementation</a>.</p>

<p>Definition at line <a class="el" href="Champ__Face_8h_source.html#l00177">177</a> of file <a class="el" href="Champ__Face_8h_source.html">Champ_Face.h</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">return</span> <a class="code" href="classChamp__Face.html#a8295648faf26571b0de56ca395b042ef">Champ_Face_implementation::valeur_aux_sommets_compo</a>(dom, val, comp);
}
</pre></div>
</div>
</div>
<a class="anchor" id="a3c08f436f3733745a93a5e0526002353"></a><!-- doxytag: member="Champ_Face::verifie_valeurs_cl" ref="a3c08f436f3733745a93a5e0526002353" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Champ_Face::verifie_valeurs_cl </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="classChamp__Inc__base.html#a92b54f473eec9016fed84f9a82a1b13d">Champ_Inc_base</a>.</p>

<p>Definition at line <a class="el" href="Champ__Face_8cpp_source.html#l00276">276</a> of file <a class="el" href="Champ__Face_8cpp_source.html">Champ_Face.cpp</a>.</p>

<p>References <a class="el" href="DoubleVect_8cpp_source.html#l00277">DoubleVect::echange_espace_virtuel()</a>, <a class="el" href="Periodique_8h_source.html#l00056">Periodique::face_associee()</a>, <a class="el" href="Cond__lim__base_8h_source.html#l00123">Cond_lim_base::frontiere_dis()</a>, <a class="el" href="Zone__Cl__dis__base_8cpp_source.html#l00522">Zone_Cl_dis_base::les_conditions_limites()</a>, <a class="el" href="Zone__Cl__dis__base_8cpp_source.html#l00603">Zone_Cl_dis_base::nb_cond_lim()</a>, <a class="el" href="Front__VF_8h_source.html#l00061">Front_VF::nb_faces()</a>, <a class="el" href="Front__VF_8h_source.html#l00071">Front_VF::num_premiere_face()</a>, <a class="el" href="Cast_8h_source.html#l00059">ref_cast</a>, <a class="el" href="Cast_8h_source.html#l00054">sub_type</a>, <a class="el" href="Cond__lim_8h_source.html#l00031">Deriv_Cond_lim_base::valeur()</a>, <a class="el" href="Zone__Cl__dis_8h_source.html#l00032">Deriv_Zone_Cl_dis_base::valeur()</a>, <a class="el" href="Champ__Inc__base_8cpp_source.html#l00221">Champ_Inc_base::valeurs()</a>, and <a class="el" href="Champ__Inc__base_8cpp_source.html#l01122">Champ_Inc_base::zone_Cl_dis()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">const</span> <a class="code" href="classZone__Cl__dis__base.html" title="classe Zone_Cl_dis_base Les objets Zone_Cl_dis_base representent les conditions aux limites discretis...">Zone_Cl_dis_base</a>&amp; zcl = <a class="code" href="classChamp__Inc__base.html#a8d729b89f1854471101bd0a47ddaf45a">zone_Cl_dis</a>().<a class="code" href="classDeriv__Zone__Cl__dis__base.html#a6b56880f00b604e1f13970ec6d5bc077">valeur</a>();
  <span class="keywordtype">int</span> nb_cl = zcl.<a class="code" href="classZone__Cl__dis__base.html#aa6f1df56cfd6e2eae83cc991c7cc9b41" title="Renvoie le nombre de conditions aux limites.">nb_cond_lim</a>();
  <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; ch_tab = <a class="code" href="classChamp__Inc__base.html#adb537f43f1649e103a8980314c7ed175" title="Renvoie le tableau des valeurs du champ au temps courant.">valeurs</a>();
  <span class="keywordtype">int</span> ndeb,nfin,num_face;

  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;nb_cl; i++)
    {
      <span class="keyword">const</span> <a class="code" href="classCond__lim__base.html" title="classe Cond_lim_base Classe de base pour la hierarchie des classes qui representent les differentes c...">Cond_lim_base</a>&amp; la_cl = zcl.<a class="code" href="classZone__Cl__dis__base.html#af75e0ed7786863e4d333bfb29d67c323" title="Renvoie la i-ieme condition aux limites. (version const)">les_conditions_limites</a>(i).<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>();
      <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>,la_cl))
        {
          <span class="keyword">const</span> <a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>&amp; la_cl_perio = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>,la_cl);
          <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp; le_bord = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>,la_cl.<a class="code" href="classCond__lim__base.html#ad88b3b516351146c85e8fce1df0f691a" title="Renvoie la frontiere discretisee a laquelle les conditions aux limites s&#39;appliquent.">frontiere_dis</a>());
          ndeb = le_bord.<a class="code" href="classFront__VF.html#a4986f0c65653fe9eb40bbbff5a97bf16" title="Numero de la premiere face du bord dans la liste des faces.">num_premiere_face</a>();
          nfin = ndeb + le_bord.<a class="code" href="classFront__VF.html#a341e2fcb5117b96e745fd7078ba86bab" title="Nombre de faces reelles du bord.">nb_faces</a>();
          <span class="keywordtype">int</span> voisine;
          <span class="keywordtype">double</span> moy;

          <span class="keywordflow">for</span> (num_face=ndeb; num_face&lt;nfin; num_face++)
            {
              voisine = la_cl_perio.<a class="code" href="classPeriodique.html#a207b86556f199a63ea059b841851ca6a">face_associee</a>(num_face-ndeb) + ndeb;
              <span class="keywordflow">if</span> (ch_tab[num_face] != ch_tab[voisine])
                {
                  moy = 0.5*(ch_tab[num_face] + ch_tab[voisine]);
                  ch_tab[num_face] = moy;
                  ch_tab[voisine] = moy;
                }
            }
        }
    }
  ch_tab.<a class="code" href="classDoubleVect.html#abfebbc2f685ce7bc4b80c720d7da9bf3">echange_espace_virtuel</a>();
}
</pre></div>
</div>
</div>
<a class="anchor" id="a7e818c86cac3e4325f35d19b0416b006"></a><!-- doxytag: member="Champ_Face::zone_dis_base" ref="a7e818c86cac3e4325f35d19b0416b006" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classZone__dis__base.html">Zone_dis_base</a> &amp; Champ_Face::zone_dis_base </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="classChamp__implementation.html#a1be8c351fc8394e9126755dd557d13ca">Champ_implementation</a>.</p>

<p>Definition at line <a class="el" href="Champ__Face_8cpp_source.html#l00064">64</a> of file <a class="el" href="Champ__Face_8cpp_source.html">Champ_Face.cpp</a>.</p>

<p>References <a class="el" href="Champ__Face_8h_source.html#l00119">la_zone_VDF</a>, and <a class="el" href="Ref__Zone__VDF_8h_source.html#l00028">Ref_Zone_VDF::valeur()</a>.</p>

<p>Referenced by <a class="el" href="VDF__discretisation_8cpp_source.html#l00559">VDF_discretisation::creer_champ_vorticite()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">return</span> <a class="code" href="classChamp__Face.html#a84b6abcd128000e1d5759caaa7ae0dee">la_zone_VDF</a>.<a class="code" href="classRef__Zone__VDF.html#a84151da4db745d02791d6246e3682b67">valeur</a>();
}
</pre></div>
</div>
</div>
<a class="anchor" id="a3afc1887ea97d1cdde9dcbdb01ea77fc"></a><!-- doxytag: member="Champ_Face::zone_vdf" ref="a3afc1887ea97d1cdde9dcbdb01ea77fc" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classZone__VDF.html">Zone_VDF</a> &amp; Champ_Face::zone_vdf </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implements <a class="el" href="classChamp__Face__implementation.html#a449ac38bddb582c76230cadb8a18da70">Champ_Face_implementation</a>.</p>

<p>Definition at line <a class="el" href="Champ__Face_8h_source.html#l00213">213</a> of file <a class="el" href="Champ__Face_8h_source.html">Champ_Face.h</a>.</p>

<p>References <a class="el" href="Champ__Face_8h_source.html#l00119">la_zone_VDF</a>, and <a class="el" href="Ref__Zone__VDF_8h_source.html#l00028">Ref_Zone_VDF::valeur()</a>.</p>

<p>Referenced by <a class="el" href="Champ__Face_8cpp_source.html#l00074">fixer_nb_valeurs_nodales()</a>, and <a class="el" href="Zone__Cl__VDF_8cpp_source.html#l00417">Zone_Cl_VDF::imposer_cond_lim()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">return</span> <a class="code" href="classChamp__Face.html#a84b6abcd128000e1d5759caaa7ae0dee">la_zone_VDF</a>.<a class="code" href="classRef__Zone__VDF.html#a84151da4db745d02791d6246e3682b67">valeur</a>();
}
</pre></div>
</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="a3441ef57d0e159b60960b9536803e3b9"></a><!-- doxytag: member="Champ_Face::info_obj" ref="a3441ef57d0e159b60960b9536803e3b9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classType__info.html">Type_info</a> <a class="el" href="classChamp__Face.html#a3441ef57d0e159b60960b9536803e3b9">Champ_Face::info_obj</a><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="classChamp__Inc__base.html#a0f1529a4a469b12b7720e7f8d867513b">Champ_Inc_base</a>.</p>

<p>Definition at line <a class="el" href="Champ__Face_8h_source.html#l00053">53</a> of file <a class="el" href="Champ__Face_8h_source.html">Champ_Face.h</a>.</p>

</div>
</div>
<a class="anchor" id="a84b6abcd128000e1d5759caaa7ae0dee"></a><!-- doxytag: member="Champ_Face::la_zone_VDF" ref="a84b6abcd128000e1d5759caaa7ae0dee" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRef__Zone__VDF.html">Ref_Zone_VDF</a> <a class="el" href="classChamp__Face.html#a84b6abcd128000e1d5759caaa7ae0dee">Champ_Face::la_zone_VDF</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Champ__Face_8h_source.html#l00119">119</a> of file <a class="el" href="Champ__Face_8h_source.html">Champ_Face.h</a>.</p>

<p>Referenced by <a class="el" href="Champ__Face_8cpp_source.html#l00196">affecter()</a>, <a class="el" href="Champ__Face_8cpp_source.html#l00093">affecter_()</a>, <a class="el" href="Champ__Face_8cpp_source.html#l00069">associer_zone_dis_base()</a>, <a class="el" href="Champ__Face3_8cpp_source.html#l00519">calcul_critere_Q()</a>, <a class="el" href="Champ__Face3_8cpp_source.html#l00682">calcul_duidxj()</a>, <a class="el" href="Champ__Face3_8cpp_source.html#l01457">calcul_grad_u()</a>, <a class="el" href="Champ__Face3_8cpp_source.html#l01427">calcul_S_barre()</a>, <a class="el" href="Champ__Face3_8cpp_source.html#l01128">calcul_S_barre_sans_contrib_paroi()</a>, <a class="el" href="Champ__Face3_8cpp_source.html#l00555">calcul_y_plus()</a>, <a class="el" href="Champ__Face2_8cpp_source.html#l00031">calculer_dercov_axi()</a>, <a class="el" href="Champ__Face4_8cpp_source.html#l00800">calculer_dscald_centre_element()</a>, <a class="el" href="Champ__Face3_8cpp_source.html#l00498">calculer_rotationnel_ordre2_centre_element()</a>, <a class="el" href="Champ__Face_8cpp_source.html#l00453">compo_normale_sortante()</a>, <a class="el" href="Champ__Face_8cpp_source.html#l00087">dimensionner_tenseur_Grad()</a>, <a class="el" href="Champ__Face_8cpp_source.html#l00064">zone_dis_base()</a>, and <a class="el" href="Champ__Face_8h_source.html#l00213">zone_vdf()</a>.</p>

</div>
</div>
<a class="anchor" id="a5706b082facc8da2b44e61d89d36f151"></a><!-- doxytag: member="Champ_Face::tau_croises_" ref="a5706b082facc8da2b44e61d89d36f151" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDoubleTab.html">DoubleTab</a> <a class="el" href="classChamp__Face.html#a5706b082facc8da2b44e61d89d36f151">Champ_Face::tau_croises_</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>termes extradiagonaux du tenseur Grad </p>

<p>Definition at line <a class="el" href="Champ__Face_8h_source.html#l00122">122</a> of file <a class="el" href="Champ__Face_8h_source.html">Champ_Face.h</a>.</p>

<p>Referenced by <a class="el" href="Champ__Face2_8cpp_source.html#l00031">calculer_dercov_axi()</a>, <a class="el" href="Champ__Face_8cpp_source.html#l00087">dimensionner_tenseur_Grad()</a>, and <a class="el" href="Champ__Face_8h_source.html#l00198">tau_croises()</a>.</p>

</div>
</div>
<a class="anchor" id="a6438021756713a2835a461188753f9cc"></a><!-- doxytag: member="Champ_Face::tau_diag_" ref="a6438021756713a2835a461188753f9cc" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDoubleTab.html">DoubleTab</a> <a class="el" href="classChamp__Face.html#a6438021756713a2835a461188753f9cc">Champ_Face::tau_diag_</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>termes diagonaux du tenseur Grad </p>

<p>Definition at line <a class="el" href="Champ__Face_8h_source.html#l00121">121</a> of file <a class="el" href="Champ__Face_8h_source.html">Champ_Face.h</a>.</p>

<p>Referenced by <a class="el" href="Champ__Face2_8cpp_source.html#l00031">calculer_dercov_axi()</a>, <a class="el" href="Champ__Face_8cpp_source.html#l00087">dimensionner_tenseur_Grad()</a>, and <a class="el" href="Champ__Face_8h_source.html#l00193">tau_diag()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/VDF/Champs/<a class="el" href="Champ__Face_8h_source.html">Champ_Face.h</a></li>
<li>src/VDF/Champs/<a class="el" href="Champ__Face_8cpp_source.html">Champ_Face.cpp</a></li>
<li>src/VDF/Champs/<a class="el" href="Champ__Face2_8cpp_source.html">Champ_Face2.cpp</a></li>
<li>src/VDF/Champs/<a class="el" href="Champ__Face3_8cpp_source.html">Champ_Face3.cpp</a></li>
<li>src/VDF/Champs/<a class="el" href="Champ__Face4_8cpp_source.html">Champ_Face4.cpp</a></li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Tue Dec 14 2021 19:36:09 for TRUST by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
