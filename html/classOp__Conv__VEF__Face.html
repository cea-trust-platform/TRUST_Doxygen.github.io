<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>TRUST: Op_Conv_VEF_Face Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">TRUST&#160;<span id="projectnumber">1.8.4</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-types">Protected Types</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a>  </div>
  <div class="headertitle">
<div class="title">Op_Conv_VEF_Face Class Reference</div>  </div>
</div>
<div class="contents">
<!-- doxytag: class="Op_Conv_VEF_Face" --><!-- doxytag: inherits="Op_Conv_VEF_base" -->
<p>class <a class="el" href="classOp__Conv__VEF__Face.html" title="class Op_Conv_VEF_Face Cette classe represente l&#39;operateur de convection associe a une equation de tr...">Op_Conv_VEF_Face</a><br/>
Cette classe represente l'operateur de convection associe a une equation de<br/>
transport d'un scalaire.<br/>
La discretisation est VEF<br/>
Le champ convecte est scalaire ou vecteur de type <a class="el" href="classChamp__P1NC.html">Champ_P1NC</a><br/>
Le schema de convection est du type Decentre ou Centre  
 <a href="classOp__Conv__VEF__Face.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="Op__Conv__VEF__Face_8h_source.html">Op_Conv_VEF_Face.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Op_Conv_VEF_Face:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classOp__Conv__VEF__Face.png" usemap="#Op_Conv_VEF_Face_map" alt=""/>
  <map id="Op_Conv_VEF_Face_map" name="Op_Conv_VEF_Face_map">
<area href="classOp__Conv__VEF__base.html" title="class Op_Conv_VEF_base Classe de base des operateurs de convection VEF" alt="Op_Conv_VEF_base" shape="rect" coords="542,224,749,248"/>
<area href="classOperateur__Conv__base.html" title="classe Operateur_Conv_base Cette classe est la base de la hierarchie des operateurs representant un t..." alt="Operateur_Conv_base" shape="rect" coords="434,168,641,192"/>
<area href="classOp__VEF__Face.html" alt="Op_VEF_Face" shape="rect" coords="651,168,858,192"/>
<area href="classOperateur__base.html" title="classe Operateur_base Classe est la base de la hierarchie des objets representant un operateur utilis..." alt="Operateur_base" shape="rect" coords="434,112,641,136"/>
<area href="classObjet__U.html" title="classe Objet_U Cette classe est la classe de base des Objets de TRUST Dans les classes derivees de Ob..." alt="Objet_U" shape="rect" coords="217,56,424,80"/>
<area href="classMorEqn.html" title="classe MorEqn Classe qui regroupe les fonctionnalites de liaison avec une Equation. Le membre MorEqn::mon_equation contient une reference vers un objet Equation_base. Les classes qui sont des &quot;Morceaux d&#39;equation&quot; sont associe par une liaison 1-1 a leur equation en heritant de MorEqn, par exemple: Operateur_base, Solveur_Masse, Source_base ..." alt="MorEqn" shape="rect" coords="434,56,641,80"/>
<area href="classChamps__compris__interface.html" title="classe Champs_compris_interface Cette classe contient une interface de methodes destinees a gerer les..." alt="Champs_compris_interface" shape="rect" coords="651,56,858,80"/>
<area href="classProcess.html" title="Classe de base de TRUST (notamment Objet_U). Elle fournit quelques services de base accessibles de pa..." alt="Process" shape="rect" coords="217,0,424,24"/>
<area href="classOp__Conv__Amont__VEF__Face.html" title="class Op_Conv_Amont_VEF_Face Cette classe represente l&#39;operateur de convection associe a une equation..." alt="Op_Conv_Amont_VEF_Face" shape="rect" coords="0,336,207,360"/>
<area href="classOp__Conv__Centre__VEF__Face.html" title="class Op_Conv_Centre_VEF_Face Cette classe represente l&#39;operateur de convection associe a une equatio..." alt="Op_Conv_Centre_VEF_Face" shape="rect" coords="217,336,424,360"/>
<area href="classOp__Conv__EF__VEF__P1NC__Stab.html" title="class Op_Conv_EF_VEF_P1NC_Stab Cette classe represente l&#39;operateur de convection associe a une equati..." alt="Op_Conv_EF_VEF_P1NC_Stab" shape="rect" coords="434,336,641,360"/>
<area href="classOp__Conv__Muscl3__VEF__Face.html" title="class Op_Conv_Muscl3_VEF_Face Cette classe represente l&#39;operateur de convection associe a une equatio..." alt="Op_Conv_Muscl3_VEF_Face" shape="rect" coords="651,336,858,360"/>
<area href="classOp__Conv__Muscl__New__VEF__Face.html" title="class Op_Conv_Muscl_New_VEF_Face Cette classe represente l&#39;operateur de convection associe a une equa..." alt="Op_Conv_Muscl_New_VEF_Face" shape="rect" coords="868,336,1075,360"/>
<area href="classOp__Conv__Muscl__VEF__Face.html" title="class Op_Conv_Muscl_VEF_Face Cette classe represente l&#39;operateur de convection associe a une equation..." alt="Op_Conv_Muscl_VEF_Face" shape="rect" coords="1085,336,1292,360"/>
</map>
 </div></div>

<p><a href="classOp__Conv__VEF__Face-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOp__Conv__VEF__Face.html#a84ff72e96d4f142a09a0ad59b63a8ba0">~Op_Conv_VEF_Face</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOp__Conv__VEF__Face.html#a0425dbae6b4c7a815392e6e4ae50861d">taille_memoire</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOp__Conv__VEF__Face.html#a730ff7f720a85346c2e64d887d2e83a3">duplique</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classType__info.html">Type_info</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOp__Conv__VEF__Face.html#a7956413d25ad3f47537c18be89fa8a93">get_info</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Donne des informations sur le type de l'Objet_U.  <a href="#a7956413d25ad3f47537c18be89fa8a93"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOp__Conv__VEF__Face.html#ae9cb44271acc7663c3e2333c7f7dab60">Op_Conv_VEF_Face</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOp__Conv__VEF__Face.html#a88409d0b56b9e0db3d4f241a09930f82">ajouter</a> (const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;, <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOp__Conv__VEF__Face.html#a1fcf6b33ff3ee706ffef89a117e2f54a">remplir_fluent</a> (<a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOp__Conv__VEF__Face.html#a968452c80df39cea3adbc3a89976785a">dimensionner</a> (<a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">on dimensionne notre matrice au moyen de la methode dimensionner de la classe<br/>
<a class="el" href="classOp__VEF__Face.html">Op_VEF_Face</a>.  <a href="#a968452c80df39cea3adbc3a89976785a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOp__Conv__VEF__Face.html#aa087b349430a7cd7fd4ef64670dad088">modifier_pour_Cl</a> (<a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;, <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">On modifie le second membre et la matrice dans le cas des<br/>
conditions de dirichlet.  <a href="#aa087b349430a7cd7fd4ef64670dad088"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOp__Conv__VEF__Face.html#a27f891883f7b38b525b59d38d3f97ef3">contribuer_a_avec</a> (const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;, <a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">on assemble la matrice des inconnues implicite.  <a href="#a27f891883f7b38b525b59d38d3f97ef3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOp__Conv__VEF__Face.html#a175b6b231b04247e273074cee23474e7">contribuer_au_second_membre</a> (<a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">on ajoute la contribution du second membre.  <a href="#a175b6b231b04247e273074cee23474e7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOp__Conv__VEF__Face.html#a1ba01f3a164ec599e2eb12fea246fac7">contribue_au_second_membre</a> (<a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOp__Conv__VEF__Face.html#ad46bfa5e97653f57e64fb7f890d15e1b">ajouter_contribution</a> (const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;, <a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOp__Conv__VEF__Face.html#a80256cc6352e925934a4d1233f7378ea">get_ordre</a> (int &amp;) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOp__Conv__VEF__Face.html#a2e291bb90398522c5bbd1a08fb03f693">get_type_lim</a> (<a class="el" href="classMotcle.html">Motcle</a> &amp;) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOp__Conv__VEF__Face.html#ab2a0e04ea2fa8b2f9880d2e43ac49fc3">get_alpha</a> (double &amp;) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOp__Conv__VEF__Face.html#a0c5603c7c6d4d7eba5897a472b607e32">get_type_op</a> (int &amp;) const </td></tr>
<tr><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classObjet__U.html">Objet_U</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOp__Conv__VEF__Face.html#a95e421a79f78a63f6fc31001e480b801">cree_instance</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classType__info.html">Type_info</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOp__Conv__VEF__Face.html#a96dd257161111f4a1bc7028456c16da4">info</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Donne des informations sur le type de l'Objet_U.  <a href="#a96dd257161111f4a1bc7028456c16da4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classOp__Conv__VEF__Face.html">Op_Conv_VEF_Face</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOp__Conv__VEF__Face.html#aaf796aa5e9861e15db4afb2db07d6e12">self_cast</a> (<a class="el" href="classObjet__U.html">Objet_U</a> &amp;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classOp__Conv__VEF__Face.html">Op_Conv_VEF_Face</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOp__Conv__VEF__Face.html#a137b0427f8ba4a591de409481c8e54d4">self_cast</a> (const <a class="el" href="classObjet__U.html">Objet_U</a> &amp;)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">methode ajoutee pour caster en python  <a href="#a137b0427f8ba4a591de409481c8e54d4"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classType__info.html">Type_info</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOp__Conv__VEF__Face.html#ab04ee3b4166df4eea5ee4afa9bf25d43">info_obj</a></td></tr>
<tr><td colspan="2"><h2><a name="pro-types"></a>
Protected Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOp__Conv__VEF__Face.html#abbf17549ccbad9c64780dcca7a3e2634">type_operateur</a> { <a class="el" href="classOp__Conv__VEF__Face.html#abbf17549ccbad9c64780dcca7a3e2634a1192ae3f2c2a1d9d734f4cc495b58a44">amont</a>, 
<a class="el" href="classOp__Conv__VEF__Face.html#abbf17549ccbad9c64780dcca7a3e2634af9bc4313cad73dd46e9d5364c4f001b3">muscl</a>, 
<a class="el" href="classOp__Conv__VEF__Face.html#abbf17549ccbad9c64780dcca7a3e2634aeb4b20f4ab0bb61c69bfbf25d47d219d">centre</a>
 }</td></tr>
<tr><td colspan="2"><h2><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classSortie.html">Sortie</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOp__Conv__VEF__Face.html#a8eacb11670d5ea5cc15ed16632d15360">printOn</a> (<a class="el" href="classSortie.html">Sortie</a> &amp;x) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">NE FAIT RIEN<br/>
A surcharger dans les classes derivees.  <a href="#a8eacb11670d5ea5cc15ed16632d15360"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classEntree.html">Entree</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOp__Conv__VEF__Face.html#a20514a9862bc5e8a557eadc1b8860a2a">readOn</a> (<a class="el" href="classEntree.html">Entree</a> &amp;)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">NE FAIT RIEN<br/>
A surcharger dans les classes derivees.  <a href="#a20514a9862bc5e8a557eadc1b8860a2a"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMotcle.html">Motcle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOp__Conv__VEF__Face.html#a070e3e30a22b79bd58ac3bd36f7802f6">type_lim</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOp__Conv__VEF__Face.html#ad30e1a556295f226b7ef1215dc0030e5">ordre</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOp__Conv__VEF__Face.html#aebc1771cc4608fc51a8b6d15b93c8d3d">alpha_</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOp__Conv__VEF__Face.html#abbf17549ccbad9c64780dcca7a3e2634">type_operateur</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOp__Conv__VEF__Face.html#aac6bde5c9421ce149a3f28a11709b1f6">type_op</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOp__Conv__VEF__Face.html#a5a58e90633d9d06d20e898980ab9c4da">LIMITEUR</a> )(double, double)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classArrOfInt.html">ArrOfInt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOp__Conv__VEF__Face.html#a4adb50fa6ba0bee8a6fbbc0a2655fe86">traitement_pres_bord_</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classArrOfInt.html">ArrOfInt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOp__Conv__VEF__Face.html#a17766a9e6e2a57fde63def2595fbc6ca">est_une_face_de_dirichlet_</a></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>class <a class="el" href="classOp__Conv__VEF__Face.html" title="class Op_Conv_VEF_Face Cette classe represente l&#39;operateur de convection associe a une equation de tr...">Op_Conv_VEF_Face</a><br/>
Cette classe represente l'operateur de convection associe a une equation de<br/>
transport d'un scalaire.<br/>
La discretisation est VEF<br/>
Le champ convecte est scalaire ou vecteur de type <a class="el" href="classChamp__P1NC.html">Champ_P1NC</a><br/>
Le schema de convection est du type Decentre ou Centre </p>

<p>Definition at line <a class="el" href="Op__Conv__VEF__Face_8h_source.html#l00044">44</a> of file <a class="el" href="Op__Conv__VEF__Face_8h_source.html">Op_Conv_VEF_Face.h</a>.</p>
</div><hr/><h2>Member Enumeration Documentation</h2>
<a class="anchor" id="abbf17549ccbad9c64780dcca7a3e2634"></a><!-- doxytag: member="Op_Conv_VEF_Face::type_operateur" ref="abbf17549ccbad9c64780dcca7a3e2634" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classOp__Conv__VEF__Face.html#abbf17549ccbad9c64780dcca7a3e2634">Op_Conv_VEF_Face::type_operateur</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="abbf17549ccbad9c64780dcca7a3e2634a1192ae3f2c2a1d9d734f4cc495b58a44"></a><!-- doxytag: member="amont" ref="abbf17549ccbad9c64780dcca7a3e2634a1192ae3f2c2a1d9d734f4cc495b58a44" args="" -->amont</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="abbf17549ccbad9c64780dcca7a3e2634af9bc4313cad73dd46e9d5364c4f001b3"></a><!-- doxytag: member="muscl" ref="abbf17549ccbad9c64780dcca7a3e2634af9bc4313cad73dd46e9d5364c4f001b3" args="" -->muscl</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="abbf17549ccbad9c64780dcca7a3e2634aeb4b20f4ab0bb61c69bfbf25d47d219d"></a><!-- doxytag: member="centre" ref="abbf17549ccbad9c64780dcca7a3e2634aeb4b20f4ab0bb61c69bfbf25d47d219d" args="" -->centre</em>&nbsp;</td><td>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="Op__Conv__VEF__Face_8h_source.html#l00071">71</a> of file <a class="el" href="Op__Conv__VEF__Face_8h_source.html">Op_Conv_VEF_Face.h</a>.</p>
<div class="fragment"><pre class="fragment">{ <a class="code" href="classOp__Conv__VEF__Face.html#abbf17549ccbad9c64780dcca7a3e2634a1192ae3f2c2a1d9d734f4cc495b58a44">amont</a>, <a class="code" href="classOp__Conv__VEF__Face.html#abbf17549ccbad9c64780dcca7a3e2634af9bc4313cad73dd46e9d5364c4f001b3">muscl</a>, <a class="code" href="classOp__Conv__VEF__Face.html#abbf17549ccbad9c64780dcca7a3e2634aeb4b20f4ab0bb61c69bfbf25d47d219d">centre</a> };
</pre></div>
</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a84ff72e96d4f142a09a0ad59b63a8ba0"></a><!-- doxytag: member="Op_Conv_VEF_Face::~Op_Conv_VEF_Face" ref="a84ff72e96d4f142a09a0ad59b63a8ba0" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Op_Conv_VEF_Face::~Op_Conv_VEF_Face </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Op__Conv__VEF__Face_8cpp_source.html#l00029">29</a> of file <a class="el" href="Op__Conv__VEF__Face_8cpp_source.html">Op_Conv_VEF_Face.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae9cb44271acc7663c3e2333c7f7dab60"></a><!-- doxytag: member="Op_Conv_VEF_Face::Op_Conv_VEF_Face" ref="ae9cb44271acc7663c3e2333c7f7dab60" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Op_Conv_VEF_Face::Op_Conv_VEF_Face </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Op__Conv__VEF__Face_8h_source.html#l00050">50</a> of file <a class="el" href="Op__Conv__VEF__Face_8h_source.html">Op_Conv_VEF_Face.h</a>.</p>
<div class="fragment"><pre class="fragment">: <a class="code" href="classOp__Conv__VEF__Face.html#aebc1771cc4608fc51a8b6d15b93c8d3d">alpha_</a>(1) {};
</pre></div>
</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a88409d0b56b9e0db3d4f241a09930f82"></a><!-- doxytag: member="Op_Conv_VEF_Face::ajouter" ref="a88409d0b56b9e0db3d4f241a09930f82" args="(const DoubleTab &amp;, DoubleTab &amp;) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDoubleTab.html">DoubleTab</a> &amp; Op_Conv_VEF_Face::ajouter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>transporte</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>resu</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>&lt; (du/dx du/dy dv/dx dv/dy) pour un poly</p>
<p>&lt; (du/dx du/dy dv/dx dv/dy) pour une face</p>
<p>&lt; Une face reelle sur l'element virtuel</p>
<p>&lt; muscl ou centre </p>
</p>

<p>Reimplemented from <a class="el" href="classOperateur__base.html#a883475470b7446b8b2093859494abef4">Operateur_base</a>.</p>

<p>Reimplemented in <a class="el" href="classOp__Conv__EF__VEF__P1NC__Stab.html#a2364297a05bedfff1cde523dfc9563b0">Op_Conv_EF_VEF_P1NC_Stab</a>, and <a class="el" href="classOp__Conv__Muscl__New__VEF__Face.html#a51a3ed81dae9a408009dad9e3104f7de">Op_Conv_Muscl_New_VEF_Face</a>.</p>

<p>Definition at line <a class="el" href="Op__Conv__VEF__Face_8cpp_source.html#l00121">121</a> of file <a class="el" href="Op__Conv__VEF__Face_8cpp_source.html">Op_Conv_VEF_Face.cpp</a>.</p>

<p>References <a class="el" href="Op__Conv__VEF__Face_8h_source.html#l00070">alpha_</a>, <a class="el" href="Op__Conv__VEF__Face_8h_source.html#l00071">amont</a>, <a class="el" href="Champ__P1NC_8cpp_source.html#l00940">Champ_P1NC::calcul_gradient()</a>, <a class="el" href="classElem__VEF__base.html#a02b712675ec9d8bbb6571ddbbec33417">Elem_VEF_base::calcul_vc()</a>, <a class="el" href="classElem__VEF__base.html#a00c120f0da0a535610698bd8f2999f4c">Elem_VEF_base::calcul_xg()</a>, <a class="el" href="Op__Conv__VEF__Face_8h_source.html#l00071">centre</a>, <a class="el" href="Champ__P1iP1B__implementation_8cpp_source.html#l00331">coeff</a>, <a class="el" href="Domaine_8h_source.html#l00500">Domaine::coord_sommets()</a>, <a class="el" href="Zone__VF_8cpp_source.html#l00623">Zone_VF::creer_tableau_faces()</a>, <a class="el" href="Objet__U_8h_source.html#l00079">Objet_U::dimension</a>, <a class="el" href="DoubleTab_8h_source.html#l00243">DoubleTab::dimension()</a>, <a class="el" href="Zone_8cpp_source.html#l00262">Zone::domaine()</a>, <a class="el" href="DoubleVect_8cpp_source.html#l00277">DoubleVect::echange_espace_virtuel()</a>, <a class="el" href="Zone__VF_8h_source.html#l00574">Zone_VF::elem_faces()</a>, <a class="el" href="MorEqn_8h_source.html#l00082">MorEqn::equation()</a>, <a class="el" href="Op__Conv__VEF__Face_8h_source.html#l00076">est_une_face_de_dirichlet_</a>, <a class="el" href="Periodique_8h_source.html#l00056">Periodique::face_associee()</a>, <a class="el" href="Zone__VEF_8h_source.html#l00145">Zone_VEF::face_normales()</a>, <a class="el" href="Zone__VF_8h_source.html#l00609">Zone_VF::face_sommets()</a>, <a class="el" href="Zone__VF_8h_source.html#l00458">Zone_VF::face_voisins()</a>, <a class="el" href="Zone__VEF_8h_source.html#l00152">Zone_VEF::facette_normales()</a>, <a class="el" href="Operateur__base_8h_source.html#l00168">Operateur_base::flux_bords_</a>, <a class="el" href="Cond__lim_8h_source.html#l00130">Cond_lim::frontiere_dis()</a>, <a class="el" href="Cond__lim__base_8h_source.html#l00123">Cond_lim_base::frontiere_dis()</a>, <a class="el" href="Elem__VEF__base_8h_source.html#l00047">Elem_VEF_base::KEL()</a>, <a class="el" href="Op__Conv__VEF__base_8h_source.html#l00093">Op_Conv_VEF_base::la_zcl_vef</a>, <a class="el" href="Op__Conv__VEF__base_8h_source.html#l00092">Op_Conv_VEF_base::la_zone_vef</a>, <a class="el" href="Zone__Cl__dis__base_8cpp_source.html#l00522">Zone_Cl_dis_base::les_conditions_limites()</a>, <a class="el" href="Zone_8h_source.html#l00402">Zone::les_elems()</a>, <a class="el" href="Convection__tools_8cpp_source.html#l00031">minmod()</a>, <a class="el" href="Porosites__champ_8cpp_source.html#l00035">modif_par_porosite_si_flag()</a>, <a class="el" href="Op__VEF__Face_8cpp_source.html#l00384">Op_VEF_Face::modifier_flux()</a>, <a class="el" href="Op__Conv__VEF__Face_8h_source.html#l00071">muscl</a>, <a class="el" href="DoubleTab_8h_source.html#l00264">DoubleTab::nb_dim()</a>, <a class="el" href="Zone__dis__base_8h_source.html#l00144">Zone_dis_base::nb_elem_tot()</a>, <a class="el" href="Zone__VF_8h_source.html#l00519">Zone_VF::nb_faces()</a>, <a class="el" href="Front__VF_8h_source.html#l00061">Front_VF::nb_faces()</a>, <a class="el" href="Zone__VF_8h_source.html#l00547">Zone_VF::nb_faces_bord()</a>, <a class="el" href="Zone_8h_source.html#l00469">Zone::nb_faces_elem()</a>, <a class="el" href="Zone__VF_8h_source.html#l00527">Zone_VF::nb_faces_tot()</a>, <a class="el" href="Front__VF_8h_source.html#l00066">Front_VF::nb_faces_tot()</a>, <a class="el" href="Elem__VEF_8h_source.html#l00083">Elem_VEF::nb_facette()</a>, <a class="el" href="Zone__dis__base_8h_source.html#l00156">Zone_dis_base::nb_front_Cl()</a>, <a class="el" href="Zone_8h_source.html#l00445">Zone::nb_som_elem()</a>, <a class="el" href="Zone__dis__base_8h_source.html#l00152">Zone_dis_base::nb_som_tot()</a>, <a class="el" href="Zone__Cl__VEF_8h_source.html#l00130">Zone_Cl_VEF::normales_facettes_Cl()</a>, <a class="el" href="Front__VF_8h_source.html#l00076">Front_VF::num_face()</a>, <a class="el" href="Front__VF_8h_source.html#l00071">Front_VF::num_premiere_face()</a>, <a class="el" href="Op__Conv__VEF__Face_8h_source.html#l00069">ordre</a>, <a class="el" href="Op__Conv__VEF__base_8cpp_source.html#l00053">Op_Conv_VEF_base::phi_u_transportant()</a>, <a class="el" href="Zone__VF_8h_source.html#l00315">Zone_VF::porosite_elem()</a>, <a class="el" href="Zone__VF_8h_source.html#l00285">Zone_VF::porosite_face()</a>, <a class="el" href="Zone__VF_8h_source.html#l00512">Zone_VF::premiere_face_int()</a>, <a class="el" href="Objet__U_8cpp_source.html#l00132">Objet_U::que_suis_je()</a>, <a class="el" href="Zone__VEF_8h_source.html#l00165">Zone_VEF::rang_elem_non_std()</a>, <a class="el" href="DoubleTab_8cpp_source.html#l00211">DoubleTab::ref()</a>, <a class="el" href="Cast_8h_source.html#l00059">ref_cast</a>, <a class="el" href="Cast_8h_source.html#l00062">ref_cast_non_const</a>, <a class="el" href="DoubleTab_8cpp_source.html#l00335">DoubleTab::resize()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00240">ArrOfInt::resize_array()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00342">ArrOfInt::size_array()</a>, <a class="el" href="Cast_8h_source.html#l00054">sub_type</a>, <a class="el" href="Op__Conv__VEF__Face_8h_source.html#l00075">traitement_pres_bord_</a>, <a class="el" href="Zone__VEF_8h_source.html#l00138">Zone_VEF::type_elem()</a>, <a class="el" href="Zone__Cl__VEF_8h_source.html#l00167">Zone_Cl_VEF::type_elem_Cl()</a>, <a class="el" href="Op__Conv__VEF__Face_8h_source.html#l00072">type_op</a>, <a class="el" href="Neumann__sortie__libre_8cpp_source.html#l00138">Neumann_sortie_libre::val_ext()</a>, <a class="el" href="Elem__VEF_8h_source.html#l00041">Deriv_Elem_VEF_base::valeur()</a>, <a class="el" href="Cond__lim_8h_source.html#l00031">Deriv_Cond_lim_base::valeur()</a>, <a class="el" href="Ref__Zone__VEF_8h_source.html#l00028">Ref_Zone_VEF::valeur()</a>, <a class="el" href="Ref__Zone__Cl__VEF_8h_source.html#l00028">Ref_Zone_Cl_VEF::valeur()</a>, <a class="el" href="Zone__Cl__VEF_8h_source.html#l00140">Zone_Cl_VEF::vecteur_face_facette_Cl()</a>, <a class="el" href="Op__Conv__VEF__base_8h_source.html#l00069">Op_Conv_VEF_base::vitesse()</a>, <a class="el" href="Zone__VF_8h_source.html#l00650">Zone_VF::xv()</a>, and <a class="el" href="Zone__dis__base_8h_source.html#l00106">Zone_dis_base::zone()</a>.</p>
<div class="fragment"><pre class="fragment">{
<span class="comment">// statistiques().begin_count(m1);</span>
  assert((<a class="code" href="classOp__Conv__VEF__Face.html#aac6bde5c9421ce149a3f28a11709b1f6">type_op</a>==<a class="code" href="classOp__Conv__VEF__Face.html#abbf17549ccbad9c64780dcca7a3e2634a1192ae3f2c2a1d9d734f4cc495b58a44">amont</a>) || (<a class="code" href="classOp__Conv__VEF__Face.html#aac6bde5c9421ce149a3f28a11709b1f6">type_op</a>==<a class="code" href="classOp__Conv__VEF__Face.html#abbf17549ccbad9c64780dcca7a3e2634af9bc4313cad73dd46e9d5364c4f001b3">muscl</a>) || (<a class="code" href="classOp__Conv__VEF__Face.html#aac6bde5c9421ce149a3f28a11709b1f6">type_op</a>==<a class="code" href="classOp__Conv__VEF__Face.html#abbf17549ccbad9c64780dcca7a3e2634aeb4b20f4ab0bb61c69bfbf25d47d219d">centre</a>));
  <span class="keyword">const</span> <a class="code" href="classZone__Cl__VEF.html">Zone_Cl_VEF</a>&amp; zone_Cl_VEF = <a class="code" href="classOp__Conv__VEF__base.html#a03f677ee7911706a4f85cd37e0ca4535">la_zcl_vef</a>.<a class="code" href="classRef__Zone__Cl__VEF.html#a0970d7253def65ad4f0c5ce1830fd243">valeur</a>();
  <span class="keyword">const</span> <a class="code" href="classZone__VEF.html" title="class Zone_VEF Classe instanciable qui derive de Zone_VF. Cette classe contient les informations geom...">Zone_VEF</a>&amp; zone_VEF = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classZone__VEF.html" title="class Zone_VEF Classe instanciable qui derive de Zone_VF. Cette classe contient les informations geom...">Zone_VEF</a>, <a class="code" href="classOp__Conv__VEF__base.html#a6c29a488a6805ba4a9f2f059cdba77ae">la_zone_vef</a>.<a class="code" href="classRef__Zone__VEF.html#aafd9a5ee1a76f290c9c6b5447b0c8d30">valeur</a>());
  <span class="keyword">const</span> <a class="code" href="classChamp__Inc__base.html" title="Classe Champ_Inc_base Classe de base des champs inconnues qui sont les champs calcules par une equati...">Champ_Inc_base</a>&amp; la_vitesse=<a class="code" href="classOp__Conv__VEF__base.html#a4872ffd7c638ecc415191d92d7f5f507">vitesse</a>();
  <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; vitesse_face_absolue=la_vitesse.valeurs();
  <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; porosite_face = zone_VEF.<a class="code" href="classZone__VF.html#ad9d74d1d9da9f50ab26768dbbca7711b">porosite_face</a>();

  <span class="keywordtype">int</span> marq=<a class="code" href="classOp__Conv__VEF__base.html#ad380b9b9ca1d70282b289838a604a4b0" title="definit si l&#39;on convecte psi avec phi*u ou avec u">phi_u_transportant</a>(<a class="code" href="classMorEqn.html#a615dd9abff96edcb625fa0424a489864" title="Renvoie la reference sur l&#39;equation pointe par MorEqn::mon_equation. (version const)">equation</a>());
  <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a> transporte_face_;
  <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a> vitesse_face_;
<span class="comment">// soit on a transporte_face=phi*transporte et vitesse_face=vitesse</span>
<span class="comment">// soit on a transporte_face=transporte et vitesse_face=phi*vitesse</span>
<span class="comment">// cela depend si on transporte avec phi*u ou avec u.</span>
  <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; transporte_face = <a class="code" href="Porosites__champ_8cpp.html#a2340e7d73d0f9d34926d012fe1b1d884" title="renvoit le tableau res, res=org si flag=0, res= porosite*org sinon attention ne pas modifier res car ...">modif_par_porosite_si_flag</a>(transporte,transporte_face_,!marq,porosite_face);
  <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; vitesse_face    = <a class="code" href="Porosites__champ_8cpp.html#a2340e7d73d0f9d34926d012fe1b1d884" title="renvoit le tableau res, res=org si flag=0, res= porosite*org sinon attention ne pas modifier res car ...">modif_par_porosite_si_flag</a>(vitesse_face_absolue,vitesse_face_,marq,porosite_face);

  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; elem_faces = zone_VEF.<a class="code" href="classZone__VF.html#a067e462dcd3ab92b0f6d945b19e4eb37" title="renvoie le numero de le ieme face de la maille num_elem la facon dont ces faces sont numerotees est l...">elem_faces</a>();
  <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; facenormales = zone_VEF.<a class="code" href="classZone__VEF.html#a5742d75972e4846bf9fbb6ed5715053e">face_normales</a>();
  <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; facette_normales = zone_VEF.<a class="code" href="classZone__VEF.html#a581b1ca0e62c668c92f104351d19fda6">facette_normales</a>();
  <span class="keyword">const</span> <a class="code" href="classZone.html" title="classe Zone Une Zone est un maillage compose d&#39;un ensemble d&#39;elements geometriques de meme type...">Zone</a>&amp; zone = zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> nfa7 = zone_VEF.<a class="code" href="classZone__VEF.html#a46693c060b8096fb2595ca72192eea2a">type_elem</a>().<a class="code" href="classElem__VEF.html#a4a34777c0083b38dd34c8a400d5b4e90">nb_facette</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_elem_tot = zone_VEF.<a class="code" href="classZone__dis__base.html#a4d6aa445f152aa6dc54d66ea7a071147">nb_elem_tot</a>();
  <span class="keyword">const</span> <a class="code" href="classIntVect.html">IntVect</a>&amp; rang_elem_non_std = zone_VEF.<a class="code" href="classZone__VEF.html#a4b2171a85e5fc33663a3366acb713584">rang_elem_non_std</a>();
  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; face_voisins = zone_VEF.<a class="code" href="classZone__VF.html#a49d4322f5585a8fa95748ca785b70702" title="renvoie l&#39;element voisin de numface dans la direction i. i=0 : dans le sens oppose de l&#39;axe orthogona...">face_voisins</a>();
  <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; normales_facettes_Cl = zone_Cl_VEF.<a class="code" href="classZone__Cl__VEF.html#a83c05e82370553470ed05f10932e0f3f">normales_facettes_Cl</a>();
  <span class="keywordtype">int</span> premiere_face_int = zone_VEF.<a class="code" href="classZone__VF.html#a12869806fa4834aca8f2964e16509dfd" title="une face est interne ssi elle separe deux elements. renvoie le numero de la premiere face interne...">premiere_face_int</a>();
  <span class="keywordtype">int</span> nfac = zone.<a class="code" href="classZone.html#a548fbc7518be2f122b1a5c9589a443c2" title="Renvoie le nombre de face de type i des elements geometriques constituants la zone. Ex: les objets de la classe Prisme ont 2 types de faces: triangle ou quadrangle.">nb_faces_elem</a>();
  <span class="keywordtype">int</span> nsom = zone.<a class="code" href="classZone.html#ae0b34a93b9ae8146df2d1884157afe9f" title="Renvoie le nombre de sommets des elements geometriques constituants la zone. Tous les elements de la ...">nb_som_elem</a>();
  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; sommet_elem = zone.<a class="code" href="classZone.html#ac115e8342be89afb882b7b61cc343267" title="Renvoie le tableau des sommets des elements.">les_elems</a>();
  <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; vecteur_face_facette = <a class="code" href="Cast_8h.html#ad3836a067c92103af8df5ad8f35959a6">ref_cast_non_const</a>(<a class="code" href="classZone__VEF.html" title="class Zone_VEF Classe instanciable qui derive de Zone_VF. Cette classe contient les informations geom...">Zone_VEF</a>,zone_VEF).vecteur_face_facette();
  <span class="keyword">const</span>  <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; vecteur_face_facette_Cl = zone_Cl_VEF.<a class="code" href="classZone__Cl__VEF.html#aa7acf4bf79e075ba2488e2ee9051c6fe">vecteur_face_facette_Cl</a>();
  <span class="keywordtype">int</span> nb_bord = zone_VEF.<a class="code" href="classZone__dis__base.html#af22167d614644f55591a29c77eb1c009">nb_front_Cl</a>();
  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; les_elems=zone.<a class="code" href="classZone.html#ac115e8342be89afb882b7b61cc343267" title="Renvoie le tableau des sommets des elements.">les_elems</a>();

<span class="comment">// Permet d&#39;avoir un flux_bord coherent avec les CLs (mais parfois diverge?)</span>
<span class="comment">// Active uniquement pour ordre 3</span>
  <span class="keywordtype">int</span> option_appliquer_cl_dirichlet = (<a class="code" href="classOp__Conv__VEF__Face.html#ad30e1a556295f226b7ef1215dc0030e5">ordre</a>==3 ? 1 : 0);
  <span class="keywordtype">int</span> option_calcul_flux_en_un_point = 0;<span class="comment">//(ordre==3 ? 1 : 0);</span>
<span class="comment">// Definition d&#39;un tableau pour un traitement special des schemas pres des bords</span>
  <span class="keywordflow">if</span> (<a class="code" href="classOp__Conv__VEF__Face.html#a4adb50fa6ba0bee8a6fbbc0a2655fe86">traitement_pres_bord_</a>.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>()!=nb_elem_tot)
    {
      <a class="code" href="classOp__Conv__VEF__Face.html#a4adb50fa6ba0bee8a6fbbc0a2655fe86">traitement_pres_bord_</a>.<a class="code" href="classArrOfInt.html#a9b3afbb46b16870dbd36236c8935b535">resize_array</a>(nb_elem_tot);
      <a class="code" href="classOp__Conv__VEF__Face.html#a4adb50fa6ba0bee8a6fbbc0a2655fe86">traitement_pres_bord_</a>=0;
<span class="comment">// Pour muscl3 on applique le minmod sur les elements ayant une face de Dirichlet</span>
      <span class="keywordflow">if</span> (<a class="code" href="classOp__Conv__VEF__Face.html#ad30e1a556295f226b7ef1215dc0030e5">ordre</a>==3)
        {
          <span class="keywordflow">for</span> (<span class="keywordtype">int</span> n_bord=0; n_bord&lt;nb_bord; n_bord++)
            {
              <span class="keyword">const</span> <a class="code" href="classCond__lim__base.html" title="classe Cond_lim_base Classe de base pour la hierarchie des classes qui representent les differentes c...">Cond_lim_base</a>&amp; la_cl = zone_Cl_VEF.<a class="code" href="classZone__Cl__dis__base.html#af75e0ed7786863e4d333bfb29d67c323" title="Renvoie la i-ieme condition aux limites. (version const)">les_conditions_limites</a>(n_bord).<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>();
              <span class="keywordflow">if</span> ( <a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classDirichlet.html" title="classe Dirichlet Cette classe est la classe de base de la hierarchie des conditions aux limites de ty...">Dirichlet</a>,la_cl) || <a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classDirichlet__homogene.html" title="Classe Dirichlet_homogene Cette classe est la classe de base de la hierarchie des conditions aux limi...">Dirichlet_homogene</a>,la_cl) )
                {
                  <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp; le_bord = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>,la_cl.<a class="code" href="classCond__lim__base.html#ad88b3b516351146c85e8fce1df0f691a" title="Renvoie la frontiere discretisee a laquelle les conditions aux limites s&#39;appliquent.">frontiere_dis</a>());
                  <span class="keywordtype">int</span> nb_faces_tot = le_bord.<a class="code" href="classFront__VF.html#aed4006d91bf2ef3af2b9f7933d863a09" title="Nombre de faces reelles et virtuelles du bord.">nb_faces_tot</a>();
                  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> ind_face=0; ind_face&lt;nb_faces_tot; ind_face++)
                    {
                      <span class="keywordtype">int</span> num_face = le_bord.<a class="code" href="classFront__VF.html#a3402a19d7e54ed797d2b18e9a47ead1e" title="Renvoie le numero de face de la ieme face du bord.">num_face</a>(ind_face);
                      <span class="keywordtype">int</span> elem = face_voisins(num_face,0);
                      <a class="code" href="classOp__Conv__VEF__Face.html#a4adb50fa6ba0bee8a6fbbc0a2655fe86">traitement_pres_bord_</a>(elem)=1;
                    }
                }
            }
        }
      <span class="keywordflow">else</span>
        {
<span class="comment">// Pour le muscl/centre actuels on utilise un calcul de flux a l&#39;ordre 1</span>
<span class="comment">// aux mailles de bord ou aux mailles ayant un sommet de Dirichlet</span>
          <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> est_un_sommet_de_bord_(zone_VEF.<a class="code" href="classZone__dis__base.html#a8f793341b7a41d67561ba563ae0f69a0">nb_som_tot</a>());
          <span class="keywordflow">for</span> (<span class="keywordtype">int</span> n_bord=0; n_bord&lt;nb_bord; n_bord++)
            {
              <span class="keyword">const</span> <a class="code" href="classCond__lim__base.html" title="classe Cond_lim_base Classe de base pour la hierarchie des classes qui representent les differentes c...">Cond_lim_base</a>&amp; la_cl = zone_Cl_VEF.<a class="code" href="classZone__Cl__dis__base.html#af75e0ed7786863e4d333bfb29d67c323" title="Renvoie la i-ieme condition aux limites. (version const)">les_conditions_limites</a>(n_bord).<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>();
              <span class="keywordflow">if</span> ( <a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classDirichlet.html" title="classe Dirichlet Cette classe est la classe de base de la hierarchie des conditions aux limites de ty...">Dirichlet</a>,la_cl) || <a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classDirichlet__homogene.html" title="Classe Dirichlet_homogene Cette classe est la classe de base de la hierarchie des conditions aux limi...">Dirichlet_homogene</a>,la_cl) )
                {
                  <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp; le_bord = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>,la_cl.<a class="code" href="classCond__lim__base.html#ad88b3b516351146c85e8fce1df0f691a" title="Renvoie la frontiere discretisee a laquelle les conditions aux limites s&#39;appliquent.">frontiere_dis</a>());
                  <span class="keywordtype">int</span> nb_faces_tot = le_bord.<a class="code" href="classFront__VF.html#aed4006d91bf2ef3af2b9f7933d863a09" title="Nombre de faces reelles et virtuelles du bord.">nb_faces_tot</a>();
                  <span class="keywordtype">int</span> size = zone_VEF.<a class="code" href="classZone__VF.html#a298e73b18e17da55f421b1fb0879bd46" title="renvoie le numero du ieme sommet de la face num_face.">face_sommets</a>().dimension(1);
                  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> ind_face=0; ind_face&lt;nb_faces_tot; ind_face++)
                    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> som=0; som&lt;size; som++)
                      {
                        <span class="keywordtype">int</span> face = le_bord.<a class="code" href="classFront__VF.html#a3402a19d7e54ed797d2b18e9a47ead1e" title="Renvoie le numero de face de la ieme face du bord.">num_face</a>(ind_face);
                        est_un_sommet_de_bord_(zone_VEF.<a class="code" href="classZone__VF.html#a298e73b18e17da55f421b1fb0879bd46" title="renvoie le numero du ieme sommet de la face num_face.">face_sommets</a>(face,som))=1;
                      }
                }
            }
          <span class="keywordflow">for</span> (<span class="keywordtype">int</span> elem=0; elem&lt;nb_elem_tot; elem++)
            {
              <span class="keywordflow">if</span> (rang_elem_non_std(elem)!=-1)
                <a class="code" href="classOp__Conv__VEF__Face.html#a4adb50fa6ba0bee8a6fbbc0a2655fe86">traitement_pres_bord_</a>(elem)=1;
              <span class="keywordflow">else</span>
                {
                  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> n_som=0; n_som&lt;nsom; n_som++)
                    <span class="keywordflow">if</span> (est_un_sommet_de_bord_(les_elems(elem,n_som)))
                      <a class="code" href="classOp__Conv__VEF__Face.html#a4adb50fa6ba0bee8a6fbbc0a2655fe86">traitement_pres_bord_</a>(elem)=1;
                }
            }
        }
<span class="comment">// Construction du tableau est_une_face_de_dirichlet_</span>
      <a class="code" href="classOp__Conv__VEF__Face.html#a17766a9e6e2a57fde63def2595fbc6ca">est_une_face_de_dirichlet_</a>.<a class="code" href="classArrOfInt.html#a9b3afbb46b16870dbd36236c8935b535">resize_array</a>(zone_VEF.<a class="code" href="classZone__VF.html#a50fd21c9535680489015a3c8b88c685a" title="renvoie le nombre total de faces. C&#39;est-a-dire faces reelles + faces virtuelles">nb_faces_tot</a>());
      <a class="code" href="classOp__Conv__VEF__Face.html#a17766a9e6e2a57fde63def2595fbc6ca">est_une_face_de_dirichlet_</a>=0;
      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> n_bord=0; n_bord&lt;nb_bord; n_bord++)
        {
          <span class="keyword">const</span> <a class="code" href="classCond__lim__base.html" title="classe Cond_lim_base Classe de base pour la hierarchie des classes qui representent les differentes c...">Cond_lim_base</a>&amp; la_cl = zone_Cl_VEF.<a class="code" href="classZone__Cl__dis__base.html#af75e0ed7786863e4d333bfb29d67c323" title="Renvoie la i-ieme condition aux limites. (version const)">les_conditions_limites</a>(n_bord).<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>();
          <span class="keywordflow">if</span> ( <a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classDirichlet.html" title="classe Dirichlet Cette classe est la classe de base de la hierarchie des conditions aux limites de ty...">Dirichlet</a>,la_cl) || <a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classDirichlet__homogene.html" title="Classe Dirichlet_homogene Cette classe est la classe de base de la hierarchie des conditions aux limi...">Dirichlet_homogene</a>,la_cl) )
            {
              <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp; le_bord = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>,la_cl.<a class="code" href="classCond__lim__base.html#ad88b3b516351146c85e8fce1df0f691a" title="Renvoie la frontiere discretisee a laquelle les conditions aux limites s&#39;appliquent.">frontiere_dis</a>());
              <span class="keywordtype">int</span> nb_faces_tot = le_bord.<a class="code" href="classFront__VF.html#aed4006d91bf2ef3af2b9f7933d863a09" title="Nombre de faces reelles et virtuelles du bord.">nb_faces_tot</a>();
              <span class="keywordflow">for</span> (<span class="keywordtype">int</span> ind_face=0; ind_face&lt;nb_faces_tot; ind_face++)
                {
                  <span class="keywordtype">int</span> num_face = le_bord.<a class="code" href="classFront__VF.html#a3402a19d7e54ed797d2b18e9a47ead1e" title="Renvoie le numero de face de la ieme face du bord.">num_face</a>(ind_face);
                  <a class="code" href="classOp__Conv__VEF__Face.html#a17766a9e6e2a57fde63def2595fbc6ca">est_une_face_de_dirichlet_</a>(num_face) = 1;
                }
            }
        }
    }

<span class="comment">// Pour le traitement de la convection on distingue les polyedres</span>
<span class="comment">// standard qui ne &quot;voient&quot; pas les conditions aux limites et les</span>
<span class="comment">// polyedres non standard qui ont au moins une face sur le bord.</span>
<span class="comment">// Un polyedre standard a n facettes sur lesquelles on applique le</span>
<span class="comment">// schema de convection.</span>
<span class="comment">// Pour un polyedre non standard qui porte des conditions aux limites</span>
<span class="comment">// de Dirichlet, une partie des facettes sont portees par les faces.</span>
<span class="comment">// En bref pour un polyedre le traitement de la convection depend</span>
<span class="comment">// du type (triangle, tetraedre ...) et du nombre de faces de Dirichlet.</span>

  <span class="keyword">const</span> <a class="code" href="classElem__VEF__base.html">Elem_VEF_base</a>&amp; type_elemvef= zone_VEF.<a class="code" href="classZone__VEF.html#a46693c060b8096fb2595ca72192eea2a">type_elem</a>().<a class="code" href="classDeriv__Elem__VEF__base.html#a2886905d5071be902c77248b69ca0b7b">valeur</a>();
  <span class="keywordtype">int</span> istetra=0;
  <a class="code" href="classNom.html" title="class Nom Une chaine de caractere pour nommer les objets de TRUST">Nom</a> nom_elem=type_elemvef.<a class="code" href="classObjet__U.html#aa58e9a81c0ddc2c1149053b8f96698ac" title="renvoie la chaine identifiant la classe.">que_suis_je</a>();
  <span class="keywordflow">if</span> ((nom_elem==<span class="stringliteral">&quot;Tetra_VEF&quot;</span>)||(nom_elem==<span class="stringliteral">&quot;Tri_VEF&quot;</span>))
    istetra=1;

  <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; porosite_elem = zone_VEF.<a class="code" href="classZone__VF.html#afd135a1b227731193b1a97b7ed525435">porosite_elem</a>();
  <span class="keywordtype">double</span> psc;
  <span class="keywordtype">int</span> poly,face_adj,fa7,i,j,n_bord;
  <span class="keywordtype">int</span> num_face, rang;
  <span class="keywordtype">int</span> num10,num20,num_som;
  <span class="keywordtype">int</span> ncomp_ch_transporte=(transporte_face.<a class="code" href="classDoubleTab.html#ae6dda48778e7107e1beb723beef1f75b" title="Returns the number of dimensions of the array (&gt;= 1)">nb_dim</a>() == 1?1:transporte_face.<a class="code" href="classDoubleTab.html#ac3805e2637a3b880ba2d3e650c69dac4" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(1));

<span class="comment">// Traitement particulier pour les faces de periodicite</span>
  <span class="keywordtype">int</span> nb_faces_perio = 0;
  <span class="keywordflow">for</span> (n_bord=0; n_bord&lt;nb_bord; n_bord++)
    {
      <span class="keyword">const</span> <a class="code" href="classCond__lim.html" title="classe Cond_lim Classe generique servant a representer n&#39;importe quelle classe derivee de la classe C...">Cond_lim</a>&amp; la_cl = zone_Cl_VEF.<a class="code" href="classZone__Cl__dis__base.html#af75e0ed7786863e4d333bfb29d67c323" title="Renvoie la i-ieme condition aux limites. (version const)">les_conditions_limites</a>(n_bord);
      <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>()))
        {
          <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp; le_bord = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>,la_cl.<a class="code" href="classCond__lim.html#a5b2d24809cee07727006a891d4ce8d22" title="Appel a l&#39;objet sous-jacent Renvoie la frontiere discretisee associee a la condition aux limites...">frontiere_dis</a>());
          nb_faces_perio+=le_bord.<a class="code" href="classFront__VF.html#a341e2fcb5117b96e745fd7078ba86bab" title="Nombre de faces reelles du bord.">nb_faces</a>();
        }
    }

  <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a> tab;
  <span class="keywordflow">if</span> (ncomp_ch_transporte == 1)
    tab.<a class="code" href="classDoubleTab.html#ae83b4d31205c53d9c8d2b43da178ce75" title="Change la taille du vecteur (identique a resize_array() pour le traitement des anciennes valeurs et d...">resize</a>(nb_faces_perio);
  <span class="keywordflow">else</span>
    tab.<a class="code" href="classDoubleTab.html#ae83b4d31205c53d9c8d2b43da178ce75" title="Change la taille du vecteur (identique a resize_array() pour le traitement des anciennes valeurs et d...">resize</a>(nb_faces_perio,ncomp_ch_transporte);

  nb_faces_perio=0;
  <span class="keywordflow">for</span> (n_bord=0; n_bord&lt;nb_bord; n_bord++)
    {
      <span class="keyword">const</span> <a class="code" href="classCond__lim.html" title="classe Cond_lim Classe generique servant a representer n&#39;importe quelle classe derivee de la classe C...">Cond_lim</a>&amp; la_cl = zone_Cl_VEF.<a class="code" href="classZone__Cl__dis__base.html#af75e0ed7786863e4d333bfb29d67c323" title="Renvoie la i-ieme condition aux limites. (version const)">les_conditions_limites</a>(n_bord);
      <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>()))
        {
          <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp; le_bord = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>,la_cl.<a class="code" href="classCond__lim.html#a5b2d24809cee07727006a891d4ce8d22" title="Appel a l&#39;objet sous-jacent Renvoie la frontiere discretisee associee a la condition aux limites...">frontiere_dis</a>());
          <span class="keywordtype">int</span> num1 = le_bord.<a class="code" href="classFront__VF.html#a4986f0c65653fe9eb40bbbff5a97bf16" title="Numero de la premiere face du bord dans la liste des faces.">num_premiere_face</a>();
          <span class="keywordtype">int</span> num2 = num1 + le_bord.<a class="code" href="classFront__VF.html#a341e2fcb5117b96e745fd7078ba86bab" title="Nombre de faces reelles du bord.">nb_faces</a>();
          <span class="keywordflow">for</span> (num_face=num1; num_face&lt;num2; num_face++)
            {
              <span class="keywordflow">if</span> (ncomp_ch_transporte == 1)
                tab(nb_faces_perio) = resu(num_face);
              <span class="keywordflow">else</span>
                <span class="keywordflow">for</span> (<span class="keywordtype">int</span> comp=0; comp&lt;ncomp_ch_transporte; comp++)
                  tab(nb_faces_perio,comp) = resu(num_face,comp);
              nb_faces_perio++;
            }
        }
    }

  <span class="keywordtype">int</span> fac=0,elem1,elem2,comp0;
  <span class="keywordtype">int</span> nb_faces_ = zone_VEF.<a class="code" href="classZone__VF.html#aede27992d9f2eedd52c24d4a80ff7ffb" title="renvoie le nombre global de faces.">nb_faces</a>();
  <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> face(nfac);
<span class="comment">// statistiques().end_count(m1);</span>
<span class="comment">// statistiques().begin_count(m2);</span>

<span class="comment">// Tableau gradient base sur gradient_elem selon schema</span>
  <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a> gradient_elem(nb_elem_tot,ncomp_ch_transporte,<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>);  <span class="comment">//!&lt; (du/dx du/dy dv/dx dv/dy) pour un poly</span>
<span class="comment"></span>  <span class="keywordflow">if</span>(<a class="code" href="classOp__Conv__VEF__Face.html#aac6bde5c9421ce149a3f28a11709b1f6">type_op</a>==<a class="code" href="classOp__Conv__VEF__Face.html#abbf17549ccbad9c64780dcca7a3e2634aeb4b20f4ab0bb61c69bfbf25d47d219d">centre</a> || <a class="code" href="classOp__Conv__VEF__Face.html#aac6bde5c9421ce149a3f28a11709b1f6">type_op</a>==<a class="code" href="classOp__Conv__VEF__Face.html#abbf17549ccbad9c64780dcca7a3e2634af9bc4313cad73dd46e9d5364c4f001b3">muscl</a>)
    {
      <a class="code" href="classChamp__P1NC.html#a87d96c073d3c127684934610f9a1e407">Champ_P1NC::calcul_gradient</a>(transporte_face,gradient_elem,zone_Cl_VEF);
    }
  <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a> gradient;
  <span class="keywordflow">if</span> (<a class="code" href="classOp__Conv__VEF__Face.html#aac6bde5c9421ce149a3f28a11709b1f6">type_op</a>==<a class="code" href="classOp__Conv__VEF__Face.html#abbf17549ccbad9c64780dcca7a3e2634aeb4b20f4ab0bb61c69bfbf25d47d219d">centre</a>)
    {
      gradient.<a class="code" href="classDoubleTab.html#afc7cddeeec2c80636e54eaf330ac41ad" title="fait pointer le tableau sur le vecteur v et en associant la meme structure parallele. Attention, si line_size du vecteur v est different de 1, on cree un tableau bidimensionnel (on peut avoir un vecteur de ce type si on copie un Tab dans un Vect puis on prend une ref sur ce Vect).">ref</a>(gradient_elem);
    }
  <span class="keywordflow">else</span> <span class="keywordflow">if</span>(<a class="code" href="classOp__Conv__VEF__Face.html#aac6bde5c9421ce149a3f28a11709b1f6">type_op</a>==<a class="code" href="classOp__Conv__VEF__Face.html#abbf17549ccbad9c64780dcca7a3e2634af9bc4313cad73dd46e9d5364c4f001b3">muscl</a>)
    {
<span class="comment">// application du limiteur</span>
      gradient.<a class="code" href="classDoubleTab.html#ae83b4d31205c53d9c8d2b43da178ce75" title="Change la taille du vecteur (identique a resize_array() pour le traitement des anciennes valeurs et d...">resize</a>(0, ncomp_ch_transporte, <a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>);     <span class="comment">//!&lt; (du/dx du/dy dv/dx dv/dy) pour une face</span>
<span class="comment"></span>      zone_VEF.<a class="code" href="classZone__VF.html#a8e02e68f236356f72728b82536538ac5">creer_tableau_faces</a>(gradient);
      <span class="keywordflow">for</span> (n_bord=0; n_bord&lt;nb_bord; n_bord++)
        {
          <span class="keyword">const</span> <a class="code" href="classCond__lim.html" title="classe Cond_lim Classe generique servant a representer n&#39;importe quelle classe derivee de la classe C...">Cond_lim</a>&amp; la_cl = zone_Cl_VEF.<a class="code" href="classZone__Cl__dis__base.html#af75e0ed7786863e4d333bfb29d67c323" title="Renvoie la i-ieme condition aux limites. (version const)">les_conditions_limites</a>(n_bord);
          <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp; le_bord = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>,la_cl.<a class="code" href="classCond__lim.html#a5b2d24809cee07727006a891d4ce8d22" title="Appel a l&#39;objet sous-jacent Renvoie la frontiere discretisee associee a la condition aux limites...">frontiere_dis</a>());
          <span class="keywordtype">int</span> num1 = le_bord.<a class="code" href="classFront__VF.html#a4986f0c65653fe9eb40bbbff5a97bf16" title="Numero de la premiere face du bord dans la liste des faces.">num_premiere_face</a>();
          <span class="keywordtype">int</span> num2 = num1 + le_bord.<a class="code" href="classFront__VF.html#a341e2fcb5117b96e745fd7078ba86bab" title="Nombre de faces reelles du bord.">nb_faces</a>();
          <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>()))
            {
              <span class="keywordflow">for</span> (fac=num1; fac&lt;num2; fac++)
                {
                  elem1=face_voisins(fac,0);
                  elem2=face_voisins(fac,1);
                  <span class="keywordflow">for</span> (comp0=0; comp0&lt;ncomp_ch_transporte; comp0++)
                    <span class="keywordflow">for</span> (i=0; i&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; i++)
                      {
                        <span class="keywordtype">double</span> grad1=gradient_elem(elem1, comp0, i);
                        <span class="keywordtype">double</span> grad2=gradient_elem(elem2, comp0, i);
                        gradient(fac, comp0, i) =(*LIMITEUR)(grad1, grad2);
                      }
                }
            }
          <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classSymetrie.html" title="classe Symetrie Sur les faces de symetrie on a les proprietes suivantes: - composante normale de la v...">Symetrie</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>()))
            {
              <span class="keywordflow">for</span> (fac=num1; fac&lt;num2; fac++)
                {
                  elem1=face_voisins(fac,0);
                  <span class="keywordflow">for</span> (comp0=0; comp0&lt;ncomp_ch_transporte; comp0++)
                    <span class="keywordflow">for</span> (i=0; i&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; i++)
                      gradient(fac, comp0, i) = gradient_elem(elem1, comp0, i);

                  <span class="keywordflow">if</span> (<a class="code" href="classOp__Conv__VEF__Face.html#ad30e1a556295f226b7ef1215dc0030e5">ordre</a>==3)
                    {
<span class="comment">// On enleve la composante normale (on pourrait le faire pour les autres schemas...)</span>
<span class="comment">// mais pour le moment, on ne veut pas changer le comportement par defaut du muscl...</span>
<span class="comment">// const DoubleTab&amp; facenormales = zone_VEF.face_normales();</span>
                      <span class="keywordflow">for</span> (comp0=0; comp0&lt;ncomp_ch_transporte; comp0++)
                        <span class="keywordflow">for</span> (i=0; i&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; i++)
                          {
                            <span class="keywordtype">double</span> carre_surface=0;
                            <span class="keywordtype">double</span> tmp=0;
                            <span class="keywordflow">for</span> (j=0; j&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; j++)
                              {
                                <span class="keywordtype">double</span> ndS=facenormales(fac,j);
                                carre_surface += ndS*ndS;
                                tmp += gradient(fac, comp0, j)*ndS;
                              }
                            gradient(fac, comp0, i) -= tmp*facenormales(fac,i)/carre_surface;
                          }
                    }
                }
            }
        }

      <span class="keywordflow">for</span> (fac=premiere_face_int; fac&lt;nb_faces_; fac++)
        {
          elem1=face_voisins(fac,0);
          elem2=face_voisins(fac,1);
          <span class="keywordtype">int</span> minmod_pres_du_bord = 0;
          <span class="keywordflow">if</span> (<a class="code" href="classOp__Conv__VEF__Face.html#ad30e1a556295f226b7ef1215dc0030e5">ordre</a>==3 &amp;&amp; (<a class="code" href="classOp__Conv__VEF__Face.html#a4adb50fa6ba0bee8a6fbbc0a2655fe86">traitement_pres_bord_</a>(elem1) || <a class="code" href="classOp__Conv__VEF__Face.html#a4adb50fa6ba0bee8a6fbbc0a2655fe86">traitement_pres_bord_</a>(elem2))) minmod_pres_du_bord = 1;
          <span class="keywordflow">for</span> (comp0=0; comp0&lt;ncomp_ch_transporte; comp0++)
            <span class="keywordflow">for</span> (i=0; i&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; i++)
              {
                <span class="keywordtype">double</span> grad1=gradient_elem(elem1, comp0, i);
                <span class="keywordtype">double</span> grad2=gradient_elem(elem2, comp0, i);
                <span class="keywordflow">if</span> (minmod_pres_du_bord)
                  gradient(fac, comp0, i) = <a class="code" href="Convection__tools_8cpp.html#acd40757070ae472ea829cf1cb522d91a">minmod</a>(grad1, grad2);
                <span class="keywordflow">else</span>
                  gradient(fac, comp0, i) = (*LIMITEUR)(grad1, grad2);
              }
        } <span class="comment">//!&lt; fin du for faces</span>
<span class="comment"></span>      gradient.<a class="code" href="classDoubleVect.html#abfebbc2f685ce7bc4b80c720d7da9bf3">echange_espace_virtuel</a>();
    }<span class="comment">//!&lt; fin if(type_op==muscl)</span>
<span class="comment"></span>
  <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a> vs(dimension);
  <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a> vc(dimension);
  <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a> cc(dimension);
  <a class="code" href="classDoubleVect.html">DoubleVect</a> xc(dimension);
  <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a> vsom(nsom,dimension);
  <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a> xsom(nsom,dimension);

<span class="comment">// Dimensionnement du tableau des flux convectifs au bord du domaine de calcul</span>
  <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; flux_b = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>,<a class="code" href="classOperateur__base.html#a451f51b41518ddbc0d3f586a8177d319" title="Tableau contenant les flux sur les bords de l&#39;operateur.">flux_bords_</a>);
  <span class="keywordtype">int</span> nb_faces_bord=zone_VEF.<a class="code" href="classZone__VF.html#a8815e2276637c0db23868f043dc43e58" title="renvoie le nombre de faces sur lesquelles sont appliquees les conditions limites : bords...">nb_faces_bord</a>();
  flux_b.<a class="code" href="classDoubleTab.html#ae83b4d31205c53d9c8d2b43da178ce75" title="Change la taille du vecteur (identique a resize_array() pour le traitement des anciennes valeurs et d...">resize</a>(nb_faces_bord,ncomp_ch_transporte);
  flux_b = 0.;

  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; KEL=type_elemvef.<a class="code" href="classElem__VEF__base.html#ab129610ef702aa8c9c98dcb4c7551172">KEL</a>();
  <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; xv=zone_VEF.<a class="code" href="classZone__VF.html#a918c0885a9b67317fcce3a0535306542">xv</a>();
  <span class="keyword">const</span> <a class="code" href="classDomaine.html" title="Classe Domaine Un Domaine represente le domaine (spatial) de resolution d&#39;un Probleme. Un Domaine a un Nom, il est constitue d&#39;une ou plusieurs Zone qui peuvent etre eventuellement decoupees en Sous_Zone. Un Domaine porte l&#39;ensemble des sommets utilises par ses Zones. On peut vouloir resoudre des problemes de type different sur plusieurs domaines, geometriquement les domaines sont alors couples par des surfaces qu&#39;on appelle Raccord.">Domaine</a>&amp; domaine=zone.<a class="code" href="classZone.html#a379ad2206b5a13a4f4f3df6d44c7546a" title="Renvoie le domaine dont la zone fait partie. (version const)">domaine</a>();
  <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; coord_sommets=domaine.<a class="code" href="classDomaine.html#aecd32c3eecc15cce7d1a0e468dadbf96" title="Renvoie le tableau des coordonnees des noeuds (sommets). (acces en lecture)">coord_sommets</a>();

<span class="comment">// Boucle ou non selon la valeur de alpha (uniquement a l&#39;ordre 3 pour le moment)</span>
<span class="comment">// Si alpha=1, la boucle se limite a une simple passe avec le schema choisi (muscl, amont, centre)</span>
<span class="comment">// Si alpha&lt;1, la boucle se compose de 2 passes:</span>
<span class="comment">// -la premiere avec le schema choisi et une ponderation de alpha</span>
<span class="comment">// -la seconde avec le schema centre et une ponderation de 1-alpha</span>
  <span class="keywordtype">double</span> alpha = <a class="code" href="classOp__Conv__VEF__Face.html#aebc1771cc4608fc51a8b6d15b93c8d3d">alpha_</a>;
  <span class="keywordtype">int</span> nombre_passes = (alpha==1 ? 1 : 2);
  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> passe=1; passe&lt;=nombre_passes; passe++)
    {
      <a class="code" href="classOp__Conv__VEF__Face.html#abbf17549ccbad9c64780dcca7a3e2634">type_operateur</a> type_op_boucle = <a class="code" href="classOp__Conv__VEF__Face.html#aac6bde5c9421ce149a3f28a11709b1f6">type_op</a>;
      <span class="keywordflow">if</span> (passe==2)
        {
          type_op_boucle = <a class="code" href="classOp__Conv__VEF__Face.html#abbf17549ccbad9c64780dcca7a3e2634aeb4b20f4ab0bb61c69bfbf25d47d219d">centre</a>;
          gradient.<a class="code" href="classDoubleTab.html#afc7cddeeec2c80636e54eaf330ac41ad" title="fait pointer le tableau sur le vecteur v et en associant la meme structure parallele. Attention, si line_size du vecteur v est different de 1, on cree un tableau bidimensionnel (on peut avoir un vecteur de ce type si on copie un Tab dans un Vect puis on prend une ref sur ce Vect).">ref</a>(gradient_elem);
        }
<span class="comment">// Les polyedres non standard sont ranges en 2 groupes dans la Zone_VEF:</span>
<span class="comment">// - polyedres bords et joints</span>
<span class="comment">// - polyedres bords et non joints</span>
<span class="comment">// On traite les polyedres en suivant l&#39;ordre dans lequel ils figurent</span>
<span class="comment">// dans la zone</span>
<span class="comment">// boucle sur les polys</span>
      <span class="keywordflow">for</span> (poly=0; poly&lt;nb_elem_tot; poly++)
        {
          <span class="keywordtype">int</span> contrib = 0;
<span class="comment">// calcul des numeros des faces du polyedre</span>
          <span class="keywordflow">for</span> (face_adj=0; face_adj&lt;nfac; face_adj++)
            {
              <span class="keywordtype">int</span> face_ = elem_faces(poly,face_adj);
              face(face_adj)= face_;
              <span class="keywordflow">if</span> (face_&lt;nb_faces_) contrib=1; <span class="comment">//!&lt; Une face reelle sur l&#39;element virtuel</span>
<span class="comment"></span>            }
<span class="comment">// </span>
          <span class="keywordflow">if</span> (contrib)
            {
              <span class="keywordtype">int</span> calcul_flux_en_un_point = (<a class="code" href="classOp__Conv__VEF__Face.html#ad30e1a556295f226b7ef1215dc0030e5">ordre</a> != 3) &amp;&amp; (<a class="code" href="classOp__Conv__VEF__Face.html#ad30e1a556295f226b7ef1215dc0030e5">ordre</a>==1 || <a class="code" href="classOp__Conv__VEF__Face.html#a4adb50fa6ba0bee8a6fbbc0a2655fe86">traitement_pres_bord_</a>(poly));
              <span class="keywordflow">for</span> (j=0; j&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; j++)
                {
                  vs(j) = vitesse_face_absolue(face(0),j)*porosite_face(face(0));
                  <span class="keywordflow">for</span> (i=1; i&lt;nfac; i++)
                    vs(j)+= vitesse_face_absolue(face(i),j)*porosite_face(face(i));
                }
<span class="comment">// calcul de la vitesse aux sommets des polyedres</span>
<span class="comment">// On va utliser les fonctions de forme implementees dans la classe Champs_P1_impl ou Champs_Q1_impl</span>
              <span class="keywordflow">if</span> (istetra==1)
                {
                  <span class="keywordflow">for</span> (i=0; i&lt;nsom; i++)
                    <span class="keywordflow">for</span> (j=0; j&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; j++)
                      vsom(i,j) = (vs(j) - dimension*vitesse_face_absolue(face(i),j)*porosite_face(face(i)));
                }
              <span class="keywordflow">else</span>
                {
<span class="comment">// pour que cela soit valide avec les hexa (c&#39;est + lent a calculer...)</span>
                  <span class="keywordflow">for</span> (j=0; j&lt;nsom; j++)
                    {
                      num_som = sommet_elem(poly,j);
                      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> ncomp=0; ncomp&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; ncomp++)
                        vsom(j,ncomp) = la_vitesse.valeur_a_sommet_compo(num_som,poly,ncomp);
                    }
                }

<span class="comment">// Determination du type de CL selon le rang</span>
              rang = rang_elem_non_std(poly);
              <span class="keywordtype">int</span> itypcl = (rang==-1 ? 0 : zone_Cl_VEF.<a class="code" href="classZone__Cl__VEF.html#a483bdab7690f844ed04e3defe04ec70a">type_elem_Cl</a>(rang));

<span class="comment">// calcul de vc (a l&#39;intersection des 3 facettes) vc vs vsom proportionnelles a la porosite</span>
              type_elemvef.<a class="code" href="classElem__VEF__base.html#a02b712675ec9d8bbb6571ddbbec33417">calcul_vc</a>(face,vc,vs,vsom,<a class="code" href="classOp__Conv__VEF__base.html#a4872ffd7c638ecc415191d92d7f5f507">vitesse</a>(),itypcl,porosite_face);

<span class="comment">// calcul de xc (a l&#39;intersection des 3 facettes) necessaire pour muscl3</span>
              <span class="keywordflow">if</span> (<a class="code" href="classOp__Conv__VEF__Face.html#ad30e1a556295f226b7ef1215dc0030e5">ordre</a>==3)
                {
                  <span class="keywordtype">int</span> idirichlet;
                  <span class="keywordtype">int</span> n1,n2,n3;
                  <span class="keywordflow">for</span> (i=0; i&lt;nsom; i++)
                    <span class="keywordflow">for</span> (j=0; j&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; j++)
                      xsom(i,j) = coord_sommets(les_elems(poly,i),j);
                  type_elemvef.<a class="code" href="classElem__VEF__base.html#a00c120f0da0a535610698bd8f2999f4c">calcul_xg</a>(xc,xsom,itypcl,idirichlet,n1,n2,n3);
                }

<span class="comment">// Gestion de la porosite</span>
              <span class="keywordflow">if</span> (marq==0)
                {
                  <span class="keywordtype">double</span> <a class="code" href="Champ__P1iP1B__implementation_8cpp.html#aa8c8f49390c3cf7c702d71a71bc977e3">coeff</a>=1./porosite_elem(poly);
                  vsom*=<a class="code" href="Champ__P1iP1B__implementation_8cpp.html#aa8c8f49390c3cf7c702d71a71bc977e3">coeff</a>;
                  vc*=<a class="code" href="Champ__P1iP1B__implementation_8cpp.html#aa8c8f49390c3cf7c702d71a71bc977e3">coeff</a>;
                }
<span class="comment">// Boucle sur les facettes du polyedre non standard:</span>
              <span class="keywordflow">for</span> (fa7=0; fa7&lt;nfa7; fa7++)
                {
                  num10 = face(KEL(0,fa7));
                  num20 = face(KEL(1,fa7));
<span class="comment">// normales aux facettes</span>
                  <span class="keywordflow">if</span> (rang==-1)
                    <span class="keywordflow">for</span> (i=0; i&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; i++)
                      cc[i] = facette_normales(poly, fa7, i);
                  <span class="keywordflow">else</span>
                    <span class="keywordflow">for</span> (i=0; i&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; i++)
                      cc[i] = normales_facettes_Cl(rang,fa7,i);

<span class="comment">// Calcul des vitesses en C,S,S2 les 3 extremites de la fa7 et M le centre de la fa7</span>
                  <span class="keywordtype">double</span> psc_c=0,psc_s=0,psc_m,psc_s2=0;
                  <span class="keywordflow">if</span> (dimension==2)
                    {
                      <span class="keywordflow">for</span> (i=0; i&lt;2; i++)
                        {
                          psc_c+=vc[i]*cc[i];
                          psc_s+=vsom(KEL(2,fa7),i)*cc[i];
                        }
                      psc_m=(psc_c+psc_s)/2.;
                    }
                  <span class="keywordflow">else</span>
                    {
                      <span class="keywordflow">for</span> (i=0; i&lt;3; i++)
                        {
                          psc_c+=vc[i]*cc[i];
                          psc_s+=vsom(KEL(2,fa7),i)*cc[i];
                          psc_s2+=vsom(KEL(3,fa7),i)*cc[i];
                        }
                      psc_m=(psc_c+psc_s+psc_s2)/3.;
                    }
<span class="comment">// On applique les CL de Dirichlet si num1 ou num2 est une face avec CL de Dirichlet</span>
<span class="comment">// auquel cas la fa7 coincide avec la face num1 ou num2 -&gt; C est au centre de la face</span>
                  <span class="keywordtype">int</span> appliquer_cl_dirichlet=0;
                  <span class="keywordflow">if</span> (option_appliquer_cl_dirichlet)
                    <span class="keywordflow">if</span> (<a class="code" href="classOp__Conv__VEF__Face.html#a17766a9e6e2a57fde63def2595fbc6ca">est_une_face_de_dirichlet_</a>(num10) || <a class="code" href="classOp__Conv__VEF__Face.html#a17766a9e6e2a57fde63def2595fbc6ca">est_une_face_de_dirichlet_</a>(num20))
                      {
                        appliquer_cl_dirichlet = 1;
                        psc_m = psc_c;
                      }

<span class="comment">// Determination de la face amont pour M</span>
                  <span class="keywordtype">int</span> face_amont_m,dir;
                  <span class="keywordflow">if</span> (psc_m &gt;= 0)
                    {
                      face_amont_m = num10;
                      dir=0;
                    }
                  <span class="keywordflow">else</span>
                    {
                      face_amont_m = num20;
                      dir=1;
                    }
<span class="comment">// Determination des faces amont pour les points C,S,S2</span>
                  <span class="keywordtype">int</span> face_amont_c=face_amont_m;
                  <span class="keywordtype">int</span> face_amont_s=face_amont_m;
                  <span class="keywordtype">int</span> face_amont_s2=face_amont_m;
                  <span class="keywordflow">if</span> (type_op_boucle==<a class="code" href="classOp__Conv__VEF__Face.html#abbf17549ccbad9c64780dcca7a3e2634af9bc4313cad73dd46e9d5364c4f001b3">muscl</a> &amp;&amp; <a class="code" href="classOp__Conv__VEF__Face.html#ad30e1a556295f226b7ef1215dc0030e5">ordre</a>==3)
                    {
                      face_amont_c  = (psc_c &gt;= 0)  ? num10 : num20;
                      face_amont_s  = (psc_s &gt;= 0)  ? num10 : num20;
                      face_amont_s2 = (psc_s2 &gt;= 0) ? num10 : num20;
                    }
<span class="comment">// gradient aux items element (schema centre) ou aux items face (schemas muscl)</span>
                  <span class="keywordtype">int</span> item_m=poly;
                  <span class="keywordtype">int</span> item_c=poly;
                  <span class="keywordtype">int</span> item_s=poly;
                  <span class="keywordtype">int</span> item_s2=poly;
                  <span class="keywordflow">if</span> (type_op_boucle==<a class="code" href="classOp__Conv__VEF__Face.html#abbf17549ccbad9c64780dcca7a3e2634af9bc4313cad73dd46e9d5364c4f001b3">muscl</a>)
                    {
                      item_m = face_amont_m;
                      item_c = face_amont_c;
                      item_s = face_amont_s;
                      item_s2 = face_amont_s2;
                    }

                  <span class="keywordflow">for</span> (comp0=0; comp0&lt;ncomp_ch_transporte; comp0++)
                    {
                      <span class="keywordtype">double</span> flux;
                      <span class="keywordtype">double</span> inco_m = (ncomp_ch_transporte==1?transporte_face(face_amont_m):transporte_face(face_amont_m,comp0));
                      <span class="keywordflow">if</span> (type_op_boucle==<a class="code" href="classOp__Conv__VEF__Face.html#abbf17549ccbad9c64780dcca7a3e2634a1192ae3f2c2a1d9d734f4cc495b58a44">amont</a> || appliquer_cl_dirichlet)
                        {
                          flux = inco_m*psc_m;
                        }
                      <span class="keywordflow">else</span> <span class="comment">//!&lt; muscl ou centre</span>
<span class="comment"></span>                        {
<span class="comment">// Calcul de l&#39;inconnue au centre M de la fa7</span>
                          <span class="keywordflow">if</span> (rang==-1)
                            <span class="keywordflow">for</span> (j=0; j&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; j++)
                              inco_m+= gradient(item_m,comp0,j)*vecteur_face_facette(poly,fa7,j,dir);
                          <span class="keywordflow">else</span>
                            <span class="keywordflow">for</span> (j=0; j&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; j++)
                              inco_m+= gradient(item_m,comp0,j)*vecteur_face_facette_Cl(rang,fa7,j,dir);

<span class="comment">// Calcul de l&#39;inconnue au sommet S, une premiere extremite de la fa7</span>
                          <span class="keywordtype">double</span> inco_s = (ncomp_ch_transporte==1?transporte_face(face_amont_s):transporte_face(face_amont_s,comp0));
                          <span class="keywordtype">int</span> sommet_s = sommet_elem(poly,KEL(2,fa7));
                          <span class="keywordflow">for</span> (j=0; j&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; j++)
                            inco_s+= gradient(item_s,comp0,j)*(-xv(face_amont_s,j)+coord_sommets(sommet_s,j));

<span class="comment">// Calcul de l&#39;inconnue au sommet S2, la derniere extremite de la fa7 en 3D</span>
                          <span class="keywordtype">double</span> inco_s2=0;
                          <span class="keywordflow">if</span> (dimension==3)
                            {
                              inco_s2 = (ncomp_ch_transporte==1?transporte_face(face_amont_s2):transporte_face(face_amont_s2,comp0));
                              <span class="keywordtype">int</span> sommet_s2 = sommet_elem(poly,KEL(3,fa7));
                              <span class="keywordflow">for</span> (j=0; j&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; j++)
                                inco_s2+= gradient(item_s2,comp0,j)*(-xv(face_amont_s2,j)+coord_sommets(sommet_s2,j));
                            }

<span class="comment">// Calcul de l&#39;inconnue a C, une autre extremite de la fa7, intersection avec les autres fa7</span>
<span class="comment">// du polyedre. C=G centre du polyedre si volume non etendu</span>
<span class="comment">// xc donne par elemvef.calcul_xg()</span>
                          <span class="keywordtype">double</span> inco_c;
                          <span class="keywordflow">if</span> (<a class="code" href="classOp__Conv__VEF__Face.html#ad30e1a556295f226b7ef1215dc0030e5">ordre</a>==3)
                            {
                              inco_c = (ncomp_ch_transporte==1?transporte_face(face_amont_c):transporte_face(face_amont_c,comp0));
                              <span class="keywordflow">for</span> (j=0; j&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; j++)
                                inco_c+= gradient(item_c,comp0,j)*(-xv(face_amont_c,j)+xc(j));
                            }
                          <span class="keywordflow">else</span>
                            {
                              inco_c = dimension*inco_m-inco_s-inco_s2;
                            }

<span class="comment">// Calcul du flux sur 1 point</span>
                          <span class="keywordflow">if</span> (calcul_flux_en_un_point || option_calcul_flux_en_un_point)
                            {
                              flux = inco_m*psc_m;
                            }
                          <span class="keywordflow">else</span>
                            {
<span class="comment">// Calcul du flux sur 3 points</span>
                              flux = (dimension==2) ? (inco_c*psc_c + inco_s*psc_s + 4*inco_m*psc_m)/6
                                     : (inco_c*psc_c + inco_s*psc_s + inco_s2*psc_s2 + 9*inco_m*psc_m)/12;
                            }
                        }

<span class="comment">// Ponderation par coefficient alpha</span>
                      flux*=alpha;

                      <span class="keywordflow">if</span> (ncomp_ch_transporte == 1)
                        {
                          resu(num10) -= flux;
                          resu(num20) += flux;
                          <span class="keywordflow">if</span> (num10&lt;nb_faces_bord) flux_b(num10,0) += flux;
                          <span class="keywordflow">if</span> (num20&lt;nb_faces_bord) flux_b(num20,0) -= flux;
                        }
                      <span class="keywordflow">else</span>
                        {
                          resu(num10,comp0) -= flux;
                          resu(num20,comp0) += flux;
                          <span class="keywordflow">if</span> (num10&lt;nb_faces_bord) flux_b(num10,comp0) += flux;
                          <span class="keywordflow">if</span> (num20&lt;nb_faces_bord) flux_b(num20,comp0) -= flux;
                        }

                    }<span class="comment">//!&lt; boucle sur comp</span>
<span class="comment"></span>                } <span class="comment">//!&lt; fin de la boucle sur les facettes</span>
<span class="comment"></span>            }
        } <span class="comment">//!&lt; fin de la boucle</span>
<span class="comment"></span>      alpha = 1 - alpha;
    } <span class="comment">//!&lt; fin de la boucle statistiques().end_count(m2); statistiques().begin_count(m3);</span>
<span class="comment"></span><span class="comment">//</span>
<span class="comment">//</span>
  <span class="keywordtype">int</span> voisine;
  nb_faces_perio = 0;
  <span class="keywordtype">double</span> diff1,diff2;

<span class="comment">// Boucle sur les bords pour traiter les conditions aux limites</span>
<span class="comment">// il y a prise en compte d&#39;un terme de convection pour les</span>
<span class="comment">// conditions aux limites de Neumann_sortie_libre seulement</span>
  <span class="keywordflow">for</span> (n_bord=0; n_bord&lt;nb_bord; n_bord++)
    {
      <span class="keyword">const</span> <a class="code" href="classCond__lim.html" title="classe Cond_lim Classe generique servant a representer n&#39;importe quelle classe derivee de la classe C...">Cond_lim</a>&amp; la_cl = zone_Cl_VEF.<a class="code" href="classZone__Cl__dis__base.html#af75e0ed7786863e4d333bfb29d67c323" title="Renvoie la i-ieme condition aux limites. (version const)">les_conditions_limites</a>(n_bord);

      <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classNeumann__sortie__libre.html" title="classe Neumann_sortie_libre Cette classe represente une frontiere ouverte sans vitesse imposee Pour l...">Neumann_sortie_libre</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>()))
        {
          <span class="keyword">const</span> <a class="code" href="classNeumann__sortie__libre.html" title="classe Neumann_sortie_libre Cette classe represente une frontiere ouverte sans vitesse imposee Pour l...">Neumann_sortie_libre</a>&amp; la_sortie_libre = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classNeumann__sortie__libre.html" title="classe Neumann_sortie_libre Cette classe represente une frontiere ouverte sans vitesse imposee Pour l...">Neumann_sortie_libre</a>, la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>());
          <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp; le_bord = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>,la_cl.<a class="code" href="classCond__lim.html#a5b2d24809cee07727006a891d4ce8d22" title="Appel a l&#39;objet sous-jacent Renvoie la frontiere discretisee associee a la condition aux limites...">frontiere_dis</a>());
          <span class="keywordtype">int</span> num1 = le_bord.num_premiere_face();
          <span class="keywordtype">int</span> num2 = num1 + le_bord.nb_faces();
          <span class="keywordflow">for</span> (num_face=num1; num_face&lt;num2; num_face++)
            {
              psc =0;
              <span class="keywordflow">for</span> (i=0; i&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; i++)
                psc += vitesse_face(num_face,i)*facenormales(num_face,i);
              <span class="keywordflow">if</span> (psc&gt;0)
                <span class="keywordflow">if</span> (ncomp_ch_transporte == 1)
                  {
                    resu(num_face) -= psc*transporte_face(num_face);
                    flux_b(num_face,0) = -psc*transporte_face(num_face);
                  }
                <span class="keywordflow">else</span>
                  <span class="keywordflow">for</span> (i=0; i&lt;ncomp_ch_transporte; i++)
                    {
                      resu(num_face,i) -= psc*transporte_face(num_face,i);
                      flux_b(num_face,i) = -psc*transporte_face(num_face,i);
                    }
              <span class="keywordflow">else</span>
                {
                  <span class="keywordflow">if</span> (ncomp_ch_transporte == 1)
                    {
                      resu(num_face) -= psc*la_sortie_libre.<a class="code" href="classNeumann__sortie__libre.html#a886f1804fa2a9028fc56a0778a72a75d" title="Renvoie la valeur de la i-eme composante du champ impose a l&#39;exterieur de la frontiere.">val_ext</a>(num_face-num1);
                      flux_b(num_face,0) = -psc*la_sortie_libre.<a class="code" href="classNeumann__sortie__libre.html#a886f1804fa2a9028fc56a0778a72a75d" title="Renvoie la valeur de la i-eme composante du champ impose a l&#39;exterieur de la frontiere.">val_ext</a>(num_face-num1);
                    }
                  <span class="keywordflow">else</span>
                    <span class="keywordflow">for</span> (i=0; i&lt;ncomp_ch_transporte; i++)
                      {
                        resu(num_face,i) -= psc*la_sortie_libre.<a class="code" href="classNeumann__sortie__libre.html#a886f1804fa2a9028fc56a0778a72a75d" title="Renvoie la valeur de la i-eme composante du champ impose a l&#39;exterieur de la frontiere.">val_ext</a>(num_face-num1,i);
                        flux_b(num_face,i) = -psc*la_sortie_libre.<a class="code" href="classNeumann__sortie__libre.html#a886f1804fa2a9028fc56a0778a72a75d" title="Renvoie la valeur de la i-eme composante du champ impose a l&#39;exterieur de la frontiere.">val_ext</a>(num_face-num1,i);
                      }
                }
            }
        }
      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>()))
        {
          <span class="keyword">const</span> <a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>&amp; la_cl_perio = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>, la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>());
          <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp; le_bord = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>,la_cl.<a class="code" href="classCond__lim.html#a5b2d24809cee07727006a891d4ce8d22" title="Appel a l&#39;objet sous-jacent Renvoie la frontiere discretisee associee a la condition aux limites...">frontiere_dis</a>());
          <span class="keywordtype">int</span> num1 = le_bord.num_premiere_face();
          <span class="keywordtype">int</span> num2 = num1 + le_bord.nb_faces();
          <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> fait(le_bord.nb_faces());
          fait = 0;
          <span class="keywordflow">for</span> (num_face=num1; num_face&lt;num2; num_face++)
            {
              <span class="keywordflow">if</span> (fait[num_face-num1] == 0)
                {
                  voisine = la_cl_perio.<a class="code" href="classPeriodique.html#a207b86556f199a63ea059b841851ca6a">face_associee</a>(num_face-num1) + num1;

                  <span class="keywordflow">if</span> (ncomp_ch_transporte == 1)
                    {
                      diff1 = resu(num_face)-tab(nb_faces_perio);
                      diff2 = resu(voisine)-tab(nb_faces_perio+voisine-num_face);
                      resu(voisine)  += diff1;
                      resu(num_face) += diff2;
                      <span class="comment">/* On ne doit pas ajouter a flux_b, c&#39;est deja calcule au dessus</span>
<span class="comment">                         flux_b(voisine,0) += diff1;</span>
<span class="comment">                         flux_b(num_face,0) += diff2;*/</span>
                    }
                  <span class="keywordflow">else</span>
                    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> comp=0; comp&lt;ncomp_ch_transporte; comp++)
                      {
                        diff1 = resu(num_face,comp)-tab(nb_faces_perio,comp);
                        diff2 = resu(voisine,comp)-tab(nb_faces_perio+voisine-num_face,comp);
                        resu(voisine,comp)  += diff1;
                        resu(num_face,comp) += diff2;
                        <span class="comment">/* On ne doit pas ajouter a flux_b, c&#39;est deja calcule au dessus</span>
<span class="comment">                           flux_b(voisine,comp) += diff1;</span>
<span class="comment">                           flux_b(num_face,comp) += diff2; */</span>
                      }

                  fait[num_face-num1]= 1;
                  fait[voisine-num1] = 1;
                }
              nb_faces_perio++;
            }
        }
    }

  <a class="code" href="classOp__VEF__Face.html#a6c8ce571769b4f2e20b07cbb7a6944f2">modifier_flux</a>(*<span class="keyword">this</span>);
<span class="comment">// statistiques().end_count(m3);</span>
  <span class="keywordflow">return</span> resu;
}
</pre></div>
</div>
</div>
<a class="anchor" id="ad46bfa5e97653f57e64fb7f890d15e1b"></a><!-- doxytag: member="Op_Conv_VEF_Face::ajouter_contribution" ref="ad46bfa5e97653f57e64fb7f890d15e1b" args="(const DoubleTab &amp;, Matrice_Morse &amp;) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Op_Conv_VEF_Face::ajouter_contribution </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>transporte</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;&#160;</td>
          <td class="paramname"><em>matrice</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented in <a class="el" href="classOp__Conv__EF__VEF__P1NC__Stab.html#a25b8ce54605b7783a8d7078a932e4187">Op_Conv_EF_VEF_P1NC_Stab</a>, and <a class="el" href="classOp__Conv__Muscl__New__VEF__Face.html#abac773d46607384fdecf846d33a9c3c5">Op_Conv_Muscl_New_VEF_Face</a>.</p>

<p>Definition at line <a class="el" href="Op__Conv__VEF__Face_8cpp_source.html#l00798">798</a> of file <a class="el" href="Op__Conv__VEF__Face_8cpp_source.html">Op_Conv_VEF_Face.cpp</a>.</p>

<p>References <a class="el" href="classElem__VEF__base.html#a02b712675ec9d8bbb6571ddbbec33417">Elem_VEF_base::calcul_vc()</a>, <a class="el" href="Champ__P1iP1B__implementation_8cpp_source.html#l00331">coeff</a>, <a class="el" href="Op__Conv__VEF__Face_8cpp_source.html#l00766">convbisimplicite_dec()</a>, <a class="el" href="Objet__U_8h_source.html#l00079">Objet_U::dimension</a>, <a class="el" href="DoubleTab_8h_source.html#l00243">DoubleTab::dimension()</a>, <a class="el" href="Zone__VF_8h_source.html#l00574">Zone_VF::elem_faces()</a>, <a class="el" href="MorEqn_8h_source.html#l00082">MorEqn::equation()</a>, <a class="el" href="Zone__VEF_8h_source.html#l00145">Zone_VEF::face_normales()</a>, <a class="el" href="Zone__VEF_8h_source.html#l00152">Zone_VEF::facette_normales()</a>, <a class="el" href="Cond__lim_8h_source.html#l00130">Cond_lim::frontiere_dis()</a>, <a class="el" href="Matrice__Morse_8h_source.html#l00129">Matrice_Morse::get_set_coeff()</a>, <a class="el" href="Elem__VEF__base_8h_source.html#l00047">Elem_VEF_base::KEL()</a>, <a class="el" href="Op__Conv__VEF__base_8h_source.html#l00093">Op_Conv_VEF_base::la_zcl_vef</a>, <a class="el" href="Op__Conv__VEF__base_8h_source.html#l00092">Op_Conv_VEF_base::la_zone_vef</a>, <a class="el" href="Zone__Cl__dis__base_8cpp_source.html#l00522">Zone_Cl_dis_base::les_conditions_limites()</a>, <a class="el" href="Zone_8h_source.html#l00402">Zone::les_elems()</a>, <a class="el" href="Porosites__champ_8cpp_source.html#l00035">modif_par_porosite_si_flag()</a>, <a class="el" href="Op__VEF__Face_8cpp_source.html#l00792">Op_VEF_Face::modifier_matrice_pour_periodique_apres_contribuer()</a>, <a class="el" href="Op__VEF__Face_8cpp_source.html#l00780">Op_VEF_Face::modifier_matrice_pour_periodique_avant_contribuer()</a>, <a class="el" href="DoubleTab_8h_source.html#l00264">DoubleTab::nb_dim()</a>, <a class="el" href="Zone__dis__base_8h_source.html#l00144">Zone_dis_base::nb_elem_tot()</a>, <a class="el" href="Front__VF_8h_source.html#l00061">Front_VF::nb_faces()</a>, <a class="el" href="Zone_8h_source.html#l00469">Zone::nb_faces_elem()</a>, <a class="el" href="Elem__VEF_8h_source.html#l00083">Elem_VEF::nb_facette()</a>, <a class="el" href="Zone__dis__base_8h_source.html#l00156">Zone_dis_base::nb_front_Cl()</a>, <a class="el" href="Zone_8h_source.html#l00445">Zone::nb_som_elem()</a>, <a class="el" href="Zone__Cl__VEF_8h_source.html#l00130">Zone_Cl_VEF::normales_facettes_Cl()</a>, <a class="el" href="Front__VF_8h_source.html#l00071">Front_VF::num_premiere_face()</a>, <a class="el" href="Op__Conv__VEF__base_8cpp_source.html#l00053">Op_Conv_VEF_base::phi_u_transportant()</a>, <a class="el" href="Zone__VF_8h_source.html#l00315">Zone_VF::porosite_elem()</a>, <a class="el" href="Zone__VF_8h_source.html#l00285">Zone_VF::porosite_face()</a>, <a class="el" href="Objet__U_8cpp_source.html#l00132">Objet_U::que_suis_je()</a>, <a class="el" href="Zone__VEF_8h_source.html#l00165">Zone_VEF::rang_elem_non_std()</a>, <a class="el" href="Cast_8h_source.html#l00059">ref_cast</a>, <a class="el" href="Cast_8h_source.html#l00054">sub_type</a>, <a class="el" href="Zone__VEF_8h_source.html#l00138">Zone_VEF::type_elem()</a>, <a class="el" href="Raffiner__Simplexes_8cpp_source.html#l00183">type_elem()</a>, <a class="el" href="Zone__Cl__VEF_8h_source.html#l00167">Zone_Cl_VEF::type_elem_Cl()</a>, <a class="el" href="Cond__lim_8h_source.html#l00031">Deriv_Cond_lim_base::valeur()</a>, <a class="el" href="Elem__VEF_8h_source.html#l00041">Deriv_Elem_VEF_base::valeur()</a>, <a class="el" href="Ref__Zone__VEF_8h_source.html#l00028">Ref_Zone_VEF::valeur()</a>, <a class="el" href="Ref__Zone__Cl__VEF_8h_source.html#l00028">Ref_Zone_Cl_VEF::valeur()</a>, <a class="el" href="Champ__base_8cpp_source.html#l00412">Champ_base::valeur_a_sommet_compo()</a>, <a class="el" href="Champ__Inc__base_8cpp_source.html#l00221">Champ_Inc_base::valeurs()</a>, <a class="el" href="Op__Conv__VEF__base_8h_source.html#l00069">Op_Conv_VEF_base::vitesse()</a>, and <a class="el" href="Zone__dis__base_8h_source.html#l00106">Zone_dis_base::zone()</a>.</p>

<p>Referenced by <a class="el" href="Op__Conv__VEF__Face_8h_source.html#l00103">contribuer_a_avec()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <a class="code" href="classOp__VEF__Face.html#ab66c49a837d41ba7e304a0efc484a5d5" title="divise les coefficients sur les ligne des faces periodiques par 2 en prevision de l&#39;application modif...">modifier_matrice_pour_periodique_avant_contribuer</a>(matrice,<a class="code" href="classMorEqn.html#a615dd9abff96edcb625fa0424a489864" title="Renvoie la reference sur l&#39;equation pointe par MorEqn::mon_equation. (version const)">equation</a>());
  <span class="keyword">const</span> <a class="code" href="classZone__Cl__VEF.html">Zone_Cl_VEF</a>&amp; zone_Cl_VEF = <a class="code" href="classOp__Conv__VEF__base.html#a03f677ee7911706a4f85cd37e0ca4535">la_zcl_vef</a>.<a class="code" href="classRef__Zone__Cl__VEF.html#a0970d7253def65ad4f0c5ce1830fd243">valeur</a>();
  <span class="keyword">const</span> <a class="code" href="classZone__VEF.html" title="class Zone_VEF Classe instanciable qui derive de Zone_VF. Cette classe contient les informations geom...">Zone_VEF</a>&amp; zone_VEF = <a class="code" href="classOp__Conv__VEF__base.html#a6c29a488a6805ba4a9f2f059cdba77ae">la_zone_vef</a>.<a class="code" href="classRef__Zone__VEF.html#aafd9a5ee1a76f290c9c6b5447b0c8d30">valeur</a>();
  <span class="keyword">const</span> <a class="code" href="classChamp__Inc__base.html" title="Classe Champ_Inc_base Classe de base des champs inconnues qui sont les champs calcules par une equati...">Champ_Inc_base</a>&amp; la_vitesse=<a class="code" href="classOp__Conv__VEF__base.html#a4872ffd7c638ecc415191d92d7f5f507">vitesse</a>();
  <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; vitesse_face_absolue=la_vitesse.<a class="code" href="classChamp__Inc__base.html#adb537f43f1649e103a8980314c7ed175" title="Renvoie le tableau des valeurs du champ au temps courant.">valeurs</a>();
  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; elem_faces = zone_VEF.<a class="code" href="classZone__VF.html#a067e462dcd3ab92b0f6d945b19e4eb37" title="renvoie le numero de le ieme face de la maille num_elem la facon dont ces faces sont numerotees est l...">elem_faces</a>();
  <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; face_normales = zone_VEF.<a class="code" href="classZone__VEF.html#a5742d75972e4846bf9fbb6ed5715053e">face_normales</a>();
  <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; facette_normales = zone_VEF.<a class="code" href="classZone__VEF.html#a581b1ca0e62c668c92f104351d19fda6">facette_normales</a>();
  <span class="keyword">const</span> <a class="code" href="classZone.html" title="classe Zone Une Zone est un maillage compose d&#39;un ensemble d&#39;elements geometriques de meme type...">Zone</a>&amp; zone = zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>();
  <span class="keyword">const</span> <a class="code" href="classElem__VEF.html">Elem_VEF</a>&amp; <a class="code" href="Raffiner__Simplexes_8cpp.html#a358dc168d8905bbafc12587204bc9fb8">type_elem</a> = zone_VEF.<a class="code" href="classZone__VEF.html#a46693c060b8096fb2595ca72192eea2a">type_elem</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> nfa7 = type_elem.<a class="code" href="classElem__VEF.html#a4a34777c0083b38dd34c8a400d5b4e90">nb_facette</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_elem_tot = zone_VEF.<a class="code" href="classZone__dis__base.html#a4d6aa445f152aa6dc54d66ea7a071147">nb_elem_tot</a>();
  <span class="keyword">const</span> <a class="code" href="classIntVect.html">IntVect</a>&amp; rang_elem_non_std = zone_VEF.<a class="code" href="classZone__VEF.html#a4b2171a85e5fc33663a3366acb713584">rang_elem_non_std</a>();


  <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; porosite_face = zone_VEF.<a class="code" href="classZone__VF.html#ad9d74d1d9da9f50ab26768dbbca7711b">porosite_face</a>();
  <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; porosite_elem = zone_VEF.<a class="code" href="classZone__VF.html#afd135a1b227731193b1a97b7ed525435">porosite_elem</a>();
  <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; normales_facettes_Cl = zone_Cl_VEF.<a class="code" href="classZone__Cl__VEF.html#a83c05e82370553470ed05f10932e0f3f">normales_facettes_Cl</a>();

  <span class="keywordtype">int</span> nfac = zone.<a class="code" href="classZone.html#a548fbc7518be2f122b1a5c9589a443c2" title="Renvoie le nombre de face de type i des elements geometriques constituants la zone. Ex: les objets de la classe Prisme ont 2 types de faces: triangle ou quadrangle.">nb_faces_elem</a>();
  <span class="keywordtype">int</span> nsom = zone.<a class="code" href="classZone.html#ae0b34a93b9ae8146df2d1884157afe9f" title="Renvoie le nombre de sommets des elements geometriques constituants la zone. Tous les elements de la ...">nb_som_elem</a>();
  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; sommet_elem = zone.<a class="code" href="classZone.html#ac115e8342be89afb882b7b61cc343267" title="Renvoie le tableau des sommets des elements.">les_elems</a>();

<span class="comment">// Pour le traitement de la convection on distingue les polyedres</span>
<span class="comment">// standard qui ne &quot;voient&quot; pas les conditions aux limites et les</span>
<span class="comment">// polyedres non standard qui ont au moins une face sur le bord.</span>
<span class="comment">// Un polyedre standard a n facettes sur lesquelles on applique le</span>
<span class="comment">// schema de convection.</span>
<span class="comment">// Pour un polyedre non standard qui porte des conditions aux limites</span>
<span class="comment">// de Dirichlet, une partie des facettes sont portees par les faces.</span>
<span class="comment">// En bref pour un polyedre le traitement de la convection depend</span>
<span class="comment">// du type (triangle, tetraedre ...) et du nombre de faces de Dirichlet.</span>

  <span class="keywordtype">double</span> psc;
  <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a> pscl=0;
  <span class="keywordtype">int</span> poly,face_adj,fa7,i,j,n_bord;
  <span class="keywordtype">int</span> num_face, rang ,itypcl;
  <span class="keywordtype">int</span> num10,num20,num_som;
  <span class="keywordtype">int</span> ncomp_ch_transporte;
  <span class="keywordflow">if</span> (transporte.<a class="code" href="classDoubleTab.html#ae6dda48778e7107e1beb723beef1f75b" title="Returns the number of dimensions of the array (&gt;= 1)">nb_dim</a>() == 1)
    ncomp_ch_transporte=1;
  <span class="keywordflow">else</span>
    ncomp_ch_transporte= transporte.<a class="code" href="classDoubleTab.html#ac3805e2637a3b880ba2d3e650c69dac4" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(1);


  <span class="keywordtype">int</span> marq=<a class="code" href="classOp__Conv__VEF__base.html#ad380b9b9ca1d70282b289838a604a4b0" title="definit si l&#39;on convecte psi avec phi*u ou avec u">phi_u_transportant</a>(<a class="code" href="classMorEqn.html#a615dd9abff96edcb625fa0424a489864" title="Renvoie la reference sur l&#39;equation pointe par MorEqn::mon_equation. (version const)">equation</a>());

  <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a> vitesse_face_;
<span class="comment">// soit on a transporte=phi*transporte_ et vitesse_face=vitesse_</span>
<span class="comment">// soit transporte=transporte_ et vitesse_face=phi*vitesse_</span>
<span class="comment">// cela depend si on transporte avec phi u ou avec u.</span>
  <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; vitesse_face=<a class="code" href="Porosites__champ_8cpp.html#a2340e7d73d0f9d34926d012fe1b1d884" title="renvoit le tableau res, res=org si flag=0, res= porosite*org sinon attention ne pas modifier res car ...">modif_par_porosite_si_flag</a>(vitesse_face_absolue,vitesse_face_,marq,porosite_face);
  <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> face(nfac);
  <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a> vs(<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>);
  <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a> vc(<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>);
  <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a> vsom(nsom,<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>);
  <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a> cc(<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>);
  <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; <a class="code" href="Champ__P1iP1B__implementation_8cpp.html#aa8c8f49390c3cf7c702d71a71bc977e3">coeff</a> = matrice.<a class="code" href="classMatrice__Morse.html#acd067e8514e5741f52b18a1d99746d11">get_set_coeff</a>();
  <span class="keyword">const</span> <a class="code" href="classElem__VEF__base.html">Elem_VEF_base</a>&amp; type_elemvef= zone_VEF.<a class="code" href="classZone__VEF.html#a46693c060b8096fb2595ca72192eea2a">type_elem</a>().<a class="code" href="classDeriv__Elem__VEF__base.html#a2886905d5071be902c77248b69ca0b7b">valeur</a>();
  <span class="keywordtype">int</span> istetra=0;
  <a class="code" href="classNom.html" title="class Nom Une chaine de caractere pour nommer les objets de TRUST">Nom</a> nom_elem=type_elemvef.<a class="code" href="classObjet__U.html#aa58e9a81c0ddc2c1149053b8f96698ac" title="renvoie la chaine identifiant la classe.">que_suis_je</a>();
  <span class="keywordflow">if</span> ((nom_elem==<span class="stringliteral">&quot;Tetra_VEF&quot;</span>)||(nom_elem==<span class="stringliteral">&quot;Tri_VEF&quot;</span>))
    istetra=1;


<span class="comment">// Les polyedres non standard sont ranges en 2 groupes dans la Zone_VEF:</span>
<span class="comment">// - polyedres bords et joints</span>
<span class="comment">// - polyedres bords et non joints</span>
<span class="comment">// On traite les polyedres en suivant l&#39;ordre dans lequel ils figurent</span>
<span class="comment">// dans la zone</span>

<span class="comment">// boucle sur les polys</span>
  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; KEL=zone_VEF.<a class="code" href="classZone__VEF.html#a46693c060b8096fb2595ca72192eea2a">type_elem</a>().<a class="code" href="classDeriv__Elem__VEF__base.html#a2886905d5071be902c77248b69ca0b7b">valeur</a>().<a class="code" href="classElem__VEF__base.html#ab129610ef702aa8c9c98dcb4c7551172">KEL</a>();
  <span class="keywordtype">int</span> phi_u_transportant_yes=<a class="code" href="classOp__Conv__VEF__base.html#ad380b9b9ca1d70282b289838a604a4b0" title="definit si l&#39;on convecte psi avec phi*u ou avec u">phi_u_transportant</a>(<a class="code" href="classMorEqn.html#a615dd9abff96edcb625fa0424a489864" title="Renvoie la reference sur l&#39;equation pointe par MorEqn::mon_equation. (version const)">equation</a>());
  <span class="keywordflow">for</span> (poly=0; poly&lt;nb_elem_tot; poly++)
    {

      rang = rang_elem_non_std(poly);
      <span class="keywordflow">if</span> (rang==-1)
        itypcl=0;
      <span class="keywordflow">else</span>
        itypcl=zone_Cl_VEF.<a class="code" href="classZone__Cl__VEF.html#a483bdab7690f844ed04e3defe04ec70a">type_elem_Cl</a>(rang);

<span class="comment">// calcul des numeros des faces du polyedre</span>
      <span class="keywordflow">for</span> (face_adj=0; face_adj&lt;nfac; face_adj++)
        face(face_adj)= elem_faces(poly,face_adj);

      <span class="keywordflow">for</span> (j=0; j&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; j++)
        {
          vs(j) = vitesse_face_absolue(face(0),j)*porosite_face(face(0));
          <span class="keywordflow">for</span> (i=1; i&lt;nfac; i++)
            vs(j)+= vitesse_face_absolue(face(i),j)*porosite_face(face(i));
        }
<span class="comment">// calcul de la vitesse aux sommets des polyedres</span>
<span class="comment">// On va utliser les fonctions de forme implementees dans la classe Champs_P1_impl ou Champs_Q1_impl</span>
      <span class="keywordflow">if</span> (istetra==1)
        {
          <span class="keywordflow">for</span> (i=0; i&lt;nsom; i++)
            <span class="keywordflow">for</span> (j=0; j&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; j++)
              vsom(i,j) = (vs(j) - dimension*vitesse_face_absolue(face(i),j)*porosite_face(face(i)));
        }
      <span class="keywordflow">else</span>
        {
<span class="comment">// pour que cela soit valide avec les hexa (c&#39;est + lent a calculer...)</span>
          <span class="keywordtype">int</span> ncomp;
          <span class="keywordflow">for</span> (j=0; j&lt;nsom; j++)
            {
              num_som = sommet_elem(poly,j);
              <span class="keywordflow">for</span> (ncomp=0; ncomp&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; ncomp++)
                vsom(j,ncomp) = la_vitesse.<a class="code" href="classChamp__base.html#ad78f84c898b6fca623a30a9ae665c269" title="renvoi la compo eme corrdonne des valeurs a l&#39;element le_poly au sommet sommet">valeur_a_sommet_compo</a>(num_som,poly,ncomp);
            }
        }


<span class="comment">// calcul de vc (a l&#39;intersection des 3 facettes) vc vs vsom proportionnelles a la prosite</span>
      type_elemvef.<a class="code" href="classElem__VEF__base.html#a02b712675ec9d8bbb6571ddbbec33417">calcul_vc</a>(face,vc,vs,vsom,<a class="code" href="classOp__Conv__VEF__base.html#a4872ffd7c638ecc415191d92d7f5f507">vitesse</a>(),itypcl,porosite_face);
      <span class="keywordflow">if</span> (marq==0)
        {
          <span class="keywordtype">double</span> porosite_poly=porosite_elem(poly);
          <span class="keywordflow">for</span> (i=0; i&lt;nsom; i++)
            <span class="keywordflow">for</span> (j=0; j&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; j++)
              vsom(i,j)/=porosite_poly;
          <span class="keywordflow">for</span> (j=0; j&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; j++)
            {
              vs(j)/= porosite_elem(poly);
              vc(j)/=porosite_elem(poly);
            }
        }
<span class="comment">// Boucle sur les facettes du polyedre non standard:</span>
      <span class="keywordflow">for</span> (fa7=0; fa7&lt;nfa7; fa7++)
        {
          num10 = face(KEL(0,fa7));
          num20 = face(KEL(1,fa7));
<span class="comment">// normales aux facettes</span>
          <span class="keywordflow">if</span> (rang==-1)
            {
              <span class="keywordflow">for</span> (i=0; i&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; i++)
                cc[i] = facette_normales(poly, fa7, i);
            }
          <span class="keywordflow">else</span>
            {
              <span class="keywordflow">for</span> (i=0; i&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; i++)
                cc[i] = normales_facettes_Cl(rang,fa7,i);
            }
<span class="comment">// On applique le schema de convection a chaque sommet de la facette</span>


          <span class="keywordtype">double</span> psc_c=0,psc_s=0,psc_m,psc_s2=0;
          <span class="keywordflow">if</span> (dimension==2)
            {
              <span class="keywordflow">for</span> (i=0; i&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; i++)
                {
                  psc_c+=vc[i]*cc[i];
                  psc_s+=vsom(KEL(2,fa7),i)*cc[i];
                }
              psc_m=(psc_c+psc_s)/2.;
            }
          <span class="keywordflow">else</span>
            {
              <span class="keywordflow">for</span> (i=0; i&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; i++)
                {
                  psc_c+=vc[i]*cc[i];
                  psc_s+=vsom(KEL(2,fa7),i)*cc[i];
                  psc_s2+=vsom(KEL(3,fa7),i)*cc[i];
                }
              psc_m=(psc_c+psc_s+psc_s2)/3.;
            }
          <a class="code" href="Op__Conv__VEF__Face_8cpp.html#a59458e475a218a4b9bc7832d508dcf0b">convbisimplicite_dec</a>(psc_m,num10,num20,transporte,ncomp_ch_transporte,coeff,matrice,porosite_face,phi_u_transportant_yes);
        } <span class="comment">//!&lt; fin de boucle sur les facettes.</span>
<span class="comment"></span>
    } <span class="comment">//!&lt; fin de boucle sur les polyedres.</span>
<span class="comment"></span>
<span class="comment">// Boucle sur les bords pour traiter les conditions aux limites</span>
<span class="comment">// il y a prise en compte d&#39;un terme de convection pour les</span>
<span class="comment">// conditions aux limites de Neumann_sortie_libre seulement</span>
  <span class="keywordtype">int</span> nb_bord = zone_VEF.<a class="code" href="classZone__dis__base.html#af22167d614644f55591a29c77eb1c009">nb_front_Cl</a>();
  <span class="keywordflow">for</span> (n_bord=0; n_bord&lt;nb_bord; n_bord++)
    {

      <span class="keyword">const</span> <a class="code" href="classCond__lim.html" title="classe Cond_lim Classe generique servant a representer n&#39;importe quelle classe derivee de la classe C...">Cond_lim</a>&amp; la_cl = zone_Cl_VEF.<a class="code" href="classZone__Cl__dis__base.html#af75e0ed7786863e4d333bfb29d67c323" title="Renvoie la i-ieme condition aux limites. (version const)">les_conditions_limites</a>(n_bord);

      <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classNeumann__sortie__libre.html" title="classe Neumann_sortie_libre Cette classe represente une frontiere ouverte sans vitesse imposee Pour l...">Neumann_sortie_libre</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>()))
        {
          <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp; le_bord = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>,la_cl.<a class="code" href="classCond__lim.html#a5b2d24809cee07727006a891d4ce8d22" title="Appel a l&#39;objet sous-jacent Renvoie la frontiere discretisee associee a la condition aux limites...">frontiere_dis</a>());
          <span class="keywordtype">int</span> num1 = le_bord.<a class="code" href="classFront__VF.html#a4986f0c65653fe9eb40bbbff5a97bf16" title="Numero de la premiere face du bord dans la liste des faces.">num_premiere_face</a>();
          <span class="keywordtype">int</span> num2 = num1 + le_bord.<a class="code" href="classFront__VF.html#a341e2fcb5117b96e745fd7078ba86bab" title="Nombre de faces reelles du bord.">nb_faces</a>();
          <span class="keywordflow">for</span> (num_face=num1; num_face&lt;num2; num_face++)
            {
              psc =0;
              <span class="keywordflow">for</span> (i=0; i&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; i++)
                psc += vitesse_face(num_face,i)*face_normales(num_face,i);
              <span class="keywordflow">if</span> (!phi_u_transportant_yes)
                psc*=porosite_face(num_face);
              <span class="keywordflow">if</span> (psc&gt;0)
                {
                  <span class="keywordflow">for</span> (j=0; j&lt;ncomp_ch_transporte; j++)
                    {
                      <span class="keywordtype">int</span> n0=num_face*ncomp_ch_transporte+j;
                      matrice(n0,n0)+=psc;
                    }
                }
            }
        }
    }
  <a class="code" href="classOp__VEF__Face.html#a00a9703ef92c279f100fa3872cc8ec09" title="Somme les 2 lignes des faces periodiques associees permet de calculer dans le code sans se poser de q...">modifier_matrice_pour_periodique_apres_contribuer</a>(matrice,<a class="code" href="classMorEqn.html#a615dd9abff96edcb625fa0424a489864" title="Renvoie la reference sur l&#39;equation pointe par MorEqn::mon_equation. (version const)">equation</a>());
}
</pre></div>
</div>
</div>
<a class="anchor" id="a1ba01f3a164ec599e2eb12fea246fac7"></a><!-- doxytag: member="Op_Conv_VEF_Face::contribue_au_second_membre" ref="a1ba01f3a164ec599e2eb12fea246fac7" args="(DoubleTab &amp;) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Op_Conv_VEF_Face::contribue_au_second_membre </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>resu</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Op__Conv__VEF__Face_8cpp_source.html#l01007">1007</a> of file <a class="el" href="Op__Conv__VEF__Face_8cpp_source.html">Op_Conv_VEF_Face.cpp</a>.</p>

<p>References <a class="el" href="Objet__U_8h_source.html#l00079">Objet_U::dimension</a>, <a class="el" href="DoubleTab_8h_source.html#l00243">DoubleTab::dimension()</a>, <a class="el" href="Periodique_8h_source.html#l00056">Periodique::face_associee()</a>, <a class="el" href="Zone__VEF_8h_source.html#l00145">Zone_VEF::face_normales()</a>, <a class="el" href="Cond__lim_8h_source.html#l00130">Cond_lim::frontiere_dis()</a>, <a class="el" href="Op__Conv__VEF__base_8h_source.html#l00093">Op_Conv_VEF_base::la_zcl_vef</a>, <a class="el" href="Op__Conv__VEF__base_8h_source.html#l00092">Op_Conv_VEF_base::la_zone_vef</a>, <a class="el" href="Zone__Cl__dis__base_8cpp_source.html#l00522">Zone_Cl_dis_base::les_conditions_limites()</a>, <a class="el" href="DoubleTab_8h_source.html#l00264">DoubleTab::nb_dim()</a>, <a class="el" href="Front__VF_8h_source.html#l00061">Front_VF::nb_faces()</a>, <a class="el" href="Zone_8h_source.html#l00469">Zone::nb_faces_elem()</a>, <a class="el" href="Zone__dis__base_8h_source.html#l00156">Zone_dis_base::nb_front_Cl()</a>, <a class="el" href="Front__VF_8h_source.html#l00071">Front_VF::num_premiere_face()</a>, <a class="el" href="Cast_8h_source.html#l00059">ref_cast</a>, <a class="el" href="DoubleTab_8cpp_source.html#l00335">DoubleTab::resize()</a>, <a class="el" href="Cast_8h_source.html#l00054">sub_type</a>, <a class="el" href="Neumann__sortie__libre_8cpp_source.html#l00138">Neumann_sortie_libre::val_ext()</a>, <a class="el" href="Cond__lim_8h_source.html#l00031">Deriv_Cond_lim_base::valeur()</a>, <a class="el" href="Ref__Zone__VEF_8h_source.html#l00028">Ref_Zone_VEF::valeur()</a>, <a class="el" href="Ref__Zone__Cl__VEF_8h_source.html#l00028">Ref_Zone_Cl_VEF::valeur()</a>, <a class="el" href="Op__Conv__VEF__base_8h_source.html#l00069">Op_Conv_VEF_base::vitesse()</a>, and <a class="el" href="Zone__dis__base_8h_source.html#l00106">Zone_dis_base::zone()</a>.</p>

<p>Referenced by <a class="el" href="Op__Conv__VEF__Face_8h_source.html#l00112">contribuer_au_second_membre()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">const</span> <a class="code" href="classZone__Cl__VEF.html">Zone_Cl_VEF</a>&amp; zone_Cl_VEF = <a class="code" href="classOp__Conv__VEF__base.html#a03f677ee7911706a4f85cd37e0ca4535">la_zcl_vef</a>.<a class="code" href="classRef__Zone__Cl__VEF.html#a0970d7253def65ad4f0c5ce1830fd243">valeur</a>();
  <span class="keyword">const</span> <a class="code" href="classZone__VEF.html" title="class Zone_VEF Classe instanciable qui derive de Zone_VF. Cette classe contient les informations geom...">Zone_VEF</a>&amp; zone_VEF = <a class="code" href="classOp__Conv__VEF__base.html#a6c29a488a6805ba4a9f2f059cdba77ae">la_zone_vef</a>.<a class="code" href="classRef__Zone__VEF.html#aafd9a5ee1a76f290c9c6b5447b0c8d30">valeur</a>();
  <span class="keyword">const</span> <a class="code" href="classChamp__Inc__base.html" title="Classe Champ_Inc_base Classe de base des champs inconnues qui sont les champs calcules par une equati...">Champ_Inc_base</a>&amp; la_vitesse=<a class="code" href="classOp__Conv__VEF__base.html#a4872ffd7c638ecc415191d92d7f5f507">vitesse</a>();
  <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; face_normales = zone_VEF.<a class="code" href="classZone__VEF.html#a5742d75972e4846bf9fbb6ed5715053e">face_normales</a>();
  <span class="keyword">const</span> <a class="code" href="classZone.html" title="classe Zone Une Zone est un maillage compose d&#39;un ensemble d&#39;elements geometriques de meme type...">Zone</a>&amp; zone = zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>();
  <span class="keywordtype">int</span> nfac = zone.<a class="code" href="classZone.html#a548fbc7518be2f122b1a5c9589a443c2" title="Renvoie le nombre de face de type i des elements geometriques constituants la zone. Ex: les objets de la classe Prisme ont 2 types de faces: triangle ou quadrangle.">nb_faces_elem</a>();

  <span class="keywordtype">double</span> psc;
  <span class="keywordtype">int</span> i,n_bord;
  <span class="keywordtype">int</span> num_face;
  <span class="keywordtype">int</span> ncomp;
  <span class="keywordflow">if</span> (resu.<a class="code" href="classDoubleTab.html#ae6dda48778e7107e1beb723beef1f75b" title="Returns the number of dimensions of the array (&gt;= 1)">nb_dim</a>() == 1)
    ncomp=1;
  <span class="keywordflow">else</span>
    ncomp= resu.<a class="code" href="classDoubleTab.html#ac3805e2637a3b880ba2d3e650c69dac4" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(1);

  <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> face(nfac);


<span class="comment">// Traitement particulier pour les faces de periodicite</span>

  <span class="keywordtype">int</span> nb_faces_perio = 0;
  <span class="keywordtype">int</span> voisine;
  <span class="keywordtype">double</span> diff1,diff2;

<span class="comment">// Boucle pour compter le nombre de faces de periodicite</span>
  <span class="keywordflow">for</span> (n_bord=0; n_bord&lt;zone_VEF.<a class="code" href="classZone__dis__base.html#af22167d614644f55591a29c77eb1c009">nb_front_Cl</a>(); n_bord++)
    {
      <span class="keyword">const</span> <a class="code" href="classCond__lim.html" title="classe Cond_lim Classe generique servant a representer n&#39;importe quelle classe derivee de la classe C...">Cond_lim</a>&amp; la_cl = zone_Cl_VEF.<a class="code" href="classZone__Cl__dis__base.html#af75e0ed7786863e4d333bfb29d67c323" title="Renvoie la i-ieme condition aux limites. (version const)">les_conditions_limites</a>(n_bord);
      <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>()))
        {
          <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp; le_bord = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>,la_cl.<a class="code" href="classCond__lim.html#a5b2d24809cee07727006a891d4ce8d22" title="Appel a l&#39;objet sous-jacent Renvoie la frontiere discretisee associee a la condition aux limites...">frontiere_dis</a>());
          nb_faces_perio += le_bord.<a class="code" href="classFront__VF.html#a341e2fcb5117b96e745fd7078ba86bab" title="Nombre de faces reelles du bord.">nb_faces</a>();
        }
    }

  <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a> tab;
  <span class="keywordflow">if</span> (ncomp == 1)
    tab.<a class="code" href="classDoubleTab.html#ae83b4d31205c53d9c8d2b43da178ce75" title="Change la taille du vecteur (identique a resize_array() pour le traitement des anciennes valeurs et d...">resize</a>(nb_faces_perio);
  <span class="keywordflow">else</span>
    tab.<a class="code" href="classDoubleTab.html#ae83b4d31205c53d9c8d2b43da178ce75" title="Change la taille du vecteur (identique a resize_array() pour le traitement des anciennes valeurs et d...">resize</a>(nb_faces_perio,ncomp);

<span class="comment">// Boucle pour remplir tab</span>
  nb_faces_perio=0;
  <span class="keywordflow">for</span> (n_bord=0; n_bord&lt;zone_VEF.<a class="code" href="classZone__dis__base.html#af22167d614644f55591a29c77eb1c009">nb_front_Cl</a>(); n_bord++)
    {
      <span class="keyword">const</span> <a class="code" href="classCond__lim.html" title="classe Cond_lim Classe generique servant a representer n&#39;importe quelle classe derivee de la classe C...">Cond_lim</a>&amp; la_cl = zone_Cl_VEF.<a class="code" href="classZone__Cl__dis__base.html#af75e0ed7786863e4d333bfb29d67c323" title="Renvoie la i-ieme condition aux limites. (version const)">les_conditions_limites</a>(n_bord);
      <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>()))
        {
          <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp; le_bord = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>,la_cl.<a class="code" href="classCond__lim.html#a5b2d24809cee07727006a891d4ce8d22" title="Appel a l&#39;objet sous-jacent Renvoie la frontiere discretisee associee a la condition aux limites...">frontiere_dis</a>());
          <span class="keywordtype">int</span> num1 = le_bord.<a class="code" href="classFront__VF.html#a4986f0c65653fe9eb40bbbff5a97bf16" title="Numero de la premiere face du bord dans la liste des faces.">num_premiere_face</a>();
          <span class="keywordtype">int</span> num2 = num1 + le_bord.<a class="code" href="classFront__VF.html#a341e2fcb5117b96e745fd7078ba86bab" title="Nombre de faces reelles du bord.">nb_faces</a>();
          <span class="keywordflow">for</span> (num_face=num1; num_face&lt;num2; num_face++)
            {
              <span class="keywordflow">if</span> (ncomp == 1)
                tab(nb_faces_perio) = resu(num_face);
              <span class="keywordflow">else</span>
                <span class="keywordflow">for</span> (<span class="keywordtype">int</span> comp=0; comp&lt;ncomp; comp++)
                  tab(nb_faces_perio,comp) = resu(num_face,comp);
              nb_faces_perio++;
            }
        }
    }
<span class="comment">// Boucle sur les bords pour traiter les conditions aux limites</span>
<span class="comment">// il y a prise en compte d&#39;un terme de convection pour les</span>
<span class="comment">// conditions aux limites de Neumann_sortie_libre seulement</span>
  nb_faces_perio=0;
  <span class="keywordflow">for</span> (n_bord=0; n_bord&lt;zone_VEF.<a class="code" href="classZone__dis__base.html#af22167d614644f55591a29c77eb1c009">nb_front_Cl</a>(); n_bord++)
    {

      <span class="keyword">const</span> <a class="code" href="classCond__lim.html" title="classe Cond_lim Classe generique servant a representer n&#39;importe quelle classe derivee de la classe C...">Cond_lim</a>&amp; la_cl = zone_Cl_VEF.<a class="code" href="classZone__Cl__dis__base.html#af75e0ed7786863e4d333bfb29d67c323" title="Renvoie la i-ieme condition aux limites. (version const)">les_conditions_limites</a>(n_bord);

      <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classNeumann__sortie__libre.html" title="classe Neumann_sortie_libre Cette classe represente une frontiere ouverte sans vitesse imposee Pour l...">Neumann_sortie_libre</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>()))
        {
          <span class="keyword">const</span> <a class="code" href="classNeumann__sortie__libre.html" title="classe Neumann_sortie_libre Cette classe represente une frontiere ouverte sans vitesse imposee Pour l...">Neumann_sortie_libre</a>&amp; la_sortie_libre = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classNeumann__sortie__libre.html" title="classe Neumann_sortie_libre Cette classe represente une frontiere ouverte sans vitesse imposee Pour l...">Neumann_sortie_libre</a>, la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>());
          <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp; le_bord = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>,la_cl.<a class="code" href="classCond__lim.html#a5b2d24809cee07727006a891d4ce8d22" title="Appel a l&#39;objet sous-jacent Renvoie la frontiere discretisee associee a la condition aux limites...">frontiere_dis</a>());
          <span class="keywordtype">int</span> num1 = le_bord.num_premiere_face();
          <span class="keywordtype">int</span> num2 = num1 + le_bord.nb_faces();
          <span class="keywordflow">for</span> (num_face=num1; num_face&lt;num2; num_face++)
            {
              psc =0;
              <span class="keywordflow">for</span> (i=0; i&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; i++)
                psc += la_vitesse(num_face,i)*face_normales(num_face,i);
              <span class="keywordflow">if</span> (psc&gt;0)
                <span class="keywordflow">if</span> (ncomp == 1)
                  resu(num_face) += 0;
                <span class="keywordflow">else</span>
                  <span class="keywordflow">for</span> (i=0; i&lt;ncomp; i++)
                    resu(num_face,i) += 0;
              <span class="keywordflow">else</span>
                {
                  <span class="keywordflow">if</span> (ncomp == 1)
                    resu(num_face) -= psc*la_sortie_libre.<a class="code" href="classNeumann__sortie__libre.html#a886f1804fa2a9028fc56a0778a72a75d" title="Renvoie la valeur de la i-eme composante du champ impose a l&#39;exterieur de la frontiere.">val_ext</a>(num_face-num1);
                  <span class="keywordflow">else</span>
                    <span class="keywordflow">for</span> (i=0; i&lt;ncomp; i++)
                      resu(num_face,i) -= psc*la_sortie_libre.<a class="code" href="classNeumann__sortie__libre.html#a886f1804fa2a9028fc56a0778a72a75d" title="Renvoie la valeur de la i-eme composante du champ impose a l&#39;exterieur de la frontiere.">val_ext</a>(num_face-num1,i);
                }
            }
        }
      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>()))
        {
          <span class="keyword">const</span> <a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>&amp; la_cl_perio = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>, la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>());
          <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp; le_bord = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>,la_cl.<a class="code" href="classCond__lim.html#a5b2d24809cee07727006a891d4ce8d22" title="Appel a l&#39;objet sous-jacent Renvoie la frontiere discretisee associee a la condition aux limites...">frontiere_dis</a>());
          <span class="keywordtype">int</span> num1 = le_bord.num_premiere_face();
          <span class="keywordtype">int</span> num2 = num1 + le_bord.nb_faces();
          <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> fait(le_bord.nb_faces());
          fait = 0;
          <span class="keywordflow">for</span> (num_face=num1; num_face&lt;num2; num_face++)
            {
              <span class="keywordflow">if</span> (fait[num_face-num1] == 0)
                {
                  voisine = la_cl_perio.<a class="code" href="classPeriodique.html#a207b86556f199a63ea059b841851ca6a">face_associee</a>(num_face-num1) + num1;

                  <span class="keywordflow">if</span> (ncomp == 1)
                    {
                      diff1 = resu(num_face)-tab(nb_faces_perio);
                      diff2 = resu(voisine)-tab(nb_faces_perio+voisine-num_face);
                      resu(voisine)  += diff1;
                      resu(num_face) += diff2;
                    }
                  <span class="keywordflow">else</span>
                    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> comp=0; comp&lt;ncomp; comp++)
                      {
                        diff1 = resu(num_face,comp)-tab(nb_faces_perio,comp);
                        diff2 = resu(voisine,comp)-tab(nb_faces_perio+voisine-num_face,comp);
                        resu(voisine,comp)  += diff1;
                        resu(num_face,comp) += diff2;
                      }

                  fait[num_face-num1]= 1;
                  fait[voisine-num1] = 1;
                }
              nb_faces_perio++;
            }
        }
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a27f891883f7b38b525b59d38d3f97ef3"></a><!-- doxytag: member="Op_Conv_VEF_Face::contribuer_a_avec" ref="a27f891883f7b38b525b59d38d3f97ef3" args="(const DoubleTab &amp;, Matrice_Morse &amp;) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Op_Conv_VEF_Face::contribuer_a_avec </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>inco</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;&#160;</td>
          <td class="paramname"><em>matrice</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>on assemble la matrice des inconnues implicite. </p>

<p>Reimplemented from <a class="el" href="classOperateur__base.html#a903e728aad8e2d490580bf264319d65f">Operateur_base</a>.</p>

<p>Reimplemented in <a class="el" href="classOp__Conv__EF__VEF__P1NC__Stab.html#ae88c01c5bab6101cc73c18023db6f55b">Op_Conv_EF_VEF_P1NC_Stab</a>, and <a class="el" href="classOp__Conv__Muscl__New__VEF__Face.html#acb80c8643054dda4979c7b94d6f28bbf">Op_Conv_Muscl_New_VEF_Face</a>.</p>

<p>Definition at line <a class="el" href="Op__Conv__VEF__Face_8h_source.html#l00103">103</a> of file <a class="el" href="Op__Conv__VEF__Face_8h_source.html">Op_Conv_VEF_Face.h</a>.</p>

<p>References <a class="el" href="Op__Conv__VEF__Face_8cpp_source.html#l00798">ajouter_contribution()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <a class="code" href="classOp__Conv__VEF__Face.html#ad46bfa5e97653f57e64fb7f890d15e1b">ajouter_contribution</a>(inco, matrice);
}
</pre></div>
</div>
</div>
<a class="anchor" id="a175b6b231b04247e273074cee23474e7"></a><!-- doxytag: member="Op_Conv_VEF_Face::contribuer_au_second_membre" ref="a175b6b231b04247e273074cee23474e7" args="(DoubleTab &amp;) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Op_Conv_VEF_Face::contribuer_au_second_membre </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>resu</em></td><td>)</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>on ajoute la contribution du second membre. </p>

<p>Reimplemented from <a class="el" href="classOperateur__base.html#a1b64f0211a360c124a218be15c80d9c7">Operateur_base</a>.</p>

<p>Definition at line <a class="el" href="Op__Conv__VEF__Face_8h_source.html#l00112">112</a> of file <a class="el" href="Op__Conv__VEF__Face_8h_source.html">Op_Conv_VEF_Face.h</a>.</p>

<p>References <a class="el" href="Op__Conv__VEF__Face_8cpp_source.html#l01007">contribue_au_second_membre()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <a class="code" href="classOp__Conv__VEF__Face.html#a1ba01f3a164ec599e2eb12fea246fac7">contribue_au_second_membre</a>(resu);
}
</pre></div>
</div>
</div>
<a class="anchor" id="a95e421a79f78a63f6fc31001e480b801"></a><!-- doxytag: member="Op_Conv_VEF_Face::cree_instance" ref="a95e421a79f78a63f6fc31001e480b801" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classObjet__U.html">Objet_U</a> * Op_Conv_VEF_Face::cree_instance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented in <a class="el" href="classOp__Conv__Amont__VEF__Face.html#a45bf1daa251a1a271b62b995f7303a65">Op_Conv_Amont_VEF_Face</a>, <a class="el" href="classOp__Conv__Centre__VEF__Face.html#a77749f4d443f52c8073db731f1c1b0d8">Op_Conv_Centre_VEF_Face</a>, <a class="el" href="classOp__Conv__EF__VEF__P1NC__Stab.html#a0bc0e96870fa11143a92dcbeb2a36ec6">Op_Conv_EF_VEF_P1NC_Stab</a>, <a class="el" href="classOp__Conv__Muscl3__VEF__Face.html#a1d7fa685b179ed47aa10b83fb00fdaa3">Op_Conv_Muscl3_VEF_Face</a>, <a class="el" href="classOp__Conv__Muscl__New__VEF__Face.html#ad2aaff32ae487ec536e6fba1361558b6">Op_Conv_Muscl_New_VEF_Face</a>, and <a class="el" href="classOp__Conv__Muscl__VEF__Face.html#a0f54f4064bdd112d3dc9db6684573c17">Op_Conv_Muscl_VEF_Face</a>.</p>

<p>Definition at line <a class="el" href="Op__Conv__VEF__Face_8cpp_source.html#l00029">29</a> of file <a class="el" href="Op__Conv__VEF__Face_8cpp_source.html">Op_Conv_VEF_Face.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a968452c80df39cea3adbc3a89976785a"></a><!-- doxytag: member="Op_Conv_VEF_Face::dimensionner" ref="a968452c80df39cea3adbc3a89976785a" args="(Matrice_Morse &amp;) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Op_Conv_VEF_Face::dimensionner </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;&#160;</td>
          <td class="paramname"><em>matrice</em></td><td>)</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>on dimensionne notre matrice au moyen de la methode dimensionner de la classe<br/>
<a class="el" href="classOp__VEF__Face.html">Op_VEF_Face</a>. </p>

<p>Reimplemented from <a class="el" href="classOperateur__base.html#a66ef3c42e72d13fce0852ba92e56be6a">Operateur_base</a>.</p>

<p>Definition at line <a class="el" href="Op__Conv__VEF__Face_8h_source.html#l00084">84</a> of file <a class="el" href="Op__Conv__VEF__Face_8h_source.html">Op_Conv_VEF_Face.h</a>.</p>

<p>References <a class="el" href="Op__Conv__VEF__base_8h_source.html#l00093">Op_Conv_VEF_base::la_zcl_vef</a>, <a class="el" href="Op__Conv__VEF__base_8h_source.html#l00092">Op_Conv_VEF_base::la_zone_vef</a>, <a class="el" href="Ref__Zone__Cl__VEF_8h_source.html#l00028">Ref_Zone_Cl_VEF::valeur()</a>, and <a class="el" href="Ref__Zone__VEF_8h_source.html#l00028">Ref_Zone_VEF::valeur()</a>.</p>

<p>Referenced by <a class="el" href="Op__Conv__EF__VEF__P1NC__Stab_8cpp_source.html#l02838">Op_Conv_EF_VEF_P1NC_Stab::test_implicite()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <a class="code" href="classOp__Conv__VEF__Face.html#a968452c80df39cea3adbc3a89976785a" title="on dimensionne notre matrice au moyen de la methode dimensionner de la classe Op_VEF_Face.">Op_VEF_Face::dimensionner</a>(<a class="code" href="classOp__Conv__VEF__base.html#a6c29a488a6805ba4a9f2f059cdba77ae">la_zone_vef</a>.<a class="code" href="classRef__Zone__VEF.html#aafd9a5ee1a76f290c9c6b5447b0c8d30">valeur</a>(),<a class="code" href="classOp__Conv__VEF__base.html#a03f677ee7911706a4f85cd37e0ca4535">la_zcl_vef</a>.<a class="code" href="classRef__Zone__Cl__VEF.html#a0970d7253def65ad4f0c5ce1830fd243">valeur</a>(), matrice);
}
</pre></div>
</div>
</div>
<a class="anchor" id="a730ff7f720a85346c2e64d887d2e83a3"></a><!-- doxytag: member="Op_Conv_VEF_Face::duplique" ref="a730ff7f720a85346c2e64d887d2e83a3" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Op_Conv_VEF_Face::duplique </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implements <a class="el" href="classOp__Conv__VEF__base.html#aecf8ac3a5894aae03486baec6ffbdc92">Op_Conv_VEF_base</a>.</p>

<p>Reimplemented in <a class="el" href="classOp__Conv__Amont__VEF__Face.html#a3a5576599652265199f1fe86ca1eb750">Op_Conv_Amont_VEF_Face</a>, <a class="el" href="classOp__Conv__Centre__VEF__Face.html#a102fd1e97505af9716b74d51b53e2a83">Op_Conv_Centre_VEF_Face</a>, <a class="el" href="classOp__Conv__EF__VEF__P1NC__Stab.html#a1b807c5a31fa60c909ebe69e81a2adc4">Op_Conv_EF_VEF_P1NC_Stab</a>, <a class="el" href="classOp__Conv__Muscl3__VEF__Face.html#a4857fc7d6cc8fa22616a97f82b4137ca">Op_Conv_Muscl3_VEF_Face</a>, <a class="el" href="classOp__Conv__Muscl__New__VEF__Face.html#a8cb4fcb38968e497474dad4fdd1a9190">Op_Conv_Muscl_New_VEF_Face</a>, and <a class="el" href="classOp__Conv__Muscl__VEF__Face.html#a86174093bc522593c37cc98b0e89f7e5">Op_Conv_Muscl_VEF_Face</a>.</p>

<p>Definition at line <a class="el" href="Op__Conv__VEF__Face_8cpp_source.html#l00029">29</a> of file <a class="el" href="Op__Conv__VEF__Face_8cpp_source.html">Op_Conv_VEF_Face.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab2a0e04ea2fa8b2f9880d2e43ac49fc3"></a><!-- doxytag: member="Op_Conv_VEF_Face::get_alpha" ref="ab2a0e04ea2fa8b2f9880d2e43ac49fc3" args="(double &amp;) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Op_Conv_VEF_Face::get_alpha </td>
          <td>(</td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>alp</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Op__Conv__VEF__Face_8cpp_source.html#l01369">1369</a> of file <a class="el" href="Op__Conv__VEF__Face_8cpp_source.html">Op_Conv_VEF_Face.cpp</a>.</p>

<p>References <a class="el" href="Op__Conv__VEF__Face_8h_source.html#l00070">alpha_</a>.</p>
<div class="fragment"><pre class="fragment">{
  alp=<a class="code" href="classOp__Conv__VEF__Face.html#aebc1771cc4608fc51a8b6d15b93c8d3d">alpha_</a>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a7956413d25ad3f47537c18be89fa8a93"></a><!-- doxytag: member="Op_Conv_VEF_Face::get_info" ref="a7956413d25ad3f47537c18be89fa8a93" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classType__info.html">Type_info</a> * Op_Conv_VEF_Face::get_info </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Donne des informations sur le type de l'Objet_U. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>const Type_info*<br/>
 Signification: structure regroupant les informations sur le type de l'Objet_U<br/>
 Contraintes: </dd></dl>

<p>Reimplemented from <a class="el" href="classOp__Conv__VEF__base.html#a4f45e8d5bbed035668e5babaab9f29de">Op_Conv_VEF_base</a>.</p>

<p>Reimplemented in <a class="el" href="classOp__Conv__Amont__VEF__Face.html#a8a04134d7c03c7a9ca7be779ab2153e0">Op_Conv_Amont_VEF_Face</a>, <a class="el" href="classOp__Conv__Centre__VEF__Face.html#ab7be0c4f7570100ac498ea402570b9b5">Op_Conv_Centre_VEF_Face</a>, <a class="el" href="classOp__Conv__EF__VEF__P1NC__Stab.html#a1c79230221c8b7758076fa691e5b39c5">Op_Conv_EF_VEF_P1NC_Stab</a>, <a class="el" href="classOp__Conv__Muscl3__VEF__Face.html#ac5e08a7821460db008d983834abe3490">Op_Conv_Muscl3_VEF_Face</a>, <a class="el" href="classOp__Conv__Muscl__New__VEF__Face.html#a4bf8a3114c691efecfc752810cc524e0">Op_Conv_Muscl_New_VEF_Face</a>, and <a class="el" href="classOp__Conv__Muscl__VEF__Face.html#a3f8800e1a74959f05b1d4f47a1edabed">Op_Conv_Muscl_VEF_Face</a>.</p>

<p>Definition at line <a class="el" href="Op__Conv__VEF__Face_8cpp_source.html#l00029">29</a> of file <a class="el" href="Op__Conv__VEF__Face_8cpp_source.html">Op_Conv_VEF_Face.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a80256cc6352e925934a4d1233f7378ea"></a><!-- doxytag: member="Op_Conv_VEF_Face::get_ordre" ref="a80256cc6352e925934a4d1233f7378ea" args="(int &amp;) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Op_Conv_VEF_Face::get_ordre </td>
          <td>(</td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>ord</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Op__Conv__VEF__Face_8cpp_source.html#l01361">1361</a> of file <a class="el" href="Op__Conv__VEF__Face_8cpp_source.html">Op_Conv_VEF_Face.cpp</a>.</p>

<p>References <a class="el" href="Op__Conv__VEF__Face_8h_source.html#l00069">ordre</a>.</p>
<div class="fragment"><pre class="fragment">{
  ord=<a class="code" href="classOp__Conv__VEF__Face.html#ad30e1a556295f226b7ef1215dc0030e5">ordre</a>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a2e291bb90398522c5bbd1a08fb03f693"></a><!-- doxytag: member="Op_Conv_VEF_Face::get_type_lim" ref="a2e291bb90398522c5bbd1a08fb03f693" args="(Motcle &amp;) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Op_Conv_VEF_Face::get_type_lim </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMotcle.html">Motcle</a> &amp;&#160;</td>
          <td class="paramname"><em>typelim</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Op__Conv__VEF__Face_8cpp_source.html#l01365">1365</a> of file <a class="el" href="Op__Conv__VEF__Face_8cpp_source.html">Op_Conv_VEF_Face.cpp</a>.</p>

<p>References <a class="el" href="Op__Conv__VEF__Face_8h_source.html#l00067">type_lim</a>.</p>
<div class="fragment"><pre class="fragment">{
  typelim=<a class="code" href="classOp__Conv__VEF__Face.html#a070e3e30a22b79bd58ac3bd36f7802f6">type_lim</a>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a0c5603c7c6d4d7eba5897a472b607e32"></a><!-- doxytag: member="Op_Conv_VEF_Face::get_type_op" ref="a0c5603c7c6d4d7eba5897a472b607e32" args="(int &amp;) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Op_Conv_VEF_Face::get_type_op </td>
          <td>(</td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>typeop</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Op__Conv__VEF__Face_8cpp_source.html#l01374">1374</a> of file <a class="el" href="Op__Conv__VEF__Face_8cpp_source.html">Op_Conv_VEF_Face.cpp</a>.</p>

<p>References <a class="el" href="Op__Conv__VEF__Face_8h_source.html#l00072">type_op</a>.</p>
<div class="fragment"><pre class="fragment">{
  typeop=<a class="code" href="classOp__Conv__VEF__Face.html#aac6bde5c9421ce149a3f28a11709b1f6">type_op</a>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a96dd257161111f4a1bc7028456c16da4"></a><!-- doxytag: member="Op_Conv_VEF_Face::info" ref="a96dd257161111f4a1bc7028456c16da4" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classType__info.html">Type_info</a> * Op_Conv_VEF_Face::info </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Donne des informations sur le type de l'Objet_U. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>const Type_info*<br/>
 Signification: structure regroupant les informations sur le type de l'Objet_U<br/>
 Contraintes: </dd></dl>

<p>Reimplemented from <a class="el" href="classOp__Conv__VEF__base.html#a7fb4c40de2314e6119ba04a6cd2305ed">Op_Conv_VEF_base</a>.</p>

<p>Reimplemented in <a class="el" href="classOp__Conv__Amont__VEF__Face.html#abf731f317927f39cba695bf51b3f8b30">Op_Conv_Amont_VEF_Face</a>, <a class="el" href="classOp__Conv__Centre__VEF__Face.html#a5bc769e49dff60180be197de058880b1">Op_Conv_Centre_VEF_Face</a>, <a class="el" href="classOp__Conv__EF__VEF__P1NC__Stab.html#a3507906fb3da346af9d9b6d23fccefa0">Op_Conv_EF_VEF_P1NC_Stab</a>, <a class="el" href="classOp__Conv__Muscl3__VEF__Face.html#ae251e3d7ea490f385709f85b7488a8e7">Op_Conv_Muscl3_VEF_Face</a>, <a class="el" href="classOp__Conv__Muscl__New__VEF__Face.html#a8bf367586ce23a9a6c8f77d4db6bfb77">Op_Conv_Muscl_New_VEF_Face</a>, and <a class="el" href="classOp__Conv__Muscl__VEF__Face.html#adad1a450fb1185640a79bc2438037682">Op_Conv_Muscl_VEF_Face</a>.</p>

<p>Definition at line <a class="el" href="Op__Conv__VEF__Face_8cpp_source.html#l00029">29</a> of file <a class="el" href="Op__Conv__VEF__Face_8cpp_source.html">Op_Conv_VEF_Face.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa087b349430a7cd7fd4ef64670dad088"></a><!-- doxytag: member="Op_Conv_VEF_Face::modifier_pour_Cl" ref="aa087b349430a7cd7fd4ef64670dad088" args="(Matrice_Morse &amp;, DoubleTab &amp;) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Op_Conv_VEF_Face::modifier_pour_Cl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;&#160;</td>
          <td class="paramname"><em>matrice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>secmem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>On modifie le second membre et la matrice dans le cas des<br/>
conditions de dirichlet. </p>

<p>Reimplemented from <a class="el" href="classOperateur__base.html#a119798b1efa7c62fb28a53c20ccd105c">Operateur_base</a>.</p>

<p>Reimplemented in <a class="el" href="classOp__Conv__EF__VEF__P1NC__Stab.html#af4230688a46b05442654639fb87b1a14">Op_Conv_EF_VEF_P1NC_Stab</a>, and <a class="el" href="classOp__Conv__Muscl__New__VEF__Face.html#a9aa7c75c67bd0c800683b833d35eab0f">Op_Conv_Muscl_New_VEF_Face</a>.</p>

<p>Definition at line <a class="el" href="Op__Conv__VEF__Face_8h_source.html#l00094">94</a> of file <a class="el" href="Op__Conv__VEF__Face_8h_source.html">Op_Conv_VEF_Face.h</a>.</p>

<p>References <a class="el" href="Op__Conv__VEF__base_8h_source.html#l00093">Op_Conv_VEF_base::la_zcl_vef</a>, <a class="el" href="Op__Conv__VEF__base_8h_source.html#l00092">Op_Conv_VEF_base::la_zone_vef</a>, <a class="el" href="Ref__Zone__Cl__VEF_8h_source.html#l00028">Ref_Zone_Cl_VEF::valeur()</a>, and <a class="el" href="Ref__Zone__VEF_8h_source.html#l00028">Ref_Zone_VEF::valeur()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <a class="code" href="classOp__Conv__VEF__Face.html#aa087b349430a7cd7fd4ef64670dad088" title="On modifie le second membre et la matrice dans le cas des conditions de dirichlet.">Op_VEF_Face::modifier_pour_Cl</a>(<a class="code" href="classOp__Conv__VEF__base.html#a6c29a488a6805ba4a9f2f059cdba77ae">la_zone_vef</a>.<a class="code" href="classRef__Zone__VEF.html#aafd9a5ee1a76f290c9c6b5447b0c8d30">valeur</a>(),<a class="code" href="classOp__Conv__VEF__base.html#a03f677ee7911706a4f85cd37e0ca4535">la_zcl_vef</a>.<a class="code" href="classRef__Zone__Cl__VEF.html#a0970d7253def65ad4f0c5ce1830fd243">valeur</a>(), matrice, secmem);
}
</pre></div>
</div>
</div>
<a class="anchor" id="a8eacb11670d5ea5cc15ed16632d15360"></a><!-- doxytag: member="Op_Conv_VEF_Face::printOn" ref="a8eacb11670d5ea5cc15ed16632d15360" args="(Sortie &amp;x) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSortie.html">Sortie</a> &amp; Op_Conv_VEF_Face::printOn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSortie.html">Sortie</a> &amp;&#160;</td>
          <td class="paramname"><em>os</em></td><td>)</td>
          <td> const<code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>NE FAIT RIEN<br/>
A surcharger dans les classes derivees. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="classSortie.html" title="Classe de base des flux de sortie. Elle sait ecrire des types simples&lt;br&gt;(entiers, flottants) et des Ob...">Sortie</a>&amp;<br/>
 Signification: le flot de sortie<br/>
 Contraintes: </dd></dl>

<p>Reimplemented from <a class="el" href="classOp__Conv__VEF__base.html#ad405db77626f057684dc1668ca9b3221">Op_Conv_VEF_base</a>.</p>

<p>Reimplemented in <a class="el" href="classOp__Conv__Amont__VEF__Face.html#ae6d0d20273f9d9731a8e5c1deb299baf">Op_Conv_Amont_VEF_Face</a>, <a class="el" href="classOp__Conv__Centre__VEF__Face.html#a1c0ceac0081807f16d8692d924566b60">Op_Conv_Centre_VEF_Face</a>, <a class="el" href="classOp__Conv__EF__VEF__P1NC__Stab.html#a603ebee3d7bebc91e571c828355a13ff">Op_Conv_EF_VEF_P1NC_Stab</a>, <a class="el" href="classOp__Conv__Muscl3__VEF__Face.html#a4c5a38cdb84981a023aad352601d4c79">Op_Conv_Muscl3_VEF_Face</a>, <a class="el" href="classOp__Conv__Muscl__New__VEF__Face.html#af69550ea7cba363dae2162d2ff994fe0">Op_Conv_Muscl_New_VEF_Face</a>, and <a class="el" href="classOp__Conv__Muscl__VEF__Face.html#ad725b338d03ab5cea1cd4e38649c1783">Op_Conv_Muscl_VEF_Face</a>.</p>

<p>Definition at line <a class="el" href="Op__Conv__VEF__Face_8cpp_source.html#l00034">34</a> of file <a class="el" href="Op__Conv__VEF__Face_8cpp_source.html">Op_Conv_VEF_Face.cpp</a>.</p>

<p>References <a class="el" href="Objet__U_8cpp_source.html#l00132">Objet_U::que_suis_je()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">return</span> s &lt;&lt; <a class="code" href="classObjet__U.html#aa58e9a81c0ddc2c1149053b8f96698ac" title="renvoie la chaine identifiant la classe.">que_suis_je</a>() ;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a20514a9862bc5e8a557eadc1b8860a2a"></a><!-- doxytag: member="Op_Conv_VEF_Face::readOn" ref="a20514a9862bc5e8a557eadc1b8860a2a" args="(Entree &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEntree.html">Entree</a> &amp; Op_Conv_VEF_Face::readOn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEntree.html">Entree</a> &amp;&#160;</td>
          <td class="paramname"><em>is</em></td><td>)</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>NE FAIT RIEN<br/>
A surcharger dans les classes derivees. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="classEntree.html" title="Classe de definition des operateurs et methodes pour toute lecture dans un flot d&#39;entree (fichier...">Entree</a>&amp;<br/>
 Signification: le flot d'entree<br/>
 Contraintes: </dd></dl>

<p>Reimplemented from <a class="el" href="classOp__Conv__VEF__base.html#aa902fa2f6efc960b4153e2c180f64233">Op_Conv_VEF_base</a>.</p>

<p>Reimplemented in <a class="el" href="classOp__Conv__Amont__VEF__Face.html#aaf72157b5149f28180ec3b0175a7b23b">Op_Conv_Amont_VEF_Face</a>, <a class="el" href="classOp__Conv__Centre__VEF__Face.html#a51b1f20336e751ac92c17dcd13d015ad">Op_Conv_Centre_VEF_Face</a>, <a class="el" href="classOp__Conv__EF__VEF__P1NC__Stab.html#a902293420aedb4314065a6855089ac7e">Op_Conv_EF_VEF_P1NC_Stab</a>, <a class="el" href="classOp__Conv__Muscl3__VEF__Face.html#acf1769f95358eda9a5703fb3b436810f">Op_Conv_Muscl3_VEF_Face</a>, <a class="el" href="classOp__Conv__Muscl__New__VEF__Face.html#a8bfb304871cfa825d460dd1bdc8f6594">Op_Conv_Muscl_New_VEF_Face</a>, and <a class="el" href="classOp__Conv__Muscl__VEF__Face.html#a5b8c0838b513fc1626455763c54c1abc">Op_Conv_Muscl_VEF_Face</a>.</p>

<p>Definition at line <a class="el" href="Op__Conv__VEF__Face_8cpp_source.html#l00041">41</a> of file <a class="el" href="Op__Conv__VEF__Face_8cpp_source.html">Op_Conv_VEF_Face.cpp</a>.</p>

<p>References <a class="el" href="Op__Conv__VEF__Face_8h_source.html#l00070">alpha_</a>, <a class="el" href="Op__Conv__VEF__Face_8h_source.html#l00071">amont</a>, <a class="el" href="Op__Conv__VEF__Face_8h_source.html#l00071">centre</a>, <a class="el" href="EntreeSortie_8h_source.html#l00032">Cerr</a>, <a class="el" href="Convection__tools_8cpp_source.html#l00053">chakravarthy()</a>, <a class="el" href="Process_8cpp_source.html#l00223">Process::exit()</a>, <a class="el" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>, <a class="el" href="Op__Conv__VEF__Face_8h_source.html#l00074">LIMITEUR</a>, <a class="el" href="Convection__tools_8cpp_source.html#l00031">minmod()</a>, <a class="el" href="Op__Conv__VEF__Face_8h_source.html#l00071">muscl</a>, <a class="el" href="Op__Conv__VEF__Face_8h_source.html#l00069">ordre</a>, <a class="el" href="Objet__U_8cpp_source.html#l00132">Objet_U::que_suis_je()</a>, <a class="el" href="Convection__tools_8cpp_source.html#l00070">superbee()</a>, <a class="el" href="Op__Conv__VEF__Face_8h_source.html#l00067">type_lim</a>, <a class="el" href="Op__Conv__VEF__Face_8h_source.html#l00072">type_op</a>, <a class="el" href="Convection__tools_8cpp_source.html#l00045">vanalbada()</a>, and <a class="el" href="Convection__tools_8cpp_source.html#l00038">vanleer()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <a class="code" href="classMotcle.html" title="Une chaine de caractere (Nom) en majuscules.">Motcle</a> type_op_lu;
  s &gt;&gt; type_op_lu;

  <span class="keywordflow">if</span> (!(type_op_lu==<span class="stringliteral">&quot;amont&quot;</span>) &amp;&amp; !(type_op_lu==<span class="stringliteral">&quot;muscl&quot;</span>) &amp;&amp; !(type_op_lu==<span class="stringliteral">&quot;centre&quot;</span>))
    {
      <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; type_op_lu &lt;&lt; <span class="stringliteral">&quot; n&#39;est pas compris par &quot;</span> &lt;&lt; <a class="code" href="classObjet__U.html#aa58e9a81c0ddc2c1149053b8f96698ac" title="renvoie la chaine identifiant la classe.">que_suis_je</a>() &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
      <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot; choisir parmi : amont - muscl - centre &quot;</span> &lt;&lt; finl;
      <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">exit</a>();
    }

  <span class="keywordflow">if</span> (type_op_lu==<span class="stringliteral">&quot;muscl&quot;</span>)
    {
      <a class="code" href="classOp__Conv__VEF__Face.html#aac6bde5c9421ce149a3f28a11709b1f6">type_op</a> = <a class="code" href="classOp__Conv__VEF__Face.html#abbf17549ccbad9c64780dcca7a3e2634af9bc4313cad73dd46e9d5364c4f001b3">muscl</a>;
      s &gt;&gt; <a class="code" href="classOp__Conv__VEF__Face.html#a070e3e30a22b79bd58ac3bd36f7802f6">type_lim</a>;

      <span class="keywordflow">if</span> ( !(type_lim==<span class="stringliteral">&quot;minmod&quot;</span>) &amp;&amp; !(type_lim==<span class="stringliteral">&quot;vanleer&quot;</span>) &amp;&amp; !(type_lim==<span class="stringliteral">&quot;vanalbada&quot;</span>)
           &amp;&amp;  !(type_lim==<span class="stringliteral">&quot;chakravarthy&quot;</span>) &amp;&amp; !(type_lim==<span class="stringliteral">&quot;superbee&quot;</span>) )
        {
          <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; type_lim &lt;&lt; <span class="stringliteral">&quot; n&#39;est pas compris par &quot;</span> &lt;&lt; <a class="code" href="classObjet__U.html#aa58e9a81c0ddc2c1149053b8f96698ac" title="renvoie la chaine identifiant la classe.">que_suis_je</a>() &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
          <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot; choisir parmi : minmod - vanleer - vanalbada - chakravarthy - superbee &quot;</span> &lt;&lt; finl;
          <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">exit</a>();
        }

      <span class="keywordflow">if</span> (type_lim==<span class="stringliteral">&quot;minmod&quot;</span>) <a class="code" href="classOp__Conv__VEF__Face.html#a5a58e90633d9d06d20e898980ab9c4da">LIMITEUR</a>=&amp;<a class="code" href="Convection__tools_8cpp.html#acd40757070ae472ea829cf1cb522d91a">minmod</a>;
      <span class="keywordflow">if</span> (type_lim==<span class="stringliteral">&quot;vanleer&quot;</span>) <a class="code" href="classOp__Conv__VEF__Face.html#a5a58e90633d9d06d20e898980ab9c4da">LIMITEUR</a>=&amp;<a class="code" href="Convection__tools_8cpp.html#a1a4e56eba2ab02a6dc14150e0c64aaa9">vanleer</a>;
      <span class="keywordflow">if</span> (type_lim==<span class="stringliteral">&quot;vanalbada&quot;</span>) <a class="code" href="classOp__Conv__VEF__Face.html#a5a58e90633d9d06d20e898980ab9c4da">LIMITEUR</a>=&amp;<a class="code" href="Convection__tools_8cpp.html#a76960377768725078abb6c302d998684">vanalbada</a>;
      <span class="keywordflow">if</span> (type_lim==<span class="stringliteral">&quot;chakravarthy&quot;</span>) <a class="code" href="classOp__Conv__VEF__Face.html#a5a58e90633d9d06d20e898980ab9c4da">LIMITEUR</a>=&amp;<a class="code" href="Convection__tools_8cpp.html#a87e787b999612072da5bb5d40d9af9c7">chakravarthy</a>;
      <span class="keywordflow">if</span> (type_lim==<span class="stringliteral">&quot;superbee&quot;</span>) <a class="code" href="classOp__Conv__VEF__Face.html#a5a58e90633d9d06d20e898980ab9c4da">LIMITEUR</a>=&amp;<a class="code" href="Convection__tools_8cpp.html#acb830b6dc6f01da7073bcd2336e9b621">superbee</a>;

      s &gt;&gt; <a class="code" href="classOp__Conv__VEF__Face.html#ad30e1a556295f226b7ef1215dc0030e5">ordre</a>;

      <span class="keywordflow">if</span> (ordre!=1 &amp;&amp; ordre!=2 &amp;&amp; ordre!=3)
        {
          <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;l&#39;ordre apres &quot;</span> &lt;&lt; type_lim &lt;&lt; <span class="stringliteral">&quot; dans &quot;</span> &lt;&lt; <a class="code" href="classObjet__U.html#aa58e9a81c0ddc2c1149053b8f96698ac" title="renvoie la chaine identifiant la classe.">que_suis_je</a>() &lt;&lt; <span class="stringliteral">&quot; doit etre soit 1, soit 2, soit 3&quot;</span> &lt;&lt;  <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
          <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">exit</a>();
        }
      <span class="keywordflow">if</span> (ordre==3)
        {
<span class="comment">// Lecture de alpha_</span>
          s &gt;&gt; <a class="code" href="classOp__Conv__VEF__Face.html#aebc1771cc4608fc51a8b6d15b93c8d3d">alpha_</a>;
        }
    }

  <span class="keywordflow">if</span> (type_op_lu==<span class="stringliteral">&quot;centre&quot;</span>)
    {
      <a class="code" href="classOp__Conv__VEF__Face.html#aac6bde5c9421ce149a3f28a11709b1f6">type_op</a> = <a class="code" href="classOp__Conv__VEF__Face.html#abbf17549ccbad9c64780dcca7a3e2634aeb4b20f4ab0bb61c69bfbf25d47d219d">centre</a>;
      s &gt;&gt; <a class="code" href="classOp__Conv__VEF__Face.html#ad30e1a556295f226b7ef1215dc0030e5">ordre</a>;

      <span class="keywordflow">if</span> (ordre!=1 &amp;&amp; ordre!=2)
        {
          <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;l&#39;ordre apres &quot;</span> &lt;&lt; type_op_lu &lt;&lt; <span class="stringliteral">&quot; dans &quot;</span> &lt;&lt; <a class="code" href="classObjet__U.html#aa58e9a81c0ddc2c1149053b8f96698ac" title="renvoie la chaine identifiant la classe.">que_suis_je</a>() &lt;&lt; <span class="stringliteral">&quot; doit etre soit 1, soit 2 &quot;</span> &lt;&lt;  <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
          <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">exit</a>();
        }
    }

  <span class="keywordflow">if</span> (type_op_lu==<span class="stringliteral">&quot;amont&quot;</span>)
    {
      <a class="code" href="classOp__Conv__VEF__Face.html#aac6bde5c9421ce149a3f28a11709b1f6">type_op</a> = <a class="code" href="classOp__Conv__VEF__Face.html#abbf17549ccbad9c64780dcca7a3e2634a1192ae3f2c2a1d9d734f4cc495b58a44">amont</a>;
      ordre = 1;
    }

  <span class="keywordflow">return</span> s ;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a1fcf6b33ff3ee706ffef89a117e2f54a"></a><!-- doxytag: member="Op_Conv_VEF_Face::remplir_fluent" ref="a1fcf6b33ff3ee706ffef89a117e2f54a" args="(DoubleVect &amp;) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Op_Conv_VEF_Face::remplir_fluent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;&#160;</td>
          <td class="paramname"><em>tab_fluent</em></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="classOp__Conv__VEF__base.html#ac646fced78c4ef4ea26c6483a419ab31">Op_Conv_VEF_base</a>.</p>

<p>Reimplemented in <a class="el" href="classOp__Conv__EF__VEF__P1NC__Stab.html#a1c6a846b83bbf93ffaddfe6b0f040fe1">Op_Conv_EF_VEF_P1NC_Stab</a>, and <a class="el" href="classOp__Conv__Muscl__New__VEF__Face.html#a3bd2f8fbc0e634221c7df74db0bca01d">Op_Conv_Muscl_New_VEF_Face</a>.</p>

<p>Definition at line <a class="el" href="Op__Conv__VEF__Face_8cpp_source.html#l01149">1149</a> of file <a class="el" href="Op__Conv__VEF__Face_8cpp_source.html">Op_Conv_VEF_Face.cpp</a>.</p>

<p>References <a class="el" href="Op__Conv__VEF__Face_8h_source.html#l00071">amont</a>, <a class="el" href="classElem__VEF__base.html#a02b712675ec9d8bbb6571ddbbec33417">Elem_VEF_base::calcul_vc()</a>, <a class="el" href="Op__Conv__VEF__Face_8h_source.html#l00071">centre</a>, <a class="el" href="Objet__U_8h_source.html#l00079">Objet_U::dimension</a>, <a class="el" href="Zone__VF_8h_source.html#l00574">Zone_VF::elem_faces()</a>, <a class="el" href="MorEqn_8h_source.html#l00082">MorEqn::equation()</a>, <a class="el" href="Zone__VEF_8h_source.html#l00145">Zone_VEF::face_normales()</a>, <a class="el" href="Zone__VEF_8h_source.html#l00152">Zone_VEF::facette_normales()</a>, <a class="el" href="Cond__lim_8h_source.html#l00130">Cond_lim::frontiere_dis()</a>, <a class="el" href="Elem__VEF__base_8h_source.html#l00047">Elem_VEF_base::KEL()</a>, <a class="el" href="Op__Conv__VEF__base_8h_source.html#l00093">Op_Conv_VEF_base::la_zcl_vef</a>, <a class="el" href="Op__Conv__VEF__base_8h_source.html#l00092">Op_Conv_VEF_base::la_zone_vef</a>, <a class="el" href="Zone__Cl__dis__base_8cpp_source.html#l00522">Zone_Cl_dis_base::les_conditions_limites()</a>, <a class="el" href="Zone_8h_source.html#l00402">Zone::les_elems()</a>, <a class="el" href="Op__Conv__VEF__Face_8h_source.html#l00071">muscl</a>, <a class="el" href="Zone__dis__base_8h_source.html#l00144">Zone_dis_base::nb_elem_tot()</a>, <a class="el" href="Front__VF_8h_source.html#l00061">Front_VF::nb_faces()</a>, <a class="el" href="Zone_8h_source.html#l00469">Zone::nb_faces_elem()</a>, <a class="el" href="Elem__VEF_8h_source.html#l00083">Elem_VEF::nb_facette()</a>, <a class="el" href="Zone__dis__base_8h_source.html#l00156">Zone_dis_base::nb_front_Cl()</a>, <a class="el" href="Zone_8h_source.html#l00445">Zone::nb_som_elem()</a>, <a class="el" href="Zone__Cl__VEF_8h_source.html#l00130">Zone_Cl_VEF::normales_facettes_Cl()</a>, <a class="el" href="Front__VF_8h_source.html#l00071">Front_VF::num_premiere_face()</a>, <a class="el" href="Op__Conv__VEF__base_8cpp_source.html#l00053">Op_Conv_VEF_base::phi_u_transportant()</a>, <a class="el" href="Zone__VF_8h_source.html#l00315">Zone_VF::porosite_elem()</a>, <a class="el" href="Zone__VF_8h_source.html#l00285">Zone_VF::porosite_face()</a>, <a class="el" href="Objet__U_8cpp_source.html#l00132">Objet_U::que_suis_je()</a>, <a class="el" href="Zone__VEF_8h_source.html#l00165">Zone_VEF::rang_elem_non_std()</a>, <a class="el" href="Cast_8h_source.html#l00059">ref_cast</a>, <a class="el" href="Cast_8h_source.html#l00054">sub_type</a>, <a class="el" href="Zone__VEF_8h_source.html#l00138">Zone_VEF::type_elem()</a>, <a class="el" href="Zone__Cl__VEF_8h_source.html#l00167">Zone_Cl_VEF::type_elem_Cl()</a>, <a class="el" href="Op__Conv__VEF__Face_8h_source.html#l00072">type_op</a>, <a class="el" href="Cond__lim_8h_source.html#l00031">Deriv_Cond_lim_base::valeur()</a>, <a class="el" href="Elem__VEF_8h_source.html#l00041">Deriv_Elem_VEF_base::valeur()</a>, <a class="el" href="Ref__Zone__VEF_8h_source.html#l00028">Ref_Zone_VEF::valeur()</a>, <a class="el" href="Ref__Zone__Cl__VEF_8h_source.html#l00028">Ref_Zone_Cl_VEF::valeur()</a>, <a class="el" href="Op__Conv__VEF__base_8h_source.html#l00069">Op_Conv_VEF_base::vitesse()</a>, and <a class="el" href="Zone__dis__base_8h_source.html#l00106">Zone_dis_base::zone()</a>.</p>
<div class="fragment"><pre class="fragment">{

  assert((<a class="code" href="classOp__Conv__VEF__Face.html#aac6bde5c9421ce149a3f28a11709b1f6">type_op</a>==<a class="code" href="classOp__Conv__VEF__Face.html#abbf17549ccbad9c64780dcca7a3e2634a1192ae3f2c2a1d9d734f4cc495b58a44">amont</a>) || (<a class="code" href="classOp__Conv__VEF__Face.html#aac6bde5c9421ce149a3f28a11709b1f6">type_op</a>==<a class="code" href="classOp__Conv__VEF__Face.html#abbf17549ccbad9c64780dcca7a3e2634af9bc4313cad73dd46e9d5364c4f001b3">muscl</a>) || (<a class="code" href="classOp__Conv__VEF__Face.html#aac6bde5c9421ce149a3f28a11709b1f6">type_op</a>==<a class="code" href="classOp__Conv__VEF__Face.html#abbf17549ccbad9c64780dcca7a3e2634aeb4b20f4ab0bb61c69bfbf25d47d219d">centre</a>));
  <span class="keyword">const</span> <a class="code" href="classZone__Cl__VEF.html">Zone_Cl_VEF</a>&amp; zone_Cl_VEF = <a class="code" href="classOp__Conv__VEF__base.html#a03f677ee7911706a4f85cd37e0ca4535">la_zcl_vef</a>.<a class="code" href="classRef__Zone__Cl__VEF.html#a0970d7253def65ad4f0c5ce1830fd243">valeur</a>();
  <span class="keyword">const</span> <a class="code" href="classZone__VEF.html" title="class Zone_VEF Classe instanciable qui derive de Zone_VF. Cette classe contient les informations geom...">Zone_VEF</a>&amp; zone_VEF = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classZone__VEF.html" title="class Zone_VEF Classe instanciable qui derive de Zone_VF. Cette classe contient les informations geom...">Zone_VEF</a>, <a class="code" href="classOp__Conv__VEF__base.html#a6c29a488a6805ba4a9f2f059cdba77ae">la_zone_vef</a>.<a class="code" href="classRef__Zone__VEF.html#aafd9a5ee1a76f290c9c6b5447b0c8d30">valeur</a>());
  <span class="keyword">const</span> <a class="code" href="classChamp__Inc__base.html" title="Classe Champ_Inc_base Classe de base des champs inconnues qui sont les champs calcules par une equati...">Champ_Inc_base</a>&amp; la_vitesse=<a class="code" href="classOp__Conv__VEF__base.html#a4872ffd7c638ecc415191d92d7f5f507">vitesse</a>();
  <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; vitesse_face_absolue=la_vitesse.valeurs();

  <span class="keywordtype">int</span> marq=<a class="code" href="classOp__Conv__VEF__base.html#ad380b9b9ca1d70282b289838a604a4b0" title="definit si l&#39;on convecte psi avec phi*u ou avec u">phi_u_transportant</a>(<a class="code" href="classMorEqn.html#a615dd9abff96edcb625fa0424a489864" title="Renvoie la reference sur l&#39;equation pointe par MorEqn::mon_equation. (version const)">equation</a>());
<span class="comment">// on force a calculer un pas de temps sans &quot;porosite&quot;</span>
  marq=0;

  <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; porosite_face = zone_VEF.<a class="code" href="classZone__VF.html#ad9d74d1d9da9f50ab26768dbbca7711b">porosite_face</a>();


  <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; vitesse_face=vitesse_face_absolue;

  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; elem_faces = zone_VEF.<a class="code" href="classZone__VF.html#a067e462dcd3ab92b0f6d945b19e4eb37" title="renvoie le numero de le ieme face de la maille num_elem la facon dont ces faces sont numerotees est l...">elem_faces</a>();
  <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; face_normales = zone_VEF.<a class="code" href="classZone__VEF.html#a5742d75972e4846bf9fbb6ed5715053e">face_normales</a>();
  <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; facette_normales = zone_VEF.<a class="code" href="classZone__VEF.html#a581b1ca0e62c668c92f104351d19fda6">facette_normales</a>();
  <span class="keyword">const</span> <a class="code" href="classZone.html" title="classe Zone Une Zone est un maillage compose d&#39;un ensemble d&#39;elements geometriques de meme type...">Zone</a>&amp; zone = zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> nfa7 = zone_VEF.<a class="code" href="classZone__VEF.html#a46693c060b8096fb2595ca72192eea2a">type_elem</a>().<a class="code" href="classElem__VEF.html#a4a34777c0083b38dd34c8a400d5b4e90">nb_facette</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_elem_tot = zone_VEF.<a class="code" href="classZone__dis__base.html#a4d6aa445f152aa6dc54d66ea7a071147">nb_elem_tot</a>();
  <span class="keyword">const</span> <a class="code" href="classIntVect.html">IntVect</a>&amp; rang_elem_non_std = zone_VEF.<a class="code" href="classZone__VEF.html#a4b2171a85e5fc33663a3366acb713584">rang_elem_non_std</a>();
  <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; normales_facettes_Cl = zone_Cl_VEF.<a class="code" href="classZone__Cl__VEF.html#a83c05e82370553470ed05f10932e0f3f">normales_facettes_Cl</a>();
  <span class="keywordtype">int</span> nfac = zone.<a class="code" href="classZone.html#a548fbc7518be2f122b1a5c9589a443c2" title="Renvoie le nombre de face de type i des elements geometriques constituants la zone. Ex: les objets de la classe Prisme ont 2 types de faces: triangle ou quadrangle.">nb_faces_elem</a>();
  <span class="keywordtype">int</span> nsom = zone.<a class="code" href="classZone.html#ae0b34a93b9ae8146df2d1884157afe9f" title="Renvoie le nombre de sommets des elements geometriques constituants la zone. Tous les elements de la ...">nb_som_elem</a>();
  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; sommet_elem = zone.<a class="code" href="classZone.html#ac115e8342be89afb882b7b61cc343267" title="Renvoie le tableau des sommets des elements.">les_elems</a>();
  <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; fluent_ = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classDoubleVect.html">DoubleVect</a>, tab_fluent);

<span class="comment">// On definit le tableau des sommets:(C MALOD 17/07/2007)</span>

<span class="comment">// Pour le traitement de la convection on distingue les polyedres</span>
<span class="comment">// standard qui ne &quot;voient&quot; pas les conditions aux limites et les</span>
<span class="comment">// polyedres non standard qui ont au moins une face sur le bord.</span>
<span class="comment">// Un polyedre standard a n facettes sur lesquelles on applique le</span>
<span class="comment">// schema de convection.</span>
<span class="comment">// Pour un polyedre non standard qui porte des conditions aux limites</span>
<span class="comment">// de Dirichlet, une partie des facettes sont portees par les faces.</span>
<span class="comment">// En bref pour un polyedre le traitement de la convection depend</span>
<span class="comment">// du type (triangle, tetraedre ...) et du nombre de faces de Dirichlet.</span>

  <span class="keyword">const</span> <a class="code" href="classElem__VEF__base.html">Elem_VEF_base</a>&amp; type_elemvef= zone_VEF.<a class="code" href="classZone__VEF.html#a46693c060b8096fb2595ca72192eea2a">type_elem</a>().<a class="code" href="classDeriv__Elem__VEF__base.html#a2886905d5071be902c77248b69ca0b7b">valeur</a>();
  <span class="keywordtype">int</span> istetra=0;
  <a class="code" href="classNom.html" title="class Nom Une chaine de caractere pour nommer les objets de TRUST">Nom</a> nom_elem=type_elemvef.<a class="code" href="classObjet__U.html#aa58e9a81c0ddc2c1149053b8f96698ac" title="renvoie la chaine identifiant la classe.">que_suis_je</a>();
  <span class="keywordflow">if</span> ((nom_elem==<span class="stringliteral">&quot;Tetra_VEF&quot;</span>)||(nom_elem==<span class="stringliteral">&quot;Tri_VEF&quot;</span>))
    istetra=1;
  <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; porosite_elem = zone_VEF.<a class="code" href="classZone__VF.html#afd135a1b227731193b1a97b7ed525435">porosite_elem</a>();

  <span class="keywordtype">double</span> psc;
  <span class="keywordtype">int</span> poly,face_adj,fa7,i,j,n_bord;
  <span class="keywordtype">int</span> num_face, rang ,itypcl;
  <span class="keywordtype">int</span> num1,num2,num_som;

  <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> face(nfac);
  <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a> vs(<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>);
  <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a> vc(<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>);
  <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a> vsom(nsom,<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>);
  <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a> cc(<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>);

<span class="comment">// Dimensionnement du tableau des flux convectifs au bord du domaine de calcul</span>
  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; KEL=type_elemvef.<a class="code" href="classElem__VEF__base.html#ab129610ef702aa8c9c98dcb4c7551172">KEL</a>();

<span class="comment">// On remet a zero le tableau qui sert pour</span>
<span class="comment">// le calcul du pas de temps de stabilite</span>
  fluent_ = 0;

<span class="comment">// Les polyedres non standard sont ranges en 2 groupes dans la Zone_VEF:</span>
<span class="comment">// - polyedres bords et joints</span>
<span class="comment">// - polyedres bords et non joints</span>
<span class="comment">// On traite les polyedres en suivant l&#39;ordre dans lequel ils figurent</span>
<span class="comment">// dans la zone</span>

<span class="comment">// boucle sur les polys</span>
  <span class="keywordflow">for</span> (poly=0; poly&lt;nb_elem_tot; poly++)
    {
      rang = rang_elem_non_std(poly);
<span class="comment">// On cherche, pour un elem qui n&#39;est pas de bord (rang==-1),</span>
<span class="comment">// si un des sommets est sur un bord (tableau des sommets) (C MALOD 17/07/2007)</span>

      <span class="keywordflow">if</span> (rang==-1)
        itypcl=0;
      <span class="keywordflow">else</span>
        itypcl=zone_Cl_VEF.<a class="code" href="classZone__Cl__VEF.html#a483bdab7690f844ed04e3defe04ec70a">type_elem_Cl</a>(rang);

<span class="comment">// calcul des numeros des faces du polyedre</span>
      <span class="keywordflow">for</span> (face_adj=0; face_adj&lt;nfac; face_adj++)
        face(face_adj)= elem_faces(poly,face_adj);

      <span class="keywordflow">for</span> (j=0; j&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; j++)
        {
          vs(j) = vitesse_face_absolue(face(0),j)*porosite_face(face(0));
          <span class="keywordflow">for</span> (i=1; i&lt;nfac; i++)
            vs(j)+= vitesse_face_absolue(face(i),j)*porosite_face(face(i));
        }
<span class="comment">// calcul de la vitesse aux sommets des polyedres</span>
<span class="comment">// On va utliser les fonctions de forme implementees dans la classe Champs_P1_impl ou Champs_Q1_impl</span>
      <span class="keywordflow">if</span> (istetra==1)
        {
          <span class="keywordflow">for</span> (i=0; i&lt;nsom; i++)
            <span class="keywordflow">for</span> (j=0; j&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; j++)
              vsom(i,j) = (vs(j) - dimension*vitesse_face_absolue(face(i),j)*porosite_face(face(i)));
        }
      <span class="keywordflow">else</span>
        {
<span class="comment">// pour que cela soit valide avec les hexa (c&#39;est + lent a calculer...)</span>
          <span class="keywordtype">int</span> ncomp;
          <span class="keywordflow">for</span> (j=0; j&lt;nsom; j++)
            {
              num_som = sommet_elem(poly,j);
              <span class="keywordflow">for</span> (ncomp=0; ncomp&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; ncomp++)
                vsom(j,ncomp) = la_vitesse.valeur_a_sommet_compo(num_som,poly,ncomp);
            }
        }

<span class="comment">// calcul de vc (a l&#39;intersection des 3 facettes) vc vs vsom proportionnelles a la prosite</span>
      type_elemvef.<a class="code" href="classElem__VEF__base.html#a02b712675ec9d8bbb6571ddbbec33417">calcul_vc</a>(face,vc,vs,vsom,<a class="code" href="classOp__Conv__VEF__base.html#a4872ffd7c638ecc415191d92d7f5f507">vitesse</a>(),itypcl,porosite_face);
      <span class="keywordflow">if</span> (marq==0)
        {
          <span class="keywordtype">double</span> porosite_poly=porosite_elem(poly);
          <span class="keywordflow">for</span> (i=0; i&lt;nsom; i++)
            <span class="keywordflow">for</span> (j=0; j&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; j++)
              vsom(i,j)/=porosite_poly;
          <span class="keywordflow">for</span> (j=0; j&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; j++)
            {
              vs(j)/= porosite_poly;
              vc(j)/=porosite_poly;
            }
        }
<span class="comment">// Boucle sur les facettes du polyedre non standard:</span>
      <span class="keywordflow">for</span> (fa7=0; fa7&lt;nfa7; fa7++)
        {
          num1 = face(KEL(0,fa7));
          num2 = face(KEL(1,fa7));
<span class="comment">// normales aux facettes</span>
          <span class="keywordflow">if</span> (rang==-1)
            {
              <span class="keywordflow">for</span> (i=0; i&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; i++)
                cc[i] = facette_normales(poly, fa7, i);
            }
          <span class="keywordflow">else</span>
            {
              <span class="keywordflow">for</span> (i=0; i&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; i++)
                cc[i] = normales_facettes_Cl(rang,fa7,i);
            }
<span class="comment">// On applique le schema de convection a chaque sommet de la facette</span>

          <span class="keywordtype">double</span> psc_c=0,psc_s=0,psc_m,psc_s2=0;
          <span class="keywordflow">if</span> (dimension==2)
            {
              <span class="keywordflow">for</span> (i=0; i&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; i++)
                {
                  psc_c+=vc[i]*cc[i];
                  psc_s+=vsom(KEL(2,fa7),i)*cc[i];
                }
              psc_m=(psc_c+psc_s)/2.;
            }
          <span class="keywordflow">else</span>
            {
              <span class="keywordflow">for</span> (i=0; i&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; i++)
                {
                  psc_c+=vc[i]*cc[i];
                  psc_s+=vsom(KEL(2,fa7),i)*cc[i];
                  psc_s2+=vsom(KEL(3,fa7),i)*cc[i];
                }
              psc_m=(psc_c+psc_s+psc_s2)/3.;
            }

<span class="comment">// int amont,dir;</span>
          <span class="keywordflow">if</span> (psc_m &gt;= 0)
            {
<span class="comment">// amont = num1;</span>
              fluent_(num2)  += psc_m;
<span class="comment">// dir=0;</span>
            }
          <span class="keywordflow">else</span>
            {
<span class="comment">// amont = num2;</span>
              fluent_(num1)  -= psc_m;
<span class="comment">// dir=1;</span>
            }

        } <span class="comment">//!&lt; fin de la boucle sur les facettes</span>
<span class="comment"></span>    } <span class="comment">//!&lt; fin de la boucle</span>
<span class="comment"></span>
<span class="comment">// Boucle sur les bords pour traiter les conditions aux limites</span>
<span class="comment">// il y a prise en compte d&#39;un terme de convection pour les</span>
<span class="comment">// conditions aux limites de Neumann_sortie_libre seulement</span>
  <span class="keywordtype">int</span> nb_bord = zone_VEF.<a class="code" href="classZone__dis__base.html#af22167d614644f55591a29c77eb1c009">nb_front_Cl</a>();
  <span class="keywordflow">for</span> (n_bord=0; n_bord&lt;nb_bord; n_bord++)
    {
      <span class="keyword">const</span> <a class="code" href="classCond__lim.html" title="classe Cond_lim Classe generique servant a representer n&#39;importe quelle classe derivee de la classe C...">Cond_lim</a>&amp; la_cl = zone_Cl_VEF.<a class="code" href="classZone__Cl__dis__base.html#af75e0ed7786863e4d333bfb29d67c323" title="Renvoie la i-ieme condition aux limites. (version const)">les_conditions_limites</a>(n_bord);
      <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classNeumann__sortie__libre.html" title="classe Neumann_sortie_libre Cette classe represente une frontiere ouverte sans vitesse imposee Pour l...">Neumann_sortie_libre</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>()))
        {
          <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp; le_bord = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>,la_cl.<a class="code" href="classCond__lim.html#a5b2d24809cee07727006a891d4ce8d22" title="Appel a l&#39;objet sous-jacent Renvoie la frontiere discretisee associee a la condition aux limites...">frontiere_dis</a>());
          <span class="keywordtype">int</span> num1b = le_bord.<a class="code" href="classFront__VF.html#a4986f0c65653fe9eb40bbbff5a97bf16" title="Numero de la premiere face du bord dans la liste des faces.">num_premiere_face</a>();
          <span class="keywordtype">int</span> num2b = num1b + le_bord.<a class="code" href="classFront__VF.html#a341e2fcb5117b96e745fd7078ba86bab" title="Nombre de faces reelles du bord.">nb_faces</a>();
          <span class="keywordflow">for</span> (num_face=num1b; num_face&lt;num2b; num_face++)
            {
              psc = 0;
              <span class="keywordflow">for</span> (i=0; i&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; i++)
                psc += vitesse_face(num_face,i)*face_normales(num_face,i);
              <span class="keywordflow">if</span> (psc&gt;0)
                ;
              <span class="keywordflow">else</span>
                fluent_(num_face) -= psc;
            }
        }
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="aaf796aa5e9861e15db4afb2db07d6e12"></a><!-- doxytag: member="Op_Conv_VEF_Face::self_cast" ref="aaf796aa5e9861e15db4afb2db07d6e12" args="(Objet_U &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOp__Conv__VEF__Face.html">Op_Conv_VEF_Face</a> &amp; Op_Conv_VEF_Face::self_cast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classObjet__U.html">Objet_U</a> &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="classOp__Conv__VEF__base.html#ad79fc48ca1771d3ff175be00ae86bda3">Op_Conv_VEF_base</a>.</p>

<p>Reimplemented in <a class="el" href="classOp__Conv__Amont__VEF__Face.html#ae61f3fd7c4e233f16b833eb9e7c2a653">Op_Conv_Amont_VEF_Face</a>, <a class="el" href="classOp__Conv__Centre__VEF__Face.html#aaaa5d041240580de22771b300c4cc647">Op_Conv_Centre_VEF_Face</a>, <a class="el" href="classOp__Conv__EF__VEF__P1NC__Stab.html#a19f131f7e109c2715031324fa9c116f9">Op_Conv_EF_VEF_P1NC_Stab</a>, <a class="el" href="classOp__Conv__Muscl3__VEF__Face.html#a04c9ceb440b8f4e5b5a59977efe140db">Op_Conv_Muscl3_VEF_Face</a>, <a class="el" href="classOp__Conv__Muscl__New__VEF__Face.html#ae3051e6ae4326900ce530965a9e382cc">Op_Conv_Muscl_New_VEF_Face</a>, and <a class="el" href="classOp__Conv__Muscl__VEF__Face.html#a2821ef7fe96f7bf5359666d5b0856956">Op_Conv_Muscl_VEF_Face</a>.</p>

<p>Definition at line <a class="el" href="Op__Conv__VEF__Face_8cpp_source.html#l00029">29</a> of file <a class="el" href="Op__Conv__VEF__Face_8cpp_source.html">Op_Conv_VEF_Face.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a137b0427f8ba4a591de409481c8e54d4"></a><!-- doxytag: member="Op_Conv_VEF_Face::self_cast" ref="a137b0427f8ba4a591de409481c8e54d4" args="(const Objet_U &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classOp__Conv__VEF__Face.html">Op_Conv_VEF_Face</a> &amp; Op_Conv_VEF_Face::self_cast </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classObjet__U.html">Objet_U</a> &amp;&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>methode ajoutee pour caster en python </p>

<p>Reimplemented from <a class="el" href="classOp__Conv__VEF__base.html#aa01f06b06f61d70ab78b3ce3b5779c83">Op_Conv_VEF_base</a>.</p>

<p>Reimplemented in <a class="el" href="classOp__Conv__Amont__VEF__Face.html#a85619d4c44c6005fb44751a2a5c1b8ec">Op_Conv_Amont_VEF_Face</a>, <a class="el" href="classOp__Conv__Centre__VEF__Face.html#a9704a443dc6798f72ef7f37d9d056d67">Op_Conv_Centre_VEF_Face</a>, <a class="el" href="classOp__Conv__EF__VEF__P1NC__Stab.html#a72ce7a8fd1825b07a59f1eb8fddd656f">Op_Conv_EF_VEF_P1NC_Stab</a>, <a class="el" href="classOp__Conv__Muscl3__VEF__Face.html#a896afd448286110a1aa02a92a368f5ab">Op_Conv_Muscl3_VEF_Face</a>, <a class="el" href="classOp__Conv__Muscl__New__VEF__Face.html#a92c196702032a60e9e1c8085bf0109fb">Op_Conv_Muscl_New_VEF_Face</a>, and <a class="el" href="classOp__Conv__Muscl__VEF__Face.html#a6a318d68701d364e340e0a18b5c0e20c">Op_Conv_Muscl_VEF_Face</a>.</p>

<p>Definition at line <a class="el" href="Op__Conv__VEF__Face_8cpp_source.html#l00029">29</a> of file <a class="el" href="Op__Conv__VEF__Face_8cpp_source.html">Op_Conv_VEF_Face.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0425dbae6b4c7a815392e6e4ae50861d"></a><!-- doxytag: member="Op_Conv_VEF_Face::taille_memoire" ref="a0425dbae6b4c7a815392e6e4ae50861d" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned Op_Conv_VEF_Face::taille_memoire </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implements <a class="el" href="classObjet__U.html#a0ee0946339f09a2c73c09fcda71c3be2">Objet_U</a>.</p>

<p>Reimplemented in <a class="el" href="classOp__Conv__Amont__VEF__Face.html#a4a5be9815ae05e6c56bdd7bcf5357c17">Op_Conv_Amont_VEF_Face</a>, <a class="el" href="classOp__Conv__Centre__VEF__Face.html#ac4e571ce03a31510e7e37375caadcbbb">Op_Conv_Centre_VEF_Face</a>, <a class="el" href="classOp__Conv__EF__VEF__P1NC__Stab.html#aa7fe145018f53089c26323d64b1cd808">Op_Conv_EF_VEF_P1NC_Stab</a>, <a class="el" href="classOp__Conv__Muscl3__VEF__Face.html#a6beefae08f030bc2a651c46bfa4689e7">Op_Conv_Muscl3_VEF_Face</a>, <a class="el" href="classOp__Conv__Muscl__New__VEF__Face.html#ac77cc14784ce355125d44a3af42dcba0">Op_Conv_Muscl_New_VEF_Face</a>, and <a class="el" href="classOp__Conv__Muscl__VEF__Face.html#a1e48a59646fff6b8449ec288cac7fa27">Op_Conv_Muscl_VEF_Face</a>.</p>

<p>Definition at line <a class="el" href="Op__Conv__VEF__Face_8cpp_source.html#l00029">29</a> of file <a class="el" href="Op__Conv__VEF__Face_8cpp_source.html">Op_Conv_VEF_Face.cpp</a>.</p>

</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="aebc1771cc4608fc51a8b6d15b93c8d3d"></a><!-- doxytag: member="Op_Conv_VEF_Face::alpha_" ref="aebc1771cc4608fc51a8b6d15b93c8d3d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classOp__Conv__VEF__Face.html#aebc1771cc4608fc51a8b6d15b93c8d3d">Op_Conv_VEF_Face::alpha_</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented in <a class="el" href="classOp__Conv__EF__VEF__P1NC__Stab.html#a515503fe50ac73fb7f86363fea4ee594">Op_Conv_EF_VEF_P1NC_Stab</a>, and <a class="el" href="classOp__Conv__Muscl__New__VEF__Face.html#aba93a9d2fdc68f373410c6439c95074c">Op_Conv_Muscl_New_VEF_Face</a>.</p>

<p>Definition at line <a class="el" href="Op__Conv__VEF__Face_8h_source.html#l00070">70</a> of file <a class="el" href="Op__Conv__VEF__Face_8h_source.html">Op_Conv_VEF_Face.h</a>.</p>

<p>Referenced by <a class="el" href="Op__Conv__VEF__Face_8cpp_source.html#l00121">ajouter()</a>, <a class="el" href="Op__Conv__VEF__Face_8cpp_source.html#l01369">get_alpha()</a>, <a class="el" href="Op__Conv__VEF__Face_8cpp_source.html#l00041">readOn()</a>, and <a class="el" href="Op__Conv__Muscl3__VEF__Face_8cpp_source.html#l00038">Op_Conv_Muscl3_VEF_Face::readOn()</a>.</p>

</div>
</div>
<a class="anchor" id="a17766a9e6e2a57fde63def2595fbc6ca"></a><!-- doxytag: member="Op_Conv_VEF_Face::est_une_face_de_dirichlet_" ref="a17766a9e6e2a57fde63def2595fbc6ca" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classArrOfInt.html">ArrOfInt</a> <a class="el" href="classOp__Conv__VEF__Face.html#a17766a9e6e2a57fde63def2595fbc6ca">Op_Conv_VEF_Face::est_une_face_de_dirichlet_</a><code> [mutable, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Op__Conv__VEF__Face_8h_source.html#l00076">76</a> of file <a class="el" href="Op__Conv__VEF__Face_8h_source.html">Op_Conv_VEF_Face.h</a>.</p>

<p>Referenced by <a class="el" href="Op__Conv__VEF__Face_8cpp_source.html#l00121">ajouter()</a>.</p>

</div>
</div>
<a class="anchor" id="ab04ee3b4166df4eea5ee4afa9bf25d43"></a><!-- doxytag: member="Op_Conv_VEF_Face::info_obj" ref="ab04ee3b4166df4eea5ee4afa9bf25d43" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classType__info.html">Type_info</a> <a class="el" href="classOp__Conv__VEF__Face.html#ab04ee3b4166df4eea5ee4afa9bf25d43">Op_Conv_VEF_Face::info_obj</a><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="classOp__Conv__VEF__base.html#a86d82f68e3374cf3786dec8249cd703d">Op_Conv_VEF_base</a>.</p>

<p>Reimplemented in <a class="el" href="classOp__Conv__Amont__VEF__Face.html#ae0a5580bb400fe293969db9853d06738">Op_Conv_Amont_VEF_Face</a>, <a class="el" href="classOp__Conv__Centre__VEF__Face.html#a323cafd8ea5ba3f822a46d52f141dc76">Op_Conv_Centre_VEF_Face</a>, <a class="el" href="classOp__Conv__EF__VEF__P1NC__Stab.html#a219062e7ce20f8e2d281c87823754ecf">Op_Conv_EF_VEF_P1NC_Stab</a>, <a class="el" href="classOp__Conv__Muscl3__VEF__Face.html#a4f6e131c44a7dbc88b6de69e449444c7">Op_Conv_Muscl3_VEF_Face</a>, <a class="el" href="classOp__Conv__Muscl__New__VEF__Face.html#a3de84e25f40003eae5fb33eaf0fde4b4">Op_Conv_Muscl_New_VEF_Face</a>, and <a class="el" href="classOp__Conv__Muscl__VEF__Face.html#a1f4bcc4e31deaaa0d9dfff3e7a2aeb2a">Op_Conv_Muscl_VEF_Face</a>.</p>

<p>Definition at line <a class="el" href="Op__Conv__VEF__Face_8h_source.html#l00047">47</a> of file <a class="el" href="Op__Conv__VEF__Face_8h_source.html">Op_Conv_VEF_Face.h</a>.</p>

</div>
</div>
<a class="anchor" id="a5a58e90633d9d06d20e898980ab9c4da"></a><!-- doxytag: member="Op_Conv_VEF_Face::LIMITEUR" ref="a5a58e90633d9d06d20e898980ab9c4da" args=")(double, double)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double(* <a class="el" href="classOp__Conv__VEF__Face.html#a5a58e90633d9d06d20e898980ab9c4da">Op_Conv_VEF_Face::LIMITEUR</a>)(double, double)<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Op__Conv__VEF__Face_8h_source.html#l00074">74</a> of file <a class="el" href="Op__Conv__VEF__Face_8h_source.html">Op_Conv_VEF_Face.h</a>.</p>

<p>Referenced by <a class="el" href="Op__Conv__VEF__Face_8cpp_source.html#l00041">readOn()</a>, <a class="el" href="Op__Conv__Muscl__VEF__Face_8cpp_source.html#l00038">Op_Conv_Muscl_VEF_Face::readOn()</a>, and <a class="el" href="Op__Conv__Muscl3__VEF__Face_8cpp_source.html#l00038">Op_Conv_Muscl3_VEF_Face::readOn()</a>.</p>

</div>
</div>
<a class="anchor" id="ad30e1a556295f226b7ef1215dc0030e5"></a><!-- doxytag: member="Op_Conv_VEF_Face::ordre" ref="ad30e1a556295f226b7ef1215dc0030e5" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classOp__Conv__VEF__Face.html#ad30e1a556295f226b7ef1215dc0030e5">Op_Conv_VEF_Face::ordre</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Op__Conv__VEF__Face_8h_source.html#l00069">69</a> of file <a class="el" href="Op__Conv__VEF__Face_8h_source.html">Op_Conv_VEF_Face.h</a>.</p>

<p>Referenced by <a class="el" href="Op__Conv__VEF__Face_8cpp_source.html#l00121">ajouter()</a>, <a class="el" href="Op__Conv__VEF__Face_8cpp_source.html#l01361">get_ordre()</a>, <a class="el" href="Op__Conv__VEF__Face_8cpp_source.html#l00041">readOn()</a>, <a class="el" href="Op__Conv__Muscl__VEF__Face_8cpp_source.html#l00038">Op_Conv_Muscl_VEF_Face::readOn()</a>, <a class="el" href="Op__Conv__Muscl3__VEF__Face_8cpp_source.html#l00038">Op_Conv_Muscl3_VEF_Face::readOn()</a>, <a class="el" href="Op__Conv__Centre__VEF__Face_8cpp_source.html#l00037">Op_Conv_Centre_VEF_Face::readOn()</a>, and <a class="el" href="Op__Conv__Amont__VEF__Face_8cpp_source.html#l00037">Op_Conv_Amont_VEF_Face::readOn()</a>.</p>

</div>
</div>
<a class="anchor" id="a4adb50fa6ba0bee8a6fbbc0a2655fe86"></a><!-- doxytag: member="Op_Conv_VEF_Face::traitement_pres_bord_" ref="a4adb50fa6ba0bee8a6fbbc0a2655fe86" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classArrOfInt.html">ArrOfInt</a> <a class="el" href="classOp__Conv__VEF__Face.html#a4adb50fa6ba0bee8a6fbbc0a2655fe86">Op_Conv_VEF_Face::traitement_pres_bord_</a><code> [mutable, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Op__Conv__VEF__Face_8h_source.html#l00075">75</a> of file <a class="el" href="Op__Conv__VEF__Face_8h_source.html">Op_Conv_VEF_Face.h</a>.</p>

<p>Referenced by <a class="el" href="Op__Conv__VEF__Face_8cpp_source.html#l00121">ajouter()</a>.</p>

</div>
</div>
<a class="anchor" id="a070e3e30a22b79bd58ac3bd36f7802f6"></a><!-- doxytag: member="Op_Conv_VEF_Face::type_lim" ref="a070e3e30a22b79bd58ac3bd36f7802f6" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMotcle.html">Motcle</a> <a class="el" href="classOp__Conv__VEF__Face.html#a070e3e30a22b79bd58ac3bd36f7802f6">Op_Conv_VEF_Face::type_lim</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Op__Conv__VEF__Face_8h_source.html#l00067">67</a> of file <a class="el" href="Op__Conv__VEF__Face_8h_source.html">Op_Conv_VEF_Face.h</a>.</p>

<p>Referenced by <a class="el" href="Op__Conv__VEF__Face_8cpp_source.html#l01365">get_type_lim()</a>, and <a class="el" href="Op__Conv__VEF__Face_8cpp_source.html#l00041">readOn()</a>.</p>

</div>
</div>
<a class="anchor" id="aac6bde5c9421ce149a3f28a11709b1f6"></a><!-- doxytag: member="Op_Conv_VEF_Face::type_op" ref="aac6bde5c9421ce149a3f28a11709b1f6" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOp__Conv__VEF__Face.html#abbf17549ccbad9c64780dcca7a3e2634">type_operateur</a> <a class="el" href="classOp__Conv__VEF__Face.html#aac6bde5c9421ce149a3f28a11709b1f6">Op_Conv_VEF_Face::type_op</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Op__Conv__VEF__Face_8h_source.html#l00072">72</a> of file <a class="el" href="Op__Conv__VEF__Face_8h_source.html">Op_Conv_VEF_Face.h</a>.</p>

<p>Referenced by <a class="el" href="Op__Conv__VEF__Face_8cpp_source.html#l00121">ajouter()</a>, <a class="el" href="Op__Conv__VEF__Face_8cpp_source.html#l01374">get_type_op()</a>, <a class="el" href="Op__Conv__VEF__Face_8cpp_source.html#l00041">readOn()</a>, <a class="el" href="Op__Conv__Muscl__VEF__Face_8cpp_source.html#l00038">Op_Conv_Muscl_VEF_Face::readOn()</a>, <a class="el" href="Op__Conv__Muscl3__VEF__Face_8cpp_source.html#l00038">Op_Conv_Muscl3_VEF_Face::readOn()</a>, <a class="el" href="Op__Conv__Centre__VEF__Face_8cpp_source.html#l00037">Op_Conv_Centre_VEF_Face::readOn()</a>, <a class="el" href="Op__Conv__Amont__VEF__Face_8cpp_source.html#l00037">Op_Conv_Amont_VEF_Face::readOn()</a>, and <a class="el" href="Op__Conv__VEF__Face_8cpp_source.html#l01149">remplir_fluent()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/VEF/Operateurs/<a class="el" href="Op__Conv__VEF__Face_8h_source.html">Op_Conv_VEF_Face.h</a></li>
<li>src/VEF/Operateurs/<a class="el" href="Op__Conv__VEF__Face_8cpp_source.html">Op_Conv_VEF_Face.cpp</a></li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Tue Dec 14 2021 19:37:17 for TRUST by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
