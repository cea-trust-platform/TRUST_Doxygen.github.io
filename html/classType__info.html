<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>TRUST: Type_info Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">TRUST&#160;<span id="projectnumber">1.8.4</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-static-methods">Static Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#pri-static-attribs">Static Private Attributes</a>  </div>
  <div class="headertitle">
<div class="title">Type_info Class Reference</div>  </div>
</div>
<div class="contents">
<!-- doxytag: class="Type_info" -->
<p>modelise une information de type pour les <a class="el" href="classObjet__U.html" title="classe Objet_U Cette classe est la classe de base des Objets de TRUST Dans les classes derivees de Ob...">Objet_U</a>  
 <a href="classType__info.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="Type__info_8h_source.html">Type_info.h</a>&gt;</code></p>

<p><a href="classType__info-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classType__info.html#a5e41818729985641c48e21c1c7d8caf5">~Type_info</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classType__info.html#a292e3a6795679e130c6a91b961fc38d1">Type_info</a> (const char *name, <a class="el" href="classObjet__U.html">Objet_U</a> *(*f)(), int nb_bases=0, const <a class="el" href="classType__info.html">Type_info</a> **bases=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructeur par un nom, une fonction et un tableau de meres.<br/>
La fonction permet de creer une instance du bon type.  <a href="#a292e3a6795679e130c6a91b961fc38d1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classType__info.html#ab843c96b5f8fa45d3fae40e6623fe5f0">Type_info</a> (const char *name, int nb_bases=0, const <a class="el" href="classType__info.html">Type_info</a> **bases=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructeur par un nom, un tableau de meres.  <a href="#ab843c96b5f8fa45d3fae40e6623fe5f0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classNom.html">Nom</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classType__info.html#a1aa9c21734c5750238f5502727866302">name</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classType__info.html#aa6a7edea86641de16fe5eb684c0484c3">can_cast</a> (const <a class="el" href="classType__info.html">Type_info</a> *p) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Exploration de la hierarchie des types<br/>
retourne 1 si p pointe sur un sous type du type considere.  <a href="#aa6a7edea86641de16fe5eb684c0484c3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classType__info.html#a1320edd811b44634a323248048f63a7e">same</a> (const <a class="el" href="classType__info.html">Type_info</a> *p) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Renvoie 1 si this==p, 0 sinon.  <a href="#a1320edd811b44634a323248048f63a7e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classType__info.html#a9c1b7c54c3bdbaf5dcea4492be021e6f">same</a> (const <a class="el" href="classNom.html">Nom</a> &amp;) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparaison sur le nom d'un type<br/>
Retourne 1 si les chaines de caracteres des noms du type considere et du nom indique sont identiques<br/>
Retour 0 sinon.  <a href="#a9c1b7c54c3bdbaf5dcea4492be021e6f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classType__info.html#ac61d373559ee51190d5caddaf26882e1">has_base</a> (const <a class="el" href="classType__info.html">Type_info</a> *p, int direct=0) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Test d'appartenance d'un type dans les types de bases du type considere<br/>
si direct == 0<br/>
renvoie 1 si (*p) fait partie des bases de (*this)<br/>
renvoie 0 sinon.<br/>
si direct != 0<br/>
renvoie 1 si (*p) fait partie des bases de (*this)<br/>
ou des meres directes ou non de (*this)<br/>
renvoie 0 sinon.  <a href="#ac61d373559ee51190d5caddaf26882e1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classType__info.html#add877771ae46e2e6e4b8982a1c2af7d5">has_base</a> (const <a class="el" href="classNom.html">Nom</a> &amp;, int direct=0) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Test d'appartenance d'un type dans les types de bases du type considere<br/>
Le type a rechercher est identifie par son nom<br/>
si direct == 0<br/>
renvoie 1 si le type de nom name fait partie des bases de (*this)<br/>
renvoie 0 sinon.<br/>
si direct != 0<br/>
renvoie 1 si le type de nom name fait partie des bases de (*this)<br/>
ou des meres directes ou non de (*this)<br/>
renvoie 0 sinon.  <a href="#add877771ae46e2e6e4b8982a1c2af7d5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSortie.html">Sortie</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classType__info.html#ac3159ec7adabda56a382e7d25d404f24">bases</a> (<a class="el" href="classSortie.html">Sortie</a> &amp;) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Ecriture des bases du type considere sur un flot de sortie.  <a href="#ac3159ec7adabda56a382e7d25d404f24"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classObjet__U.html">Objet_U</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classType__info.html#afa4b59a996405af3dbe9aa0167e43b61">instance</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Cree une instance de la classe associee au type_info.  <a href="#afa4b59a996405af3dbe9aa0167e43b61"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classType__info.html#ab62eec9a5f8d28944ec91317b9e89bbd">instanciable</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Renvoie 1 si le type associe est instanciable (cree_instance non nul)<br/>
renvoie 0 sinon.  <a href="#ab62eec9a5f8d28944ec91317b9e89bbd"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSortie.html">Sortie</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classType__info.html#aad48b1f59d3d7b01ce0cfe4592282fda">hierarchie</a> (<a class="el" href="classSortie.html">Sortie</a> &amp;)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Ecriture de toute la hierarchie du type considere sur un flix de sortie.  <a href="#aad48b1f59d3d7b01ce0cfe4592282fda"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classType__info.html#a88e7068fd06bbded90b11681f8efb384">est_un_type</a> (const char *)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Test d'existence d'une classe du type indique<br/>
si il existe une classe T dont le <a class="el" href="classType__info.html" title="modelise une information de type pour les Objet_U">Type_info</a> a<br/>
le nom nom, alors est_un_type renvoie 1<br/>
renvoie le pointeur nul sinon.  <a href="#a88e7068fd06bbded90b11681f8efb384"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classType__info.html#a28bcfaa023a518d5c4bc940dead669a4">les_sous_types</a> (const <a class="el" href="classNom.html">Nom</a> &amp;, <a class="el" href="classNoms.html">Noms</a> &amp;sous_types)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Donne les noms des sous-types, un type mere etant donne par son nom.  <a href="#a28bcfaa023a518d5c4bc940dead669a4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classType__info.html#a3ffac2b5d055fbc32d63fe370ccb3c78">les_sous_types</a> (const <a class="el" href="classType__info.html">Type_info</a> &amp;, <a class="el" href="classNoms.html">Noms</a> &amp;sous_types)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Donne les noms des sous-types, un type mere etant donne.  <a href="#a3ffac2b5d055fbc32d63fe370ccb3c78"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classType__info.html">Type_info</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classType__info.html#ab37d59e931ab9761812e24ed99842a43">type_info_from_name</a> (const char *type_name)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Methode statique qui renvoie un pointeur vers le <a class="el" href="classType__info.html" title="modelise une information de type pour les Objet_U">Type_info</a><br/>
dont le nom est "type_name". Si type_name n'est pas un type,<br/>
renvoie un pointeur nul.  <a href="#ab37d59e931ab9761812e24ed99842a43"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classObjet__U.html">Objet_U</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classType__info.html#ad1fa92e3f428801201d374f18875db5f">instance</a> (const char *typ)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Instanciation d'un <a class="el" href="classObjet__U.html" title="classe Objet_U Cette classe est la classe de base des Objets de TRUST Dans les classes derivees de Ob...">Objet_U</a> du type indique<br/>
S'il existe une classe T dont le <a class="el" href="classType__info.html" title="modelise une information de type pour les Objet_U">Type_info</a> a<br/>
le nom typ, alors instance renvoie un pointeur<br/>
sur une nouvelle instance de T.<br/>
renvoie le pointeur nul sinon.  <a href="#ad1fa92e3f428801201d374f18875db5f"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classType__info.html#a43a5965a12abe49965c00ccf1e220102">Type_info</a> (<a class="el" href="classType__info.html">Type_info</a> &amp;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classType__info.html">Type_info</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classType__info.html#ae68d88ce1f07b61947a8323a743bf8d8">operator=</a> (<a class="el" href="classType__info.html">Type_info</a> &amp;)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructeur par copie invalide.  <a href="#ae68d88ce1f07b61947a8323a743bf8d8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classType__info.html#aed129a24841aaac52a0da3b18d3a8a58">ajouter_type</a> (const <a class="el" href="classType__info.html">Type_info</a> &amp;type_info)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Methode statique appelee par les constructeurs de <a class="el" href="classType__info.html" title="modelise une information de type pour les Objet_U">Type_info</a> pour<br/>
ajouter un nouveau type a la liste des types enregistres.<br/>
Verifie que le nom du type n'existe pas encore.  <a href="#aed129a24841aaac52a0da3b18d3a8a58"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pri-static-methods"></a>
Static Private Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classType__info.html#a34add11ef2b9a1e0dc9c87c56eb69ae9">search_type_info_name</a> (const char *nom, int &amp;index)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Recherche le type de nom "nom" dans la liste de types enregistres<br/>
par une recherche binaire.<br/>
On compare les chaines converties en majuscules.<br/>
On range dans "index" l'indice du type, s'il a ete trouve<br/>
et sinon l'indice du type juste apres (dans ce cas, on a<br/>
les_types[index-1]-&gt;n &lt; nom &lt; les_types[index]-&gt;n )<br/>
Si le type a ete trouve on renvoie 1, sinon 0.  <a href="#a34add11ef2b9a1e0dc9c87c56eb69ae9"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classType__info.html#a162e9046f5d74583e6bd7c1746fca5c3">names_</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classNom.html">Nom</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classType__info.html#abf2205f043a8185bea074c55dee97d08">name_</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">(eg: A)  <a href="#abf2205f043a8185bea074c55dee97d08"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classNom.html">Nom</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classType__info.html#a5e2534805f58ee3e3ef5912a8827d33f">synonym_name_</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">(eg: B) Object synonym:  <a href="#a5e2534805f58ee3e3ef5912a8827d33f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSynonyme__info.html">Synonyme_info</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classType__info.html#ac1dda6db4d271c66f894e3b264093dbb">synonym_</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Synonym.  <a href="#ac1dda6db4d271c66f894e3b264093dbb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classType__info.html#a166fc5732d940399584c38f6fda3e203">nb_bases_</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classType__info.html">Type_info</a> **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classType__info.html#af658ff13a996a871f3640ec2e87cf49e">b</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classObjet__U.html">Objet_U</a> *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classType__info.html#af6e19128e6c8e3ffa1d28923b8053a46">cree_instance</a> )()</td></tr>
<tr><td colspan="2"><h2><a name="pri-static-attribs"></a>
Static Private Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classType__info.html">Type_info</a> **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classType__info.html#aa9bb33cd8086c236747314d048730a06">les_types</a> = 0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classType__info.html#aefa2e065733773d08b1d0fb853d66136">types_homonymes</a> = 0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classType__info.html#a1183245116dba3d760860eb376d7020e">nb_classes</a> = 0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classType__info.html#a6a41434bc3f14d2771eb8eaa2090c5ca">les_types_memsize</a> = 0</td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>modelise une information de type pour les <a class="el" href="classObjet__U.html" title="classe Objet_U Cette classe est la classe de base des Objets de TRUST Dans les classes derivees de Ob...">Objet_U</a> </p>

<p>Definition at line <a class="el" href="Type__info_8h_source.html#l00042">42</a> of file <a class="el" href="Type__info_8h_source.html">Type_info.h</a>.</p>
</div><hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a5e41818729985641c48e21c1c7d8caf5"></a><!-- doxytag: member="Type_info::~Type_info" ref="a5e41818729985641c48e21c1c7d8caf5" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Type_info::~Type_info </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Type__info_8cpp_source.html#l00074">74</a> of file <a class="el" href="Type__info_8cpp_source.html">Type_info.cpp</a>.</p>

<p>References <a class="el" href="Type__info_8h_source.html#l00097">les_types</a>, <a class="el" href="Type__info_8h_source.html#l00105">les_types_memsize</a>, <a class="el" href="Type__info_8h_source.html#l00049">name()</a>, <a class="el" href="Type__info_8h_source.html#l00082">name_</a>, <a class="el" href="Type__info_8h_source.html#l00102">nb_classes</a>, <a class="el" href="Type__info_8cpp_source.html#l00113">search_type_info_name()</a>, <a class="el" href="Type__info_8h_source.html#l00085">synonym_</a>, <a class="el" href="Type__info_8h_source.html#l00083">synonym_name_</a>, and <a class="el" href="Type__info_8h_source.html#l00100">types_homonymes</a>.</p>
<div class="fragment"><pre class="fragment">{
<span class="comment">// On cherche ou retirer le type dans le tableau :</span>
  <span class="keywordtype">int</span> index;
  <span class="keywordtype">int</span> existe_deja = <a class="code" href="classType__info.html#a34add11ef2b9a1e0dc9c87c56eb69ae9" title="Recherche le type de nom &quot;nom&quot; dans la liste de types enregistres par une recherche binaire...">search_type_info_name</a>(<a class="code" href="classType__info.html#a1aa9c21734c5750238f5502727866302">name</a>(), index);
  <span class="keywordflow">if</span> (existe_deja)
    {
      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = index; i&lt;<a class="code" href="classType__info.html#a1183245116dba3d760860eb376d7020e">nb_classes</a>-1; i++)
        {
          <a class="code" href="classType__info.html#aa9bb33cd8086c236747314d048730a06">les_types</a>[i] = <a class="code" href="classType__info.html#aa9bb33cd8086c236747314d048730a06">les_types</a>[i+1];
          <a class="code" href="classType__info.html#aefa2e065733773d08b1d0fb853d66136">types_homonymes</a>[i] = <a class="code" href="classType__info.html#aefa2e065733773d08b1d0fb853d66136">types_homonymes</a>[i+1];
        }
      nb_classes--;
    }
  <span class="keywordflow">if</span> (<a class="code" href="classType__info.html#abf2205f043a8185bea074c55dee97d08" title="(eg: A)">name_</a>)
    {
      <span class="keyword">delete</span> <a class="code" href="classType__info.html#abf2205f043a8185bea074c55dee97d08" title="(eg: A)">name_</a>;
      <a class="code" href="classType__info.html#abf2205f043a8185bea074c55dee97d08" title="(eg: A)">name_</a>=0;
      <span class="keyword">delete</span> <a class="code" href="classType__info.html#ac1dda6db4d271c66f894e3b264093dbb" title="Synonym.">synonym_</a>;
      <a class="code" href="classType__info.html#ac1dda6db4d271c66f894e3b264093dbb" title="Synonym.">synonym_</a>=0;
      <span class="keyword">delete</span> <a class="code" href="classType__info.html#a5e2534805f58ee3e3ef5912a8827d33f" title="(eg: B) Object synonym:">synonym_name_</a>;
      <a class="code" href="classType__info.html#a5e2534805f58ee3e3ef5912a8827d33f" title="(eg: B) Object synonym:">synonym_name_</a>=0;
    }
  <span class="keywordflow">if</span> ((<a class="code" href="classType__info.html#a1183245116dba3d760860eb376d7020e">nb_classes</a>==0)&amp;&amp; (<a class="code" href="classType__info.html#a6a41434bc3f14d2771eb8eaa2090c5ca">les_types_memsize</a>!=0))
    {
      <span class="keyword">delete</span> [] <a class="code" href="classType__info.html#aa9bb33cd8086c236747314d048730a06">les_types</a>;
      <span class="keyword">delete</span> [] <a class="code" href="classType__info.html#aefa2e065733773d08b1d0fb853d66136">types_homonymes</a>;
      <a class="code" href="classType__info.html#a6a41434bc3f14d2771eb8eaa2090c5ca">les_types_memsize</a>=0;
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a292e3a6795679e130c6a91b961fc38d1"></a><!-- doxytag: member="Type_info::Type_info" ref="a292e3a6795679e130c6a91b961fc38d1" args="(const char *name, Objet_U *(*f)(), int nb_bases=0, const Type_info **bases=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Type_info::Type_info </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classObjet__U.html">Objet_U</a> *(*)()&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nb_bases</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classType__info.html">Type_info</a> **&#160;</td>
          <td class="paramname"><em>bases</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructeur par un nom, une fonction et un tableau de meres.<br/>
La fonction permet de creer une instance du bon type. </p>

<p>Definition at line <a class="el" href="Type__info_8cpp_source.html#l00219">219</a> of file <a class="el" href="Type__info_8cpp_source.html">Type_info.cpp</a>.</p>

<p>References <a class="el" href="Type__info_8cpp_source.html#l00244">ajouter_type()</a>, <a class="el" href="EntreeSortie_8h_source.html#l00032">Cerr</a>, <a class="el" href="Process_8cpp_source.html#l00223">Process::exit()</a>, and <a class="el" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>.</p>
<div class="fragment"><pre class="fragment">                                                  :
  <a class="code" href="classType__info.html#a162e9046f5d74583e6bd7c1746fca5c3">names_</a>(un_nom),
  <a class="code" href="classType__info.html#abf2205f043a8185bea074c55dee97d08" title="(eg: A)">name_</a>((<a class="code" href="classNom.html" title="class Nom Une chaine de caractere pour nommer les objets de TRUST">Nom</a>*) 0),
  <a class="code" href="classType__info.html#a5e2534805f58ee3e3ef5912a8827d33f" title="(eg: B) Object synonym:">synonym_name_</a>((<a class="code" href="classNom.html" title="class Nom Une chaine de caractere pour nommer les objets de TRUST">Nom</a>*) 0),
  <a class="code" href="classType__info.html#a166fc5732d940399584c38f6fda3e203">nb_bases_</a>(nb_base),
  <a class="code" href="classType__info.html#af658ff13a996a871f3640ec2e87cf49e">b</a>(the_bases),
  <a class="code" href="classType__info.html#af6e19128e6c8e3ffa1d28923b8053a46">cree_instance</a>(f)
{
  <span class="keywordflow">if</span>(un_nom == 0)
    {
      <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Type_info::Type_info(const char* nom,Objet_U* (*f)()...)\n&quot;</span>;
      <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot; Error : name == 0&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
      assert(0);
      <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">Process::exit</a>();
    }
  <a class="code" href="classType__info.html#aed129a24841aaac52a0da3b18d3a8a58" title="Methode statique appelee par les constructeurs de Type_info pour ajouter un nouveau type a la liste d...">ajouter_type</a>(*<span class="keyword">this</span>);
}
</pre></div>
</div>
</div>
<a class="anchor" id="ab843c96b5f8fa45d3fae40e6623fe5f0"></a><!-- doxytag: member="Type_info::Type_info" ref="ab843c96b5f8fa45d3fae40e6623fe5f0" args="(const char *name, int nb_bases=0, const Type_info **bases=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Type_info::Type_info </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nb_bases</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classType__info.html">Type_info</a> **&#160;</td>
          <td class="paramname"><em>bases</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructeur par un nom, un tableau de meres. </p>

<p>Definition at line <a class="el" href="Type__info_8cpp_source.html#l00170">170</a> of file <a class="el" href="Type__info_8cpp_source.html">Type_info.cpp</a>.</p>

<p>References <a class="el" href="Type__info_8cpp_source.html#l00244">ajouter_type()</a>, <a class="el" href="EntreeSortie_8h_source.html#l00032">Cerr</a>, <a class="el" href="Process_8cpp_source.html#l00223">Process::exit()</a>, and <a class="el" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>.</p>
<div class="fragment"><pre class="fragment">                                                                                 :
  <a class="code" href="classType__info.html#a162e9046f5d74583e6bd7c1746fca5c3">names_</a>(un_nom),
  <a class="code" href="classType__info.html#abf2205f043a8185bea074c55dee97d08" title="(eg: A)">name_</a>((<a class="code" href="classNom.html" title="class Nom Une chaine de caractere pour nommer les objets de TRUST">Nom</a>*)0),
  <a class="code" href="classType__info.html#a5e2534805f58ee3e3ef5912a8827d33f" title="(eg: B) Object synonym:">synonym_name_</a>((<a class="code" href="classNom.html" title="class Nom Une chaine de caractere pour nommer les objets de TRUST">Nom</a>*) 0),
  <a class="code" href="classType__info.html#a166fc5732d940399584c38f6fda3e203">nb_bases_</a>(nb_base),
  <a class="code" href="classType__info.html#af658ff13a996a871f3640ec2e87cf49e">b</a>(the_bases),
  <a class="code" href="classType__info.html#af6e19128e6c8e3ffa1d28923b8053a46">cree_instance</a>(0)
{
  <span class="keywordflow">if</span>(un_nom == 0)
    {
      <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Type_info::Type_info(const char* nom,Objet_U* (*f)()...)\n&quot;</span>;
      <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot; Error : name == 0&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
      assert(0);
      <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">Process::exit</a>();
    }
  <a class="code" href="classType__info.html#aed129a24841aaac52a0da3b18d3a8a58" title="Methode statique appelee par les constructeurs de Type_info pour ajouter un nouveau type a la liste d...">ajouter_type</a>(*<span class="keyword">this</span>);
}
</pre></div>
</div>
</div>
<a class="anchor" id="a43a5965a12abe49965c00ccf1e220102"></a><!-- doxytag: member="Type_info::Type_info" ref="a43a5965a12abe49965c00ccf1e220102" args="(Type_info &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Type_info::Type_info </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classType__info.html">Type_info</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Type__info_8h_source.html#l00074">74</a> of file <a class="el" href="Type__info_8h_source.html">Type_info.h</a>.</p>
<div class="fragment"><pre class="fragment">{}; <span class="comment">//!&lt; Constructeur par copie invalide</span>
</pre></div>
</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="aed129a24841aaac52a0da3b18d3a8a58"></a><!-- doxytag: member="Type_info::ajouter_type" ref="aed129a24841aaac52a0da3b18d3a8a58" args="(const Type_info &amp;type_info)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Type_info::ajouter_type </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classType__info.html">Type_info</a> &amp;&#160;</td>
          <td class="paramname"><em>type_info</em></td><td>)</td>
          <td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Methode statique appelee par les constructeurs de <a class="el" href="classType__info.html" title="modelise une information de type pour les Objet_U">Type_info</a> pour<br/>
ajouter un nouveau type a la liste des types enregistres.<br/>
Verifie que le nom du type n'existe pas encore. </p>

<p><p>&lt; Start loop</p>
<p>&lt; End loop </p>
</p>

<p>Definition at line <a class="el" href="Type__info_8cpp_source.html#l00244">244</a> of file <a class="el" href="Type__info_8cpp_source.html">Type_info.cpp</a>.</p>

<p>References <a class="el" href="EntreeSortie_8h_source.html#l00032">Cerr</a>, <a class="el" href="Synonyme__info_8cpp_source.html#l00265">Synonyme_info::est_un_synonyme()</a>, <a class="el" href="Process_8cpp_source.html#l00223">Process::exit()</a>, <a class="el" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>, <a class="el" href="Nom_8h_source.html#l00088">Nom::getChar()</a>, <a class="el" href="Type__info_8h_source.html#l00097">les_types</a>, <a class="el" href="Type__info_8h_source.html#l00105">les_types_memsize</a>, <a class="el" href="Type__info_8h_source.html#l00049">name()</a>, <a class="el" href="Type__info_8h_source.html#l00082">name_</a>, <a class="el" href="Type__info_8h_source.html#l00080">names_</a>, <a class="el" href="Type__info_8h_source.html#l00102">nb_classes</a>, <a class="el" href="Type__info_8cpp_source.html#l00113">search_type_info_name()</a>, <a class="el" href="generique_8h_source.html#l00078">string_macro_trio</a>, <a class="el" href="Type__info_8h_source.html#l00085">synonym_</a>, <a class="el" href="Type__info_8h_source.html#l00083">synonym_name_</a>, and <a class="el" href="Type__info_8h_source.html#l00100">types_homonymes</a>.</p>

<p>Referenced by <a class="el" href="Type__info_8cpp_source.html#l00170">Type_info()</a>.</p>
<div class="fragment"><pre class="fragment">{
<span class="comment">// Split type_info.names_ into A if | is found (eg: n=A|B)</span>
<span class="comment">// and add a synonym B</span>
  <a class="code" href="classNom.html" title="class Nom Une chaine de caractere pour nommer les objets de TRUST">Nom</a> A(<span class="stringliteral">&quot;&quot;</span>);
  <a class="code" href="classNom.html" title="class Nom Une chaine de caractere pour nommer les objets de TRUST">Nom</a> B(<span class="stringliteral">&quot;&quot;</span>);
  <span class="keywordtype">int</span> synonym_found=0;
  <span class="keywordtype">int</span> i = 0;
  <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> c;
  <span class="keywordflow">do</span> <span class="comment">//!&lt; Start loop</span>
<span class="comment"></span>    {
      c = type_info.<a class="code" href="classType__info.html#a162e9046f5d74583e6bd7c1746fca5c3">names_</a>[i];
<span class="comment">// Find a |</span>
      <span class="keywordflow">if</span> (c==124)
        {
          <span class="keywordflow">if</span> (synonym_found==1)
            {
              <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;More than 1 synonym found in &quot;</span> &lt;&lt; type_info.<a class="code" href="classType__info.html#a162e9046f5d74583e6bd7c1746fca5c3">names_</a> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
              <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Not supported yet !&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
              <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">Process::exit</a>();
            }
          <span class="keywordflow">else</span>
            {
              synonym_found=1;
              i++;
              c = type_info.<a class="code" href="classType__info.html#a162e9046f5d74583e6bd7c1746fca5c3">names_</a>[i];
              <span class="keywordflow">if</span> (c==0)
                {
                  <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Error in a classname which can&#39;t finished by | : &quot;</span> &lt;&lt; type_info.<a class="code" href="classType__info.html#a162e9046f5d74583e6bd7c1746fca5c3">names_</a> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
                  <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">Process::exit</a>();
                }
            }
        }
<span class="comment">// Build the synonym name:</span>
      <span class="keywordflow">if</span> (synonym_found)
        B+=c;
      <span class="keywordflow">else</span>
        A+=c;
      i++;
    }
  <span class="keywordflow">while</span> (c!=0); <span class="comment">//!&lt; End loop</span>
<span class="comment"></span>
  <a class="code" href="classType__info.html#abf2205f043a8185bea074c55dee97d08" title="(eg: A)">name_</a> = <span class="keyword">new</span> <a class="code" href="classNom.html" title="class Nom Une chaine de caractere pour nommer les objets de TRUST">Nom</a>(A);
  <span class="keywordflow">if</span> (synonym_found)
    {
<span class="comment">// Commented cause too verbose:</span>
<span class="comment">// Cerr &lt;&lt; &quot;Keyword &quot; &lt;&lt; A &lt;&lt; &quot; has a synonym: &quot; &lt;&lt; B &lt;&lt; finl;</span>
      <a class="code" href="classType__info.html#a5e2534805f58ee3e3ef5912a8827d33f" title="(eg: B) Object synonym:">synonym_name_</a> = <span class="keyword">new</span> <a class="code" href="classNom.html" title="class Nom Une chaine de caractere pour nommer les objets de TRUST">Nom</a>(B);
      <a class="code" href="classType__info.html#ac1dda6db4d271c66f894e3b264093dbb" title="Synonym.">synonym_</a> = <span class="keyword">new</span> <a class="code" href="classSynonyme__info.html" title="modelise une information de synonyme pour les Objet_U">Synonyme_info</a>(<a class="code" href="classType__info.html#a5e2534805f58ee3e3ef5912a8827d33f" title="(eg: B) Object synonym:">synonym_name_</a>-&gt;<a class="code" href="classNom.html#aa9f24bd3370b5f1c66666e65252eea05">getChar</a>(),<a class="code" href="classType__info.html#abf2205f043a8185bea074c55dee97d08" title="(eg: A)">name_</a>-&gt;<a class="code" href="classNom.html#aa9f24bd3370b5f1c66666e65252eea05">getChar</a>());
    }
<span class="comment">// Verifie qu&#39;il y a assez de place dans le tableau :</span>
  <span class="keywordflow">if</span> (<a class="code" href="classType__info.html#a6a41434bc3f14d2771eb8eaa2090c5ca">les_types_memsize</a> &lt;= <a class="code" href="classType__info.html#a1183245116dba3d760860eb376d7020e">nb_classes</a> + 1)
    {
      <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> INCREMENT = 512;
<span class="comment">// Plus assez de place dans le tableau: on redimensionne.</span>
      <a class="code" href="classType__info.html#a6a41434bc3f14d2771eb8eaa2090c5ca">les_types_memsize</a> += INCREMENT;
      <span class="keyword">const</span> <a class="code" href="classType__info.html" title="modelise une information de type pour les Objet_U">Type_info</a>** nouveau = <span class="keyword">new</span> <span class="keyword">const</span> <a class="code" href="classType__info.html" title="modelise une information de type pour les Objet_U">Type_info</a>*[<a class="code" href="classType__info.html#a6a41434bc3f14d2771eb8eaa2090c5ca">les_types_memsize</a>];
      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; <a class="code" href="classType__info.html#a1183245116dba3d760860eb376d7020e">nb_classes</a>; j++)
        nouveau[j] = <a class="code" href="classType__info.html#aa9bb33cd8086c236747314d048730a06">les_types</a>[j];
      <span class="keyword">delete</span>[] <a class="code" href="classType__info.html#aa9bb33cd8086c236747314d048730a06">les_types</a>;
      <a class="code" href="classType__info.html#aa9bb33cd8086c236747314d048730a06">les_types</a> = nouveau;

      <span class="keywordtype">int</span> * temp = <span class="keyword">new</span> <span class="keywordtype">int</span>[<a class="code" href="classType__info.html#a6a41434bc3f14d2771eb8eaa2090c5ca">les_types_memsize</a>];
      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; <a class="code" href="classType__info.html#a1183245116dba3d760860eb376d7020e">nb_classes</a>; j++)
        temp[j] = <a class="code" href="classType__info.html#aefa2e065733773d08b1d0fb853d66136">types_homonymes</a>[j];
      <span class="keyword">delete</span>[] <a class="code" href="classType__info.html#aefa2e065733773d08b1d0fb853d66136">types_homonymes</a>;
      <a class="code" href="classType__info.html#aefa2e065733773d08b1d0fb853d66136">types_homonymes</a> = temp;
    }

<span class="comment">// On cherche ou mettre le type dans le tableau :</span>
  <span class="keywordtype">int</span> existe_deja=<a class="code" href="classSynonyme__info.html#a5cca36b7acd77f0a792fabc92f17ee87" title="Test d&#39;existence d&#39;une classe du synonyme indique si il existe une classe T dont le Synonyme_info a l...">Synonyme_info::est_un_synonyme</a>(type_info.<a class="code" href="classType__info.html#a1aa9c21734c5750238f5502727866302">name</a>());
  <span class="keywordflow">if</span> (existe_deja)
    {
      <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a>&lt;&lt;<span class="stringliteral">&quot; class &quot;</span>&lt;&lt;type_info.<a class="code" href="classType__info.html#a1aa9c21734c5750238f5502727866302">name</a>()&lt;&lt;<span class="stringliteral">&quot; already exists as a synonym which is forbidden!!!!&quot;</span>&lt;&lt;<a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
      <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">Process::exit</a>();
    }
  <span class="keywordtype">int</span> index;
  existe_deja = <a class="code" href="classType__info.html#a34add11ef2b9a1e0dc9c87c56eb69ae9" title="Recherche le type de nom &quot;nom&quot; dans la liste de types enregistres par une recherche binaire...">search_type_info_name</a>(type_info.<a class="code" href="classType__info.html#a1aa9c21734c5750238f5502727866302">name</a>(), index);
  <span class="keywordflow">if</span> (existe_deja)
    {
      <a class="code" href="classType__info.html#aefa2e065733773d08b1d0fb853d66136">types_homonymes</a>[index] = 1;
<span class="comment">// GF: si on a un homonyme que la macro string_macro_trio fonctionne</span>
<span class="comment">// on a un pb sauf pour les iterateurs</span>
      <span class="keywordflow">if</span> (strcmp(<a class="code" href="generique_8h.html#a2d139adfdc75efdde7ba4415f7b3c3d9">string_macro_trio</a>(<span class="stringliteral">&quot;VECT&quot;</span>,titi),<span class="stringliteral">&quot;VECT&quot;</span>))
        {
          <span class="keywordflow">if</span> (strncmp(type_info.<a class="code" href="classType__info.html#a1aa9c21734c5750238f5502727866302">name</a>(),<span class="stringliteral">&quot;Iterateur_&quot;</span>,10))
            {
              <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a>&lt;&lt;<span class="stringliteral">&quot; type &quot;</span>&lt;&lt;type_info.<a class="code" href="classType__info.html#a1aa9c21734c5750238f5502727866302">name</a>()&lt;&lt;<span class="stringliteral">&quot; is in double and it is not allowed!!!!&quot;</span>&lt;&lt;<a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
              <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">Process::exit</a>();
            }
        }
    }
  <span class="keywordflow">else</span>
    {
<span class="comment">// Ajout du type dans le tableau a l&#39;indice &quot;index&quot;:</span>
      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = nb_classes; j &gt; index; j--)
        {
          <a class="code" href="classType__info.html#aa9bb33cd8086c236747314d048730a06">les_types</a>[j] = <a class="code" href="classType__info.html#aa9bb33cd8086c236747314d048730a06">les_types</a>[j-1];
          <a class="code" href="classType__info.html#aefa2e065733773d08b1d0fb853d66136">types_homonymes</a>[j] = <a class="code" href="classType__info.html#aefa2e065733773d08b1d0fb853d66136">types_homonymes</a>[j-1];
        }
      <a class="code" href="classType__info.html#aa9bb33cd8086c236747314d048730a06">les_types</a>[index] = &amp;type_info;
      <a class="code" href="classType__info.html#aefa2e065733773d08b1d0fb853d66136">types_homonymes</a>[index] = 0;
      nb_classes++;
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="ac3159ec7adabda56a382e7d25d404f24"></a><!-- doxytag: member="Type_info::bases" ref="ac3159ec7adabda56a382e7d25d404f24" args="(Sortie &amp;) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSortie.html">Sortie</a> &amp; Type_info::bases </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSortie.html">Sortie</a> &amp;&#160;</td>
          <td class="paramname"><em>os</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Ecriture des bases du type considere sur un flot de sortie. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="classSortie.html" title="Classe de base des flux de sortie. Elle sait ecrire des types simples&lt;br&gt;(entiers, flottants) et des Ob...">Sortie</a>&amp;<br/>
 Signification: le flot de sortie modifie<br/>
 Contraintes: </dd></dl>

<p>Definition at line <a class="el" href="Type__info_8cpp_source.html#l00364">364</a> of file <a class="el" href="Type__info_8cpp_source.html">Type_info.cpp</a>.</p>

<p>References <a class="el" href="Type__info_8h_source.html#l00090">b</a>, <a class="el" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>, <a class="el" href="Type__info_8h_source.html#l00049">name()</a>, and <a class="el" href="Type__info_8h_source.html#l00088">nb_bases_</a>.</p>

<p>Referenced by <a class="el" href="Type__info_8cpp_source.html#l00386">hierarchie()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">int</span> i= <a class="code" href="classType__info.html#a166fc5732d940399584c38f6fda3e203">nb_bases_</a>;
  <span class="keywordflow">while</span>(i--)
    os &lt;&lt; <a class="code" href="classType__info.html#af658ff13a996a871f3640ec2e87cf49e">b</a>[i]-&gt;<a class="code" href="classType__info.html#a1aa9c21734c5750238f5502727866302">name</a>() &lt;&lt; <span class="stringliteral">&quot; &quot;</span>;
  <span class="keywordflow">return</span> os &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="aa6a7edea86641de16fe5eb684c0484c3"></a><!-- doxytag: member="Type_info::can_cast" ref="aa6a7edea86641de16fe5eb684c0484c3" args="(const Type_info *p) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Type_info::can_cast </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classType__info.html">Type_info</a> *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Exploration de la hierarchie des types<br/>
retourne 1 si p pointe sur un sous type du type considere. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>int<br/>
 Signification: 1 si p pointe sur un sous type du type considere, 0 sinon<br/>
 Contraintes: </dd></dl>

<p>Definition at line <a class="el" href="Type__info_8h_source.html#l00123">123</a> of file <a class="el" href="Type__info_8h_source.html">Type_info.h</a>.</p>

<p>References <a class="el" href="Type__info_8cpp_source.html#l00496">has_base()</a>, and <a class="el" href="Type__info_8cpp_source.html#l00582">same()</a>.</p>

<p>Referenced by <a class="el" href="O__U__Ptr_8cpp_source.html#l00148">O_U_Ptr::check_O_U_Ptr_type()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">return</span> ( (<a class="code" href="classType__info.html#a1320edd811b44634a323248048f63a7e" title="Renvoie 1 si this==p, 0 sinon.">same</a>(p)) || (p-&gt;<a class="code" href="classType__info.html#ac61d373559ee51190d5caddaf26882e1" title="Test d&#39;appartenance d&#39;un type dans les types de bases du type considere si direct == 0 renvoie 1 si (...">has_base</a>(<span class="keyword">this</span>)) );
}
</pre></div>
</div>
</div>
<a class="anchor" id="a88e7068fd06bbded90b11681f8efb384"></a><!-- doxytag: member="Type_info::est_un_type" ref="a88e7068fd06bbded90b11681f8efb384" args="(const char *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Type_info::est_un_type </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>nom</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Test d'existence d'une classe du type indique<br/>
si il existe une classe T dont le <a class="el" href="classType__info.html" title="modelise une information de type pour les Objet_U">Type_info</a> a<br/>
le nom nom, alors est_un_type renvoie 1<br/>
renvoie le pointeur nul sinon. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>int<br/>
 Signification: code de retour (0 ou 1)<br/>
 Contraintes: </dd></dl>

<p>Definition at line <a class="el" href="Type__info_8cpp_source.html#l00464">464</a> of file <a class="el" href="Type__info_8cpp_source.html">Type_info.cpp</a>.</p>

<p>References <a class="el" href="Type__info_8cpp_source.html#l00681">type_info_from_name()</a>.</p>

<p>Referenced by <a class="el" href="Synonyme__info_8cpp_source.html#l00185">Synonyme_info::ajouter_synonyme()</a>, and <a class="el" href="Type__info_8cpp_source.html#l00657">les_sous_types()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">const</span> <a class="code" href="classType__info.html" title="modelise une information de type pour les Objet_U">Type_info</a> * type = <a class="code" href="classType__info.html#ab37d59e931ab9761812e24ed99842a43" title="Methode statique qui renvoie un pointeur vers le Type_info dont le nom est &quot;type_name&quot;. Si type_name n&#39;est pas un type, renvoie un pointeur nul.">type_info_from_name</a>(nom);
  <span class="keywordflow">return</span> (type != 0);
}
</pre></div>
</div>
</div>
<a class="anchor" id="ac61d373559ee51190d5caddaf26882e1"></a><!-- doxytag: member="Type_info::has_base" ref="ac61d373559ee51190d5caddaf26882e1" args="(const Type_info *p, int direct=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Type_info::has_base </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classType__info.html">Type_info</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>direct</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Test d'appartenance d'un type dans les types de bases du type considere<br/>
si direct == 0<br/>
renvoie 1 si (*p) fait partie des bases de (*this)<br/>
renvoie 0 sinon.<br/>
si direct != 0<br/>
renvoie 1 si (*p) fait partie des bases de (*this)<br/>
ou des meres directes ou non de (*this)<br/>
renvoie 0 sinon. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>int<br/>
 Signification: code de retour (0 ou 1)<br/>
 Contraintes: </dd></dl>

<p>Definition at line <a class="el" href="Type__info_8cpp_source.html#l00496">496</a> of file <a class="el" href="Type__info_8cpp_source.html">Type_info.cpp</a>.</p>

<p>References <a class="el" href="Type__info_8h_source.html#l00090">b</a>, and <a class="el" href="Type__info_8h_source.html#l00088">nb_bases_</a>.</p>

<p>Referenced by <a class="el" href="Type__info_8h_source.html#l00123">can_cast()</a>, <a class="el" href="Zone__Cl__dis__base_8cpp_source.html#l00199">Zone_Cl_dis_base::contient_Cl()</a>, <a class="el" href="Type__info_8cpp_source.html#l00557">has_base()</a>, <a class="el" href="Type__info_8cpp_source.html#l00606">les_sous_types()</a>, <a class="el" href="Deriv___8cpp_source.html#l00091">Deriv_::typer()</a>, and <a class="el" href="Discretisation__base_8cpp_source.html#l00649">Discretisation_base::verifie_sous_type()</a>.</p>
<div class="fragment"><pre class="fragment">{
<span class="comment">// recherche de p-&gt;name() dans b</span>
<span class="comment">// si trouve return 1</span>
<span class="comment">// sinon si pas direct return 0;</span>
<span class="comment">// sinon recherche dans les bases de b</span>
<span class="comment">// Modif de B. Mathieu: test uniquement sur l&#39;adresse du type_info,</span>
<span class="comment">// pas sur le nom du type...</span>
  <span class="keywordflow">if</span> (p == 0)
    {
      <span class="keywordflow">return</span> 0;
    }
  <span class="keywordflow">else</span>
    {
      <span class="keywordflow">if</span> (p == <span class="keyword">this</span>)
        {
          <span class="keywordflow">return</span> 1;
        }
      <span class="keywordflow">else</span>
        {
          <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; <a class="code" href="classType__info.html#a166fc5732d940399584c38f6fda3e203">nb_bases_</a>; i++)
            <span class="keywordflow">if</span> (<a class="code" href="classType__info.html#af658ff13a996a871f3640ec2e87cf49e">b</a>[i] == p)
              <span class="keywordflow">return</span> 1;
          <span class="keywordflow">if</span> (!direct)
            {
<span class="comment">// Verifier les ancetres de niveau superieur</span>
              <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; <a class="code" href="classType__info.html#a166fc5732d940399584c38f6fda3e203">nb_bases_</a>; i++)
                <span class="keywordflow">if</span> (<a class="code" href="classType__info.html#af658ff13a996a871f3640ec2e87cf49e">b</a>[i]-&gt;<a class="code" href="classType__info.html#ac61d373559ee51190d5caddaf26882e1" title="Test d&#39;appartenance d&#39;un type dans les types de bases du type considere si direct == 0 renvoie 1 si (...">has_base</a>(p, direct)) <span class="keywordflow">return</span> 1;
            }
        }
    }
  <span class="keywordflow">return</span> 0;
}
</pre></div>
</div>
</div>
<a class="anchor" id="add877771ae46e2e6e4b8982a1c2af7d5"></a><!-- doxytag: member="Type_info::has_base" ref="add877771ae46e2e6e4b8982a1c2af7d5" args="(const Nom &amp;, int direct=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Type_info::has_base </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classNom.html">Nom</a> &amp;&#160;</td>
          <td class="paramname"><em>aname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>direct</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Test d'appartenance d'un type dans les types de bases du type considere<br/>
Le type a rechercher est identifie par son nom<br/>
si direct == 0<br/>
renvoie 1 si le type de nom name fait partie des bases de (*this)<br/>
renvoie 0 sinon.<br/>
si direct != 0<br/>
renvoie 1 si le type de nom name fait partie des bases de (*this)<br/>
ou des meres directes ou non de (*this)<br/>
renvoie 0 sinon. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>int<br/>
 Signification: code de retour (0 ou 1)<br/>
 Contraintes: </dd></dl>

<p>Definition at line <a class="el" href="Type__info_8cpp_source.html#l00557">557</a> of file <a class="el" href="Type__info_8cpp_source.html">Type_info.cpp</a>.</p>

<p>References <a class="el" href="Type__info_8cpp_source.html#l00496">has_base()</a>, and <a class="el" href="Type__info_8cpp_source.html#l00681">type_info_from_name()</a>.</p>
<div class="fragment"><pre class="fragment">{
<span class="comment">// recherche de aname dans b</span>
<span class="comment">// si trouve return 1</span>
<span class="comment">// sinon si pas direct return 0;</span>
<span class="comment">// sinon recherche dans les bases de b</span>
<span class="comment">// Modif B. Mathieu: comparaison des adresses du Type_info uniquement,</span>
<span class="comment">// pas du nom du type.</span>

  <span class="keyword">const</span> <a class="code" href="classType__info.html" title="modelise une information de type pour les Objet_U">Type_info</a> * type = <a class="code" href="classType__info.html#ab37d59e931ab9761812e24ed99842a43" title="Methode statique qui renvoie un pointeur vers le Type_info dont le nom est &quot;type_name&quot;. Si type_name n&#39;est pas un type, renvoie un pointeur nul.">type_info_from_name</a>(aname);
  <span class="keywordtype">int</span> resultat = <a class="code" href="classType__info.html#ac61d373559ee51190d5caddaf26882e1" title="Test d&#39;appartenance d&#39;un type dans les types de bases du type considere si direct == 0 renvoie 1 si (...">has_base</a>(type, direct);
  <span class="keywordflow">return</span> resultat;
}
</pre></div>
</div>
</div>
<a class="anchor" id="aad48b1f59d3d7b01ce0cfe4592282fda"></a><!-- doxytag: member="Type_info::hierarchie" ref="aad48b1f59d3d7b01ce0cfe4592282fda" args="(Sortie &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSortie.html">Sortie</a> &amp; Type_info::hierarchie </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSortie.html">Sortie</a> &amp;&#160;</td>
          <td class="paramname"><em>os</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Ecriture de toute la hierarchie du type considere sur un flix de sortie. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="classSortie.html" title="Classe de base des flux de sortie. Elle sait ecrire des types simples&lt;br&gt;(entiers, flottants) et des Ob...">Sortie</a>&amp;<br/>
 Signification: le flot de sortie modifie<br/>
 Contraintes: </dd></dl>

<p>Definition at line <a class="el" href="Type__info_8cpp_source.html#l00386">386</a> of file <a class="el" href="Type__info_8cpp_source.html">Type_info.cpp</a>.</p>

<p>References <a class="el" href="Type__info_8cpp_source.html#l00364">bases()</a>, <a class="el" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>, <a class="el" href="Type__info_8h_source.html#l00097">les_types</a>, <a class="el" href="Type__info_8h_source.html#l00049">name()</a>, and <a class="el" href="Type__info_8h_source.html#l00102">nb_classes</a>.</p>

<p>Referenced by <a class="el" href="Process_8cpp_source.html#l00228">Process::exit()</a>.</p>
<div class="fragment"><pre class="fragment">{
  os &lt;&lt; <span class="stringliteral">&quot;There is &quot;</span> &lt;&lt; <a class="code" href="classType__info.html#a1183245116dba3d760860eb376d7020e">nb_classes</a> &lt;&lt; <span class="stringliteral">&quot; classes:&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
  <span class="keywordtype">int</span> i= <a class="code" href="classType__info.html#a1183245116dba3d760860eb376d7020e">nb_classes</a>;
  <span class="keywordflow">while</span>(i--)
    {
      os &lt;&lt; <a class="code" href="classType__info.html#aa9bb33cd8086c236747314d048730a06">les_types</a>[i]-&gt;<a class="code" href="classType__info.html#a1aa9c21734c5750238f5502727866302">name</a>() &lt;&lt; <span class="stringliteral">&quot; inherits from &quot;</span>;
      <a class="code" href="classType__info.html#aa9bb33cd8086c236747314d048730a06">les_types</a>[i]-&gt;<a class="code" href="classType__info.html#ac3159ec7adabda56a382e7d25d404f24" title="Ecriture des bases du type considere sur un flot de sortie.">bases</a>(os);
    }
  <span class="keywordflow">return</span> os &lt;&lt; flush;
}
</pre></div>
</div>
</div>
<a class="anchor" id="afa4b59a996405af3dbe9aa0167e43b61"></a><!-- doxytag: member="Type_info::instance" ref="afa4b59a996405af3dbe9aa0167e43b61" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classObjet__U.html">Objet_U</a> * Type_info::instance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Cree une instance de la classe associee au type_info. </p>

<p>Definition at line <a class="el" href="Type__info_8cpp_source.html#l00434">434</a> of file <a class="el" href="Type__info_8cpp_source.html">Type_info.cpp</a>.</p>

<p>References <a class="el" href="EntreeSortie_8h_source.html#l00032">Cerr</a>, <a class="el" href="Type__info_8h_source.html#l00093">cree_instance</a>, <a class="el" href="Process_8cpp_source.html#l00223">Process::exit()</a>, <a class="el" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>, and <a class="el" href="Type__info_8h_source.html#l00049">name()</a>.</p>

<p>Referenced by <a class="el" href="Type__info_8cpp_source.html#l00417">instance()</a>, and <a class="el" href="Deriv___8cpp_source.html#l00091">Deriv_::typer()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">if</span> (<a class="code" href="classType__info.html#af6e19128e6c8e3ffa1d28923b8053a46">cree_instance</a> == 0)
    {
      <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Error in Type_info::instance()\n&quot;</span>;
      <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot; The type &quot;</span> &lt;&lt; <a class="code" href="classType__info.html#a1aa9c21734c5750238f5502727866302">name</a>() &lt;&lt; <span class="stringliteral">&quot; is not instantiable&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
      assert(0);
      <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">Process::exit</a>();
    }
  <a class="code" href="classObjet__U.html" title="classe Objet_U Cette classe est la classe de base des Objets de TRUST Dans les classes derivees de Ob...">Objet_U</a> * ainstance = (*cree_instance)();
  <span class="keywordflow">return</span> ainstance;
}
</pre></div>
</div>
</div>
<a class="anchor" id="ad1fa92e3f428801201d374f18875db5f"></a><!-- doxytag: member="Type_info::instance" ref="ad1fa92e3f428801201d374f18875db5f" args="(const char *typ)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classObjet__U.html">Objet_U</a> * Type_info::instance </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>typ</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Instanciation d'un <a class="el" href="classObjet__U.html" title="classe Objet_U Cette classe est la classe de base des Objets de TRUST Dans les classes derivees de Ob...">Objet_U</a> du type indique<br/>
S'il existe une classe T dont le <a class="el" href="classType__info.html" title="modelise une information de type pour les Objet_U">Type_info</a> a<br/>
le nom typ, alors instance renvoie un pointeur<br/>
sur une nouvelle instance de T.<br/>
renvoie le pointeur nul sinon. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Objet_U*<br/>
 Signification: pointeur sur un nouvel <a class="el" href="classObjet__U.html" title="classe Objet_U Cette classe est la classe de base des Objets de TRUST Dans les classes derivees de Ob...">Objet_U</a> du type typ<br/>
 Contraintes: </dd></dl>

<p>Definition at line <a class="el" href="Type__info_8cpp_source.html#l00417">417</a> of file <a class="el" href="Type__info_8cpp_source.html">Type_info.cpp</a>.</p>

<p>References <a class="el" href="Type__info_8cpp_source.html#l00434">instance()</a>, and <a class="el" href="Type__info_8cpp_source.html#l00681">type_info_from_name()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">const</span> <a class="code" href="classType__info.html" title="modelise une information de type pour les Objet_U">Type_info</a> * le_type = <a class="code" href="classType__info.html#ab37d59e931ab9761812e24ed99842a43" title="Methode statique qui renvoie un pointeur vers le Type_info dont le nom est &quot;type_name&quot;. Si type_name n&#39;est pas un type, renvoie un pointeur nul.">type_info_from_name</a>(typ);
  <a class="code" href="classObjet__U.html" title="classe Objet_U Cette classe est la classe de base des Objets de TRUST Dans les classes derivees de Ob...">Objet_U</a> * <a class="code" href="classType__info.html#afa4b59a996405af3dbe9aa0167e43b61" title="Cree une instance de la classe associee au type_info.">instance</a>;
  <span class="keywordflow">if</span> (le_type)
    instance = le_type-&gt;<a class="code" href="classType__info.html#afa4b59a996405af3dbe9aa0167e43b61" title="Cree une instance de la classe associee au type_info.">instance</a>();
  <span class="keywordflow">else</span>
    instance = 0;
  <span class="keywordflow">return</span> <a class="code" href="classType__info.html#afa4b59a996405af3dbe9aa0167e43b61" title="Cree une instance de la classe associee au type_info.">instance</a>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="ab62eec9a5f8d28944ec91317b9e89bbd"></a><!-- doxytag: member="Type_info::instanciable" ref="ab62eec9a5f8d28944ec91317b9e89bbd" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Type_info::instanciable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Renvoie 1 si le type associe est instanciable (cree_instance non nul)<br/>
renvoie 0 sinon. </p>

<p>Definition at line <a class="el" href="Type__info_8cpp_source.html#l00709">709</a> of file <a class="el" href="Type__info_8cpp_source.html">Type_info.cpp</a>.</p>

<p>References <a class="el" href="Type__info_8h_source.html#l00093">cree_instance</a>.</p>

<p>Referenced by <a class="el" href="Deriv___8cpp_source.html#l00091">Deriv_::typer()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">return</span> (<a class="code" href="classType__info.html#af6e19128e6c8e3ffa1d28923b8053a46">cree_instance</a> != 0);
}
</pre></div>
</div>
</div>
<a class="anchor" id="a3ffac2b5d055fbc32d63fe370ccb3c78"></a><!-- doxytag: member="Type_info::les_sous_types" ref="a3ffac2b5d055fbc32d63fe370ccb3c78" args="(const Type_info &amp;, Noms &amp;sous_types)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Type_info::les_sous_types </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classType__info.html">Type_info</a> &amp;&#160;</td>
          <td class="paramname"><em>mere</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classNoms.html">Noms</a> &amp;&#160;</td>
          <td class="paramname"><em>les_sous_types</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Donne les noms des sous-types, un type mere etant donne. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>int<br/>
 Signification: nombre de sous-types retournes<br/>
 Contraintes: </dd></dl>

<p>Definition at line <a class="el" href="Type__info_8cpp_source.html#l00606">606</a> of file <a class="el" href="Type__info_8cpp_source.html">Type_info.cpp</a>.</p>

<p>References <a class="el" href="EntreeSortie_8h_source.html#l00032">Cerr</a>, <a class="el" href="Memoire_8cpp_source.html#l00026">compteur</a>, <a class="el" href="vect__impl_8cpp_source.html#l00145">vect_impl::dimensionner()</a>, <a class="el" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>, <a class="el" href="Type__info_8cpp_source.html#l00496">has_base()</a>, <a class="el" href="Type__info_8h_source.html#l00097">les_types</a>, <a class="el" href="Type__info_8h_source.html#l00049">name()</a>, <a class="el" href="Type__info_8h_source.html#l00102">nb_classes</a>, and <a class="el" href="Type__info_8cpp_source.html#l00582">same()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">int</span> <a class="code" href="Memoire_8cpp.html#ade857a99d48bcb8cfaa57c4cd8d7d2e8">compteur</a>=0;
  <span class="keywordtype">int</span> i= <a class="code" href="classType__info.html#a1183245116dba3d760860eb376d7020e">nb_classes</a>;
<span class="comment">// Modif B. Mathieu: name() ne renvoie plus un static.</span>
  <span class="keyword">const</span> <a class="code" href="classNom.html" title="class Nom Une chaine de caractere pour nommer les objets de TRUST">Nom</a>&amp; nom_mere = mere.<a class="code" href="classType__info.html#a1aa9c21734c5750238f5502727866302">name</a>();
  <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;---------&quot;</span> &lt;&lt; (<span class="keyword">const</span> <span class="keywordtype">char</span>*) nom_mere &lt;&lt; finl;
  <span class="keywordflow">while</span>(i--)
    {
      <span class="keywordflow">if</span>( <a class="code" href="classType__info.html#aa9bb33cd8086c236747314d048730a06">les_types</a>[i]-&gt;<a class="code" href="classType__info.html#ac61d373559ee51190d5caddaf26882e1" title="Test d&#39;appartenance d&#39;un type dans les types de bases du type considere si direct == 0 renvoie 1 si (...">has_base</a>(nom_mere, 0) )
        <span class="keywordflow">if</span> (!<a class="code" href="classType__info.html#aa9bb33cd8086c236747314d048730a06">les_types</a>[i]-&gt;<a class="code" href="classType__info.html#a1320edd811b44634a323248048f63a7e" title="Renvoie 1 si this==p, 0 sinon.">same</a>(nom_mere))
          {
            compteur++;
          }
    }
  <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; compteur &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a> ;
  <span class="keywordflow">if</span>(compteur==0) <span class="keywordflow">return</span> 0;
  les_sous_types.<a class="code" href="classvect__impl.html#ad841d6b676a796bae26ed2566b7b3b41">dimensionner</a>(compteur);
  compteur=0;
  i= <a class="code" href="classType__info.html#a1183245116dba3d760860eb376d7020e">nb_classes</a>;
  <span class="keywordflow">while</span>(i--)
    {
      <span class="keywordflow">if</span>( <a class="code" href="classType__info.html#aa9bb33cd8086c236747314d048730a06">les_types</a>[i]-&gt;<a class="code" href="classType__info.html#ac61d373559ee51190d5caddaf26882e1" title="Test d&#39;appartenance d&#39;un type dans les types de bases du type considere si direct == 0 renvoie 1 si (...">has_base</a>(nom_mere, 0) )
        <span class="keywordflow">if</span> (!<a class="code" href="classType__info.html#aa9bb33cd8086c236747314d048730a06">les_types</a>[i]-&gt;<a class="code" href="classType__info.html#a1320edd811b44634a323248048f63a7e" title="Renvoie 1 si this==p, 0 sinon.">same</a>(nom_mere))
          {
            les_sous_types[compteur++]=<a class="code" href="classType__info.html#aa9bb33cd8086c236747314d048730a06">les_types</a>[i]-&gt;<a class="code" href="classType__info.html#a1aa9c21734c5750238f5502727866302">name</a>();
          }
    }
  <span class="keywordflow">return</span> <a class="code" href="Memoire_8cpp.html#ade857a99d48bcb8cfaa57c4cd8d7d2e8">compteur</a>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a28bcfaa023a518d5c4bc940dead669a4"></a><!-- doxytag: member="Type_info::les_sous_types" ref="a28bcfaa023a518d5c4bc940dead669a4" args="(const Nom &amp;, Noms &amp;sous_types)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Type_info::les_sous_types </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classNom.html">Nom</a> &amp;&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classNoms.html">Noms</a> &amp;&#160;</td>
          <td class="paramname"><em>sous_types</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Donne les noms des sous-types, un type mere etant donne par son nom. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>int<br/>
 Signification: nombre de sous-types retournes<br/>
 Contraintes: </dd></dl>

<p>Definition at line <a class="el" href="Type__info_8cpp_source.html#l00657">657</a> of file <a class="el" href="Type__info_8cpp_source.html">Type_info.cpp</a>.</p>

<p>References <a class="el" href="EntreeSortie_8h_source.html#l00032">Cerr</a>, <a class="el" href="Type__info_8cpp_source.html#l00464">est_un_type()</a>, <a class="el" href="Process_8cpp_source.html#l00223">Process::exit()</a>, <a class="el" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>, <a class="el" href="Type__info_8h_source.html#l00097">les_types</a>, <a class="el" href="Type__info_8h_source.html#l00102">nb_classes</a>, and <a class="el" href="Type__info_8cpp_source.html#l00582">same()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">if</span> (!<a class="code" href="classType__info.html#a88e7068fd06bbded90b11681f8efb384" title="Test d&#39;existence d&#39;une classe du type indique si il existe une classe T dont le Type_info a le nom no...">est_un_type</a>(type))
    {
      <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; type &lt;&lt; <span class="stringliteral">&quot;is not a type recognized by TRUST Unitaire &quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
      <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">Process::exit</a>();
    }
  <span class="keywordtype">int</span> i= <a class="code" href="classType__info.html#a1183245116dba3d760860eb376d7020e">nb_classes</a>;
  <span class="keywordflow">while</span>(i--)
    {
      <span class="keyword">const</span> <a class="code" href="classType__info.html" title="modelise une information de type pour les Objet_U">Type_info</a>&amp; mere = *<a class="code" href="classType__info.html#aa9bb33cd8086c236747314d048730a06">les_types</a>[i];
      <span class="keywordflow">if</span>( <a class="code" href="classType__info.html#aa9bb33cd8086c236747314d048730a06">les_types</a>[i]-&gt;<a class="code" href="classType__info.html#a1320edd811b44634a323248048f63a7e" title="Renvoie 1 si this==p, 0 sinon.">same</a>(type) )
        {
          <span class="keywordflow">return</span> <a class="code" href="classType__info.html#a28bcfaa023a518d5c4bc940dead669a4" title="Donne les noms des sous-types, un type mere etant donne par son nom.">les_sous_types</a>(mere, sous_types);
        }
    }
  <span class="keywordflow">return</span> 0;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a1aa9c21734c5750238f5502727866302"></a><!-- doxytag: member="Type_info::name" ref="a1aa9c21734c5750238f5502727866302" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classNom.html">Nom</a>&amp; Type_info::name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Type__info_8h_source.html#l00049">49</a> of file <a class="el" href="Type__info_8h_source.html">Type_info.h</a>.</p>

<p>References <a class="el" href="Type__info_8h_source.html#l00082">name_</a>.</p>

<p>Referenced by <a class="el" href="Type__info_8cpp_source.html#l00244">ajouter_type()</a>, <a class="el" href="Cast_8cpp_source.html#l00034">bad_ref_cast()</a>, <a class="el" href="Type__info_8cpp_source.html#l00364">bases()</a>, <a class="el" href="O__U__Ptr_8cpp_source.html#l00148">O_U_Ptr::check_O_U_Ptr_type()</a>, <a class="el" href="Type__info_8cpp_source.html#l00386">hierarchie()</a>, <a class="el" href="Type__info_8cpp_source.html#l00434">instance()</a>, <a class="el" href="Objet__U_8cpp_source.html#l00384">Objet_U::le_type()</a>, <a class="el" href="Type__info_8cpp_source.html#l00606">les_sous_types()</a>, <a class="el" href="Objet__U_8cpp_source.html#l00132">Objet_U::que_suis_je()</a>, <a class="el" href="Type__info_8cpp_source.html#l00575">same()</a>, <a class="el" href="Type__info_8cpp_source.html#l00113">search_type_info_name()</a>, <a class="el" href="Deriv___8cpp_source.html#l00091">Deriv_::typer()</a>, and <a class="el" href="Type__info_8cpp_source.html#l00074">~Type_info()</a>.</p>
<div class="fragment"><pre class="fragment">  {
    <span class="keywordflow">return</span> *<a class="code" href="classType__info.html#abf2205f043a8185bea074c55dee97d08" title="(eg: A)">name_</a>;
  };
</pre></div>
</div>
</div>
<a class="anchor" id="ae68d88ce1f07b61947a8323a743bf8d8"></a><!-- doxytag: member="Type_info::operator=" ref="ae68d88ce1f07b61947a8323a743bf8d8" args="(Type_info &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classType__info.html">Type_info</a>&amp; Type_info::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classType__info.html">Type_info</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructeur par copie invalide. </p>
<p>Operateur= invalide </p>

</div>
</div>
<a class="anchor" id="a1320edd811b44634a323248048f63a7e"></a><!-- doxytag: member="Type_info::same" ref="a1320edd811b44634a323248048f63a7e" args="(const Type_info *p) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Type_info::same </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classType__info.html">Type_info</a> *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Renvoie 1 si this==p, 0 sinon. </p>

<p>Definition at line <a class="el" href="Type__info_8cpp_source.html#l00582">582</a> of file <a class="el" href="Type__info_8cpp_source.html">Type_info.cpp</a>.</p>

<p>Referenced by <a class="el" href="Type__info_8h_source.html#l00123">can_cast()</a>, and <a class="el" href="Type__info_8cpp_source.html#l00606">les_sous_types()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">return</span> (<span class="keyword">this</span> == p);
}
</pre></div>
</div>
</div>
<a class="anchor" id="a9c1b7c54c3bdbaf5dcea4492be021e6f"></a><!-- doxytag: member="Type_info::same" ref="a9c1b7c54c3bdbaf5dcea4492be021e6f" args="(const Nom &amp;) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Type_info::same </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classNom.html">Nom</a> &amp;&#160;</td>
          <td class="paramname"><em>other_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Comparaison sur le nom d'un type<br/>
Retourne 1 si les chaines de caracteres des noms du type considere et du nom indique sont identiques<br/>
Retour 0 sinon. </p>

<p>Definition at line <a class="el" href="Type__info_8cpp_source.html#l00575">575</a> of file <a class="el" href="Type__info_8cpp_source.html">Type_info.cpp</a>.</p>

<p>References <a class="el" href="Type__info_8h_source.html#l00049">name()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">return</span> strcmp(<a class="code" href="classType__info.html#a1aa9c21734c5750238f5502727866302">name</a>(),other_name)==0;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a34add11ef2b9a1e0dc9c87c56eb69ae9"></a><!-- doxytag: member="Type_info::search_type_info_name" ref="a34add11ef2b9a1e0dc9c87c56eb69ae9" args="(const char *nom, int &amp;index)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Type_info::search_type_info_name </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>nom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Recherche le type de nom "nom" dans la liste de types enregistres<br/>
par une recherche binaire.<br/>
On compare les chaines converties en majuscules.<br/>
On range dans "index" l'indice du type, s'il a ete trouve<br/>
et sinon l'indice du type juste apres (dans ce cas, on a<br/>
les_types[index-1]-&gt;n &lt; nom &lt; les_types[index]-&gt;n )<br/>
Si le type a ete trouve on renvoie 1, sinon 0. </p>

<p>Definition at line <a class="el" href="Type__info_8cpp_source.html#l00113">113</a> of file <a class="el" href="Type__info_8cpp_source.html">Type_info.cpp</a>.</p>

<p>References <a class="el" href="Type__info_8h_source.html#l00097">les_types</a>, <a class="el" href="Type__info_8h_source.html#l00049">name()</a>, <a class="el" href="Type__info_8h_source.html#l00102">nb_classes</a>, and <a class="el" href="Type__info_8cpp_source.html#l00056">strcmp_uppercase()</a>.</p>

<p>Referenced by <a class="el" href="Type__info_8cpp_source.html#l00244">ajouter_type()</a>, <a class="el" href="Type__info_8cpp_source.html#l00681">type_info_from_name()</a>, and <a class="el" href="Type__info_8cpp_source.html#l00074">~Type_info()</a>.</p>
<div class="fragment"><pre class="fragment">{
  assert(nom != 0);
<span class="comment">// [imin..imax] est l&#39;intervalle ou se trouve l&#39;index recherche</span>
  <span class="keywordtype">int</span> imin = 0;
  <span class="keywordtype">int</span> imax = <a class="code" href="classType__info.html#a1183245116dba3d760860eb376d7020e">nb_classes</a>;
  <span class="keywordflow">while</span> (imax &gt; imin)
    {
<span class="comment">// On a toujours milieu &lt; imax</span>
      <span class="keywordtype">int</span> milieu = (imin + imax) / 2;
      <span class="keywordtype">int</span> comparaison = <a class="code" href="Type__info_8cpp.html#aa17622716dc89f97b11c93215fdbb311">strcmp_uppercase</a>(nom, <a class="code" href="classType__info.html#aa9bb33cd8086c236747314d048730a06">les_types</a>[milieu]-&gt;<a class="code" href="classType__info.html#a1aa9c21734c5750238f5502727866302">name</a>());
      <span class="keywordflow">if</span> (comparaison == 0)
        {
          index = milieu;
          <span class="keywordflow">return</span> 1;
        }
      <span class="keywordflow">if</span> (comparaison &lt; 0)
        {
<span class="comment">// nom &lt; les_types[milieu]</span>
<span class="comment">// l&#39;index recherche est donc inferieur ou egal a &quot;milieu&quot;</span>
          imax = milieu;
        }
      <span class="keywordflow">else</span>
        {
<span class="comment">// nom &gt; les_types[milieu]</span>
<span class="comment">// l&#39;index recherche est donc strictement superieur a &quot;milieu&quot;</span>
          imin = milieu + 1;
        }
    }
  index = imax;
  <span class="keywordflow">return</span> 0;
}
</pre></div>
</div>
</div>
<a class="anchor" id="ab37d59e931ab9761812e24ed99842a43"></a><!-- doxytag: member="Type_info::type_info_from_name" ref="ab37d59e931ab9761812e24ed99842a43" args="(const char *type_name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classType__info.html">Type_info</a> * Type_info::type_info_from_name </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>type_name</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Methode statique qui renvoie un pointeur vers le <a class="el" href="classType__info.html" title="modelise une information de type pour les Objet_U">Type_info</a><br/>
dont le nom est "type_name". Si type_name n'est pas un type,<br/>
renvoie un pointeur nul. </p>

<p>Definition at line <a class="el" href="Type__info_8cpp_source.html#l00681">681</a> of file <a class="el" href="Type__info_8cpp_source.html">Type_info.cpp</a>.</p>

<p>References <a class="el" href="EntreeSortie_8h_source.html#l00032">Cerr</a>, <a class="el" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>, <a class="el" href="Type__info_8h_source.html#l00097">les_types</a>, <a class="el" href="Type__info_8cpp_source.html#l00113">search_type_info_name()</a>, and <a class="el" href="Type__info_8h_source.html#l00100">types_homonymes</a>.</p>

<p>Referenced by <a class="el" href="Type__info_8cpp_source.html#l00464">est_un_type()</a>, <a class="el" href="Type__info_8cpp_source.html#l00557">has_base()</a>, <a class="el" href="Type__info_8cpp_source.html#l00417">instance()</a>, <a class="el" href="Deriv___8cpp_source.html#l00091">Deriv_::typer()</a>, and <a class="el" href="Discretisation__base_8cpp_source.html#l00649">Discretisation_base::verifie_sous_type()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">const</span> <a class="code" href="classType__info.html" title="modelise une information de type pour les Objet_U">Type_info</a> * type_info = 0;
  <span class="keywordflow">if</span> (type_name != 0)
    {
      <span class="keywordtype">int</span> index;
      <span class="keywordflow">if</span> (<a class="code" href="classType__info.html#a34add11ef2b9a1e0dc9c87c56eb69ae9" title="Recherche le type de nom &quot;nom&quot; dans la liste de types enregistres par une recherche binaire...">search_type_info_name</a>(type_name, index))
        {
          <span class="keywordflow">if</span> (<a class="code" href="classType__info.html#aefa2e065733773d08b1d0fb853d66136">types_homonymes</a>[index] == 0)
            {
              type_info = <a class="code" href="classType__info.html#aa9bb33cd8086c236747314d048730a06">les_types</a>[index];
            }
          <span class="keywordflow">else</span>
            {
<span class="comment">// Le type est enregistre mais le nom correspond</span>
<span class="comment">// a plusieurs types...</span>
              <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;const Type_info * Type_info::type_info_from_name(const char * type_name)\n&quot;</span>;
              <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot; The type &quot;</span> &lt;&lt; type_name &lt;&lt; <span class="stringliteral">&quot; has several homonymous\n&quot;</span>;
              <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot; We doing as if the type is unknown...&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
            }
        }
    }
  <span class="keywordflow">return</span> type_info;
}
</pre></div>
</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="af658ff13a996a871f3640ec2e87cf49e"></a><!-- doxytag: member="Type_info::b" ref="af658ff13a996a871f3640ec2e87cf49e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classType__info.html">Type_info</a>** <a class="el" href="classType__info.html#af658ff13a996a871f3640ec2e87cf49e">Type_info::b</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Type__info_8h_source.html#l00090">90</a> of file <a class="el" href="Type__info_8h_source.html">Type_info.h</a>.</p>

<p>Referenced by <a class="el" href="Type__info_8cpp_source.html#l00364">bases()</a>, and <a class="el" href="Type__info_8cpp_source.html#l00496">has_base()</a>.</p>

</div>
</div>
<a class="anchor" id="af6e19128e6c8e3ffa1d28923b8053a46"></a><!-- doxytag: member="Type_info::cree_instance" ref="af6e19128e6c8e3ffa1d28923b8053a46" args=")()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classObjet__U.html">Objet_U</a>*(* <a class="el" href="classType__info.html#af6e19128e6c8e3ffa1d28923b8053a46">Type_info::cree_instance</a>)()<code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Type__info_8h_source.html#l00093">93</a> of file <a class="el" href="Type__info_8h_source.html">Type_info.h</a>.</p>

<p>Referenced by <a class="el" href="Type__info_8cpp_source.html#l00434">instance()</a>, and <a class="el" href="Type__info_8cpp_source.html#l00709">instanciable()</a>.</p>

</div>
</div>
<a class="anchor" id="aa9bb33cd8086c236747314d048730a06"></a><!-- doxytag: member="Type_info::les_types" ref="aa9bb33cd8086c236747314d048730a06" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classType__info.html">Type_info</a> ** <a class="el" href="classType__info.html#aa9bb33cd8086c236747314d048730a06">Type_info::les_types</a> = 0<code> [static, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Type__info_8h_source.html#l00097">97</a> of file <a class="el" href="Type__info_8h_source.html">Type_info.h</a>.</p>

<p>Referenced by <a class="el" href="Type__info_8cpp_source.html#l00244">ajouter_type()</a>, <a class="el" href="Type__info_8cpp_source.html#l00386">hierarchie()</a>, <a class="el" href="Type__info_8cpp_source.html#l00606">les_sous_types()</a>, <a class="el" href="Type__info_8cpp_source.html#l00113">search_type_info_name()</a>, <a class="el" href="Type__info_8cpp_source.html#l00681">type_info_from_name()</a>, and <a class="el" href="Type__info_8cpp_source.html#l00074">~Type_info()</a>.</p>

</div>
</div>
<a class="anchor" id="a6a41434bc3f14d2771eb8eaa2090c5ca"></a><!-- doxytag: member="Type_info::les_types_memsize" ref="a6a41434bc3f14d2771eb8eaa2090c5ca" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classType__info.html#a6a41434bc3f14d2771eb8eaa2090c5ca">Type_info::les_types_memsize</a> = 0<code> [static, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Type__info_8h_source.html#l00105">105</a> of file <a class="el" href="Type__info_8h_source.html">Type_info.h</a>.</p>

<p>Referenced by <a class="el" href="Type__info_8cpp_source.html#l00244">ajouter_type()</a>, and <a class="el" href="Type__info_8cpp_source.html#l00074">~Type_info()</a>.</p>

</div>
</div>
<a class="anchor" id="abf2205f043a8185bea074c55dee97d08"></a><!-- doxytag: member="Type_info::name_" ref="abf2205f043a8185bea074c55dee97d08" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNom.html">Nom</a>* <a class="el" href="classType__info.html#abf2205f043a8185bea074c55dee97d08">Type_info::name_</a><code> [mutable, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>(eg: A) </p>

<p>Definition at line <a class="el" href="Type__info_8h_source.html#l00082">82</a> of file <a class="el" href="Type__info_8h_source.html">Type_info.h</a>.</p>

<p>Referenced by <a class="el" href="Type__info_8cpp_source.html#l00244">ajouter_type()</a>, <a class="el" href="Type__info_8h_source.html#l00049">name()</a>, and <a class="el" href="Type__info_8cpp_source.html#l00074">~Type_info()</a>.</p>

</div>
</div>
<a class="anchor" id="a162e9046f5d74583e6bd7c1746fca5c3"></a><!-- doxytag: member="Type_info::names_" ref="a162e9046f5d74583e6bd7c1746fca5c3" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* <a class="el" href="classType__info.html#a162e9046f5d74583e6bd7c1746fca5c3">Type_info::names_</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Type__info_8h_source.html#l00080">80</a> of file <a class="el" href="Type__info_8h_source.html">Type_info.h</a>.</p>

<p>Referenced by <a class="el" href="Type__info_8cpp_source.html#l00244">ajouter_type()</a>.</p>

</div>
</div>
<a class="anchor" id="a166fc5732d940399584c38f6fda3e203"></a><!-- doxytag: member="Type_info::nb_bases_" ref="a166fc5732d940399584c38f6fda3e203" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classType__info.html#a166fc5732d940399584c38f6fda3e203">Type_info::nb_bases_</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Type__info_8h_source.html#l00088">88</a> of file <a class="el" href="Type__info_8h_source.html">Type_info.h</a>.</p>

<p>Referenced by <a class="el" href="Type__info_8cpp_source.html#l00364">bases()</a>, and <a class="el" href="Type__info_8cpp_source.html#l00496">has_base()</a>.</p>

</div>
</div>
<a class="anchor" id="a1183245116dba3d760860eb376d7020e"></a><!-- doxytag: member="Type_info::nb_classes" ref="a1183245116dba3d760860eb376d7020e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classType__info.html#a1183245116dba3d760860eb376d7020e">Type_info::nb_classes</a> = 0<code> [static, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Type__info_8h_source.html#l00102">102</a> of file <a class="el" href="Type__info_8h_source.html">Type_info.h</a>.</p>

<p>Referenced by <a class="el" href="Type__info_8cpp_source.html#l00244">ajouter_type()</a>, <a class="el" href="Type__info_8cpp_source.html#l00386">hierarchie()</a>, <a class="el" href="Type__info_8cpp_source.html#l00606">les_sous_types()</a>, <a class="el" href="Type__info_8cpp_source.html#l00113">search_type_info_name()</a>, and <a class="el" href="Type__info_8cpp_source.html#l00074">~Type_info()</a>.</p>

</div>
</div>
<a class="anchor" id="ac1dda6db4d271c66f894e3b264093dbb"></a><!-- doxytag: member="Type_info::synonym_" ref="ac1dda6db4d271c66f894e3b264093dbb" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSynonyme__info.html">Synonyme_info</a>* <a class="el" href="classType__info.html#ac1dda6db4d271c66f894e3b264093dbb">Type_info::synonym_</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Synonym. </p>

<p>Definition at line <a class="el" href="Type__info_8h_source.html#l00085">85</a> of file <a class="el" href="Type__info_8h_source.html">Type_info.h</a>.</p>

<p>Referenced by <a class="el" href="Type__info_8cpp_source.html#l00244">ajouter_type()</a>, and <a class="el" href="Type__info_8cpp_source.html#l00074">~Type_info()</a>.</p>

</div>
</div>
<a class="anchor" id="a5e2534805f58ee3e3ef5912a8827d33f"></a><!-- doxytag: member="Type_info::synonym_name_" ref="a5e2534805f58ee3e3ef5912a8827d33f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNom.html">Nom</a>* <a class="el" href="classType__info.html#a5e2534805f58ee3e3ef5912a8827d33f">Type_info::synonym_name_</a><code> [mutable, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>(eg: B) Object synonym: </p>

<p>Definition at line <a class="el" href="Type__info_8h_source.html#l00083">83</a> of file <a class="el" href="Type__info_8h_source.html">Type_info.h</a>.</p>

<p>Referenced by <a class="el" href="Type__info_8cpp_source.html#l00244">ajouter_type()</a>, and <a class="el" href="Type__info_8cpp_source.html#l00074">~Type_info()</a>.</p>

</div>
</div>
<a class="anchor" id="aefa2e065733773d08b1d0fb853d66136"></a><!-- doxytag: member="Type_info::types_homonymes" ref="aefa2e065733773d08b1d0fb853d66136" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int * <a class="el" href="classType__info.html#aefa2e065733773d08b1d0fb853d66136">Type_info::types_homonymes</a> = 0<code> [static, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Type__info_8h_source.html#l00100">100</a> of file <a class="el" href="Type__info_8h_source.html">Type_info.h</a>.</p>

<p>Referenced by <a class="el" href="Type__info_8cpp_source.html#l00244">ajouter_type()</a>, <a class="el" href="Type__info_8cpp_source.html#l00681">type_info_from_name()</a>, and <a class="el" href="Type__info_8cpp_source.html#l00074">~Type_info()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/Kernel/Utilitaires/<a class="el" href="Type__info_8h_source.html">Type_info.h</a></li>
<li>src/Kernel/Utilitaires/<a class="el" href="Type__info_8cpp_source.html">Type_info.cpp</a></li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Tue Dec 14 2021 19:38:09 for TRUST by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
