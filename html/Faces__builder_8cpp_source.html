<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>TRUST: src/Kernel/Geometrie/Faces_builder.cpp Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">TRUST&#160;<span id="projectnumber">1.8.4</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
<div class="header">
  <div class="headertitle">
<div class="title">src/Kernel/Geometrie/Faces_builder.cpp</div>  </div>
</div>
<div class="contents">
<a href="Faces__builder_8cpp.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/****************************************************************************</span>
<a name="l00002"></a>00002 <span class="comment">* Copyright (c) 2019, CEA</span>
<a name="l00003"></a>00003 <span class="comment">* All rights reserved.</span>
<a name="l00004"></a>00004 <span class="comment">*</span>
<a name="l00005"></a>00005 <span class="comment">* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</span>
<a name="l00006"></a>00006 <span class="comment">* 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.</span>
<a name="l00007"></a>00007 <span class="comment">* 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.</span>
<a name="l00008"></a>00008 <span class="comment">* 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.</span>
<a name="l00009"></a>00009 <span class="comment">*</span>
<a name="l00010"></a>00010 <span class="comment">* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.</span>
<a name="l00011"></a>00011 <span class="comment">* IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;</span>
<a name="l00012"></a>00012 <span class="comment">* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>
<a name="l00013"></a>00013 <span class="comment">*</span>
<a name="l00014"></a>00014 <span class="comment">*****************************************************************************/</span>
<a name="l00015"></a>00015 <span class="comment">//</span>
<a name="l00016"></a>00016 <span class="comment">// </span>
<a name="l00017"></a>00017 <span class="comment">// File:        Faces_builder.cpp</span>
<a name="l00018"></a>00018 <span class="comment">// Directory:   $TRUST_ROOT/src/Kernel/Geometrie</span>
<a name="l00019"></a>00019 <span class="comment">// Version:     /main/41</span>
<a name="l00020"></a>00020 <span class="comment">// </span>
<a name="l00021"></a>00021 <span class="comment">//</span>
<a name="l00022"></a>00022 <span class="preprocessor">#include &lt;<a class="code" href="Faces__builder_8h.html">Faces_builder.h</a>&gt;</span>
<a name="l00023"></a>00023 <span class="preprocessor">#include &lt;<a class="code" href="IntTrav_8h.html">IntTrav.h</a>&gt;</span>
<a name="l00024"></a>00024 <span class="preprocessor">#include &lt;<a class="code" href="Domaine_8h.html">Domaine.h</a>&gt;</span>
<a name="l00025"></a>00025 <span class="preprocessor">#include &lt;<a class="code" href="LecFicDistribueBin_8h.html">LecFicDistribueBin.h</a>&gt;</span>
<a name="l00026"></a>00026 <span class="preprocessor">#include &lt;<a class="code" href="EcrFicCollecteBin_8h.html">EcrFicCollecteBin.h</a>&gt;</span>
<a name="l00027"></a>00027 <span class="preprocessor">#include &lt;<a class="code" href="Faces2_8h.html">Faces2.h</a>&gt;</span>
<a name="l00028"></a>00028 <span class="preprocessor">#include &lt;<a class="code" href="NettoieNoeuds_8h.html">NettoieNoeuds.h</a>&gt;</span>
<a name="l00029"></a>00029 <span class="preprocessor">#include &lt;<a class="code" href="Connectivite__som__elem_8h.html">Connectivite_som_elem.h</a>&gt;</span>
<a name="l00030"></a>00030 <span class="preprocessor">#include &lt;<a class="code" href="Scatter_8h.html">Scatter.h</a>&gt;</span>
<a name="l00031"></a>00031 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
<a name="l00032"></a>00032 <span class="preprocessor">#include &lt;<a class="code" href="Poly__geom__base_8h.html">Poly_geom_base.h</a>&gt;</span>
<a name="l00033"></a>00033 <span class="preprocessor">#include &lt;<a class="code" href="Elem__geom__base_8h.html">Elem_geom_base.h</a>&gt;</span>
<a name="l00034"></a>00034 <span class="preprocessor">#include &lt;<a class="code" href="MD__Vector__tools_8h.html">MD_Vector_tools.h</a>&gt;</span>
<a name="l00035"></a>00035 <span class="preprocessor">#include &lt;<a class="code" href="MD__Vector__std_8h.html">MD_Vector_std.h</a>&gt;</span>
<a name="l00036"></a>00036 <span class="preprocessor">#include &lt;<a class="code" href="Schema__Comm_8h.html">Schema_Comm.h</a>&gt;</span>
<a name="l00037"></a>00037 <span class="preprocessor">#include &lt;<a class="code" href="Array__tools_8h.html">Array_tools.h</a>&gt;</span>
<a name="l00038"></a>00038 <span class="preprocessor">#include &lt;<a class="code" href="communications_8h.html">communications.h</a>&gt;</span>
<a name="l00039"></a>00039 <span class="preprocessor">#include &lt;array&gt;</span>
<a name="l00040"></a>00040 <span class="preprocessor">#include &lt;vector&gt;</span>
<a name="l00041"></a>00041 <span class="preprocessor">#include &lt;map&gt;</span>
<a name="l00042"></a>00042 
<a name="l00043"></a><a class="code" href="classFaces__builder.html#a690953da7fca9b33ad10747f1c606cac">00043</a> <a class="code" href="classFaces__builder.html#a690953da7fca9b33ad10747f1c606cac">Faces_builder::Faces_builder</a>() :
<a name="l00044"></a>00044   les_elements_ptr_(0),
<a name="l00045"></a>00045   connectivite_som_elem_ptr_(0),
<a name="l00046"></a>00046   is_polyedre_(-1)
<a name="l00047"></a>00047 {
<a name="l00048"></a>00048 }
<a name="l00049"></a>00049 
<a name="l00050"></a><a class="code" href="classFaces__builder.html#aecd26cae77aa00884a228ab14b57ddb8">00050</a> <span class="keywordtype">void</span> <a class="code" href="classFaces__builder.html#aecd26cae77aa00884a228ab14b57ddb8">Faces_builder::reset</a>()
<a name="l00051"></a>00051 {
<a name="l00052"></a>00052   <a class="code" href="classFaces__builder.html#ad20059c937f9dd87de32f49c15c60202">les_elements_ptr_</a> = 0;
<a name="l00053"></a>00053   <a class="code" href="classFaces__builder.html#a63465157f176a5ff77aba327d5438f14">connectivite_som_elem_ptr_</a> = 0;
<a name="l00054"></a>00054   <a class="code" href="classFaces__builder.html#a202081564197f53d95fe6a3a2ace2caa">faces_element_reference_old_</a>.<a class="code" href="classIntTab.html#ac66710ddde96fe2745f341a0166b3b34" title="met le tableau dans l&#39;etat obtenu par le constructeur par defaut voir IntVect::reset()">reset</a>();
<a name="l00055"></a>00055   <a class="code" href="classFaces__builder.html#a4da2e2efdd507fd9db4977dfad555fcf">ref_zone_</a>.<a class="code" href="classRef__.html#aefc8130f02e22c692853dd435cbd1c18" title="Annule la ref.">reset</a>();
<a name="l00056"></a>00056   <a class="code" href="classFaces__builder.html#ae34616daf8a3bff24ad1673b447e3655">faces_sommets_</a>.<a class="code" href="classRef__.html#aefc8130f02e22c692853dd435cbd1c18" title="Annule la ref.">reset</a>();
<a name="l00057"></a>00057   <a class="code" href="classFaces__builder.html#ae6a50f5e178055468ccd61d1b03dd496">face_elem_</a>.<a class="code" href="classRef__.html#aefc8130f02e22c692853dd435cbd1c18" title="Annule la ref.">reset</a>();
<a name="l00058"></a>00058 }
<a name="l00059"></a>00059 
<a name="l00060"></a>00060 <span class="comment">//</span>
<a name="l00061"></a>00061 <span class="comment">//</span>
<a name="l00062"></a>00062 <span class="comment">//</span>
<a name="l00063"></a>00063 <span class="comment">//</span>
<a name="l00064"></a>00064 <span class="comment">//</span>
<a name="l00065"></a>00065 <span class="comment">//</span>
<a name="l00066"></a>00066 <span class="comment">//</span>
<a name="l00067"></a>00067 <span class="comment">//</span>
<a name="l00068"></a>00068 <span class="comment">//</span><span class="comment"></span>
<a name="l00069"></a>00069 <span class="comment">//! A partir de la description des elements de la zone et des frontieres&lt;br&gt;(bords, raccords, faces internes et joints) :&lt;br&gt;Remplissage des structures suivantes:&lt;br&gt;- pour les frontieres de la zone: fixer_num_premiere_face&lt;br&gt;- les_faces.faces_sommets (faces reeles)&lt;br&gt;- les_faces.faces_voisins (faces reeles)&lt;br&gt;- elem_faces              (pour les faces reeles des elements reels)&lt;br&gt;(on initialise elem_faces de taille nb_elem_reels, nb_faces_par_elem)&lt;br&gt;- joints.items_communs(FACE)</span>
<a name="l00070"></a><a class="code" href="classFaces__builder.html#a5b48ba95888da226cbf702f677656ff6">00070</a> <span class="comment"></span><span class="keywordtype">void</span> <a class="code" href="classFaces__builder.html#a5b48ba95888da226cbf702f677656ff6" title="A partir de la description des elements de la zone et des frontieres&lt;br&gt;(bords, raccords, faces internes et joints) : Remplissage des structures suivantes: - pour les frontieres de la zone: fixer_num_premiere_face - les_faces.faces_sommets (faces reeles) - les_faces.faces_voisins (faces reeles) - elem_faces (pour les faces reeles des elements reels) (on initialise elem_faces de taille nb_elem_reels, nb_faces_par_elem) - joints.items_communs(FACE)">Faces_builder::creer_faces_reeles</a>(<a class="code" href="classZone.html" title="classe Zone Une Zone est un maillage compose d&#39;un ensemble d&#39;elements geometriques de meme type...">Zone</a>&amp; zone,
<a name="l00071"></a>00071                                        <span class="keyword">const</span> <a class="code" href="classStatic__Int__Lists.html" title="Cette classe permet de stocker des listes d&#39;entiers accessibles en temps constant. La taille des listes ne peut pas changer sans perdre le contenu (ce sont des listes statiques). Exemple: Static_Int_List l; ArrOfInt tailles(3); tailles[0] = 2; tailles[1] = 3; tailles[2] = 0; // On reserve la memoire pour trois listes de taille 2, 3 et 0: l.set_list_sizes(tailles); // On affecte une valeur au deuxieme element de la premiere liste: l.set_value(0,1,765); // Affiche la valeur Cout &lt;&lt; l(0,1);.">Static_Int_Lists</a>&amp; connect_som_elem,
<a name="l00072"></a>00072                                        <a class="code" href="classFaces.html" title="enum Type_Face Les differents types geometriques de faces.">Faces</a>&amp;   les_faces,
<a name="l00073"></a>00073                                        <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; elem_faces)
<a name="l00074"></a>00074 {
<a name="l00075"></a>00075   <a class="code" href="classFaces__builder.html#ad20059c937f9dd87de32f49c15c60202">les_elements_ptr_</a> = &amp; zone.<a class="code" href="classZone.html#ac115e8342be89afb882b7b61cc343267" title="Renvoie le tableau des sommets des elements.">les_elems</a>();
<a name="l00076"></a>00076 
<a name="l00077"></a>00077   <a class="code" href="classFaces__builder.html#a63465157f176a5ff77aba327d5438f14">connectivite_som_elem_ptr_</a> = &amp; connect_som_elem;
<a name="l00078"></a>00078 <span class="comment">// La connectivite doit contenir les sommets virtuels</span>
<a name="l00079"></a>00079   assert(connect_som_elem.<a class="code" href="classStatic__Int__Lists.html#a5872636466919b2cb8efe715c315d7ca" title="renvoie le nombre de listes stockees">get_nb_lists</a>() == zone.<a class="code" href="classZone.html#a01ed67af826d6045ef4eacfb87a663e8" title="Renvoie le nombre total de sommets de la zone. i.e. le nombre de sommets reels et virtuels sur le pro...">nb_som_tot</a>());
<a name="l00080"></a>00080 
<a name="l00081"></a>00081 <span class="comment">// Remplissage du tableau des faces de l&#39;element de reference</span>
<a name="l00082"></a>00082 
<a name="l00083"></a>00083   <a class="code" href="classFaces__builder.html#a8998f284fc8c1071af65de5ba552aed0">is_polyedre_</a>=0;
<a name="l00084"></a>00084   <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classPoly__geom__base.html" title=": class Poly_geom_base &lt;Description of class Poly_geom_base&gt;">Poly_geom_base</a>,zone.<a class="code" href="classZone.html#a18cf83cd0f9c368dcfa32fb802a0ac94" title="Renvoie un element geometrique du type de ceux qui constituent la zone. (version const)">type_elem</a>().<a class="code" href="classDeriv__Elem__geom__base.html#a384b487459a33f9f521fb16539ec81de">valeur</a>()))
<a name="l00085"></a>00085     {
<a name="l00086"></a>00086       is_polyedre_=1;
<a name="l00087"></a>00087     }
<a name="l00088"></a>00088   <span class="keywordflow">else</span>
<a name="l00089"></a>00089     zone.<a class="code" href="classZone.html#a18cf83cd0f9c368dcfa32fb802a0ac94" title="Renvoie un element geometrique du type de ceux qui constituent la zone. (version const)">type_elem</a>().<a class="code" href="classDeriv__Elem__geom__base.html#a384b487459a33f9f521fb16539ec81de">valeur</a>().<a class="code" href="classElem__geom__base.html#a9993267e98ef97472d3a5ef9c3c67882" title="remplit le tableau faces_som_local(i,j) qui donne pour 0 &lt;= i &lt; nb_faces() et 0 &lt;= j &lt; nb_som_face(i) le ...">get_tab_faces_sommets_locaux</a>(<a class="code" href="classFaces__builder.html#a202081564197f53d95fe6a3a2ace2caa">faces_element_reference_old_</a>);
<a name="l00090"></a>00090 <span class="comment">// Tableau de taille (nb_faces, nb_sommets par face),</span>
<a name="l00091"></a>00091 <span class="comment">// pour chaque face, les indices de ses sommets dans le domaine.</span>
<a name="l00092"></a>00092 <span class="comment">// L&#39;ordre des sommets est celui donne par l&#39;element de reference,</span>
<a name="l00093"></a>00093 <span class="comment">// pour celui des elements voisins de la face qui a le plus petit</span>
<a name="l00094"></a>00094 <span class="comment">// indice.</span>
<a name="l00095"></a>00095   <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; faces_sommets = les_faces.<a class="code" href="classFaces.html#a07b8d8db9e3d656b93a21a49c063430c">les_sommets</a>();
<a name="l00096"></a>00096 
<a name="l00097"></a>00097 <span class="comment">// Tableau de taille (nb_faces, 2) contenant pour chaque face</span>
<a name="l00098"></a>00098 <span class="comment">// les indices des deux elements voisins. Si &quot;i_face&quot; a un seul voisin,</span>
<a name="l00099"></a>00099 <span class="comment">// faces_voisins_(i_face, 1) = -1;</span>
<a name="l00100"></a>00100   <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; faces_voisins = les_faces.<a class="code" href="classFaces.html#af49c4448e67aa7c732c2cc1dc237b442" title="Renvoie le tableau des voisins (des faces).">voisins</a>();
<a name="l00101"></a>00101 
<a name="l00102"></a>00102 <span class="comment">// Initialisation des references utilisees dans check_erreur_faces</span>
<a name="l00103"></a>00103   <a class="code" href="classFaces__builder.html#ae34616daf8a3bff24ad1673b447e3655">faces_sommets_</a> = faces_sommets;
<a name="l00104"></a>00104   <a class="code" href="classFaces__builder.html#ae6a50f5e178055468ccd61d1b03dd496">face_elem_</a> = faces_voisins;
<a name="l00105"></a>00105   <a class="code" href="classFaces__builder.html#a4da2e2efdd507fd9db4977dfad555fcf">ref_zone_</a> = zone;
<a name="l00106"></a>00106 
<a name="l00107"></a>00107 <span class="comment">// Le tableau des faces des elements:</span>
<a name="l00108"></a>00108 <span class="comment">// dimension(0) = nombre d&#39;elements,</span>
<a name="l00109"></a>00109 <span class="comment">// dimension(1) = nombre de faces par element</span>
<a name="l00110"></a>00110 <span class="comment">// elem_faces(i,j) = indice de la face j de l&#39;element i dans les</span>
<a name="l00111"></a>00111 <span class="comment">// tableaux faces_sommets et faces_voisins</span>
<a name="l00112"></a>00112 <span class="comment">// (les faces de l&#39;element sont dans l&#39;ordre donne par faces_element_reference)</span>
<a name="l00113"></a>00113 <span class="comment">// espaces distants et virtuels appropries pour les elements</span>
<a name="l00114"></a>00114   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_elements          = <a class="code" href="classFaces__builder.html#a30ad4fbd88a8069b4cfd093d1da1116c">les_elements</a>().<a class="code" href="classIntTab.html#abc3b32c94925a82f69d5b153a356e359" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(0);
<a name="l00115"></a>00115   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_faces_par_element = <a class="code" href="classFaces__builder.html#aa173ce9252eff3fb6981b4c199137c32" title="redonne les faces pour un element, dans le cas des polyhedres cela depend du numero de l&#39;element...">faces_element_reference</a>(0).<a class="code" href="classIntTab.html#abc3b32c94925a82f69d5b153a356e359" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(0) ? <a class="code" href="classFaces__builder.html#aa173ce9252eff3fb6981b4c199137c32" title="redonne les faces pour un element, dans le cas des polyhedres cela depend du numero de l&#39;element...">faces_element_reference</a>(0).<a class="code" href="classIntTab.html#abc3b32c94925a82f69d5b153a356e359" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(0) : 4;
<a name="l00116"></a>00116   elem_faces.<a class="code" href="classIntTab.html#a22e6bed6826b3688d4d0181cbf3b7a38" title="Change la taille du vecteur (identique a resize_array() pour le traitement des anciennes valeurs et d...">resize</a>(nb_elements, nb_faces_par_element);
<a name="l00117"></a>00117   elem_faces = -1;
<a name="l00118"></a>00118 
<a name="l00119"></a>00119   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_sommets_par_face = <a class="code" href="classFaces__builder.html#aa173ce9252eff3fb6981b4c199137c32" title="redonne les faces pour un element, dans le cas des polyhedres cela depend du numero de l&#39;element...">faces_element_reference</a>(0).<a class="code" href="classIntTab.html#abc3b32c94925a82f69d5b153a356e359" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(0) ? <a class="code" href="classFaces__builder.html#aa173ce9252eff3fb6981b4c199137c32" title="redonne les faces pour un element, dans le cas des polyhedres cela depend du numero de l&#39;element...">faces_element_reference</a>(0).<a class="code" href="classIntTab.html#abc3b32c94925a82f69d5b153a356e359" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(1) : 3;
<a name="l00120"></a>00120 <span class="comment">// On ajoute chaque face avec resize(n+1,...), donc smart_resize:</span>
<a name="l00121"></a>00121 <span class="comment">// Calcul du nombre theorique de faces:</span>
<a name="l00122"></a>00122   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_faces_front = zone.<a class="code" href="classZone.html#adb3970b0289aa1b0a38772011fd5d915" title="Renvoie le nombre de faces frontiere de la zone du type specifie. C&#39;est la somme des nombres de bords...">nb_faces_frontiere</a>() + zone.<a class="code" href="classZone.html#aff77b437f8c58064cc80a3221a0b6130" title="Renvoie le nombre de joints de la zone.">nb_faces_joint</a>();
<a name="l00123"></a>00123   <span class="keywordtype">int</span> nb_faces_prevision = (nb_elements * nb_faces_par_element + nb_faces_front) / 2;
<a name="l00124"></a>00124   <span class="keywordflow">if</span> (is_polyedre_)
<a name="l00125"></a>00125     {
<a name="l00126"></a>00126 <span class="comment">// les faces sont toutes deja connues....</span>
<a name="l00127"></a>00127       <span class="keyword">const</span> <a class="code" href="classPoly__geom__base.html" title=": class Poly_geom_base &lt;Description of class Poly_geom_base&gt;">Poly_geom_base</a>&amp; poly=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classPoly__geom__base.html" title=": class Poly_geom_base &lt;Description of class Poly_geom_base&gt;">Poly_geom_base</a>,<a class="code" href="classFaces__builder.html#a4da2e2efdd507fd9db4977dfad555fcf">ref_zone_</a>-&gt;type_elem().<a class="code" href="classRef__Zone.html#ab4ba0de67809ff502efeb24c1e43bfe1">valeur</a>());
<a name="l00128"></a>00128       nb_faces_prevision=(poly.<a class="code" href="classPoly__geom__base.html#aa5aae399947d9858e81d2bd6c4edf812">get_somme_nb_faces_elem</a>()+ nb_faces_front) / 2;;
<a name="l00129"></a>00129     }
<a name="l00130"></a>00130 <span class="comment">// Allocation memoire pour le nombre de faces prevu pour eviter de reallouer</span>
<a name="l00131"></a>00131 <span class="comment">// de la memoire n fois (voir set_smart_resize)</span>
<a name="l00132"></a>00132   faces_sommets.<a class="code" href="classArrOfInt.html#a22d744bcd452d039580d1d9186f02b4e" title="Change le mode l&#39;allocation memoire: reallocation d&#39;un tableau a chaque changement de taille (flag = ...">set_smart_resize</a>(1);
<a name="l00133"></a>00133   faces_sommets.<a class="code" href="classIntTab.html#a22e6bed6826b3688d4d0181cbf3b7a38" title="Change la taille du vecteur (identique a resize_array() pour le traitement des anciennes valeurs et d...">resize</a>(nb_faces_prevision, nb_sommets_par_face);
<a name="l00134"></a>00134   faces_sommets.<a class="code" href="classIntTab.html#a22e6bed6826b3688d4d0181cbf3b7a38" title="Change la taille du vecteur (identique a resize_array() pour le traitement des anciennes valeurs et d...">resize</a>(0, nb_sommets_par_face);
<a name="l00135"></a>00135   faces_voisins.<a class="code" href="classArrOfInt.html#a22d744bcd452d039580d1d9186f02b4e" title="Change le mode l&#39;allocation memoire: reallocation d&#39;un tableau a chaque changement de taille (flag = ...">set_smart_resize</a>(1);
<a name="l00136"></a>00136   faces_voisins.<a class="code" href="classIntTab.html#a22e6bed6826b3688d4d0181cbf3b7a38" title="Change la taille du vecteur (identique a resize_array() pour le traitement des anciennes valeurs et d...">resize</a>(nb_faces_prevision, 2);
<a name="l00137"></a>00137   faces_voisins.<a class="code" href="classIntTab.html#a22e6bed6826b3688d4d0181cbf3b7a38" title="Change la taille du vecteur (identique a resize_array() pour le traitement des anciennes valeurs et d...">resize</a>(0, 2);
<a name="l00138"></a>00138 
<a name="l00139"></a>00139 <span class="comment">// ******** Traitement des frontieres **********</span>
<a name="l00140"></a>00140 <span class="comment">// attention, on initialise &quot;num_premiere_face&quot; pour les frontieres !</span>
<a name="l00141"></a>00141 
<a name="l00142"></a>00142 <span class="comment">// Creation des faces de bord</span>
<a name="l00143"></a>00143   {
<a name="l00144"></a>00144     <a class="code" href="classBords.html" title="Classe Bords Cette classe represente une liste d&#39;objets de type Bord.">Bords</a>&amp; bords = zone.<a class="code" href="classZone.html#a4bc04163903c004c5c1383eaa5fa844d" title="Renvoie la liste des bords de la zone. (version const)">faces_bord</a>();
<a name="l00145"></a>00145     <span class="keyword">const</span> <span class="keywordtype">int</span> n = bords.<a class="code" href="classliste.html#ab47f280662ff68f9aa2e00e50431c5dc" title="Renvoie la taille de la liste Une liste vide est de taille nulle.">size</a>();
<a name="l00146"></a>00146     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; n; i++)
<a name="l00147"></a>00147       {
<a name="l00148"></a>00148         <a class="code" href="classFrontiere.html" title="Classe Frontiere. Une Frontiere decrit une partie de la frontiere d&#39;une Zone, elle possede un Nom...">Frontiere</a>&amp; frontiere = bords[i];
<a name="l00149"></a>00149         <a class="code" href="classFaces__builder.html#a451a0948864cba2c5cc5022a2013c83c" title="Insere les faces de la frontiere donnee dans les trois tableaux, a la suite des faces deja presentes ...">creer_faces_frontiere</a>(1, <span class="comment">/* un element voisin par face */</span>
<a name="l00150"></a>00150                               frontiere,
<a name="l00151"></a>00151                               faces_sommets,
<a name="l00152"></a>00152                               faces_voisins,
<a name="l00153"></a>00153                               elem_faces);
<a name="l00154"></a>00154       }
<a name="l00155"></a>00155   }
<a name="l00156"></a>00156 <span class="comment">// Raccords</span>
<a name="l00157"></a>00157   {
<a name="l00158"></a>00158     <a class="code" href="classRaccords.html" title="Classe Raccords Cette represente une liste d&#39;objets de type Raccord.">Raccords</a>&amp; raccords = zone.<a class="code" href="classZone.html#ac2a20fe8fa5529c7eefd418b43c0131c" title="Renvoie la liste des racoords de la zone. (version const)">faces_raccord</a>();
<a name="l00159"></a>00159     <span class="keyword">const</span> <span class="keywordtype">int</span> n = raccords.<a class="code" href="classliste.html#ab47f280662ff68f9aa2e00e50431c5dc" title="Renvoie la taille de la liste Une liste vide est de taille nulle.">size</a>();
<a name="l00160"></a>00160     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; n; i++)
<a name="l00161"></a>00161       {
<a name="l00162"></a>00162         <a class="code" href="classFrontiere.html" title="Classe Frontiere. Une Frontiere decrit une partie de la frontiere d&#39;une Zone, elle possede un Nom...">Frontiere</a>&amp; frontiere = raccords[i].<a class="code" href="classList__Raccord.html#aa4dce0dae3e5e35c2a4faca1a2ce1bae" title="Retourne l&#39;Objet_U associe a la cellule de la liste.">valeur</a>();
<a name="l00163"></a>00163         <a class="code" href="classFaces__builder.html#a451a0948864cba2c5cc5022a2013c83c" title="Insere les faces de la frontiere donnee dans les trois tableaux, a la suite des faces deja presentes ...">creer_faces_frontiere</a>(1, <span class="comment">/* un element voisin par face */</span>
<a name="l00164"></a>00164                               frontiere,
<a name="l00165"></a>00165                               faces_sommets,
<a name="l00166"></a>00166                               faces_voisins,
<a name="l00167"></a>00167                               elem_faces);
<a name="l00168"></a>00168       }
<a name="l00169"></a>00169   }
<a name="l00170"></a>00170 
<a name="l00171"></a>00171 <span class="comment">// Faces de bord &quot;internes&quot;</span>
<a name="l00172"></a>00172   {
<a name="l00173"></a>00173     <a class="code" href="classFaces__Internes.html" title="Class Faces_Internes Cette classe represente une liste d&#39;objets de type Faces_Interne.">Faces_Internes</a>&amp; faces_int = zone.<a class="code" href="classZone.html#ad1d5f91adfa5e56003ce778cab9610e8" title="Renvoie la liste des faces internes de la zone. (version const)">faces_int</a>();
<a name="l00174"></a>00174     <span class="keyword">const</span> <span class="keywordtype">int</span> n = faces_int.<a class="code" href="classliste.html#ab47f280662ff68f9aa2e00e50431c5dc" title="Renvoie la taille de la liste Une liste vide est de taille nulle.">size</a>();
<a name="l00175"></a>00175     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; n; i++)
<a name="l00176"></a>00176       {
<a name="l00177"></a>00177         <a class="code" href="classFrontiere.html" title="Classe Frontiere. Une Frontiere decrit une partie de la frontiere d&#39;une Zone, elle possede un Nom...">Frontiere</a>&amp; frontiere = faces_int[i];
<a name="l00178"></a>00178         <a class="code" href="classFaces__builder.html#a451a0948864cba2c5cc5022a2013c83c" title="Insere les faces de la frontiere donnee dans les trois tableaux, a la suite des faces deja presentes ...">creer_faces_frontiere</a>(2, <span class="comment">/* deux elements voisin par face */</span>
<a name="l00179"></a>00179                               frontiere,
<a name="l00180"></a>00180                               faces_sommets,
<a name="l00181"></a>00181                               faces_voisins,
<a name="l00182"></a>00182                               elem_faces);
<a name="l00183"></a>00183       }
<a name="l00184"></a>00184 
<a name="l00185"></a>00185 <span class="comment">// On duplique les faces internes : pour chaque face qui a deux</span>
<a name="l00186"></a>00186 <span class="comment">// voisins, on cree une deuxieme face identique avec le deuxieme voisin,</span>
<a name="l00187"></a>00187 <span class="comment">// on efface le deuxieme voisin de la face d&#39;origine et on change</span>
<a name="l00188"></a>00188 <span class="comment">// la face voisins de deuxieme voisin:</span>
<a name="l00189"></a>00189     <span class="keywordflow">if</span> (n &gt; 0)
<a name="l00190"></a>00190       {
<a name="l00191"></a>00191         <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Faces_builder::creer_faces_reeles not coded for the internal faces of boundary&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
<a name="l00192"></a>00192         <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">Process::exit</a>();
<a name="l00193"></a>00193 <span class="comment">// A faire selon l&#39;ancienne version de zone2... et a tester !</span>
<a name="l00194"></a>00194       }
<a name="l00195"></a>00195   }
<a name="l00196"></a>00196 
<a name="l00197"></a>00197 <span class="comment">// Faces de joint</span>
<a name="l00198"></a>00198   {
<a name="l00199"></a>00199     <a class="code" href="classJoints.html" title="Classe Joints Cette classe represente une liste d&#39;objet de type Joint.">Joints</a>&amp; joints = zone.<a class="code" href="classZone.html#a16f273a76321d31435995cdad664285a" title="Renvoie la liste des joints de la zone. (version const)">faces_joint</a>();
<a name="l00200"></a>00200     <span class="keyword">const</span> <span class="keywordtype">int</span> n = joints.<a class="code" href="classliste.html#ab47f280662ff68f9aa2e00e50431c5dc" title="Renvoie la taille de la liste Une liste vide est de taille nulle.">size</a>();
<a name="l00201"></a>00201     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; n; i++)
<a name="l00202"></a>00202       {
<a name="l00203"></a>00203         <a class="code" href="classFrontiere.html" title="Classe Frontiere. Une Frontiere decrit une partie de la frontiere d&#39;une Zone, elle possede un Nom...">Frontiere</a>&amp; frontiere = joints[i];
<a name="l00204"></a>00204         <a class="code" href="classFaces__builder.html#a451a0948864cba2c5cc5022a2013c83c" title="Insere les faces de la frontiere donnee dans les trois tableaux, a la suite des faces deja presentes ...">creer_faces_frontiere</a>(2, <span class="comment">/* elements voisins par face */</span>
<a name="l00205"></a>00205                               frontiere,
<a name="l00206"></a>00206                               faces_sommets,
<a name="l00207"></a>00207                               faces_voisins,
<a name="l00208"></a>00208                               elem_faces);
<a name="l00209"></a>00209 <span class="comment">// Remplissage de items_communs(FACE)</span>
<a name="l00210"></a>00210 <span class="comment">// Les faces de joint sont dans le meme ordre en local et sur le voisin.</span>
<a name="l00211"></a>00211         <a class="code" href="classJoint.html" title="La classe Joint est une Frontiere qui contient les faces et les sommets de joint avec la zone PEvoisi...">Joint</a>&amp; joint = joints[i];
<a name="l00212"></a>00212         <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; indices_faces =
<a name="l00213"></a>00213           joint.<a class="code" href="classJoint.html#aa1c4d729a3017082d26907d82ad1d7de" title="Renvoie les informations de joint pour un type d&#39;item geometrique donne, pour remplissage des structu...">set_joint_item</a>(<a class="code" href="classJoint.html#a1e2d15d088c27c9b7b11c02bf4d2c926ab255b88987fc7f64c215c958cbe2af6b">Joint::FACE</a>).<a class="code" href="classJoint__Items.html#aa01c4601d506c658f4f1d45e66951ce0" title="Renvoie le tableau items_communs_ pour le remplir. (BM: ce tableau n&#39;est pas encore rempli)...">set_items_communs</a>();
<a name="l00214"></a>00214         <span class="keyword">const</span> <span class="keywordtype">int</span> nb_faces  = joint.<a class="code" href="classFrontiere.html#aa073fe9dbdddde59471ee7032b256aa2" title="Renvoie le nombre de faces de la frontiere.">nb_faces</a>();
<a name="l00215"></a>00215         indices_faces.<a class="code" href="classArrOfInt.html#a9b3afbb46b16870dbd36236c8935b535">resize_array</a>(nb_faces);
<a name="l00216"></a>00216         <span class="keyword">const</span> <span class="keywordtype">int</span> num_premiere_face = joint.<a class="code" href="classFrontiere.html#a2a41c319a1530c984c356121e5ca2383">num_premiere_face</a>();
<a name="l00217"></a>00217         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i2 = 0; i2 &lt; nb_faces; i2++)
<a name="l00218"></a>00218           indices_faces[i2] = num_premiere_face + i2;
<a name="l00219"></a>00219       }
<a name="l00220"></a>00220   }
<a name="l00221"></a>00221 
<a name="l00222"></a>00222 <span class="comment">// *********************************************</span>
<a name="l00223"></a>00223 <span class="comment">// Faces internes</span>
<a name="l00224"></a>00224 
<a name="l00225"></a>00225   <a class="code" href="classFaces__builder.html#ae52612e6c9aff57afbe490c910930516" title="Construction des faces interieures au domaine (faces qui ont deux voisins et qui ne sont pas des &quot;fac...">creer_faces_internes</a>(faces_sommets,
<a name="l00226"></a>00226                        elem_faces,
<a name="l00227"></a>00227                        faces_voisins);
<a name="l00228"></a>00228 
<a name="l00229"></a>00229 <span class="comment">// *********************************************</span>
<a name="l00230"></a>00230 <span class="comment">// C&#39;est fini: on verifie qu&#39;on a bien le nombre de faces prevu</span>
<a name="l00231"></a>00231   <span class="keywordflow">if</span> (faces_sommets.<a class="code" href="classIntTab.html#abc3b32c94925a82f69d5b153a356e359" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(0) != nb_faces_prevision)
<a name="l00232"></a>00232     {
<a name="l00233"></a>00233       <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Error in Faces_builder::creer_faces_reeles:\n&quot;</span>
<a name="l00234"></a>00234            &lt;&lt; <span class="stringliteral">&quot; number of faces does not match predicted number of faces.\n&quot;</span>
<a name="l00235"></a>00235            &lt;&lt; <span class="stringliteral">&quot; (problem with faces_internes ?)&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
<a name="l00236"></a>00236       <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">Process::exit</a>();
<a name="l00237"></a>00237     }
<a name="l00238"></a>00238 
<a name="l00239"></a>00239 <span class="comment">// RAZ attribut smart_resize des tableaux faces_sommets et faces_voisins.</span>
<a name="l00240"></a>00240   faces_sommets.<a class="code" href="classArrOfInt.html#a22d744bcd452d039580d1d9186f02b4e" title="Change le mode l&#39;allocation memoire: reallocation d&#39;un tableau a chaque changement de taille (flag = ...">set_smart_resize</a>(0);
<a name="l00241"></a>00241   faces_voisins.<a class="code" href="classArrOfInt.html#a22d744bcd452d039580d1d9186f02b4e" title="Change le mode l&#39;allocation memoire: reallocation d&#39;un tableau a chaque changement de taille (flag = ...">set_smart_resize</a>(0);
<a name="l00242"></a>00242 <span class="comment">// RAZ des attributs de la classe</span>
<a name="l00243"></a>00243   <a class="code" href="classFaces__builder.html#aecd26cae77aa00884a228ab14b57ddb8">reset</a>();
<a name="l00244"></a>00244 }
<a name="l00245"></a>00245 
<a name="l00246"></a>00246 <span class="comment">//</span><span class="comment"></span>
<a name="l00247"></a>00247 <span class="comment">//! methode outil pour creer_faces_frontiere et creer_faces_internes&lt;br&gt;(si liste non vide sur au moins un processeur, affiche un message et exit()).</span>
<a name="l00248"></a><a class="code" href="classFaces__builder.html#a2a1241fa1f4adf443332bd7440e9472f">00248</a> <span class="comment"></span><span class="keywordtype">void</span> <a class="code" href="classFaces__builder.html#a2a1241fa1f4adf443332bd7440e9472f" title="methode outil pour creer_faces_frontiere et creer_faces_internes (si liste non vide sur au moins un p...">Faces_builder::check_erreur_faces</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> * <a class="code" href="Reordonner__faces__periodiques_8cpp.html#a137d78a01e63d3b66d1b2ed0de0f4c4c">message</a>,
<a name="l00249"></a>00249                                        <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; liste_faces)<span class="keyword"> const</span>
<a name="l00250"></a>00250 <span class="keyword"></span>{
<a name="l00251"></a>00251   <span class="keyword">const</span> <span class="keywordtype">int</span> nmax = 100;
<a name="l00252"></a>00252   <span class="keywordtype">int</span> n = liste_faces.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>();
<a name="l00253"></a>00253   <span class="keywordflow">if</span> (n &gt; 0)
<a name="l00254"></a>00254     {
<a name="l00255"></a>00255       <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;==========================&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
<a name="l00256"></a>00256       <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Error!&quot;</span> &lt;&lt; finl &lt;&lt; message
<a name="l00257"></a>00257            &lt;&lt; <span class="stringliteral">&quot;\nSee log file of this PE for detailed info.&quot;</span>
<a name="l00258"></a>00258            &lt;&lt; finl;
<a name="l00259"></a>00259       <a class="code" href="classSortie.html" title="Classe de base des flux de sortie. Elle sait ecrire des types simples&lt;br&gt;(entiers, flottants) et des Ob...">Sortie</a>&amp; J = <a class="code" href="classProcess.html#a57e0f54b11e6eaadbea224fa904b18dd" title="Renvoie un objet statique de type Sortie qui sert de journal d&#39;evenements. Si message_level &lt;= verbose...">Process::Journal</a>();
<a name="l00260"></a>00260       J &lt;&lt;  <span class="stringliteral">&quot;Error in Faces_builder::creer_faces_*\n&quot;</span>
<a name="l00261"></a>00261         &lt;&lt; message &lt;&lt; finl;
<a name="l00262"></a>00262       <span class="keywordflow">if</span> (n &gt; nmax)
<a name="l00263"></a>00263         {
<a name="l00264"></a>00264           J &lt;&lt; <span class="stringliteral">&quot;Too many faces to display (&quot;</span> &lt;&lt; n &lt;&lt; <span class="stringliteral">&quot;) display only &quot;</span> &lt;&lt; nmax &lt;&lt; <span class="stringliteral">&quot; first faces&quot;</span> &lt;&lt; finl;
<a name="l00265"></a>00265           n = nmax;
<a name="l00266"></a>00266         }
<a name="l00267"></a>00267       <span class="keywordtype">int</span> i;
<a name="l00268"></a>00268       J &lt;&lt; <span class="stringliteral">&quot;Display format:\n&quot;</span>
<a name="l00269"></a>00269         &lt;&lt; <span class="stringliteral">&quot; facenumber = face index in faces_sommet array\n&quot;</span>
<a name="l00270"></a>00270         &lt;&lt; <span class="stringliteral">&quot; som1..som4 = node index\n&quot;</span>
<a name="l00271"></a>00271         &lt;&lt; <span class="stringliteral">&quot; elem1 elem2 = neighbouring element number\n&quot;</span>
<a name="l00272"></a>00272         &lt;&lt; <span class="stringliteral">&quot;facenumber som1 (x1 y1 z1) som2 (x2 y2 z2) [som3 (x3 y3 z3)...] elem1 elem2&quot;</span> &lt;&lt; finl;
<a name="l00273"></a>00273       <span class="keywordtype">char</span> s[1000];
<a name="l00274"></a>00274       <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; coord = <a class="code" href="classFaces__builder.html#a4da2e2efdd507fd9db4977dfad555fcf">ref_zone_</a>.<a class="code" href="classRef__Zone.html#ab4ba0de67809ff502efeb24c1e43bfe1">valeur</a>().<a class="code" href="classZone.html#a379ad2206b5a13a4f4f3df6d44c7546a" title="Renvoie le domaine dont la zone fait partie. (version const)">domaine</a>().<a class="code" href="classDomaine.html#aecd32c3eecc15cce7d1a0e468dadbf96" title="Renvoie le tableau des coordonnees des noeuds (sommets). (acces en lecture)">coord_sommets</a>();
<a name="l00275"></a>00275       <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp;     faces = <a class="code" href="classFaces__builder.html#ae34616daf8a3bff24ad1673b447e3655">faces_sommets_</a>.<a class="code" href="classRef__IntTab.html#a554cc94104fea2e3e62fb5d935d46166">valeur</a>();
<a name="l00276"></a>00276       <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp;     face_elem = <a class="code" href="classFaces__builder.html#ae6a50f5e178055468ccd61d1b03dd496">face_elem_</a>.<a class="code" href="classRef__IntTab.html#a554cc94104fea2e3e62fb5d935d46166">valeur</a>();
<a name="l00277"></a>00277       <span class="keyword">const</span> <span class="keywordtype">int</span> dim = <a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>;
<a name="l00278"></a>00278       <span class="keyword">const</span> <span class="keywordtype">int</span> nb_som_faces = faces.<a class="code" href="classIntTab.html#abc3b32c94925a82f69d5b153a356e359" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(1);
<a name="l00279"></a>00279       <span class="keywordflow">for</span> (i = 0; i &lt; n; i++)
<a name="l00280"></a>00280         {
<a name="l00281"></a>00281           <span class="keywordtype">char</span> *sptr = s;
<a name="l00282"></a>00282           <span class="keyword">const</span> <span class="keywordtype">int</span> iface = liste_faces[i];
<a name="l00283"></a>00283           sptr += sprintf(sptr, <span class="stringliteral">&quot;%4ld &quot;</span>,(<span class="keywordtype">long</span>) iface);
<a name="l00284"></a>00284           <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; nb_som_faces; j++)
<a name="l00285"></a>00285             {
<a name="l00286"></a>00286               <span class="keyword">const</span> <span class="keywordtype">int</span> isom = faces(iface,j);
<a name="l00287"></a>00287               sptr += sprintf(sptr, <span class="stringliteral">&quot;%5ld(&quot;</span>, (<span class="keywordtype">long</span>)isom);
<a name="l00288"></a>00288               <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k = 0; k &lt; dim; k++)
<a name="l00289"></a>00289                 <span class="keywordflow">if</span> (isom!=-1)
<a name="l00290"></a>00290                   sptr += sprintf(sptr, <span class="stringliteral">&quot;%10.6f&quot;</span>, coord(isom, k));
<a name="l00291"></a>00291               sptr += sprintf(sptr, <span class="stringliteral">&quot;)&quot;</span>);
<a name="l00292"></a>00292             }
<a name="l00293"></a>00293           sptr += sprintf(sptr, <span class="stringliteral">&quot;%4ld %4ld&quot;</span>, (<span class="keywordtype">long</span>)face_elem(iface,0),(<span class="keywordtype">long</span>) face_elem(iface,1));
<a name="l00294"></a>00294           J &lt;&lt; s &lt;&lt; finl;
<a name="l00295"></a>00295         }
<a name="l00296"></a>00296       <a class="code" href="classNettoieNoeuds.html#a56b05b201015e968fead33b89f743db7" title="regarde si on n&#39;a pas des noeuds doubles">NettoieNoeuds::verifie_noeuds</a>(<a class="code" href="classFaces__builder.html#a4da2e2efdd507fd9db4977dfad555fcf">ref_zone_</a>.<a class="code" href="classRef__Zone.html#ab4ba0de67809ff502efeb24c1e43bfe1">valeur</a>().<a class="code" href="classZone.html#a379ad2206b5a13a4f4f3df6d44c7546a" title="Renvoie le domaine dont la zone fait partie. (version const)">domaine</a>());
<a name="l00297"></a>00297       <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">Process::exit</a>();
<a name="l00298"></a>00298     }
<a name="l00299"></a>00299 }
<a name="l00300"></a>00300 <span class="comment"></span>
<a name="l00301"></a>00301 <span class="comment">//! ajoute une face reelle dans faces_sommets et faces_voisins.</span>
<a name="l00302"></a><a class="code" href="classFaces__builder.html#aacc718530a516ea356626f074b9e6bdc">00302</a> <span class="comment"></span><span class="keywordtype">int</span> <a class="code" href="classFaces__builder.html#aacc718530a516ea356626f074b9e6bdc" title="ajoute une face reelle dans faces_sommets et faces_voisins.">Faces_builder::ajouter_une_face</a>(<span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; une_face,
<a name="l00303"></a>00303                                     <span class="keyword">const</span> <span class="keywordtype">int</span> elem0,
<a name="l00304"></a>00304                                     <span class="keyword">const</span> <span class="keywordtype">int</span> elem1,
<a name="l00305"></a>00305                                     <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; faces_sommets,
<a name="l00306"></a>00306                                     <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; faces_voisins)
<a name="l00307"></a>00307 {
<a name="l00308"></a>00308   <span class="keywordtype">int</span> i;
<a name="l00309"></a>00309   <span class="keyword">const</span> <span class="keywordtype">int</span> num_new_face        = faces_sommets.<a class="code" href="classIntTab.html#abc3b32c94925a82f69d5b153a356e359" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(0);
<a name="l00310"></a>00310   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_sommets_par_face = faces_sommets.<a class="code" href="classIntTab.html#abc3b32c94925a82f69d5b153a356e359" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(1);
<a name="l00311"></a>00311   <span class="keyword">const</span> <span class="keywordtype">int</span> new_size = num_new_face + 1;
<a name="l00312"></a>00312 
<a name="l00313"></a>00313   assert(une_face.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() == nb_sommets_par_face);
<a name="l00314"></a>00314   faces_sommets.<a class="code" href="classIntTab.html#a22e6bed6826b3688d4d0181cbf3b7a38" title="Change la taille du vecteur (identique a resize_array() pour le traitement des anciennes valeurs et d...">resize</a>(new_size, nb_sommets_par_face);
<a name="l00315"></a>00315   <span class="keywordflow">for</span> (i = 0; i &lt; nb_sommets_par_face; i++)
<a name="l00316"></a>00316     faces_sommets(num_new_face, i) = une_face[i];
<a name="l00317"></a>00317 
<a name="l00318"></a>00318   faces_voisins.<a class="code" href="classIntTab.html#a22e6bed6826b3688d4d0181cbf3b7a38" title="Change la taille du vecteur (identique a resize_array() pour le traitement des anciennes valeurs et d...">resize</a>(new_size, 2);
<a name="l00319"></a>00319   faces_voisins(num_new_face, 0) = elem0;
<a name="l00320"></a>00320   faces_voisins(num_new_face, 1) = elem1;
<a name="l00321"></a>00321 
<a name="l00322"></a>00322   <span class="keywordflow">return</span> num_new_face;
<a name="l00323"></a>00323 }
<a name="l00324"></a>00324 
<a name="l00325"></a><a class="code" href="classFaces__builder.html#a17469d1ff2feae7d358abcccd2d67831">00325</a> <span class="keywordtype">int</span> <a class="code" href="classFaces__builder.html#a17469d1ff2feae7d358abcccd2d67831">Faces_builder::chercher_face_element</a>(<span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp;    elem_som,
<a name="l00326"></a>00326                                          <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp;    faces_element_ref,
<a name="l00327"></a>00327                                          <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; une_face,
<a name="l00328"></a>00328                                          <span class="keyword">const</span> <span class="keywordtype">int</span>     elem)
<a name="l00329"></a>00329 {
<a name="l00330"></a>00330 <span class="preprocessor">#ifdef old</span>
<a name="l00331"></a>00331 <span class="preprocessor"></span><span class="preprocessor">#ifndef NDEBUG</span>
<a name="l00332"></a>00332 <span class="preprocessor"></span>  <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> sommets_element(8);
<a name="l00333"></a>00333 <span class="preprocessor">#else</span>
<a name="l00334"></a>00334 <span class="preprocessor"></span>  <span class="keywordtype">int</span> sommets_element[8];
<a name="l00335"></a>00335 <span class="preprocessor">#endif</span>
<a name="l00336"></a>00336 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00337"></a>00337 <span class="preprocessor"></span>
<a name="l00338"></a>00338   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_sommets_par_element    = elem_som.<a class="code" href="classIntTab.html#abc3b32c94925a82f69d5b153a356e359" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(1);
<a name="l00339"></a>00339   <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> sommets_element(nb_sommets_par_element);
<a name="l00340"></a>00340   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_faces_element          = faces_element_ref.<a class="code" href="classIntTab.html#abc3b32c94925a82f69d5b153a356e359" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(0);
<a name="l00341"></a>00341   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_sommets_par_face       = faces_element_ref.<a class="code" href="classIntTab.html#abc3b32c94925a82f69d5b153a356e359" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(1);
<a name="l00342"></a>00342 <span class="comment">// assert(nb_sommets_par_element &lt;= 8);</span>
<a name="l00343"></a>00343 
<a name="l00344"></a>00344   <span class="keywordtype">int</span> i;
<a name="l00345"></a>00345   <span class="keywordflow">for</span> (i = 0; i &lt; nb_sommets_par_element; i++)
<a name="l00346"></a>00346     sommets_element[i] = elem_som(elem, i);
<a name="l00347"></a>00347 
<a name="l00348"></a>00348   <span class="keywordtype">int</span> i_face, i_som, i_som2;
<a name="l00349"></a>00349   <span class="keywordflow">for</span> (i_face = 0; i_face &lt; nb_faces_element; i_face++)
<a name="l00350"></a>00350     {
<a name="l00351"></a>00351       <span class="keywordflow">for</span> (i_som = 0; i_som &lt; nb_sommets_par_face; i_som++)
<a name="l00352"></a>00352         {
<a name="l00353"></a>00353           <span class="keyword">const</span> <span class="keywordtype">int</span> sommet_elem_ref = faces_element_ref(i_face, i_som);
<a name="l00354"></a>00354           <span class="keywordtype">int</span> sommet_domaine ;
<a name="l00355"></a>00355           <span class="keywordflow">if</span> (sommet_elem_ref==-1)
<a name="l00356"></a>00356             sommet_domaine=-1;
<a name="l00357"></a>00357           <span class="keywordflow">else</span>
<a name="l00358"></a>00358             sommet_domaine = sommets_element[sommet_elem_ref];
<a name="l00359"></a>00359 <span class="comment">// const int sommet_domaine = sommets_element[sommet_elem_ref];</span>
<a name="l00360"></a>00360           <span class="keywordflow">for</span> (i_som2 = 0; i_som2 &lt; nb_sommets_par_face; i_som2++)
<a name="l00361"></a>00361             <span class="keywordflow">if</span> (une_face[i_som2] == sommet_domaine) <span class="comment">//!&lt; si sommet trouve, stop</span>
<a name="l00362"></a>00362 <span class="comment"></span>              <span class="keywordflow">break</span>;
<a name="l00363"></a>00363           <span class="keywordflow">if</span> (i_som2 == nb_sommets_par_face) <span class="comment">//!&lt; si sommet non trouve, stop</span>
<a name="l00364"></a>00364 <span class="comment"></span>            <span class="keywordflow">break</span>;
<a name="l00365"></a>00365         }
<a name="l00366"></a>00366       <span class="keywordflow">if</span> (i_som == nb_sommets_par_face) <span class="comment">//!&lt; si tous les sommets ont ete trouves, stop</span>
<a name="l00367"></a>00367 <span class="comment"></span>        <span class="keywordflow">break</span>;
<a name="l00368"></a>00368     }
<a name="l00369"></a>00369   <span class="keywordflow">if</span> (i_face == nb_faces_element) <span class="comment">//!&lt; si face non trouvee</span>
<a name="l00370"></a>00370 <span class="comment"></span>    <span class="keywordflow">return</span> -1;
<a name="l00371"></a>00371   <span class="keywordflow">else</span>
<a name="l00372"></a>00372     <span class="keywordflow">return</span> i_face;
<a name="l00373"></a>00373 }
<a name="l00374"></a><a class="code" href="classFaces__builder.html#aa173ce9252eff3fb6981b4c199137c32">00374</a> <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; <a class="code" href="classFaces__builder.html#aa173ce9252eff3fb6981b4c199137c32" title="redonne les faces pour un element, dans le cas des polyhedres cela depend du numero de l&#39;element...">Faces_builder::faces_element_reference</a>(<span class="keywordtype">int</span> elem)<span class="keyword"> const</span>
<a name="l00375"></a>00375 <span class="keyword"></span>{
<a name="l00376"></a>00376   <span class="keywordflow">if</span> (<a class="code" href="classFaces__builder.html#a8998f284fc8c1071af65de5ba552aed0">is_polyedre_</a>==1 &amp;&amp; <a class="code" href="classFaces__builder.html#ad20059c937f9dd87de32f49c15c60202">les_elements_ptr_</a>-&gt;<a class="code" href="classIntTab.html#abc3b32c94925a82f69d5b153a356e359" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(0))
<a name="l00377"></a>00377     {
<a name="l00378"></a>00378       assert(<a class="code" href="classFaces__builder.html#a8998f284fc8c1071af65de5ba552aed0">is_polyedre_</a>==1);
<a name="l00379"></a>00379       <span class="keyword">const</span> <a class="code" href="classPoly__geom__base.html" title=": class Poly_geom_base &lt;Description of class Poly_geom_base&gt;">Poly_geom_base</a>&amp; poly=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classPoly__geom__base.html" title=": class Poly_geom_base &lt;Description of class Poly_geom_base&gt;">Poly_geom_base</a>,<a class="code" href="classFaces__builder.html#a4da2e2efdd507fd9db4977dfad555fcf">ref_zone_</a>-&gt;type_elem().<a class="code" href="classRef__Zone.html#ab4ba0de67809ff502efeb24c1e43bfe1">valeur</a>());
<a name="l00380"></a>00380       <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; elem_ref_mod=<a class="code" href="Cast_8h.html#ad3836a067c92103af8df5ad8f35959a6">ref_cast_non_const</a>(<a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>,<a class="code" href="classFaces__builder.html#a202081564197f53d95fe6a3a2ace2caa">faces_element_reference_old_</a>);
<a name="l00381"></a>00381       poly.<a class="code" href="classPoly__geom__base.html#a1357e4033dba242d8a899bcb87d9f6f3" title="remplit le tableau faces_som_local(i,j) qui donne pour 0 &lt;= i &lt; nb_faces() et 0 &lt;= j &lt; nb_som_face(i) le ...">get_tab_faces_sommets_locaux</a>(elem_ref_mod,elem);
<a name="l00382"></a>00382 
<a name="l00383"></a>00383 <span class="comment">// abort();</span>
<a name="l00384"></a>00384 <span class="comment">// return faces_element_reference(0);</span>
<a name="l00385"></a>00385     }
<a name="l00386"></a>00386   <span class="keywordflow">return</span> <a class="code" href="classFaces__builder.html#a202081564197f53d95fe6a3a2ace2caa">faces_element_reference_old_</a>;
<a name="l00387"></a>00387 }
<a name="l00388"></a>00388 
<a name="l00389"></a>00389 
<a name="l00390"></a>00390 <span class="comment">//</span>
<a name="l00391"></a>00391 <span class="comment">//</span>
<a name="l00392"></a>00392 <span class="comment">//</span>
<a name="l00393"></a>00393 <span class="comment">//</span>
<a name="l00394"></a>00394 <span class="comment">//</span><span class="comment"></span>
<a name="l00395"></a>00395 <span class="comment">//! Methode outil: on suppose que &quot;une_face&quot; contient les indices&lt;br&gt;des sommets d&#39;une face de l&#39;element d&#39;indice &quot;elem&quot; dans la zone.&lt;br&gt;On cherche quel est le numero de cette face sur l&#39;element&lt;br&gt;de reference. Si les sommets ne correspondent a aucune face de&lt;br&gt;l&#39;element, on renvoie -1.</span>
<a name="l00396"></a><a class="code" href="classFaces__builder.html#ab381d2766eda537c836a664eff17f0d8">00396</a> <span class="comment"></span><span class="keywordtype">int</span> <a class="code" href="classFaces__builder.html#a17469d1ff2feae7d358abcccd2d67831">Faces_builder::chercher_face_element</a>(<span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; une_face,
<a name="l00397"></a>00397                                          <span class="keyword">const</span> <span class="keywordtype">int</span>     elem)<span class="keyword"> const</span>
<a name="l00398"></a>00398 <span class="keyword"></span>{
<a name="l00399"></a>00399   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; elem_som                = <a class="code" href="classFaces__builder.html#a30ad4fbd88a8069b4cfd093d1da1116c">les_elements</a>();
<a name="l00400"></a>00400   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; faces_element_ref       = <a class="code" href="classFaces__builder.html#aa173ce9252eff3fb6981b4c199137c32" title="redonne les faces pour un element, dans le cas des polyhedres cela depend du numero de l&#39;element...">faces_element_reference</a>(elem);
<a name="l00401"></a>00401   <span class="keywordtype">int</span> i_face = <a class="code" href="classFaces__builder.html#a17469d1ff2feae7d358abcccd2d67831">chercher_face_element</a>(elem_som, faces_element_ref, une_face, elem);
<a name="l00402"></a>00402   <span class="keywordflow">return</span> i_face;
<a name="l00403"></a>00403 }
<a name="l00404"></a>00404 
<a name="l00405"></a>00405 <span class="comment">//</span>
<a name="l00406"></a>00406 <span class="comment">//</span>
<a name="l00407"></a>00407 <span class="comment">//</span>
<a name="l00408"></a>00408 <span class="comment">//</span>
<a name="l00409"></a>00409 <span class="comment">//</span>
<a name="l00410"></a>00410 <span class="comment">//</span>
<a name="l00411"></a>00411 <span class="comment">//</span>
<a name="l00412"></a>00412 <span class="comment">//</span><span class="comment"></span>
<a name="l00413"></a>00413 <span class="comment">//! Insere les faces de la frontiere donnee dans les trois tableaux,&lt;br&gt;a la suite des faces deja presentes dans faces_sommets.&lt;br&gt;Remplissage de :&lt;br&gt;frontiere.num_premiere_face&lt;br&gt;Completion de :&lt;br&gt;faces_sommets&lt;br&gt;elem_faces&lt;br&gt;faces_voisins</span>
<a name="l00414"></a><a class="code" href="classFaces__builder.html#a451a0948864cba2c5cc5022a2013c83c">00414</a> <span class="comment"></span><span class="keywordtype">void</span> <a class="code" href="classFaces__builder.html#a451a0948864cba2c5cc5022a2013c83c" title="Insere les faces de la frontiere donnee dans les trois tableaux, a la suite des faces deja presentes ...">Faces_builder::creer_faces_frontiere</a>(<span class="keyword">const</span> <span class="keywordtype">int</span> nb_voisins_attendus,
<a name="l00415"></a>00415                                           <a class="code" href="classFrontiere.html" title="Classe Frontiere. Une Frontiere decrit une partie de la frontiere d&#39;une Zone, elle possede un Nom...">Frontiere</a>&amp;   frontiere,
<a name="l00416"></a>00416                                           <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; faces_sommets,
<a name="l00417"></a>00417                                           <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; faces_voisins,
<a name="l00418"></a>00418                                           <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; elem_faces)<span class="keyword"> const</span>
<a name="l00419"></a>00419 <span class="keyword"></span>{
<a name="l00420"></a>00420   assert(nb_voisins_attendus == 1 || nb_voisins_attendus == 2);
<a name="l00421"></a>00421 
<a name="l00422"></a>00422   <span class="keyword">const</span> <a class="code" href="classStatic__Int__Lists.html" title="Cette classe permet de stocker des listes d&#39;entiers accessibles en temps constant. La taille des listes ne peut pas changer sans perdre le contenu (ce sont des listes statiques). Exemple: Static_Int_List l; ArrOfInt tailles(3); tailles[0] = 2; tailles[1] = 3; tailles[2] = 0; // On reserve la memoire pour trois listes de taille 2, 3 et 0: l.set_list_sizes(tailles); // On affecte une valeur au deuxieme element de la premiere liste: l.set_value(0,1,765); // Affiche la valeur Cout &lt;&lt; l(0,1);.">Static_Int_Lists</a>&amp; som_elem   = <a class="code" href="classFaces__builder.html#a8a270bd6890413328324bb1506709106">connectivite_som_elem</a>();
<a name="l00423"></a>00423   <span class="keyword">const</span> <span class="keywordtype">int</span>   nb_sommets_par_face  = <a class="code" href="classFaces__builder.html#aa173ce9252eff3fb6981b4c199137c32" title="redonne les faces pour un element, dans le cas des polyhedres cela depend du numero de l&#39;element...">faces_element_reference</a>(0).<a class="code" href="classIntTab.html#abc3b32c94925a82f69d5b153a356e359" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(0) ? <a class="code" href="classFaces__builder.html#aa173ce9252eff3fb6981b4c199137c32" title="redonne les faces pour un element, dans le cas des polyhedres cela depend du numero de l&#39;element...">faces_element_reference</a>(0).<a class="code" href="classIntTab.html#abc3b32c94925a82f69d5b153a356e359" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(1) : 3;
<a name="l00424"></a>00424   <span class="keyword">const</span> <span class="keywordtype">int</span>   num_premiere_face    = faces_sommets.<a class="code" href="classIntTab.html#abc3b32c94925a82f69d5b153a356e359" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(0);
<a name="l00425"></a>00425   <span class="keyword">const</span> <span class="keywordtype">int</span>   nb_elem_reels        = elem_faces.<a class="code" href="classIntTab.html#abc3b32c94925a82f69d5b153a356e359" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(0);
<a name="l00426"></a>00426   frontiere.<a class="code" href="classFrontiere.html#a66cbd407fb5a1611b9aca04bddd0f6e0">fixer_num_premiere_face</a>(num_premiere_face);
<a name="l00427"></a>00427 
<a name="l00428"></a>00428   <span class="keyword">const</span> <a class="code" href="classFaces.html" title="enum Type_Face Les differents types geometriques de faces.">Faces</a>&amp;   faces_frontiere  = frontiere.<a class="code" href="classFrontiere.html#ac64479069f0c43a17cb5766a39ce5ba8" title="Renvoie les faces de la frontiere&lt;br&gt;(version const)">faces</a>();
<a name="l00429"></a>00429   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; sommets_faces_fr = faces_frontiere.<a class="code" href="classFaces.html#a07b8d8db9e3d656b93a21a49c063430c">les_sommets</a>();
<a name="l00430"></a>00430   <span class="keyword">const</span> <span class="keywordtype">int</span>   nb_faces         = faces_frontiere.<a class="code" href="classFaces.html#a64d898edb20c3687d357018f1821c50a" title="Renvoie le nombre de Faces.">nb_faces</a>();
<a name="l00431"></a>00431   <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>       une_face(nb_sommets_par_face);
<a name="l00432"></a>00432   <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>       voisins;
<a name="l00433"></a>00433   voisins.<a class="code" href="classArrOfInt.html#a22d744bcd452d039580d1d9186f02b4e" title="Change le mode l&#39;allocation memoire: reallocation d&#39;un tableau a chaque changement de taille (flag = ...">set_smart_resize</a>(1);
<a name="l00434"></a>00434   <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> liste_faces_erreur0;
<a name="l00435"></a>00435   liste_faces_erreur0.<a class="code" href="classArrOfInt.html#a22d744bcd452d039580d1d9186f02b4e" title="Change le mode l&#39;allocation memoire: reallocation d&#39;un tableau a chaque changement de taille (flag = ...">set_smart_resize</a>(1);
<a name="l00436"></a>00436   <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> liste_faces_erreur1;
<a name="l00437"></a>00437   liste_faces_erreur1.<a class="code" href="classArrOfInt.html#a22d744bcd452d039580d1d9186f02b4e" title="Change le mode l&#39;allocation memoire: reallocation d&#39;un tableau a chaque changement de taille (flag = ...">set_smart_resize</a>(1);
<a name="l00438"></a>00438   <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> liste_faces_erreur2;
<a name="l00439"></a>00439   liste_faces_erreur2.<a class="code" href="classArrOfInt.html#a22d744bcd452d039580d1d9186f02b4e" title="Change le mode l&#39;allocation memoire: reallocation d&#39;un tableau a chaque changement de taille (flag = ...">set_smart_resize</a>(1);
<a name="l00440"></a>00440   <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> liste_faces_erreur3;
<a name="l00441"></a>00441   liste_faces_erreur3.<a class="code" href="classArrOfInt.html#a22d744bcd452d039580d1d9186f02b4e" title="Change le mode l&#39;allocation memoire: reallocation d&#39;un tableau a chaque changement de taille (flag = ...">set_smart_resize</a>(1);
<a name="l00442"></a>00442 
<a name="l00443"></a>00443   <span class="keywordtype">int</span> i_face;
<a name="l00444"></a>00444   <span class="keywordflow">for</span> (i_face = 0; i_face &lt; nb_faces; i_face++)
<a name="l00445"></a>00445     {
<a name="l00446"></a>00446       {
<a name="l00447"></a>00447         <span class="keywordtype">int</span> nb_sommets_par_face_fr=sommets_faces_fr.<a class="code" href="classIntTab.html#abc3b32c94925a82f69d5b153a356e359" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(1);
<a name="l00448"></a>00448         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; <a class="code" href="Double_8h.html#a2f8edc4561e9744ed4233b205fa7ec32">min</a>(nb_sommets_par_face, nb_sommets_par_face_fr); i++)
<a name="l00449"></a>00449           une_face[i] = sommets_faces_fr(i_face, i);
<a name="l00450"></a>00450         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = <a class="code" href="Double_8h.html#a2f8edc4561e9744ed4233b205fa7ec32">min</a>(nb_sommets_par_face, nb_sommets_par_face_fr); i &lt; nb_sommets_par_face; i++)
<a name="l00451"></a>00451           une_face[i] = -1;
<a name="l00452"></a>00452       }
<a name="l00453"></a>00453 <span class="comment">// Quels sont les elements voisins de cette face ?</span>
<a name="l00454"></a>00454       <a class="code" href="Connectivite__som__elem_8cpp.html#afccbadf5344a16154a56b33dbddf88c1" title="Cherche les elements qui contiennent tous les sommets du tableau sommets_to_find (permet de trouver l...">find_adjacent_elements</a>(som_elem, une_face, voisins);
<a name="l00455"></a>00455       <span class="keyword">const</span> <span class="keywordtype">int</span> nb_voisins = voisins.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>();
<a name="l00456"></a>00456       <span class="keyword">const</span> <span class="keywordtype">int</span> elem0 = (nb_voisins &gt; 0) ? voisins[0] : -1;
<a name="l00457"></a>00457       <span class="keyword">const</span> <span class="keywordtype">int</span> elem1 = (nb_voisins &gt; 1) ? voisins[1] : -1;
<a name="l00458"></a>00458       <span class="keyword">const</span> <span class="keywordtype">int</span> indice_face =
<a name="l00459"></a>00459         <a class="code" href="classFaces__builder.html#aacc718530a516ea356626f074b9e6bdc" title="ajoute une face reelle dans faces_sommets et faces_voisins.">ajouter_une_face</a>(une_face, elem0, elem1, faces_sommets, faces_voisins);
<a name="l00460"></a>00460 
<a name="l00461"></a>00461       <span class="keywordflow">switch</span>(nb_voisins)
<a name="l00462"></a>00462         {
<a name="l00463"></a>00463         <span class="keywordflow">case</span> 0:
<a name="l00464"></a>00464           {
<a name="l00465"></a>00465 <span class="comment">// Erreur: la face n&#39;a pas de voisin</span>
<a name="l00466"></a>00466             liste_faces_erreur0.<a class="code" href="classArrOfInt.html#a3f39d0966599416e7b1f7cd8159d8d01" title="Ajoute une case en fin de tableau et y stocke la &quot;valeur&quot;.">append_array</a>(indice_face);
<a name="l00467"></a>00467             <span class="keywordflow">break</span>;
<a name="l00468"></a>00468           }
<a name="l00469"></a>00469         <span class="keywordflow">case</span> 1:
<a name="l00470"></a>00470         <span class="keywordflow">case</span> 2:
<a name="l00471"></a>00471           {
<a name="l00472"></a>00472             <span class="keywordflow">if</span> (nb_voisins_attendus == nb_voisins)
<a name="l00473"></a>00473               {
<a name="l00474"></a>00474                 <span class="keywordtype">int</span> i_voisin;
<a name="l00475"></a>00475                 <span class="keywordflow">for</span> (i_voisin = 0; i_voisin &lt; nb_voisins; i_voisin++)
<a name="l00476"></a>00476                   {
<a name="l00477"></a>00477                     <span class="keyword">const</span> <span class="keywordtype">int</span> elem = voisins[i_voisin];
<a name="l00478"></a>00478 <span class="comment">// Quelle est la face de l&#39;element ?</span>
<a name="l00479"></a>00479                     <span class="keyword">const</span> <span class="keywordtype">int</span> i_face_elem = <a class="code" href="classFaces__builder.html#a17469d1ff2feae7d358abcccd2d67831">chercher_face_element</a>(une_face, elem);
<a name="l00480"></a>00480                     <span class="keywordflow">if</span> (i_face_elem &gt;= 0)
<a name="l00481"></a>00481                       {
<a name="l00482"></a>00482 <span class="comment">// Si c&#39;est un element reel, on associe la face</span>
<a name="l00483"></a>00483                         <span class="keywordflow">if</span> (elem &lt; nb_elem_reels)
<a name="l00484"></a>00484                           {
<a name="l00485"></a>00485                             <span class="keywordflow">if</span> (elem_faces(elem, i_face_elem) &lt; 0)
<a name="l00486"></a>00486                               {
<a name="l00487"></a>00487                                 elem_faces(elem, i_face_elem) = indice_face;
<a name="l00488"></a>00488                               }
<a name="l00489"></a>00489                             <span class="keywordflow">else</span>
<a name="l00490"></a>00490                               {
<a name="l00491"></a>00491 <span class="comment">// Erreur: cette face existe deja (dans cette frontiere ou une autre)</span>
<a name="l00492"></a>00492                                 liste_faces_erreur3.<a class="code" href="classArrOfInt.html#a3f39d0966599416e7b1f7cd8159d8d01" title="Ajoute une case en fin de tableau et y stocke la &quot;valeur&quot;.">append_array</a>(indice_face);
<a name="l00493"></a>00493                               }
<a name="l00494"></a>00494                           }
<a name="l00495"></a>00495                       }
<a name="l00496"></a>00496                     <span class="keywordflow">else</span>
<a name="l00497"></a>00497                       {
<a name="l00498"></a>00498 <span class="comment">// Erreur: la face n&#39;est pas une face de l&#39;element.</span>
<a name="l00499"></a>00499                         liste_faces_erreur0.<a class="code" href="classArrOfInt.html#a3f39d0966599416e7b1f7cd8159d8d01" title="Ajoute une case en fin de tableau et y stocke la &quot;valeur&quot;.">append_array</a>(indice_face);
<a name="l00500"></a>00500                       }
<a name="l00501"></a>00501                   }
<a name="l00502"></a>00502               }
<a name="l00503"></a>00503             <span class="keywordflow">else</span>
<a name="l00504"></a>00504               {
<a name="l00505"></a>00505 <span class="comment">// Erreur, on attendait pas ce nombre de voisins.</span>
<a name="l00506"></a>00506                 liste_faces_erreur1.<a class="code" href="classArrOfInt.html#a3f39d0966599416e7b1f7cd8159d8d01" title="Ajoute une case en fin de tableau et y stocke la &quot;valeur&quot;.">append_array</a>(indice_face);
<a name="l00507"></a>00507               }
<a name="l00508"></a>00508             <span class="keywordflow">break</span>;
<a name="l00509"></a>00509           }
<a name="l00510"></a>00510         <span class="keywordflow">default</span>:
<a name="l00511"></a>00511 <span class="comment">// Erreur, plus de deux voisins, c&#39;est n&#39;importe quoi...</span>
<a name="l00512"></a>00512           liste_faces_erreur2.<a class="code" href="classArrOfInt.html#a3f39d0966599416e7b1f7cd8159d8d01" title="Ajoute une case en fin de tableau et y stocke la &quot;valeur&quot;.">append_array</a>(indice_face);
<a name="l00513"></a>00513         }
<a name="l00514"></a>00514     }
<a name="l00515"></a>00515   <a class="code" href="classNom.html" title="class Nom Une chaine de caractere pour nommer les objets de TRUST">Nom</a> msg;
<a name="l00516"></a>00516   msg = <span class="stringliteral">&quot;Boundary \&quot;&quot;</span>;
<a name="l00517"></a>00517   msg += frontiere.<a class="code" href="classFrontiere.html#a2868774681d6f050479a95cbc7cd6fc9" title="Renvoie le nom de la frontiere.">le_nom</a>();
<a name="l00518"></a>00518   msg += <span class="stringliteral">&quot;\&quot; contains faces which do not belong to any element.&quot;</span>;
<a name="l00519"></a>00519   <a class="code" href="classFaces__builder.html#a2a1241fa1f4adf443332bd7440e9472f" title="methode outil pour creer_faces_frontiere et creer_faces_internes (si liste non vide sur au moins un p...">check_erreur_faces</a>(msg, liste_faces_erreur0);
<a name="l00520"></a>00520 
<a name="l00521"></a>00521   msg = <span class="stringliteral">&quot;Boundary \&quot;&quot;</span>;
<a name="l00522"></a>00522   msg += frontiere.<a class="code" href="classFrontiere.html#a2868774681d6f050479a95cbc7cd6fc9" title="Renvoie le nom de la frontiere.">le_nom</a>();
<a name="l00523"></a>00523   msg += <span class="stringliteral">&quot;\&quot; contains faces that belong to &quot;</span>;
<a name="l00524"></a>00524   msg += <a class="code" href="classNom.html" title="class Nom Une chaine de caractere pour nommer les objets de TRUST">Nom</a>(3-nb_voisins_attendus);
<a name="l00525"></a>00525   msg += <span class="stringliteral">&quot; elements.\n&quot;</span>;
<a name="l00526"></a>00526   <span class="keywordflow">switch</span>(nb_voisins_attendus)
<a name="l00527"></a>00527     {
<a name="l00528"></a>00528     <span class="keywordflow">case</span> 1:
<a name="l00529"></a>00529       msg += <span class="stringliteral">&quot;These faces should have only 1 neighbouring element.&quot;</span>;
<a name="l00530"></a>00530       <span class="keywordflow">break</span>;
<a name="l00531"></a>00531     <span class="keywordflow">case</span> 2:
<a name="l00532"></a>00532       msg += <span class="stringliteral">&quot;These faces should have 2 neighbouring elements.&quot;</span>;
<a name="l00533"></a>00533       <span class="keywordflow">break</span>;
<a name="l00534"></a>00534     <span class="keywordflow">default</span>:
<a name="l00535"></a>00535       msg = <span class="stringliteral">&quot;Internal error.&quot;</span>;
<a name="l00536"></a>00536     }
<a name="l00537"></a>00537   <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classJoint.html" title="La classe Joint est une Frontiere qui contient les faces et les sommets de joint avec la zone PEvoisi...">Joint</a>, frontiere))
<a name="l00538"></a>00538     {
<a name="l00539"></a>00539 <span class="comment">// Deux sources d&#39;erreur possibles: les faces de joint sont fausses</span>
<a name="l00540"></a>00540 <span class="comment">// ou bien la zone ne contient pas les elements virtuels (il faut</span>
<a name="l00541"></a>00541 <span class="comment">// au moins que la zone contienne les elements virtuels voisins des</span>
<a name="l00542"></a>00542 <span class="comment">// faces de joint).</span>
<a name="l00543"></a>00543       msg += <span class="stringliteral">&quot;(Error in a Joint object: internal error in the mesh splitter or scatter ? )\n&quot;</span>;
<a name="l00544"></a>00544     }
<a name="l00545"></a>00545   <a class="code" href="classFaces__builder.html#a2a1241fa1f4adf443332bd7440e9472f" title="methode outil pour creer_faces_frontiere et creer_faces_internes (si liste non vide sur au moins un p...">check_erreur_faces</a>(msg, liste_faces_erreur1);
<a name="l00546"></a>00546 
<a name="l00547"></a>00547   msg = <span class="stringliteral">&quot;Boundary \&quot;&quot;</span>;
<a name="l00548"></a>00548   msg += frontiere.<a class="code" href="classFrontiere.html#a2868774681d6f050479a95cbc7cd6fc9" title="Renvoie le nom de la frontiere.">le_nom</a>();
<a name="l00549"></a>00549   msg += <span class="stringliteral">&quot;\&quot; contains faces that belong to more than 2 elements.\n&quot;</span>;
<a name="l00550"></a>00550   <a class="code" href="classFaces__builder.html#a2a1241fa1f4adf443332bd7440e9472f" title="methode outil pour creer_faces_frontiere et creer_faces_internes (si liste non vide sur au moins un p...">check_erreur_faces</a>(msg, liste_faces_erreur2);
<a name="l00551"></a>00551 
<a name="l00552"></a>00552   msg = <span class="stringliteral">&quot;Boundary \&quot;&quot;</span>;
<a name="l00553"></a>00553   msg += frontiere.<a class="code" href="classFrontiere.html#a2868774681d6f050479a95cbc7cd6fc9" title="Renvoie le nom de la frontiere.">le_nom</a>();
<a name="l00554"></a>00554   msg += <span class="stringliteral">&quot;\&quot; contains faces that already exist in another boundary or in this one.\n&quot;</span>;
<a name="l00555"></a>00555   <a class="code" href="classFaces__builder.html#a2a1241fa1f4adf443332bd7440e9472f" title="methode outil pour creer_faces_frontiere et creer_faces_internes (si liste non vide sur au moins un p...">check_erreur_faces</a>(msg, liste_faces_erreur3);
<a name="l00556"></a>00556 }
<a name="l00557"></a>00557 
<a name="l00558"></a>00558 <span class="comment">//</span>
<a name="l00559"></a>00559 <span class="comment">//</span>
<a name="l00560"></a>00560 <span class="comment">//</span><span class="comment"></span>
<a name="l00561"></a>00561 <span class="comment">//! Construction des faces interieures au domaine&lt;br&gt;(faces qui ont deux voisins et qui ne sont pas des &quot;faces_bord_internes&quot;)&lt;br&gt;Les faces de joint ont deja ete creees.</span>
<a name="l00562"></a><a class="code" href="classFaces__builder.html#ae52612e6c9aff57afbe490c910930516">00562</a> <span class="comment"></span><span class="keywordtype">void</span> <a class="code" href="classFaces__builder.html#ae52612e6c9aff57afbe490c910930516" title="Construction des faces interieures au domaine (faces qui ont deux voisins et qui ne sont pas des &quot;fac...">Faces_builder::creer_faces_internes</a>(<a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; faces_sommets,
<a name="l00563"></a>00563                                          <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; elem_faces,
<a name="l00564"></a>00564                                          <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; faces_voisins)<span class="keyword"> const</span>
<a name="l00565"></a>00565 <span class="keyword"></span>{
<a name="l00566"></a>00566   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; elem_som             = <a class="code" href="classFaces__builder.html#a30ad4fbd88a8069b4cfd093d1da1116c">les_elements</a>();
<a name="l00567"></a>00567   <span class="keyword">const</span> <a class="code" href="classStatic__Int__Lists.html" title="Cette classe permet de stocker des listes d&#39;entiers accessibles en temps constant. La taille des listes ne peut pas changer sans perdre le contenu (ce sont des listes statiques). Exemple: Static_Int_List l; ArrOfInt tailles(3); tailles[0] = 2; tailles[1] = 3; tailles[2] = 0; // On reserve la memoire pour trois listes de taille 2, 3 et 0: l.set_list_sizes(tailles); // On affecte une valeur au deuxieme element de la premiere liste: l.set_value(0,1,765); // Affiche la valeur Cout &lt;&lt; l(0,1);.">Static_Int_Lists</a>&amp; som_elem   = <a class="code" href="classFaces__builder.html#a8a270bd6890413328324bb1506709106">connectivite_som_elem</a>();
<a name="l00568"></a>00568 <span class="comment">// const IntTab &amp; faces_elem_ref       = faces_element_reference();</span>
<a name="l00569"></a>00569   <span class="keyword">const</span> <span class="keywordtype">int</span>   nb_elem              = elem_som.<a class="code" href="classIntTab.html#abc3b32c94925a82f69d5b153a356e359" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(0);
<a name="l00570"></a>00570   <span class="keyword">const</span> <span class="keywordtype">int</span>   nb_faces_par_element = <a class="code" href="classFaces__builder.html#aa173ce9252eff3fb6981b4c199137c32" title="redonne les faces pour un element, dans le cas des polyhedres cela depend du numero de l&#39;element...">faces_element_reference</a>(0).<a class="code" href="classIntTab.html#abc3b32c94925a82f69d5b153a356e359" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(0);
<a name="l00571"></a>00571   <span class="keyword">const</span> <span class="keywordtype">int</span>   nb_sommets_par_face  = nb_faces_par_element ? <a class="code" href="classFaces__builder.html#aa173ce9252eff3fb6981b4c199137c32" title="redonne les faces pour un element, dans le cas des polyhedres cela depend du numero de l&#39;element...">faces_element_reference</a>(0).<a class="code" href="classIntTab.html#abc3b32c94925a82f69d5b153a356e359" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(1) : 3;
<a name="l00572"></a>00572 
<a name="l00573"></a>00573 <span class="comment">// Tableau temporaire dans lequel on stocke les indices des sommets</span>
<a name="l00574"></a>00574 <span class="comment">// de la face en cours de traitement</span>
<a name="l00575"></a>00575   <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> une_face(nb_sommets_par_face);
<a name="l00576"></a>00576 <span class="comment">// Tableau temporaire (liste des elements voisins d&#39;une face)</span>
<a name="l00577"></a>00577   <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> voisins;
<a name="l00578"></a>00578   voisins.<a class="code" href="classArrOfInt.html#a22d744bcd452d039580d1d9186f02b4e" title="Change le mode l&#39;allocation memoire: reallocation d&#39;un tableau a chaque changement de taille (flag = ...">set_smart_resize</a>(1);
<a name="l00579"></a>00579 <span class="comment">// Liste des faces n&#39;ayant qu&#39;un seul voisin et qui ne figurent pas</span>
<a name="l00580"></a>00580 <span class="comment">// dans les faces de bord (ce sont des erreurs):</span>
<a name="l00581"></a>00581   <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> liste_faces_frontiere_non_declarees;
<a name="l00582"></a>00582   liste_faces_frontiere_non_declarees.<a class="code" href="classArrOfInt.html#a22d744bcd452d039580d1d9186f02b4e" title="Change le mode l&#39;allocation memoire: reallocation d&#39;un tableau a chaque changement de taille (flag = ...">set_smart_resize</a>(1);
<a name="l00583"></a>00583   <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> liste_faces_joint_non_declarees;
<a name="l00584"></a>00584   liste_faces_joint_non_declarees.<a class="code" href="classArrOfInt.html#a22d744bcd452d039580d1d9186f02b4e" title="Change le mode l&#39;allocation memoire: reallocation d&#39;un tableau a chaque changement de taille (flag = ...">set_smart_resize</a>(1);
<a name="l00585"></a>00585 <span class="comment">// Liste des faces presentant une erreur de connectivite (plus de</span>
<a name="l00586"></a>00586 <span class="comment">// deux elements voisins, ou connection a des sommets qui ne</span>
<a name="l00587"></a>00587 <span class="comment">// sont pas une face de l&#39;element:</span>
<a name="l00588"></a>00588   <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> liste_faces_erreurs_connectivite;
<a name="l00589"></a>00589   liste_faces_erreurs_connectivite.<a class="code" href="classArrOfInt.html#a22d744bcd452d039580d1d9186f02b4e" title="Change le mode l&#39;allocation memoire: reallocation d&#39;un tableau a chaque changement de taille (flag = ...">set_smart_resize</a>(1);
<a name="l00590"></a>00590 
<a name="l00591"></a>00591 <span class="comment">// Boucle sur les elements</span>
<a name="l00592"></a>00592   <span class="keywordtype">int</span> i_elem;
<a name="l00593"></a>00593   <span class="keywordflow">for</span> (i_elem = 0; i_elem &lt; nb_elem; i_elem++)
<a name="l00594"></a>00594     {
<a name="l00595"></a>00595       <span class="keywordtype">int</span> i_face;
<a name="l00596"></a>00596 <span class="comment">// Boucle sur les faces de l&#39;element</span>
<a name="l00597"></a>00597       <span class="keywordflow">for</span> (i_face = 0; i_face &lt; nb_faces_par_element; i_face++)
<a name="l00598"></a>00598         {
<a name="l00599"></a>00599 
<a name="l00600"></a>00600 <span class="comment">// L&#39;indice de cette face dans le tableau faces_sommets.</span>
<a name="l00601"></a>00601 <span class="comment">// Il vaut -1 si la face n&#39;a pas encore ete creee,</span>
<a name="l00602"></a>00602           <span class="keywordtype">int</span> indice_face = elem_faces(i_elem, i_face);
<a name="l00603"></a>00603 
<a name="l00604"></a>00604 <span class="comment">// Calcul des indices des sommets de la face dans le domaine:</span>
<a name="l00605"></a>00605           <span class="keywordtype">int</span> i;
<a name="l00606"></a>00606 <span class="comment">// Attention il ne faut laisser l&#39;appel ici...</span>
<a name="l00607"></a>00607           <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; faces_elem_ref       = <a class="code" href="classFaces__builder.html#aa173ce9252eff3fb6981b4c199137c32" title="redonne les faces pour un element, dans le cas des polyhedres cela depend du numero de l&#39;element...">faces_element_reference</a>(i_elem);
<a name="l00608"></a>00608 
<a name="l00609"></a>00609           <span class="keywordflow">for</span> (i = 0; i &lt; nb_sommets_par_face; i++)
<a name="l00610"></a>00610             {
<a name="l00611"></a>00611 <span class="comment">// indice du sommet sur l&#39;element de reference</span>
<a name="l00612"></a>00612               <span class="keyword">const</span> <span class="keywordtype">int</span> i_som_ref = faces_elem_ref(i_face, i);
<a name="l00613"></a>00613 <span class="comment">// indice du sommet dans le domaine</span>
<a name="l00614"></a>00614               <span class="keywordflow">if</span> (i_som_ref==-1)
<a name="l00615"></a>00615                 une_face[i] = -1;
<a name="l00616"></a>00616               <span class="keywordflow">else</span>
<a name="l00617"></a>00617                 {
<a name="l00618"></a>00618                   <span class="keyword">const</span> <span class="keywordtype">int</span> i_som = elem_som(i_elem, i_som_ref);
<a name="l00619"></a>00619                   une_face[i] = i_som;
<a name="l00620"></a>00620                 }
<a name="l00621"></a>00621             }
<a name="l00622"></a>00622           <span class="keywordflow">if</span> (une_face[0]==-1)
<a name="l00623"></a>00623             {
<a name="l00624"></a>00624 <span class="comment">// on a une face bidon on ne fait rien</span>
<a name="l00625"></a>00625               elem_faces(i_elem, i_face) = -1;
<a name="l00626"></a>00626             }
<a name="l00627"></a>00627           <span class="keywordflow">else</span>
<a name="l00628"></a>00628             {
<a name="l00629"></a>00629 <span class="comment">// Recherche des elements voisins de cette face.</span>
<a name="l00630"></a>00630 <span class="comment">// Le tableau &quot;voisins&quot; est classe dans l&#39;ordre croissant.</span>
<a name="l00631"></a>00631               <a class="code" href="Connectivite__som__elem_8cpp.html#afccbadf5344a16154a56b33dbddf88c1" title="Cherche les elements qui contiennent tous les sommets du tableau sommets_to_find (permet de trouver l...">find_adjacent_elements</a>(som_elem, une_face, voisins);
<a name="l00632"></a>00632 
<a name="l00633"></a>00633               <span class="keyword">const</span> <span class="keywordtype">int</span> nb_voisins = voisins.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>();
<a name="l00634"></a>00634               assert (nb_voisins &gt; 0); <span class="comment">//!&lt; Il devrait au moins y avoir i_elem !!! (ou alors on a une face constitues de -1);</span>
<a name="l00635"></a>00635 <span class="comment"></span>
<a name="l00636"></a>00636               <span class="keywordflow">if</span> (nb_voisins == 1)   <span class="comment">//!&lt; ***** La face a 1 voisin ********</span>
<a name="l00637"></a>00637 <span class="comment"></span>                {
<a name="l00638"></a>00638 
<a name="l00639"></a>00639                   assert(voisins[0] == i_elem); <span class="comment">//!&lt; L&#39;element voisin est forcement i_elem Une face ayant un seul element voisin est une face de frontiere.</span>
<a name="l00640"></a>00640 <span class="comment"></span><span class="comment">//</span>
<a name="l00641"></a>00641                   <span class="keywordflow">if</span> (indice_face &gt;= 0)
<a name="l00642"></a>00642                     {
<a name="l00643"></a>00643 <span class="comment">// Ok, c&#39;est normal, les frontieres ont deja ete traitees</span>
<a name="l00644"></a>00644                     }
<a name="l00645"></a>00645                   <span class="keywordflow">else</span>
<a name="l00646"></a>00646                     {
<a name="l00647"></a>00647 <span class="comment">// Erreur: la face n&#39;existe pas encore. Elle devrait avoir ete</span>
<a name="l00648"></a>00648 <span class="comment">// creee a partir des frontieres (creer_faces_frontiere)</span>
<a name="l00649"></a>00649                       indice_face = <a class="code" href="classFaces__builder.html#aacc718530a516ea356626f074b9e6bdc" title="ajoute une face reelle dans faces_sommets et faces_voisins.">ajouter_une_face</a>(une_face, i_elem, -1,
<a name="l00650"></a>00650                                                      faces_sommets, faces_voisins);
<a name="l00651"></a>00651                       liste_faces_frontiere_non_declarees.<a class="code" href="classArrOfInt.html#a3f39d0966599416e7b1f7cd8159d8d01" title="Ajoute une case en fin de tableau et y stocke la &quot;valeur&quot;.">append_array</a>(indice_face);
<a name="l00652"></a>00652                     }
<a name="l00653"></a>00653 
<a name="l00654"></a>00654                 }
<a name="l00655"></a>00655               <span class="keywordflow">else</span> <span class="keywordflow">if</span> (nb_voisins == 2)     <span class="comment">//!&lt; ***** La face a 2 voisins ********</span>
<a name="l00656"></a>00656 <span class="comment"></span>                {
<a name="l00657"></a>00657 
<a name="l00658"></a>00658                   <span class="keyword">const</span> <span class="keywordtype">int</span> elem0 = voisins[0];
<a name="l00659"></a>00659                   <span class="keyword">const</span> <span class="keywordtype">int</span> elem1 = voisins[1];
<a name="l00660"></a>00660                   assert(elem0 &lt; elem1);
<a name="l00661"></a>00661                   <span class="keywordflow">if</span> (indice_face &gt;= 0)
<a name="l00662"></a>00662                     {
<a name="l00663"></a>00663 <span class="comment">// La face a deje ete creee.</span>
<a name="l00664"></a>00664                     }
<a name="l00665"></a>00665                   <span class="keywordflow">else</span>
<a name="l00666"></a>00666                     {
<a name="l00667"></a>00667 <span class="comment">// La face n&#39;existe pas encore.</span>
<a name="l00668"></a>00668                       <span class="keywordflow">if</span> (elem0 == i_elem)
<a name="l00669"></a>00669                         {
<a name="l00670"></a>00670 <span class="comment">// Les voisins sont classes: elem0 &lt; elem1</span>
<a name="l00671"></a>00671 <span class="comment">// donc c&#39;est la premiere fois qu&#39;on parcourt cette face dans la boucle</span>
<a name="l00672"></a>00672 <span class="comment">// sur les elements.</span>
<a name="l00673"></a>00673                           indice_face = <a class="code" href="classFaces__builder.html#aacc718530a516ea356626f074b9e6bdc" title="ajoute une face reelle dans faces_sommets et faces_voisins.">ajouter_une_face</a>(une_face, elem0, elem1,
<a name="l00674"></a>00674                                                          faces_sommets, faces_voisins);
<a name="l00675"></a>00675 
<a name="l00676"></a>00676 <span class="comment">// Ou est cette face sur l&#39;element voisin ?</span>
<a name="l00677"></a>00677                           <span class="keyword">const</span> <span class="keywordtype">int</span> i_face_elem1 = <a class="code" href="classFaces__builder.html#a17469d1ff2feae7d358abcccd2d67831">chercher_face_element</a>(une_face, elem1);
<a name="l00678"></a>00678                           <span class="keywordflow">if</span> (i_face_elem1 &gt;= 0)
<a name="l00679"></a>00679                             {
<a name="l00680"></a>00680                               <span class="keywordflow">if</span> (elem1 &lt; nb_elem) <span class="comment">//!&lt; Element voisin reel ?</span>
<a name="l00681"></a>00681 <span class="comment"></span>                                elem_faces(elem1, i_face_elem1) = indice_face;
<a name="l00682"></a>00682                             }
<a name="l00683"></a>00683                           <span class="keywordflow">else</span>
<a name="l00684"></a>00684                             {
<a name="l00685"></a>00685 <span class="comment">// Erreur, les sommets de la face sont des sommets de l&#39;element elem1</span>
<a name="l00686"></a>00686 <span class="comment">// mais ne sont pas sur une face de cet element. Erreur de</span>
<a name="l00687"></a>00687 <span class="comment">// connectivite du maillage.</span>
<a name="l00688"></a>00688                               liste_faces_erreurs_connectivite.<a class="code" href="classArrOfInt.html#a3f39d0966599416e7b1f7cd8159d8d01" title="Ajoute une case en fin de tableau et y stocke la &quot;valeur&quot;.">append_array</a>(indice_face);
<a name="l00689"></a>00689                             }
<a name="l00690"></a>00690                           <span class="keywordflow">if</span> (elem1 &gt;= nb_elem)
<a name="l00691"></a>00691                             {
<a name="l00692"></a>00692 <span class="comment">// Erreur : le voisin est un element virtuel, cette face</span>
<a name="l00693"></a>00693 <span class="comment">// devrait etre dans les faces de joint, donc deja creee.</span>
<a name="l00694"></a>00694                               liste_faces_joint_non_declarees.<a class="code" href="classArrOfInt.html#a3f39d0966599416e7b1f7cd8159d8d01" title="Ajoute une case en fin de tableau et y stocke la &quot;valeur&quot;.">append_array</a>(indice_face);
<a name="l00695"></a>00695                             }
<a name="l00696"></a>00696                         }
<a name="l00697"></a>00697                       <span class="keywordflow">else</span>
<a name="l00698"></a>00698                         {
<a name="l00699"></a>00699                           assert(elem1 == i_elem);
<a name="l00700"></a>00700                           indice_face = <a class="code" href="classFaces__builder.html#aacc718530a516ea356626f074b9e6bdc" title="ajoute une face reelle dans faces_sommets et faces_voisins.">ajouter_une_face</a>(une_face, elem0, elem1,
<a name="l00701"></a>00701                                                          faces_sommets, faces_voisins);
<a name="l00702"></a>00702 <span class="comment">// On aurait deja du creer cette face car elle est voisine de elem0</span>
<a name="l00703"></a>00703 <span class="comment">// qui est deja traite (indice plus petit). Si on arrive ici,</span>
<a name="l00704"></a>00704 <span class="comment">// c&#39;est que les sommets de &quot;une_face&quot; appartiennent bien a l&#39;elem0,</span>
<a name="l00705"></a>00705 <span class="comment">// mais qu&#39;ils ne sont pas sur une face de cet element. C&#39;est une</span>
<a name="l00706"></a>00706 <span class="comment">// erreur de connectivite.</span>
<a name="l00707"></a>00707                           liste_faces_erreurs_connectivite.<a class="code" href="classArrOfInt.html#a3f39d0966599416e7b1f7cd8159d8d01" title="Ajoute une case en fin de tableau et y stocke la &quot;valeur&quot;.">append_array</a>(indice_face);
<a name="l00708"></a>00708                         }
<a name="l00709"></a>00709                     }
<a name="l00710"></a>00710 
<a name="l00711"></a>00711                 }
<a name="l00712"></a>00712               <span class="keywordflow">else</span>                        <span class="comment">//!&lt; ***** La face a &gt; 2 voisins ********</span>
<a name="l00713"></a>00713 <span class="comment"></span>                {
<a name="l00714"></a>00714                   <span class="keywordflow">if</span> (indice_face &lt; 0)
<a name="l00715"></a>00715                     {
<a name="l00716"></a>00716                       <span class="keyword">const</span> <span class="keywordtype">int</span> elem0 = voisins[0];
<a name="l00717"></a>00717                       <span class="keyword">const</span> <span class="keywordtype">int</span> elem1 = voisins[1];
<a name="l00718"></a>00718                       indice_face = <a class="code" href="classFaces__builder.html#aacc718530a516ea356626f074b9e6bdc" title="ajoute une face reelle dans faces_sommets et faces_voisins.">ajouter_une_face</a>(une_face, elem0, elem1,
<a name="l00719"></a>00719                                                      faces_sommets, faces_voisins);
<a name="l00720"></a>00720                     }
<a name="l00721"></a>00721                   liste_faces_erreurs_connectivite.<a class="code" href="classArrOfInt.html#a3f39d0966599416e7b1f7cd8159d8d01" title="Ajoute une case en fin de tableau et y stocke la &quot;valeur&quot;.">append_array</a>(indice_face);
<a name="l00722"></a>00722                 }
<a name="l00723"></a>00723 
<a name="l00724"></a>00724 <span class="comment">// Si la face n&#39;existait pas, on l&#39;a creee et on a mis son indice</span>
<a name="l00725"></a>00725 <span class="comment">// dans indice_face. Sinon on a trouve l&#39;indice de la face existante.</span>
<a name="l00726"></a>00726               assert(indice_face &gt;= 0);
<a name="l00727"></a>00727               elem_faces(i_elem, i_face) = indice_face; <span class="comment">/* WRITE elem_faces */</span>
<a name="l00728"></a>00728             }
<a name="l00729"></a>00729         }
<a name="l00730"></a>00730     }
<a name="l00731"></a>00731 
<a name="l00732"></a>00732 <span class="comment">// Traitement des erreurs:</span>
<a name="l00733"></a>00733   {
<a name="l00734"></a>00734     <span class="keyword">const</span> <span class="keywordtype">char</span> * <span class="keyword">const</span> msg1 = <span class="stringliteral">&quot;We found faces which belong to one element/cell only and are not declared in any boundary ! You forgot to define at least one boundary in your mesh. Fix your mesh.\n&quot;</span>;
<a name="l00735"></a>00735     <span class="keyword">const</span> <span class="keywordtype">char</span> * <span class="keyword">const</span> msg2 = <span class="stringliteral">&quot;Joint faces are incomplete: internal error in the mesh splitter\n&quot;</span>;
<a name="l00736"></a>00736     <span class="keyword">const</span> <span class="keywordtype">char</span> * <span class="keyword">const</span> msg3 = <span class="stringliteral">&quot;Connectivity error in the mesh elements. Possible errors:\n- one face of one element belongs to more than 2 elements\n- two element have at least 3 common nodes but these nodes are not faces of these elements\n&quot;</span>;
<a name="l00737"></a>00737     <a class="code" href="classFaces__builder.html#a2a1241fa1f4adf443332bd7440e9472f" title="methode outil pour creer_faces_frontiere et creer_faces_internes (si liste non vide sur au moins un p...">check_erreur_faces</a>(msg1, liste_faces_frontiere_non_declarees);
<a name="l00738"></a>00738     <a class="code" href="classFaces__builder.html#a2a1241fa1f4adf443332bd7440e9472f" title="methode outil pour creer_faces_frontiere et creer_faces_internes (si liste non vide sur au moins un p...">check_erreur_faces</a>(msg2, liste_faces_joint_non_declarees);
<a name="l00739"></a>00739     <a class="code" href="classFaces__builder.html#a2a1241fa1f4adf443332bd7440e9472f" title="methode outil pour creer_faces_frontiere et creer_faces_internes (si liste non vide sur au moins un p...">check_erreur_faces</a>(msg3, liste_faces_erreurs_connectivite);
<a name="l00740"></a>00740   }
<a name="l00741"></a>00741 }
<a name="l00742"></a>00742 
<a name="l00743"></a>00743 <span class="comment">//</span>
<a name="l00744"></a>00744 <span class="comment">//</span>
<a name="l00745"></a>00745 <span class="comment">//</span>
<a name="l00746"></a>00746 <span class="comment">//</span>
<a name="l00747"></a>00747 <span class="comment">//</span>
<a name="l00748"></a>00748 <span class="comment">//</span>
<a name="l00749"></a>00749 <span class="comment">//</span><span class="comment"></span>
<a name="l00750"></a>00750 <span class="comment">//! Methode appelee par Zone_VF::discretiser().&lt;br&gt;Construction du descripteur pour les faces de bord&lt;br&gt;Remplissage de ind_faces_virt_bord et des tableaux get_faces_virt() des frontieres&lt;br&gt;a partir du descripteur parallele des faces.&lt;br&gt;Note B.M.: le fait d&#39;avoir mis les faces dans la Zone_VF, les aretes dans la Zone,&lt;br&gt;certaines parties des proprites des faces de bord dans la Zone_VF et d&#39;autres dans la Zone&lt;br&gt;fait que l&#39;initialisation passe par des chemins un peu tordus... il faudra nettoyer ca.</span>
<a name="l00751"></a><a class="code" href="classZone.html#a89ba3ad245d1544c37c309d122399a22">00751</a> <span class="comment"></span><span class="keywordtype">void</span> <a class="code" href="classZone.html#a89ba3ad245d1544c37c309d122399a22" title="Methode appelee par Zone_VF::discretiser(). Construction du descripteur pour les faces de bord Rempli...">Zone::init_faces_virt_bord</a>(<span class="keyword">const</span> <a class="code" href="classMD__Vector.html" title=": Cette classe est un DERIV mais l&#39;objet pointe est partage entre plusieurs instances de cette classe...">MD_Vector</a>&amp; md_vect_faces, <a class="code" href="classMD__Vector.html" title=": Cette classe est un DERIV mais l&#39;objet pointe est partage entre plusieurs instances de cette classe...">MD_Vector</a>&amp; md_vect_faces_front)
<a name="l00752"></a>00752 {
<a name="l00753"></a>00753 <span class="comment">// ***************************************</span>
<a name="l00754"></a>00754 <span class="comment">// 1) Construction des structures de tableaux pour toutes les faces de bord</span>
<a name="l00755"></a>00755 <span class="comment">// (faces de 0 a nb_faces_frontiere())</span>
<a name="l00756"></a>00756   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_faces_fr = <a class="code" href="classZone.html#ac2734e92fd818342edab539cab41bf6a" title="Renvoie le nombre de faces frontiere de la zone. C&#39;est la somme des nombres de bords, de raccords et de faces internes.">nb_faces_frontiere</a>();
<a name="l00757"></a>00757 <span class="comment">// Marquage des faces de bord (-1=&gt;pas une face de bord, 0=&gt;face de bord)</span>
<a name="l00758"></a>00758   <a class="code" href="classIntVect.html">IntVect</a> vect_renum;
<a name="l00759"></a>00759   <a class="code" href="MD__Vector__tools_8cpp.html#aff1ed2791dba1a76fdb300920147cfdf">MD_Vector_tools::creer_tableau_distribue</a>(md_vect_faces, vect_renum, <a class="code" href="classArray__base.html#abee342aa9ac59623c4c782dc9d7877ffaf6ae9ba7eb51c5f298ce693345b3ec68">Array_base::NOCOPY_NOINIT</a>);
<a name="l00760"></a>00760   vect_renum = -1;
<a name="l00761"></a>00761   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; nb_faces_fr; i++)
<a name="l00762"></a>00762     vect_renum[i] = 0;
<a name="l00763"></a>00763   vect_renum.<a class="code" href="classIntVect.html#ad12bea67621d1a0ee82b27c9a37ca4ef">echange_espace_virtuel</a>();
<a name="l00764"></a>00764 
<a name="l00765"></a>00765 <span class="comment">// Creation du descripteur pour les faces de bord (par extraction d&#39;un sous ensemble du descripteur</span>
<a name="l00766"></a>00766 <span class="comment">// des faces). On utilise la numerotation par defaut dans l&#39;ordre croissant:</span>
<a name="l00767"></a>00767   <a class="code" href="classMD__Vector__tools.html#a773ef21e5af6331de459189d19cc340b" title="Idem que creer_md_vect_renum() mais cree une numerotation par defaut. Le tableau flags_renum doit con...">MD_Vector_tools::creer_md_vect_renum_auto</a>(vect_renum, md_vect_faces_front);
<a name="l00768"></a>00768 
<a name="l00769"></a>00769 <span class="comment">// Remplissage du tableau ind_faces_virt_bord. C&#39;est juste la partie virtuelle du tableau renum.</span>
<a name="l00770"></a>00770 <span class="comment">// (la partie reelle est triviale: c&#39;est une numerotation contigue de 0 a nb_faces_frontiere()</span>
<a name="l00771"></a>00771   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_faces = vect_renum.<a class="code" href="classIntVect.html#ad90cfd411cbbd631ccf1935bb36f7c40" title="Identique a size_reelle()">size</a>();
<a name="l00772"></a>00772   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_faces_tot = vect_renum.<a class="code" href="classIntVect.html#afa716e1f0a1f0f74f4f73e95b5651412" title="Identique a size_array()">size_totale</a>();
<a name="l00773"></a>00773   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_faces_virt = nb_faces_tot - nb_faces;
<a name="l00774"></a>00774   <a class="code" href="classZone.html#a7df85e9bdb7f512b41647efe4926c590" title="contient les indices des faces virtuelles de bord">ind_faces_virt_bord_</a>.<a class="code" href="classArrOfInt.html#a9b3afbb46b16870dbd36236c8935b535">resize_array</a>(nb_faces_virt, <a class="code" href="classArray__base.html#abee342aa9ac59623c4c782dc9d7877ffaf6ae9ba7eb51c5f298ce693345b3ec68">Array_base::NOCOPY_NOINIT</a>);
<a name="l00775"></a>00775   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; nb_faces_virt; i++)
<a name="l00776"></a>00776     <a class="code" href="classZone.html#a7df85e9bdb7f512b41647efe4926c590" title="contient les indices des faces virtuelles de bord">ind_faces_virt_bord_</a>[i] = vect_renum[nb_faces + i];
<a name="l00777"></a>00777 
<a name="l00778"></a>00778 <span class="comment">// **************************************</span>
<a name="l00779"></a>00779 <span class="comment">// 2) Construction des structures de tableaux pour chaque frontiere</span>
<a name="l00780"></a>00780 
<a name="l00781"></a>00781 <span class="comment">// Remplissage des tableaux</span>
<a name="l00782"></a>00782 <span class="comment">// frontiere(i).get_faces_virt() pour 0 &lt;= i &lt; nb_front_Cl()</span>
<a name="l00783"></a>00783 <span class="comment">// Ce tableau contient les indices dans la Zone_VF des faces virtuelles</span>
<a name="l00784"></a>00784 <span class="comment">// qui sont sur la frontiere i.</span>
<a name="l00785"></a>00785 <span class="comment">// Calcul de l&#39;espace virtuel des faces de chaque frontiere</span>
<a name="l00786"></a>00786 
<a name="l00787"></a>00787 <span class="comment">// Nombre de frontieres:</span>
<a name="l00788"></a>00788   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_frontieres = <a class="code" href="classZone.html#a9bf185c52ad1809d954bba670d9aed8a" title="Renvoie le nombre de bords + le nombre de raccords + le nombre de faces frontieres internes...">nb_front_Cl</a>();
<a name="l00789"></a>00789   <span class="keywordtype">int</span> i_frontiere;
<a name="l00790"></a>00790 <span class="comment">// Remplissage des tableaux get_faces_virt():</span>
<a name="l00791"></a>00791 <span class="comment">// et constructrion des MD_Vector de chaque frontiere (associe au tableau des faces)</span>
<a name="l00792"></a>00792   <span class="keywordflow">for</span> (i_frontiere = 0; i_frontiere &lt; nb_frontieres; i_frontiere++)
<a name="l00793"></a>00793     {
<a name="l00794"></a>00794       <a class="code" href="classFrontiere.html" title="Classe Frontiere. Une Frontiere decrit une partie de la frontiere d&#39;une Zone, elle possede un Nom...">Frontiere</a>&amp; front = <a class="code" href="classZone.html#ac338b119d4b0bc4f510a223b9086fe5e">frontiere</a>(i_frontiere);
<a name="l00795"></a>00795       <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; faces_sommets_frontiere = front.<a class="code" href="classFrontiere.html#a6d1f96137ddae39a46985a8c3e53bcf5" title="Renvoie les sommets des faces de la frontiere.">les_sommets_des_faces</a>();
<a name="l00796"></a>00796 <span class="comment">// Certains problemes ont plusieurs objets Zone_VF attaches a la meme Zone (rayonnement)</span>
<a name="l00797"></a>00797 <span class="comment">// Si on est deja passe par ici, ne pas refaire le travail:</span>
<a name="l00798"></a>00798       <span class="keywordflow">if</span> (faces_sommets_frontiere.<a class="code" href="classIntVect.html#ae74e1fee6aca124d32718267e33a40c6">get_md_vector</a>().<a class="code" href="classMD__Vector.html#a4165c00904b7096274e38fdc7ca340f4">non_nul</a>())
<a name="l00799"></a>00799         {
<a name="l00800"></a>00800           <span class="keywordflow">continue</span>;
<a name="l00801"></a>00801         }
<a name="l00802"></a>00802 <span class="comment">// les tableaux faces_sommets_frontiere doivent faire la meme largeur sur tous les procs avant echange</span>
<a name="l00803"></a>00803       <span class="keywordtype">int</span> nb_som_faces = <a class="code" href="classProcess.html#a1e9d9f9899b71927cfafae14c7bd048d" title="Calcule le max de x sur tous les processeurs du groupe courant. Remarques : Cette methode doit etre a...">Process::mp_max</a>(faces_sommets_frontiere.<a class="code" href="classIntTab.html#abc3b32c94925a82f69d5b153a356e359" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(1));
<a name="l00804"></a>00804       <span class="keywordflow">if</span> (faces_sommets_frontiere.<a class="code" href="classIntTab.html#abc3b32c94925a82f69d5b153a356e359" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(1) &lt; nb_som_faces)
<a name="l00805"></a>00805         {
<a name="l00806"></a>00806           <a class="code" href="classIntTrav.html" title="Tableau de travail a n entrees pour n&lt;= 4 C&#39;est un IntTab avec allocation dans un pool de memoire gere...">IntTrav</a> fsf_old;
<a name="l00807"></a>00807           fsf_old = faces_sommets_frontiere;
<a name="l00808"></a>00808           faces_sommets_frontiere.<a class="code" href="classIntTab.html#a22e6bed6826b3688d4d0181cbf3b7a38" title="Change la taille du vecteur (identique a resize_array() pour le traitement des anciennes valeurs et d...">resize</a>(fsf_old.<a class="code" href="classIntTab.html#a71e9b9ddc1793094b1b3f109377952b1" title="Returns the total dimensions of the multi-dimensionnal array, including virtual items (used in parall...">dimension_tot</a>(0), nb_som_faces);
<a name="l00809"></a>00809           faces_sommets_frontiere = -1;
<a name="l00810"></a>00810           <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0, j; i &lt; fsf_old.<a class="code" href="classIntTab.html#a71e9b9ddc1793094b1b3f109377952b1" title="Returns the total dimensions of the multi-dimensionnal array, including virtual items (used in parall...">dimension_tot</a>(0); i++)
<a name="l00811"></a>00811             <span class="keywordflow">for</span> (j = 0; j &lt; fsf_old.<a class="code" href="classIntTab.html#abc3b32c94925a82f69d5b153a356e359" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(1); j++)
<a name="l00812"></a>00812               faces_sommets_frontiere(i, j) = fsf_old(i, j);
<a name="l00813"></a>00813         }
<a name="l00814"></a>00814 
<a name="l00815"></a>00815       vect_renum = -1;
<a name="l00816"></a>00816       <span class="keyword">const</span> <span class="keywordtype">int</span> i_premiere_face = front.<a class="code" href="classFrontiere.html#a2a41c319a1530c984c356121e5ca2383">num_premiere_face</a>();
<a name="l00817"></a>00817       <span class="keyword">const</span> <span class="keywordtype">int</span> nb_faces_front = front.<a class="code" href="classFrontiere.html#aa073fe9dbdddde59471ee7032b256aa2" title="Renvoie le nombre de faces de la frontiere.">nb_faces</a>();
<a name="l00818"></a>00818 <span class="comment">// Marquage des faces de cette frontiere</span>
<a name="l00819"></a>00819       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = i_premiere_face; i &lt; i_premiere_face + nb_faces_front; i++)
<a name="l00820"></a>00820         vect_renum[i] = 0;
<a name="l00821"></a>00821       vect_renum.<a class="code" href="classIntVect.html#ad12bea67621d1a0ee82b27c9a37ca4ef">echange_espace_virtuel</a>();
<a name="l00822"></a>00822 <span class="comment">// Construction d&#39;un descripteur contenant le sous-ensemble des faces de cette frontiere</span>
<a name="l00823"></a>00823       <a class="code" href="classMD__Vector.html" title=": Cette classe est un DERIV mais l&#39;objet pointe est partage entre plusieurs instances de cette classe...">MD_Vector</a> md_frontiere;
<a name="l00824"></a>00824       <a class="code" href="classMD__Vector__tools.html#a773ef21e5af6331de459189d19cc340b" title="Idem que creer_md_vect_renum() mais cree une numerotation par defaut. Le tableau flags_renum doit con...">MD_Vector_tools::creer_md_vect_renum_auto</a>(vect_renum, md_frontiere);
<a name="l00825"></a>00825 
<a name="l00826"></a>00826 <span class="comment">// Creation de l&#39;espace virtuel des faces de la frontiere</span>
<a name="l00827"></a>00827 <span class="comment">// (c&#39;est ici qu&#39;on associe le descripteur md_frontiere au tableau des faces)</span>
<a name="l00828"></a>00828       <span class="keyword">const</span> <a class="code" href="classMD__Vector.html" title=": Cette classe est un DERIV mais l&#39;objet pointe est partage entre plusieurs instances de cette classe...">MD_Vector</a>&amp; md_sommets = <a class="code" href="classZone.html#a379ad2206b5a13a4f4f3df6d44c7546a" title="Renvoie le domaine dont la zone fait partie. (version const)">domaine</a>().<a class="code" href="classDomaine.html#a0846ac03a10b65c4df911fe35a19c02f" title="Renvoie le nombre total de sommets.">les_sommets</a>().<a class="code" href="classDoubleVect.html#a0d16d30580c90526e4895388fb44be5d">get_md_vector</a>();
<a name="l00829"></a>00829       <a class="code" href="classScatter.html#a33c68e7eff97ee92b457b50e8e3ad58d" title="Construit la structure items_communs + espaces virtuels d&#39;un tableau contenant des indices d&#39;items ge...">Scatter::construire_espace_virtuel_traduction</a>(md_frontiere, <span class="comment">/* tableau indexe par des numeros de faces de bord */</span>
<a name="l00830"></a>00830                                                     md_sommets, <span class="comment">/* contenant des indices de sommets du domaine */</span>
<a name="l00831"></a>00831                                                     faces_sommets_frontiere, <span class="comment">/* tableau a traiter */</span>
<a name="l00832"></a>00832                                                     1 <span class="comment">/* erreur fatale: si un sommet est manquant, c&#39;est une erreur */</span>);
<a name="l00833"></a>00833 
<a name="l00834"></a>00834 <span class="comment">// On recupere dans renum l&#39;indice renumerote de chaque face:</span>
<a name="l00835"></a>00835 <span class="comment">// on extrait les indices des faces virtuelles de cette frontiere</span>
<a name="l00836"></a>00836       <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; tab = front.<a class="code" href="classFrontiere.html#af1785ae558446734ad201d6ff9fece32">get_faces_virt</a>();
<a name="l00837"></a>00837       assert(faces_sommets_frontiere.<a class="code" href="classIntTab.html#abc3b32c94925a82f69d5b153a356e359" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(0) == nb_faces_front);
<a name="l00838"></a>00838       <span class="keyword">const</span> <span class="keywordtype">int</span> nb_faces_tot_frontiere = faces_sommets_frontiere.<a class="code" href="classIntTab.html#a71e9b9ddc1793094b1b3f109377952b1" title="Returns the total dimensions of the multi-dimensionnal array, including virtual items (used in parall...">dimension_tot</a>(0);
<a name="l00839"></a>00839       <span class="keyword">const</span> <span class="keywordtype">int</span> nb_faces_virt_frontiere = nb_faces_tot_frontiere - nb_faces_front;
<a name="l00840"></a>00840       tab.<a class="code" href="classArrOfInt.html#a9b3afbb46b16870dbd36236c8935b535">resize_array</a>(nb_faces_virt_frontiere);
<a name="l00841"></a>00841       <span class="keyword">const</span> <span class="keywordtype">int</span> ndebut = nb_faces; <span class="comment">//!&lt; nombre de faces de la Zone !</span>
<a name="l00842"></a>00842 <span class="comment"></span>      <span class="keyword">const</span> <span class="keywordtype">int</span> nfin = nb_faces_tot; <span class="comment">//!&lt; idem !</span>
<a name="l00843"></a>00843 <span class="comment"></span>      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = ndebut; i &lt; nfin; i++)
<a name="l00844"></a>00844         {
<a name="l00845"></a>00845           <span class="keyword">const</span> <span class="keywordtype">int</span> j = vect_renum[i];
<a name="l00846"></a>00846           <span class="keywordflow">if</span> (j &gt;= 0)
<a name="l00847"></a>00847             {
<a name="l00848"></a>00848               assert(j &gt;= nb_faces_front &amp;&amp; j &lt; nb_faces_tot_frontiere);
<a name="l00849"></a>00849 <span class="comment">// La face i est virtuelle et sur cette frontiere</span>
<a name="l00850"></a>00850               tab[j - nb_faces_front] = i;
<a name="l00851"></a>00851             }
<a name="l00852"></a>00852         }
<a name="l00853"></a>00853     }
<a name="l00854"></a>00854 }
<a name="l00855"></a>00855 
<a name="l00856"></a>00856 <span class="comment">//</span>
<a name="l00857"></a>00857 <span class="comment">//</span>
<a name="l00858"></a>00858 <span class="comment">//</span><span class="comment"></span>
<a name="l00859"></a>00859 <span class="comment">//! Cette methode permet de faire un echange espace virtuel d&#39;un tableau aux aretes&lt;br&gt;sans passer par le descripteur des aretes. On utilise le tableau elem_aretes et l&#39;echange&lt;br&gt;espace virtuel des elements</span>
<a name="l00860"></a><a class="code" href="Faces__builder_8cpp.html#a3981bc38009477c100eca94e823234b6">00860</a> <span class="comment"></span><span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="Faces__builder_8cpp.html#a3981bc38009477c100eca94e823234b6" title="Cette methode permet de faire un echange espace virtuel d&#39;un tableau aux aretes sans passer par le de...">echanger_tableau_aretes</a>(<span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; elem_aretes, <span class="keywordtype">int</span> nb_aretes_reelles, <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; tab_aretes)
<a name="l00861"></a>00861 {
<a name="l00862"></a>00862   <span class="keyword">const</span> <span class="keywordtype">int</span> moi = <a class="code" href="classProcess.html#ab55ba07167ec807ed3a145cac0f5dca4" title="renvoie mon rang dans le groupe de communication courant. Voir Comm_Group::rank() et PE_Groups::curre...">Process::me</a>();
<a name="l00863"></a>00863 
<a name="l00864"></a>00864   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_elem = elem_aretes.<a class="code" href="classIntTab.html#abc3b32c94925a82f69d5b153a356e359" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(0);
<a name="l00865"></a>00865   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_elem_tot = elem_aretes.<a class="code" href="classIntTab.html#a71e9b9ddc1793094b1b3f109377952b1" title="Returns the total dimensions of the multi-dimensionnal array, including virtual items (used in parall...">dimension_tot</a>(0);
<a name="l00866"></a>00866   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_aretes_elem = elem_aretes.<a class="code" href="classIntTab.html#abc3b32c94925a82f69d5b153a356e359" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(1);
<a name="l00867"></a>00867   <span class="keywordtype">int</span> i;
<a name="l00868"></a>00868 
<a name="l00869"></a>00869 <span class="comment">// **********************</span>
<a name="l00870"></a>00870 <span class="comment">// I) Echange pour mettre a jour les items communs</span>
<a name="l00871"></a>00871 <span class="comment">// Algo un peu complique pour mettre a jour les items communs: pour chaque arete reele,</span>
<a name="l00872"></a>00872 <span class="comment">// la valeur de tab_aretes doit etre egale a la valeur initiale de tab_arete donnee par</span>
<a name="l00873"></a>00873 <span class="comment">// le processeur de rang le plus petit parmi ceux qui partagent l&#39;arete (c&#39;est a dire</span>
<a name="l00874"></a>00874 <span class="comment">// les processeurs qui ont un element adjacent a cette arete).</span>
<a name="l00875"></a>00875 
<a name="l00876"></a>00876 <span class="comment">// Tableau permettant de connaitre le processeur proprietaire d&#39;une arete reele</span>
<a name="l00877"></a>00877   <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> pe_arete(nb_aretes_reelles);
<a name="l00878"></a>00878   pe_arete= moi;
<a name="l00879"></a>00879 <span class="comment">// Tableau qui donne, pour chaque element, le processeur proprietaire</span>
<a name="l00880"></a>00880   <a class="code" href="classIntVect.html">IntVect</a> pe_elem(nb_elem_tot);
<a name="l00881"></a>00881   pe_elem= moi; <span class="comment">//!&lt; initialise avec &quot;moi&quot;</span>
<a name="l00882"></a>00882 <span class="comment"></span>  {
<a name="l00883"></a>00883     pe_elem.<a class="code" href="classIntVect.html#aefca15627f9f7852150f4a769f00e3e2" title="associe le md_vector au vecteur et initialise l&#39;attribut size_reelle_ (voir methode size_reelle()) Si...">set_md_vector</a>(elem_aretes.<a class="code" href="classIntVect.html#ae74e1fee6aca124d32718267e33a40c6">get_md_vector</a>());
<a name="l00884"></a>00884     pe_elem.<a class="code" href="classIntVect.html#ad12bea67621d1a0ee82b27c9a37ca4ef">echange_espace_virtuel</a>();
<a name="l00885"></a>00885 <span class="comment">// On range dans pe_arete le numero du plus petit processeur proprietaire des</span>
<a name="l00886"></a>00886 <span class="comment">// elements adjacents a cette arete</span>
<a name="l00887"></a>00887 <span class="comment">// Inutile de parcourir les elements reels, on va trouver pe_elem[i]==moi...</span>
<a name="l00888"></a>00888 <span class="comment">// Si l&#39;arete se trouve sur un processeur de rang inferieur, on lui attribue</span>
<a name="l00889"></a>00889     <span class="keywordflow">for</span> (i = nb_elem; i &lt; nb_elem_tot; i++)
<a name="l00890"></a>00890       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> pe = pe_elem[i], j = 0, a; j &lt; nb_aretes_elem &amp;&amp; (a = elem_aretes(i, j)) &gt;= 0; j++)
<a name="l00891"></a>00891         <span class="keywordflow">if</span> (a &lt; nb_aretes_reelles &amp;&amp; pe_arete[a] &gt; pe)
<a name="l00892"></a>00892           pe_arete[a] = pe;
<a name="l00893"></a>00893   }
<a name="l00894"></a>00894 <span class="comment">// On suppose que l&#39;espace virtuel des elements contient au moins une couche d&#39;elements virtuels</span>
<a name="l00895"></a>00895 <span class="comment">// (tous les voisins des elements reels par des sommets) alors les aretes reelles sont</span>
<a name="l00896"></a>00896 <span class="comment">// echangees (pas encore les aretes virtuelles)</span>
<a name="l00897"></a>00897 <span class="comment">// Dans ce cas, pe_arete est maintenant correctement rempli pour les aretes reelles.</span>
<a name="l00898"></a>00898 
<a name="l00899"></a>00899   <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a> tmp;
<a name="l00900"></a>00900   tmp.<a class="code" href="classIntTab.html#a3d200d04b7bf53a32c27867c42065a0e">copy</a>(elem_aretes, <a class="code" href="classArray__base.html#abee342aa9ac59623c4c782dc9d7877ffaf6ae9ba7eb51c5f298ce693345b3ec68">Array_base::NOCOPY_NOINIT</a>); <span class="comment">//!&lt; copier uniquement la structure</span>
<a name="l00901"></a>00901 <span class="comment"></span>
<a name="l00902"></a>00902 <span class="comment">// Copier tab_aretes dans la structure tmp (on sait echanger tmp, pas tab_aretes)</span>
<a name="l00903"></a>00903   <span class="keywordflow">for</span> (i = 0; i &lt; nb_elem; i++)
<a name="l00904"></a>00904     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0, a; j &lt; nb_aretes_elem &amp;&amp; (a = elem_aretes(i, j)) &gt;= 0; j++)
<a name="l00905"></a>00905       tmp(i, j) = tab_aretes[a];
<a name="l00906"></a>00906 
<a name="l00907"></a>00907 <span class="comment">// 2) Echange du tableau</span>
<a name="l00908"></a>00908   tmp.<a class="code" href="classIntVect.html#ad12bea67621d1a0ee82b27c9a37ca4ef">echange_espace_virtuel</a>();
<a name="l00909"></a>00909 
<a name="l00910"></a>00910 <span class="comment">// 3) On reverse dans la partie reelle de tab_aretes les valeurs prises dans tmp:</span>
<a name="l00911"></a>00911 <span class="comment">// pour une arete partagee par plusieurs procs, c&#39;est le proc de rang le plus petit</span>
<a name="l00912"></a>00912 <span class="comment">// qui donne la valeur</span>
<a name="l00913"></a>00913 <span class="comment">// Inutile de parcourir les elements reels, la valeur ne changerait pas</span>
<a name="l00914"></a>00914   <span class="keywordflow">for</span> (i = nb_elem; i &lt; nb_elem_tot; i++)
<a name="l00915"></a>00915     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> pe = pe_elem[i], j = 0, a; j &lt; nb_aretes_elem &amp;&amp; (a = elem_aretes(i, j)) &gt;= 0; j++)
<a name="l00916"></a>00916       <span class="keywordflow">if</span> (a &lt; nb_aretes_reelles &amp;&amp; pe_arete[a] == pe)
<a name="l00917"></a>00917         tab_aretes[a] = tmp(i, j);
<a name="l00918"></a>00918 
<a name="l00919"></a>00919 <span class="comment">// tab_aretes contient maintenant des valeurs correctes pour toutes les aretes reeles</span>
<a name="l00920"></a>00920 <span class="comment">// (les items communs sont a jour). On fait encore un echange en passant par tmp pour</span>
<a name="l00921"></a>00921 <span class="comment">// mettre a jour les items virtuels:</span>
<a name="l00922"></a>00922 
<a name="l00923"></a>00923 <span class="comment">// ******************</span>
<a name="l00924"></a>00924 <span class="comment">// II) echange pour mettre a jour l&#39;espace virtuel des aretes</span>
<a name="l00925"></a>00925 
<a name="l00926"></a>00926 <span class="comment">// Copier encore une fois tab_aretes dans la structure tmp</span>
<a name="l00927"></a>00927   <span class="keywordflow">for</span> (i = 0; i &lt; nb_elem; i++)
<a name="l00928"></a>00928     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0, a; j &lt; nb_aretes_elem &amp;&amp; (a = elem_aretes(i, j)) &gt;= 0; j++)
<a name="l00929"></a>00929       tmp(i, j) = tab_aretes[a];
<a name="l00930"></a>00930 
<a name="l00931"></a>00931 <span class="comment">// Echange du tableau</span>
<a name="l00932"></a>00932   tmp.<a class="code" href="classIntVect.html#ad12bea67621d1a0ee82b27c9a37ca4ef">echange_espace_virtuel</a>();
<a name="l00933"></a>00933 <span class="comment">// Recopie de tmp dans tab_aretes</span>
<a name="l00934"></a>00934   <span class="keywordflow">for</span> (i = nb_elem; i &lt; nb_elem_tot; i++)
<a name="l00935"></a>00935     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0, a; j &lt; nb_aretes_elem &amp;&amp; (a = elem_aretes(i, j)) &gt;= 0; j++)
<a name="l00936"></a>00936       tab_aretes[a] = tmp(i, j);
<a name="l00937"></a>00937 }
<a name="l00938"></a>00938 
<a name="l00939"></a>00939 <span class="comment">/* version de creer_aretes compatible avec les polyedres */</span>
<a name="l00940"></a><a class="code" href="classZone.html#af27e3cb93ea77b05069e6016f981e227">00940</a> <span class="keywordtype">void</span> <a class="code" href="classZone.html#af27e3cb93ea77b05069e6016f981e227">Zone::creer_aretes</a>()
<a name="l00941"></a>00941 {
<a name="l00942"></a>00942   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; elem_som = <a class="code" href="classZone.html#ac115e8342be89afb882b7b61cc343267" title="Renvoie le tableau des sommets des elements.">les_elems</a>();
<a name="l00943"></a>00943 <span class="comment">// Nombre d&#39;elements reels:</span>
<a name="l00944"></a>00944   <span class="keyword">const</span> <span class="keywordtype">int</span> nbelem = elem_som.<a class="code" href="classIntTab.html#abc3b32c94925a82f69d5b153a356e359" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(0);
<a name="l00945"></a>00945 <span class="comment">// Les elements virtuels sont deja construits:</span>
<a name="l00946"></a>00946   <span class="keyword">const</span> <span class="keywordtype">int</span> nbelem_tot = elem_som.<a class="code" href="classIntTab.html#a71e9b9ddc1793094b1b3f109377952b1" title="Returns the total dimensions of the multi-dimensionnal array, including virtual items (used in parall...">dimension_tot</a>(0);
<a name="l00947"></a>00947 
<a name="l00948"></a>00948   <a class="code" href="classZone.html#a23956e4bc2f330a105c27dcadb80c21d">Aretes_som</a>.<a class="code" href="classArrOfInt.html#a22d744bcd452d039580d1d9186f02b4e" title="Change le mode l&#39;allocation memoire: reallocation d&#39;un tableau a chaque changement de taille (flag = ...">set_smart_resize</a>(1);
<a name="l00949"></a>00949   <a class="code" href="classZone.html#a23956e4bc2f330a105c27dcadb80c21d">Aretes_som</a>.<a class="code" href="classIntTab.html#a22e6bed6826b3688d4d0181cbf3b7a38" title="Change la taille du vecteur (identique a resize_array() pour le traitement des anciennes valeurs et d...">resize</a>(0, 2);
<a name="l00950"></a>00950   <span class="keywordtype">bool</span> is_poly = <a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classPoly__geom__base.html" title=": class Poly_geom_base &lt;Description of class Poly_geom_base&gt;">Poly_geom_base</a>, <a class="code" href="classZone.html#a18cf83cd0f9c368dcfa32fb802a0ac94" title="Renvoie un element geometrique du type de ceux qui constituent la zone. (version const)">type_elem</a>().<a class="code" href="Source__Generique__Face__PolyMAC_8cpp.html#a7d7b5d77a3caa1af70f5e1c9108de5a1">valeur</a>());
<a name="l00951"></a>00951 
<a name="l00952"></a>00952   std::vector&lt;std::vector&lt;int&gt; &gt; v_e_a(nbelem_tot);<span class="comment">//liste des aretes de chaque element</span>
<a name="l00953"></a>00953   <span class="keywordtype">int</span> nb_aretes_reelles = 0, i, j;
<a name="l00954"></a>00954   {
<a name="l00955"></a>00955 <span class="comment">// Une liste chainee pour retrouver, pour chaque sommet, la liste des aretes</span>
<a name="l00956"></a>00956 <span class="comment">// attachees a ce sommet. Le tableau est de meme taille que Aretes_som.dimension(0)</span>
<a name="l00957"></a>00957 <span class="comment">// chaine_aretes_sommets[i] contient l&#39;indice de la prochaine arete attachee au</span>
<a name="l00958"></a>00958 <span class="comment">// meme sommet ou -1 si c&#39;est la derniere</span>
<a name="l00959"></a>00959     <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> chaine_aretes_sommets;
<a name="l00960"></a>00960     chaine_aretes_sommets.<a class="code" href="classArrOfInt.html#a22d744bcd452d039580d1d9186f02b4e" title="Change le mode l&#39;allocation memoire: reallocation d&#39;un tableau a chaque changement de taille (flag = ...">set_smart_resize</a>(1);
<a name="l00961"></a>00961 <span class="comment">// Indice de la premiere arete attachee a chaque sommet dans chaine_aretes_sommets</span>
<a name="l00962"></a>00962     <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> premiere_arete_som(<a class="code" href="classZone.html#a01ed67af826d6045ef4eacfb87a663e8" title="Renvoie le nombre total de sommets de la zone. i.e. le nombre de sommets reels et virtuels sur le pro...">nb_som_tot</a>());
<a name="l00963"></a>00963     premiere_arete_som= -1;
<a name="l00964"></a>00964 
<a name="l00965"></a>00965     std::map&lt;std::array&lt;double, 3&gt;, std::array&lt;int, 2&gt; &gt; aretes_loc; <span class="comment">//aretes de l&#39;element considere : aretes_loc[{xa, ya, za}] = { s1, s2}</span>
<a name="l00966"></a>00966 <span class="comment">// l&#39;utilisation d&#39;un map permet de s&#39;assurer que les aretes soient dans le meme ordre sur tous les procs!</span>
<a name="l00967"></a>00967     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i_elem = 0; i_elem &lt; nbelem_tot; aretes_loc.clear(), i_elem++)
<a name="l00968"></a>00968       {
<a name="l00969"></a>00969         <span class="comment">/* 1. on retrouve les aretes de l&#39;element en iterant sur ses faces */</span>
<a name="l00970"></a>00970         <span class="keyword">const</span> <a class="code" href="classElem__geom__base.html" title="Classe Elem_geom_base Cette classe est la classe de base pour la definition d&#39;elements geometriques c...">Elem_geom_base</a>&amp; elem_g = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classElem__geom__base.html" title="Classe Elem_geom_base Cette classe est la classe de base pour la definition d&#39;elements geometriques c...">Elem_geom_base</a>, <a class="code" href="classZone.html#a18cf83cd0f9c368dcfa32fb802a0ac94" title="Renvoie un element geometrique du type de ceux qui constituent la zone. (version const)">type_elem</a>().<a class="code" href="Source__Generique__Face__PolyMAC_8cpp.html#a7d7b5d77a3caa1af70f5e1c9108de5a1">valeur</a>());
<a name="l00971"></a>00971         <a class="code" href="classIntTrav.html" title="Tableau de travail a n entrees pour n&lt;= 4 C&#39;est un IntTab avec allocation dans un pool de memoire gere...">IntTrav</a> f_e_r;
<a name="l00972"></a>00972         <span class="keywordflow">if</span> (is_poly)
<a name="l00973"></a>00973           {
<a name="l00974"></a>00974             <span class="keyword">const</span> <a class="code" href="classPoly__geom__base.html" title=": class Poly_geom_base &lt;Description of class Poly_geom_base&gt;">Poly_geom_base</a>&amp; poly_g = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classPoly__geom__base.html" title=": class Poly_geom_base &lt;Description of class Poly_geom_base&gt;">Poly_geom_base</a>, <a class="code" href="classZone.html#a18cf83cd0f9c368dcfa32fb802a0ac94" title="Renvoie un element geometrique du type de ceux qui constituent la zone. (version const)">type_elem</a>().<a class="code" href="Source__Generique__Face__PolyMAC_8cpp.html#a7d7b5d77a3caa1af70f5e1c9108de5a1">valeur</a>());
<a name="l00975"></a>00975             poly_g.<a class="code" href="classPoly__geom__base.html#a1357e4033dba242d8a899bcb87d9f6f3" title="remplit le tableau faces_som_local(i,j) qui donne pour 0 &lt;= i &lt; nb_faces() et 0 &lt;= j &lt; nb_som_face(i) le ...">get_tab_faces_sommets_locaux</a>(f_e_r, i_elem);
<a name="l00976"></a>00976           }
<a name="l00977"></a>00977         <span class="keywordflow">else</span> elem_g.<a class="code" href="classElem__geom__base.html#a9993267e98ef97472d3a5ef9c3c67882" title="remplit le tableau faces_som_local(i,j) qui donne pour 0 &lt;= i &lt; nb_faces() et 0 &lt;= j &lt; nb_som_face(i) le ...">get_tab_faces_sommets_locaux</a>(f_e_r);
<a name="l00978"></a>00978 
<a name="l00979"></a>00979         <span class="keywordflow">for</span> (i = 0; i &lt; f_e_r.<a class="code" href="classIntTab.html#abc3b32c94925a82f69d5b153a356e359" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(0) &amp;&amp; f_e_r(i, 0) &gt;= 0; i++)
<a name="l00980"></a>00980           <span class="keywordflow">for</span> (j = 0; j &lt; f_e_r.<a class="code" href="classIntTab.html#abc3b32c94925a82f69d5b153a356e359" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(1) &amp;&amp; f_e_r(i, j) &gt;= 0; j++)
<a name="l00981"></a>00981             {
<a name="l00982"></a>00982               <span class="keywordtype">int</span> s1 = elem_som(i_elem, f_e_r(i, j)),
<a name="l00983"></a>00983                   s2 = elem_som(i_elem, f_e_r(i, j + 1 &lt; f_e_r.<a class="code" href="classIntTab.html#abc3b32c94925a82f69d5b153a356e359" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(1) &amp;&amp; f_e_r(i, j + 1) &gt;= 0 ? j + 1 : 0));
<a name="l00984"></a>00984               std::array&lt;double, 3&gt; key;
<a name="l00985"></a>00985               <span class="keywordflow">for</span> (<span class="keywordtype">int</span> l = 0; l &lt; 3; l++) key[l] = (<a class="code" href="classZone.html#a379ad2206b5a13a4f4f3df6d44c7546a" title="Renvoie le domaine dont la zone fait partie. (version const)">domaine</a>().coord_sommets()(s1, l) + <a class="code" href="classZone.html#a379ad2206b5a13a4f4f3df6d44c7546a" title="Renvoie le domaine dont la zone fait partie. (version const)">domaine</a>().coord_sommets()(s2, l)) / 2;
<a name="l00986"></a>00986               aretes_loc[key] = {{ <a class="code" href="Double_8h.html#a2f8edc4561e9744ed4233b205fa7ec32">min</a>(s1, s2), <a class="code" href="Double_8h.html#a1c45761573e6cbc97cfacac78d905016">max</a>(s1, s2) }};
<a name="l00987"></a>00987             }
<a name="l00988"></a>00988 
<a name="l00989"></a>00989         <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;&amp; kv : aretes_loc)
<a name="l00990"></a>00990           {
<a name="l00991"></a>00991 <span class="comment">// a-t-on deja vu cette arete ?</span>
<a name="l00992"></a>00992             <span class="keywordtype">int</span> k = premiere_arete_som[kv.second[0]];
<a name="l00993"></a>00993             <span class="keywordflow">while</span> (k &gt;= 0 &amp;&amp; (<a class="code" href="classZone.html#a23956e4bc2f330a105c27dcadb80c21d">Aretes_som</a>(k, 0) != kv.second[0] || <a class="code" href="classZone.html#a23956e4bc2f330a105c27dcadb80c21d">Aretes_som</a>(k, 1) != kv.second[1])) k = chaine_aretes_sommets[k];
<a name="l00994"></a>00994             <span class="keywordflow">if</span> (k &lt; 0) <span class="comment">//on n&#39;a pas encore trouve l&#39;arete -&gt; maj de premiere_arete_som et chaine_arete_sommets</span>
<a name="l00995"></a>00995               {
<a name="l00996"></a>00996 <span class="comment">// L&#39;arete n&#39;existe pas encore</span>
<a name="l00997"></a>00997                 k = chaine_aretes_sommets.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>();
<a name="l00998"></a>00998                 assert(k == <a class="code" href="classZone.html#a23956e4bc2f330a105c27dcadb80c21d">Aretes_som</a>.<a class="code" href="classIntTab.html#abc3b32c94925a82f69d5b153a356e359" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(0));
<a name="l00999"></a>00999                 <a class="code" href="classZone.html#a23956e4bc2f330a105c27dcadb80c21d">Aretes_som</a>.<a class="code" href="classIntTab.html#ac0af4eac42ca46facc05f985c3ef05c6" title="Adds 1 to dimension_tot(0) and puts a in the added line.">append_line</a>(kv.second[0], kv.second[1]);
<a name="l01000"></a>01000 <span class="comment">// Insertion de l&#39;arete en tete de la liste chainee</span>
<a name="l01001"></a>01001                 <span class="keywordtype">int</span> old_head = premiere_arete_som[kv.second[0]];
<a name="l01002"></a>01002 <span class="comment">// Indice de la nouvelle arete</span>
<a name="l01003"></a>01003                 <span class="keywordtype">int</span> new_head = chaine_aretes_sommets.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>();
<a name="l01004"></a>01004                 chaine_aretes_sommets.<a class="code" href="classArrOfInt.html#a3f39d0966599416e7b1f7cd8159d8d01" title="Ajoute une case en fin de tableau et y stocke la &quot;valeur&quot;.">append_array</a>(old_head);
<a name="l01005"></a>01005                 premiere_arete_som[kv.second[0]] = new_head;
<a name="l01006"></a>01006               }
<a name="l01007"></a>01007             v_e_a[i_elem].push_back(k); <span class="comment">//ajout de l&#39;arete a la liste des aretes de l&#39;element</span>
<a name="l01008"></a>01008           }
<a name="l01009"></a>01009         <span class="keywordflow">if</span> (i_elem == nbelem - 1)
<a name="l01010"></a>01010           {
<a name="l01011"></a>01011 <span class="comment">// On vient de finir les aretes reelles</span>
<a name="l01012"></a>01012             nb_aretes_reelles = <a class="code" href="classZone.html#a23956e4bc2f330a105c27dcadb80c21d">Aretes_som</a>.<a class="code" href="classIntTab.html#abc3b32c94925a82f69d5b153a356e359" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(0);
<a name="l01013"></a>01013           }
<a name="l01014"></a>01014       }
<a name="l01015"></a>01015   }
<a name="l01016"></a>01016   <span class="comment">/* remplissage du tableau elem_aretes a l&#39;aide de v_e_a */</span>
<a name="l01017"></a>01017   <span class="keywordtype">int</span> nb_aretes_elem = 0;
<a name="l01018"></a>01018   <span class="keywordflow">for</span> (i = 0; i &lt; nbelem_tot; i++) nb_aretes_elem = <a class="code" href="Double_8h.html#a1c45761573e6cbc97cfacac78d905016">max</a>(nb_aretes_elem, (<span class="keywordtype">int</span>) v_e_a[i].size());
<a name="l01019"></a>01019   nb_aretes_elem = <a class="code" href="classProcess.html#a1e9d9f9899b71927cfafae14c7bd048d" title="Calcule le max de x sur tous les processeurs du groupe courant. Remarques : Cette methode doit etre a...">mp_max</a>(nb_aretes_elem);
<a name="l01020"></a>01020   <a class="code" href="classZone.html#ab46b40586a161b08b0a833f0352a7805">Elem_Aretes</a>.<a class="code" href="classIntTab.html#a22e6bed6826b3688d4d0181cbf3b7a38" title="Change la taille du vecteur (identique a resize_array() pour le traitement des anciennes valeurs et d...">resize</a>(0, nb_aretes_elem);
<a name="l01021"></a>01021   <a class="code" href="classZone.html#a600fa15a19c7e1384564dffd83ecab4d" title="creation d&#39;un tableau parallele de valeurs aux elements. Voir MD_Vector_tools::creer_tableau_distribu...">creer_tableau_elements</a>(<a class="code" href="classZone.html#ab46b40586a161b08b0a833f0352a7805">Elem_Aretes</a>, <a class="code" href="classArray__base.html#abee342aa9ac59623c4c782dc9d7877ffaf6ae9ba7eb51c5f298ce693345b3ec68">Array_base::NOCOPY_NOINIT</a>);
<a name="l01022"></a>01022   <span class="keywordflow">for</span> (i = 0, <a class="code" href="classZone.html#ab46b40586a161b08b0a833f0352a7805">Elem_Aretes</a> = -1; i &lt; nbelem_tot; i++)
<a name="l01023"></a>01023     <span class="keywordflow">for</span> (j = 0; j &lt; (int) v_e_a[i].size(); j++)
<a name="l01024"></a>01024       <a class="code" href="classZone.html#ab46b40586a161b08b0a833f0352a7805">Elem_Aretes</a>(i, j) = v_e_a[i][j];
<a name="l01025"></a>01025 
<a name="l01026"></a>01026 <span class="comment">// Ajuste la taille du tableau Aretes_som</span>
<a name="l01027"></a>01027   <span class="keyword">const</span> <span class="keywordtype">int</span> n_aretes_tot = <a class="code" href="classZone.html#a23956e4bc2f330a105c27dcadb80c21d">Aretes_som</a>.<a class="code" href="classIntTab.html#abc3b32c94925a82f69d5b153a356e359" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(0); <span class="comment">//!&lt; attention, nb_aretes_tot est une methode !</span>
<a name="l01028"></a>01028 <span class="comment"></span>  <a class="code" href="classZone.html#a23956e4bc2f330a105c27dcadb80c21d">Aretes_som</a>.<a class="code" href="classIntTab.html#ac0af4eac42ca46facc05f985c3ef05c6" title="Adds 1 to dimension_tot(0) and puts a in the added line.">append_line</a>(-1, -1); <span class="comment">//!&lt; car le resize suivant ne fait quelque chose que si on change de taille</span>
<a name="l01029"></a>01029 <span class="comment"></span>  <a class="code" href="classZone.html#a23956e4bc2f330a105c27dcadb80c21d">Aretes_som</a>.<a class="code" href="classArrOfInt.html#a22d744bcd452d039580d1d9186f02b4e" title="Change le mode l&#39;allocation memoire: reallocation d&#39;un tableau a chaque changement de taille (flag = ...">set_smart_resize</a>(0);
<a name="l01030"></a>01030   <a class="code" href="classZone.html#a23956e4bc2f330a105c27dcadb80c21d">Aretes_som</a>.<a class="code" href="classIntTab.html#a22e6bed6826b3688d4d0181cbf3b7a38" title="Change la taille du vecteur (identique a resize_array() pour le traitement des anciennes valeurs et d...">resize</a>(n_aretes_tot, 2);
<a name="l01031"></a>01031 
<a name="l01032"></a>01032   <a class="code" href="classProcess.html#a57e0f54b11e6eaadbea224fa904b18dd" title="Renvoie un objet statique de type Sortie qui sert de journal d&#39;evenements. Si message_level &lt;= verbose...">Journal</a>() &lt;&lt; <span class="stringliteral">&quot;Domaine &quot;</span> &lt;&lt; <a class="code" href="classZone.html#a379ad2206b5a13a4f4f3df6d44c7546a" title="Renvoie le domaine dont la zone fait partie. (version const)">domaine</a>().<a class="code" href="classDomaine.html#a87e2cdc035a26565e6fe481446aa4cd3" title="Renvoie le nom du domaine.">le_nom</a>() &lt;&lt; <span class="stringliteral">&quot; nb_aretes=&quot;</span> &lt;&lt; nb_aretes_reelles
<a name="l01033"></a>01033             &lt;&lt; <span class="stringliteral">&quot; nb_aretes_tot=&quot;</span> &lt;&lt; n_aretes_tot &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
<a name="l01034"></a>01034 
<a name="l01035"></a>01035 <span class="comment">// Construction du descripteur parallele</span>
<a name="l01036"></a>01036   {
<a name="l01037"></a>01037 <span class="comment">// Pour chaque arete, indice du processeur proprietaire de l&#39;arete</span>
<a name="l01038"></a>01038     <span class="keyword">const</span> <span class="keywordtype">int</span> moi = <a class="code" href="classProcess.html#ab55ba07167ec807ed3a145cac0f5dca4" title="renvoie mon rang dans le groupe de communication courant. Voir Comm_Group::rank() et PE_Groups::curre...">Process::me</a>();
<a name="l01039"></a>01039     <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> pe_aretes(n_aretes_tot);
<a name="l01040"></a>01040     pe_aretes=moi;
<a name="l01041"></a>01041     <a class="code" href="Faces__builder_8cpp.html#a3981bc38009477c100eca94e823234b6" title="Cette methode permet de faire un echange espace virtuel d&#39;un tableau aux aretes sans passer par le de...">echanger_tableau_aretes</a>(<a class="code" href="classZone.html#ab46b40586a161b08b0a833f0352a7805">Elem_Aretes</a>, nb_aretes_reelles, pe_aretes);
<a name="l01042"></a>01042 
<a name="l01043"></a>01043 <span class="comment">// Pour chaque arete, indice de l&#39;arete sur le processeur proprietaire</span>
<a name="l01044"></a>01044     <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> indice_aretes_owner;
<a name="l01045"></a>01045     indice_aretes_owner.<a class="code" href="classArrOfInt.html#a9b3afbb46b16870dbd36236c8935b535">resize_array</a>(n_aretes_tot, <a class="code" href="classArray__base.html#abee342aa9ac59623c4c782dc9d7877ffaf6ae9ba7eb51c5f298ce693345b3ec68">Array_base::NOCOPY_NOINIT</a>);
<a name="l01046"></a>01046     <span class="keywordflow">for</span> (i = 0; i &lt; nb_aretes_reelles; i++)
<a name="l01047"></a>01047       indice_aretes_owner[i] = i;
<a name="l01048"></a>01048     <a class="code" href="Faces__builder_8cpp.html#a3981bc38009477c100eca94e823234b6" title="Cette methode permet de faire un echange espace virtuel d&#39;un tableau aux aretes sans passer par le de...">echanger_tableau_aretes</a>(<a class="code" href="classZone.html#ab46b40586a161b08b0a833f0352a7805">Elem_Aretes</a>, nb_aretes_reelles, indice_aretes_owner);
<a name="l01049"></a>01049 
<a name="l01050"></a>01050 <span class="comment">// Construction de pe_voisins</span>
<a name="l01051"></a>01051     <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> pe_voisins;
<a name="l01052"></a>01052     pe_voisins.<a class="code" href="classArrOfInt.html#a22d744bcd452d039580d1d9186f02b4e" title="Change le mode l&#39;allocation memoire: reallocation d&#39;un tableau a chaque changement de taille (flag = ...">set_smart_resize</a>(1);
<a name="l01053"></a>01053     <span class="keywordflow">for</span> (i=0; i&lt;n_aretes_tot; i++)
<a name="l01054"></a>01054       <span class="keywordflow">if</span> (pe_aretes[i]!=moi)
<a name="l01055"></a>01055         pe_voisins.<a class="code" href="classArrOfInt.html#a3f39d0966599416e7b1f7cd8159d8d01" title="Ajoute une case en fin de tableau et y stocke la &quot;valeur&quot;.">append_array</a>(pe_aretes[i]);
<a name="l01056"></a>01056 
<a name="l01057"></a>01057     <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> liste_pe;
<a name="l01058"></a>01058     liste_pe.<a class="code" href="classArrOfInt.html#a22d744bcd452d039580d1d9186f02b4e" title="Change le mode l&#39;allocation memoire: reallocation d&#39;un tableau a chaque changement de taille (flag = ...">set_smart_resize</a>(1);
<a name="l01059"></a>01059     <a class="code" href="communications_8cpp.html#a38c9e2f958081bff6f390b56ec939523" title="Calcule la transposee d&#39;une liste de processeurs: On construit le tableau dest_list tel que: x est da...">reverse_send_recv_pe_list</a>(pe_voisins, liste_pe);
<a name="l01060"></a>01060 
<a name="l01061"></a>01061 <span class="comment">// On concatene les deux listes.</span>
<a name="l01062"></a>01062     <span class="keywordflow">for</span> (i = 0; i &lt; liste_pe.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>(); i++)
<a name="l01063"></a>01063       pe_voisins.<a class="code" href="classArrOfInt.html#a3f39d0966599416e7b1f7cd8159d8d01" title="Ajoute une case en fin de tableau et y stocke la &quot;valeur&quot;.">append_array</a>(liste_pe[i]);
<a name="l01064"></a>01064     <a class="code" href="Scatter_8cpp.html#a23c4d19dc90caae2323f04de90621709" title="Methode outil pour retirer les doublons dans un tableau.">array_trier_retirer_doublons</a>(pe_voisins);
<a name="l01065"></a>01065 
<a name="l01066"></a>01066     <span class="keywordtype">int</span> nb_voisins = pe_voisins.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>();
<a name="l01067"></a>01067     <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> indices_pe(<a class="code" href="classProcess.html#a6bf692ce58d9578aa62ac3c07b8caaa1" title="renvoie le nombre de processeurs dans le groupe courant Voir Comm_Group::nproc() et PE_Groups::curren...">nproc</a>());
<a name="l01068"></a>01068     indices_pe= -1;
<a name="l01069"></a>01069     <span class="keywordflow">for</span> (i = 0; i &lt; nb_voisins; i++)
<a name="l01070"></a>01070       indices_pe[pe_voisins[i]] = i;
<a name="l01071"></a>01071 
<a name="l01072"></a>01072     <a class="code" href="Vect_8h.html#adc7c7b04809c9aec2cb897cd2ef06378">VECT</a>(<a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>) aretes_communes_to_recv(nb_voisins);
<a name="l01073"></a>01073     <a class="code" href="Vect_8h.html#adc7c7b04809c9aec2cb897cd2ef06378">VECT</a>(<a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>) blocs_aretes_virt(nb_voisins);
<a name="l01074"></a>01074     <a class="code" href="Vect_8h.html#adc7c7b04809c9aec2cb897cd2ef06378">VECT</a>(<a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>) aretes_to_send(nb_voisins);
<a name="l01075"></a>01075     <span class="keywordflow">for</span> (i = 0; i &lt; nb_voisins; i++)
<a name="l01076"></a>01076       {
<a name="l01077"></a>01077         aretes_communes_to_recv[i].set_smart_resize(1);
<a name="l01078"></a>01078         blocs_aretes_virt[i].set_smart_resize(1);
<a name="l01079"></a>01079         aretes_to_send[i].set_smart_resize(1);
<a name="l01080"></a>01080       }
<a name="l01081"></a>01081 <span class="comment">// Parcours des aretes: recherche des aretes a recevoir d&#39;un autre processeur.</span>
<a name="l01082"></a>01082 <span class="comment">// Aretes reeles (items communs)</span>
<a name="l01083"></a>01083     <span class="keywordflow">for</span> (i = 0; i &lt; nb_aretes_reelles; i++)
<a name="l01084"></a>01084       {
<a name="l01085"></a>01085         <span class="keyword">const</span> <span class="keywordtype">int</span> pe = pe_aretes[i];
<a name="l01086"></a>01086         <span class="keywordflow">if</span> (pe != moi)
<a name="l01087"></a>01087           {
<a name="l01088"></a>01088             <span class="keyword">const</span> <span class="keywordtype">int</span> indice_pe = indices_pe[pe];
<a name="l01089"></a>01089             <span class="keywordflow">if</span> (indice_pe &lt; 0)
<a name="l01090"></a>01090               {
<a name="l01091"></a>01091                 <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Error: indice_pe=&quot;</span> &lt;&lt; indice_pe &lt;&lt; <span class="stringliteral">&quot; shouldn&#39;t be negative in Zone::creer_aretes.&quot;</span> &lt;&lt; finl;
<a name="l01092"></a>01092                 <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;It is a TRUST bug on this mesh with the Pa discretization, contact support.&quot;</span> &lt;&lt; finl;
<a name="l01093"></a>01093                 <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;You could also try another partitioned mesh to get around this issue.&quot;</span> &lt;&lt; finl;
<a name="l01094"></a>01094                 <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">exit</a>();
<a name="l01095"></a>01095               }
<a name="l01096"></a>01096 <span class="comment">// Je recois cette arete d&#39;un autre proc</span>
<a name="l01097"></a>01097             <span class="keyword">const</span> <span class="keywordtype">int</span> indice_distant = indice_aretes_owner[i];
<a name="l01098"></a>01098             aretes_to_send[indice_pe].<a class="code" href="classArrOfInt.html#a3f39d0966599416e7b1f7cd8159d8d01" title="Ajoute une case en fin de tableau et y stocke la &quot;valeur&quot;.">append_array</a>(indice_distant); <span class="comment">//!&lt; indice sur le pe voisin</span>
<a name="l01099"></a>01099 <span class="comment"></span>            aretes_communes_to_recv[indice_pe].append_array(i); <span class="comment">//!&lt; indice local de l&#39;arete</span>
<a name="l01100"></a>01100 <span class="comment"></span>          }
<a name="l01101"></a>01101       }
<a name="l01102"></a>01102 <span class="comment">// Aretes virtuelles</span>
<a name="l01103"></a>01103     <span class="keywordflow">for</span> (i = nb_aretes_reelles; i &lt; n_aretes_tot; i++)
<a name="l01104"></a>01104       {
<a name="l01105"></a>01105         <span class="keyword">const</span> <span class="keywordtype">int</span> pe = pe_aretes[i];
<a name="l01106"></a>01106         assert(pe &lt; <a class="code" href="classProcess.html#a6bf692ce58d9578aa62ac3c07b8caaa1" title="renvoie le nombre de processeurs dans le groupe courant Voir Comm_Group::nproc() et PE_Groups::curren...">nproc</a>() &amp;&amp; pe != moi);
<a name="l01107"></a>01107         <span class="keyword">const</span> <span class="keywordtype">int</span> indice_pe = indices_pe[pe];
<a name="l01108"></a>01108         <span class="keywordflow">if</span> (indice_pe &lt; 0)
<a name="l01109"></a>01109           {
<a name="l01110"></a>01110             <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Error: indice_pe=&quot;</span> &lt;&lt; indice_pe &lt;&lt; <span class="stringliteral">&quot; shouldn&#39;t be negative in Zone::creer_aretes.&quot;</span> &lt;&lt; finl;
<a name="l01111"></a>01111             <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;It is a TRUST bug on this mesh with the Pa discretization, contact support.&quot;</span> &lt;&lt; finl;
<a name="l01112"></a>01112             <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;You could also try another partitioned mesh to get around this issue.&quot;</span> &lt;&lt; finl;
<a name="l01113"></a>01113             <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">exit</a>();
<a name="l01114"></a>01114           }
<a name="l01115"></a>01115         <span class="keyword">const</span> <span class="keywordtype">int</span> indice_distant = indice_aretes_owner[i];
<a name="l01116"></a>01116         aretes_to_send[indice_pe].<a class="code" href="classArrOfInt.html#a3f39d0966599416e7b1f7cd8159d8d01" title="Ajoute une case en fin de tableau et y stocke la &quot;valeur&quot;.">append_array</a>(indice_distant); <span class="comment">//!&lt; indice sur le pe voisin</span>
<a name="l01117"></a>01117 <span class="comment"></span>        <a class="code" href="classMD__Vector__base2.html#af0e28390469007418371b633a7fad378" title="methode outil pour ajouter un item a un tableau du genre &quot;blocs&quot; contenant des series de blocs...">MD_Vector_base2::append_item_to_blocs</a>(blocs_aretes_virt[indice_pe], i);
<a name="l01118"></a>01118       }
<a name="l01119"></a>01119     {
<a name="l01120"></a>01120       <a class="code" href="classSchema__Comm.html">Schema_Comm</a> schema;
<a name="l01121"></a>01121       schema.<a class="code" href="classSchema__Comm.html#ad11c9b47999c294c26ae4df8d2bbd57b" title="Definit la liste des processeurs a qui on va envoyer et de qui on va recevoir des donnees...">set_send_recv_pe_list</a>(pe_voisins, pe_voisins);
<a name="l01122"></a>01122       schema.<a class="code" href="classSchema__Comm.html#ac617b53de22748cdd9fa30a0cfd0f4a8" title="Statut passe a WRITING Autorise si status_ == WRITING:">begin_comm</a>();
<a name="l01123"></a>01123 <span class="comment">// On empile le tableau aretes_to_send et le nombre d&#39;aretes commune avec ce pe:</span>
<a name="l01124"></a>01124       <span class="keywordflow">for</span> (i = 0; i &lt; nb_voisins; i++)
<a name="l01125"></a>01125         schema.<a class="code" href="classSchema__Comm.html#a6c771eae3b46250ae0d2f0126a7d8065" title="renvoie le buffer correspondant au processeur num_PE pour y entasser des donnees a envoyer...">send_buffer</a>(pe_voisins[i]) &lt;&lt; aretes_to_send[i];
<a name="l01126"></a>01126       schema.<a class="code" href="classSchema__Comm.html#abca0e8ac6c2b742d26f3cfaee0690c72" title="Statut passe a EXCHANGED.">echange_taille_et_messages</a>();
<a name="l01127"></a>01127 <span class="comment">// Reception</span>
<a name="l01128"></a>01128       <span class="keywordflow">for</span> (i = 0; i &lt; nb_voisins; i++)
<a name="l01129"></a>01129         schema.<a class="code" href="classSchema__Comm.html#a0c056eb81ab8fd513912b336b4d13a1a" title="renvoie le buffer correspondant au processeur num_PE pour y lire les donnees recues. Le schema doit etre dans l&#39;etat EXCHANGED.">recv_buffer</a>(pe_voisins[i]) &gt;&gt; aretes_to_send[i];
<a name="l01130"></a>01130       schema.<a class="code" href="classSchema__Comm.html#a73a981f88b6ffebc150fb46c5cce75d9" title="Statut passe a RESET Accesseurs:">end_comm</a>();
<a name="l01131"></a>01131     }
<a name="l01132"></a>01132 
<a name="l01133"></a>01133 <span class="comment">// Construit l&#39;objet descripteur</span>
<a name="l01134"></a>01134     <a class="code" href="classMD__Vector__std.html" title="C&#39;est le plus simple des descripteurs, utilise pour les tableaux de valeurs aux sommets, elements, faces, aretes, faces de bord, etc... Il supporte la notion d&#39;items &quot;communs&quot; (sommets du maillage partages entre plusieurs processeurs) et d&#39;items &quot;distants&quot; et &quot;virtuels&quot; (sommets, elements dans l&#39;epaisseur de joint). Voir aussi MD_Vector_composite (descripteur compose d&#39;une reunion de plusieurs descripteurs, pour le P1Bulle par exemple)">MD_Vector_std</a> md_aretes(n_aretes_tot,
<a name="l01135"></a>01135                             nb_aretes_reelles,
<a name="l01136"></a>01136                             pe_voisins,
<a name="l01137"></a>01137                             aretes_to_send,
<a name="l01138"></a>01138                             aretes_communes_to_recv,
<a name="l01139"></a>01139                             blocs_aretes_virt);
<a name="l01140"></a>01140     <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Total number of edges = &quot;</span> &lt;&lt; md_aretes.<a class="code" href="classMD__Vector__base2.html#a7cf9dbd94db6c0ba49e87681d207aef0">nb_items_seq_tot_</a> &lt;&lt; finl;
<a name="l01141"></a>01141 <span class="comment">// Range l&#39;objet dans un MD_Vector (devient const)</span>
<a name="l01142"></a>01142     <a class="code" href="classMD__Vector.html" title=": Cette classe est un DERIV mais l&#39;objet pointe est partage entre plusieurs instances de cette classe...">MD_Vector</a> md;
<a name="l01143"></a>01143     md.<a class="code" href="classMD__Vector.html#a063644dd8ca62e707a2d059eedeb58a7" title="construction d&#39;un objet MD_Vector par copie d&#39;un objet existant. C&#39;est la methode recommandee pour cr...">copy</a>(md_aretes);
<a name="l01144"></a>01144 <span class="comment">// Attache le descripteur au tableau</span>
<a name="l01145"></a>01145     <a class="code" href="classZone.html#a23956e4bc2f330a105c27dcadb80c21d">Aretes_som</a>.<a class="code" href="classIntTab.html#a02470d5d5921700f4daee05a5b3d2601" title="associe le md_vector au vecteur (voir IntVect::set_md_vector()) dimension(0) sera initialise a md_vec...">set_md_vector</a>(md);
<a name="l01146"></a>01146   }
<a name="l01147"></a>01147 }
<a name="l01148"></a>01148 
</pre></div></div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Tue Dec 14 2021 19:35:18 for TRUST by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
