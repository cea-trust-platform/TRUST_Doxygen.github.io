<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>TRUST: src/Kernel/Geometrie/Connex_components.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">TRUST<span id="projectnumber">&#160;1.9.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="dir_4ebb9cf478835123b919db691d6366a3.html">Kernel</a></li><li class="navelem"><a class="el" href="dir_248459fe65344770a2fa593f47170c23.html">Geometrie</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Connex_components.h File Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;<a class="el" href="Connectivite__som__elem_8h_source.html">Connectivite_som_elem.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="TRUSTTabs__forward_8h_source.html">TRUSTTabs_forward.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="arch_8h_source.html">arch.h</a>&gt;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for Connex_components.h:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="Connex__components_8h__incl.svg" width="359" height="202"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</div><div class="textblock"><div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="Connex__components_8h__dep__incl.svg" width="200" height="142"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</div>
<p><a href="Connex__components_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ad771774190b40158b92030966f3f5a17"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Connex__components_8h.html#ad771774190b40158b92030966f3f5a17">search_connex_components_local</a> (const <a class="el" href="TRUSTTab_8h.html#a065b78ba28f61d9465e585c97135364c">IntTab</a> &amp;elem_faces, const <a class="el" href="TRUSTTab_8h.html#a065b78ba28f61d9465e585c97135364c">IntTab</a> &amp;faces_elem, <a class="el" href="TRUSTTabs__forward_8h.html#af6acf03d86acc37bcfb1375968278c0f">IntVect</a> &amp;num_compo)</td></tr>
<tr class="memdesc:ad771774190b40158b92030966f3f5a17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calcul des ensembles connexes par faces d'elements<br  />
non "marques" (les elements sont relies entre eux par un graphe<br  />
symetrique passant par les faces).<br  />
Une portion de domaine connexe porte un numero 0 &lt;= i &lt; N<br  />
unique et est delimite soit par un bord, soit par un element voisin "marque"<br  />
par num_compo[elem] = -1.<br  />
Cette methode est sequentielle (peut etre appelee sur un seul processeur)<br  />
Parametre: elem_faces<br  />
graph de connectivite elements-faces (pour chaque element i, indices<br  />
des faces de cet element), voir <a class="el" href="classZone__VF.html#a8e09b61902b9f1d2c4c7bedc3b8f39d3" title="renvoie le tableau de connectivite element/faces">Zone_VF::elem_faces()</a><br  />
Parametre: faces_elem<br  />
graph de connectivite faces-elements (pour chaque face, indice du<br  />
ou des deux elements adjacents), voir <a class="el" href="classZone__VF.html#a05b26c350e24c059f7076a7c2020dbdc" title="renvoie le tableaux des volumes des connectivites face elements cf au dessus.">Zone_VF::face_voisins()</a><br  />
Parametre: num_compo<br  />
En entree, un tableau tel que num_compo.size_array() == elem_faces.dimension_tot(0),<br  />
et dont certaines valeurs valent -1 (elements marques), et d'autres non.<br  />
En sortie: les elements pour lesquels num_compo = -1 ne sont pas modifies, les autres<br  />
sont numerotes par composante connexe locale. On remplit tout le tableau<br  />
jusqu'a size_tot() y compris les elements virtuels. Les numeros de composantes<br  />
sont locaux a ce processeur.<br  />
Valeur de retour: N, nombre de composantes connexes locales.  <a href="Connex__components_8h.html#ad771774190b40158b92030966f3f5a17">More...</a><br /></td></tr>
<tr class="separator:ad771774190b40158b92030966f3f5a17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e4b3977c09e7f6f4e8a3d554c05e727"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Connex__components_8h.html#a1e4b3977c09e7f6f4e8a3d554c05e727">compute_graph_connex_components</a> (const <a class="el" href="TRUSTTab_8h.html#a065b78ba28f61d9465e585c97135364c">IntTab</a> &amp;graph, <a class="el" href="TRUSTArray_8h.html#af4ca55b348855905aeda61884ae11154">ArrOfInt</a> &amp;connex_components)</td></tr>
<tr class="memdesc:a1e4b3977c09e7f6f4e8a3d554c05e727"><td class="mdescLeft">&#160;</td><td class="mdescRight">recherche des composantes connexes d'un graphe local (non distribue<br  />
sur les processeurs) non symetrique.<br  />
Parametre: graph<br  />
On suppose que "graph" est un tableau a deux colonnes<br  />
contenant des couples d'indices de "sommets" d'un graphe. Ces couples definissent<br  />
un graphe dont on veut chercher les composantes connexes:<br  />
deux indices i et j sont dans la meme composante connexe si et seulement si il<br  />
existe une suite de couples qui relient directement ou indirectement i et j.<br  />
Parametre: connex_components<br  />
On suppose que connex_components est dimensionne a nb_sommets, le nombre de sommets du graphe.<br  />
On met dans connex_components[i] le numero de la composante connexe du graphe a laquelle appartient<br  />
le "sommet" i. On attribue tous les numeros i tels que 0 &lt;= i &lt; N<br  />
Valeur de retour: le nombre N de composantes connexes trouvees.  <a href="Connex__components_8h.html#a1e4b3977c09e7f6f4e8a3d554c05e727">More...</a><br /></td></tr>
<tr class="separator:a1e4b3977c09e7f6f4e8a3d554c05e727"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a476f055e17d2b6b039961d59afb7ebcb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Connex__components_8h.html#a476f055e17d2b6b039961d59afb7ebcb">compute_global_connex_components</a> (<a class="el" href="TRUSTTabs__forward_8h.html#af6acf03d86acc37bcfb1375968278c0f">IntVect</a> &amp;num_compo, int nb_local_components)</td></tr>
<tr class="memdesc:a476f055e17d2b6b039961d59afb7ebcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recherche les composantes connexes d'un ensemble d'elements distribue sur<br  />
tous les processeurs. Cette methode est parallele et doit etre appelee en<br  />
meme temps sur tous les processeurs.<br  />
Parametre: num_compo<br  />
num_compo doit avoir au moins une couche d'elements virtuels et doit contenir<br  />
le resultat de la methode <a class="el" href="Connex__components_8cpp.html#ad771774190b40158b92030966f3f5a17" title="Calcul des ensembles connexes par faces d&#39;elements non &quot;marques&quot; (les elements sont relies entre eux ...">search_connex_components_local()</a>. Les elements<br  />
virtuels ont donc ete remplis avec des numeros de composantes connexes locales.<br  />
Le tableau num_compo ne doit PAS avoir subi echange_espace_virtuel !!!<br  />
On cherche a l'aide des elements virtuels les composantes connexes connectees<br  />
entre elles entre deux processeurs et on leur attribue un numero unique i tel<br  />
que tous les indices 0 &lt;= i &lt; N sont utilises.<br  />
Parametre: nb_local_components<br  />
doit contenir le nombre de composantes connexes locales utilisees<br  />
dans num_compo a l'entree (egale a la valeur de retour de la fonction<br  />
<a class="el" href="Connex__components_8cpp.html#ad771774190b40158b92030966f3f5a17" title="Calcul des ensembles connexes par faces d&#39;elements non &quot;marques&quot; (les elements sont relies entre eux ...">search_connex_components_local()</a>).<br  />
Valeur de retour: nombre N de composantes connexes globales trouvees.  <a href="Connex__components_8h.html#a476f055e17d2b6b039961d59afb7ebcb">More...</a><br /></td></tr>
<tr class="separator:a476f055e17d2b6b039961d59afb7ebcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="a476f055e17d2b6b039961d59afb7ebcb" name="a476f055e17d2b6b039961d59afb7ebcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a476f055e17d2b6b039961d59afb7ebcb">&#9670;&nbsp;</a></span>compute_global_connex_components()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int compute_global_connex_components </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="TRUSTTabs__forward_8h.html#af6acf03d86acc37bcfb1375968278c0f">IntVect</a> &amp;&#160;</td>
          <td class="paramname"><em>num_compo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nb_local_components</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Recherche les composantes connexes d'un ensemble d'elements distribue sur<br  />
tous les processeurs. Cette methode est parallele et doit etre appelee en<br  />
meme temps sur tous les processeurs.<br  />
Parametre: num_compo<br  />
num_compo doit avoir au moins une couche d'elements virtuels et doit contenir<br  />
le resultat de la methode <a class="el" href="Connex__components_8cpp.html#ad771774190b40158b92030966f3f5a17" title="Calcul des ensembles connexes par faces d&#39;elements non &quot;marques&quot; (les elements sont relies entre eux ...">search_connex_components_local()</a>. Les elements<br  />
virtuels ont donc ete remplis avec des numeros de composantes connexes locales.<br  />
Le tableau num_compo ne doit PAS avoir subi echange_espace_virtuel !!!<br  />
On cherche a l'aide des elements virtuels les composantes connexes connectees<br  />
entre elles entre deux processeurs et on leur attribue un numero unique i tel<br  />
que tous les indices 0 &lt;= i &lt; N sont utilises.<br  />
Parametre: nb_local_components<br  />
doit contenir le nombre de composantes connexes locales utilisees<br  />
dans num_compo a l'entree (egale a la valeur de retour de la fonction<br  />
<a class="el" href="Connex__components_8cpp.html#ad771774190b40158b92030966f3f5a17" title="Calcul des ensembles connexes par faces d&#39;elements non &quot;marques&quot; (les elements sont relies entre eux ...">search_connex_components_local()</a>).<br  />
Valeur de retour: nombre N de composantes connexes globales trouvees. </p>

<p class="definition">Definition at line <a class="el" href="Connex__components_8cpp_source.html#l00207">207</a> of file <a class="el" href="Connex__components_8cpp_source.html">Connex_components.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  208</span>{</div>
<div class="line"><span class="lineno">  209</span>  <span class="keyword">const</span> <span class="keywordtype">int</span> nbelem = num_compo.<a class="code hl_function" href="classTRUSTVect.html#ae94cb18641c81d97b4011f129dba7ba9">size</a>();</div>
<div class="line"><span class="lineno">  210</span>  <span class="keyword">const</span> <span class="keywordtype">int</span> nbelem_tot = num_compo.<a class="code hl_function" href="classTRUSTVect.html#a5ae6fa5040fbdc708e54a7aba732413f">size_totale</a>();</div>
<div class="line"><span class="lineno">  211</span><span class="comment">// int i;</span></div>
<div class="line"><span class="lineno">  212</span> </div>
<div class="line"><span class="lineno">  213</span><span class="comment">// Transformation des indices locaux de composantes connexes en un indice global</span></div>
<div class="line"><span class="lineno">  214</span><span class="comment">// (on ajoute un decalage aux indices globaux avec mppartial_sum())</span></div>
<div class="line"><span class="lineno">  215</span>  <span class="keyword">const</span> <span class="keywordtype">int</span> decalage = <a class="code hl_function" href="communications_8cpp.html#a13b5bdc7cfe14771b52a033b1ecbc071">mppartial_sum</a>(nb_local_components);</div>
<div class="line"><span class="lineno">  216</span>  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_total_components = <a class="code hl_function" href="classProcess.html#a7d23bc1ef94b3f0623fbc79d034c27fd">Process::mp_sum</a>(nb_local_components);</div>
<div class="line"><span class="lineno">  217</span>  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; nbelem_tot; i++)</div>
<div class="line"><span class="lineno">  218</span>    <span class="keywordflow">if</span> (num_compo[i] &gt;= 0)</div>
<div class="line"><span class="lineno">  219</span>      num_compo[i] += decalage;</div>
<div class="line"><span class="lineno">  220</span> </div>
<div class="line"><span class="lineno">  221</span><span class="comment">// Pour trouver les correspondances entre un numero de composante locale et un</span></div>
<div class="line"><span class="lineno">  222</span><span class="comment">// numero de la meme composante sur le processeur voisin, on cree une copie du</span></div>
<div class="line"><span class="lineno">  223</span><span class="comment">// tableau num_compo sur laquelle on fait un echange_espace_virtuel(). Ainsi,</span></div>
<div class="line"><span class="lineno">  224</span><span class="comment">// sur les cases virtuelles du tableau, on a dans num_compo le numero de la</span></div>
<div class="line"><span class="lineno">  225</span><span class="comment">// composante locale et dans copie_compo le numero de cette meme composante sur</span></div>
<div class="line"><span class="lineno">  226</span><span class="comment">// le processeur proprietaire de l&#39;element. Donc ces deux numeros designent</span></div>
<div class="line"><span class="lineno">  227</span><span class="comment">// la meme composante connexe.</span></div>
<div class="line"><span class="lineno">  228</span>  <a class="code hl_class" href="classTRUSTVect.html">IntVect</a> copie_compo(num_compo);</div>
<div class="line"><span class="lineno">  229</span>  copie_compo.echange_espace_virtuel();</div>
<div class="line"><span class="lineno">  230</span> </div>
<div class="line"><span class="lineno">  231</span><span class="comment">// Recherche des equivalences entre les numeros des composantes locales et</span></div>
<div class="line"><span class="lineno">  232</span><span class="comment">// les numeros des composantes voisines. On construit un graphe dont les</span></div>
<div class="line"><span class="lineno">  233</span><span class="comment">// liens relient les composantes equivalentes.</span></div>
<div class="line"><span class="lineno">  234</span><span class="comment">// Tableau de marqeurs pour les equivalences deja trouvees.</span></div>
<div class="line"><span class="lineno">  235</span><span class="comment">// Dimensions = nb composantes locales * nb_composantes total</span></div>
<div class="line"><span class="lineno">  236</span><span class="comment">// (pour ne pas prendre en compte la meme composante plusieurs fois).</span></div>
<div class="line"><span class="lineno">  237</span>  <a class="code hl_class" href="classArrOfBit.html">ArrOfBit</a> markers(nb_local_components * nb_total_components);</div>
<div class="line"><span class="lineno">  238</span>  markers = 0;</div>
<div class="line"><span class="lineno">  239</span><span class="comment">// Tableau de correspondances entre composantes connexes locales et distantes</span></div>
<div class="line"><span class="lineno">  240</span>  <a class="code hl_class" href="classTRUSTTab.html">IntTab</a> graph;</div>
<div class="line"><span class="lineno">  241</span>  graph.<a class="code hl_function" href="classTRUSTArray.html#a7c2cb947c5f755b7bcc8256246ccfdb5">set_smart_resize</a>(1);</div>
<div class="line"><span class="lineno">  242</span>  <span class="keywordtype">int</span> graph_size = 0;</div>
<div class="line"><span class="lineno">  243</span><span class="comment">// Parcours des elements virtuels uniquement</span></div>
<div class="line"><span class="lineno">  244</span>  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = nbelem; i &lt; nbelem_tot; i++)</div>
<div class="line"><span class="lineno">  245</span>    {</div>
<div class="line"><span class="lineno">  246</span>      <span class="keywordtype">int</span> compo = num_compo[i];</div>
<div class="line"><span class="lineno">  247</span>      <span class="keywordflow">if</span> (compo &lt; 0)</div>
<div class="line"><span class="lineno">  248</span>        <span class="keywordflow">continue</span>;</div>
<div class="line"><span class="lineno">  249</span>      <span class="keywordtype">int</span> compo2 = copie_compo[i];</div>
<div class="line"><span class="lineno">  250</span><span class="comment">// Index du couple compo2/compo dans le tableau markers</span></div>
<div class="line"><span class="lineno">  251</span><span class="comment">// Le tableau num_compo ne doit contenir que des composantes locales:</span></div>
<div class="line"><span class="lineno">  252</span>      assert(compo &gt;= decalage &amp;&amp; compo - decalage &lt; nb_local_components);</div>
<div class="line"><span class="lineno">  253</span><span class="comment">// compo2 est forcement une composante distante.</span></div>
<div class="line"><span class="lineno">  254</span>      assert(compo2 &lt; decalage || compo2 - decalage &gt;= nb_local_components);</div>
<div class="line"><span class="lineno">  255</span>      <span class="keyword">const</span> <span class="keywordtype">int</span> index = (compo - decalage) * nb_total_components + compo2;</div>
<div class="line"><span class="lineno">  256</span>      <span class="keywordflow">if</span> (!markers.testsetbit(index))</div>
<div class="line"><span class="lineno">  257</span>        {</div>
<div class="line"><span class="lineno">  258</span>          graph.<a class="code hl_function" href="classTRUSTTab.html#a33c4f72e40e49cdb553fc7311fe656bc">resize</a>(graph_size+1, 2);</div>
<div class="line"><span class="lineno">  259</span><span class="comment">// On met le plus petit numero de composante en colonne 0:</span></div>
<div class="line"><span class="lineno">  260</span>          <span class="keywordflow">if</span> (compo2 &lt; compo)</div>
<div class="line"><span class="lineno">  261</span>            {</div>
<div class="line"><span class="lineno">  262</span>              <span class="keywordtype">int</span> tmp = compo;</div>
<div class="line"><span class="lineno">  263</span>              compo = compo2;</div>
<div class="line"><span class="lineno">  264</span>              compo2 = tmp;</div>
<div class="line"><span class="lineno">  265</span>            }</div>
<div class="line"><span class="lineno">  266</span>          graph(graph_size, 0) = compo;</div>
<div class="line"><span class="lineno">  267</span>          graph(graph_size, 1) = compo2;</div>
<div class="line"><span class="lineno">  268</span>          graph_size++;</div>
<div class="line"><span class="lineno">  269</span>        }</div>
<div class="line"><span class="lineno">  270</span>    }</div>
<div class="line"><span class="lineno">  271</span> </div>
<div class="line"><span class="lineno">  272</span>  <a class="code hl_class" href="classTRUSTArray.html">ArrOfInt</a> renum;</div>
<div class="line"><span class="lineno">  273</span>  <span class="keywordflow">if</span> (<a class="code hl_function" href="classProcess.html#acd052b99706c577f8a5b6656217cf4c2">Process::je_suis_maitre</a>())</div>
<div class="line"><span class="lineno">  274</span>    {</div>
<div class="line"><span class="lineno">  275</span><span class="comment">// Reception des portions de graphe des autres processeurs</span></div>
<div class="line"><span class="lineno">  276</span>      <a class="code hl_class" href="classTRUSTTab.html">IntTab</a> tmp;</div>
<div class="line"><span class="lineno">  277</span>      <span class="keyword">const</span> <span class="keywordtype">int</span> nproc = <a class="code hl_function" href="classProcess.html#a6bf692ce58d9578aa62ac3c07b8caaa1">Process::nproc</a>();</div>
<div class="line"><span class="lineno">  278</span>      <span class="keywordtype">int</span> pe;</div>
<div class="line"><span class="lineno">  279</span>      <span class="keywordflow">for</span> (pe = 1; pe &lt; nproc; pe++)</div>
<div class="line"><span class="lineno">  280</span>        {</div>
<div class="line"><span class="lineno">  281</span>          <a class="code hl_function" href="communications_8cpp.html#a486fb18563e940716d63be14ea997826">recevoir</a>(tmp, pe, 54 <span class="comment">/* tag */</span>);</div>
<div class="line"><span class="lineno">  282</span>          <span class="keyword">const</span> <span class="keywordtype">int</span> n2 = tmp.<a class="code hl_function" href="classTRUSTTab.html#a8fecd3f1f3a13e933c3f767a25c54805">dimension</a>(0);</div>
<div class="line"><span class="lineno">  283</span>          graph.<a class="code hl_function" href="classTRUSTTab.html#a33c4f72e40e49cdb553fc7311fe656bc">resize</a>(graph_size + n2, 2);</div>
<div class="line"><span class="lineno">  284</span>          <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; n2; i++)</div>
<div class="line"><span class="lineno">  285</span>            {</div>
<div class="line"><span class="lineno">  286</span>              graph(graph_size, 0) = tmp(i, 0);</div>
<div class="line"><span class="lineno">  287</span>              graph(graph_size, 1) = tmp(i, 1);</div>
<div class="line"><span class="lineno">  288</span>              graph_size++;</div>
<div class="line"><span class="lineno">  289</span>            }</div>
<div class="line"><span class="lineno">  290</span>        }</div>
<div class="line"><span class="lineno">  291</span><span class="comment">// Calcul des composantes connexes du graphe</span></div>
<div class="line"><span class="lineno">  292</span>      renum.<a class="code hl_function" href="classTRUSTArray.html#a7fdab39e76f6cb0f5a5691eaaee32d8c">resize_array</a>(nb_total_components);</div>
<div class="line"><span class="lineno">  293</span>      <span class="keyword">const</span> <span class="keywordtype">int</span> n = <a class="code hl_function" href="Connex__components_8cpp.html#a1e4b3977c09e7f6f4e8a3d554c05e727">compute_graph_connex_components</a>(graph, renum);</div>
<div class="line"><span class="lineno">  294</span>      <a class="code hl_function" href="classProcess.html#a57e0f54b11e6eaadbea224fa904b18dd">Process::Journal</a>() &lt;&lt; <span class="stringliteral">&quot;compute_global_connex_components: nb_components=&quot;</span> &lt;&lt; n &lt;&lt; <a class="code hl_variable" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;</div>
<div class="line"><span class="lineno">  295</span>    }</div>
<div class="line"><span class="lineno">  296</span>  <span class="keywordflow">else</span></div>
<div class="line"><span class="lineno">  297</span>    {</div>
<div class="line"><span class="lineno">  298</span><span class="comment">// Envoi du graphe local au processeur 0</span></div>
<div class="line"><span class="lineno">  299</span>      <a class="code hl_function" href="communications_8cpp.html#adf84865cbc943510d0bbef3fa31be03b">envoyer</a>(graph, 0, 54 <span class="comment">/* tag */</span>);</div>
<div class="line"><span class="lineno">  300</span>    }</div>
<div class="line"><span class="lineno">  301</span> </div>
<div class="line"><span class="lineno">  302</span><span class="comment">// Reception des composantes connexes</span></div>
<div class="line"><span class="lineno">  303</span>  <a class="code hl_function" href="communications_8cpp.html#ac27e5b453a41187241fa75bfd2e76df2">envoyer_broadcast</a>(renum, 0 <span class="comment">/* processeur source */</span>);</div>
<div class="line"><span class="lineno">  304</span> </div>
<div class="line"><span class="lineno">  305</span><span class="comment">// Renumerotation des composantes dans num_compo</span></div>
<div class="line"><span class="lineno">  306</span>  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; nbelem_tot; i++)</div>
<div class="line"><span class="lineno">  307</span>    {</div>
<div class="line"><span class="lineno">  308</span>      <span class="keyword">const</span> <span class="keywordtype">int</span> x = num_compo[i];</div>
<div class="line"><span class="lineno">  309</span>      <span class="keywordflow">if</span> (x &gt;= 0)</div>
<div class="line"><span class="lineno">  310</span>        {</div>
<div class="line"><span class="lineno">  311</span>          <span class="keyword">const</span> <span class="keywordtype">int</span> new_x = renum[x];</div>
<div class="line"><span class="lineno">  312</span>          num_compo[i] = new_x;</div>
<div class="line"><span class="lineno">  313</span>        }</div>
<div class="line"><span class="lineno">  314</span>    }</div>
<div class="line"><span class="lineno">  315</span><span class="comment">// Verification: si on fait un echange espace virtuel,</span></div>
<div class="line"><span class="lineno">  316</span><span class="comment">// cela ne doit par changer le numero des composantes</span></div>
<div class="line"><span class="lineno">  317</span><span class="comment">// connexes !</span></div>
<div class="line"><span class="lineno">  318</span> </div>
<div class="line"><span class="lineno">  319</span>  <span class="keywordtype">int</span> nb_components = 0;</div>
<div class="line"><span class="lineno">  320</span><span class="comment">// Tous les processeurs possedent le meme tableau renum, tout le monde</span></div>
<div class="line"><span class="lineno">  321</span><span class="comment">// calcule donc le meme maximum !</span></div>
<div class="line"><span class="lineno">  322</span>  <span class="keywordflow">if</span> (renum.<a class="code hl_function" href="classTRUSTArray.html#ac03d475a56970fcc19cf624a0353e42e">size_array</a>() &gt; 0)</div>
<div class="line"><span class="lineno">  323</span>    nb_components = <a class="code hl_function" href="TRUSTArray__tools_8tpp.html#ae9f568bb017d31ce0f5320b9a9db608f">max_array</a>(renum) + 1;</div>
<div class="line"><span class="lineno">  324</span>  <span class="keywordflow">return</span> nb_components;</div>
<div class="line"><span class="lineno">  325</span>}</div>
<div class="ttc" id="aConnex__components_8cpp_html_a1e4b3977c09e7f6f4e8a3d554c05e727"><div class="ttname"><a href="Connex__components_8cpp.html#a1e4b3977c09e7f6f4e8a3d554c05e727">compute_graph_connex_components</a></div><div class="ttdeci">int compute_graph_connex_components(const IntTab &amp;graph, ArrOfInt &amp;connex_components)</div><div class="ttdoc">recherche des composantes connexes d'un graphe local (non distribue sur les processeurs) non symetriq...</div><div class="ttdef"><b>Definition:</b> <a href="Connex__components_8cpp_source.html#l00117">Connex_components.cpp:117</a></div></div>
<div class="ttc" id="aEntreeSortie_8h_html_a7f716d3c5b6411631d5d0700ead09467"><div class="ttname"><a href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a></div><div class="ttdeci">const Separateur finl</div></div>
<div class="ttc" id="aTRUSTArray__tools_8tpp_html_ae9f568bb017d31ce0f5320b9a9db608f"><div class="ttname"><a href="TRUSTArray__tools_8tpp.html#ae9f568bb017d31ce0f5320b9a9db608f">max_array</a></div><div class="ttdeci">_TYPE_ max_array(const TRUSTArray&lt; _TYPE_ &gt; &amp;dx)</div><div class="ttdoc">Retourne la valeur maximale.</div><div class="ttdef"><b>Definition:</b> <a href="TRUSTArray__tools_8tpp_source.html#l00110">TRUSTArray_tools.tpp:110</a></div></div>
<div class="ttc" id="aclassArrOfBit_html"><div class="ttname"><a href="classArrOfBit.html">ArrOfBit</a></div><div class="ttdef"><b>Definition:</b> <a href="ArrOfBit_8h_source.html#l00022">ArrOfBit.h:23</a></div></div>
<div class="ttc" id="aclassProcess_html_a57e0f54b11e6eaadbea224fa904b18dd"><div class="ttname"><a href="classProcess.html#a57e0f54b11e6eaadbea224fa904b18dd">Process::Journal</a></div><div class="ttdeci">static Sortie &amp; Journal(int message_level=0)</div><div class="ttdoc">Renvoie un objet statique de type Sortie qui sert de journal d'evenements. Si message_level &lt;= verbos...</div><div class="ttdef"><b>Definition:</b> <a href="Process_8cpp_source.html#l00335">Process.cpp:335</a></div></div>
<div class="ttc" id="aclassProcess_html_a6bf692ce58d9578aa62ac3c07b8caaa1"><div class="ttname"><a href="classProcess.html#a6bf692ce58d9578aa62ac3c07b8caaa1">Process::nproc</a></div><div class="ttdeci">static int nproc()</div><div class="ttdoc">renvoie le nombre de processeurs dans le groupe courant Voir Comm_Group::nproc() et PE_Groups::curren...</div><div class="ttdef"><b>Definition:</b> <a href="Process_8cpp_source.html#l00099">Process.cpp:99</a></div></div>
<div class="ttc" id="aclassProcess_html_a7d23bc1ef94b3f0623fbc79d034c27fd"><div class="ttname"><a href="classProcess.html#a7d23bc1ef94b3f0623fbc79d034c27fd">Process::mp_sum</a></div><div class="ttdeci">static double mp_sum(double)</div><div class="ttdoc">Calcule la somme de x sur tous les processeurs du groupe courant. Voir aussi mp_max()</div><div class="ttdef"><b>Definition:</b> <a href="Process_8cpp_source.html#l00168">Process.cpp:168</a></div></div>
<div class="ttc" id="aclassProcess_html_acd052b99706c577f8a5b6656217cf4c2"><div class="ttname"><a href="classProcess.html#acd052b99706c577f8a5b6656217cf4c2">Process::je_suis_maitre</a></div><div class="ttdeci">static int je_suis_maitre()</div><div class="ttdoc">renvoie 1 si on est sur le processeur maitre du groupe courant (c'est a dire me() == 0),...</div><div class="ttdef"><b>Definition:</b> <a href="Process_8cpp_source.html#l00085">Process.cpp:85</a></div></div>
<div class="ttc" id="aclassTRUSTArray_html"><div class="ttname"><a href="classTRUSTArray.html">TRUSTArray&lt; int &gt;</a></div></div>
<div class="ttc" id="aclassTRUSTArray_html_a7c2cb947c5f755b7bcc8256246ccfdb5"><div class="ttname"><a href="classTRUSTArray.html#a7c2cb947c5f755b7bcc8256246ccfdb5">TRUSTArray::set_smart_resize</a></div><div class="ttdeci">void set_smart_resize(int flag)</div><div class="ttdef"><b>Definition:</b> <a href="TRUSTArray_8tpp_source.html#l00058">TRUSTArray.tpp:58</a></div></div>
<div class="ttc" id="aclassTRUSTArray_html_a7fdab39e76f6cb0f5a5691eaaee32d8c"><div class="ttname"><a href="classTRUSTArray.html#a7fdab39e76f6cb0f5a5691eaaee32d8c">TRUSTArray::resize_array</a></div><div class="ttdeci">void resize_array(int new_size, Array_base::Resize_Options opt=COPY_INIT)</div><div class="ttdef"><b>Definition:</b> <a href="TRUSTArray_8tpp_source.html#l00038">TRUSTArray.tpp:38</a></div></div>
<div class="ttc" id="aclassTRUSTArray_html_ac03d475a56970fcc19cf624a0353e42e"><div class="ttname"><a href="classTRUSTArray.html#ac03d475a56970fcc19cf624a0353e42e">TRUSTArray::size_array</a></div><div class="ttdeci">int size_array() const</div><div class="ttdef"><b>Definition:</b> <a href="TRUSTArray_8tpp_source.html#l00195">TRUSTArray.tpp:195</a></div></div>
<div class="ttc" id="aclassTRUSTTab_html"><div class="ttname"><a href="classTRUSTTab.html">TRUSTTab&lt; int &gt;</a></div></div>
<div class="ttc" id="aclassTRUSTTab_html_a33c4f72e40e49cdb553fc7311fe656bc"><div class="ttname"><a href="classTRUSTTab.html#a33c4f72e40e49cdb553fc7311fe656bc">TRUSTTab::resize</a></div><div class="ttdeci">void resize(int n, Array_base::Resize_Options opt=Array_base::COPY_INIT)</div><div class="ttdef"><b>Definition:</b> <a href="TRUSTTab_8tpp_source.html#l00313">TRUSTTab.tpp:313</a></div></div>
<div class="ttc" id="aclassTRUSTTab_html_a8fecd3f1f3a13e933c3f767a25c54805"><div class="ttname"><a href="classTRUSTTab.html#a8fecd3f1f3a13e933c3f767a25c54805">TRUSTTab::dimension</a></div><div class="ttdeci">int dimension(int) const</div><div class="ttdef"><b>Definition:</b> <a href="TRUSTTab_8tpp_source.html#l00119">TRUSTTab.tpp:119</a></div></div>
<div class="ttc" id="aclassTRUSTVect_html"><div class="ttname"><a href="classTRUSTVect.html">TRUSTVect&lt; int &gt;</a></div></div>
<div class="ttc" id="aclassTRUSTVect_html_a5ae6fa5040fbdc708e54a7aba732413f"><div class="ttname"><a href="classTRUSTVect.html#a5ae6fa5040fbdc708e54a7aba732413f">TRUSTVect::size_totale</a></div><div class="ttdeci">int size_totale() const</div><div class="ttdef"><b>Definition:</b> <a href="TRUSTVect_8tpp_source.html#l00058">TRUSTVect.tpp:58</a></div></div>
<div class="ttc" id="aclassTRUSTVect_html_ae94cb18641c81d97b4011f129dba7ba9"><div class="ttname"><a href="classTRUSTVect.html#ae94cb18641c81d97b4011f129dba7ba9">TRUSTVect::size</a></div><div class="ttdeci">int size() const</div><div class="ttdef"><b>Definition:</b> <a href="TRUSTVect_8tpp_source.html#l00044">TRUSTVect.tpp:44</a></div></div>
<div class="ttc" id="acommunications_8cpp_html_a13b5bdc7cfe14771b52a033b1ecbc071"><div class="ttname"><a href="communications_8cpp.html#a13b5bdc7cfe14771b52a033b1ecbc071">mppartial_sum</a></div><div class="ttdeci">int mppartial_sum(int x)</div><div class="ttdoc">Calul de la somme partielle de i sur les processeurs 0 a me()-1 (renvoie 0 sur le processeur 0)....</div><div class="ttdef"><b>Definition:</b> <a href="communications_8cpp_source.html#l00297">communications.cpp:297</a></div></div>
<div class="ttc" id="acommunications_8cpp_html_a486fb18563e940716d63be14ea997826"><div class="ttname"><a href="communications_8cpp.html#a486fb18563e940716d63be14ea997826">recevoir</a></div><div class="ttdeci">int recevoir(Objet_U &amp;t, int source, int cible, int canal)</div><div class="ttdef"><b>Definition:</b> <a href="communications_8cpp_source.html#l00158">communications.cpp:158</a></div></div>
<div class="ttc" id="acommunications_8cpp_html_ac27e5b453a41187241fa75bfd2e76df2"><div class="ttname"><a href="communications_8cpp.html#ac27e5b453a41187241fa75bfd2e76df2">envoyer_broadcast</a></div><div class="ttdeci">int envoyer_broadcast(Objet_U &amp;t, int source)</div><div class="ttdef"><b>Definition:</b> <a href="communications_8cpp_source.html#l00168">communications.cpp:168</a></div></div>
<div class="ttc" id="acommunications_8cpp_html_adf84865cbc943510d0bbef3fa31be03b"><div class="ttname"><a href="communications_8cpp.html#adf84865cbc943510d0bbef3fa31be03b">envoyer</a></div><div class="ttdeci">int envoyer(const Objet_U &amp;t, int source, int cible, int canal)</div><div class="ttdef"><b>Definition:</b> <a href="communications_8cpp_source.html#l00148">communications.cpp:148</a></div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="Connex__components_8cpp_source.html#l00117">compute_graph_connex_components()</a>, <a class="el" href="TRUSTTab_8tpp_source.html#l00119">TRUSTTab&lt; _TYPE_ &gt;::dimension()</a>, <a class="el" href="TRUSTVect_8tpp_source.html#l00267">TRUSTVect&lt; _TYPE_ &gt;::echange_espace_virtuel()</a>, <a class="el" href="communications_8cpp_source.html#l00148">envoyer()</a>, <a class="el" href="communications_8cpp_source.html#l00168">envoyer_broadcast()</a>, <a class="el" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>, <a class="el" href="Process_8cpp_source.html#l00085">Process::je_suis_maitre()</a>, <a class="el" href="Process_8cpp_source.html#l00335">Process::Journal()</a>, <a class="el" href="TRUSTArray__tools_8tpp_source.html#l00110">max_array()</a>, <a class="el" href="Process_8cpp_source.html#l00168">Process::mp_sum()</a>, <a class="el" href="communications_8cpp_source.html#l00297">mppartial_sum()</a>, <a class="el" href="Process_8cpp_source.html#l00099">Process::nproc()</a>, <a class="el" href="communications_8cpp_source.html#l00158">recevoir()</a>, <a class="el" href="TRUSTTab_8tpp_source.html#l00313">TRUSTTab&lt; _TYPE_ &gt;::resize()</a>, <a class="el" href="TRUSTArray_8tpp_source.html#l00038">TRUSTArray&lt; _TYPE_ &gt;::resize_array()</a>, <a class="el" href="TRUSTArray_8tpp_source.html#l00058">TRUSTArray&lt; _TYPE_ &gt;::set_smart_resize()</a>, <a class="el" href="TRUSTVect_8tpp_source.html#l00044">TRUSTVect&lt; _TYPE_ &gt;::size()</a>, <a class="el" href="TRUSTArray_8tpp_source.html#l00195">TRUSTArray&lt; _TYPE_ &gt;::size_array()</a>, <a class="el" href="TRUSTVect_8tpp_source.html#l00058">TRUSTVect&lt; _TYPE_ &gt;::size_totale()</a>, and <a class="el" href="ArrOfBit_8h_source.html#l00066">ArrOfBit::testsetbit()</a>.</p>

</div>
</div>
<a id="a1e4b3977c09e7f6f4e8a3d554c05e727" name="a1e4b3977c09e7f6f4e8a3d554c05e727"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e4b3977c09e7f6f4e8a3d554c05e727">&#9670;&nbsp;</a></span>compute_graph_connex_components()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int compute_graph_connex_components </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="TRUSTTab_8h.html#a065b78ba28f61d9465e585c97135364c">IntTab</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="TRUSTArray_8h.html#af4ca55b348855905aeda61884ae11154">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>connex_components</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>recherche des composantes connexes d'un graphe local (non distribue<br  />
sur les processeurs) non symetrique.<br  />
Parametre: graph<br  />
On suppose que "graph" est un tableau a deux colonnes<br  />
contenant des couples d'indices de "sommets" d'un graphe. Ces couples definissent<br  />
un graphe dont on veut chercher les composantes connexes:<br  />
deux indices i et j sont dans la meme composante connexe si et seulement si il<br  />
existe une suite de couples qui relient directement ou indirectement i et j.<br  />
Parametre: connex_components<br  />
On suppose que connex_components est dimensionne a nb_sommets, le nombre de sommets du graphe.<br  />
On met dans connex_components[i] le numero de la composante connexe du graphe a laquelle appartient<br  />
le "sommet" i. On attribue tous les numeros i tels que 0 &lt;= i &lt; N<br  />
Valeur de retour: le nombre N de composantes connexes trouvees. </p>
<p >&lt; fin de liste</p>
<p >&lt; la plus petite</p>
<p >&lt; la plus grande</p>

<p class="definition">Definition at line <a class="el" href="Connex__components_8cpp_source.html#l00117">117</a> of file <a class="el" href="Connex__components_8cpp_source.html">Connex_components.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  118</span>{</div>
<div class="line"><span class="lineno">  119</span><span class="comment">// connex_components doit deja avoir la bonne taille en entree !</span></div>
<div class="line"><span class="lineno">  120</span>  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_sommets = connex_components.<a class="code hl_function" href="classTRUSTArray.html#ac03d475a56970fcc19cf624a0353e42e">size_array</a>();</div>
<div class="line"><span class="lineno">  121</span> </div>
<div class="line"><span class="lineno">  122</span><span class="comment">// renum_data definit des listes chainees de numeros de &quot;sommets&quot; appartenant a</span></div>
<div class="line"><span class="lineno">  123</span><span class="comment">// la meme composante connexe.</span></div>
<div class="line"><span class="lineno">  124</span><span class="comment">// renum_data(i,0)= numero du premier &quot;sommet&quot; de la liste a laquelle appartient i</span></div>
<div class="line"><span class="lineno">  125</span><span class="comment">// renum_data(i,1)= numero du &quot;sommet&quot; suivant dans la liste</span></div>
<div class="line"><span class="lineno">  126</span>  <a class="code hl_class" href="classTRUSTTab.html">IntTab</a> renum_data(nb_sommets, 2);</div>
<div class="line"><span class="lineno">  127</span><span class="comment">// Au debut, chaque sommet est toute seule dans une liste:</span></div>
<div class="line"><span class="lineno">  128</span>  <span class="keywordtype">int</span> i_sommet;</div>
<div class="line"><span class="lineno">  129</span>  <span class="keywordflow">for</span> (i_sommet = 0; i_sommet &lt; nb_sommets; i_sommet++)</div>
<div class="line"><span class="lineno">  130</span>    {</div>
<div class="line"><span class="lineno">  131</span>      renum_data(i_sommet, 0) = i_sommet;</div>
<div class="line"><span class="lineno">  132</span>      renum_data(i_sommet, 1) = -1; <span class="comment">//!&lt; fin de liste</span></div>
<div class="line"><span class="lineno">  133</span>    }</div>
<div class="line"><span class="lineno">  134</span>  <span class="keyword">const</span> <span class="keywordtype">int</span> nbcouples = graph.<a class="code hl_function" href="classTRUSTTab.html#a8fecd3f1f3a13e933c3f767a25c54805">dimension</a>(0);</div>
<div class="line"><span class="lineno">  135</span>  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i_couple = 0; i_couple &lt; nbcouples; i_couple++)</div>
<div class="line"><span class="lineno">  136</span>    {</div>
<div class="line"><span class="lineno">  137</span>      <span class="keyword">const</span> <span class="keywordtype">int</span> compo1 = graph(i_couple, 0); <span class="comment">//!&lt; la plus petite</span></div>
<div class="line"><span class="lineno">  138</span>      <span class="keyword">const</span> <span class="keywordtype">int</span> compo2 = graph(i_couple, 1); <span class="comment">//!&lt; la plus grande</span></div>
<div class="line"><span class="lineno">  139</span>      assert(compo1 != compo2);</div>
<div class="line"><span class="lineno">  140</span><span class="comment">// Si les deux composantes sont deja dans la meme liste,</span></div>
<div class="line"><span class="lineno">  141</span><span class="comment">// ne rien faire.</span></div>
<div class="line"><span class="lineno">  142</span>      <span class="keywordflow">if</span> (renum_data(compo1, 0) == renum_data(compo2, 0))</div>
<div class="line"><span class="lineno">  143</span>        <span class="keywordflow">continue</span>;</div>
<div class="line"><span class="lineno">  144</span><span class="comment">// Reunir la liste1 contenant compo1 et la liste2 contenant compo2:</span></div>
<div class="line"><span class="lineno">  145</span><span class="comment">// 1) trouver la fin de la premiere liste</span></div>
<div class="line"><span class="lineno">  146</span>      <span class="keywordtype">int</span> fin_liste1 = compo1;</div>
<div class="line"><span class="lineno">  147</span>      <span class="keywordflow">for</span> (;;)</div>
<div class="line"><span class="lineno">  148</span>        {</div>
<div class="line"><span class="lineno">  149</span>          <span class="keyword">const</span> <span class="keywordtype">int</span> <a class="code hl_function" href="Zone__VEF__PreP1b_8cpp.html#a24a462bbedad66c2a21f5f6f84b8ec5b">next</a> = renum_data(fin_liste1, 1);</div>
<div class="line"><span class="lineno">  150</span>          <span class="keywordflow">if</span> (<a class="code hl_function" href="Zone__VEF__PreP1b_8cpp.html#a24a462bbedad66c2a21f5f6f84b8ec5b">next</a> &lt; 0)</div>
<div class="line"><span class="lineno">  151</span>            <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno">  152</span>          fin_liste1 = <a class="code hl_function" href="Zone__VEF__PreP1b_8cpp.html#a24a462bbedad66c2a21f5f6f84b8ec5b">next</a>;</div>
<div class="line"><span class="lineno">  153</span>        }</div>
<div class="line"><span class="lineno">  154</span><span class="comment">// 2) brancher la liste2 a la fin de la liste1 :</span></div>
<div class="line"><span class="lineno">  155</span>      <span class="keyword">const</span> <span class="keywordtype">int</span> debut_liste2 = renum_data(compo2, 0);</div>
<div class="line"><span class="lineno">  156</span>      renum_data(fin_liste1, 1) = debut_liste2;</div>
<div class="line"><span class="lineno">  157</span><span class="comment">// 2) mettre a jour le debut de liste pour liste2 :</span></div>
<div class="line"><span class="lineno">  158</span>      i_sommet = debut_liste2;</div>
<div class="line"><span class="lineno">  159</span>      <span class="keyword">const</span> <span class="keywordtype">int</span> debut_liste1 = renum_data(compo1, 0);</div>
<div class="line"><span class="lineno">  160</span>      <span class="keywordflow">do</span></div>
<div class="line"><span class="lineno">  161</span>        {</div>
<div class="line"><span class="lineno">  162</span>          renum_data(i_sommet, 0) = debut_liste1;</div>
<div class="line"><span class="lineno">  163</span>          i_sommet = renum_data(i_sommet, 1);</div>
<div class="line"><span class="lineno">  164</span>        }</div>
<div class="line"><span class="lineno">  165</span>      <span class="keywordflow">while</span> (i_sommet &gt;= 0);</div>
<div class="line"><span class="lineno">  166</span>    }</div>
<div class="line"><span class="lineno">  167</span> </div>
<div class="line"><span class="lineno">  168</span><span class="comment">// Creation d&#39;une numerotation contigue pour les composantes:</span></div>
<div class="line"><span class="lineno">  169</span><span class="comment">// Prochain numero a attribuer</span></div>
<div class="line"><span class="lineno">  170</span>  <span class="keywordtype">int</span> count = 0;</div>
<div class="line"><span class="lineno">  171</span>  connex_components = -1;</div>
<div class="line"><span class="lineno">  172</span>  <span class="keywordflow">for</span> (i_sommet = 0; i_sommet &lt; nb_sommets; i_sommet++)</div>
<div class="line"><span class="lineno">  173</span>    {</div>
<div class="line"><span class="lineno">  174</span>      <span class="keywordflow">if</span> (connex_components[i_sommet] &lt; 0)</div>
<div class="line"><span class="lineno">  175</span>        {</div>
<div class="line"><span class="lineno">  176</span><span class="comment">// sommet pas encore traite</span></div>
<div class="line"><span class="lineno">  177</span><span class="comment">// Associe un nouveau numero a tous les sommets de la composante</span></div>
<div class="line"><span class="lineno">  178</span><span class="comment">// connexe a laquelle appartient i_sommet:</span></div>
<div class="line"><span class="lineno">  179</span>          <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = renum_data(i_sommet, 0); i &gt;= 0; i = renum_data(i, 1))</div>
<div class="line"><span class="lineno">  180</span>            connex_components[i] = count;</div>
<div class="line"><span class="lineno">  181</span><span class="comment">// Nouveau numero pour la prochaine composante</span></div>
<div class="line"><span class="lineno">  182</span>          count++;</div>
<div class="line"><span class="lineno">  183</span>        }</div>
<div class="line"><span class="lineno">  184</span>    }</div>
<div class="line"><span class="lineno">  185</span><span class="comment">// On renvoie le nombre de composantes connexes trouvees</span></div>
<div class="line"><span class="lineno">  186</span>  <span class="keywordflow">return</span> count;</div>
<div class="line"><span class="lineno">  187</span>}</div>
<div class="ttc" id="aZone__VEF__PreP1b_8cpp_html_a24a462bbedad66c2a21f5f6f84b8ec5b"><div class="ttname"><a href="Zone__VEF__PreP1b_8cpp.html#a24a462bbedad66c2a21f5f6f84b8ec5b">next</a></div><div class="ttdeci">static int next(int S, const ArrOfInt &amp;contenu)</div><div class="ttdef"><b>Definition:</b> <a href="Zone__VEF__PreP1b_8cpp_source.html#l00196">Zone_VEF_PreP1b.cpp:196</a></div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="TRUSTTab_8tpp_source.html#l00119">TRUSTTab&lt; _TYPE_ &gt;::dimension()</a>, <a class="el" href="Zone__VEF__PreP1b_8cpp_source.html#l00196">next()</a>, and <a class="el" href="TRUSTArray_8tpp_source.html#l00195">TRUSTArray&lt; _TYPE_ &gt;::size_array()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Connex__components_8cpp_source.html#l00207">compute_global_connex_components()</a>.</p>

</div>
</div>
<a id="ad771774190b40158b92030966f3f5a17" name="ad771774190b40158b92030966f3f5a17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad771774190b40158b92030966f3f5a17">&#9670;&nbsp;</a></span>search_connex_components_local()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int search_connex_components_local </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="TRUSTTab_8h.html#a065b78ba28f61d9465e585c97135364c">IntTab</a> &amp;&#160;</td>
          <td class="paramname"><em>elem_faces</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="TRUSTTab_8h.html#a065b78ba28f61d9465e585c97135364c">IntTab</a> &amp;&#160;</td>
          <td class="paramname"><em>faces_elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="TRUSTTabs__forward_8h.html#af6acf03d86acc37bcfb1375968278c0f">IntVect</a> &amp;&#160;</td>
          <td class="paramname"><em>num_compo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calcul des ensembles connexes par faces d'elements<br  />
non "marques" (les elements sont relies entre eux par un graphe<br  />
symetrique passant par les faces).<br  />
Une portion de domaine connexe porte un numero 0 &lt;= i &lt; N<br  />
unique et est delimite soit par un bord, soit par un element voisin "marque"<br  />
par num_compo[elem] = -1.<br  />
Cette methode est sequentielle (peut etre appelee sur un seul processeur)<br  />
Parametre: elem_faces<br  />
graph de connectivite elements-faces (pour chaque element i, indices<br  />
des faces de cet element), voir <a class="el" href="classZone__VF.html#a8e09b61902b9f1d2c4c7bedc3b8f39d3" title="renvoie le tableau de connectivite element/faces">Zone_VF::elem_faces()</a><br  />
Parametre: faces_elem<br  />
graph de connectivite faces-elements (pour chaque face, indice du<br  />
ou des deux elements adjacents), voir <a class="el" href="classZone__VF.html#a05b26c350e24c059f7076a7c2020dbdc" title="renvoie le tableaux des volumes des connectivites face elements cf au dessus.">Zone_VF::face_voisins()</a><br  />
Parametre: num_compo<br  />
En entree, un tableau tel que num_compo.size_array() == elem_faces.dimension_tot(0),<br  />
et dont certaines valeurs valent -1 (elements marques), et d'autres non.<br  />
En sortie: les elements pour lesquels num_compo = -1 ne sont pas modifies, les autres<br  />
sont numerotes par composante connexe locale. On remplit tout le tableau<br  />
jusqu'a size_tot() y compris les elements virtuels. Les numeros de composantes<br  />
sont locaux a ce processeur.<br  />
Valeur de retour: N, nombre de composantes connexes locales. </p>

<p class="definition">Definition at line <a class="el" href="Connex__components_8cpp_source.html#l00042">42</a> of file <a class="el" href="Connex__components_8cpp_source.html">Connex_components.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">   43</span>{</div>
<div class="line"><span class="lineno">   44</span>  <span class="keyword">const</span> <span class="keywordtype">int</span> nbelem = num_compo.<a class="code hl_function" href="classTRUSTVect.html#a5ae6fa5040fbdc708e54a7aba732413f">size_totale</a>();</div>
<div class="line"><span class="lineno">   45</span>  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_voisins = elem_faces.<a class="code hl_function" href="classTRUSTTab.html#a8fecd3f1f3a13e933c3f767a25c54805">dimension</a>(1);</div>
<div class="line"><span class="lineno">   46</span>  assert(elem_faces.<a class="code hl_function" href="classTRUSTTab.html#a02f5d997850b88e5f307f6ddaf67286e">dimension_tot</a>(0) == nbelem);</div>
<div class="line"><span class="lineno">   47</span>  {</div>
<div class="line"><span class="lineno">   48</span>    <span class="keywordtype">int</span> i;</div>
<div class="line"><span class="lineno">   49</span>    <span class="keywordflow">for</span> (i = 0; i &lt; nbelem; i++)</div>
<div class="line"><span class="lineno">   50</span>      <span class="keywordflow">if</span> (num_compo[i] != -1)</div>
<div class="line"><span class="lineno">   51</span>        num_compo[i] = -2;</div>
<div class="line"><span class="lineno">   52</span>  }</div>
<div class="line"><span class="lineno">   53</span>  <span class="keywordtype">int</span> start_element = 0;</div>
<div class="line"><span class="lineno">   54</span>  <span class="keywordtype">int</span> num_compo_courant = 0;</div>
<div class="line"><span class="lineno">   55</span>  <a class="code hl_class" href="classTRUSTArray.html">ArrOfInt</a> liste_elems;</div>
<div class="line"><span class="lineno">   56</span>  liste_elems.<a class="code hl_function" href="classTRUSTArray.html#a7c2cb947c5f755b7bcc8256246ccfdb5">set_smart_resize</a>(1);</div>
<div class="line"><span class="lineno">   57</span>  <a class="code hl_class" href="classTRUSTArray.html">ArrOfInt</a> tmp_liste;</div>
<div class="line"><span class="lineno">   58</span>  tmp_liste.<a class="code hl_function" href="classTRUSTArray.html#a7c2cb947c5f755b7bcc8256246ccfdb5">set_smart_resize</a>(1);</div>
<div class="line"><span class="lineno">   59</span>  <span class="keywordflow">do</span></div>
<div class="line"><span class="lineno">   60</span>    {</div>
<div class="line"><span class="lineno">   61</span><span class="comment">// Cherche le prochain element non attribue a une composante connexe</span></div>
<div class="line"><span class="lineno">   62</span>      <span class="keywordflow">while</span> (start_element &lt; nbelem &amp;&amp; num_compo[start_element] &gt;= -1)</div>
<div class="line"><span class="lineno">   63</span>        start_element++;</div>
<div class="line"><span class="lineno">   64</span>      <span class="keywordflow">if</span> (start_element == nbelem)</div>
<div class="line"><span class="lineno">   65</span>        <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno">   66</span><span class="comment">// Recherche des elements de la composante connexe a partir de cet element</span></div>
<div class="line"><span class="lineno">   67</span>      liste_elems.<a class="code hl_function" href="classTRUSTArray.html#a7fdab39e76f6cb0f5a5691eaaee32d8c">resize_array</a>(1);</div>
<div class="line"><span class="lineno">   68</span>      liste_elems[0] = start_element;</div>
<div class="line"><span class="lineno">   69</span>      num_compo[start_element] = num_compo_courant;</div>
<div class="line"><span class="lineno">   70</span>      <span class="keywordflow">while</span> (liste_elems.<a class="code hl_function" href="classTRUSTArray.html#ac03d475a56970fcc19cf624a0353e42e">size_array</a>() &gt; 0)</div>
<div class="line"><span class="lineno">   71</span>        {</div>
<div class="line"><span class="lineno">   72</span>          tmp_liste.<a class="code hl_function" href="classTRUSTArray.html#a7fdab39e76f6cb0f5a5691eaaee32d8c">resize_array</a>(0);</div>
<div class="line"><span class="lineno">   73</span>          <span class="keyword">const</span> <span class="keywordtype">int</span> liste_elems_size = liste_elems.<a class="code hl_function" href="classTRUSTArray.html#ac03d475a56970fcc19cf624a0353e42e">size_array</a>();</div>
<div class="line"><span class="lineno">   74</span>          <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i_elem = 0; i_elem &lt; liste_elems_size; i_elem++)</div>
<div class="line"><span class="lineno">   75</span>            {</div>
<div class="line"><span class="lineno">   76</span>              <span class="keyword">const</span> <span class="keywordtype">int</span> elem = liste_elems[i_elem];</div>
<div class="line"><span class="lineno">   77</span><span class="comment">// Ajout des voisins non attribues de cet element dans la liste a</span></div>
<div class="line"><span class="lineno">   78</span><span class="comment">// traiter a l&#39;etape suivante</span></div>
<div class="line"><span class="lineno">   79</span>              <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; nb_voisins; j++)</div>
<div class="line"><span class="lineno">   80</span>                {</div>
<div class="line"><span class="lineno">   81</span>                  <span class="keyword">const</span> <span class="keywordtype">int</span> face = elem_faces(elem, j);</div>
<div class="line"><span class="lineno">   82</span>                  <span class="keyword">const</span> <span class="keywordtype">int</span> voisin = faces_elem(face, 0) + faces_elem(face, 1) - elem;</div>
<div class="line"><span class="lineno">   83</span>                  <span class="keywordflow">if</span> (voisin &gt;= 0)</div>
<div class="line"><span class="lineno">   84</span>                    {</div>
<div class="line"><span class="lineno">   85</span>                      <span class="keyword">const</span> <span class="keywordtype">int</span> num = num_compo[voisin];</div>
<div class="line"><span class="lineno">   86</span>                      <span class="keywordflow">if</span> (num == -2)</div>
<div class="line"><span class="lineno">   87</span>                        {</div>
<div class="line"><span class="lineno">   88</span>                          num_compo[voisin] = num_compo_courant;</div>
<div class="line"><span class="lineno">   89</span>                          tmp_liste.<a class="code hl_function" href="classTRUSTArray.html#a7dfa8096799f0638dd3b700d945f5f04">append_array</a>(voisin);</div>
<div class="line"><span class="lineno">   90</span>                        }</div>
<div class="line"><span class="lineno">   91</span>                    }</div>
<div class="line"><span class="lineno">   92</span>                }</div>
<div class="line"><span class="lineno">   93</span>            }</div>
<div class="line"><span class="lineno">   94</span>          liste_elems = tmp_liste;</div>
<div class="line"><span class="lineno">   95</span>        }</div>
<div class="line"><span class="lineno">   96</span>      num_compo_courant++;</div>
<div class="line"><span class="lineno">   97</span>    }</div>
<div class="line"><span class="lineno">   98</span>  <span class="keywordflow">while</span> (1);</div>
<div class="line"><span class="lineno">   99</span><span class="comment">// Renvoie le nombre de composantes connexes locales trouvees</span></div>
<div class="line"><span class="lineno">  100</span>  <span class="keywordflow">return</span> num_compo_courant;</div>
<div class="line"><span class="lineno">  101</span>}</div>
<div class="ttc" id="aclassTRUSTArray_html_a7dfa8096799f0638dd3b700d945f5f04"><div class="ttname"><a href="classTRUSTArray.html#a7dfa8096799f0638dd3b700d945f5f04">TRUSTArray::append_array</a></div><div class="ttdeci">void append_array(_TYPE_ valeur)</div><div class="ttdef"><b>Definition:</b> <a href="TRUSTArray_8tpp_source.html#l00215">TRUSTArray.tpp:215</a></div></div>
<div class="ttc" id="aclassTRUSTTab_html_a02f5d997850b88e5f307f6ddaf67286e"><div class="ttname"><a href="classTRUSTTab.html#a02f5d997850b88e5f307f6ddaf67286e">TRUSTTab::dimension_tot</a></div><div class="ttdeci">int dimension_tot(int) const</div><div class="ttdef"><b>Definition:</b> <a href="TRUSTTab_8tpp_source.html#l00129">TRUSTTab.tpp:129</a></div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="TRUSTArray_8tpp_source.html#l00215">TRUSTArray&lt; _TYPE_ &gt;::append_array()</a>, <a class="el" href="TRUSTTab_8tpp_source.html#l00119">TRUSTTab&lt; _TYPE_ &gt;::dimension()</a>, <a class="el" href="TRUSTTab_8tpp_source.html#l00129">TRUSTTab&lt; _TYPE_ &gt;::dimension_tot()</a>, <a class="el" href="TRUSTArray_8tpp_source.html#l00038">TRUSTArray&lt; _TYPE_ &gt;::resize_array()</a>, <a class="el" href="TRUSTArray_8tpp_source.html#l00058">TRUSTArray&lt; _TYPE_ &gt;::set_smart_resize()</a>, <a class="el" href="TRUSTArray_8tpp_source.html#l00195">TRUSTArray&lt; _TYPE_ &gt;::size_array()</a>, and <a class="el" href="TRUSTVect_8tpp_source.html#l00058">TRUSTVect&lt; _TYPE_ &gt;::size_totale()</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Jun 29 2022 11:11:36 for TRUST by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.3
</small></address>
</body>
</html>
