<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>TRUST: ArrOfDouble Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">TRUST&#160;<span id="projectnumber">1.8.4</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a>  </div>
  <div class="headertitle">
<div class="title">ArrOfDouble Class Reference</div>  </div>
</div>
<div class="contents">
<!-- doxytag: class="ArrOfDouble" --><!-- doxytag: inherits="Array_base" -->
<p>Represente un tableau d'elements de type double.<br/>
L'etat du tableau est caracterise par la valeur de p_ et de data_ :<br/>
* detache : on a alors p_==0, data_==0, size_array_==0<br/>
(etat obtenu par le constructeur par defaut, <a class="el" href="classArrOfDouble.html#a30d7509eec18c3ef46cc0140bdcdc48f" title="Amene le tableau dans l&#39;etat &quot;detache&quot;. C&#39;est a dire: Si le tableau est &quot;detache&quot; : * ne rien faire...">detach_array()</a><br/>
et resize_array(0) dans certains cas)<br/>
* normal : alors p pointe vers une structure Vdbldata, data_==p-&gt;data_<br/>
et size_array_ &lt;= p-&gt;size_. A la destruction du tableau, si<br/>
p-&gt;ref_count_ est nul on libere la memoire.<br/>
data_ n'est pas nul.<br/>
L'espace memoire du tableau peut etre partage entre plusieurs<br/>
<a class="el" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a> (le pointeur "p" pointe alors sur une meme structure).<br/>
Ce type de tableau est produit par <a class="el" href="classArrOfDouble.html#a1831984f45c77967bf13fe67b97e95a9" title="Fait pointer le tableau vers les memes donnees qu&#39;un tableau existant. Le tableau sera du meme type q...">ref_array()</a>.<br/>
Le dernier <a class="el" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a> a utiliser une zone de memoire<br/>
la detruit lorsqu'il a fini (voir <a class="el" href="classArrOfDouble.html#a30d7509eec18c3ef46cc0140bdcdc48f" title="Amene le tableau dans l&#39;etat &quot;detache&quot;. C&#39;est a dire: Si le tableau est &quot;detache&quot; : * ne rien faire...">detach_array()</a>)<br/>
Si smart_resize_==0, alors on a toujours size_array_==p-&gt;size_.<br/>
* ref_data : p_==0, data_ pointe vers un tableau existant, la memoire<br/>
n'est pas liberee a la destruction du <a class="el" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a>.<br/>
Ces tableaux sont obtenus par appel a ref_data(...) et peuvent servir<br/>
pour importer un tableau fourni par une routine exterieure (C ou fortran)<br/>
Valeur initiale par defaut : voir "fill_default_value".<br/>
Priere de supposer desormais que les tableaux ne sont pas initialises<br/>
par defaut.  
 <a href="classArrOfDouble.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="ArrOfDouble_8h_source.html">ArrOfDouble.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for ArrOfDouble:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classArrOfDouble.png" usemap="#ArrOfDouble_map" alt=""/>
  <map id="ArrOfDouble_map" name="ArrOfDouble_map">
<area href="classArray__base.html" title=": classe vide servant de base a tous les tableaux. (permet de passer un type generique quel que soit ..." alt="Array_base" shape="rect" coords="0,112,85,136"/>
<area href="classObjet__U.html" title="classe Objet_U Cette classe est la classe de base des Objets de TRUST Dans les classes derivees de Ob..." alt="Objet_U" shape="rect" coords="0,56,85,80"/>
<area href="classProcess.html" title="Classe de base de TRUST (notamment Objet_U). Elle fournit quelques services de base accessibles de pa..." alt="Process" shape="rect" coords="0,0,85,24"/>
<area href="classDoubleVect.html" alt="DoubleVect" shape="rect" coords="0,224,85,248"/>
<area href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les..." alt="DoubleTab" shape="rect" coords="0,280,85,304"/>
<area href="classDoubleTrav.html" title="Tableau de travail a n entrees pour n&lt;= 4 C&#39;est un DoubleTab avec allocation dans un pool de memoire g..." alt="DoubleTrav" shape="rect" coords="0,336,85,360"/>
</map>
 </div></div>

<p><a href="classArrOfDouble-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArrOfDouble.html#aa6c9b9bbc6bc40ecd74d10411dc560de">Storage</a> { <a class="el" href="classArrOfDouble.html#aa6c9b9bbc6bc40ecd74d10411dc560dead35388f27e20e247aaeaf8797437d110">STANDARD</a>, 
<a class="el" href="classArrOfDouble.html#aa6c9b9bbc6bc40ecd74d10411dc560dea86f97b783db46940466f21da61664650">TEMP_STORAGE</a>
 }</td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArrOfDouble.html#a305e3b5889f1044ab22d8f44edfe65bc">taille_memoire</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArrOfDouble.html#a121292f1748dacefa9d701e5d64557f9">duplique</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classType__info.html">Type_info</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArrOfDouble.html#a4f370ec412709796eb51fef1d1f068ac">get_info</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Donne des informations sur le type de l'Objet_U.  <a href="#a4f370ec412709796eb51fef1d1f068ac"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArrOfDouble.html#a71ad0b1778d7c3df7f37c51f1a9c7844">~ArrOfDouble</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructeur : appelle <a class="el" href="classArrOfDouble.html#a30d7509eec18c3ef46cc0140bdcdc48f" title="Amene le tableau dans l&#39;etat &quot;detache&quot;. C&#39;est a dire: Si le tableau est &quot;detache&quot; : * ne rien faire...">detach_array()</a>  <a href="#a71ad0b1778d7c3df7f37c51f1a9c7844"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArrOfDouble.html#a8890dc9a68c33a7862e776f411adaa02">ArrOfDouble</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructeur par defaut: cree un tableau "detache",<br/>
soit p_==0, data_==0, size_array_==0, smart_resize_==0.  <a href="#a8890dc9a68c33a7862e776f411adaa02"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArrOfDouble.html#a8501f69b54146bfd7dac7d11539e931f">ArrOfDouble</a> (int size)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Cree un tableau de taille n avec allocation standard (voir set_mem_storage).<br/>
Le tableau est rempli avec zero par defaut. Pour creer un tableau non initialise, utiliser:<br/>
<a class="el" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a> toto;<br/>
toto.resize_array(n, NOCOPY_NOINIT);<br/>
Parametre: int n<br/>
Signification: taille du tableau.  <a href="#a8501f69b54146bfd7dac7d11539e931f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArrOfDouble.html#a3cc20f7f8fe3bc9cd924e73838307887">ArrOfDouble</a> (const <a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructeur par copie. On alloue une nouvelle zone de memoire<br/>
et on copie le contenu du tableau (il s'agit d'un "deep copy").<br/>
L'attribut smart_resize_ est copie aussi.<br/>
Si le tableau A est de taille nulle, on cree un tableau "detache",<br/>
sinon on cree un tableau "normal".<br/>
Parametre: const <a class="el" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a>&amp; A<br/>
Signification: le tableau a copier.  <a href="#a3cc20f7f8fe3bc9cd924e73838307887"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArrOfDouble.html#a610464f4b3dccac6f814915b526783ed">resize_array</a> (int new_size, <a class="el" href="classArray__base.html#abee342aa9ac59623c4c782dc9d7877ff">Array_base::Resize_Options</a> opt=COPY_INIT)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArrOfDouble.html#aa5d7035f2e4f451c484aabd5dffb873b">resize</a> (int new_size, <a class="el" href="classArray__base.html#abee342aa9ac59623c4c782dc9d7877ff">Array_base::Resize_Options</a> opt=COPY_INIT)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">appel a <a class="el" href="classArrOfDouble.html#a610464f4b3dccac6f814915b526783ed">ArrOfDouble::resize_array()</a>  <a href="#aa5d7035f2e4f451c484aabd5dffb873b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArrOfDouble.html#a03c0eaca0e960a1f59cc077deb9fd4b2">resize_tab</a> (int n, <a class="el" href="classArray__base.html#abee342aa9ac59623c4c782dc9d7877ff">Array_base::Resize_Options</a> opt=COPY_INIT)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">methode virtuelle identique a <a class="el" href="classArrOfDouble.html#a610464f4b3dccac6f814915b526783ed">resize_array()</a>, permet de traiter<br/>
de facon generique les ArrOf, Vect et Tab.<br/>
Si l'objet est de type <a class="el" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a>, appel a resize_array(n)<br/>
Prerequis: le tableau doit etre "resizable" (voir <a class="el" href="classArrOfDouble.html#a610464f4b3dccac6f814915b526783ed">resize_array()</a>).<br/>
S'il est d'un type derive (Vect ou Tab), il ne doit pas avoir de descripteur<br/>
parallele si la taille est effectivement modifiee.  <a href="#a03c0eaca0e960a1f59cc077deb9fd4b2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArrOfDouble.html#ab49f6cae96be9d3f597468d8a53b67b6">set_smart_resize</a> (int flag)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Change le mode l'allocation memoire: reallocation d'un tableau<br/>
a chaque changement de taille (flag = 0) ou reallocation<br/>
uniquement si la taille augmente et par doublement de la taille<br/>
du tableau (flag = 1).  <a href="#ab49f6cae96be9d3f597468d8a53b67b6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArrOfDouble.html#a716c70fbed9c253e2deb5732c9f0601b">set_mem_storage</a> (const <a class="el" href="classArrOfDouble.html#aa6c9b9bbc6bc40ecd74d10411dc560de">Storage</a> storage)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Change le mode d'allocation memoire lors des resize&lt;br&gt;(voir VDoubledata et Double_ptr_trav)<br/>
Exemple pour creer un tableau avec allocation temporaire:<br/>
<a class="el" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a> tab; // Creation d'un tableau vide<br/>
tab.set_mem_storage(TEMP_STORAGE); // Changement de mode d'allocation<br/>
tab.resize(n); // Allocation memoire.  <a href="#a716c70fbed9c253e2deb5732c9f0601b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classArrOfDouble.html#aa6c9b9bbc6bc40ecd74d10411dc560de">Storage</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArrOfDouble.html#a2b905fb71100ad2c00ada973435d3cea">get_mem_storage</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Renvoie le mode d'allocation du tableau (qui sera utilise<br/>
lors du prochain resize si changement de taille).<br/>
(voir <a class="el" href="classVDoubledata.html" title="VDoubledata alloue une zone de memoire de la taille specifiee au constructeur, et libere la zone de m...">VDoubledata</a> et <a class="el" href="classDouble__ptr__trav.html" title="Une zone de travail de la Memoire TRUST composee d&#39;elements de type double.">Double_ptr_trav</a>)  <a href="#a2b905fb71100ad2c00ada973435d3cea"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArrOfDouble.html#a8cc97dbe67c8001dad97008b10fa7690">ref_data</a> (double *ptr, int size)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Fait pointer le tableau vers la zone de memoire "data_".<br/>
On detache la zone de memoire existante. Le tableau devient<br/>
de type "ref_data". Attention : ptr doit etre non nul.<br/>
La taille est initialisee avec size.<br/>
Attention: methode virtuelle: dans les classes derivee, cette methode<br/>
initialise les structures pour creer un tableau sequentiel.<br/>
Pour faire une ref sur un tableau parallele utiliser <a class="el" href="classDoubleVect.html#a2b45ece955d7d57746fa32b5a6a89cc2" title="detache le tableau et l&#39;attache a v (sauf si v==*this, ne fait rien) Fait pointer le tableau sur la m...">DoubleVect::ref()</a><br/>
Parametre: double*<br/>
Signification: le tableau a recuperer. Si pointeur nul alors size<br/>
doit etre nulle aussi et le tableau reste detache<br/>
Parametre: int size<br/>
Signification: le nombre d'elements du tableau.  <a href="#a8cc97dbe67c8001dad97008b10fa7690"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArrOfDouble.html#a1831984f45c77967bf13fe67b97e95a9">ref_array</a> (<a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;, int start=0, int <a class="el" href="Nom_8cpp.html#a0e1ea19fb9fa7881d15d84eff4c090e1">sz</a>=-1)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Fait pointer le tableau vers les memes donnees qu'un tableau<br/>
existant. Le tableau sera du meme type que le tableau m ("detache",<br/>
"normal"). Le tableau m ne doit pas etre de type "ref_data"<br/>
Attention, le tableau source et *this sont ensuite figes (<a class="el" href="classArrOfDouble.html#a610464f4b3dccac6f814915b526783ed">resize_array()</a><br/>
interdit).<br/>
Attention: methode virtuelle: dans les classes derivee, cette methode<br/>
initialise les structures pour creer un tableau sequentiel.<br/>
Parametre: const <a class="el" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a>&amp; m<br/>
Signification: le tableau a referencer (pas de type "ref_data"<br/>
et different de *this !!!)  <a href="#a1831984f45c77967bf13fe67b97e95a9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArrOfDouble.html#a433dc3b67b6d6e70f7dda611e67c45ac">operator=</a> (const <a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copie les donnees du tableau m.<br/>
Si "m" n'a pas la meme taille que "*this", on fait un resize_array.<br/>
Ensuite, on copie les valeurs de "m" dans "*this".<br/>
Le type de tableau (methode d'allocation) n'est pas copie.  <a href="#a433dc3b67b6d6e70f7dda611e67c45ac"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArrOfDouble.html#a8c937710d2664d65500f24ce5f7e0ce0">reset</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Remet le tableau dans l'etat obtenu avec le constructeur par defaut<br/>
(libere la memoire mais conserve le mode d'allocation memoire actuel)  <a href="#a8c937710d2664d65500f24ce5f7e0ce0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArrOfDouble.html#a67cc8a3c1012b2f210a9a71f535c6162">operator=</a> (double valeur)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">x est affecte a toutes les cases  <a href="#a67cc8a3c1012b2f210a9a71f535c6162"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArrOfDouble.html#a5b23a83d22d2c8b6278b0d14fb5c9ede">operator[]</a> (int i)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">operateur [] retourne le ieme element du tableau  <a href="#a5b23a83d22d2c8b6278b0d14fb5c9ede"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const double &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArrOfDouble.html#a38bb0d0daa1c9287e3b880745acde015">operator[]</a> (int i) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">operateur [] retourne le ieme element du tableau  <a href="#a38bb0d0daa1c9287e3b880745acde015"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArrOfDouble.html#a1318e4d5d3e8a95119dcd4ddd6b7403b">operator()</a> (int i)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">idem operator[]  <a href="#a1318e4d5d3e8a95119dcd4ddd6b7403b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const double &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArrOfDouble.html#a0594a5464922bed384889c63c6b970e8">operator()</a> (int i) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983">addr</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Renvoie un pointeur sur le premier element du tableau.<br/>
Le pointeur est nul si le tableau est "detache".<br/>
Attention, l'adresse peut changer apres un appel<br/>
a <a class="el" href="classArrOfDouble.html#a610464f4b3dccac6f814915b526783ed">resize_array()</a>, ref_data, ref_array, ...  <a href="#a95357a1390c11dbd481d385257f2e983"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArrOfDouble.html#a28b030def940d51da6e19e47d7a0b2cc">addr</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Renvoie un pointeur sur le premier element du tableau.<br/>
Le pointeur est nul si le tableau est "detache".  <a href="#a28b030def940d51da6e19e47d7a0b2cc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArrOfDouble.html#a3c3b33bea0e88b87315c21ee94bee05f">size_array</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Renvoie la taille du tableau (nombre d'elements declares<br/>
a la construction ou a <a class="el" href="classArrOfDouble.html#a610464f4b3dccac6f814915b526783ed">resize_array()</a>).<br/>
C'est le nombre d'elements accessibles a operator[].  <a href="#a3c3b33bea0e88b87315c21ee94bee05f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArrOfDouble.html#a324a6714dc9d9a7b5997fda646d24974">ref_count</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne le nombre de references des donnees du tableau<br/>
si le tableau est "normal", -1 s'il est "detache" ou "ref_data".  <a href="#a324a6714dc9d9a7b5997fda646d24974"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArrOfDouble.html#a989b455da23fcea97918c7fca5349c85">append_array</a> (double valeur)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Ajoute une case en fin de tableau et y stocke la "valeur".  <a href="#a989b455da23fcea97918c7fca5349c85"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArrOfDouble.html#a2d092d5c1a7d8523c65ca2e85507fd0d">operator+=</a> (const <a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition case a case sur toutes les cases du tableau.  <a href="#a2d092d5c1a7d8523c65ca2e85507fd0d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArrOfDouble.html#a688855b6b9ccf42e2b4f51c3ba4edc59">operator+=</a> (const double)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">ajoute la meme valeur a toutes les cases du tableau  <a href="#a688855b6b9ccf42e2b4f51c3ba4edc59"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArrOfDouble.html#a94cc5d4c485cc75070ec3a041288c0bd">operator-=</a> (const <a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Soustraction case a case sur toutes les cases du tableau<br/>
Parametre: const <a class="el" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a>&amp; y<br/>
Signification: tableau de meme taille que *this.  <a href="#a94cc5d4c485cc75070ec3a041288c0bd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArrOfDouble.html#ae19bfdc7b46e16daa1f26333ceaa4e32">operator-=</a> (const double)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">soustrait la meme valeur a toutes les cases  <a href="#ae19bfdc7b46e16daa1f26333ceaa4e32"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArrOfDouble.html#a2fcb2a2d3b59425c6cb37526ea6af6a3">inject_array</a> (const <a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;source, int nb_elements=-1, int first_element_dest=0, int first_element_source=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copie les elements source[first_element_source + i]<br/>
dans les elements (*this)[first_element_dest + i] pour 0 &lt;= i &lt; nb_elements<br/>
Les autres elements de (*this) sont inchanges.  <a href="#a2fcb2a2d3b59425c6cb37526ea6af6a3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArrOfDouble.html#a89ba688c107e2f6089501983dfa051b0">copy_array</a> (const <a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">appelle operator=(a)  <a href="#a89ba688c107e2f6089501983dfa051b0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArrOfDouble.html#a5fe07362b3180016e5dfd698fcb6747b">operator=</a> (const FArrOfDouble &amp;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArrOfDouble.html#a6ec3428662ddd818f935ffe1b6c57347">operator*=</a> (const double)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">muliplie toutes les cases par dy  <a href="#a6ec3428662ddd818f935ffe1b6c57347"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArrOfDouble.html#a98ad403cfd1de7934a9ebd66751666c2">operator/=</a> (const double)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">divise toutes les cases par dy  <a href="#a98ad403cfd1de7934a9ebd66751666c2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArrOfDouble.html#a779184ebb5056c91f6185acf7c10088c">ordonne_array</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Tri des valeurs du tableau dans l'ordre croissant.<br/>
La fonction utilisee est qsort de stdlib (elle est en n*log(n)).  <a href="#a779184ebb5056c91f6185acf7c10088c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArrOfDouble.html#aee755ade0ca203a8490ef2b29e1136cd">array_trier_retirer_doublons</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Tri des valeurs du tableau dans l'ordre croissant et suppresion des doublons<br/>
La fonction utilisee est qsort de stdlib (elle est en n*log(n)).  <a href="#aee755ade0ca203a8490ef2b29e1136cd"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classObjet__U.html">Objet_U</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArrOfDouble.html#a4f257238def20a795b7f470c4c9c5617">cree_instance</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classType__info.html">Type_info</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArrOfDouble.html#af51837b06770e07fa016fda29eb0bf3a">info</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Donne des informations sur le type de l'Objet_U.  <a href="#af51837b06770e07fa016fda29eb0bf3a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArrOfDouble.html#ac7de1e66e976de768ed0eacb8e4196c6">self_cast</a> (<a class="el" href="classObjet__U.html">Objet_U</a> &amp;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArrOfDouble.html#a1edbfb14b1f0576e04bbfd1d7001117b">self_cast</a> (const <a class="el" href="classObjet__U.html">Objet_U</a> &amp;)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">methode ajoutee pour caster en python  <a href="#a1edbfb14b1f0576e04bbfd1d7001117b"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classType__info.html">Type_info</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArrOfDouble.html#a249fb161408eabb4b7efa45129ab7b6c">info_obj</a></td></tr>
<tr><td colspan="2"><h2><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classSortie.html">Sortie</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArrOfDouble.html#a9dc3bfa20c1ddf76911449fcb5746c6d">printOn</a> (<a class="el" href="classSortie.html">Sortie</a> &amp;x) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Ecriture du tableau sur "os" :<br/>
ecrit le nombre d'elements suivi des valeurs du tableau.  <a href="#a9dc3bfa20c1ddf76911449fcb5746c6d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classEntree.html">Entree</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArrOfDouble.html#a5e51c4df4648b6e1aaeee466f3be0044">readOn</a> (<a class="el" href="classEntree.html">Entree</a> &amp;)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Lecture d'un tableau dans un flot d'entree<br/>
Lit le nombre d'elements suivi des elements eux-memes.  <a href="#a5e51c4df4648b6e1aaeee466f3be0044"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArrOfDouble.html#af59467d8ccfc8e5cdac8e24e1c8a1e66">attach_array</a> (const <a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;a, int start=0, int size=-1)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Amene le tableau dans l'etat "normal", "detache" ou "ref_array"<br/>
en associant une sous-zone de memoire du tableau m, definie par start et size<br/>
Si size &lt; 0, on prend le tableau m jusqu'a la fin.  <a href="#af59467d8ccfc8e5cdac8e24e1c8a1e66"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArrOfDouble.html#a30d7509eec18c3ef46cc0140bdcdc48f">detach_array</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Amene le tableau dans l'etat "detache". C'est a dire:<br/>
Si le tableau est "detache" :<br/>
* ne rien faire<br/>
Si le tableau est "normal" :<br/>
* decremente le nombre de references a *p<br/>
* detruit *p si p-&gt;ref_count==0<br/>
* annule p_, data_ et size_array_<br/>
Si le tableau est "ref_data" :<br/>
* annule data_ et size_array_.  <a href="#a30d7509eec18c3ef46cc0140bdcdc48f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArrOfDouble.html#a67d30f4f02d7656362fce21d8e0e9745">fill_default_value</a> (<a class="el" href="classArray__base.html#abee342aa9ac59623c4c782dc9d7877ff">Array_base::Resize_Options</a> opt, int first, int nb)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Remplit "nb" cases consecutives du tableau a partir de la case "first"<br/>
avec une valeur par defaut.<br/>
Cette fonction est appelee lors d'un resize pour initialiser les<br/>
cases nouvellement creees.<br/>
Le comportement depend actuellement du type de tableau :<br/>
* Tableau de type "smart_resize":<br/>
* en mode debug (macro NDEBUG non definie) le tableau est initialise<br/>
avec une valeur invalide.<br/>
* en optimise, le tableau n'est pas initialise<br/>
* Tableau normal :<br/>
Le tableau est initialise avec la valeur 0. Ce comportement est choisi<br/>
pour des raisons de compatibilite avec l'implementation precedente.<br/>
Cette specification pourrait etre modifiee prochainement pour des raisons<br/>
de performances (pour ne pas avoir a initialiser inutilement les tableaux).<br/>
DONC: il faut supposer desormais que les nouvelles cases ne sont pas<br/>
initialisees lors d'un resize.<br/>
Parametre: first<br/>
Signification: premiere case a initialiser.<br/>
Contrainte: (nb==0) ou (0 &lt;= first &lt; memory_size_)<br/>
Parametre: nb<br/>
Signification: nombre de cases a initialiser.<br/>
Contrainte: (nb==0) ou (0 &lt; nb &lt;= memory_size_ - first)  <a href="#a67d30f4f02d7656362fce21d8e0e9745"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArrOfDouble.html#af6aaac97844f02d467f6b84286e1cf1b">resize_array_</a> (int n, <a class="el" href="classArray__base.html#abee342aa9ac59623c4c782dc9d7877ff">Array_base::Resize_Options</a> opt=COPY_INIT)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">methode protegee de changement de taille, appelable par<br/>
les classes derivees (idem que <a class="el" href="classArrOfDouble.html#a610464f4b3dccac6f814915b526783ed">resize_array()</a> mais sans condition sur le<br/>
type derive de l'objet)  <a href="#af6aaac97844f02d467f6b84286e1cf1b"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArrOfDouble.html#a98d8a5b5486b130787f95664ee8127e6">memory_resize</a> (int new_size, <a class="el" href="classArray__base.html#abee342aa9ac59623c4c782dc9d7877ff">Array_base::Resize_Options</a> opt=COPY_INIT)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Si besoin, alloue une nouvelle zone de memoire,<br/>
copie les donnees et efface l'ancienne zone de memoire.<br/>
Attention, on suppose que cette methode est appelee par<br/>
<a class="el" href="classArrOfDouble.html#a610464f4b3dccac6f814915b526783ed">resize_array()</a>.<br/>
Attention: si ref_count_&gt;1, l'appel a <a class="el" href="classArrOfDouble.html#a610464f4b3dccac6f814915b526783ed">resize_array()</a> est<br/>
autorise uniquement si la nouvelle taille est identique<br/>
a la precedente (auquel cas on ne fait rien)<br/>
Si ref_count_ == 1, l'appel est invalide si p_-&gt;data_ est<br/>
different de data_ (le tableau a ete construit avec <a class="el" href="classArrOfDouble.html#a1831984f45c77967bf13fe67b97e95a9" title="Fait pointer le tableau vers les memes donnees qu&#39;un tableau existant. Le tableau sera du meme type q...">ref_array()</a><br/>
avec start &gt; 0)  <a href="#a98d8a5b5486b130787f95664ee8127e6"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVDoubledata.html">VDoubledata</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArrOfDouble.html#a16cc4d79375188b7cb389fce2c920186">p_</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArrOfDouble.html#a77419df7d43ac2ce76b9388a39ad90e9">data_</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArrOfDouble.html#ae201cdbdbf9f840376398199e5f737a0">size_array_</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArrOfDouble.html#a952e7436d209c8957ea0209f1fa66976">memory_size_</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArrOfDouble.html#a527b3aabfef167644bb124f8255245b3">smart_resize_</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classArrOfDouble.html#aa6c9b9bbc6bc40ecd74d10411dc560de">Storage</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArrOfDouble.html#a9724d501cbca852e174ef0a7351698b1">storage_type_</a></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Represente un tableau d'elements de type double.<br/>
L'etat du tableau est caracterise par la valeur de p_ et de data_ :<br/>
* detache : on a alors p_==0, data_==0, size_array_==0<br/>
(etat obtenu par le constructeur par defaut, <a class="el" href="classArrOfDouble.html#a30d7509eec18c3ef46cc0140bdcdc48f" title="Amene le tableau dans l&#39;etat &quot;detache&quot;. C&#39;est a dire: Si le tableau est &quot;detache&quot; : * ne rien faire...">detach_array()</a><br/>
et resize_array(0) dans certains cas)<br/>
* normal : alors p pointe vers une structure Vdbldata, data_==p-&gt;data_<br/>
et size_array_ &lt;= p-&gt;size_. A la destruction du tableau, si<br/>
p-&gt;ref_count_ est nul on libere la memoire.<br/>
data_ n'est pas nul.<br/>
L'espace memoire du tableau peut etre partage entre plusieurs<br/>
<a class="el" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a> (le pointeur "p" pointe alors sur une meme structure).<br/>
Ce type de tableau est produit par <a class="el" href="classArrOfDouble.html#a1831984f45c77967bf13fe67b97e95a9" title="Fait pointer le tableau vers les memes donnees qu&#39;un tableau existant. Le tableau sera du meme type q...">ref_array()</a>.<br/>
Le dernier <a class="el" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a> a utiliser une zone de memoire<br/>
la detruit lorsqu'il a fini (voir <a class="el" href="classArrOfDouble.html#a30d7509eec18c3ef46cc0140bdcdc48f" title="Amene le tableau dans l&#39;etat &quot;detache&quot;. C&#39;est a dire: Si le tableau est &quot;detache&quot; : * ne rien faire...">detach_array()</a>)<br/>
Si smart_resize_==0, alors on a toujours size_array_==p-&gt;size_.<br/>
* ref_data : p_==0, data_ pointe vers un tableau existant, la memoire<br/>
n'est pas liberee a la destruction du <a class="el" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a>.<br/>
Ces tableaux sont obtenus par appel a ref_data(...) et peuvent servir<br/>
pour importer un tableau fourni par une routine exterieure (C ou fortran)<br/>
Valeur initiale par defaut : voir "fill_default_value".<br/>
Priere de supposer desormais que les tableaux ne sont pas initialises<br/>
par defaut. </p>

<p>Definition at line <a class="el" href="ArrOfDouble_8h_source.html#l00071">71</a> of file <a class="el" href="ArrOfDouble_8h_source.html">ArrOfDouble.h</a>.</p>
</div><hr/><h2>Member Enumeration Documentation</h2>
<a class="anchor" id="aa6c9b9bbc6bc40ecd74d10411dc560de"></a><!-- doxytag: member="ArrOfDouble::Storage" ref="aa6c9b9bbc6bc40ecd74d10411dc560de" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classArrOfDouble.html#aa6c9b9bbc6bc40ecd74d10411dc560de">ArrOfDouble::Storage</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="aa6c9b9bbc6bc40ecd74d10411dc560dead35388f27e20e247aaeaf8797437d110"></a><!-- doxytag: member="STANDARD" ref="aa6c9b9bbc6bc40ecd74d10411dc560dead35388f27e20e247aaeaf8797437d110" args="" -->STANDARD</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="aa6c9b9bbc6bc40ecd74d10411dc560dea86f97b783db46940466f21da61664650"></a><!-- doxytag: member="TEMP_STORAGE" ref="aa6c9b9bbc6bc40ecd74d10411dc560dea86f97b783db46940466f21da61664650" args="" -->TEMP_STORAGE</em>&nbsp;</td><td>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="ArrOfDouble_8h_source.html#l00101">101</a> of file <a class="el" href="ArrOfDouble_8h_source.html">ArrOfDouble.h</a>.</p>
<div class="fragment"><pre class="fragment">{ <a class="code" href="classArrOfDouble.html#aa6c9b9bbc6bc40ecd74d10411dc560dead35388f27e20e247aaeaf8797437d110">STANDARD</a>, <a class="code" href="classArrOfDouble.html#aa6c9b9bbc6bc40ecd74d10411dc560dea86f97b783db46940466f21da61664650">TEMP_STORAGE</a> };
</pre></div>
</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a71ad0b1778d7c3df7f37c51f1a9c7844"></a><!-- doxytag: member="ArrOfDouble::~ArrOfDouble" ref="a71ad0b1778d7c3df7f37c51f1a9c7844" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ArrOfDouble::~ArrOfDouble </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Destructeur : appelle <a class="el" href="classArrOfDouble.html#a30d7509eec18c3ef46cc0140bdcdc48f" title="Amene le tableau dans l&#39;etat &quot;detache&quot;. C&#39;est a dire: Si le tableau est &quot;detache&quot; : * ne rien faire...">detach_array()</a> </p>

<p><p>&lt; Paranoia: si size_array_==-1, c'est un zombie </p>
</p>

<p>Definition at line <a class="el" href="ArrOfDouble_8cpp_source.html#l00316">316</a> of file <a class="el" href="ArrOfDouble_8cpp_source.html">ArrOfDouble.cpp</a>.</p>

<p>References <a class="el" href="ArrOfDouble_8cpp_source.html#l01014">detach_array()</a>, and <a class="el" href="ArrOfDouble_8h_source.html#l00182">size_array_</a>.</p>
<div class="fragment"><pre class="fragment">{
  <a class="code" href="classArrOfDouble.html#a30d7509eec18c3ef46cc0140bdcdc48f" title="Amene le tableau dans l&#39;etat &quot;detache&quot;. C&#39;est a dire: Si le tableau est &quot;detache&quot; : * ne rien faire...">detach_array</a>();
  <a class="code" href="classArrOfDouble.html#ae201cdbdbf9f840376398199e5f737a0">size_array_</a> = -1; <span class="comment">//!&lt; Paranoia: si size_array_==-1, c&#39;est un zombie</span>
<span class="comment"></span>}
</pre></div>
</div>
</div>
<a class="anchor" id="a8890dc9a68c33a7862e776f411adaa02"></a><!-- doxytag: member="ArrOfDouble::ArrOfDouble" ref="a8890dc9a68c33a7862e776f411adaa02" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ArrOfDouble::ArrOfDouble </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructeur par defaut: cree un tableau "detache",<br/>
soit p_==0, data_==0, size_array_==0, smart_resize_==0. </p>

<p>Definition at line <a class="el" href="ArrOfDouble_8cpp_source.html#l00325">325</a> of file <a class="el" href="ArrOfDouble_8cpp_source.html">ArrOfDouble.cpp</a>.</p>
<div class="fragment"><pre class="fragment">                         :
  <a class="code" href="classArrOfDouble.html#a16cc4d79375188b7cb389fce2c920186">p_</a>(0),
  <a class="code" href="classArrOfDouble.html#a77419df7d43ac2ce76b9388a39ad90e9">data_</a>(0),
  <a class="code" href="classArrOfDouble.html#ae201cdbdbf9f840376398199e5f737a0">size_array_</a>(0),
  <a class="code" href="classArrOfDouble.html#a952e7436d209c8957ea0209f1fa66976">memory_size_</a>(0),
  <a class="code" href="classArrOfDouble.html#a527b3aabfef167644bb124f8255245b3">smart_resize_</a>(0),
  <a class="code" href="classArrOfDouble.html#a9724d501cbca852e174ef0a7351698b1">storage_type_</a>(<a class="code" href="classArrOfDouble.html#aa6c9b9bbc6bc40ecd74d10411dc560dead35388f27e20e247aaeaf8797437d110">STANDARD</a>)
{
}
</pre></div>
</div>
</div>
<a class="anchor" id="a8501f69b54146bfd7dac7d11539e931f"></a><!-- doxytag: member="ArrOfDouble::ArrOfDouble" ref="a8501f69b54146bfd7dac7d11539e931f" args="(int size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ArrOfDouble::ArrOfDouble </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Cree un tableau de taille n avec allocation standard (voir set_mem_storage).<br/>
Le tableau est rempli avec zero par defaut. Pour creer un tableau non initialise, utiliser:<br/>
<a class="el" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a> toto;<br/>
toto.resize_array(n, NOCOPY_NOINIT);<br/>
Parametre: int n<br/>
Signification: taille du tableau. </p>

<p>Definition at line <a class="el" href="ArrOfDouble_8cpp_source.html#l00342">342</a> of file <a class="el" href="ArrOfDouble_8cpp_source.html">ArrOfDouble.cpp</a>.</p>

<p>References <a class="el" href="Array__base_8h_source.html#l00038">Array_base::COPY_INIT</a>, <a class="el" href="ArrOfDouble_8h_source.html#l00178">data_</a>, <a class="el" href="ArrOfDouble_8cpp_source.html#l00650">fill_default_value()</a>, <a class="el" href="ArrOfDouble_8cpp_source.html#l00223">VDoubledata::get_data()</a>, <a class="el" href="ArrOfDouble_8h_source.html#l00170">p_</a>, and <a class="el" href="ArrOfDouble_8h_source.html#l00101">STANDARD</a>.</p>
<div class="fragment"><pre class="fragment">                              :
  <a class="code" href="classArrOfDouble.html#a16cc4d79375188b7cb389fce2c920186">p_</a>(0),
  <a class="code" href="classArrOfDouble.html#a77419df7d43ac2ce76b9388a39ad90e9">data_</a>(0),
  <a class="code" href="classArrOfDouble.html#ae201cdbdbf9f840376398199e5f737a0">size_array_</a>(n),
  <a class="code" href="classArrOfDouble.html#a952e7436d209c8957ea0209f1fa66976">memory_size_</a>(n),
  <a class="code" href="classArrOfDouble.html#a527b3aabfef167644bb124f8255245b3">smart_resize_</a>(0),
  <a class="code" href="classArrOfDouble.html#a9724d501cbca852e174ef0a7351698b1">storage_type_</a>(<a class="code" href="classArrOfDouble.html#aa6c9b9bbc6bc40ecd74d10411dc560dead35388f27e20e247aaeaf8797437d110">STANDARD</a>)
{
  <span class="keywordflow">if</span> (n)
    {
      <a class="code" href="classArrOfDouble.html#a16cc4d79375188b7cb389fce2c920186">p_</a> = <span class="keyword">new</span> <a class="code" href="classVDoubledata.html" title="VDoubledata alloue une zone de memoire de la taille specifiee au constructeur, et libere la zone de m...">VDoubledata</a>(n, <a class="code" href="classArrOfDouble.html#aa6c9b9bbc6bc40ecd74d10411dc560dead35388f27e20e247aaeaf8797437d110">STANDARD</a>);
      <a class="code" href="classArrOfDouble.html#a77419df7d43ac2ce76b9388a39ad90e9">data_</a> = <a class="code" href="classArrOfDouble.html#a16cc4d79375188b7cb389fce2c920186">p_</a>-&gt;<a class="code" href="classVDoubledata.html#a554af3f6bbf09270b1c4862de9654c17" title="renvoie data_">get_data</a>();
      <a class="code" href="classArrOfDouble.html#a67d30f4f02d7656362fce21d8e0e9745" title="Remplit &quot;nb&quot; cases consecutives du tableau a partir de la case &quot;first&quot; avec une valeur par defaut...">fill_default_value</a>(<a class="code" href="classArray__base.html#abee342aa9ac59623c4c782dc9d7877ffa9a675e25b5b7accff8d861e05060547b">COPY_INIT</a>, 0, n);
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a3cc20f7f8fe3bc9cd924e73838307887"></a><!-- doxytag: member="ArrOfDouble::ArrOfDouble" ref="a3cc20f7f8fe3bc9cd924e73838307887" args="(const ArrOfDouble &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ArrOfDouble::ArrOfDouble </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructeur par copie. On alloue une nouvelle zone de memoire<br/>
et on copie le contenu du tableau (il s'agit d'un "deep copy").<br/>
L'attribut smart_resize_ est copie aussi.<br/>
Si le tableau A est de taille nulle, on cree un tableau "detache",<br/>
sinon on cree un tableau "normal".<br/>
Parametre: const <a class="el" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a>&amp; A<br/>
Signification: le tableau a copier. </p>

<p>Definition at line <a class="el" href="ArrOfDouble_8cpp_source.html#l00390">390</a> of file <a class="el" href="ArrOfDouble_8cpp_source.html">ArrOfDouble.cpp</a>.</p>

<p>References <a class="el" href="ArrOfDouble_8h_source.html#l00178">data_</a>, <a class="el" href="ArrOfDouble_8cpp_source.html#l00223">VDoubledata::get_data()</a>, <a class="el" href="ArrOfDouble_8cpp_source.html#l01110">inject_array()</a>, <a class="el" href="ArrOfDouble_8h_source.html#l00187">memory_size_</a>, <a class="el" href="ArrOfDouble_8h_source.html#l00170">p_</a>, <a class="el" href="ArrOfDouble_8h_source.html#l00350">size_array()</a>, <a class="el" href="ArrOfDouble_8h_source.html#l00182">size_array_</a>, <a class="el" href="ArrOfDouble_8h_source.html#l00193">smart_resize_</a>, <a class="el" href="ArrOfDouble_8h_source.html#l00101">STANDARD</a>, and <a class="el" href="ArrOfDouble_8h_source.html#l00197">storage_type_</a>.</p>
<div class="fragment"><pre class="fragment">                                            : <a class="code" href="classArray__base.html" title=": classe vide servant de base a tous les tableaux. (permet de passer un type generique quel que soit ...">Array_base</a>()
{
  <span class="keyword">const</span> <span class="keywordtype">int</span> size = A.<a class="code" href="classArrOfDouble.html#a3c3b33bea0e88b87315c21ee94bee05f" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>();
  <span class="keywordflow">if</span> (size &gt; 0)
    {
<span class="comment">// Creation d&#39;un tableau &quot;normal&quot;</span>
      <a class="code" href="classArrOfDouble.html#a9724d501cbca852e174ef0a7351698b1">storage_type_</a> = <a class="code" href="classArrOfDouble.html#aa6c9b9bbc6bc40ecd74d10411dc560dead35388f27e20e247aaeaf8797437d110">STANDARD</a>;
      <a class="code" href="classArrOfDouble.html#a16cc4d79375188b7cb389fce2c920186">p_</a> = <span class="keyword">new</span> <a class="code" href="classVDoubledata.html" title="VDoubledata alloue une zone de memoire de la taille specifiee au constructeur, et libere la zone de m...">VDoubledata</a>(size, <a class="code" href="classArrOfDouble.html#aa6c9b9bbc6bc40ecd74d10411dc560dead35388f27e20e247aaeaf8797437d110">STANDARD</a>);
      <a class="code" href="classArrOfDouble.html#a77419df7d43ac2ce76b9388a39ad90e9">data_</a> = <a class="code" href="classArrOfDouble.html#a16cc4d79375188b7cb389fce2c920186">p_</a>-&gt;<a class="code" href="classVDoubledata.html#a554af3f6bbf09270b1c4862de9654c17" title="renvoie data_">get_data</a>();
      <a class="code" href="classArrOfDouble.html#ae201cdbdbf9f840376398199e5f737a0">size_array_</a> = size;
      <a class="code" href="classArrOfDouble.html#a952e7436d209c8957ea0209f1fa66976">memory_size_</a> = size;
      <a class="code" href="classArrOfDouble.html#a527b3aabfef167644bb124f8255245b3">smart_resize_</a> = A.<a class="code" href="classArrOfDouble.html#a527b3aabfef167644bb124f8255245b3">smart_resize_</a>;
      <a class="code" href="classArrOfDouble.html#a2fcb2a2d3b59425c6cb37526ea6af6a3" title="Copie les elements source[first_element_source + i] dans les elements (*this)[first_element_dest + i]...">inject_array</a>(A);
    }
  <span class="keywordflow">else</span>
    {
<span class="comment">// Creation d&#39;un tableau &quot;detache&quot;</span>
      <a class="code" href="classArrOfDouble.html#a16cc4d79375188b7cb389fce2c920186">p_</a> = 0;
      <a class="code" href="classArrOfDouble.html#a77419df7d43ac2ce76b9388a39ad90e9">data_</a> = 0;
      <a class="code" href="classArrOfDouble.html#ae201cdbdbf9f840376398199e5f737a0">size_array_</a> = 0;
      <a class="code" href="classArrOfDouble.html#a952e7436d209c8957ea0209f1fa66976">memory_size_</a> = 0;
      <a class="code" href="classArrOfDouble.html#a527b3aabfef167644bb124f8255245b3">smart_resize_</a> = 0;
      <a class="code" href="classArrOfDouble.html#a9724d501cbca852e174ef0a7351698b1">storage_type_</a> = <a class="code" href="classArrOfDouble.html#aa6c9b9bbc6bc40ecd74d10411dc560dead35388f27e20e247aaeaf8797437d110">STANDARD</a>;
    }
}
</pre></div>
</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a95357a1390c11dbd481d385257f2e983"></a><!-- doxytag: member="ArrOfDouble::addr" ref="a95357a1390c11dbd481d385257f2e983" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const double * ArrOfDouble::addr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Renvoie un pointeur sur le premier element du tableau.<br/>
Le pointeur est nul si le tableau est "detache".<br/>
Attention, l'adresse peut changer apres un appel<br/>
a <a class="el" href="classArrOfDouble.html#a610464f4b3dccac6f814915b526783ed">resize_array()</a>, ref_data, ref_array, ... </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>const double*<br/>
 Signification: pointeur sur le premier element du tableau </dd></dl>

<p>Definition at line <a class="el" href="ArrOfDouble_8h_source.html#l00379">379</a> of file <a class="el" href="ArrOfDouble_8h_source.html">ArrOfDouble.h</a>.</p>

<p>References <a class="el" href="ArrOfDouble_8h_source.html#l00178">data_</a>.</p>

<p>Referenced by <a class="el" href="MD__Vector__std_8cpp_source.html#l00652">add_to_vect_blocs()</a>, <a class="el" href="MD__Vector__std_8cpp_source.html#l00413">add_to_vect_items()</a>, <a class="el" href="Convert__ICoCoTrioField_8cpp_source.html#l00033">affecte_double_avec_doubletab()</a>, <a class="el" href="DoubleVect_8cpp_source.html#l01531">ajoute_alpha_v()</a>, <a class="el" href="Solv__GCP_8cpp_source.html#l00378">ajoute_alpha_v_norme()</a>, <a class="el" href="DoubleVect_8cpp_source.html#l01594">ajoute_carre()</a>, <a class="el" href="DoubleVect_8cpp_source.html#l01657">ajoute_produit_scalaire()</a>, <a class="el" href="Terme__Source__Decroissance__Radioactive__VEF__Face_8cpp_source.html#l00076">Terme_Source_Decroissance_Radioactive_VEF_Face::ajouter()</a>, <a class="el" href="Terme__Puissance__Thermique__Echange__Impose__VEF__Face_8cpp_source.html#l00119">Terme_Puissance_Thermique_Echange_Impose_VEF_Face::ajouter()</a>, <a class="el" href="Terme__Puissance__Thermique__Echange__Impose__P0__VDF_8cpp_source.html#l00093">Terme_Puissance_Thermique_Echange_Impose_P0_VDF::ajouter()</a>, <a class="el" href="T__It__VDF__Elem_8h_source.html#l00130">T_It_VDF_Elem&lt; _TYPE_ &gt;::ajouter()</a>, <a class="el" href="Terme__Boussinesq__PolyMAC__Face_8cpp_source.html#l00059">Terme_Boussinesq_PolyMAC_Face::ajouter()</a>, <a class="el" href="Solveur__Masse__base_8cpp_source.html#l00186">Solveur_Masse_base::ajouter_masse()</a>, <a class="el" href="Solveur__Masse__base_8cpp_source.html#l00263">Solveur_Masse_base::ajouter_masse_dt_local()</a>, <a class="el" href="Matrice__SuperMorse_8cpp_source.html#l00032">Matrice_SuperMorse::ajouter_mult_vect_et_prodscal()</a>, <a class="el" href="Matrice__Morse__Sym_8cpp_source.html#l00335">Matrice_Morse_Sym::ajouter_multvect_()</a>, <a class="el" href="Matrice__Morse_8cpp_source.html#l00936">Matrice_Morse::ajouter_multvect_()</a>, <a class="el" href="Matrice__Diagonale_8cpp_source.html#l00055">Matrice_Diagonale::ajouter_multvect_()</a>, <a class="el" href="Matrice__Bloc__Sym_8cpp_source.html#l00080">Matrice_Bloc_Sym::ajouter_multvect_()</a>, <a class="el" href="Matrice__Bloc_8cpp_source.html#l00115">Matrice_Bloc::ajouter_multvect_()</a>, <a class="el" href="Matrice__Bloc_8cpp_source.html#l00148">Matrice_Bloc::ajouter_multvectT_()</a>, <a class="el" href="Op__Diff__EF_8cpp_source.html#l00508">Op_Diff_EF::ajouter_scalaire_dim2_nbn_4()</a>, <a class="el" href="Op__Diff__EF_8cpp_source.html#l00340">Op_Diff_EF::ajouter_scalaire_dim3_nbn_8()</a>, <a class="el" href="Op__Diff__EF_8cpp_source.html#l00588">Op_Diff_EF::ajouter_scalaire_gen()</a>, <a class="el" href="Op__Conv__EF_8cpp_source.html#l00850">Op_Conv_EF::ajouter_sous_cond_dim2_nbn4_nbdim1()</a>, <a class="el" href="Op__Conv__EF_8cpp_source.html#l00685">Op_Conv_EF::ajouter_sous_cond_dim2_nbn4_nbdim2()</a>, <a class="el" href="Op__Conv__EF_8cpp_source.html#l00519">Op_Conv_EF::ajouter_sous_cond_dim3_nbn8_nbdim1()</a>, <a class="el" href="Op__Conv__EF_8cpp_source.html#l00354">Op_Conv_EF::ajouter_sous_cond_dim3_nbn8_nbdim2()</a>, <a class="el" href="Op__Diff__EF_8cpp_source.html#l00421">Op_Diff_EF::ajouter_vectoriel_dim2_nbn_4()</a>, <a class="el" href="Op__Diff__EF_8cpp_source.html#l00253">Op_Diff_EF::ajouter_vectoriel_dim3_nbn_8()</a>, <a class="el" href="Op__Diff__EF_8cpp_source.html#l00662">Op_Diff_EF::ajouter_vectoriel_gen()</a>, <a class="el" href="DoubleTab_8h_source.html#l00271">DoubleTab::append_line()</a>, <a class="el" href="Fluide__base_8cpp_source.html#l00318">Fluide_base::calculer_nu()</a>, <a class="el" href="DoubleVect_8cpp_source.html#l01782">carre()</a>, <a class="el" href="Solv__Cholesky_8cpp_source.html#l00143">Solv_Cholesky::Cholesky()</a>, <a class="el" href="interface__INITGAUSS_8cpp_source.html#l00065">interface_INITGAUSS::Compute()</a>, <a class="el" href="interface__CALCULSI_8cpp_source.html#l00065">interface_CALCULSI::Compute()</a>, <a class="el" href="interface__CALCULBIJ_8cpp_source.html#l00065">interface_CALCULBIJ::Compute()</a>, <a class="el" href="Terme__Puissance__Thermique__Echange__Impose__VEF__Face_8cpp_source.html#l00167">Terme_Puissance_Thermique_Echange_Impose_VEF_Face::contribuer_a_avec()</a>, <a class="el" href="Terme__Puissance__Thermique__Echange__Impose__P0__VDF_8cpp_source.html#l00113">Terme_Puissance_Thermique_Echange_Impose_P0_VDF::contribuer_a_avec()</a>, <a class="el" href="Solveur__Masse__base_8cpp_source.html#l00388">Solveur_Masse_base::corriger_solution()</a>, <a class="el" href="SSOR_8cpp_source.html#l00179">descente()</a>, <a class="el" href="SSOR_8cpp_source.html#l00411">descente_assert()</a>, <a class="el" href="SSOR_8cpp_source.html#l01239">descente_assert_precond_diag()</a>, <a class="el" href="SSOR_8cpp_source.html#l00461">descente_bloc_extradiag_assert()</a>, <a class="el" href="SSOR_8cpp_source.html#l00793">descente_diag_ok_assert()</a>, <a class="el" href="SSOR_8cpp_source.html#l01025">descente_precond_diag()</a>, <a class="el" href="Matrice__Morse_8cpp_source.html#l00864">Matrice_Morse::diagmulmat()</a>, <a class="el" href="Zone__CoviMAC_8cpp_source.html#l00591">disp_da()</a>, <a class="el" href="Zone__CoviMAC_8cpp_source.html#l00571">disp_dt()</a>, <a class="el" href="Zone__CoviMAC_8cpp_source.html#l00618">disp_m()</a>, <a class="el" href="ArrOfDouble_8cpp_source.html#l01277">dotproduct_array()</a>, <a class="el" href="MD__Vector__tools_8cpp_source.html#l00653">MD_Vector_tools::dump_vector_with_md()</a>, <a class="el" href="Debog_8cpp_source.html#l00643">Debog_Pb::ecrire_partie()</a>, <a class="el" href="EcritureLectureSpecial_8cpp_source.html#l00152">ecrit()</a>, <a class="el" href="communications_8cpp_source.html#l00497">envoyer_all_to_all()</a>, <a class="el" href="Solv__Cholesky_8cpp_source.html#l00236">Solv_Cholesky::Fact_Cholesky()</a>, <a class="el" href="ILU_8cpp_source.html#l00126">ILU::factoriser()</a>, <a class="el" href="Champ__P1iP1B__implementation_8cpp_source.html#l00473">Champ_P1iP1B_implementation::filtrage()</a>, <a class="el" href="Champ__Generique__Transformation_8cpp_source.html#l00510">Champ_Generique_Transformation::get_champ()</a>, <a class="el" href="Solveur__Masse__base_8cpp_source.html#l00360">Solveur_Masse_base::get_masse_divide_by_local_dt()</a>, <a class="el" href="Solveur__Masse__base_8cpp_source.html#l00332">Solveur_Masse_base::get_masse_dt_local()</a>, <a class="el" href="ILU_8cpp_source.html#l00269">ILU::ilu()</a>, <a class="el" href="ILU_8cpp_source.html#l00275">ILU::ilut()</a>, <a class="el" href="Echange__contact__CoviMAC_8cpp_source.html#l00082">Echange_contact_CoviMAC::init_fe_dist()</a>, <a class="el" href="Champ__implementation__P1_8cpp_source.html#l00165">Champ_implementation_P1::init_from_file()</a>, <a class="el" href="Zone__PolyMAC_8cpp_source.html#l01059">Zone_PolyMAC::init_m2()</a>, <a class="el" href="ArrOfDouble_8cpp_source.html#l01110">inject_array()</a>, <a class="el" href="Champ__Face__PolyMAC_8cpp_source.html#l00437">Champ_Face_PolyMAC::interp_gve()</a>, <a class="el" href="Integrer__champ__med_8cpp_source.html#l00150">Integrer_champ_med::interpreter()</a>, <a class="el" href="Lire__Ideas_8cpp_source.html#l00042">Lire_Ideas::interpreter_()</a>, <a class="el" href="DoubleVect_8cpp_source.html#l00379">invalidate_data()</a>, <a class="el" href="Matrice__Morse_8cpp_source.html#l01184">Matrice_Morse::inverse()</a>, <a class="el" href="Matrice__Dense_8cpp_source.html#l00377">Matrice_Dense::inverse()</a>, <a class="el" href="SolvElem__Gmres_8h_source.html#l00044">SolvElem_Gmres::iteration()</a>, <a class="el" href="SolvElem__BiCGStab_8h_source.html#l00044">SolvElem_BiCGStab::iteration()</a>, <a class="el" href="Zone__CoviMAC_8h_source.html#l00359">kersol()</a>, <a class="el" href="EcritureLectureSpecial_8cpp_source.html#l00328">lire_special()</a>, <a class="el" href="DoubleVect_8cpp_source.html#l00298">DoubleVect::lit()</a>, <a class="el" href="DoubleVect_8cpp_source.html#l00481">local_carre_norme_vect()</a>, <a class="el" href="DoubleVect_8cpp_source.html#l00716">local_imax_vect()</a>, <a class="el" href="DoubleVect_8cpp_source.html#l00603">local_imin_vect()</a>, <a class="el" href="DoubleVect_8cpp_source.html#l00829">local_max_abs_vect()</a>, <a class="el" href="DoubleVect_8cpp_source.html#l00773">local_max_vect()</a>, <a class="el" href="DoubleVect_8cpp_source.html#l00886">local_min_abs_vect()</a>, <a class="el" href="DoubleVect_8cpp_source.html#l00660">local_min_vect()</a>, <a class="el" href="DoubleVect_8cpp_source.html#l00419">local_prodscal()</a>, <a class="el" href="DoubleVect_8cpp_source.html#l00541">local_somme_vect()</a>, <a class="el" href="DoubleTab_8cpp_source.html#l00909">DoubleTab::max_du_u()</a>, <a class="el" href="MD__Vector__std_8cpp_source.html#l00457">max_to_vect_items()</a>, <a class="el" href="Terme__Puissance__Thermique__Echange__Impose__VEF__Face_8cpp_source.html#l00057">Terme_Puissance_Thermique_Echange_Impose_VEF_Face::mettre_a_jour()</a>, <a class="el" href="Terme__Puissance__Thermique__Echange__Impose__P0__VDF_8cpp_source.html#l00058">Terme_Puissance_Thermique_Echange_Impose_P0_VDF::mettre_a_jour()</a>, <a class="el" href="Chimie_8cpp_source.html#l00200">Chimie::mettre_a_jour()</a>, <a class="el" href="Champ__Fonc__Fonction__txyz__Morceaux_8cpp_source.html#l00566">Champ_Fonc_Fonction_txyz_Morceaux::mettre_a_jour()</a>, <a class="el" href="MD__Vector__std_8cpp_source.html#l00503">mincol1_to_vect_items()</a>, <a class="el" href="communications_8cpp_source.html#l00644">mp_collective_op()</a>, <a class="el" href="Solv__GCP_8cpp_source.html#l00357">multiply_sub()</a>, <a class="el" href="Matrice__Morse__Sym_8cpp_source.html#l00266">Matrice_Morse_Sym::multvect_et_prodscal()</a>, <a class="el" href="Assembleur__P__VEFPreP1B_8cpp_source.html#l01117">operation01()</a>, <a class="el" href="Assembleur__P__VEFPreP1B_8cpp_source.html#l01018">operation11()</a>, <a class="el" href="Matrice__Morse_8cpp_source.html#l01117">operator+()</a>, <a class="el" href="ArrOfDouble_8cpp_source.html#l00702">operator==()</a>, <a class="el" href="DoubleVect_8cpp_source.html#l00943">operator_abs()</a>, <a class="el" href="DoubleVect_8cpp_source.html#l00999">operator_add()</a>, <a class="el" href="DoubleVect_8cpp_source.html#l01838">operator_divide()</a>, <a class="el" href="DoubleVect_8cpp_source.html#l01412">operator_egal()</a>, <a class="el" href="DoubleVect_8cpp_source.html#l01902">operator_inverse()</a>, <a class="el" href="DoubleVect_8cpp_source.html#l01237">operator_multiply()</a>, <a class="el" href="DoubleVect_8cpp_source.html#l01356">operator_negate()</a>, <a class="el" href="DoubleVect_8cpp_source.html#l01118">operator_sub()</a>, <a class="el" href="Solv__GCP_8cpp_source.html#l00124">Solv_GCP::prepare_data()</a>, <a class="el" href="DoubleTab_8cpp_source.html#l00048">DoubleTab::printOn()</a>, <a class="el" href="DoubleVect_8cpp_source.html#l01726">racine_carree()</a>, <a class="el" href="MD__Vector__std_8cpp_source.html#l00558">read_from_vect_blocs()</a>, <a class="el" href="MD__Vector__std_8cpp_source.html#l00325">read_from_vect_items()</a>, <a class="el" href="SSOR_8cpp_source.html#l00227">remontee()</a>, <a class="el" href="SSOR_8cpp_source.html#l00494">remontee_assert()</a>, <a class="el" href="SSOR_8cpp_source.html#l01283">remontee_assert_precond_diag()</a>, <a class="el" href="SSOR_8cpp_source.html#l00552">remontee_bloc_extradiag_assert()</a>, <a class="el" href="SSOR_8cpp_source.html#l00841">remontee_diag_ok_assert()</a>, <a class="el" href="SSOR_8cpp_source.html#l01069">remontee_precond_diag()</a>, <a class="el" href="Matrice__Morse_8cpp_source.html#l02068">Matrice_Morse::remplir()</a>, <a class="el" href="Matrice__Bloc_8cpp_source.html#l00676">Matrice_Bloc::remplir()</a>, <a class="el" href="Matrice__Morse__Sym_8cpp_source.html#l00988">Matrice_Morse_Sym::renumerote()</a>, <a class="el" href="Solv__Petsc_8cpp_source.html#l01553">Solv_Petsc::resoudre_systeme()</a>, <a class="el" href="MD__Vector__tools_8cpp_source.html#l00671">MD_Vector_tools::restore_vector_with_md()</a>, <a class="el" href="Zone_8cpp_source.html#l00351">sameDoubleTab()</a>, <a class="el" href="Champ__Input__Proto_8cpp_source.html#l00133">Champ_Input_Proto::setValueOnTab()</a>, <a class="el" href="DoubleVect_8cpp_source.html#l02029">tab_divide_any_shape_()</a>, <a class="el" href="DoubleVect_8cpp_source.html#l01959">tab_multiply_any_shape_()</a>, <a class="el" href="Raccord__distant__homogene_8cpp_source.html#l00167">Raccord_distant_homogene::trace_face_distant()</a>, <a class="el" href="Frontiere_8cpp_source.html#l00396">Frontiere::trace_face_local()</a>, <a class="el" href="SSOR_8cpp_source.html#l00161">traite_diagonale()</a>, <a class="el" href="Op__Diff__CoviMAC__base_8cpp_source.html#l00282">Op_Diff_CoviMAC_base::update_nu_invh()</a>, <a class="el" href="Champ__Face__CoviMAC_8cpp_source.html#l00316">Champ_Face_CoviMAC::valeur_aux_elems_compo()</a>, <a class="el" href="Vecteur3_8h_source.html#l00054">Vecteur3::Vecteur3()</a>, <a class="el" href="Debog_8cpp_source.html#l00705">Debog_Pb::verifier_partie_std()</a>, <a class="el" href="Format__Post__Lata_8cpp_source.html#l00322">Format_Post_Lata::write_doubletab()</a>, <a class="el" href="MD__Vector__std_8cpp_source.html#l00605">write_to_vect_blocs()</a>, <a class="el" href="MD__Vector__std_8cpp_source.html#l00369">write_to_vect_items()</a>, and <a class="el" href="Zone__VF_8cpp_source.html#l00660">Zone_VF::xv_bord()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">return</span> <a class="code" href="classArrOfDouble.html#a77419df7d43ac2ce76b9388a39ad90e9">data_</a>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a28b030def940d51da6e19e47d7a0b2cc"></a><!-- doxytag: member="ArrOfDouble::addr" ref="a28b030def940d51da6e19e47d7a0b2cc" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double * ArrOfDouble::addr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Renvoie un pointeur sur le premier element du tableau.<br/>
Le pointeur est nul si le tableau est "detache". </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>const double*<br/>
 Signification: la zone memoire du tableau </dd></dl>

<p>Definition at line <a class="el" href="ArrOfDouble_8h_source.html#l00390">390</a> of file <a class="el" href="ArrOfDouble_8h_source.html">ArrOfDouble.h</a>.</p>

<p>References <a class="el" href="ArrOfDouble_8h_source.html#l00178">data_</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">return</span> <a class="code" href="classArrOfDouble.html#a77419df7d43ac2ce76b9388a39ad90e9">data_</a>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a989b455da23fcea97918c7fca5349c85"></a><!-- doxytag: member="ArrOfDouble::append_array" ref="a989b455da23fcea97918c7fca5349c85" args="(double valeur)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ArrOfDouble::append_array </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>valeur</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Ajoute une case en fin de tableau et y stocke la "valeur". </p>

<p>Definition at line <a class="el" href="ArrOfDouble_8h_source.html#l00363">363</a> of file <a class="el" href="ArrOfDouble_8h_source.html">ArrOfDouble.h</a>.</p>

<p>References <a class="el" href="Array__base_8h_source.html#l00038">Array_base::COPY_NOINIT</a>, <a class="el" href="ArrOfDouble_8h_source.html#l00178">data_</a>, <a class="el" href="ArrOfDouble_8h_source.html#l00244">resize_array()</a>, <a class="el" href="ArrOfDouble_8h_source.html#l00182">size_array_</a>, <a class="el" href="ArrOfDouble_8h_source.html#l00193">smart_resize_</a>, and <a class="el" href="Source__Generique__Face__PolyMAC_8cpp_source.html#l00045">valeur()</a>.</p>

<p>Referenced by <a class="el" href="CSR__Builder_8h_source.html#l00054">CSR_Builder::add_coeff()</a>, and <a class="el" href="Matrice__Morse__Sym_8cpp_source.html#l00748">Matrice_Morse_Sym::get_symmetric_stencil_and_coefficients()</a>.</p>
<div class="fragment"><pre class="fragment">{
  assert(<a class="code" href="classArrOfDouble.html#a527b3aabfef167644bb124f8255245b3">smart_resize_</a>);
  <span class="keyword">const</span> <span class="keywordtype">int</span> n = <a class="code" href="classArrOfDouble.html#ae201cdbdbf9f840376398199e5f737a0">size_array_</a>;
  <a class="code" href="classArrOfDouble.html#a610464f4b3dccac6f814915b526783ed">resize_array</a>(<a class="code" href="classArrOfDouble.html#ae201cdbdbf9f840376398199e5f737a0">size_array_</a>+1, <a class="code" href="classArray__base.html#abee342aa9ac59623c4c782dc9d7877ffac85954f9768f1ed2b14e58cea8ddb7c5">COPY_NOINIT</a>);
  <a class="code" href="classArrOfDouble.html#a77419df7d43ac2ce76b9388a39ad90e9">data_</a>[n] = <a class="code" href="Source__Generique__Face__PolyMAC_8cpp.html#a7d7b5d77a3caa1af70f5e1c9108de5a1">valeur</a>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="aee755ade0ca203a8490ef2b29e1136cd"></a><!-- doxytag: member="ArrOfDouble::array_trier_retirer_doublons" ref="aee755ade0ca203a8490ef2b29e1136cd" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ArrOfDouble::array_trier_retirer_doublons </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Tri des valeurs du tableau dans l'ordre croissant et suppresion des doublons<br/>
La fonction utilisee est qsort de stdlib (elle est en n*log(n)). </p>

<p>Definition at line <a class="el" href="ArrOfDouble_8cpp_source.html#l00923">923</a> of file <a class="el" href="ArrOfDouble_8cpp_source.html">ArrOfDouble.cpp</a>.</p>

<p>References <a class="el" href="ArrOfDouble_8h_source.html#l00178">data_</a>, <a class="el" href="ArrOfDouble_8cpp_source.html#l00909">ordonne_array()</a>, <a class="el" href="ArrOfDouble_8h_source.html#l00244">resize_array()</a>, and <a class="el" href="ArrOfDouble_8h_source.html#l00182">size_array_</a>.</p>

<p>Referenced by <a class="el" href="ExtrudeParoi_8cpp_source.html#l00127">ExtrudeParoi::interpreter_()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">const</span> <span class="keywordtype">int</span> size_ = <a class="code" href="classArrOfDouble.html#ae201cdbdbf9f840376398199e5f737a0">size_array_</a>;
  <span class="keywordflow">if</span> (size_ &lt;= 0)
    <span class="keywordflow">return</span>;
<span class="comment">// Tri dans l&#39;ordre croissant</span>
  <a class="code" href="classArrOfDouble.html#a779184ebb5056c91f6185acf7c10088c" title="Tri des valeurs du tableau dans l&#39;ordre croissant. La fonction utilisee est qsort de stdlib (elle est...">ordonne_array</a>();
<span class="comment">// Retire les doublons (codage optimise en pointeurs)</span>
  <span class="keywordtype">double</span> last_value = *<a class="code" href="classArrOfDouble.html#a77419df7d43ac2ce76b9388a39ad90e9">data_</a>;
  <span class="keywordtype">double</span> *src = <a class="code" href="classArrOfDouble.html#a77419df7d43ac2ce76b9388a39ad90e9">data_</a> + 1;
  <span class="keywordtype">double</span> *dest = <a class="code" href="classArrOfDouble.html#a77419df7d43ac2ce76b9388a39ad90e9">data_</a> + 1;
  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = size_ - 1; i != 0; i--)
    {
      <span class="keywordtype">double</span> x = *(src++);
      <span class="keywordflow">if</span> (x != last_value)
        {
          *(dest++) = x;
          last_value = x;
        }
    }
  <span class="keywordtype">int</span> new_size_ = dest - <a class="code" href="classArrOfDouble.html#a77419df7d43ac2ce76b9388a39ad90e9">data_</a>;
  <a class="code" href="classArrOfDouble.html#a610464f4b3dccac6f814915b526783ed">resize_array</a>(new_size_);
}
</pre></div>
</div>
</div>
<a class="anchor" id="af59467d8ccfc8e5cdac8e24e1c8a1e66"></a><!-- doxytag: member="ArrOfDouble::attach_array" ref="af59467d8ccfc8e5cdac8e24e1c8a1e66" args="(const ArrOfDouble &amp;a, int start=0, int size=&#45;1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ArrOfDouble::attach_array </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>start</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Amene le tableau dans l'etat "normal", "detache" ou "ref_array"<br/>
en associant une sous-zone de memoire du tableau m, definie par start et size<br/>
Si size &lt; 0, on prend le tableau m jusqu'a la fin. </p>

<p>Definition at line <a class="el" href="ArrOfDouble_8cpp_source.html#l01054">1054</a> of file <a class="el" href="ArrOfDouble_8cpp_source.html">ArrOfDouble.cpp</a>.</p>

<p>References <a class="el" href="ArrOfDouble_8cpp_source.html#l00204">VDoubledata::add_one_ref()</a>, <a class="el" href="ArrOfDouble_8h_source.html#l00178">data_</a>, <a class="el" href="ArrOfDouble_8h_source.html#l00187">memory_size_</a>, <a class="el" href="ArrOfDouble_8h_source.html#l00170">p_</a>, <a class="el" href="ArrOfDouble_8h_source.html#l00350">size_array()</a>, <a class="el" href="ArrOfDouble_8h_source.html#l00182">size_array_</a>, and <a class="el" href="ArrOfDouble_8h_source.html#l00193">smart_resize_</a>.</p>

<p>Referenced by <a class="el" href="DoubleVect_8cpp_source.html#l00133">DoubleVect::ref()</a>, and <a class="el" href="ArrOfDouble_8cpp_source.html#l00964">ref_array()</a>.</p>
<div class="fragment"><pre class="fragment">{
<span class="comment">// Le tableau doit etre detache</span>
  assert(<a class="code" href="classArrOfDouble.html#a77419df7d43ac2ce76b9388a39ad90e9">data_</a> == 0 &amp;&amp; <a class="code" href="classArrOfDouble.html#a16cc4d79375188b7cb389fce2c920186">p_</a> == 0);
<span class="comment">// Le tableau doit etre different de *this</span>
  assert(&amp;m != <span class="keyword">this</span>);
  <span class="keywordflow">if</span> (size &lt; 0)
    size = m.size_array_ - start;
  assert(start &gt;= 0 &amp;&amp; size &gt;=0 &amp;&amp; start + size &lt;= m.size_array_);
  <span class="keywordflow">if</span> (m.size_array() &gt; 0)
    {
      <a class="code" href="classArrOfDouble.html#a16cc4d79375188b7cb389fce2c920186">p_</a> = m.p_;
      <span class="keywordflow">if</span> (<a class="code" href="classArrOfDouble.html#a16cc4d79375188b7cb389fce2c920186">p_</a>)
        <a class="code" href="classArrOfDouble.html#a16cc4d79375188b7cb389fce2c920186">p_</a>-&gt;<a class="code" href="classVDoubledata.html#a15b5bc0cf033070e4670245e2c3789ab" title="Un nouveau tableau utilise cette zone memoire : incremente ref_count.">add_one_ref</a>();
      <a class="code" href="classArrOfDouble.html#a77419df7d43ac2ce76b9388a39ad90e9">data_</a> = m.data_ + start;
      <a class="code" href="classArrOfDouble.html#ae201cdbdbf9f840376398199e5f737a0">size_array_</a> = size;
      <a class="code" href="classArrOfDouble.html#a952e7436d209c8957ea0209f1fa66976">memory_size_</a> = m.memory_size_ - start;
      <a class="code" href="classArrOfDouble.html#a527b3aabfef167644bb124f8255245b3">smart_resize_</a> = m.smart_resize_;
    }
  <span class="keywordflow">else</span>
    {
<span class="comment">// Cas particulier ou on attache un tableau de taille nulle:</span>
<span class="comment">// en theorie, c&#39;est pareil qu&#39;un tableau de taille non nulle, MAIS</span>
<span class="comment">// dans les operateurs (ex:Op_Dift_VDF_Face_Axi), une ref est construite</span>
<span class="comment">// avant que le tableau ne prenne sa taille definitive. Donc, pour ne pas</span>
<span class="comment">// empecher le resize, il ne faut pas attacher le tableau s&#39;il n&#39;a pas</span>
<span class="comment">// encore la bonne taille. Solution propre: reecrire les operateurs pour</span>
<span class="comment">// qu&#39;ils ne prennent pas une ref avant que le tableau ne soit valide</span>
<span class="comment">// et faire p_ = m.p_ dans tous les cas.</span>
<span class="comment">// Process::Journal() &lt;&lt; &quot;Warning ArrOfDouble::attach_array(m), m.size_array()==0, on n attache pas le tableau&quot; &lt;&lt; finl;</span>
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a89ba688c107e2f6089501983dfa051b0"></a><!-- doxytag: member="ArrOfDouble::copy_array" ref="a89ba688c107e2f6089501983dfa051b0" args="(const ArrOfDouble &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp; ArrOfDouble::copy_array </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>appelle operator=(a) </p>

<p>Definition at line <a class="el" href="ArrOfDouble_8cpp_source.html#l00500">500</a> of file <a class="el" href="ArrOfDouble_8cpp_source.html">ArrOfDouble.cpp</a>.</p>

<p>References <a class="el" href="ArrOfDouble_8cpp_source.html#l00467">operator=()</a>.</p>

<p>Referenced by <a class="el" href="Champ__front__contact__VEF_8cpp_source.html#l00204">Champ_front_contact_VEF::calcul_grads_transf()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <a class="code" href="classArrOfDouble.html#a433dc3b67b6d6e70f7dda611e67c45ac" title="Copie les donnees du tableau m. Si &quot;m&quot; n&#39;a pas la meme taille que &quot;*this&quot;, on fait un resize_arra...">operator=</a>(a);
  <span class="keywordflow">return</span> *<span class="keyword">this</span>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a4f257238def20a795b7f470c4c9c5617"></a><!-- doxytag: member="ArrOfDouble::cree_instance" ref="a4f257238def20a795b7f470c4c9c5617" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classObjet__U.html">Objet_U</a> * ArrOfDouble::cree_instance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented in <a class="el" href="classDoubleTab.html#a5be4e22576e583a5be4e6590f6b661ed">DoubleTab</a>, <a class="el" href="classDoubleTrav.html#a2e1d10cefecb29a1746453feb9ed4a6c">DoubleTrav</a>, and <a class="el" href="classDoubleVect.html#ae3f00f45147d3d58937860d37cdb858a">DoubleVect</a>.</p>

<p>Definition at line <a class="el" href="ArrOfDouble_8cpp_source.html#l00037">37</a> of file <a class="el" href="ArrOfDouble_8cpp_source.html">ArrOfDouble.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{
</pre></div>
</div>
</div>
<a class="anchor" id="a30d7509eec18c3ef46cc0140bdcdc48f"></a><!-- doxytag: member="ArrOfDouble::detach_array" ref="a30d7509eec18c3ef46cc0140bdcdc48f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ArrOfDouble::detach_array </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Amene le tableau dans l'etat "detache". C'est a dire:<br/>
Si le tableau est "detache" :<br/>
* ne rien faire<br/>
Si le tableau est "normal" :<br/>
* decremente le nombre de references a *p<br/>
* detruit *p si p-&gt;ref_count==0<br/>
* annule p_, data_ et size_array_<br/>
Si le tableau est "ref_data" :<br/>
* annule data_ et size_array_. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>int<br/>
 Signification: 1 si les donnees du tableau ont ete supprimees </dd></dl>

<p>Definition at line <a class="el" href="ArrOfDouble_8cpp_source.html#l01014">1014</a> of file <a class="el" href="ArrOfDouble_8cpp_source.html">ArrOfDouble.cpp</a>.</p>

<p>References <a class="el" href="ArrOfDouble_8h_source.html#l00178">data_</a>, <a class="el" href="ArrOfDouble_8h_source.html#l00187">memory_size_</a>, <a class="el" href="ArrOfDouble_8h_source.html#l00170">p_</a>, <a class="el" href="ArrOfDouble_8h_source.html#l00182">size_array_</a>, and <a class="el" href="ArrOfDouble_8cpp_source.html#l00216">VDoubledata::suppr_one_ref()</a>.</p>

<p>Referenced by <a class="el" href="ArrOfDouble_8cpp_source.html#l00541">memory_resize()</a>, <a class="el" href="DoubleVect_8cpp_source.html#l00133">DoubleVect::ref()</a>, <a class="el" href="ArrOfDouble_8cpp_source.html#l00964">ref_array()</a>, <a class="el" href="ArrOfDouble_8cpp_source.html#l00988">ref_data()</a>, <a class="el" href="ArrOfDouble_8cpp_source.html#l00451">reset()</a>, and <a class="el" href="ArrOfDouble_8cpp_source.html#l00316">~ArrOfDouble()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">int</span> retour = 0;
  <span class="keywordflow">if</span> (<a class="code" href="classArrOfDouble.html#a16cc4d79375188b7cb389fce2c920186">p_</a>)
    {
<span class="comment">// Le tableau est de type &quot;normal&quot;</span>
<span class="comment">// Si la zone de memoire n&#39;est plus utilisee par personne,</span>
<span class="comment">// on la detruit.</span>
      <span class="keywordflow">if</span> ((<a class="code" href="classArrOfDouble.html#a16cc4d79375188b7cb389fce2c920186">p_</a>-&gt;<a class="code" href="classVDoubledata.html#ad09f0a1c617ee9eb1b0af8cc324c7348" title="Un tableau de moins utilise cette zone memoire decremente ref_count.">suppr_one_ref</a>()) == 0)
        {
          <span class="keyword">delete</span> <a class="code" href="classArrOfDouble.html#a16cc4d79375188b7cb389fce2c920186">p_</a>;
          retour = 1;
        }
      <a class="code" href="classArrOfDouble.html#a16cc4d79375188b7cb389fce2c920186">p_</a> = 0;
    }
  <a class="code" href="classArrOfDouble.html#a77419df7d43ac2ce76b9388a39ad90e9">data_</a> = 0;
  <a class="code" href="classArrOfDouble.html#ae201cdbdbf9f840376398199e5f737a0">size_array_</a> = 0;
  <a class="code" href="classArrOfDouble.html#a952e7436d209c8957ea0209f1fa66976">memory_size_</a> = 0;
  <span class="keywordflow">return</span> retour;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a121292f1748dacefa9d701e5d64557f9"></a><!-- doxytag: member="ArrOfDouble::duplique" ref="a121292f1748dacefa9d701e5d64557f9" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ArrOfDouble::duplique </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implements <a class="el" href="classArray__base.html#a4116173313698f7f48ffe1765b474083">Array_base</a>.</p>

<p>Reimplemented in <a class="el" href="classDoubleTab.html#acd2241580fb245a65abd412cd427f385">DoubleTab</a>, <a class="el" href="classDoubleTrav.html#a10183892743b44a3ffb778408a5b9d8b">DoubleTrav</a>, and <a class="el" href="classDoubleVect.html#a94226f3c1cc26a9e83646c8f8107fb57">DoubleVect</a>.</p>

<p>Definition at line <a class="el" href="ArrOfDouble_8cpp_source.html#l00037">37</a> of file <a class="el" href="ArrOfDouble_8cpp_source.html">ArrOfDouble.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{
</pre></div>
</div>
</div>
<a class="anchor" id="a67d30f4f02d7656362fce21d8e0e9745"></a><!-- doxytag: member="ArrOfDouble::fill_default_value" ref="a67d30f4f02d7656362fce21d8e0e9745" args="(Array_base::Resize_Options opt, int first, int nb)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ArrOfDouble::fill_default_value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classArray__base.html#abee342aa9ac59623c4c782dc9d7877ff">Array_base::Resize_Options</a>&#160;</td>
          <td class="paramname"><em>opt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Remplit "nb" cases consecutives du tableau a partir de la case "first"<br/>
avec une valeur par defaut.<br/>
Cette fonction est appelee lors d'un resize pour initialiser les<br/>
cases nouvellement creees.<br/>
Le comportement depend actuellement du type de tableau :<br/>
* Tableau de type "smart_resize":<br/>
* en mode debug (macro NDEBUG non definie) le tableau est initialise<br/>
avec une valeur invalide.<br/>
* en optimise, le tableau n'est pas initialise<br/>
* Tableau normal :<br/>
Le tableau est initialise avec la valeur 0. Ce comportement est choisi<br/>
pour des raisons de compatibilite avec l'implementation precedente.<br/>
Cette specification pourrait etre modifiee prochainement pour des raisons<br/>
de performances (pour ne pas avoir a initialiser inutilement les tableaux).<br/>
DONC: il faut supposer desormais que les nouvelles cases ne sont pas<br/>
initialisees lors d'un resize.<br/>
Parametre: first<br/>
Signification: premiere case a initialiser.<br/>
Contrainte: (nb==0) ou (0 &lt;= first &lt; memory_size_)<br/>
Parametre: nb<br/>
Signification: nombre de cases a initialiser.<br/>
Contrainte: (nb==0) ou (0 &lt; nb &lt;= memory_size_ - first) </p>

<p>Definition at line <a class="el" href="ArrOfDouble_8cpp_source.html#l00650">650</a> of file <a class="el" href="ArrOfDouble_8cpp_source.html">ArrOfDouble.cpp</a>.</p>

<p>References <a class="el" href="Array__base_8h_source.html#l00038">Array_base::COPY_INIT</a>, <a class="el" href="ArrOfDouble_8h_source.html#l00178">data_</a>, <a class="el" href="Double_8h_source.html#l00072">DMAXFLOAT</a>, and <a class="el" href="ArrOfDouble_8h_source.html#l00187">memory_size_</a>.</p>

<p>Referenced by <a class="el" href="ArrOfDouble_8cpp_source.html#l00342">ArrOfDouble()</a>, and <a class="el" href="ArrOfDouble_8cpp_source.html#l00541">memory_resize()</a>.</p>
<div class="fragment"><pre class="fragment">{
  assert((nb == 0) || (first &gt;= 0 &amp;&amp; first &lt; <a class="code" href="classArrOfDouble.html#a952e7436d209c8957ea0209f1fa66976">memory_size_</a>));
  assert((nb == 0) || (nb &gt; 0 &amp;&amp; nb &lt;= <a class="code" href="classArrOfDouble.html#a952e7436d209c8957ea0209f1fa66976">memory_size_</a> - first));
  <span class="keywordtype">double</span> * data = <a class="code" href="classArrOfDouble.html#a77419df7d43ac2ce76b9388a39ad90e9">data_</a>;
  assert(data!=0 || nb==0);
  data += first;
  <span class="keywordflow">if</span> (opt != <a class="code" href="classArray__base.html#abee342aa9ac59623c4c782dc9d7877ffa9a675e25b5b7accff8d861e05060547b">COPY_INIT</a>)
    {
<span class="comment">// On initialise uniquement en mode debug</span>
<span class="preprocessor">#ifndef NDEBUG</span>
<span class="preprocessor"></span><span class="comment">// B.M. L&#39;utilisation de NAN n&#39;est pas possible car elle provoque une erreur</span>
<span class="comment">// dans double &amp; operator[] a cause de assert(...DMAXFLOAT). Du coup il est</span>
<span class="comment">// impossible de mettre une valeur dans le tableau autrement qu&#39;avec append_array()</span>
<span class="preprocessor">#if 0</span>
<span class="preprocessor"></span><span class="comment">// Ceci represente un NAN. N&#39;importe quelle operation avec ca fait encore un NAN.</span>
<span class="comment">// Si c&#39;est pas portable, on peut remplacer par DMAX_FLOAT sur les autres machines.</span>
<span class="comment">// Attention, il faut long long car sinon warning sur gcc 4.1 et i686</span>
      <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> VALEUR_INVALIDE =
        0x7ff7ffffffffffffULL;
      <span class="comment">/* static const double VALEUR_INVALIDE = DMAXFLOAT;    */</span>

<span class="comment">// On utilise &quot;memcpy&quot; et non &quot;=&quot; car &quot;=&quot; peut provoquer une exception</span>
<span class="comment">// si la copie passe par le fpu.</span>
      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; nb; i++)
        memcpy(data + i, &amp; VALEUR_INVALIDE, <span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));
<span class="preprocessor">#else</span>
<span class="preprocessor"></span><span class="comment">// Alternative acceptable... ?</span>
      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; nb; i++)
        data[i] = <a class="code" href="Double_8h.html#ae0ee0cebfad5968da0ad6cc7a49e16b6">DMAXFLOAT</a>*0.999;
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span><span class="preprocessor">#endif</span>
<span class="preprocessor"></span>    }
  <span class="keywordflow">else</span>
    {
<span class="comment">// Comportement pour les tableaux normaux : compatibilite avec la</span>
<span class="comment">// version precedente : on initialise avec 0.</span>
      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; nb; i++)
        data[i] = (<span class="keywordtype">double</span>) 0;
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a4f370ec412709796eb51fef1d1f068ac"></a><!-- doxytag: member="ArrOfDouble::get_info" ref="a4f370ec412709796eb51fef1d1f068ac" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classType__info.html">Type_info</a> * ArrOfDouble::get_info </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Donne des informations sur le type de l'Objet_U. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>const Type_info*<br/>
 Signification: structure regroupant les informations sur le type de l'Objet_U<br/>
 Contraintes: </dd></dl>

<p>Reimplemented from <a class="el" href="classArray__base.html#a794e57ef060138d9ecbdb37d34d46634">Array_base</a>.</p>

<p>Reimplemented in <a class="el" href="classDoubleTab.html#a626679285ce3564bb1990033fb0cfdb4">DoubleTab</a>, <a class="el" href="classDoubleTrav.html#a156b70bb22a3ecefdf2a83587b0f2945">DoubleTrav</a>, and <a class="el" href="classDoubleVect.html#a530ac863a73858ff1254f70de10b6348">DoubleVect</a>.</p>

<p>Definition at line <a class="el" href="ArrOfDouble_8cpp_source.html#l00037">37</a> of file <a class="el" href="ArrOfDouble_8cpp_source.html">ArrOfDouble.cpp</a>.</p>

<p>Referenced by <a class="el" href="DoubleVect_8cpp_source.html#l00166">DoubleVect::copy()</a>, and <a class="el" href="ArrOfDouble_8h_source.html#l00244">resize_array()</a>.</p>
<div class="fragment"><pre class="fragment">{
</pre></div>
</div>
</div>
<a class="anchor" id="a2b905fb71100ad2c00ada973435d3cea"></a><!-- doxytag: member="ArrOfDouble::get_mem_storage" ref="a2b905fb71100ad2c00ada973435d3cea" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classArrOfDouble.html#aa6c9b9bbc6bc40ecd74d10411dc560de">ArrOfDouble::Storage</a> ArrOfDouble::get_mem_storage </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Renvoie le mode d'allocation du tableau (qui sera utilise<br/>
lors du prochain resize si changement de taille).<br/>
(voir <a class="el" href="classVDoubledata.html" title="VDoubledata alloue une zone de memoire de la taille specifiee au constructeur, et libere la zone de m...">VDoubledata</a> et <a class="el" href="classDouble__ptr__trav.html" title="Une zone de travail de la Memoire TRUST composee d&#39;elements de type double.">Double_ptr_trav</a>) </p>

<p>Definition at line <a class="el" href="ArrOfDouble_8cpp_source.html#l00432">432</a> of file <a class="el" href="ArrOfDouble_8cpp_source.html">ArrOfDouble.cpp</a>.</p>

<p>References <a class="el" href="ArrOfDouble_8h_source.html#l00197">storage_type_</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">return</span> <a class="code" href="classArrOfDouble.html#a9724d501cbca852e174ef0a7351698b1">storage_type_</a>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="af51837b06770e07fa016fda29eb0bf3a"></a><!-- doxytag: member="ArrOfDouble::info" ref="af51837b06770e07fa016fda29eb0bf3a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classType__info.html">Type_info</a> * ArrOfDouble::info </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Donne des informations sur le type de l'Objet_U. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>const Type_info*<br/>
 Signification: structure regroupant les informations sur le type de l'Objet_U<br/>
 Contraintes: </dd></dl>

<p>Reimplemented from <a class="el" href="classArray__base.html#a5214dee08ff85f62ec0aef0806eadeae">Array_base</a>.</p>

<p>Reimplemented in <a class="el" href="classDoubleTab.html#a76c632079308b096de27f09a3f56543a">DoubleTab</a>, <a class="el" href="classDoubleTrav.html#a39bec8936922301d3fd35404b1c80f17">DoubleTrav</a>, and <a class="el" href="classDoubleVect.html#abd68c2dcd3230d422bf30045df688994">DoubleVect</a>.</p>

<p>Definition at line <a class="el" href="ArrOfDouble_8cpp_source.html#l00037">37</a> of file <a class="el" href="ArrOfDouble_8cpp_source.html">ArrOfDouble.cpp</a>.</p>

<p>Referenced by <a class="el" href="ArrOfDouble_8h_source.html#l00244">resize_array()</a>.</p>
<div class="fragment"><pre class="fragment">{
</pre></div>
</div>
</div>
<a class="anchor" id="a2fcb2a2d3b59425c6cb37526ea6af6a3"></a><!-- doxytag: member="ArrOfDouble::inject_array" ref="a2fcb2a2d3b59425c6cb37526ea6af6a3" args="(const ArrOfDouble &amp;source, int nb_elements=&#45;1, int first_element_dest=0, int first_element_source=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp; ArrOfDouble::inject_array </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nb_elements</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>first_element_dest</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>first_element_source</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copie les elements source[first_element_source + i]<br/>
dans les elements (*this)[first_element_dest + i] pour 0 &lt;= i &lt; nb_elements<br/>
Les autres elements de (*this) sont inchanges. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a>&amp;<br/>
 Signification: *this<br/>
 Contraintes: </dd></dl>

<p>Definition at line <a class="el" href="ArrOfDouble_8cpp_source.html#l01110">1110</a> of file <a class="el" href="ArrOfDouble_8cpp_source.html">ArrOfDouble.cpp</a>.</p>

<p>References <a class="el" href="ArrOfDouble_8h_source.html#l00379">addr()</a>, <a class="el" href="ArrOfDouble_8h_source.html#l00178">data_</a>, and <a class="el" href="ArrOfDouble_8h_source.html#l00350">size_array()</a>.</p>

<p>Referenced by <a class="el" href="Array__tools_8cpp_source.html#l00523">append_array_to_array()</a>, <a class="el" href="ArrOfDouble_8cpp_source.html#l00390">ArrOfDouble()</a>, <a class="el" href="Eval__Source__C__VEF__Face_8h_source.html#l00112">Eval_Source_C_VEF_Face::calculer_terme_source_non_standard()</a>, <a class="el" href="Eval__Source__C__VEF__Face_8h_source.html#l00096">Eval_Source_C_VEF_Face::calculer_terme_source_standard()</a>, <a class="el" href="DoubleVect_8cpp_source.html#l00166">DoubleVect::copy()</a>, <a class="el" href="DoubleVect_8cpp_source.html#l00191">DoubleVect::copy_()</a>, <a class="el" href="communications_8cpp_source.html#l00497">envoyer_all_to_all()</a>, <a class="el" href="ExtrudeParoi_8cpp_source.html#l00159">ExtrudeParoi::extrude()</a>, <a class="el" href="Modifier__pour__fluide__dilatable_8cpp_source.html#l00037">multiplier_diviser_rho()</a>, <a class="el" href="ArrOfDouble_8cpp_source.html#l00467">operator=()</a>, <a class="el" href="Solv__GCP_8cpp_source.html#l00124">Solv_GCP::prepare_data()</a>, <a class="el" href="Op__Diff__VEF__base_8cpp_source.html#l00268">Op_Diff_VEF_base::remplir_nu()</a>, <a class="el" href="Solv__GCP_8cpp_source.html#l00404">Solv_GCP::resoudre_()</a>, <a class="el" href="Discret__Thyd_8cpp_source.html#l00253">Discret_Thyd::section_passage()</a>, and <a class="el" href="Op__Diff__PolyMAC__base_8cpp_source.html#l00324">Op_Diff_PolyMAC_base::update_nu()</a>.</p>
<div class="fragment"><pre class="fragment">{
  assert(&amp;source != <span class="keyword">this</span>);
  assert(nb_elements &gt;= -1);
  assert(first_element_dest &gt;= 0);
  assert(first_element_source &gt;= 0);

  <span class="keywordflow">if</span> (nb_elements &lt; 0)
    nb_elements = source.<a class="code" href="classArrOfDouble.html#a3c3b33bea0e88b87315c21ee94bee05f" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>();

  assert(first_element_source + nb_elements &lt;= source.<a class="code" href="classArrOfDouble.html#a3c3b33bea0e88b87315c21ee94bee05f" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>());
  assert(first_element_dest + nb_elements &lt;= <a class="code" href="classArrOfDouble.html#a3c3b33bea0e88b87315c21ee94bee05f" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>());

  <span class="keywordflow">if</span> (nb_elements &gt; 0)
    {
      <span class="keywordtype">double</span> * addr_dest = <a class="code" href="classArrOfDouble.html#a77419df7d43ac2ce76b9388a39ad90e9">data_</a> + first_element_dest;
      <span class="keyword">const</span> <span class="keywordtype">double</span> * addr_source = source.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() + first_element_source;
<span class="comment">// PL: On utilise le memcpy car c&#39;est VRAIMENT plus rapide (10% +vite sur RNR_G20)</span>
      memcpy(addr_dest , addr_source, nb_elements * <span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));
      <span class="comment">/*</span>
<span class="comment">        int i;</span>
<span class="comment">        for (i = 0; i &lt; nb_elements; i++) {</span>
<span class="comment">        addr_dest[i] = addr_source[i];</span>
<span class="comment">        } */</span>
    }
  <span class="keywordflow">return</span> *<span class="keyword">this</span>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a98d8a5b5486b130787f95664ee8127e6"></a><!-- doxytag: member="ArrOfDouble::memory_resize" ref="a98d8a5b5486b130787f95664ee8127e6" args="(int new_size, Array_base::Resize_Options opt=COPY_INIT)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ArrOfDouble::memory_resize </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>new_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArray__base.html#abee342aa9ac59623c4c782dc9d7877ff">Array_base::Resize_Options</a>&#160;</td>
          <td class="paramname"><em>opt</em> = <code>COPY_INIT</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Si besoin, alloue une nouvelle zone de memoire,<br/>
copie les donnees et efface l'ancienne zone de memoire.<br/>
Attention, on suppose que cette methode est appelee par<br/>
<a class="el" href="classArrOfDouble.html#a610464f4b3dccac6f814915b526783ed">resize_array()</a>.<br/>
Attention: si ref_count_&gt;1, l'appel a <a class="el" href="classArrOfDouble.html#a610464f4b3dccac6f814915b526783ed">resize_array()</a> est<br/>
autorise uniquement si la nouvelle taille est identique<br/>
a la precedente (auquel cas on ne fait rien)<br/>
Si ref_count_ == 1, l'appel est invalide si p_-&gt;data_ est<br/>
different de data_ (le tableau a ete construit avec <a class="el" href="classArrOfDouble.html#a1831984f45c77967bf13fe67b97e95a9" title="Fait pointer le tableau vers les memes donnees qu&#39;un tableau existant. Le tableau sera du meme type q...">ref_array()</a><br/>
avec start &gt; 0) </p>

<p>Definition at line <a class="el" href="ArrOfDouble_8cpp_source.html#l00541">541</a> of file <a class="el" href="ArrOfDouble_8cpp_source.html">ArrOfDouble.cpp</a>.</p>

<p>References <a class="el" href="Array__base_8h_source.html#l00038">Array_base::COPY_INIT</a>, <a class="el" href="ArrOfDouble_8h_source.html#l00178">data_</a>, <a class="el" href="ArrOfDouble_8cpp_source.html#l01014">detach_array()</a>, <a class="el" href="ArrOfDouble_8cpp_source.html#l00650">fill_default_value()</a>, <a class="el" href="ArrOfDouble_8cpp_source.html#l00223">VDoubledata::get_data()</a>, <a class="el" href="ArrOfDouble_8cpp_source.html#l00194">VDoubledata::get_size()</a>, <a class="el" href="ArrOfDouble_8h_source.html#l00187">memory_size_</a>, <a class="el" href="Array__base_8h_source.html#l00038">Array_base::NOCOPY_NOINIT</a>, <a class="el" href="ArrOfDouble_8h_source.html#l00170">p_</a>, <a class="el" href="ArrOfDouble_8cpp_source.html#l01146">ref_count()</a>, <a class="el" href="ArrOfDouble_8h_source.html#l00182">size_array_</a>, <a class="el" href="ArrOfDouble_8h_source.html#l00193">smart_resize_</a>, and <a class="el" href="ArrOfDouble_8h_source.html#l00197">storage_type_</a>.</p>

<p>Referenced by <a class="el" href="ArrOfDouble_8h_source.html#l00260">resize_array_()</a>.</p>
<div class="fragment"><pre class="fragment">{
  assert(new_size &gt;= 0);

<span class="comment">// Si new_size==size_array_, on ne fait rien, c&#39;est toujours autorise</span>
  <span class="keywordflow">if</span> (new_size == <a class="code" href="classArrOfDouble.html#ae201cdbdbf9f840376398199e5f737a0">size_array_</a>)
    <span class="keywordflow">return</span>;

<span class="comment">// Sinon, il faut que le resize soit autorise, c&#39;est a dire</span>
<span class="comment">// - soit le tableau est detache</span>
<span class="comment">// - soit le tableau est normal et il n&#39;y a pas d&#39;autre reference au tableau</span>
  assert((<a class="code" href="classArrOfDouble.html#a77419df7d43ac2ce76b9388a39ad90e9">data_</a> == 0) || ((<a class="code" href="classArrOfDouble.html#a16cc4d79375188b7cb389fce2c920186">p_</a> != 0) &amp;&amp; (<a class="code" href="classArrOfDouble.html#a16cc4d79375188b7cb389fce2c920186">p_</a>-&gt;<a class="code" href="classVDoubledata.html#a554af3f6bbf09270b1c4862de9654c17" title="renvoie data_">get_data</a>() == <a class="code" href="classArrOfDouble.html#a77419df7d43ac2ce76b9388a39ad90e9">data_</a>) &amp;&amp; (<a class="code" href="classArrOfDouble.html#a324a6714dc9d9a7b5997fda646d24974" title="Retourne le nombre de references des donnees du tableau si le tableau est &quot;normal&quot;, -1 s&#39;il est &quot;detache&quot; ou &quot;ref_data&quot;.">ref_count</a>() == 1)));

<span class="comment">// Occupation memoire de l&#39;ancien tableau:</span>
  <span class="keywordtype">int</span> old_mem_size = <a class="code" href="classArrOfDouble.html#a952e7436d209c8957ea0209f1fa66976">memory_size_</a>;
  assert((!<a class="code" href="classArrOfDouble.html#a16cc4d79375188b7cb389fce2c920186">p_</a>) || (<a class="code" href="classArrOfDouble.html#a16cc4d79375188b7cb389fce2c920186">p_</a>-&gt;<a class="code" href="classVDoubledata.html#aa4024084623369d62bfc24a70fdec663" title="renvoie size_">get_size</a>() == <a class="code" href="classArrOfDouble.html#a952e7436d209c8957ea0209f1fa66976">memory_size_</a>));
  assert(<a class="code" href="classArrOfDouble.html#a952e7436d209c8957ea0209f1fa66976">memory_size_</a> &gt;= <a class="code" href="classArrOfDouble.html#ae201cdbdbf9f840376398199e5f737a0">size_array_</a>);

<span class="comment">// Occupation memoire du nouveau tableau :</span>
<span class="comment">// Si smart_resize, on prend au moins deux fois la taille</span>
<span class="comment">// precedente, ou new_size</span>
  <span class="keywordtype">int</span> new_mem_size = new_size;
  <span class="keywordflow">if</span> (<a class="code" href="classArrOfDouble.html#a527b3aabfef167644bb124f8255245b3">smart_resize_</a>)
    {
      <span class="keywordflow">if</span> (new_size &lt;= old_mem_size)
        new_mem_size = old_mem_size;
      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (new_size &lt; old_mem_size * 2)
        new_mem_size = old_mem_size * 2;
      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (new_size &gt; old_mem_size &amp;&amp; old_mem_size &gt; INT_MAX / 2)
        new_mem_size = INT_MAX;
    }

  <span class="keywordflow">if</span> (new_mem_size != old_mem_size)
    {
<span class="comment">// detach_array() efface le contenu de size_array_. On le met de cote:</span>
      <span class="keyword">const</span> <span class="keywordtype">int</span> old_size_array = <a class="code" href="classArrOfDouble.html#ae201cdbdbf9f840376398199e5f737a0">size_array_</a>;
      <span class="keywordflow">if</span> (new_mem_size == 0)
        {
<span class="comment">// La nouvelle taille est nulle, on cree un tableau &quot;detache&quot;</span>
          <a class="code" href="classArrOfDouble.html#a30d7509eec18c3ef46cc0140bdcdc48f" title="Amene le tableau dans l&#39;etat &quot;detache&quot;. C&#39;est a dire: Si le tableau est &quot;detache&quot; : * ne rien faire...">detach_array</a>();
        }
      <span class="keywordflow">else</span>
        {
<span class="comment">// Allocation d&#39;une nouvelle zone</span>
          <a class="code" href="classVDoubledata.html" title="VDoubledata alloue une zone de memoire de la taille specifiee au constructeur, et libere la zone de m...">VDoubledata</a> * new_p = <span class="keyword">new</span> <a class="code" href="classVDoubledata.html" title="VDoubledata alloue une zone de memoire de la taille specifiee au constructeur, et libere la zone de m...">VDoubledata</a>(new_mem_size, <a class="code" href="classArrOfDouble.html#a9724d501cbca852e174ef0a7351698b1">storage_type_</a>);
          <span class="keywordtype">double</span> * new_data = new_p-&gt;<a class="code" href="classVDoubledata.html#a554af3f6bbf09270b1c4862de9654c17" title="renvoie data_">get_data</a>();
<span class="comment">// Raccourci si le tableau etait &quot;detache&quot;, inutile de copier</span>
<span class="comment">// les anciennes donnees. On copie si COPY_OLD est demande</span>
          <span class="keywordtype">int</span> copy_size = 0;
          <span class="keywordflow">if</span> (<a class="code" href="classArrOfDouble.html#a77419df7d43ac2ce76b9388a39ad90e9">data_</a> != 0)
            {
<span class="comment">// Calcul du nombre d&#39;elements a copier vers la nouvelle</span>
<span class="comment">// zone de memoire : c&#39;est le min de l&#39;ancienne et de</span>
<span class="comment">// la nouvelle taille.</span>
              <span class="keywordflow">if</span> (opt != <a class="code" href="classArray__base.html#abee342aa9ac59623c4c782dc9d7877ffaf6ae9ba7eb51c5f298ce693345b3ec68">NOCOPY_NOINIT</a>)
                {
                  copy_size = <a class="code" href="classArrOfDouble.html#ae201cdbdbf9f840376398199e5f737a0">size_array_</a>;
                  <span class="keywordflow">if</span> (new_size &lt; copy_size)
                    copy_size = new_size;
<span class="comment">// Copie des valeurs dans le nouveau tableau</span>
                  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; copy_size; i++)
                    new_data[i] = <a class="code" href="classArrOfDouble.html#a77419df7d43ac2ce76b9388a39ad90e9">data_</a>[i];
                }
<span class="comment">// Destruction de l&#39;ancienne zone (si plus aucune reference)</span>
              <a class="code" href="classArrOfDouble.html#a30d7509eec18c3ef46cc0140bdcdc48f" title="Amene le tableau dans l&#39;etat &quot;detache&quot;. C&#39;est a dire: Si le tableau est &quot;detache&quot; : * ne rien faire...">detach_array</a>();
            }
<span class="comment">// On attache la nouvelle zone de memoire</span>
          <a class="code" href="classArrOfDouble.html#a16cc4d79375188b7cb389fce2c920186">p_</a> = new_p;
          <a class="code" href="classArrOfDouble.html#a77419df7d43ac2ce76b9388a39ad90e9">data_</a> = new_data;
          <a class="code" href="classArrOfDouble.html#a952e7436d209c8957ea0209f1fa66976">memory_size_</a> = new_mem_size;
<span class="comment">// Initialisation des cases supplementaires avec une valeur par defaut</span>
          <a class="code" href="classArrOfDouble.html#a67d30f4f02d7656362fce21d8e0e9745" title="Remplit &quot;nb&quot; cases consecutives du tableau a partir de la case &quot;first&quot; avec une valeur par defaut...">fill_default_value</a>(opt, copy_size, new_mem_size - copy_size);
<span class="comment">// Restaure l&#39;ancienne valeur de size_array_</span>
          <a class="code" href="classArrOfDouble.html#ae201cdbdbf9f840376398199e5f737a0">size_array_</a> = old_size_array;
        }
    }
  <span class="keywordflow">else</span>
    {
<span class="comment">// Pas de reallocation, initialisation si besoin</span>
      <span class="keywordflow">if</span> (opt == <a class="code" href="classArray__base.html#abee342aa9ac59623c4c782dc9d7877ffa9a675e25b5b7accff8d861e05060547b">COPY_INIT</a> &amp;&amp; new_size &gt; <a class="code" href="classArrOfDouble.html#ae201cdbdbf9f840376398199e5f737a0">size_array_</a>)
        {
          <a class="code" href="classArrOfDouble.html#a67d30f4f02d7656362fce21d8e0e9745" title="Remplit &quot;nb&quot; cases consecutives du tableau a partir de la case &quot;first&quot; avec une valeur par defaut...">fill_default_value</a>(opt, <a class="code" href="classArrOfDouble.html#ae201cdbdbf9f840376398199e5f737a0">size_array_</a>, new_size - <a class="code" href="classArrOfDouble.html#ae201cdbdbf9f840376398199e5f737a0">size_array_</a>);
        }
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a1318e4d5d3e8a95119dcd4ddd6b7403b"></a><!-- doxytag: member="ArrOfDouble::operator()" ref="a1318e4d5d3e8a95119dcd4ddd6b7403b" args="(int i)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double &amp; ArrOfDouble::operator() </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>idem operator[] </p>

<p>Reimplemented in <a class="el" href="classDoubleTab.html#a10c51674e8197125dbebdf8ed597c1d1">DoubleTab</a>.</p>

<p>Definition at line <a class="el" href="ArrOfDouble_8h_source.html#l00335">335</a> of file <a class="el" href="ArrOfDouble_8h_source.html">ArrOfDouble.h</a>.</p>

<p>References <a class="el" href="ArrOfDouble_8h_source.html#l00311">operator[]()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">return</span> <a class="code" href="classArrOfDouble.html#a5b23a83d22d2c8b6278b0d14fb5c9ede" title="operateur [] retourne le ieme element du tableau">operator[]</a>(i);
}
</pre></div>
</div>
</div>
<a class="anchor" id="a0594a5464922bed384889c63c6b970e8"></a><!-- doxytag: member="ArrOfDouble::operator()" ref="a0594a5464922bed384889c63c6b970e8" args="(int i) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const double &amp; ArrOfDouble::operator() </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented in <a class="el" href="classDoubleTab.html#aee0db63d8bd2b9a9b45ec8a38fd71491">DoubleTab</a>.</p>

<p>Definition at line <a class="el" href="ArrOfDouble_8h_source.html#l00340">340</a> of file <a class="el" href="ArrOfDouble_8h_source.html">ArrOfDouble.h</a>.</p>

<p>References <a class="el" href="ArrOfDouble_8h_source.html#l00311">operator[]()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">return</span> <a class="code" href="classArrOfDouble.html#a5b23a83d22d2c8b6278b0d14fb5c9ede" title="operateur [] retourne le ieme element du tableau">operator[]</a>(i);
}
</pre></div>
</div>
</div>
<a class="anchor" id="a6ec3428662ddd818f935ffe1b6c57347"></a><!-- doxytag: member="ArrOfDouble::operator*=" ref="a6ec3428662ddd818f935ffe1b6c57347" args="(const double)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp; ArrOfDouble::operator*= </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>dy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>muliplie toutes les cases par dy </p>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a> &amp;<br/>
 Signification: *this </dd></dl>

<p>Reimplemented in <a class="el" href="classDoubleVect.html#acecc46ec6cbbd6aa9e36172b15d3601a">DoubleVect</a>.</p>

<p>Definition at line <a class="el" href="ArrOfDouble_8cpp_source.html#l01238">1238</a> of file <a class="el" href="ArrOfDouble_8cpp_source.html">ArrOfDouble.cpp</a>.</p>

<p>References <a class="el" href="ArrOfDouble_8h_source.html#l00178">data_</a>, and <a class="el" href="ArrOfDouble_8h_source.html#l00350">size_array()</a>.</p>

<p>Referenced by <a class="el" href="ArrOfDouble_8cpp_source.html#l01252">operator/=()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">double</span> * data = <a class="code" href="classArrOfDouble.html#a77419df7d43ac2ce76b9388a39ad90e9">data_</a>;
  <span class="keyword">const</span> <span class="keywordtype">int</span> n = <a class="code" href="classArrOfDouble.html#a3c3b33bea0e88b87315c21ee94bee05f" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>();
  <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i &lt; n; i++)
    data[i] *= dy;
  <span class="keywordflow">return</span> *<span class="keyword">this</span>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a2d092d5c1a7d8523c65ca2e85507fd0d"></a><!-- doxytag: member="ArrOfDouble::operator+=" ref="a2d092d5c1a7d8523c65ca2e85507fd0d" args="(const ArrOfDouble &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp; ArrOfDouble::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;&#160;</td>
          <td class="paramname"><em>y</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Addition case a case sur toutes les cases du tableau. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a>&amp;<br/>
 Signification: *this<br/>
 Contraintes: </dd></dl>

<p>Definition at line <a class="el" href="ArrOfDouble_8cpp_source.html#l01169">1169</a> of file <a class="el" href="ArrOfDouble_8cpp_source.html">ArrOfDouble.cpp</a>.</p>

<p>References <a class="el" href="ArrOfDouble_8h_source.html#l00178">data_</a>, and <a class="el" href="ArrOfDouble_8h_source.html#l00350">size_array()</a>.</p>
<div class="fragment"><pre class="fragment">{
  assert(<a class="code" href="classArrOfDouble.html#a3c3b33bea0e88b87315c21ee94bee05f" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>()==y.<a class="code" href="classArrOfDouble.html#a3c3b33bea0e88b87315c21ee94bee05f" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>());
  <span class="keywordtype">double</span>* dx = <a class="code" href="classArrOfDouble.html#a77419df7d43ac2ce76b9388a39ad90e9">data_</a>;
  <span class="keyword">const</span> <span class="keywordtype">double</span>* dy = y.<a class="code" href="classArrOfDouble.html#a77419df7d43ac2ce76b9388a39ad90e9">data_</a>;
  <span class="keyword">const</span> <span class="keywordtype">int</span> n = <a class="code" href="classArrOfDouble.html#a3c3b33bea0e88b87315c21ee94bee05f" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>();
  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;n; i++)
    dx[i] += dy[i];
  <span class="keywordflow">return</span> *<span class="keyword">this</span>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a688855b6b9ccf42e2b4f51c3ba4edc59"></a><!-- doxytag: member="ArrOfDouble::operator+=" ref="a688855b6b9ccf42e2b4f51c3ba4edc59" args="(const double)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp; ArrOfDouble::operator+= </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>dy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>ajoute la meme valeur a toutes les cases du tableau </p>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a><br/>
 Signification: *this<br/>
 Contraintes: </dd></dl>

<p>Reimplemented in <a class="el" href="classDoubleVect.html#a4b639a09dba0f4bd8ebfdfe8ac6b1085">DoubleVect</a>.</p>

<p>Definition at line <a class="el" href="ArrOfDouble_8cpp_source.html#l01194">1194</a> of file <a class="el" href="ArrOfDouble_8cpp_source.html">ArrOfDouble.cpp</a>.</p>

<p>References <a class="el" href="ArrOfDouble_8h_source.html#l00178">data_</a>, and <a class="el" href="ArrOfDouble_8h_source.html#l00350">size_array()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">double</span> * data = <a class="code" href="classArrOfDouble.html#a77419df7d43ac2ce76b9388a39ad90e9">data_</a>;
  <span class="keyword">const</span> <span class="keywordtype">int</span> n = <a class="code" href="classArrOfDouble.html#a3c3b33bea0e88b87315c21ee94bee05f" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>();
  <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i &lt; n; i++)
    data[i] += dy;
  <span class="keywordflow">return</span> *<span class="keyword">this</span>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a94cc5d4c485cc75070ec3a041288c0bd"></a><!-- doxytag: member="ArrOfDouble::operator&#45;=" ref="a94cc5d4c485cc75070ec3a041288c0bd" args="(const ArrOfDouble &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp; ArrOfDouble::operator-= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;&#160;</td>
          <td class="paramname"><em>y</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Soustraction case a case sur toutes les cases du tableau<br/>
Parametre: const <a class="el" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a>&amp; y<br/>
Signification: tableau de meme taille que *this. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a>&amp;<br/>
 Signification: *this </dd></dl>

<p>Definition at line <a class="el" href="ArrOfDouble_8cpp_source.html#l01208">1208</a> of file <a class="el" href="ArrOfDouble_8cpp_source.html">ArrOfDouble.cpp</a>.</p>

<p>References <a class="el" href="ArrOfDouble_8h_source.html#l00178">data_</a>, and <a class="el" href="ArrOfDouble_8h_source.html#l00350">size_array()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">const</span> <span class="keywordtype">int</span> size = <a class="code" href="classArrOfDouble.html#a3c3b33bea0e88b87315c21ee94bee05f" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>();
  assert(size == y.<a class="code" href="classArrOfDouble.html#a3c3b33bea0e88b87315c21ee94bee05f" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>());
  <span class="keywordtype">double</span> * data = <a class="code" href="classArrOfDouble.html#a77419df7d43ac2ce76b9388a39ad90e9">data_</a>;
  <span class="keyword">const</span> <span class="keywordtype">double</span> * data_y = y.<a class="code" href="classArrOfDouble.html#a77419df7d43ac2ce76b9388a39ad90e9">data_</a>;
  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i &lt; size; i++)
    data[i] -= data_y[i];
  <span class="keywordflow">return</span> *<span class="keyword">this</span>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="ae19bfdc7b46e16daa1f26333ceaa4e32"></a><!-- doxytag: member="ArrOfDouble::operator&#45;=" ref="ae19bfdc7b46e16daa1f26333ceaa4e32" args="(const double)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp; ArrOfDouble::operator-= </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>dy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>soustrait la meme valeur a toutes les cases </p>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a> &amp;<br/>
 Signification: *this </dd></dl>

<p>Reimplemented in <a class="el" href="classDoubleVect.html#ac872b1bef0a267d6930eb45b479eee58">DoubleVect</a>.</p>

<p>Definition at line <a class="el" href="ArrOfDouble_8cpp_source.html#l01224">1224</a> of file <a class="el" href="ArrOfDouble_8cpp_source.html">ArrOfDouble.cpp</a>.</p>

<p>References <a class="el" href="ArrOfDouble_8h_source.html#l00178">data_</a>, and <a class="el" href="ArrOfDouble_8h_source.html#l00350">size_array()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">double</span> * data = <a class="code" href="classArrOfDouble.html#a77419df7d43ac2ce76b9388a39ad90e9">data_</a>;
  <span class="keyword">const</span> <span class="keywordtype">int</span> n = <a class="code" href="classArrOfDouble.html#a3c3b33bea0e88b87315c21ee94bee05f" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>();
  <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i &lt; n; i++)
    data[i] -= dy;
  <span class="keywordflow">return</span> *<span class="keyword">this</span>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a98ad403cfd1de7934a9ebd66751666c2"></a><!-- doxytag: member="ArrOfDouble::operator/=" ref="a98ad403cfd1de7934a9ebd66751666c2" args="(const double)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp; ArrOfDouble::operator/= </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>dy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>divise toutes les cases par dy </p>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a> &amp;<br/>
 Signification: *this </dd></dl>

<p>Reimplemented in <a class="el" href="classDoubleVect.html#a70ae7c84bf8a19861de96d9908fe0402">DoubleVect</a>.</p>

<p>Definition at line <a class="el" href="ArrOfDouble_8cpp_source.html#l01252">1252</a> of file <a class="el" href="ArrOfDouble_8cpp_source.html">ArrOfDouble.cpp</a>.</p>

<p>References <a class="el" href="ArrOfDouble_8cpp_source.html#l01238">operator*=()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">const</span> <span class="keywordtype">double</span> i_dy = 1. / dy;
  <a class="code" href="classArrOfDouble.html#a6ec3428662ddd818f935ffe1b6c57347" title="muliplie toutes les cases par dy">operator*=</a>(i_dy);
  <span class="keywordflow">return</span> *<span class="keyword">this</span>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a433dc3b67b6d6e70f7dda611e67c45ac"></a><!-- doxytag: member="ArrOfDouble::operator=" ref="a433dc3b67b6d6e70f7dda611e67c45ac" args="(const ArrOfDouble &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp; ArrOfDouble::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copie les donnees du tableau m.<br/>
Si "m" n'a pas la meme taille que "*this", on fait un resize_array.<br/>
Ensuite, on copie les valeurs de "m" dans "*this".<br/>
Le type de tableau (methode d'allocation) n'est pas copie. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a>&amp;<br/>
 Signification: *this </dd></dl>

<p>Definition at line <a class="el" href="ArrOfDouble_8cpp_source.html#l00467">467</a> of file <a class="el" href="ArrOfDouble_8cpp_source.html">ArrOfDouble.cpp</a>.</p>

<p>References <a class="el" href="ArrOfDouble_8cpp_source.html#l01110">inject_array()</a>, <a class="el" href="Array__base_8h_source.html#l00038">Array_base::NOCOPY_NOINIT</a>, <a class="el" href="ArrOfDouble_8h_source.html#l00244">resize_array()</a>, and <a class="el" href="ArrOfDouble_8h_source.html#l00350">size_array()</a>.</p>

<p>Referenced by <a class="el" href="ArrOfDouble_8cpp_source.html#l00500">copy_array()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">if</span> (&amp;m != <span class="keyword">this</span>)
    {
      <span class="keyword">const</span> <span class="keywordtype">int</span> new_size = m.<a class="code" href="classArrOfDouble.html#a3c3b33bea0e88b87315c21ee94bee05f" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>();
<span class="comment">// On utilise la methode resize_array() qui teste le type derive de l&#39;objet</span>
<span class="comment">// (resize interdit sur un type derive)</span>
      <a class="code" href="classArrOfDouble.html#a610464f4b3dccac6f814915b526783ed">resize_array</a>(new_size, <a class="code" href="classArray__base.html#abee342aa9ac59623c4c782dc9d7877ffaf6ae9ba7eb51c5f298ce693345b3ec68">NOCOPY_NOINIT</a>);
      <a class="code" href="classArrOfDouble.html#a2fcb2a2d3b59425c6cb37526ea6af6a3" title="Copie les elements source[first_element_source + i] dans les elements (*this)[first_element_dest + i]...">inject_array</a>(m);
    }
  <span class="keywordflow">return</span> *<span class="keyword">this</span>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a5fe07362b3180016e5dfd698fcb6747b"></a><!-- doxytag: member="ArrOfDouble::operator=" ref="a5fe07362b3180016e5dfd698fcb6747b" args="(const FArrOfDouble &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classArrOfDouble.html">ArrOfDouble</a>&amp; ArrOfDouble::operator= </td>
          <td>(</td>
          <td class="paramtype">const FArrOfDouble &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a67cc8a3c1012b2f210a9a71f535c6162"></a><!-- doxytag: member="ArrOfDouble::operator=" ref="a67cc8a3c1012b2f210a9a71f535c6162" args="(double valeur)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp; ArrOfDouble::operator= </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>x est affecte a toutes les cases </p>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a>&amp;<br/>
 Signification: *this<br/>
 Contraintes: </dd></dl>

<p>Reimplemented in <a class="el" href="classDoubleTab.html#a8f92a9aa9437716dbdd2d26e106e3f9a">DoubleTab</a>, <a class="el" href="classDoubleTrav.html#ac955de77bfa716ff4f212b07e7a63c20">DoubleTrav</a>, and <a class="el" href="classDoubleVect.html#adb44f4edc6d90c74d0e6be2a662e60ca">DoubleVect</a>.</p>

<p>Definition at line <a class="el" href="ArrOfDouble_8h_source.html#l00292">292</a> of file <a class="el" href="ArrOfDouble_8h_source.html">ArrOfDouble.h</a>.</p>

<p>References <a class="el" href="ArrOfDouble_8h_source.html#l00178">data_</a>, and <a class="el" href="ArrOfDouble_8h_source.html#l00182">size_array_</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">const</span> <span class="keywordtype">int</span> n = <a class="code" href="classArrOfDouble.html#ae201cdbdbf9f840376398199e5f737a0">size_array_</a>;
  <span class="keywordtype">double</span> *data = <a class="code" href="classArrOfDouble.html#a77419df7d43ac2ce76b9388a39ad90e9">data_</a>;
  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; n; i++)
    {
      data[i] = x;
    }
  <span class="keywordflow">return</span> *<span class="keyword">this</span>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a5b23a83d22d2c8b6278b0d14fb5c9ede"></a><!-- doxytag: member="ArrOfDouble::operator[]" ref="a5b23a83d22d2c8b6278b0d14fb5c9ede" args="(int i)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double &amp; ArrOfDouble::operator[] </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>operateur [] retourne le ieme element du tableau </p>

<p>Reimplemented in <a class="el" href="classDoubleTab.html#a5a6d1b0e71669331466c03b455f8ff63">DoubleTab</a>.</p>

<p>Definition at line <a class="el" href="ArrOfDouble_8h_source.html#l00311">311</a> of file <a class="el" href="ArrOfDouble_8h_source.html">ArrOfDouble.h</a>.</p>

<p>References <a class="el" href="ArrOfDouble_8h_source.html#l00178">data_</a>, <a class="el" href="Double_8h_source.html#l00072">DMAXFLOAT</a>, and <a class="el" href="ArrOfDouble_8h_source.html#l00182">size_array_</a>.</p>

<p>Referenced by <a class="el" href="ArrOfDouble_8h_source.html#l00335">operator()()</a>.</p>
<div class="fragment"><pre class="fragment">{
  assert(i &gt;= 0 &amp;&amp; i &lt; <a class="code" href="classArrOfDouble.html#ae201cdbdbf9f840376398199e5f737a0">size_array_</a>);
  assert(<a class="code" href="classArrOfDouble.html#a77419df7d43ac2ce76b9388a39ad90e9">data_</a>[i] &gt; -<a class="code" href="Double_8h.html#ae0ee0cebfad5968da0ad6cc7a49e16b6">DMAXFLOAT</a> &amp;&amp; <a class="code" href="classArrOfDouble.html#a77419df7d43ac2ce76b9388a39ad90e9">data_</a>[i] &lt; <a class="code" href="Double_8h.html#ae0ee0cebfad5968da0ad6cc7a49e16b6">DMAXFLOAT</a>);
  <span class="keywordflow">return</span> <a class="code" href="classArrOfDouble.html#a77419df7d43ac2ce76b9388a39ad90e9">data_</a>[i];
}
</pre></div>
</div>
</div>
<a class="anchor" id="a38bb0d0daa1c9287e3b880745acde015"></a><!-- doxytag: member="ArrOfDouble::operator[]" ref="a38bb0d0daa1c9287e3b880745acde015" args="(int i) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const double &amp; ArrOfDouble::operator[] </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>operateur [] retourne le ieme element du tableau </p>

<p>Reimplemented in <a class="el" href="classDoubleTab.html#ada0ddc8eddef6157ff58104557feab85">DoubleTab</a>.</p>

<p>Definition at line <a class="el" href="ArrOfDouble_8h_source.html#l00326">326</a> of file <a class="el" href="ArrOfDouble_8h_source.html">ArrOfDouble.h</a>.</p>

<p>References <a class="el" href="ArrOfDouble_8h_source.html#l00178">data_</a>, <a class="el" href="Double_8h_source.html#l00072">DMAXFLOAT</a>, and <a class="el" href="ArrOfDouble_8h_source.html#l00182">size_array_</a>.</p>
<div class="fragment"><pre class="fragment">{
  assert(i &gt;= 0 &amp;&amp; i &lt; <a class="code" href="classArrOfDouble.html#ae201cdbdbf9f840376398199e5f737a0">size_array_</a>);
  assert(<a class="code" href="classArrOfDouble.html#a77419df7d43ac2ce76b9388a39ad90e9">data_</a>[i] &gt; -<a class="code" href="Double_8h.html#ae0ee0cebfad5968da0ad6cc7a49e16b6">DMAXFLOAT</a> &amp;&amp; <a class="code" href="classArrOfDouble.html#a77419df7d43ac2ce76b9388a39ad90e9">data_</a>[i] &lt; <a class="code" href="Double_8h.html#ae0ee0cebfad5968da0ad6cc7a49e16b6">DMAXFLOAT</a>);
  <span class="keywordflow">return</span> <a class="code" href="classArrOfDouble.html#a77419df7d43ac2ce76b9388a39ad90e9">data_</a>[i];
}
</pre></div>
</div>
</div>
<a class="anchor" id="a779184ebb5056c91f6185acf7c10088c"></a><!-- doxytag: member="ArrOfDouble::ordonne_array" ref="a779184ebb5056c91f6185acf7c10088c" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ArrOfDouble::ordonne_array </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Tri des valeurs du tableau dans l'ordre croissant.<br/>
La fonction utilisee est qsort de stdlib (elle est en n*log(n)). </p>

<p>Definition at line <a class="el" href="ArrOfDouble_8cpp_source.html#l00909">909</a> of file <a class="el" href="ArrOfDouble_8cpp_source.html">ArrOfDouble.cpp</a>.</p>

<p>References <a class="el" href="ArrOfDouble_8h_source.html#l00178">data_</a>, <a class="el" href="ArrOfDouble_8cpp_source.html#l00894">fonction_compare_arrofdouble_ordonner()</a>, and <a class="el" href="ArrOfDouble_8h_source.html#l00182">size_array_</a>.</p>

<p>Referenced by <a class="el" href="ArrOfDouble_8cpp_source.html#l00923">array_trier_retirer_doublons()</a>, and <a class="el" href="Traitement__particulier__NS__canal_8cpp_source.html#l00252">Traitement_particulier_NS_canal::remplir_reordonne_Y_tot()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">const</span> <span class="keywordtype">int</span> size = <a class="code" href="classArrOfDouble.html#ae201cdbdbf9f840376398199e5f737a0">size_array_</a>;
  <span class="keywordflow">if</span> (size &gt; 1)
    {
      <span class="keywordtype">double</span> * data = <a class="code" href="classArrOfDouble.html#a77419df7d43ac2ce76b9388a39ad90e9">data_</a>;
      qsort(data, size, <span class="keyword">sizeof</span>(<span class="keywordtype">double</span>),
            <a class="code" href="ArrOfDouble_8cpp.html#ac6c1c13b23da42455b5364d7737df70a" title="Fonction de comparaison utilisee pour trier le tableau dans ArrOfDouble::trier(). Voir man qsort...">fonction_compare_arrofdouble_ordonner</a>);
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a9dc3bfa20c1ddf76911449fcb5746c6d"></a><!-- doxytag: member="ArrOfDouble::printOn" ref="a9dc3bfa20c1ddf76911449fcb5746c6d" args="(Sortie &amp;x) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSortie.html">Sortie</a> &amp; ArrOfDouble::printOn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSortie.html">Sortie</a> &amp;&#160;</td>
          <td class="paramname"><em>os</em></td><td>)</td>
          <td> const<code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Ecriture du tableau sur "os" :<br/>
ecrit le nombre d'elements suivi des valeurs du tableau. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="classSortie.html" title="Classe de base des flux de sortie. Elle sait ecrire des types simples&lt;br&gt;(entiers, flottants) et des Ob...">Sortie</a>&amp;<br/>
 Signification: le flot de sortie modifie </dd></dl>

<p>Reimplemented from <a class="el" href="classArray__base.html#af0712503fdbe484e22213d746b1b4c37">Array_base</a>.</p>

<p>Reimplemented in <a class="el" href="classDoubleTab.html#a024bd0f6105546e1f4eef2eeae3d19a9">DoubleTab</a>, <a class="el" href="classDoubleTrav.html#a08d7c2afd620265c7689b376f05bcdd7">DoubleTrav</a>, and <a class="el" href="classDoubleVect.html#a621020bfecb3e6ad09afd47c99e1e48c">DoubleVect</a>.</p>

<p>Definition at line <a class="el" href="ArrOfDouble_8cpp_source.html#l00263">263</a> of file <a class="el" href="ArrOfDouble_8cpp_source.html">ArrOfDouble.cpp</a>.</p>

<p>References <a class="el" href="ArrOfDouble_8h_source.html#l00178">data_</a>, <a class="el" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>, <a class="el" href="Sortie_8cpp_source.html#l00176">Sortie::put()</a>, <a class="el" href="ArrOfDouble_8h_source.html#l00350">size_array()</a>, and <a class="el" href="Nom_8cpp_source.html#l00040">sz</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">int</span> <a class="code" href="Nom_8cpp.html#a0e1ea19fb9fa7881d15d84eff4c090e1">sz</a>=<a class="code" href="classArrOfDouble.html#a3c3b33bea0e88b87315c21ee94bee05f" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>();
  os &lt;&lt; sz &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
  <span class="keywordflow">if</span> (sz &gt; 0)
    {
      <span class="keyword">const</span> <span class="keywordtype">double</span>* v = <a class="code" href="classArrOfDouble.html#a77419df7d43ac2ce76b9388a39ad90e9">data_</a>;
      os.<a class="code" href="classSortie.html#aa3f46aaccaff0f83c018784b50d8ea24" title="Methode de bas niveau pour ecrire un tableau d&#39;ints ou reels dans le stream. Dans l&#39;implementation de...">put</a>(v,sz,sz);
    }
  <span class="keywordflow">return</span> os;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a5e51c4df4648b6e1aaeee466f3be0044"></a><!-- doxytag: member="ArrOfDouble::readOn" ref="a5e51c4df4648b6e1aaeee466f3be0044" args="(Entree &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEntree.html">Entree</a> &amp; ArrOfDouble::readOn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEntree.html">Entree</a> &amp;&#160;</td>
          <td class="paramname"><em>is</em></td><td>)</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Lecture d'un tableau dans un flot d'entree<br/>
Lit le nombre d'elements suivi des elements eux-memes. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="classEntree.html" title="Classe de definition des operateurs et methodes pour toute lecture dans un flot d&#39;entree (fichier...">Entree</a>&amp;<br/>
 Signification: le flot d'entree modifie<br/>
 Contraintes: </dd></dl>

<p>Reimplemented from <a class="el" href="classArray__base.html#a568a333d18bc619ebfe4da6a38151248">Array_base</a>.</p>

<p>Reimplemented in <a class="el" href="classDoubleTab.html#a30d8f252c4e82b758e84d4d68a7938c3">DoubleTab</a>, <a class="el" href="classDoubleTrav.html#a953fe7bfedd76d205b091f7744de7ecc">DoubleTrav</a>, and <a class="el" href="classDoubleVect.html#a75fc33dba77cd2c19512dfbd14ed53a4">DoubleVect</a>.</p>

<p>Definition at line <a class="el" href="ArrOfDouble_8cpp_source.html#l00290">290</a> of file <a class="el" href="ArrOfDouble_8cpp_source.html">ArrOfDouble.cpp</a>.</p>

<p>References <a class="el" href="EntreeSortie_8h_source.html#l00032">Cerr</a>, <a class="el" href="ArrOfDouble_8h_source.html#l00178">data_</a>, <a class="el" href="Process_8cpp_source.html#l00223">Process::exit()</a>, <a class="el" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>, <a class="el" href="Entree_8cpp_source.html#l00302">Entree::get()</a>, <a class="el" href="ArrOfDouble_8h_source.html#l00260">resize_array_()</a>, and <a class="el" href="Nom_8cpp_source.html#l00040">sz</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">int</span> <a class="code" href="Nom_8cpp.html#a0e1ea19fb9fa7881d15d84eff4c090e1">sz</a>;
  is &gt;&gt; <a class="code" href="Nom_8cpp.html#a0e1ea19fb9fa7881d15d84eff4c090e1">sz</a>;
  <span class="keywordflow">if</span> (sz &gt;= 0)
    {
<span class="comment">// Appel a la methode sans precondition sur le type derive</span>
<span class="comment">// (car readOn est virtuelle, les autres proprietes seront initialisees correctement)</span>
      <a class="code" href="classArrOfDouble.html#af6aaac97844f02d467f6b84286e1cf1b" title="methode protegee de changement de taille, appelable par les classes derivees (idem que resize_array()...">resize_array_</a>(sz);
      <span class="keywordflow">if</span> (sz &gt; 0)
        {
          <span class="keywordtype">double</span>* v = <a class="code" href="classArrOfDouble.html#a77419df7d43ac2ce76b9388a39ad90e9">data_</a>;
          is.<a class="code" href="classEntree.html#aa434f5ceb8169e469613d1f6cd1fd99f" title="methode virtuelle pour lire un tableau d&#39;ints ou reels&lt;br&gt;(le tableau doit avoir la bonne dimension: ...">get</a>(v,sz);
        }
    }
  <span class="keywordflow">else</span>
    {
      <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Error in ArrOfDouble:readOn : size = &quot;</span> &lt;&lt; sz &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
      assert(0);
      <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">exit</a>();
    }
  <span class="keywordflow">return</span> is;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a1831984f45c77967bf13fe67b97e95a9"></a><!-- doxytag: member="ArrOfDouble::ref_array" ref="a1831984f45c77967bf13fe67b97e95a9" args="(ArrOfDouble &amp;, int start=0, int sz=&#45;1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ArrOfDouble::ref_array </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>start</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fait pointer le tableau vers les memes donnees qu'un tableau<br/>
existant. Le tableau sera du meme type que le tableau m ("detache",<br/>
"normal"). Le tableau m ne doit pas etre de type "ref_data"<br/>
Attention, le tableau source et *this sont ensuite figes (<a class="el" href="classArrOfDouble.html#a610464f4b3dccac6f814915b526783ed">resize_array()</a><br/>
interdit).<br/>
Attention: methode virtuelle: dans les classes derivee, cette methode<br/>
initialise les structures pour creer un tableau sequentiel.<br/>
Parametre: const <a class="el" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a>&amp; m<br/>
Signification: le tableau a referencer (pas de type "ref_data"<br/>
et different de *this !!!) </p>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a>&amp;<br/>
 Signification: *this<br/>
 Contraintes: </dd></dl>

<p>Reimplemented in <a class="el" href="classDoubleTab.html#a8eb99ddb58266d6f9d6e149c6f8c6a1f">DoubleTab</a>, and <a class="el" href="classDoubleVect.html#a88bf18f58757b68e59fbabbb781d217f">DoubleVect</a>.</p>

<p>Definition at line <a class="el" href="ArrOfDouble_8cpp_source.html#l00964">964</a> of file <a class="el" href="ArrOfDouble_8cpp_source.html">ArrOfDouble.cpp</a>.</p>

<p>References <a class="el" href="ArrOfDouble_8cpp_source.html#l01054">attach_array()</a>, and <a class="el" href="ArrOfDouble_8cpp_source.html#l01014">detach_array()</a>.</p>

<p>Referenced by <a class="el" href="Op__Diff__VEF__Anisotrope__Face_8cpp_source.html#l00271">Op_Diff_VEF_Anisotrope_Face::ajouter_cas_multi_scalaire()</a>, <a class="el" href="Op__Diff__VEF__Anisotrope__Face_8cpp_source.html#l00722">Op_Diff_VEF_Anisotrope_Face::ajouter_contribution_multi_scalaire()</a>, and <a class="el" href="Champ__implementation__P1_8cpp_source.html#l00165">Champ_implementation_P1::init_from_file()</a>.</p>
<div class="fragment"><pre class="fragment">{
  assert(&amp;m != <span class="keyword">this</span>);
<span class="comment">// La condition &#39;m n&#39;est pas de type &quot;ref_data&quot;&#39; est necessaire pour</span>
<span class="comment">// attach_array().</span>
  <a class="code" href="classArrOfDouble.html#a30d7509eec18c3ef46cc0140bdcdc48f" title="Amene le tableau dans l&#39;etat &quot;detache&quot;. C&#39;est a dire: Si le tableau est &quot;detache&quot; : * ne rien faire...">detach_array</a>();
  <a class="code" href="classArrOfDouble.html#af59467d8ccfc8e5cdac8e24e1c8a1e66" title="Amene le tableau dans l&#39;etat &quot;normal&quot;, &quot;detache&quot; ou &quot;ref_array&quot; en associant une sous-zone de m...">attach_array</a>(m, start, size);
}
</pre></div>
</div>
</div>
<a class="anchor" id="a324a6714dc9d9a7b5997fda646d24974"></a><!-- doxytag: member="ArrOfDouble::ref_count" ref="a324a6714dc9d9a7b5997fda646d24974" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ArrOfDouble::ref_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retourne le nombre de references des donnees du tableau<br/>
si le tableau est "normal", -1 s'il est "detache" ou "ref_data". </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>int<br/>
 Signification: ref_count_ </dd></dl>

<p>Definition at line <a class="el" href="ArrOfDouble_8cpp_source.html#l01146">1146</a> of file <a class="el" href="ArrOfDouble_8cpp_source.html">ArrOfDouble.cpp</a>.</p>

<p>References <a class="el" href="ArrOfDouble_8h_source.html#l00170">p_</a>, and <a class="el" href="ArrOfDouble_8cpp_source.html#l00188">VDoubledata::ref_count()</a>.</p>

<p>Referenced by <a class="el" href="ArrOfDouble_8cpp_source.html#l00541">memory_resize()</a>, <a class="el" href="Memoire_8cpp_source.html#l00587">operator&lt;&lt;()</a>, and <a class="el" href="ArrOfDouble_8h_source.html#l00260">resize_array_()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">if</span> (<a class="code" href="classArrOfDouble.html#a16cc4d79375188b7cb389fce2c920186">p_</a>)
    <span class="keywordflow">return</span> <a class="code" href="classArrOfDouble.html#a16cc4d79375188b7cb389fce2c920186">p_</a>-&gt;<a class="code" href="classVDoubledata.html#a9a5ad2abd6b9a242dea253941b3c9448" title="renvoie ref_count_">ref_count</a>();
  <span class="keywordflow">else</span>
    <span class="keywordflow">return</span> -1;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a8cc97dbe67c8001dad97008b10fa7690"></a><!-- doxytag: member="ArrOfDouble::ref_data" ref="a8cc97dbe67c8001dad97008b10fa7690" args="(double *ptr, int size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ArrOfDouble::ref_data </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fait pointer le tableau vers la zone de memoire "data_".<br/>
On detache la zone de memoire existante. Le tableau devient<br/>
de type "ref_data". Attention : ptr doit etre non nul.<br/>
La taille est initialisee avec size.<br/>
Attention: methode virtuelle: dans les classes derivee, cette methode<br/>
initialise les structures pour creer un tableau sequentiel.<br/>
Pour faire une ref sur un tableau parallele utiliser <a class="el" href="classDoubleVect.html#a2b45ece955d7d57746fa32b5a6a89cc2" title="detache le tableau et l&#39;attache a v (sauf si v==*this, ne fait rien) Fait pointer le tableau sur la m...">DoubleVect::ref()</a><br/>
Parametre: double*<br/>
Signification: le tableau a recuperer. Si pointeur nul alors size<br/>
doit etre nulle aussi et le tableau reste detache<br/>
Parametre: int size<br/>
Signification: le nombre d'elements du tableau. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a>&amp;<br/>
 Signification: *this </dd></dl>

<p><p>&lt; Pour passer les tests si on resize a la meme taille </p>
</p>

<p>Reimplemented in <a class="el" href="classDoubleTab.html#a76e24eeb9502bdae0b4bdfe3d54e5c04">DoubleTab</a>, and <a class="el" href="classDoubleVect.html#a4cc7c18df3f14857336aee6ff41f4f49">DoubleVect</a>.</p>

<p>Definition at line <a class="el" href="ArrOfDouble_8cpp_source.html#l00988">988</a> of file <a class="el" href="ArrOfDouble_8cpp_source.html">ArrOfDouble.cpp</a>.</p>

<p>References <a class="el" href="ArrOfDouble_8h_source.html#l00178">data_</a>, <a class="el" href="ArrOfDouble_8cpp_source.html#l01014">detach_array()</a>, <a class="el" href="ArrOfDouble_8h_source.html#l00187">memory_size_</a>, and <a class="el" href="ArrOfDouble_8h_source.html#l00182">size_array_</a>.</p>

<p>Referenced by <a class="el" href="Schema__Comm__Vecteurs_8h_source.html#l00180">Schema_Comm_Vecteurs::get_next_area_double()</a>, and <a class="el" href="Solv__GCP_8cpp_source.html#l00124">Solv_GCP::prepare_data()</a>.</p>
<div class="fragment"><pre class="fragment">{
  assert(ptr != 0 || size == 0);
  assert(size &gt;= 0);
  <a class="code" href="classArrOfDouble.html#a30d7509eec18c3ef46cc0140bdcdc48f" title="Amene le tableau dans l&#39;etat &quot;detache&quot;. C&#39;est a dire: Si le tableau est &quot;detache&quot; : * ne rien faire...">detach_array</a>();
  <a class="code" href="classArrOfDouble.html#a77419df7d43ac2ce76b9388a39ad90e9">data_</a> = ptr;
  <a class="code" href="classArrOfDouble.html#ae201cdbdbf9f840376398199e5f737a0">size_array_</a> = size;
  <a class="code" href="classArrOfDouble.html#a952e7436d209c8957ea0209f1fa66976">memory_size_</a> = size; <span class="comment">//!&lt; Pour passer les tests si on resize a la meme taille</span>
<span class="comment"></span>}
</pre></div>
</div>
</div>
<a class="anchor" id="a8c937710d2664d65500f24ce5f7e0ce0"></a><!-- doxytag: member="ArrOfDouble::reset" ref="a8c937710d2664d65500f24ce5f7e0ce0" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ArrOfDouble::reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Remet le tableau dans l'etat obtenu avec le constructeur par defaut<br/>
(libere la memoire mais conserve le mode d'allocation memoire actuel) </p>

<p>Reimplemented in <a class="el" href="classDoubleTab.html#acb465ae8c9b24990db18002693b42dea">DoubleTab</a>, and <a class="el" href="classDoubleVect.html#a990500e5bf63a8ca55fd833d111e135c">DoubleVect</a>.</p>

<p>Definition at line <a class="el" href="ArrOfDouble_8cpp_source.html#l00451">451</a> of file <a class="el" href="ArrOfDouble_8cpp_source.html">ArrOfDouble.cpp</a>.</p>

<p>References <a class="el" href="ArrOfDouble_8cpp_source.html#l01014">detach_array()</a>.</p>

<p>Referenced by <a class="el" href="Octree__Zone_8cpp_source.html#l00025">Octree_Zone::reset()</a>, and <a class="el" href="Octree__Double_8cpp_source.html#l00030">Octree_Double::reset()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <a class="code" href="classArrOfDouble.html#a30d7509eec18c3ef46cc0140bdcdc48f" title="Amene le tableau dans l&#39;etat &quot;detache&quot;. C&#39;est a dire: Si le tableau est &quot;detache&quot; : * ne rien faire...">detach_array</a>();
}
</pre></div>
</div>
</div>
<a class="anchor" id="aa5d7035f2e4f451c484aabd5dffb873b"></a><!-- doxytag: member="ArrOfDouble::resize" ref="aa5d7035f2e4f451c484aabd5dffb873b" args="(int new_size, Array_base::Resize_Options opt=COPY_INIT)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ArrOfDouble::resize </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>new_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArray__base.html#abee342aa9ac59623c4c782dc9d7877ff">Array_base::Resize_Options</a>&#160;</td>
          <td class="paramname"><em>opt</em> = <code>COPY_INIT</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>appel a <a class="el" href="classArrOfDouble.html#a610464f4b3dccac6f814915b526783ed">ArrOfDouble::resize_array()</a> </p>

<p>Reimplemented in <a class="el" href="classDoubleTab.html#ae83b4d31205c53d9c8d2b43da178ce75">DoubleTab</a>, and <a class="el" href="classDoubleVect.html#ac55a86eea7b2f06b084b88b16042b67b">DoubleVect</a>.</p>

<p>Definition at line <a class="el" href="ArrOfDouble_8h_source.html#l00252">252</a> of file <a class="el" href="ArrOfDouble_8h_source.html">ArrOfDouble.h</a>.</p>

<p>References <a class="el" href="ArrOfDouble_8h_source.html#l00244">resize_array()</a>.</p>

<p>Referenced by <a class="el" href="Extruder_8cpp_source.html#l00032">Extruder::Extruder()</a>, <a class="el" href="Extruder__en20_8cpp_source.html#l00033">Extruder_en20::Extruder_en20()</a>, <a class="el" href="Extruder__en3_8cpp_source.html#l00033">Extruder_en3::Extruder_en3()</a>, <a class="el" href="Matrice__Nulle_8cpp_source.html#l00117">Matrice_Nulle::get_stencil_and_coefficients()</a>, <a class="el" href="Matrice__Morse_8cpp_source.html#l01968">Matrice_Morse::get_stencil_and_coefficients()</a>, <a class="el" href="Matrice__Morse__Sym_8cpp_source.html#l00748">Matrice_Morse_Sym::get_symmetric_stencil_and_coefficients()</a>, <a class="el" href="Terme__Source__Canal__perio_8cpp_source.html#l00077">Terme_Source_Canal_perio::lire_donnees()</a>, <a class="el" href="Terme__Boussinesq__base_8cpp_source.html#l00108">Terme_Boussinesq_base::lire_donnees()</a>, <a class="el" href="Statistiques_8cpp_source.html#l00537">print_stat()</a>, and <a class="el" href="Terme__Source__Canal__perio_8cpp_source.html#l00396">Terme_Source_Canal_perio::source()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <a class="code" href="classArrOfDouble.html#a610464f4b3dccac6f814915b526783ed">resize_array</a>(new_size, opt);
}
</pre></div>
</div>
</div>
<a class="anchor" id="a610464f4b3dccac6f814915b526783ed"></a><!-- doxytag: member="ArrOfDouble::resize_array" ref="a610464f4b3dccac6f814915b526783ed" args="(int new_size, Array_base::Resize_Options opt=COPY_INIT)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ArrOfDouble::resize_array </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>new_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArray__base.html#abee342aa9ac59623c4c782dc9d7877ff">Array_base::Resize_Options</a>&#160;</td>
          <td class="paramname"><em>opt</em> = <code>COPY_INIT</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="ArrOfDouble_8h_source.html#l00244">244</a> of file <a class="el" href="ArrOfDouble_8h_source.html">ArrOfDouble.h</a>.</p>

<p>References <a class="el" href="ArrOfDouble_8cpp_source.html#l00037">get_info()</a>, <a class="el" href="ArrOfDouble_8cpp_source.html#l00037">info()</a>, <a class="el" href="ArrOfDouble_8h_source.html#l00260">resize_array_()</a>, and <a class="el" href="ArrOfDouble_8h_source.html#l00182">size_array_</a>.</p>

<p>Referenced by <a class="el" href="ArrOfDouble_8h_source.html#l00363">append_array()</a>, <a class="el" href="Array__tools_8cpp_source.html#l00523">append_array_to_array()</a>, <a class="el" href="Array__tools_8cpp_source.html#l00506">array_smart_allocate()</a>, <a class="el" href="ArrOfDouble_8cpp_source.html#l00923">array_trier_retirer_doublons()</a>, <a class="el" href="Octree__Zone_8cpp_source.html#l00032">Octree_Zone::build()</a>, <a class="el" href="Moyenne__volumique_8cpp_source.html#l00579">Calcul_integrale_locale::calculer()</a>, <a class="el" href="Reordonner__faces__periodiques_8cpp_source.html#l00216">Reordonner_faces_periodiques::check_faces_periodiques()</a>, <a class="el" href="Reordonner__faces__periodiques_8cpp_source.html#l00065">Reordonner_faces_periodiques::chercher_direction_perio()</a>, <a class="el" href="Terme__Source__Rappel__T__VEF__Face_8cpp_source.html#l00125">Terme_Source_Rappel_T_VEF_Face::completer()</a>, <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8cpp_source.html#l02311">Op_Conv_Muscl_New_VEF_Face::completer()</a>, <a class="el" href="Op__Conv__EF__VEF__P1NC__Stab_8cpp_source.html#l02104">Op_Conv_EF_VEF_P1NC_Stab::completer()</a>, <a class="el" href="Reaction_8cpp_source.html#l00097">Reaction::completer()</a>, <a class="el" href="Chimie_8cpp_source.html#l00090">Chimie::completer()</a>, <a class="el" href="Verifier__Qualite__Raffinements_8cpp_source.html#l00176">compute_cell_qualities_for_tetrahedron()</a>, <a class="el" href="Verifier__Qualite__Raffinements_8cpp_source.html#l00053">compute_cell_qualities_for_triangle()</a>, <a class="el" href="Octree__Double_8cpp_source.html#l00102">Octree_Double::compute_origin_factors()</a>, <a class="el" href="Assembleur__P__VDF_8cpp_source.html#l00112">Assembleur_P_VDF::construire()</a>, <a class="el" href="SolvElem__Gmres_8h_source.html#l00054">SolvElem_Gmres::dimensionne_wks()</a>, <a class="el" href="SolvElem__BiCGStab_8h_source.html#l00054">SolvElem_BiCGStab::dimensionne_wks()</a>, <a class="el" href="communications_8cpp_source.html#l00497">envoyer_all_to_all()</a>, <a class="el" href="Reaction_8cpp_source.html#l00061">extract_coef_local()</a>, <a class="el" href="ExtrudeParoi_8cpp_source.html#l00035">ExtrudeParoi::ExtrudeParoi()</a>, <a class="el" href="Solv__Cholesky_8cpp_source.html#l00236">Solv_Cholesky::Fact_Cholesky()</a>, <a class="el" href="ILU_8cpp_source.html#l00126">ILU::factoriser()</a>, <a class="el" href="Matrice__Morse_8cpp_source.html#l01968">Matrice_Morse::get_stencil_and_coefficients()</a>, <a class="el" href="Matrice__Diagonale_8cpp_source.html#l00142">Matrice_Diagonale::get_stencil_and_coefficients()</a>, <a class="el" href="Matrice__Bloc_8cpp_source.html#l00393">Matrice_Bloc::get_stencil_and_coefficients()</a>, <a class="el" href="Matrice__Morse__Sym_8cpp_source.html#l00748">Matrice_Morse_Sym::get_symmetric_stencil_and_coefficients()</a>, <a class="el" href="Matrice__Bloc__Sym_8cpp_source.html#l00430">Matrice_Bloc_Sym::get_symmetric_stencil_and_coefficients()</a>, <a class="el" href="MaillerParallel_8cpp_source.html#l00534">MaillerParallel::interpreter()</a>, <a class="el" href="Extraire__plan_8cpp_source.html#l00105">Extraire_plan::interpreter_()</a>, <a class="el" href="Calculer__Moments_8cpp_source.html#l00041">Calculer_Moments::interpreter_()</a>, <a class="el" href="Champ__Fonc__MED__Table__Temps_8cpp_source.html#l00064">Champ_Fonc_MED_Table_Temps::lire_donnees_champ()</a>, <a class="el" href="Equation__base_8cpp_source.html#l00304">Equation_base::lire_motcle_non_standard()</a>, <a class="el" href="ArrOfDouble_8cpp_source.html#l00467">operator=()</a>, <a class="el" href="Solv__GCP_8cpp_source.html#l00124">Solv_GCP::prepare_data()</a>, <a class="el" href="ArrOfDouble_8h_source.html#l00252">resize()</a>, <a class="el" href="ArrOfDouble_8cpp_source.html#l00512">resize_tab()</a>, and <a class="el" href="Matrice__Sym_8cpp_source.html#l00098">Matrice_Sym::unsymmetrize_stencil_and_coefficients()</a>.</p>
<div class="fragment"><pre class="fragment">{
<span class="comment">// Si le tableau change de taille, il doit etre du type ArrOfDouble</span>
  assert(new_size == <a class="code" href="classArrOfDouble.html#ae201cdbdbf9f840376398199e5f737a0">size_array_</a> || <a class="code" href="classArrOfDouble.html#a4f370ec412709796eb51fef1d1f068ac" title="Donne des informations sur le type de l&#39;Objet_U.">get_info</a>() == <a class="code" href="classArrOfDouble.html#af51837b06770e07fa016fda29eb0bf3a" title="Donne des informations sur le type de l&#39;Objet_U.">ArrOfDouble::info</a>());
  <a class="code" href="classArrOfDouble.html#af6aaac97844f02d467f6b84286e1cf1b" title="methode protegee de changement de taille, appelable par les classes derivees (idem que resize_array()...">resize_array_</a>(new_size, opt);
}
</pre></div>
</div>
</div>
<a class="anchor" id="af6aaac97844f02d467f6b84286e1cf1b"></a><!-- doxytag: member="ArrOfDouble::resize_array_" ref="af6aaac97844f02d467f6b84286e1cf1b" args="(int n, Array_base::Resize_Options opt=COPY_INIT)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ArrOfDouble::resize_array_ </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArray__base.html#abee342aa9ac59623c4c782dc9d7877ff">Array_base::Resize_Options</a>&#160;</td>
          <td class="paramname"><em>opt</em> = <code>COPY_INIT</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>methode protegee de changement de taille, appelable par<br/>
les classes derivees (idem que <a class="el" href="classArrOfDouble.html#a610464f4b3dccac6f814915b526783ed">resize_array()</a> mais sans condition sur le<br/>
type derive de l'objet) </p>

<p>Definition at line <a class="el" href="ArrOfDouble_8h_source.html#l00260">260</a> of file <a class="el" href="ArrOfDouble_8h_source.html">ArrOfDouble.h</a>.</p>

<p>References <a class="el" href="Array__base_8h_source.html#l00038">Array_base::COPY_INIT</a>, <a class="el" href="ArrOfDouble_8h_source.html#l00178">data_</a>, <a class="el" href="ArrOfDouble_8cpp_source.html#l00541">memory_resize()</a>, <a class="el" href="ArrOfDouble_8h_source.html#l00187">memory_size_</a>, <a class="el" href="ArrOfDouble_8h_source.html#l00170">p_</a>, <a class="el" href="ArrOfDouble_8cpp_source.html#l01146">ref_count()</a>, <a class="el" href="ArrOfDouble_8h_source.html#l00182">size_array_</a>, and <a class="el" href="ArrOfDouble_8h_source.html#l00193">smart_resize_</a>.</p>

<p>Referenced by <a class="el" href="DoubleVect_8cpp_source.html#l00191">DoubleVect::copy_()</a>, <a class="el" href="ArrOfDouble_8cpp_source.html#l00290">readOn()</a>, <a class="el" href="ArrOfDouble_8h_source.html#l00244">resize_array()</a>, and <a class="el" href="DoubleVect_8h_source.html#l00205">DoubleVect::resize_vect_()</a>.</p>
<div class="fragment"><pre class="fragment">{
  assert(new_size &gt;= 0);
<span class="comment">// Soit le tableau est detache (data_==0), soit il est normal (p_!=0)</span>
<span class="comment">// S&#39;il est normal, il ne faut pas qu&#39;il y ait d&#39;autre reference au tableau,</span>
<span class="comment">// ou alors la taille ne doit pas changer.</span>
  assert(new_size == <a class="code" href="classArrOfDouble.html#ae201cdbdbf9f840376398199e5f737a0">size_array_</a> || <a class="code" href="classArrOfDouble.html#a77419df7d43ac2ce76b9388a39ad90e9">data_</a> == 0 || (<a class="code" href="classArrOfDouble.html#a16cc4d79375188b7cb389fce2c920186">p_</a> != 0 &amp;&amp; <a class="code" href="classArrOfDouble.html#a324a6714dc9d9a7b5997fda646d24974" title="Retourne le nombre de references des donnees du tableau si le tableau est &quot;normal&quot;, -1 s&#39;il est &quot;detache&quot; ou &quot;ref_data&quot;.">ref_count</a>() == 1));
<span class="comment">// Le seul cas ou on n&#39;appelle pas memory_resize est le suivant:</span>
<span class="comment">// le tableau est smart_resize</span>
<span class="comment">// ET la taille reste inferieure ou egale a la taille allouee</span>
<span class="comment">// ET on ne veut pas initialiser les nouvelles cases</span>
  <span class="keywordflow">if</span> ((opt == <a class="code" href="classArray__base.html#abee342aa9ac59623c4c782dc9d7877ffa9a675e25b5b7accff8d861e05060547b">COPY_INIT</a>) || (new_size &gt; <a class="code" href="classArrOfDouble.html#a952e7436d209c8957ea0209f1fa66976">memory_size_</a>) || (<a class="code" href="classArrOfDouble.html#a527b3aabfef167644bb124f8255245b3">smart_resize_</a> == 0))
<span class="comment">// attention, il existe un cas ou memory_resize realloue un buffer meme si size_array_==new_size:</span>
<span class="comment">// si on est passe de smart_resize=1 a smart_resize=0, on realloue juste ce qu&#39;il faut.</span>
    <a class="code" href="classArrOfDouble.html#a98d8a5b5486b130787f95664ee8127e6" title="Si besoin, alloue une nouvelle zone de memoire, copie les donnees et efface l&#39;ancienne zone de memoir...">memory_resize</a>(new_size, opt);
  <a class="code" href="classArrOfDouble.html#ae201cdbdbf9f840376398199e5f737a0">size_array_</a> = new_size;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a03c0eaca0e960a1f59cc077deb9fd4b2"></a><!-- doxytag: member="ArrOfDouble::resize_tab" ref="a03c0eaca0e960a1f59cc077deb9fd4b2" args="(int n, Array_base::Resize_Options opt=COPY_INIT)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ArrOfDouble::resize_tab </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArray__base.html#abee342aa9ac59623c4c782dc9d7877ff">Array_base::Resize_Options</a>&#160;</td>
          <td class="paramname"><em>opt</em> = <code>COPY_INIT</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>methode virtuelle identique a <a class="el" href="classArrOfDouble.html#a610464f4b3dccac6f814915b526783ed">resize_array()</a>, permet de traiter<br/>
de facon generique les ArrOf, Vect et Tab.<br/>
Si l'objet est de type <a class="el" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a>, appel a resize_array(n)<br/>
Prerequis: le tableau doit etre "resizable" (voir <a class="el" href="classArrOfDouble.html#a610464f4b3dccac6f814915b526783ed">resize_array()</a>).<br/>
S'il est d'un type derive (Vect ou Tab), il ne doit pas avoir de descripteur<br/>
parallele si la taille est effectivement modifiee. </p>

<p>Reimplemented in <a class="el" href="classDoubleTab.html#ae19eb47302f3d2fd69f9cd72090dec7c">DoubleTab</a>, and <a class="el" href="classDoubleVect.html#a4cc7c1dd4811f2461056e3ad14601adc">DoubleVect</a>.</p>

<p>Definition at line <a class="el" href="ArrOfDouble_8cpp_source.html#l00512">512</a> of file <a class="el" href="ArrOfDouble_8cpp_source.html">ArrOfDouble.cpp</a>.</p>

<p>References <a class="el" href="ArrOfDouble_8h_source.html#l00244">resize_array()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <a class="code" href="classArrOfDouble.html#a610464f4b3dccac6f814915b526783ed">resize_array</a>(n, opt);
}
</pre></div>
</div>
</div>
<a class="anchor" id="ac7de1e66e976de768ed0eacb8e4196c6"></a><!-- doxytag: member="ArrOfDouble::self_cast" ref="ac7de1e66e976de768ed0eacb8e4196c6" args="(Objet_U &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp; ArrOfDouble::self_cast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classObjet__U.html">Objet_U</a> &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="classArray__base.html#a2caf0d582315a1559c4eef365c47c7a1">Array_base</a>.</p>

<p>Reimplemented in <a class="el" href="classDoubleTab.html#ac14302afeb3238195e4867338bfc6fdd">DoubleTab</a>, <a class="el" href="classDoubleTrav.html#a49e0940bfafe542cd4ad2ce3b2118271">DoubleTrav</a>, and <a class="el" href="classDoubleVect.html#a5ea419fe1e5059dbced6dfbcc6f6e248">DoubleVect</a>.</p>

<p>Definition at line <a class="el" href="ArrOfDouble_8cpp_source.html#l00037">37</a> of file <a class="el" href="ArrOfDouble_8cpp_source.html">ArrOfDouble.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{
</pre></div>
</div>
</div>
<a class="anchor" id="a1edbfb14b1f0576e04bbfd1d7001117b"></a><!-- doxytag: member="ArrOfDouble::self_cast" ref="a1edbfb14b1f0576e04bbfd1d7001117b" args="(const Objet_U &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp; ArrOfDouble::self_cast </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classObjet__U.html">Objet_U</a> &amp;&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>methode ajoutee pour caster en python </p>

<p>Reimplemented from <a class="el" href="classArray__base.html#a64527ccffc076b9bf4777de657a636e5">Array_base</a>.</p>

<p>Reimplemented in <a class="el" href="classDoubleTab.html#a00a23f850f9da003068b1737b69da50d">DoubleTab</a>, <a class="el" href="classDoubleTrav.html#af9df46dd94a4ca6c5c56e1845f92d843">DoubleTrav</a>, and <a class="el" href="classDoubleVect.html#acffdbfcf3848d8ddbe95cb5b12ac7b94">DoubleVect</a>.</p>

<p>Definition at line <a class="el" href="ArrOfDouble_8cpp_source.html#l00037">37</a> of file <a class="el" href="ArrOfDouble_8cpp_source.html">ArrOfDouble.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{
</pre></div>
</div>
</div>
<a class="anchor" id="a716c70fbed9c253e2deb5732c9f0601b"></a><!-- doxytag: member="ArrOfDouble::set_mem_storage" ref="a716c70fbed9c253e2deb5732c9f0601b" args="(const Storage storage)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ArrOfDouble::set_mem_storage </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classArrOfDouble.html#aa6c9b9bbc6bc40ecd74d10411dc560de">Storage</a>&#160;</td>
          <td class="paramname"><em>storage</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Change le mode d'allocation memoire lors des resize&lt;br&gt;(voir VDoubledata et Double_ptr_trav)<br/>
Exemple pour creer un tableau avec allocation temporaire:<br/>
<a class="el" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a> tab; // Creation d'un tableau vide<br/>
tab.set_mem_storage(TEMP_STORAGE); // Changement de mode d'allocation<br/>
tab.resize(n); // Allocation memoire. </p>

<p>Definition at line <a class="el" href="ArrOfDouble_8cpp_source.html#l00423">423</a> of file <a class="el" href="ArrOfDouble_8cpp_source.html">ArrOfDouble.cpp</a>.</p>

<p>References <a class="el" href="ArrOfDouble_8h_source.html#l00197">storage_type_</a>.</p>

<p>Referenced by <a class="el" href="DoubleTrav_8cpp_source.html#l00051">DoubleTrav::DoubleTrav()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <a class="code" href="classArrOfDouble.html#a9724d501cbca852e174ef0a7351698b1">storage_type_</a> = storage;
}
</pre></div>
</div>
</div>
<a class="anchor" id="ab49f6cae96be9d3f597468d8a53b67b6"></a><!-- doxytag: member="ArrOfDouble::set_smart_resize" ref="ab49f6cae96be9d3f597468d8a53b67b6" args="(int flag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ArrOfDouble::set_smart_resize </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Change le mode l'allocation memoire: reallocation d'un tableau<br/>
a chaque changement de taille (flag = 0) ou reallocation<br/>
uniquement si la taille augmente et par doublement de la taille<br/>
du tableau (flag = 1). </p>

<p>Definition at line <a class="el" href="ArrOfDouble_8cpp_source.html#l00442">442</a> of file <a class="el" href="ArrOfDouble_8cpp_source.html">ArrOfDouble.cpp</a>.</p>

<p>References <a class="el" href="ArrOfDouble_8h_source.html#l00193">smart_resize_</a>.</p>

<p>Referenced by <a class="el" href="Array__tools_8cpp_source.html#l00506">array_smart_allocate()</a>, <a class="el" href="Assembleur__P__PolyMAC_8cpp_source.html#l00091">Assembleur_P_PolyMAC::assembler_mat()</a>, <a class="el" href="Ch__front__input_8cpp_source.html#l00104">Ch_front_input::buildSommetsFaces()</a>, <a class="el" href="Moyenne__volumique_8cpp_source.html#l00548">Calcul_integrale_locale::Calcul_integrale_locale()</a>, <a class="el" href="Zone__CoviMAC_8cpp_source.html#l00837">Zone_CoviMAC::fgrad()</a>, <a class="el" href="Echange__contact__CoviMAC_8cpp_source.html#l00174">Echange_contact_CoviMAC::fgrad()</a>, <a class="el" href="Matrice__Morse_8cpp_source.html#l01968">Matrice_Morse::get_stencil_and_coefficients()</a>, <a class="el" href="Matrice__Morse__Sym_8cpp_source.html#l00748">Matrice_Morse_Sym::get_symmetric_stencil_and_coefficients()</a>, <a class="el" href="Zone__PolyMAC_8cpp_source.html#l01249">Zone_PolyMAC::init_m1_2d()</a>, <a class="el" href="Zone__PolyMAC_8cpp_source.html#l01272">Zone_PolyMAC::init_m1_3d()</a>, <a class="el" href="Zone__PolyMAC_8cpp_source.html#l01059">Zone_PolyMAC::init_m2()</a>, <a class="el" href="Champ__Face__PolyMAC_8cpp_source.html#l00186">Champ_Face_PolyMAC::init_ra()</a>, <a class="el" href="Zone__PolyMAC_8cpp_source.html#l01156">Zone_PolyMAC::init_rf()</a>, <a class="el" href="Champ__Face__PolyMAC_8cpp_source.html#l00236">Champ_Face_PolyMAC::init_va()</a>, <a class="el" href="Zone__PolyMAC_8cpp_source.html#l01134">Zone_PolyMAC::init_ve()</a>, <a class="el" href="Zone__CoviMAC_8cpp_source.html#l00688">Zone_CoviMAC::init_ve()</a>, <a class="el" href="Champ__Face__CoviMAC_8cpp_source.html#l00169">Champ_Face_CoviMAC::init_ve2()</a>, <a class="el" href="Zone__PolyMAC_8cpp_source.html#l01201">Zone_PolyMAC::init_we_2d()</a>, <a class="el" href="Zone__PolyMAC_8cpp_source.html#l01221">Zone_PolyMAC::init_we_3d()</a>, <a class="el" href="Champ__front__recyclage_8cpp_source.html#l00472">Champ_front_recyclage::initialiser()</a>, and <a class="el" href="Zone__PolyMAC_8cpp_source.html#l00573">Zone_PolyMAC::orthocentrer()</a>.</p>
<div class="fragment"><pre class="fragment">{
  assert(flag == 0 || flag == 1);
  <a class="code" href="classArrOfDouble.html#a527b3aabfef167644bb124f8255245b3">smart_resize_</a> = flag;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a3c3b33bea0e88b87315c21ee94bee05f"></a><!-- doxytag: member="ArrOfDouble::size_array" ref="a3c3b33bea0e88b87315c21ee94bee05f" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ArrOfDouble::size_array </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Renvoie la taille du tableau (nombre d'elements declares<br/>
a la construction ou a <a class="el" href="classArrOfDouble.html#a610464f4b3dccac6f814915b526783ed">resize_array()</a>).<br/>
C'est le nombre d'elements accessibles a operator[]. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>int </dd></dl>

<p>Definition at line <a class="el" href="ArrOfDouble_8h_source.html#l00350">350</a> of file <a class="el" href="ArrOfDouble_8h_source.html">ArrOfDouble.h</a>.</p>

<p>References <a class="el" href="ArrOfDouble_8h_source.html#l00182">size_array_</a>.</p>

<p>Referenced by <a class="el" href="CSR__Builder_8h_source.html#l00054">CSR_Builder::add_coeff()</a>, <a class="el" href="Matrix__tools_8cpp_source.html#l00356">Matrix_tools::add_scaled_matrices()</a>, <a class="el" href="Matrix__tools_8cpp_source.html#l00410">Matrix_tools::add_symmetric_scaled_matrices()</a>, <a class="el" href="MD__Vector__std_8cpp_source.html#l00652">add_to_vect_blocs()</a>, <a class="el" href="MD__Vector__std_8cpp_source.html#l00413">add_to_vect_items()</a>, <a class="el" href="Convert__ICoCoTrioField_8cpp_source.html#l00033">affecte_double_avec_doubletab()</a>, <a class="el" href="Terme__Source__Canal__perio__VEF__P1NC_8cpp_source.html#l00083">Terme_Source_Canal_perio_VEF_P1NC::ajouter()</a>, <a class="el" href="T__It__VDF__Elem_8h_source.html#l00130">T_It_VDF_Elem&lt; _TYPE_ &gt;::ajouter()</a>, <a class="el" href="Matrice__SuperMorse_8cpp_source.html#l00032">Matrice_SuperMorse::ajouter_mult_vect_et_prodscal()</a>, <a class="el" href="Matrice__Morse_8cpp_source.html#l00936">Matrice_Morse::ajouter_multvect_()</a>, <a class="el" href="Matrice__Dense_8cpp_source.html#l00219">Matrice_Dense::ajouter_multvect_()</a>, <a class="el" href="Matrice__Bloc__Sym_8cpp_source.html#l00080">Matrice_Bloc_Sym::ajouter_multvect_()</a>, <a class="el" href="Matrice__Bloc_8cpp_source.html#l00115">Matrice_Bloc::ajouter_multvect_()</a>, <a class="el" href="Matrice__Morse_8cpp_source.html#l01077">Matrice_Morse::ajouter_multvectT_()</a>, <a class="el" href="Matrice__Dense_8cpp_source.html#l00302">Matrice_Dense::ajouter_multvectT_()</a>, <a class="el" href="Matrice__Bloc_8cpp_source.html#l00148">Matrice_Bloc::ajouter_multvectT_()</a>, <a class="el" href="Array__tools_8cpp_source.html#l00523">append_array_to_array()</a>, <a class="el" href="DoubleTab_8h_source.html#l00271">DoubleTab::append_line()</a>, <a class="el" href="ArrOfDouble_8cpp_source.html#l00390">ArrOfDouble()</a>, <a class="el" href="Assembleur__P__VEFPreP1B_8cpp_source.html#l00192">Assembleur_P_VEFPreP1B::assembler_rho_variable()</a>, <a class="el" href="Assembleur__P__EF_8cpp_source.html#l00117">Assembleur_P_EF::assembler_rho_variable()</a>, <a class="el" href="ArrOfDouble_8cpp_source.html#l01054">attach_array()</a>, <a class="el" href="BilanQdmVEF_8cpp_source.html#l00114">BilanQdmVEF::bilan_energie()</a>, <a class="el" href="BilanQdmVEF_8cpp_source.html#l00031">BilanQdmVEF::bilan_qdm()</a>, <a class="el" href="Matrix__tools_8cpp_source.html#l00152">Matrix_tools::build_morse_matrix()</a>, <a class="el" href="Matrix__tools_8cpp_source.html#l00228">Matrix_tools::build_symmetric_morse_matrix()</a>, <a class="el" href="Reaction_8cpp_source.html#l00305">Reaction::calcul_proportion_implicite()</a>, <a class="el" href="Zone__EF_8cpp_source.html#l00578">Zone_EF::calculer_Bij()</a>, <a class="el" href="Op__Dift__VEF__Face_8cpp_source.html#l00069">Op_Dift_VEF_Face::calculer_dt_stab()</a>, <a class="el" href="Op__Diff__VEF__base_8cpp_source.html#l00107">Op_Diff_VEF_base::calculer_dt_stab()</a>, <a class="el" href="Op__Dift__VDF__Multi__inco__Elem__Axi_8cpp_source.html#l00109">Op_Dift_VDF_Multi_inco_Elem_Axi::calculer_dt_stab()</a>, <a class="el" href="Partitionneur__base_8cpp_source.html#l00147">Partitionneur_base::calculer_graphe_connexions_periodiques()</a>, <a class="el" href="Op__Dift__VEF__Face_8cpp_source.html#l00176">Op_Dift_VEF_Face::calculer_pour_post()</a>, <a class="el" href="Op__Diff__VEF__base_8cpp_source.html#l00201">Op_Diff_VEF_base::calculer_pour_post()</a>, <a class="el" href="Op__Conv__EF__VEF__P1NC__Stab_8cpp_source.html#l00941">Op_Conv_EF_VEF_P1NC_Stab::calculer_senseur()</a>, <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8cpp_source.html#l02043">Op_Conv_Muscl_New_VEF_Face::calculer_senseur_v1()</a>, <a class="el" href="Eval__Puiss__Th__QC__VDF__Elem_8h_source.html#l00059">Eval_Puiss_Th_QC_VDF_Elem::calculer_terme_source()</a>, <a class="el" href="Reordonner__faces__periodiques_8cpp_source.html#l00034">calculer_vecteur_2faces()</a>, <a class="el" href="Zone__EF_8cpp_source.html#l00132">Zone_EF::calculer_volumes_sommets()</a>, <a class="el" href="Scatter_8cpp_source.html#l00297">Scatter::check_consistancy_remote_items()</a>, <a class="el" href="Zone_8cpp_source.html#l00360">Zone::chercher_elements()</a>, <a class="el" href="Periodique_8cpp_source.html#l00072">Periodique::completer()</a>, <a class="el" href="Schema__Adams__Bashforth__order__3_8cpp_source.html#l00165">Schema_Adams_Bashforth_order_3::compute_adams_bashforth_coefficients()</a>, <a class="el" href="Schema__Adams__Bashforth__order__2_8cpp_source.html#l00110">Schema_Adams_Bashforth_order_2::compute_adams_bashforth_coefficients()</a>, <a class="el" href="Schema__Adams__Moulton__order__3_8cpp_source.html#l00100">Schema_Adams_Moulton_order_3::compute_adams_moulton_coefficients()</a>, <a class="el" href="Schema__Adams__Moulton__order__2_8cpp_source.html#l00077">Schema_Adams_Moulton_order_2::compute_adams_moulton_coefficients()</a>, <a class="el" href="Schema__Backward__Differentiation__order__3_8cpp_source.html#l00109">Schema_Backward_Differentiation_order_3::compute_backward_differentiation_coefficients()</a>, <a class="el" href="Schema__Backward__Differentiation__order__2_8cpp_source.html#l00109">Schema_Backward_Differentiation_order_2::compute_backward_differentiation_coefficients()</a>, <a class="el" href="Triangle_8cpp_source.html#l00129">Triangle::contient()</a>, <a class="el" href="Tetraedre_8cpp_source.html#l00129">Tetraedre::contient()</a>, <a class="el" href="Segment_8cpp_source.html#l00160">Segment::contient()</a>, <a class="el" href="Rectangle__axi_8cpp_source.html#l00233">Rectangle_axi::contient()</a>, <a class="el" href="Rectangle_8cpp_source.html#l00223">Rectangle::contient()</a>, <a class="el" href="Quadrangle__VEF_8cpp_source.html#l00144">Quadrangle_VEF::contient()</a>, <a class="el" href="Prisme_8cpp_source.html#l00156">Prisme::contient()</a>, <a class="el" href="Point_8cpp_source.html#l00137">Point::contient()</a>, <a class="el" href="Hexaedre__VEF_8cpp_source.html#l00321">Hexaedre_VEF::contient()</a>, <a class="el" href="Hexaedre__axi_8cpp_source.html#l00199">Hexaedre_axi::contient()</a>, <a class="el" href="Hexaedre_8cpp_source.html#l00243">Hexaedre::contient()</a>, <a class="el" href="DoubleVect_8cpp_source.html#l00166">DoubleVect::copy()</a>, <a class="el" href="DoubleVect_8cpp_source.html#l00191">DoubleVect::copy_()</a>, <a class="el" href="Champ__Inc__base_8cpp_source.html#l00166">Champ_Inc_base::creer_tableau_distribue()</a>, <a class="el" href="Champ__Fonc__base_8cpp_source.html#l00102">Champ_Fonc_base::creer_tableau_distribue()</a>, <a class="el" href="SSOR_8cpp_source.html#l00461">descente_bloc_extradiag_assert()</a>, <a class="el" href="Matrice__Morse_8cpp_source.html#l00864">Matrice_Morse::diagmulmat()</a>, <a class="el" href="Zone__CoviMAC_8cpp_source.html#l00591">disp_da()</a>, <a class="el" href="ArrOfDouble_8cpp_source.html#l01277">dotproduct_array()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00518">dotproduct_array_fois_inverse_quantitee_entrelacee()</a>, <a class="el" href="DoubleTrav_8cpp_source.html#l00112">DoubleTrav::DoubleTrav()</a>, <a class="el" href="MD__Vector__tools_8cpp_source.html#l00653">MD_Vector_tools::dump_vector_with_md()</a>, <a class="el" href="Debog_8cpp_source.html#l00643">Debog_Pb::ecrire_partie()</a>, <a class="el" href="communications_8cpp_source.html#l00497">envoyer_all_to_all()</a>, <a class="el" href="Moyenne__volumique_8cpp_source.html#l00126">Moyenne_volumique::eval_filtre()</a>, <a class="el" href="Zone__VEF__PreP1b_8cpp_source.html#l00287">exemple_champ_non_homogene()</a>, <a class="el" href="Equation__base_8cpp_source.html#l02466">Equation_base::expression_residu()</a>, <a class="el" href="Reaction_8cpp_source.html#l00090">Reaction::extract_coef()</a>, <a class="el" href="Octree__Zone_8cpp_source.html#l00055">Octree_Zone::find_elements()</a>, <a class="el" href="Turbulence__paroi__base_8cpp_source.html#l00131">Turbulence_paroi_base::get_champ()</a>, <a class="el" href="Matrice__Morse_8cpp_source.html#l01968">Matrice_Morse::get_stencil_and_coefficients()</a>, <a class="el" href="Matrice__Bloc_8cpp_source.html#l00393">Matrice_Bloc::get_stencil_and_coefficients()</a>, <a class="el" href="Matrice__Morse__Sym_8cpp_source.html#l00748">Matrice_Morse_Sym::get_symmetric_stencil_and_coefficients()</a>, <a class="el" href="Matrice__Bloc__Sym_8cpp_source.html#l00430">Matrice_Bloc_Sym::get_symmetric_stencil_and_coefficients()</a>, <a class="el" href="Solv__Gmres_8cpp_source.html#l00208">gmres_local()</a>, <a class="el" href="ArrOfDouble_8cpp_source.html#l00763">imax_array()</a>, <a class="el" href="ArrOfDouble_8cpp_source.html#l00735">imin_array()</a>, <a class="el" href="Navier__Stokes__std_8cpp_source.html#l01974">Navier_Stokes_std::impr()</a>, <a class="el" href="Equation__base_8cpp_source.html#l02446">Equation_base::imprime_residu()</a>, <a class="el" href="Ch__front__input__P1_8cpp_source.html#l00047">Ch_front_input_P1::initialiser()</a>, <a class="el" href="Ch__front__input__uniforme_8cpp_source.html#l00061">Ch_front_input_uniforme::initialiser()</a>, <a class="el" href="ArrOfDouble_8cpp_source.html#l01110">inject_array()</a>, <a class="el" href="ExtrudeParoi_8cpp_source.html#l00127">ExtrudeParoi::interpreter_()</a>, <a class="el" href="Extraire__plan_8cpp_source.html#l00105">Extraire_plan::interpreter_()</a>, <a class="el" href="Corriger__frontiere__periodique_8cpp_source.html#l00060">Corriger_frontiere_periodique::interpreter_()</a>, <a class="el" href="DoubleVect_8cpp_source.html#l00379">invalidate_data()</a>, <a class="el" href="Loi__horaire_8cpp_source.html#l00142">inverse()</a>, <a class="el" href="DoubleTab_8cpp_source.html#l00720">DoubleTab::inverse_LU()</a>, <a class="el" href="DoubleVect_8h_source.html#l00164">DoubleVect::line_size()</a>, <a class="el" href="Champ__Fonc__MED_8cpp_source.html#l00313">Champ_Fonc_MED::lire()</a>, <a class="el" href="EcritureLectureSpecial_8cpp_source.html#l00328">lire_special()</a>, <a class="el" href="DoubleVect_8cpp_source.html#l00298">DoubleVect::lit()</a>, <a class="el" href="DoubleTab_8cpp_source.html#l00555">DoubleTab::lit()</a>, <a class="el" href="DoubleTab_8cpp_source.html#l00607">local_carre_norme_tab()</a>, <a class="el" href="DoubleTab_8cpp_source.html#l00636">local_max_abs_tab()</a>, <a class="el" href="ArrOfDouble_8cpp_source.html#l00848">max_abs_array()</a>, <a class="el" href="ArrOfDouble_8cpp_source.html#l00814">max_array()</a>, <a class="el" href="DoubleTab_8cpp_source.html#l00909">DoubleTab::max_du_u()</a>, <a class="el" href="MD__Vector__std_8cpp_source.html#l00457">max_to_vect_items()</a>, <a class="el" href="Op__Dift__VEF__base_8cpp_source.html#l00050">Op_Dift_VEF_base::mettre_a_jour()</a>, <a class="el" href="Eval__Dift__VDF__var__Face_8h_source.html#l00054">Eval_Dift_VDF_var_Face::mettre_a_jour()</a>, <a class="el" href="Terme__Boussinesq__base_8h_source.html#l00092">Terme_Boussinesq_base::mettre_a_jour()</a>, <a class="el" href="Champ__Fonc__MED__Tabule_8cpp_source.html#l00042">Champ_Fonc_MED_Tabule::mettre_a_jour()</a>, <a class="el" href="Champ__front__xyz__debit_8cpp_source.html#l00206">Champ_front_xyz_debit::mettre_a_jour()</a>, <a class="el" href="ArrOfDouble_8cpp_source.html#l00877">min_abs_array()</a>, <a class="el" href="ArrOfDouble_8cpp_source.html#l00792">min_array()</a>, <a class="el" href="MD__Vector__std_8cpp_source.html#l00503">mincol1_to_vect_items()</a>, <a class="el" href="Zone__Cl__EF_8cpp_source.html#l00465">Zone_Cl_EF::modifie_gradient()</a>, <a class="el" href="communications_8cpp_source.html#l00644">mp_collective_op()</a>, <a class="el" href="DoubleTab_8cpp_source.html#l00600">mp_norme_tab()</a>, <a class="el" href="Loi__horaire_8cpp_source.html#l00130">multiplie()</a>, <a class="el" href="ArrOfDouble_8cpp_source.html#l01294">norme_array()</a>, <a class="el" href="ArrOfDouble_8cpp_source.html#l01238">operator*=()</a>, <a class="el" href="ArrOfDouble_8cpp_source.html#l01169">operator+=()</a>, <a class="el" href="ArrOfDouble_8cpp_source.html#l01208">operator-=()</a>, <a class="el" href="Memoire_8cpp_source.html#l00587">operator&lt;&lt;()</a>, <a class="el" href="DoubleTab_8cpp_source.html#l00430">DoubleTab::operator=()</a>, <a class="el" href="ArrOfDouble_8cpp_source.html#l00467">operator=()</a>, <a class="el" href="ArrOfDouble_8cpp_source.html#l00702">operator==()</a>, <a class="el" href="Solv__GCP_8cpp_source.html#l00124">Solv_GCP::prepare_data()</a>, <a class="el" href="DoubleTab_8cpp_source.html#l00048">DoubleTab::printOn()</a>, <a class="el" href="ArrOfDouble_8cpp_source.html#l00263">printOn()</a>, <a class="el" href="Eval__centre__VDF__Elem_8h_source.html#l01454">Eval_centre_VDF_Elem::qcentre()</a>, <a class="el" href="Eval__centre4__VDF__Elem_8h_source.html#l01318">Eval_centre4_VDF_Elem::qcentre()</a>, <a class="el" href="Eval__centre__PolyMAC__Elem_8h_source.html#l01307">Eval_centre_PolyMAC_Elem::qcentre()</a>, <a class="el" href="Eval__Quick__VDF__Elem_8h_source.html#l00714">Eval_Quick_VDF_Elem::quick_fram()</a>, <a class="el" href="Objet__a__lire_8cpp_source.html#l00207">Objet_a_lire::read()</a>, <a class="el" href="MD__Vector__std_8cpp_source.html#l00558">read_from_vect_blocs()</a>, <a class="el" href="MD__Vector__std_8cpp_source.html#l00325">read_from_vect_items()</a>, <a class="el" href="Pb__MED_8cpp_source.html#l00055">Pbc_MED::readOn()</a>, <a class="el" href="Champ__Fonc__MED_8cpp_source.html#l00077">Champ_Fonc_MED::readOn()</a>, <a class="el" href="DoubleVect_8cpp_source.html#l00058">DoubleVect::readOn()</a>, <a class="el" href="DoubleTab_8cpp_source.html#l00072">DoubleTab::readOn()</a>, <a class="el" href="Champ__input__P0_8cpp_source.html#l00037">Champ_input_P0::readOn()</a>, <a class="el" href="Ch__input__uniforme_8cpp_source.html#l00031">Ch_input_uniforme::readOn()</a>, <a class="el" href="DoubleTab_8cpp_source.html#l00211">DoubleTab::ref()</a>, <a class="el" href="DoubleVect_8cpp_source.html#l00235">DoubleVect::ref_array()</a>, <a class="el" href="DoubleTab_8cpp_source.html#l00274">DoubleTab::ref_array()</a>, <a class="el" href="DoubleTab_8cpp_source.html#l00261">DoubleTab::ref_data()</a>, <a class="el" href="DoubleTab_8cpp_source.html#l00288">DoubleTab::ref_tab()</a>, <a class="el" href="SSOR_8cpp_source.html#l00552">remontee_bloc_extradiag_assert()</a>, <a class="el" href="Assembleur__P__VEF_8cpp_source.html#l00134">Assembleur_P_VEF::remplir()</a>, <a class="el" href="Matrice__Bloc_8cpp_source.html#l00676">Matrice_Bloc::remplir()</a>, <a class="el" href="Zone__Cl__VEF_8cpp_source.html#l00151">Zone_Cl_VEF::remplir_volumes_entrelaces_Cl()</a>, <a class="el" href="DoubleVect_8h_source.html#l00193">DoubleVect::resize()</a>, <a class="el" href="DoubleTab_8cpp_source.html#l00326">DoubleTab::resize_dim0()</a>, <a class="el" href="Solv__Petsc_8cpp_source.html#l01553">Solv_Petsc::resoudre_systeme()</a>, <a class="el" href="Zone_8cpp_source.html#l00351">sameDoubleTab()</a>, <a class="el" href="Champ__Inc__base_8cpp_source.html#l00635">Champ_Inc_base::sauvegarder()</a>, <a class="el" href="Champ__Fonc__base_8cpp_source.html#l00140">Champ_Fonc_base::sauvegarder()</a>, <a class="el" href="Octree__Double_8cpp_source.html#l00271">Octree_Double::search_elements_box()</a>, <a class="el" href="Octree__Double_8cpp_source.html#l00322">Octree_Double::search_nodes_close_to()</a>, <a class="el" href="Zone__VF_8h_source.html#l00351">Zone_VF::section_passage_face()</a>, <a class="el" href="DoubleVect_8cpp_source.html#l00248">DoubleVect::set_md_vector()</a>, <a class="el" href="DoubleVect_8h_source.html#l00135">DoubleVect::size_reelle()</a>, <a class="el" href="DoubleVect_8h_source.html#l00159">DoubleVect::size_totale()</a>, <a class="el" href="Solv__Gen_8cpp_source.html#l00220">Solv_Gen::solve()</a>, <a class="el" href="DoubleVect_8cpp_source.html#l02127">tab_divide_any_shape()</a>, <a class="el" href="DoubleVect_8cpp_source.html#l02107">tab_multiply_any_shape()</a>, <a class="el" href="Solv__Optimal_8cpp_source.html#l00097">test_solveur()</a>, <a class="el" href="Solv__Optimal_8cpp_source.html#l00050">test_un_solveur()</a>, <a class="el" href="Raccord__distant__homogene_8cpp_source.html#l00121">Raccord_distant_homogene::trace_elem_distant()</a>, <a class="el" href="Frontiere_8cpp_source.html#l00333">Frontiere::trace_elem_local()</a>, <a class="el" href="Raccord__distant__homogene_8cpp_source.html#l00167">Raccord_distant_homogene::trace_face_distant()</a>, <a class="el" href="Frontiere_8cpp_source.html#l00358">Frontiere::trace_som_local()</a>, <a class="el" href="Trier_8cpp_source.html#l00072">trier()</a>, <a class="el" href="Trier_8cpp_source.html#l00060">trier_abs()</a>, <a class="el" href="Matrice__Sym_8cpp_source.html#l00098">Matrice_Sym::unsymmetrize_stencil_and_coefficients()</a>, <a class="el" href="Schema__Temps__base_8cpp_source.html#l01068">Schema_Temps_base::update_critere_statio()</a>, <a class="el" href="Loi__horaire_8cpp_source.html#l00257">Loi_horaire::verifier_derivee()</a>, <a class="el" href="Debog_8cpp_source.html#l00879">Debog_Pb::verifier_gen()</a>, <a class="el" href="Verifier__Qualite__Raffinements_8cpp_source.html#l00233">Verifier_Qualite_Raffinements::verifier_qualite_raffinements()</a>, <a class="el" href="MD__Vector__std_8cpp_source.html#l00605">write_to_vect_blocs()</a>, and <a class="el" href="MD__Vector__std_8cpp_source.html#l00369">write_to_vect_items()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">return</span> <a class="code" href="classArrOfDouble.html#ae201cdbdbf9f840376398199e5f737a0">size_array_</a>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a305e3b5889f1044ab22d8f44edfe65bc"></a><!-- doxytag: member="ArrOfDouble::taille_memoire" ref="a305e3b5889f1044ab22d8f44edfe65bc" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned ArrOfDouble::taille_memoire </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implements <a class="el" href="classObjet__U.html#a0ee0946339f09a2c73c09fcda71c3be2">Objet_U</a>.</p>

<p>Reimplemented in <a class="el" href="classDoubleTab.html#a299deb03cdcc2d1a7d6e38275b77d717">DoubleTab</a>, <a class="el" href="classDoubleTrav.html#a0e71eaf6d7e1ae220fc3abab02cdf816">DoubleTrav</a>, and <a class="el" href="classDoubleVect.html#ab4cf51590ad58957a2a57aa30eede599">DoubleVect</a>.</p>

<p>Definition at line <a class="el" href="ArrOfDouble_8cpp_source.html#l00037">37</a> of file <a class="el" href="ArrOfDouble_8cpp_source.html">ArrOfDouble.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{
</pre></div>
</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="a77419df7d43ac2ce76b9388a39ad90e9"></a><!-- doxytag: member="ArrOfDouble::data_" ref="a77419df7d43ac2ce76b9388a39ad90e9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double* <a class="el" href="classArrOfDouble.html#a77419df7d43ac2ce76b9388a39ad90e9">ArrOfDouble::data_</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="ArrOfDouble_8h_source.html#l00178">178</a> of file <a class="el" href="ArrOfDouble_8h_source.html">ArrOfDouble.h</a>.</p>

<p>Referenced by <a class="el" href="ArrOfDouble_8h_source.html#l00379">addr()</a>, <a class="el" href="ArrOfDouble_8h_source.html#l00363">append_array()</a>, <a class="el" href="ArrOfDouble_8cpp_source.html#l00923">array_trier_retirer_doublons()</a>, <a class="el" href="ArrOfDouble_8cpp_source.html#l00342">ArrOfDouble()</a>, <a class="el" href="ArrOfDouble_8cpp_source.html#l01054">attach_array()</a>, <a class="el" href="ArrOfDouble_8cpp_source.html#l01014">detach_array()</a>, <a class="el" href="ArrOfDouble_8cpp_source.html#l00650">fill_default_value()</a>, <a class="el" href="ArrOfDouble_8cpp_source.html#l01110">inject_array()</a>, <a class="el" href="ArrOfDouble_8cpp_source.html#l00541">memory_resize()</a>, <a class="el" href="ArrOfDouble_8cpp_source.html#l01238">operator*=()</a>, <a class="el" href="ArrOfDouble_8cpp_source.html#l01169">operator+=()</a>, <a class="el" href="ArrOfDouble_8cpp_source.html#l01208">operator-=()</a>, <a class="el" href="ArrOfDouble_8h_source.html#l00292">operator=()</a>, <a class="el" href="ArrOfDouble_8h_source.html#l00311">operator[]()</a>, <a class="el" href="ArrOfDouble_8cpp_source.html#l00909">ordonne_array()</a>, <a class="el" href="ArrOfDouble_8cpp_source.html#l00263">printOn()</a>, <a class="el" href="ArrOfDouble_8cpp_source.html#l00290">readOn()</a>, <a class="el" href="ArrOfDouble_8cpp_source.html#l00988">ref_data()</a>, and <a class="el" href="ArrOfDouble_8h_source.html#l00260">resize_array_()</a>.</p>

</div>
</div>
<a class="anchor" id="a249fb161408eabb4b7efa45129ab7b6c"></a><!-- doxytag: member="ArrOfDouble::info_obj" ref="a249fb161408eabb4b7efa45129ab7b6c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classType__info.html">Type_info</a> <a class="el" href="classArrOfDouble.html#a249fb161408eabb4b7efa45129ab7b6c">ArrOfDouble::info_obj</a><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="classArray__base.html#af95fada2845d7f9bae474221a2e12d9a">Array_base</a>.</p>

<p>Reimplemented in <a class="el" href="classDoubleTab.html#ac668dde8bf53c41143de90d25d981882">DoubleTab</a>, <a class="el" href="classDoubleTrav.html#a04fe61c613719d1a2b1571668ef996f2">DoubleTrav</a>, and <a class="el" href="classDoubleVect.html#aed92c085246860a0221c2329db5f7319">DoubleVect</a>.</p>

<p>Definition at line <a class="el" href="ArrOfDouble_8h_source.html#l00074">74</a> of file <a class="el" href="ArrOfDouble_8h_source.html">ArrOfDouble.h</a>.</p>

</div>
</div>
<a class="anchor" id="a952e7436d209c8957ea0209f1fa66976"></a><!-- doxytag: member="ArrOfDouble::memory_size_" ref="a952e7436d209c8957ea0209f1fa66976" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classArrOfDouble.html#a952e7436d209c8957ea0209f1fa66976">ArrOfDouble::memory_size_</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="ArrOfDouble_8h_source.html#l00187">187</a> of file <a class="el" href="ArrOfDouble_8h_source.html">ArrOfDouble.h</a>.</p>

<p>Referenced by <a class="el" href="ArrOfDouble_8cpp_source.html#l00390">ArrOfDouble()</a>, <a class="el" href="ArrOfDouble_8cpp_source.html#l01054">attach_array()</a>, <a class="el" href="ArrOfDouble_8cpp_source.html#l01014">detach_array()</a>, <a class="el" href="ArrOfDouble_8cpp_source.html#l00650">fill_default_value()</a>, <a class="el" href="ArrOfDouble_8cpp_source.html#l00541">memory_resize()</a>, <a class="el" href="ArrOfDouble_8cpp_source.html#l00988">ref_data()</a>, and <a class="el" href="ArrOfDouble_8h_source.html#l00260">resize_array_()</a>.</p>

</div>
</div>
<a class="anchor" id="a16cc4d79375188b7cb389fce2c920186"></a><!-- doxytag: member="ArrOfDouble::p_" ref="a16cc4d79375188b7cb389fce2c920186" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVDoubledata.html">VDoubledata</a>* <a class="el" href="classArrOfDouble.html#a16cc4d79375188b7cb389fce2c920186">ArrOfDouble::p_</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="ArrOfDouble_8h_source.html#l00170">170</a> of file <a class="el" href="ArrOfDouble_8h_source.html">ArrOfDouble.h</a>.</p>

<p>Referenced by <a class="el" href="ArrOfDouble_8cpp_source.html#l00342">ArrOfDouble()</a>, <a class="el" href="ArrOfDouble_8cpp_source.html#l01054">attach_array()</a>, <a class="el" href="ArrOfDouble_8cpp_source.html#l01014">detach_array()</a>, <a class="el" href="ArrOfDouble_8cpp_source.html#l00541">memory_resize()</a>, <a class="el" href="ArrOfDouble_8cpp_source.html#l01146">ref_count()</a>, and <a class="el" href="ArrOfDouble_8h_source.html#l00260">resize_array_()</a>.</p>

</div>
</div>
<a class="anchor" id="ae201cdbdbf9f840376398199e5f737a0"></a><!-- doxytag: member="ArrOfDouble::size_array_" ref="ae201cdbdbf9f840376398199e5f737a0" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classArrOfDouble.html#ae201cdbdbf9f840376398199e5f737a0">ArrOfDouble::size_array_</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="ArrOfDouble_8h_source.html#l00182">182</a> of file <a class="el" href="ArrOfDouble_8h_source.html">ArrOfDouble.h</a>.</p>

<p>Referenced by <a class="el" href="ArrOfDouble_8h_source.html#l00363">append_array()</a>, <a class="el" href="ArrOfDouble_8cpp_source.html#l00923">array_trier_retirer_doublons()</a>, <a class="el" href="ArrOfDouble_8cpp_source.html#l00390">ArrOfDouble()</a>, <a class="el" href="ArrOfDouble_8cpp_source.html#l01054">attach_array()</a>, <a class="el" href="ArrOfDouble_8cpp_source.html#l01014">detach_array()</a>, <a class="el" href="ArrOfDouble_8cpp_source.html#l00541">memory_resize()</a>, <a class="el" href="ArrOfDouble_8h_source.html#l00292">operator=()</a>, <a class="el" href="ArrOfDouble_8h_source.html#l00311">operator[]()</a>, <a class="el" href="ArrOfDouble_8cpp_source.html#l00909">ordonne_array()</a>, <a class="el" href="ArrOfDouble_8cpp_source.html#l00988">ref_data()</a>, <a class="el" href="ArrOfDouble_8h_source.html#l00244">resize_array()</a>, <a class="el" href="ArrOfDouble_8h_source.html#l00260">resize_array_()</a>, <a class="el" href="ArrOfDouble_8h_source.html#l00350">size_array()</a>, and <a class="el" href="ArrOfDouble_8cpp_source.html#l00316">~ArrOfDouble()</a>.</p>

</div>
</div>
<a class="anchor" id="a527b3aabfef167644bb124f8255245b3"></a><!-- doxytag: member="ArrOfDouble::smart_resize_" ref="a527b3aabfef167644bb124f8255245b3" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classArrOfDouble.html#a527b3aabfef167644bb124f8255245b3">ArrOfDouble::smart_resize_</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="ArrOfDouble_8h_source.html#l00193">193</a> of file <a class="el" href="ArrOfDouble_8h_source.html">ArrOfDouble.h</a>.</p>

<p>Referenced by <a class="el" href="ArrOfDouble_8h_source.html#l00363">append_array()</a>, <a class="el" href="ArrOfDouble_8cpp_source.html#l00390">ArrOfDouble()</a>, <a class="el" href="ArrOfDouble_8cpp_source.html#l01054">attach_array()</a>, <a class="el" href="ArrOfDouble_8cpp_source.html#l00541">memory_resize()</a>, <a class="el" href="ArrOfDouble_8h_source.html#l00260">resize_array_()</a>, and <a class="el" href="ArrOfDouble_8cpp_source.html#l00442">set_smart_resize()</a>.</p>

</div>
</div>
<a class="anchor" id="a9724d501cbca852e174ef0a7351698b1"></a><!-- doxytag: member="ArrOfDouble::storage_type_" ref="a9724d501cbca852e174ef0a7351698b1" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classArrOfDouble.html#aa6c9b9bbc6bc40ecd74d10411dc560de">Storage</a> <a class="el" href="classArrOfDouble.html#a9724d501cbca852e174ef0a7351698b1">ArrOfDouble::storage_type_</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="ArrOfDouble_8h_source.html#l00197">197</a> of file <a class="el" href="ArrOfDouble_8h_source.html">ArrOfDouble.h</a>.</p>

<p>Referenced by <a class="el" href="ArrOfDouble_8cpp_source.html#l00390">ArrOfDouble()</a>, <a class="el" href="ArrOfDouble_8cpp_source.html#l00432">get_mem_storage()</a>, <a class="el" href="ArrOfDouble_8cpp_source.html#l00541">memory_resize()</a>, and <a class="el" href="ArrOfDouble_8cpp_source.html#l00423">set_mem_storage()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/Kernel/Math/<a class="el" href="ArrOfDouble_8h_source.html">ArrOfDouble.h</a></li>
<li>src/Kernel/Math/<a class="el" href="ArrOfDouble_8cpp_source.html">ArrOfDouble.cpp</a></li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Tue Dec 14 2021 19:36:06 for TRUST by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
