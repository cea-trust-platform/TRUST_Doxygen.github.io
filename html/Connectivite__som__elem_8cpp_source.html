<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>TRUST: src/Kernel/Geometrie/Connectivite_som_elem.cpp Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">TRUST&#160;<span id="projectnumber">1.8.4</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
<div class="header">
  <div class="headertitle">
<div class="title">src/Kernel/Geometrie/Connectivite_som_elem.cpp</div>  </div>
</div>
<div class="contents">
<a href="Connectivite__som__elem_8cpp.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/****************************************************************************</span>
<a name="l00002"></a>00002 <span class="comment">* Copyright (c) 2015 - 2016, CEA</span>
<a name="l00003"></a>00003 <span class="comment">* All rights reserved.</span>
<a name="l00004"></a>00004 <span class="comment">*</span>
<a name="l00005"></a>00005 <span class="comment">* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</span>
<a name="l00006"></a>00006 <span class="comment">* 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.</span>
<a name="l00007"></a>00007 <span class="comment">* 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.</span>
<a name="l00008"></a>00008 <span class="comment">* 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.</span>
<a name="l00009"></a>00009 <span class="comment">*</span>
<a name="l00010"></a>00010 <span class="comment">* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.</span>
<a name="l00011"></a>00011 <span class="comment">* IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;</span>
<a name="l00012"></a>00012 <span class="comment">* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>
<a name="l00013"></a>00013 <span class="comment">*</span>
<a name="l00014"></a>00014 <span class="comment">*****************************************************************************/</span>
<a name="l00015"></a>00015 <span class="comment">//</span>
<a name="l00016"></a>00016 <span class="comment">// </span>
<a name="l00017"></a>00017 <span class="comment">// File:        Connectivite_som_elem.cpp</span>
<a name="l00018"></a>00018 <span class="comment">// Directory:   $TRUST_ROOT/src/Kernel/Geometrie</span>
<a name="l00019"></a>00019 <span class="comment">// Version:     /main/8</span>
<a name="l00020"></a>00020 <span class="comment">// </span>
<a name="l00021"></a>00021 <span class="comment">//</span>
<a name="l00022"></a>00022 <span class="preprocessor">#include &lt;<a class="code" href="Connectivite__som__elem_8h.html">Connectivite_som_elem.h</a>&gt;</span>
<a name="l00023"></a>00023 <span class="preprocessor">#include &lt;<a class="code" href="Static__Int__Lists_8h.html">Static_Int_Lists.h</a>&gt;</span>
<a name="l00024"></a>00024 <span class="preprocessor">#include &lt;<a class="code" href="IntTab_8h.html">IntTab.h</a>&gt;</span>
<a name="l00025"></a>00025 
<a name="l00026"></a>00026 <span class="comment">//</span>
<a name="l00027"></a>00027 <span class="comment">//</span>
<a name="l00028"></a>00028 <span class="comment">//</span>
<a name="l00029"></a>00029 <span class="comment">//</span>
<a name="l00030"></a>00030 <span class="comment">//</span>
<a name="l00031"></a>00031 <span class="comment">//</span>
<a name="l00032"></a>00032 <span class="comment">//</span>
<a name="l00033"></a>00033 <span class="comment">//</span>
<a name="l00034"></a>00034 <span class="comment">//</span>
<a name="l00035"></a>00035 <span class="comment">//</span>
<a name="l00036"></a>00036 <span class="comment">//</span>
<a name="l00037"></a>00037 <span class="comment">//</span>
<a name="l00038"></a>00038 <span class="comment">//</span>
<a name="l00039"></a>00039 <span class="comment">//</span>
<a name="l00040"></a>00040 <span class="comment">//</span><span class="comment"></span>
<a name="l00041"></a>00041 <span class="comment">//! construction de la structure som_elem pour la zone donnee&lt;br&gt;On cree pour chaque sommet i la liste des elements adjacents a ce sommet&lt;br&gt;(c&#39;est la liste des elements k tels que il existe j tel que les_elems(k,j) == i)&lt;br&gt;Parametre:   nb_sommets&lt;br&gt;nombre de sommets utilises dans les elements (som_elem contiendra&lt;br&gt;autant de listes). Si include_virtual==1, c&#39;est le nombre de sommets&lt;br&gt;total, sinon c&#39;est le nombre de sommets reels&lt;br&gt;Parametre:   les_elems&lt;br&gt;tableau des elements (contient les numeros des sommets de chaque element)&lt;br&gt;Les valeurs du tableau doivent etre inferieurs a nb_sommets.&lt;br&gt;Parametre:   som_elem&lt;br&gt;la structure dans laquelle on stocke le resultat. L&#39;ancien&lt;br&gt;contenu est perdu. Chaque liste d&#39;elements est triee dans l&#39;ordre croissant&lt;br&gt;Parametre:   include_virtual&lt;br&gt;0 =&gt; seuls les elements reels sont inclus dans la structure&lt;br&gt;1 =&gt; on inclut les elements virtuels (donc les sommets virtuels)</span>
<a name="l00042"></a><a class="code" href="Connectivite__som__elem_8h.html#a82161461a228e43ae236c31101ff3ce6">00042</a> <span class="comment"></span><span class="keywordtype">void</span> <a class="code" href="Connectivite__som__elem_8cpp.html#a82161461a228e43ae236c31101ff3ce6" title="construction de la structure som_elem pour la zone donnee On cree pour chaque sommet i la liste des e...">construire_connectivite_som_elem</a>(<span class="keyword">const</span> <span class="keywordtype">int</span>       nb_sommets,
<a name="l00043"></a>00043                                       <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp;      les_elems,
<a name="l00044"></a>00044                                       <a class="code" href="classStatic__Int__Lists.html" title="Cette classe permet de stocker des listes d&#39;entiers accessibles en temps constant. La taille des listes ne peut pas changer sans perdre le contenu (ce sont des listes statiques). Exemple: Static_Int_List l; ArrOfInt tailles(3); tailles[0] = 2; tailles[1] = 3; tailles[2] = 0; // On reserve la memoire pour trois listes de taille 2, 3 et 0: l.set_list_sizes(tailles); // On affecte une valeur au deuxieme element de la premiere liste: l.set_value(0,1,765); // Affiche la valeur Cout &lt;&lt; l(0,1);.">Static_Int_Lists</a>&amp; som_elem,
<a name="l00045"></a>00045                                       <span class="keyword">const</span> <span class="keywordtype">int</span>       include_virtual)
<a name="l00046"></a>00046 {
<a name="l00047"></a>00047 <span class="comment">// Nombre d&#39;elements du domaine</span>
<a name="l00048"></a>00048   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_elem = (include_virtual) ? les_elems.<a class="code" href="classIntTab.html#a71e9b9ddc1793094b1b3f109377952b1" title="Returns the total dimensions of the multi-dimensionnal array, including virtual items (used in parall...">dimension_tot</a>(0) : les_elems.<a class="code" href="classIntTab.html#abc3b32c94925a82f69d5b153a356e359" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(0);
<a name="l00049"></a>00049 <span class="comment">// Nombre de sommets par element</span>
<a name="l00050"></a>00050   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_sommets_par_element = les_elems.<a class="code" href="classIntTab.html#abc3b32c94925a82f69d5b153a356e359" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(1);
<a name="l00051"></a>00051 
<a name="l00052"></a>00052 <span class="comment">// Construction d&#39;un tableau initialise a zero : pour chaque sommet,</span>
<a name="l00053"></a>00053 <span class="comment">// nombre d&#39;elements voisins de ce sommet</span>
<a name="l00054"></a>00054   <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> nb_elements_voisins(nb_sommets);
<a name="l00055"></a>00055 
<a name="l00056"></a>00056 <span class="comment">// Premier passage : on calcule le nombre d&#39;elements voisins de chaque</span>
<a name="l00057"></a>00057 <span class="comment">// sommet pour creer la structure de donnees</span>
<a name="l00058"></a>00058   <span class="keywordtype">int</span> elem, i;
<a name="l00059"></a>00059 
<a name="l00060"></a>00060   <span class="keywordflow">for</span> (elem = 0; elem &lt; nb_elem; elem++)
<a name="l00061"></a>00061     {
<a name="l00062"></a>00062       <span class="keywordflow">for</span> (i = 0; i &lt; nb_sommets_par_element; i++)
<a name="l00063"></a>00063         {
<a name="l00064"></a>00064           <span class="keywordtype">int</span> sommet = les_elems(elem, i);
<a name="l00065"></a>00065 <span class="comment">// GF cas des polyedres</span>
<a name="l00066"></a>00066           <span class="keywordflow">if</span> (sommet==-1) <span class="keywordflow">break</span>;
<a name="l00067"></a>00067           nb_elements_voisins[sommet]++;
<a name="l00068"></a>00068         }
<a name="l00069"></a>00069     }
<a name="l00070"></a>00070 
<a name="l00071"></a>00071   som_elem.<a class="code" href="classStatic__Int__Lists.html#a60da63cb1970f5b87d1e1fdf6d65dcb2" title="detruit les listes existantes et en cree de nouvelles. On cree autant de listes que d&#39;elements dans l...">set_list_sizes</a>(nb_elements_voisins);
<a name="l00072"></a>00072 
<a name="l00073"></a>00073 <span class="comment">// On reutilise le tableau pour stocker le nombre d&#39;elements dans</span>
<a name="l00074"></a>00074 <span class="comment">// chaque liste pendant qu&#39;on la remplit</span>
<a name="l00075"></a>00075   nb_elements_voisins = 0;
<a name="l00076"></a>00076 
<a name="l00077"></a>00077 <span class="comment">// Remplissage du tableau des elements voisins.</span>
<a name="l00078"></a>00078   <span class="keywordflow">for</span> (elem = 0; elem &lt; nb_elem; elem++)
<a name="l00079"></a>00079     {
<a name="l00080"></a>00080       <span class="keywordflow">for</span> (i = 0; i &lt; nb_sommets_par_element; i++)
<a name="l00081"></a>00081         {
<a name="l00082"></a>00082           <span class="keywordtype">int</span> sommet = les_elems(elem, i);
<a name="l00083"></a>00083 <span class="comment">// GF cas des polyedres</span>
<a name="l00084"></a>00084           <span class="keywordflow">if</span> (sommet==-1) <span class="keywordflow">break</span>;
<a name="l00085"></a>00085           <span class="keywordtype">int</span> n = (nb_elements_voisins[sommet])++;
<a name="l00086"></a>00086           som_elem.<a class="code" href="classStatic__Int__Lists.html#ab56f42945e3057185cc1086e1cbc1bbb" title="affecte la &quot;valeur&quot; au j-ieme element de la i-ieme liste avec 0 &lt;= i &lt; get_nb_lists() et 0 &lt;= j &lt; get...">set_value</a>(sommet, n, elem);
<a name="l00087"></a>00087         }
<a name="l00088"></a>00088     }
<a name="l00089"></a>00089 
<a name="l00090"></a>00090 <span class="comment">// Tri de toutes les listes dans l&#39;ordre croissant</span>
<a name="l00091"></a>00091   som_elem.<a class="code" href="classStatic__Int__Lists.html#ac6174c2ad8e64329eb7a90538cdf8c9c" title="tri par ordre croissant des valeurs de la i-ieme liste. Si num_liste &lt; 0, on trie toutes les listes...">trier_liste</a>(-1);
<a name="l00092"></a>00092 }
<a name="l00093"></a>00093 
<a name="l00094"></a>00094 <span class="comment">//</span>
<a name="l00095"></a>00095 <span class="comment">//</span>
<a name="l00096"></a>00096 <span class="comment">//</span>
<a name="l00097"></a>00097 <span class="comment">//</span>
<a name="l00098"></a>00098 <span class="comment">//</span>
<a name="l00099"></a>00099 <span class="comment">//</span>
<a name="l00100"></a>00100 <span class="comment">//</span>
<a name="l00101"></a>00101 <span class="comment">//</span>
<a name="l00102"></a>00102 <span class="comment">//</span>
<a name="l00103"></a>00103 <span class="comment">//</span>
<a name="l00104"></a>00104 <span class="comment">//</span>
<a name="l00105"></a>00105 <span class="comment">//</span>
<a name="l00106"></a>00106 <span class="comment">//</span><span class="comment"></span>
<a name="l00107"></a>00107 <span class="comment">//! Cherche les elements qui contiennent tous les sommets&lt;br&gt;du tableau sommets_to_find (permet de trouver les elements&lt;br&gt;adjacents a une face ou une arete)&lt;br&gt;Parametre:     som_elem&lt;br&gt;Signification: pour chaque sommet, liste triee des elements adjacents&lt;br&gt;(voir construire_connectivite_som_elem)&lt;br&gt;Parametre:     sommets_to_find&lt;br&gt;Signification: une liste de sommets&lt;br&gt;Parametre:     elements&lt;br&gt;Signification: resultat de la recherche: la liste des elements qui&lt;br&gt;contiennent tous les sommets de sommets_to_find.&lt;br&gt;Si sommets_to_find est vide, on renvoie un tableau vide.&lt;br&gt;(en cas d&#39;appels repetes a cette fonction, il est&lt;br&gt;conseille de mettre le drapeau &quot;smart_resize&quot;)</span>
<a name="l00108"></a><a class="code" href="Connectivite__som__elem_8h.html#afccbadf5344a16154a56b33dbddf88c1">00108</a> <span class="comment"></span><span class="keywordtype">void</span> <a class="code" href="Connectivite__som__elem_8cpp.html#afccbadf5344a16154a56b33dbddf88c1" title="Cherche les elements qui contiennent tous les sommets du tableau sommets_to_find (permet de trouver l...">find_adjacent_elements</a>(<span class="keyword">const</span> <a class="code" href="classStatic__Int__Lists.html" title="Cette classe permet de stocker des listes d&#39;entiers accessibles en temps constant. La taille des listes ne peut pas changer sans perdre le contenu (ce sont des listes statiques). Exemple: Static_Int_List l; ArrOfInt tailles(3); tailles[0] = 2; tailles[1] = 3; tailles[2] = 0; // On reserve la memoire pour trois listes de taille 2, 3 et 0: l.set_list_sizes(tailles); // On affecte une valeur au deuxieme element de la premiere liste: l.set_value(0,1,765); // Affiche la valeur Cout &lt;&lt; l(0,1);.">Static_Int_Lists</a>&amp; som_elem,
<a name="l00109"></a>00109                             <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; sommets_to_find,
<a name="l00110"></a>00110                             <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; elements)
<a name="l00111"></a>00111 {
<a name="l00112"></a>00112   <span class="keywordtype">int</span> nb_som_to_find = sommets_to_find.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>();
<a name="l00113"></a>00113 <span class="comment">// on retire les sommets valant -1 (cas ou plusieurs types de faces)</span>
<a name="l00114"></a>00114   <span class="keywordflow">while</span> (sommets_to_find(nb_som_to_find-1)==-1) nb_som_to_find--;
<a name="l00115"></a>00115   <span class="keywordflow">if</span> (nb_som_to_find == 0)
<a name="l00116"></a>00116     {
<a name="l00117"></a>00117       elements.<a class="code" href="classArrOfInt.html#a9b3afbb46b16870dbd36236c8935b535">resize_array</a>(0);
<a name="l00118"></a>00118       <span class="keywordflow">return</span>;
<a name="l00119"></a>00119     }
<a name="l00120"></a>00120 <span class="comment">// Algorithme: on initialise elements avec tous les elements adjacents</span>
<a name="l00121"></a>00121 <span class="comment">// au premier sommet de la liste.</span>
<a name="l00122"></a>00122 <span class="comment">// Puis pour chacun des autres sommets de la liste, on retire du tableau</span>
<a name="l00123"></a>00123 <span class="comment">// &quot;elements&quot; les elements qui ne sont pas voisins du sommet.</span>
<a name="l00124"></a>00124 <span class="comment">// A la fin, il ne reste que les elements qui sont dans toutes les listes.</span>
<a name="l00125"></a>00125   {
<a name="l00126"></a>00126 <span class="comment">// Initialisation avec les elements adjacents au premier sommet</span>
<a name="l00127"></a>00127     <span class="keyword">const</span> <span class="keywordtype">int</span> sommet = sommets_to_find[0];
<a name="l00128"></a>00128     som_elem.<a class="code" href="classStatic__Int__Lists.html#ac5f80aca1def83653c95221f391b916d" title="copie la i-ieme liste dans le tableau fourni Le tableau array doit etre resizable.">copy_list_to_array</a>(sommet, elements);
<a name="l00129"></a>00129   }
<a name="l00130"></a>00130   <span class="keywordtype">int</span> nb_elem_found = elements.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>();
<a name="l00131"></a>00131   <span class="keywordtype">int</span> i_sommet;
<a name="l00132"></a>00132   <span class="keywordflow">for</span> (i_sommet = 1; i_sommet &lt; nb_som_to_find; i_sommet++)
<a name="l00133"></a>00133     {
<a name="l00134"></a>00134       <span class="keyword">const</span> <span class="keywordtype">int</span> sommet = sommets_to_find[i_sommet];
<a name="l00135"></a>00135 <span class="comment">// Calcul des elements communs entre elements[.] et som_elem(sommet,.)</span>
<a name="l00136"></a>00136 <span class="comment">// Nombre d&#39;elements communs entre elements et la nouvelle liste de sommets</span>
<a name="l00137"></a>00137       <span class="keywordtype">int</span> nb_elems_restants = 0;
<a name="l00138"></a>00138 <span class="comment">// Nombre d&#39;elements adjacents au &quot;sommet&quot;</span>
<a name="l00139"></a>00139       <span class="keyword">const</span> <span class="keywordtype">int</span> nb_elem_liste = som_elem.<a class="code" href="classStatic__Int__Lists.html#adbf6903737c3c30bf87e05b29f5a5b56" title="renvoie le nombre d&#39;elements de la liste i">get_list_size</a>(sommet);
<a name="l00140"></a>00140 <span class="comment">// On suppose que les listes d&#39;elements sont triees dans l&#39;ordre croissant</span>
<a name="l00141"></a>00141 <span class="comment">// On parcourt simultanement les deux listes et on conserve les elements</span>
<a name="l00142"></a>00142 <span class="comment">// communs.</span>
<a name="l00143"></a>00143       <span class="keywordtype">int</span> i = 0;
<a name="l00144"></a>00144       <span class="keywordtype">int</span> j = 0;
<a name="l00145"></a>00145       <span class="keywordflow">if</span> (nb_elem_found == 0)
<a name="l00146"></a>00146         <span class="keywordflow">break</span>;
<a name="l00147"></a>00147       <span class="keywordflow">if</span> (nb_elem_liste &gt; 0)
<a name="l00148"></a>00148         {
<a name="l00149"></a>00149           <span class="keywordflow">while</span> (1)
<a name="l00150"></a>00150             {
<a name="l00151"></a>00151               <span class="keyword">const</span> <span class="keywordtype">int</span> elem_i = elements[i];
<a name="l00152"></a>00152               <span class="keyword">const</span> <span class="keywordtype">int</span> elem_j = som_elem(sommet, j);
<a name="l00153"></a>00153               <span class="keywordflow">if</span> (elem_i == elem_j)
<a name="l00154"></a>00154                 {
<a name="l00155"></a>00155 <span class="comment">// Element commun aux deux listes, on le garde</span>
<a name="l00156"></a>00156                   elements[nb_elems_restants] = elem_i;
<a name="l00157"></a>00157                   nb_elems_restants++;
<a name="l00158"></a>00158                 }
<a name="l00159"></a>00159               <span class="keywordflow">if</span> (elem_i &gt;= elem_j)
<a name="l00160"></a>00160                 {
<a name="l00161"></a>00161                   j++;
<a name="l00162"></a>00162                   <span class="keywordflow">if</span> (j &gt;= nb_elem_liste)
<a name="l00163"></a>00163                     <span class="keywordflow">break</span>;
<a name="l00164"></a>00164                 }
<a name="l00165"></a>00165               <span class="keywordflow">if</span> (elem_j &gt;= elem_i)
<a name="l00166"></a>00166                 {
<a name="l00167"></a>00167                   i++;
<a name="l00168"></a>00168                   <span class="keywordflow">if</span> (i &gt;= nb_elem_found)
<a name="l00169"></a>00169                     <span class="keywordflow">break</span>;
<a name="l00170"></a>00170                 }
<a name="l00171"></a>00171             }
<a name="l00172"></a>00172         }
<a name="l00173"></a>00173       <span class="keywordflow">else</span>
<a name="l00174"></a>00174         {
<a name="l00175"></a>00175           nb_elems_restants = 0;
<a name="l00176"></a>00176         }
<a name="l00177"></a>00177       nb_elem_found = nb_elems_restants;
<a name="l00178"></a>00178     }
<a name="l00179"></a>00179   elements.<a class="code" href="classArrOfInt.html#a9b3afbb46b16870dbd36236c8935b535">resize_array</a>(nb_elem_found);
<a name="l00180"></a>00180 }
<a name="l00181"></a>00181 
<a name="l00182"></a>00182 
</pre></div></div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Tue Dec 14 2021 19:35:17 for TRUST by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
