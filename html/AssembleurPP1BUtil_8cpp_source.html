<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>TRUST: src/P1NCP1B/Solveurs/AssembleurPP1BUtil.cpp Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">TRUST&#160;<span id="projectnumber">1.8.4</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
<div class="header">
  <div class="headertitle">
<div class="title">src/P1NCP1B/Solveurs/AssembleurPP1BUtil.cpp</div>  </div>
</div>
<div class="contents">
<a href="AssembleurPP1BUtil_8cpp.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/****************************************************************************</span>
<a name="l00002"></a>00002 <span class="comment">* Copyright (c) 2015 - 2016, CEA</span>
<a name="l00003"></a>00003 <span class="comment">* All rights reserved.</span>
<a name="l00004"></a>00004 <span class="comment">*</span>
<a name="l00005"></a>00005 <span class="comment">* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</span>
<a name="l00006"></a>00006 <span class="comment">* 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.</span>
<a name="l00007"></a>00007 <span class="comment">* 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.</span>
<a name="l00008"></a>00008 <span class="comment">* 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.</span>
<a name="l00009"></a>00009 <span class="comment">*</span>
<a name="l00010"></a>00010 <span class="comment">* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.</span>
<a name="l00011"></a>00011 <span class="comment">* IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;</span>
<a name="l00012"></a>00012 <span class="comment">* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>
<a name="l00013"></a>00013 <span class="comment">*</span>
<a name="l00014"></a>00014 <span class="comment">*****************************************************************************/</span>
<a name="l00015"></a>00015 <span class="comment">//</span>
<a name="l00016"></a>00016 <span class="comment">// </span>
<a name="l00017"></a>00017 <span class="comment">// File:        AssembleurPP1BUtil.cpp</span>
<a name="l00018"></a>00018 <span class="comment">// Directory:   $TRUST_ROOT/src/P1NCP1B/Solveurs</span>
<a name="l00019"></a>00019 <span class="comment">// Version:     /main/22</span>
<a name="l00020"></a>00020 <span class="comment">// </span>
<a name="l00021"></a>00021 <span class="comment">//</span>
<a name="l00022"></a>00022 
<a name="l00023"></a>00023 <span class="preprocessor">#include &lt;<a class="code" href="Assembleur__P__VEFPreP1B_8h.html">Assembleur_P_VEFPreP1B.h</a>&gt;</span>
<a name="l00024"></a>00024 <span class="preprocessor">#include &lt;<a class="code" href="Matrice__Bloc__Sym_8h.html">Matrice_Bloc_Sym.h</a>&gt;</span>
<a name="l00025"></a>00025 <span class="preprocessor">#include &lt;<a class="code" href="Domaine_8h.html">Domaine.h</a>&gt;</span>
<a name="l00026"></a>00026 <span class="preprocessor">#include &lt;<a class="code" href="Dirichlet_8h.html">Dirichlet.h</a>&gt;</span>
<a name="l00027"></a>00027 <span class="preprocessor">#include &lt;<a class="code" href="Dirichlet__homogene_8h.html">Dirichlet_homogene.h</a>&gt;</span>
<a name="l00028"></a>00028 <span class="preprocessor">#include &lt;<a class="code" href="Periodique_8h.html">Periodique.h</a>&gt;</span>
<a name="l00029"></a>00029 <span class="preprocessor">#include &lt;<a class="code" href="Neumann__sortie__libre_8h.html">Neumann_sortie_libre.h</a>&gt;</span>
<a name="l00030"></a>00030 <span class="preprocessor">#include &lt;<a class="code" href="Symetrie_8h.html">Symetrie.h</a>&gt;</span>
<a name="l00031"></a>00031 <span class="preprocessor">#include &lt;<a class="code" href="LecFicDistribueBin_8h.html">LecFicDistribueBin.h</a>&gt;</span>
<a name="l00032"></a>00032 <span class="preprocessor">#include &lt;<a class="code" href="EcrFicCollecteBin_8h.html">EcrFicCollecteBin.h</a>&gt;</span>
<a name="l00033"></a>00033 <span class="preprocessor">#include &lt;<a class="code" href="DoubleLists_8h.html">DoubleLists.h</a>&gt;</span>
<a name="l00034"></a>00034 <span class="preprocessor">#include &lt;<a class="code" href="Navier__Stokes__std_8h.html">Navier_Stokes_std.h</a>&gt;</span>
<a name="l00035"></a>00035 <span class="preprocessor">#include &lt;<a class="code" href="Op__Div__VEFP1B__Elem_8h.html">Op_Div_VEFP1B_Elem.h</a>&gt;</span>
<a name="l00036"></a>00036 <span class="preprocessor">#include &lt;<a class="code" href="Champ__front__instationnaire__base_8h.html">Champ_front_instationnaire_base.h</a>&gt;</span>
<a name="l00037"></a>00037 <span class="preprocessor">#include &lt;<a class="code" href="Champ__front__var_8h.html">Champ_front_var.h</a>&gt;</span>
<a name="l00038"></a>00038 <span class="preprocessor">#include &lt;<a class="code" href="Op__Grad__VEF__P1B__Face_8h.html">Op_Grad_VEF_P1B_Face.h</a>&gt;</span>
<a name="l00039"></a>00039 <span class="preprocessor">#include &lt;<a class="code" href="Milieu__base_8h.html">Milieu_base.h</a>&gt;</span>
<a name="l00040"></a>00040 <span class="preprocessor">#include &lt;<a class="code" href="IntLists_8h.html">IntLists.h</a>&gt;</span>
<a name="l00041"></a>00041 <span class="preprocessor">#include &lt;<a class="code" href="Debog_8h.html">Debog.h</a>&gt;</span>
<a name="l00042"></a>00042 <span class="preprocessor">#include &lt;<a class="code" href="Check__espace__virtuel_8h.html">Check_espace_virtuel.h</a>&gt;</span>
<a name="l00043"></a>00043 <span class="preprocessor">#include &lt;<a class="code" href="Scatter_8h.html">Scatter.h</a>&gt;</span>
<a name="l00044"></a>00044 <span class="preprocessor">#include &lt;<a class="code" href="communications_8h.html">communications.h</a>&gt;</span>
<a name="l00045"></a>00045 
<a name="l00046"></a><a class="code" href="AssembleurPP1BUtil_8cpp.html#a3e374d53ebc7860e1c2f0b7906f2936d">00046</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="AssembleurPP1BUtil_8cpp.html#a3e374d53ebc7860e1c2f0b7906f2936d">face_associee</a>=-1;
<a name="l00047"></a>00047 
<a name="l00048"></a>00048 <span class="comment">// static ArrOfDouble coef_som;</span>
<a name="l00049"></a>00049 
<a name="l00050"></a>00050 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span>
<a name="l00051"></a><a class="code" href="AssembleurPP1BUtil_8cpp.html#a67ce6f1ce2314223209eca2d6ef7ac06">00051</a> <a class="code" href="Champ__Generique__Transformation_8cpp.html#a0705a900f8a8003047df2f59d6cd4bae">projette</a>(<a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a>&amp; gradi, <span class="keywordtype">int</span> face, <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; normales)
<a name="l00052"></a>00052 {
<a name="l00053"></a>00053   <span class="keywordtype">double</span> psc=0, norm=0;
<a name="l00054"></a>00054   <span class="keywordtype">int</span> dimension=<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>, comp;
<a name="l00055"></a>00055   <span class="keywordflow">for</span>(comp=0; comp&lt;dimension; comp++)
<a name="l00056"></a>00056     {
<a name="l00057"></a>00057       psc+=gradi(comp)*normales(face,comp);
<a name="l00058"></a>00058       norm+=normales(face,comp)*normales(face,comp);
<a name="l00059"></a>00059     }
<a name="l00060"></a>00060 <span class="comment">// psc/=norm; // Fixed bug: Arithmetic exception</span>
<a name="l00061"></a>00061   <span class="keywordflow">if</span> (<a class="code" href="Double_8h.html#aaecd4ca8a2fe69cc6568af2938b94d2e">dabs</a>(norm)&gt;=<a class="code" href="Double_8h.html#a0a3fffa6d17ad8f7de4bb337c6266561">DMINFLOAT</a>) psc/=norm;
<a name="l00062"></a>00062   <span class="keywordflow">for</span>(comp=0; comp&lt;dimension; comp++)
<a name="l00063"></a>00063     {
<a name="l00064"></a>00064       gradi(comp)-=psc*normales(face,comp);
<a name="l00065"></a>00065     }
<a name="l00066"></a>00066   psc=0;
<a name="l00067"></a>00067 <span class="comment">// for(comp=0; comp&lt;dimension; comp++)</span>
<a name="l00068"></a>00068 <span class="comment">// {</span>
<a name="l00069"></a>00069 <span class="comment">// psc+=gradi(comp)*normales(face,comp);</span>
<a name="l00070"></a>00070 <span class="comment">// }</span>
<a name="l00071"></a>00071 <span class="comment">// assert(psc &lt; 1.e-10);</span>
<a name="l00072"></a>00072 }
<a name="l00073"></a>00073 <span class="comment">// </span>
<a name="l00074"></a>00074 
<a name="l00075"></a>00075 <span class="comment">// renvoie la premiere face non Dirichlet</span>
<a name="l00076"></a>00076 <span class="comment">// 2 si Perio</span>
<a name="l00077"></a>00077 <span class="comment">// 3 si Neumann</span>
<a name="l00078"></a>00078 <span class="comment">// 4 si Symetrie</span>
<a name="l00079"></a>00079 <span class="comment">// 1 sinon</span>
<a name="l00080"></a>00080 <span class="comment">// et face_associee=-1 sauf si perio (face_associee=face associee)</span>
<a name="l00081"></a><a class="code" href="AssembleurPP1BUtil_8cpp.html#a40cf40213663174bb24649e51832bf3e">00081</a> <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> <a class="code" href="AssembleurPP1BUtil_8cpp.html#a40cf40213663174bb24649e51832bf3e">okface</a>(<span class="keywordtype">int</span>&amp; ind_face, <span class="keywordtype">int</span>&amp; face, <span class="keyword">const</span> <a class="code" href="classCond__lim.html" title="classe Cond_lim Classe generique servant a representer n&#39;importe quelle classe derivee de la classe C...">Cond_lim</a>&amp; la_cl)
<a name="l00082"></a>00082 {
<a name="l00083"></a>00083   <a class="code" href="AssembleurPP1BUtil_8cpp.html#a3e374d53ebc7860e1c2f0b7906f2936d">face_associee</a>=-1;
<a name="l00084"></a>00084   <span class="keywordtype">int</span> ok=1;
<a name="l00085"></a>00085   <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp; le_bord = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>,la_cl.<a class="code" href="classCond__lim.html#a5b2d24809cee07727006a891d4ce8d22" title="Appel a l&#39;objet sous-jacent Renvoie la frontiere discretisee associee a la condition aux limites...">frontiere_dis</a>());
<a name="l00086"></a>00086   <span class="keywordtype">int</span> nb_faces_bord_tot = le_bord.<a class="code" href="classFront__VF.html#aed4006d91bf2ef3af2b9f7933d863a09" title="Nombre de faces reelles et virtuelles du bord.">nb_faces_tot</a>();
<a name="l00087"></a>00087   <span class="keywordflow">do</span>
<a name="l00088"></a>00088     {
<a name="l00089"></a>00089       face=le_bord.<a class="code" href="classFront__VF.html#a3402a19d7e54ed797d2b18e9a47ead1e" title="Renvoie le numero de face de la ieme face du bord.">num_face</a>(ind_face);
<a name="l00090"></a>00090       <span class="keywordflow">if</span> ((<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classDirichlet.html" title="classe Dirichlet Cette classe est la classe de base de la hierarchie des conditions aux limites de ty...">Dirichlet</a>, la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>()))
<a name="l00091"></a>00091           || (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classDirichlet__homogene.html" title="Classe Dirichlet_homogene Cette classe est la classe de base de la hierarchie des conditions aux limi...">Dirichlet_homogene</a>, la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>())))
<a name="l00092"></a>00092         {
<a name="l00093"></a>00093           ok=0;
<a name="l00094"></a>00094         }
<a name="l00095"></a>00095       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>()))
<a name="l00096"></a>00096         {
<a name="l00097"></a>00097 <span class="comment">// periodicite</span>
<a name="l00098"></a>00098           <span class="keyword">const</span> <a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>&amp; la_cl_perio = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>, la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>());
<a name="l00099"></a>00099           <a class="code" href="AssembleurPP1BUtil_8cpp.html#a3e374d53ebc7860e1c2f0b7906f2936d">face_associee</a>=le_bord.<a class="code" href="classFront__VF.html#a3402a19d7e54ed797d2b18e9a47ead1e" title="Renvoie le numero de face de la ieme face du bord.">num_face</a>(la_cl_perio.<a class="code" href="classPeriodique.html#a207b86556f199a63ea059b841851ca6a">face_associee</a>(ind_face));
<a name="l00100"></a>00100           ok=2;
<a name="l00101"></a>00101         }
<a name="l00102"></a>00102       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classNeumann__sortie__libre.html" title="classe Neumann_sortie_libre Cette classe represente une frontiere ouverte sans vitesse imposee Pour l...">Neumann_sortie_libre</a>, la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>()))
<a name="l00103"></a>00103         {
<a name="l00104"></a>00104 <span class="comment">// sortie_libre</span>
<a name="l00105"></a>00105           ok=3;
<a name="l00106"></a>00106         }
<a name="l00107"></a>00107       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classSymetrie.html" title="classe Symetrie Sur les faces de symetrie on a les proprietes suivantes: - composante normale de la v...">Symetrie</a>, la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>()))
<a name="l00108"></a>00108         {
<a name="l00109"></a>00109 <span class="comment">// symetrie</span>
<a name="l00110"></a>00110           ok=4;
<a name="l00111"></a>00111         }
<a name="l00112"></a>00112     }
<a name="l00113"></a>00113   <span class="keywordflow">while</span> ( ( (ok==0) || ((ok==2)&amp;&amp;(<a class="code" href="AssembleurPP1BUtil_8cpp.html#a3e374d53ebc7860e1c2f0b7906f2936d">face_associee</a>&lt;face)) ) &amp;&amp; (++ind_face&lt;nb_faces_bord_tot) );
<a name="l00114"></a>00114   <span class="keywordflow">if</span> (ind_face==nb_faces_bord_tot) ok=-1;
<a name="l00115"></a>00115   <span class="keywordflow">return</span> ok;
<a name="l00116"></a>00116 }
<a name="l00117"></a>00117 
<a name="l00118"></a><a class="code" href="AssembleurPP1BUtil_8cpp.html#add6cc8459f10f15a9a6bac24d1727880">00118</a> <span class="keyword">inline</span> <span class="keywordtype">int</span> <a class="code" href="AssembleurPP1BUtil_8cpp.html#add6cc8459f10f15a9a6bac24d1727880">verifier_complet</a>(<span class="keyword">const</span> <a class="code" href="classAssembleur__P__VEFPreP1B.html">Assembleur_P_VEFPreP1B</a>&amp; ass,
<a name="l00119"></a>00119                             <span class="keyword">const</span> <a class="code" href="classMatrice__Bloc__Sym.html">Matrice_Bloc_Sym</a>&amp; matrice,
<a name="l00120"></a>00120                             <span class="keyword">const</span> <a class="code" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a>&amp; zone_VEF)
<a name="l00121"></a>00121 {
<a name="l00122"></a>00122   <span class="keyword">const</span> <a class="code" href="classNavier__Stokes__std.html" title="classe Navier_Stokes_std Cette classe porte les termes de l&#39;equation de la dynamique pour un fluide s...">Navier_Stokes_std</a>&amp; eqn=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classNavier__Stokes__std.html" title="classe Navier_Stokes_std Cette classe porte les termes de l&#39;equation de la dynamique pour un fluide s...">Navier_Stokes_std</a>, ass.<a class="code" href="classAssembleur__P__VEFPreP1B.html#a9a85837c29e80d1bcbc3a7f740f93807">equation</a>());
<a name="l00123"></a>00123   <span class="keyword">const</span> <a class="code" href="classOperateur__Div.html" title="classe Operateur_Div Classe generique de la hierarchie des operateurs calculant la divergence d&#39;un ch...">Operateur_Div</a>&amp; opdiv=eqn.<a class="code" href="classNavier__Stokes__std.html#a614d41350181667ee295b87a72779c1a" title="Renvoie l&#39;operateur de calcul de la divergence associe a l&#39;equation.">operateur_divergence</a>();
<a name="l00124"></a>00124   <span class="keyword">const</span> <a class="code" href="classOp__Div__VEFP1B__Elem.html">Op_Div_VEFP1B_Elem</a>&amp; div=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classOp__Div__VEFP1B__Elem.html">Op_Div_VEFP1B_Elem</a>,
<a name="l00125"></a>00125                                          opdiv.valeur());
<a name="l00126"></a>00126 <span class="comment">// div.verifier();</span>
<a name="l00127"></a>00127   <span class="keyword">const</span> <a class="code" href="classOperateur__Grad.html" title="Classe Operateur_Grad Classe generique de la hierarchie des operateurs calculant le gradient d&#39;un cha...">Operateur_Grad</a>&amp; opgrad=eqn.<a class="code" href="classNavier__Stokes__std.html#a840295836fce939b7861f1353da595ff" title="Renvoie l&#39;operateur de calcul du gradient associe a l&#39;equation.">operateur_gradient</a>();
<a name="l00128"></a>00128   <span class="keyword">const</span> <a class="code" href="classOp__Grad__VEF__P1B__Face.html">Op_Grad_VEF_P1B_Face</a>&amp; grad=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classOp__Grad__VEF__P1B__Face.html">Op_Grad_VEF_P1B_Face</a>,
<a name="l00129"></a>00129                                             opgrad.valeur());
<a name="l00130"></a>00130 <span class="comment">// grad.verifier();</span>
<a name="l00131"></a>00131   <span class="keyword">const</span> <a class="code" href="classSolveur__Masse.html" title="classe Solveur_Masse Classe generique de la hierarchie des solveurs de masse, un objet Solveur_Masse ...">Solveur_Masse</a>&amp; solvm=eqn.<a class="code" href="classEquation__base.html#adfedf474c07a92f6b2261ca2f1cee80e" title="Renvoie le solveur de masse associe a l&#39;equation.">solv_masse</a>();
<a name="l00132"></a>00132   <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; pression=eqn.<a class="code" href="classNavier__Stokes__std.html#afbb8f39bdfd70328dfad21bf2b9dd45a" title="Renvoie le champ de pression.">pression</a>().<a class="code" href="classChamp__Inc.html#a28ef3d411d12cb5684ac5e799efb7d24" title="Appel a l&#39;objet sous-jacent Renvoie le tableau des valeurs au temps courant.">valeurs</a>();
<a name="l00133"></a>00133   <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a> tab(pression);
<a name="l00134"></a>00134   <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a> resu(tab), resu2(tab), <a class="code" href="Solv__GCP__NS_8cpp.html#ab6aa1075b965c7713d8db20dd3a8e09b">erreur</a>(tab);
<a name="l00135"></a>00135 
<a name="l00136"></a>00136 <span class="comment">// On calcule un champ de pression quelconque</span>
<a name="l00137"></a>00137   <a class="code" href="Zone__VEF__PreP1b_8cpp.html#ad8ba71244ad9a61cd78b6f388d7e503a">exemple_champ_non_homogene</a>(zone_VEF, tab);
<a name="l00138"></a>00138 
<a name="l00139"></a>00139   <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a> gradP(eqn.<a class="code" href="classNavier__Stokes__std.html#a743b777e6185faee7837326844c8fca1" title="Renvoie la vitesse (champ inconnue de l&#39;equation) (version const)">inconnue</a>().<a class="code" href="classChamp__Inc.html#a28ef3d411d12cb5684ac5e799efb7d24" title="Appel a l&#39;objet sous-jacent Renvoie le tableau des valeurs au temps courant.">valeurs</a>());
<a name="l00140"></a>00140   grad.<a class="code" href="classOp__Grad__VEF__Face.html#a06e2a3259889b939f7a0b8d7420d16f3">calculer</a>(tab, gradP);
<a name="l00141"></a>00141   solvm.appliquer(gradP);
<a name="l00142"></a>00142   div.<a class="code" href="classOp__Div__VEF__Elem.html#ab28b31e5146e5774e799093c3aaffa19">calculer</a>(gradP, resu);
<a name="l00143"></a>00143   matrice.<a class="code" href="classMatrice__Base.html#a05caa487a25a6d5e7fbd38d4b2f4ee1e" title="Multiplication d&#39;un vecteur par la matrice. Operation: r = A*x.">multvect</a>(tab, resu2);
<a name="l00144"></a>00144   <span class="keywordflow">return</span> 0;
<a name="l00145"></a>00145 }
<a name="l00146"></a><a class="code" href="AssembleurPP1BUtil_8cpp.html#ab3f0bf1b466f4f73f7c106a25a0ce950">00146</a> <span class="keywordtype">int</span> <a class="code" href="Op__Div__VEFP1B__Elem_8cpp.html#a45261662b3b88d5db461b3fc99246e5a">verifier</a>( <span class="keyword">const</span> <a class="code" href="classAssembleur__P__VEFPreP1B.html">Assembleur_P_VEFPreP1B</a>&amp; ass,
<a name="l00147"></a>00147               <span class="keyword">const</span> <a class="code" href="classMatrice__Bloc__Sym.html">Matrice_Bloc_Sym</a>&amp; matrice,
<a name="l00148"></a>00148               <span class="keyword">const</span> <a class="code" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a>&amp; zone_VEF,
<a name="l00149"></a>00149               <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; inverse_quantitee_entrelacee)
<a name="l00150"></a>00150 {
<a name="l00151"></a>00151   <span class="keywordflow">if</span> (zone_VEF.<a class="code" href="classZone__VEF__PreP1b.html#aee2def53aa92584d7945e7c3d0d98963">get_alphaE</a>()+zone_VEF.<a class="code" href="classZone__VEF__PreP1b.html#ad7fbcb5567dcc2e6f0a0ed85ce90a4fa">get_alphaS</a>()+zone_VEF.<a class="code" href="classZone__VEF__PreP1b.html#a9d02e2431efb6e75c3d733ff06f89549">get_alphaA</a>()!=<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>)
<a name="l00152"></a>00152     {
<a name="l00153"></a>00153       <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Assembleur_P_VEFPreP1B::verifier n&#39;est pas prevu pour verifier votre discretisation.&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
<a name="l00154"></a>00154       <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">Process::exit</a>();
<a name="l00155"></a>00155     }
<a name="l00156"></a>00156   <span class="keyword">const</span> <a class="code" href="classNavier__Stokes__std.html" title="classe Navier_Stokes_std Cette classe porte les termes de l&#39;equation de la dynamique pour un fluide s...">Navier_Stokes_std</a>&amp; eqn=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classNavier__Stokes__std.html" title="classe Navier_Stokes_std Cette classe porte les termes de l&#39;equation de la dynamique pour un fluide s...">Navier_Stokes_std</a>, ass.<a class="code" href="classAssembleur__P__VEFPreP1B.html#a9a85837c29e80d1bcbc3a7f740f93807">equation</a>());
<a name="l00157"></a>00157   <span class="keyword">const</span> <a class="code" href="classOperateur__Div.html" title="classe Operateur_Div Classe generique de la hierarchie des operateurs calculant la divergence d&#39;un ch...">Operateur_Div</a>&amp; opdiv=eqn.<a class="code" href="classNavier__Stokes__std.html#a614d41350181667ee295b87a72779c1a" title="Renvoie l&#39;operateur de calcul de la divergence associe a l&#39;equation.">operateur_divergence</a>();
<a name="l00158"></a>00158   <span class="keyword">const</span> <a class="code" href="classOp__Div__VEFP1B__Elem.html">Op_Div_VEFP1B_Elem</a>&amp; div=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classOp__Div__VEFP1B__Elem.html">Op_Div_VEFP1B_Elem</a>,
<a name="l00159"></a>00159                                          opdiv.valeur());
<a name="l00160"></a>00160 <span class="comment">// div.verifier();</span>
<a name="l00161"></a>00161   <span class="keyword">const</span> <a class="code" href="classOperateur__Grad.html" title="Classe Operateur_Grad Classe generique de la hierarchie des operateurs calculant le gradient d&#39;un cha...">Operateur_Grad</a>&amp; opgrad=eqn.<a class="code" href="classNavier__Stokes__std.html#a840295836fce939b7861f1353da595ff" title="Renvoie l&#39;operateur de calcul du gradient associe a l&#39;equation.">operateur_gradient</a>();
<a name="l00162"></a>00162   <span class="keyword">const</span> <a class="code" href="classOp__Grad__VEF__P1B__Face.html">Op_Grad_VEF_P1B_Face</a>&amp; grad=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classOp__Grad__VEF__P1B__Face.html">Op_Grad_VEF_P1B_Face</a>,
<a name="l00163"></a>00163                                             opgrad.valeur());
<a name="l00164"></a>00164 <span class="comment">// grad.verifier();</span>
<a name="l00165"></a>00165 <span class="comment">// const Solveur_Masse&amp; solvm=eqn.solv_masse();</span>
<a name="l00166"></a>00166   <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; pression=eqn.<a class="code" href="classNavier__Stokes__std.html#afbb8f39bdfd70328dfad21bf2b9dd45a" title="Renvoie le champ de pression.">pression</a>().<a class="code" href="classChamp__Inc.html#a28ef3d411d12cb5684ac5e799efb7d24" title="Appel a l&#39;objet sous-jacent Renvoie le tableau des valeurs au temps courant.">valeurs</a>();
<a name="l00167"></a>00167   <span class="keywordtype">int</span> ko=0;
<a name="l00168"></a>00168   ko=<a class="code" href="AssembleurPP1BUtil_8cpp.html#add6cc8459f10f15a9a6bac24d1727880">verifier_complet</a>(ass, matrice, zone_VEF);
<a name="l00169"></a>00169   <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a> pre(pression);
<a name="l00170"></a>00170   <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a> resu(pre), resu2(pre), <a class="code" href="Solv__GCP__NS_8cpp.html#ab6aa1075b965c7713d8db20dd3a8e09b">erreur</a>(pre);
<a name="l00171"></a>00171   <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a> gradP(eqn.<a class="code" href="classNavier__Stokes__std.html#a743b777e6185faee7837326844c8fca1" title="Renvoie la vitesse (champ inconnue de l&#39;equation) (version const)">inconnue</a>().<a class="code" href="classChamp__Inc.html#a28ef3d411d12cb5684ac5e799efb7d24" title="Appel a l&#39;objet sous-jacent Renvoie le tableau des valeurs au temps courant.">valeurs</a>());
<a name="l00172"></a>00172   <span class="keyword">const</span> <a class="code" href="classZone.html" title="classe Zone Une Zone est un maillage compose d&#39;un ensemble d&#39;elements geometriques de meme type...">Zone</a>&amp; zone=zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>();
<a name="l00173"></a>00173   <span class="keywordtype">int</span> nb_elem=zone.<a class="code" href="classZone.html#a7f249429803b27139a1c54436f6164a5" title="Renvoie le nombre d&#39;elements de la zone.">nb_elem</a>();
<a name="l00174"></a>00174   <span class="keywordtype">int</span> nb_elem_tot=zone.nb_elem_tot();
<a name="l00175"></a>00175   <span class="keywordtype">int</span> nb_som=zone.domaine().nb_som();
<a name="l00176"></a>00176   <span class="keywordtype">int</span> nb_som_tot=zone.domaine().nb_som_tot();
<a name="l00177"></a>00177   <span class="keywordtype">int</span> nb_aretes=zone.nb_aretes();
<a name="l00178"></a>00178   <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; ok_arete=zone_VEF.<a class="code" href="classZone__VEF__PreP1b.html#a83771f784d487e346b2ef22a389472a2">get_ok_arete</a>();
<a name="l00179"></a>00179   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> proc=0; proc&lt;<a class="code" href="classProcess.html#a6bf692ce58d9578aa62ac3c07b8caaa1" title="renvoie le nombre de processeurs dans le groupe courant Voir Comm_Group::nproc() et PE_Groups::curren...">Process::nproc</a>(); proc++)
<a name="l00180"></a>00180     {
<a name="l00181"></a>00181       <span class="keywordtype">int</span> n = pre.<a class="code" href="classDoubleTab.html#a3eadd63f3ba20c1b454d760b430acbf7" title="Returns the total dimensions of the multi-dimensionnal array, including virtual items (used in parall...">dimension_tot</a>(0);
<a name="l00182"></a>00182 <span class="comment">// Le processeur proc impose sa valeur de n a tout le monde</span>
<a name="l00183"></a>00183       <a class="code" href="communications_8cpp.html#a2335b36078ae87e23dab400a6e129a3c">envoyer_broadcast</a>(n, proc);
<a name="l00184"></a>00184 
<a name="l00185"></a>00185       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;n; i++)
<a name="l00186"></a>00186         {
<a name="l00187"></a>00187 <span class="comment">// Cerr &lt;&lt; &quot;[&quot; &lt;&lt; Process::me() &lt;&lt; &quot;] On verifie la ligne &quot; &lt;&lt; i &lt;&lt; &quot; de la matrice.&quot; &lt;&lt; finl;</span>
<a name="l00188"></a>00188           pre=0;
<a name="l00189"></a>00189           <span class="keywordflow">if</span> (<a class="code" href="classProcess.html#ab55ba07167ec807ed3a145cac0f5dca4" title="renvoie mon rang dans le groupe de communication courant. Voir Comm_Group::rank() et PE_Groups::curre...">Process::me</a>()==proc)
<a name="l00190"></a>00190             {
<a name="l00191"></a>00191               <span class="keywordflow">if</span> (0&lt;=i &amp;&amp; i&lt;nb_elem)
<a name="l00192"></a>00192                 {
<a name="l00193"></a>00193                   <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;On verifie l&#39;element reel &quot;</span> &lt;&lt; i &lt;&lt; <span class="stringliteral">&quot; du processeur &quot;</span> &lt;&lt; proc;
<a name="l00194"></a>00194                   pre(i)=1;
<a name="l00195"></a>00195                 }
<a name="l00196"></a>00196               <span class="keywordflow">else</span> <span class="keywordflow">if</span> (nb_elem_tot&lt;=i &amp;&amp; i&lt;nb_elem_tot+nb_som)
<a name="l00197"></a>00197                 {
<a name="l00198"></a>00198                   <span class="keywordtype">int</span> sommet=i-nb_elem_tot;
<a name="l00199"></a>00199                   <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;On verifie le sommet reel &quot;</span>;
<a name="l00200"></a>00200                   <span class="keywordflow">if</span> (zone.domaine().get_renum_som_perio(sommet)!=sommet) <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;periodique &quot;</span>;
<a name="l00201"></a>00201                   <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; i-nb_elem_tot &lt;&lt; <span class="stringliteral">&quot; du processeur &quot;</span> &lt;&lt; proc;
<a name="l00202"></a>00202                   pre(i)=1;
<a name="l00203"></a>00203                 }
<a name="l00204"></a>00204               <span class="keywordflow">else</span> <span class="keywordflow">if</span> (nb_elem_tot+nb_som_tot&lt;=i &amp;&amp; i&lt;nb_elem_tot+nb_som_tot+nb_aretes &amp;&amp; ok_arete(i-nb_elem_tot-nb_som_tot))
<a name="l00205"></a>00205                 {
<a name="l00206"></a>00206                   <span class="keywordtype">int</span> arete=i-nb_elem_tot-nb_som_tot;
<a name="l00207"></a>00207                   <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; renum_arete_perio=zone_VEF.<a class="code" href="classZone__VEF__PreP1b.html#a43767f8684512d1ee950dc07eea76c5b">get_renum_arete_perio</a>();
<a name="l00208"></a>00208                   <span class="keywordflow">if</span> (renum_arete_perio(arete)==arete)
<a name="l00209"></a>00209                     {
<a name="l00210"></a>00210                       <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;On verifie l&#39;arete reelle non superflue et non periodique &quot;</span> &lt;&lt; arete &lt;&lt; <span class="stringliteral">&quot; du processeur &quot;</span> &lt;&lt; proc;
<a name="l00211"></a>00211                       pre(i)=1;
<a name="l00212"></a>00212                     }
<a name="l00213"></a>00213                 }
<a name="l00214"></a>00214               <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot; &quot;</span>;
<a name="l00215"></a>00215 <span class="comment">// Cerr &lt;&lt; finl;</span>
<a name="l00216"></a>00216             }
<a name="l00217"></a>00217           <span class="keywordtype">double</span> <a class="code" href="Type__Verifie_8cpp.html#ad3531c82596e15d1af86ea6b2713ef51">verifie</a>=<a class="code" href="DoubleVect_8cpp.html#adcc29a107bd1ad77828da317da293203">mp_max_vect</a>(pre);
<a name="l00218"></a>00218 <span class="comment">// verifie=1;pre(i)=1; // On teste tout</span>
<a name="l00219"></a>00219           <span class="keywordflow">if</span> (verifie)
<a name="l00220"></a>00220             {
<a name="l00221"></a>00221               pre.<a class="code" href="classDoubleVect.html#abfebbc2f685ce7bc4b80c720d7da9bf3">echange_espace_virtuel</a>();
<a name="l00222"></a>00222               <span class="comment">/* Inutile le debog ce n&#39;est pas comparable le sequentiel et le parallele</span>
<a name="l00223"></a>00223 <span class="comment">                 Nom ch;</span>
<a name="l00224"></a>00224 <span class="comment">                 ch=&quot;pre pour la ligne &quot;;</span>
<a name="l00225"></a>00225 <span class="comment">                 ch+=(Nom)i+&quot; du processeur &quot;;</span>
<a name="l00226"></a>00226 <span class="comment">                 ch+=(Nom)proc+&quot; =&quot;;</span>
<a name="l00227"></a>00227 <span class="comment">                 Debog::verifier(ch,pre);</span>
<a name="l00228"></a>00228 <span class="comment">              */</span>
<a name="l00229"></a>00229 <span class="comment">// Calcul par Div(Grad(P))</span>
<a name="l00230"></a>00230               grad.<a class="code" href="classOp__Grad__VEF__Face.html#a06e2a3259889b939f7a0b8d7420d16f3">calculer</a>(pre, gradP);
<a name="l00231"></a>00231               {
<a name="l00232"></a>00232                 <span class="keywordtype">int</span> nbf=inverse_quantitee_entrelacee.<a class="code" href="classDoubleVect.html#a392c1f20b462563365389d28e0853867" title="Identique a size_reelle()">size</a>();
<a name="l00233"></a>00233                 <span class="keywordtype">int</span> d = <a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>;
<a name="l00234"></a>00234                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> face=0; face&lt;nbf; face++)
<a name="l00235"></a>00235                   <span class="keywordflow">for</span>(<span class="keywordtype">int</span> k=0; k&lt;d; k++)
<a name="l00236"></a>00236                     gradP(face,k)*=inverse_quantitee_entrelacee(face,k);
<a name="l00237"></a>00237               }
<a name="l00238"></a>00238 <span class="comment">// solvm.appliquer(gradP);</span>
<a name="l00239"></a>00239               div.<a class="code" href="classOp__Div__VEF__Elem.html#ab28b31e5146e5774e799093c3aaffa19">calculer</a>(gradP, resu);
<a name="l00240"></a>00240 <span class="comment">// Calcul par -Lap(P)</span>
<a name="l00241"></a>00241               matrice.<a class="code" href="classMatrice__Base.html#a05caa487a25a6d5e7fbd38d4b2f4ee1e" title="Multiplication d&#39;un vecteur par la matrice. Operation: r = A*x.">multvect</a>(pre, resu2);
<a name="l00242"></a>00242 <span class="comment">// On doit trouver erreur nul</span>
<a name="l00243"></a>00243               erreur=resu2;
<a name="l00244"></a>00244               erreur+=resu;
<a name="l00245"></a>00245               resu*=-1;
<a name="l00246"></a>00246 <span class="comment">// Cas ou la diagonale est *2, on corrige:</span>
<a name="l00247"></a>00247               <span class="keywordflow">if</span> (<a class="code" href="Double_8h.html#ac86f5f350b0f95fd8c34b0ac8d720f6f">est_egal</a>(2*resu(i),resu2(i))) <a class="code" href="Solv__GCP__NS_8cpp.html#ab6aa1075b965c7713d8db20dd3a8e09b">erreur</a>(i)=0;
<a name="l00248"></a>00248               <span class="keywordtype">double</span> erreur_absolue=<a class="code" href="DoubleVect_8cpp.html#afaa33f0032aa927d8d54ff9fb002b749">mp_norme_vect</a>(erreur);
<a name="l00249"></a>00249               <span class="keywordtype">double</span> erreur_relative=erreur_absolue/(<a class="code" href="DoubleVect_8cpp.html#afaa33f0032aa927d8d54ff9fb002b749">mp_norme_vect</a>(resu2)+<a class="code" href="DoubleVect_8cpp.html#afaa33f0032aa927d8d54ff9fb002b749">mp_norme_vect</a>(resu)+<a class="code" href="Double_8h.html#a0a3fffa6d17ad8f7de4bb337c6266561">DMINFLOAT</a>);
<a name="l00250"></a>00250               <span class="keywordtype">double</span> app=<a class="code" href="DoubleVect_8cpp.html#a07d13cbdadca6b60d5e128653f52a4bb">mp_prodscal</a>(resu,pre);
<a name="l00251"></a>00251               <span class="keywordflow">if</span>(erreur_absolue&gt;1.e-12 &amp;&amp; erreur_relative&gt;1.e-6)
<a name="l00252"></a>00252                 {
<a name="l00253"></a>00253                   <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;[&quot;</span> &lt;&lt; <a class="code" href="classProcess.html#ab55ba07167ec807ed3a145cac0f5dca4" title="renvoie mon rang dans le groupe de communication courant. Voir Comm_Group::rank() et PE_Groups::curre...">Process::me</a>() &lt;&lt; <span class="stringliteral">&quot;] KO a la ligne &quot;</span> &lt;&lt; i &lt;&lt; <span class="stringliteral">&quot; pour le proc &quot;</span> &lt;&lt; proc &lt;&lt; <span class="stringliteral">&quot; (AP,P)= &quot;</span> &lt;&lt; app &lt;&lt; <span class="stringliteral">&quot; erreur= &quot;</span> &lt;&lt; erreur_absolue &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
<a name="l00254"></a>00254                   ko=1;
<a name="l00255"></a>00255                   <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;[&quot;</span> &lt;&lt; <a class="code" href="classProcess.html#ab55ba07167ec807ed3a145cac0f5dca4" title="renvoie mon rang dans le groupe de communication courant. Voir Comm_Group::rank() et PE_Groups::curre...">Process::me</a>() &lt;&lt; <span class="stringliteral">&quot;] pre= &quot;</span>;
<a name="l00256"></a>00256                   pre.<a class="code" href="classDoubleTab.html#ab7588e94792cc0be3a3288573c44ca18" title="ecriture des valeurs du tableau &quot;raw&quot; sans structure parallele">ecrit</a>(<a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a>);
<a name="l00257"></a>00257                   <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;[&quot;</span> &lt;&lt; <a class="code" href="classProcess.html#ab55ba07167ec807ed3a145cac0f5dca4" title="renvoie mon rang dans le groupe de communication courant. Voir Comm_Group::rank() et PE_Groups::curre...">Process::me</a>() &lt;&lt; <span class="stringliteral">&quot;] Div(gradP) = &quot;</span>;
<a name="l00258"></a>00258                   resu.ecrit(<a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a>);
<a name="l00259"></a>00259                   <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;[&quot;</span> &lt;&lt; <a class="code" href="classProcess.html#ab55ba07167ec807ed3a145cac0f5dca4" title="renvoie mon rang dans le groupe de communication courant. Voir Comm_Group::rank() et PE_Groups::curre...">Process::me</a>() &lt;&lt; <span class="stringliteral">&quot;] Lap(P) = &quot;</span>;
<a name="l00260"></a>00260                   resu2.ecrit(<a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a>);
<a name="l00261"></a>00261                   <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;[&quot;</span> &lt;&lt; <a class="code" href="classProcess.html#ab55ba07167ec807ed3a145cac0f5dca4" title="renvoie mon rang dans le groupe de communication courant. Voir Comm_Group::rank() et PE_Groups::curre...">Process::me</a>() &lt;&lt; <span class="stringliteral">&quot;] erreur = &quot;</span>;
<a name="l00262"></a>00262                   erreur.<a class="code" href="classDoubleTab.html#ab7588e94792cc0be3a3288573c44ca18" title="ecriture des valeurs du tableau &quot;raw&quot; sans structure parallele">ecrit</a>(<a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a>);
<a name="l00263"></a>00263                   <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;[&quot;</span> &lt;&lt; <a class="code" href="classProcess.html#ab55ba07167ec807ed3a145cac0f5dca4" title="renvoie mon rang dans le groupe de communication courant. Voir Comm_Group::rank() et PE_Groups::curre...">Process::me</a>() &lt;&lt; <span class="stringliteral">&quot;] invqtentrelacee = &quot;</span>;
<a name="l00264"></a>00264                   inverse_quantitee_entrelacee.<a class="code" href="classDoubleTab.html#ab7588e94792cc0be3a3288573c44ca18" title="ecriture des valeurs du tableau &quot;raw&quot; sans structure parallele">ecrit</a>(<a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a>);
<a name="l00265"></a>00265                 }
<a name="l00266"></a>00266               <span class="keywordflow">else</span>
<a name="l00267"></a>00267                 {
<a name="l00268"></a>00268                   <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;[&quot;</span> &lt;&lt; <a class="code" href="classProcess.html#ab55ba07167ec807ed3a145cac0f5dca4" title="renvoie mon rang dans le groupe de communication courant. Voir Comm_Group::rank() et PE_Groups::curre...">Process::me</a>() &lt;&lt; <span class="stringliteral">&quot;] OK a la ligne &quot;</span> &lt;&lt; i &lt;&lt; <span class="stringliteral">&quot; pour le proc &quot;</span> &lt;&lt; proc &lt;&lt; <span class="stringliteral">&quot; (AP,P)= &quot;</span> &lt;&lt; app &lt;&lt; <span class="stringliteral">&quot; erreur= &quot;</span> &lt;&lt; erreur_absolue &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
<a name="l00269"></a>00269                 }
<a name="l00270"></a>00270             }
<a name="l00271"></a>00271         }
<a name="l00272"></a>00272     }
<a name="l00273"></a>00273   <span class="keywordflow">if</span> (ko)
<a name="l00274"></a>00274     {
<a name="l00275"></a>00275       <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;[&quot;</span> &lt;&lt; <a class="code" href="classProcess.html#ab55ba07167ec807ed3a145cac0f5dca4" title="renvoie mon rang dans le groupe de communication courant. Voir Comm_Group::rank() et PE_Groups::curre...">Process::me</a>() &lt;&lt; <span class="stringliteral">&quot;] Matrice en pression:&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
<a name="l00276"></a>00276       matrice.<a class="code" href="classMatrice__Bloc__Sym.html#a6218305c5024cbfa78d29c229cb6340f">imprimer_formatte</a>(<a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a>);
<a name="l00277"></a>00277       <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Echec de la methode verifier de l&#39;assembleur. Voir les KO.&quot;</span> &lt;&lt; finl;
<a name="l00278"></a>00278       <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">Process::exit</a>();
<a name="l00279"></a>00279     }
<a name="l00280"></a>00280   <span class="keywordflow">return</span> 1;
<a name="l00281"></a>00281 }
<a name="l00282"></a>00282 <span class="comment">// </span>
<a name="l00283"></a>00283 <span class="comment">// trie le tableau sommets dans l&#39;ordre croissant et</span>
<a name="l00284"></a>00284 <span class="comment">// faces_op1 et faces_op2 consequemment.</span>
<a name="l00285"></a>00285 <span class="comment">// </span>
<a name="l00286"></a><a class="code" href="AssembleurPP1BUtil_8cpp.html#acff816d35f8d4ce978f860e0cd958b8a">00286</a> <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="AssembleurPP1BUtil_8cpp.html#acff816d35f8d4ce978f860e0cd958b8a">sort</a>( <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; sommets, <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; faces_op1, <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; faces_op2)
<a name="l00287"></a>00287 {
<a name="l00288"></a>00288   <span class="keywordtype">int</span> <a class="code" href="Nom_8cpp.html#a0e1ea19fb9fa7881d15d84eff4c090e1">sz</a>=sommets.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>();
<a name="l00289"></a>00289   <span class="keywordflow">if</span>(sommets(sz-1)==-1) sz--;
<a name="l00290"></a>00290   <span class="keywordtype">int</span> i,j;
<a name="l00291"></a>00291   <span class="keywordflow">for</span>(i=0; i&lt;<a class="code" href="Nom_8cpp.html#a0e1ea19fb9fa7881d15d84eff4c090e1">sz</a>; i++)
<a name="l00292"></a>00292     <span class="keywordflow">for</span>(j=i; j&lt;<a class="code" href="Nom_8cpp.html#a0e1ea19fb9fa7881d15d84eff4c090e1">sz</a>; j++)
<a name="l00293"></a>00293       <span class="keywordflow">if</span>(sommets(i)&gt;sommets(j))
<a name="l00294"></a>00294         {
<a name="l00295"></a>00295           <span class="keywordtype">int</span> tmp=sommets(i);
<a name="l00296"></a>00296           sommets(i)=sommets(j);
<a name="l00297"></a>00297           sommets(j)=tmp;
<a name="l00298"></a>00298           tmp=faces_op1(i);
<a name="l00299"></a>00299           faces_op1(i)=faces_op1(j);
<a name="l00300"></a>00300           faces_op1(j)=tmp;
<a name="l00301"></a>00301           tmp=faces_op2(i);
<a name="l00302"></a>00302           faces_op2(i)=faces_op2(j);
<a name="l00303"></a>00303           faces_op2(j)=tmp;
<a name="l00304"></a>00304         }
<a name="l00305"></a>00305 }
<a name="l00306"></a><a class="code" href="AssembleurPP1BUtil_8cpp.html#ae1c00f10faaf4da3ffdea8f881565a1b">00306</a> <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> <a class="code" href="AssembleurPP1BUtil_8cpp.html#ae1c00f10faaf4da3ffdea8f881565a1b">chercher_arete</a>(<span class="keyword">const</span> <a class="code" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a>&amp; zone_VEF,
<a name="l00307"></a>00307                                  <span class="keywordtype">int</span> elem, <span class="keywordtype">int</span> somi, <span class="keywordtype">int</span> somj,
<a name="l00308"></a>00308                                  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; elem_aretes,
<a name="l00309"></a>00309                                  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; aretes_som)
<a name="l00310"></a>00310 {
<a name="l00311"></a>00311   <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; renum_arete_perio=zone_VEF.<a class="code" href="classZone__VEF__PreP1b.html#a43767f8684512d1ee950dc07eea76c5b">get_renum_arete_perio</a>();
<a name="l00312"></a>00312   <span class="keyword">const</span> <a class="code" href="classDomaine.html" title="Classe Domaine Un Domaine represente le domaine (spatial) de resolution d&#39;un Probleme. Un Domaine a un Nom, il est constitue d&#39;une ou plusieurs Zone qui peuvent etre eventuellement decoupees en Sous_Zone. Un Domaine porte l&#39;ensemble des sommets utilises par ses Zones. On peut vouloir resoudre des problemes de type different sur plusieurs domaines, geometriquement les domaines sont alors couples par des surfaces qu&#39;on appelle Raccord.">Domaine</a>&amp; dom=zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#a379ad2206b5a13a4f4f3df6d44c7546a" title="Renvoie le domaine dont la zone fait partie. (version const)">domaine</a>();
<a name="l00313"></a>00313   <span class="keywordflow">if</span>(somi&gt;somj)
<a name="l00314"></a>00314     {
<a name="l00315"></a>00315       <span class="keywordtype">int</span> k=somi;
<a name="l00316"></a>00316       somi=somj;
<a name="l00317"></a>00317       somj=k;
<a name="l00318"></a>00318     }
<a name="l00319"></a>00319   <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i_arete=0; i_arete&lt;6; i_arete++)
<a name="l00320"></a>00320     {
<a name="l00321"></a>00321       <span class="keywordtype">int</span> arete=elem_aretes(elem, i_arete);
<a name="l00322"></a>00322       <span class="keywordtype">int</span> som1=dom.<a class="code" href="classDomaine.html#a37cc657f1907d53b0d5a573da862af80">get_renum_som_perio</a>(aretes_som(arete,0));
<a name="l00323"></a>00323       <span class="keywordtype">int</span> som2=dom.<a class="code" href="classDomaine.html#a37cc657f1907d53b0d5a573da862af80">get_renum_som_perio</a>(aretes_som(arete,1));
<a name="l00324"></a>00324       somi=dom.<a class="code" href="classDomaine.html#a37cc657f1907d53b0d5a573da862af80">get_renum_som_perio</a>(somi);
<a name="l00325"></a>00325       somj=dom.<a class="code" href="classDomaine.html#a37cc657f1907d53b0d5a573da862af80">get_renum_som_perio</a>(somj);
<a name="l00326"></a>00326       <span class="keywordflow">if</span>( (somi==som1)
<a name="l00327"></a>00327           &amp;&amp; (somj==som2) )
<a name="l00328"></a>00328         <span class="keywordflow">return</span> renum_arete_perio(arete);
<a name="l00329"></a>00329       <span class="keywordflow">if</span>( (somi==som2)
<a name="l00330"></a>00330           &amp;&amp; (somj==som1) )
<a name="l00331"></a>00331         <span class="keywordflow">return</span> renum_arete_perio(arete);
<a name="l00332"></a>00332     }
<a name="l00333"></a>00333   <span class="keywordflow">return</span> -1;
<a name="l00334"></a>00334 }
<a name="l00335"></a><a class="code" href="AssembleurPP1BUtil_8cpp.html#a3117b050530c46b4a15b6ab9ce6d0b41">00335</a> <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="AssembleurPP1BUtil_8cpp.html#a3117b050530c46b4a15b6ab9ce6d0b41">swap</a> (<span class="keywordtype">int</span>&amp; i, <span class="keywordtype">int</span>&amp; j)
<a name="l00336"></a>00336 {
<a name="l00337"></a>00337   <span class="keywordtype">int</span> k=i;
<a name="l00338"></a>00338   i=j;
<a name="l00339"></a>00339   j=k;
<a name="l00340"></a>00340 }
<a name="l00341"></a>00341 
<a name="l00342"></a>00342 <span class="comment">// </span>
<a name="l00343"></a>00343 <span class="comment">// rempli sommets, faces_op1 et faces_op2</span>
<a name="l00344"></a>00344 <span class="comment">// ou sommets contient les sommets de face et les sommets de elem1 et elem2</span>
<a name="l00345"></a>00345 <span class="comment">// qui ne sont pas dans face. face_op1(i) est le numero de la face opposee a sommets(i)</span>
<a name="l00346"></a>00346 <span class="comment">// dans elem1. face_op2(i) est ... dans elem2. (si elem2=-1, alors face_op2=-1)</span>
<a name="l00347"></a>00347 <span class="comment">// les dimension premiers sommets sont ceux de face</span>
<a name="l00348"></a>00348 <span class="comment">// le dernier est dans elem2</span>
<a name="l00349"></a><a class="code" href="AssembleurPP1BUtil_8cpp.html#afd0a249a235b161c5267e7574e199a82">00349</a> <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="AssembleurPP1BUtil_8cpp.html#afd0a249a235b161c5267e7574e199a82">remplir_sommets</a>(<span class="keyword">const</span> <a class="code" href="classZone__VEF.html" title="class Zone_VEF Classe instanciable qui derive de Zone_VF. Cette classe contient les informations geom...">Zone_VEF</a>&amp; zone_VEF,
<a name="l00350"></a>00350                                    <span class="keywordtype">int</span> face, <span class="keywordtype">int</span> elem1, <span class="keywordtype">int</span> elem2,
<a name="l00351"></a>00351                                    <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; sommets,
<a name="l00352"></a>00352                                    <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; faces_op1,
<a name="l00353"></a>00353                                    <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; faces_op2)
<a name="l00354"></a>00354 {
<a name="l00355"></a>00355   <span class="keywordtype">int</span> dplusun=<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>+1;
<a name="l00356"></a>00356   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; elem_som = zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#ac115e8342be89afb882b7b61cc343267" title="Renvoie le tableau des sommets des elements.">les_elems</a>();
<a name="l00357"></a>00357   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; face_som = zone_VEF.<a class="code" href="classZone__VF.html#a298e73b18e17da55f421b1fb0879bd46" title="renvoie le numero du ieme sommet de la face num_face.">face_sommets</a>();
<a name="l00358"></a>00358   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; elem_faces = zone_VEF.<a class="code" href="classZone__VF.html#a067e462dcd3ab92b0f6d945b19e4eb37" title="renvoie le numero de le ieme face de la maille num_elem la facon dont ces faces sont numerotees est l...">elem_faces</a>();
<a name="l00359"></a>00359   <span class="keyword">const</span> <a class="code" href="classDomaine.html" title="Classe Domaine Un Domaine represente le domaine (spatial) de resolution d&#39;un Probleme. Un Domaine a un Nom, il est constitue d&#39;une ou plusieurs Zone qui peuvent etre eventuellement decoupees en Sous_Zone. Un Domaine porte l&#39;ensemble des sommets utilises par ses Zones. On peut vouloir resoudre des problemes de type different sur plusieurs domaines, geometriquement les domaines sont alors couples par des surfaces qu&#39;on appelle Raccord.">Domaine</a>&amp; dom=zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#a379ad2206b5a13a4f4f3df6d44c7546a" title="Renvoie le domaine dont la zone fait partie. (version const)">domaine</a>();
<a name="l00360"></a>00360   <span class="keywordtype">int</span> i,j,k;
<a name="l00361"></a>00361   <span class="keywordflow">for</span>(i=0; i&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>; i++)
<a name="l00362"></a>00362     sommets(i)=dom.<a class="code" href="classDomaine.html#a37cc657f1907d53b0d5a573da862af80">get_renum_som_perio</a>(face_som(face,i));
<a name="l00363"></a>00363   <span class="keywordflow">if</span>(elem1!=-1)
<a name="l00364"></a>00364     {
<a name="l00365"></a>00365       <span class="keywordtype">int</span> ok=0;
<a name="l00366"></a>00366       <span class="keywordflow">for</span>(i=0; i&lt;dplusun; i++)
<a name="l00367"></a>00367         <span class="keywordflow">if</span>( (elem_faces(elem1,i)==face) ||
<a name="l00368"></a>00368             (elem_faces(elem1,i)==<a class="code" href="AssembleurPP1BUtil_8cpp.html#a3e374d53ebc7860e1c2f0b7906f2936d">face_associee</a>) )
<a name="l00369"></a>00369           {
<a name="l00370"></a>00370             sommets(Objet_U::dimension)=
<a name="l00371"></a>00371               dom.<a class="code" href="classDomaine.html#a37cc657f1907d53b0d5a573da862af80">get_renum_som_perio</a>(elem_som(elem1, i));
<a name="l00372"></a>00372             faces_op1(Objet_U::dimension)=face;
<a name="l00373"></a>00373             faces_op2(Objet_U::dimension)=-1;
<a name="l00374"></a>00374             ok=1;
<a name="l00375"></a>00375           }
<a name="l00376"></a>00376         <span class="keywordflow">else</span>
<a name="l00377"></a>00377           {
<a name="l00378"></a>00378             j=dom.<a class="code" href="classDomaine.html#a37cc657f1907d53b0d5a573da862af80">get_renum_som_perio</a>(elem_som(elem1, i));
<a name="l00379"></a>00379             <span class="keywordflow">for</span>(k=0; k&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>; k++)
<a name="l00380"></a>00380               <span class="keywordflow">if</span>(j==sommets(k))
<a name="l00381"></a>00381                 faces_op1(k)=elem_faces(elem1, i);
<a name="l00382"></a>00382           }
<a name="l00383"></a>00383       <span class="keywordflow">if</span> (ok!=1)
<a name="l00384"></a>00384         {
<a name="l00385"></a>00385           <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;The discretization used has a P1 component&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
<a name="l00386"></a>00386           <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;which is not available to deal your mesh.&quot;</span> &lt;&lt; finl;
<a name="l00387"></a>00387           <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;The mesh with this discretization must contain only &quot;</span>;
<a name="l00388"></a>00388           <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; (Objet_U::dimension==2?<span class="stringliteral">&quot;triangles&quot;</span>:<span class="stringliteral">&quot;tetraedras&quot;</span>) &lt;&lt; <span class="stringliteral">&quot;.&quot;</span> &lt;&lt; finl;
<a name="l00389"></a>00389           <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">Process::exit</a>();
<a name="l00390"></a>00390         }
<a name="l00391"></a>00391     }
<a name="l00392"></a>00392   <span class="keywordflow">else</span>
<a name="l00393"></a>00393     {
<a name="l00394"></a>00394       <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;pas prevu ... &quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
<a name="l00395"></a>00395       <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">Process::exit</a>();
<a name="l00396"></a>00396     }
<a name="l00397"></a>00397   <span class="keywordflow">if</span>(elem2!=-1)
<a name="l00398"></a>00398     {
<a name="l00399"></a>00399 <span class="comment">// int ok=0;</span>
<a name="l00400"></a>00400       <span class="keywordflow">for</span>(i=0; i&lt;dplusun; i++)
<a name="l00401"></a>00401         <span class="keywordflow">if</span>( (elem_faces(elem2,i)==face)||
<a name="l00402"></a>00402             (elem_faces(elem2,i)==<a class="code" href="AssembleurPP1BUtil_8cpp.html#a3e374d53ebc7860e1c2f0b7906f2936d">face_associee</a>) )
<a name="l00403"></a>00403           {
<a name="l00404"></a>00404             sommets(dplusun)=dom.<a class="code" href="classDomaine.html#a37cc657f1907d53b0d5a573da862af80">get_renum_som_perio</a>(elem_som(elem2, i));
<a name="l00405"></a>00405             faces_op2(dplusun)=face;
<a name="l00406"></a>00406             faces_op1(dplusun)=-1;
<a name="l00407"></a>00407 <span class="comment">// ok=1;</span>
<a name="l00408"></a>00408           }
<a name="l00409"></a>00409         <span class="keywordflow">else</span>
<a name="l00410"></a>00410           {
<a name="l00411"></a>00411             j=dom.<a class="code" href="classDomaine.html#a37cc657f1907d53b0d5a573da862af80">get_renum_som_perio</a>(elem_som(elem2, i));
<a name="l00412"></a>00412             <span class="keywordflow">for</span>(k=0; k&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>; k++)
<a name="l00413"></a>00413               <span class="keywordflow">if</span>(j==sommets(k))
<a name="l00414"></a>00414                 faces_op2(k)=elem_faces(elem2, i);
<a name="l00415"></a>00415           }
<a name="l00416"></a>00416 <span class="comment">// A cause de mise en commentaire de ok=1 assert(ok==1);</span>
<a name="l00417"></a>00417     }
<a name="l00418"></a>00418   <span class="keywordflow">else</span>
<a name="l00419"></a>00419     {
<a name="l00420"></a>00420       sommets(dplusun)=-1;
<a name="l00421"></a>00421       faces_op2(dplusun)=-1;
<a name="l00422"></a>00422       faces_op1(dplusun)=-1;
<a name="l00423"></a>00423     }
<a name="l00424"></a>00424 }
<a name="l00425"></a>00425 
<a name="l00426"></a>00426 <span class="comment">// calcule le gradient a la face separant elem1 et elem2</span>
<a name="l00427"></a>00427 <span class="comment">// de la fonction de forme associee au sommet s</span>
<a name="l00428"></a>00428 <span class="comment">// </span>
<a name="l00429"></a><a class="code" href="AssembleurPP1BUtil_8cpp.html#a556b82e62a565319fb25218f97cfc50c">00429</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="AssembleurPP1BUtil_8cpp.html#a556b82e62a565319fb25218f97cfc50c">calculer_grad</a>(<span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; face_voisins,
<a name="l00430"></a>00430                           <span class="keywordtype">int</span> elem1, <span class="keywordtype">int</span> elem2,
<a name="l00431"></a>00431                           <span class="keyword">const</span> <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a>&amp; coef_som,
<a name="l00432"></a>00432                           <span class="keywordtype">int</span> s, <span class="keywordtype">int</span> fop1, <span class="keywordtype">int</span> fop2,
<a name="l00433"></a>00433                           <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; normales,
<a name="l00434"></a>00434                           <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a>&amp; grad)
<a name="l00435"></a>00435 {
<a name="l00436"></a>00436   <span class="keywordtype">int</span> dimension=<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>;
<a name="l00437"></a>00437   <span class="keywordtype">double</span> signe=1;
<a name="l00438"></a>00438   <span class="keywordflow">if</span>(fop1!=-1)
<a name="l00439"></a>00439     {
<a name="l00440"></a>00440       <span class="keywordflow">if</span>(elem1!=face_voisins(fop1,0))
<a name="l00441"></a>00441         signe=-1;
<a name="l00442"></a>00442       signe*=coef_som[elem1];
<a name="l00443"></a>00443       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> comp=0; comp&lt;dimension; comp++)
<a name="l00444"></a>00444         grad[comp]=signe*normales(fop1,comp);
<a name="l00445"></a>00445     }
<a name="l00446"></a>00446   <span class="keywordflow">else</span>
<a name="l00447"></a>00447     grad=0;
<a name="l00448"></a>00448   <span class="keywordflow">if</span>((elem2!=-1)&amp;&amp;(fop2!=-1))
<a name="l00449"></a>00449     {
<a name="l00450"></a>00450       signe=1;
<a name="l00451"></a>00451       <span class="keywordflow">if</span>(elem2!=face_voisins(fop2,0))
<a name="l00452"></a>00452         signe=-1;
<a name="l00453"></a>00453       signe*=coef_som[elem2];
<a name="l00454"></a>00454       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> comp=0; comp&lt;dimension; comp++)
<a name="l00455"></a>00455         grad[comp]+=signe*normales(fop2,comp);
<a name="l00456"></a>00456     }
<a name="l00457"></a>00457 }
<a name="l00458"></a>00458 
<a name="l00459"></a>00459 <span class="comment">// calcule le gradient a la face separant elem1 et elem2</span>
<a name="l00460"></a>00460 <span class="comment">// de la fonction de forme associee au sommet s</span>
<a name="l00461"></a>00461 <span class="comment">// </span>
<a name="l00462"></a><a class="code" href="AssembleurPP1BUtil_8cpp.html#aa26334c33fd016e71cbab82de7ef2fe5">00462</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="AssembleurPP1BUtil_8cpp.html#aa26334c33fd016e71cbab82de7ef2fe5">calculer_grad_arete</a>(<span class="keywordtype">int</span> face,
<a name="l00463"></a>00463                                 <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; face_voisins,
<a name="l00464"></a>00464                                 <span class="keywordtype">int</span> i, <span class="keywordtype">int</span> j,
<a name="l00465"></a>00465                                 <span class="keywordtype">int</span> elem1, <span class="keywordtype">int</span> elem2,
<a name="l00466"></a>00466                                 <span class="keywordtype">int</span> fop1, <span class="keywordtype">int</span> fop2,
<a name="l00467"></a>00467                                 <span class="keywordtype">int</span> fop3, <span class="keywordtype">int</span> fop4,
<a name="l00468"></a>00468                                 <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; normales,
<a name="l00469"></a>00469                                 <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a>&amp; grad)
<a name="l00470"></a>00470 {
<a name="l00471"></a>00471   assert(face_voisins(face,0)==elem1);
<a name="l00472"></a>00472   <span class="keywordtype">int</span> signe1=1,signe2=1,signe3=1,signe4=1;
<a name="l00473"></a>00473   <span class="keywordflow">if</span>((!(fop1==-1) &amp;&amp; !(face_voisins(fop1,0)==elem1)))
<a name="l00474"></a>00474     signe1=-1;
<a name="l00475"></a>00475   <span class="keywordflow">if</span>(!(fop3==-1) &amp;&amp; !(face_voisins(fop3,0)==elem1))
<a name="l00476"></a>00476     signe3=-1;
<a name="l00477"></a>00477   <span class="keywordflow">if</span>(elem2!=-1)
<a name="l00478"></a>00478     {
<a name="l00479"></a>00479       <span class="keywordflow">if</span>((!(fop2==-1) &amp;&amp; !(face_voisins(fop2,0)==elem2)))
<a name="l00480"></a>00480         signe2=-1;
<a name="l00481"></a>00481       <span class="keywordflow">if</span>(!(fop4==-1) &amp;&amp; !( face_voisins(fop4,0)==elem2))
<a name="l00482"></a>00482         signe4=-1;
<a name="l00483"></a>00483     }
<a name="l00484"></a>00484   <span class="keywordflow">if</span>(j&lt;3) <span class="comment">//!&lt; une arete de la face</span>
<a name="l00485"></a>00485 <span class="comment"></span>    {
<a name="l00486"></a>00486       <span class="keywordflow">if</span>(elem2!=-1)
<a name="l00487"></a>00487         {
<a name="l00488"></a>00488           <span class="keywordflow">for</span>(<span class="keywordtype">int</span> comp=0; comp&lt;3; comp++)
<a name="l00489"></a>00489             grad(comp)=-2./15.*(signe1*normales(fop1,comp)
<a name="l00490"></a>00490                                 +signe2*normales(fop2,comp)
<a name="l00491"></a>00491                                 +signe3*normales(fop3,comp)
<a name="l00492"></a>00492                                 +signe4*normales(fop4,comp));
<a name="l00493"></a>00493         }
<a name="l00494"></a>00494       <span class="keywordflow">else</span>
<a name="l00495"></a>00495         {
<a name="l00496"></a>00496           <span class="keywordflow">for</span>(<span class="keywordtype">int</span> comp=0; comp&lt;3; comp++)
<a name="l00497"></a>00497             grad(comp)=-2./15.*(signe1*normales(fop1,comp)
<a name="l00498"></a>00498                                 +signe3*normales(fop3,comp)
<a name="l00499"></a>00499                                 +normales(face,comp));
<a name="l00500"></a>00500         }
<a name="l00501"></a>00501 
<a name="l00502"></a>00502     }
<a name="l00503"></a>00503   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (j==3) <span class="comment">//!&lt; une arete de elem1 mais pas de face</span>
<a name="l00504"></a>00504 <span class="comment"></span>    {
<a name="l00505"></a>00505       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> comp=0; comp&lt;3; comp++)
<a name="l00506"></a>00506         grad(comp)=1./15.*(signe1*normales(fop1,comp)
<a name="l00507"></a>00507                            +signe3*normales(fop3,comp));
<a name="l00508"></a>00508     }
<a name="l00509"></a>00509   <span class="keywordflow">else</span> <span class="comment">//!&lt; une arete de elem2 mais pas de face</span>
<a name="l00510"></a>00510 <span class="comment"></span>    {
<a name="l00511"></a>00511       assert(j==4);
<a name="l00512"></a>00512       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> comp=0; comp&lt;3; comp++)
<a name="l00513"></a>00513         grad(comp)=1./15.*(signe2*normales(fop2,comp)
<a name="l00514"></a>00514                            +signe4*normales(fop4,comp));
<a name="l00515"></a>00515     }
<a name="l00516"></a>00516 }
<a name="l00517"></a>00517 
<a name="l00518"></a><a class="code" href="AssembleurPP1BUtil_8cpp.html#a828055cfc33e4c56db8e2f5beb059862">00518</a> <span class="keyword">static</span> <span class="keywordtype">double</span> <a class="code" href="AssembleurPP1BUtil_8cpp.html#a828055cfc33e4c56db8e2f5beb059862">dotproduct_array_fois_inverse_quantitee_entrelacee</a>(<span class="keyword">const</span> <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a>&amp; gradi,<span class="keyword">const</span> <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a>&amp; gradE,<span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; inverse_quantitee_entrelacee, <span class="keywordtype">int</span> face )
<a name="l00519"></a>00519 {
<a name="l00520"></a>00520   <span class="keywordtype">double</span> dot=0;
<a name="l00521"></a>00521   <span class="keywordtype">int</span> size=gradi.<a class="code" href="classArrOfDouble.html#a3c3b33bea0e88b87315c21ee94bee05f" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>();
<a name="l00522"></a>00522   assert(size == gradE.<a class="code" href="classArrOfDouble.html#a3c3b33bea0e88b87315c21ee94bee05f" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>());
<a name="l00523"></a>00523   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;size; i++) dot+=gradi(i)*gradE(i)*inverse_quantitee_entrelacee(face,i);
<a name="l00524"></a>00524   <span class="keywordflow">return</span> dot;
<a name="l00525"></a>00525   <span class="keywordflow">return</span>  <a class="code" href="ArrOfDouble_8cpp.html#af541bfdadae7483016c96f13760598ac" title="Produit scalaire de deux &quot;array&quot;. (dotproduct_array remplace operator* car le nom indique clairemen...">dotproduct_array</a>(gradi,gradE)*inverse_quantitee_entrelacee(face,0);
<a name="l00526"></a>00526 }
<a name="l00527"></a>00527 
<a name="l00528"></a><a class="code" href="AssembleurPP1BUtil_8cpp.html#ae2056e931f2d24d03da578b6af30cd54">00528</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="AssembleurPP1BUtil_8cpp.html#ae2056e931f2d24d03da578b6af30cd54">contribuer_matriceP0P1</a>(<span class="keyword">const</span> <a class="code" href="classZone__VEF.html" title="class Zone_VEF Classe instanciable qui derive de Zone_VF. Cette classe contient les informations geom...">Zone_VEF</a>&amp; zone_VEF,
<a name="l00529"></a>00529                                    <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; inverse_quantitee_entrelacee,
<a name="l00530"></a>00530                                    <span class="keywordtype">int</span> face, <span class="keywordtype">int</span> elem1, <span class="keywordtype">int</span> elem2,
<a name="l00531"></a>00531                                    <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; sommets, <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; faces_op1,
<a name="l00532"></a>00532                                    <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; faces_op2,
<a name="l00533"></a>00533                                    <span class="keyword">const</span> <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a>&amp; coef_som,
<a name="l00534"></a>00534                                    <a class="code" href="classIntLists.html" title="Un tableau de listes de type IntList.">IntLists</a>&amp; voisins, <a class="code" href="classDoubleLists.html" title="Un tableau de listes de type DoubleList.">DoubleLists</a>&amp; coeffs,
<a name="l00535"></a>00535                                    <span class="keywordtype">int</span>&amp; nnz)
<a name="l00536"></a>00536 {
<a name="l00537"></a>00537   <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; normales = zone_VEF.<a class="code" href="classZone__VEF.html#a5742d75972e4846bf9fbb6ed5715053e">face_normales</a>();
<a name="l00538"></a>00538   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; face_voisins = zone_VEF.<a class="code" href="classZone__VF.html#a49d4322f5585a8fa95748ca785b70702" title="renvoie l&#39;element voisin de numface dans la direction i. i=0 : dans le sens oppose de l&#39;axe orthogona...">face_voisins</a>();
<a name="l00539"></a>00539   assert(elem1==face_voisins(face, 0));
<a name="l00540"></a>00540   assert(elem2==face_voisins(face, 1));
<a name="l00541"></a>00541 
<a name="l00542"></a>00542   <span class="keywordtype">int</span> dimension=<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>,
<a name="l00543"></a>00543       dplusdeux=dimension+2;
<a name="l00544"></a>00544   <span class="keywordtype">double</span> psc;
<a name="l00545"></a>00545 <span class="comment">// double coeff_som=1./(dimension)/(dimension+1);</span>
<a name="l00546"></a>00546 
<a name="l00547"></a>00547   <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a> gradi(dimension);
<a name="l00548"></a>00548   <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a> gradE(dimension);
<a name="l00549"></a>00549 
<a name="l00550"></a>00550   <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;dplusdeux; i++)
<a name="l00551"></a>00551     {
<a name="l00552"></a>00552       <span class="keywordtype">int</span> si=sommets(i);
<a name="l00553"></a>00553       <span class="keywordflow">if</span> (si&lt;0) <span class="keywordflow">break</span>;
<a name="l00554"></a>00554       <a class="code" href="AssembleurPP1BUtil_8cpp.html#a556b82e62a565319fb25218f97cfc50c">calculer_grad</a>(face_voisins, elem1, elem2,coef_som, si, faces_op1(i),
<a name="l00555"></a>00555                     faces_op2(i), normales, gradi);
<a name="l00556"></a>00556       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> k=0; k&lt;dimension; k++)
<a name="l00557"></a>00557         gradE(k)=normales(face,k);
<a name="l00558"></a>00558       psc=<a class="code" href="AssembleurPP1BUtil_8cpp.html#a828055cfc33e4c56db8e2f5beb059862">dotproduct_array_fois_inverse_quantitee_entrelacee</a>(gradi,gradE,
<a name="l00559"></a>00559                                                              inverse_quantitee_entrelacee,face);
<a name="l00560"></a>00560       <span class="keywordtype">int</span> rang1=voisins[elem1].rang(si);
<a name="l00561"></a>00561       <span class="keywordflow">if</span>(rang1==-1)
<a name="l00562"></a>00562         {
<a name="l00563"></a>00563           voisins[elem1].add(si);
<a name="l00564"></a>00564           coeffs[elem1].add(psc);
<a name="l00565"></a>00565           nnz++;
<a name="l00566"></a>00566         }
<a name="l00567"></a>00567       <span class="keywordflow">else</span>
<a name="l00568"></a>00568         {
<a name="l00569"></a>00569           coeffs[elem1][rang1]+=psc;
<a name="l00570"></a>00570         }
<a name="l00571"></a>00571       <span class="keywordflow">if</span> (elem2!=-1)
<a name="l00572"></a>00572         {
<a name="l00573"></a>00573           <span class="keywordtype">int</span> rang2=voisins[elem2].rang(si);
<a name="l00574"></a>00574           psc*=-1;
<a name="l00575"></a>00575           <span class="keywordflow">if</span>(rang2==-1)
<a name="l00576"></a>00576             {
<a name="l00577"></a>00577               voisins[elem2].add(si);
<a name="l00578"></a>00578               coeffs[elem2].add(psc);
<a name="l00579"></a>00579               nnz++;
<a name="l00580"></a>00580             }
<a name="l00581"></a>00581           <span class="keywordflow">else</span>
<a name="l00582"></a>00582             {
<a name="l00583"></a>00583               coeffs[elem2][rang2]+=psc;
<a name="l00584"></a>00584             }
<a name="l00585"></a>00585         }
<a name="l00586"></a>00586     }
<a name="l00587"></a>00587 }
<a name="l00588"></a><a class="code" href="AssembleurPP1BUtil_8cpp.html#ab68e858c58953d7d372ea8deee92fc6a">00588</a> <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="Assembleur__P__VEFPreP1B_8cpp.html#a1ba6a21d7cd10f7974541a879696c5db">range</a>(<span class="keywordtype">int</span>&amp; i, <span class="keywordtype">int</span>&amp; n, <span class="keywordtype">int</span>&amp; j, <span class="keywordtype">int</span>&amp; m, <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; ARR, <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; ARV, <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; AVR, <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; AVV, <span class="keywordtype">double</span> <a class="code" href="Champ__P1iP1B__implementation_8cpp.html#aa8c8f49390c3cf7c702d71a71bc977e3">coeff</a>)
<a name="l00589"></a>00589 {
<a name="l00590"></a>00590   <span class="keywordflow">if</span>(i&lt;n)
<a name="l00591"></a>00591     <span class="keywordflow">if</span>(j&lt;m)
<a name="l00592"></a>00592       ARR(i,j)+=<a class="code" href="Champ__P1iP1B__implementation_8cpp.html#aa8c8f49390c3cf7c702d71a71bc977e3">coeff</a>;
<a name="l00593"></a>00593     <span class="keywordflow">else</span>
<a name="l00594"></a>00594       ARV(i,j-m)+=<a class="code" href="Champ__P1iP1B__implementation_8cpp.html#aa8c8f49390c3cf7c702d71a71bc977e3">coeff</a>;
<a name="l00595"></a>00595   <span class="keywordflow">else</span> <span class="keywordflow">if</span>(j&lt;m)
<a name="l00596"></a>00596     AVR(i-n,j)+=<a class="code" href="Champ__P1iP1B__implementation_8cpp.html#aa8c8f49390c3cf7c702d71a71bc977e3">coeff</a>;
<a name="l00597"></a>00597   <span class="keywordflow">else</span>
<a name="l00598"></a>00598     AVV(i-n,j-m)+=<a class="code" href="Champ__P1iP1B__implementation_8cpp.html#aa8c8f49390c3cf7c702d71a71bc977e3">coeff</a>;
<a name="l00599"></a>00599 }
<a name="l00600"></a><a class="code" href="AssembleurPP1BUtil_8cpp.html#aa7aef5562f5fe1f2d5b1eeb6664bca53">00600</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="AssembleurPP1BUtil_8cpp.html#aa7aef5562f5fe1f2d5b1eeb6664bca53">update_matriceP0P1</a>(<span class="keyword">const</span> <a class="code" href="classZone__VEF.html" title="class Zone_VEF Classe instanciable qui derive de Zone_VF. Cette classe contient les informations geom...">Zone_VEF</a>&amp; zone_VEF,
<a name="l00601"></a>00601                                <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; inverse_quantitee_entrelacee,
<a name="l00602"></a>00602                                <span class="keywordtype">int</span> face, <span class="keywordtype">int</span> elem1, <span class="keywordtype">int</span> elem2,
<a name="l00603"></a>00603                                <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; sommets, <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; faces_op1,
<a name="l00604"></a>00604                                <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; faces_op2,           <span class="keyword">const</span> <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a>&amp; coef_som,
<a name="l00605"></a>00605                                <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; ARR, <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; ARV,
<a name="l00606"></a>00606                                <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; AVR, <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; AVV)
<a name="l00607"></a>00607 {
<a name="l00608"></a>00608   <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; normales = zone_VEF.<a class="code" href="classZone__VEF.html#a5742d75972e4846bf9fbb6ed5715053e">face_normales</a>();
<a name="l00609"></a>00609   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; face_voisins = zone_VEF.<a class="code" href="classZone__VF.html#a49d4322f5585a8fa95748ca785b70702" title="renvoie l&#39;element voisin de numface dans la direction i. i=0 : dans le sens oppose de l&#39;axe orthogona...">face_voisins</a>();
<a name="l00610"></a>00610   assert(elem1==face_voisins(face, 0));
<a name="l00611"></a>00611   assert(elem2==face_voisins(face, 1));
<a name="l00612"></a>00612 
<a name="l00613"></a>00613   <span class="keywordtype">int</span> dimension=<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>,
<a name="l00614"></a>00614       dplusdeux=dimension+2;
<a name="l00615"></a>00615   <span class="keywordtype">double</span> psc;
<a name="l00616"></a>00616 <span class="comment">// double coeff_som=1./(dimension)/(dimension+1);</span>
<a name="l00617"></a>00617   <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a> gradi(dimension);
<a name="l00618"></a>00618   <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a> gradE(dimension);
<a name="l00619"></a>00619 
<a name="l00620"></a>00620   <span class="keywordtype">int</span> nb_elem=zone_VEF.<a class="code" href="classZone__dis__base.html#a790cb2f6bc2928518799e748313d0eb3">nb_elem</a>();
<a name="l00621"></a>00621   <span class="keywordtype">int</span> nb_som=zone_VEF.<a class="code" href="classZone__dis__base.html#acc9921d6a29cb719fd832fd573e47825">nb_som</a>();
<a name="l00622"></a>00622   <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;dplusdeux; i++)
<a name="l00623"></a>00623     {
<a name="l00624"></a>00624       <span class="keywordtype">int</span> si=sommets(i);
<a name="l00625"></a>00625       <span class="keywordflow">if</span> (si&lt;0) <span class="keywordflow">break</span>;
<a name="l00626"></a>00626       <a class="code" href="AssembleurPP1BUtil_8cpp.html#a556b82e62a565319fb25218f97cfc50c">calculer_grad</a>(face_voisins, elem1, elem2, coef_som,si, faces_op1(i),
<a name="l00627"></a>00627                     faces_op2(i), normales, gradi);
<a name="l00628"></a>00628       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> k=0; k&lt;dimension; k++)
<a name="l00629"></a>00629         gradE(k)=normales(face,k);
<a name="l00630"></a>00630       psc=<a class="code" href="AssembleurPP1BUtil_8cpp.html#a828055cfc33e4c56db8e2f5beb059862">dotproduct_array_fois_inverse_quantitee_entrelacee</a>(gradi,gradE,
<a name="l00631"></a>00631                                                              inverse_quantitee_entrelacee,face);
<a name="l00632"></a>00632       <a class="code" href="Assembleur__P__VEFPreP1B_8cpp.html#a1ba6a21d7cd10f7974541a879696c5db">range</a>(elem1,nb_elem,si,nb_som,ARR,ARV,AVR,AVV,psc);
<a name="l00633"></a>00633       <span class="keywordflow">if</span> (elem2!=-1)
<a name="l00634"></a>00634         <a class="code" href="Assembleur__P__VEFPreP1B_8cpp.html#a1ba6a21d7cd10f7974541a879696c5db">range</a>(elem2,nb_elem,si,nb_som,ARR,ARV,AVR,AVV,-psc);
<a name="l00635"></a>00635     }
<a name="l00636"></a>00636 }
<a name="l00637"></a>00637 
<a name="l00638"></a><a class="code" href="AssembleurPP1BUtil_8cpp.html#ae9226a0247d37eab885c3915814c82c7">00638</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="AssembleurPP1BUtil_8cpp.html#ae9226a0247d37eab885c3915814c82c7">contribuer_matriceP1P1</a>(<span class="keyword">const</span> <a class="code" href="classZone__VEF.html" title="class Zone_VEF Classe instanciable qui derive de Zone_VF. Cette classe contient les informations geom...">Zone_VEF</a>&amp; zone_VEF,
<a name="l00639"></a>00639                                    <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; inverse_quantitee_entrelacee,
<a name="l00640"></a>00640                                    <span class="keywordtype">int</span> face, <span class="keywordtype">int</span> elem1, <span class="keywordtype">int</span> elem2,
<a name="l00641"></a>00641                                    <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; sommets, <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; faces_op1,
<a name="l00642"></a>00642                                    <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; faces_op2,           <span class="keyword">const</span> <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a>&amp; coef_som,
<a name="l00643"></a>00643                                    <a class="code" href="classIntLists.html" title="Un tableau de listes de type IntList.">IntLists</a>&amp; voisins, <a class="code" href="classDoubleLists.html" title="Un tableau de listes de type DoubleList.">DoubleLists</a>&amp; coeffs,
<a name="l00644"></a>00644                                    <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; diag, <span class="keywordtype">int</span>&amp; nnz)
<a name="l00645"></a>00645 {
<a name="l00646"></a>00646   <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; normales = zone_VEF.<a class="code" href="classZone__VEF.html#a5742d75972e4846bf9fbb6ed5715053e">face_normales</a>();
<a name="l00647"></a>00647   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; face_voisins = zone_VEF.<a class="code" href="classZone__VF.html#a49d4322f5585a8fa95748ca785b70702" title="renvoie l&#39;element voisin de numface dans la direction i. i=0 : dans le sens oppose de l&#39;axe orthogona...">face_voisins</a>();
<a name="l00648"></a>00648 
<a name="l00649"></a>00649   <span class="keywordtype">int</span> dimension=<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>,
<a name="l00650"></a>00650       dplusdeux=dimension+2;
<a name="l00651"></a>00651   <span class="keywordtype">double</span> psc;
<a name="l00652"></a>00652 <span class="comment">// double coeff_som=1./(dimension)/(dimension+1);</span>
<a name="l00653"></a>00653 <span class="comment">// coeff_som*=coeff_som;</span>
<a name="l00654"></a>00654   <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a> gradi(dimension);
<a name="l00655"></a>00655   <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a> gradj(dimension);
<a name="l00656"></a>00656   <span class="keywordtype">int</span> i,j;
<a name="l00657"></a>00657 
<a name="l00658"></a>00658 <span class="comment">// On ne traite pas les sommets -1 qui</span>
<a name="l00659"></a>00659 <span class="comment">// sont en fin de tableau sommets:</span>
<a name="l00660"></a>00660   <span class="keywordflow">while</span> (sommets(dplusdeux-1)==-1)
<a name="l00661"></a>00661     dplusdeux--;
<a name="l00662"></a>00662 
<a name="l00663"></a>00663   <span class="keywordflow">for</span>(i=0; i&lt;dplusdeux; i++)
<a name="l00664"></a>00664     {
<a name="l00665"></a>00665       <span class="keywordtype">int</span> si=sommets(i);
<a name="l00666"></a>00666       <a class="code" href="AssembleurPP1BUtil_8cpp.html#a556b82e62a565319fb25218f97cfc50c">calculer_grad</a>(face_voisins, elem1, elem2,  coef_som,si, faces_op1(i),
<a name="l00667"></a>00667                     faces_op2(i), normales, gradi);
<a name="l00668"></a>00668       diag[si]+=<a class="code" href="AssembleurPP1BUtil_8cpp.html#a828055cfc33e4c56db8e2f5beb059862">dotproduct_array_fois_inverse_quantitee_entrelacee</a>(gradi,gradi,
<a name="l00669"></a>00669                                                                    inverse_quantitee_entrelacee,face);
<a name="l00670"></a>00670       <span class="keywordflow">for</span>(j=i+1; j&lt;dplusdeux; j++)
<a name="l00671"></a>00671         {
<a name="l00672"></a>00672           <span class="keywordtype">int</span> sj=sommets(j);
<a name="l00673"></a>00673           <a class="code" href="AssembleurPP1BUtil_8cpp.html#a556b82e62a565319fb25218f97cfc50c">calculer_grad</a>(face_voisins, elem1, elem2,  coef_som,sj, faces_op1(j),
<a name="l00674"></a>00674                         faces_op2(j), normales, gradj);
<a name="l00675"></a>00675           psc=<a class="code" href="AssembleurPP1BUtil_8cpp.html#a828055cfc33e4c56db8e2f5beb059862">dotproduct_array_fois_inverse_quantitee_entrelacee</a>(gradi,gradj,inverse_quantitee_entrelacee,face);
<a name="l00676"></a>00676           <span class="keywordtype">int</span> rang=voisins[si].rang(sj);
<a name="l00677"></a>00677           <span class="keywordflow">if</span> (sj&gt;si)
<a name="l00678"></a>00678             {
<a name="l00679"></a>00679               <span class="keywordflow">if</span>(rang==-1)
<a name="l00680"></a>00680                 {
<a name="l00681"></a>00681                   voisins[si].add(sj);
<a name="l00682"></a>00682                   coeffs[si].add(psc);
<a name="l00683"></a>00683                   nnz++;
<a name="l00684"></a>00684                 }
<a name="l00685"></a>00685               <span class="keywordflow">else</span>
<a name="l00686"></a>00686                 {
<a name="l00687"></a>00687                   coeffs[si][rang]+=psc;
<a name="l00688"></a>00688                 }
<a name="l00689"></a>00689             }
<a name="l00690"></a>00690         }
<a name="l00691"></a>00691     }
<a name="l00692"></a>00692 }
<a name="l00693"></a>00693 
<a name="l00694"></a><a class="code" href="AssembleurPP1BUtil_8cpp.html#a77351839245012751e4d90a39922356a">00694</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="AssembleurPP1BUtil_8cpp.html#a77351839245012751e4d90a39922356a">update_matriceP1P1</a>(<span class="keyword">const</span> <a class="code" href="classZone__VEF.html" title="class Zone_VEF Classe instanciable qui derive de Zone_VF. Cette classe contient les informations geom...">Zone_VEF</a>&amp; zone_VEF,
<a name="l00695"></a>00695                                <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; inverse_quantitee_entrelacee,
<a name="l00696"></a>00696                                <span class="keywordtype">int</span> face, <span class="keywordtype">int</span> elem1, <span class="keywordtype">int</span> elem2,
<a name="l00697"></a>00697                                <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; sommets, <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; faces_op1,
<a name="l00698"></a>00698                                <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; faces_op2,           <span class="keyword">const</span> <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a>&amp; coef_som,
<a name="l00699"></a>00699                                <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; ARR, <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; ARV,
<a name="l00700"></a>00700                                <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; AVR, <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; AVV)
<a name="l00701"></a>00701 {
<a name="l00702"></a>00702   <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; normales = zone_VEF.<a class="code" href="classZone__VEF.html#a5742d75972e4846bf9fbb6ed5715053e">face_normales</a>();
<a name="l00703"></a>00703   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; face_voisins = zone_VEF.<a class="code" href="classZone__VF.html#a49d4322f5585a8fa95748ca785b70702" title="renvoie l&#39;element voisin de numface dans la direction i. i=0 : dans le sens oppose de l&#39;axe orthogona...">face_voisins</a>();
<a name="l00704"></a>00704 
<a name="l00705"></a>00705   <span class="keywordtype">int</span> dimension=<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>,
<a name="l00706"></a>00706       dplusdeux=dimension+2;
<a name="l00707"></a>00707   <span class="keywordtype">double</span> psc;
<a name="l00708"></a>00708 <span class="comment">// double coeff_som=1./(dimension)/(dimension+1);</span>
<a name="l00709"></a>00709 <span class="comment">// coeff_som*=coeff_som;</span>
<a name="l00710"></a>00710   <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a> gradi(dimension);
<a name="l00711"></a>00711   <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a> gradj(dimension);
<a name="l00712"></a>00712   <span class="keywordtype">int</span> nb_som_tot=zone_VEF.<a class="code" href="classZone__dis__base.html#acc9921d6a29cb719fd832fd573e47825">nb_som</a>();
<a name="l00713"></a>00713   <span class="keywordtype">int</span> i,j;
<a name="l00714"></a>00714 
<a name="l00715"></a>00715 <span class="comment">// On ne traite pas les sommets -1 qui</span>
<a name="l00716"></a>00716 <span class="comment">// sont en fin de tableau sommets:</span>
<a name="l00717"></a>00717   <span class="keywordflow">while</span> (sommets(dplusdeux-1)==-1)
<a name="l00718"></a>00718     dplusdeux--;
<a name="l00719"></a>00719 
<a name="l00720"></a>00720   <span class="keywordflow">for</span>(i=0; i&lt;dplusdeux; i++)
<a name="l00721"></a>00721     {
<a name="l00722"></a>00722       <span class="keywordtype">int</span> si=sommets(i);
<a name="l00723"></a>00723       <a class="code" href="AssembleurPP1BUtil_8cpp.html#a556b82e62a565319fb25218f97cfc50c">calculer_grad</a>(face_voisins, elem1, elem2, coef_som,si, faces_op1(i),
<a name="l00724"></a>00724                     faces_op2(i), normales, gradi);
<a name="l00725"></a>00725       <span class="keywordflow">if</span>(si&lt;nb_som_tot)
<a name="l00726"></a>00726         ARR(si,si)+=<a class="code" href="AssembleurPP1BUtil_8cpp.html#a828055cfc33e4c56db8e2f5beb059862">dotproduct_array_fois_inverse_quantitee_entrelacee</a>(gradi,gradi,
<a name="l00727"></a>00727                                                                        inverse_quantitee_entrelacee,face);
<a name="l00728"></a>00728       <span class="keywordflow">for</span>(j=i+1; j&lt;dplusdeux; j++)
<a name="l00729"></a>00729         {
<a name="l00730"></a>00730           <span class="keywordtype">int</span> sj=sommets(j);
<a name="l00731"></a>00731           <a class="code" href="AssembleurPP1BUtil_8cpp.html#a556b82e62a565319fb25218f97cfc50c">calculer_grad</a>(face_voisins, elem1, elem2,coef_som, sj, faces_op1(j),
<a name="l00732"></a>00732                         faces_op2(j), normales, gradj);
<a name="l00733"></a>00733           psc=<a class="code" href="AssembleurPP1BUtil_8cpp.html#a828055cfc33e4c56db8e2f5beb059862">dotproduct_array_fois_inverse_quantitee_entrelacee</a>(gradi,gradj,inverse_quantitee_entrelacee,face);
<a name="l00734"></a>00734 <span class="comment">// assert(sj&gt;si);</span>
<a name="l00735"></a>00735           <span class="keywordflow">if</span>(si&lt;nb_som_tot)
<a name="l00736"></a>00736             <span class="keywordflow">if</span>(sj&lt;nb_som_tot)
<a name="l00737"></a>00737               ARR(si,sj)+=psc;
<a name="l00738"></a>00738             <span class="keywordflow">else</span>
<a name="l00739"></a>00739               ARV(si,sj-nb_som_tot)+=psc;
<a name="l00740"></a>00740           <span class="keywordflow">else</span> <span class="keywordflow">if</span>(sj&lt;nb_som_tot)
<a name="l00741"></a>00741             AVR(si-nb_som_tot,sj)+=psc;
<a name="l00742"></a>00742           <span class="keywordflow">else</span>
<a name="l00743"></a>00743             AVV(si-nb_som_tot,sj-nb_som_tot)+=psc;
<a name="l00744"></a>00744         }
<a name="l00745"></a>00745     }
<a name="l00746"></a>00746 }
<a name="l00747"></a>00747 
<a name="l00748"></a><a class="code" href="AssembleurPP1BUtil_8cpp.html#a59992a437cf7e18b4b9ce353d77d0bda">00748</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="AssembleurPP1BUtil_8cpp.html#a59992a437cf7e18b4b9ce353d77d0bda">contribuer_matricePaPa</a>(<span class="keyword">const</span> <a class="code" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a>&amp; zone_VEF,
<a name="l00749"></a>00749                                    <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; inverse_quantitee_entrelacee,
<a name="l00750"></a>00750                                    <span class="keywordtype">int</span> face, <span class="keywordtype">int</span> elem1, <span class="keywordtype">int</span> elem2,
<a name="l00751"></a>00751                                    <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; sommets, <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; faces_op1,
<a name="l00752"></a>00752                                    <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; faces_op2,
<a name="l00753"></a>00753                                    <a class="code" href="classIntLists.html" title="Un tableau de listes de type IntList.">IntLists</a>&amp; voisins, <a class="code" href="classDoubleLists.html" title="Un tableau de listes de type DoubleList.">DoubleLists</a>&amp; coeffs,
<a name="l00754"></a>00754                                    <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; diag, <span class="keywordtype">int</span>&amp; nnz)
<a name="l00755"></a>00755 {
<a name="l00756"></a>00756   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; elem_aretes=zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#a1e1e86ef5b088c4d33d42cd38a967b4a" title="renvoie le numero de la jeme arete du ieme element.">elem_aretes</a>();
<a name="l00757"></a>00757   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; aretes_som=zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#affa60690e1b372fa4c01d6088267dbe4" title="renvoie le tableau de connectivite aretes/sommets.">aretes_som</a>();
<a name="l00758"></a>00758   <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; ok_arete=zone_VEF.<a class="code" href="classZone__VEF__PreP1b.html#a83771f784d487e346b2ef22a389472a2">get_ok_arete</a>();
<a name="l00759"></a>00759   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; face_voisins=zone_VEF.<a class="code" href="classZone__VF.html#a49d4322f5585a8fa95748ca785b70702" title="renvoie l&#39;element voisin de numface dans la direction i. i=0 : dans le sens oppose de l&#39;axe orthogona...">face_voisins</a>();
<a name="l00760"></a>00760   <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; normales = zone_VEF.<a class="code" href="classZone__VEF.html#a5742d75972e4846bf9fbb6ed5715053e">face_normales</a>();
<a name="l00761"></a>00761   <span class="keywordtype">int</span> i, j, k, l;
<a name="l00762"></a>00762   <span class="keywordtype">double</span> psc;
<a name="l00763"></a>00763 <span class="comment">// On ne traite pas les sommets -1 qui</span>
<a name="l00764"></a>00764 <span class="comment">// sont en fin de tableau sommets:</span>
<a name="l00765"></a>00765 <span class="comment">// while (sommets(dplusdeux-1)==-1)</span>
<a name="l00766"></a>00766 <span class="comment">// dplusdeux--;</span>
<a name="l00767"></a>00767 
<a name="l00768"></a>00768   <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a> grad1(3);
<a name="l00769"></a>00769   <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a> grad2(3);
<a name="l00770"></a>00770   <span class="keywordtype">int</span> jmax=5;
<a name="l00771"></a>00771   <span class="keywordflow">if</span>(elem2==-1) jmax=4;
<a name="l00772"></a>00772   <span class="keywordflow">for</span>(i=0; i&lt;3; i++)
<a name="l00773"></a>00773     {
<a name="l00774"></a>00774       <span class="keywordtype">int</span> si=sommets(i);
<a name="l00775"></a>00775       <span class="keywordflow">for</span>(j=i+1; j&lt;jmax; j++)
<a name="l00776"></a>00776         {
<a name="l00777"></a>00777           <span class="keywordtype">int</span> sj=sommets(j);
<a name="l00778"></a>00778           <span class="keywordtype">int</span> arete1;
<a name="l00779"></a>00779           <span class="keywordflow">if</span>(j&lt;4)
<a name="l00780"></a>00780             arete1 = <a class="code" href="AssembleurPP1BUtil_8cpp.html#ae1c00f10faaf4da3ffdea8f881565a1b">chercher_arete</a>(zone_VEF,elem1, si, sj,
<a name="l00781"></a>00781                                     elem_aretes, aretes_som);
<a name="l00782"></a>00782           <span class="keywordflow">else</span>
<a name="l00783"></a>00783             arete1 = <a class="code" href="AssembleurPP1BUtil_8cpp.html#ae1c00f10faaf4da3ffdea8f881565a1b">chercher_arete</a>(zone_VEF,elem2, si, sj,
<a name="l00784"></a>00784                                     elem_aretes, aretes_som);
<a name="l00785"></a>00785           assert(arete1!=-1);
<a name="l00786"></a>00786           <span class="keywordflow">if</span>(ok_arete(arete1))
<a name="l00787"></a>00787             {
<a name="l00788"></a>00788               <a class="code" href="AssembleurPP1BUtil_8cpp.html#aa26334c33fd016e71cbab82de7ef2fe5">calculer_grad_arete</a>(face, face_voisins, i, j,
<a name="l00789"></a>00789                                   elem1, elem2,
<a name="l00790"></a>00790                                   faces_op1(i), faces_op2(i),
<a name="l00791"></a>00791                                   faces_op1(j), faces_op2(j),
<a name="l00792"></a>00792                                   normales, grad1);
<a name="l00793"></a>00793               diag[arete1]+=<a class="code" href="AssembleurPP1BUtil_8cpp.html#a828055cfc33e4c56db8e2f5beb059862">dotproduct_array_fois_inverse_quantitee_entrelacee</a>(grad1,grad1,
<a name="l00794"></a>00794                                                                                inverse_quantitee_entrelacee,face);
<a name="l00795"></a>00795               <span class="keywordtype">int</span> jj=j;
<a name="l00796"></a>00796               <span class="keywordflow">for</span>(k=i; k&lt;3; k++)
<a name="l00797"></a>00797                 {
<a name="l00798"></a>00798                   <span class="keywordtype">int</span> sk=sommets(k);
<a name="l00799"></a>00799                   <span class="keywordflow">for</span>(l=jj+1; l&lt;jmax; l++)
<a name="l00800"></a>00800                     {
<a name="l00801"></a>00801                       <span class="keywordtype">int</span> sl=sommets(l);
<a name="l00802"></a>00802                       <span class="keywordtype">int</span> arete2;
<a name="l00803"></a>00803                       <span class="keywordflow">if</span>(l&lt;4)
<a name="l00804"></a>00804                         arete2 = <a class="code" href="AssembleurPP1BUtil_8cpp.html#ae1c00f10faaf4da3ffdea8f881565a1b">chercher_arete</a>(zone_VEF,elem1, sl, sk,
<a name="l00805"></a>00805                                                 elem_aretes,
<a name="l00806"></a>00806                                                 aretes_som);
<a name="l00807"></a>00807                       <span class="keywordflow">else</span>
<a name="l00808"></a>00808                         arete2 = <a class="code" href="AssembleurPP1BUtil_8cpp.html#ae1c00f10faaf4da3ffdea8f881565a1b">chercher_arete</a>(zone_VEF,elem2, sl, sk,
<a name="l00809"></a>00809                                                 elem_aretes,
<a name="l00810"></a>00810                                                 aretes_som);
<a name="l00811"></a>00811                       assert(arete2!=-1);
<a name="l00812"></a>00812                       <span class="keywordflow">if</span>(ok_arete(arete2))
<a name="l00813"></a>00813                         {
<a name="l00814"></a>00814                           <a class="code" href="AssembleurPP1BUtil_8cpp.html#aa26334c33fd016e71cbab82de7ef2fe5">calculer_grad_arete</a>(face, face_voisins, k, l,
<a name="l00815"></a>00815                                               elem1, elem2,
<a name="l00816"></a>00816                                               faces_op1(k), faces_op2(k),
<a name="l00817"></a>00817                                               faces_op1(l), faces_op2(l),
<a name="l00818"></a>00818                                               normales, grad2);
<a name="l00819"></a>00819                           psc=<a class="code" href="AssembleurPP1BUtil_8cpp.html#a828055cfc33e4c56db8e2f5beb059862">dotproduct_array_fois_inverse_quantitee_entrelacee</a>(grad1,grad2,
<a name="l00820"></a>00820                                                                                  inverse_quantitee_entrelacee,face);
<a name="l00821"></a>00821                           <span class="keywordtype">int</span> tmp=arete1;
<a name="l00822"></a>00822                           <span class="keywordflow">if</span>(arete1&gt;arete2) <a class="code" href="AssembleurPP1BUtil_8cpp.html#a3117b050530c46b4a15b6ab9ce6d0b41">swap</a>(arete1, arete2);
<a name="l00823"></a>00823                           <span class="keywordtype">int</span> rang=voisins[arete1].rang(arete2);
<a name="l00824"></a>00824                           <span class="keywordflow">if</span>(rang==-1)
<a name="l00825"></a>00825                             {
<a name="l00826"></a>00826                               voisins[arete1].add(arete2);
<a name="l00827"></a>00827                               coeffs[arete1].add(psc);
<a name="l00828"></a>00828                               nnz++;
<a name="l00829"></a>00829                             }
<a name="l00830"></a>00830                           <span class="keywordflow">else</span>
<a name="l00831"></a>00831                             {
<a name="l00832"></a>00832                               coeffs[arete1][rang]+=psc;
<a name="l00833"></a>00833                             }
<a name="l00834"></a>00834                           arete1=tmp;
<a name="l00835"></a>00835                         }
<a name="l00836"></a>00836                     }
<a name="l00837"></a>00837                   jj=k+1;
<a name="l00838"></a>00838                 }
<a name="l00839"></a>00839             }
<a name="l00840"></a>00840         }
<a name="l00841"></a>00841     }
<a name="l00842"></a>00842 }
<a name="l00843"></a><a class="code" href="AssembleurPP1BUtil_8cpp.html#a76d676949fb80bc3c7f1ab5f7f8078c0">00843</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="AssembleurPP1BUtil_8cpp.html#a76d676949fb80bc3c7f1ab5f7f8078c0">update_matricePaPa</a>(<span class="keyword">const</span> <a class="code" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a>&amp; zone_VEF,
<a name="l00844"></a>00844                                <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; inverse_quantitee_entrelacee,
<a name="l00845"></a>00845                                <span class="keywordtype">int</span> face, <span class="keywordtype">int</span> elem1, <span class="keywordtype">int</span> elem2,
<a name="l00846"></a>00846                                <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; sommets, <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; faces_op1,
<a name="l00847"></a>00847                                <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; faces_op2,
<a name="l00848"></a>00848                                <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; ARR, <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; ARV,
<a name="l00849"></a>00849                                <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; AVR, <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; AVV)
<a name="l00850"></a>00850 {
<a name="l00851"></a>00851   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; elem_aretes=zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#a1e1e86ef5b088c4d33d42cd38a967b4a" title="renvoie le numero de la jeme arete du ieme element.">elem_aretes</a>();
<a name="l00852"></a>00852   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; aretes_som=zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#affa60690e1b372fa4c01d6088267dbe4" title="renvoie le tableau de connectivite aretes/sommets.">aretes_som</a>();
<a name="l00853"></a>00853   <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; ok_arete=zone_VEF.<a class="code" href="classZone__VEF__PreP1b.html#a83771f784d487e346b2ef22a389472a2">get_ok_arete</a>();
<a name="l00854"></a>00854   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; face_voisins=zone_VEF.<a class="code" href="classZone__VF.html#a49d4322f5585a8fa95748ca785b70702" title="renvoie l&#39;element voisin de numface dans la direction i. i=0 : dans le sens oppose de l&#39;axe orthogona...">face_voisins</a>();
<a name="l00855"></a>00855   <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; normales = zone_VEF.<a class="code" href="classZone__VEF.html#a5742d75972e4846bf9fbb6ed5715053e">face_normales</a>();
<a name="l00856"></a>00856   <span class="keywordtype">int</span> nb_aretes_tot=zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#a3e3b48691911fd85574c7bc10a1a4fb8" title="renvoie le nombre d&#39;aretes reelles.">nb_aretes</a>();
<a name="l00857"></a>00857   <span class="keywordtype">int</span> i, j, k, l;
<a name="l00858"></a>00858   <span class="keywordtype">double</span> psc;
<a name="l00859"></a>00859 <span class="comment">// On ne traite pas les sommets -1 qui</span>
<a name="l00860"></a>00860 <span class="comment">// sont en fin de tableau sommets:</span>
<a name="l00861"></a>00861 <span class="comment">// while (sommets(dplusdeux-1)==-1)</span>
<a name="l00862"></a>00862 <span class="comment">// dplusdeux--;</span>
<a name="l00863"></a>00863 
<a name="l00864"></a>00864   <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a> grad1(3);
<a name="l00865"></a>00865   <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a> grad2(3);
<a name="l00866"></a>00866   <span class="keywordtype">int</span> jmax=5;
<a name="l00867"></a>00867   <span class="keywordflow">if</span>(elem2==-1) jmax=4;
<a name="l00868"></a>00868   <span class="keywordflow">for</span>(i=0; i&lt;3; i++)
<a name="l00869"></a>00869     {
<a name="l00870"></a>00870       <span class="keywordtype">int</span> si=sommets(i);
<a name="l00871"></a>00871       <span class="keywordflow">for</span>(j=i+1; j&lt;jmax; j++)
<a name="l00872"></a>00872         {
<a name="l00873"></a>00873           <span class="keywordtype">int</span> sj=sommets(j);
<a name="l00874"></a>00874           <span class="keywordtype">int</span> arete1;
<a name="l00875"></a>00875           <span class="keywordflow">if</span>(j&lt;4)
<a name="l00876"></a>00876             arete1 = <a class="code" href="AssembleurPP1BUtil_8cpp.html#ae1c00f10faaf4da3ffdea8f881565a1b">chercher_arete</a>(zone_VEF,elem1, si, sj,
<a name="l00877"></a>00877                                     elem_aretes, aretes_som);
<a name="l00878"></a>00878           <span class="keywordflow">else</span>
<a name="l00879"></a>00879             arete1 = <a class="code" href="AssembleurPP1BUtil_8cpp.html#ae1c00f10faaf4da3ffdea8f881565a1b">chercher_arete</a>(zone_VEF,elem2, si, sj,
<a name="l00880"></a>00880                                     elem_aretes, aretes_som);
<a name="l00881"></a>00881           assert(arete1!=-1);
<a name="l00882"></a>00882           <span class="keywordflow">if</span>(ok_arete(arete1))
<a name="l00883"></a>00883             {
<a name="l00884"></a>00884               <a class="code" href="AssembleurPP1BUtil_8cpp.html#aa26334c33fd016e71cbab82de7ef2fe5">calculer_grad_arete</a>(face, face_voisins, i, j,
<a name="l00885"></a>00885                                   elem1, elem2,
<a name="l00886"></a>00886                                   faces_op1(i), faces_op2(i),
<a name="l00887"></a>00887                                   faces_op1(j), faces_op2(j),
<a name="l00888"></a>00888                                   normales, grad1);
<a name="l00889"></a>00889               <span class="keywordflow">if</span>(arete1&lt;nb_aretes_tot)
<a name="l00890"></a>00890                 ARR(arete1,arete1)+=<a class="code" href="AssembleurPP1BUtil_8cpp.html#a828055cfc33e4c56db8e2f5beb059862">dotproduct_array_fois_inverse_quantitee_entrelacee</a>(grad1,grad1,
<a name="l00891"></a>00891                                                                                        inverse_quantitee_entrelacee,face);
<a name="l00892"></a>00892               <span class="keywordtype">int</span> jj=j;
<a name="l00893"></a>00893               <span class="keywordflow">for</span>(k=i; k&lt;3; k++)
<a name="l00894"></a>00894                 {
<a name="l00895"></a>00895                   <span class="keywordtype">int</span> sk=sommets(k);
<a name="l00896"></a>00896                   <span class="keywordflow">for</span>(l=jj+1; l&lt;jmax; l++)
<a name="l00897"></a>00897                     {
<a name="l00898"></a>00898                       <span class="keywordtype">int</span> sl=sommets(l);
<a name="l00899"></a>00899                       <span class="keywordtype">int</span> arete2;
<a name="l00900"></a>00900                       <span class="keywordflow">if</span>(l&lt;4)
<a name="l00901"></a>00901                         arete2 = <a class="code" href="AssembleurPP1BUtil_8cpp.html#ae1c00f10faaf4da3ffdea8f881565a1b">chercher_arete</a>(zone_VEF,elem1, sl, sk,
<a name="l00902"></a>00902                                                 elem_aretes,
<a name="l00903"></a>00903                                                 aretes_som);
<a name="l00904"></a>00904                       <span class="keywordflow">else</span>
<a name="l00905"></a>00905                         arete2 = <a class="code" href="AssembleurPP1BUtil_8cpp.html#ae1c00f10faaf4da3ffdea8f881565a1b">chercher_arete</a>(zone_VEF,elem2, sl, sk,
<a name="l00906"></a>00906                                                 elem_aretes,
<a name="l00907"></a>00907                                                 aretes_som);
<a name="l00908"></a>00908                       assert(arete2!=-1);
<a name="l00909"></a>00909                       <span class="keywordflow">if</span>(ok_arete(arete2))
<a name="l00910"></a>00910                         {
<a name="l00911"></a>00911                           <a class="code" href="AssembleurPP1BUtil_8cpp.html#aa26334c33fd016e71cbab82de7ef2fe5">calculer_grad_arete</a>(face, face_voisins, k, l,
<a name="l00912"></a>00912                                               elem1, elem2,
<a name="l00913"></a>00913                                               faces_op1(k), faces_op2(k),
<a name="l00914"></a>00914                                               faces_op1(l), faces_op2(l),
<a name="l00915"></a>00915                                               normales, grad2);
<a name="l00916"></a>00916                           psc=<a class="code" href="AssembleurPP1BUtil_8cpp.html#a828055cfc33e4c56db8e2f5beb059862">dotproduct_array_fois_inverse_quantitee_entrelacee</a>(grad1,grad2,
<a name="l00917"></a>00917                                                                                  inverse_quantitee_entrelacee,face);
<a name="l00918"></a>00918                           <span class="keywordtype">int</span> tmp=arete1;
<a name="l00919"></a>00919                           <span class="keywordflow">if</span>(arete1&gt;arete2) <a class="code" href="AssembleurPP1BUtil_8cpp.html#a3117b050530c46b4a15b6ab9ce6d0b41">swap</a>(arete1, arete2);
<a name="l00920"></a>00920                           <span class="keywordflow">if</span>(arete1&lt;nb_aretes_tot)
<a name="l00921"></a>00921                             <span class="keywordflow">if</span>(arete2&lt;nb_aretes_tot)
<a name="l00922"></a>00922                               ARR(arete1,arete2)+=psc;
<a name="l00923"></a>00923                             <span class="keywordflow">else</span>
<a name="l00924"></a>00924                               ARV(arete1,arete2-nb_aretes_tot)+=psc;
<a name="l00925"></a>00925                           <span class="keywordflow">else</span> <span class="keywordflow">if</span>(arete2&lt;nb_aretes_tot)
<a name="l00926"></a>00926                             AVR(arete1-nb_aretes_tot,arete2)+=psc;
<a name="l00927"></a>00927                           <span class="keywordflow">else</span>
<a name="l00928"></a>00928                             AVV(arete1-nb_aretes_tot,arete2-nb_aretes_tot)+=psc;
<a name="l00929"></a>00929                           arete1=tmp;
<a name="l00930"></a>00930                         }
<a name="l00931"></a>00931                     }
<a name="l00932"></a>00932                   jj=k+1;
<a name="l00933"></a>00933                 }
<a name="l00934"></a>00934             }
<a name="l00935"></a>00935         }
<a name="l00936"></a>00936     }
<a name="l00937"></a>00937 }
<a name="l00938"></a>00938 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00939"></a><a class="code" href="AssembleurPP1BUtil_8cpp.html#a5e6fc2e2157dce70a345b3d8c1294477">00939</a> <a class="code" href="AssembleurPP1BUtil_8cpp.html#a5e6fc2e2157dce70a345b3d8c1294477">contribuer_matrice_NeumannP0P1</a>(<span class="keyword">const</span> <a class="code" href="classZone__VEF.html" title="class Zone_VEF Classe instanciable qui derive de Zone_VF. Cette classe contient les informations geom...">Zone_VEF</a>&amp; zone_VEF,
<a name="l00940"></a>00940                                <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; inverse_quantitee_entrelacee,
<a name="l00941"></a>00941                                <span class="keywordtype">int</span> face, <span class="keywordtype">int</span> elem,
<a name="l00942"></a>00942                                <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; sommets, <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; faces_op1,   <span class="keyword">const</span> <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a>&amp; coef_som,
<a name="l00943"></a>00943                                <a class="code" href="classIntLists.html" title="Un tableau de listes de type IntList.">IntLists</a>&amp; voisins, <a class="code" href="classDoubleLists.html" title="Un tableau de listes de type DoubleList.">DoubleLists</a>&amp; coeffs,
<a name="l00944"></a>00944                                <span class="keywordtype">int</span>&amp; nnz)
<a name="l00945"></a>00945 {
<a name="l00946"></a>00946   <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; normales = zone_VEF.<a class="code" href="classZone__VEF.html#a5742d75972e4846bf9fbb6ed5715053e">face_normales</a>();
<a name="l00947"></a>00947   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; face_voisins = zone_VEF.<a class="code" href="classZone__VF.html#a49d4322f5585a8fa95748ca785b70702" title="renvoie l&#39;element voisin de numface dans la direction i. i=0 : dans le sens oppose de l&#39;axe orthogona...">face_voisins</a>();
<a name="l00948"></a>00948 
<a name="l00949"></a>00949   <span class="keywordtype">int</span> dimension=<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>,
<a name="l00950"></a>00950       dplusun=dimension+1;
<a name="l00951"></a>00951   <span class="keywordtype">double</span> unsurdim=1./<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>;
<a name="l00952"></a>00952   <span class="keywordtype">double</span> psc;
<a name="l00953"></a>00953 <span class="comment">// double coeff_som=1./(dimension)/(dplusun);</span>
<a name="l00954"></a>00954   <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a> gradi(dimension);
<a name="l00955"></a>00955   <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a> gradE(dimension);
<a name="l00956"></a>00956   <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;dplusun; i++)
<a name="l00957"></a>00957     {
<a name="l00958"></a>00958       <span class="keywordtype">int</span> si=sommets(i);
<a name="l00959"></a>00959       <a class="code" href="AssembleurPP1BUtil_8cpp.html#a556b82e62a565319fb25218f97cfc50c">calculer_grad</a>(face_voisins, elem, -1, coef_som,si, faces_op1(i),
<a name="l00960"></a>00960                     -1, normales, gradi);
<a name="l00961"></a>00961       <span class="keywordflow">if</span>(faces_op1(i)!=face)
<a name="l00962"></a>00962         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> comp=0; comp&lt;dimension; comp++)
<a name="l00963"></a>00963           gradi(comp)+=normales(face,comp)*unsurdim;
<a name="l00964"></a>00964       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> k=0; k&lt;dimension; k++)
<a name="l00965"></a>00965         gradE(k)=normales(face,k);
<a name="l00966"></a>00966       psc=<a class="code" href="AssembleurPP1BUtil_8cpp.html#a828055cfc33e4c56db8e2f5beb059862">dotproduct_array_fois_inverse_quantitee_entrelacee</a>(gradi,gradE,
<a name="l00967"></a>00967                                                              inverse_quantitee_entrelacee,face);
<a name="l00968"></a>00968       <span class="keywordtype">int</span> rang1=voisins[elem].rang(si);
<a name="l00969"></a>00969       <span class="keywordflow">if</span>(rang1==-1)
<a name="l00970"></a>00970         {
<a name="l00971"></a>00971           voisins[elem].add(si);
<a name="l00972"></a>00972           coeffs[elem].add(psc);
<a name="l00973"></a>00973           nnz++;
<a name="l00974"></a>00974         }
<a name="l00975"></a>00975       <span class="keywordflow">else</span>
<a name="l00976"></a>00976         {
<a name="l00977"></a>00977           coeffs[elem][rang1]+=psc;
<a name="l00978"></a>00978         }
<a name="l00979"></a>00979     }
<a name="l00980"></a>00980 }
<a name="l00981"></a>00981 
<a name="l00982"></a>00982 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00983"></a><a class="code" href="AssembleurPP1BUtil_8cpp.html#a1aa97c31d5b8f95ae899f599d606a1da">00983</a> <a class="code" href="AssembleurPP1BUtil_8cpp.html#a1aa97c31d5b8f95ae899f599d606a1da">update_matrice_NeumannP0P1</a>(<span class="keyword">const</span> <a class="code" href="classZone__VEF.html" title="class Zone_VEF Classe instanciable qui derive de Zone_VF. Cette classe contient les informations geom...">Zone_VEF</a>&amp; zone_VEF,
<a name="l00984"></a>00984                            <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; inverse_quantitee_entrelacee,
<a name="l00985"></a>00985                            <span class="keywordtype">int</span> face, <span class="keywordtype">int</span> elem,
<a name="l00986"></a>00986                            <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; sommets, <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; faces_op1,   <span class="keyword">const</span> <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a>&amp; coef_som,
<a name="l00987"></a>00987                            <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; ARR, <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; ARV,
<a name="l00988"></a>00988                            <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; AVR, <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; AVV)
<a name="l00989"></a>00989 {
<a name="l00990"></a>00990   <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; normales = zone_VEF.<a class="code" href="classZone__VEF.html#a5742d75972e4846bf9fbb6ed5715053e">face_normales</a>();
<a name="l00991"></a>00991   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; face_voisins = zone_VEF.<a class="code" href="classZone__VF.html#a49d4322f5585a8fa95748ca785b70702" title="renvoie l&#39;element voisin de numface dans la direction i. i=0 : dans le sens oppose de l&#39;axe orthogona...">face_voisins</a>();
<a name="l00992"></a>00992 
<a name="l00993"></a>00993   <span class="keywordtype">int</span> nb_elem_tot=zone_VEF.<a class="code" href="classZone__dis__base.html#a790cb2f6bc2928518799e748313d0eb3">nb_elem</a>();
<a name="l00994"></a>00994   <span class="keywordtype">int</span> nb_som_tot=zone_VEF.<a class="code" href="classZone__dis__base.html#acc9921d6a29cb719fd832fd573e47825">nb_som</a>();
<a name="l00995"></a>00995 
<a name="l00996"></a>00996   <span class="keywordtype">int</span> dimension=<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>,
<a name="l00997"></a>00997       dplusun=dimension+1;
<a name="l00998"></a>00998   <span class="keywordtype">double</span> unsurdim=1./<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>;
<a name="l00999"></a>00999   <span class="keywordtype">double</span> psc;
<a name="l01000"></a>01000 <span class="comment">// double coeff_som=1./(dimension)/(dplusun);</span>
<a name="l01001"></a>01001   <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a> gradi(dimension);
<a name="l01002"></a>01002   <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a> gradE(dimension);
<a name="l01003"></a>01003   <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;dplusun; i++)
<a name="l01004"></a>01004     {
<a name="l01005"></a>01005       <span class="keywordtype">int</span> si=sommets(i);
<a name="l01006"></a>01006       <a class="code" href="AssembleurPP1BUtil_8cpp.html#a556b82e62a565319fb25218f97cfc50c">calculer_grad</a>(face_voisins, elem, -1,  coef_som,si, faces_op1(i),
<a name="l01007"></a>01007                     -1, normales, gradi);
<a name="l01008"></a>01008       <span class="keywordflow">if</span>(faces_op1(i)!=face)
<a name="l01009"></a>01009         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> comp=0; comp&lt;dimension; comp++)
<a name="l01010"></a>01010           gradi(comp)+= normales(face,comp)*unsurdim;
<a name="l01011"></a>01011       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> k=0; k&lt;dimension; k++)
<a name="l01012"></a>01012         gradE(k)=normales(face,k);
<a name="l01013"></a>01013       psc=<a class="code" href="AssembleurPP1BUtil_8cpp.html#a828055cfc33e4c56db8e2f5beb059862">dotproduct_array_fois_inverse_quantitee_entrelacee</a>(gradi,gradE,
<a name="l01014"></a>01014                                                              inverse_quantitee_entrelacee,face);
<a name="l01015"></a>01015       <span class="keywordflow">if</span>(elem&lt;nb_elem_tot)
<a name="l01016"></a>01016         <span class="keywordflow">if</span>(si&lt;nb_som_tot)
<a name="l01017"></a>01017           ARR(elem,si)+=psc;
<a name="l01018"></a>01018         <span class="keywordflow">else</span>
<a name="l01019"></a>01019           ARV(elem,si-nb_som_tot)+=psc;
<a name="l01020"></a>01020       <span class="keywordflow">else</span> <span class="keywordflow">if</span>(si&lt;nb_som_tot)
<a name="l01021"></a>01021         AVR(elem-nb_elem_tot,si)+=psc;
<a name="l01022"></a>01022       <span class="keywordflow">else</span>
<a name="l01023"></a>01023         AVV(elem-nb_elem_tot,si-nb_som_tot)+=psc;
<a name="l01024"></a>01024     }
<a name="l01025"></a>01025 }
<a name="l01026"></a>01026 
<a name="l01027"></a>01027 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l01028"></a><a class="code" href="AssembleurPP1BUtil_8cpp.html#ad9eeb295c62a30fa2305edf29ad7cfd5">01028</a> <a class="code" href="AssembleurPP1BUtil_8cpp.html#ad9eeb295c62a30fa2305edf29ad7cfd5">contribuer_matrice_NeumannP1P1</a>(<span class="keyword">const</span> <a class="code" href="classZone__VEF.html" title="class Zone_VEF Classe instanciable qui derive de Zone_VF. Cette classe contient les informations geom...">Zone_VEF</a>&amp; zone_VEF,
<a name="l01029"></a>01029                                <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; inverse_quantitee_entrelacee,
<a name="l01030"></a>01030                                <span class="keywordtype">int</span> face, <span class="keywordtype">int</span> elem,
<a name="l01031"></a>01031                                <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; sommets, <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; faces_op1,   <span class="keyword">const</span> <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a>&amp; coef_som,
<a name="l01032"></a>01032                                <a class="code" href="classIntLists.html" title="Un tableau de listes de type IntList.">IntLists</a>&amp; voisins, <a class="code" href="classDoubleLists.html" title="Un tableau de listes de type DoubleList.">DoubleLists</a>&amp; coeffs,
<a name="l01033"></a>01033                                <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; diag, <span class="keywordtype">int</span>&amp; nnz)
<a name="l01034"></a>01034 {
<a name="l01035"></a>01035   <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; normales = zone_VEF.<a class="code" href="classZone__VEF.html#a5742d75972e4846bf9fbb6ed5715053e">face_normales</a>();
<a name="l01036"></a>01036   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; face_voisins = zone_VEF.<a class="code" href="classZone__VF.html#a49d4322f5585a8fa95748ca785b70702" title="renvoie l&#39;element voisin de numface dans la direction i. i=0 : dans le sens oppose de l&#39;axe orthogona...">face_voisins</a>();
<a name="l01037"></a>01037 
<a name="l01038"></a>01038   <span class="keywordtype">int</span> dimension=<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>,
<a name="l01039"></a>01039       dplusun=dimension+1;
<a name="l01040"></a>01040   <span class="keywordtype">double</span> unsurdim=1./<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>;
<a name="l01041"></a>01041   <span class="keywordtype">double</span> psc;
<a name="l01042"></a>01042 <span class="comment">// double coeff_som=1./(dimension)/(dplusun);</span>
<a name="l01043"></a>01043 <span class="comment">// coeff_som*=coeff_som;</span>
<a name="l01044"></a>01044   <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a> gradi(dimension);
<a name="l01045"></a>01045   <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a> gradj(dimension);
<a name="l01046"></a>01046   <span class="keywordtype">int</span> i,j;
<a name="l01047"></a>01047   <span class="keywordflow">for</span>(i=0; i&lt;dplusun; i++)
<a name="l01048"></a>01048     {
<a name="l01049"></a>01049       <span class="keywordtype">int</span> si=sommets(i);
<a name="l01050"></a>01050       <a class="code" href="AssembleurPP1BUtil_8cpp.html#a556b82e62a565319fb25218f97cfc50c">calculer_grad</a>(face_voisins, elem, -1, coef_som, si, faces_op1(i),
<a name="l01051"></a>01051                     -1, normales, gradi);
<a name="l01052"></a>01052       <span class="keywordflow">if</span>(faces_op1(i)!=face)
<a name="l01053"></a>01053         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> comp=0; comp&lt;dimension; comp++)
<a name="l01054"></a>01054           gradi(comp)+= normales(face,comp)*unsurdim;
<a name="l01055"></a>01055       diag[si]+=<a class="code" href="AssembleurPP1BUtil_8cpp.html#a828055cfc33e4c56db8e2f5beb059862">dotproduct_array_fois_inverse_quantitee_entrelacee</a>(gradi,gradi,
<a name="l01056"></a>01056                                                                    inverse_quantitee_entrelacee,face);
<a name="l01057"></a>01057       <span class="keywordflow">for</span>(j=i+1; j&lt;dplusun; j++)
<a name="l01058"></a>01058         {
<a name="l01059"></a>01059           <span class="keywordtype">int</span> sj=sommets(j);
<a name="l01060"></a>01060           <a class="code" href="AssembleurPP1BUtil_8cpp.html#a556b82e62a565319fb25218f97cfc50c">calculer_grad</a>(face_voisins, elem, -1,  coef_som,sj, faces_op1(j),
<a name="l01061"></a>01061                         -1, normales, gradj);
<a name="l01062"></a>01062           <span class="keywordflow">if</span>(faces_op1(j)!=face)
<a name="l01063"></a>01063             <span class="keywordflow">for</span> (<span class="keywordtype">int</span> comp=0; comp&lt;dimension; comp++)
<a name="l01064"></a>01064               gradj(comp)+= normales(face,comp)*unsurdim;
<a name="l01065"></a>01065           psc=<a class="code" href="AssembleurPP1BUtil_8cpp.html#a828055cfc33e4c56db8e2f5beb059862">dotproduct_array_fois_inverse_quantitee_entrelacee</a>(gradi,gradj,inverse_quantitee_entrelacee,face);
<a name="l01066"></a>01066           <span class="keywordtype">int</span> rang=voisins[si].rang(sj);
<a name="l01067"></a>01067           <span class="keywordflow">if</span>(rang==-1)
<a name="l01068"></a>01068             {
<a name="l01069"></a>01069               voisins[si].add(sj);
<a name="l01070"></a>01070               coeffs[si].add(psc);
<a name="l01071"></a>01071               nnz++;
<a name="l01072"></a>01072             }
<a name="l01073"></a>01073           <span class="keywordflow">else</span>
<a name="l01074"></a>01074             {
<a name="l01075"></a>01075 
<a name="l01076"></a>01076               coeffs[si][rang]+=psc;
<a name="l01077"></a>01077             }
<a name="l01078"></a>01078         }
<a name="l01079"></a>01079     }
<a name="l01080"></a>01080 }
<a name="l01081"></a>01081 
<a name="l01082"></a>01082 
<a name="l01083"></a>01083 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l01084"></a><a class="code" href="AssembleurPP1BUtil_8cpp.html#affe9938bfd355c4e19b608c286c0293b">01084</a> <a class="code" href="AssembleurPP1BUtil_8cpp.html#affe9938bfd355c4e19b608c286c0293b">update_matrice_NeumannP1P1</a>(<span class="keyword">const</span> <a class="code" href="classZone__VEF.html" title="class Zone_VEF Classe instanciable qui derive de Zone_VF. Cette classe contient les informations geom...">Zone_VEF</a>&amp; zone_VEF,
<a name="l01085"></a>01085                            <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; inverse_quantitee_entrelacee,
<a name="l01086"></a>01086                            <span class="keywordtype">int</span> face, <span class="keywordtype">int</span> elem,
<a name="l01087"></a>01087                            <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; sommets, <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; faces_op1,   <span class="keyword">const</span> <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a>&amp; coef_som,
<a name="l01088"></a>01088                            <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; ARR, <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; ARV,
<a name="l01089"></a>01089                            <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; AVR, <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; AVV)
<a name="l01090"></a>01090 {
<a name="l01091"></a>01091   <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; normales = zone_VEF.<a class="code" href="classZone__VEF.html#a5742d75972e4846bf9fbb6ed5715053e">face_normales</a>();
<a name="l01092"></a>01092   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; face_voisins = zone_VEF.<a class="code" href="classZone__VF.html#a49d4322f5585a8fa95748ca785b70702" title="renvoie l&#39;element voisin de numface dans la direction i. i=0 : dans le sens oppose de l&#39;axe orthogona...">face_voisins</a>();
<a name="l01093"></a>01093 
<a name="l01094"></a>01094   <span class="keywordtype">int</span> dimension=<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>,
<a name="l01095"></a>01095       dplusun=dimension+1;
<a name="l01096"></a>01096   <span class="keywordtype">double</span> unsurdim=1./<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>;
<a name="l01097"></a>01097   <span class="keywordtype">double</span> psc;
<a name="l01098"></a>01098 <span class="comment">// double coeff_som=1./(dimension)/(dplusun);</span>
<a name="l01099"></a>01099 <span class="comment">// coeff_som*=coeff_som;</span>
<a name="l01100"></a>01100   <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a> gradi(dimension);
<a name="l01101"></a>01101   <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a> gradj(dimension);
<a name="l01102"></a>01102   <span class="keywordtype">int</span> nb_som_tot=zone_VEF.<a class="code" href="classZone__dis__base.html#acc9921d6a29cb719fd832fd573e47825">nb_som</a>();
<a name="l01103"></a>01103   <span class="keywordtype">int</span> i,j;
<a name="l01104"></a>01104   <span class="keywordflow">for</span>(i=0; i&lt;dplusun; i++)
<a name="l01105"></a>01105     {
<a name="l01106"></a>01106       <span class="keywordtype">int</span> si=sommets(i);
<a name="l01107"></a>01107       <a class="code" href="AssembleurPP1BUtil_8cpp.html#a556b82e62a565319fb25218f97cfc50c">calculer_grad</a>(face_voisins, elem, -1,  coef_som,si, faces_op1(i),
<a name="l01108"></a>01108                     -1, normales, gradi);
<a name="l01109"></a>01109       <span class="keywordflow">if</span>(faces_op1(i)!=face)
<a name="l01110"></a>01110         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> comp=0; comp&lt;dimension; comp++)
<a name="l01111"></a>01111           gradi(comp)+= normales(face,comp)*unsurdim;
<a name="l01112"></a>01112       <span class="keywordflow">if</span>(si&lt;nb_som_tot)
<a name="l01113"></a>01113         ARR(si,si)+=<a class="code" href="AssembleurPP1BUtil_8cpp.html#a828055cfc33e4c56db8e2f5beb059862">dotproduct_array_fois_inverse_quantitee_entrelacee</a>(gradi,gradi,
<a name="l01114"></a>01114                                                                        inverse_quantitee_entrelacee,face);
<a name="l01115"></a>01115       <span class="keywordflow">for</span>(j=i+1; j&lt;dplusun; j++)
<a name="l01116"></a>01116         {
<a name="l01117"></a>01117           <span class="keywordtype">int</span> sj=sommets(j);
<a name="l01118"></a>01118           <a class="code" href="AssembleurPP1BUtil_8cpp.html#a556b82e62a565319fb25218f97cfc50c">calculer_grad</a>(face_voisins, elem, -1,  coef_som,sj, faces_op1(j),
<a name="l01119"></a>01119                         -1, normales, gradj);
<a name="l01120"></a>01120           <span class="keywordflow">if</span>(faces_op1(j)!=face)
<a name="l01121"></a>01121             <span class="keywordflow">for</span> (<span class="keywordtype">int</span> comp=0; comp&lt;dimension; comp++)
<a name="l01122"></a>01122               gradj(comp)+= normales(face,comp)*unsurdim;
<a name="l01123"></a>01123           psc=<a class="code" href="AssembleurPP1BUtil_8cpp.html#a828055cfc33e4c56db8e2f5beb059862">dotproduct_array_fois_inverse_quantitee_entrelacee</a>(gradi,gradj,inverse_quantitee_entrelacee,face);
<a name="l01124"></a>01124           <span class="keywordflow">if</span>(si&lt;nb_som_tot)
<a name="l01125"></a>01125             <span class="keywordflow">if</span>(sj&lt;nb_som_tot)
<a name="l01126"></a>01126               ARR(si,sj)+=psc;
<a name="l01127"></a>01127             <span class="keywordflow">else</span>
<a name="l01128"></a>01128               ARV(si,sj-nb_som_tot)+=psc;
<a name="l01129"></a>01129           <span class="keywordflow">else</span> <span class="keywordflow">if</span>(sj&lt;nb_som_tot)
<a name="l01130"></a>01130             AVR(si-nb_som_tot,sj)+=psc;
<a name="l01131"></a>01131           <span class="keywordflow">else</span>
<a name="l01132"></a>01132             AVV(si-nb_som_tot,sj-nb_som_tot)+=psc;
<a name="l01133"></a>01133         }
<a name="l01134"></a>01134     }
<a name="l01135"></a>01135 }
<a name="l01136"></a>01136 
<a name="l01137"></a>01137 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l01138"></a><a class="code" href="AssembleurPP1BUtil_8cpp.html#a9568a5e0cbf3b9e2b60ad3f3bdac25df">01138</a> <a class="code" href="AssembleurPP1BUtil_8cpp.html#a9568a5e0cbf3b9e2b60ad3f3bdac25df">contribuer_matrice_SymetrieP1P1</a>(<span class="keyword">const</span> <a class="code" href="classZone__VEF.html" title="class Zone_VEF Classe instanciable qui derive de Zone_VF. Cette classe contient les informations geom...">Zone_VEF</a>&amp; zone_VEF,
<a name="l01139"></a>01139                                 <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; inverse_quantitee_entrelacee,
<a name="l01140"></a>01140                                 <span class="keywordtype">int</span> face, <span class="keywordtype">int</span> elem,
<a name="l01141"></a>01141                                 <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; sommets, <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; faces_op1,<span class="keyword">const</span> <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a>&amp; coef_som,
<a name="l01142"></a>01142                                 <a class="code" href="classIntLists.html" title="Un tableau de listes de type IntList.">IntLists</a>&amp; voisins, <a class="code" href="classDoubleLists.html" title="Un tableau de listes de type DoubleList.">DoubleLists</a>&amp; coeffs,
<a name="l01143"></a>01143                                 <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; diag, <span class="keywordtype">int</span>&amp; nnz)
<a name="l01144"></a>01144 {
<a name="l01145"></a>01145   <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; normales = zone_VEF.<a class="code" href="classZone__VEF.html#a5742d75972e4846bf9fbb6ed5715053e">face_normales</a>();
<a name="l01146"></a>01146   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; face_voisins = zone_VEF.<a class="code" href="classZone__VF.html#a49d4322f5585a8fa95748ca785b70702" title="renvoie l&#39;element voisin de numface dans la direction i. i=0 : dans le sens oppose de l&#39;axe orthogona...">face_voisins</a>();
<a name="l01147"></a>01147 
<a name="l01148"></a>01148   <span class="keywordtype">int</span> dimension=<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>,
<a name="l01149"></a>01149       dplusun=dimension+1;
<a name="l01150"></a>01150 
<a name="l01151"></a>01151   <span class="keywordtype">double</span> psc;
<a name="l01152"></a>01152 <span class="comment">// double coeff_som=1./(dimension)/(dplusun);</span>
<a name="l01153"></a>01153 <span class="comment">// coeff_som*=coeff_som;</span>
<a name="l01154"></a>01154   <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a> gradi(dimension);
<a name="l01155"></a>01155   <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a> gradj(dimension);
<a name="l01156"></a>01156   <span class="keywordtype">int</span> i,j;
<a name="l01157"></a>01157   <span class="keywordflow">for</span>(i=0; i&lt;dplusun; i++)
<a name="l01158"></a>01158     {
<a name="l01159"></a>01159       <span class="keywordtype">int</span> si=sommets(i);
<a name="l01160"></a>01160       <a class="code" href="AssembleurPP1BUtil_8cpp.html#a556b82e62a565319fb25218f97cfc50c">calculer_grad</a>(face_voisins, elem, -1, coef_som, si, faces_op1(i),
<a name="l01161"></a>01161                     -1, normales, gradi);
<a name="l01162"></a>01162       <a class="code" href="Champ__Generique__Transformation_8cpp.html#a0705a900f8a8003047df2f59d6cd4bae">projette</a>(gradi, face, normales);
<a name="l01163"></a>01163       diag[si]+=<a class="code" href="AssembleurPP1BUtil_8cpp.html#a828055cfc33e4c56db8e2f5beb059862">dotproduct_array_fois_inverse_quantitee_entrelacee</a>(gradi,gradi,
<a name="l01164"></a>01164                                                                    inverse_quantitee_entrelacee,face);
<a name="l01165"></a>01165       <span class="keywordflow">for</span>(j=i+1; j&lt;dplusun; j++)
<a name="l01166"></a>01166         {
<a name="l01167"></a>01167           <span class="keywordtype">int</span> sj=sommets(j);
<a name="l01168"></a>01168           <a class="code" href="AssembleurPP1BUtil_8cpp.html#a556b82e62a565319fb25218f97cfc50c">calculer_grad</a>(face_voisins, elem,  -1, coef_som, sj, faces_op1(j),
<a name="l01169"></a>01169                         -1, normales, gradj);
<a name="l01170"></a>01170           <a class="code" href="Champ__Generique__Transformation_8cpp.html#a0705a900f8a8003047df2f59d6cd4bae">projette</a>(gradj, face, normales);
<a name="l01171"></a>01171           psc=<a class="code" href="AssembleurPP1BUtil_8cpp.html#a828055cfc33e4c56db8e2f5beb059862">dotproduct_array_fois_inverse_quantitee_entrelacee</a>(gradi,gradj,
<a name="l01172"></a>01172                                                                  inverse_quantitee_entrelacee,face);
<a name="l01173"></a>01173           <span class="keywordtype">int</span> rang=voisins[si].rang(sj);
<a name="l01174"></a>01174           <span class="keywordflow">if</span>(rang==-1)
<a name="l01175"></a>01175             {
<a name="l01176"></a>01176               voisins[si].add(sj);
<a name="l01177"></a>01177               coeffs[si].add(psc);
<a name="l01178"></a>01178               nnz++;
<a name="l01179"></a>01179             }
<a name="l01180"></a>01180           <span class="keywordflow">else</span>
<a name="l01181"></a>01181             {
<a name="l01182"></a>01182 
<a name="l01183"></a>01183               coeffs[si][rang]+=psc;
<a name="l01184"></a>01184             }
<a name="l01185"></a>01185         }
<a name="l01186"></a>01186     }
<a name="l01187"></a>01187 }
<a name="l01188"></a>01188 
<a name="l01189"></a>01189 
<a name="l01190"></a>01190 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l01191"></a><a class="code" href="AssembleurPP1BUtil_8cpp.html#ade1c92b286a861f3920664b658ba3fb1">01191</a> <a class="code" href="AssembleurPP1BUtil_8cpp.html#ade1c92b286a861f3920664b658ba3fb1">update_matrice_SymetrieP1P1</a>(<span class="keyword">const</span> <a class="code" href="classZone__VEF.html" title="class Zone_VEF Classe instanciable qui derive de Zone_VF. Cette classe contient les informations geom...">Zone_VEF</a>&amp; zone_VEF,
<a name="l01192"></a>01192                             <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; inverse_quantitee_entrelacee,
<a name="l01193"></a>01193                             <span class="keywordtype">int</span> face, <span class="keywordtype">int</span> elem,
<a name="l01194"></a>01194                             <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; sommets, <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; faces_op1,   <span class="keyword">const</span> <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a>&amp; coef_som,
<a name="l01195"></a>01195                             <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; ARR, <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; ARV,
<a name="l01196"></a>01196                             <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; AVR, <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; AVV)
<a name="l01197"></a>01197 {
<a name="l01198"></a>01198   <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; normales = zone_VEF.<a class="code" href="classZone__VEF.html#a5742d75972e4846bf9fbb6ed5715053e">face_normales</a>();
<a name="l01199"></a>01199   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; face_voisins = zone_VEF.<a class="code" href="classZone__VF.html#a49d4322f5585a8fa95748ca785b70702" title="renvoie l&#39;element voisin de numface dans la direction i. i=0 : dans le sens oppose de l&#39;axe orthogona...">face_voisins</a>();
<a name="l01200"></a>01200 
<a name="l01201"></a>01201   <span class="keywordtype">int</span> dimension=<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>,
<a name="l01202"></a>01202       dplusun=dimension+1;
<a name="l01203"></a>01203   <span class="keywordtype">double</span> psc;
<a name="l01204"></a>01204 <span class="comment">// double coeff_som=1./(dimension)/(dplusun);</span>
<a name="l01205"></a>01205 <span class="comment">// coeff_som*=coeff_som;</span>
<a name="l01206"></a>01206   <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a> gradi(dimension);
<a name="l01207"></a>01207   <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a> gradj(dimension);
<a name="l01208"></a>01208   <span class="keywordtype">int</span> nb_som_tot=zone_VEF.<a class="code" href="classZone__dis__base.html#acc9921d6a29cb719fd832fd573e47825">nb_som</a>();
<a name="l01209"></a>01209   <span class="keywordtype">int</span> i,j;
<a name="l01210"></a>01210   <span class="keywordflow">for</span>(i=0; i&lt;dplusun; i++)
<a name="l01211"></a>01211     {
<a name="l01212"></a>01212       <span class="keywordtype">int</span> si=sommets(i);
<a name="l01213"></a>01213       <a class="code" href="AssembleurPP1BUtil_8cpp.html#a556b82e62a565319fb25218f97cfc50c">calculer_grad</a>(face_voisins, elem, -1, coef_som, si, faces_op1(i),
<a name="l01214"></a>01214                     -1, normales, gradi);
<a name="l01215"></a>01215       <a class="code" href="Champ__Generique__Transformation_8cpp.html#a0705a900f8a8003047df2f59d6cd4bae">projette</a>(gradi, face, normales);
<a name="l01216"></a>01216       <span class="keywordflow">if</span>(si&lt;nb_som_tot)
<a name="l01217"></a>01217         ARR(si,si)+=<a class="code" href="AssembleurPP1BUtil_8cpp.html#a828055cfc33e4c56db8e2f5beb059862">dotproduct_array_fois_inverse_quantitee_entrelacee</a>(gradi,gradi,
<a name="l01218"></a>01218                                                                        inverse_quantitee_entrelacee,face);
<a name="l01219"></a>01219       <span class="keywordflow">for</span>(j=i+1; j&lt;dplusun; j++)
<a name="l01220"></a>01220         {
<a name="l01221"></a>01221           <span class="keywordtype">int</span> sj=sommets(j);
<a name="l01222"></a>01222           <a class="code" href="AssembleurPP1BUtil_8cpp.html#a556b82e62a565319fb25218f97cfc50c">calculer_grad</a>(face_voisins, elem, -1,  coef_som,sj, faces_op1(j),
<a name="l01223"></a>01223                         -1, normales, gradj);
<a name="l01224"></a>01224           <a class="code" href="Champ__Generique__Transformation_8cpp.html#a0705a900f8a8003047df2f59d6cd4bae">projette</a>(gradj, face, normales);
<a name="l01225"></a>01225           psc=<a class="code" href="AssembleurPP1BUtil_8cpp.html#a828055cfc33e4c56db8e2f5beb059862">dotproduct_array_fois_inverse_quantitee_entrelacee</a>(gradi,gradj,
<a name="l01226"></a>01226                                                                  inverse_quantitee_entrelacee,face);
<a name="l01227"></a>01227           <span class="keywordflow">if</span>(si&lt;nb_som_tot)
<a name="l01228"></a>01228             <span class="keywordflow">if</span>(sj&lt;nb_som_tot)
<a name="l01229"></a>01229               ARR(si,sj)+=psc;
<a name="l01230"></a>01230             <span class="keywordflow">else</span>
<a name="l01231"></a>01231               ARV(si,sj-nb_som_tot)+=psc;
<a name="l01232"></a>01232           <span class="keywordflow">else</span> <span class="keywordflow">if</span>(sj&lt;nb_som_tot)
<a name="l01233"></a>01233             AVR(si-nb_som_tot,sj)+=psc;
<a name="l01234"></a>01234           <span class="keywordflow">else</span>
<a name="l01235"></a>01235             AVV(si-nb_som_tot,sj-nb_som_tot)+=psc;
<a name="l01236"></a>01236         }
<a name="l01237"></a>01237     }
<a name="l01238"></a>01238 }
<a name="l01239"></a>01239 
<a name="l01240"></a>01240 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l01241"></a><a class="code" href="AssembleurPP1BUtil_8cpp.html#a80033228b3ed99e778b70c35cda5e4e6">01241</a> <a class="code" href="AssembleurPP1BUtil_8cpp.html#a80033228b3ed99e778b70c35cda5e4e6">contribuer_matrice_NeumannPaPa</a>(<span class="keyword">const</span> <a class="code" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a>&amp; zone_VEF,
<a name="l01242"></a>01242                                <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; inverse_quantitee_entrelacee,
<a name="l01243"></a>01243                                <span class="keywordtype">int</span> face, <span class="keywordtype">int</span> elem,
<a name="l01244"></a>01244                                <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; sommets, <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; faces_op1,
<a name="l01245"></a>01245                                <a class="code" href="classIntLists.html" title="Un tableau de listes de type IntList.">IntLists</a>&amp; voisins, <a class="code" href="classDoubleLists.html" title="Un tableau de listes de type DoubleList.">DoubleLists</a>&amp; coeffs,
<a name="l01246"></a>01246                                <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; diag, <span class="keywordtype">int</span>&amp; nnz)
<a name="l01247"></a>01247 {
<a name="l01248"></a>01248   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; elem_aretes=zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#a1e1e86ef5b088c4d33d42cd38a967b4a" title="renvoie le numero de la jeme arete du ieme element.">elem_aretes</a>();
<a name="l01249"></a>01249   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; aretes_som=zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#affa60690e1b372fa4c01d6088267dbe4" title="renvoie le tableau de connectivite aretes/sommets.">aretes_som</a>();
<a name="l01250"></a>01250   <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; ok_arete=zone_VEF.<a class="code" href="classZone__VEF__PreP1b.html#a83771f784d487e346b2ef22a389472a2">get_ok_arete</a>();
<a name="l01251"></a>01251   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; face_voisins=zone_VEF.<a class="code" href="classZone__VF.html#a49d4322f5585a8fa95748ca785b70702" title="renvoie l&#39;element voisin de numface dans la direction i. i=0 : dans le sens oppose de l&#39;axe orthogona...">face_voisins</a>();
<a name="l01252"></a>01252   <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; normales = zone_VEF.<a class="code" href="classZone__VEF.html#a5742d75972e4846bf9fbb6ed5715053e">face_normales</a>();
<a name="l01253"></a>01253   <span class="keywordtype">int</span> i, j, k, l;
<a name="l01254"></a>01254   <span class="keywordtype">double</span> psc;
<a name="l01255"></a>01255   <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a> grad1(3);
<a name="l01256"></a>01256   <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a> grad2(3);
<a name="l01257"></a>01257   <span class="keywordflow">for</span>(i=0; i&lt;3; i++)
<a name="l01258"></a>01258     {
<a name="l01259"></a>01259       <span class="keywordtype">int</span> si=sommets(i);
<a name="l01260"></a>01260       <span class="keywordflow">for</span>(j=i+1; j&lt;4; j++)
<a name="l01261"></a>01261         {
<a name="l01262"></a>01262           <span class="keywordtype">int</span> sj=sommets(j);
<a name="l01263"></a>01263           <span class="keywordtype">int</span> arete1;
<a name="l01264"></a>01264           arete1 = <a class="code" href="AssembleurPP1BUtil_8cpp.html#ae1c00f10faaf4da3ffdea8f881565a1b">chercher_arete</a>(zone_VEF,elem, si, sj,
<a name="l01265"></a>01265                                   elem_aretes, aretes_som);
<a name="l01266"></a>01266           <span class="keywordflow">if</span>(ok_arete(arete1))
<a name="l01267"></a>01267             {
<a name="l01268"></a>01268               <a class="code" href="AssembleurPP1BUtil_8cpp.html#aa26334c33fd016e71cbab82de7ef2fe5">calculer_grad_arete</a>(face, face_voisins, i, j,
<a name="l01269"></a>01269                                   elem, -1,
<a name="l01270"></a>01270                                   faces_op1(i), -1,
<a name="l01271"></a>01271                                   faces_op1(j), -1,
<a name="l01272"></a>01272                                   normales, grad1);
<a name="l01273"></a>01273               diag[arete1]+=<a class="code" href="AssembleurPP1BUtil_8cpp.html#a828055cfc33e4c56db8e2f5beb059862">dotproduct_array_fois_inverse_quantitee_entrelacee</a>(grad1,grad1,
<a name="l01274"></a>01274                                                                                inverse_quantitee_entrelacee,face);
<a name="l01275"></a>01275               <span class="keywordtype">int</span> jj=j;
<a name="l01276"></a>01276               <span class="keywordflow">for</span>(k=i; k&lt;3; k++)
<a name="l01277"></a>01277                 {
<a name="l01278"></a>01278                   <span class="keywordtype">int</span> sk=sommets(k);
<a name="l01279"></a>01279                   <span class="keywordflow">for</span>(l=jj+1; l&lt;4; l++)
<a name="l01280"></a>01280                     {
<a name="l01281"></a>01281                       <span class="keywordtype">int</span> sl=sommets(l);
<a name="l01282"></a>01282                       <span class="keywordtype">int</span> arete2= <a class="code" href="AssembleurPP1BUtil_8cpp.html#ae1c00f10faaf4da3ffdea8f881565a1b">chercher_arete</a>(zone_VEF,elem, sl, sk,
<a name="l01283"></a>01283                                                  elem_aretes,
<a name="l01284"></a>01284                                                  aretes_som);
<a name="l01285"></a>01285                       assert(arete2!=-1);
<a name="l01286"></a>01286                       <span class="keywordflow">if</span>(ok_arete(arete2))
<a name="l01287"></a>01287                         {
<a name="l01288"></a>01288                           <a class="code" href="AssembleurPP1BUtil_8cpp.html#aa26334c33fd016e71cbab82de7ef2fe5">calculer_grad_arete</a>(face, face_voisins, k, l,
<a name="l01289"></a>01289                                               elem, -1,
<a name="l01290"></a>01290                                               faces_op1(k), -1,
<a name="l01291"></a>01291                                               faces_op1(l), -1,
<a name="l01292"></a>01292                                               normales, grad2);
<a name="l01293"></a>01293                           psc=<a class="code" href="AssembleurPP1BUtil_8cpp.html#a828055cfc33e4c56db8e2f5beb059862">dotproduct_array_fois_inverse_quantitee_entrelacee</a>(grad1,grad2,
<a name="l01294"></a>01294                                                                                  inverse_quantitee_entrelacee,face);
<a name="l01295"></a>01295                           <span class="keywordtype">int</span> tmp=arete1;
<a name="l01296"></a>01296                           <span class="keywordflow">if</span>(arete1&gt;arete2) <a class="code" href="AssembleurPP1BUtil_8cpp.html#a3117b050530c46b4a15b6ab9ce6d0b41">swap</a>(arete1, arete2);
<a name="l01297"></a>01297                           <span class="keywordtype">int</span> rang=voisins[arete1].rang(arete2);
<a name="l01298"></a>01298                           <span class="keywordflow">if</span>(rang==-1)
<a name="l01299"></a>01299                             {
<a name="l01300"></a>01300                               voisins[arete1].add(arete2);
<a name="l01301"></a>01301                               coeffs[arete1].add(psc);
<a name="l01302"></a>01302                               nnz++;
<a name="l01303"></a>01303                             }
<a name="l01304"></a>01304                           <span class="keywordflow">else</span>
<a name="l01305"></a>01305                             {
<a name="l01306"></a>01306                               coeffs[arete1][rang]+=psc;
<a name="l01307"></a>01307                             }
<a name="l01308"></a>01308                           arete1=tmp;
<a name="l01309"></a>01309                         }
<a name="l01310"></a>01310                     }
<a name="l01311"></a>01311                   jj=k+1;
<a name="l01312"></a>01312                 }
<a name="l01313"></a>01313             }
<a name="l01314"></a>01314         }
<a name="l01315"></a>01315     }
<a name="l01316"></a>01316 }
<a name="l01317"></a>01317 
<a name="l01318"></a>01318 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l01319"></a><a class="code" href="AssembleurPP1BUtil_8cpp.html#a6a26a390dab2336113f60275e5978aaf">01319</a> <a class="code" href="AssembleurPP1BUtil_8cpp.html#a6a26a390dab2336113f60275e5978aaf">update_matrice_NeumannPaPa</a>(<span class="keyword">const</span> <a class="code" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a>&amp; zone_VEF,
<a name="l01320"></a>01320                            <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; inverse_quantitee_entrelacee,
<a name="l01321"></a>01321                            <span class="keywordtype">int</span> face, <span class="keywordtype">int</span> elem,
<a name="l01322"></a>01322                            <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; sommets, <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; faces_op1,
<a name="l01323"></a>01323                            <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; ARR, <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; ARV,
<a name="l01324"></a>01324                            <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; AVR, <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; AVV)
<a name="l01325"></a>01325 {
<a name="l01326"></a>01326   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; elem_aretes=zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#a1e1e86ef5b088c4d33d42cd38a967b4a" title="renvoie le numero de la jeme arete du ieme element.">elem_aretes</a>();
<a name="l01327"></a>01327   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; aretes_som=zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#affa60690e1b372fa4c01d6088267dbe4" title="renvoie le tableau de connectivite aretes/sommets.">aretes_som</a>();
<a name="l01328"></a>01328   <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; ok_arete=zone_VEF.<a class="code" href="classZone__VEF__PreP1b.html#a83771f784d487e346b2ef22a389472a2">get_ok_arete</a>();
<a name="l01329"></a>01329   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; face_voisins=zone_VEF.<a class="code" href="classZone__VF.html#a49d4322f5585a8fa95748ca785b70702" title="renvoie l&#39;element voisin de numface dans la direction i. i=0 : dans le sens oppose de l&#39;axe orthogona...">face_voisins</a>();
<a name="l01330"></a>01330   <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; normales = zone_VEF.<a class="code" href="classZone__VEF.html#a5742d75972e4846bf9fbb6ed5715053e">face_normales</a>();
<a name="l01331"></a>01331   <span class="keywordtype">int</span> nb_aretes_tot=zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#a3e3b48691911fd85574c7bc10a1a4fb8" title="renvoie le nombre d&#39;aretes reelles.">nb_aretes</a>();
<a name="l01332"></a>01332 
<a name="l01333"></a>01333   <span class="keywordtype">int</span> i, j, k, l;
<a name="l01334"></a>01334   <span class="keywordtype">double</span> psc;
<a name="l01335"></a>01335   <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a> grad1(3);
<a name="l01336"></a>01336   <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a> grad2(3);
<a name="l01337"></a>01337   <span class="keywordflow">for</span>(i=0; i&lt;3; i++)
<a name="l01338"></a>01338     {
<a name="l01339"></a>01339       <span class="keywordtype">int</span> si=sommets(i);
<a name="l01340"></a>01340       <span class="keywordflow">for</span>(j=i+1; j&lt;4; j++)
<a name="l01341"></a>01341         {
<a name="l01342"></a>01342           <span class="keywordtype">int</span> sj=sommets(j);
<a name="l01343"></a>01343           <span class="keywordtype">int</span> arete1;
<a name="l01344"></a>01344           arete1 = <a class="code" href="AssembleurPP1BUtil_8cpp.html#ae1c00f10faaf4da3ffdea8f881565a1b">chercher_arete</a>(zone_VEF,elem, si, sj,
<a name="l01345"></a>01345                                   elem_aretes, aretes_som);
<a name="l01346"></a>01346           <span class="keywordflow">if</span>(ok_arete(arete1))
<a name="l01347"></a>01347             {
<a name="l01348"></a>01348               <a class="code" href="AssembleurPP1BUtil_8cpp.html#aa26334c33fd016e71cbab82de7ef2fe5">calculer_grad_arete</a>(face, face_voisins, i, j,
<a name="l01349"></a>01349                                   elem, -1,
<a name="l01350"></a>01350                                   faces_op1(i), -1,
<a name="l01351"></a>01351                                   faces_op1(j), -1,
<a name="l01352"></a>01352                                   normales, grad1);
<a name="l01353"></a>01353               <span class="keywordflow">if</span>(arete1&lt;nb_aretes_tot)
<a name="l01354"></a>01354                 ARR(arete1,arete1)+=<a class="code" href="AssembleurPP1BUtil_8cpp.html#a828055cfc33e4c56db8e2f5beb059862">dotproduct_array_fois_inverse_quantitee_entrelacee</a>(grad1,grad1,
<a name="l01355"></a>01355                                                                                        inverse_quantitee_entrelacee,face);
<a name="l01356"></a>01356               <span class="keywordtype">int</span> jj=j;
<a name="l01357"></a>01357               <span class="keywordflow">for</span>(k=i; k&lt;3; k++)
<a name="l01358"></a>01358                 {
<a name="l01359"></a>01359                   <span class="keywordtype">int</span> sk=sommets(k);
<a name="l01360"></a>01360                   <span class="keywordflow">for</span>(l=jj+1; l&lt;4; l++)
<a name="l01361"></a>01361                     {
<a name="l01362"></a>01362                       <span class="keywordtype">int</span> sl=sommets(l);
<a name="l01363"></a>01363                       <span class="keywordtype">int</span> arete2= <a class="code" href="AssembleurPP1BUtil_8cpp.html#ae1c00f10faaf4da3ffdea8f881565a1b">chercher_arete</a>(zone_VEF,elem, sl, sk,
<a name="l01364"></a>01364                                                  elem_aretes,
<a name="l01365"></a>01365                                                  aretes_som);
<a name="l01366"></a>01366                       assert(arete2!=-1);
<a name="l01367"></a>01367                       <span class="keywordflow">if</span>(ok_arete(arete2))
<a name="l01368"></a>01368                         {
<a name="l01369"></a>01369                           <a class="code" href="AssembleurPP1BUtil_8cpp.html#aa26334c33fd016e71cbab82de7ef2fe5">calculer_grad_arete</a>(face, face_voisins, k, l,
<a name="l01370"></a>01370                                               elem, -1,
<a name="l01371"></a>01371                                               faces_op1(k), -1,
<a name="l01372"></a>01372                                               faces_op1(l), -1,
<a name="l01373"></a>01373                                               normales, grad2);
<a name="l01374"></a>01374                           psc=<a class="code" href="AssembleurPP1BUtil_8cpp.html#a828055cfc33e4c56db8e2f5beb059862">dotproduct_array_fois_inverse_quantitee_entrelacee</a>(grad1,grad2,
<a name="l01375"></a>01375                                                                                  inverse_quantitee_entrelacee,face);
<a name="l01376"></a>01376                           <span class="keywordtype">int</span> tmp=arete1;
<a name="l01377"></a>01377                           <span class="keywordflow">if</span>(arete1&gt;arete2) <a class="code" href="AssembleurPP1BUtil_8cpp.html#a3117b050530c46b4a15b6ab9ce6d0b41">swap</a>(arete1, arete2);
<a name="l01378"></a>01378                           <span class="keywordflow">if</span>(arete1&lt;nb_aretes_tot)
<a name="l01379"></a>01379                             <span class="keywordflow">if</span>(arete2&lt;nb_aretes_tot)
<a name="l01380"></a>01380                               ARR(arete1,arete2)+=psc;
<a name="l01381"></a>01381                             <span class="keywordflow">else</span>
<a name="l01382"></a>01382                               ARV(arete1,arete2-nb_aretes_tot)+=psc;
<a name="l01383"></a>01383                           <span class="keywordflow">else</span> <span class="keywordflow">if</span>(arete2&lt;nb_aretes_tot)
<a name="l01384"></a>01384                             AVR(arete1-nb_aretes_tot,arete2)+=psc;
<a name="l01385"></a>01385                           <span class="keywordflow">else</span>
<a name="l01386"></a>01386                             AVV(arete1-nb_aretes_tot,arete2-nb_aretes_tot)+=psc;
<a name="l01387"></a>01387                           arete1=tmp;
<a name="l01388"></a>01388                         }
<a name="l01389"></a>01389                     }
<a name="l01390"></a>01390                   jj=k+1;
<a name="l01391"></a>01391                 }
<a name="l01392"></a>01392             }
<a name="l01393"></a>01393         }
<a name="l01394"></a>01394     }
<a name="l01395"></a>01395 }
<a name="l01396"></a>01396 
<a name="l01397"></a>01397 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l01398"></a><a class="code" href="AssembleurPP1BUtil_8cpp.html#ac51ccb6fe9aac0200f1b08da9d81c65b">01398</a> <a class="code" href="AssembleurPP1BUtil_8cpp.html#ac51ccb6fe9aac0200f1b08da9d81c65b">contribuer_matrice_SymetriePaPa</a>(<span class="keyword">const</span> <a class="code" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a>&amp; zone_VEF,
<a name="l01399"></a>01399                                 <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; inverse_quantitee_entrelacee,
<a name="l01400"></a>01400                                 <span class="keywordtype">int</span> face, <span class="keywordtype">int</span> elem,
<a name="l01401"></a>01401                                 <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; sommets, <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; faces_op1,
<a name="l01402"></a>01402                                 <a class="code" href="classIntLists.html" title="Un tableau de listes de type IntList.">IntLists</a>&amp; voisins, <a class="code" href="classDoubleLists.html" title="Un tableau de listes de type DoubleList.">DoubleLists</a>&amp; coeffs,
<a name="l01403"></a>01403                                 <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; diag, <span class="keywordtype">int</span>&amp; nnz)
<a name="l01404"></a>01404 {
<a name="l01405"></a>01405   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; elem_aretes=zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#a1e1e86ef5b088c4d33d42cd38a967b4a" title="renvoie le numero de la jeme arete du ieme element.">elem_aretes</a>();
<a name="l01406"></a>01406   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; aretes_som=zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#affa60690e1b372fa4c01d6088267dbe4" title="renvoie le tableau de connectivite aretes/sommets.">aretes_som</a>();
<a name="l01407"></a>01407   <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; ok_arete=zone_VEF.<a class="code" href="classZone__VEF__PreP1b.html#a83771f784d487e346b2ef22a389472a2">get_ok_arete</a>();
<a name="l01408"></a>01408   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; face_voisins=zone_VEF.<a class="code" href="classZone__VF.html#a49d4322f5585a8fa95748ca785b70702" title="renvoie l&#39;element voisin de numface dans la direction i. i=0 : dans le sens oppose de l&#39;axe orthogona...">face_voisins</a>();
<a name="l01409"></a>01409   <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; normales = zone_VEF.<a class="code" href="classZone__VEF.html#a5742d75972e4846bf9fbb6ed5715053e">face_normales</a>();
<a name="l01410"></a>01410   <span class="keywordtype">int</span> i, j, k, l;
<a name="l01411"></a>01411   <span class="keywordtype">double</span> psc;
<a name="l01412"></a>01412   <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a> grad1(3);
<a name="l01413"></a>01413   <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a> grad2(3);
<a name="l01414"></a>01414   <span class="keywordflow">for</span>(i=0; i&lt;3; i++)
<a name="l01415"></a>01415     {
<a name="l01416"></a>01416       <span class="keywordtype">int</span> si=sommets(i);
<a name="l01417"></a>01417       <span class="keywordflow">for</span>(j=i+1; j&lt;4; j++)
<a name="l01418"></a>01418         {
<a name="l01419"></a>01419           <span class="keywordtype">int</span> sj=sommets(j);
<a name="l01420"></a>01420           <span class="keywordtype">int</span> arete1;
<a name="l01421"></a>01421           arete1 = <a class="code" href="AssembleurPP1BUtil_8cpp.html#ae1c00f10faaf4da3ffdea8f881565a1b">chercher_arete</a>(zone_VEF,elem, si, sj,
<a name="l01422"></a>01422                                   elem_aretes, aretes_som);
<a name="l01423"></a>01423           <span class="keywordflow">if</span>(ok_arete(arete1))
<a name="l01424"></a>01424             {
<a name="l01425"></a>01425               <a class="code" href="AssembleurPP1BUtil_8cpp.html#aa26334c33fd016e71cbab82de7ef2fe5">calculer_grad_arete</a>(face, face_voisins, i, j,
<a name="l01426"></a>01426                                   elem, -1,
<a name="l01427"></a>01427                                   faces_op1(i), -1,
<a name="l01428"></a>01428                                   faces_op1(j), -1,
<a name="l01429"></a>01429                                   normales, grad1);
<a name="l01430"></a>01430               <a class="code" href="Champ__Generique__Transformation_8cpp.html#a0705a900f8a8003047df2f59d6cd4bae">projette</a>(grad1, face, normales);
<a name="l01431"></a>01431               diag[arete1]+=<a class="code" href="AssembleurPP1BUtil_8cpp.html#a828055cfc33e4c56db8e2f5beb059862">dotproduct_array_fois_inverse_quantitee_entrelacee</a>(grad1,grad1,
<a name="l01432"></a>01432                                                                                inverse_quantitee_entrelacee,face);
<a name="l01433"></a>01433               <span class="keywordtype">int</span> jj=j;
<a name="l01434"></a>01434               <span class="keywordflow">for</span>(k=i; k&lt;3; k++)
<a name="l01435"></a>01435                 {
<a name="l01436"></a>01436                   <span class="keywordtype">int</span> sk=sommets(k);
<a name="l01437"></a>01437                   <span class="keywordflow">for</span>(l=jj+1; l&lt;4; l++)
<a name="l01438"></a>01438                     {
<a name="l01439"></a>01439                       <span class="keywordtype">int</span> sl=sommets(l);
<a name="l01440"></a>01440                       <span class="keywordtype">int</span> arete2= <a class="code" href="AssembleurPP1BUtil_8cpp.html#ae1c00f10faaf4da3ffdea8f881565a1b">chercher_arete</a>(zone_VEF,elem, sl, sk,
<a name="l01441"></a>01441                                                  elem_aretes,
<a name="l01442"></a>01442                                                  aretes_som);
<a name="l01443"></a>01443                       assert(arete2!=-1);
<a name="l01444"></a>01444                       <span class="keywordflow">if</span>(ok_arete(arete2))
<a name="l01445"></a>01445                         {
<a name="l01446"></a>01446                           <a class="code" href="AssembleurPP1BUtil_8cpp.html#aa26334c33fd016e71cbab82de7ef2fe5">calculer_grad_arete</a>(face, face_voisins, k, l,
<a name="l01447"></a>01447                                               elem, -1,
<a name="l01448"></a>01448                                               faces_op1(k), -1,
<a name="l01449"></a>01449                                               faces_op1(l), -1,
<a name="l01450"></a>01450                                               normales, grad2);
<a name="l01451"></a>01451                           <a class="code" href="Champ__Generique__Transformation_8cpp.html#a0705a900f8a8003047df2f59d6cd4bae">projette</a>(grad2, face, normales);
<a name="l01452"></a>01452                           psc=<a class="code" href="AssembleurPP1BUtil_8cpp.html#a828055cfc33e4c56db8e2f5beb059862">dotproduct_array_fois_inverse_quantitee_entrelacee</a>(grad1,grad2,
<a name="l01453"></a>01453                                                                                  inverse_quantitee_entrelacee,face);
<a name="l01454"></a>01454                           <span class="keywordtype">int</span> tmp=arete1;
<a name="l01455"></a>01455                           <span class="keywordflow">if</span>(arete1&gt;arete2) <a class="code" href="AssembleurPP1BUtil_8cpp.html#a3117b050530c46b4a15b6ab9ce6d0b41">swap</a>(arete1, arete2);
<a name="l01456"></a>01456                           <span class="keywordtype">int</span> rang=voisins[arete1].rang(arete2);
<a name="l01457"></a>01457                           <span class="keywordflow">if</span>(rang==-1)
<a name="l01458"></a>01458                             {
<a name="l01459"></a>01459                               voisins[arete1].add(arete2);
<a name="l01460"></a>01460                               coeffs[arete1].add(psc);
<a name="l01461"></a>01461                               nnz++;
<a name="l01462"></a>01462                             }
<a name="l01463"></a>01463                           <span class="keywordflow">else</span>
<a name="l01464"></a>01464                             {
<a name="l01465"></a>01465                               coeffs[arete1][rang]+=psc;
<a name="l01466"></a>01466                             }
<a name="l01467"></a>01467                           arete1=tmp;
<a name="l01468"></a>01468                         }
<a name="l01469"></a>01469                     }
<a name="l01470"></a>01470                   jj=k+1;
<a name="l01471"></a>01471                 }
<a name="l01472"></a>01472             }
<a name="l01473"></a>01473         }
<a name="l01474"></a>01474     }
<a name="l01475"></a>01475 }
<a name="l01476"></a>01476 
<a name="l01477"></a>01477 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l01478"></a><a class="code" href="AssembleurPP1BUtil_8cpp.html#a6e9d49381847c5756d002970ca6441b8">01478</a> <a class="code" href="AssembleurPP1BUtil_8cpp.html#a6e9d49381847c5756d002970ca6441b8">update_matrice_SymetriePaPa</a>(<span class="keyword">const</span> <a class="code" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a>&amp; zone_VEF,
<a name="l01479"></a>01479                             <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; inverse_quantitee_entrelacee,
<a name="l01480"></a>01480                             <span class="keywordtype">int</span> face, <span class="keywordtype">int</span> elem,
<a name="l01481"></a>01481                             <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; sommets, <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; faces_op1,
<a name="l01482"></a>01482                             <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; ARR, <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; ARV,
<a name="l01483"></a>01483                             <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; AVR, <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; AVV)
<a name="l01484"></a>01484 {
<a name="l01485"></a>01485   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; elem_aretes=zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#a1e1e86ef5b088c4d33d42cd38a967b4a" title="renvoie le numero de la jeme arete du ieme element.">elem_aretes</a>();
<a name="l01486"></a>01486   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; aretes_som=zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#affa60690e1b372fa4c01d6088267dbe4" title="renvoie le tableau de connectivite aretes/sommets.">aretes_som</a>();
<a name="l01487"></a>01487   <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; ok_arete=zone_VEF.<a class="code" href="classZone__VEF__PreP1b.html#a83771f784d487e346b2ef22a389472a2">get_ok_arete</a>();
<a name="l01488"></a>01488   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; face_voisins=zone_VEF.<a class="code" href="classZone__VF.html#a49d4322f5585a8fa95748ca785b70702" title="renvoie l&#39;element voisin de numface dans la direction i. i=0 : dans le sens oppose de l&#39;axe orthogona...">face_voisins</a>();
<a name="l01489"></a>01489   <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; normales = zone_VEF.<a class="code" href="classZone__VEF.html#a5742d75972e4846bf9fbb6ed5715053e">face_normales</a>();
<a name="l01490"></a>01490   <span class="keywordtype">int</span> i, j, k, l;
<a name="l01491"></a>01491   <span class="keywordtype">int</span> nb_aretes_tot=zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#a3e3b48691911fd85574c7bc10a1a4fb8" title="renvoie le nombre d&#39;aretes reelles.">nb_aretes</a>();
<a name="l01492"></a>01492 
<a name="l01493"></a>01493   <span class="keywordtype">double</span> psc;
<a name="l01494"></a>01494   <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a> grad1(3);
<a name="l01495"></a>01495   <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a> grad2(3);
<a name="l01496"></a>01496   <span class="keywordflow">for</span>(i=0; i&lt;3; i++)
<a name="l01497"></a>01497     {
<a name="l01498"></a>01498       <span class="keywordtype">int</span> si=sommets(i);
<a name="l01499"></a>01499       <span class="keywordflow">for</span>(j=i+1; j&lt;4; j++)
<a name="l01500"></a>01500         {
<a name="l01501"></a>01501           <span class="keywordtype">int</span> sj=sommets(j);
<a name="l01502"></a>01502           <span class="keywordtype">int</span> arete1;
<a name="l01503"></a>01503           arete1 = <a class="code" href="AssembleurPP1BUtil_8cpp.html#ae1c00f10faaf4da3ffdea8f881565a1b">chercher_arete</a>(zone_VEF,elem, si, sj,
<a name="l01504"></a>01504                                   elem_aretes, aretes_som);
<a name="l01505"></a>01505           <span class="keywordflow">if</span>(ok_arete(arete1))
<a name="l01506"></a>01506             {
<a name="l01507"></a>01507               <a class="code" href="AssembleurPP1BUtil_8cpp.html#aa26334c33fd016e71cbab82de7ef2fe5">calculer_grad_arete</a>(face, face_voisins, i, j,
<a name="l01508"></a>01508                                   elem, -1,
<a name="l01509"></a>01509                                   faces_op1(i), -1,
<a name="l01510"></a>01510                                   faces_op1(j), -1,
<a name="l01511"></a>01511                                   normales, grad1);
<a name="l01512"></a>01512               <a class="code" href="Champ__Generique__Transformation_8cpp.html#a0705a900f8a8003047df2f59d6cd4bae">projette</a>(grad1, face, normales);
<a name="l01513"></a>01513               <span class="keywordflow">if</span>(arete1&lt;nb_aretes_tot)
<a name="l01514"></a>01514                 ARR(arete1,arete1)+=<a class="code" href="AssembleurPP1BUtil_8cpp.html#a828055cfc33e4c56db8e2f5beb059862">dotproduct_array_fois_inverse_quantitee_entrelacee</a>(grad1,grad1,
<a name="l01515"></a>01515                                                                                        inverse_quantitee_entrelacee,face);
<a name="l01516"></a>01516               <span class="keywordtype">int</span> jj=j;
<a name="l01517"></a>01517               <span class="keywordflow">for</span>(k=i; k&lt;3; k++)
<a name="l01518"></a>01518                 {
<a name="l01519"></a>01519                   <span class="keywordtype">int</span> sk=sommets(k);
<a name="l01520"></a>01520                   <span class="keywordflow">for</span>(l=jj+1; l&lt;4; l++)
<a name="l01521"></a>01521                     {
<a name="l01522"></a>01522                       <span class="keywordtype">int</span> sl=sommets(l);
<a name="l01523"></a>01523                       <span class="keywordtype">int</span> arete2= <a class="code" href="AssembleurPP1BUtil_8cpp.html#ae1c00f10faaf4da3ffdea8f881565a1b">chercher_arete</a>(zone_VEF,elem, sl, sk,
<a name="l01524"></a>01524                                                  elem_aretes,
<a name="l01525"></a>01525                                                  aretes_som);
<a name="l01526"></a>01526                       assert(arete2!=-1);
<a name="l01527"></a>01527                       <span class="keywordflow">if</span>(ok_arete(arete2))
<a name="l01528"></a>01528                         {
<a name="l01529"></a>01529                           <a class="code" href="AssembleurPP1BUtil_8cpp.html#aa26334c33fd016e71cbab82de7ef2fe5">calculer_grad_arete</a>(face, face_voisins, k, l,
<a name="l01530"></a>01530                                               elem, -1,
<a name="l01531"></a>01531                                               faces_op1(k), -1,
<a name="l01532"></a>01532                                               faces_op1(l), -1,
<a name="l01533"></a>01533                                               normales, grad2);
<a name="l01534"></a>01534                           <a class="code" href="Champ__Generique__Transformation_8cpp.html#a0705a900f8a8003047df2f59d6cd4bae">projette</a>(grad2, face, normales);
<a name="l01535"></a>01535                           psc=<a class="code" href="AssembleurPP1BUtil_8cpp.html#a828055cfc33e4c56db8e2f5beb059862">dotproduct_array_fois_inverse_quantitee_entrelacee</a>(grad1,grad2,
<a name="l01536"></a>01536                                                                                  inverse_quantitee_entrelacee,face);
<a name="l01537"></a>01537                           <span class="keywordtype">int</span> tmp=arete1;
<a name="l01538"></a>01538                           <span class="keywordflow">if</span>(arete1&gt;arete2) <a class="code" href="AssembleurPP1BUtil_8cpp.html#a3117b050530c46b4a15b6ab9ce6d0b41">swap</a>(arete1, arete2);
<a name="l01539"></a>01539                           <span class="keywordflow">if</span>(arete1&lt;nb_aretes_tot)
<a name="l01540"></a>01540                             <span class="keywordflow">if</span>(arete2&lt;nb_aretes_tot)
<a name="l01541"></a>01541                               ARR(arete1,arete2)+=psc;
<a name="l01542"></a>01542                             <span class="keywordflow">else</span>
<a name="l01543"></a>01543                               ARV(arete1,arete2-nb_aretes_tot)+=psc;
<a name="l01544"></a>01544                           <span class="keywordflow">else</span> <span class="keywordflow">if</span>(arete2&lt;nb_aretes_tot)
<a name="l01545"></a>01545                             AVR(arete1-nb_aretes_tot,arete2)+=psc;
<a name="l01546"></a>01546                           <span class="keywordflow">else</span>
<a name="l01547"></a>01547                             AVV(arete1-nb_aretes_tot,arete2-nb_aretes_tot)+=psc;
<a name="l01548"></a>01548                           arete1=tmp;
<a name="l01549"></a>01549                         }
<a name="l01550"></a>01550                     }
<a name="l01551"></a>01551                   jj=k+1;
<a name="l01552"></a>01552                 }
<a name="l01553"></a>01553             }
<a name="l01554"></a>01554         }
<a name="l01555"></a>01555     }
<a name="l01556"></a>01556 }
<a name="l01557"></a>01557 
<a name="l01558"></a><a class="code" href="AssembleurPP1BUtil_8cpp.html#a36c4cdf9e6baa421844cf7cffa1396df">01558</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="AssembleurPP1BUtil_8cpp.html#a36c4cdf9e6baa421844cf7cffa1396df">contribuer_matriceP0Pa</a>(<span class="keyword">const</span> <a class="code" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a>&amp; zone_VEF,
<a name="l01559"></a>01559                                    <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; inverse_quantitee_entrelacee,
<a name="l01560"></a>01560                                    <span class="keywordtype">int</span> face, <span class="keywordtype">int</span> elem1, <span class="keywordtype">int</span> elem2,
<a name="l01561"></a>01561                                    <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; sommets,
<a name="l01562"></a>01562                                    <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; faces_op1,
<a name="l01563"></a>01563                                    <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; faces_op2,
<a name="l01564"></a>01564                                    <a class="code" href="classIntLists.html" title="Un tableau de listes de type IntList.">IntLists</a>&amp; voisins,
<a name="l01565"></a>01565                                    <a class="code" href="classDoubleLists.html" title="Un tableau de listes de type DoubleList.">DoubleLists</a>&amp; coeffs,
<a name="l01566"></a>01566                                    <span class="keywordtype">int</span>&amp; nnz)
<a name="l01567"></a>01567 {
<a name="l01568"></a>01568   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; elem_aretes=zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#a1e1e86ef5b088c4d33d42cd38a967b4a" title="renvoie le numero de la jeme arete du ieme element.">elem_aretes</a>();
<a name="l01569"></a>01569   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; aretes_som=zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#affa60690e1b372fa4c01d6088267dbe4" title="renvoie le tableau de connectivite aretes/sommets.">aretes_som</a>();
<a name="l01570"></a>01570   <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; ok_arete=zone_VEF.<a class="code" href="classZone__VEF__PreP1b.html#a83771f784d487e346b2ef22a389472a2">get_ok_arete</a>();
<a name="l01571"></a>01571   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; face_voisins=zone_VEF.<a class="code" href="classZone__VF.html#a49d4322f5585a8fa95748ca785b70702" title="renvoie l&#39;element voisin de numface dans la direction i. i=0 : dans le sens oppose de l&#39;axe orthogona...">face_voisins</a>();
<a name="l01572"></a>01572   <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; normales = zone_VEF.<a class="code" href="classZone__VEF.html#a5742d75972e4846bf9fbb6ed5715053e">face_normales</a>();
<a name="l01573"></a>01573   <span class="keywordtype">int</span> i, j;
<a name="l01574"></a>01574   <span class="keywordtype">double</span> psc;
<a name="l01575"></a>01575   <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a> grad1(3);
<a name="l01576"></a>01576   <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a> grad2(3);
<a name="l01577"></a>01577   <span class="keywordtype">int</span> jmax=5;
<a name="l01578"></a>01578   <span class="keywordflow">if</span>(elem2==-1) jmax=4;
<a name="l01579"></a>01579   <span class="keywordflow">for</span>(i=0; i&lt;3; i++)
<a name="l01580"></a>01580     {
<a name="l01581"></a>01581       <span class="keywordtype">int</span> si=sommets(i);
<a name="l01582"></a>01582       <span class="keywordflow">for</span>(j=i+1; j&lt;jmax; j++)
<a name="l01583"></a>01583         {
<a name="l01584"></a>01584           <span class="keywordtype">int</span> sj=sommets(j);
<a name="l01585"></a>01585           <span class="keywordtype">int</span> arete1;
<a name="l01586"></a>01586           <span class="keywordflow">if</span>(j&lt;4)
<a name="l01587"></a>01587             arete1 = <a class="code" href="AssembleurPP1BUtil_8cpp.html#ae1c00f10faaf4da3ffdea8f881565a1b">chercher_arete</a>(zone_VEF,elem1, si, sj,
<a name="l01588"></a>01588                                     elem_aretes, aretes_som);
<a name="l01589"></a>01589           <span class="keywordflow">else</span>
<a name="l01590"></a>01590             arete1 = <a class="code" href="AssembleurPP1BUtil_8cpp.html#ae1c00f10faaf4da3ffdea8f881565a1b">chercher_arete</a>(zone_VEF,elem2, si, sj,
<a name="l01591"></a>01591                                     elem_aretes, aretes_som);
<a name="l01592"></a>01592           <span class="keywordflow">if</span>(ok_arete(arete1))
<a name="l01593"></a>01593             {
<a name="l01594"></a>01594               <a class="code" href="AssembleurPP1BUtil_8cpp.html#aa26334c33fd016e71cbab82de7ef2fe5">calculer_grad_arete</a>(face, face_voisins, i, j,
<a name="l01595"></a>01595                                   elem1, elem2,
<a name="l01596"></a>01596                                   faces_op1(i), faces_op2(i),
<a name="l01597"></a>01597                                   faces_op1(j), faces_op2(j),
<a name="l01598"></a>01598                                   normales, grad1);
<a name="l01599"></a>01599               psc=0;
<a name="l01600"></a>01600               <span class="keywordflow">for</span>(<span class="keywordtype">int</span> comp=0; comp&lt;3; comp++)
<a name="l01601"></a>01601                 psc+=grad1(comp)*normales(face, comp)*
<a name="l01602"></a>01602                      (-inverse_quantitee_entrelacee(face,comp));
<a name="l01603"></a>01603               <span class="keywordtype">int</span> rang=voisins[elem1].rang(arete1);
<a name="l01604"></a>01604               <span class="keywordflow">if</span>(rang==-1)
<a name="l01605"></a>01605                 {
<a name="l01606"></a>01606                   voisins[elem1].add(arete1);
<a name="l01607"></a>01607                   coeffs[elem1].add(psc);
<a name="l01608"></a>01608                   nnz++;
<a name="l01609"></a>01609                 }
<a name="l01610"></a>01610               <span class="keywordflow">else</span>
<a name="l01611"></a>01611                 {
<a name="l01612"></a>01612                   coeffs[elem1][rang]+=psc;
<a name="l01613"></a>01613                 }
<a name="l01614"></a>01614               <span class="keywordflow">if</span>(elem2!=-1)
<a name="l01615"></a>01615                 {
<a name="l01616"></a>01616                   psc*=-1.0;
<a name="l01617"></a>01617                   <span class="keywordtype">int</span> rangbis=voisins[elem2].rang(arete1);
<a name="l01618"></a>01618                   <span class="keywordflow">if</span>(rangbis==-1)
<a name="l01619"></a>01619                     {
<a name="l01620"></a>01620                       voisins[elem2].add(arete1);
<a name="l01621"></a>01621                       coeffs[elem2].add(psc);
<a name="l01622"></a>01622                       nnz++;
<a name="l01623"></a>01623                     }
<a name="l01624"></a>01624                   <span class="keywordflow">else</span>
<a name="l01625"></a>01625                     {
<a name="l01626"></a>01626                       coeffs[elem2][rangbis]+=psc;
<a name="l01627"></a>01627                     }
<a name="l01628"></a>01628                 }
<a name="l01629"></a>01629             }
<a name="l01630"></a>01630         }
<a name="l01631"></a>01631     }
<a name="l01632"></a>01632 }
<a name="l01633"></a>01633 
<a name="l01634"></a><a class="code" href="AssembleurPP1BUtil_8cpp.html#a68f4b5d510b37d5518ed576764da2611">01634</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="AssembleurPP1BUtil_8cpp.html#a68f4b5d510b37d5518ed576764da2611">update_matriceP0Pa</a>(<span class="keyword">const</span> <a class="code" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a>&amp; zone_VEF,
<a name="l01635"></a>01635                                <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; inverse_quantitee_entrelacee,
<a name="l01636"></a>01636                                <span class="keywordtype">int</span> face, <span class="keywordtype">int</span> elem1, <span class="keywordtype">int</span> elem2,
<a name="l01637"></a>01637                                <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; sommets,
<a name="l01638"></a>01638                                <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; faces_op1,
<a name="l01639"></a>01639                                <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; faces_op2,
<a name="l01640"></a>01640                                <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; ARR, <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; ARV,
<a name="l01641"></a>01641                                <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; AVR, <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; AVV)
<a name="l01642"></a>01642 {
<a name="l01643"></a>01643   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; elem_aretes=zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#a1e1e86ef5b088c4d33d42cd38a967b4a" title="renvoie le numero de la jeme arete du ieme element.">elem_aretes</a>();
<a name="l01644"></a>01644   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; aretes_som=zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#affa60690e1b372fa4c01d6088267dbe4" title="renvoie le tableau de connectivite aretes/sommets.">aretes_som</a>();
<a name="l01645"></a>01645   <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; ok_arete=zone_VEF.<a class="code" href="classZone__VEF__PreP1b.html#a83771f784d487e346b2ef22a389472a2">get_ok_arete</a>();
<a name="l01646"></a>01646   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; face_voisins=zone_VEF.<a class="code" href="classZone__VF.html#a49d4322f5585a8fa95748ca785b70702" title="renvoie l&#39;element voisin de numface dans la direction i. i=0 : dans le sens oppose de l&#39;axe orthogona...">face_voisins</a>();
<a name="l01647"></a>01647   <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; normales = zone_VEF.<a class="code" href="classZone__VEF.html#a5742d75972e4846bf9fbb6ed5715053e">face_normales</a>();
<a name="l01648"></a>01648   <span class="keywordtype">int</span> nb_aretes_tot=zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#a3e3b48691911fd85574c7bc10a1a4fb8" title="renvoie le nombre d&#39;aretes reelles.">nb_aretes</a>();
<a name="l01649"></a>01649   <span class="keywordtype">int</span> nb_elem_tot=zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#a7f249429803b27139a1c54436f6164a5" title="Renvoie le nombre d&#39;elements de la zone.">nb_elem</a>();
<a name="l01650"></a>01650 
<a name="l01651"></a>01651   <span class="keywordtype">int</span> i, j;
<a name="l01652"></a>01652   <span class="keywordtype">double</span> psc;
<a name="l01653"></a>01653   <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a> grad1(3);
<a name="l01654"></a>01654   <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a> grad2(3);
<a name="l01655"></a>01655   <span class="keywordtype">int</span> jmax=5;
<a name="l01656"></a>01656   <span class="keywordflow">if</span>(elem2==-1) jmax=4;
<a name="l01657"></a>01657   <span class="keywordflow">for</span>(i=0; i&lt;3; i++)
<a name="l01658"></a>01658     {
<a name="l01659"></a>01659       <span class="keywordtype">int</span> si=sommets(i);
<a name="l01660"></a>01660       <span class="keywordflow">for</span>(j=i+1; j&lt;jmax; j++)
<a name="l01661"></a>01661         {
<a name="l01662"></a>01662           <span class="keywordtype">int</span> sj=sommets(j);
<a name="l01663"></a>01663           <span class="keywordtype">int</span> arete1;
<a name="l01664"></a>01664           <span class="keywordflow">if</span>(j&lt;4)
<a name="l01665"></a>01665             arete1 = <a class="code" href="AssembleurPP1BUtil_8cpp.html#ae1c00f10faaf4da3ffdea8f881565a1b">chercher_arete</a>(zone_VEF,elem1, si, sj,
<a name="l01666"></a>01666                                     elem_aretes, aretes_som);
<a name="l01667"></a>01667           <span class="keywordflow">else</span>
<a name="l01668"></a>01668             arete1 = <a class="code" href="AssembleurPP1BUtil_8cpp.html#ae1c00f10faaf4da3ffdea8f881565a1b">chercher_arete</a>(zone_VEF,elem2, si, sj,
<a name="l01669"></a>01669                                     elem_aretes, aretes_som);
<a name="l01670"></a>01670           <span class="keywordflow">if</span>(ok_arete(arete1))
<a name="l01671"></a>01671             {
<a name="l01672"></a>01672               <a class="code" href="AssembleurPP1BUtil_8cpp.html#aa26334c33fd016e71cbab82de7ef2fe5">calculer_grad_arete</a>(face, face_voisins, i, j,
<a name="l01673"></a>01673                                   elem1, elem2,
<a name="l01674"></a>01674                                   faces_op1(i), faces_op2(i),
<a name="l01675"></a>01675                                   faces_op1(j), faces_op2(j),
<a name="l01676"></a>01676                                   normales, grad1);
<a name="l01677"></a>01677               psc=0;
<a name="l01678"></a>01678               <span class="keywordflow">for</span>(<span class="keywordtype">int</span> comp=0; comp&lt;3; comp++)
<a name="l01679"></a>01679                 psc+=grad1(comp)*normales(face, comp)
<a name="l01680"></a>01680                      *(-inverse_quantitee_entrelacee(face,comp));
<a name="l01681"></a>01681               <span class="keywordflow">if</span>(elem1&lt;nb_elem_tot)
<a name="l01682"></a>01682                 <span class="keywordflow">if</span>(arete1&lt;nb_aretes_tot)
<a name="l01683"></a>01683                   ARR(elem1,arete1)+=psc;
<a name="l01684"></a>01684                 <span class="keywordflow">else</span>
<a name="l01685"></a>01685                   ARV(elem1,arete1-nb_aretes_tot)+=psc;
<a name="l01686"></a>01686               <span class="keywordflow">else</span> <span class="keywordflow">if</span>(arete1&lt;nb_aretes_tot)
<a name="l01687"></a>01687                 AVR(elem1-nb_elem_tot,arete1)+=psc;
<a name="l01688"></a>01688               <span class="keywordflow">else</span>
<a name="l01689"></a>01689                 AVV(elem1-nb_elem_tot,arete1-nb_aretes_tot)+=psc;
<a name="l01690"></a>01690 
<a name="l01691"></a>01691               <span class="keywordflow">if</span>(elem2!=-1)
<a name="l01692"></a>01692                 {
<a name="l01693"></a>01693                   psc*=-1.0;
<a name="l01694"></a>01694                   <span class="keywordflow">if</span>(elem2&lt;nb_elem_tot)
<a name="l01695"></a>01695                     <span class="keywordflow">if</span>(arete1&lt;nb_aretes_tot)
<a name="l01696"></a>01696                       ARR(elem2,arete1)+=psc;
<a name="l01697"></a>01697                     <span class="keywordflow">else</span>
<a name="l01698"></a>01698                       ARV(elem2,arete1-nb_aretes_tot)+=psc;
<a name="l01699"></a>01699                   <span class="keywordflow">else</span> <span class="keywordflow">if</span>(arete1&lt;nb_aretes_tot)
<a name="l01700"></a>01700                     AVR(elem2-nb_elem_tot,arete1)+=psc;
<a name="l01701"></a>01701                   <span class="keywordflow">else</span>
<a name="l01702"></a>01702                     AVV(elem2-nb_elem_tot,arete1-nb_aretes_tot)+=psc;
<a name="l01703"></a>01703                 }
<a name="l01704"></a>01704             }
<a name="l01705"></a>01705         }
<a name="l01706"></a>01706     }
<a name="l01707"></a>01707 }
<a name="l01708"></a>01708 
<a name="l01709"></a>01709 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l01710"></a><a class="code" href="AssembleurPP1BUtil_8cpp.html#ae709048ec2f850b47b8601c013ed8550">01710</a> <a class="code" href="AssembleurPP1BUtil_8cpp.html#ae709048ec2f850b47b8601c013ed8550">contribuer_matrice_NeumannP0Pa</a>(<span class="keyword">const</span> <a class="code" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a>&amp; zone_VEF,
<a name="l01711"></a>01711                                <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; inverse_quantitee_entrelacee,
<a name="l01712"></a>01712                                <span class="keywordtype">int</span> face, <span class="keywordtype">int</span> elem,
<a name="l01713"></a>01713                                <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; sommets,
<a name="l01714"></a>01714                                <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; faces_op1,
<a name="l01715"></a>01715                                <a class="code" href="classIntLists.html" title="Un tableau de listes de type IntList.">IntLists</a>&amp; voisins,
<a name="l01716"></a>01716                                <a class="code" href="classDoubleLists.html" title="Un tableau de listes de type DoubleList.">DoubleLists</a>&amp; coeffs,
<a name="l01717"></a>01717                                <span class="keywordtype">int</span>&amp; nnz)
<a name="l01718"></a>01718 {
<a name="l01719"></a>01719   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; elem_aretes=zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#a1e1e86ef5b088c4d33d42cd38a967b4a" title="renvoie le numero de la jeme arete du ieme element.">elem_aretes</a>();
<a name="l01720"></a>01720   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; aretes_som=zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#affa60690e1b372fa4c01d6088267dbe4" title="renvoie le tableau de connectivite aretes/sommets.">aretes_som</a>();
<a name="l01721"></a>01721   <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; ok_arete=zone_VEF.<a class="code" href="classZone__VEF__PreP1b.html#a83771f784d487e346b2ef22a389472a2">get_ok_arete</a>();
<a name="l01722"></a>01722   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; face_voisins=zone_VEF.<a class="code" href="classZone__VF.html#a49d4322f5585a8fa95748ca785b70702" title="renvoie l&#39;element voisin de numface dans la direction i. i=0 : dans le sens oppose de l&#39;axe orthogona...">face_voisins</a>();
<a name="l01723"></a>01723   <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; normales = zone_VEF.<a class="code" href="classZone__VEF.html#a5742d75972e4846bf9fbb6ed5715053e">face_normales</a>();
<a name="l01724"></a>01724   <span class="keywordtype">int</span> i, j;
<a name="l01725"></a>01725   <span class="keywordtype">double</span> psc;
<a name="l01726"></a>01726   <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a> grad1(3);
<a name="l01727"></a>01727   <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a> grad2(3);
<a name="l01728"></a>01728   <span class="keywordflow">for</span>(i=0; i&lt;3; i++)
<a name="l01729"></a>01729     {
<a name="l01730"></a>01730       <span class="keywordtype">int</span> si=sommets(i);
<a name="l01731"></a>01731       <span class="keywordflow">for</span>(j=i+1; j&lt;4; j++)
<a name="l01732"></a>01732         {
<a name="l01733"></a>01733           <span class="keywordtype">int</span> sj=sommets(j);
<a name="l01734"></a>01734           <span class="keywordtype">int</span> arete1;
<a name="l01735"></a>01735           arete1 = <a class="code" href="AssembleurPP1BUtil_8cpp.html#ae1c00f10faaf4da3ffdea8f881565a1b">chercher_arete</a>(zone_VEF,elem, si, sj,
<a name="l01736"></a>01736                                   elem_aretes, aretes_som);
<a name="l01737"></a>01737           <span class="keywordflow">if</span>(ok_arete(arete1))
<a name="l01738"></a>01738             {
<a name="l01739"></a>01739               <a class="code" href="AssembleurPP1BUtil_8cpp.html#aa26334c33fd016e71cbab82de7ef2fe5">calculer_grad_arete</a>(face, face_voisins, i, j,
<a name="l01740"></a>01740                                   elem, -1,
<a name="l01741"></a>01741                                   faces_op1(i), -1,
<a name="l01742"></a>01742                                   faces_op1(j), -1,
<a name="l01743"></a>01743                                   normales, grad1);
<a name="l01744"></a>01744               psc=0;
<a name="l01745"></a>01745               <span class="keywordflow">for</span>(<span class="keywordtype">int</span> comp=0; comp&lt;3; comp++)
<a name="l01746"></a>01746                 psc+=grad1(comp)*normales(face, comp)
<a name="l01747"></a>01747                      *(-inverse_quantitee_entrelacee(face,comp));
<a name="l01748"></a>01748               <span class="keywordtype">int</span> rang=voisins[elem].rang(arete1);
<a name="l01749"></a>01749               <span class="keywordflow">if</span>(rang==-1)
<a name="l01750"></a>01750                 {
<a name="l01751"></a>01751                   voisins[elem].add(arete1);
<a name="l01752"></a>01752                   coeffs[elem].add(psc);
<a name="l01753"></a>01753                   nnz++;
<a name="l01754"></a>01754                 }
<a name="l01755"></a>01755               <span class="keywordflow">else</span>
<a name="l01756"></a>01756                 {
<a name="l01757"></a>01757                   coeffs[elem][rang]+=psc;
<a name="l01758"></a>01758                 }
<a name="l01759"></a>01759             }
<a name="l01760"></a>01760         }
<a name="l01761"></a>01761     }
<a name="l01762"></a>01762 }
<a name="l01763"></a>01763 
<a name="l01764"></a>01764 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l01765"></a><a class="code" href="AssembleurPP1BUtil_8cpp.html#a45b45851ba59992d7eb7a25c002a9f73">01765</a> <a class="code" href="AssembleurPP1BUtil_8cpp.html#a45b45851ba59992d7eb7a25c002a9f73">update_matrice_NeumannP0Pa</a>(<span class="keyword">const</span> <a class="code" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a>&amp; zone_VEF,
<a name="l01766"></a>01766                            <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; inverse_quantitee_entrelacee,
<a name="l01767"></a>01767                            <span class="keywordtype">int</span> face, <span class="keywordtype">int</span> elem,
<a name="l01768"></a>01768                            <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; sommets,
<a name="l01769"></a>01769                            <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; faces_op1,
<a name="l01770"></a>01770                            <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; ARR, <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; ARV,
<a name="l01771"></a>01771                            <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; AVR, <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; AVV)
<a name="l01772"></a>01772 {
<a name="l01773"></a>01773   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; elem_aretes=zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#a1e1e86ef5b088c4d33d42cd38a967b4a" title="renvoie le numero de la jeme arete du ieme element.">elem_aretes</a>();
<a name="l01774"></a>01774   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; aretes_som=zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#affa60690e1b372fa4c01d6088267dbe4" title="renvoie le tableau de connectivite aretes/sommets.">aretes_som</a>();
<a name="l01775"></a>01775   <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; ok_arete=zone_VEF.<a class="code" href="classZone__VEF__PreP1b.html#a83771f784d487e346b2ef22a389472a2">get_ok_arete</a>();
<a name="l01776"></a>01776   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; face_voisins=zone_VEF.<a class="code" href="classZone__VF.html#a49d4322f5585a8fa95748ca785b70702" title="renvoie l&#39;element voisin de numface dans la direction i. i=0 : dans le sens oppose de l&#39;axe orthogona...">face_voisins</a>();
<a name="l01777"></a>01777   <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; normales = zone_VEF.<a class="code" href="classZone__VEF.html#a5742d75972e4846bf9fbb6ed5715053e">face_normales</a>();
<a name="l01778"></a>01778   <span class="keywordtype">int</span> nb_aretes_tot=zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#a3e3b48691911fd85574c7bc10a1a4fb8" title="renvoie le nombre d&#39;aretes reelles.">nb_aretes</a>();
<a name="l01779"></a>01779   <span class="keywordtype">int</span> nb_elem_tot=zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#a7f249429803b27139a1c54436f6164a5" title="Renvoie le nombre d&#39;elements de la zone.">nb_elem</a>();
<a name="l01780"></a>01780 
<a name="l01781"></a>01781   <span class="keywordtype">int</span> i, j;
<a name="l01782"></a>01782   <span class="keywordtype">double</span> psc;
<a name="l01783"></a>01783   <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a> grad1(3);
<a name="l01784"></a>01784   <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a> grad2(3);
<a name="l01785"></a>01785   <span class="keywordflow">for</span>(i=0; i&lt;3; i++)
<a name="l01786"></a>01786     {
<a name="l01787"></a>01787       <span class="keywordtype">int</span> si=sommets(i);
<a name="l01788"></a>01788       <span class="keywordflow">for</span>(j=i+1; j&lt;4; j++)
<a name="l01789"></a>01789         {
<a name="l01790"></a>01790           <span class="keywordtype">int</span> sj=sommets(j);
<a name="l01791"></a>01791           <span class="keywordtype">int</span> arete1;
<a name="l01792"></a>01792           arete1 = <a class="code" href="AssembleurPP1BUtil_8cpp.html#ae1c00f10faaf4da3ffdea8f881565a1b">chercher_arete</a>(zone_VEF,elem, si, sj,
<a name="l01793"></a>01793                                   elem_aretes, aretes_som);
<a name="l01794"></a>01794           <span class="keywordflow">if</span>(ok_arete(arete1))
<a name="l01795"></a>01795             {
<a name="l01796"></a>01796               <a class="code" href="AssembleurPP1BUtil_8cpp.html#aa26334c33fd016e71cbab82de7ef2fe5">calculer_grad_arete</a>(face, face_voisins, i, j,
<a name="l01797"></a>01797                                   elem, -1,
<a name="l01798"></a>01798                                   faces_op1(i), -1,
<a name="l01799"></a>01799                                   faces_op1(j), -1,
<a name="l01800"></a>01800                                   normales, grad1);
<a name="l01801"></a>01801               psc=0;
<a name="l01802"></a>01802               <span class="keywordflow">for</span>(<span class="keywordtype">int</span> comp=0; comp&lt;3; comp++)
<a name="l01803"></a>01803                 psc+=grad1(comp)*normales(face, comp)
<a name="l01804"></a>01804                      *(-inverse_quantitee_entrelacee(face,comp));
<a name="l01805"></a>01805               <span class="keywordflow">if</span>(elem&lt;nb_elem_tot)
<a name="l01806"></a>01806                 <span class="keywordflow">if</span>(arete1&lt;nb_aretes_tot)
<a name="l01807"></a>01807                   ARR(elem,arete1)+=psc;
<a name="l01808"></a>01808                 <span class="keywordflow">else</span>
<a name="l01809"></a>01809                   ARV(elem,arete1-nb_aretes_tot)+=psc;
<a name="l01810"></a>01810               <span class="keywordflow">else</span> <span class="keywordflow">if</span>(arete1&lt;nb_aretes_tot)
<a name="l01811"></a>01811                 AVR(elem-nb_elem_tot,arete1)+=psc;
<a name="l01812"></a>01812               <span class="keywordflow">else</span>
<a name="l01813"></a>01813                 AVV(elem-nb_elem_tot,arete1-nb_aretes_tot)+=psc;
<a name="l01814"></a>01814             }
<a name="l01815"></a>01815         }
<a name="l01816"></a>01816     }
<a name="l01817"></a>01817 }
<a name="l01818"></a>01818 
<a name="l01819"></a><a class="code" href="AssembleurPP1BUtil_8cpp.html#a0000fbbb1165039c7071352be4a35877">01819</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="AssembleurPP1BUtil_8cpp.html#a0000fbbb1165039c7071352be4a35877">contribuer_matriceP1Pa</a>(<span class="keyword">const</span> <a class="code" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a>&amp; zone_VEF,
<a name="l01820"></a>01820                                    <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; inverse_quantitee_entrelacee,
<a name="l01821"></a>01821                                    <span class="keywordtype">int</span> face, <span class="keywordtype">int</span> elem1, <span class="keywordtype">int</span> elem2,
<a name="l01822"></a>01822                                    <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; sommets,
<a name="l01823"></a>01823                                    <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; faces_op1,
<a name="l01824"></a>01824                                    <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; faces_op2,           <span class="keyword">const</span> <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a>&amp; coef_som,
<a name="l01825"></a>01825                                    <a class="code" href="classIntLists.html" title="Un tableau de listes de type IntList.">IntLists</a>&amp; voisins,
<a name="l01826"></a>01826                                    <a class="code" href="classDoubleLists.html" title="Un tableau de listes de type DoubleList.">DoubleLists</a>&amp; coeffs,
<a name="l01827"></a>01827                                    <span class="keywordtype">int</span>&amp; nnz)
<a name="l01828"></a>01828 {
<a name="l01829"></a>01829 <span class="comment">// int dimension=Objet_U::dimension,</span>
<a name="l01830"></a>01830 <span class="comment">// dplusun=dimension+1;</span>
<a name="l01831"></a>01831 <span class="comment">// double coeff_som=1./(dimension)/(dplusun);</span>
<a name="l01832"></a>01832   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; elem_aretes=zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#a1e1e86ef5b088c4d33d42cd38a967b4a" title="renvoie le numero de la jeme arete du ieme element.">elem_aretes</a>();
<a name="l01833"></a>01833   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; aretes_som=zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#affa60690e1b372fa4c01d6088267dbe4" title="renvoie le tableau de connectivite aretes/sommets.">aretes_som</a>();
<a name="l01834"></a>01834   <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; ok_arete=zone_VEF.<a class="code" href="classZone__VEF__PreP1b.html#a83771f784d487e346b2ef22a389472a2">get_ok_arete</a>();
<a name="l01835"></a>01835   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; face_voisins=zone_VEF.<a class="code" href="classZone__VF.html#a49d4322f5585a8fa95748ca785b70702" title="renvoie l&#39;element voisin de numface dans la direction i. i=0 : dans le sens oppose de l&#39;axe orthogona...">face_voisins</a>();
<a name="l01836"></a>01836   <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; normales = zone_VEF.<a class="code" href="classZone__VEF.html#a5742d75972e4846bf9fbb6ed5715053e">face_normales</a>();
<a name="l01837"></a>01837   <span class="keywordtype">int</span> i, j, k;
<a name="l01838"></a>01838   <span class="keywordtype">double</span> psc;
<a name="l01839"></a>01839   <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a> grad1(3);
<a name="l01840"></a>01840   <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a> grad2(3);
<a name="l01841"></a>01841   <span class="keywordtype">int</span> jmax=5;
<a name="l01842"></a>01842   <span class="keywordflow">if</span>(elem2==-1) jmax=4;
<a name="l01843"></a>01843   <span class="keywordflow">for</span>(i=0; i&lt;3; i++)
<a name="l01844"></a>01844     {
<a name="l01845"></a>01845       <span class="keywordtype">int</span> si=sommets(i);
<a name="l01846"></a>01846       <span class="keywordflow">for</span>(j=i+1; j&lt;jmax; j++)
<a name="l01847"></a>01847         {
<a name="l01848"></a>01848           <span class="keywordtype">int</span> sj=sommets(j);
<a name="l01849"></a>01849           <span class="keywordtype">int</span> arete1;
<a name="l01850"></a>01850           <span class="keywordflow">if</span>(j&lt;4)
<a name="l01851"></a>01851             arete1 = <a class="code" href="AssembleurPP1BUtil_8cpp.html#ae1c00f10faaf4da3ffdea8f881565a1b">chercher_arete</a>(zone_VEF,elem1, si, sj,
<a name="l01852"></a>01852                                     elem_aretes, aretes_som);
<a name="l01853"></a>01853           <span class="keywordflow">else</span>
<a name="l01854"></a>01854             arete1 = <a class="code" href="AssembleurPP1BUtil_8cpp.html#ae1c00f10faaf4da3ffdea8f881565a1b">chercher_arete</a>(zone_VEF,elem2, si, sj,
<a name="l01855"></a>01855                                     elem_aretes, aretes_som);
<a name="l01856"></a>01856           <span class="keywordflow">if</span>(ok_arete(arete1))
<a name="l01857"></a>01857             {
<a name="l01858"></a>01858               <a class="code" href="AssembleurPP1BUtil_8cpp.html#aa26334c33fd016e71cbab82de7ef2fe5">calculer_grad_arete</a>(face, face_voisins, i, j,
<a name="l01859"></a>01859                                   elem1, elem2,
<a name="l01860"></a>01860                                   faces_op1(i), faces_op2(i),
<a name="l01861"></a>01861                                   faces_op1(j), faces_op2(j),
<a name="l01862"></a>01862                                   normales, grad1);
<a name="l01863"></a>01863               <span class="keywordflow">for</span>(k=0; k&lt;jmax; k++)
<a name="l01864"></a>01864                 {
<a name="l01865"></a>01865                   <span class="keywordtype">int</span> sk=sommets(k);
<a name="l01866"></a>01866                   <a class="code" href="AssembleurPP1BUtil_8cpp.html#a556b82e62a565319fb25218f97cfc50c">calculer_grad</a>(face_voisins, elem1, elem2, coef_som, sk,
<a name="l01867"></a>01867                                 faces_op1(k), faces_op2(k),
<a name="l01868"></a>01868                                 normales, grad2);
<a name="l01869"></a>01869                   psc=-<a class="code" href="AssembleurPP1BUtil_8cpp.html#a828055cfc33e4c56db8e2f5beb059862">dotproduct_array_fois_inverse_quantitee_entrelacee</a>(grad1,grad2,
<a name="l01870"></a>01870                                                                           inverse_quantitee_entrelacee,face);
<a name="l01871"></a>01871                   <span class="keywordtype">int</span> rang1=voisins[sk].rang(arete1);
<a name="l01872"></a>01872                   <span class="keywordflow">if</span>(rang1==-1)
<a name="l01873"></a>01873                     {
<a name="l01874"></a>01874                       voisins[sk].add(arete1);
<a name="l01875"></a>01875                       coeffs[sk].add(psc);
<a name="l01876"></a>01876                       nnz++;
<a name="l01877"></a>01877                     }
<a name="l01878"></a>01878                   <span class="keywordflow">else</span>
<a name="l01879"></a>01879                     {
<a name="l01880"></a>01880                       coeffs[sk][rang1]+=psc;
<a name="l01881"></a>01881                     }
<a name="l01882"></a>01882                 }
<a name="l01883"></a>01883             }
<a name="l01884"></a>01884         }
<a name="l01885"></a>01885     }
<a name="l01886"></a>01886 }
<a name="l01887"></a>01887 
<a name="l01888"></a><a class="code" href="AssembleurPP1BUtil_8cpp.html#ac499159b3caa7be06c8c9fddfdb5c8c1">01888</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="AssembleurPP1BUtil_8cpp.html#ac499159b3caa7be06c8c9fddfdb5c8c1">update_matriceP1Pa</a>(<span class="keyword">const</span> <a class="code" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a>&amp; zone_VEF,
<a name="l01889"></a>01889                                <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; inverse_quantitee_entrelacee,
<a name="l01890"></a>01890                                <span class="keywordtype">int</span> face, <span class="keywordtype">int</span> elem1, <span class="keywordtype">int</span> elem2,
<a name="l01891"></a>01891                                <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; sommets,
<a name="l01892"></a>01892                                <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; faces_op1,
<a name="l01893"></a>01893                                <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; faces_op2,           <span class="keyword">const</span> <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a>&amp; coef_som,
<a name="l01894"></a>01894                                <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; ARR, <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; ARV,
<a name="l01895"></a>01895                                <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; AVR, <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; AVV)
<a name="l01896"></a>01896 {
<a name="l01897"></a>01897 <span class="comment">// int dimension=Objet_U::dimension,</span>
<a name="l01898"></a>01898 <span class="comment">// dplusun=dimension+1;</span>
<a name="l01899"></a>01899 <span class="comment">// double coeff_som=1./(dimension)/(dplusun);</span>
<a name="l01900"></a>01900   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; elem_aretes=zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#a1e1e86ef5b088c4d33d42cd38a967b4a" title="renvoie le numero de la jeme arete du ieme element.">elem_aretes</a>();
<a name="l01901"></a>01901   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; aretes_som=zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#affa60690e1b372fa4c01d6088267dbe4" title="renvoie le tableau de connectivite aretes/sommets.">aretes_som</a>();
<a name="l01902"></a>01902   <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; ok_arete=zone_VEF.<a class="code" href="classZone__VEF__PreP1b.html#a83771f784d487e346b2ef22a389472a2">get_ok_arete</a>();
<a name="l01903"></a>01903   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; face_voisins=zone_VEF.<a class="code" href="classZone__VF.html#a49d4322f5585a8fa95748ca785b70702" title="renvoie l&#39;element voisin de numface dans la direction i. i=0 : dans le sens oppose de l&#39;axe orthogona...">face_voisins</a>();
<a name="l01904"></a>01904   <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; normales = zone_VEF.<a class="code" href="classZone__VEF.html#a5742d75972e4846bf9fbb6ed5715053e">face_normales</a>();
<a name="l01905"></a>01905   <span class="keywordtype">int</span> nb_aretes_tot=zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#a3e3b48691911fd85574c7bc10a1a4fb8" title="renvoie le nombre d&#39;aretes reelles.">nb_aretes</a>();
<a name="l01906"></a>01906   <span class="keywordtype">int</span> nb_som_tot=zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#ad340f571f81fa5c2e028b88c00b5c2ca" title="Renvoie le nombre de sommets de la zone.">nb_som</a>();
<a name="l01907"></a>01907 
<a name="l01908"></a>01908   <span class="keywordtype">int</span> i, j, k;
<a name="l01909"></a>01909   <span class="keywordtype">double</span> psc;
<a name="l01910"></a>01910   <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a> grad1(3);
<a name="l01911"></a>01911   <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a> grad2(3);
<a name="l01912"></a>01912   <span class="keywordtype">int</span> jmax=5;
<a name="l01913"></a>01913   <span class="keywordflow">if</span>(elem2==-1) jmax=4;
<a name="l01914"></a>01914   <span class="keywordflow">for</span>(i=0; i&lt;3; i++)
<a name="l01915"></a>01915     {
<a name="l01916"></a>01916       <span class="keywordtype">int</span> si=sommets(i);
<a name="l01917"></a>01917       <span class="keywordflow">for</span>(j=i+1; j&lt;jmax; j++)
<a name="l01918"></a>01918         {
<a name="l01919"></a>01919           <span class="keywordtype">int</span> sj=sommets(j);
<a name="l01920"></a>01920           <span class="keywordtype">int</span> arete1;
<a name="l01921"></a>01921           <span class="keywordflow">if</span>(j&lt;4)
<a name="l01922"></a>01922             arete1 = <a class="code" href="AssembleurPP1BUtil_8cpp.html#ae1c00f10faaf4da3ffdea8f881565a1b">chercher_arete</a>(zone_VEF,elem1, si, sj,
<a name="l01923"></a>01923                                     elem_aretes, aretes_som);
<a name="l01924"></a>01924           <span class="keywordflow">else</span>
<a name="l01925"></a>01925             arete1 = <a class="code" href="AssembleurPP1BUtil_8cpp.html#ae1c00f10faaf4da3ffdea8f881565a1b">chercher_arete</a>(zone_VEF,elem2, si, sj,
<a name="l01926"></a>01926                                     elem_aretes, aretes_som);
<a name="l01927"></a>01927           <span class="keywordflow">if</span>(ok_arete(arete1))
<a name="l01928"></a>01928             {
<a name="l01929"></a>01929               <a class="code" href="AssembleurPP1BUtil_8cpp.html#aa26334c33fd016e71cbab82de7ef2fe5">calculer_grad_arete</a>(face, face_voisins, i, j,
<a name="l01930"></a>01930                                   elem1, elem2,
<a name="l01931"></a>01931                                   faces_op1(i), faces_op2(i),
<a name="l01932"></a>01932                                   faces_op1(j), faces_op2(j),
<a name="l01933"></a>01933                                   normales, grad1);
<a name="l01934"></a>01934               <span class="keywordflow">for</span>(k=0; k&lt;jmax; k++)
<a name="l01935"></a>01935                 {
<a name="l01936"></a>01936                   <span class="keywordtype">int</span> sk=sommets(k);
<a name="l01937"></a>01937                   <a class="code" href="AssembleurPP1BUtil_8cpp.html#a556b82e62a565319fb25218f97cfc50c">calculer_grad</a>(face_voisins, elem1, elem2, coef_som, sk,
<a name="l01938"></a>01938                                 faces_op1(k), faces_op2(k),
<a name="l01939"></a>01939                                 normales, grad2);
<a name="l01940"></a>01940                   psc=-<a class="code" href="AssembleurPP1BUtil_8cpp.html#a828055cfc33e4c56db8e2f5beb059862">dotproduct_array_fois_inverse_quantitee_entrelacee</a>(grad1,grad2,
<a name="l01941"></a>01941                                                                           inverse_quantitee_entrelacee,face);
<a name="l01942"></a>01942                   <span class="keywordflow">if</span>(sk&lt;nb_som_tot)
<a name="l01943"></a>01943                     <span class="keywordflow">if</span>(arete1&lt;nb_aretes_tot)
<a name="l01944"></a>01944                       ARR(sk,arete1)+=psc;
<a name="l01945"></a>01945                     <span class="keywordflow">else</span>
<a name="l01946"></a>01946                       ARV(sk,arete1-nb_aretes_tot)+=psc;
<a name="l01947"></a>01947                   <span class="keywordflow">else</span> <span class="keywordflow">if</span>(arete1&lt;nb_aretes_tot)
<a name="l01948"></a>01948                     AVR(sk-nb_som_tot,arete1)+=psc;
<a name="l01949"></a>01949                   <span class="keywordflow">else</span>
<a name="l01950"></a>01950                     AVV(sk-nb_som_tot,arete1-nb_aretes_tot)+=psc;
<a name="l01951"></a>01951                 }
<a name="l01952"></a>01952             }
<a name="l01953"></a>01953         }
<a name="l01954"></a>01954     }
<a name="l01955"></a>01955 }
<a name="l01956"></a>01956 
<a name="l01957"></a>01957 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l01958"></a><a class="code" href="AssembleurPP1BUtil_8cpp.html#a1ee529d67fc174bfe005efe590812122">01958</a> <a class="code" href="AssembleurPP1BUtil_8cpp.html#a1ee529d67fc174bfe005efe590812122">contribuer_matrice_NeumannP1Pa</a>(<span class="keyword">const</span> <a class="code" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a>&amp; zone_VEF,
<a name="l01959"></a>01959                                <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; inverse_quantitee_entrelacee,
<a name="l01960"></a>01960                                <span class="keywordtype">int</span> face, <span class="keywordtype">int</span> elem,
<a name="l01961"></a>01961                                <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; sommets,
<a name="l01962"></a>01962                                <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; faces_op1,    <span class="keyword">const</span> <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a>&amp; coef_som,
<a name="l01963"></a>01963                                <a class="code" href="classIntLists.html" title="Un tableau de listes de type IntList.">IntLists</a>&amp; voisins,
<a name="l01964"></a>01964                                <a class="code" href="classDoubleLists.html" title="Un tableau de listes de type DoubleList.">DoubleLists</a>&amp; coeffs,
<a name="l01965"></a>01965                                <span class="keywordtype">int</span>&amp; nnz)
<a name="l01966"></a>01966 {
<a name="l01967"></a>01967   <span class="keywordtype">int</span> dimension=<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>;
<a name="l01968"></a>01968 <span class="comment">// dplusun=dimension+1;</span>
<a name="l01969"></a>01969 <span class="comment">// double coeff_som=1./(dimension)/(dplusun);</span>
<a name="l01970"></a>01970   <span class="keywordtype">double</span> unsurdim=1./<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>;
<a name="l01971"></a>01971   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; elem_aretes=zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#a1e1e86ef5b088c4d33d42cd38a967b4a" title="renvoie le numero de la jeme arete du ieme element.">elem_aretes</a>();
<a name="l01972"></a>01972   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; aretes_som=zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#affa60690e1b372fa4c01d6088267dbe4" title="renvoie le tableau de connectivite aretes/sommets.">aretes_som</a>();
<a name="l01973"></a>01973   <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; ok_arete=zone_VEF.<a class="code" href="classZone__VEF__PreP1b.html#a83771f784d487e346b2ef22a389472a2">get_ok_arete</a>();
<a name="l01974"></a>01974   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; face_voisins=zone_VEF.<a class="code" href="classZone__VF.html#a49d4322f5585a8fa95748ca785b70702" title="renvoie l&#39;element voisin de numface dans la direction i. i=0 : dans le sens oppose de l&#39;axe orthogona...">face_voisins</a>();
<a name="l01975"></a>01975   <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; normales = zone_VEF.<a class="code" href="classZone__VEF.html#a5742d75972e4846bf9fbb6ed5715053e">face_normales</a>();
<a name="l01976"></a>01976   <span class="keywordtype">int</span> i, j, k;
<a name="l01977"></a>01977   <span class="keywordtype">double</span> psc;
<a name="l01978"></a>01978   <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a> grad1(3);
<a name="l01979"></a>01979   <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a> grad2(3);
<a name="l01980"></a>01980   <span class="keywordflow">for</span>(i=0; i&lt;3; i++)
<a name="l01981"></a>01981     {
<a name="l01982"></a>01982       <span class="keywordtype">int</span> si=sommets(i);
<a name="l01983"></a>01983       <span class="keywordflow">for</span>(j=i+1; j&lt;4; j++)
<a name="l01984"></a>01984         {
<a name="l01985"></a>01985           <span class="keywordtype">int</span> sj=sommets(j);
<a name="l01986"></a>01986           <span class="keywordtype">int</span> arete1;
<a name="l01987"></a>01987           arete1 = <a class="code" href="AssembleurPP1BUtil_8cpp.html#ae1c00f10faaf4da3ffdea8f881565a1b">chercher_arete</a>(zone_VEF,elem, si, sj,
<a name="l01988"></a>01988                                   elem_aretes, aretes_som);
<a name="l01989"></a>01989           <span class="keywordflow">if</span>(ok_arete(arete1))
<a name="l01990"></a>01990             {
<a name="l01991"></a>01991               <a class="code" href="AssembleurPP1BUtil_8cpp.html#aa26334c33fd016e71cbab82de7ef2fe5">calculer_grad_arete</a>(face, face_voisins, i, j,
<a name="l01992"></a>01992                                   elem, -1,
<a name="l01993"></a>01993                                   faces_op1(i), -1,
<a name="l01994"></a>01994                                   faces_op1(j), -1,
<a name="l01995"></a>01995                                   normales, grad1);
<a name="l01996"></a>01996               <span class="keywordflow">for</span>(k=0; k&lt;4; k++)
<a name="l01997"></a>01997                 {
<a name="l01998"></a>01998                   <span class="keywordtype">int</span> sk=sommets(k);
<a name="l01999"></a>01999                   <a class="code" href="AssembleurPP1BUtil_8cpp.html#a556b82e62a565319fb25218f97cfc50c">calculer_grad</a>(face_voisins, elem, -1, coef_som, sk,
<a name="l02000"></a>02000                                 faces_op1(k), -1,
<a name="l02001"></a>02001                                 normales, grad2);
<a name="l02002"></a>02002                   <span class="keywordflow">if</span>(faces_op1(k)!=face)
<a name="l02003"></a>02003                     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> comp=0; comp&lt;dimension; comp++)
<a name="l02004"></a>02004                       grad2(comp)+= normales(face,comp)*unsurdim;
<a name="l02005"></a>02005                   psc=-<a class="code" href="AssembleurPP1BUtil_8cpp.html#a828055cfc33e4c56db8e2f5beb059862">dotproduct_array_fois_inverse_quantitee_entrelacee</a>(grad1,grad2,
<a name="l02006"></a>02006                                                                           inverse_quantitee_entrelacee,face);
<a name="l02007"></a>02007                   <span class="keywordtype">int</span> rang1=voisins[sk].rang(arete1);
<a name="l02008"></a>02008                   <span class="keywordflow">if</span>(rang1==-1)
<a name="l02009"></a>02009                     {
<a name="l02010"></a>02010                       voisins[sk].add(arete1);
<a name="l02011"></a>02011                       coeffs[sk].add(psc);
<a name="l02012"></a>02012                       nnz++;
<a name="l02013"></a>02013                     }
<a name="l02014"></a>02014                   <span class="keywordflow">else</span>
<a name="l02015"></a>02015                     {
<a name="l02016"></a>02016                       coeffs[sk][rang1]+=psc;
<a name="l02017"></a>02017                     }
<a name="l02018"></a>02018                 }
<a name="l02019"></a>02019             }
<a name="l02020"></a>02020         }
<a name="l02021"></a>02021     }
<a name="l02022"></a>02022 }
<a name="l02023"></a>02023 
<a name="l02024"></a>02024 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l02025"></a><a class="code" href="AssembleurPP1BUtil_8cpp.html#a7da454ba757d1b7ed7ccc39954e6cab5">02025</a> <a class="code" href="AssembleurPP1BUtil_8cpp.html#a7da454ba757d1b7ed7ccc39954e6cab5">update_matrice_NeumannP1Pa</a>(<span class="keyword">const</span> <a class="code" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a>&amp; zone_VEF,
<a name="l02026"></a>02026                            <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; inverse_quantitee_entrelacee,
<a name="l02027"></a>02027                            <span class="keywordtype">int</span> face, <span class="keywordtype">int</span> elem,
<a name="l02028"></a>02028                            <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; sommets,
<a name="l02029"></a>02029                            <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; faces_op1,   <span class="keyword">const</span> <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a>&amp; coef_som,
<a name="l02030"></a>02030                            <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; ARR, <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; ARV,
<a name="l02031"></a>02031                            <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; AVR, <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; AVV)
<a name="l02032"></a>02032 {
<a name="l02033"></a>02033   <span class="keywordtype">int</span> dimension=<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>;
<a name="l02034"></a>02034 <span class="comment">// dplusun=dimension+1;</span>
<a name="l02035"></a>02035 <span class="comment">// double coeff_som=1./(dimension)/(dplusun);</span>
<a name="l02036"></a>02036   <span class="keywordtype">double</span> unsurdim=1./<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>;
<a name="l02037"></a>02037   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; elem_aretes=zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#a1e1e86ef5b088c4d33d42cd38a967b4a" title="renvoie le numero de la jeme arete du ieme element.">elem_aretes</a>();
<a name="l02038"></a>02038   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; aretes_som=zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#affa60690e1b372fa4c01d6088267dbe4" title="renvoie le tableau de connectivite aretes/sommets.">aretes_som</a>();
<a name="l02039"></a>02039   <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; ok_arete=zone_VEF.<a class="code" href="classZone__VEF__PreP1b.html#a83771f784d487e346b2ef22a389472a2">get_ok_arete</a>();
<a name="l02040"></a>02040   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; face_voisins=zone_VEF.<a class="code" href="classZone__VF.html#a49d4322f5585a8fa95748ca785b70702" title="renvoie l&#39;element voisin de numface dans la direction i. i=0 : dans le sens oppose de l&#39;axe orthogona...">face_voisins</a>();
<a name="l02041"></a>02041   <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; normales = zone_VEF.<a class="code" href="classZone__VEF.html#a5742d75972e4846bf9fbb6ed5715053e">face_normales</a>();
<a name="l02042"></a>02042   <span class="keywordtype">int</span> nb_aretes_tot=zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#a3e3b48691911fd85574c7bc10a1a4fb8" title="renvoie le nombre d&#39;aretes reelles.">nb_aretes</a>();
<a name="l02043"></a>02043   <span class="keywordtype">int</span> nb_som_tot=zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#ad340f571f81fa5c2e028b88c00b5c2ca" title="Renvoie le nombre de sommets de la zone.">nb_som</a>();
<a name="l02044"></a>02044 
<a name="l02045"></a>02045   <span class="keywordtype">int</span> i, j, k;
<a name="l02046"></a>02046   <span class="keywordtype">double</span> psc;
<a name="l02047"></a>02047   <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a> grad1(3);
<a name="l02048"></a>02048   <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a> grad2(3);
<a name="l02049"></a>02049   <span class="keywordflow">for</span>(i=0; i&lt;3; i++)
<a name="l02050"></a>02050     {
<a name="l02051"></a>02051       <span class="keywordtype">int</span> si=sommets(i);
<a name="l02052"></a>02052       <span class="keywordflow">for</span>(j=i+1; j&lt;4; j++)
<a name="l02053"></a>02053         {
<a name="l02054"></a>02054           <span class="keywordtype">int</span> sj=sommets(j);
<a name="l02055"></a>02055           <span class="keywordtype">int</span> arete1;
<a name="l02056"></a>02056           arete1 = <a class="code" href="AssembleurPP1BUtil_8cpp.html#ae1c00f10faaf4da3ffdea8f881565a1b">chercher_arete</a>(zone_VEF,elem, si, sj,
<a name="l02057"></a>02057                                   elem_aretes, aretes_som);
<a name="l02058"></a>02058           <span class="keywordflow">if</span>(ok_arete(arete1))
<a name="l02059"></a>02059             {
<a name="l02060"></a>02060               <a class="code" href="AssembleurPP1BUtil_8cpp.html#aa26334c33fd016e71cbab82de7ef2fe5">calculer_grad_arete</a>(face, face_voisins, i, j,
<a name="l02061"></a>02061                                   elem, -1,
<a name="l02062"></a>02062                                   faces_op1(i), -1,
<a name="l02063"></a>02063                                   faces_op1(j), -1,
<a name="l02064"></a>02064                                   normales, grad1);
<a name="l02065"></a>02065               <span class="keywordflow">for</span>(k=0; k&lt;4; k++)
<a name="l02066"></a>02066                 {
<a name="l02067"></a>02067                   <span class="keywordtype">int</span> sk=sommets(k);
<a name="l02068"></a>02068                   <a class="code" href="AssembleurPP1BUtil_8cpp.html#a556b82e62a565319fb25218f97cfc50c">calculer_grad</a>(face_voisins, elem, -1,  coef_som,sk,
<a name="l02069"></a>02069                                 faces_op1(k), -1,
<a name="l02070"></a>02070                                 normales, grad2);
<a name="l02071"></a>02071                   <span class="keywordflow">if</span>(faces_op1(k)!=face)
<a name="l02072"></a>02072                     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> comp=0; comp&lt;dimension; comp++)
<a name="l02073"></a>02073                       grad2(comp)+= normales(face,comp)*unsurdim;
<a name="l02074"></a>02074                   psc=-<a class="code" href="AssembleurPP1BUtil_8cpp.html#a828055cfc33e4c56db8e2f5beb059862">dotproduct_array_fois_inverse_quantitee_entrelacee</a>(grad1,grad2,
<a name="l02075"></a>02075                                                                           inverse_quantitee_entrelacee,face);
<a name="l02076"></a>02076                   <span class="keywordflow">if</span>(sk&lt;nb_som_tot)
<a name="l02077"></a>02077                     <span class="keywordflow">if</span>(arete1&lt;nb_aretes_tot)
<a name="l02078"></a>02078                       ARR(sk,arete1)+=psc;
<a name="l02079"></a>02079                     <span class="keywordflow">else</span>
<a name="l02080"></a>02080                       ARV(sk,arete1-nb_aretes_tot)+=psc;
<a name="l02081"></a>02081                   <span class="keywordflow">else</span> <span class="keywordflow">if</span>(arete1&lt;nb_aretes_tot)
<a name="l02082"></a>02082                     AVR(sk-nb_som_tot,arete1)+=psc;
<a name="l02083"></a>02083                   <span class="keywordflow">else</span>
<a name="l02084"></a>02084                     AVV(sk-nb_som_tot,arete1-nb_aretes_tot)+=psc;
<a name="l02085"></a>02085                 }
<a name="l02086"></a>02086             }
<a name="l02087"></a>02087         }
<a name="l02088"></a>02088     }
<a name="l02089"></a>02089 }
<a name="l02090"></a>02090 
<a name="l02091"></a>02091 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l02092"></a><a class="code" href="AssembleurPP1BUtil_8cpp.html#ae3056a39c9c01f3a2727f0dbf4b5e331">02092</a> <a class="code" href="AssembleurPP1BUtil_8cpp.html#ae3056a39c9c01f3a2727f0dbf4b5e331">contribuer_matrice_SymetrieP1Pa</a>(<span class="keyword">const</span> <a class="code" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a>&amp; zone_VEF,
<a name="l02093"></a>02093                                 <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; inverse_quantitee_entrelacee,
<a name="l02094"></a>02094                                 <span class="keywordtype">int</span> face, <span class="keywordtype">int</span> elem,
<a name="l02095"></a>02095                                 <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; sommets,
<a name="l02096"></a>02096                                 <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; faces_op1,   <span class="keyword">const</span> <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a>&amp; coef_som,
<a name="l02097"></a>02097                                 <a class="code" href="classIntLists.html" title="Un tableau de listes de type IntList.">IntLists</a>&amp; voisins,
<a name="l02098"></a>02098                                 <a class="code" href="classDoubleLists.html" title="Un tableau de listes de type DoubleList.">DoubleLists</a>&amp; coeffs,
<a name="l02099"></a>02099                                 <span class="keywordtype">int</span>&amp; nnz)
<a name="l02100"></a>02100 {
<a name="l02101"></a>02101 <span class="comment">// int dimension=Objet_U::dimension,</span>
<a name="l02102"></a>02102 <span class="comment">// dplusun=dimension+1;</span>
<a name="l02103"></a>02103 <span class="comment">// double coeff_som=1./(dimension)/(dplusun);</span>
<a name="l02104"></a>02104   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; elem_aretes=zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#a1e1e86ef5b088c4d33d42cd38a967b4a" title="renvoie le numero de la jeme arete du ieme element.">elem_aretes</a>();
<a name="l02105"></a>02105   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; aretes_som=zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#affa60690e1b372fa4c01d6088267dbe4" title="renvoie le tableau de connectivite aretes/sommets.">aretes_som</a>();
<a name="l02106"></a>02106   <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; ok_arete=zone_VEF.<a class="code" href="classZone__VEF__PreP1b.html#a83771f784d487e346b2ef22a389472a2">get_ok_arete</a>();
<a name="l02107"></a>02107   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; face_voisins=zone_VEF.<a class="code" href="classZone__VF.html#a49d4322f5585a8fa95748ca785b70702" title="renvoie l&#39;element voisin de numface dans la direction i. i=0 : dans le sens oppose de l&#39;axe orthogona...">face_voisins</a>();
<a name="l02108"></a>02108   <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; normales = zone_VEF.<a class="code" href="classZone__VEF.html#a5742d75972e4846bf9fbb6ed5715053e">face_normales</a>();
<a name="l02109"></a>02109   <span class="keywordtype">int</span> i, j, k;
<a name="l02110"></a>02110   <span class="keywordtype">double</span> psc;
<a name="l02111"></a>02111   <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a> grad1(3);
<a name="l02112"></a>02112   <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a> grad2(3);
<a name="l02113"></a>02113   <span class="keywordflow">for</span>(i=0; i&lt;3; i++)
<a name="l02114"></a>02114     {
<a name="l02115"></a>02115       <span class="keywordtype">int</span> si=sommets(i);
<a name="l02116"></a>02116       <span class="keywordflow">for</span>(j=i+1; j&lt;4; j++)
<a name="l02117"></a>02117         {
<a name="l02118"></a>02118           <span class="keywordtype">int</span> sj=sommets(j);
<a name="l02119"></a>02119           <span class="keywordtype">int</span> arete1;
<a name="l02120"></a>02120           arete1 = <a class="code" href="AssembleurPP1BUtil_8cpp.html#ae1c00f10faaf4da3ffdea8f881565a1b">chercher_arete</a>(zone_VEF,elem, si, sj,
<a name="l02121"></a>02121                                   elem_aretes, aretes_som);
<a name="l02122"></a>02122           <span class="keywordflow">if</span>(ok_arete(arete1))
<a name="l02123"></a>02123             {
<a name="l02124"></a>02124               <a class="code" href="AssembleurPP1BUtil_8cpp.html#aa26334c33fd016e71cbab82de7ef2fe5">calculer_grad_arete</a>(face, face_voisins, i, j,
<a name="l02125"></a>02125                                   elem, -1,
<a name="l02126"></a>02126                                   faces_op1(i), -1,
<a name="l02127"></a>02127                                   faces_op1(j), -1,
<a name="l02128"></a>02128                                   normales, grad1);
<a name="l02129"></a>02129               <a class="code" href="Champ__Generique__Transformation_8cpp.html#a0705a900f8a8003047df2f59d6cd4bae">projette</a>(grad1, face, normales);
<a name="l02130"></a>02130               <span class="keywordflow">for</span>(k=0; k&lt;4; k++)
<a name="l02131"></a>02131                 {
<a name="l02132"></a>02132                   <span class="keywordtype">int</span> sk=sommets(k);
<a name="l02133"></a>02133                   <a class="code" href="AssembleurPP1BUtil_8cpp.html#a556b82e62a565319fb25218f97cfc50c">calculer_grad</a>(face_voisins, elem, -1, coef_som, sk,
<a name="l02134"></a>02134                                 faces_op1(k), -1,
<a name="l02135"></a>02135                                 normales, grad2);
<a name="l02136"></a>02136                   <a class="code" href="Champ__Generique__Transformation_8cpp.html#a0705a900f8a8003047df2f59d6cd4bae">projette</a>(grad2, face, normales);
<a name="l02137"></a>02137                   psc=-<a class="code" href="AssembleurPP1BUtil_8cpp.html#a828055cfc33e4c56db8e2f5beb059862">dotproduct_array_fois_inverse_quantitee_entrelacee</a>(grad1,grad2,
<a name="l02138"></a>02138                                                                           inverse_quantitee_entrelacee,face);
<a name="l02139"></a>02139                   <span class="keywordtype">int</span> rang1=voisins[sk].rang(arete1);
<a name="l02140"></a>02140                   <span class="keywordflow">if</span>(rang1==-1)
<a name="l02141"></a>02141                     {
<a name="l02142"></a>02142                       voisins[sk].add(arete1);
<a name="l02143"></a>02143                       coeffs[sk].add(psc);
<a name="l02144"></a>02144                       nnz++;
<a name="l02145"></a>02145                     }
<a name="l02146"></a>02146                   <span class="keywordflow">else</span>
<a name="l02147"></a>02147                     {
<a name="l02148"></a>02148                       coeffs[sk][rang1]+=psc;
<a name="l02149"></a>02149                     }
<a name="l02150"></a>02150                 }
<a name="l02151"></a>02151             }
<a name="l02152"></a>02152         }
<a name="l02153"></a>02153     }
<a name="l02154"></a>02154 }
<a name="l02155"></a>02155 
<a name="l02156"></a>02156 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l02157"></a><a class="code" href="AssembleurPP1BUtil_8cpp.html#aa18f9eabe40c3c77172253c07802c05f">02157</a> <a class="code" href="AssembleurPP1BUtil_8cpp.html#aa18f9eabe40c3c77172253c07802c05f">update_matrice_SymetrieP1Pa</a>(<span class="keyword">const</span> <a class="code" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a>&amp; zone_VEF,
<a name="l02158"></a>02158                             <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; inverse_quantitee_entrelacee,
<a name="l02159"></a>02159                             <span class="keywordtype">int</span> face, <span class="keywordtype">int</span> elem,
<a name="l02160"></a>02160                             <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; sommets,
<a name="l02161"></a>02161                             <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; faces_op1,   <span class="keyword">const</span> <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a>&amp; coef_som,
<a name="l02162"></a>02162                             <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; ARR, <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; ARV,
<a name="l02163"></a>02163                             <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; AVR, <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; AVV)
<a name="l02164"></a>02164 {
<a name="l02165"></a>02165 <span class="comment">// int dimension=Objet_U::dimension,</span>
<a name="l02166"></a>02166 <span class="comment">// dplusun=dimension+1;</span>
<a name="l02167"></a>02167 <span class="comment">// double coeff_som=1./(dimension)/(dplusun);</span>
<a name="l02168"></a>02168   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; elem_aretes=zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#a1e1e86ef5b088c4d33d42cd38a967b4a" title="renvoie le numero de la jeme arete du ieme element.">elem_aretes</a>();
<a name="l02169"></a>02169   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; aretes_som=zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#affa60690e1b372fa4c01d6088267dbe4" title="renvoie le tableau de connectivite aretes/sommets.">aretes_som</a>();
<a name="l02170"></a>02170   <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; ok_arete=zone_VEF.<a class="code" href="classZone__VEF__PreP1b.html#a83771f784d487e346b2ef22a389472a2">get_ok_arete</a>();
<a name="l02171"></a>02171   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; face_voisins=zone_VEF.<a class="code" href="classZone__VF.html#a49d4322f5585a8fa95748ca785b70702" title="renvoie l&#39;element voisin de numface dans la direction i. i=0 : dans le sens oppose de l&#39;axe orthogona...">face_voisins</a>();
<a name="l02172"></a>02172   <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; normales = zone_VEF.<a class="code" href="classZone__VEF.html#a5742d75972e4846bf9fbb6ed5715053e">face_normales</a>();
<a name="l02173"></a>02173   <span class="keywordtype">int</span> nb_aretes_tot=zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#a3e3b48691911fd85574c7bc10a1a4fb8" title="renvoie le nombre d&#39;aretes reelles.">nb_aretes</a>();
<a name="l02174"></a>02174   <span class="keywordtype">int</span> nb_som_tot=zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#ad340f571f81fa5c2e028b88c00b5c2ca" title="Renvoie le nombre de sommets de la zone.">nb_som</a>();
<a name="l02175"></a>02175 
<a name="l02176"></a>02176   <span class="keywordtype">int</span> i, j, k;
<a name="l02177"></a>02177   <span class="keywordtype">double</span> psc;
<a name="l02178"></a>02178   <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a> grad1(3);
<a name="l02179"></a>02179   <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a> grad2(3);
<a name="l02180"></a>02180   <span class="keywordflow">for</span>(i=0; i&lt;3; i++)
<a name="l02181"></a>02181     {
<a name="l02182"></a>02182       <span class="keywordtype">int</span> si=sommets(i);
<a name="l02183"></a>02183       <span class="keywordflow">for</span>(j=i+1; j&lt;4; j++)
<a name="l02184"></a>02184         {
<a name="l02185"></a>02185           <span class="keywordtype">int</span> sj=sommets(j);
<a name="l02186"></a>02186           <span class="keywordtype">int</span> arete1;
<a name="l02187"></a>02187           arete1 = <a class="code" href="AssembleurPP1BUtil_8cpp.html#ae1c00f10faaf4da3ffdea8f881565a1b">chercher_arete</a>(zone_VEF,elem, si, sj,
<a name="l02188"></a>02188                                   elem_aretes, aretes_som);
<a name="l02189"></a>02189           <span class="keywordflow">if</span>(ok_arete(arete1))
<a name="l02190"></a>02190             {
<a name="l02191"></a>02191               <a class="code" href="AssembleurPP1BUtil_8cpp.html#aa26334c33fd016e71cbab82de7ef2fe5">calculer_grad_arete</a>(face, face_voisins, i, j,
<a name="l02192"></a>02192                                   elem, -1,
<a name="l02193"></a>02193                                   faces_op1(i), -1,
<a name="l02194"></a>02194                                   faces_op1(j), -1,
<a name="l02195"></a>02195                                   normales, grad1);
<a name="l02196"></a>02196               <a class="code" href="Champ__Generique__Transformation_8cpp.html#a0705a900f8a8003047df2f59d6cd4bae">projette</a>(grad1, face, normales);
<a name="l02197"></a>02197               <span class="keywordflow">for</span>(k=0; k&lt;4; k++)
<a name="l02198"></a>02198                 {
<a name="l02199"></a>02199                   <span class="keywordtype">int</span> sk=sommets(k);
<a name="l02200"></a>02200                   <a class="code" href="AssembleurPP1BUtil_8cpp.html#a556b82e62a565319fb25218f97cfc50c">calculer_grad</a>(face_voisins, elem, -1,  coef_som,sk,
<a name="l02201"></a>02201                                 faces_op1(k), -1,
<a name="l02202"></a>02202                                 normales, grad2);
<a name="l02203"></a>02203                   <a class="code" href="Champ__Generique__Transformation_8cpp.html#a0705a900f8a8003047df2f59d6cd4bae">projette</a>(grad2, face, normales);
<a name="l02204"></a>02204                   psc=-<a class="code" href="AssembleurPP1BUtil_8cpp.html#a828055cfc33e4c56db8e2f5beb059862">dotproduct_array_fois_inverse_quantitee_entrelacee</a>(grad1,grad2,
<a name="l02205"></a>02205                                                                           inverse_quantitee_entrelacee,face);
<a name="l02206"></a>02206                   <span class="keywordflow">if</span>(sk&lt;nb_som_tot)
<a name="l02207"></a>02207                     <span class="keywordflow">if</span>(arete1&lt;nb_aretes_tot)
<a name="l02208"></a>02208                       ARR(sk,arete1)+=psc;
<a name="l02209"></a>02209                     <span class="keywordflow">else</span>
<a name="l02210"></a>02210                       ARV(sk,arete1-nb_aretes_tot)+=psc;
<a name="l02211"></a>02211                   <span class="keywordflow">else</span> <span class="keywordflow">if</span>(arete1&lt;nb_aretes_tot)
<a name="l02212"></a>02212                     AVR(sk-nb_som_tot,arete1)+=psc;
<a name="l02213"></a>02213                   <span class="keywordflow">else</span>
<a name="l02214"></a>02214                     AVV(sk-nb_som_tot,arete1-nb_aretes_tot)+=psc;
<a name="l02215"></a>02215                 }
<a name="l02216"></a>02216             }
<a name="l02217"></a>02217         }
<a name="l02218"></a>02218     }
<a name="l02219"></a>02219 }
<a name="l02220"></a>02220 
<a name="l02221"></a>02221 <span class="keywordtype">void</span>
<a name="l02222"></a><a class="code" href="AssembleurPP1BUtil_8cpp.html#a31e2d4bc38d5bc0bbf9e2c36d15b589b">02222</a> <a class="code" href="Assembleur__P__VEFPreP1B_8cpp.html#a31e2d4bc38d5bc0bbf9e2c36d15b589b">assemblerP0P0</a>(<span class="keyword">const</span> <a class="code" href="classZone__dis__base.html" title="classe Zone_dis_base Cette classe est la base de la hierarchie des zones discretisees. Un objet Zone est associe a la zone discretise. A chaque methode numerique de Trio U correspond une classe derivant de Zone_dis_base implementant les outils necessaires a la methode.">Zone_dis_base</a>&amp; z,
<a name="l02223"></a>02223               <span class="keyword">const</span> <a class="code" href="classZone__Cl__dis__base.html" title="classe Zone_Cl_dis_base Les objets Zone_Cl_dis_base representent les conditions aux limites discretis...">Zone_Cl_dis_base</a>&amp; zcl,
<a name="l02224"></a>02224               <a class="code" href="classMatrice.html">Matrice</a>&amp; matrice,
<a name="l02225"></a>02225               <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; inverse_quantitee_entrelacee)
<a name="l02226"></a>02226 {
<a name="l02227"></a>02227   <a class="code" href="classAssembleur__P__VEF.html">Assembleur_P_VEF</a> Assembleur_P0;
<a name="l02228"></a>02228   Assembleur_P0.<a class="code" href="classAssembleur__P__VEF.html#a5b2a8af584466c11399b032515921978">associer_zone_dis_base</a>(z);
<a name="l02229"></a>02229   Assembleur_P0.<a class="code" href="classAssembleur__P__VEF.html#a69468e49c8496eda05508c8e8477493b">associer_zone_cl_dis_base</a>(zcl);
<a name="l02230"></a>02230   Assembleur_P0.<a class="code" href="classAssembleur__P__VEF.html#abe02c31a6c1ada8d05996def7f43ea58">remplir</a>(matrice,inverse_quantitee_entrelacee);
<a name="l02231"></a>02231   <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Assemblage P0 OK&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
<a name="l02232"></a>02232 }
<a name="l02233"></a>02233 
<a name="l02234"></a>02234 <span class="keywordtype">void</span>
<a name="l02235"></a><a class="code" href="AssembleurPP1BUtil_8cpp.html#a48eaaecaa31bdde228ea5e3995db4771">02235</a> <a class="code" href="Assembleur__P__VEFPreP1B_8cpp.html#a48eaaecaa31bdde228ea5e3995db4771">updateP0P0</a>(<span class="keyword">const</span> <a class="code" href="classZone__dis__base.html" title="classe Zone_dis_base Cette classe est la base de la hierarchie des zones discretisees. Un objet Zone est associe a la zone discretise. A chaque methode numerique de Trio U correspond une classe derivant de Zone_dis_base implementant les outils necessaires a la methode.">Zone_dis_base</a>&amp; z,
<a name="l02236"></a>02236            <span class="keyword">const</span> <a class="code" href="classZone__Cl__dis__base.html" title="classe Zone_Cl_dis_base Les objets Zone_Cl_dis_base representent les conditions aux limites discretis...">Zone_Cl_dis_base</a>&amp; zcl,
<a name="l02237"></a>02237            <a class="code" href="classMatrice.html">Matrice</a>&amp; matrice,
<a name="l02238"></a>02238            <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; inverse_quantitee_entrelacee)
<a name="l02239"></a>02239 {
<a name="l02240"></a>02240   <a class="code" href="classAssembleur__P__VEF.html">Assembleur_P_VEF</a> Assembleur_P0;
<a name="l02241"></a>02241   Assembleur_P0.<a class="code" href="classAssembleur__P__VEF.html#a5b2a8af584466c11399b032515921978">associer_zone_dis_base</a>(z);
<a name="l02242"></a>02242   Assembleur_P0.<a class="code" href="classAssembleur__P__VEF.html#a69468e49c8496eda05508c8e8477493b">associer_zone_cl_dis_base</a>(zcl);
<a name="l02243"></a>02243   Assembleur_P0.<a class="code" href="classAssembleur__P__VEF.html#abe02c31a6c1ada8d05996def7f43ea58">remplir</a>(matrice,inverse_quantitee_entrelacee);
<a name="l02244"></a>02244   <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Update P0 OK&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
<a name="l02245"></a>02245 }
<a name="l02246"></a>02246 
<a name="l02247"></a><a class="code" href="AssembleurPP1BUtil_8cpp.html#a31f132f3fda04d8428de212c63fd902f">02247</a> <span class="keywordtype">void</span> <a class="code" href="Assembleur__P__VEFPreP1B_8cpp.html#a31f132f3fda04d8428de212c63fd902f">assemblerP1P1</a>(<span class="keyword">const</span> <a class="code" href="classZone__dis__base.html" title="classe Zone_dis_base Cette classe est la base de la hierarchie des zones discretisees. Un objet Zone est associe a la zone discretise. A chaque methode numerique de Trio U correspond une classe derivant de Zone_dis_base implementant les outils necessaires a la methode.">Zone_dis_base</a>&amp; z,
<a name="l02248"></a>02248                    <span class="keyword">const</span> <a class="code" href="classZone__Cl__dis__base.html" title="classe Zone_Cl_dis_base Les objets Zone_Cl_dis_base representent les conditions aux limites discretis...">Zone_Cl_dis_base</a>&amp; zcl,
<a name="l02249"></a>02249                    <a class="code" href="classMatrice.html">Matrice</a>&amp; matrice, <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; inverse_quantitee_entrelacee, <span class="keyword">const</span> <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a>&amp; coef_som)
<a name="l02250"></a>02250 {
<a name="l02251"></a>02251   <span class="keywordtype">int</span> dimension=<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>;
<a name="l02252"></a>02252   <span class="keyword">const</span> <a class="code" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a>&amp; zone_VEF=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a>, z);
<a name="l02253"></a>02253   <span class="keyword">const</span> <a class="code" href="classZone.html" title="classe Zone Une Zone est un maillage compose d&#39;un ensemble d&#39;elements geometriques de meme type...">Zone</a>&amp; zone=zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>();
<a name="l02254"></a>02254   <span class="keyword">const</span> <a class="code" href="classZone__Cl__VEF.html">Zone_Cl_VEF</a>&amp; zone_Cl_VEF=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classZone__Cl__VEF.html">Zone_Cl_VEF</a>, zcl);
<a name="l02255"></a>02255   <span class="keyword">const</span> <a class="code" href="classConds__lim.html">Conds_lim</a>&amp; les_cl = zone_Cl_VEF.<a class="code" href="classZone__Cl__dis__base.html#af75e0ed7786863e4d333bfb29d67c323" title="Renvoie la i-ieme condition aux limites. (version const)">les_conditions_limites</a>();
<a name="l02256"></a>02256   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; face_voisins = zone_VEF.<a class="code" href="classZone__VF.html#a49d4322f5585a8fa95748ca785b70702" title="renvoie l&#39;element voisin de numface dans la direction i. i=0 : dans le sens oppose de l&#39;axe orthogona...">face_voisins</a>();
<a name="l02257"></a>02257   <span class="keywordtype">int</span> nint = zone_VEF.<a class="code" href="classZone__VF.html#a12869806fa4834aca8f2964e16509dfd" title="une face est interne ssi elle separe deux elements. renvoie le numero de la premiere face interne...">premiere_face_int</a>();
<a name="l02258"></a>02258   <span class="keywordtype">int</span> nb_faces = zone_VEF.<a class="code" href="classZone__VF.html#a50fd21c9535680489015a3c8b88c685a" title="renvoie le nombre total de faces. C&#39;est-a-dire faces reelles + faces virtuelles">nb_faces_tot</a>();
<a name="l02259"></a>02259   <span class="keywordtype">int</span> nb_som = zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#a01ed67af826d6045ef4eacfb87a663e8" title="Renvoie le nombre total de sommets de la zone. i.e. le nombre de sommets reels et virtuels sur le pro...">nb_som_tot</a>();
<a name="l02260"></a>02260   <span class="keywordtype">int</span> elem1, elem2, face, ok;
<a name="l02261"></a>02261   <span class="keywordtype">int</span> nnz=nb_som;
<a name="l02262"></a>02262   <a class="code" href="classIntLists.html" title="Un tableau de listes de type IntList.">IntLists</a> voisins(nb_som);
<a name="l02263"></a>02263   <a class="code" href="classDoubleLists.html" title="Un tableau de listes de type DoubleList.">DoubleLists</a> coeffs(nb_som);
<a name="l02264"></a>02264   <a class="code" href="classDoubleVect.html">DoubleVect</a> diag(nb_som);
<a name="l02265"></a>02265   <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> sommets(dimension+2);
<a name="l02266"></a>02266   <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> face_opp1(dimension+2);
<a name="l02267"></a>02267   <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> face_opp2(dimension+2);
<a name="l02268"></a>02268 <span class="comment">// Faces de bord :</span>
<a name="l02269"></a>02269   <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;les_cl.<a class="code" href="classvect__impl.html#a78155bfbd6b61f4710b9830641ed1694">size</a>(); i++)
<a name="l02270"></a>02270     {
<a name="l02271"></a>02271       <span class="keyword">const</span> <a class="code" href="classCond__lim.html" title="classe Cond_lim Classe generique servant a representer n&#39;importe quelle classe derivee de la classe C...">Cond_lim</a>&amp; la_cl = les_cl[i];
<a name="l02272"></a>02272       <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp; le_bord = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>,la_cl.<a class="code" href="classCond__lim.html#a5b2d24809cee07727006a891d4ce8d22" title="Appel a l&#39;objet sous-jacent Renvoie la frontiere discretisee associee a la condition aux limites...">frontiere_dis</a>());
<a name="l02273"></a>02273       <span class="keywordtype">int</span> nb_faces_bord_tot = le_bord.<a class="code" href="classFront__VF.html#aed4006d91bf2ef3af2b9f7933d863a09" title="Nombre de faces reelles et virtuelles du bord.">nb_faces_tot</a>();
<a name="l02274"></a>02274       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> ind_face=0; ind_face&lt;nb_faces_bord_tot; ind_face++)
<a name="l02275"></a>02275         {
<a name="l02276"></a>02276           ok=<a class="code" href="AssembleurPP1BUtil_8cpp.html#a40cf40213663174bb24649e51832bf3e">okface</a>(ind_face, face, la_cl);
<a name="l02277"></a>02277           <span class="keywordflow">if</span> (ok==-1) <span class="keywordflow">break</span>;
<a name="l02278"></a>02278           elem1=face_voisins(face, 0);
<a name="l02279"></a>02279           elem2=face_voisins(face, 1);
<a name="l02280"></a>02280           <a class="code" href="AssembleurPP1BUtil_8cpp.html#afd0a249a235b161c5267e7574e199a82">remplir_sommets</a>(zone_VEF, face, elem1, elem2, sommets,
<a name="l02281"></a>02281                           face_opp1, face_opp2);
<a name="l02282"></a>02282           <a class="code" href="AssembleurPP1BUtil_8cpp.html#acff816d35f8d4ce978f860e0cd958b8a">sort</a>(sommets, face_opp1, face_opp2);
<a name="l02283"></a>02283           <span class="keywordflow">if</span>(ok==3)
<a name="l02284"></a>02284             {
<a name="l02285"></a>02285               <a class="code" href="AssembleurPP1BUtil_8cpp.html#ad9eeb295c62a30fa2305edf29ad7cfd5">contribuer_matrice_NeumannP1P1</a>(zone_VEF,
<a name="l02286"></a>02286                                              inverse_quantitee_entrelacee,
<a name="l02287"></a>02287                                              face, elem1, sommets,
<a name="l02288"></a>02288                                              face_opp1, coef_som,
<a name="l02289"></a>02289                                              voisins, coeffs, diag, nnz);
<a name="l02290"></a>02290             }
<a name="l02291"></a>02291           <span class="keywordflow">else</span> <span class="keywordflow">if</span>(ok==4)
<a name="l02292"></a>02292             {
<a name="l02293"></a>02293               <a class="code" href="AssembleurPP1BUtil_8cpp.html#a9568a5e0cbf3b9e2b60ad3f3bdac25df">contribuer_matrice_SymetrieP1P1</a>(zone_VEF,
<a name="l02294"></a>02294                                               inverse_quantitee_entrelacee,
<a name="l02295"></a>02295                                               face, elem1, sommets,
<a name="l02296"></a>02296                                               face_opp1, coef_som,
<a name="l02297"></a>02297                                               voisins, coeffs, diag, nnz);
<a name="l02298"></a>02298             }
<a name="l02299"></a>02299           <span class="keywordflow">else</span>
<a name="l02300"></a>02300             <a class="code" href="AssembleurPP1BUtil_8cpp.html#ae9226a0247d37eab885c3915814c82c7">contribuer_matriceP1P1</a>(zone_VEF,
<a name="l02301"></a>02301                                    inverse_quantitee_entrelacee,
<a name="l02302"></a>02302                                    face, elem1, elem2, sommets,
<a name="l02303"></a>02303                                    face_opp1, face_opp2, coef_som,
<a name="l02304"></a>02304                                    voisins, coeffs, diag, nnz);
<a name="l02305"></a>02305         }
<a name="l02306"></a>02306     }
<a name="l02307"></a>02307   <a class="code" href="AssembleurPP1BUtil_8cpp.html#a3e374d53ebc7860e1c2f0b7906f2936d">face_associee</a>=-1;
<a name="l02308"></a>02308   <span class="keywordflow">for</span>(face=nint; face&lt;nb_faces; face++)
<a name="l02309"></a>02309     {
<a name="l02310"></a>02310       elem1=face_voisins(face, 0);
<a name="l02311"></a>02311       elem2=face_voisins(face, 1);
<a name="l02312"></a>02312       <span class="keywordflow">if</span> (!zone_VEF.<a class="code" href="classZone__VF.html#a33909d3880435e82e84639b51482d2c6" title="renvoie 1 si face est une face virtuelle de bord, 0 sinon">est_une_face_virt_bord</a>(face)) <span class="comment">//!&lt; On ne traite que les faces internes</span>
<a name="l02313"></a>02313 <span class="comment"></span>        {
<a name="l02314"></a>02314           <a class="code" href="AssembleurPP1BUtil_8cpp.html#afd0a249a235b161c5267e7574e199a82">remplir_sommets</a>(zone_VEF, face, elem1, elem2, sommets,
<a name="l02315"></a>02315                           face_opp1, face_opp2);
<a name="l02316"></a>02316           <a class="code" href="AssembleurPP1BUtil_8cpp.html#acff816d35f8d4ce978f860e0cd958b8a">sort</a>(sommets, face_opp1, face_opp2);
<a name="l02317"></a>02317           <a class="code" href="AssembleurPP1BUtil_8cpp.html#ae9226a0247d37eab885c3915814c82c7">contribuer_matriceP1P1</a>(zone_VEF,
<a name="l02318"></a>02318                                  inverse_quantitee_entrelacee,
<a name="l02319"></a>02319                                  face, elem1, elem2, sommets,
<a name="l02320"></a>02320                                  face_opp1, face_opp2, coef_som,
<a name="l02321"></a>02321                                  voisins, coeffs, diag, nnz);
<a name="l02322"></a>02322         }
<a name="l02323"></a>02323     }
<a name="l02324"></a>02324 
<a name="l02325"></a>02325   <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;nb_som; i++)
<a name="l02326"></a>02326     <span class="keywordflow">if</span>(diag(i)==0)
<a name="l02327"></a>02327       {
<a name="l02328"></a>02328 <span class="comment">// Cerr &lt;&lt; &quot;On modifie la ligne (sommet) orpheline &quot; &lt;&lt; i &lt;&lt; finl;</span>
<a name="l02329"></a>02329         diag(i)=1.;
<a name="l02330"></a>02330       }
<a name="l02331"></a>02331 
<a name="l02332"></a>02332   matrice.<a class="code" href="classDeriv__.html#ad1d33400ed15b6ff96579ed82d9e2719" title="Essaie de creer une instance du type &quot;type&quot;. si type n&#39;est pas un type ou type n&#39;est pas instanciab...">typer</a>(<span class="stringliteral">&quot;Matrice_Bloc&quot;</span>);
<a name="l02333"></a>02333   <a class="code" href="classMatrice__Bloc.html">Matrice_Bloc</a>&amp; matrice_bloc=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Bloc.html">Matrice_Bloc</a>, matrice.<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>());
<a name="l02334"></a>02334   matrice_bloc.<a class="code" href="classMatrice__Bloc.html#a7d624ebd3f141e34502e59f6d1b1d601">remplir</a>(voisins, coeffs, diag, zone.<a class="code" href="classZone.html#ad340f571f81fa5c2e028b88c00b5c2ca" title="Renvoie le nombre de sommets de la zone.">nb_som</a>(), zone.<a class="code" href="classZone.html#a01ed67af826d6045ef4eacfb87a663e8" title="Renvoie le nombre total de sommets de la zone. i.e. le nombre de sommets reels et virtuels sur le pro...">nb_som_tot</a>());
<a name="l02335"></a>02335   <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Assemblage P1 OK&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
<a name="l02336"></a>02336 }
<a name="l02337"></a>02337 
<a name="l02338"></a>02338 
<a name="l02339"></a><a class="code" href="AssembleurPP1BUtil_8cpp.html#ab3c25c4172223f48fd2f9d433b005e0c">02339</a> <span class="keywordtype">void</span> <a class="code" href="Assembleur__P__VEFPreP1B_8cpp.html#ab3c25c4172223f48fd2f9d433b005e0c">updateP1P1</a>(<span class="keyword">const</span> <a class="code" href="classZone__dis__base.html" title="classe Zone_dis_base Cette classe est la base de la hierarchie des zones discretisees. Un objet Zone est associe a la zone discretise. A chaque methode numerique de Trio U correspond une classe derivant de Zone_dis_base implementant les outils necessaires a la methode.">Zone_dis_base</a>&amp; z,
<a name="l02340"></a>02340                 <span class="keyword">const</span> <a class="code" href="classZone__Cl__dis__base.html" title="classe Zone_Cl_dis_base Les objets Zone_Cl_dis_base representent les conditions aux limites discretis...">Zone_Cl_dis_base</a>&amp; zcl,
<a name="l02341"></a>02341                 <a class="code" href="classMatrice.html">Matrice</a>&amp; matrice,
<a name="l02342"></a>02342                 <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; inverse_quantitee_entrelacee, <span class="keyword">const</span> <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a>&amp; coef_som)
<a name="l02343"></a>02343 {
<a name="l02344"></a>02344   <span class="keywordtype">int</span> dimension=<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>;
<a name="l02345"></a>02345   <span class="keyword">const</span> <a class="code" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a>&amp; zone_VEF=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a>, z);
<a name="l02346"></a>02346 <span class="comment">// const Zone&amp; zone=zone_VEF.zone();</span>
<a name="l02347"></a>02347   <span class="keyword">const</span> <a class="code" href="classZone__Cl__VEF.html">Zone_Cl_VEF</a>&amp; zone_Cl_VEF=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classZone__Cl__VEF.html">Zone_Cl_VEF</a>, zcl);
<a name="l02348"></a>02348   <span class="keyword">const</span> <a class="code" href="classConds__lim.html">Conds_lim</a>&amp; les_cl = zone_Cl_VEF.<a class="code" href="classZone__Cl__dis__base.html#af75e0ed7786863e4d333bfb29d67c323" title="Renvoie la i-ieme condition aux limites. (version const)">les_conditions_limites</a>();
<a name="l02349"></a>02349   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; face_voisins = zone_VEF.<a class="code" href="classZone__VF.html#a49d4322f5585a8fa95748ca785b70702" title="renvoie l&#39;element voisin de numface dans la direction i. i=0 : dans le sens oppose de l&#39;axe orthogona...">face_voisins</a>();
<a name="l02350"></a>02350   <span class="keywordtype">int</span> nint = zone_VEF.<a class="code" href="classZone__VF.html#a12869806fa4834aca8f2964e16509dfd" title="une face est interne ssi elle separe deux elements. renvoie le numero de la premiere face interne...">premiere_face_int</a>();
<a name="l02351"></a>02351   <span class="keywordtype">int</span> nb_faces = zone_VEF.<a class="code" href="classZone__VF.html#a50fd21c9535680489015a3c8b88c685a" title="renvoie le nombre total de faces. C&#39;est-a-dire faces reelles + faces virtuelles">nb_faces_tot</a>();
<a name="l02352"></a>02352 <span class="comment">// int nb_som = zone_VEF.zone().nb_som_tot();</span>
<a name="l02353"></a>02353   <span class="keywordtype">int</span> elem1, elem2, face, ok;
<a name="l02354"></a>02354 <span class="comment">// int nnz=nb_som;</span>
<a name="l02355"></a>02355   <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> sommets(dimension+2);
<a name="l02356"></a>02356   <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> face_opp1(dimension+2);
<a name="l02357"></a>02357   <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> face_opp2(dimension+2);
<a name="l02358"></a>02358   <a class="code" href="classMatrice__Bloc.html">Matrice_Bloc</a>&amp; A=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Bloc.html">Matrice_Bloc</a>, matrice.<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>());
<a name="l02359"></a>02359   <a class="code" href="classMatrice__Morse__Sym.html" title="Classe Matrice_Morse_Sym Represente une matrice M (creuse) symetrique stockee au format Morse Symetri...">Matrice_Morse_Sym</a>&amp; ARR=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Morse__Sym.html" title="Classe Matrice_Morse_Sym Represente une matrice M (creuse) symetrique stockee au format Morse Symetri...">Matrice_Morse_Sym</a>, A.<a class="code" href="classMatrice__Bloc.html#a7ffa38f7b93454432b2df7c616ed0a4e">get_bloc</a>(0,0).<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>());
<a name="l02360"></a>02360   <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; ARV=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>, A.<a class="code" href="classMatrice__Bloc.html#a7ffa38f7b93454432b2df7c616ed0a4e">get_bloc</a>(0,1).<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>());
<a name="l02361"></a>02361   <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; AVR=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>, A.<a class="code" href="classMatrice__Bloc.html#a7ffa38f7b93454432b2df7c616ed0a4e">get_bloc</a>(1,0).<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>());
<a name="l02362"></a>02362   <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; AVV=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>, A.<a class="code" href="classMatrice__Bloc.html#a7ffa38f7b93454432b2df7c616ed0a4e">get_bloc</a>(1,1).<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>());
<a name="l02363"></a>02363 <span class="comment">// Faces de bord :</span>
<a name="l02364"></a>02364   <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;les_cl.<a class="code" href="classvect__impl.html#a78155bfbd6b61f4710b9830641ed1694">size</a>(); i++)
<a name="l02365"></a>02365     {
<a name="l02366"></a>02366       <span class="keyword">const</span> <a class="code" href="classCond__lim.html" title="classe Cond_lim Classe generique servant a representer n&#39;importe quelle classe derivee de la classe C...">Cond_lim</a>&amp; la_cl = les_cl[i];
<a name="l02367"></a>02367       <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp; le_bord = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>,la_cl.<a class="code" href="classCond__lim.html#a5b2d24809cee07727006a891d4ce8d22" title="Appel a l&#39;objet sous-jacent Renvoie la frontiere discretisee associee a la condition aux limites...">frontiere_dis</a>());
<a name="l02368"></a>02368       <span class="keywordtype">int</span> nb_faces_bord_tot = le_bord.<a class="code" href="classFront__VF.html#aed4006d91bf2ef3af2b9f7933d863a09" title="Nombre de faces reelles et virtuelles du bord.">nb_faces_tot</a>();
<a name="l02369"></a>02369       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> ind_face=0; ind_face&lt;nb_faces_bord_tot; ind_face++)
<a name="l02370"></a>02370         {
<a name="l02371"></a>02371           ok=<a class="code" href="AssembleurPP1BUtil_8cpp.html#a40cf40213663174bb24649e51832bf3e">okface</a>(ind_face, face, la_cl);
<a name="l02372"></a>02372           <span class="keywordflow">if</span> (ok==-1) <span class="keywordflow">break</span>;
<a name="l02373"></a>02373           elem1=face_voisins(face, 0);
<a name="l02374"></a>02374           elem2=face_voisins(face, 1);
<a name="l02375"></a>02375           <a class="code" href="AssembleurPP1BUtil_8cpp.html#afd0a249a235b161c5267e7574e199a82">remplir_sommets</a>(zone_VEF, face, elem1, elem2, sommets,
<a name="l02376"></a>02376                           face_opp1, face_opp2);
<a name="l02377"></a>02377           <a class="code" href="AssembleurPP1BUtil_8cpp.html#acff816d35f8d4ce978f860e0cd958b8a">sort</a>(sommets, face_opp1, face_opp2);
<a name="l02378"></a>02378           <span class="keywordflow">if</span>(ok==3)
<a name="l02379"></a>02379             {
<a name="l02380"></a>02380               <a class="code" href="AssembleurPP1BUtil_8cpp.html#affe9938bfd355c4e19b608c286c0293b">update_matrice_NeumannP1P1</a>(zone_VEF,
<a name="l02381"></a>02381                                          inverse_quantitee_entrelacee,
<a name="l02382"></a>02382                                          face, elem1, sommets,
<a name="l02383"></a>02383                                          face_opp1, coef_som,
<a name="l02384"></a>02384                                          ARR,ARV,AVR,AVV);
<a name="l02385"></a>02385             }
<a name="l02386"></a>02386           <span class="keywordflow">else</span> <span class="keywordflow">if</span>(ok==4)
<a name="l02387"></a>02387             {
<a name="l02388"></a>02388               <a class="code" href="AssembleurPP1BUtil_8cpp.html#ade1c92b286a861f3920664b658ba3fb1">update_matrice_SymetrieP1P1</a>(zone_VEF,
<a name="l02389"></a>02389                                           inverse_quantitee_entrelacee,
<a name="l02390"></a>02390                                           face, elem1, sommets,
<a name="l02391"></a>02391                                           face_opp1, coef_som,
<a name="l02392"></a>02392                                           ARR,ARV,AVR,AVV);
<a name="l02393"></a>02393             }
<a name="l02394"></a>02394           <span class="keywordflow">else</span>
<a name="l02395"></a>02395             <a class="code" href="AssembleurPP1BUtil_8cpp.html#a77351839245012751e4d90a39922356a">update_matriceP1P1</a>(zone_VEF,
<a name="l02396"></a>02396                                inverse_quantitee_entrelacee,
<a name="l02397"></a>02397                                face, elem1, elem2, sommets,
<a name="l02398"></a>02398                                face_opp1, face_opp2, coef_som,
<a name="l02399"></a>02399                                ARR,ARV,AVR,AVV);
<a name="l02400"></a>02400         }
<a name="l02401"></a>02401     }
<a name="l02402"></a>02402   <a class="code" href="AssembleurPP1BUtil_8cpp.html#a3e374d53ebc7860e1c2f0b7906f2936d">face_associee</a>=-1;
<a name="l02403"></a>02403   <span class="keywordflow">for</span>(face=nint; face&lt;nb_faces; face++)
<a name="l02404"></a>02404     {
<a name="l02405"></a>02405       elem1=face_voisins(face, 0);
<a name="l02406"></a>02406       elem2=face_voisins(face, 1);
<a name="l02407"></a>02407       <span class="keywordflow">if</span> (!zone_VEF.<a class="code" href="classZone__VF.html#a33909d3880435e82e84639b51482d2c6" title="renvoie 1 si face est une face virtuelle de bord, 0 sinon">est_une_face_virt_bord</a>(face)) <span class="comment">//!&lt; On ne traite que les faces internes</span>
<a name="l02408"></a>02408 <span class="comment"></span>        {
<a name="l02409"></a>02409           <a class="code" href="AssembleurPP1BUtil_8cpp.html#afd0a249a235b161c5267e7574e199a82">remplir_sommets</a>(zone_VEF, face, elem1, elem2, sommets,
<a name="l02410"></a>02410                           face_opp1, face_opp2);
<a name="l02411"></a>02411           <a class="code" href="AssembleurPP1BUtil_8cpp.html#acff816d35f8d4ce978f860e0cd958b8a">sort</a>(sommets, face_opp1, face_opp2);
<a name="l02412"></a>02412           <a class="code" href="AssembleurPP1BUtil_8cpp.html#a77351839245012751e4d90a39922356a">update_matriceP1P1</a>(zone_VEF, inverse_quantitee_entrelacee,
<a name="l02413"></a>02413                              face, elem1, elem2, sommets,
<a name="l02414"></a>02414                              face_opp1, face_opp2, coef_som,
<a name="l02415"></a>02415                              ARR,ARV,AVR,AVV);
<a name="l02416"></a>02416         }
<a name="l02417"></a>02417     }
<a name="l02418"></a>02418   <span class="keywordtype">int</span> nb_som=zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#ad340f571f81fa5c2e028b88c00b5c2ca" title="Renvoie le nombre de sommets de la zone.">nb_som</a>();
<a name="l02419"></a>02419   <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;nb_som; i++)
<a name="l02420"></a>02420     <span class="keywordflow">if</span>(ARR(i,i)==0)
<a name="l02421"></a>02421       {
<a name="l02422"></a>02422 <span class="comment">// Cerr &lt;&lt; &quot;On modifie la ligne (sommet) orpheline &quot; &lt;&lt; i &lt;&lt; finl;</span>
<a name="l02423"></a>02423         ARR(i,i)=1.;
<a name="l02424"></a>02424       }
<a name="l02425"></a>02425   <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Update P1 OK&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
<a name="l02426"></a>02426 }
<a name="l02427"></a>02427 
<a name="l02428"></a>02428 
<a name="l02429"></a><a class="code" href="AssembleurPP1BUtil_8cpp.html#a1ce15acad922bef2d305d970c13c68c8">02429</a> <span class="keywordtype">void</span> <a class="code" href="Assembleur__P__VEFPreP1B_8cpp.html#a1ce15acad922bef2d305d970c13c68c8">modifieP1P1neumann</a>(<span class="keyword">const</span> <a class="code" href="classZone__dis__base.html" title="classe Zone_dis_base Cette classe est la base de la hierarchie des zones discretisees. Un objet Zone est associe a la zone discretise. A chaque methode numerique de Trio U correspond une classe derivant de Zone_dis_base implementant les outils necessaires a la methode.">Zone_dis_base</a>&amp; z,
<a name="l02430"></a>02430                         <span class="keyword">const</span> <a class="code" href="classZone__Cl__dis__base.html" title="classe Zone_Cl_dis_base Les objets Zone_Cl_dis_base representent les conditions aux limites discretis...">Zone_Cl_dis_base</a>&amp; zcl,
<a name="l02431"></a>02431                         <a class="code" href="classMatrice.html">Matrice</a>&amp; matrice,
<a name="l02432"></a>02432                         <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; inverse_quantitee_entrelacee, <span class="keyword">const</span> <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a>&amp; coef_som)
<a name="l02433"></a>02433 {
<a name="l02434"></a>02434 
<a name="l02435"></a>02435   <span class="keywordtype">int</span> dimension=<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>;
<a name="l02436"></a>02436   <span class="keyword">const</span> <a class="code" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a>&amp; zone_VEF=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a>, z);
<a name="l02437"></a>02437 <span class="comment">// const Zone&amp; zone=zone_VEF.zone();</span>
<a name="l02438"></a>02438   <span class="keyword">const</span> <a class="code" href="classZone__Cl__VEF.html">Zone_Cl_VEF</a>&amp; zone_Cl_VEF=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classZone__Cl__VEF.html">Zone_Cl_VEF</a>, zcl);
<a name="l02439"></a>02439   <span class="keyword">const</span> <a class="code" href="classConds__lim.html">Conds_lim</a>&amp; les_cl = zone_Cl_VEF.<a class="code" href="classZone__Cl__dis__base.html#af75e0ed7786863e4d333bfb29d67c323" title="Renvoie la i-ieme condition aux limites. (version const)">les_conditions_limites</a>();
<a name="l02440"></a>02440 
<a name="l02441"></a>02441 <span class="comment">// int nnz=nb_som;</span>
<a name="l02442"></a>02442   <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> sommets(dimension+2);
<a name="l02443"></a>02443   <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> face_opp1(dimension+2);
<a name="l02444"></a>02444   <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> face_opp2(dimension+2);
<a name="l02445"></a>02445   <a class="code" href="classMatrice__Bloc.html">Matrice_Bloc</a>&amp; A=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Bloc.html">Matrice_Bloc</a>, matrice.<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>());
<a name="l02446"></a>02446   <a class="code" href="classMatrice__Morse__Sym.html" title="Classe Matrice_Morse_Sym Represente une matrice M (creuse) symetrique stockee au format Morse Symetri...">Matrice_Morse_Sym</a>&amp; ARR=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Morse__Sym.html" title="Classe Matrice_Morse_Sym Represente une matrice M (creuse) symetrique stockee au format Morse Symetri...">Matrice_Morse_Sym</a>, A.<a class="code" href="classMatrice__Bloc.html#a7ffa38f7b93454432b2df7c616ed0a4e">get_bloc</a>(0,0).<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>());
<a name="l02447"></a>02447 <span class="comment">// Faces de bord :</span>
<a name="l02448"></a>02448   assert(<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a>, z).get_cl_pression_sommet_faible()==0);
<a name="l02449"></a>02449   <span class="keywordtype">int</span> nb_som_tot=z.<a class="code" href="classZone__dis__base.html#acc9921d6a29cb719fd832fd573e47825">nb_som</a>();
<a name="l02450"></a>02450   <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;les_cl.<a class="code" href="classvect__impl.html#a78155bfbd6b61f4710b9830641ed1694">size</a>(); i++)
<a name="l02451"></a>02451     {
<a name="l02452"></a>02452 
<a name="l02453"></a>02453       <span class="keyword">const</span> <a class="code" href="classCond__lim__base.html" title="classe Cond_lim_base Classe de base pour la hierarchie des classes qui representent les differentes c...">Cond_lim_base</a>&amp; la_cl = les_cl[i].valeur();
<a name="l02454"></a>02454       <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classNeumann__sortie__libre.html" title="classe Neumann_sortie_libre Cette classe represente une frontiere ouverte sans vitesse imposee Pour l...">Neumann_sortie_libre</a>,la_cl))
<a name="l02455"></a>02455         {
<a name="l02456"></a>02456           <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp; le_bord = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>,la_cl.<a class="code" href="classCond__lim__base.html#ad88b3b516351146c85e8fce1df0f691a" title="Renvoie la frontiere discretisee a laquelle les conditions aux limites s&#39;appliquent.">frontiere_dis</a>());
<a name="l02457"></a>02457           <span class="keywordtype">int</span> nb_faces_bord = le_bord.<a class="code" href="classFront__VF.html#aed4006d91bf2ef3af2b9f7933d863a09" title="Nombre de faces reelles et virtuelles du bord.">nb_faces_tot</a>();
<a name="l02458"></a>02458           <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; faces=zone_VEF.<a class="code" href="classZone__VF.html#a298e73b18e17da55f421b1fb0879bd46" title="renvoie le numero du ieme sommet de la face num_face.">face_sommets</a>();
<a name="l02459"></a>02459           <span class="keywordtype">int</span> nbsf=faces.<a class="code" href="classIntTab.html#abc3b32c94925a82f69d5b153a356e359" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(1);
<a name="l02460"></a>02460           <span class="keywordflow">for</span>(<span class="keywordtype">int</span> ind_face=0; ind_face&lt;nb_faces_bord; ind_face++)
<a name="l02461"></a>02461             {
<a name="l02462"></a>02462               <span class="keywordtype">int</span> face=le_bord.<a class="code" href="classFront__VF.html#a3402a19d7e54ed797d2b18e9a47ead1e" title="Renvoie le numero de face de la ieme face du bord.">num_face</a>(ind_face);
<a name="l02463"></a>02463               <span class="keywordflow">for</span>(<span class="keywordtype">int</span> som=0; som&lt;nbsf; som++)
<a name="l02464"></a>02464                 {
<a name="l02465"></a>02465 
<a name="l02466"></a>02466                   <span class="keywordtype">int</span> som_glob=faces(face,som);
<a name="l02467"></a>02467                   <span class="keywordflow">if</span> (som_glob&lt;nb_som_tot)
<a name="l02468"></a>02468                     ARR(som_glob,som_glob)=1e12;
<a name="l02469"></a>02469 <span class="comment">// Cout&lt;&lt;ref_cast(Zone_VEF_PreP1b, z).numero_premier_sommet()&lt;&lt;&quot; ici &quot;&lt;&lt;som_glob&lt;&lt;finl;</span>
<a name="l02470"></a>02470                 }
<a name="l02471"></a>02471             }
<a name="l02472"></a>02472         }
<a name="l02473"></a>02473     }
<a name="l02474"></a>02474   <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Modifie P1P1 Neumann OK&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
<a name="l02475"></a>02475 }
<a name="l02476"></a>02476 
<a name="l02477"></a><a class="code" href="AssembleurPP1BUtil_8cpp.html#a7840f924363ed7d3fbd50a59d9d990c0">02477</a> <span class="keywordtype">void</span> <a class="code" href="Assembleur__P__VEFPreP1B_8cpp.html#a7840f924363ed7d3fbd50a59d9d990c0">assemblerPaPa</a>(<span class="keyword">const</span> <a class="code" href="classZone__dis__base.html" title="classe Zone_dis_base Cette classe est la base de la hierarchie des zones discretisees. Un objet Zone est associe a la zone discretise. A chaque methode numerique de Trio U correspond une classe derivant de Zone_dis_base implementant les outils necessaires a la methode.">Zone_dis_base</a>&amp; z,
<a name="l02478"></a>02478                    <span class="keyword">const</span> <a class="code" href="classZone__Cl__dis__base.html" title="classe Zone_Cl_dis_base Les objets Zone_Cl_dis_base representent les conditions aux limites discretis...">Zone_Cl_dis_base</a>&amp; zcl,
<a name="l02479"></a>02479                    <a class="code" href="classMatrice.html">Matrice</a>&amp; matrice,
<a name="l02480"></a>02480                    <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; inverse_quantitee_entrelacee)
<a name="l02481"></a>02481 {
<a name="l02482"></a>02482   <span class="keywordtype">int</span> dimension=<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>;
<a name="l02483"></a>02483   <span class="keyword">const</span> <a class="code" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a>&amp; zone_VEF=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a>, z);
<a name="l02484"></a>02484   <span class="keyword">const</span> <a class="code" href="classZone.html" title="classe Zone Une Zone est un maillage compose d&#39;un ensemble d&#39;elements geometriques de meme type...">Zone</a>&amp; zone=zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>();
<a name="l02485"></a>02485   <span class="keyword">const</span> <a class="code" href="classZone__Cl__VEF.html">Zone_Cl_VEF</a>&amp; zone_Cl_VEF=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classZone__Cl__VEF.html">Zone_Cl_VEF</a>, zcl);
<a name="l02486"></a>02486   <span class="keyword">const</span> <a class="code" href="classConds__lim.html">Conds_lim</a>&amp; les_cl = zone_Cl_VEF.<a class="code" href="classZone__Cl__dis__base.html#af75e0ed7786863e4d333bfb29d67c323" title="Renvoie la i-ieme condition aux limites. (version const)">les_conditions_limites</a>();
<a name="l02487"></a>02487   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; face_voisins = zone_VEF.<a class="code" href="classZone__VF.html#a49d4322f5585a8fa95748ca785b70702" title="renvoie l&#39;element voisin de numface dans la direction i. i=0 : dans le sens oppose de l&#39;axe orthogona...">face_voisins</a>();
<a name="l02488"></a>02488   <span class="keywordtype">int</span> nint = zone_VEF.<a class="code" href="classZone__VF.html#a12869806fa4834aca8f2964e16509dfd" title="une face est interne ssi elle separe deux elements. renvoie le numero de la premiere face interne...">premiere_face_int</a>();
<a name="l02489"></a>02489   <span class="keywordtype">int</span> nb_faces = zone_VEF.<a class="code" href="classZone__VF.html#a50fd21c9535680489015a3c8b88c685a" title="renvoie le nombre total de faces. C&#39;est-a-dire faces reelles + faces virtuelles">nb_faces_tot</a>();
<a name="l02490"></a>02490   <span class="keywordtype">int</span> nb_arete = zone.<a class="code" href="classZone.html#a59ae0ababf85ce303a7c6f339430e335" title="renvoie le nombre d&#39;aretes total (reelles+virtuelles).">nb_aretes_tot</a>();
<a name="l02491"></a>02491   <span class="keywordtype">int</span> elem1, elem2, face, ok;
<a name="l02492"></a>02492   <span class="keywordtype">int</span> nnz=nb_arete;
<a name="l02493"></a>02493   <a class="code" href="classIntLists.html" title="Un tableau de listes de type IntList.">IntLists</a> voisins(nb_arete);
<a name="l02494"></a>02494   <a class="code" href="classDoubleLists.html" title="Un tableau de listes de type DoubleList.">DoubleLists</a> coeffs(nb_arete);
<a name="l02495"></a>02495   <a class="code" href="classDoubleVect.html">DoubleVect</a> diag(nb_arete);
<a name="l02496"></a>02496   <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> sommets(dimension+2);
<a name="l02497"></a>02497   <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> face_opp1(dimension+2);
<a name="l02498"></a>02498   <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> face_opp2(dimension+2);
<a name="l02499"></a>02499 <span class="comment">// Faces de bord :</span>
<a name="l02500"></a>02500   <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;les_cl.<a class="code" href="classvect__impl.html#a78155bfbd6b61f4710b9830641ed1694">size</a>(); i++)
<a name="l02501"></a>02501     {
<a name="l02502"></a>02502       <span class="keyword">const</span> <a class="code" href="classCond__lim.html" title="classe Cond_lim Classe generique servant a representer n&#39;importe quelle classe derivee de la classe C...">Cond_lim</a>&amp; la_cl = les_cl[i];
<a name="l02503"></a>02503       <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp; le_bord = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>,la_cl.<a class="code" href="classCond__lim.html#a5b2d24809cee07727006a891d4ce8d22" title="Appel a l&#39;objet sous-jacent Renvoie la frontiere discretisee associee a la condition aux limites...">frontiere_dis</a>());
<a name="l02504"></a>02504       <span class="keywordtype">int</span> nb_faces_bord_tot = le_bord.<a class="code" href="classFront__VF.html#aed4006d91bf2ef3af2b9f7933d863a09" title="Nombre de faces reelles et virtuelles du bord.">nb_faces_tot</a>();
<a name="l02505"></a>02505       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> ind_face=0; ind_face&lt;nb_faces_bord_tot; ind_face++)
<a name="l02506"></a>02506         {
<a name="l02507"></a>02507           ok=<a class="code" href="AssembleurPP1BUtil_8cpp.html#a40cf40213663174bb24649e51832bf3e">okface</a>(ind_face, face, la_cl);
<a name="l02508"></a>02508           <span class="keywordflow">if</span> (ok==-1) <span class="keywordflow">break</span>;
<a name="l02509"></a>02509           elem1=face_voisins(face, 0);
<a name="l02510"></a>02510           elem2=face_voisins(face, 1);
<a name="l02511"></a>02511           <a class="code" href="AssembleurPP1BUtil_8cpp.html#afd0a249a235b161c5267e7574e199a82">remplir_sommets</a>(zone_VEF, face, elem1, elem2, sommets,
<a name="l02512"></a>02512                           face_opp1, face_opp2);
<a name="l02513"></a>02513           <span class="keywordflow">if</span>(ok==3)
<a name="l02514"></a>02514             {
<a name="l02515"></a>02515               <a class="code" href="AssembleurPP1BUtil_8cpp.html#a80033228b3ed99e778b70c35cda5e4e6">contribuer_matrice_NeumannPaPa</a>(zone_VEF,
<a name="l02516"></a>02516                                              inverse_quantitee_entrelacee,
<a name="l02517"></a>02517                                              face, elem1, sommets,
<a name="l02518"></a>02518                                              face_opp1,
<a name="l02519"></a>02519                                              voisins, coeffs, diag, nnz);
<a name="l02520"></a>02520             }
<a name="l02521"></a>02521           <span class="keywordflow">else</span> <span class="keywordflow">if</span>(ok==4)
<a name="l02522"></a>02522             {
<a name="l02523"></a>02523               <a class="code" href="AssembleurPP1BUtil_8cpp.html#ac51ccb6fe9aac0200f1b08da9d81c65b">contribuer_matrice_SymetriePaPa</a>(zone_VEF,
<a name="l02524"></a>02524                                               inverse_quantitee_entrelacee,
<a name="l02525"></a>02525                                               face, elem1, sommets,
<a name="l02526"></a>02526                                               face_opp1,
<a name="l02527"></a>02527                                               voisins, coeffs, diag, nnz);
<a name="l02528"></a>02528             }
<a name="l02529"></a>02529           <span class="keywordflow">else</span>
<a name="l02530"></a>02530             <a class="code" href="AssembleurPP1BUtil_8cpp.html#a59992a437cf7e18b4b9ce353d77d0bda">contribuer_matricePaPa</a>(zone_VEF,
<a name="l02531"></a>02531                                    inverse_quantitee_entrelacee,
<a name="l02532"></a>02532                                    face, elem1, elem2, sommets,
<a name="l02533"></a>02533                                    face_opp1, face_opp2,
<a name="l02534"></a>02534                                    voisins, coeffs, diag, nnz);
<a name="l02535"></a>02535         }
<a name="l02536"></a>02536     }
<a name="l02537"></a>02537   <a class="code" href="AssembleurPP1BUtil_8cpp.html#a3e374d53ebc7860e1c2f0b7906f2936d">face_associee</a>=-1;
<a name="l02538"></a>02538   <span class="keywordflow">for</span>(face=nint; face&lt;nb_faces; face++)
<a name="l02539"></a>02539     {
<a name="l02540"></a>02540       elem1=face_voisins(face, 0);
<a name="l02541"></a>02541       elem2=face_voisins(face, 1);
<a name="l02542"></a>02542       <span class="keywordflow">if</span> (!zone_VEF.<a class="code" href="classZone__VF.html#a33909d3880435e82e84639b51482d2c6" title="renvoie 1 si face est une face virtuelle de bord, 0 sinon">est_une_face_virt_bord</a>(face)) <span class="comment">//!&lt; On ne traite que les faces internes</span>
<a name="l02543"></a>02543 <span class="comment"></span>        {
<a name="l02544"></a>02544           <a class="code" href="AssembleurPP1BUtil_8cpp.html#afd0a249a235b161c5267e7574e199a82">remplir_sommets</a>(zone_VEF, face, elem1, elem2, sommets,
<a name="l02545"></a>02545                           face_opp1, face_opp2);
<a name="l02546"></a>02546           <a class="code" href="AssembleurPP1BUtil_8cpp.html#a59992a437cf7e18b4b9ce353d77d0bda">contribuer_matricePaPa</a>(zone_VEF,
<a name="l02547"></a>02547                                  inverse_quantitee_entrelacee,
<a name="l02548"></a>02548                                  face, elem1, elem2, sommets,
<a name="l02549"></a>02549                                  face_opp1, face_opp2,
<a name="l02550"></a>02550                                  voisins, coeffs, diag, nnz);
<a name="l02551"></a>02551         }
<a name="l02552"></a>02552     }
<a name="l02553"></a>02553   <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;nb_arete; i++)
<a name="l02554"></a>02554     <span class="keywordflow">if</span>(diag(i)==0)
<a name="l02555"></a>02555       {
<a name="l02556"></a>02556 <span class="comment">// On n&#39;affiche pas car trop sur de gros maillages</span>
<a name="l02557"></a>02557 <span class="comment">// Cerr &lt;&lt; &quot;On modifie la ligne (arete) orpheline &quot; &lt;&lt; i &lt;&lt; finl;</span>
<a name="l02558"></a>02558         diag(i)=1;
<a name="l02559"></a>02559       }
<a name="l02560"></a>02560 
<a name="l02561"></a>02561   matrice.<a class="code" href="classDeriv__.html#ad1d33400ed15b6ff96579ed82d9e2719" title="Essaie de creer une instance du type &quot;type&quot;. si type n&#39;est pas un type ou type n&#39;est pas instanciab...">typer</a>(<span class="stringliteral">&quot;Matrice_Bloc&quot;</span>);
<a name="l02562"></a>02562   <a class="code" href="classMatrice__Bloc.html">Matrice_Bloc</a>&amp; matrice_bloc=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Bloc.html">Matrice_Bloc</a>, matrice.<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>());
<a name="l02563"></a>02563   matrice_bloc.<a class="code" href="classMatrice__Bloc.html#a7d624ebd3f141e34502e59f6d1b1d601">remplir</a>(voisins, coeffs, diag, zone.<a class="code" href="classZone.html#a3e3b48691911fd85574c7bc10a1a4fb8" title="renvoie le nombre d&#39;aretes reelles.">nb_aretes</a>(), zone.<a class="code" href="classZone.html#a59ae0ababf85ce303a7c6f339430e335" title="renvoie le nombre d&#39;aretes total (reelles+virtuelles).">nb_aretes_tot</a>());
<a name="l02564"></a>02564   <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Assemblage Pa OK&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
<a name="l02565"></a>02565 }
<a name="l02566"></a>02566 
<a name="l02567"></a><a class="code" href="AssembleurPP1BUtil_8cpp.html#a4e0c0752e80915fd8b0143b70f08e718">02567</a> <span class="keywordtype">void</span> <a class="code" href="Assembleur__P__VEFPreP1B_8cpp.html#a4e0c0752e80915fd8b0143b70f08e718">updatePaPa</a>(<span class="keyword">const</span> <a class="code" href="classZone__dis__base.html" title="classe Zone_dis_base Cette classe est la base de la hierarchie des zones discretisees. Un objet Zone est associe a la zone discretise. A chaque methode numerique de Trio U correspond une classe derivant de Zone_dis_base implementant les outils necessaires a la methode.">Zone_dis_base</a>&amp; z,
<a name="l02568"></a>02568                 <span class="keyword">const</span> <a class="code" href="classZone__Cl__dis__base.html" title="classe Zone_Cl_dis_base Les objets Zone_Cl_dis_base representent les conditions aux limites discretis...">Zone_Cl_dis_base</a>&amp; zcl,
<a name="l02569"></a>02569                 <a class="code" href="classMatrice.html">Matrice</a>&amp; matrice,
<a name="l02570"></a>02570                 <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; inverse_quantitee_entrelacee)
<a name="l02571"></a>02571 {
<a name="l02572"></a>02572   <span class="keywordtype">int</span> dimension=<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>;
<a name="l02573"></a>02573   <span class="keyword">const</span> <a class="code" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a>&amp; zone_VEF=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a>, z);
<a name="l02574"></a>02574   <span class="keyword">const</span> <a class="code" href="classZone.html" title="classe Zone Une Zone est un maillage compose d&#39;un ensemble d&#39;elements geometriques de meme type...">Zone</a>&amp; zone=zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>();
<a name="l02575"></a>02575   <span class="keyword">const</span> <a class="code" href="classZone__Cl__VEF.html">Zone_Cl_VEF</a>&amp; zone_Cl_VEF=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classZone__Cl__VEF.html">Zone_Cl_VEF</a>, zcl);
<a name="l02576"></a>02576   <span class="keyword">const</span> <a class="code" href="classConds__lim.html">Conds_lim</a>&amp; les_cl = zone_Cl_VEF.<a class="code" href="classZone__Cl__dis__base.html#af75e0ed7786863e4d333bfb29d67c323" title="Renvoie la i-ieme condition aux limites. (version const)">les_conditions_limites</a>();
<a name="l02577"></a>02577   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; face_voisins = zone_VEF.<a class="code" href="classZone__VF.html#a49d4322f5585a8fa95748ca785b70702" title="renvoie l&#39;element voisin de numface dans la direction i. i=0 : dans le sens oppose de l&#39;axe orthogona...">face_voisins</a>();
<a name="l02578"></a>02578   <span class="keywordtype">int</span> nint = zone_VEF.<a class="code" href="classZone__VF.html#a12869806fa4834aca8f2964e16509dfd" title="une face est interne ssi elle separe deux elements. renvoie le numero de la premiere face interne...">premiere_face_int</a>();
<a name="l02579"></a>02579   <span class="keywordtype">int</span> nb_faces = zone_VEF.<a class="code" href="classZone__VF.html#a50fd21c9535680489015a3c8b88c685a" title="renvoie le nombre total de faces. C&#39;est-a-dire faces reelles + faces virtuelles">nb_faces_tot</a>();
<a name="l02580"></a>02580   <span class="keywordtype">int</span> nb_arete = zone.<a class="code" href="classZone.html#a3e3b48691911fd85574c7bc10a1a4fb8" title="renvoie le nombre d&#39;aretes reelles.">nb_aretes</a>();
<a name="l02581"></a>02581   <span class="keywordtype">int</span> elem1, elem2, face, ok;
<a name="l02582"></a>02582   <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> sommets(dimension+2);
<a name="l02583"></a>02583   <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> face_opp1(dimension+2);
<a name="l02584"></a>02584   <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> face_opp2(dimension+2);
<a name="l02585"></a>02585   <a class="code" href="classMatrice__Bloc.html">Matrice_Bloc</a>&amp; A=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Bloc.html">Matrice_Bloc</a>, matrice.<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>());
<a name="l02586"></a>02586   <a class="code" href="classMatrice__Morse__Sym.html" title="Classe Matrice_Morse_Sym Represente une matrice M (creuse) symetrique stockee au format Morse Symetri...">Matrice_Morse_Sym</a>&amp; ARR=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Morse__Sym.html" title="Classe Matrice_Morse_Sym Represente une matrice M (creuse) symetrique stockee au format Morse Symetri...">Matrice_Morse_Sym</a>, A.<a class="code" href="classMatrice__Bloc.html#a7ffa38f7b93454432b2df7c616ed0a4e">get_bloc</a>(0,0).<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>());
<a name="l02587"></a>02587   <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; ARV=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>, A.<a class="code" href="classMatrice__Bloc.html#a7ffa38f7b93454432b2df7c616ed0a4e">get_bloc</a>(0,1).<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>());
<a name="l02588"></a>02588   <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; AVR=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>, A.<a class="code" href="classMatrice__Bloc.html#a7ffa38f7b93454432b2df7c616ed0a4e">get_bloc</a>(1,0).<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>());
<a name="l02589"></a>02589   <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; AVV=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>, A.<a class="code" href="classMatrice__Bloc.html#a7ffa38f7b93454432b2df7c616ed0a4e">get_bloc</a>(1,1).<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>());
<a name="l02590"></a>02590 <span class="comment">// Faces de bord :</span>
<a name="l02591"></a>02591   <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;les_cl.<a class="code" href="classvect__impl.html#a78155bfbd6b61f4710b9830641ed1694">size</a>(); i++)
<a name="l02592"></a>02592     {
<a name="l02593"></a>02593       <span class="keyword">const</span> <a class="code" href="classCond__lim.html" title="classe Cond_lim Classe generique servant a representer n&#39;importe quelle classe derivee de la classe C...">Cond_lim</a>&amp; la_cl = les_cl[i];
<a name="l02594"></a>02594       <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp; le_bord = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>,la_cl.<a class="code" href="classCond__lim.html#a5b2d24809cee07727006a891d4ce8d22" title="Appel a l&#39;objet sous-jacent Renvoie la frontiere discretisee associee a la condition aux limites...">frontiere_dis</a>());
<a name="l02595"></a>02595       <span class="keywordtype">int</span> nb_faces_bord_tot = le_bord.<a class="code" href="classFront__VF.html#aed4006d91bf2ef3af2b9f7933d863a09" title="Nombre de faces reelles et virtuelles du bord.">nb_faces_tot</a>();
<a name="l02596"></a>02596       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> ind_face=0; ind_face&lt;nb_faces_bord_tot; ind_face++)
<a name="l02597"></a>02597         {
<a name="l02598"></a>02598           ok=<a class="code" href="AssembleurPP1BUtil_8cpp.html#a40cf40213663174bb24649e51832bf3e">okface</a>(ind_face, face, la_cl);
<a name="l02599"></a>02599           <span class="keywordflow">if</span> (ok==-1) <span class="keywordflow">break</span>;
<a name="l02600"></a>02600           elem1=face_voisins(face, 0);
<a name="l02601"></a>02601           elem2=face_voisins(face, 1);
<a name="l02602"></a>02602           <a class="code" href="AssembleurPP1BUtil_8cpp.html#afd0a249a235b161c5267e7574e199a82">remplir_sommets</a>(zone_VEF, face, elem1, elem2, sommets,
<a name="l02603"></a>02603                           face_opp1, face_opp2);
<a name="l02604"></a>02604           <span class="keywordflow">if</span>(ok==3)
<a name="l02605"></a>02605             {
<a name="l02606"></a>02606               <a class="code" href="AssembleurPP1BUtil_8cpp.html#a6a26a390dab2336113f60275e5978aaf">update_matrice_NeumannPaPa</a>(zone_VEF,
<a name="l02607"></a>02607                                          inverse_quantitee_entrelacee,
<a name="l02608"></a>02608                                          face, elem1, sommets,
<a name="l02609"></a>02609                                          face_opp1,
<a name="l02610"></a>02610                                          ARR, ARV, AVR, AVV);
<a name="l02611"></a>02611             }
<a name="l02612"></a>02612           <span class="keywordflow">else</span> <span class="keywordflow">if</span>(ok==4)
<a name="l02613"></a>02613             {
<a name="l02614"></a>02614               <a class="code" href="AssembleurPP1BUtil_8cpp.html#a6e9d49381847c5756d002970ca6441b8">update_matrice_SymetriePaPa</a>(zone_VEF,
<a name="l02615"></a>02615                                           inverse_quantitee_entrelacee,
<a name="l02616"></a>02616                                           face, elem1, sommets,
<a name="l02617"></a>02617                                           face_opp1,
<a name="l02618"></a>02618                                           ARR, ARV, AVR, AVV);
<a name="l02619"></a>02619             }
<a name="l02620"></a>02620           <span class="keywordflow">else</span>
<a name="l02621"></a>02621             <a class="code" href="AssembleurPP1BUtil_8cpp.html#a76d676949fb80bc3c7f1ab5f7f8078c0">update_matricePaPa</a>(zone_VEF,
<a name="l02622"></a>02622                                inverse_quantitee_entrelacee,
<a name="l02623"></a>02623                                face, elem1, elem2, sommets,
<a name="l02624"></a>02624                                face_opp1, face_opp2,
<a name="l02625"></a>02625                                ARR, ARV, AVR, AVV);
<a name="l02626"></a>02626         }
<a name="l02627"></a>02627     }
<a name="l02628"></a>02628   <a class="code" href="AssembleurPP1BUtil_8cpp.html#a3e374d53ebc7860e1c2f0b7906f2936d">face_associee</a>=-1;
<a name="l02629"></a>02629   <span class="keywordflow">for</span>(face=nint; face&lt;nb_faces; face++)
<a name="l02630"></a>02630     {
<a name="l02631"></a>02631       elem1=face_voisins(face, 0);
<a name="l02632"></a>02632       elem2=face_voisins(face, 1);
<a name="l02633"></a>02633       <span class="keywordflow">if</span> (!zone_VEF.<a class="code" href="classZone__VF.html#a33909d3880435e82e84639b51482d2c6" title="renvoie 1 si face est une face virtuelle de bord, 0 sinon">est_une_face_virt_bord</a>(face)) <span class="comment">//!&lt; On ne traite que les faces internes</span>
<a name="l02634"></a>02634 <span class="comment"></span>        {
<a name="l02635"></a>02635           <a class="code" href="AssembleurPP1BUtil_8cpp.html#afd0a249a235b161c5267e7574e199a82">remplir_sommets</a>(zone_VEF, face, elem1, elem2, sommets,
<a name="l02636"></a>02636                           face_opp1, face_opp2);
<a name="l02637"></a>02637           <a class="code" href="AssembleurPP1BUtil_8cpp.html#a76d676949fb80bc3c7f1ab5f7f8078c0">update_matricePaPa</a>(zone_VEF,
<a name="l02638"></a>02638                              inverse_quantitee_entrelacee,
<a name="l02639"></a>02639                              face, elem1, elem2, sommets,
<a name="l02640"></a>02640                              face_opp1, face_opp2,
<a name="l02641"></a>02641                              ARR,ARV,AVR,AVV);
<a name="l02642"></a>02642         }
<a name="l02643"></a>02643     }
<a name="l02644"></a>02644   <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;nb_arete; i++)
<a name="l02645"></a>02645     <span class="keywordflow">if</span>(ARR(i,i)==0)
<a name="l02646"></a>02646       {
<a name="l02647"></a>02647 <span class="comment">// On n&#39;affiche pas car trop sur de gros maillages</span>
<a name="l02648"></a>02648 <span class="comment">// Cerr &lt;&lt; &quot;On modifie la ligne (arete) orpheline &quot; &lt;&lt; i &lt;&lt; finl;</span>
<a name="l02649"></a>02649         ARR(i,i)=1;
<a name="l02650"></a>02650       }
<a name="l02651"></a>02651 
<a name="l02652"></a>02652   <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Update Pa OK&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
<a name="l02653"></a>02653 }
<a name="l02654"></a>02654 
<a name="l02655"></a><a class="code" href="AssembleurPP1BUtil_8cpp.html#a30b5e404b46e2a239584ee19835c88bf">02655</a> <span class="keywordtype">void</span> <a class="code" href="Assembleur__P__VEFPreP1B_8cpp.html#a30b5e404b46e2a239584ee19835c88bf">assemblerP0Pa</a>(<span class="keyword">const</span> <a class="code" href="classZone__dis__base.html" title="classe Zone_dis_base Cette classe est la base de la hierarchie des zones discretisees. Un objet Zone est associe a la zone discretise. A chaque methode numerique de Trio U correspond une classe derivant de Zone_dis_base implementant les outils necessaires a la methode.">Zone_dis_base</a>&amp; z,
<a name="l02656"></a>02656                    <span class="keyword">const</span> <a class="code" href="classZone__Cl__dis__base.html" title="classe Zone_Cl_dis_base Les objets Zone_Cl_dis_base representent les conditions aux limites discretis...">Zone_Cl_dis_base</a>&amp; zcl,
<a name="l02657"></a>02657                    <a class="code" href="classMatrice.html">Matrice</a>&amp; matrice,
<a name="l02658"></a>02658                    <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; inverse_quantitee_entrelacee)
<a name="l02659"></a>02659 {
<a name="l02660"></a>02660   <span class="keywordtype">int</span> dimension=<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>;
<a name="l02661"></a>02661   <span class="keyword">const</span> <a class="code" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a>&amp; zone_VEF=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a>, z);
<a name="l02662"></a>02662   <span class="keyword">const</span> <a class="code" href="classZone.html" title="classe Zone Une Zone est un maillage compose d&#39;un ensemble d&#39;elements geometriques de meme type...">Zone</a>&amp; zone=zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>();
<a name="l02663"></a>02663   <span class="keyword">const</span> <a class="code" href="classZone__Cl__VEF.html">Zone_Cl_VEF</a>&amp; zone_Cl_VEF=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classZone__Cl__VEF.html">Zone_Cl_VEF</a>, zcl);
<a name="l02664"></a>02664   <span class="keyword">const</span> <a class="code" href="classConds__lim.html">Conds_lim</a>&amp; les_cl = zone_Cl_VEF.<a class="code" href="classZone__Cl__dis__base.html#af75e0ed7786863e4d333bfb29d67c323" title="Renvoie la i-ieme condition aux limites. (version const)">les_conditions_limites</a>();
<a name="l02665"></a>02665   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; face_voisins = zone_VEF.<a class="code" href="classZone__VF.html#a49d4322f5585a8fa95748ca785b70702" title="renvoie l&#39;element voisin de numface dans la direction i. i=0 : dans le sens oppose de l&#39;axe orthogona...">face_voisins</a>();
<a name="l02666"></a>02666   <span class="keywordtype">int</span> nint = zone_VEF.<a class="code" href="classZone__VF.html#a12869806fa4834aca8f2964e16509dfd" title="une face est interne ssi elle separe deux elements. renvoie le numero de la premiere face interne...">premiere_face_int</a>();
<a name="l02667"></a>02667   <span class="keywordtype">int</span> nb_faces = zone_VEF.<a class="code" href="classZone__VF.html#a50fd21c9535680489015a3c8b88c685a" title="renvoie le nombre total de faces. C&#39;est-a-dire faces reelles + faces virtuelles">nb_faces_tot</a>();
<a name="l02668"></a>02668   <span class="keywordtype">int</span> nb_elem = zone.<a class="code" href="classZone.html#aa3a33e8b723618b9092460007153e42d" title="Renvoie le nombre total d&#39;elements de la zone.">nb_elem_tot</a>();
<a name="l02669"></a>02669   <span class="keywordtype">int</span> elem1, elem2, face, ok;
<a name="l02670"></a>02670   <span class="keywordtype">int</span> nnz=0;
<a name="l02671"></a>02671   <a class="code" href="classIntLists.html" title="Un tableau de listes de type IntList.">IntLists</a> voisins(nb_elem);
<a name="l02672"></a>02672   <a class="code" href="classDoubleLists.html" title="Un tableau de listes de type DoubleList.">DoubleLists</a> coeffs(nb_elem);
<a name="l02673"></a>02673   <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> sommets(dimension+2);
<a name="l02674"></a>02674   <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> face_opp1(dimension+2);
<a name="l02675"></a>02675   <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> face_opp2(dimension+2);
<a name="l02676"></a>02676 <span class="comment">// Faces de bord :</span>
<a name="l02677"></a>02677   <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;les_cl.<a class="code" href="classvect__impl.html#a78155bfbd6b61f4710b9830641ed1694">size</a>(); i++)
<a name="l02678"></a>02678     {
<a name="l02679"></a>02679       <span class="keyword">const</span> <a class="code" href="classCond__lim.html" title="classe Cond_lim Classe generique servant a representer n&#39;importe quelle classe derivee de la classe C...">Cond_lim</a>&amp; la_cl = les_cl[i];
<a name="l02680"></a>02680       <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp; le_bord = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>,la_cl.<a class="code" href="classCond__lim.html#a5b2d24809cee07727006a891d4ce8d22" title="Appel a l&#39;objet sous-jacent Renvoie la frontiere discretisee associee a la condition aux limites...">frontiere_dis</a>());
<a name="l02681"></a>02681       <span class="keywordtype">int</span> nb_faces_bord_tot = le_bord.<a class="code" href="classFront__VF.html#aed4006d91bf2ef3af2b9f7933d863a09" title="Nombre de faces reelles et virtuelles du bord.">nb_faces_tot</a>();
<a name="l02682"></a>02682       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> ind_face=0; ind_face&lt;nb_faces_bord_tot; ind_face++)
<a name="l02683"></a>02683         {
<a name="l02684"></a>02684           ok=<a class="code" href="AssembleurPP1BUtil_8cpp.html#a40cf40213663174bb24649e51832bf3e">okface</a>(ind_face, face, la_cl);
<a name="l02685"></a>02685           <span class="keywordflow">if</span> (ok==-1) <span class="keywordflow">break</span>;
<a name="l02686"></a>02686           elem1=face_voisins(face, 0);
<a name="l02687"></a>02687           elem2=face_voisins(face, 1);
<a name="l02688"></a>02688           <a class="code" href="AssembleurPP1BUtil_8cpp.html#afd0a249a235b161c5267e7574e199a82">remplir_sommets</a>(zone_VEF, face, elem1, elem2, sommets,
<a name="l02689"></a>02689                           face_opp1, face_opp2);
<a name="l02690"></a>02690           <span class="keywordflow">if</span>(ok==3)
<a name="l02691"></a>02691             {
<a name="l02692"></a>02692               <a class="code" href="AssembleurPP1BUtil_8cpp.html#ae709048ec2f850b47b8601c013ed8550">contribuer_matrice_NeumannP0Pa</a>(zone_VEF,
<a name="l02693"></a>02693                                              inverse_quantitee_entrelacee,
<a name="l02694"></a>02694                                              face, elem1, sommets,
<a name="l02695"></a>02695                                              face_opp1,
<a name="l02696"></a>02696                                              voisins, coeffs, nnz);
<a name="l02697"></a>02697             }
<a name="l02698"></a>02698           <span class="keywordflow">else</span> <span class="keywordflow">if</span>(ok==4)
<a name="l02699"></a>02699             {
<a name="l02700"></a>02700               ; <span class="comment">//!&lt; RIEN</span>
<a name="l02701"></a>02701 <span class="comment"></span>            }
<a name="l02702"></a>02702           <span class="keywordflow">else</span>
<a name="l02703"></a>02703             <a class="code" href="AssembleurPP1BUtil_8cpp.html#a36c4cdf9e6baa421844cf7cffa1396df">contribuer_matriceP0Pa</a>(zone_VEF, inverse_quantitee_entrelacee, face, elem1, elem2, sommets,
<a name="l02704"></a>02704                                    face_opp1, face_opp2,
<a name="l02705"></a>02705                                    voisins, coeffs, nnz);
<a name="l02706"></a>02706         }
<a name="l02707"></a>02707     }
<a name="l02708"></a>02708   <a class="code" href="AssembleurPP1BUtil_8cpp.html#a3e374d53ebc7860e1c2f0b7906f2936d">face_associee</a>=-1;
<a name="l02709"></a>02709   <span class="keywordflow">for</span>(face=nint; face&lt;nb_faces; face++)
<a name="l02710"></a>02710     {
<a name="l02711"></a>02711       elem1=face_voisins(face, 0);
<a name="l02712"></a>02712       elem2=face_voisins(face, 1);
<a name="l02713"></a>02713       <span class="keywordflow">if</span> (!zone_VEF.<a class="code" href="classZone__VF.html#a33909d3880435e82e84639b51482d2c6" title="renvoie 1 si face est une face virtuelle de bord, 0 sinon">est_une_face_virt_bord</a>(face)) <span class="comment">//!&lt; On ne traite que les faces internes</span>
<a name="l02714"></a>02714 <span class="comment"></span>        {
<a name="l02715"></a>02715           <a class="code" href="AssembleurPP1BUtil_8cpp.html#afd0a249a235b161c5267e7574e199a82">remplir_sommets</a>(zone_VEF, face, elem1, elem2, sommets,
<a name="l02716"></a>02716                           face_opp1, face_opp2);
<a name="l02717"></a>02717           <a class="code" href="AssembleurPP1BUtil_8cpp.html#a36c4cdf9e6baa421844cf7cffa1396df">contribuer_matriceP0Pa</a>(zone_VEF,
<a name="l02718"></a>02718                                  inverse_quantitee_entrelacee,
<a name="l02719"></a>02719                                  face, elem1, elem2, sommets,
<a name="l02720"></a>02720                                  face_opp1, face_opp2,
<a name="l02721"></a>02721                                  voisins, coeffs, nnz);
<a name="l02722"></a>02722         }
<a name="l02723"></a>02723     }
<a name="l02724"></a>02724   matrice.<a class="code" href="classDeriv__.html#ad1d33400ed15b6ff96579ed82d9e2719" title="Essaie de creer une instance du type &quot;type&quot;. si type n&#39;est pas un type ou type n&#39;est pas instanciab...">typer</a>(<span class="stringliteral">&quot;Matrice_Bloc&quot;</span>);
<a name="l02725"></a>02725   <a class="code" href="classMatrice__Bloc.html">Matrice_Bloc</a>&amp; matrice_bloc=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Bloc.html">Matrice_Bloc</a>, matrice.<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>());
<a name="l02726"></a>02726   matrice_bloc.<a class="code" href="classMatrice__Bloc.html#a7d624ebd3f141e34502e59f6d1b1d601">remplir</a>(voisins, coeffs, zone.<a class="code" href="classZone.html#a7f249429803b27139a1c54436f6164a5" title="Renvoie le nombre d&#39;elements de la zone.">nb_elem</a>(), zone.<a class="code" href="classZone.html#aa3a33e8b723618b9092460007153e42d" title="Renvoie le nombre total d&#39;elements de la zone.">nb_elem_tot</a>(), zone.<a class="code" href="classZone.html#a3e3b48691911fd85574c7bc10a1a4fb8" title="renvoie le nombre d&#39;aretes reelles.">nb_aretes</a>(), zone.<a class="code" href="classZone.html#a59ae0ababf85ce303a7c6f339430e335" title="renvoie le nombre d&#39;aretes total (reelles+virtuelles).">nb_aretes_tot</a>());
<a name="l02727"></a>02727   <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Assemblage P0Pa OK&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
<a name="l02728"></a>02728 }
<a name="l02729"></a>02729 
<a name="l02730"></a><a class="code" href="AssembleurPP1BUtil_8cpp.html#aacede92ea2595a5546e6357fbd1e1498">02730</a> <span class="keywordtype">void</span> <a class="code" href="Assembleur__P__VEFPreP1B_8cpp.html#aacede92ea2595a5546e6357fbd1e1498">updateP0Pa</a>(<span class="keyword">const</span> <a class="code" href="classZone__dis__base.html" title="classe Zone_dis_base Cette classe est la base de la hierarchie des zones discretisees. Un objet Zone est associe a la zone discretise. A chaque methode numerique de Trio U correspond une classe derivant de Zone_dis_base implementant les outils necessaires a la methode.">Zone_dis_base</a>&amp; z,
<a name="l02731"></a>02731                 <span class="keyword">const</span> <a class="code" href="classZone__Cl__dis__base.html" title="classe Zone_Cl_dis_base Les objets Zone_Cl_dis_base representent les conditions aux limites discretis...">Zone_Cl_dis_base</a>&amp; zcl,
<a name="l02732"></a>02732                 <a class="code" href="classMatrice.html">Matrice</a>&amp; matrice,
<a name="l02733"></a>02733                 <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; inverse_quantitee_entrelacee)
<a name="l02734"></a>02734 {
<a name="l02735"></a>02735   <span class="keywordtype">int</span> dimension=<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>;
<a name="l02736"></a>02736   <span class="keyword">const</span> <a class="code" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a>&amp; zone_VEF=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a>, z);
<a name="l02737"></a>02737   <span class="keyword">const</span> <a class="code" href="classZone__Cl__VEF.html">Zone_Cl_VEF</a>&amp; zone_Cl_VEF=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classZone__Cl__VEF.html">Zone_Cl_VEF</a>, zcl);
<a name="l02738"></a>02738   <span class="keyword">const</span> <a class="code" href="classConds__lim.html">Conds_lim</a>&amp; les_cl = zone_Cl_VEF.<a class="code" href="classZone__Cl__dis__base.html#af75e0ed7786863e4d333bfb29d67c323" title="Renvoie la i-ieme condition aux limites. (version const)">les_conditions_limites</a>();
<a name="l02739"></a>02739   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; face_voisins = zone_VEF.<a class="code" href="classZone__VF.html#a49d4322f5585a8fa95748ca785b70702" title="renvoie l&#39;element voisin de numface dans la direction i. i=0 : dans le sens oppose de l&#39;axe orthogona...">face_voisins</a>();
<a name="l02740"></a>02740   <span class="keywordtype">int</span> nint = zone_VEF.<a class="code" href="classZone__VF.html#a12869806fa4834aca8f2964e16509dfd" title="une face est interne ssi elle separe deux elements. renvoie le numero de la premiere face interne...">premiere_face_int</a>();
<a name="l02741"></a>02741   <span class="keywordtype">int</span> nb_faces = zone_VEF.<a class="code" href="classZone__VF.html#a50fd21c9535680489015a3c8b88c685a" title="renvoie le nombre total de faces. C&#39;est-a-dire faces reelles + faces virtuelles">nb_faces_tot</a>();
<a name="l02742"></a>02742   <span class="keywordtype">int</span> elem1, elem2, face, ok;
<a name="l02743"></a>02743   <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> sommets(dimension+2);
<a name="l02744"></a>02744   <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> face_opp1(dimension+2);
<a name="l02745"></a>02745   <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> face_opp2(dimension+2);
<a name="l02746"></a>02746   <a class="code" href="classMatrice__Bloc.html">Matrice_Bloc</a>&amp; A=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Bloc.html">Matrice_Bloc</a>, matrice.<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>());
<a name="l02747"></a>02747   <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; ARR=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>, A.<a class="code" href="classMatrice__Bloc.html#a7ffa38f7b93454432b2df7c616ed0a4e">get_bloc</a>(0,0).<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>());
<a name="l02748"></a>02748   <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; ARV=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>, A.<a class="code" href="classMatrice__Bloc.html#a7ffa38f7b93454432b2df7c616ed0a4e">get_bloc</a>(0,1).<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>());
<a name="l02749"></a>02749   <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; AVR=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>, A.<a class="code" href="classMatrice__Bloc.html#a7ffa38f7b93454432b2df7c616ed0a4e">get_bloc</a>(1,0).<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>());
<a name="l02750"></a>02750   <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; AVV=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>, A.<a class="code" href="classMatrice__Bloc.html#a7ffa38f7b93454432b2df7c616ed0a4e">get_bloc</a>(1,1).<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>());
<a name="l02751"></a>02751 <span class="comment">// Faces de bord :</span>
<a name="l02752"></a>02752   <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;les_cl.<a class="code" href="classvect__impl.html#a78155bfbd6b61f4710b9830641ed1694">size</a>(); i++)
<a name="l02753"></a>02753     {
<a name="l02754"></a>02754       <span class="keyword">const</span> <a class="code" href="classCond__lim.html" title="classe Cond_lim Classe generique servant a representer n&#39;importe quelle classe derivee de la classe C...">Cond_lim</a>&amp; la_cl = les_cl[i];
<a name="l02755"></a>02755       <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp; le_bord = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>,la_cl.<a class="code" href="classCond__lim.html#a5b2d24809cee07727006a891d4ce8d22" title="Appel a l&#39;objet sous-jacent Renvoie la frontiere discretisee associee a la condition aux limites...">frontiere_dis</a>());
<a name="l02756"></a>02756       <span class="keywordtype">int</span> nb_faces_bord_tot = le_bord.<a class="code" href="classFront__VF.html#aed4006d91bf2ef3af2b9f7933d863a09" title="Nombre de faces reelles et virtuelles du bord.">nb_faces_tot</a>();
<a name="l02757"></a>02757       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> ind_face=0; ind_face&lt;nb_faces_bord_tot; ind_face++)
<a name="l02758"></a>02758         {
<a name="l02759"></a>02759           ok=<a class="code" href="AssembleurPP1BUtil_8cpp.html#a40cf40213663174bb24649e51832bf3e">okface</a>(ind_face, face, la_cl);
<a name="l02760"></a>02760           <span class="keywordflow">if</span> (ok==-1) <span class="keywordflow">break</span>;
<a name="l02761"></a>02761           elem1=face_voisins(face, 0);
<a name="l02762"></a>02762           elem2=face_voisins(face, 1);
<a name="l02763"></a>02763           <a class="code" href="AssembleurPP1BUtil_8cpp.html#afd0a249a235b161c5267e7574e199a82">remplir_sommets</a>(zone_VEF, face, elem1, elem2, sommets,
<a name="l02764"></a>02764                           face_opp1, face_opp2);
<a name="l02765"></a>02765           <span class="keywordflow">if</span>(ok==3)
<a name="l02766"></a>02766             {
<a name="l02767"></a>02767               <a class="code" href="AssembleurPP1BUtil_8cpp.html#a45b45851ba59992d7eb7a25c002a9f73">update_matrice_NeumannP0Pa</a>(zone_VEF,
<a name="l02768"></a>02768                                          inverse_quantitee_entrelacee,
<a name="l02769"></a>02769                                          face, elem1, sommets,
<a name="l02770"></a>02770                                          face_opp1,
<a name="l02771"></a>02771                                          ARR,ARV,AVR,AVV);
<a name="l02772"></a>02772             }
<a name="l02773"></a>02773           <span class="keywordflow">else</span> <span class="keywordflow">if</span>(ok==4)
<a name="l02774"></a>02774             {
<a name="l02775"></a>02775               ; <span class="comment">//!&lt; RIEN</span>
<a name="l02776"></a>02776 <span class="comment"></span>            }
<a name="l02777"></a>02777           <span class="keywordflow">else</span>
<a name="l02778"></a>02778             <a class="code" href="AssembleurPP1BUtil_8cpp.html#a68f4b5d510b37d5518ed576764da2611">update_matriceP0Pa</a>(zone_VEF, inverse_quantitee_entrelacee,
<a name="l02779"></a>02779                                face, elem1, elem2, sommets,
<a name="l02780"></a>02780                                face_opp1, face_opp2,
<a name="l02781"></a>02781                                ARR,ARV,AVR,AVV);
<a name="l02782"></a>02782         }
<a name="l02783"></a>02783     }
<a name="l02784"></a>02784   <a class="code" href="AssembleurPP1BUtil_8cpp.html#a3e374d53ebc7860e1c2f0b7906f2936d">face_associee</a>=-1;
<a name="l02785"></a>02785   <span class="keywordflow">for</span>(face=nint; face&lt;nb_faces; face++)
<a name="l02786"></a>02786     {
<a name="l02787"></a>02787       elem1=face_voisins(face, 0);
<a name="l02788"></a>02788       elem2=face_voisins(face, 1);
<a name="l02789"></a>02789       <span class="keywordflow">if</span> (!zone_VEF.<a class="code" href="classZone__VF.html#a33909d3880435e82e84639b51482d2c6" title="renvoie 1 si face est une face virtuelle de bord, 0 sinon">est_une_face_virt_bord</a>(face)) <span class="comment">//!&lt; On ne traite que les faces internes</span>
<a name="l02790"></a>02790 <span class="comment"></span>        {
<a name="l02791"></a>02791           <a class="code" href="AssembleurPP1BUtil_8cpp.html#afd0a249a235b161c5267e7574e199a82">remplir_sommets</a>(zone_VEF, face, elem1, elem2, sommets,
<a name="l02792"></a>02792                           face_opp1, face_opp2);
<a name="l02793"></a>02793           <a class="code" href="AssembleurPP1BUtil_8cpp.html#a68f4b5d510b37d5518ed576764da2611">update_matriceP0Pa</a>(zone_VEF,
<a name="l02794"></a>02794                              inverse_quantitee_entrelacee,
<a name="l02795"></a>02795                              face, elem1, elem2, sommets,
<a name="l02796"></a>02796                              face_opp1, face_opp2,
<a name="l02797"></a>02797                              ARR,ARV,AVR,AVV);
<a name="l02798"></a>02798         }
<a name="l02799"></a>02799     }
<a name="l02800"></a>02800   <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Update P0Pa OK&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
<a name="l02801"></a>02801 }
<a name="l02802"></a>02802 
<a name="l02803"></a><a class="code" href="AssembleurPP1BUtil_8cpp.html#a5dcfee4400f896bcbb100259f53a5de1">02803</a> <span class="keywordtype">void</span> <a class="code" href="Assembleur__P__VEFPreP1B_8cpp.html#a5dcfee4400f896bcbb100259f53a5de1">assemblerP1Pa</a>(<span class="keyword">const</span> <a class="code" href="classZone__dis__base.html" title="classe Zone_dis_base Cette classe est la base de la hierarchie des zones discretisees. Un objet Zone est associe a la zone discretise. A chaque methode numerique de Trio U correspond une classe derivant de Zone_dis_base implementant les outils necessaires a la methode.">Zone_dis_base</a>&amp; z,
<a name="l02804"></a>02804                    <span class="keyword">const</span> <a class="code" href="classZone__Cl__dis__base.html" title="classe Zone_Cl_dis_base Les objets Zone_Cl_dis_base representent les conditions aux limites discretis...">Zone_Cl_dis_base</a>&amp; zcl,
<a name="l02805"></a>02805                    <a class="code" href="classMatrice.html">Matrice</a>&amp; matrice,
<a name="l02806"></a>02806                    <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; inverse_quantitee_entrelacee, <span class="keyword">const</span> <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a>&amp; coef_som)
<a name="l02807"></a>02807 {
<a name="l02808"></a>02808   <span class="keywordtype">int</span> dimension=<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>;
<a name="l02809"></a>02809   <span class="keyword">const</span> <a class="code" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a>&amp; zone_VEF=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a>, z);
<a name="l02810"></a>02810   <span class="keyword">const</span> <a class="code" href="classZone.html" title="classe Zone Une Zone est un maillage compose d&#39;un ensemble d&#39;elements geometriques de meme type...">Zone</a>&amp; zone=zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>();
<a name="l02811"></a>02811   <span class="keyword">const</span> <a class="code" href="classZone__Cl__VEF.html">Zone_Cl_VEF</a>&amp; zone_Cl_VEF=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classZone__Cl__VEF.html">Zone_Cl_VEF</a>, zcl);
<a name="l02812"></a>02812   <span class="keyword">const</span> <a class="code" href="classConds__lim.html">Conds_lim</a>&amp; les_cl = zone_Cl_VEF.<a class="code" href="classZone__Cl__dis__base.html#af75e0ed7786863e4d333bfb29d67c323" title="Renvoie la i-ieme condition aux limites. (version const)">les_conditions_limites</a>();
<a name="l02813"></a>02813   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; face_voisins = zone_VEF.<a class="code" href="classZone__VF.html#a49d4322f5585a8fa95748ca785b70702" title="renvoie l&#39;element voisin de numface dans la direction i. i=0 : dans le sens oppose de l&#39;axe orthogona...">face_voisins</a>();
<a name="l02814"></a>02814   <span class="keywordtype">int</span> nint = zone_VEF.<a class="code" href="classZone__VF.html#a12869806fa4834aca8f2964e16509dfd" title="une face est interne ssi elle separe deux elements. renvoie le numero de la premiere face interne...">premiere_face_int</a>();
<a name="l02815"></a>02815   <span class="keywordtype">int</span> nb_faces = zone_VEF.<a class="code" href="classZone__VF.html#a50fd21c9535680489015a3c8b88c685a" title="renvoie le nombre total de faces. C&#39;est-a-dire faces reelles + faces virtuelles">nb_faces_tot</a>();
<a name="l02816"></a>02816   <span class="keywordtype">int</span> elem1, elem2, face, ok;
<a name="l02817"></a>02817   <span class="keywordtype">int</span> nnz=0;
<a name="l02818"></a>02818   <span class="keywordtype">int</span> nb_som = zone.<a class="code" href="classZone.html#a01ed67af826d6045ef4eacfb87a663e8" title="Renvoie le nombre total de sommets de la zone. i.e. le nombre de sommets reels et virtuels sur le pro...">nb_som_tot</a>();
<a name="l02819"></a>02819   <a class="code" href="classIntLists.html" title="Un tableau de listes de type IntList.">IntLists</a> voisins(nb_som);
<a name="l02820"></a>02820   <a class="code" href="classDoubleLists.html" title="Un tableau de listes de type DoubleList.">DoubleLists</a> coeffs(nb_som);
<a name="l02821"></a>02821   <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> sommets(dimension+2);
<a name="l02822"></a>02822   <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> face_opp1(dimension+2);
<a name="l02823"></a>02823   <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> face_opp2(dimension+2);
<a name="l02824"></a>02824 <span class="comment">// Faces de bord :</span>
<a name="l02825"></a>02825   <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;les_cl.<a class="code" href="classvect__impl.html#a78155bfbd6b61f4710b9830641ed1694">size</a>(); i++)
<a name="l02826"></a>02826     {
<a name="l02827"></a>02827       <span class="keyword">const</span> <a class="code" href="classCond__lim.html" title="classe Cond_lim Classe generique servant a representer n&#39;importe quelle classe derivee de la classe C...">Cond_lim</a>&amp; la_cl = les_cl[i];
<a name="l02828"></a>02828       <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp; le_bord = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>,la_cl.<a class="code" href="classCond__lim.html#a5b2d24809cee07727006a891d4ce8d22" title="Appel a l&#39;objet sous-jacent Renvoie la frontiere discretisee associee a la condition aux limites...">frontiere_dis</a>());
<a name="l02829"></a>02829       <span class="keywordtype">int</span> nb_faces_bord_tot = le_bord.<a class="code" href="classFront__VF.html#aed4006d91bf2ef3af2b9f7933d863a09" title="Nombre de faces reelles et virtuelles du bord.">nb_faces_tot</a>();
<a name="l02830"></a>02830       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> ind_face=0; ind_face&lt;nb_faces_bord_tot; ind_face++)
<a name="l02831"></a>02831         {
<a name="l02832"></a>02832           ok=<a class="code" href="AssembleurPP1BUtil_8cpp.html#a40cf40213663174bb24649e51832bf3e">okface</a>(ind_face, face, la_cl);
<a name="l02833"></a>02833           <span class="keywordflow">if</span> (ok==-1) <span class="keywordflow">break</span>;
<a name="l02834"></a>02834           elem1=face_voisins(face, 0);
<a name="l02835"></a>02835           elem2=face_voisins(face, 1);
<a name="l02836"></a>02836           <a class="code" href="AssembleurPP1BUtil_8cpp.html#afd0a249a235b161c5267e7574e199a82">remplir_sommets</a>(zone_VEF, face, elem1, elem2, sommets,
<a name="l02837"></a>02837                           face_opp1, face_opp2);
<a name="l02838"></a>02838           <span class="keywordflow">if</span>(ok==3)
<a name="l02839"></a>02839             {
<a name="l02840"></a>02840               <a class="code" href="AssembleurPP1BUtil_8cpp.html#a1ee529d67fc174bfe005efe590812122">contribuer_matrice_NeumannP1Pa</a>(zone_VEF,
<a name="l02841"></a>02841                                              inverse_quantitee_entrelacee,
<a name="l02842"></a>02842                                              face, elem1, sommets,
<a name="l02843"></a>02843                                              face_opp1,coef_som,
<a name="l02844"></a>02844                                              voisins, coeffs, nnz);
<a name="l02845"></a>02845             }
<a name="l02846"></a>02846           <span class="keywordflow">else</span> <span class="keywordflow">if</span>(ok==4)
<a name="l02847"></a>02847             {
<a name="l02848"></a>02848               <a class="code" href="AssembleurPP1BUtil_8cpp.html#ae3056a39c9c01f3a2727f0dbf4b5e331">contribuer_matrice_SymetrieP1Pa</a>(zone_VEF,
<a name="l02849"></a>02849                                               inverse_quantitee_entrelacee,
<a name="l02850"></a>02850                                               face, elem1, sommets,
<a name="l02851"></a>02851                                               face_opp1, coef_som,
<a name="l02852"></a>02852                                               voisins, coeffs, nnz);
<a name="l02853"></a>02853             }
<a name="l02854"></a>02854           <span class="keywordflow">else</span>
<a name="l02855"></a>02855             <a class="code" href="AssembleurPP1BUtil_8cpp.html#a0000fbbb1165039c7071352be4a35877">contribuer_matriceP1Pa</a>(zone_VEF,
<a name="l02856"></a>02856                                    inverse_quantitee_entrelacee,
<a name="l02857"></a>02857                                    face, elem1, elem2, sommets,
<a name="l02858"></a>02858                                    face_opp1, face_opp2, coef_som,
<a name="l02859"></a>02859                                    voisins, coeffs, nnz);
<a name="l02860"></a>02860         }
<a name="l02861"></a>02861     }
<a name="l02862"></a>02862   <a class="code" href="AssembleurPP1BUtil_8cpp.html#a3e374d53ebc7860e1c2f0b7906f2936d">face_associee</a>=-1;
<a name="l02863"></a>02863   <span class="keywordflow">for</span>(face=nint; face&lt;nb_faces; face++)
<a name="l02864"></a>02864     {
<a name="l02865"></a>02865       elem1=face_voisins(face, 0);
<a name="l02866"></a>02866       elem2=face_voisins(face, 1);
<a name="l02867"></a>02867       <span class="keywordflow">if</span> (!zone_VEF.<a class="code" href="classZone__VF.html#a33909d3880435e82e84639b51482d2c6" title="renvoie 1 si face est une face virtuelle de bord, 0 sinon">est_une_face_virt_bord</a>(face)) <span class="comment">//!&lt; On ne traite que les faces internes</span>
<a name="l02868"></a>02868 <span class="comment"></span>        {
<a name="l02869"></a>02869           <a class="code" href="AssembleurPP1BUtil_8cpp.html#afd0a249a235b161c5267e7574e199a82">remplir_sommets</a>(zone_VEF, face, elem1, elem2, sommets,
<a name="l02870"></a>02870                           face_opp1, face_opp2);
<a name="l02871"></a>02871           <a class="code" href="AssembleurPP1BUtil_8cpp.html#a0000fbbb1165039c7071352be4a35877">contribuer_matriceP1Pa</a>(zone_VEF,
<a name="l02872"></a>02872                                  inverse_quantitee_entrelacee,
<a name="l02873"></a>02873                                  face, elem1, elem2, sommets,
<a name="l02874"></a>02874                                  face_opp1, face_opp2, coef_som,
<a name="l02875"></a>02875                                  voisins, coeffs, nnz);
<a name="l02876"></a>02876         }
<a name="l02877"></a>02877     }
<a name="l02878"></a>02878 
<a name="l02879"></a>02879   matrice.<a class="code" href="classDeriv__.html#ad1d33400ed15b6ff96579ed82d9e2719" title="Essaie de creer une instance du type &quot;type&quot;. si type n&#39;est pas un type ou type n&#39;est pas instanciab...">typer</a>(<span class="stringliteral">&quot;Matrice_Bloc&quot;</span>);
<a name="l02880"></a>02880   <a class="code" href="classMatrice__Bloc.html">Matrice_Bloc</a>&amp; matrice_bloc=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Bloc.html">Matrice_Bloc</a>, matrice.<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>());
<a name="l02881"></a>02881   matrice_bloc.<a class="code" href="classMatrice__Bloc.html#a7d624ebd3f141e34502e59f6d1b1d601">remplir</a>(voisins, coeffs, zone.<a class="code" href="classZone.html#ad340f571f81fa5c2e028b88c00b5c2ca" title="Renvoie le nombre de sommets de la zone.">nb_som</a>(), zone.<a class="code" href="classZone.html#a01ed67af826d6045ef4eacfb87a663e8" title="Renvoie le nombre total de sommets de la zone. i.e. le nombre de sommets reels et virtuels sur le pro...">nb_som_tot</a>(), zone.<a class="code" href="classZone.html#a3e3b48691911fd85574c7bc10a1a4fb8" title="renvoie le nombre d&#39;aretes reelles.">nb_aretes</a>(), zone.<a class="code" href="classZone.html#a59ae0ababf85ce303a7c6f339430e335" title="renvoie le nombre d&#39;aretes total (reelles+virtuelles).">nb_aretes_tot</a>());
<a name="l02882"></a>02882   <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Assemblage P1Pa OK&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
<a name="l02883"></a>02883 }
<a name="l02884"></a>02884 
<a name="l02885"></a><a class="code" href="AssembleurPP1BUtil_8cpp.html#a8d9349eb29399f4ac72dc10543a4005a">02885</a> <span class="keywordtype">void</span> <a class="code" href="Assembleur__P__VEFPreP1B_8cpp.html#a8d9349eb29399f4ac72dc10543a4005a">updateP1Pa</a>(<span class="keyword">const</span> <a class="code" href="classZone__dis__base.html" title="classe Zone_dis_base Cette classe est la base de la hierarchie des zones discretisees. Un objet Zone est associe a la zone discretise. A chaque methode numerique de Trio U correspond une classe derivant de Zone_dis_base implementant les outils necessaires a la methode.">Zone_dis_base</a>&amp; z,
<a name="l02886"></a>02886                 <span class="keyword">const</span> <a class="code" href="classZone__Cl__dis__base.html" title="classe Zone_Cl_dis_base Les objets Zone_Cl_dis_base representent les conditions aux limites discretis...">Zone_Cl_dis_base</a>&amp; zcl,
<a name="l02887"></a>02887                 <a class="code" href="classMatrice.html">Matrice</a>&amp; matrice,
<a name="l02888"></a>02888                 <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; inverse_quantitee_entrelacee, <span class="keyword">const</span> <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a>&amp; coef_som)
<a name="l02889"></a>02889 {
<a name="l02890"></a>02890   <span class="keywordtype">int</span> dimension=<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>;
<a name="l02891"></a>02891   <span class="keyword">const</span> <a class="code" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a>&amp; zone_VEF=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a>, z);
<a name="l02892"></a>02892   <span class="keyword">const</span> <a class="code" href="classZone.html" title="classe Zone Une Zone est un maillage compose d&#39;un ensemble d&#39;elements geometriques de meme type...">Zone</a>&amp; zone=zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>();
<a name="l02893"></a>02893   <span class="keyword">const</span> <a class="code" href="classZone__Cl__VEF.html">Zone_Cl_VEF</a>&amp; zone_Cl_VEF=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classZone__Cl__VEF.html">Zone_Cl_VEF</a>, zcl);
<a name="l02894"></a>02894   <span class="keyword">const</span> <a class="code" href="classConds__lim.html">Conds_lim</a>&amp; les_cl = zone_Cl_VEF.<a class="code" href="classZone__Cl__dis__base.html#af75e0ed7786863e4d333bfb29d67c323" title="Renvoie la i-ieme condition aux limites. (version const)">les_conditions_limites</a>();
<a name="l02895"></a>02895   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; face_voisins = zone_VEF.<a class="code" href="classZone__VF.html#a49d4322f5585a8fa95748ca785b70702" title="renvoie l&#39;element voisin de numface dans la direction i. i=0 : dans le sens oppose de l&#39;axe orthogona...">face_voisins</a>();
<a name="l02896"></a>02896   <span class="keywordtype">int</span> nint = zone_VEF.<a class="code" href="classZone__VF.html#a12869806fa4834aca8f2964e16509dfd" title="une face est interne ssi elle separe deux elements. renvoie le numero de la premiere face interne...">premiere_face_int</a>();
<a name="l02897"></a>02897   <span class="keywordtype">int</span> nb_faces = zone_VEF.<a class="code" href="classZone__VF.html#a50fd21c9535680489015a3c8b88c685a" title="renvoie le nombre total de faces. C&#39;est-a-dire faces reelles + faces virtuelles">nb_faces_tot</a>();
<a name="l02898"></a>02898   <span class="keywordtype">int</span> elem1, elem2, face, ok;
<a name="l02899"></a>02899   <span class="keywordtype">int</span> nb_som = zone.<a class="code" href="classZone.html#a01ed67af826d6045ef4eacfb87a663e8" title="Renvoie le nombre total de sommets de la zone. i.e. le nombre de sommets reels et virtuels sur le pro...">nb_som_tot</a>();
<a name="l02900"></a>02900   <a class="code" href="classIntLists.html" title="Un tableau de listes de type IntList.">IntLists</a> voisins(nb_som);
<a name="l02901"></a>02901   <a class="code" href="classDoubleLists.html" title="Un tableau de listes de type DoubleList.">DoubleLists</a> coeffs(nb_som);
<a name="l02902"></a>02902   <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> sommets(dimension+2);
<a name="l02903"></a>02903   <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> face_opp1(dimension+2);
<a name="l02904"></a>02904   <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> face_opp2(dimension+2);
<a name="l02905"></a>02905   <a class="code" href="classMatrice__Bloc.html">Matrice_Bloc</a>&amp; A=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Bloc.html">Matrice_Bloc</a>, matrice.<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>());
<a name="l02906"></a>02906   <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; ARR=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>, A.<a class="code" href="classMatrice__Bloc.html#a7ffa38f7b93454432b2df7c616ed0a4e">get_bloc</a>(0,0).<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>());
<a name="l02907"></a>02907   <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; ARV=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>, A.<a class="code" href="classMatrice__Bloc.html#a7ffa38f7b93454432b2df7c616ed0a4e">get_bloc</a>(0,1).<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>());
<a name="l02908"></a>02908   <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; AVR=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>, A.<a class="code" href="classMatrice__Bloc.html#a7ffa38f7b93454432b2df7c616ed0a4e">get_bloc</a>(1,0).<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>());
<a name="l02909"></a>02909   <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; AVV=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>, A.<a class="code" href="classMatrice__Bloc.html#a7ffa38f7b93454432b2df7c616ed0a4e">get_bloc</a>(1,1).<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>());
<a name="l02910"></a>02910 <span class="comment">// Faces de bord :</span>
<a name="l02911"></a>02911   <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;les_cl.<a class="code" href="classvect__impl.html#a78155bfbd6b61f4710b9830641ed1694">size</a>(); i++)
<a name="l02912"></a>02912     {
<a name="l02913"></a>02913       <span class="keyword">const</span> <a class="code" href="classCond__lim.html" title="classe Cond_lim Classe generique servant a representer n&#39;importe quelle classe derivee de la classe C...">Cond_lim</a>&amp; la_cl = les_cl[i];
<a name="l02914"></a>02914       <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp; le_bord = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>,la_cl.<a class="code" href="classCond__lim.html#a5b2d24809cee07727006a891d4ce8d22" title="Appel a l&#39;objet sous-jacent Renvoie la frontiere discretisee associee a la condition aux limites...">frontiere_dis</a>());
<a name="l02915"></a>02915       <span class="keywordtype">int</span> nb_faces_bord_tot = le_bord.<a class="code" href="classFront__VF.html#aed4006d91bf2ef3af2b9f7933d863a09" title="Nombre de faces reelles et virtuelles du bord.">nb_faces_tot</a>();
<a name="l02916"></a>02916       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> ind_face=0; ind_face&lt;nb_faces_bord_tot; ind_face++)
<a name="l02917"></a>02917         {
<a name="l02918"></a>02918           ok=<a class="code" href="AssembleurPP1BUtil_8cpp.html#a40cf40213663174bb24649e51832bf3e">okface</a>(ind_face, face, la_cl);
<a name="l02919"></a>02919           <span class="keywordflow">if</span> (ok==-1) <span class="keywordflow">break</span>;
<a name="l02920"></a>02920           elem1=face_voisins(face, 0);
<a name="l02921"></a>02921           elem2=face_voisins(face, 1);
<a name="l02922"></a>02922           <a class="code" href="AssembleurPP1BUtil_8cpp.html#afd0a249a235b161c5267e7574e199a82">remplir_sommets</a>(zone_VEF, face, elem1, elem2, sommets,
<a name="l02923"></a>02923                           face_opp1, face_opp2);
<a name="l02924"></a>02924           <span class="keywordflow">if</span>(ok==3)
<a name="l02925"></a>02925             {
<a name="l02926"></a>02926               <a class="code" href="AssembleurPP1BUtil_8cpp.html#a7da454ba757d1b7ed7ccc39954e6cab5">update_matrice_NeumannP1Pa</a>(zone_VEF,
<a name="l02927"></a>02927                                          inverse_quantitee_entrelacee,
<a name="l02928"></a>02928                                          face, elem1, sommets,
<a name="l02929"></a>02929                                          face_opp1, coef_som,
<a name="l02930"></a>02930                                          ARR,ARV,AVR,AVV);
<a name="l02931"></a>02931             }
<a name="l02932"></a>02932           <span class="keywordflow">else</span> <span class="keywordflow">if</span>(ok==4)
<a name="l02933"></a>02933             {
<a name="l02934"></a>02934               <a class="code" href="AssembleurPP1BUtil_8cpp.html#aa18f9eabe40c3c77172253c07802c05f">update_matrice_SymetrieP1Pa</a>(zone_VEF,
<a name="l02935"></a>02935                                           inverse_quantitee_entrelacee,
<a name="l02936"></a>02936                                           face, elem1, sommets,
<a name="l02937"></a>02937                                           face_opp1, coef_som,
<a name="l02938"></a>02938                                           ARR,ARV,AVR,AVV);
<a name="l02939"></a>02939             }
<a name="l02940"></a>02940           <span class="keywordflow">else</span>
<a name="l02941"></a>02941             <a class="code" href="AssembleurPP1BUtil_8cpp.html#ac499159b3caa7be06c8c9fddfdb5c8c1">update_matriceP1Pa</a>(zone_VEF,
<a name="l02942"></a>02942                                inverse_quantitee_entrelacee,
<a name="l02943"></a>02943                                face, elem1, elem2, sommets,
<a name="l02944"></a>02944                                face_opp1, face_opp2, coef_som,
<a name="l02945"></a>02945                                ARR,ARV,AVR,AVV);
<a name="l02946"></a>02946         }
<a name="l02947"></a>02947     }
<a name="l02948"></a>02948   <a class="code" href="AssembleurPP1BUtil_8cpp.html#a3e374d53ebc7860e1c2f0b7906f2936d">face_associee</a>=-1;
<a name="l02949"></a>02949   <span class="keywordflow">for</span>(face=nint; face&lt;nb_faces; face++)
<a name="l02950"></a>02950     {
<a name="l02951"></a>02951       elem1=face_voisins(face, 0);
<a name="l02952"></a>02952       elem2=face_voisins(face, 1);
<a name="l02953"></a>02953       <span class="keywordflow">if</span> (!zone_VEF.<a class="code" href="classZone__VF.html#a33909d3880435e82e84639b51482d2c6" title="renvoie 1 si face est une face virtuelle de bord, 0 sinon">est_une_face_virt_bord</a>(face)) <span class="comment">//!&lt; On ne traite que les faces internes</span>
<a name="l02954"></a>02954 <span class="comment"></span>        {
<a name="l02955"></a>02955           <a class="code" href="AssembleurPP1BUtil_8cpp.html#afd0a249a235b161c5267e7574e199a82">remplir_sommets</a>(zone_VEF, face, elem1, elem2, sommets,
<a name="l02956"></a>02956                           face_opp1, face_opp2);
<a name="l02957"></a>02957           <a class="code" href="AssembleurPP1BUtil_8cpp.html#ac499159b3caa7be06c8c9fddfdb5c8c1">update_matriceP1Pa</a>(zone_VEF,
<a name="l02958"></a>02958                              inverse_quantitee_entrelacee,
<a name="l02959"></a>02959                              face, elem1, elem2, sommets,
<a name="l02960"></a>02960                              face_opp1, face_opp2,coef_som,
<a name="l02961"></a>02961                              ARR,ARV,AVR,AVV);
<a name="l02962"></a>02962         }
<a name="l02963"></a>02963     }
<a name="l02964"></a>02964 
<a name="l02965"></a>02965   <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Update P1Pa OK&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
<a name="l02966"></a>02966 }
<a name="l02967"></a>02967 
<a name="l02968"></a><a class="code" href="AssembleurPP1BUtil_8cpp.html#a3774b1608aeee56152e7e1e5f385bfe1">02968</a> <span class="keywordtype">void</span> <a class="code" href="Assembleur__P__VEFPreP1B_8cpp.html#a3774b1608aeee56152e7e1e5f385bfe1">assemblerP0P1</a>(<span class="keyword">const</span> <a class="code" href="classZone__dis__base.html" title="classe Zone_dis_base Cette classe est la base de la hierarchie des zones discretisees. Un objet Zone est associe a la zone discretise. A chaque methode numerique de Trio U correspond une classe derivant de Zone_dis_base implementant les outils necessaires a la methode.">Zone_dis_base</a>&amp; z,
<a name="l02969"></a>02969                    <span class="keyword">const</span> <a class="code" href="classZone__Cl__dis__base.html" title="classe Zone_Cl_dis_base Les objets Zone_Cl_dis_base representent les conditions aux limites discretis...">Zone_Cl_dis_base</a>&amp; zcl,
<a name="l02970"></a>02970                    <a class="code" href="classMatrice.html">Matrice</a>&amp; matrice,
<a name="l02971"></a>02971                    <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; inverse_quantitee_entrelacee, <span class="keyword">const</span> <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a>&amp; coef_som)
<a name="l02972"></a>02972 {
<a name="l02973"></a>02973   <span class="keywordtype">int</span> dimension=<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>;
<a name="l02974"></a>02974   <span class="keyword">const</span> <a class="code" href="classZone__VEF.html" title="class Zone_VEF Classe instanciable qui derive de Zone_VF. Cette classe contient les informations geom...">Zone_VEF</a>&amp; zone_VEF=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a>, z);
<a name="l02975"></a>02975   <span class="keyword">const</span> <a class="code" href="classZone.html" title="classe Zone Une Zone est un maillage compose d&#39;un ensemble d&#39;elements geometriques de meme type...">Zone</a>&amp; zone=zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>();
<a name="l02976"></a>02976   <span class="keyword">const</span> <a class="code" href="classZone__Cl__VEF.html">Zone_Cl_VEF</a>&amp; zone_Cl_VEF=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classZone__Cl__VEF.html">Zone_Cl_VEF</a>, zcl);
<a name="l02977"></a>02977   <span class="keyword">const</span> <a class="code" href="classConds__lim.html">Conds_lim</a>&amp; les_cl = zone_Cl_VEF.<a class="code" href="classZone__Cl__dis__base.html#af75e0ed7786863e4d333bfb29d67c323" title="Renvoie la i-ieme condition aux limites. (version const)">les_conditions_limites</a>();
<a name="l02978"></a>02978   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; face_voisins = zone_VEF.<a class="code" href="classZone__VF.html#a49d4322f5585a8fa95748ca785b70702" title="renvoie l&#39;element voisin de numface dans la direction i. i=0 : dans le sens oppose de l&#39;axe orthogona...">face_voisins</a>();
<a name="l02979"></a>02979   <span class="keywordtype">int</span> nint = zone_VEF.<a class="code" href="classZone__VF.html#a12869806fa4834aca8f2964e16509dfd" title="une face est interne ssi elle separe deux elements. renvoie le numero de la premiere face interne...">premiere_face_int</a>();
<a name="l02980"></a>02980   <span class="keywordtype">int</span> nb_faces = zone_VEF.<a class="code" href="classZone__VF.html#a50fd21c9535680489015a3c8b88c685a" title="renvoie le nombre total de faces. C&#39;est-a-dire faces reelles + faces virtuelles">nb_faces_tot</a>();
<a name="l02981"></a>02981   <span class="keywordtype">int</span> nb_elem = zone.<a class="code" href="classZone.html#aa3a33e8b723618b9092460007153e42d" title="Renvoie le nombre total d&#39;elements de la zone.">nb_elem_tot</a>();
<a name="l02982"></a>02982   <span class="keywordtype">int</span> elem1, elem2, face, ok;
<a name="l02983"></a>02983   <span class="keywordtype">int</span> nnz=0;
<a name="l02984"></a>02984   <a class="code" href="classIntLists.html" title="Un tableau de listes de type IntList.">IntLists</a> voisins(nb_elem);
<a name="l02985"></a>02985   <a class="code" href="classDoubleLists.html" title="Un tableau de listes de type DoubleList.">DoubleLists</a> coeffs(nb_elem);
<a name="l02986"></a>02986   <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> sommets(dimension+2);
<a name="l02987"></a>02987   <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> face_opp1(dimension+2);
<a name="l02988"></a>02988   <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> face_opp2(dimension+2);
<a name="l02989"></a>02989 <span class="comment">// Faces de bord :</span>
<a name="l02990"></a>02990   <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;les_cl.<a class="code" href="classvect__impl.html#a78155bfbd6b61f4710b9830641ed1694">size</a>(); i++)
<a name="l02991"></a>02991     {
<a name="l02992"></a>02992       <span class="keyword">const</span> <a class="code" href="classCond__lim.html" title="classe Cond_lim Classe generique servant a representer n&#39;importe quelle classe derivee de la classe C...">Cond_lim</a>&amp; la_cl = les_cl[i];
<a name="l02993"></a>02993       <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp; le_bord = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>,la_cl.<a class="code" href="classCond__lim.html#a5b2d24809cee07727006a891d4ce8d22" title="Appel a l&#39;objet sous-jacent Renvoie la frontiere discretisee associee a la condition aux limites...">frontiere_dis</a>());
<a name="l02994"></a>02994       <span class="keywordtype">int</span> nb_faces_bord_tot = le_bord.<a class="code" href="classFront__VF.html#aed4006d91bf2ef3af2b9f7933d863a09" title="Nombre de faces reelles et virtuelles du bord.">nb_faces_tot</a>();
<a name="l02995"></a>02995       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> ind_face=0; ind_face&lt;nb_faces_bord_tot; ind_face++)
<a name="l02996"></a>02996         {
<a name="l02997"></a>02997           ok=<a class="code" href="AssembleurPP1BUtil_8cpp.html#a40cf40213663174bb24649e51832bf3e">okface</a>(ind_face, face, la_cl);
<a name="l02998"></a>02998           <span class="keywordflow">if</span> (ok==-1) <span class="keywordflow">break</span>;
<a name="l02999"></a>02999           elem1=face_voisins(face, 0);
<a name="l03000"></a>03000           elem2=face_voisins(face, 1);
<a name="l03001"></a>03001           <a class="code" href="AssembleurPP1BUtil_8cpp.html#afd0a249a235b161c5267e7574e199a82">remplir_sommets</a>(zone_VEF, face, elem1, elem2, sommets,
<a name="l03002"></a>03002                           face_opp1, face_opp2);
<a name="l03003"></a>03003           <a class="code" href="AssembleurPP1BUtil_8cpp.html#acff816d35f8d4ce978f860e0cd958b8a">sort</a>(sommets, face_opp1, face_opp2);
<a name="l03004"></a>03004           <span class="keywordflow">if</span>(ok==3)
<a name="l03005"></a>03005             {
<a name="l03006"></a>03006               <a class="code" href="AssembleurPP1BUtil_8cpp.html#a5e6fc2e2157dce70a345b3d8c1294477">contribuer_matrice_NeumannP0P1</a>(zone_VEF,
<a name="l03007"></a>03007                                              inverse_quantitee_entrelacee,
<a name="l03008"></a>03008                                              face, elem1, sommets,
<a name="l03009"></a>03009                                              face_opp1, coef_som,
<a name="l03010"></a>03010                                              voisins, coeffs, nnz);
<a name="l03011"></a>03011             }
<a name="l03012"></a>03012           <span class="keywordflow">else</span> <span class="keywordflow">if</span>(ok==4)
<a name="l03013"></a>03013             {
<a name="l03014"></a>03014               ;<span class="comment">//!&lt; RIEN</span>
<a name="l03015"></a>03015 <span class="comment"></span>            }
<a name="l03016"></a>03016           <span class="keywordflow">else</span>
<a name="l03017"></a>03017             <a class="code" href="AssembleurPP1BUtil_8cpp.html#ae2056e931f2d24d03da578b6af30cd54">contribuer_matriceP0P1</a>(zone_VEF,
<a name="l03018"></a>03018                                    inverse_quantitee_entrelacee,
<a name="l03019"></a>03019                                    face, elem1, elem2, sommets,
<a name="l03020"></a>03020                                    face_opp1, face_opp2, coef_som,
<a name="l03021"></a>03021                                    voisins, coeffs, nnz);
<a name="l03022"></a>03022         }
<a name="l03023"></a>03023     }
<a name="l03024"></a>03024   <a class="code" href="AssembleurPP1BUtil_8cpp.html#a3e374d53ebc7860e1c2f0b7906f2936d">face_associee</a>=-1;
<a name="l03025"></a>03025   <span class="keywordflow">for</span>(face=nint; face&lt;nb_faces; face++)
<a name="l03026"></a>03026     {
<a name="l03027"></a>03027       elem1=face_voisins(face, 0);
<a name="l03028"></a>03028       elem2=face_voisins(face, 1);
<a name="l03029"></a>03029       <span class="keywordflow">if</span> (!zone_VEF.<a class="code" href="classZone__VF.html#a33909d3880435e82e84639b51482d2c6" title="renvoie 1 si face est une face virtuelle de bord, 0 sinon">est_une_face_virt_bord</a>(face)) <span class="comment">//!&lt; On ne traite que les faces internes</span>
<a name="l03030"></a>03030 <span class="comment"></span>        {
<a name="l03031"></a>03031           <a class="code" href="AssembleurPP1BUtil_8cpp.html#afd0a249a235b161c5267e7574e199a82">remplir_sommets</a>(zone_VEF, face, elem1, elem2, sommets,
<a name="l03032"></a>03032                           face_opp1, face_opp2);
<a name="l03033"></a>03033           <a class="code" href="AssembleurPP1BUtil_8cpp.html#acff816d35f8d4ce978f860e0cd958b8a">sort</a>(sommets, face_opp1, face_opp2);
<a name="l03034"></a>03034           <a class="code" href="AssembleurPP1BUtil_8cpp.html#ae2056e931f2d24d03da578b6af30cd54">contribuer_matriceP0P1</a>(zone_VEF,
<a name="l03035"></a>03035                                  inverse_quantitee_entrelacee,
<a name="l03036"></a>03036                                  face, elem1, elem2, sommets,
<a name="l03037"></a>03037                                  face_opp1, face_opp2, coef_som,
<a name="l03038"></a>03038                                  voisins, coeffs, nnz);
<a name="l03039"></a>03039         }
<a name="l03040"></a>03040     }
<a name="l03041"></a>03041 
<a name="l03042"></a>03042   matrice.<a class="code" href="classDeriv__.html#ad1d33400ed15b6ff96579ed82d9e2719" title="Essaie de creer une instance du type &quot;type&quot;. si type n&#39;est pas un type ou type n&#39;est pas instanciab...">typer</a>(<span class="stringliteral">&quot;Matrice_Bloc&quot;</span>);
<a name="l03043"></a>03043   <a class="code" href="classMatrice__Bloc.html">Matrice_Bloc</a>&amp; matrice_bloc=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Bloc.html">Matrice_Bloc</a>, matrice.<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>());
<a name="l03044"></a>03044   matrice_bloc.<a class="code" href="classMatrice__Bloc.html#a7d624ebd3f141e34502e59f6d1b1d601">remplir</a>(voisins, coeffs, zone.<a class="code" href="classZone.html#a7f249429803b27139a1c54436f6164a5" title="Renvoie le nombre d&#39;elements de la zone.">nb_elem</a>(), zone.<a class="code" href="classZone.html#aa3a33e8b723618b9092460007153e42d" title="Renvoie le nombre total d&#39;elements de la zone.">nb_elem_tot</a>(), zone.<a class="code" href="classZone.html#ad340f571f81fa5c2e028b88c00b5c2ca" title="Renvoie le nombre de sommets de la zone.">nb_som</a>(), zone.<a class="code" href="classZone.html#a01ed67af826d6045ef4eacfb87a663e8" title="Renvoie le nombre total de sommets de la zone. i.e. le nombre de sommets reels et virtuels sur le pro...">nb_som_tot</a>());
<a name="l03045"></a>03045   <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Assemblage POP1 OK&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
<a name="l03046"></a>03046 }
<a name="l03047"></a>03047 
<a name="l03048"></a><a class="code" href="AssembleurPP1BUtil_8cpp.html#af30661e8e1b45bf522a5595f65ecc741">03048</a> <span class="keywordtype">void</span> <a class="code" href="Assembleur__P__VEFPreP1B_8cpp.html#af30661e8e1b45bf522a5595f65ecc741">updateP0P1</a>(<span class="keyword">const</span> <a class="code" href="classZone__dis__base.html" title="classe Zone_dis_base Cette classe est la base de la hierarchie des zones discretisees. Un objet Zone est associe a la zone discretise. A chaque methode numerique de Trio U correspond une classe derivant de Zone_dis_base implementant les outils necessaires a la methode.">Zone_dis_base</a>&amp; z,
<a name="l03049"></a>03049                 <span class="keyword">const</span> <a class="code" href="classZone__Cl__dis__base.html" title="classe Zone_Cl_dis_base Les objets Zone_Cl_dis_base representent les conditions aux limites discretis...">Zone_Cl_dis_base</a>&amp; zcl,
<a name="l03050"></a>03050                 <a class="code" href="classMatrice.html">Matrice</a>&amp; matrice,
<a name="l03051"></a>03051                 <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; inverse_quantitee_entrelacee, <span class="keyword">const</span> <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a>&amp; coef_som)
<a name="l03052"></a>03052 {
<a name="l03053"></a>03053   <span class="keywordtype">int</span> dimension=<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>;
<a name="l03054"></a>03054   <span class="keyword">const</span> <a class="code" href="classZone__VEF.html" title="class Zone_VEF Classe instanciable qui derive de Zone_VF. Cette classe contient les informations geom...">Zone_VEF</a>&amp; zone_VEF=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a>, z);
<a name="l03055"></a>03055   <span class="keyword">const</span> <a class="code" href="classZone__Cl__VEF.html">Zone_Cl_VEF</a>&amp; zone_Cl_VEF=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classZone__Cl__VEF.html">Zone_Cl_VEF</a>, zcl);
<a name="l03056"></a>03056   <span class="keyword">const</span> <a class="code" href="classConds__lim.html">Conds_lim</a>&amp; les_cl = zone_Cl_VEF.<a class="code" href="classZone__Cl__dis__base.html#af75e0ed7786863e4d333bfb29d67c323" title="Renvoie la i-ieme condition aux limites. (version const)">les_conditions_limites</a>();
<a name="l03057"></a>03057   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; face_voisins = zone_VEF.<a class="code" href="classZone__VF.html#a49d4322f5585a8fa95748ca785b70702" title="renvoie l&#39;element voisin de numface dans la direction i. i=0 : dans le sens oppose de l&#39;axe orthogona...">face_voisins</a>();
<a name="l03058"></a>03058   <span class="keywordtype">int</span> nint = zone_VEF.<a class="code" href="classZone__VF.html#a12869806fa4834aca8f2964e16509dfd" title="une face est interne ssi elle separe deux elements. renvoie le numero de la premiere face interne...">premiere_face_int</a>();
<a name="l03059"></a>03059   <span class="keywordtype">int</span> nb_faces = zone_VEF.<a class="code" href="classZone__VF.html#a50fd21c9535680489015a3c8b88c685a" title="renvoie le nombre total de faces. C&#39;est-a-dire faces reelles + faces virtuelles">nb_faces_tot</a>();
<a name="l03060"></a>03060   <span class="keywordtype">int</span> elem1, elem2, face, ok;
<a name="l03061"></a>03061   <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> sommets(dimension+2);
<a name="l03062"></a>03062   <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> face_opp1(dimension+2);
<a name="l03063"></a>03063   <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> face_opp2(dimension+2);
<a name="l03064"></a>03064   <a class="code" href="classMatrice__Bloc.html">Matrice_Bloc</a>&amp; A=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Bloc.html">Matrice_Bloc</a>, matrice.<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>());
<a name="l03065"></a>03065   <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; ARR=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>, A.<a class="code" href="classMatrice__Bloc.html#a7ffa38f7b93454432b2df7c616ed0a4e">get_bloc</a>(0,0).<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>());
<a name="l03066"></a>03066   <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; ARV=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>, A.<a class="code" href="classMatrice__Bloc.html#a7ffa38f7b93454432b2df7c616ed0a4e">get_bloc</a>(0,1).<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>());
<a name="l03067"></a>03067   <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; AVR=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>, A.<a class="code" href="classMatrice__Bloc.html#a7ffa38f7b93454432b2df7c616ed0a4e">get_bloc</a>(1,0).<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>());
<a name="l03068"></a>03068   <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; AVV=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>, A.<a class="code" href="classMatrice__Bloc.html#a7ffa38f7b93454432b2df7c616ed0a4e">get_bloc</a>(1,1).<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>());
<a name="l03069"></a>03069 <span class="comment">// Faces de bord :</span>
<a name="l03070"></a>03070   <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;les_cl.<a class="code" href="classvect__impl.html#a78155bfbd6b61f4710b9830641ed1694">size</a>(); i++)
<a name="l03071"></a>03071     {
<a name="l03072"></a>03072       <span class="keyword">const</span> <a class="code" href="classCond__lim.html" title="classe Cond_lim Classe generique servant a representer n&#39;importe quelle classe derivee de la classe C...">Cond_lim</a>&amp; la_cl = les_cl[i];
<a name="l03073"></a>03073       <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp; le_bord = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>,la_cl.<a class="code" href="classCond__lim.html#a5b2d24809cee07727006a891d4ce8d22" title="Appel a l&#39;objet sous-jacent Renvoie la frontiere discretisee associee a la condition aux limites...">frontiere_dis</a>());
<a name="l03074"></a>03074       <span class="keywordtype">int</span> nb_faces_bord_tot = le_bord.<a class="code" href="classFront__VF.html#aed4006d91bf2ef3af2b9f7933d863a09" title="Nombre de faces reelles et virtuelles du bord.">nb_faces_tot</a>();
<a name="l03075"></a>03075       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> ind_face=0; ind_face&lt;nb_faces_bord_tot; ind_face++)
<a name="l03076"></a>03076         {
<a name="l03077"></a>03077           ok=<a class="code" href="AssembleurPP1BUtil_8cpp.html#a40cf40213663174bb24649e51832bf3e">okface</a>(ind_face, face, la_cl);
<a name="l03078"></a>03078           <span class="keywordflow">if</span> (ok==-1) <span class="keywordflow">break</span>;
<a name="l03079"></a>03079           elem1=face_voisins(face, 0);
<a name="l03080"></a>03080           elem2=face_voisins(face, 1);
<a name="l03081"></a>03081           <a class="code" href="AssembleurPP1BUtil_8cpp.html#afd0a249a235b161c5267e7574e199a82">remplir_sommets</a>(zone_VEF, face, elem1, elem2, sommets,
<a name="l03082"></a>03082                           face_opp1, face_opp2);
<a name="l03083"></a>03083           <a class="code" href="AssembleurPP1BUtil_8cpp.html#acff816d35f8d4ce978f860e0cd958b8a">sort</a>(sommets, face_opp1, face_opp2);
<a name="l03084"></a>03084           <span class="keywordflow">if</span>(ok==3)
<a name="l03085"></a>03085             {
<a name="l03086"></a>03086               <a class="code" href="AssembleurPP1BUtil_8cpp.html#a1aa97c31d5b8f95ae899f599d606a1da">update_matrice_NeumannP0P1</a>(zone_VEF,
<a name="l03087"></a>03087                                          inverse_quantitee_entrelacee,
<a name="l03088"></a>03088                                          face, elem1, sommets,
<a name="l03089"></a>03089                                          face_opp1, coef_som,
<a name="l03090"></a>03090                                          ARR,ARV,AVR,AVV);
<a name="l03091"></a>03091             }
<a name="l03092"></a>03092           <span class="keywordflow">else</span> <span class="keywordflow">if</span>(ok==4)
<a name="l03093"></a>03093             {
<a name="l03094"></a>03094               ;<span class="comment">//!&lt; RIEN</span>
<a name="l03095"></a>03095 <span class="comment"></span>            }
<a name="l03096"></a>03096           <span class="keywordflow">else</span>
<a name="l03097"></a>03097             <a class="code" href="AssembleurPP1BUtil_8cpp.html#aa7aef5562f5fe1f2d5b1eeb6664bca53">update_matriceP0P1</a>(zone_VEF,
<a name="l03098"></a>03098                                inverse_quantitee_entrelacee,
<a name="l03099"></a>03099                                face, elem1, elem2, sommets,
<a name="l03100"></a>03100                                face_opp1, face_opp2, coef_som,
<a name="l03101"></a>03101                                ARR,ARV,AVR,AVV);
<a name="l03102"></a>03102         }
<a name="l03103"></a>03103     }
<a name="l03104"></a>03104   <a class="code" href="AssembleurPP1BUtil_8cpp.html#a3e374d53ebc7860e1c2f0b7906f2936d">face_associee</a>=-1;
<a name="l03105"></a>03105   <span class="keywordflow">for</span>(face=nint; face&lt;nb_faces; face++)
<a name="l03106"></a>03106     {
<a name="l03107"></a>03107       elem1=face_voisins(face, 0);
<a name="l03108"></a>03108       elem2=face_voisins(face, 1);
<a name="l03109"></a>03109       <span class="keywordflow">if</span> (!zone_VEF.<a class="code" href="classZone__VF.html#a33909d3880435e82e84639b51482d2c6" title="renvoie 1 si face est une face virtuelle de bord, 0 sinon">est_une_face_virt_bord</a>(face)) <span class="comment">//!&lt; On ne traite que les faces internes</span>
<a name="l03110"></a>03110 <span class="comment"></span>        {
<a name="l03111"></a>03111           <a class="code" href="AssembleurPP1BUtil_8cpp.html#afd0a249a235b161c5267e7574e199a82">remplir_sommets</a>(zone_VEF, face, elem1, elem2, sommets,
<a name="l03112"></a>03112                           face_opp1, face_opp2);
<a name="l03113"></a>03113           <a class="code" href="AssembleurPP1BUtil_8cpp.html#acff816d35f8d4ce978f860e0cd958b8a">sort</a>(sommets, face_opp1, face_opp2);
<a name="l03114"></a>03114           <a class="code" href="AssembleurPP1BUtil_8cpp.html#aa7aef5562f5fe1f2d5b1eeb6664bca53">update_matriceP0P1</a>(zone_VEF,
<a name="l03115"></a>03115                              inverse_quantitee_entrelacee,
<a name="l03116"></a>03116                              face, elem1, elem2, sommets,
<a name="l03117"></a>03117                              face_opp1, face_opp2, coef_som,
<a name="l03118"></a>03118                              ARR,ARV,AVR,AVV);
<a name="l03119"></a>03119         }
<a name="l03120"></a>03120     }
<a name="l03121"></a>03121   <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Update POP1 OK&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
<a name="l03122"></a>03122 }
<a name="l03123"></a>03123 
<a name="l03124"></a>03124 
<a name="l03125"></a>03125 
</pre></div></div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Tue Dec 14 2021 19:35:29 for TRUST by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
