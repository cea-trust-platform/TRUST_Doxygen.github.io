<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>TRUST: Assembleur_P_VDF Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">TRUST&#160;<span id="projectnumber">1.8.4</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a>  </div>
  <div class="headertitle">
<div class="title">Assembleur_P_VDF Class Reference</div>  </div>
</div>
<div class="contents">
<!-- doxytag: class="Assembleur_P_VDF" --><!-- doxytag: inherits="Assembleur_base" -->
<p><code>#include &lt;<a class="el" href="Assembleur__P__VDF_8h_source.html">Assembleur_P_VDF.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Assembleur_P_VDF:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classAssembleur__P__VDF.png" usemap="#Assembleur_P_VDF_map" alt=""/>
  <map id="Assembleur_P_VDF_map" name="Assembleur_P_VDF_map">
<area href="classAssembleur__base.html" alt="Assembleur_base" shape="rect" coords="0,112,126,136"/>
<area href="classObjet__U.html" title="classe Objet_U Cette classe est la classe de base des Objets de TRUST Dans les classes derivees de Ob..." alt="Objet_U" shape="rect" coords="0,56,126,80"/>
<area href="classProcess.html" title="Classe de base de TRUST (notamment Objet_U). Elle fournit quelques services de base accessibles de pa..." alt="Process" shape="rect" coords="0,0,126,24"/>
</map>
 </div></div>

<p><a href="classAssembleur__P__VDF-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAssembleur__P__VDF.html#af7a5bf2f0a8a8f6ba21650a19c3dc7f1">Assembleur_P_VDF</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAssembleur__P__VDF.html#ad5aceddc736aa748ad4bfe903248f360">~Assembleur_P_VDF</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAssembleur__P__VDF.html#a3c2e1cb318b4ae7a999f4baaf39a12d0">taille_memoire</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAssembleur__P__VDF.html#a6e80e84024f44643250ce92f75dd8bd0">duplique</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classType__info.html">Type_info</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAssembleur__P__VDF.html#aad2204e7c88793e9cbfe36b724f2b0ca">get_info</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Donne des informations sur le type de l'Objet_U.  <a href="#aad2204e7c88793e9cbfe36b724f2b0ca"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAssembleur__P__VDF.html#a72f34b9bd041058658eb11612911bbb1">associer_zone_dis_base</a> (const <a class="el" href="classZone__dis__base.html">Zone_dis_base</a> &amp;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAssembleur__P__VDF.html#a3e68b615f3394b7dd7002e5e10dee8ad">associer_zone_cl_dis_base</a> (const <a class="el" href="classZone__Cl__dis__base.html">Zone_Cl_dis_base</a> &amp;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classZone__dis__base.html">Zone_dis_base</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAssembleur__P__VDF.html#ac88b839fd9e38462641eac2515a74e12">zone_dis_base</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classZone__Cl__dis__base.html">Zone_Cl_dis_base</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAssembleur__P__VDF.html#adf03371f0f2cb7af8d04c4f6154588f1">zone_Cl_dis_base</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAssembleur__P__VDF.html#a043e47e99329ef400ed57fce0a54ffc7">assembler</a> (<a class="el" href="classMatrice.html">Matrice</a> &amp;)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Assemblage de la matrice de pression M telle que<br/>
M*P = div(porosite * grad (P))<br/>
et calcul des coefficients pour modifier_secmem.  <a href="#a043e47e99329ef400ed57fce0a54ffc7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAssembleur__P__VDF.html#a7360af042ae3d4713acc92707c421a48">assembler_mat</a> (<a class="el" href="classMatrice.html">Matrice</a> &amp;, const <a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;, int incr_pression, int resoudre_en_u)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAssembleur__P__VDF.html#aafa5800907c06a84ce79890cc9f736e7">assembler_rho_variable</a> (<a class="el" href="classMatrice.html">Matrice</a> &amp;, const <a class="el" href="classChamp__Don__base.html">Champ_Don_base</a> &amp;rho)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Assemblage de la matrice de pression M telle que<br/>
M*P = div(porosite/rho * grad (P))<br/>
et calcul des coefficients pour modifier_secmem.<br/>
Parametre: matrice<br/>
Signification: La matrice a assembler.<br/>
Contrainte: Soit la matrice n'est pas encore typee (alors on la "construit"),<br/>
soit c'est la meme que lors de l'appel precedent.<br/>
Parametre: rho<br/>
Contrainte: Doit etre un champ de type <a class="el" href="classChamp__Fonc__Face.html" title="classe Champ_Fonc_Face">Champ_Fonc_Face</a>.  <a href="#aafa5800907c06a84ce79890cc9f736e7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAssembleur__P__VDF.html#a1813c6eb0764db3280e0891e73b1ca60">assembler_QC</a> (const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;, <a class="el" href="classMatrice.html">Matrice</a> &amp;)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Assemble la matrice de pression pour un fluide quasi compressible.<br/>
La matrice M est telle que M*P = div( porosite * grad(P) ).<br/>
Le drapeau resoudre_increment_pression est mis a zero s'il n'a pas<br/>
encore ete assigne.  <a href="#a1813c6eb0764db3280e0891e73b1ca60"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAssembleur__P__VDF.html#adcac76493991056ab933d63ebff5e780">modifier_secmem</a> (<a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Modification du second membre pour appliquer les conditions aux limites.<br/>
Les conditions prises en charge sont<br/>
<a class="el" href="classNeumann__sortie__libre.html" title="classe Neumann_sortie_libre Cette classe represente une frontiere ouverte sans vitesse imposee Pour l...">Neumann_sortie_libre</a>,<br/>
<a class="el" href="classEntree__fluide__vitesse__imposee.html" title="classe Entree_fluide_vitesse_imposee Cas particulier de la classe Dirichlet_entree_fluide pour la vit...">Entree_fluide_vitesse_imposee</a>,<br/>
<a class="el" href="classDirichlet__paroi__defilante.html" title="classe Dirichlet_paroi_defilante Impose la vitesse de paroi dnas une equation de type Navier_Stokes...">Dirichlet_paroi_defilante</a> (rien a faire),<br/>
<a class="el" href="classDirichlet__paroi__fixe.html" title="classe Dirichlet_paroi_fixe Represente une paroi immobile dans une equation de type Navier_Stokes...">Dirichlet_paroi_fixe</a> (rien a faire),<br/>
<a class="el" href="classSymetrie.html" title="classe Symetrie Sur les faces de symetrie on a les proprietes suivantes: - composante normale de la v...">Symetrie</a> (rien a faire)  <a href="#adcac76493991056ab933d63ebff5e780"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAssembleur__P__VDF.html#a47e1e481696ee70a0a542926e77573b2">modifier_solution</a> (<a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAssembleur__P__VDF.html#ac0f82190e804db68a60b05e3fbfa06fd">completer</a> (const <a class="el" href="classEquation__base.html">Equation_base</a> &amp;)</td></tr>
<tr><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classObjet__U.html">Objet_U</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAssembleur__P__VDF.html#aca8f3849303b39954b9b194eda33e3dc">cree_instance</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classType__info.html">Type_info</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAssembleur__P__VDF.html#a62f79284c8f89020057b250ce31b26fa">info</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Donne des informations sur le type de l'Objet_U.  <a href="#a62f79284c8f89020057b250ce31b26fa"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classAssembleur__P__VDF.html">Assembleur_P_VDF</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAssembleur__P__VDF.html#a2a50db3de619951c7d56894bfafefc25">self_cast</a> (<a class="el" href="classObjet__U.html">Objet_U</a> &amp;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classAssembleur__P__VDF.html">Assembleur_P_VDF</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAssembleur__P__VDF.html#a651e1b3f00736a77995dda8af15c21b3">self_cast</a> (const <a class="el" href="classObjet__U.html">Objet_U</a> &amp;)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">methode ajoutee pour caster en python  <a href="#a651e1b3f00736a77995dda8af15c21b3"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classType__info.html">Type_info</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAssembleur__P__VDF.html#ab8e041b71b608e70ea351ef761fb5891">info_obj</a></td></tr>
<tr><td colspan="2"><h2><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classSortie.html">Sortie</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAssembleur__P__VDF.html#a2b5c25eb00889312bb6e6dc92e1d2616">printOn</a> (<a class="el" href="classSortie.html">Sortie</a> &amp;x) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Ecriture de l'objet sur un flot de sortie<br/>
Methode a surcharger.  <a href="#a2b5c25eb00889312bb6e6dc92e1d2616"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classEntree.html">Entree</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAssembleur__P__VDF.html#adba7dcdab645b9099b6134d74189677b">readOn</a> (<a class="el" href="classEntree.html">Entree</a> &amp;)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Lecture d'un <a class="el" href="classObjet__U.html" title="classe Objet_U Cette classe est la classe de base des Objets de TRUST Dans les classes derivees de Ob...">Objet_U</a> sur un flot d'entree<br/>
Methode a surcharger.  <a href="#adba7dcdab645b9099b6134d74189677b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAssembleur__P__VDF.html#aa56befba8f81a9161c144f009d3cdddd">construire</a> (<a class="el" href="classMatrice.html">Matrice</a> &amp;la_matrice)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine les elements non nuls de la matrice et prepare le stockage.<br/>
<a class="el" href="classMatrice.html">Matrice</a> creuse de taille nb_elements (lignes) * nb_elem_tot (colonnes)<br/>
Codee comme une matrice bloc composee de deux matrices morse:<br/>
* <a class="el" href="classMatrice.html">Matrice</a> carree symetrique nb_elements * nb_elements<br/>
(contient les termes M(i,j) ou i et j sont des numeros d'elements reels)<br/>
* <a class="el" href="classMatrice.html">Matrice</a> rectangle nb_elements * (nb_elem_tot - nb_elem)<br/>
(contient les termes M(i,j) ou i est reel et j est virtuel.  <a href="#aa56befba8f81a9161c144f009d3cdddd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAssembleur__P__VDF.html#ae6419915244b87d5c8f186d7c4fc1992">remplir</a> (<a class="el" href="classMatrice.html">Matrice</a> &amp;la_matrice, const <a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;volumes_entrelaces, const <a class="el" href="classChamp__Don__base.html">Champ_Don_base</a> *rho_ptr)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calcul des coefficients de la matrice de pression avec un champ de rho.<br/>
Si rho_ptr == 0, on calcule la matrice -div( porosite * grad P ),<br/>
sinon on calcule -div( porosite/rho grad P ) et *rho_ptr doit etre un <a class="el" href="classChamp__Fonc__Face.html" title="classe Champ_Fonc_Face">Champ_Fonc_Face</a>.  <a href="#ae6419915244b87d5c8f186d7c4fc1992"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAssembleur__P__VDF.html#a3e01aa32a7925771e8f8abf2f3556ebb">modifier_secmem_pression_imposee</a> (const <a class="el" href="classNeumann__sortie__libre.html">Neumann_sortie_libre</a> &amp;cond_lim, const <a class="el" href="classFront__VF.html">Front_VF</a> &amp;frontiere_vf, <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;secmem)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Modification du second membre du solveur en pression pour une condition<br/>
"Neumann_sortie_libre".<br/>
Calcul en "increment de pression" :<br/>
ajouter l'increment de pression, c'est a dire zero (c.l. instationnaire non supportee)<br/>
Calcul en "pression" :<br/>
Ajout du terme Pimpose * surface / volume_entrelace au second membre dans la discretisation de la<br/>
pression au bord (entre un element elem0 et un element fictif exterieur a pression imposee) :<br/>
grad P = (P(elem0) - Pimpose) * surface / volume_entrelace.  <a href="#a3e01aa32a7925771e8f8abf2f3556ebb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAssembleur__P__VDF.html#a9479432519c9424e8d5c6be2ce7a5493">modifier_secmem_vitesse_imposee</a> (const <a class="el" href="classEntree__fluide__vitesse__imposee.html">Entree_fluide_vitesse_imposee</a> &amp;cond_lim, const <a class="el" href="classFront__VF.html">Front_VF</a> &amp;frontiere_vf, <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;secmem)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Modification du second membre du systeme en pression pour une condition aux limites<br/>
de vitesse imposee.<br/>
Si on resout en increment de pression, ...<br/>
sinon rien a faire.  <a href="#a9479432519c9424e8d5c6be2ce7a5493"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAssembleur__P__VDF.html#a48da6c5fc5769465a659da41fab00812">liste_faces_periodiques</a> (<a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;faces)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Remplit le tableau faces avec la liste des indices des faces periodiques<br/>
dans le tableau faces_voisins. Chaque face periodique figure deux fois<br/>
dans faces_voisins (a chaque face correspond la face opposee). On ne<br/>
met dans le tableau faces que celle des deux qui a l'indice le + petit<br/>
dans la liste des faces de chaque bord periodique.<br/>
Valeur de retour:<br/>
nombre de faces periodiques (egal a la taille du tableau faces).  <a href="#a48da6c5fc5769465a659da41fab00812"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRef__Zone__VDF.html">Ref_Zone_VDF</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAssembleur__P__VDF.html#a4ce1358c35e162057c7968aa583cd581">la_zone_VDF</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRef__Zone__Cl__VDF.html">Ref_Zone_Cl_VDF</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAssembleur__P__VDF.html#a0b984a6831f2750865e12296e5e07a2b">la_zone_Cl_VDF</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classArrOfDouble.html">ArrOfDouble</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAssembleur__P__VDF.html#af8eca29a2e48d27e8e1f77e0945dc38d">les_coeff_pression</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAssembleur__P__VDF.html#a9d277900967c598cd61dcc14dcb7ebbd">has_P_ref</a></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock">
<p>Definition at line <a class="el" href="Assembleur__P__VDF_8h_source.html#l00040">40</a> of file <a class="el" href="Assembleur__P__VDF_8h_source.html">Assembleur_P_VDF.h</a>.</p>
</div><hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="af7a5bf2f0a8a8f6ba21650a19c3dc7f1"></a><!-- doxytag: member="Assembleur_P_VDF::Assembleur_P_VDF" ref="af7a5bf2f0a8a8f6ba21650a19c3dc7f1" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Assembleur_P_VDF::Assembleur_P_VDF </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Assembleur__P__VDF_8cpp_source.html#l00042">42</a> of file <a class="el" href="Assembleur__P__VDF_8cpp_source.html">Assembleur_P_VDF.cpp</a>.</p>
<div class="fragment"><pre class="fragment">                                   :
  <a class="code" href="classAssembleur__P__VDF.html#a9d277900967c598cd61dcc14dcb7ebbd">has_P_ref</a>(0)
{
}
</pre></div>
</div>
</div>
<a class="anchor" id="ad5aceddc736aa748ad4bfe903248f360"></a><!-- doxytag: member="Assembleur_P_VDF::~Assembleur_P_VDF" ref="ad5aceddc736aa748ad4bfe903248f360" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Assembleur_P_VDF::~Assembleur_P_VDF </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Assembleur__P__VDF_8cpp_source.html#l00040">40</a> of file <a class="el" href="Assembleur__P__VDF_8cpp_source.html">Assembleur_P_VDF.cpp</a>.</p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a043e47e99329ef400ed57fce0a54ffc7"></a><!-- doxytag: member="Assembleur_P_VDF::assembler" ref="a043e47e99329ef400ed57fce0a54ffc7" args="(Matrice &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Assembleur_P_VDF::assembler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMatrice.html">Matrice</a> &amp;&#160;</td>
          <td class="paramname"><em>matrice</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assemblage de la matrice de pression M telle que<br/>
M*P = div(porosite * grad (P))<br/>
et calcul des coefficients pour modifier_secmem. </p>

<p>Implements <a class="el" href="classAssembleur__base.html#a701b633c4c62af0880e72d9169220ccf">Assembleur_base</a>.</p>

<p>Definition at line <a class="el" href="Assembleur__P__VDF_8cpp_source.html#l00697">697</a> of file <a class="el" href="Assembleur__P__VDF_8cpp_source.html">Assembleur_P_VDF.cpp</a>.</p>

<p>References <a class="el" href="EntreeSortie_8h_source.html#l00032">Cerr</a>, <a class="el" href="Assembleur__P__VDF_8cpp_source.html#l00112">construire()</a>, <a class="el" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>, <a class="el" href="Process_8cpp_source.html#l00095">Process::je_suis_maitre()</a>, <a class="el" href="Assembleur__P__VDF_8h_source.html#l00068">la_zone_VDF</a>, <a class="el" href="Assembleur__P__VDF_8cpp_source.html#l00303">remplir()</a>, <a class="el" href="Assembleur__base_8cpp_source.html#l00077">Assembleur_base::set_resoudre_en_u()</a>, <a class="el" href="Assembleur__base_8cpp_source.html#l00055">Assembleur_base::set_resoudre_increment_pression()</a>, <a class="el" href="Ref__Zone__VDF_8h_source.html#l00028">Ref_Zone_VDF::valeur()</a>, and <a class="el" href="Zone__VF_8h_source.html#l00736">Zone_VF::volumes_entrelaces()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">if</span> (<a class="code" href="classProcess.html#acd052b99706c577f8a5b6656217cf4c2" title="renvoie 1 si on est sur le processeur maitre du groupe courant (c&#39;est a dire me() == 0)...">je_suis_maitre</a>())
    <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Assemblage de la matrice pression : Assembleur_P_VDF::assembler&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
<span class="comment">// Par defaut, resolution en increment de pression</span>
  <a class="code" href="classAssembleur__base.html#ad134c3371f3ced3768a1704be52e0fe8" title="Definit la valeur du drapeau resoudre_increment_pression_. Ce drapeau determine si le solveur en pres...">set_resoudre_increment_pression</a>(1);
  <a class="code" href="classAssembleur__base.html#a9cdaa49e5340da74de179c2f22f08605" title="Definit la valeur du drapeau resoudre_en_u__. Ce drapeau determine si le solveur en pression resou en...">set_resoudre_en_u</a>(1);
  <a class="code" href="classAssembleur__P__VDF.html#aa56befba8f81a9161c144f009d3cdddd" title="Determine les elements non nuls de la matrice et prepare le stockage. Matrice creuse de taille nb_ele...">construire</a>(matrice);
  <span class="keyword">const</span> <a class="code" href="classZone__VDF.html" title="class Zone_VDF Classe instanciable qui derive de Zone_VF. Cette classe contient les informations geom...">Zone_VDF</a>&amp; zone_vdf   = <a class="code" href="classAssembleur__P__VDF.html#a4ce1358c35e162057c7968aa583cd581">la_zone_VDF</a>.<a class="code" href="classRef__Zone__VDF.html#a84151da4db745d02791d6246e3682b67">valeur</a>();

  <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; volumes_entrelaces = zone_vdf.<a class="code" href="classZone__VF.html#a64f0b549e5aea1656855113e3510f418">volumes_entrelaces</a>();
  <a class="code" href="classAssembleur__P__VDF.html#ae6419915244b87d5c8f186d7c4fc1992" title="Calcul des coefficients de la matrice de pression avec un champ de rho. Si rho_ptr == 0...">remplir</a>(matrice,volumes_entrelaces, 0);
  <span class="keywordflow">return</span> 1;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a7360af042ae3d4713acc92707c421a48"></a><!-- doxytag: member="Assembleur_P_VDF::assembler_mat" ref="a7360af042ae3d4713acc92707c421a48" args="(Matrice &amp;, const DoubleVect &amp;, int incr_pression, int resoudre_en_u)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Assembleur_P_VDF::assembler_mat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMatrice.html">Matrice</a> &amp;&#160;</td>
          <td class="paramname"><em>matrice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;&#160;</td>
          <td class="paramname"><em>volumes_entrelaces</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>incr_pression</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>resoudre_en_u</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="classAssembleur__base.html#a0710705cb88b7db3620b993a2cb31e05">Assembleur_base</a>.</p>

<p>Definition at line <a class="el" href="Assembleur__P__VDF_8cpp_source.html#l00677">677</a> of file <a class="el" href="Assembleur__P__VDF_8cpp_source.html">Assembleur_P_VDF.cpp</a>.</p>

<p>References <a class="el" href="EntreeSortie_8h_source.html#l00032">Cerr</a>, <a class="el" href="Assembleur__P__VDF_8cpp_source.html#l00112">construire()</a>, <a class="el" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>, <a class="el" href="Process_8cpp_source.html#l00095">Process::je_suis_maitre()</a>, <a class="el" href="O__U__Ptr_8cpp_source.html#l00098">O_U_Ptr::non_nul()</a>, <a class="el" href="Assembleur__P__VDF_8cpp_source.html#l00303">remplir()</a>, <a class="el" href="Assembleur__base_8cpp_source.html#l00077">Assembleur_base::set_resoudre_en_u()</a>, and <a class="el" href="Assembleur__base_8cpp_source.html#l00055">Assembleur_base::set_resoudre_increment_pression()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">if</span> (! matrice.<a class="code" href="classO__U__Ptr.html#a16f216b2d169e885876419182658ddcc" title="Renvoie 1 si le pointeur est non_nul Renvoie 0 sinon.">non_nul</a>())
    {
      <span class="keywordflow">if</span> (<a class="code" href="classProcess.html#acd052b99706c577f8a5b6656217cf4c2" title="renvoie 1 si on est sur le processeur maitre du groupe courant (c&#39;est a dire me() == 0)...">je_suis_maitre</a>())
        <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Assemblage de la matrice pression : Assembleur_P_VDF::assembler&quot;</span> &lt;&lt; finl;
<span class="comment">// Par defaut, resolution en increment de pression</span>
      <a class="code" href="classAssembleur__P__VDF.html#aa56befba8f81a9161c144f009d3cdddd" title="Determine les elements non nuls de la matrice et prepare le stockage. Matrice creuse de taille nb_ele...">construire</a>(matrice);
    }
  <a class="code" href="classAssembleur__base.html#ad134c3371f3ced3768a1704be52e0fe8" title="Definit la valeur du drapeau resoudre_increment_pression_. Ce drapeau determine si le solveur en pres...">set_resoudre_increment_pression</a>(incr_pression);
  <a class="code" href="classAssembleur__base.html#a9cdaa49e5340da74de179c2f22f08605" title="Definit la valeur du drapeau resoudre_en_u__. Ce drapeau determine si le solveur en pression resou en...">set_resoudre_en_u</a>(resoudre_en_u);

  <a class="code" href="classAssembleur__P__VDF.html#ae6419915244b87d5c8f186d7c4fc1992" title="Calcul des coefficients de la matrice de pression avec un champ de rho. Si rho_ptr == 0...">remplir</a>(matrice,volumes_entrelaces, 0);
  <span class="keywordflow">return</span> 1;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a1813c6eb0764db3280e0891e73b1ca60"></a><!-- doxytag: member="Assembleur_P_VDF::assembler_QC" ref="a1813c6eb0764db3280e0891e73b1ca60" args="(const DoubleTab &amp;, Matrice &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Assembleur_P_VDF::assembler_QC </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>tab_rho</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatrice.html">Matrice</a> &amp;&#160;</td>
          <td class="paramname"><em>matrice</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assemble la matrice de pression pour un fluide quasi compressible.<br/>
La matrice M est telle que M*P = div( porosite * grad(P) ).<br/>
Le drapeau resoudre_increment_pression est mis a zero s'il n'a pas<br/>
encore ete assigne. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>int<br/>
 Signification: renvoie toujours 1<br/>
 Contraintes: </dd></dl>

<p>Reimplemented from <a class="el" href="classAssembleur__base.html#ac2a0006ad3edf6e76de92289afa995cd">Assembleur_base</a>.</p>

<p>Definition at line <a class="el" href="Assembleur__P__VDF_8cpp_source.html#l00764">764</a> of file <a class="el" href="Assembleur__P__VDF_8cpp_source.html">Assembleur_P_VDF.cpp</a>.</p>

<p>References <a class="el" href="EntreeSortie_8h_source.html#l00032">Cerr</a>, <a class="el" href="Assembleur__P__VDF_8cpp_source.html#l00112">construire()</a>, <a class="el" href="Process_8cpp_source.html#l00223">Process::exit()</a>, <a class="el" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>, <a class="el" href="Matrice__Bloc_8cpp_source.html#l00568">Matrice_Bloc::get_bloc()</a>, <a class="el" href="Assembleur__base_8cpp_source.html#l00065">Assembleur_base::get_resoudre_increment_pression()</a>, <a class="el" href="Process_8cpp_source.html#l00095">Process::je_suis_maitre()</a>, <a class="el" href="Assembleur__P__VDF_8h_source.html#l00068">la_zone_VDF</a>, <a class="el" href="O__U__Ptr_8cpp_source.html#l00098">O_U_Ptr::non_nul()</a>, <a class="el" href="Cast_8h_source.html#l00059">ref_cast</a>, <a class="el" href="Assembleur__P__VDF_8cpp_source.html#l00303">remplir()</a>, <a class="el" href="Assembleur__base_8cpp_source.html#l00077">Assembleur_base::set_resoudre_en_u()</a>, <a class="el" href="Assembleur__base_8cpp_source.html#l00055">Assembleur_base::set_resoudre_increment_pression()</a>, <a class="el" href="Deriv__Matrice__Base_8h_source.html#l00028">Deriv_Matrice_Base::valeur()</a>, <a class="el" href="Ref__Zone__VDF_8h_source.html#l00028">Ref_Zone_VDF::valeur()</a>, and <a class="el" href="Zone__VF_8h_source.html#l00736">Zone_VF::volumes_entrelaces()</a>.</p>
<div class="fragment"><pre class="fragment">{
<span class="comment">// Par defaut pour le qc: resolution en pression et pas en increment pression.</span>
  <span class="keywordflow">if</span> (<a class="code" href="classAssembleur__base.html#afb2f8c92496b38dcafa391fe380c0385" title="Renvoie la valeur du drapeau resoudre_increment_pression_ (0 ou 1) Renvoie -1 si le drapeau n&#39;a pas e...">get_resoudre_increment_pression</a>() &lt; 0)
    {
      <a class="code" href="classAssembleur__base.html#ad134c3371f3ced3768a1704be52e0fe8" title="Definit la valeur du drapeau resoudre_increment_pression_. Ce drapeau determine si le solveur en pres...">set_resoudre_increment_pression</a>(1);
      <a class="code" href="classAssembleur__base.html#a9cdaa49e5340da74de179c2f22f08605" title="Definit la valeur du drapeau resoudre_en_u__. Ce drapeau determine si le solveur en pression resou en...">set_resoudre_en_u</a>(0);
    }
  <span class="keywordflow">if</span> (! matrice.<a class="code" href="classO__U__Ptr.html#a16f216b2d169e885876419182658ddcc" title="Renvoie 1 si le pointeur est non_nul Renvoie 0 sinon.">non_nul</a>())
    {
      <span class="keywordflow">if</span> (<a class="code" href="classProcess.html#acd052b99706c577f8a5b6656217cf4c2" title="renvoie 1 si on est sur le processeur maitre du groupe courant (c&#39;est a dire me() == 0)...">je_suis_maitre</a>())
        {
          <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Assemblage de la matrice pression : &quot;</span>;
          <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Assembleur_P_VDF::assembler_QC&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
        }
      <a class="code" href="classAssembleur__P__VDF.html#aa56befba8f81a9161c144f009d3cdddd" title="Determine les elements non nuls de la matrice et prepare le stockage. Matrice creuse de taille nb_ele...">construire</a>(matrice);
      <span class="keyword">const</span> <a class="code" href="classZone__VDF.html" title="class Zone_VDF Classe instanciable qui derive de Zone_VF. Cette classe contient les informations geom...">Zone_VDF</a>&amp; zone_vdf   = <a class="code" href="classAssembleur__P__VDF.html#a4ce1358c35e162057c7968aa583cd581">la_zone_VDF</a>.<a class="code" href="classRef__Zone__VDF.html#a84151da4db745d02791d6246e3682b67">valeur</a>();

      <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; volumes_entrelaces = zone_vdf.<a class="code" href="classZone__VF.html#a64f0b549e5aea1656855113e3510f418">volumes_entrelaces</a>();
      <a class="code" href="classAssembleur__P__VDF.html#ae6419915244b87d5c8f186d7c4fc1992" title="Calcul des coefficients de la matrice de pression avec un champ de rho. Si rho_ptr == 0...">remplir</a>(matrice,volumes_entrelaces, 0);

      <a class="code" href="classMatrice__Bloc.html">Matrice_Bloc</a>&amp; matrice_bloc=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Bloc.html">Matrice_Bloc</a>,matrice.<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>());
      <a class="code" href="classMatrice__Morse__Sym.html" title="Classe Matrice_Morse_Sym Represente une matrice M (creuse) symetrique stockee au format Morse Symetri...">Matrice_Morse_Sym</a>&amp; la_matrice =<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Morse__Sym.html" title="Classe Matrice_Morse_Sym Represente une matrice M (creuse) symetrique stockee au format Morse Symetri...">Matrice_Morse_Sym</a>,matrice_bloc.<a class="code" href="classMatrice__Bloc.html#a7ffa38f7b93454432b2df7c616ed0a4e">get_bloc</a>(0,0).<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>());
      <span class="keywordflow">if</span> (la_matrice.get_est_definie()!=1)
        {
          <span class="keywordflow">if</span> ((<a class="code" href="classProcess.html#acd052b99706c577f8a5b6656217cf4c2" title="renvoie 1 si on est sur le processeur maitre du groupe courant (c&#39;est a dire me() == 0)...">je_suis_maitre</a>()) &amp;&amp; (la_matrice.nb_lignes()==0) &amp;&amp; (la_matrice.nb_colonnes()==0))
            {
              <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a>&lt;&lt;<span class="stringliteral">&quot;Pressure matrix will not be defined.&quot;</span>&lt;&lt;<a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
              <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">exit</a>();
            }

          <span class="keywordflow">if</span> ((la_matrice.nb_lignes()&gt;0) &amp;&amp; (la_matrice.nb_colonnes()&gt;0))
            {
              <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a>&lt;&lt;<span class="stringliteral">&quot;la_matrice(0,0)&quot;</span>&lt;&lt;la_matrice(0,0)&lt;&lt;<a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
              <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a>&lt;&lt;<span class="stringliteral">&quot;Pas de pression imposee  --&gt; P(0)=0&quot;</span>&lt;&lt;finl;
              <span class="keywordflow">if</span> (<a class="code" href="classProcess.html#acd052b99706c577f8a5b6656217cf4c2" title="renvoie 1 si on est sur le processeur maitre du groupe courant (c&#39;est a dire me() == 0)...">je_suis_maitre</a>())    la_matrice(0,0) *= 2;
            }
          la_matrice.set_est_definie(1);
        }
    }
  <span class="keywordflow">return</span> 1;
}
</pre></div>
</div>
</div>
<a class="anchor" id="aafa5800907c06a84ce79890cc9f736e7"></a><!-- doxytag: member="Assembleur_P_VDF::assembler_rho_variable" ref="aafa5800907c06a84ce79890cc9f736e7" args="(Matrice &amp;, const Champ_Don_base &amp;rho)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Assembleur_P_VDF::assembler_rho_variable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMatrice.html">Matrice</a> &amp;&#160;</td>
          <td class="paramname"><em>matrice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classChamp__Don__base.html">Champ_Don_base</a> &amp;&#160;</td>
          <td class="paramname"><em>rho</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assemblage de la matrice de pression M telle que<br/>
M*P = div(porosite/rho * grad (P))<br/>
et calcul des coefficients pour modifier_secmem.<br/>
Parametre: matrice<br/>
Signification: La matrice a assembler.<br/>
Contrainte: Soit la matrice n'est pas encore typee (alors on la "construit"),<br/>
soit c'est la meme que lors de l'appel precedent.<br/>
Parametre: rho<br/>
Contrainte: Doit etre un champ de type <a class="el" href="classChamp__Fonc__Face.html" title="classe Champ_Fonc_Face">Champ_Fonc_Face</a>. </p>

<p>Reimplemented from <a class="el" href="classAssembleur__base.html#a22607eed0ff59b926b346c632cd629f5">Assembleur_base</a>.</p>

<p>Definition at line <a class="el" href="Assembleur__P__VDF_8cpp_source.html#l00722">722</a> of file <a class="el" href="Assembleur__P__VDF_8cpp_source.html">Assembleur_P_VDF.cpp</a>.</p>

<p>References <a class="el" href="EntreeSortie_8h_source.html#l00032">Cerr</a>, <a class="el" href="Assembleur__P__VDF_8cpp_source.html#l00112">construire()</a>, <a class="el" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>, <a class="el" href="Assembleur__base_8cpp_source.html#l00087">Assembleur_base::get_resoudre_en_u()</a>, <a class="el" href="Assembleur__base_8cpp_source.html#l00065">Assembleur_base::get_resoudre_increment_pression()</a>, <a class="el" href="Process_8cpp_source.html#l00095">Process::je_suis_maitre()</a>, <a class="el" href="Assembleur__P__VDF_8h_source.html#l00068">la_zone_VDF</a>, <a class="el" href="O__U__Ptr_8cpp_source.html#l00098">O_U_Ptr::non_nul()</a>, <a class="el" href="Assembleur__P__VDF_8cpp_source.html#l00303">remplir()</a>, <a class="el" href="Ref__Zone__VDF_8h_source.html#l00028">Ref_Zone_VDF::valeur()</a>, and <a class="el" href="Zone__VF_8h_source.html#l00736">Zone_VF::volumes_entrelaces()</a>.</p>
<div class="fragment"><pre class="fragment">{
<span class="comment">// assembler_rho_variable a ete introduit pour le front-tracking:</span>
<span class="comment">// il faut dire explicitement si on resout en increment de pression</span>
  assert(<a class="code" href="classAssembleur__base.html#afb2f8c92496b38dcafa391fe380c0385" title="Renvoie la valeur du drapeau resoudre_increment_pression_ (0 ou 1) Renvoie -1 si le drapeau n&#39;a pas e...">get_resoudre_increment_pression</a>() &gt;= 0);
<span class="comment">// idem pour resoudre en u</span>
  assert(<a class="code" href="classAssembleur__base.html#a3744c3df3886e9fc65246c2eb1abb794" title="Renvoie la valeur du drapeau resoudre_en_u_ (0 ou 1) Renvoie -1 si le drapeau n&#39;a pas ete initialise...">get_resoudre_en_u</a>() &gt;= 0);
<span class="comment">// Si la matrice n&#39;a pas encore ete typee, il faut la construire :</span>
  <span class="keywordflow">if</span> (! matrice.<a class="code" href="classO__U__Ptr.html#a16f216b2d169e885876419182658ddcc" title="Renvoie 1 si le pointeur est non_nul Renvoie 0 sinon.">non_nul</a>())
    {
      <span class="keywordflow">if</span> (<a class="code" href="classProcess.html#acd052b99706c577f8a5b6656217cf4c2" title="renvoie 1 si on est sur le processeur maitre du groupe courant (c&#39;est a dire me() == 0)...">je_suis_maitre</a>())
        {
          <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Assemblage de la matrice pression : &quot;</span>;
          <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Assembleur_P_VDF::assembler_rho_variable&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
        }
      <a class="code" href="classAssembleur__P__VDF.html#aa56befba8f81a9161c144f009d3cdddd" title="Determine les elements non nuls de la matrice et prepare le stockage. Matrice creuse de taille nb_ele...">construire</a>(matrice);
    }
  <span class="keyword">const</span> <a class="code" href="classZone__VDF.html" title="class Zone_VDF Classe instanciable qui derive de Zone_VF. Cette classe contient les informations geom...">Zone_VDF</a>&amp; zone_vdf   = <a class="code" href="classAssembleur__P__VDF.html#a4ce1358c35e162057c7968aa583cd581">la_zone_VDF</a>.<a class="code" href="classRef__Zone__VDF.html#a84151da4db745d02791d6246e3682b67">valeur</a>();

  <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; volumes_entrelaces = zone_vdf.<a class="code" href="classZone__VF.html#a64f0b549e5aea1656855113e3510f418">volumes_entrelaces</a>();
  <a class="code" href="classAssembleur__P__VDF.html#ae6419915244b87d5c8f186d7c4fc1992" title="Calcul des coefficients de la matrice de pression avec un champ de rho. Si rho_ptr == 0...">remplir</a>(matrice,volumes_entrelaces, &amp; rho);
  <span class="keywordflow">return</span> 1;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a3e68b615f3394b7dd7002e5e10dee8ad"></a><!-- doxytag: member="Assembleur_P_VDF::associer_zone_cl_dis_base" ref="a3e68b615f3394b7dd7002e5e10dee8ad" args="(const Zone_Cl_dis_base &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Assembleur_P_VDF::associer_zone_cl_dis_base </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classZone__Cl__dis__base.html">Zone_Cl_dis_base</a> &amp;&#160;</td>
          <td class="paramname"><em>la_zone_Cl_dis</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implements <a class="el" href="classAssembleur__base.html#ae39b86add804b76604136b3c179e563d">Assembleur_base</a>.</p>

<p>Definition at line <a class="el" href="Assembleur__P__VDF_8cpp_source.html#l00822">822</a> of file <a class="el" href="Assembleur__P__VDF_8cpp_source.html">Assembleur_P_VDF.cpp</a>.</p>

<p>References <a class="el" href="Assembleur__P__VDF_8h_source.html#l00069">la_zone_Cl_VDF</a>, and <a class="el" href="Cast_8h_source.html#l00059">ref_cast</a>.</p>
<div class="fragment"><pre class="fragment">{
  <a class="code" href="classAssembleur__P__VDF.html#a0b984a6831f2750865e12296e5e07a2b">la_zone_Cl_VDF</a> = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classZone__Cl__VDF.html" title="&lt; namespace TypeAreteCoinVDF">Zone_Cl_VDF</a>, la_zone_Cl_dis);
}
</pre></div>
</div>
</div>
<a class="anchor" id="a72f34b9bd041058658eb11612911bbb1"></a><!-- doxytag: member="Assembleur_P_VDF::associer_zone_dis_base" ref="a72f34b9bd041058658eb11612911bbb1" args="(const Zone_dis_base &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Assembleur_P_VDF::associer_zone_dis_base </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classZone__dis__base.html">Zone_dis_base</a> &amp;&#160;</td>
          <td class="paramname"><em>la_zone_dis</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implements <a class="el" href="classAssembleur__base.html#a0bc0bbf0f23d197b146cf296bf01a06c">Assembleur_base</a>.</p>

<p>Definition at line <a class="el" href="Assembleur__P__VDF_8cpp_source.html#l00817">817</a> of file <a class="el" href="Assembleur__P__VDF_8cpp_source.html">Assembleur_P_VDF.cpp</a>.</p>

<p>References <a class="el" href="Assembleur__P__VDF_8h_source.html#l00068">la_zone_VDF</a>, and <a class="el" href="Cast_8h_source.html#l00059">ref_cast</a>.</p>
<div class="fragment"><pre class="fragment">{
  <a class="code" href="classAssembleur__P__VDF.html#a4ce1358c35e162057c7968aa583cd581">la_zone_VDF</a> = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classZone__VDF.html" title="class Zone_VDF Classe instanciable qui derive de Zone_VF. Cette classe contient les informations geom...">Zone_VDF</a>, la_zone_dis);
}
</pre></div>
</div>
</div>
<a class="anchor" id="ac0f82190e804db68a60b05e3fbfa06fd"></a><!-- doxytag: member="Assembleur_P_VDF::completer" ref="ac0f82190e804db68a60b05e3fbfa06fd" args="(const Equation_base &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Assembleur_P_VDF::completer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEquation__base.html">Equation_base</a> &amp;&#160;</td>
          <td class="paramname"><em>Eqn</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implements <a class="el" href="classAssembleur__base.html#af1ccb24293dc6acd5ce923ead993e409">Assembleur_base</a>.</p>

<p>Definition at line <a class="el" href="Assembleur__P__VDF_8cpp_source.html#l00827">827</a> of file <a class="el" href="Assembleur__P__VDF_8cpp_source.html">Assembleur_P_VDF.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{
<span class="comment">// CCa 30/04/99 : je ne sais pas si je dois faire qqchose</span>
  ;
}
</pre></div>
</div>
</div>
<a class="anchor" id="aa56befba8f81a9161c144f009d3cdddd"></a><!-- doxytag: member="Assembleur_P_VDF::construire" ref="aa56befba8f81a9161c144f009d3cdddd" args="(Matrice &amp;la_matrice)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Assembleur_P_VDF::construire </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMatrice.html">Matrice</a> &amp;&#160;</td>
          <td class="paramname"><em>la_matrice</em></td><td>)</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Determine les elements non nuls de la matrice et prepare le stockage.<br/>
<a class="el" href="classMatrice.html">Matrice</a> creuse de taille nb_elements (lignes) * nb_elem_tot (colonnes)<br/>
Codee comme une matrice bloc composee de deux matrices morse:<br/>
* <a class="el" href="classMatrice.html">Matrice</a> carree symetrique nb_elements * nb_elements<br/>
(contient les termes M(i,j) ou i et j sont des numeros d'elements reels)<br/>
* <a class="el" href="classMatrice.html">Matrice</a> rectangle nb_elements * (nb_elem_tot - nb_elem)<br/>
(contient les termes M(i,j) ou i est reel et j est virtuel. </p>

<p><p>&lt; Astuce pour boucler sur les faces internes et periodiques</p>
<p>&lt; elem0 est reel</p>
<p>&lt; elem1 reel</p>
<p>&lt; elem1 virtuel</p>
<p>&lt; tab1_ contient un indice fortran (1er element en 1)</p>
<p>&lt; Indice fortran 1&lt;=i&lt;=nb_elem</p>
<p>&lt; Nombre de coefficients non nuls sur chaque ligne</p>
<p>&lt; Verifie qu'on a bien deux elements voisins</p>
<p>&lt; elem0 est reel</p>
<p>&lt; Indice fortran</p>
<p>&lt; elem1 est reel aussi</p>
<p>&lt; Indice fortran</p>
<p>&lt; Indice fortran dans tab2</p>
<p>&lt; elem1 est virtuel</p>
<p>&lt; Indice fortran</p>
<p>&lt; Indice fortran dans tab2 </p>
</p>

<p>Definition at line <a class="el" href="Assembleur__P__VDF_8cpp_source.html#l00112">112</a> of file <a class="el" href="Assembleur__P__VDF_8cpp_source.html">Assembleur_P_VDF.cpp</a>.</p>

<p>References <a class="el" href="Double_8h_source.html#l00098">carre()</a>, <a class="el" href="Matrice__Morse_8cpp_source.html#l00346">Matrice_Morse::dimensionner()</a>, <a class="el" href="Matrice__Bloc_8cpp_source.html#l00560">Matrice_Bloc::dimensionner()</a>, <a class="el" href="Zone__VF_8h_source.html#l00458">Zone_VF::face_voisins()</a>, <a class="el" href="Matrice__Bloc_8cpp_source.html#l00568">Matrice_Bloc::get_bloc()</a>, <a class="el" href="Matrice__Morse_8h_source.html#l00119">Matrice_Morse::get_set_tab1()</a>, <a class="el" href="Matrice__Morse_8h_source.html#l00124">Matrice_Morse::get_set_tab2()</a>, <a class="el" href="Assembleur__P__VDF_8h_source.html#l00068">la_zone_VDF</a>, <a class="el" href="Assembleur__P__VDF_8h_source.html#l00070">les_coeff_pression</a>, <a class="el" href="Assembleur__P__VDF_8cpp_source.html#l00065">liste_faces_periodiques()</a>, <a class="el" href="Zone__dis__base_8h_source.html#l00140">Zone_dis_base::nb_elem()</a>, <a class="el" href="Zone__dis__base_8h_source.html#l00144">Zone_dis_base::nb_elem_tot()</a>, <a class="el" href="Zone__VF_8h_source.html#l00547">Zone_VF::nb_faces_bord()</a>, <a class="el" href="Zone__VF_8h_source.html#l00565">Zone_VF::nb_faces_internes()</a>, <a class="el" href="Zone__VF_8h_source.html#l00512">Zone_VF::premiere_face_int()</a>, <a class="el" href="Cast_8h_source.html#l00059">ref_cast</a>, <a class="el" href="ArrOfDouble_8h_source.html#l00244">ArrOfDouble::resize_array()</a>, <a class="el" href="Deriv___8cpp_source.html#l00091">Deriv_::typer()</a>, <a class="el" href="Deriv__Matrice__Base_8h_source.html#l00028">Deriv_Matrice_Base::valeur()</a>, and <a class="el" href="Ref__Zone__VDF_8h_source.html#l00028">Ref_Zone_VDF::valeur()</a>.</p>

<p>Referenced by <a class="el" href="Assembleur__P__VDF_8cpp_source.html#l00697">assembler()</a>, <a class="el" href="Assembleur__P__VDF_8cpp_source.html#l00677">assembler_mat()</a>, <a class="el" href="Assembleur__P__VDF_8cpp_source.html#l00764">assembler_QC()</a>, and <a class="el" href="Assembleur__P__VDF_8cpp_source.html#l00722">assembler_rho_variable()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">int</span> i;
  <span class="keyword">const</span> <a class="code" href="classZone__VDF.html" title="class Zone_VDF Classe instanciable qui derive de Zone_VF. Cette classe contient les informations geom...">Zone_VDF</a>&amp; zone_vdf   = <a class="code" href="classAssembleur__P__VDF.html#a4ce1358c35e162057c7968aa583cd581">la_zone_VDF</a>.<a class="code" href="classRef__Zone__VDF.html#a84151da4db745d02791d6246e3682b67">valeur</a>();
  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; face_voisins = zone_vdf.<a class="code" href="classZone__VF.html#a49d4322f5585a8fa95748ca785b70702" title="renvoie l&#39;element voisin de numface dans la direction i. i=0 : dans le sens oppose de l&#39;axe orthogona...">face_voisins</a>();

<span class="comment">// Comptage du nombre total d&#39;elements non nuls:</span>
<span class="comment">// matrice carree : nombre de faces internes / 2 + nb_elem + nbfaces periodiques</span>
<span class="comment">// (chaque face interne donne un coef, et on a un element</span>
<span class="comment">// diagonal et chaque face periodique donne aussi un coef)</span>
<span class="comment">// matrice rectangle : nombre de faces de joint</span>


<span class="comment">// Premiere etape : comptage du nombre d&#39;elements non nuls sur chaque ligne</span>
<span class="comment">// Pour chaque ligne de la matrice carree, nombre d&#39;elements non nuls</span>
  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_elem     = zone_vdf.<a class="code" href="classZone__dis__base.html#a790cb2f6bc2928518799e748313d0eb3">nb_elem</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_elem_tot = zone_vdf.<a class="code" href="classZone__dis__base.html#a4d6aa445f152aa6dc54d66ea7a071147">nb_elem_tot</a>();
  <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> carre_nb_non_zero(nb_elem);
<span class="comment">// Idem pour le rectangle</span>
  <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> rect_nb_non_zero(nb_elem);
<span class="comment">// Il y a l&#39;element sur la diagonale :</span>
  carre_nb_non_zero = 1;
  rect_nb_non_zero = 0;
  <span class="keywordtype">int</span> carre_nb_non_zero_tot = nb_elem;
  <span class="keywordtype">int</span> rect_nb_non_zero_tot = 0;

<span class="comment">// Plus un element non nul pour chaque face interne et chaque face periodique</span>
<span class="comment">// (matrice symetrique, on ne stocke que l&#39;element m(line,col) avec col&gt;line)</span>

  <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> liste_faces_perio;
  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_faces_periodiques = <a class="code" href="classAssembleur__P__VDF.html#a48da6c5fc5769465a659da41fab00812" title="Remplit le tableau faces avec la liste des indices des faces periodiques dans le tableau faces_voisin...">liste_faces_periodiques</a>(liste_faces_perio);
  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_faces_internes = zone_vdf.<a class="code" href="classZone__VF.html#a1210c3de419eab8ce27debddd632218e" title="une face est interne ssi elle separe deux elements. renvoie le nombre de faces internes.">nb_faces_internes</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> premiere_face_interne = zone_vdf.<a class="code" href="classZone__VF.html#a12869806fa4834aca8f2964e16509dfd" title="une face est interne ssi elle separe deux elements. renvoie le numero de la premiere face interne...">premiere_face_int</a>();
  <span class="keywordflow">for</span> (i = 0; i &lt; nb_faces_internes + nb_faces_periodiques; i++)
    {
      <span class="keywordtype">int</span> face;
      <span class="keywordflow">if</span> (i &lt; nb_faces_internes) <span class="comment">//!&lt; Astuce pour boucler sur les faces internes et periodiques</span>
<span class="comment"></span>        face = premiere_face_interne + i;
      <span class="keywordflow">else</span>
        face = liste_faces_perio[i - nb_faces_internes];

      <span class="keywordtype">int</span> elem0 = face_voisins(face,0);
      <span class="keywordtype">int</span> elem1 = face_voisins(face,1);
      <span class="keywordflow">if</span> (elem0 &gt; elem1)
        {
          <span class="keywordtype">int</span> tmp = elem1;
          elem1 = elem0;
          elem0 = tmp;
        }
      <span class="keywordflow">if</span> (elem0 &lt; nb_elem)   <span class="comment">//!&lt; elem0 est reel</span>
<span class="comment"></span>        {
          <span class="keywordflow">if</span> (elem1 &lt; nb_elem)      <span class="comment">//!&lt; elem1 reel</span>
<span class="comment"></span>            {
              carre_nb_non_zero[elem0] ++;
              carre_nb_non_zero_tot ++;
            }
          <span class="keywordflow">else</span>                      <span class="comment">//!&lt; elem1 virtuel</span>
<span class="comment"></span>            {
              rect_nb_non_zero[elem0] ++;
              rect_nb_non_zero_tot ++;
            }
        }
    }

<span class="comment">// Typage et dimensionnement de la matrice de pression</span>
  la_matrice.<a class="code" href="classDeriv__.html#ad1d33400ed15b6ff96579ed82d9e2719" title="Essaie de creer une instance du type &quot;type&quot;. si type n&#39;est pas un type ou type n&#39;est pas instanciab...">typer</a>(<span class="stringliteral">&quot;Matrice_Bloc&quot;</span>);
  <a class="code" href="classMatrice__Bloc.html">Matrice_Bloc</a>&amp; matrice =<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Bloc.html">Matrice_Bloc</a> , la_matrice.<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>());
  matrice.<a class="code" href="classMatrice__Bloc.html#a1db7c549cc1be958d5f00c29cd0f3a8c">dimensionner</a>(1,2);
  matrice.<a class="code" href="classMatrice__Bloc.html#a7ffa38f7b93454432b2df7c616ed0a4e">get_bloc</a>(0,0).<a class="code" href="classDeriv__.html#ad1d33400ed15b6ff96579ed82d9e2719" title="Essaie de creer une instance du type &quot;type&quot;. si type n&#39;est pas un type ou type n&#39;est pas instanciab...">typer</a>(<span class="stringliteral">&quot;Matrice_Morse_Sym&quot;</span>);
  matrice.<a class="code" href="classMatrice__Bloc.html#a7ffa38f7b93454432b2df7c616ed0a4e">get_bloc</a>(0,1).<a class="code" href="classDeriv__.html#ad1d33400ed15b6ff96579ed82d9e2719" title="Essaie de creer une instance du type &quot;type&quot;. si type n&#39;est pas un type ou type n&#39;est pas instanciab...">typer</a>(<span class="stringliteral">&quot;Matrice_Morse&quot;</span>);
  <a class="code" href="classMatrice__Morse__Sym.html" title="Classe Matrice_Morse_Sym Represente une matrice M (creuse) symetrique stockee au format Morse Symetri...">Matrice_Morse_Sym</a>&amp; <a class="code" href="Double_8h.html#aa4be1ab61f49e9ebb241ed3f4957fd4a" title="fonctions utiles sur les double">carre</a> = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Morse__Sym.html" title="Classe Matrice_Morse_Sym Represente une matrice M (creuse) symetrique stockee au format Morse Symetri...">Matrice_Morse_Sym</a> ,matrice.<a class="code" href="classMatrice__Bloc.html#a7ffa38f7b93454432b2df7c616ed0a4e">get_bloc</a>(0,0).<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>());
  <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp;      rect  = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a> ,     matrice.<a class="code" href="classMatrice__Bloc.html#a7ffa38f7b93454432b2df7c616ed0a4e">get_bloc</a>(0,1).<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>());

  carre.<a class="code" href="classMatrice__Morse.html#ae95f9ed88a8a3fc637cd2a705cead9c8" title="Size the matrix with n lines and n columns and nnz zero-values coefficients.">dimensionner</a>(nb_elem, carre_nb_non_zero_tot);
  rect.dimensionner(nb_elem, nb_elem_tot - nb_elem, rect_nb_non_zero_tot);

  {
    <span class="keyword">const</span> <span class="keywordtype">int</span> nb_faces_bord = zone_vdf.<a class="code" href="classZone__VF.html#a8815e2276637c0db23868f043dc43e58" title="renvoie le nombre de faces sur lesquelles sont appliquees les conditions limites : bords...">nb_faces_bord</a>();
    <a class="code" href="classAssembleur__P__VDF.html#af8eca29a2e48d27e8e1f77e0945dc38d">les_coeff_pression</a>.<a class="code" href="classArrOfDouble.html#a610464f4b3dccac6f814915b526783ed">resize_array</a>(nb_faces_bord);
  }
  <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; carre_tab1 = carre.<a class="code" href="classMatrice__Morse.html#a7a49c763706dcfaed900f9d2cbb68716">get_set_tab1</a>();
  <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; rect_tab1 = rect.get_set_tab1();

<span class="comment">// Matrice creuse, stockage morse avec des indices fortran:</span>
<span class="comment">// lignes numerotees 1..n, colonnes 1..m</span>
<span class="comment">// Le k-ieme coefficient non nul de la ligne i (1&lt;=i&lt;=n) est (avec 1&lt;=k)</span>
<span class="comment">// M(i,j) = coeff_[tab1_[k]]     en fortran</span>
<span class="comment">// M(i,j) = coeff_[tab1_[k-1]-1] en C</span>
<span class="comment">// Le numero j de la colonne ou se trouve ce coefficient (1&lt;=j&lt;=m) est</span>
<span class="comment">// j = tab2_[tab1_[k]]     en fortran</span>
<span class="comment">// j = tab2_[tab1_[k-1]-1] en C</span>
<span class="comment">// </span>
<span class="comment">// Calcul de l&#39;indice du premier coefficient de la ligne i</span>
<span class="comment">// dans le tableau d&#39;indices morse des deux matrices (tab1_)</span>
  {
    <span class="keywordtype">int</span> indice = 1; <span class="comment">//!&lt; tab1_ contient un indice fortran (1er element en 1)</span>
<span class="comment"></span>    <span class="keywordflow">for</span> (i = 0; i &lt; nb_elem; i++)
      {
        carre_tab1[i] = indice;
        indice += carre_nb_non_zero[i];
      }
    carre_tab1[i] = indice;

    indice = 1;
    <span class="keywordflow">for</span> (i = 0; i &lt; nb_elem; i++)
      {
        rect_tab1[i] = indice;
        indice += rect_nb_non_zero[i];
      }
    rect_tab1[i] = indice;
  }

<span class="comment">// Deuxieme etape : remplissage de tab2_ = numero de la colonne de chaque</span>
<span class="comment">// terme non nul de la matrice</span>
  <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; carre_tab2 = carre.<a class="code" href="classMatrice__Morse.html#af11c5853518e9e6db4c7e6e6acc8d7fd">get_set_tab2</a>();
  <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; rect_tab2 = rect.get_set_tab2();

  carre_tab2 = -1;
  rect_tab2 = -1;

<span class="comment">// Terme diagonal:</span>
  <span class="keywordflow">for</span> (i = 1; i &lt;= nb_elem; i++)
    carre_tab2[carre_tab1[i-1]-1] = i; <span class="comment">//!&lt; Indice fortran 1&lt;=i&lt;=nb_elem</span>
<span class="comment"></span>
  carre_nb_non_zero = 1; <span class="comment">//!&lt; Nombre de coefficients non nuls sur chaque ligne</span>
<span class="comment"></span>  rect_nb_non_zero = 0;

<span class="comment">// Termes extra-diagonaux:</span>
  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i_face = 0; i_face &lt; nb_faces_internes + nb_faces_periodiques; i_face++)
    {

<span class="comment">// Calcul du numero de la face a traiter</span>
      <span class="keyword">const</span> <span class="keywordtype">int</span> face = (i_face &lt; nb_faces_internes)
                       ? premiere_face_interne + i_face
                       : liste_faces_perio[i_face - nb_faces_internes];

      <span class="keywordtype">int</span> elem0 = face_voisins(face,0);
      <span class="keywordtype">int</span> elem1 = face_voisins(face,1);
      <span class="keywordflow">if</span> (elem0 &gt; elem1)
        {
          <span class="keywordtype">int</span> tmp = elem1;
          elem1 = elem0;
          elem0 = tmp;
        }
      assert(elem0 &gt;= 0);            <span class="comment">//!&lt; Verifie qu&#39;on a bien deux elements voisins</span>
<span class="comment"></span>      <span class="keywordflow">if</span> (elem0 &lt; nb_elem)                              <span class="comment">//!&lt; elem0 est reel</span>
<span class="comment"></span>        {
          <span class="keyword">const</span> <span class="keywordtype">int</span> ligne = elem0 + 1;                 <span class="comment">//!&lt; Indice fortran</span>
<span class="comment"></span>          <span class="keywordflow">if</span> (elem1 &lt; nb_elem)                            <span class="comment">//!&lt; elem1 est reel aussi</span>
<span class="comment"></span>            {
              <span class="keyword">const</span> <span class="keywordtype">int</span> colonne = elem1 + 1;             <span class="comment">//!&lt; Indice fortran</span>
<span class="comment"></span>              <span class="keyword">const</span> <span class="keywordtype">int</span> n = carre_nb_non_zero[ligne-1]++;
              <span class="keyword">const</span> <span class="keywordtype">int</span> index = carre_tab1[ligne-1] + n; <span class="comment">//!&lt; Indice fortran dans tab2</span>
<span class="comment"></span>              carre_tab2[index - 1] = colonne;
            }
          <span class="keywordflow">else</span>                                           <span class="comment">//!&lt; elem1 est virtuel</span>
<span class="comment"></span>            {
              <span class="keyword">const</span> <span class="keywordtype">int</span> colonne = elem1 - nb_elem + 1;  <span class="comment">//!&lt; Indice fortran</span>
<span class="comment"></span>              <span class="keyword">const</span> <span class="keywordtype">int</span> n = rect_nb_non_zero[ligne-1]++;
              <span class="keyword">const</span> <span class="keywordtype">int</span> index = rect_tab1[ligne-1] + n; <span class="comment">//!&lt; Indice fortran dans tab2</span>
<span class="comment"></span>              rect_tab2[index - 1] = colonne;
            }
        }
    }

  <span class="keywordflow">return</span> 1;
}
</pre></div>
</div>
</div>
<a class="anchor" id="aca8f3849303b39954b9b194eda33e3dc"></a><!-- doxytag: member="Assembleur_P_VDF::cree_instance" ref="aca8f3849303b39954b9b194eda33e3dc" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classObjet__U.html">Objet_U</a> * Assembleur_P_VDF::cree_instance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Assembleur__P__VDF_8cpp_source.html#l00040">40</a> of file <a class="el" href="Assembleur__P__VDF_8cpp_source.html">Assembleur_P_VDF.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6e80e84024f44643250ce92f75dd8bd0"></a><!-- doxytag: member="Assembleur_P_VDF::duplique" ref="a6e80e84024f44643250ce92f75dd8bd0" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Assembleur_P_VDF::duplique </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implements <a class="el" href="classAssembleur__base.html#acde1fe2768463e4d7c2cb1b6c72d6f64">Assembleur_base</a>.</p>

<p>Definition at line <a class="el" href="Assembleur__P__VDF_8cpp_source.html#l00040">40</a> of file <a class="el" href="Assembleur__P__VDF_8cpp_source.html">Assembleur_P_VDF.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="aad2204e7c88793e9cbfe36b724f2b0ca"></a><!-- doxytag: member="Assembleur_P_VDF::get_info" ref="aad2204e7c88793e9cbfe36b724f2b0ca" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classType__info.html">Type_info</a> * Assembleur_P_VDF::get_info </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Donne des informations sur le type de l'Objet_U. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>const Type_info*<br/>
 Signification: structure regroupant les informations sur le type de l'Objet_U<br/>
 Contraintes: </dd></dl>

<p>Reimplemented from <a class="el" href="classAssembleur__base.html#ab82f4a59737c61c5f37f90e48a67f383">Assembleur_base</a>.</p>

<p>Definition at line <a class="el" href="Assembleur__P__VDF_8cpp_source.html#l00040">40</a> of file <a class="el" href="Assembleur__P__VDF_8cpp_source.html">Assembleur_P_VDF.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a62f79284c8f89020057b250ce31b26fa"></a><!-- doxytag: member="Assembleur_P_VDF::info" ref="a62f79284c8f89020057b250ce31b26fa" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classType__info.html">Type_info</a> * Assembleur_P_VDF::info </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Donne des informations sur le type de l'Objet_U. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>const Type_info*<br/>
 Signification: structure regroupant les informations sur le type de l'Objet_U<br/>
 Contraintes: </dd></dl>

<p>Reimplemented from <a class="el" href="classAssembleur__base.html#acb4acc74d53c76cd6f8c132ae21fdb36">Assembleur_base</a>.</p>

<p>Definition at line <a class="el" href="Assembleur__P__VDF_8cpp_source.html#l00040">40</a> of file <a class="el" href="Assembleur__P__VDF_8cpp_source.html">Assembleur_P_VDF.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a48da6c5fc5769465a659da41fab00812"></a><!-- doxytag: member="Assembleur_P_VDF::liste_faces_periodiques" ref="a48da6c5fc5769465a659da41fab00812" args="(ArrOfInt &amp;faces)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Assembleur_P_VDF::liste_faces_periodiques </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>faces</em></td><td>)</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Remplit le tableau faces avec la liste des indices des faces periodiques<br/>
dans le tableau faces_voisins. Chaque face periodique figure deux fois<br/>
dans faces_voisins (a chaque face correspond la face opposee). On ne<br/>
met dans le tableau faces que celle des deux qui a l'indice le + petit<br/>
dans la liste des faces de chaque bord periodique.<br/>
Valeur de retour:<br/>
nombre de faces periodiques (egal a la taille du tableau faces). </p>

<p>Definition at line <a class="el" href="Assembleur__P__VDF_8cpp_source.html#l00065">65</a> of file <a class="el" href="Assembleur__P__VDF_8cpp_source.html">Assembleur_P_VDF.cpp</a>.</p>

<p>References <a class="el" href="Periodique_8h_source.html#l00056">Periodique::face_associee()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00046">face_associee</a>, <a class="el" href="Cond__lim__base_8h_source.html#l00123">Cond_lim_base::frontiere_dis()</a>, <a class="el" href="Assembleur__P__VDF_8h_source.html#l00069">la_zone_Cl_VDF</a>, <a class="el" href="Assembleur__P__VDF_8h_source.html#l00068">la_zone_VDF</a>, <a class="el" href="Zone__Cl__dis__base_8cpp_source.html#l00522">Zone_Cl_dis_base::les_conditions_limites()</a>, <a class="el" href="Front__VF_8h_source.html#l00061">Front_VF::nb_faces()</a>, <a class="el" href="Zone__VF_8h_source.html#l00547">Zone_VF::nb_faces_bord()</a>, <a class="el" href="Front__VF_8h_source.html#l00071">Front_VF::num_premiere_face()</a>, <a class="el" href="Cast_8h_source.html#l00059">ref_cast</a>, <a class="el" href="ArrOfInt_8h_source.html#l00240">ArrOfInt::resize_array()</a>, <a class="el" href="vect__impl_8h_source.html#l00057">vect_impl::size()</a>, <a class="el" href="Cast_8h_source.html#l00054">sub_type</a>, <a class="el" href="Ref__Zone__Cl__VDF_8h_source.html#l00028">Ref_Zone_Cl_VDF::valeur()</a>, and <a class="el" href="Ref__Zone__VDF_8h_source.html#l00028">Ref_Zone_VDF::valeur()</a>.</p>

<p>Referenced by <a class="el" href="Assembleur__P__VDF_8cpp_source.html#l00112">construire()</a>, and <a class="el" href="Assembleur__P__VDF_8cpp_source.html#l00303">remplir()</a>.</p>
<div class="fragment"><pre class="fragment">{
<span class="comment">// On commence par surestimer largement la taille du tableau :</span>
<span class="comment">// nombre de faces de bord</span>
  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_faces_bord = <a class="code" href="classAssembleur__P__VDF.html#a4ce1358c35e162057c7968aa583cd581">la_zone_VDF</a>.<a class="code" href="classRef__Zone__VDF.html#a84151da4db745d02791d6246e3682b67">valeur</a>().<a class="code" href="classZone__VF.html#a8815e2276637c0db23868f043dc43e58" title="renvoie le nombre de faces sur lesquelles sont appliquees les conditions limites : bords...">nb_faces_bord</a>();
  faces.<a class="code" href="classArrOfInt.html#a9b3afbb46b16870dbd36236c8935b535">resize_array</a>(nb_faces_bord);

<span class="comment">// Recherche des faces periodiques dans les conditions aux limites:</span>
  <span class="keyword">const</span> <a class="code" href="classConds__lim.html">Conds_lim</a>&amp; les_cl = <a class="code" href="classAssembleur__P__VDF.html#a0b984a6831f2750865e12296e5e07a2b">la_zone_Cl_VDF</a>.<a class="code" href="classRef__Zone__Cl__VDF.html#a1e655604e840cda5b393e45f975b73ff">valeur</a>().<a class="code" href="classZone__Cl__dis__base.html#af75e0ed7786863e4d333bfb29d67c323" title="Renvoie la i-ieme condition aux limites. (version const)">les_conditions_limites</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_cl = les_cl.<a class="code" href="classvect__impl.html#a78155bfbd6b61f4710b9830641ed1694">size</a>();
  <span class="keywordtype">int</span> nb_faces_periodiques = 0;
  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> num_cl = 0; num_cl &lt; nb_cl; num_cl++)
    {
      <span class="keyword">const</span> <a class="code" href="classCond__lim__base.html" title="classe Cond_lim_base Classe de base pour la hierarchie des classes qui representent les differentes c...">Cond_lim_base</a>&amp; la_cl = les_cl[num_cl].valeur();
<span class="comment">// Selectionne uniquement les conditions Periodique</span>
      <span class="keywordflow">if</span> ( ! <a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>,la_cl))
        <span class="keywordflow">continue</span>;
      <span class="keyword">const</span> <a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>&amp; la_cl_perio = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>, la_cl);
      <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp;    frontiere = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>, la_cl.<a class="code" href="classCond__lim__base.html#ad88b3b516351146c85e8fce1df0f691a" title="Renvoie la frontiere discretisee a laquelle les conditions aux limites s&#39;appliquent.">frontiere_dis</a>());
      <span class="keyword">const</span> <span class="keywordtype">int</span> nb_faces_cl = frontiere.<a class="code" href="classFront__VF.html#a341e2fcb5117b96e745fd7078ba86bab" title="Nombre de faces reelles du bord.">nb_faces</a>();
      <span class="keyword">const</span> <span class="keywordtype">int</span> num_premiere_face = frontiere.<a class="code" href="classFront__VF.html#a4986f0c65653fe9eb40bbbff5a97bf16" title="Numero de la premiere face du bord dans la liste des faces.">num_premiere_face</a>();
      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; nb_faces_cl; i++)
        {
<span class="comment">// Numero de la face opposee dans le tableau des faces du bord:</span>
          <span class="keyword">const</span> <span class="keywordtype">int</span> <a class="code" href="AssembleurPP1BUtil_8cpp.html#a3e374d53ebc7860e1c2f0b7906f2936d">face_associee</a> = la_cl_perio.<a class="code" href="classPeriodique.html#a207b86556f199a63ea059b841851ca6a">face_associee</a>(i);
          <span class="keywordflow">if</span> (face_associee &gt; i)
            {
              <span class="keyword">const</span> <span class="keywordtype">int</span> num_face_global = num_premiere_face + i;
              faces[nb_faces_periodiques] = num_face_global;
              nb_faces_periodiques++;
            }
        }
    }

<span class="comment">// Taille finale du tableau faces</span>
  faces.<a class="code" href="classArrOfInt.html#a9b3afbb46b16870dbd36236c8935b535">resize_array</a>(nb_faces_periodiques);
  <span class="keywordflow">return</span> nb_faces_periodiques;
}
</pre></div>
</div>
</div>
<a class="anchor" id="adcac76493991056ab933d63ebff5e780"></a><!-- doxytag: member="Assembleur_P_VDF::modifier_secmem" ref="adcac76493991056ab933d63ebff5e780" args="(DoubleTab &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Assembleur_P_VDF::modifier_secmem </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>secmem</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Modification du second membre pour appliquer les conditions aux limites.<br/>
Les conditions prises en charge sont<br/>
<a class="el" href="classNeumann__sortie__libre.html" title="classe Neumann_sortie_libre Cette classe represente une frontiere ouverte sans vitesse imposee Pour l...">Neumann_sortie_libre</a>,<br/>
<a class="el" href="classEntree__fluide__vitesse__imposee.html" title="classe Entree_fluide_vitesse_imposee Cas particulier de la classe Dirichlet_entree_fluide pour la vit...">Entree_fluide_vitesse_imposee</a>,<br/>
<a class="el" href="classDirichlet__paroi__defilante.html" title="classe Dirichlet_paroi_defilante Impose la vitesse de paroi dnas une equation de type Navier_Stokes...">Dirichlet_paroi_defilante</a> (rien a faire),<br/>
<a class="el" href="classDirichlet__paroi__fixe.html" title="classe Dirichlet_paroi_fixe Represente une paroi immobile dans une equation de type Navier_Stokes...">Dirichlet_paroi_fixe</a> (rien a faire),<br/>
<a class="el" href="classSymetrie.html" title="classe Symetrie Sur les faces de symetrie on a les proprietes suivantes: - composante normale de la v...">Symetrie</a> (rien a faire) </p>

<p>Implements <a class="el" href="classAssembleur__base.html#a1b7505480a151e375f3916e94e134a92">Assembleur_base</a>.</p>

<p>Definition at line <a class="el" href="Assembleur__P__VDF_8cpp_source.html#l00498">498</a> of file <a class="el" href="Assembleur__P__VDF_8cpp_source.html">Assembleur_P_VDF.cpp</a>.</p>

<p>References <a class="el" href="EntreeSortie_8h_source.html#l00032">Cerr</a>, <a class="el" href="DoubleVect_8cpp_source.html#l00277">DoubleVect::echange_espace_virtuel()</a>, <a class="el" href="Process_8cpp_source.html#l00223">Process::exit()</a>, <a class="el" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>, <a class="el" href="Cond__lim__base_8h_source.html#l00123">Cond_lim_base::frontiere_dis()</a>, <a class="el" href="Assembleur__P__VDF_8h_source.html#l00069">la_zone_Cl_VDF</a>, <a class="el" href="Zone__Cl__dis__base_8cpp_source.html#l00522">Zone_Cl_dis_base::les_conditions_limites()</a>, <a class="el" href="Assembleur__P__VDF_8cpp_source.html#l00560">modifier_secmem_pression_imposee()</a>, <a class="el" href="Assembleur__P__VDF_8cpp_source.html#l00603">modifier_secmem_vitesse_imposee()</a>, <a class="el" href="Zone__Cl__dis__base_8cpp_source.html#l00603">Zone_Cl_dis_base::nb_cond_lim()</a>, <a class="el" href="Objet__U_8cpp_source.html#l00132">Objet_U::que_suis_je()</a>, <a class="el" href="Cast_8h_source.html#l00059">ref_cast</a>, <a class="el" href="Cast_8h_source.html#l00054">sub_type</a>, <a class="el" href="Cond__lim_8h_source.html#l00031">Deriv_Cond_lim_base::valeur()</a>, and <a class="el" href="Ref__Zone__Cl__VDF_8h_source.html#l00028">Ref_Zone_Cl_VDF::valeur()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">const</span> <a class="code" href="classZone__Cl__VDF.html" title="&lt; namespace TypeAreteCoinVDF">Zone_Cl_VDF</a>&amp; la_zone_cl = <a class="code" href="classAssembleur__P__VDF.html#a0b984a6831f2750865e12296e5e07a2b">la_zone_Cl_VDF</a>.<a class="code" href="classRef__Zone__Cl__VDF.html#a1e655604e840cda5b393e45f975b73ff">valeur</a>();
  <span class="keywordtype">int</span> nb_cond_lim = la_zone_cl.<a class="code" href="classZone__Cl__dis__base.html#aa6f1df56cfd6e2eae83cc991c7cc9b41" title="Renvoie le nombre de conditions aux limites.">nb_cond_lim</a>();

  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> indice_cl = 0; indice_cl &lt; nb_cond_lim; indice_cl++)
    {
      <span class="keyword">const</span> <a class="code" href="classCond__lim__base.html" title="classe Cond_lim_base Classe de base pour la hierarchie des classes qui representent les differentes c...">Cond_lim_base</a>&amp; la_cl_base =
        la_zone_cl.<a class="code" href="classZone__Cl__dis__base.html#af75e0ed7786863e4d333bfb29d67c323" title="Renvoie la i-ieme condition aux limites. (version const)">les_conditions_limites</a>(indice_cl).<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>();

      <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp; frontiere_vf = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>, la_cl_base.<a class="code" href="classCond__lim__base.html#ad88b3b516351146c85e8fce1df0f691a" title="Renvoie la frontiere discretisee a laquelle les conditions aux limites s&#39;appliquent.">frontiere_dis</a>());

      <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classNeumann__sortie__libre.html" title="classe Neumann_sortie_libre Cette classe represente une frontiere ouverte sans vitesse imposee Pour l...">Neumann_sortie_libre</a>, la_cl_base))
        {
          <a class="code" href="classAssembleur__P__VDF.html#a3e01aa32a7925771e8f8abf2f3556ebb" title="Modification du second membre du solveur en pression pour une condition &quot;Neumann_sortie_libre&quot;. Calcul en &quot;increment de pression&quot; : ajouter l&#39;increment de pression, c&#39;est a dire zero (c.l. instationnaire non supportee) Calcul en &quot;pression&quot; : Ajout du terme Pimpose * surface / volume_entrelace au second membre dans la discretisation de la pression au bord (entre un element elem0 et un element fictif exterieur a pression imposee) : grad P = (P(elem0) - Pimpose) * surface / volume_entrelace.">modifier_secmem_pression_imposee</a>(<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>( <a class="code" href="classNeumann__sortie__libre.html" title="classe Neumann_sortie_libre Cette classe represente une frontiere ouverte sans vitesse imposee Pour l...">Neumann_sortie_libre</a>, la_cl_base),
                                           frontiere_vf,
                                           secmem);
        }
      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classEntree__fluide__vitesse__imposee.html" title="classe Entree_fluide_vitesse_imposee Cas particulier de la classe Dirichlet_entree_fluide pour la vit...">Entree_fluide_vitesse_imposee</a>, la_cl_base))
        {
          <a class="code" href="classAssembleur__P__VDF.html#a9479432519c9424e8d5c6be2ce7a5493" title="Modification du second membre du systeme en pression pour une condition aux limites de vitesse impose...">modifier_secmem_vitesse_imposee</a>(<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classEntree__fluide__vitesse__imposee.html" title="classe Entree_fluide_vitesse_imposee Cas particulier de la classe Dirichlet_entree_fluide pour la vit...">Entree_fluide_vitesse_imposee</a> ,la_cl_base),
                                          frontiere_vf,
                                          secmem);
        }
      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classDirichlet__paroi__defilante.html" title="classe Dirichlet_paroi_defilante Impose la vitesse de paroi dnas une equation de type Navier_Stokes...">Dirichlet_paroi_defilante</a>, la_cl_base))
        {
<span class="comment">// Pour une paroi defilante, rien a faire.</span>
        }
      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classDirichlet__paroi__fixe.html" title="classe Dirichlet_paroi_fixe Represente une paroi immobile dans une equation de type Navier_Stokes...">Dirichlet_paroi_fixe</a>, la_cl_base))
        {
<span class="comment">// Rien a faire non plus.</span>
        }
      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classSymetrie.html" title="classe Symetrie Sur les faces de symetrie on a les proprietes suivantes: - composante normale de la v...">Symetrie</a>, la_cl_base))
        {
<span class="comment">// Encore rien a faire</span>
        }
      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>, la_cl_base))
        {
<span class="comment">// Rien a faire</span>
        }
      <span class="keywordflow">else</span>
        {
          <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Erreur dans Assembleur_P_VDF::modifier_secmem\n la condition aux limites &quot;</span>;
          <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; la_cl_base.<a class="code" href="classObjet__U.html#aa58e9a81c0ddc2c1149053b8f96698ac" title="renvoie la chaine identifiant la classe.">que_suis_je</a>() &lt;&lt; <span class="stringliteral">&quot; n&#39;est pas prise en charge.&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
          assert(0);
          <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">exit</a>();
        }
    }
  secmem.<a class="code" href="classDoubleVect.html#abfebbc2f685ce7bc4b80c720d7da9bf3">echange_espace_virtuel</a>();
  <span class="keywordflow">return</span> 1;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a3e01aa32a7925771e8f8abf2f3556ebb"></a><!-- doxytag: member="Assembleur_P_VDF::modifier_secmem_pression_imposee" ref="a3e01aa32a7925771e8f8abf2f3556ebb" args="(const Neumann_sortie_libre &amp;cond_lim, const Front_VF &amp;frontiere_vf, DoubleTab &amp;secmem)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Assembleur_P_VDF::modifier_secmem_pression_imposee </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classNeumann__sortie__libre.html">Neumann_sortie_libre</a> &amp;&#160;</td>
          <td class="paramname"><em>cond_lim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFront__VF.html">Front_VF</a> &amp;&#160;</td>
          <td class="paramname"><em>frontiere_vf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>secmem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Modification du second membre du solveur en pression pour une condition<br/>
"Neumann_sortie_libre".<br/>
Calcul en "increment de pression" :<br/>
ajouter l'increment de pression, c'est a dire zero (c.l. instationnaire non supportee)<br/>
Calcul en "pression" :<br/>
Ajout du terme Pimpose * surface / volume_entrelace au second membre dans la discretisation de la<br/>
pression au bord (entre un element elem0 et un element fictif exterieur a pression imposee) :<br/>
grad P = (P(elem0) - Pimpose) * surface / volume_entrelace. </p>

<p>Definition at line <a class="el" href="Assembleur__P__VDF_8cpp_source.html#l00560">560</a> of file <a class="el" href="Assembleur__P__VDF_8cpp_source.html">Assembleur_P_VDF.cpp</a>.</p>

<p>References <a class="el" href="Zone__VF_8h_source.html#l00458">Zone_VF::face_voisins()</a>, <a class="el" href="Neumann_8cpp_source.html#l00081">Neumann::flux_impose()</a>, <a class="el" href="Assembleur__base_8cpp_source.html#l00065">Assembleur_base::get_resoudre_increment_pression()</a>, <a class="el" href="Assembleur__P__VDF_8h_source.html#l00068">la_zone_VDF</a>, <a class="el" href="Assembleur__P__VDF_8h_source.html#l00070">les_coeff_pression</a>, <a class="el" href="Front__VF_8h_source.html#l00061">Front_VF::nb_faces()</a>, <a class="el" href="Front__VF_8h_source.html#l00071">Front_VF::num_premiere_face()</a>, and <a class="el" href="Ref__Zone__VDF_8h_source.html#l00028">Ref_Zone_VDF::valeur()</a>.</p>

<p>Referenced by <a class="el" href="Assembleur__P__VDF_8cpp_source.html#l00498">modifier_secmem()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">const</span> <a class="code" href="classZone__VDF.html" title="class Zone_VDF Classe instanciable qui derive de Zone_VF. Cette classe contient les informations geom...">Zone_VDF</a>&amp; la_zone = <a class="code" href="classAssembleur__P__VDF.html#a4ce1358c35e162057c7968aa583cd581">la_zone_VDF</a>.<a class="code" href="classRef__Zone__VDF.html#a84151da4db745d02791d6246e3682b67">valeur</a>();
  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; face_voisins = la_zone.<a class="code" href="classZone__VF.html#a49d4322f5585a8fa95748ca785b70702" title="renvoie l&#39;element voisin de numface dans la direction i. i=0 : dans le sens oppose de l&#39;axe orthogona...">face_voisins</a>();
  <span class="keywordflow">if</span> (<a class="code" href="classAssembleur__base.html#afb2f8c92496b38dcafa391fe380c0385" title="Renvoie la valeur du drapeau resoudre_increment_pression_ (0 ou 1) Renvoie -1 si le drapeau n&#39;a pas e...">get_resoudre_increment_pression</a>())
    {
      <span class="comment">/*</span>
<span class="comment">        const Champ_front_base &amp; champ_front = cond_lim.champ_front().valeur();</span>
<span class="comment">        if (sub_type(Champ_front_instationnaire_base, champ_front)</span>
<span class="comment">        || sub_type(Champ_front_var_instationnaire, champ_front)) {</span>
<span class="comment">        Cerr &lt;&lt; &quot;Erreur dans Assembleur_P_VDF::modifier_secmem_pression_imposee\n &quot;;</span>
<span class="comment">        Cerr &lt;&lt; champ_front.que_suis_je();</span>
<span class="comment">        Cerr &lt;&lt; &quot; + resoudre_increment_pression non code&quot; &lt;&lt; finl;</span>
<span class="comment">        assert(0);</span>
<span class="comment">        exit();</span>
<span class="comment">        } else {</span>
<span class="comment">        // Champ stationnaire, on ajoute un increment de pression nul.</span>
<span class="comment">        // Donc rien a faire.</span>
<span class="comment">        }</span>
<span class="comment">      */</span>
    }
  <span class="keywordflow">else</span>
    {
      <span class="keyword">const</span> <span class="keywordtype">int</span> nb_faces = frontiere_vf.<a class="code" href="classFront__VF.html#a341e2fcb5117b96e745fd7078ba86bab" title="Nombre de faces reelles du bord.">nb_faces</a>();
      <span class="keyword">const</span> <span class="keywordtype">int</span> num_premiere_face = frontiere_vf.<a class="code" href="classFront__VF.html#a4986f0c65653fe9eb40bbbff5a97bf16" title="Numero de la premiere face du bord dans la liste des faces.">num_premiere_face</a>();
      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; nb_faces; i++)
        {
          <span class="keyword">const</span> <span class="keywordtype">int</span> num_face = num_premiere_face + i;
          <span class="keyword">const</span> <span class="keywordtype">double</span> Pimp = cond_lim.<a class="code" href="classNeumann.html#a4f6ee6cc54ca6471254c2a530c5b70b5" title="Renvoie la valeur du flux impose sur la i-eme composante du champ representant le flux a la frontiere...">flux_impose</a>(i);
          <span class="keyword">const</span> <span class="keywordtype">double</span> coef = <a class="code" href="classAssembleur__P__VDF.html#af8eca29a2e48d27e8e1f77e0945dc38d">les_coeff_pression</a>[num_face] * Pimp;
          <span class="keyword">const</span> <span class="keywordtype">int</span> elem = face_voisins(num_face, 0) + face_voisins(num_face, 1) + 1;
          secmem[elem] += coef;
        }
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a9479432519c9424e8d5c6be2ce7a5493"></a><!-- doxytag: member="Assembleur_P_VDF::modifier_secmem_vitesse_imposee" ref="a9479432519c9424e8d5c6be2ce7a5493" args="(const Entree_fluide_vitesse_imposee &amp;cond_lim, const Front_VF &amp;frontiere_vf, DoubleTab &amp;secmem)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Assembleur_P_VDF::modifier_secmem_vitesse_imposee </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEntree__fluide__vitesse__imposee.html">Entree_fluide_vitesse_imposee</a> &amp;&#160;</td>
          <td class="paramname"><em>cond_lim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFront__VF.html">Front_VF</a> &amp;&#160;</td>
          <td class="paramname"><em>frontiere_vf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>secmem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Modification du second membre du systeme en pression pour une condition aux limites<br/>
de vitesse imposee.<br/>
Si on resout en increment de pression, ...<br/>
sinon rien a faire. </p>

<p><p>&lt; Instationnaire uniforme</p>
<p>&lt; Instationnaire variable</p>
<p>&lt; Stationnaire </p>
</p>

<p>Definition at line <a class="el" href="Assembleur__P__VDF_8cpp_source.html#l00603">603</a> of file <a class="el" href="Assembleur__P__VDF_8cpp_source.html">Assembleur_P_VDF.cpp</a>.</p>

<p>References <a class="el" href="Cond__lim__base_8h_source.html#l00196">Cond_lim_base::champ_front()</a>, <a class="el" href="Zone__VF_8h_source.html#l00054">Zone_VF::face_surfaces()</a>, <a class="el" href="Zone__VF_8h_source.html#l00458">Zone_VF::face_voisins()</a>, <a class="el" href="Assembleur__base_8cpp_source.html#l00087">Assembleur_base::get_resoudre_en_u()</a>, <a class="el" href="Assembleur__P__VDF_8h_source.html#l00068">la_zone_VDF</a>, <a class="el" href="Front__VF_8h_source.html#l00061">Front_VF::nb_faces()</a>, <a class="el" href="Front__VF_8h_source.html#l00071">Front_VF::num_premiere_face()</a>, <a class="el" href="Zone__VDF_8h_source.html#l00266">Zone_VDF::orientation()</a>, <a class="el" href="Cast_8h_source.html#l00059">ref_cast</a>, <a class="el" href="Cast_8h_source.html#l00054">sub_type</a>, <a class="el" href="Ref__Zone__VDF_8h_source.html#l00028">Ref_Zone_VDF::valeur()</a>, and <a class="el" href="Champ__front_8h_source.html#l00030">Deriv_Champ_front_base::valeur()</a>.</p>

<p>Referenced by <a class="el" href="Assembleur__P__VDF_8cpp_source.html#l00498">modifier_secmem()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">const</span> <a class="code" href="classChamp__front__base.html" title="classe Champ_front_base Classe de base pour la hierarchie des champs aux frontieres. Un objet Champ_front_base definit un champ sur la frontiere d&#39;un domaine. Un objet de type Champ_front_base sera associe a chaque condition aux limites. Champ_front_base derive de Champ_Proto, afin d&#39;avoir une interface conforme a tous les champs, et d&#39;heriter des operations courantes sur les Champs. Les deux methodes principales sont initialiser et mettre_a_jour. Ce sont les deux seules qui peuvent modifier les valeurs du champ. La methode initialiser est appelee une fois au debut du calcul. Elle ne doit pas dependre de donnees exterieures a l&#39;equation qui porte la CL (en effet, rien ne garantit que ces donnees sont initialisees). En revanche, les valeurs de l&#39;inconnue sur laquelle porte la CL peuvent etre utiles pour l&#39;initialisation =&gt; l&#39;inconnue est passee en parametre en lecture seule. La methode mettre_a_jour est appelee au debut de chaque pas de temps ou sous-pas-de-temps, elle peut utiliser des donnees exterieures a l&#39;equation. A charge a l&#39;algorithme de s&#39;assurer que ces donnees sont pertinentes... Dans le cas de champs stationnaires, la methode mettre_a_jour n&#39;a rien a faire et les valeurs sont remplies une fois pour toutes par la methode initialiser. Dans le cas de champs instationnaires, il y a plusieurs valeurs en temps et chacune peut etre mise a jour. Les Champ_front sont divises en : * Champ_front_uniforme, constant dans le temps et l&#39;espace * Champ_front_instationnaire_base, uniformes en espace mais variables en temps * Champ_front_var, variables en espace. Les Champ_front_var sont ensuite classes selon qu&#39;ils sont stationnaires ou instationnaires. Les valeurs sont stockees dans une roue de DoubleTab. Si le champ est uniforme en espace, les DoubleTab sont dimensionnes a 1. S&#39;il est stationnaire, la roue n&#39;a qu&#39;une valeur temporelle et le temps qui lui est assigne n&#39;a pas de sens. S&#39;il est instationnaire, les valeurs temporelles sont celles de l&#39;inconnue de l&#39;equation a laquelle se rapporte le champ.">Champ_front_base</a>&amp; champ_front = cond_lim.<a class="code" href="classCond__lim__base.html#a8cddc02f544ee44bebd5bae0e6a9581c">champ_front</a>().<a class="code" href="classDeriv__Champ__front__base.html#a5405a20c106b868a23805a45c4436a53">valeur</a>();
  <span class="keyword">const</span> <a class="code" href="classZone__VDF.html" title="class Zone_VDF Classe instanciable qui derive de Zone_VF. Cette classe contient les informations geom...">Zone_VDF</a>&amp; la_zone = <a class="code" href="classAssembleur__P__VDF.html#a4ce1358c35e162057c7968aa583cd581">la_zone_VDF</a>.<a class="code" href="classRef__Zone__VDF.html#a84151da4db745d02791d6246e3682b67">valeur</a>();
  <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; face_surfaces = la_zone.<a class="code" href="classZone__VF.html#a40c3382b189a4fc508cf1c3e37b04b21">face_surfaces</a>();
  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; face_voisins = la_zone.<a class="code" href="classZone__VF.html#a49d4322f5585a8fa95748ca785b70702" title="renvoie l&#39;element voisin de numface dans la direction i. i=0 : dans le sens oppose de l&#39;axe orthogona...">face_voisins</a>();

  <span class="keywordflow">if</span> (<a class="code" href="classAssembleur__base.html#a3744c3df3886e9fc65246c2eb1abb794" title="Renvoie la valeur du drapeau resoudre_en_u_ (0 ou 1) Renvoie -1 si le drapeau n&#39;a pas ete initialise...">get_resoudre_en_u</a>())
    {
      <span class="keywordtype">int</span> gpoint_variable;
      <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classChamp__front__instationnaire__base.html" title="classe Champ_front_base Classe de base pour les Champs aux frontieres instationnaires, mais uniformes en espace. Les aspects temporels sont equivalents a ceux de Ch_front_var_instationnaire. En revanche, le tableau de valeurs est dimensionne a une seule valeur et n&#39;a pas d&#39;espace virtuel.">Champ_front_instationnaire_base</a>, champ_front))
        gpoint_variable = 0; <span class="comment">//!&lt; Instationnaire uniforme</span>
<span class="comment"></span>      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classChamp__front__var__instationnaire.html" title="classe Champ_front_var_instationnaire Classe derivee de Champ_front_var qui represente les champs aux...">Champ_front_var_instationnaire</a>, champ_front))
        gpoint_variable = 1; <span class="comment">//!&lt; Instationnaire variable</span>
<span class="comment"></span>      <span class="keywordflow">else</span>
        gpoint_variable = -1; <span class="comment">//!&lt; Stationnaire</span>
<span class="comment"></span>
      <span class="keywordflow">if</span> (gpoint_variable &gt;= 0)
        {
          <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; tab_gpoint = (gpoint_variable)
                                        ? <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classChamp__front__var__instationnaire.html" title="classe Champ_front_var_instationnaire Classe derivee de Champ_front_var qui represente les champs aux...">Champ_front_var_instationnaire</a>,  champ_front).Gpoint()
                                        : <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classChamp__front__instationnaire__base.html" title="classe Champ_front_base Classe de base pour les Champs aux frontieres instationnaires, mais uniformes en espace. Les aspects temporels sont equivalents a ceux de Ch_front_var_instationnaire. En revanche, le tableau de valeurs est dimensionne a une seule valeur et n&#39;a pas d&#39;espace virtuel.">Champ_front_instationnaire_base</a>, champ_front).Gpoint();

          <span class="keyword">const</span> <span class="keywordtype">int</span> nb_faces = frontiere_vf.<a class="code" href="classFront__VF.html#a341e2fcb5117b96e745fd7078ba86bab" title="Nombre de faces reelles du bord.">nb_faces</a>();
          <span class="keyword">const</span> <span class="keywordtype">int</span> num_premiere_face = frontiere_vf.<a class="code" href="classFront__VF.html#a4986f0c65653fe9eb40bbbff5a97bf16" title="Numero de la premiere face du bord dans la liste des faces.">num_premiere_face</a>();
          <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; nb_faces; i++)
            {
              <span class="keyword">const</span> <span class="keywordtype">int</span> num_face = num_premiere_face + i;
              <span class="keyword">const</span> <span class="keywordtype">double</span> surface = face_surfaces(num_face);
              <span class="keyword">const</span> <span class="keywordtype">int</span> elem0 = face_voisins(num_face, 0);
              <span class="keyword">const</span> <span class="keywordtype">int</span> elem1 = face_voisins(num_face, 1);
<span class="comment">// gpoint est relatif a la normale a la face (elle pointe vers elem1)</span>
<span class="comment">// La normale est-elle entrante ou sortante ?</span>
              <span class="keyword">const</span> <span class="keywordtype">double</span> signe = (elem0 &lt; 0) ? 1. : -1.;
<span class="comment">// Numero de l&#39;element adjacent a la face de bord</span>
              <span class="keyword">const</span> <span class="keywordtype">int</span> elem = elem0 + elem1 + 1;
              <span class="keyword">const</span> <span class="keywordtype">int</span> ori = la_zone.<a class="code" href="classZone__VDF.html#a9a9bd747218e463b3408a3590c12814c" title="inline DoubleVect&amp; Zone_VDF::porosite_face() { return porosite_face_; }">orientation</a>(num_face);
              <span class="keyword">const</span> <span class="keywordtype">double</span> gpoint = (gpoint_variable) ? tab_gpoint(i, ori) : tab_gpoint(ori);

              secmem[elem] += signe * surface * gpoint;
            }
        }
      <span class="keywordflow">else</span>
        {
<span class="comment">// Le champ frontiere est stationnaire, rien a faire.</span>
        }
    }
  <span class="keywordflow">else</span>
    {
<span class="comment">// Resolution en pression: la condition aux limites est imposee ailleurs</span>
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a47e1e481696ee70a0a542926e77573b2"></a><!-- doxytag: member="Assembleur_P_VDF::modifier_solution" ref="a47e1e481696ee70a0a542926e77573b2" args="(DoubleTab &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Assembleur_P_VDF::modifier_solution </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>pression</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implements <a class="el" href="classAssembleur__base.html#ab63a4124e6e959dc5986c566748422f6">Assembleur_base</a>.</p>

<p>Definition at line <a class="el" href="Assembleur__P__VDF_8cpp_source.html#l00658">658</a> of file <a class="el" href="Assembleur__P__VDF_8cpp_source.html">Assembleur_P_VDF.cpp</a>.</p>

<p>References <a class="el" href="Double_8h_source.html#l00072">DMAXFLOAT</a>, <a class="el" href="DoubleVect_8cpp_source.html#l00277">DoubleVect::echange_espace_virtuel()</a>, <a class="el" href="Assembleur__P__VDF_8h_source.html#l00073">has_P_ref</a>, <a class="el" href="Assembleur__P__VDF_8h_source.html#l00068">la_zone_VDF</a>, <a class="el" href="Process_8cpp_source.html#l00167">Process::mp_min()</a>, <a class="el" href="Zone_8h_source.html#l00300">Zone::nb_elem()</a>, <a class="el" href="Ref__Zone__VDF_8h_source.html#l00028">Ref_Zone_VDF::valeur()</a>, and <a class="el" href="Zone__dis__base_8h_source.html#l00106">Zone_dis_base::zone()</a>.</p>
<div class="fragment"><pre class="fragment">{
<span class="comment">// Projection :</span>
  <span class="keywordtype">double</span> press_0;
  <span class="keywordflow">if</span>(!<a class="code" href="classAssembleur__P__VDF.html#a9d277900967c598cd61dcc14dcb7ebbd">has_P_ref</a>)
    {
<span class="comment">// On prend la pression minimale comme pression de reference</span>
<span class="comment">// afin d&#39;avoir la meme pression de reference en sequentiel et parallele</span>
      press_0=<a class="code" href="Double_8h.html#ae0ee0cebfad5968da0ad6cc7a49e16b6">DMAXFLOAT</a>;
      <span class="keywordtype">int</span> nb_elem=<a class="code" href="classAssembleur__P__VDF.html#a4ce1358c35e162057c7968aa583cd581">la_zone_VDF</a>.<a class="code" href="classRef__Zone__VDF.html#a84151da4db745d02791d6246e3682b67">valeur</a>().<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#a7f249429803b27139a1c54436f6164a5" title="Renvoie le nombre d&#39;elements de la zone.">nb_elem</a>();
      <span class="keywordflow">for</span>(<span class="keywordtype">int</span> n=0; n&lt;nb_elem; n++)
        <span class="keywordflow">if</span> (pression[n] &lt; press_0)
          press_0 = pression[n];
      press_0 = <a class="code" href="classProcess.html#a05de57db7288d95f9e67046af585d5ff" title="Calcule le min de x sur tous les processeurs du groupe courant. Voir aussi mp_max()">mp_min</a>(press_0);
      pression -=press_0;
      pression.<a class="code" href="classDoubleVect.html#abfebbc2f685ce7bc4b80c720d7da9bf3">echange_espace_virtuel</a>();
    }
  <span class="keywordflow">return</span> 1;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a2b5c25eb00889312bb6e6dc92e1d2616"></a><!-- doxytag: member="Assembleur_P_VDF::printOn" ref="a2b5c25eb00889312bb6e6dc92e1d2616" args="(Sortie &amp;x) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSortie.html">Sortie</a> &amp; Assembleur_P_VDF::printOn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSortie.html">Sortie</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td> const<code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Ecriture de l'objet sur un flot de sortie<br/>
Methode a surcharger. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="classSortie.html" title="Classe de base des flux de sortie. Elle sait ecrire des types simples&lt;br&gt;(entiers, flottants) et des Ob...">Sortie</a>&amp;<br/>
 Signification: flot de sortie modifie<br/>
 Contraintes: </dd></dl>

<p>Reimplemented from <a class="el" href="classAssembleur__base.html#a096c4e5f1a2a51307108da677e5d6f06">Assembleur_base</a>.</p>

<p>Definition at line <a class="el" href="Assembleur__P__VDF_8cpp_source.html#l00047">47</a> of file <a class="el" href="Assembleur__P__VDF_8cpp_source.html">Assembleur_P_VDF.cpp</a>.</p>

<p>References <a class="el" href="Objet__U_8cpp_source.html#l00260">Objet_U::le_nom()</a>, and <a class="el" href="Objet__U_8cpp_source.html#l00132">Objet_U::que_suis_je()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">return</span> s &lt;&lt; <a class="code" href="classObjet__U.html#aa58e9a81c0ddc2c1149053b8f96698ac" title="renvoie la chaine identifiant la classe.">que_suis_je</a>() &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; <a class="code" href="classObjet__U.html#a70413a8785d36bf5105fced1c89d0d2b" title="Donne le nom de l&#39;Objet_U Methode a surcharger : renvoie &quot;neant&quot; dans cette implementation.">le_nom</a>() ;
}
</pre></div>
</div>
</div>
<a class="anchor" id="adba7dcdab645b9099b6134d74189677b"></a><!-- doxytag: member="Assembleur_P_VDF::readOn" ref="adba7dcdab645b9099b6134d74189677b" args="(Entree &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEntree.html">Entree</a> &amp; Assembleur_P_VDF::readOn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEntree.html">Entree</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Lecture d'un <a class="el" href="classObjet__U.html" title="classe Objet_U Cette classe est la classe de base des Objets de TRUST Dans les classes derivees de Ob...">Objet_U</a> sur un flot d'entree<br/>
Methode a surcharger. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="classEntree.html" title="Classe de definition des operateurs et methodes pour toute lecture dans un flot d&#39;entree (fichier...">Entree</a>&amp; s<br/>
 Signification: flot d'entree modifie<br/>
 Contraintes: </dd></dl>

<p>Reimplemented from <a class="el" href="classAssembleur__base.html#a8452c201d13e41f0bf3b524af55c72e6">Assembleur_base</a>.</p>

<p>Definition at line <a class="el" href="Assembleur__P__VDF_8cpp_source.html#l00052">52</a> of file <a class="el" href="Assembleur__P__VDF_8cpp_source.html">Assembleur_P_VDF.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">return</span> <a class="code" href="classAssembleur__P__VDF.html#adba7dcdab645b9099b6134d74189677b" title="Lecture d&#39;un Objet_U sur un flot d&#39;entree Methode a surcharger.">Assembleur_base::readOn</a>(s);
}
</pre></div>
</div>
</div>
<a class="anchor" id="ae6419915244b87d5c8f186d7c4fc1992"></a><!-- doxytag: member="Assembleur_P_VDF::remplir" ref="ae6419915244b87d5c8f186d7c4fc1992" args="(Matrice &amp;la_matrice, const DoubleVect &amp;volumes_entrelaces, const Champ_Don_base *rho_ptr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Assembleur_P_VDF::remplir </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMatrice.html">Matrice</a> &amp;&#160;</td>
          <td class="paramname"><em>la_matrice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;&#160;</td>
          <td class="paramname"><em>volumes_entrelaces</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classChamp__Don__base.html">Champ_Don_base</a> *&#160;</td>
          <td class="paramname"><em>rho_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calcul des coefficients de la matrice de pression avec un champ de rho.<br/>
Si rho_ptr == 0, on calcule la matrice -div( porosite * grad P ),<br/>
sinon on calcule -div( porosite/rho grad P ) et *rho_ptr doit etre un <a class="el" href="classChamp__Fonc__Face.html" title="classe Champ_Fonc_Face">Champ_Fonc_Face</a>. </p>

<p><p>&lt; Indice fortran Indice fortran de l'element diagonal (elem0, elem0)</p>
<p>&lt; a la ligne elem1+1 Indice fortran de l'element extradiagonal (elem0, elem1)</p>
<p>&lt; Indice fortran dans tab2 Coefficient extra-diagonal</p>
<p>&lt; Indice fortran </p>
</p>

<p>Definition at line <a class="el" href="Assembleur__P__VDF_8cpp_source.html#l00303">303</a> of file <a class="el" href="Assembleur__P__VDF_8cpp_source.html">Assembleur_P_VDF.cpp</a>.</p>

<p>References <a class="el" href="Objet__U_8h_source.html#l00083">Objet_U::bidim_axi</a>, <a class="el" href="Double_8h_source.html#l00098">carre()</a>, <a class="el" href="EntreeSortie_8h_source.html#l00032">Cerr</a>, <a class="el" href="Option__VDF_8h_source.html#l00040">Option_VDF::coeff_P_neumann</a>, <a class="el" href="Double_8h_source.html#l00273">est_egal()</a>, <a class="el" href="Process_8cpp_source.html#l00223">Process::exit()</a>, <a class="el" href="Zone__VF_8h_source.html#l00054">Zone_VF::face_surfaces()</a>, <a class="el" href="Zone__VF_8h_source.html#l00458">Zone_VF::face_voisins()</a>, <a class="el" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>, <a class="el" href="Cond__lim__base_8h_source.html#l00123">Cond_lim_base::frontiere_dis()</a>, <a class="el" href="Matrice__Bloc_8cpp_source.html#l00568">Matrice_Bloc::get_bloc()</a>, <a class="el" href="Assembleur__P__VDF_8h_source.html#l00073">has_P_ref</a>, <a class="el" href="Assembleur__P__VDF_8h_source.html#l00069">la_zone_Cl_VDF</a>, <a class="el" href="Assembleur__P__VDF_8h_source.html#l00068">la_zone_VDF</a>, <a class="el" href="Frontiere__dis__base_8cpp_source.html#l00146">Frontiere_dis_base::le_nom()</a>, <a class="el" href="Assembleur__P__VDF_8h_source.html#l00070">les_coeff_pression</a>, <a class="el" href="Zone__Cl__dis__base_8cpp_source.html#l00522">Zone_Cl_dis_base::les_conditions_limites()</a>, <a class="el" href="Assembleur__P__VDF_8cpp_source.html#l00065">liste_faces_periodiques()</a>, <a class="el" href="Process_8cpp_source.html#l00156">Process::mp_max()</a>, <a class="el" href="Zone__dis__base_8h_source.html#l00140">Zone_dis_base::nb_elem()</a>, <a class="el" href="Front__VF_8h_source.html#l00061">Front_VF::nb_faces()</a>, <a class="el" href="Zone__VF_8h_source.html#l00565">Zone_VF::nb_faces_internes()</a>, <a class="el" href="Front__VF_8h_source.html#l00071">Front_VF::num_premiere_face()</a>, <a class="el" href="Zone__VF_8h_source.html#l00285">Zone_VF::porosite_face()</a>, <a class="el" href="Objet__U_8h_source.html#l00080">Objet_U::precision_geom</a>, <a class="el" href="Zone__VF_8h_source.html#l00512">Zone_VF::premiere_face_int()</a>, <a class="el" href="Cast_8h_source.html#l00059">ref_cast</a>, <a class="el" href="vect__impl_8h_source.html#l00057">vect_impl::size()</a>, <a class="el" href="Cast_8h_source.html#l00054">sub_type</a>, <a class="el" href="Ref__Zone__Cl__VDF_8h_source.html#l00028">Ref_Zone_Cl_VDF::valeur()</a>, <a class="el" href="Deriv__Matrice__Base_8h_source.html#l00028">Deriv_Matrice_Base::valeur()</a>, <a class="el" href="Ref__Zone__VDF_8h_source.html#l00028">Ref_Zone_VDF::valeur()</a>, and <a class="el" href="Champ__Don__base_8cpp_source.html#l00271">Champ_Don_base::valeurs()</a>.</p>

<p>Referenced by <a class="el" href="Assembleur__P__VDF_8cpp_source.html#l00697">assembler()</a>, <a class="el" href="Assembleur__P__VDF_8cpp_source.html#l00677">assembler_mat()</a>, <a class="el" href="Assembleur__P__VDF_8cpp_source.html#l00764">assembler_QC()</a>, and <a class="el" href="Assembleur__P__VDF_8cpp_source.html#l00722">assembler_rho_variable()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">const</span> <a class="code" href="classZone__VDF.html" title="class Zone_VDF Classe instanciable qui derive de Zone_VF. Cette classe contient les informations geom...">Zone_VDF</a>&amp; zone_vdf   = <a class="code" href="classAssembleur__P__VDF.html#a4ce1358c35e162057c7968aa583cd581">la_zone_VDF</a>.<a class="code" href="classRef__Zone__VDF.html#a84151da4db745d02791d6246e3682b67">valeur</a>();
  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; face_voisins = zone_vdf.<a class="code" href="classZone__VF.html#a49d4322f5585a8fa95748ca785b70702" title="renvoie l&#39;element voisin de numface dans la direction i. i=0 : dans le sens oppose de l&#39;axe orthogona...">face_voisins</a>();
  <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; face_surfaces = zone_vdf.<a class="code" href="classZone__VF.html#a40c3382b189a4fc508cf1c3e37b04b21">face_surfaces</a>();
<span class="comment">// const DoubleVect &amp; volumes_entrelaces = zone_vdf.volumes_entrelaces();</span>
  <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; porosite_face = zone_vdf.<a class="code" href="classZone__VF.html#ad9d74d1d9da9f50ab26768dbbca7711b">porosite_face</a>();


  <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a> * valeurs_rho = 0;
  <span class="keywordflow">if</span> (rho_ptr)
    {
      assert(<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classChamp__Fonc__Face.html" title="classe Champ_Fonc_Face">Champ_Fonc_Face</a>, *rho_ptr));
      valeurs_rho = &amp; (rho_ptr-&gt;<a class="code" href="classChamp__Don__base.html#ac0ac51817e03e27c28d2b96bb15db9a0" title="Surcharge Champ_base::valeurs() Renvoie le tableau des valeurs.">valeurs</a>());
    }

<span class="comment">// Raccourcis vers la partie carree (coefficients elements reels/reels)</span>
<span class="comment">// et la partie rectangulaire (elements reels / elements virtuels) de la matrice</span>
  <a class="code" href="classMatrice__Bloc.html">Matrice_Bloc</a>&amp; matrice = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Bloc.html">Matrice_Bloc</a>, la_matrice.<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>());
  <a class="code" href="classMatrice__Morse__Sym.html" title="Classe Matrice_Morse_Sym Represente une matrice M (creuse) symetrique stockee au format Morse Symetri...">Matrice_Morse_Sym</a>&amp; <a class="code" href="Double_8h.html#aa4be1ab61f49e9ebb241ed3f4957fd4a" title="fonctions utiles sur les double">carre</a> = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Morse__Sym.html" title="Classe Matrice_Morse_Sym Represente une matrice M (creuse) symetrique stockee au format Morse Symetri...">Matrice_Morse_Sym</a>, matrice.<a class="code" href="classMatrice__Bloc.html#a7ffa38f7b93454432b2df7c616ed0a4e">get_bloc</a>(0,0).<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>());
  <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp;      rect  = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>,     matrice.<a class="code" href="classMatrice__Bloc.html#a7ffa38f7b93454432b2df7c616ed0a4e">get_bloc</a>(0,1).<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>());

  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_elem = zone_vdf.<a class="code" href="classZone__dis__base.html#a790cb2f6bc2928518799e748313d0eb3">nb_elem</a>();
  <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> carre_nb_non_zero(nb_elem);
  <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> rect_nb_non_zero(nb_elem);
  carre_nb_non_zero = 1;
  rect_nb_non_zero = 0;

  <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; carre_tab1 = carre.get_set_tab1();
  <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; rect_tab1 = rect.get_set_tab1();
  <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a>&amp; carre_coeff = carre.get_set_coeff();
  <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a>&amp; rect_coeff = rect.get_set_coeff();

  carre_coeff = 0.;
  rect_coeff = 0.;

<span class="comment">// Traitement des faces internes et periodiques :</span>
<span class="comment">// Pour chaque face entre deux elements elem0 et elem1, y a quatre termes a ajouter :</span>
<span class="comment">// M(elem0,elem0)</span>
<span class="comment">// M(elem0,elem1)</span>
<span class="comment">// M(elem1,elem1)</span>
<span class="comment">// M(elem1,elem0)  (omis car la matrice est stockee symetrique)</span>

<span class="comment">// Construction de la liste des faces periodiques</span>
  <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> liste_faces_perio;
  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_faces_periodiques = <a class="code" href="classAssembleur__P__VDF.html#a48da6c5fc5769465a659da41fab00812" title="Remplit le tableau faces avec la liste des indices des faces periodiques dans le tableau faces_voisin...">liste_faces_periodiques</a>(liste_faces_perio);
  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_faces_internes = zone_vdf.<a class="code" href="classZone__VF.html#a1210c3de419eab8ce27debddd632218e" title="une face est interne ssi elle separe deux elements. renvoie le nombre de faces internes.">nb_faces_internes</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> premiere_face_interne = zone_vdf.<a class="code" href="classZone__VF.html#a12869806fa4834aca8f2964e16509dfd" title="une face est interne ssi elle separe deux elements. renvoie le numero de la premiere face interne...">premiere_face_int</a>();
  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i_face = 0; i_face &lt; nb_faces_internes + nb_faces_periodiques; i_face++)
    {

<span class="comment">// Calcul du numero de la face a traiter</span>
      <span class="keyword">const</span> <span class="keywordtype">int</span> num_face = (i_face &lt; nb_faces_internes)
                           ? premiere_face_interne + i_face
                           : liste_faces_perio[i_face - nb_faces_internes];
<span class="comment">// Calcul de rho sur cette face</span>
      <span class="keyword">const</span> <span class="keywordtype">double</span> rho_face = (valeurs_rho) ? (*valeurs_rho)[num_face] : 1.;
<span class="comment">// Calcul du coefficient</span>
      <span class="keyword">const</span> <span class="keywordtype">double</span> surface  = face_surfaces[num_face];
      <span class="keyword">const</span> <span class="keywordtype">double</span> volume   = volumes_entrelaces[num_face];
      <span class="keyword">const</span> <span class="keywordtype">double</span> porosite = porosite_face[num_face];
      <span class="keyword">const</span> <span class="keywordtype">double</span> coefficient = surface * surface * porosite / (volume * rho_face);
<span class="comment">// Numeros des deux elements voisins (le plus petit dans elem0)</span>
      <span class="keywordtype">int</span> elem0 = face_voisins(num_face,0);
      <span class="keywordtype">int</span> elem1 = face_voisins(num_face,1);
      <span class="keywordflow">if</span> (elem0 &gt; elem1)
        {
          <span class="keywordtype">int</span> tmp = elem1;
          elem1 = elem0;
          elem0 = tmp;
        }
      <span class="keywordflow">if</span> (elem0 &lt; nb_elem)
        {
<span class="comment">// elem0 est reel</span>
          <span class="keyword">const</span> <span class="keywordtype">int</span> ligne = elem0 + 1;   <span class="comment">//!&lt; Indice fortran Indice fortran de l&#39;element diagonal (elem0, elem0)</span>
<span class="comment"></span><span class="comment">//</span>
          <span class="keyword">const</span> <span class="keywordtype">int</span> index_diag = carre_tab1[ligne-1];
          carre_coeff[index_diag - 1] += coefficient;
          <span class="keywordflow">if</span> (elem1 &lt; nb_elem)
            {
<span class="comment">// elem1 est reel aussi</span>
<span class="comment">// Indice fortran de l&#39;element diagonal (elem1, elem1)</span>
              <span class="keyword">const</span> <span class="keywordtype">int</span> index_diag1 = carre_tab1[elem1]; <span class="comment">//!&lt; a la ligne elem1+1 Indice fortran de l&#39;element extradiagonal (elem0, elem1)</span>
<span class="comment"></span><span class="comment">//</span>
              <span class="keyword">const</span> <span class="keywordtype">int</span> n = carre_nb_non_zero[ligne-1]++;
              <span class="keyword">const</span> <span class="keywordtype">int</span> index = index_diag + n;
<span class="comment">// Coefficient diagonal</span>
              carre_coeff[index_diag1 - 1] += coefficient;
<span class="comment">// Coefficient extra-diagonal</span>
              carre_coeff[index - 1] = - coefficient;
              assert(carre.get_tab2()(index - 1) == elem1 + 1);
            }
          <span class="keywordflow">else</span>
            {
<span class="comment">// elem1 est virtuel</span>
              <span class="keyword">const</span> <span class="keywordtype">int</span> n = rect_nb_non_zero[ligne-1]++;
              <span class="keyword">const</span> <span class="keywordtype">int</span> index = rect_tab1[ligne-1] + n; <span class="comment">//!&lt; Indice fortran dans tab2 Coefficient extra-diagonal</span>
<span class="comment"></span><span class="comment">//</span>
              rect_coeff[index - 1] = - coefficient;
              assert(rect.get_tab2()(index - 1) == elem1 - nb_elem + 1);
            }
        }
    }

<span class="comment">// Traitement des conditions aux limites</span>
  <span class="keyword">const</span> <a class="code" href="classConds__lim.html">Conds_lim</a>&amp; les_cl = <a class="code" href="classAssembleur__P__VDF.html#a0b984a6831f2750865e12296e5e07a2b">la_zone_Cl_VDF</a>.<a class="code" href="classRef__Zone__Cl__VDF.html#a1e655604e840cda5b393e45f975b73ff">valeur</a>().<a class="code" href="classZone__Cl__dis__base.html#af75e0ed7786863e4d333bfb29d67c323" title="Renvoie la i-ieme condition aux limites. (version const)">les_conditions_limites</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_cl = les_cl.<a class="code" href="classvect__impl.html#a78155bfbd6b61f4710b9830641ed1694">size</a>();
  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> num_cl = 0; num_cl &lt; nb_cl; num_cl++)
    {
      <span class="keyword">const</span> <a class="code" href="classCond__lim__base.html" title="classe Cond_lim_base Classe de base pour la hierarchie des classes qui representent les differentes c...">Cond_lim_base</a>&amp; la_cl = les_cl[num_cl].valeur();
      <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp; la_front_dis = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>,la_cl.<a class="code" href="classCond__lim__base.html#ad88b3b516351146c85e8fce1df0f691a" title="Renvoie la frontiere discretisee a laquelle les conditions aux limites s&#39;appliquent.">frontiere_dis</a>());

<span class="comment">// Test sur les conditions limites en 2D RZ (on doit avoir symetrie selon l&#39;axe de revolution)</span>
      <span class="keywordflow">if</span> (<a class="code" href="classObjet__U.html#a9a47c1add9760324894500792c17a178">bidim_axi</a> &amp;&amp; !<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classSymetrie.html" title="classe Symetrie Sur les faces de symetrie on a les proprietes suivantes: - composante normale de la v...">Symetrie</a>,la_cl))
        {
          <span class="keyword">const</span> <span class="keywordtype">int</span> ndeb = la_front_dis.<a class="code" href="classFront__VF.html#a4986f0c65653fe9eb40bbbff5a97bf16" title="Numero de la premiere face du bord dans la liste des faces.">num_premiere_face</a>();
          <span class="keyword">const</span> <span class="keywordtype">int</span> nfin = ndeb + la_front_dis.<a class="code" href="classFront__VF.html#a341e2fcb5117b96e745fd7078ba86bab" title="Nombre de faces reelles du bord.">nb_faces</a>();
          <span class="keywordflow">if</span> (nfin&gt;ndeb &amp;&amp; <a class="code" href="Double_8h.html#ac86f5f350b0f95fd8c34b0ac8d720f6f">est_egal</a>(face_surfaces[ndeb],0))
            {
              <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;\nFirst face surface is smaller than PrecisionGeom = &quot;</span> &lt;&lt; <a class="code" href="classObjet__U.html#a7447e25c68cc8d3a1c06cf99f0565cff">precision_geom</a> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
              <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;May be you have an error in the definition of the boundary conditions.&quot;</span> &lt;&lt; finl;
              <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;The axis of revolution for this 2D calculation is along Y.&quot;</span> &lt;&lt; finl;
              <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;So you must specify symmetry boundary condition (symetrie keyword) for the boundary &quot;</span> &lt;&lt; la_front_dis.<a class="code" href="classFrontiere__dis__base.html#a5a7eb46dc3af8a7d4225adc1814845d8" title="Renvoie le nom de la frontiere geometrique.">le_nom</a>() &lt;&lt; finl;
              <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">exit</a>();
            }
        }

<span class="comment">// Pour chaque face de bord entre elem0 et un element fictif exterieur</span>
<span class="comment">// a pression imposee P0, on a :</span>
<span class="comment">// grad P = (P(elem0) - P0) * surface / volume_entrelace</span>
<span class="comment">// elem0 est une inconnue, P0 est ajoute au second membre dans &quot;modifier_secmem&quot;.</span>
      <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classNeumann__sortie__libre.html" title="classe Neumann_sortie_libre Cette classe represente une frontiere ouverte sans vitesse imposee Pour l...">Neumann_sortie_libre</a>,la_cl))
        {
          <a class="code" href="classAssembleur__P__VDF.html#a9d277900967c598cd61dcc14dcb7ebbd">has_P_ref</a> = 1;
          carre.set_est_definie(1);
          <span class="keyword">const</span> <span class="keywordtype">int</span> ndeb = la_front_dis.<a class="code" href="classFront__VF.html#a4986f0c65653fe9eb40bbbff5a97bf16" title="Numero de la premiere face du bord dans la liste des faces.">num_premiere_face</a>();
          <span class="keyword">const</span> <span class="keywordtype">int</span> nfin = ndeb + la_front_dis.<a class="code" href="classFront__VF.html#a341e2fcb5117b96e745fd7078ba86bab" title="Nombre de faces reelles du bord.">nb_faces</a>();
          <span class="keywordflow">for</span> (<span class="keywordtype">int</span> num_face = ndeb; num_face &lt; nfin; num_face++)
            {
<span class="comment">// Calcul de rho sur cette face</span>
              <span class="keyword">const</span> <span class="keywordtype">double</span> rho_face = (valeurs_rho) ? (*valeurs_rho)[num_face] : 1.;
<span class="comment">// Calcul du coefficient a ajouter dans la matrice</span>
              <span class="keyword">const</span> <span class="keywordtype">double</span> surface  = face_surfaces[num_face];
<span class="comment">// Attention: le volume entrelace a une valeur particuliere au bord</span>
<span class="comment">// (voir Zone_VDF::calculer_volumes_entrelaces() )</span>
              <span class="keyword">const</span> <span class="keywordtype">double</span> volume   = volumes_entrelaces[num_face];
              <span class="keyword">const</span> <span class="keywordtype">double</span> porosite = porosite_face[num_face];
              <span class="keyword">const</span> <span class="keywordtype">double</span> coefficient = <a class="code" href="classOption__VDF.html#abc56a584319b990ca8259b5219d28270">Option_VDF::coeff_P_neumann</a> * surface * surface * porosite / (volume * rho_face);
              assert(coefficient &gt; 0.);
<span class="comment">// Numero de l&#39;element voisin (l&#39;un est -1, l&#39;autre est un element reel)</span>
              <span class="keyword">const</span> <span class="keywordtype">int</span> elem0 = face_voisins(num_face, 0);
              <span class="keyword">const</span> <span class="keywordtype">int</span> elem1 = face_voisins(num_face, 1);
              assert(elem0 == -1 || elem1 == -1);
              <span class="keyword">const</span> <span class="keywordtype">int</span> elem = elem0 + elem1 + 1;
<span class="comment">// Ajout du coefficient a la matrice</span>
              assert(elem &lt; nb_elem);
              <span class="keyword">const</span> <span class="keywordtype">int</span> index = carre_tab1[elem]; <span class="comment">//!&lt; Indice fortran</span>
<span class="comment"></span>              carre_coeff[index - 1] += coefficient;
              <a class="code" href="classAssembleur__P__VDF.html#af8eca29a2e48d27e8e1f77e0945dc38d">les_coeff_pression</a>[num_face] = coefficient;
            }
        }
      <span class="keywordflow">else</span>
        {
<span class="comment">// Pour les autres conditions aux limites, aucun terme supplementaire dans</span>
<span class="comment">// la matrice (grad P scalaire n = 0 sur le bord,</span>
<span class="comment">// ou derivee en temps de grad P scalaire n = 0 sur le bord)</span>
        }
    }
  <a class="code" href="classAssembleur__P__VDF.html#a9d277900967c598cd61dcc14dcb7ebbd">has_P_ref</a> = (int)<a class="code" href="classProcess.html#a1e9d9f9899b71927cfafae14c7bd048d" title="Calcule le max de x sur tous les processeurs du groupe courant. Remarques : Cette methode doit etre a...">mp_max</a>(<a class="code" href="classAssembleur__P__VDF.html#a9d277900967c598cd61dcc14dcb7ebbd">has_P_ref</a>);

<span class="comment">// Verification sanitaire: pas d&#39;element nul sur la diagonale</span>
  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; nb_elem; i++)
    {
      <span class="keyword">const</span> <span class="keywordtype">int</span> index = carre_tab1[i];
      <span class="keyword">const</span> <span class="keywordtype">double</span> coeff_diagonal = carre_coeff[index - 1];
      <span class="keywordflow">if</span> (coeff_diagonal == 0.)
        {
<span class="comment">// La maille i n&#39;a pas de voisin: pression quelconque</span>
          carre_coeff[index - 1] = 1.;
        }
    }

  carre.compacte();
  rect.compacte();
  <span class="keywordflow">return</span> 1;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a2a50db3de619951c7d56894bfafefc25"></a><!-- doxytag: member="Assembleur_P_VDF::self_cast" ref="a2a50db3de619951c7d56894bfafefc25" args="(Objet_U &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAssembleur__P__VDF.html">Assembleur_P_VDF</a> &amp; Assembleur_P_VDF::self_cast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classObjet__U.html">Objet_U</a> &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="classAssembleur__base.html#a225f2d2435bd0363fdc04831214a6409">Assembleur_base</a>.</p>

<p>Definition at line <a class="el" href="Assembleur__P__VDF_8cpp_source.html#l00040">40</a> of file <a class="el" href="Assembleur__P__VDF_8cpp_source.html">Assembleur_P_VDF.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a651e1b3f00736a77995dda8af15c21b3"></a><!-- doxytag: member="Assembleur_P_VDF::self_cast" ref="a651e1b3f00736a77995dda8af15c21b3" args="(const Objet_U &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classAssembleur__P__VDF.html">Assembleur_P_VDF</a> &amp; Assembleur_P_VDF::self_cast </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classObjet__U.html">Objet_U</a> &amp;&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>methode ajoutee pour caster en python </p>

<p>Reimplemented from <a class="el" href="classAssembleur__base.html#a2cffd0bbc2b3d80b9a01a70c21521a9b">Assembleur_base</a>.</p>

<p>Definition at line <a class="el" href="Assembleur__P__VDF_8cpp_source.html#l00040">40</a> of file <a class="el" href="Assembleur__P__VDF_8cpp_source.html">Assembleur_P_VDF.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3c2e1cb318b4ae7a999f4baaf39a12d0"></a><!-- doxytag: member="Assembleur_P_VDF::taille_memoire" ref="a3c2e1cb318b4ae7a999f4baaf39a12d0" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned Assembleur_P_VDF::taille_memoire </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implements <a class="el" href="classObjet__U.html#a0ee0946339f09a2c73c09fcda71c3be2">Objet_U</a>.</p>

<p>Definition at line <a class="el" href="Assembleur__P__VDF_8cpp_source.html#l00040">40</a> of file <a class="el" href="Assembleur__P__VDF_8cpp_source.html">Assembleur_P_VDF.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="adf03371f0f2cb7af8d04c4f6154588f1"></a><!-- doxytag: member="Assembleur_P_VDF::zone_Cl_dis_base" ref="adf03371f0f2cb7af8d04c4f6154588f1" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classZone__Cl__dis__base.html">Zone_Cl_dis_base</a> &amp; Assembleur_P_VDF::zone_Cl_dis_base </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implements <a class="el" href="classAssembleur__base.html#a4bb9fff95986900cec3a5b8c8dadaa14">Assembleur_base</a>.</p>

<p>Definition at line <a class="el" href="Assembleur__P__VDF_8cpp_source.html#l00812">812</a> of file <a class="el" href="Assembleur__P__VDF_8cpp_source.html">Assembleur_P_VDF.cpp</a>.</p>

<p>References <a class="el" href="Assembleur__P__VDF_8h_source.html#l00069">la_zone_Cl_VDF</a>, and <a class="el" href="Ref__Zone__Cl__VDF_8h_source.html#l00028">Ref_Zone_Cl_VDF::valeur()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">return</span> <a class="code" href="classAssembleur__P__VDF.html#a0b984a6831f2750865e12296e5e07a2b">la_zone_Cl_VDF</a>.<a class="code" href="classRef__Zone__Cl__VDF.html#a1e655604e840cda5b393e45f975b73ff">valeur</a>();
}
</pre></div>
</div>
</div>
<a class="anchor" id="ac88b839fd9e38462641eac2515a74e12"></a><!-- doxytag: member="Assembleur_P_VDF::zone_dis_base" ref="ac88b839fd9e38462641eac2515a74e12" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classZone__dis__base.html">Zone_dis_base</a> &amp; Assembleur_P_VDF::zone_dis_base </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implements <a class="el" href="classAssembleur__base.html#a90d1dc339423d11e816283af20d16688">Assembleur_base</a>.</p>

<p>Definition at line <a class="el" href="Assembleur__P__VDF_8cpp_source.html#l00807">807</a> of file <a class="el" href="Assembleur__P__VDF_8cpp_source.html">Assembleur_P_VDF.cpp</a>.</p>

<p>References <a class="el" href="Assembleur__P__VDF_8h_source.html#l00068">la_zone_VDF</a>, and <a class="el" href="Ref__Zone__VDF_8h_source.html#l00028">Ref_Zone_VDF::valeur()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">return</span> <a class="code" href="classAssembleur__P__VDF.html#a4ce1358c35e162057c7968aa583cd581">la_zone_VDF</a>.<a class="code" href="classRef__Zone__VDF.html#a84151da4db745d02791d6246e3682b67">valeur</a>();
}
</pre></div>
</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="a9d277900967c598cd61dcc14dcb7ebbd"></a><!-- doxytag: member="Assembleur_P_VDF::has_P_ref" ref="a9d277900967c598cd61dcc14dcb7ebbd" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classAssembleur__P__VDF.html#a9d277900967c598cd61dcc14dcb7ebbd">Assembleur_P_VDF::has_P_ref</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Assembleur__P__VDF_8h_source.html#l00073">73</a> of file <a class="el" href="Assembleur__P__VDF_8h_source.html">Assembleur_P_VDF.h</a>.</p>

<p>Referenced by <a class="el" href="Assembleur__P__VDF_8cpp_source.html#l00658">modifier_solution()</a>, and <a class="el" href="Assembleur__P__VDF_8cpp_source.html#l00303">remplir()</a>.</p>

</div>
</div>
<a class="anchor" id="ab8e041b71b608e70ea351ef761fb5891"></a><!-- doxytag: member="Assembleur_P_VDF::info_obj" ref="ab8e041b71b608e70ea351ef761fb5891" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classType__info.html">Type_info</a> <a class="el" href="classAssembleur__P__VDF.html#ab8e041b71b608e70ea351ef761fb5891">Assembleur_P_VDF::info_obj</a><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="classAssembleur__base.html#a70e2656492d0bbd035c237b1bb04d727">Assembleur_base</a>.</p>

<p>Definition at line <a class="el" href="Assembleur__P__VDF_8h_source.html#l00042">42</a> of file <a class="el" href="Assembleur__P__VDF_8h_source.html">Assembleur_P_VDF.h</a>.</p>

</div>
</div>
<a class="anchor" id="a0b984a6831f2750865e12296e5e07a2b"></a><!-- doxytag: member="Assembleur_P_VDF::la_zone_Cl_VDF" ref="a0b984a6831f2750865e12296e5e07a2b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRef__Zone__Cl__VDF.html">Ref_Zone_Cl_VDF</a> <a class="el" href="classAssembleur__P__VDF.html#a0b984a6831f2750865e12296e5e07a2b">Assembleur_P_VDF::la_zone_Cl_VDF</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Assembleur__P__VDF_8h_source.html#l00069">69</a> of file <a class="el" href="Assembleur__P__VDF_8h_source.html">Assembleur_P_VDF.h</a>.</p>

<p>Referenced by <a class="el" href="Assembleur__P__VDF_8cpp_source.html#l00822">associer_zone_cl_dis_base()</a>, <a class="el" href="Assembleur__P__VDF_8cpp_source.html#l00065">liste_faces_periodiques()</a>, <a class="el" href="Assembleur__P__VDF_8cpp_source.html#l00498">modifier_secmem()</a>, <a class="el" href="Assembleur__P__VDF_8cpp_source.html#l00303">remplir()</a>, and <a class="el" href="Assembleur__P__VDF_8cpp_source.html#l00812">zone_Cl_dis_base()</a>.</p>

</div>
</div>
<a class="anchor" id="a4ce1358c35e162057c7968aa583cd581"></a><!-- doxytag: member="Assembleur_P_VDF::la_zone_VDF" ref="a4ce1358c35e162057c7968aa583cd581" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRef__Zone__VDF.html">Ref_Zone_VDF</a> <a class="el" href="classAssembleur__P__VDF.html#a4ce1358c35e162057c7968aa583cd581">Assembleur_P_VDF::la_zone_VDF</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Assembleur__P__VDF_8h_source.html#l00068">68</a> of file <a class="el" href="Assembleur__P__VDF_8h_source.html">Assembleur_P_VDF.h</a>.</p>

<p>Referenced by <a class="el" href="Assembleur__P__VDF_8cpp_source.html#l00697">assembler()</a>, <a class="el" href="Assembleur__P__VDF_8cpp_source.html#l00764">assembler_QC()</a>, <a class="el" href="Assembleur__P__VDF_8cpp_source.html#l00722">assembler_rho_variable()</a>, <a class="el" href="Assembleur__P__VDF_8cpp_source.html#l00817">associer_zone_dis_base()</a>, <a class="el" href="Assembleur__P__VDF_8cpp_source.html#l00112">construire()</a>, <a class="el" href="Assembleur__P__VDF_8cpp_source.html#l00065">liste_faces_periodiques()</a>, <a class="el" href="Assembleur__P__VDF_8cpp_source.html#l00560">modifier_secmem_pression_imposee()</a>, <a class="el" href="Assembleur__P__VDF_8cpp_source.html#l00603">modifier_secmem_vitesse_imposee()</a>, <a class="el" href="Assembleur__P__VDF_8cpp_source.html#l00658">modifier_solution()</a>, <a class="el" href="Assembleur__P__VDF_8cpp_source.html#l00303">remplir()</a>, and <a class="el" href="Assembleur__P__VDF_8cpp_source.html#l00807">zone_dis_base()</a>.</p>

</div>
</div>
<a class="anchor" id="af8eca29a2e48d27e8e1f77e0945dc38d"></a><!-- doxytag: member="Assembleur_P_VDF::les_coeff_pression" ref="af8eca29a2e48d27e8e1f77e0945dc38d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classArrOfDouble.html">ArrOfDouble</a> <a class="el" href="classAssembleur__P__VDF.html#af8eca29a2e48d27e8e1f77e0945dc38d">Assembleur_P_VDF::les_coeff_pression</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Assembleur__P__VDF_8h_source.html#l00070">70</a> of file <a class="el" href="Assembleur__P__VDF_8h_source.html">Assembleur_P_VDF.h</a>.</p>

<p>Referenced by <a class="el" href="Assembleur__P__VDF_8cpp_source.html#l00112">construire()</a>, <a class="el" href="Assembleur__P__VDF_8cpp_source.html#l00560">modifier_secmem_pression_imposee()</a>, and <a class="el" href="Assembleur__P__VDF_8cpp_source.html#l00303">remplir()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/VDF/Solveurs/<a class="el" href="Assembleur__P__VDF_8h_source.html">Assembleur_P_VDF.h</a></li>
<li>src/VDF/Solveurs/<a class="el" href="Assembleur__P__VDF_8cpp_source.html">Assembleur_P_VDF.cpp</a></li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Tue Dec 14 2021 19:36:07 for TRUST by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
