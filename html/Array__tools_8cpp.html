<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>TRUST: src/Kernel/Math/Array_tools.cpp File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">TRUST&#160;<span id="projectnumber">1.8.4</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">src/Kernel/Math/Array_tools.cpp File Reference</div>  </div>
</div>
<div class="contents">
<div class="textblock"><code>#include &lt;<a class="el" href="Array__tools_8h_source.html">Array_tools.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="IntTab_8h_source.html">IntTab.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="ArrOfDouble_8h_source.html">ArrOfDouble.h</a>&gt;</code><br/>
</div>
<p><a href="Array__tools_8cpp_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Array__tools_8cpp.html#a16494af4ad15ba2b7d71a3706e14ff4f">array_retirer_doublons</a> (<a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;array)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">retire les doublons du tableau array<br/>
(suppose que le tableau est trie dans l'ordre croissant)<br/>
On deplace les elements conserves pour qu'ils soient contigus<br/>
au debut du tableau.<br/>
ATTENTION: on ne resize pas le tableau, utiliser la valeur<br/>
de retour pour le faire ensuite!<br/>
(au cas ou on veuille appliquer cette fonction a un <a class="el" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>,<br/>
il faut faire resize() et non resize_array())<br/>
Valeur de retour : nombre d'elements conserves dans le tableau  <a href="#a16494af4ad15ba2b7d71a3706e14ff4f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Array__tools_8cpp.html#a81a8055923c8a80e3e74637510106227">array_trier_retirer_doublons</a> (<a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;array)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Trie le tableau array dans l'ordre croissant<br/>
et retire les doublons.  <a href="#a81a8055923c8a80e3e74637510106227"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Array__tools_8cpp.html#a7bcdb4c1fbdd4b5318fe1159fb303dc2">array_calculer_intersection</a> (<a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;liste1, const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;liste2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">calcule l'intersection entre les deux listes d'entiers<br/>
liste1 et liste2. Le resultat est mis dans liste1.<br/>
Les deux listes doivent etre triees et sans doublons. liste1 est<br/>
triee en sortie.  <a href="#a7bcdb4c1fbdd4b5318fe1159fb303dc2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Array__tools_8cpp.html#a9226d0e9dacc7ea936d9657b316a0214">array_retirer_elements</a> (<a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;sorted_array, const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;sorted_elements_list)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Retire de "sorted_array" les elements qui figurent dans "sorted_elements".<br/>
Les deux tableaux doivent etre initialement ordonnes dans l'ordre croissant.<br/>
Exemple:<br/>
En entree sorted_array=[1,4,9,10,12,18], sorted_elements=[3,5,9,10,18,25]<br/>
En sortie sorted_array=[1,4,12].  <a href="#a9226d0e9dacc7ea936d9657b316a0214"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Array__tools_8cpp.html#acf7c82ee01f8e96267a816f9dd9a2c74">array_bsearch</a> (const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;tab, int valeur)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">cherche la "valeur" dans le tableau tab par recherche binaire<br/>
Le tableau tab doit etre trie dans l'ordre croissant<br/>
Si elle n'est pas trouvee, renvoie -1 (y compris si tab est vide),<br/>
sinon, renvoie un index i tel que tab[i] == valeur&lt;br&gt;(si la valeur figure plusieurs fois dans le tableau, on ne renvoie&lt;br&gt;pas forcement la premiere occurence).  <a href="#acf7c82ee01f8e96267a816f9dd9a2c74"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="arch_8h.html#a1caaf369d9c5f0817dbaa76b43b8d87b">True_int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Array__tools_8cpp.html#a08e0b88b572e3a591b53b3c890c760ec">fct_qsort_tableau_2</a> (const void *ptr1, const void *ptr2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="arch_8h.html#a1caaf369d9c5f0817dbaa76b43b8d87b">True_int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Array__tools_8cpp.html#a0a28fc2f3126a1e1efb0053b3d09b226">fct_qsort_tableau_n</a> (const void *ptr1, const void *ptr2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Array__tools_8cpp.html#a4cfd65b3398623b2011557f6f029f8e6">tri_lexicographique_tableau</a> (<a class="el" href="classIntTab.html">IntTab</a> &amp;tab)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">tri lexicographique du tableau tab (par ordre croissant<br/>
de la premiere colonne, si premiere colonne identique, ordre croissant<br/>
de la deuxieme, etc).<br/>
Le tableau ne doit pas etre un tableau distribue.<br/>
Valeur de retour: nombre de colonnes du tableau (produit des tab.dimension(i) pour i&gt;0)  <a href="#a4cfd65b3398623b2011557f6f029f8e6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="arch_8h.html#a1caaf369d9c5f0817dbaa76b43b8d87b">True_int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Array__tools_8cpp.html#a6874e40139a04edd33dde69a7b610bec">fct_qsort_tableau_1_indirect</a> (const void *ptr1, const void *ptr2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="arch_8h.html#a1caaf369d9c5f0817dbaa76b43b8d87b">True_int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Array__tools_8cpp.html#a968cac169ba5ddbcebb8d20da67cdee4">fct_qsort_tableau_2_indirect</a> (const void *ptr1, const void *ptr2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="arch_8h.html#a1caaf369d9c5f0817dbaa76b43b8d87b">True_int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Array__tools_8cpp.html#aadf5cfbe9b9dd86af212343474875076">fct_qsort_tableau_n_indirect</a> (const void *ptr1, const void *ptr2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Array__tools_8cpp.html#ad62171ccb6e8fd4b2be47d286c164999">tri_lexicographique_tableau_indirect</a> (const <a class="el" href="classIntTab.html">IntTab</a> &amp;tab, <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;index)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Idem que tri_lexicographique_tableau mais on trie le tableau index qui<br/>
contient les indices de lignes du tableau tab tel que tab(index[i], *) soit<br/>
croissant quant i augmente. Tri de tous les indices de index...<br/>
Si le tableau index est de taille nulle, on en cree un de taille tab.dimension_tot(0)<br/>
Sinon on suppose qu'il contient deja des indices de lignes dans tab.<br/>
Valeur de retour: nombre de colonnes du tableau (produit des tab.dimension(i) pour i&gt;0)  <a href="#ad62171ccb6e8fd4b2be47d286c164999"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Array__tools_8cpp.html#aa9f63ddbdacb389d6cd42b822be6dfbd">resize_tab_lines</a> (<a class="el" href="classIntTab.html">IntTab</a> &amp;tab, const int n)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Array__tools_8cpp.html#a07eed4c823b0632bdbf353fdab2a3c6b">tableau_trier_retirer_doublons</a> (<a class="el" href="classIntTab.html">IntTab</a> &amp;tab)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Trie le tableau tab dans l'ordre lexicographique<br/>
et retire les doublons (attention [1,2] n'est pas egal a [2,1])  <a href="#a07eed4c823b0632bdbf353fdab2a3c6b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Array__tools_8cpp.html#ac46e3c4369dd60577776bb46ec92e5a5">same_line</a> (const <a class="el" href="classIntVect.html">IntVect</a> &amp;v, int i, int j)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Array__tools_8cpp.html#adba59ffed2ffdd0bfbb9f71307e81533">calculer_renum_sans_doublons</a> (const <a class="el" href="classIntTab.html">IntTab</a> &amp;tab, <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;renum, <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;renum_inverse)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">cherche par un tri lexicographique les lignes identiques de "tab"<br/>
et initialise les tailles et contenus de renum et renum_inverse.<br/>
renum est de taille tab.dimension_tot(0).<br/>
renum[i] contiendra l'indice de la ligne i dans le tableau reduit trie (contenant les lignes uniques)<br/>
renum_inverse contient, pour chaque ligne du tableau reduit trie, le plus petit indice de la ligne<br/>
correspondante dans tab.<br/>
on peut construire le tableau reduit trie en extayant les lignes tab( renum_inverse[i], ...)  <a href="#adba59ffed2ffdd0bfbb9f71307e81533"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Array__tools_8cpp.html#abbdfa89ba7360293358c11a20276d23d">array_smart_allocate</a> (<a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;array, const int n)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the smart_resize flag, preallocates memory for the given size, and resize to zero.  <a href="#abbdfa89ba7360293358c11a20276d23d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Array__tools_8cpp.html#a0a66f40788fe00b1adb025cf0bded363">array_smart_allocate</a> (<a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;array, const int n)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Array__tools_8cpp.html#a1a87846e44fce7037c7d036d5b015bf8">append_array_to_array</a> (<a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;dest, const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;src)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Increase size of "dest" array and copy "src" at the end of "dest".  <a href="#a1a87846e44fce7037c7d036d5b015bf8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Array__tools_8cpp.html#a9b07222e353ee8a80390fb01ce172a39">append_array_to_array</a> (<a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;dest, const <a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;src)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Increase size of "dest" array and copy "src" at the end of "dest".  <a href="#a9b07222e353ee8a80390fb01ce172a39"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="var-members"></a>
Variables</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Array__tools_8cpp.html#af67bfbc2db32195665d72b77c3967ea6">fct_qsort_nbcolonnes</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classIntVect.html">IntVect</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Array__tools_8cpp.html#ab80f7651089b503e8830e780e804e948">fct_qsort_tab_ptr</a> = 0</td></tr>
</table>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a1a87846e44fce7037c7d036d5b015bf8"></a><!-- doxytag: member="Array_tools.cpp::append_array_to_array" ref="a1a87846e44fce7037c7d036d5b015bf8" args="(ArrOfInt &amp;dest, const ArrOfInt &amp;src)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void append_array_to_array </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Increase size of "dest" array and copy "src" at the end of "dest". </p>

<p>Definition at line <a class="el" href="Array__tools_8cpp_source.html#l00515">515</a> of file <a class="el" href="Array__tools_8cpp_source.html">Array_tools.cpp</a>.</p>

<p>References <a class="el" href="ArrOfInt_8cpp_source.html#l01098">ArrOfInt::inject_array()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00240">ArrOfInt::resize_array()</a>, and <a class="el" href="ArrOfInt_8h_source.html#l00342">ArrOfInt::size_array()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">const</span> <span class="keywordtype">int</span> n1 = dest.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> n2 = src.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>();
  dest.<a class="code" href="classArrOfInt.html#a9b3afbb46b16870dbd36236c8935b535">resize_array</a>(n1+n2);
  dest.<a class="code" href="classArrOfInt.html#a195c644d98bf2da2fe4f8aede4e02262" title="Copie les elements source[first_element_source + i] dans les elements (*this)[first_element_dest + i]...">inject_array</a>(src, n2 <span class="comment">/* nb elem */</span>, n1 <span class="comment">/* dest index */</span>, 0 <span class="comment">/* src index */</span>);
}
</pre></div>
</div>
</div>
<a class="anchor" id="a9b07222e353ee8a80390fb01ce172a39"></a><!-- doxytag: member="Array_tools.cpp::append_array_to_array" ref="a9b07222e353ee8a80390fb01ce172a39" args="(ArrOfDouble &amp;dest, const ArrOfDouble &amp;src)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void append_array_to_array </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Increase size of "dest" array and copy "src" at the end of "dest". </p>

<p>Definition at line <a class="el" href="Array__tools_8cpp_source.html#l00523">523</a> of file <a class="el" href="Array__tools_8cpp_source.html">Array_tools.cpp</a>.</p>

<p>References <a class="el" href="ArrOfDouble_8cpp_source.html#l01110">ArrOfDouble::inject_array()</a>, <a class="el" href="ArrOfDouble_8h_source.html#l00244">ArrOfDouble::resize_array()</a>, and <a class="el" href="ArrOfDouble_8h_source.html#l00350">ArrOfDouble::size_array()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">const</span> <span class="keywordtype">int</span> n1 = dest.<a class="code" href="classArrOfDouble.html#a3c3b33bea0e88b87315c21ee94bee05f" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> n2 = src.<a class="code" href="classArrOfDouble.html#a3c3b33bea0e88b87315c21ee94bee05f" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>();
  dest.<a class="code" href="classArrOfDouble.html#a610464f4b3dccac6f814915b526783ed">resize_array</a>(n1+n2);
  dest.<a class="code" href="classArrOfDouble.html#a2fcb2a2d3b59425c6cb37526ea6af6a3" title="Copie les elements source[first_element_source + i] dans les elements (*this)[first_element_dest + i]...">inject_array</a>(src, n2 <span class="comment">/* nb elem */</span>, n1 <span class="comment">/* dest index */</span>, 0 <span class="comment">/* src index */</span>);
}
</pre></div>
</div>
</div>
<a class="anchor" id="acf7c82ee01f8e96267a816f9dd9a2c74"></a><!-- doxytag: member="Array_tools.cpp::array_bsearch" ref="acf7c82ee01f8e96267a816f9dd9a2c74" args="(const ArrOfInt &amp;tab, int valeur)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int array_bsearch </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>tab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>valeur</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>cherche la "valeur" dans le tableau tab par recherche binaire<br/>
Le tableau tab doit etre trie dans l'ordre croissant<br/>
Si elle n'est pas trouvee, renvoie -1 (y compris si tab est vide),<br/>
sinon, renvoie un index i tel que tab[i] == valeur&lt;br&gt;(si la valeur figure plusieurs fois dans le tableau, on ne renvoie&lt;br&gt;pas forcement la premiere occurence). </p>
<p>Methode outil pour chercher une valeur dans un tableau trie. </p>

<p><p>&lt; j = fin de tableau + 1 (important)</p>
<p>&lt; prendre la valeur milieu et pas milieu - 1</p>
<p>&lt; prendre la valeur milieu + 1 et pas milieu </p>
</p>

<p>Definition at line <a class="el" href="Array__tools_8cpp_source.html#l00155">155</a> of file <a class="el" href="Array__tools_8cpp_source.html">Array_tools.cpp</a>.</p>

<p>References <a class="el" href="ArrOfInt_8h_source.html#l00342">ArrOfInt::size_array()</a>.</p>
<div class="fragment"><pre class="fragment">{
<span class="comment">// attention tout est important !</span>
  <span class="keywordtype">int</span> i = 0;
  <span class="keywordtype">int</span> j = tab.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>(); <span class="comment">//!&lt; j = fin de tableau + 1 (important)</span>
<span class="comment"></span>  <span class="keywordflow">while</span> (j &gt; i)
    {
<span class="comment">// Le tableau doit etre trie</span>
      assert(j == tab.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() || tab[i] &lt;= tab[j]);
      <span class="keyword">const</span> <span class="keywordtype">int</span> milieu = (i + j) / 2;
      <span class="keyword">const</span> <span class="keywordtype">int</span> val = tab[milieu];
      <span class="keywordflow">if</span> (val &gt; <a class="code" href="Source__Generique__Face__PolyMAC_8cpp.html#a7d7b5d77a3caa1af70f5e1c9108de5a1">valeur</a>)
        j = milieu; <span class="comment">//!&lt; prendre la valeur milieu et pas milieu - 1</span>
<span class="comment"></span>      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (val &lt; <a class="code" href="Source__Generique__Face__PolyMAC_8cpp.html#a7d7b5d77a3caa1af70f5e1c9108de5a1">valeur</a>)
        i = milieu + 1; <span class="comment">//!&lt; prendre la valeur milieu + 1 et pas milieu</span>
<span class="comment"></span>      <span class="keywordflow">else</span>
        <span class="keywordflow">return</span> milieu;
    }
<span class="comment">// Si on arrive ici, c&#39;est que i==j, donc</span>
<span class="comment">// - soit j == fin de tableau + 1 et on n&#39;a pas trouve la valeur</span>
<span class="comment">// - soit tab[j] a ete teste et n&#39;est pas egale a valeur</span>
<span class="comment">// Dans les deux cas, valeur n&#39;est pas dans le tableau</span>
  <span class="keywordflow">return</span> -1;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a7bcdb4c1fbdd4b5318fe1159fb303dc2"></a><!-- doxytag: member="Array_tools.cpp::array_calculer_intersection" ref="a7bcdb4c1fbdd4b5318fe1159fb303dc2" args="(ArrOfInt &amp;liste1, const ArrOfInt &amp;liste2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void array_calculer_intersection </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>liste1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>liste2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>calcule l'intersection entre les deux listes d'entiers<br/>
liste1 et liste2. Le resultat est mis dans liste1.<br/>
Les deux listes doivent etre triees et sans doublons. liste1 est<br/>
triee en sortie. </p>
<p>Methode outil pour calculer l'intersection entre deux listes d'entiers. </p>

<p><p>&lt; Pointeur en lecture dans liste1</p>
<p>&lt; Pointeur en lecture dans liste2</p>
<p>&lt; Pointeur en ecriture</p>
<p>&lt; Bout de liste, on a fini</p>
<p>&lt; On garde cette valeur </p>
</p>

<p>Definition at line <a class="el" href="Array__tools_8cpp_source.html#l00078">78</a> of file <a class="el" href="Array__tools_8cpp_source.html">Array_tools.cpp</a>.</p>

<p>References <a class="el" href="ArrOfInt_8h_source.html#l00240">ArrOfInt::resize_array()</a>, and <a class="el" href="ArrOfInt_8h_source.html#l00342">ArrOfInt::size_array()</a>.</p>

<p>Referenced by <a class="el" href="Partitionneur__base_8cpp_source.html#l00260">Partitionneur_base::corriger_sommets_bord()</a>, and <a class="el" href="Refine__Mesh_8cpp_source.html#l00681">Refine_Mesh::find_edge()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">const</span> <span class="keywordtype">int</span> sz1 = liste1.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> sz2 = liste2.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>();
  <span class="keywordtype">int</span> i; <span class="comment">//!&lt; Pointeur en lecture dans liste1</span>
<span class="comment"></span>  <span class="keywordtype">int</span> j = 0; <span class="comment">//!&lt; Pointeur en lecture dans liste2</span>
<span class="comment"></span>  <span class="keywordtype">int</span> k = 0; <span class="comment">//!&lt; Pointeur en ecriture</span>
<span class="comment"></span>  <span class="keywordflow">for</span> (i = 0; i &lt; sz1; i++)
    {
<span class="comment">// On verifie que les listes sont triees dans l&#39;ordre croissant</span>
      assert((i &gt;= sz1-1) || (liste1[i] &lt; liste1[i+1]));
      assert((j &gt;= sz2-1) || (liste2[j] &lt; liste2[j+1]));
      <span class="keyword">const</span> <span class="keywordtype">int</span> valeur_i = liste1[i];
<span class="comment">// Avancer dans liste2 jusqu&#39;a trouver ou depasser liste1[i]</span>
      <span class="keywordflow">while</span> (j &lt; sz2 &amp;&amp; liste2[j] &lt; valeur_i)
        j++;
      <span class="keywordflow">if</span> (j == sz2)
        <span class="keywordflow">break</span>; <span class="comment">//!&lt; Bout de liste, on a fini</span>
<span class="comment"></span>      <span class="keywordflow">if</span> (liste2[j] == valeur_i)
        {
          liste1[k] = valeur_i;
          k++; <span class="comment">//!&lt; On garde cette valeur</span>
<span class="comment"></span>        }
    }
  liste1.<a class="code" href="classArrOfInt.html#a9b3afbb46b16870dbd36236c8935b535">resize_array</a>(k);
}
</pre></div>
</div>
</div>
<a class="anchor" id="a16494af4ad15ba2b7d71a3706e14ff4f"></a><!-- doxytag: member="Array_tools.cpp::array_retirer_doublons" ref="a16494af4ad15ba2b7d71a3706e14ff4f" args="(ArrOfInt &amp;array)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int array_retirer_doublons </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>array</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>retire les doublons du tableau array<br/>
(suppose que le tableau est trie dans l'ordre croissant)<br/>
On deplace les elements conserves pour qu'ils soient contigus<br/>
au debut du tableau.<br/>
ATTENTION: on ne resize pas le tableau, utiliser la valeur<br/>
de retour pour le faire ensuite!<br/>
(au cas ou on veuille appliquer cette fonction a un <a class="el" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>,<br/>
il faut faire resize() et non resize_array())<br/>
Valeur de retour : nombre d'elements conserves dans le tableau </p>

<p>Definition at line <a class="el" href="Array__tools_8cpp_source.html#l00036">36</a> of file <a class="el" href="Array__tools_8cpp_source.html">Array_tools.cpp</a>.</p>

<p>References <a class="el" href="ArrOfInt_8h_source.html#l00342">ArrOfInt::size_array()</a>.</p>

<p>Referenced by <a class="el" href="Array__tools_8cpp_source.html#l00059">array_trier_retirer_doublons()</a>, and <a class="el" href="Array__tools_8cpp_source.html#l00389">tableau_trier_retirer_doublons()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">const</span> <span class="keywordtype">int</span> size = array.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>();
  <span class="keywordflow">if</span> (size == 0)
    <span class="keywordflow">return</span> 0;
<span class="comment">// Retire les doublons</span>
  <span class="keywordtype">int</span> new_size = 1;
  <span class="keywordtype">int</span> last_value = array[0];
  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 1; i &lt; size; i++)
    {
<span class="comment">// Le tableau doit etre trie !</span>
      assert(array[i] &gt;= last_value);
      <span class="keywordflow">if</span> (array[i] != last_value)
        {
          array[new_size] = last_value = array[i];
          new_size++;
        }
    }
  <span class="keywordflow">return</span> new_size;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a9226d0e9dacc7ea936d9657b316a0214"></a><!-- doxytag: member="Array_tools.cpp::array_retirer_elements" ref="a9226d0e9dacc7ea936d9657b316a0214" args="(ArrOfInt &amp;sorted_array, const ArrOfInt &amp;sorted_elements_list)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void array_retirer_elements </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>sorted_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>sorted_elements_list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retire de "sorted_array" les elements qui figurent dans "sorted_elements".<br/>
Les deux tableaux doivent etre initialement ordonnes dans l'ordre croissant.<br/>
Exemple:<br/>
En entree sorted_array=[1,4,9,10,12,18], sorted_elements=[3,5,9,10,18,25]<br/>
En sortie sorted_array=[1,4,12]. </p>
<p>Methode outil pour calculer la difference entre deux listes d'entiers triees. </p>

<p><p>&lt; Index dans sorted_array (en lecture)</p>
<p>&lt; Index dans sorted_array (la ou on ecrit)</p>
<p>&lt; Index dans sorted_elements</p>
<p>&lt; Tableau trie ? </p>
</p>

<p>Definition at line <a class="el" href="Array__tools_8cpp_source.html#l00111">111</a> of file <a class="el" href="Array__tools_8cpp_source.html">Array_tools.cpp</a>.</p>

<p>References <a class="el" href="ArrOfInt_8h_source.html#l00240">ArrOfInt::resize_array()</a>, and <a class="el" href="ArrOfInt_8h_source.html#l00342">ArrOfInt::size_array()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">int</span> i_read;      <span class="comment">//!&lt; Index dans sorted_array (en lecture)</span>
<span class="comment"></span>  <span class="keywordtype">int</span> i_write = 0; <span class="comment">//!&lt; Index dans sorted_array (la ou on ecrit)</span>
<span class="comment"></span>  <span class="keywordtype">int</span> j = 0;       <span class="comment">//!&lt; Index dans sorted_elements</span>
<span class="comment"></span>  <span class="keyword">const</span> <span class="keywordtype">int</span> n = sorted_array.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> m = sorted_elements_list.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>();
  <span class="keywordflow">if</span> (m == 0)
    <span class="keywordflow">return</span>;

  <span class="keywordtype">int</span> j_value = sorted_elements_list[j];
  <span class="keywordflow">for</span> (i_read = 0; i_read &lt; n; i_read++)
    {
<span class="comment">// Tableau trie ?</span>
      assert(i_read == 0 || sorted_array[i_read] &gt; sorted_array[i_read-1]);
      <span class="keyword">const</span> <span class="keywordtype">int</span> i_value = sorted_array[i_read];

<span class="comment">// On avance dans la liste sorted_elements jusqu&#39;a trouver ou depasser</span>
<span class="comment">// l&#39;element i_value</span>
      <span class="keywordflow">while</span> ((j_value &lt; i_value) &amp;&amp; (j &lt; m))
        {
          j++;
          <span class="keywordflow">if</span> (j == m)
            <span class="keywordflow">break</span>;
          assert(sorted_elements_list[j] &gt; j_value); <span class="comment">//!&lt; Tableau trie ?</span>
<span class="comment"></span>          j_value = sorted_elements_list[j];
        }

      <span class="keywordflow">if</span> (j == m || j_value != i_value)
        {
<span class="comment">// i_value ne figure pas dans le tableau sorted_elements, on le garde</span>
          sorted_array[i_write] = i_value;
          i_write++;
        }
    }
  sorted_array.<a class="code" href="classArrOfInt.html#a9b3afbb46b16870dbd36236c8935b535">resize_array</a>(i_write);
}
</pre></div>
</div>
</div>
<a class="anchor" id="a0a66f40788fe00b1adb025cf0bded363"></a><!-- doxytag: member="Array_tools.cpp::array_smart_allocate" ref="a0a66f40788fe00b1adb025cf0bded363" args="(ArrOfDouble &amp;array, const int n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void array_smart_allocate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Array__tools_8cpp_source.html#l00506">506</a> of file <a class="el" href="Array__tools_8cpp_source.html">Array_tools.cpp</a>.</p>

<p>References <a class="el" href="Array__base_8h_source.html#l00038">Array_base::NOCOPY_NOINIT</a>, <a class="el" href="ArrOfDouble_8h_source.html#l00244">ArrOfDouble::resize_array()</a>, and <a class="el" href="ArrOfDouble_8cpp_source.html#l00442">ArrOfDouble::set_smart_resize()</a>.</p>
<div class="fragment"><pre class="fragment">{
  array.<a class="code" href="classArrOfDouble.html#ab49f6cae96be9d3f597468d8a53b67b6" title="Change le mode l&#39;allocation memoire: reallocation d&#39;un tableau a chaque changement de taille (flag = ...">set_smart_resize</a>(1);
<span class="comment">// get memory for the requested size</span>
  array.<a class="code" href="classArrOfDouble.html#a610464f4b3dccac6f814915b526783ed">resize_array</a>(n, <a class="code" href="classArray__base.html#abee342aa9ac59623c4c782dc9d7877ffaf6ae9ba7eb51c5f298ce693345b3ec68">Array_base::NOCOPY_NOINIT</a>);
<span class="comment">// and set actual size to zero</span>
  array.<a class="code" href="classArrOfDouble.html#a610464f4b3dccac6f814915b526783ed">resize_array</a>(0);
}
</pre></div>
</div>
</div>
<a class="anchor" id="abbdfa89ba7360293358c11a20276d23d"></a><!-- doxytag: member="Array_tools.cpp::array_smart_allocate" ref="abbdfa89ba7360293358c11a20276d23d" args="(ArrOfInt &amp;array, const int n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void array_smart_allocate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the smart_resize flag, preallocates memory for the given size, and resize to zero. </p>

<p>Definition at line <a class="el" href="Array__tools_8cpp_source.html#l00497">497</a> of file <a class="el" href="Array__tools_8cpp_source.html">Array_tools.cpp</a>.</p>

<p>References <a class="el" href="Array__base_8h_source.html#l00038">Array_base::NOCOPY_NOINIT</a>, <a class="el" href="ArrOfInt_8h_source.html#l00240">ArrOfInt::resize_array()</a>, and <a class="el" href="ArrOfInt_8cpp_source.html#l00443">ArrOfInt::set_smart_resize()</a>.</p>
<div class="fragment"><pre class="fragment">{
  array.<a class="code" href="classArrOfInt.html#a22d744bcd452d039580d1d9186f02b4e" title="Change le mode l&#39;allocation memoire: reallocation d&#39;un tableau a chaque changement de taille (flag = ...">set_smart_resize</a>(1);
<span class="comment">// get memory for the requested size</span>
  array.<a class="code" href="classArrOfInt.html#a9b3afbb46b16870dbd36236c8935b535">resize_array</a>(n, <a class="code" href="classArray__base.html#abee342aa9ac59623c4c782dc9d7877ffaf6ae9ba7eb51c5f298ce693345b3ec68">Array_base::NOCOPY_NOINIT</a>);
<span class="comment">// and set actual size to zero</span>
  array.<a class="code" href="classArrOfInt.html#a9b3afbb46b16870dbd36236c8935b535">resize_array</a>(0);
}
</pre></div>
</div>
</div>
<a class="anchor" id="a81a8055923c8a80e3e74637510106227"></a><!-- doxytag: member="Array_tools.cpp::array_trier_retirer_doublons" ref="a81a8055923c8a80e3e74637510106227" args="(ArrOfInt &amp;array)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void array_trier_retirer_doublons </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>array</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Trie le tableau array dans l'ordre croissant<br/>
et retire les doublons. </p>
<p>Methode outil pour retirer les doublons dans un tableau. </p>

<p>Definition at line <a class="el" href="Array__tools_8cpp_source.html#l00059">59</a> of file <a class="el" href="Array__tools_8cpp_source.html">Array_tools.cpp</a>.</p>

<p>References <a class="el" href="Array__tools_8cpp_source.html#l00036">array_retirer_doublons()</a>, <a class="el" href="ArrOfInt_8cpp_source.html#l00897">ArrOfInt::ordonne_array()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00240">ArrOfInt::resize_array()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00342">ArrOfInt::size_array()</a>, <a class="el" href="Cast_8h_source.html#l00054">sub_type</a>, and <a class="el" href="Nom_8cpp_source.html#l00040">sz</a>.</p>
<div class="fragment"><pre class="fragment">{
<span class="comment">// IntVect n&#39;est pas traite correctement car on ne</span>
<span class="comment">// fait pas un resize() mais un resize_array().</span>
  assert(!<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classIntVect.html">IntVect</a>, array));
  <span class="keyword">const</span> <span class="keywordtype">int</span> size = array.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>();
  <span class="keywordflow">if</span> (size == 0)
    <span class="keywordflow">return</span>;
<span class="comment">// Tri dans l&#39;ordre croissant</span>
  array.<a class="code" href="classArrOfInt.html#abb0f48cf5a4be4b70edcc90baaebd521" title="Tri des valeurs du tableau dans l&#39;ordre croissant. La fonction utilisee est qsort de stdlib (elle est...">ordonne_array</a>();
<span class="comment">// Retire les doublons</span>
  <span class="keyword">const</span> <span class="keywordtype">int</span> <a class="code" href="Nom_8cpp.html#a0e1ea19fb9fa7881d15d84eff4c090e1">sz</a> = <a class="code" href="Array__tools_8cpp.html#a16494af4ad15ba2b7d71a3706e14ff4f" title="retire les doublons du tableau array (suppose que le tableau est trie dans l&#39;ordre croissant) On depl...">array_retirer_doublons</a>(array);
  array.<a class="code" href="classArrOfInt.html#a9b3afbb46b16870dbd36236c8935b535">resize_array</a>(sz);
}
</pre></div>
</div>
</div>
<a class="anchor" id="adba59ffed2ffdd0bfbb9f71307e81533"></a><!-- doxytag: member="Array_tools.cpp::calculer_renum_sans_doublons" ref="adba59ffed2ffdd0bfbb9f71307e81533" args="(const IntTab &amp;tab, ArrOfInt &amp;renum, ArrOfInt &amp;renum_inverse)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void calculer_renum_sans_doublons </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIntTab.html">IntTab</a> &amp;&#160;</td>
          <td class="paramname"><em>tab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>renum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>renum_inverse</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>cherche par un tri lexicographique les lignes identiques de "tab"<br/>
et initialise les tailles et contenus de renum et renum_inverse.<br/>
renum est de taille tab.dimension_tot(0).<br/>
renum[i] contiendra l'indice de la ligne i dans le tableau reduit trie (contenant les lignes uniques)<br/>
renum_inverse contient, pour chaque ligne du tableau reduit trie, le plus petit indice de la ligne<br/>
correspondante dans tab.<br/>
on peut construire le tableau reduit trie en extayant les lignes tab( renum_inverse[i], ...) </p>
<p>Methode outil pour trouver les doublons (permet de retirer les doublons<br/>
sans changer l'ordre des elements) </p>

<p><p>&lt; compteur de lignes dans le tableau reduit</p>
<p>&lt; indice dans le tableau initial de la derniere ligne ajoutee dans le tableau reduit</p>
<p>&lt; pas de reallocation </p>
</p>

<p>Definition at line <a class="el" href="Array__tools_8cpp_source.html#l00456">456</a> of file <a class="el" href="Array__tools_8cpp_source.html">Array_tools.cpp</a>.</p>

<p>References <a class="el" href="Array__base_8h_source.html#l00038">Array_base::NOCOPY_NOINIT</a>, <a class="el" href="ArrOfInt_8h_source.html#l00240">ArrOfInt::resize_array()</a>, <a class="el" href="Array__tools_8cpp_source.html#l00439">same_line()</a>, <a class="el" href="ArrOfInt_8cpp_source.html#l00443">ArrOfInt::set_smart_resize()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00342">ArrOfInt::size_array()</a>, and <a class="el" href="Array__tools_8cpp_source.html#l00342">tri_lexicographique_tableau_indirect()</a>.</p>

<p>Referenced by <a class="el" href="Refine__Mesh_8cpp_source.html#l00248">Refine_Mesh::build_edges()</a>.</p>
<div class="fragment"><pre class="fragment">{
<span class="comment">// MODIF ELI LAUCOIN 31/01/2012 :</span>
<span class="comment">// Je re-ecris completement cette fonction</span>

<span class="comment">// index permet de parcourir le tableau tab dans l&#39;ordre</span>
  <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> index;
  <a class="code" href="Array__tools_8cpp.html#ad62171ccb6e8fd4b2be47d286c164999" title="Idem que tri_lexicographique_tableau mais on trie le tableau index qui contient les indices de lignes...">tri_lexicographique_tableau_indirect</a>(tab, index);
  <span class="keyword">const</span> <span class="keywordtype">int</span> n = index.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>();

<span class="comment">// on redimensionne renum et renum_index</span>
  renum.<a class="code" href="classArrOfInt.html#a9b3afbb46b16870dbd36236c8935b535">resize_array</a>(n, <a class="code" href="classArray__base.html#abee342aa9ac59623c4c782dc9d7877ffaf6ae9ba7eb51c5f298ce693345b3ec68">Array_base::NOCOPY_NOINIT</a>);
  renum_inverse.<a class="code" href="classArrOfInt.html#a9b3afbb46b16870dbd36236c8935b535">resize_array</a>(n, <a class="code" href="classArray__base.html#abee342aa9ac59623c4c782dc9d7877ffaf6ae9ba7eb51c5f298ce693345b3ec68">Array_base::NOCOPY_NOINIT</a>);

  <span class="keywordtype">int</span> count  = -1; <span class="comment">//!&lt; compteur de lignes dans le tableau reduit</span>
<span class="comment"></span>  <span class="keywordtype">int</span> latest = -1; <span class="comment">//!&lt; indice dans le tableau initial de la derniere ligne ajoutee dans le tableau reduit</span>
<span class="comment"></span>
  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;n; ++i)
    {
<span class="comment">// on parcourt tab dans l&#39;ordre croissant donne par index.</span>
<span class="comment">// si la ligne courante est differente de la derniere ligne ajoutee dans le tableau reduit,</span>
<span class="comment">// on incremente count et on met a jour latest.</span>
      <span class="keywordflow">if</span> ( ( latest &lt; 0 ) || ( !(<a class="code" href="Array__tools_8cpp.html#ac46e3c4369dd60577776bb46ec92e5a5">same_line</a>(tab,index[i],index[latest]))) )
        {
          ++count;
          latest=i;
        }

<span class="comment">// on indique dans renum ou se trouve la ligne courante dans le tableau reduit</span>
      renum[index[i]]      = count;

<span class="comment">// on ajoute la derniere ligne traitee au tableau reduit</span>
      renum_inverse[count] = index[latest];
    }

<span class="comment">// on redimensionne renum_inverse a la taille du tableau reduit</span>
  renum_inverse.<a class="code" href="classArrOfInt.html#a22d744bcd452d039580d1d9186f02b4e" title="Change le mode l&#39;allocation memoire: reallocation d&#39;un tableau a chaque changement de taille (flag = ...">set_smart_resize</a>(1); <span class="comment">//!&lt; pas de reallocation</span>
<span class="comment"></span>  renum_inverse.<a class="code" href="classArrOfInt.html#a9b3afbb46b16870dbd36236c8935b535">resize_array</a>(count+1);
<span class="comment">// FIN MODIF ELI LAUCOIN 31/01/2012</span>
}
</pre></div>
</div>
</div>
<a class="anchor" id="a6874e40139a04edd33dde69a7b610bec"></a><!-- doxytag: member="Array_tools.cpp::fct_qsort_tableau_1_indirect" ref="a6874e40139a04edd33dde69a7b610bec" args="(const void *ptr1, const void *ptr2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="arch_8h.html#a1caaf369d9c5f0817dbaa76b43b8d87b">True_int</a> fct_qsort_tableau_1_indirect </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>ptr1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>ptr2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Array__tools_8cpp_source.html#l00263">263</a> of file <a class="el" href="Array__tools_8cpp_source.html">Array_tools.cpp</a>.</p>

<p>References <a class="el" href="Array__tools_8cpp_source.html#l00261">fct_qsort_tab_ptr</a>.</p>

<p>Referenced by <a class="el" href="Array__tools_8cpp_source.html#l00342">tri_lexicographique_tableau_indirect()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">const</span> <span class="keywordtype">int</span> t1 = *((<span class="keyword">const</span> <span class="keywordtype">int</span> *) ptr1);
  <span class="keyword">const</span> <span class="keywordtype">int</span> t2 = *((<span class="keyword">const</span> <span class="keywordtype">int</span> *) ptr2);
  <span class="keyword">const</span> <a class="code" href="classIntVect.html">IntVect</a>&amp; tab = *<a class="code" href="Array__tools_8cpp.html#ab80f7651089b503e8830e780e804e948">fct_qsort_tab_ptr</a>;
  <span class="keywordtype">int</span> delta = tab[t1] - tab[t2];
<span class="preprocessor">#ifdef INT_is_64_</span>
<span class="preprocessor"></span>  <span class="keywordflow">if</span> (delta==0)
    <span class="keywordflow">return</span> 0;
  <span class="keywordflow">if</span> (delta&lt;0)
    <span class="keywordflow">return</span> -1;
  <span class="keywordflow">return</span> 1;
<span class="preprocessor">#else</span>
<span class="preprocessor"></span>  <span class="keywordflow">return</span> delta;
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>}
</pre></div>
</div>
</div>
<a class="anchor" id="a08e0b88b572e3a591b53b3c890c760ec"></a><!-- doxytag: member="Array_tools.cpp::fct_qsort_tableau_2" ref="a08e0b88b572e3a591b53b3c890c760ec" args="(const void *ptr1, const void *ptr2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="arch_8h.html#a1caaf369d9c5f0817dbaa76b43b8d87b">True_int</a> fct_qsort_tableau_2 </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>ptr1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>ptr2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Array__tools_8cpp_source.html#l00182">182</a> of file <a class="el" href="Array__tools_8cpp_source.html">Array_tools.cpp</a>.</p>

<p>Referenced by <a class="el" href="Array__tools_8cpp_source.html#l00237">tri_lexicographique_tableau()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">const</span> <span class="keywordtype">int</span> *t1 = (<span class="keyword">const</span> <span class="keywordtype">int</span> *) ptr1;
  <span class="keyword">const</span> <span class="keywordtype">int</span> *t2 = (<span class="keyword">const</span> <span class="keywordtype">int</span> *) ptr2;
  <span class="keywordtype">int</span> delta = t1[0] - t2[0];
  <span class="keywordtype">int</span> delta2 = t1[1] - t2[1];
<span class="preprocessor">#ifdef INT_is_64_</span>
<span class="preprocessor"></span>  delta= delta ? delta : delta2;
  <span class="keywordflow">if</span> (delta==0)
    <span class="keywordflow">return</span> 0;
  <span class="keywordflow">if</span> (delta&lt;0)
    <span class="keywordflow">return</span> -1;
  <span class="keywordflow">return</span> 1;
<span class="preprocessor">#else</span>
<span class="preprocessor"></span>  <span class="keywordflow">return</span> delta ? delta : delta2;
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>}
</pre></div>
</div>
</div>
<a class="anchor" id="a968cac169ba5ddbcebb8d20da67cdee4"></a><!-- doxytag: member="Array_tools.cpp::fct_qsort_tableau_2_indirect" ref="a968cac169ba5ddbcebb8d20da67cdee4" args="(const void *ptr1, const void *ptr2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="arch_8h.html#a1caaf369d9c5f0817dbaa76b43b8d87b">True_int</a> fct_qsort_tableau_2_indirect </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>ptr1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>ptr2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Array__tools_8cpp_source.html#l00280">280</a> of file <a class="el" href="Array__tools_8cpp_source.html">Array_tools.cpp</a>.</p>

<p>References <a class="el" href="Array__tools_8cpp_source.html#l00261">fct_qsort_tab_ptr</a>.</p>

<p>Referenced by <a class="el" href="Array__tools_8cpp_source.html#l00342">tri_lexicographique_tableau_indirect()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">const</span> <span class="keywordtype">int</span> t1 = *((<span class="keyword">const</span> <span class="keywordtype">int</span> *) ptr1) * 2;
  <span class="keyword">const</span> <span class="keywordtype">int</span> t2 = *((<span class="keyword">const</span> <span class="keywordtype">int</span> *) ptr2) * 2;
  <span class="keyword">const</span> <a class="code" href="classIntVect.html">IntVect</a>&amp; tab = *<a class="code" href="Array__tools_8cpp.html#ab80f7651089b503e8830e780e804e948">fct_qsort_tab_ptr</a>;
  <span class="keywordtype">int</span> delta = tab[t1] - tab[t2];
  <span class="keywordtype">int</span> delta2 = tab[t1+1] - tab[t2+1];
<span class="preprocessor">#ifdef INT_is_64_</span>
<span class="preprocessor"></span>  delta= delta ? delta : delta2;
  <span class="keywordflow">if</span> (delta==0)
    <span class="keywordflow">return</span> 0;
  <span class="keywordflow">if</span> (delta&lt;0)
    <span class="keywordflow">return</span> -1;
  <span class="keywordflow">return</span> 1;
<span class="preprocessor">#else</span>
<span class="preprocessor"></span>  <span class="keywordflow">return</span> delta ? delta : delta2;
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>
}
</pre></div>
</div>
</div>
<a class="anchor" id="a0a28fc2f3126a1e1efb0053b3d09b226"></a><!-- doxytag: member="Array_tools.cpp::fct_qsort_tableau_n" ref="a0a28fc2f3126a1e1efb0053b3d09b226" args="(const void *ptr1, const void *ptr2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="arch_8h.html#a1caaf369d9c5f0817dbaa76b43b8d87b">True_int</a> fct_qsort_tableau_n </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>ptr1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>ptr2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Array__tools_8cpp_source.html#l00200">200</a> of file <a class="el" href="Array__tools_8cpp_source.html">Array_tools.cpp</a>.</p>

<p>References <a class="el" href="Array__tools_8cpp_source.html#l00180">fct_qsort_nbcolonnes</a>.</p>

<p>Referenced by <a class="el" href="Array__tools_8cpp_source.html#l00389">tableau_trier_retirer_doublons()</a>, and <a class="el" href="Array__tools_8cpp_source.html#l00237">tri_lexicographique_tableau()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">const</span> <span class="keywordtype">int</span> *t1 = (<span class="keyword">const</span> <span class="keywordtype">int</span> *) ptr1;
  <span class="keyword">const</span> <span class="keywordtype">int</span> *t2 = (<span class="keyword">const</span> <span class="keywordtype">int</span> *) ptr2;
  <span class="keyword">const</span> <span class="keywordtype">int</span> n = <a class="code" href="Array__tools_8cpp.html#af67bfbc2db32195665d72b77c3967ea6">fct_qsort_nbcolonnes</a> - 1;
  <span class="keywordtype">int</span> i;
  <span class="keywordflow">for</span> (i = 0; i &lt; n; i++)
    {
      <span class="keywordtype">int</span> delta = t1[i] - t2[i];
      <span class="keywordflow">if</span> (delta)
        {
<span class="preprocessor">#ifdef INT_is_64_</span>
<span class="preprocessor"></span>          <span class="keywordflow">if</span> (delta&lt;0)
            <span class="keywordflow">return</span> -1;
          <span class="keywordflow">return</span> 1;
<span class="preprocessor">#else</span>
<span class="preprocessor"></span>          <span class="keywordflow">return</span> delta;
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>        }
    }
<span class="preprocessor">#ifdef INT_is_64_</span>
<span class="preprocessor"></span>  <span class="keywordtype">int</span> delta= t1[i] - t2[i];
  <span class="keywordflow">if</span> (delta==0)
    <span class="keywordflow">return</span> 0;
  <span class="keywordflow">if</span> (delta&lt;0)
    <span class="keywordflow">return</span> -1;
  <span class="keywordflow">return</span> 1;
<span class="preprocessor">#else</span>
<span class="preprocessor"></span>  <span class="keywordflow">return</span> t1[i] - t2[i];
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>}
</pre></div>
</div>
</div>
<a class="anchor" id="aadf5cfbe9b9dd86af212343474875076"></a><!-- doxytag: member="Array_tools.cpp::fct_qsort_tableau_n_indirect" ref="aadf5cfbe9b9dd86af212343474875076" args="(const void *ptr1, const void *ptr2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="arch_8h.html#a1caaf369d9c5f0817dbaa76b43b8d87b">True_int</a> fct_qsort_tableau_n_indirect </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>ptr1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>ptr2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Array__tools_8cpp_source.html#l00300">300</a> of file <a class="el" href="Array__tools_8cpp_source.html">Array_tools.cpp</a>.</p>

<p>References <a class="el" href="Array__tools_8cpp_source.html#l00180">fct_qsort_nbcolonnes</a>, and <a class="el" href="Array__tools_8cpp_source.html#l00261">fct_qsort_tab_ptr</a>.</p>

<p>Referenced by <a class="el" href="Array__tools_8cpp_source.html#l00342">tri_lexicographique_tableau_indirect()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">const</span> <span class="keywordtype">int</span> nc = <a class="code" href="Array__tools_8cpp.html#af67bfbc2db32195665d72b77c3967ea6">fct_qsort_nbcolonnes</a>;
  <span class="keywordtype">int</span> t1 = *((<span class="keyword">const</span> <span class="keywordtype">int</span> *) ptr1) * nc;
  <span class="keywordtype">int</span> t2 = *((<span class="keyword">const</span> <span class="keywordtype">int</span> *) ptr2) * nc;
  <span class="keyword">const</span> <a class="code" href="classIntVect.html">IntVect</a>&amp; tab = *<a class="code" href="Array__tools_8cpp.html#ab80f7651089b503e8830e780e804e948">fct_qsort_tab_ptr</a>;
  <span class="keyword">const</span> <span class="keywordtype">int</span> n = nc - 1;
  <span class="keywordtype">int</span> i;
  <span class="keywordflow">for</span> (i = 0; i &lt; n; i++)
    {
      <span class="keywordtype">int</span> delta = tab[t1++] - tab[t2++];
      <span class="keywordflow">if</span> (delta)
        {
<span class="preprocessor">#ifdef INT_is_64_</span>
<span class="preprocessor"></span>          <span class="keywordflow">if</span> (delta&lt;0)
            <span class="keywordflow">return</span> -1;
          <span class="keywordflow">return</span> 1;
<span class="preprocessor">#else</span>
<span class="preprocessor"></span>          <span class="keywordflow">return</span> delta;
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>        }
    }
<span class="preprocessor">#ifdef INT_is_64_</span>
<span class="preprocessor"></span>  <span class="keywordtype">int</span> delta=tab[t1] - tab[t2];
  <span class="keywordflow">if</span> (delta==0)
    <span class="keywordflow">return</span> 0;
  <span class="keywordflow">if</span> (delta&lt;0)
    <span class="keywordflow">return</span> -1;
  <span class="keywordflow">return</span> 1;
<span class="preprocessor">#else</span>
<span class="preprocessor"></span>  <span class="keywordflow">return</span> tab[t1] - tab[t2];
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>
}
</pre></div>
</div>
</div>
<a class="anchor" id="aa9f63ddbdacb389d6cd42b822be6dfbd"></a><!-- doxytag: member="Array_tools.cpp::resize_tab_lines" ref="aa9f63ddbdacb389d6cd42b822be6dfbd" args="(IntTab &amp;tab, const int n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void resize_tab_lines </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classIntTab.html">IntTab</a> &amp;&#160;</td>
          <td class="paramname"><em>tab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Array__tools_8cpp_source.html#l00382">382</a> of file <a class="el" href="Array__tools_8cpp_source.html">Array_tools.cpp</a>.</p>

<p>References <a class="el" href="IntTab_8cpp_source.html#l00344">IntTab::resize_dim0()</a>.</p>

<p>Referenced by <a class="el" href="Array__tools_8cpp_source.html#l00389">tableau_trier_retirer_doublons()</a>.</p>
<div class="fragment"><pre class="fragment">{
  tab.<a class="code" href="classIntTab.html#a425c14e929dedb4760f303ff42a20ee2" title="change la dimension[0] du tableau en conservant les autres.">resize_dim0</a>(n);
}
</pre></div>
</div>
</div>
<a class="anchor" id="ac46e3c4369dd60577776bb46ec92e5a5"></a><!-- doxytag: member="Array_tools.cpp::same_line" ref="ac46e3c4369dd60577776bb46ec92e5a5" args="(const IntVect &amp;v, int i, int j)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int same_line </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIntVect.html">IntVect</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Array__tools_8cpp_source.html#l00439">439</a> of file <a class="el" href="Array__tools_8cpp_source.html">Array_tools.cpp</a>.</p>

<p>References <a class="el" href="IntVect_8h_source.html#l00150">IntVect::line_size()</a>.</p>

<p>Referenced by <a class="el" href="Array__tools_8cpp_source.html#l00456">calculer_renum_sans_doublons()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">const</span> <span class="keywordtype">int</span> ls = v.<a class="code" href="classIntVect.html#a5ba680066169c8e057bb3e3b876e4a8c">line_size</a>();
  <span class="keywordtype">int</span> k;
  <span class="keywordflow">for</span> (k = 0; k &lt; ls; k++)
    <span class="keywordflow">if</span> (v[i*ls+k] != v[j*ls+k])
      <span class="keywordflow">break</span>;
  <span class="keywordflow">return</span> k == ls;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a07eed4c823b0632bdbf353fdab2a3c6b"></a><!-- doxytag: member="Array_tools.cpp::tableau_trier_retirer_doublons" ref="a07eed4c823b0632bdbf353fdab2a3c6b" args="(IntTab &amp;tab)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tableau_trier_retirer_doublons </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classIntTab.html">IntTab</a> &amp;&#160;</td>
          <td class="paramname"><em>tab</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Trie le tableau tab dans l'ordre lexicographique<br/>
et retire les doublons (attention [1,2] n'est pas egal a [2,1]) </p>
<p>Methode outil pour retirer les doublons dans un tableau. </p>

<p><p>&lt; Taille du tableau apres suppression</p>
<p>&lt; Derniere ligne retenue </p>
</p>

<p>Definition at line <a class="el" href="Array__tools_8cpp_source.html#l00389">389</a> of file <a class="el" href="Array__tools_8cpp_source.html">Array_tools.cpp</a>.</p>

<p>References <a class="el" href="Array__tools_8cpp_source.html#l00036">array_retirer_doublons()</a>, <a class="el" href="IntTab_8h_source.html#l00233">IntTab::dimension()</a>, <a class="el" href="Array__tools_8cpp_source.html#l00180">fct_qsort_nbcolonnes</a>, <a class="el" href="Array__tools_8cpp_source.html#l00200">fct_qsort_tableau_n()</a>, <a class="el" href="Array__tools_8cpp_source.html#l00382">resize_tab_lines()</a>, and <a class="el" href="Array__tools_8cpp_source.html#l00237">tri_lexicographique_tableau()</a>.</p>

<p>Referenced by <a class="el" href="Matrix__tools_8cpp_source.html#l00268">Matrix_tools::allocate_for_scaled_addition()</a>, <a class="el" href="Matrix__tools_8cpp_source.html#l00311">Matrix_tools::allocate_for_symmetric_scaled_addition()</a>, <a class="el" href="Assembleur__P__PolyMAC_8cpp_source.html#l00091">Assembleur_P_PolyMAC::assembler_mat()</a>, <a class="el" href="Assembleur__P__EF_8cpp_source.html#l00137">Assembleur_P_EF::assembler_mat()</a>, <a class="el" href="Assembleur__P__CoviMAC_8cpp_source.html#l00068">Assembleur_P_CoviMAC::assembler_mat()</a>, <a class="el" href="Domain__Graph_8cpp_source.html#l00102">Domain_Graph::construire_graph_from_segment()</a>, <a class="el" href="Op__Grad__VDF__Face_8cpp_source.html#l00082">Op_Grad_VDF_Face::dimensionner()</a>, <a class="el" href="Masse__PolyMAC__Face_8cpp_source.html#l00120">Masse_PolyMAC_Face::dimensionner()</a>, <a class="el" href="Masse__PolyMAC__Elem_8cpp_source.html#l00120">Masse_PolyMAC_Elem::dimensionner()</a>, <a class="el" href="Op__Grad__PolyMAC__Face_8cpp_source.html#l00079">Op_Grad_PolyMAC_Face::dimensionner()</a>, <a class="el" href="Op__Div__PolyMAC_8cpp_source.html#l00151">Op_Div_PolyMAC::dimensionner()</a>, <a class="el" href="Op__Diff__PolyMAC__Face_8cpp_source.html#l00071">Op_Diff_PolyMAC_Face::dimensionner()</a>, <a class="el" href="Op__Diff__PolyMAC__Elem_8cpp_source.html#l00179">Op_Diff_PolyMAC_Elem::dimensionner()</a>, <a class="el" href="Op__Conv__EF__Stab__PolyMAC__Face_8cpp_source.html#l00090">Op_Conv_EF_Stab_PolyMAC_Face::dimensionner()</a>, <a class="el" href="Op__EF__base_8cpp_source.html#l00050">Op_EF_base::dimensionner()</a>, <a class="el" href="Op__Div__CoviMAC_8cpp_source.html#l00070">Op_Div_CoviMAC::dimensionner()</a>, <a class="el" href="Op__VDF__Elem_8cpp_source.html#l00182">Op_VDF_Elem::dimensionner_bloc_vitesse()</a>, <a class="el" href="Op__PolyMAC__Elem_8cpp_source.html#l00188">Op_PolyMAC_Elem::dimensionner_bloc_vitesse()</a>, <a class="el" href="Op__Conv__EF__Stab__CoviMAC__Elem_8cpp_source.html#l00147">QDM_Multiphase::dimensionner_blocs()</a>, <a class="el" href="Op__Diff__VDF__Elem__base_8cpp_source.html#l00173">Op_Diff_VDF_Elem_base::dimensionner_termes_croises()</a>, <a class="el" href="Op__Diff__PolyMAC__Elem_8cpp_source.html#l00212">Op_Diff_PolyMAC_Elem::dimensionner_termes_croises()</a>, <a class="el" href="Matrix__tools_8cpp_source.html#l00544">Matrix_tools::extend_matrix_stencil()</a>, <a class="el" href="Zone__PolyMAC_8cpp_source.html#l01331">Zone_PolyMAC::init_m2solv()</a>, and <a class="el" href="Matrice__Base_8cpp_source.html#l00119">Matrice_Base::set_stencil()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_lignes = tab.<a class="code" href="classIntTab.html#abc3b32c94925a82f69d5b153a356e359" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(0);
  <span class="keywordflow">if</span> (nb_lignes == 0)
    <span class="keywordflow">return</span>;

  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_colonnes = <a class="code" href="Array__tools_8cpp.html#a4cfd65b3398623b2011557f6f029f8e6" title="tri lexicographique du tableau tab (par ordre croissant de la premiere colonne, si premiere colonne i...">tri_lexicographique_tableau</a>(tab);

<span class="comment">// Retire les doublons</span>
  <span class="keywordflow">if</span> (nb_colonnes == 1)
    {
      <span class="keyword">const</span> <span class="keywordtype">int</span> new_size = <a class="code" href="Array__tools_8cpp.html#a16494af4ad15ba2b7d71a3706e14ff4f" title="retire les doublons du tableau array (suppose que le tableau est trie dans l&#39;ordre croissant) On depl...">array_retirer_doublons</a>(tab);
      <a class="code" href="Array__tools_8cpp.html#aa9f63ddbdacb389d6cd42b822be6dfbd">resize_tab_lines</a>(tab, new_size);
    }
  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (nb_colonnes == 2)
    {
      <span class="keywordtype">int</span> j = 1; <span class="comment">//!&lt; Taille du tableau apres suppression</span>
<span class="comment"></span>      <span class="keywordtype">int</span> last_x = tab(0, 0);
      <span class="keywordtype">int</span> last_y = tab(0, 1);
      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 1; i &lt; nb_lignes; i++)
        {
          <span class="keyword">const</span> <span class="keywordtype">int</span> x = tab(i, 0);
          <span class="keyword">const</span> <span class="keywordtype">int</span> y = tab(i, 1);
          <span class="keywordflow">if</span> (x != last_x || y != last_y)
            {
              tab(j, 0) = last_x = x;
              tab(j, 1) = last_y = y;
              j++;
            }
        }
      <a class="code" href="Array__tools_8cpp.html#aa9f63ddbdacb389d6cd42b822be6dfbd">resize_tab_lines</a>(tab, j);
    }
  <span class="keywordflow">else</span>
    {
      <span class="keywordtype">int</span> j = 0; <span class="comment">//!&lt; Derniere ligne retenue</span>
<span class="comment"></span>      <a class="code" href="Array__tools_8cpp.html#af67bfbc2db32195665d72b77c3967ea6">fct_qsort_nbcolonnes</a> = nb_colonnes;
      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 1; i &lt; nb_lignes; i++)
        {
<span class="comment">// Si la ligne i est differente de la ligne j, on la conserve:</span>
          <span class="keywordflow">if</span> (!<a class="code" href="Array__tools_8cpp.html#a0a28fc2f3126a1e1efb0053b3d09b226">fct_qsort_tableau_n</a>(&amp;tab(i, 0), &amp;tab(j, 0)))
            {
              j++;
              <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k = 0; k &lt; nb_colonnes; k++)
                tab(j, k) = tab(i, k);
            }
        }
      <a class="code" href="Array__tools_8cpp.html#aa9f63ddbdacb389d6cd42b822be6dfbd">resize_tab_lines</a>(tab, j+1);
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a4cfd65b3398623b2011557f6f029f8e6"></a><!-- doxytag: member="Array_tools.cpp::tri_lexicographique_tableau" ref="a4cfd65b3398623b2011557f6f029f8e6" args="(IntTab &amp;tab)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int tri_lexicographique_tableau </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classIntTab.html">IntTab</a> &amp;&#160;</td>
          <td class="paramname"><em>tab</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>tri lexicographique du tableau tab (par ordre croissant<br/>
de la premiere colonne, si premiere colonne identique, ordre croissant<br/>
de la deuxieme, etc).<br/>
Le tableau ne doit pas etre un tableau distribue.<br/>
Valeur de retour: nombre de colonnes du tableau (produit des tab.dimension(i) pour i&gt;0) </p>
<p>Tri lexicographique d'un tableau. </p>

<p>Definition at line <a class="el" href="Array__tools_8cpp_source.html#l00237">237</a> of file <a class="el" href="Array__tools_8cpp_source.html">Array_tools.cpp</a>.</p>

<p>References <a class="el" href="ArrOfInt_8h_source.html#l00371">ArrOfInt::addr()</a>, <a class="el" href="IntTab_8h_source.html#l00233">IntTab::dimension()</a>, <a class="el" href="Array__tools_8cpp_source.html#l00180">fct_qsort_nbcolonnes</a>, <a class="el" href="Array__tools_8cpp_source.html#l00182">fct_qsort_tableau_2()</a>, <a class="el" href="Array__tools_8cpp_source.html#l00200">fct_qsort_tableau_n()</a>, <a class="el" href="IntVect_8h_source.html#l00087">IntVect::get_md_vector()</a>, <a class="el" href="IntVect_8h_source.html#l00150">IntVect::line_size()</a>, <a class="el" href="MD__Vector_8h_source.html#l00063">MD_Vector::non_nul()</a>, and <a class="el" href="ArrOfInt_8cpp_source.html#l00897">ArrOfInt::ordonne_array()</a>.</p>

<p>Referenced by <a class="el" href="ExtrudeParoi_8cpp_source.html#l00159">ExtrudeParoi::extrude()</a>, and <a class="el" href="Array__tools_8cpp_source.html#l00389">tableau_trier_retirer_doublons()</a>.</p>
<div class="fragment"><pre class="fragment">{
<span class="comment">// On verifie que le tableau n&#39;est pas un tableau distribue:</span>
  assert(!tab.<a class="code" href="classIntVect.html#ae74e1fee6aca124d32718267e33a40c6">get_md_vector</a>().<a class="code" href="classMD__Vector.html#a4165c00904b7096274e38fdc7ca340f4">non_nul</a>());

  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_lignes = tab.<a class="code" href="classIntTab.html#abc3b32c94925a82f69d5b153a356e359" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(0);
  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_colonnes = tab.<a class="code" href="classIntVect.html#a5ba680066169c8e057bb3e3b876e4a8c">line_size</a>();

  <span class="keywordflow">if</span> (nb_lignes != 0)
    {
      <span class="keywordflow">if</span> (nb_colonnes == 1)
        tab.<a class="code" href="classArrOfInt.html#abb0f48cf5a4be4b70edcc90baaebd521" title="Tri des valeurs du tableau dans l&#39;ordre croissant. La fonction utilisee est qsort de stdlib (elle est...">ordonne_array</a>();
      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (nb_colonnes == 2)
        qsort(tab.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>(), nb_lignes, nb_colonnes * <span class="keyword">sizeof</span>(int), <a class="code" href="Array__tools_8cpp.html#a08e0b88b572e3a591b53b3c890c760ec">fct_qsort_tableau_2</a>);
      <span class="keywordflow">else</span>
        {
          <a class="code" href="Array__tools_8cpp.html#af67bfbc2db32195665d72b77c3967ea6">fct_qsort_nbcolonnes</a> = nb_colonnes;
          qsort(tab.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>(), nb_lignes, nb_colonnes * <span class="keyword">sizeof</span>(int), <a class="code" href="Array__tools_8cpp.html#a0a28fc2f3126a1e1efb0053b3d09b226">fct_qsort_tableau_n</a>);
        }
    }

  <span class="keywordflow">return</span> nb_colonnes;
}
</pre></div>
</div>
</div>
<a class="anchor" id="ad62171ccb6e8fd4b2be47d286c164999"></a><!-- doxytag: member="Array_tools.cpp::tri_lexicographique_tableau_indirect" ref="ad62171ccb6e8fd4b2be47d286c164999" args="(const IntTab &amp;tab, ArrOfInt &amp;index)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int tri_lexicographique_tableau_indirect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIntTab.html">IntTab</a> &amp;&#160;</td>
          <td class="paramname"><em>tab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Idem que tri_lexicographique_tableau mais on trie le tableau index qui<br/>
contient les indices de lignes du tableau tab tel que tab(index[i], *) soit<br/>
croissant quant i augmente. Tri de tous les indices de index...<br/>
Si le tableau index est de taille nulle, on en cree un de taille tab.dimension_tot(0)<br/>
Sinon on suppose qu'il contient deja des indices de lignes dans tab.<br/>
Valeur de retour: nombre de colonnes du tableau (produit des tab.dimension(i) pour i&gt;0) </p>
<p>Tri indirect (on trie le tableau index qui contient des numeros de lignes dans tab) </p>

<p>Definition at line <a class="el" href="Array__tools_8cpp_source.html#l00342">342</a> of file <a class="el" href="Array__tools_8cpp_source.html">Array_tools.cpp</a>.</p>

<p>References <a class="el" href="ArrOfInt_8h_source.html#l00371">ArrOfInt::addr()</a>, <a class="el" href="EntreeSortie_8h_source.html#l00032">Cerr</a>, <a class="el" href="IntTab_8h_source.html#l00244">IntTab::dimension_tot()</a>, <a class="el" href="Process_8cpp_source.html#l00223">Process::exit()</a>, <a class="el" href="Array__tools_8cpp_source.html#l00180">fct_qsort_nbcolonnes</a>, <a class="el" href="Array__tools_8cpp_source.html#l00263">fct_qsort_tableau_1_indirect()</a>, <a class="el" href="Array__tools_8cpp_source.html#l00280">fct_qsort_tableau_2_indirect()</a>, <a class="el" href="Array__tools_8cpp_source.html#l00300">fct_qsort_tableau_n_indirect()</a>, <a class="el" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>, <a class="el" href="IntVect_8h_source.html#l00087">IntVect::get_md_vector()</a>, <a class="el" href="IntVect_8h_source.html#l00150">IntVect::line_size()</a>, <a class="el" href="Array__base_8h_source.html#l00038">Array_base::NOCOPY_NOINIT</a>, <a class="el" href="MD__Vector_8h_source.html#l00063">MD_Vector::non_nul()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00240">ArrOfInt::resize_array()</a>, and <a class="el" href="ArrOfInt_8h_source.html#l00342">ArrOfInt::size_array()</a>.</p>

<p>Referenced by <a class="el" href="Raffiner__Simplexes_8cpp_source.html#l00512">build_edges()</a>, <a class="el" href="Array__tools_8cpp_source.html#l00456">calculer_renum_sans_doublons()</a>, <a class="el" href="Matrice__Morse_8cpp_source.html#l01968">Matrice_Morse::get_stencil_and_coefficients()</a>, and <a class="el" href="Matrice__Morse__Sym_8cpp_source.html#l00748">Matrice_Morse_Sym::get_symmetric_stencil_and_coefficients()</a>.</p>
<div class="fragment"><pre class="fragment">{
<span class="comment">// On verifie que le tableau n&#39;est pas un tableau distribue:</span>
  assert(!tab.<a class="code" href="classIntVect.html#ae74e1fee6aca124d32718267e33a40c6">get_md_vector</a>().<a class="code" href="classMD__Vector.html#a4165c00904b7096274e38fdc7ca340f4">non_nul</a>());

  <span class="keyword">const</span> <span class="keywordtype">int</span> dimtab = tab.<a class="code" href="classIntTab.html#a71e9b9ddc1793094b1b3f109377952b1" title="Returns the total dimensions of the multi-dimensionnal array, including virtual items (used in parall...">dimension_tot</a>(0);
  <span class="keywordflow">if</span> (index.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() == 0 &amp;&amp; dimtab &gt; 0)
    {
      index.<a class="code" href="classArrOfInt.html#a9b3afbb46b16870dbd36236c8935b535">resize_array</a>(dimtab, <a class="code" href="classArray__base.html#abee342aa9ac59623c4c782dc9d7877ffaf6ae9ba7eb51c5f298ce693345b3ec68">Array_base::NOCOPY_NOINIT</a>);
      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; dimtab; i++)
        index[i] = i;
    }

  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_lignes = index.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_colonnes = tab.<a class="code" href="classIntVect.html#a5ba680066169c8e057bb3e3b876e4a8c">line_size</a>();

  <span class="keywordflow">if</span> (nb_lignes != 0)
    {
      <span class="keywordflow">if</span> (<a class="code" href="Array__tools_8cpp.html#ab80f7651089b503e8830e780e804e948">fct_qsort_tab_ptr</a>)
        {
          <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Internal error in tri_lexicographique_tableau_indirect !&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
          <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">Process::exit</a>();
<span class="comment">// Aie ! on essaye de faire du multithread ??? acces concurrent au pointeur</span>
        }
      <a class="code" href="Array__tools_8cpp.html#ab80f7651089b503e8830e780e804e948">fct_qsort_tab_ptr</a> = &amp;tab;
      <span class="keywordflow">if</span> (nb_colonnes == 1)
        qsort(index.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>(), index.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>(), <span class="keyword">sizeof</span>(int), <a class="code" href="Array__tools_8cpp.html#a6874e40139a04edd33dde69a7b610bec">fct_qsort_tableau_1_indirect</a>);
      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (nb_colonnes == 2)
        qsort(index.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>(), index.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>(), <span class="keyword">sizeof</span>(int), <a class="code" href="Array__tools_8cpp.html#a968cac169ba5ddbcebb8d20da67cdee4">fct_qsort_tableau_2_indirect</a>);
      <span class="keywordflow">else</span>
        {
          <a class="code" href="Array__tools_8cpp.html#af67bfbc2db32195665d72b77c3967ea6">fct_qsort_nbcolonnes</a> = nb_colonnes;
          qsort(index.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>(), index.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>(), <span class="keyword">sizeof</span>(int), <a class="code" href="Array__tools_8cpp.html#aadf5cfbe9b9dd86af212343474875076">fct_qsort_tableau_n_indirect</a>);
        }
      <a class="code" href="Array__tools_8cpp.html#ab80f7651089b503e8830e780e804e948">fct_qsort_tab_ptr</a> = 0;
    }

  <span class="keywordflow">return</span> nb_colonnes;
}
</pre></div>
</div>
</div>
<hr/><h2>Variable Documentation</h2>
<a class="anchor" id="af67bfbc2db32195665d72b77c3967ea6"></a><!-- doxytag: member="Array_tools.cpp::fct_qsort_nbcolonnes" ref="af67bfbc2db32195665d72b77c3967ea6" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="Array__tools_8cpp.html#af67bfbc2db32195665d72b77c3967ea6">fct_qsort_nbcolonnes</a><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Array__tools_8cpp_source.html#l00180">180</a> of file <a class="el" href="Array__tools_8cpp_source.html">Array_tools.cpp</a>.</p>

<p>Referenced by <a class="el" href="Array__tools_8cpp_source.html#l00200">fct_qsort_tableau_n()</a>, <a class="el" href="Array__tools_8cpp_source.html#l00300">fct_qsort_tableau_n_indirect()</a>, <a class="el" href="Array__tools_8cpp_source.html#l00389">tableau_trier_retirer_doublons()</a>, <a class="el" href="Array__tools_8cpp_source.html#l00237">tri_lexicographique_tableau()</a>, and <a class="el" href="Array__tools_8cpp_source.html#l00342">tri_lexicographique_tableau_indirect()</a>.</p>

</div>
</div>
<a class="anchor" id="ab80f7651089b503e8830e780e804e948"></a><!-- doxytag: member="Array_tools.cpp::fct_qsort_tab_ptr" ref="ab80f7651089b503e8830e780e804e948" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classIntVect.html">IntVect</a>* <a class="el" href="Array__tools_8cpp.html#ab80f7651089b503e8830e780e804e948">fct_qsort_tab_ptr</a> = 0<code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Array__tools_8cpp_source.html#l00261">261</a> of file <a class="el" href="Array__tools_8cpp_source.html">Array_tools.cpp</a>.</p>

<p>Referenced by <a class="el" href="Array__tools_8cpp_source.html#l00263">fct_qsort_tableau_1_indirect()</a>, <a class="el" href="Array__tools_8cpp_source.html#l00280">fct_qsort_tableau_2_indirect()</a>, and <a class="el" href="Array__tools_8cpp_source.html#l00300">fct_qsort_tableau_n_indirect()</a>.</p>

</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Tue Dec 14 2021 19:35:51 for TRUST by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
