<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>TRUST: src/Kernel/Math/IntVect.cpp File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">TRUST&#160;<span id="projectnumber">1.8.4</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">src/Kernel/Math/IntVect.cpp File Reference</div>  </div>
</div>
<div class="contents">
<div class="textblock"><code>#include &lt;<a class="el" href="IntVect_8h_source.html">IntVect.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="MD__Vector__base_8h_source.html">MD_Vector_base.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="MD__Vector__tools_8h_source.html">MD_Vector_tools.h</a>&gt;</code><br/>
<code>#include &lt;limits.h&gt;</code><br/>
<code>#include &lt;<a class="el" href="communications_8h_source.html">communications.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="DescStructure_8h_source.html">DescStructure.h</a>&gt;</code><br/>
</div>
<p><a href="IntVect_8cpp_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="IntVect_8cpp.html#ade146e7b644bec7ea5b5c6fcb88fe2a9">operator==</a> (const <a class="el" href="classIntVect.html">IntVect</a> &amp;x, const <a class="el" href="classIntVect.html">IntVect</a> &amp;y)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">renvoie 1 si meme strucuture parallele et egalite au sens ArrOfInt&lt;br&gt;(y compris espaces virtuels)<br/>
BM: faut-il etre aussi strict, comparer uniquement size() elements ?  <a href="#ade146e7b644bec7ea5b5c6fcb88fe2a9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="IntVect_8cpp.html#afe7b6a7310bafb543df557a0d845e3e4">operator!=</a> (const <a class="el" href="classIntVect.html">IntVect</a> &amp;x, const <a class="el" href="classIntVect.html">IntVect</a> &amp;y)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="IntVect_8cpp.html#a27f59c580905a55953c9aa2734a1fc73">invalidate_data</a> (<a class="el" href="classIntVect.html">IntVect</a> &amp;resu, <a class="el" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a> opt)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="IntVect_8cpp.html#aab2906ce876a975f702755e7b57e6a2a">local_prodscal</a> (const <a class="el" href="classIntVect.html">IntVect</a> &amp;vx, const <a class="el" href="classIntVect.html">IntVect</a> &amp;vy)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Renvoie la somme des x[i]*y[i] pour les items sequentiels sur ce processeur.<br/>
(tous les items si pas de structure parallele, sinon voir <a class="el" href="classMD__Vector__base.html#a7f6b6d0b7babfec0cce590cdea5bca53">MD_Vector_base::get_items_to_sum()</a>  <a href="#aab2906ce876a975f702755e7b57e6a2a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="IntVect_8cpp.html#aa5360fa2e8b71e106eb7690fb0df05fb">local_carre_norme_vect</a> (const <a class="el" href="classIntVect.html">IntVect</a> &amp;vx)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="IntVect_8cpp.html#a277f42a42c9d9bb5add1240251922a63">mp_carre_norme_vect</a> (const <a class="el" href="classIntVect.html">IntVect</a> &amp;vx)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="IntVect_8cpp.html#a884eff5c3e13bc9e38ccccd49be3ca03">local_somme_vect</a> (const <a class="el" href="classIntVect.html">IntVect</a> &amp;vx)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="IntVect_8cpp.html#aa443ab516872b5fab7a1b473d0937dfc">mp_somme_vect</a> (const <a class="el" href="classIntVect.html">IntVect</a> &amp;vx)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="IntVect_8cpp.html#a958bca1ebccdb01b6e5b997b865335fd">local_imin_vect</a> (const <a class="el" href="classIntVect.html">IntVect</a> &amp;vx, <a class="el" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a> opt)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="IntVect_8cpp.html#a5e9c0fc1b45d55d995607d0f38008400">local_min_vect</a> (const <a class="el" href="classIntVect.html">IntVect</a> &amp;vx, <a class="el" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a> opt)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="IntVect_8cpp.html#a2b558c2f2d6327a397c93b67e750b685">local_imax_vect</a> (const <a class="el" href="classIntVect.html">IntVect</a> &amp;vx, <a class="el" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a> opt)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="IntVect_8cpp.html#ae86224cad06471b195b23ee0a599eae6">local_max_vect</a> (const <a class="el" href="classIntVect.html">IntVect</a> &amp;vx, <a class="el" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a> opt)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="IntVect_8cpp.html#a3136e23feb019b080a20b417a63baf1b">local_max_abs_vect</a> (const <a class="el" href="classIntVect.html">IntVect</a> &amp;vx, <a class="el" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a> opt)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="IntVect_8cpp.html#a4a2b59fec7838ff4c00f8ed772eb83c1">local_min_abs_vect</a> (const <a class="el" href="classIntVect.html">IntVect</a> &amp;vx, <a class="el" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a> opt)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="IntVect_8cpp.html#aafa46b52a972256717da9fd2079df15c">operator_abs</a> (<a class="el" href="classIntVect.html">IntVect</a> &amp;resu, <a class="el" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a> opt)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="IntVect_8cpp.html#abacecb9b90f28486608b021d1cdbcb6b">operator_add</a> (<a class="el" href="classIntVect.html">IntVect</a> &amp;resu, const <a class="el" href="classIntVect.html">IntVect</a> &amp;vx, <a class="el" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a> opt)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="IntVect_8cpp.html#a0e31906db9339bbe43812959c7863353">operator_add</a> (<a class="el" href="classIntVect.html">IntVect</a> &amp;resu, const int x, <a class="el" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a> opt)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="IntVect_8cpp.html#a9dc30ad5fe3fcd14ea3e0420d395fb9e">operator_sub</a> (<a class="el" href="classIntVect.html">IntVect</a> &amp;resu, const <a class="el" href="classIntVect.html">IntVect</a> &amp;vx, <a class="el" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a> opt)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="IntVect_8cpp.html#a6c45faa85a0bdc6bd991b1829f046966">operator_sub</a> (<a class="el" href="classIntVect.html">IntVect</a> &amp;resu, const int x, <a class="el" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a> opt)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="IntVect_8cpp.html#abe3fa2147bc123ba67a00607d6a69625">operator_multiply</a> (<a class="el" href="classIntVect.html">IntVect</a> &amp;resu, const <a class="el" href="classIntVect.html">IntVect</a> &amp;vx, <a class="el" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a> opt)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="IntVect_8cpp.html#afd42ad14b013f889cbd1fbd8938f8ed8">operator_multiply</a> (<a class="el" href="classIntVect.html">IntVect</a> &amp;resu, const int x, <a class="el" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a> opt)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="IntVect_8cpp.html#af2456449b8237b76d4b371c9de1e4af2">operator_negate</a> (<a class="el" href="classIntVect.html">IntVect</a> &amp;resu, <a class="el" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a> opt)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="IntVect_8cpp.html#a1d7ecc85770b9a137e48bbebf2490fca">operator_egal</a> (<a class="el" href="classIntVect.html">IntVect</a> &amp;resu, int x, <a class="el" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a> opt)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="IntVect_8cpp.html#a6524c227e7647f6f1a3c80853e573c49">operator_egal</a> (<a class="el" href="classIntVect.html">IntVect</a> &amp;resu, const <a class="el" href="classIntVect.html">IntVect</a> &amp;vx, <a class="el" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a> opt)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="IntVect_8cpp.html#a1d36c55404bb2f2f8fa32977333571e4">operator_divide</a> (<a class="el" href="classIntVect.html">IntVect</a> &amp;resu, const int x, <a class="el" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a> opt)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="IntVect_8cpp.html#a25dce1b6f82a2bea6851e98ac4d59b7b">mp_max_vect</a> (const <a class="el" href="classIntVect.html">IntVect</a> &amp;x, <a class="el" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a> opt)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="IntVect_8cpp.html#ae2dd393da8943baf0bd3ade274cad458">mp_min_vect</a> (const <a class="el" href="classIntVect.html">IntVect</a> &amp;x, <a class="el" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a> opt)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="IntVect_8cpp.html#a885fd04c0974ac5ee8c725638dcc6992">mp_max_abs_vect</a> (const <a class="el" href="classIntVect.html">IntVect</a> &amp;x, <a class="el" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a> opt)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="IntVect_8cpp.html#a5873b117ba560b744d0db8c24b4301ba">mp_min_abs_vect</a> (const <a class="el" href="classIntVect.html">IntVect</a> &amp;x, <a class="el" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a> opt)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="IntVect_8cpp.html#adb38ccd0360090be713e44ee90b80cd8">mp_prodscal</a> (const <a class="el" href="classIntVect.html">IntVect</a> &amp;x, const <a class="el" href="classIntVect.html">IntVect</a> &amp;y)</td></tr>
<tr><td colspan="2"><h2><a name="var-members"></a>
Variables</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classType__info.html">Type_info</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="IntVect_8cpp.html#a26d5958ec73b0ea0949cfa0ea08cfbcc">IntVectbases</a> [1] = { &amp;( <a class="el" href="classArrOfInt.html">ArrOfInt</a> ::info_obj)}</td></tr>
</table>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a27f59c580905a55953c9aa2734a1fc73"></a><!-- doxytag: member="IntVect.cpp::invalidate_data" ref="a27f59c580905a55953c9aa2734a1fc73" args="(IntVect &amp;resu, Mp_vect_options opt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void invalidate_data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classIntVect.html">IntVect</a> &amp;&#160;</td>
          <td class="paramname"><em>resu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a>&#160;</td>
          <td class="paramname"><em>opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>&lt; no invalid values </p>
</p>

<p>Definition at line <a class="el" href="IntVect_8cpp_source.html#l00367">367</a> of file <a class="el" href="IntVect_8cpp_source.html">IntVect.cpp</a>.</p>

<p>References <a class="el" href="ArrOfInt_8h_source.html#l00371">ArrOfInt::addr()</a>, <a class="el" href="classMD__Vector__base.html#a99334ac2566d9457c8d4890ba20883ea">MD_Vector_base::get_items_to_compute()</a>, <a class="el" href="classMD__Vector__base.html#a7f6b6d0b7babfec0cce590cdea5bca53">MD_Vector_base::get_items_to_sum()</a>, <a class="el" href="IntVect_8h_source.html#l00087">IntVect::get_md_vector()</a>, <a class="el" href="IntVect_8h_source.html#l00150">IntVect::line_size()</a>, <a class="el" href="MD__Vector_8h_source.html#l00063">MD_Vector::non_nul()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00342">ArrOfInt::size_array()</a>, <a class="el" href="MD__Vector_8h_source.html#l00067">MD_Vector::valeur()</a>, <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_ALL_ITEMS</a>, <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_REAL_ITEMS</a>, and <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_SEQUENTIAL_ITEMS</a>.</p>

<p>Referenced by <a class="el" href="IntVect_8cpp_source.html#l00931">operator_abs()</a>, <a class="el" href="IntVect_8cpp_source.html#l00987">operator_add()</a>, <a class="el" href="IntVect_8cpp_source.html#l01519">operator_divide()</a>, <a class="el" href="IntVect_8cpp_source.html#l01400">operator_egal()</a>, <a class="el" href="IntVect_8cpp_source.html#l01225">operator_multiply()</a>, <a class="el" href="IntVect_8cpp_source.html#l01344">operator_negate()</a>, and <a class="el" href="IntVect_8cpp_source.html#l01106">operator_sub()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">const</span> <span class="keywordtype">int</span> invalid = INT_MAX;
  <span class="keyword">const</span> <a class="code" href="classMD__Vector.html" title=": Cette classe est un DERIV mais l&#39;objet pointe est partage entre plusieurs instances de cette classe...">MD_Vector</a>&amp; md = resu.<a class="code" href="classIntVect.html#ae74e1fee6aca124d32718267e33a40c6">get_md_vector</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> line_size = resu.<a class="code" href="classIntVect.html#a5ba680066169c8e057bb3e3b876e4a8c">line_size</a>();
  <span class="keywordflow">if</span> (opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caad18680091a9f62247573cb3caa6450b9">VECT_ALL_ITEMS</a> || (!md.<a class="code" href="classMD__Vector.html#a4165c00904b7096274e38fdc7ca340f4">non_nul</a>()))
    <span class="keywordflow">return</span>; <span class="comment">//!&lt; no invalid values</span>
<span class="comment"></span>  assert(opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a> || opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caab47906d8d2e6c20f8ba32e4acb6edbe0">VECT_REAL_ITEMS</a>);
  <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; items_blocs = (opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a>) ? md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a7f6b6d0b7babfec0cce590cdea5bca53">get_items_to_sum</a>() : md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a99334ac2566d9457c8d4890ba20883ea">get_items_to_compute</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> blocs_size = items_blocs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>();
  <span class="keywordtype">int</span> i = 0;
  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> blocs_idx = 0; blocs_idx &lt; blocs_size; blocs_idx += 2)
    {
<span class="comment">// process data until beginning of next bloc, or end of array</span>
      <span class="keyword">const</span> <span class="keywordtype">int</span> bloc_end = line_size * items_blocs[blocs_idx];
      <span class="keywordtype">int</span> *ptr = resu.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() + i;
      <span class="keywordflow">for</span> (; i &lt; bloc_end; i++)
        *(ptr++) = invalid;
      i = items_blocs[blocs_idx+1] * line_size;
    }
<span class="comment">// Process until end of vector</span>
  <span class="keyword">const</span> <span class="keywordtype">int</span> bloc_end = resu.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>();
  <span class="keywordtype">int</span> *ptr = resu.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() + i;
  <span class="keywordflow">for</span> (; i &lt; bloc_end; i++)
    *(ptr++) = invalid;
}
</pre></div>
</div>
</div>
<a class="anchor" id="aa5360fa2e8b71e106eb7690fb0df05fb"></a><!-- doxytag: member="IntVect.cpp::local_carre_norme_vect" ref="aa5360fa2e8b71e106eb7690fb0df05fb" args="(const IntVect &amp;vx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int local_carre_norme_vect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIntVect.html">IntVect</a> &amp;&#160;</td>
          <td class="paramname"><em>vx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>&lt; this test is necessary if md is null </p>
</p>

<p>Definition at line <a class="el" href="IntVect_8cpp_source.html#l00469">469</a> of file <a class="el" href="IntVect_8cpp_source.html">IntVect.cpp</a>.</p>

<p>References <a class="el" href="ArrOfInt_8h_source.html#l00371">ArrOfInt::addr()</a>, <a class="el" href="classMD__Vector__base.html#a99334ac2566d9457c8d4890ba20883ea">MD_Vector_base::get_items_to_compute()</a>, <a class="el" href="classMD__Vector__base.html#a7f6b6d0b7babfec0cce590cdea5bca53">MD_Vector_base::get_items_to_sum()</a>, <a class="el" href="IntVect_8h_source.html#l00087">IntVect::get_md_vector()</a>, <a class="el" href="IntVect_8h_source.html#l00150">IntVect::line_size()</a>, <a class="el" href="MD__Vector_8h_source.html#l00063">MD_Vector::non_nul()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00342">ArrOfInt::size_array()</a>, <a class="el" href="IntVect_8h_source.html#l00145">IntVect::size_totale()</a>, <a class="el" href="MD__Vector_8h_source.html#l00067">MD_Vector::valeur()</a>, <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_ALL_ITEMS</a>, <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_REAL_ITEMS</a>, and <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_SEQUENTIAL_ITEMS</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">int</span> sum = 0;
<span class="comment">// Master vect donne la structure de reference, les autres vecteurs</span>
<span class="comment">// doivent avoir la meme structure.</span>
  <span class="keyword">const</span> <a class="code" href="classIntVect.html">IntVect</a>&amp; master_vect = vx;
  <span class="keywordtype">int</span> line_size = master_vect.<a class="code" href="classIntVect.html#a5ba680066169c8e057bb3e3b876e4a8c">line_size</a>();
  <span class="keyword">const</span> <a class="code" href="classMD__Vector.html" title=": Cette classe est un DERIV mais l&#39;objet pointe est partage entre plusieurs instances de cette classe...">MD_Vector</a>&amp; md = master_vect.<a class="code" href="classIntVect.html#ae74e1fee6aca124d32718267e33a40c6">get_md_vector</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> vect_size_tot = master_vect.<a class="code" href="classIntVect.html#afa716e1f0a1f0f74f4f73e95b5651412" title="Identique a size_array()">size_totale</a>();
  assert(vx.<a class="code" href="classIntVect.html#a5ba680066169c8e057bb3e3b876e4a8c">line_size</a>() == line_size);
  assert(vx.<a class="code" href="classIntVect.html#afa716e1f0a1f0f74f4f73e95b5651412" title="Identique a size_array()">size_totale</a>() == vect_size_tot); <span class="comment">//!&lt; this test is necessary if md is null</span>
<span class="comment"></span>  assert(vx.<a class="code" href="classIntVect.html#ae74e1fee6aca124d32718267e33a40c6">get_md_vector</a>() == md);
<span class="comment">// Determine blocs of data to process, depending on &quot; VECT_SEQUENTIAL_ITEMS&quot;</span>
  <span class="keywordtype">int</span> nblocs_left = 1;
  <span class="keywordtype">int</span> one_bloc[2];
  <span class="keyword">const</span> <span class="keywordtype">int</span> *bloc_ptr;
  <span class="keywordflow">if</span> ( <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a> != <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caad18680091a9f62247573cb3caa6450b9">VECT_ALL_ITEMS</a> &amp;&amp; md.<a class="code" href="classMD__Vector.html#a4165c00904b7096274e38fdc7ca340f4">non_nul</a>())
    {
      assert( <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a> == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a> ||  <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a> == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caab47906d8d2e6c20f8ba32e4acb6edbe0">VECT_REAL_ITEMS</a>);
      <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; items_blocs = ( <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a> == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a>) ? md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a7f6b6d0b7babfec0cce590cdea5bca53">get_items_to_sum</a>() : md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a99334ac2566d9457c8d4890ba20883ea">get_items_to_compute</a>();
      assert(items_blocs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() % 2 == 0);
      nblocs_left = items_blocs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() &gt;&gt; 1;
      bloc_ptr = items_blocs.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
    }
  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (vect_size_tot &gt; 0)
    {
<span class="comment">// attention, si vect_size_tot est nul, line_size a le droit d&#39;etre nul</span>
<span class="comment">// Compute all data, in the vector (including virtual data), build a big bloc:</span>
      nblocs_left = 1;
      bloc_ptr = one_bloc;
      one_bloc[0] = 0;
      one_bloc[1] = vect_size_tot / line_size;
    }
  <span class="keywordflow">else</span>
    {
<span class="comment">// raccourci pour les tableaux vides (evite le cas particulier line_size == 0)</span>
      <span class="keywordflow">return</span>  sum;
    }
  <span class="keyword">const</span> <span class="keywordtype">int</span> *x_base = vx.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
  <span class="keywordflow">for</span> (; nblocs_left; nblocs_left--)
    {
<span class="comment">// Get index of next bloc start:</span>
      <span class="keyword">const</span> <span class="keywordtype">int</span> begin_bloc = (*(bloc_ptr++)) * line_size;
      <span class="keyword">const</span> <span class="keywordtype">int</span> end_bloc = (*(bloc_ptr++)) * line_size;
      assert(begin_bloc &gt;= 0 &amp;&amp; end_bloc &lt;= vect_size_tot &amp;&amp; end_bloc &gt;= begin_bloc);
      <span class="keyword">const</span> <span class="keywordtype">int</span>* x_ptr = x_base + begin_bloc;
      <span class="keywordtype">int</span> count = end_bloc - begin_bloc;
      <span class="keywordflow">for</span> (; count; count--)
        {
          <span class="keyword">const</span> <span class="keywordtype">int</span> x = *x_ptr;
          sum += x * x;
          x_ptr++;
        }
    }
  <span class="keywordflow">return</span>  sum;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a2b558c2f2d6327a397c93b67e750b685"></a><!-- doxytag: member="IntVect.cpp::local_imax_vect" ref="a2b558c2f2d6327a397c93b67e750b685" args="(const IntVect &amp;vx, Mp_vect_options opt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int local_imax_vect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIntVect.html">IntVect</a> &amp;&#160;</td>
          <td class="paramname"><em>vx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a>&#160;</td>
          <td class="paramname"><em>opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>&lt; this test is necessary if md is null </p>
</p>

<p>Definition at line <a class="el" href="IntVect_8cpp_source.html#l00704">704</a> of file <a class="el" href="IntVect_8cpp_source.html">IntVect.cpp</a>.</p>

<p>References <a class="el" href="ArrOfInt_8h_source.html#l00371">ArrOfInt::addr()</a>, <a class="el" href="classMD__Vector__base.html#a99334ac2566d9457c8d4890ba20883ea">MD_Vector_base::get_items_to_compute()</a>, <a class="el" href="classMD__Vector__base.html#a7f6b6d0b7babfec0cce590cdea5bca53">MD_Vector_base::get_items_to_sum()</a>, <a class="el" href="IntVect_8h_source.html#l00087">IntVect::get_md_vector()</a>, <a class="el" href="IntVect_8h_source.html#l00150">IntVect::line_size()</a>, <a class="el" href="MD__Vector_8h_source.html#l00063">MD_Vector::non_nul()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00342">ArrOfInt::size_array()</a>, <a class="el" href="IntVect_8h_source.html#l00145">IntVect::size_totale()</a>, <a class="el" href="MD__Vector_8h_source.html#l00067">MD_Vector::valeur()</a>, <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_ALL_ITEMS</a>, <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_REAL_ITEMS</a>, and <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_SEQUENTIAL_ITEMS</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">int</span> max_val = INT_MIN;;
  <span class="keywordtype">int</span> i_max = -1;
<span class="comment">// Master vect donne la structure de reference, les autres vecteurs</span>
<span class="comment">// doivent avoir la meme structure.</span>
  <span class="keyword">const</span> <a class="code" href="classIntVect.html">IntVect</a>&amp; master_vect = vx;
  <span class="keywordtype">int</span> line_size = master_vect.<a class="code" href="classIntVect.html#a5ba680066169c8e057bb3e3b876e4a8c">line_size</a>();
  <span class="keyword">const</span> <a class="code" href="classMD__Vector.html" title=": Cette classe est un DERIV mais l&#39;objet pointe est partage entre plusieurs instances de cette classe...">MD_Vector</a>&amp; md = master_vect.<a class="code" href="classIntVect.html#ae74e1fee6aca124d32718267e33a40c6">get_md_vector</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> vect_size_tot = master_vect.<a class="code" href="classIntVect.html#afa716e1f0a1f0f74f4f73e95b5651412" title="Identique a size_array()">size_totale</a>();
  assert(vx.<a class="code" href="classIntVect.html#a5ba680066169c8e057bb3e3b876e4a8c">line_size</a>() == line_size);
  assert(vx.<a class="code" href="classIntVect.html#afa716e1f0a1f0f74f4f73e95b5651412" title="Identique a size_array()">size_totale</a>() == vect_size_tot); <span class="comment">//!&lt; this test is necessary if md is null</span>
<span class="comment"></span>  assert(vx.<a class="code" href="classIntVect.html#ae74e1fee6aca124d32718267e33a40c6">get_md_vector</a>() == md);
<span class="comment">// Determine blocs of data to process, depending on &quot; opt&quot;</span>
  <span class="keywordtype">int</span> nblocs_left = 1;
  <span class="keywordtype">int</span> one_bloc[2];
  <span class="keyword">const</span> <span class="keywordtype">int</span> *bloc_ptr;
  <span class="keywordflow">if</span> ( opt != <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caad18680091a9f62247573cb3caa6450b9">VECT_ALL_ITEMS</a> &amp;&amp; md.<a class="code" href="classMD__Vector.html#a4165c00904b7096274e38fdc7ca340f4">non_nul</a>())
    {
      assert( opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a> ||  opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caab47906d8d2e6c20f8ba32e4acb6edbe0">VECT_REAL_ITEMS</a>);
      <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; items_blocs = ( opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a>) ? md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a7f6b6d0b7babfec0cce590cdea5bca53">get_items_to_sum</a>() : md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a99334ac2566d9457c8d4890ba20883ea">get_items_to_compute</a>();
      assert(items_blocs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() % 2 == 0);
      nblocs_left = items_blocs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() &gt;&gt; 1;
      bloc_ptr = items_blocs.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
    }
  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (vect_size_tot &gt; 0)
    {
<span class="comment">// attention, si vect_size_tot est nul, line_size a le droit d&#39;etre nul</span>
<span class="comment">// Compute all data, in the vector (including virtual data), build a big bloc:</span>
      nblocs_left = 1;
      bloc_ptr = one_bloc;
      one_bloc[0] = 0;
      one_bloc[1] = vect_size_tot / line_size;
    }
  <span class="keywordflow">else</span>
    {
<span class="comment">// raccourci pour les tableaux vides (evite le cas particulier line_size == 0)</span>
      <span class="keywordflow">return</span>  i_max;
    }
  <span class="keyword">const</span> <span class="keywordtype">int</span> *x_base = vx.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
  <span class="keywordflow">for</span> (; nblocs_left; nblocs_left--)
    {
<span class="comment">// Get index of next bloc start:</span>
      <span class="keyword">const</span> <span class="keywordtype">int</span> begin_bloc = (*(bloc_ptr++)) * line_size;
      <span class="keyword">const</span> <span class="keywordtype">int</span> end_bloc = (*(bloc_ptr++)) * line_size;
      assert(begin_bloc &gt;= 0 &amp;&amp; end_bloc &lt;= vect_size_tot &amp;&amp; end_bloc &gt;= begin_bloc);
      <span class="keyword">const</span> <span class="keywordtype">int</span>* x_ptr = x_base + begin_bloc;
      <span class="keywordtype">int</span> count = end_bloc - begin_bloc;
      <span class="keywordflow">for</span> (; count; count--)
        {
          <span class="keyword">const</span> <span class="keywordtype">int</span> x = *x_ptr;
          <span class="keywordflow">if</span> (x &gt; max_val) { i_max = x_ptr - x_base; max_val = x; }
          x_ptr++;
        }
    }
  <span class="keywordflow">return</span>  i_max;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a958bca1ebccdb01b6e5b997b865335fd"></a><!-- doxytag: member="IntVect.cpp::local_imin_vect" ref="a958bca1ebccdb01b6e5b997b865335fd" args="(const IntVect &amp;vx, Mp_vect_options opt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int local_imin_vect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIntVect.html">IntVect</a> &amp;&#160;</td>
          <td class="paramname"><em>vx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a>&#160;</td>
          <td class="paramname"><em>opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>&lt; this test is necessary if md is null </p>
</p>

<p>Definition at line <a class="el" href="IntVect_8cpp_source.html#l00591">591</a> of file <a class="el" href="IntVect_8cpp_source.html">IntVect.cpp</a>.</p>

<p>References <a class="el" href="ArrOfInt_8h_source.html#l00371">ArrOfInt::addr()</a>, <a class="el" href="classMD__Vector__base.html#a99334ac2566d9457c8d4890ba20883ea">MD_Vector_base::get_items_to_compute()</a>, <a class="el" href="classMD__Vector__base.html#a7f6b6d0b7babfec0cce590cdea5bca53">MD_Vector_base::get_items_to_sum()</a>, <a class="el" href="IntVect_8h_source.html#l00087">IntVect::get_md_vector()</a>, <a class="el" href="IntVect_8h_source.html#l00150">IntVect::line_size()</a>, <a class="el" href="MD__Vector_8h_source.html#l00063">MD_Vector::non_nul()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00342">ArrOfInt::size_array()</a>, <a class="el" href="IntVect_8h_source.html#l00145">IntVect::size_totale()</a>, <a class="el" href="MD__Vector_8h_source.html#l00067">MD_Vector::valeur()</a>, <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_ALL_ITEMS</a>, <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_REAL_ITEMS</a>, and <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_SEQUENTIAL_ITEMS</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">int</span> min_val = INT_MAX;;
  <span class="keywordtype">int</span> i_min = -1;
<span class="comment">// Master vect donne la structure de reference, les autres vecteurs</span>
<span class="comment">// doivent avoir la meme structure.</span>
  <span class="keyword">const</span> <a class="code" href="classIntVect.html">IntVect</a>&amp; master_vect = vx;
  <span class="keywordtype">int</span> line_size = master_vect.<a class="code" href="classIntVect.html#a5ba680066169c8e057bb3e3b876e4a8c">line_size</a>();
  <span class="keyword">const</span> <a class="code" href="classMD__Vector.html" title=": Cette classe est un DERIV mais l&#39;objet pointe est partage entre plusieurs instances de cette classe...">MD_Vector</a>&amp; md = master_vect.<a class="code" href="classIntVect.html#ae74e1fee6aca124d32718267e33a40c6">get_md_vector</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> vect_size_tot = master_vect.<a class="code" href="classIntVect.html#afa716e1f0a1f0f74f4f73e95b5651412" title="Identique a size_array()">size_totale</a>();
  assert(vx.<a class="code" href="classIntVect.html#a5ba680066169c8e057bb3e3b876e4a8c">line_size</a>() == line_size);
  assert(vx.<a class="code" href="classIntVect.html#afa716e1f0a1f0f74f4f73e95b5651412" title="Identique a size_array()">size_totale</a>() == vect_size_tot); <span class="comment">//!&lt; this test is necessary if md is null</span>
<span class="comment"></span>  assert(vx.<a class="code" href="classIntVect.html#ae74e1fee6aca124d32718267e33a40c6">get_md_vector</a>() == md);
<span class="comment">// Determine blocs of data to process, depending on &quot; opt&quot;</span>
  <span class="keywordtype">int</span> nblocs_left = 1;
  <span class="keywordtype">int</span> one_bloc[2];
  <span class="keyword">const</span> <span class="keywordtype">int</span> *bloc_ptr;
  <span class="keywordflow">if</span> ( opt != <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caad18680091a9f62247573cb3caa6450b9">VECT_ALL_ITEMS</a> &amp;&amp; md.<a class="code" href="classMD__Vector.html#a4165c00904b7096274e38fdc7ca340f4">non_nul</a>())
    {
      assert( opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a> ||  opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caab47906d8d2e6c20f8ba32e4acb6edbe0">VECT_REAL_ITEMS</a>);
      <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; items_blocs = ( opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a>) ? md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a7f6b6d0b7babfec0cce590cdea5bca53">get_items_to_sum</a>() : md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a99334ac2566d9457c8d4890ba20883ea">get_items_to_compute</a>();
      assert(items_blocs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() % 2 == 0);
      nblocs_left = items_blocs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() &gt;&gt; 1;
      bloc_ptr = items_blocs.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
    }
  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (vect_size_tot &gt; 0)
    {
<span class="comment">// attention, si vect_size_tot est nul, line_size a le droit d&#39;etre nul</span>
<span class="comment">// Compute all data, in the vector (including virtual data), build a big bloc:</span>
      nblocs_left = 1;
      bloc_ptr = one_bloc;
      one_bloc[0] = 0;
      one_bloc[1] = vect_size_tot / line_size;
    }
  <span class="keywordflow">else</span>
    {
<span class="comment">// raccourci pour les tableaux vides (evite le cas particulier line_size == 0)</span>
      <span class="keywordflow">return</span>  i_min;
    }
  <span class="keyword">const</span> <span class="keywordtype">int</span> *x_base = vx.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
  <span class="keywordflow">for</span> (; nblocs_left; nblocs_left--)
    {
<span class="comment">// Get index of next bloc start:</span>
      <span class="keyword">const</span> <span class="keywordtype">int</span> begin_bloc = (*(bloc_ptr++)) * line_size;
      <span class="keyword">const</span> <span class="keywordtype">int</span> end_bloc = (*(bloc_ptr++)) * line_size;
      assert(begin_bloc &gt;= 0 &amp;&amp; end_bloc &lt;= vect_size_tot &amp;&amp; end_bloc &gt;= begin_bloc);
      <span class="keyword">const</span> <span class="keywordtype">int</span>* x_ptr = x_base + begin_bloc;
      <span class="keywordtype">int</span> count = end_bloc - begin_bloc;
      <span class="keywordflow">for</span> (; count; count--)
        {
          <span class="keyword">const</span> <span class="keywordtype">int</span> x = *x_ptr;
          <span class="keywordflow">if</span> (x &lt; min_val) { i_min = x_ptr - x_base; min_val = x; }
          x_ptr++;
        }
    }
  <span class="keywordflow">return</span>  i_min;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a3136e23feb019b080a20b417a63baf1b"></a><!-- doxytag: member="IntVect.cpp::local_max_abs_vect" ref="a3136e23feb019b080a20b417a63baf1b" args="(const IntVect &amp;vx, Mp_vect_options opt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int local_max_abs_vect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIntVect.html">IntVect</a> &amp;&#160;</td>
          <td class="paramname"><em>vx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a>&#160;</td>
          <td class="paramname"><em>opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>&lt; this test is necessary if md is null </p>
</p>

<p>Definition at line <a class="el" href="IntVect_8cpp_source.html#l00817">817</a> of file <a class="el" href="IntVect_8cpp_source.html">IntVect.cpp</a>.</p>

<p>References <a class="el" href="ArrOfInt_8h_source.html#l00371">ArrOfInt::addr()</a>, <a class="el" href="classMD__Vector__base.html#a99334ac2566d9457c8d4890ba20883ea">MD_Vector_base::get_items_to_compute()</a>, <a class="el" href="classMD__Vector__base.html#a7f6b6d0b7babfec0cce590cdea5bca53">MD_Vector_base::get_items_to_sum()</a>, <a class="el" href="IntVect_8h_source.html#l00087">IntVect::get_md_vector()</a>, <a class="el" href="IntVect_8h_source.html#l00150">IntVect::line_size()</a>, <a class="el" href="MD__Vector_8h_source.html#l00063">MD_Vector::non_nul()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00342">ArrOfInt::size_array()</a>, <a class="el" href="IntVect_8h_source.html#l00145">IntVect::size_totale()</a>, <a class="el" href="MD__Vector_8h_source.html#l00067">MD_Vector::valeur()</a>, <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_ALL_ITEMS</a>, <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_REAL_ITEMS</a>, and <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_SEQUENTIAL_ITEMS</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">int</span> max_val = 0;
<span class="comment">// Master vect donne la structure de reference, les autres vecteurs</span>
<span class="comment">// doivent avoir la meme structure.</span>
  <span class="keyword">const</span> <a class="code" href="classIntVect.html">IntVect</a>&amp; master_vect = vx;
  <span class="keywordtype">int</span> line_size = master_vect.<a class="code" href="classIntVect.html#a5ba680066169c8e057bb3e3b876e4a8c">line_size</a>();
  <span class="keyword">const</span> <a class="code" href="classMD__Vector.html" title=": Cette classe est un DERIV mais l&#39;objet pointe est partage entre plusieurs instances de cette classe...">MD_Vector</a>&amp; md = master_vect.<a class="code" href="classIntVect.html#ae74e1fee6aca124d32718267e33a40c6">get_md_vector</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> vect_size_tot = master_vect.<a class="code" href="classIntVect.html#afa716e1f0a1f0f74f4f73e95b5651412" title="Identique a size_array()">size_totale</a>();
  assert(vx.<a class="code" href="classIntVect.html#a5ba680066169c8e057bb3e3b876e4a8c">line_size</a>() == line_size);
  assert(vx.<a class="code" href="classIntVect.html#afa716e1f0a1f0f74f4f73e95b5651412" title="Identique a size_array()">size_totale</a>() == vect_size_tot); <span class="comment">//!&lt; this test is necessary if md is null</span>
<span class="comment"></span>  assert(vx.<a class="code" href="classIntVect.html#ae74e1fee6aca124d32718267e33a40c6">get_md_vector</a>() == md);
<span class="comment">// Determine blocs of data to process, depending on &quot; opt&quot;</span>
  <span class="keywordtype">int</span> nblocs_left = 1;
  <span class="keywordtype">int</span> one_bloc[2];
  <span class="keyword">const</span> <span class="keywordtype">int</span> *bloc_ptr;
  <span class="keywordflow">if</span> ( opt != <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caad18680091a9f62247573cb3caa6450b9">VECT_ALL_ITEMS</a> &amp;&amp; md.<a class="code" href="classMD__Vector.html#a4165c00904b7096274e38fdc7ca340f4">non_nul</a>())
    {
      assert( opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a> ||  opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caab47906d8d2e6c20f8ba32e4acb6edbe0">VECT_REAL_ITEMS</a>);
      <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; items_blocs = ( opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a>) ? md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a7f6b6d0b7babfec0cce590cdea5bca53">get_items_to_sum</a>() : md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a99334ac2566d9457c8d4890ba20883ea">get_items_to_compute</a>();
      assert(items_blocs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() % 2 == 0);
      nblocs_left = items_blocs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() &gt;&gt; 1;
      bloc_ptr = items_blocs.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
    }
  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (vect_size_tot &gt; 0)
    {
<span class="comment">// attention, si vect_size_tot est nul, line_size a le droit d&#39;etre nul</span>
<span class="comment">// Compute all data, in the vector (including virtual data), build a big bloc:</span>
      nblocs_left = 1;
      bloc_ptr = one_bloc;
      one_bloc[0] = 0;
      one_bloc[1] = vect_size_tot / line_size;
    }
  <span class="keywordflow">else</span>
    {
<span class="comment">// raccourci pour les tableaux vides (evite le cas particulier line_size == 0)</span>
      <span class="keywordflow">return</span>  max_val;
    }
  <span class="keyword">const</span> <span class="keywordtype">int</span> *x_base = vx.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
  <span class="keywordflow">for</span> (; nblocs_left; nblocs_left--)
    {
<span class="comment">// Get index of next bloc start:</span>
      <span class="keyword">const</span> <span class="keywordtype">int</span> begin_bloc = (*(bloc_ptr++)) * line_size;
      <span class="keyword">const</span> <span class="keywordtype">int</span> end_bloc = (*(bloc_ptr++)) * line_size;
      assert(begin_bloc &gt;= 0 &amp;&amp; end_bloc &lt;= vect_size_tot &amp;&amp; end_bloc &gt;= begin_bloc);
      <span class="keyword">const</span> <span class="keywordtype">int</span>* x_ptr = x_base + begin_bloc;
      <span class="keywordtype">int</span> count = end_bloc - begin_bloc;
      <span class="keywordflow">for</span> (; count; count--)
        {
          <span class="keyword">const</span> <span class="keywordtype">int</span> x = *x_ptr;
          <span class="keywordtype">int</span> xx = abs(x);
          max_val = (xx &gt; max_val) ? xx : max_val;
          x_ptr++;
        }
    }
  <span class="keywordflow">return</span>  max_val;
}
</pre></div>
</div>
</div>
<a class="anchor" id="ae86224cad06471b195b23ee0a599eae6"></a><!-- doxytag: member="IntVect.cpp::local_max_vect" ref="ae86224cad06471b195b23ee0a599eae6" args="(const IntVect &amp;vx, Mp_vect_options opt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int local_max_vect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIntVect.html">IntVect</a> &amp;&#160;</td>
          <td class="paramname"><em>vx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a>&#160;</td>
          <td class="paramname"><em>opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>&lt; this test is necessary if md is null </p>
</p>

<p>Definition at line <a class="el" href="IntVect_8cpp_source.html#l00761">761</a> of file <a class="el" href="IntVect_8cpp_source.html">IntVect.cpp</a>.</p>

<p>References <a class="el" href="ArrOfInt_8h_source.html#l00371">ArrOfInt::addr()</a>, <a class="el" href="classMD__Vector__base.html#a99334ac2566d9457c8d4890ba20883ea">MD_Vector_base::get_items_to_compute()</a>, <a class="el" href="classMD__Vector__base.html#a7f6b6d0b7babfec0cce590cdea5bca53">MD_Vector_base::get_items_to_sum()</a>, <a class="el" href="IntVect_8h_source.html#l00087">IntVect::get_md_vector()</a>, <a class="el" href="IntVect_8h_source.html#l00150">IntVect::line_size()</a>, <a class="el" href="MD__Vector_8h_source.html#l00063">MD_Vector::non_nul()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00342">ArrOfInt::size_array()</a>, <a class="el" href="IntVect_8h_source.html#l00145">IntVect::size_totale()</a>, <a class="el" href="MD__Vector_8h_source.html#l00067">MD_Vector::valeur()</a>, <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_ALL_ITEMS</a>, <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_REAL_ITEMS</a>, and <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_SEQUENTIAL_ITEMS</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">int</span> max_val = INT_MIN;;
<span class="comment">// Master vect donne la structure de reference, les autres vecteurs</span>
<span class="comment">// doivent avoir la meme structure.</span>
  <span class="keyword">const</span> <a class="code" href="classIntVect.html">IntVect</a>&amp; master_vect = vx;
  <span class="keywordtype">int</span> line_size = master_vect.<a class="code" href="classIntVect.html#a5ba680066169c8e057bb3e3b876e4a8c">line_size</a>();
  <span class="keyword">const</span> <a class="code" href="classMD__Vector.html" title=": Cette classe est un DERIV mais l&#39;objet pointe est partage entre plusieurs instances de cette classe...">MD_Vector</a>&amp; md = master_vect.<a class="code" href="classIntVect.html#ae74e1fee6aca124d32718267e33a40c6">get_md_vector</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> vect_size_tot = master_vect.<a class="code" href="classIntVect.html#afa716e1f0a1f0f74f4f73e95b5651412" title="Identique a size_array()">size_totale</a>();
  assert(vx.<a class="code" href="classIntVect.html#a5ba680066169c8e057bb3e3b876e4a8c">line_size</a>() == line_size);
  assert(vx.<a class="code" href="classIntVect.html#afa716e1f0a1f0f74f4f73e95b5651412" title="Identique a size_array()">size_totale</a>() == vect_size_tot); <span class="comment">//!&lt; this test is necessary if md is null</span>
<span class="comment"></span>  assert(vx.<a class="code" href="classIntVect.html#ae74e1fee6aca124d32718267e33a40c6">get_md_vector</a>() == md);
<span class="comment">// Determine blocs of data to process, depending on &quot; opt&quot;</span>
  <span class="keywordtype">int</span> nblocs_left = 1;
  <span class="keywordtype">int</span> one_bloc[2];
  <span class="keyword">const</span> <span class="keywordtype">int</span> *bloc_ptr;
  <span class="keywordflow">if</span> ( opt != <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caad18680091a9f62247573cb3caa6450b9">VECT_ALL_ITEMS</a> &amp;&amp; md.<a class="code" href="classMD__Vector.html#a4165c00904b7096274e38fdc7ca340f4">non_nul</a>())
    {
      assert( opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a> ||  opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caab47906d8d2e6c20f8ba32e4acb6edbe0">VECT_REAL_ITEMS</a>);
      <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; items_blocs = ( opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a>) ? md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a7f6b6d0b7babfec0cce590cdea5bca53">get_items_to_sum</a>() : md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a99334ac2566d9457c8d4890ba20883ea">get_items_to_compute</a>();
      assert(items_blocs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() % 2 == 0);
      nblocs_left = items_blocs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() &gt;&gt; 1;
      bloc_ptr = items_blocs.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
    }
  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (vect_size_tot &gt; 0)
    {
<span class="comment">// attention, si vect_size_tot est nul, line_size a le droit d&#39;etre nul</span>
<span class="comment">// Compute all data, in the vector (including virtual data), build a big bloc:</span>
      nblocs_left = 1;
      bloc_ptr = one_bloc;
      one_bloc[0] = 0;
      one_bloc[1] = vect_size_tot / line_size;
    }
  <span class="keywordflow">else</span>
    {
<span class="comment">// raccourci pour les tableaux vides (evite le cas particulier line_size == 0)</span>
      <span class="keywordflow">return</span>  max_val;
    }
  <span class="keyword">const</span> <span class="keywordtype">int</span> *x_base = vx.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
  <span class="keywordflow">for</span> (; nblocs_left; nblocs_left--)
    {
<span class="comment">// Get index of next bloc start:</span>
      <span class="keyword">const</span> <span class="keywordtype">int</span> begin_bloc = (*(bloc_ptr++)) * line_size;
      <span class="keyword">const</span> <span class="keywordtype">int</span> end_bloc = (*(bloc_ptr++)) * line_size;
      assert(begin_bloc &gt;= 0 &amp;&amp; end_bloc &lt;= vect_size_tot &amp;&amp; end_bloc &gt;= begin_bloc);
      <span class="keyword">const</span> <span class="keywordtype">int</span>* x_ptr = x_base + begin_bloc;
      <span class="keywordtype">int</span> count = end_bloc - begin_bloc;
      <span class="keywordflow">for</span> (; count; count--)
        {
          <span class="keyword">const</span> <span class="keywordtype">int</span> x = *x_ptr;
          max_val = (x &gt; max_val) ? x : max_val;
          x_ptr++;
        }
    }
  <span class="keywordflow">return</span>  max_val;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a4a2b59fec7838ff4c00f8ed772eb83c1"></a><!-- doxytag: member="IntVect.cpp::local_min_abs_vect" ref="a4a2b59fec7838ff4c00f8ed772eb83c1" args="(const IntVect &amp;vx, Mp_vect_options opt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int local_min_abs_vect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIntVect.html">IntVect</a> &amp;&#160;</td>
          <td class="paramname"><em>vx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a>&#160;</td>
          <td class="paramname"><em>opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>&lt; this test is necessary if md is null </p>
</p>

<p>Definition at line <a class="el" href="IntVect_8cpp_source.html#l00874">874</a> of file <a class="el" href="IntVect_8cpp_source.html">IntVect.cpp</a>.</p>

<p>References <a class="el" href="ArrOfInt_8h_source.html#l00371">ArrOfInt::addr()</a>, <a class="el" href="classMD__Vector__base.html#a99334ac2566d9457c8d4890ba20883ea">MD_Vector_base::get_items_to_compute()</a>, <a class="el" href="classMD__Vector__base.html#a7f6b6d0b7babfec0cce590cdea5bca53">MD_Vector_base::get_items_to_sum()</a>, <a class="el" href="IntVect_8h_source.html#l00087">IntVect::get_md_vector()</a>, <a class="el" href="IntVect_8h_source.html#l00150">IntVect::line_size()</a>, <a class="el" href="MD__Vector_8h_source.html#l00063">MD_Vector::non_nul()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00342">ArrOfInt::size_array()</a>, <a class="el" href="IntVect_8h_source.html#l00145">IntVect::size_totale()</a>, <a class="el" href="MD__Vector_8h_source.html#l00067">MD_Vector::valeur()</a>, <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_ALL_ITEMS</a>, <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_REAL_ITEMS</a>, and <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_SEQUENTIAL_ITEMS</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">int</span> min_val = INT_MAX;;
<span class="comment">// Master vect donne la structure de reference, les autres vecteurs</span>
<span class="comment">// doivent avoir la meme structure.</span>
  <span class="keyword">const</span> <a class="code" href="classIntVect.html">IntVect</a>&amp; master_vect = vx;
  <span class="keywordtype">int</span> line_size = master_vect.<a class="code" href="classIntVect.html#a5ba680066169c8e057bb3e3b876e4a8c">line_size</a>();
  <span class="keyword">const</span> <a class="code" href="classMD__Vector.html" title=": Cette classe est un DERIV mais l&#39;objet pointe est partage entre plusieurs instances de cette classe...">MD_Vector</a>&amp; md = master_vect.<a class="code" href="classIntVect.html#ae74e1fee6aca124d32718267e33a40c6">get_md_vector</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> vect_size_tot = master_vect.<a class="code" href="classIntVect.html#afa716e1f0a1f0f74f4f73e95b5651412" title="Identique a size_array()">size_totale</a>();
  assert(vx.<a class="code" href="classIntVect.html#a5ba680066169c8e057bb3e3b876e4a8c">line_size</a>() == line_size);
  assert(vx.<a class="code" href="classIntVect.html#afa716e1f0a1f0f74f4f73e95b5651412" title="Identique a size_array()">size_totale</a>() == vect_size_tot); <span class="comment">//!&lt; this test is necessary if md is null</span>
<span class="comment"></span>  assert(vx.<a class="code" href="classIntVect.html#ae74e1fee6aca124d32718267e33a40c6">get_md_vector</a>() == md);
<span class="comment">// Determine blocs of data to process, depending on &quot; opt&quot;</span>
  <span class="keywordtype">int</span> nblocs_left = 1;
  <span class="keywordtype">int</span> one_bloc[2];
  <span class="keyword">const</span> <span class="keywordtype">int</span> *bloc_ptr;
  <span class="keywordflow">if</span> ( opt != <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caad18680091a9f62247573cb3caa6450b9">VECT_ALL_ITEMS</a> &amp;&amp; md.<a class="code" href="classMD__Vector.html#a4165c00904b7096274e38fdc7ca340f4">non_nul</a>())
    {
      assert( opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a> ||  opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caab47906d8d2e6c20f8ba32e4acb6edbe0">VECT_REAL_ITEMS</a>);
      <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; items_blocs = ( opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a>) ? md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a7f6b6d0b7babfec0cce590cdea5bca53">get_items_to_sum</a>() : md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a99334ac2566d9457c8d4890ba20883ea">get_items_to_compute</a>();
      assert(items_blocs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() % 2 == 0);
      nblocs_left = items_blocs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() &gt;&gt; 1;
      bloc_ptr = items_blocs.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
    }
  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (vect_size_tot &gt; 0)
    {
<span class="comment">// attention, si vect_size_tot est nul, line_size a le droit d&#39;etre nul</span>
<span class="comment">// Compute all data, in the vector (including virtual data), build a big bloc:</span>
      nblocs_left = 1;
      bloc_ptr = one_bloc;
      one_bloc[0] = 0;
      one_bloc[1] = vect_size_tot / line_size;
    }
  <span class="keywordflow">else</span>
    {
<span class="comment">// raccourci pour les tableaux vides (evite le cas particulier line_size == 0)</span>
      <span class="keywordflow">return</span>  min_val;
    }
  <span class="keyword">const</span> <span class="keywordtype">int</span> *x_base = vx.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
  <span class="keywordflow">for</span> (; nblocs_left; nblocs_left--)
    {
<span class="comment">// Get index of next bloc start:</span>
      <span class="keyword">const</span> <span class="keywordtype">int</span> begin_bloc = (*(bloc_ptr++)) * line_size;
      <span class="keyword">const</span> <span class="keywordtype">int</span> end_bloc = (*(bloc_ptr++)) * line_size;
      assert(begin_bloc &gt;= 0 &amp;&amp; end_bloc &lt;= vect_size_tot &amp;&amp; end_bloc &gt;= begin_bloc);
      <span class="keyword">const</span> <span class="keywordtype">int</span>* x_ptr = x_base + begin_bloc;
      <span class="keywordtype">int</span> count = end_bloc - begin_bloc;
      <span class="keywordflow">for</span> (; count; count--)
        {
          <span class="keyword">const</span> <span class="keywordtype">int</span> x = *x_ptr;
          <span class="keywordtype">int</span> xx = abs(x);
          min_val = (xx &lt; min_val) ? xx : min_val;
          x_ptr++;
        }
    }
  <span class="keywordflow">return</span>  min_val;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a5e9c0fc1b45d55d995607d0f38008400"></a><!-- doxytag: member="IntVect.cpp::local_min_vect" ref="a5e9c0fc1b45d55d995607d0f38008400" args="(const IntVect &amp;vx, Mp_vect_options opt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int local_min_vect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIntVect.html">IntVect</a> &amp;&#160;</td>
          <td class="paramname"><em>vx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a>&#160;</td>
          <td class="paramname"><em>opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>&lt; this test is necessary if md is null </p>
</p>

<p>Definition at line <a class="el" href="IntVect_8cpp_source.html#l00648">648</a> of file <a class="el" href="IntVect_8cpp_source.html">IntVect.cpp</a>.</p>

<p>References <a class="el" href="ArrOfInt_8h_source.html#l00371">ArrOfInt::addr()</a>, <a class="el" href="classMD__Vector__base.html#a99334ac2566d9457c8d4890ba20883ea">MD_Vector_base::get_items_to_compute()</a>, <a class="el" href="classMD__Vector__base.html#a7f6b6d0b7babfec0cce590cdea5bca53">MD_Vector_base::get_items_to_sum()</a>, <a class="el" href="IntVect_8h_source.html#l00087">IntVect::get_md_vector()</a>, <a class="el" href="IntVect_8h_source.html#l00150">IntVect::line_size()</a>, <a class="el" href="MD__Vector_8h_source.html#l00063">MD_Vector::non_nul()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00342">ArrOfInt::size_array()</a>, <a class="el" href="IntVect_8h_source.html#l00145">IntVect::size_totale()</a>, <a class="el" href="MD__Vector_8h_source.html#l00067">MD_Vector::valeur()</a>, <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_ALL_ITEMS</a>, <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_REAL_ITEMS</a>, and <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_SEQUENTIAL_ITEMS</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">int</span> min_val = INT_MAX;;
<span class="comment">// Master vect donne la structure de reference, les autres vecteurs</span>
<span class="comment">// doivent avoir la meme structure.</span>
  <span class="keyword">const</span> <a class="code" href="classIntVect.html">IntVect</a>&amp; master_vect = vx;
  <span class="keywordtype">int</span> line_size = master_vect.<a class="code" href="classIntVect.html#a5ba680066169c8e057bb3e3b876e4a8c">line_size</a>();
  <span class="keyword">const</span> <a class="code" href="classMD__Vector.html" title=": Cette classe est un DERIV mais l&#39;objet pointe est partage entre plusieurs instances de cette classe...">MD_Vector</a>&amp; md = master_vect.<a class="code" href="classIntVect.html#ae74e1fee6aca124d32718267e33a40c6">get_md_vector</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> vect_size_tot = master_vect.<a class="code" href="classIntVect.html#afa716e1f0a1f0f74f4f73e95b5651412" title="Identique a size_array()">size_totale</a>();
  assert(vx.<a class="code" href="classIntVect.html#a5ba680066169c8e057bb3e3b876e4a8c">line_size</a>() == line_size);
  assert(vx.<a class="code" href="classIntVect.html#afa716e1f0a1f0f74f4f73e95b5651412" title="Identique a size_array()">size_totale</a>() == vect_size_tot); <span class="comment">//!&lt; this test is necessary if md is null</span>
<span class="comment"></span>  assert(vx.<a class="code" href="classIntVect.html#ae74e1fee6aca124d32718267e33a40c6">get_md_vector</a>() == md);
<span class="comment">// Determine blocs of data to process, depending on &quot; opt&quot;</span>
  <span class="keywordtype">int</span> nblocs_left = 1;
  <span class="keywordtype">int</span> one_bloc[2];
  <span class="keyword">const</span> <span class="keywordtype">int</span> *bloc_ptr;
  <span class="keywordflow">if</span> ( opt != <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caad18680091a9f62247573cb3caa6450b9">VECT_ALL_ITEMS</a> &amp;&amp; md.<a class="code" href="classMD__Vector.html#a4165c00904b7096274e38fdc7ca340f4">non_nul</a>())
    {
      assert( opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a> ||  opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caab47906d8d2e6c20f8ba32e4acb6edbe0">VECT_REAL_ITEMS</a>);
      <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; items_blocs = ( opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a>) ? md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a7f6b6d0b7babfec0cce590cdea5bca53">get_items_to_sum</a>() : md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a99334ac2566d9457c8d4890ba20883ea">get_items_to_compute</a>();
      assert(items_blocs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() % 2 == 0);
      nblocs_left = items_blocs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() &gt;&gt; 1;
      bloc_ptr = items_blocs.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
    }
  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (vect_size_tot &gt; 0)
    {
<span class="comment">// attention, si vect_size_tot est nul, line_size a le droit d&#39;etre nul</span>
<span class="comment">// Compute all data, in the vector (including virtual data), build a big bloc:</span>
      nblocs_left = 1;
      bloc_ptr = one_bloc;
      one_bloc[0] = 0;
      one_bloc[1] = vect_size_tot / line_size;
    }
  <span class="keywordflow">else</span>
    {
<span class="comment">// raccourci pour les tableaux vides (evite le cas particulier line_size == 0)</span>
      <span class="keywordflow">return</span>  min_val;
    }
  <span class="keyword">const</span> <span class="keywordtype">int</span> *x_base = vx.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
  <span class="keywordflow">for</span> (; nblocs_left; nblocs_left--)
    {
<span class="comment">// Get index of next bloc start:</span>
      <span class="keyword">const</span> <span class="keywordtype">int</span> begin_bloc = (*(bloc_ptr++)) * line_size;
      <span class="keyword">const</span> <span class="keywordtype">int</span> end_bloc = (*(bloc_ptr++)) * line_size;
      assert(begin_bloc &gt;= 0 &amp;&amp; end_bloc &lt;= vect_size_tot &amp;&amp; end_bloc &gt;= begin_bloc);
      <span class="keyword">const</span> <span class="keywordtype">int</span>* x_ptr = x_base + begin_bloc;
      <span class="keywordtype">int</span> count = end_bloc - begin_bloc;
      <span class="keywordflow">for</span> (; count; count--)
        {
          <span class="keyword">const</span> <span class="keywordtype">int</span> x = *x_ptr;
          min_val = (x &lt; min_val) ? x : min_val;
          x_ptr++;
        }
    }
  <span class="keywordflow">return</span>  min_val;
}
</pre></div>
</div>
</div>
<a class="anchor" id="aab2906ce876a975f702755e7b57e6a2a"></a><!-- doxytag: member="IntVect.cpp::local_prodscal" ref="aab2906ce876a975f702755e7b57e6a2a" args="(const IntVect &amp;vx, const IntVect &amp;vy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int local_prodscal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIntVect.html">IntVect</a> &amp;&#160;</td>
          <td class="paramname"><em>vx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIntVect.html">IntVect</a> &amp;&#160;</td>
          <td class="paramname"><em>vy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Renvoie la somme des x[i]*y[i] pour les items sequentiels sur ce processeur.<br/>
(tous les items si pas de structure parallele, sinon voir <a class="el" href="classMD__Vector__base.html#a7f6b6d0b7babfec0cce590cdea5bca53">MD_Vector_base::get_items_to_sum()</a> </p>

<p><p>&lt; this test is necessary if md is null</p>
<p>&lt; this test is necessary if md is null </p>
</p>

<p>Definition at line <a class="el" href="IntVect_8cpp_source.html#l00407">407</a> of file <a class="el" href="IntVect_8cpp_source.html">IntVect.cpp</a>.</p>

<p>References <a class="el" href="ArrOfInt_8h_source.html#l00371">ArrOfInt::addr()</a>, <a class="el" href="classMD__Vector__base.html#a99334ac2566d9457c8d4890ba20883ea">MD_Vector_base::get_items_to_compute()</a>, <a class="el" href="classMD__Vector__base.html#a7f6b6d0b7babfec0cce590cdea5bca53">MD_Vector_base::get_items_to_sum()</a>, <a class="el" href="IntVect_8h_source.html#l00087">IntVect::get_md_vector()</a>, <a class="el" href="IntVect_8h_source.html#l00150">IntVect::line_size()</a>, <a class="el" href="MD__Vector_8h_source.html#l00063">MD_Vector::non_nul()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00342">ArrOfInt::size_array()</a>, <a class="el" href="IntVect_8h_source.html#l00145">IntVect::size_totale()</a>, <a class="el" href="MD__Vector_8h_source.html#l00067">MD_Vector::valeur()</a>, <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_ALL_ITEMS</a>, <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_REAL_ITEMS</a>, and <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_SEQUENTIAL_ITEMS</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">int</span> sum = 0;
<span class="comment">// Master vect donne la structure de reference, les autres vecteurs</span>
<span class="comment">// doivent avoir la meme structure.</span>
  <span class="keyword">const</span> <a class="code" href="classIntVect.html">IntVect</a>&amp; master_vect = vx;
  <span class="keywordtype">int</span> line_size = master_vect.<a class="code" href="classIntVect.html#a5ba680066169c8e057bb3e3b876e4a8c">line_size</a>();
  <span class="keyword">const</span> <a class="code" href="classMD__Vector.html" title=": Cette classe est un DERIV mais l&#39;objet pointe est partage entre plusieurs instances de cette classe...">MD_Vector</a>&amp; md = master_vect.<a class="code" href="classIntVect.html#ae74e1fee6aca124d32718267e33a40c6">get_md_vector</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> vect_size_tot = master_vect.<a class="code" href="classIntVect.html#afa716e1f0a1f0f74f4f73e95b5651412" title="Identique a size_array()">size_totale</a>();
  assert(vx.<a class="code" href="classIntVect.html#a5ba680066169c8e057bb3e3b876e4a8c">line_size</a>() == line_size);
  assert(vx.<a class="code" href="classIntVect.html#afa716e1f0a1f0f74f4f73e95b5651412" title="Identique a size_array()">size_totale</a>() == vect_size_tot); <span class="comment">//!&lt; this test is necessary if md is null</span>
<span class="comment"></span>  assert(vx.<a class="code" href="classIntVect.html#ae74e1fee6aca124d32718267e33a40c6">get_md_vector</a>() == md);
  assert(vy.<a class="code" href="classIntVect.html#a5ba680066169c8e057bb3e3b876e4a8c">line_size</a>() == line_size);
  assert(vy.<a class="code" href="classIntVect.html#afa716e1f0a1f0f74f4f73e95b5651412" title="Identique a size_array()">size_totale</a>() == vect_size_tot); <span class="comment">//!&lt; this test is necessary if md is null</span>
<span class="comment"></span>  assert(vy.<a class="code" href="classIntVect.html#ae74e1fee6aca124d32718267e33a40c6">get_md_vector</a>() == md);
<span class="comment">// Determine blocs of data to process, depending on &quot; VECT_SEQUENTIAL_ITEMS&quot;</span>
  <span class="keywordtype">int</span> nblocs_left = 1;
  <span class="keywordtype">int</span> one_bloc[2];
  <span class="keyword">const</span> <span class="keywordtype">int</span> *bloc_ptr;
  <span class="keywordflow">if</span> ( <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a> != <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caad18680091a9f62247573cb3caa6450b9">VECT_ALL_ITEMS</a> &amp;&amp; md.<a class="code" href="classMD__Vector.html#a4165c00904b7096274e38fdc7ca340f4">non_nul</a>())
    {
      assert( <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a> == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a> ||  <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a> == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caab47906d8d2e6c20f8ba32e4acb6edbe0">VECT_REAL_ITEMS</a>);
      <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; items_blocs = ( <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a> == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a>) ? md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a7f6b6d0b7babfec0cce590cdea5bca53">get_items_to_sum</a>() : md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a99334ac2566d9457c8d4890ba20883ea">get_items_to_compute</a>();
      assert(items_blocs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() % 2 == 0);
      nblocs_left = items_blocs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() &gt;&gt; 1;
      bloc_ptr = items_blocs.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
    }
  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (vect_size_tot &gt; 0)
    {
<span class="comment">// attention, si vect_size_tot est nul, line_size a le droit d&#39;etre nul</span>
<span class="comment">// Compute all data, in the vector (including virtual data), build a big bloc:</span>
      nblocs_left = 1;
      bloc_ptr = one_bloc;
      one_bloc[0] = 0;
      one_bloc[1] = vect_size_tot / line_size;
    }
  <span class="keywordflow">else</span>
    {
<span class="comment">// raccourci pour les tableaux vides (evite le cas particulier line_size == 0)</span>
      <span class="keywordflow">return</span>  sum;
    }
  <span class="keyword">const</span> <span class="keywordtype">int</span> *x_base = vx.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> *y_base = vy.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
  <span class="keywordflow">for</span> (; nblocs_left; nblocs_left--)
    {
<span class="comment">// Get index of next bloc start:</span>
      <span class="keyword">const</span> <span class="keywordtype">int</span> begin_bloc = (*(bloc_ptr++)) * line_size;
      <span class="keyword">const</span> <span class="keywordtype">int</span> end_bloc = (*(bloc_ptr++)) * line_size;
      assert(begin_bloc &gt;= 0 &amp;&amp; end_bloc &lt;= vect_size_tot &amp;&amp; end_bloc &gt;= begin_bloc);
      <span class="keyword">const</span> <span class="keywordtype">int</span>* x_ptr = x_base + begin_bloc;
      <span class="keyword">const</span> <span class="keywordtype">int</span>* y_ptr = y_base + begin_bloc;
      <span class="keywordtype">int</span> count = end_bloc - begin_bloc;
      <span class="keywordflow">for</span> (; count; count--)
        {
          <span class="keyword">const</span> <span class="keywordtype">int</span> x = *x_ptr;
          <span class="keyword">const</span> <span class="keywordtype">int</span> y = *(y_ptr++);
          sum += x * y;
          x_ptr++;
        }
    }
  <span class="keywordflow">return</span>  sum;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a884eff5c3e13bc9e38ccccd49be3ca03"></a><!-- doxytag: member="IntVect.cpp::local_somme_vect" ref="a884eff5c3e13bc9e38ccccd49be3ca03" args="(const IntVect &amp;vx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int local_somme_vect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIntVect.html">IntVect</a> &amp;&#160;</td>
          <td class="paramname"><em>vx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>&lt; this test is necessary if md is null </p>
</p>

<p>Definition at line <a class="el" href="IntVect_8cpp_source.html#l00529">529</a> of file <a class="el" href="IntVect_8cpp_source.html">IntVect.cpp</a>.</p>

<p>References <a class="el" href="ArrOfInt_8h_source.html#l00371">ArrOfInt::addr()</a>, <a class="el" href="classMD__Vector__base.html#a99334ac2566d9457c8d4890ba20883ea">MD_Vector_base::get_items_to_compute()</a>, <a class="el" href="classMD__Vector__base.html#a7f6b6d0b7babfec0cce590cdea5bca53">MD_Vector_base::get_items_to_sum()</a>, <a class="el" href="IntVect_8h_source.html#l00087">IntVect::get_md_vector()</a>, <a class="el" href="IntVect_8h_source.html#l00150">IntVect::line_size()</a>, <a class="el" href="MD__Vector_8h_source.html#l00063">MD_Vector::non_nul()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00342">ArrOfInt::size_array()</a>, <a class="el" href="IntVect_8h_source.html#l00145">IntVect::size_totale()</a>, <a class="el" href="MD__Vector_8h_source.html#l00067">MD_Vector::valeur()</a>, <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_ALL_ITEMS</a>, <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_REAL_ITEMS</a>, and <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_SEQUENTIAL_ITEMS</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">int</span> sum = 0;
<span class="comment">// Master vect donne la structure de reference, les autres vecteurs</span>
<span class="comment">// doivent avoir la meme structure.</span>
  <span class="keyword">const</span> <a class="code" href="classIntVect.html">IntVect</a>&amp; master_vect = vx;
  <span class="keywordtype">int</span> line_size = master_vect.<a class="code" href="classIntVect.html#a5ba680066169c8e057bb3e3b876e4a8c">line_size</a>();
  <span class="keyword">const</span> <a class="code" href="classMD__Vector.html" title=": Cette classe est un DERIV mais l&#39;objet pointe est partage entre plusieurs instances de cette classe...">MD_Vector</a>&amp; md = master_vect.<a class="code" href="classIntVect.html#ae74e1fee6aca124d32718267e33a40c6">get_md_vector</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> vect_size_tot = master_vect.<a class="code" href="classIntVect.html#afa716e1f0a1f0f74f4f73e95b5651412" title="Identique a size_array()">size_totale</a>();
  assert(vx.<a class="code" href="classIntVect.html#a5ba680066169c8e057bb3e3b876e4a8c">line_size</a>() == line_size);
  assert(vx.<a class="code" href="classIntVect.html#afa716e1f0a1f0f74f4f73e95b5651412" title="Identique a size_array()">size_totale</a>() == vect_size_tot); <span class="comment">//!&lt; this test is necessary if md is null</span>
<span class="comment"></span>  assert(vx.<a class="code" href="classIntVect.html#ae74e1fee6aca124d32718267e33a40c6">get_md_vector</a>() == md);
<span class="comment">// Determine blocs of data to process, depending on &quot; VECT_SEQUENTIAL_ITEMS&quot;</span>
  <span class="keywordtype">int</span> nblocs_left = 1;
  <span class="keywordtype">int</span> one_bloc[2];
  <span class="keyword">const</span> <span class="keywordtype">int</span> *bloc_ptr;
  <span class="keywordflow">if</span> ( <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a> != <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caad18680091a9f62247573cb3caa6450b9">VECT_ALL_ITEMS</a> &amp;&amp; md.<a class="code" href="classMD__Vector.html#a4165c00904b7096274e38fdc7ca340f4">non_nul</a>())
    {
      assert( <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a> == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a> ||  <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a> == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caab47906d8d2e6c20f8ba32e4acb6edbe0">VECT_REAL_ITEMS</a>);
      <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; items_blocs = ( <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a> == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a>) ? md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a7f6b6d0b7babfec0cce590cdea5bca53">get_items_to_sum</a>() : md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a99334ac2566d9457c8d4890ba20883ea">get_items_to_compute</a>();
      assert(items_blocs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() % 2 == 0);
      nblocs_left = items_blocs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() &gt;&gt; 1;
      bloc_ptr = items_blocs.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
    }
  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (vect_size_tot &gt; 0)
    {
<span class="comment">// attention, si vect_size_tot est nul, line_size a le droit d&#39;etre nul</span>
<span class="comment">// Compute all data, in the vector (including virtual data), build a big bloc:</span>
      nblocs_left = 1;
      bloc_ptr = one_bloc;
      one_bloc[0] = 0;
      one_bloc[1] = vect_size_tot / line_size;
    }
  <span class="keywordflow">else</span>
    {
<span class="comment">// raccourci pour les tableaux vides (evite le cas particulier line_size == 0)</span>
      <span class="keywordflow">return</span>  sum;
    }
  <span class="keyword">const</span> <span class="keywordtype">int</span> *x_base = vx.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
  <span class="keywordflow">for</span> (; nblocs_left; nblocs_left--)
    {
<span class="comment">// Get index of next bloc start:</span>
      <span class="keyword">const</span> <span class="keywordtype">int</span> begin_bloc = (*(bloc_ptr++)) * line_size;
      <span class="keyword">const</span> <span class="keywordtype">int</span> end_bloc = (*(bloc_ptr++)) * line_size;
      assert(begin_bloc &gt;= 0 &amp;&amp; end_bloc &lt;= vect_size_tot &amp;&amp; end_bloc &gt;= begin_bloc);
      <span class="keyword">const</span> <span class="keywordtype">int</span>* x_ptr = x_base + begin_bloc;
      <span class="keywordtype">int</span> count = end_bloc - begin_bloc;
      <span class="keywordflow">for</span> (; count; count--)
        {
          <span class="keyword">const</span> <span class="keywordtype">int</span> x = *x_ptr;
          sum += x;
          x_ptr++;
        }
    }
  <span class="keywordflow">return</span>  sum;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a277f42a42c9d9bb5add1240251922a63"></a><!-- doxytag: member="IntVect.cpp::mp_carre_norme_vect" ref="a277f42a42c9d9bb5add1240251922a63" args="(const IntVect &amp;vx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mp_carre_norme_vect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIntVect.html">IntVect</a> &amp;&#160;</td>
          <td class="paramname"><em>vx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="IntVect_8cpp_source.html#l00525">525</a> of file <a class="el" href="IntVect_8cpp_source.html">IntVect.cpp</a>.</p>

<p>References <a class="el" href="DoubleVect_8cpp_source.html#l00481">local_carre_norme_vect()</a>, and <a class="el" href="Process_8cpp_source.html#l00178">Process::mp_sum()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">return</span> <a class="code" href="classProcess.html#a7d23bc1ef94b3f0623fbc79d034c27fd" title="Calcule la somme de x sur tous les processeurs du groupe courant. Voir aussi mp_max()">Process::mp_sum</a>(<a class="code" href="DoubleVect_8cpp.html#aec1f3fbee9c49f94ac517feea6a8d6ed">local_carre_norme_vect</a>(vx));
}
</pre></div>
</div>
</div>
<a class="anchor" id="a885fd04c0974ac5ee8c725638dcc6992"></a><!-- doxytag: member="IntVect.cpp::mp_max_abs_vect" ref="a885fd04c0974ac5ee8c725638dcc6992" args="(const IntVect &amp;x, Mp_vect_options opt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mp_max_abs_vect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIntVect.html">IntVect</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a>&#160;</td>
          <td class="paramname"><em>opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="IntVect_8cpp_source.html#l01645">1645</a> of file <a class="el" href="IntVect_8cpp_source.html">IntVect.cpp</a>.</p>

<p>References <a class="el" href="DoubleVect_8cpp_source.html#l00829">local_max_abs_vect()</a>, and <a class="el" href="communications_8cpp_source.html#l00588">mp_max()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">int</span> s = <a class="code" href="DoubleVect_8cpp.html#aad339141fa6027fa3b627825a2407c12">local_max_abs_vect</a>(x, opt);
  s = <a class="code" href="communications_8cpp.html#a6b5d757052506cb052efbc14b268775b" title="renvoie le plus grand int i sur l&#39;ensemble des processeurs du groupe courant.">mp_max</a>(s);
  <span class="keywordflow">return</span> s;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a25dce1b6f82a2bea6851e98ac4d59b7b"></a><!-- doxytag: member="IntVect.cpp::mp_max_vect" ref="a25dce1b6f82a2bea6851e98ac4d59b7b" args="(const IntVect &amp;x, Mp_vect_options opt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mp_max_vect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIntVect.html">IntVect</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a>&#160;</td>
          <td class="paramname"><em>opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="IntVect_8cpp_source.html#l01633">1633</a> of file <a class="el" href="IntVect_8cpp_source.html">IntVect.cpp</a>.</p>

<p>References <a class="el" href="DoubleVect_8cpp_source.html#l00773">local_max_vect()</a>, and <a class="el" href="communications_8cpp_source.html#l00588">mp_max()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">int</span> s = <a class="code" href="DoubleVect_8cpp.html#a6471e7e85cb0b00b67bd7ca9bb362371">local_max_vect</a>(x, opt);
  s =  <a class="code" href="communications_8cpp.html#a6b5d757052506cb052efbc14b268775b" title="renvoie le plus grand int i sur l&#39;ensemble des processeurs du groupe courant.">mp_max</a>(s);
  <span class="keywordflow">return</span> s;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a5873b117ba560b744d0db8c24b4301ba"></a><!-- doxytag: member="IntVect.cpp::mp_min_abs_vect" ref="a5873b117ba560b744d0db8c24b4301ba" args="(const IntVect &amp;x, Mp_vect_options opt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mp_min_abs_vect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIntVect.html">IntVect</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a>&#160;</td>
          <td class="paramname"><em>opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="IntVect_8cpp_source.html#l01651">1651</a> of file <a class="el" href="IntVect_8cpp_source.html">IntVect.cpp</a>.</p>

<p>References <a class="el" href="DoubleVect_8cpp_source.html#l00886">local_min_abs_vect()</a>, and <a class="el" href="communications_8cpp_source.html#l00598">mp_min()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">int</span> s = <a class="code" href="DoubleVect_8cpp.html#abbb6099a23e2ab39b2308423112f6a67">local_min_abs_vect</a>(x, opt);
  s = <a class="code" href="communications_8cpp.html#adb9fffe31bc56a52685e93ba06932547" title="renvoie le plus petit int i sur l&#39;ensemble des processeurs du groupe courant.">mp_min</a>(s);
  <span class="keywordflow">return</span> s;
}
</pre></div>
</div>
</div>
<a class="anchor" id="ae2dd393da8943baf0bd3ade274cad458"></a><!-- doxytag: member="IntVect.cpp::mp_min_vect" ref="ae2dd393da8943baf0bd3ade274cad458" args="(const IntVect &amp;x, Mp_vect_options opt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mp_min_vect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIntVect.html">IntVect</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a>&#160;</td>
          <td class="paramname"><em>opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="IntVect_8cpp_source.html#l01639">1639</a> of file <a class="el" href="IntVect_8cpp_source.html">IntVect.cpp</a>.</p>

<p>References <a class="el" href="DoubleVect_8cpp_source.html#l00660">local_min_vect()</a>, and <a class="el" href="communications_8cpp_source.html#l00598">mp_min()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">int</span> s = <a class="code" href="DoubleVect_8cpp.html#a17be200c713a7031ede99b28391daa52">local_min_vect</a>(x, opt);
  s =  <a class="code" href="communications_8cpp.html#adb9fffe31bc56a52685e93ba06932547" title="renvoie le plus petit int i sur l&#39;ensemble des processeurs du groupe courant.">mp_min</a>(s);
  <span class="keywordflow">return</span> s;
}
</pre></div>
</div>
</div>
<a class="anchor" id="adb38ccd0360090be713e44ee90b80cd8"></a><!-- doxytag: member="IntVect.cpp::mp_prodscal" ref="adb38ccd0360090be713e44ee90b80cd8" args="(const IntVect &amp;x, const IntVect &amp;y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mp_prodscal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIntVect.html">IntVect</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIntVect.html">IntVect</a> &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="IntVect_8cpp_source.html#l01657">1657</a> of file <a class="el" href="IntVect_8cpp_source.html">IntVect.cpp</a>.</p>

<p>References <a class="el" href="DoubleVect_8cpp_source.html#l00419">local_prodscal()</a>, and <a class="el" href="Process_8cpp_source.html#l00178">Process::mp_sum()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">return</span> <a class="code" href="classProcess.html#a7d23bc1ef94b3f0623fbc79d034c27fd" title="Calcule la somme de x sur tous les processeurs du groupe courant. Voir aussi mp_max()">Process::mp_sum</a>(<a class="code" href="DoubleVect_8cpp.html#acbe5711639fbfe2e85d5f87bf81f851a" title="Renvoie la somme des x[i]*y[i] pour les items sequentiels sur ce processeur. (tous les items si pas d...">local_prodscal</a>(x, y));
}
</pre></div>
</div>
</div>
<a class="anchor" id="aa443ab516872b5fab7a1b473d0937dfc"></a><!-- doxytag: member="IntVect.cpp::mp_somme_vect" ref="aa443ab516872b5fab7a1b473d0937dfc" args="(const IntVect &amp;vx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mp_somme_vect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIntVect.html">IntVect</a> &amp;&#160;</td>
          <td class="paramname"><em>vx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="IntVect_8cpp_source.html#l00585">585</a> of file <a class="el" href="IntVect_8cpp_source.html">IntVect.cpp</a>.</p>

<p>References <a class="el" href="DoubleVect_8cpp_source.html#l00541">local_somme_vect()</a>, and <a class="el" href="Process_8cpp_source.html#l00178">Process::mp_sum()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">int</span> x = <a class="code" href="DoubleVect_8cpp.html#aaaede7053cdab4cd6f12f0fa2c065e37">local_somme_vect</a>(vx);
  <span class="keywordtype">int</span> y = <a class="code" href="classProcess.html#a7d23bc1ef94b3f0623fbc79d034c27fd" title="Calcule la somme de x sur tous les processeurs du groupe courant. Voir aussi mp_max()">Process::mp_sum</a>(x);
  <span class="keywordflow">return</span> y;
}
</pre></div>
</div>
</div>
<a class="anchor" id="afe7b6a7310bafb543df557a0d845e3e4"></a><!-- doxytag: member="IntVect.cpp::operator!=" ref="afe7b6a7310bafb543df557a0d845e3e4" args="(const IntVect &amp;x, const IntVect &amp;y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIntVect.html">IntVect</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIntVect.html">IntVect</a> &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="IntVect_8cpp_source.html#l00359">359</a> of file <a class="el" href="IntVect_8cpp_source.html">IntVect.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">return</span> !(x == y);
}
</pre></div>
</div>
</div>
<a class="anchor" id="ade146e7b644bec7ea5b5c6fcb88fe2a9"></a><!-- doxytag: member="IntVect.cpp::operator==" ref="ade146e7b644bec7ea5b5c6fcb88fe2a9" args="(const IntVect &amp;x, const IntVect &amp;y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIntVect.html">IntVect</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIntVect.html">IntVect</a> &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>renvoie 1 si meme strucuture parallele et egalite au sens ArrOfInt&lt;br&gt;(y compris espaces virtuels)<br/>
BM: faut-il etre aussi strict, comparer uniquement size() elements ? </p>

<p>Definition at line <a class="el" href="IntVect_8cpp_source.html#l00350">350</a> of file <a class="el" href="IntVect_8cpp_source.html">IntVect.cpp</a>.</p>

<p>References <a class="el" href="IntVect_8h_source.html#l00087">IntVect::get_md_vector()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">if</span> (!(x.<a class="code" href="classIntVect.html#ae74e1fee6aca124d32718267e33a40c6">get_md_vector</a>() == y.<a class="code" href="classIntVect.html#ae74e1fee6aca124d32718267e33a40c6">get_md_vector</a>()))
    <span class="keywordflow">return</span> 0;
  <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; ax = x;
  <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; ay = y;
  <span class="keywordflow">return</span> ax == ay;
}
</pre></div>
</div>
</div>
<a class="anchor" id="aafa46b52a972256717da9fd2079df15c"></a><!-- doxytag: member="IntVect.cpp::operator_abs" ref="aafa46b52a972256717da9fd2079df15c" args="(IntVect &amp;resu, Mp_vect_options opt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operator_abs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classIntVect.html">IntVect</a> &amp;&#160;</td>
          <td class="paramname"><em>resu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a>&#160;</td>
          <td class="paramname"><em>opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="IntVect_8cpp_source.html#l00931">931</a> of file <a class="el" href="IntVect_8cpp_source.html">IntVect.cpp</a>.</p>

<p>References <a class="el" href="ArrOfInt_8h_source.html#l00371">ArrOfInt::addr()</a>, <a class="el" href="classMD__Vector__base.html#a99334ac2566d9457c8d4890ba20883ea">MD_Vector_base::get_items_to_compute()</a>, <a class="el" href="classMD__Vector__base.html#a7f6b6d0b7babfec0cce590cdea5bca53">MD_Vector_base::get_items_to_sum()</a>, <a class="el" href="IntVect_8h_source.html#l00087">IntVect::get_md_vector()</a>, <a class="el" href="IntVect_8cpp_source.html#l00367">invalidate_data()</a>, <a class="el" href="IntVect_8h_source.html#l00150">IntVect::line_size()</a>, <a class="el" href="MD__Vector_8h_source.html#l00063">MD_Vector::non_nul()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00342">ArrOfInt::size_array()</a>, <a class="el" href="IntVect_8h_source.html#l00145">IntVect::size_totale()</a>, <a class="el" href="MD__Vector_8h_source.html#l00067">MD_Vector::valeur()</a>, <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_ALL_ITEMS</a>, <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_REAL_ITEMS</a>, and <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_SEQUENTIAL_ITEMS</a>.</p>
<div class="fragment"><pre class="fragment">{

<span class="comment">// Master vect donne la structure de reference, les autres vecteurs</span>
<span class="comment">// doivent avoir la meme structure.</span>
  <span class="keyword">const</span> <a class="code" href="classIntVect.html">IntVect</a>&amp; master_vect = resu;
  <span class="keywordtype">int</span> line_size = master_vect.<a class="code" href="classIntVect.html#a5ba680066169c8e057bb3e3b876e4a8c">line_size</a>();
  <span class="keyword">const</span> <a class="code" href="classMD__Vector.html" title=": Cette classe est un DERIV mais l&#39;objet pointe est partage entre plusieurs instances de cette classe...">MD_Vector</a>&amp; md = master_vect.<a class="code" href="classIntVect.html#ae74e1fee6aca124d32718267e33a40c6">get_md_vector</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> vect_size_tot = master_vect.<a class="code" href="classIntVect.html#afa716e1f0a1f0f74f4f73e95b5651412" title="Identique a size_array()">size_totale</a>();
<span class="comment">// Determine blocs of data to process, depending on &quot; opt&quot;</span>
  <span class="keywordtype">int</span> nblocs_left = 1;
  <span class="keywordtype">int</span> one_bloc[2];
  <span class="keyword">const</span> <span class="keywordtype">int</span> *bloc_ptr;
  <span class="keywordflow">if</span> ( opt != <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caad18680091a9f62247573cb3caa6450b9">VECT_ALL_ITEMS</a> &amp;&amp; md.<a class="code" href="classMD__Vector.html#a4165c00904b7096274e38fdc7ca340f4">non_nul</a>())
    {
      assert( opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a> ||  opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caab47906d8d2e6c20f8ba32e4acb6edbe0">VECT_REAL_ITEMS</a>);
      <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; items_blocs = ( opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a>) ? md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a7f6b6d0b7babfec0cce590cdea5bca53">get_items_to_sum</a>() : md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a99334ac2566d9457c8d4890ba20883ea">get_items_to_compute</a>();
      assert(items_blocs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() % 2 == 0);
      nblocs_left = items_blocs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() &gt;&gt; 1;
      bloc_ptr = items_blocs.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
    }
  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (vect_size_tot &gt; 0)
    {
<span class="comment">// attention, si vect_size_tot est nul, line_size a le droit d&#39;etre nul</span>
<span class="comment">// Compute all data, in the vector (including virtual data), build a big bloc:</span>
      nblocs_left = 1;
      bloc_ptr = one_bloc;
      one_bloc[0] = 0;
      one_bloc[1] = vect_size_tot / line_size;
    }
  <span class="keywordflow">else</span>
    {
<span class="comment">// raccourci pour les tableaux vides (evite le cas particulier line_size == 0)</span>
      return ;
    }
  <span class="keywordtype">int</span> *resu_base = resu.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
  <span class="keywordflow">for</span> (; nblocs_left; nblocs_left--)
    {
<span class="comment">// Get index of next bloc start:</span>
      <span class="keyword">const</span> <span class="keywordtype">int</span> begin_bloc = (*(bloc_ptr++)) * line_size;
      <span class="keyword">const</span> <span class="keywordtype">int</span> end_bloc = (*(bloc_ptr++)) * line_size;
      assert(begin_bloc &gt;= 0 &amp;&amp; end_bloc &lt;= vect_size_tot &amp;&amp; end_bloc &gt;= begin_bloc);
      <span class="keywordtype">int</span>* resu_ptr = resu_base + begin_bloc;
      <span class="keywordtype">int</span> count = end_bloc - begin_bloc;
      <span class="keywordflow">for</span> (; count; count--)
        {
          <span class="keywordtype">int</span>&amp; p_resu = *(resu_ptr++);
          p_resu = abs(p_resu);
        }
    }
<span class="comment">// In debug mode, put invalid values where data has not been computed</span>
<span class="preprocessor">#ifndef NDEBUG</span>
<span class="preprocessor"></span>  <a class="code" href="IntVect_8cpp.html#a27f59c580905a55953c9aa2734a1fc73">invalidate_data</a>(resu,  opt);
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>  return ;
}
</pre></div>
</div>
</div>
<a class="anchor" id="abacecb9b90f28486608b021d1cdbcb6b"></a><!-- doxytag: member="IntVect.cpp::operator_add" ref="abacecb9b90f28486608b021d1cdbcb6b" args="(IntVect &amp;resu, const IntVect &amp;vx, Mp_vect_options opt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operator_add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classIntVect.html">IntVect</a> &amp;&#160;</td>
          <td class="paramname"><em>resu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIntVect.html">IntVect</a> &amp;&#160;</td>
          <td class="paramname"><em>vx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a>&#160;</td>
          <td class="paramname"><em>opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>&lt; this test is necessary if md is null </p>
</p>

<p>Definition at line <a class="el" href="IntVect_8cpp_source.html#l00987">987</a> of file <a class="el" href="IntVect_8cpp_source.html">IntVect.cpp</a>.</p>

<p>References <a class="el" href="ArrOfInt_8h_source.html#l00371">ArrOfInt::addr()</a>, <a class="el" href="classMD__Vector__base.html#a99334ac2566d9457c8d4890ba20883ea">MD_Vector_base::get_items_to_compute()</a>, <a class="el" href="classMD__Vector__base.html#a7f6b6d0b7babfec0cce590cdea5bca53">MD_Vector_base::get_items_to_sum()</a>, <a class="el" href="IntVect_8h_source.html#l00087">IntVect::get_md_vector()</a>, <a class="el" href="IntVect_8cpp_source.html#l00367">invalidate_data()</a>, <a class="el" href="IntVect_8h_source.html#l00150">IntVect::line_size()</a>, <a class="el" href="MD__Vector_8h_source.html#l00063">MD_Vector::non_nul()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00342">ArrOfInt::size_array()</a>, <a class="el" href="IntVect_8h_source.html#l00145">IntVect::size_totale()</a>, <a class="el" href="MD__Vector_8h_source.html#l00067">MD_Vector::valeur()</a>, <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_ALL_ITEMS</a>, <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_REAL_ITEMS</a>, and <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_SEQUENTIAL_ITEMS</a>.</p>
<div class="fragment"><pre class="fragment">{

<span class="comment">// Master vect donne la structure de reference, les autres vecteurs</span>
<span class="comment">// doivent avoir la meme structure.</span>
  <span class="keyword">const</span> <a class="code" href="classIntVect.html">IntVect</a>&amp; master_vect = resu;
  <span class="keywordtype">int</span> line_size = master_vect.<a class="code" href="classIntVect.html#a5ba680066169c8e057bb3e3b876e4a8c">line_size</a>();
  <span class="keyword">const</span> <a class="code" href="classMD__Vector.html" title=": Cette classe est un DERIV mais l&#39;objet pointe est partage entre plusieurs instances de cette classe...">MD_Vector</a>&amp; md = master_vect.<a class="code" href="classIntVect.html#ae74e1fee6aca124d32718267e33a40c6">get_md_vector</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> vect_size_tot = master_vect.<a class="code" href="classIntVect.html#afa716e1f0a1f0f74f4f73e95b5651412" title="Identique a size_array()">size_totale</a>();
  assert(vx.<a class="code" href="classIntVect.html#a5ba680066169c8e057bb3e3b876e4a8c">line_size</a>() == line_size);
  assert(vx.<a class="code" href="classIntVect.html#afa716e1f0a1f0f74f4f73e95b5651412" title="Identique a size_array()">size_totale</a>() == vect_size_tot); <span class="comment">//!&lt; this test is necessary if md is null</span>
<span class="comment"></span>  assert(vx.<a class="code" href="classIntVect.html#ae74e1fee6aca124d32718267e33a40c6">get_md_vector</a>() == md);
<span class="comment">// Determine blocs of data to process, depending on &quot; opt&quot;</span>
  <span class="keywordtype">int</span> nblocs_left = 1;
  <span class="keywordtype">int</span> one_bloc[2];
  <span class="keyword">const</span> <span class="keywordtype">int</span> *bloc_ptr;
  <span class="keywordflow">if</span> ( opt != <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caad18680091a9f62247573cb3caa6450b9">VECT_ALL_ITEMS</a> &amp;&amp; md.<a class="code" href="classMD__Vector.html#a4165c00904b7096274e38fdc7ca340f4">non_nul</a>())
    {
      assert( opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a> ||  opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caab47906d8d2e6c20f8ba32e4acb6edbe0">VECT_REAL_ITEMS</a>);
      <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; items_blocs = ( opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a>) ? md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a7f6b6d0b7babfec0cce590cdea5bca53">get_items_to_sum</a>() : md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a99334ac2566d9457c8d4890ba20883ea">get_items_to_compute</a>();
      assert(items_blocs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() % 2 == 0);
      nblocs_left = items_blocs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() &gt;&gt; 1;
      bloc_ptr = items_blocs.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
    }
  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (vect_size_tot &gt; 0)
    {
<span class="comment">// attention, si vect_size_tot est nul, line_size a le droit d&#39;etre nul</span>
<span class="comment">// Compute all data, in the vector (including virtual data), build a big bloc:</span>
      nblocs_left = 1;
      bloc_ptr = one_bloc;
      one_bloc[0] = 0;
      one_bloc[1] = vect_size_tot / line_size;
    }
  <span class="keywordflow">else</span>
    {
<span class="comment">// raccourci pour les tableaux vides (evite le cas particulier line_size == 0)</span>
      return ;
    }
  <span class="keywordtype">int</span> *resu_base = resu.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> *x_base = vx.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
  <span class="keywordflow">for</span> (; nblocs_left; nblocs_left--)
    {
<span class="comment">// Get index of next bloc start:</span>
      <span class="keyword">const</span> <span class="keywordtype">int</span> begin_bloc = (*(bloc_ptr++)) * line_size;
      <span class="keyword">const</span> <span class="keywordtype">int</span> end_bloc = (*(bloc_ptr++)) * line_size;
      assert(begin_bloc &gt;= 0 &amp;&amp; end_bloc &lt;= vect_size_tot &amp;&amp; end_bloc &gt;= begin_bloc);
      <span class="keywordtype">int</span>* resu_ptr = resu_base + begin_bloc;
      <span class="keyword">const</span> <span class="keywordtype">int</span>* x_ptr = x_base + begin_bloc;
      <span class="keywordtype">int</span> count = end_bloc - begin_bloc;
      <span class="keywordflow">for</span> (; count; count--)
        {
          <span class="keyword">const</span> <span class="keywordtype">int</span> x = *x_ptr;
          <span class="keywordtype">int</span>&amp; p_resu = *(resu_ptr++);
          p_resu += x;
          x_ptr++;
        }
    }
<span class="comment">// In debug mode, put invalid values where data has not been computed</span>
<span class="preprocessor">#ifndef NDEBUG</span>
<span class="preprocessor"></span>  <a class="code" href="IntVect_8cpp.html#a27f59c580905a55953c9aa2734a1fc73">invalidate_data</a>(resu,  opt);
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>  return ;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a0e31906db9339bbe43812959c7863353"></a><!-- doxytag: member="IntVect.cpp::operator_add" ref="a0e31906db9339bbe43812959c7863353" args="(IntVect &amp;resu, const int x, Mp_vect_options opt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operator_add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classIntVect.html">IntVect</a> &amp;&#160;</td>
          <td class="paramname"><em>resu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a>&#160;</td>
          <td class="paramname"><em>opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="IntVect_8cpp_source.html#l01050">1050</a> of file <a class="el" href="IntVect_8cpp_source.html">IntVect.cpp</a>.</p>

<p>References <a class="el" href="ArrOfInt_8h_source.html#l00371">ArrOfInt::addr()</a>, <a class="el" href="classMD__Vector__base.html#a99334ac2566d9457c8d4890ba20883ea">MD_Vector_base::get_items_to_compute()</a>, <a class="el" href="classMD__Vector__base.html#a7f6b6d0b7babfec0cce590cdea5bca53">MD_Vector_base::get_items_to_sum()</a>, <a class="el" href="IntVect_8h_source.html#l00087">IntVect::get_md_vector()</a>, <a class="el" href="IntVect_8cpp_source.html#l00367">invalidate_data()</a>, <a class="el" href="IntVect_8h_source.html#l00150">IntVect::line_size()</a>, <a class="el" href="MD__Vector_8h_source.html#l00063">MD_Vector::non_nul()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00342">ArrOfInt::size_array()</a>, <a class="el" href="IntVect_8h_source.html#l00145">IntVect::size_totale()</a>, <a class="el" href="MD__Vector_8h_source.html#l00067">MD_Vector::valeur()</a>, <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_ALL_ITEMS</a>, <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_REAL_ITEMS</a>, and <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_SEQUENTIAL_ITEMS</a>.</p>
<div class="fragment"><pre class="fragment">{

<span class="comment">// Master vect donne la structure de reference, les autres vecteurs</span>
<span class="comment">// doivent avoir la meme structure.</span>
  <span class="keyword">const</span> <a class="code" href="classIntVect.html">IntVect</a>&amp; master_vect = resu;
  <span class="keywordtype">int</span> line_size = master_vect.<a class="code" href="classIntVect.html#a5ba680066169c8e057bb3e3b876e4a8c">line_size</a>();
  <span class="keyword">const</span> <a class="code" href="classMD__Vector.html" title=": Cette classe est un DERIV mais l&#39;objet pointe est partage entre plusieurs instances de cette classe...">MD_Vector</a>&amp; md = master_vect.<a class="code" href="classIntVect.html#ae74e1fee6aca124d32718267e33a40c6">get_md_vector</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> vect_size_tot = master_vect.<a class="code" href="classIntVect.html#afa716e1f0a1f0f74f4f73e95b5651412" title="Identique a size_array()">size_totale</a>();
<span class="comment">// Determine blocs of data to process, depending on &quot; opt&quot;</span>
  <span class="keywordtype">int</span> nblocs_left = 1;
  <span class="keywordtype">int</span> one_bloc[2];
  <span class="keyword">const</span> <span class="keywordtype">int</span> *bloc_ptr;
  <span class="keywordflow">if</span> ( opt != <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caad18680091a9f62247573cb3caa6450b9">VECT_ALL_ITEMS</a> &amp;&amp; md.<a class="code" href="classMD__Vector.html#a4165c00904b7096274e38fdc7ca340f4">non_nul</a>())
    {
      assert( opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a> ||  opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caab47906d8d2e6c20f8ba32e4acb6edbe0">VECT_REAL_ITEMS</a>);
      <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; items_blocs = ( opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a>) ? md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a7f6b6d0b7babfec0cce590cdea5bca53">get_items_to_sum</a>() : md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a99334ac2566d9457c8d4890ba20883ea">get_items_to_compute</a>();
      assert(items_blocs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() % 2 == 0);
      nblocs_left = items_blocs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() &gt;&gt; 1;
      bloc_ptr = items_blocs.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
    }
  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (vect_size_tot &gt; 0)
    {
<span class="comment">// attention, si vect_size_tot est nul, line_size a le droit d&#39;etre nul</span>
<span class="comment">// Compute all data, in the vector (including virtual data), build a big bloc:</span>
      nblocs_left = 1;
      bloc_ptr = one_bloc;
      one_bloc[0] = 0;
      one_bloc[1] = vect_size_tot / line_size;
    }
  <span class="keywordflow">else</span>
    {
<span class="comment">// raccourci pour les tableaux vides (evite le cas particulier line_size == 0)</span>
      return ;
    }
  <span class="keywordtype">int</span> *resu_base = resu.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
  <span class="keywordflow">for</span> (; nblocs_left; nblocs_left--)
    {
<span class="comment">// Get index of next bloc start:</span>
      <span class="keyword">const</span> <span class="keywordtype">int</span> begin_bloc = (*(bloc_ptr++)) * line_size;
      <span class="keyword">const</span> <span class="keywordtype">int</span> end_bloc = (*(bloc_ptr++)) * line_size;
      assert(begin_bloc &gt;= 0 &amp;&amp; end_bloc &lt;= vect_size_tot &amp;&amp; end_bloc &gt;= begin_bloc);
      <span class="keywordtype">int</span>* resu_ptr = resu_base + begin_bloc;
      <span class="keywordtype">int</span> count = end_bloc - begin_bloc;
      <span class="keywordflow">for</span> (; count; count--)
        {
          <span class="keywordtype">int</span>&amp; p_resu = *(resu_ptr++);
          p_resu += x;
        }
    }
<span class="comment">// In debug mode, put invalid values where data has not been computed</span>
<span class="preprocessor">#ifndef NDEBUG</span>
<span class="preprocessor"></span>  <a class="code" href="IntVect_8cpp.html#a27f59c580905a55953c9aa2734a1fc73">invalidate_data</a>(resu,  opt);
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>  return ;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a1d36c55404bb2f2f8fa32977333571e4"></a><!-- doxytag: member="IntVect.cpp::operator_divide" ref="a1d36c55404bb2f2f8fa32977333571e4" args="(IntVect &amp;resu, const int x, Mp_vect_options opt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operator_divide </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classIntVect.html">IntVect</a> &amp;&#160;</td>
          <td class="paramname"><em>resu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a>&#160;</td>
          <td class="paramname"><em>opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="IntVect_8cpp_source.html#l01519">1519</a> of file <a class="el" href="IntVect_8cpp_source.html">IntVect.cpp</a>.</p>

<p>References <a class="el" href="ArrOfInt_8h_source.html#l00371">ArrOfInt::addr()</a>, <a class="el" href="EntreeSortie_8h_source.html#l00032">Cerr</a>, <a class="el" href="Process_8cpp_source.html#l00223">Process::exit()</a>, <a class="el" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>, <a class="el" href="classMD__Vector__base.html#a99334ac2566d9457c8d4890ba20883ea">MD_Vector_base::get_items_to_compute()</a>, <a class="el" href="classMD__Vector__base.html#a7f6b6d0b7babfec0cce590cdea5bca53">MD_Vector_base::get_items_to_sum()</a>, <a class="el" href="IntVect_8h_source.html#l00087">IntVect::get_md_vector()</a>, <a class="el" href="IntVect_8cpp_source.html#l00367">invalidate_data()</a>, <a class="el" href="IntVect_8h_source.html#l00150">IntVect::line_size()</a>, <a class="el" href="MD__Vector_8h_source.html#l00063">MD_Vector::non_nul()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00342">ArrOfInt::size_array()</a>, <a class="el" href="IntVect_8h_source.html#l00145">IntVect::size_totale()</a>, <a class="el" href="MD__Vector_8h_source.html#l00067">MD_Vector::valeur()</a>, <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_ALL_ITEMS</a>, <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_REAL_ITEMS</a>, and <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_SEQUENTIAL_ITEMS</a>.</p>
<div class="fragment"><pre class="fragment">{

<span class="comment">// Master vect donne la structure de reference, les autres vecteurs</span>
<span class="comment">// doivent avoir la meme structure.</span>
  <span class="keyword">const</span> <a class="code" href="classIntVect.html">IntVect</a>&amp; master_vect = resu;
  <span class="keywordtype">int</span> line_size = master_vect.<a class="code" href="classIntVect.html#a5ba680066169c8e057bb3e3b876e4a8c">line_size</a>();
  <span class="keyword">const</span> <a class="code" href="classMD__Vector.html" title=": Cette classe est un DERIV mais l&#39;objet pointe est partage entre plusieurs instances de cette classe...">MD_Vector</a>&amp; md = master_vect.<a class="code" href="classIntVect.html#ae74e1fee6aca124d32718267e33a40c6">get_md_vector</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> vect_size_tot = master_vect.<a class="code" href="classIntVect.html#afa716e1f0a1f0f74f4f73e95b5651412" title="Identique a size_array()">size_totale</a>();
<span class="comment">// Determine blocs of data to process, depending on &quot; opt&quot;</span>
  <span class="keywordtype">int</span> nblocs_left = 1;
  <span class="keywordtype">int</span> one_bloc[2];
  <span class="keyword">const</span> <span class="keywordtype">int</span> *bloc_ptr;
  <span class="keywordflow">if</span> ( opt != <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caad18680091a9f62247573cb3caa6450b9">VECT_ALL_ITEMS</a> &amp;&amp; md.<a class="code" href="classMD__Vector.html#a4165c00904b7096274e38fdc7ca340f4">non_nul</a>())
    {
      assert( opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a> ||  opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caab47906d8d2e6c20f8ba32e4acb6edbe0">VECT_REAL_ITEMS</a>);
      <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; items_blocs = ( opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a>) ? md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a7f6b6d0b7babfec0cce590cdea5bca53">get_items_to_sum</a>() : md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a99334ac2566d9457c8d4890ba20883ea">get_items_to_compute</a>();
      assert(items_blocs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() % 2 == 0);
      nblocs_left = items_blocs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() &gt;&gt; 1;
      bloc_ptr = items_blocs.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
    }
  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (vect_size_tot &gt; 0)
    {
<span class="comment">// attention, si vect_size_tot est nul, line_size a le droit d&#39;etre nul</span>
<span class="comment">// Compute all data, in the vector (including virtual data), build a big bloc:</span>
      nblocs_left = 1;
      bloc_ptr = one_bloc;
      one_bloc[0] = 0;
      one_bloc[1] = vect_size_tot / line_size;
    }
  <span class="keywordflow">else</span>
    {
<span class="comment">// raccourci pour les tableaux vides (evite le cas particulier line_size == 0)</span>
      return ;
    }
  <span class="keywordtype">int</span> *resu_base = resu.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
  <span class="keywordflow">for</span> (; nblocs_left; nblocs_left--)
    {
<span class="comment">// Get index of next bloc start:</span>
      <span class="keyword">const</span> <span class="keywordtype">int</span> begin_bloc = (*(bloc_ptr++)) * line_size;
      <span class="keyword">const</span> <span class="keywordtype">int</span> end_bloc = (*(bloc_ptr++)) * line_size;
      assert(begin_bloc &gt;= 0 &amp;&amp; end_bloc &lt;= vect_size_tot &amp;&amp; end_bloc &gt;= begin_bloc);
      <span class="keywordtype">int</span>* resu_ptr = resu_base + begin_bloc;
      <span class="keywordtype">int</span> count = end_bloc - begin_bloc;
      <span class="keywordflow">for</span> (; count; count--)
        {
          <span class="keywordtype">int</span>&amp; p_resu = *(resu_ptr++);
          <span class="keywordflow">if</span>(x==0.) { <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Error: divide by 0 in operator_divide.&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>; <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">Process::exit</a>();};
          p_resu /= x;
        }
    }
<span class="comment">// In debug mode, put invalid values where data has not been computed</span>
<span class="preprocessor">#ifndef NDEBUG</span>
<span class="preprocessor"></span>  <a class="code" href="IntVect_8cpp.html#a27f59c580905a55953c9aa2734a1fc73">invalidate_data</a>(resu,  opt);
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>  return ;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a1d7ecc85770b9a137e48bbebf2490fca"></a><!-- doxytag: member="IntVect.cpp::operator_egal" ref="a1d7ecc85770b9a137e48bbebf2490fca" args="(IntVect &amp;resu, int x, Mp_vect_options opt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operator_egal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classIntVect.html">IntVect</a> &amp;&#160;</td>
          <td class="paramname"><em>resu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a>&#160;</td>
          <td class="paramname"><em>opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="IntVect_8cpp_source.html#l01400">1400</a> of file <a class="el" href="IntVect_8cpp_source.html">IntVect.cpp</a>.</p>

<p>References <a class="el" href="ArrOfInt_8h_source.html#l00371">ArrOfInt::addr()</a>, <a class="el" href="classMD__Vector__base.html#a99334ac2566d9457c8d4890ba20883ea">MD_Vector_base::get_items_to_compute()</a>, <a class="el" href="classMD__Vector__base.html#a7f6b6d0b7babfec0cce590cdea5bca53">MD_Vector_base::get_items_to_sum()</a>, <a class="el" href="IntVect_8h_source.html#l00087">IntVect::get_md_vector()</a>, <a class="el" href="IntVect_8cpp_source.html#l00367">invalidate_data()</a>, <a class="el" href="IntVect_8h_source.html#l00150">IntVect::line_size()</a>, <a class="el" href="MD__Vector_8h_source.html#l00063">MD_Vector::non_nul()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00342">ArrOfInt::size_array()</a>, <a class="el" href="IntVect_8h_source.html#l00145">IntVect::size_totale()</a>, <a class="el" href="MD__Vector_8h_source.html#l00067">MD_Vector::valeur()</a>, <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_ALL_ITEMS</a>, <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_REAL_ITEMS</a>, and <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_SEQUENTIAL_ITEMS</a>.</p>
<div class="fragment"><pre class="fragment">{

<span class="comment">// Master vect donne la structure de reference, les autres vecteurs</span>
<span class="comment">// doivent avoir la meme structure.</span>
  <span class="keyword">const</span> <a class="code" href="classIntVect.html">IntVect</a>&amp; master_vect = resu;
  <span class="keywordtype">int</span> line_size = master_vect.<a class="code" href="classIntVect.html#a5ba680066169c8e057bb3e3b876e4a8c">line_size</a>();
  <span class="keyword">const</span> <a class="code" href="classMD__Vector.html" title=": Cette classe est un DERIV mais l&#39;objet pointe est partage entre plusieurs instances de cette classe...">MD_Vector</a>&amp; md = master_vect.<a class="code" href="classIntVect.html#ae74e1fee6aca124d32718267e33a40c6">get_md_vector</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> vect_size_tot = master_vect.<a class="code" href="classIntVect.html#afa716e1f0a1f0f74f4f73e95b5651412" title="Identique a size_array()">size_totale</a>();
<span class="comment">// Determine blocs of data to process, depending on &quot; opt&quot;</span>
  <span class="keywordtype">int</span> nblocs_left = 1;
  <span class="keywordtype">int</span> one_bloc[2];
  <span class="keyword">const</span> <span class="keywordtype">int</span> *bloc_ptr;
  <span class="keywordflow">if</span> ( opt != <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caad18680091a9f62247573cb3caa6450b9">VECT_ALL_ITEMS</a> &amp;&amp; md.<a class="code" href="classMD__Vector.html#a4165c00904b7096274e38fdc7ca340f4">non_nul</a>())
    {
      assert( opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a> ||  opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caab47906d8d2e6c20f8ba32e4acb6edbe0">VECT_REAL_ITEMS</a>);
      <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; items_blocs = ( opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a>) ? md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a7f6b6d0b7babfec0cce590cdea5bca53">get_items_to_sum</a>() : md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a99334ac2566d9457c8d4890ba20883ea">get_items_to_compute</a>();
      assert(items_blocs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() % 2 == 0);
      nblocs_left = items_blocs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() &gt;&gt; 1;
      bloc_ptr = items_blocs.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
    }
  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (vect_size_tot &gt; 0)
    {
<span class="comment">// attention, si vect_size_tot est nul, line_size a le droit d&#39;etre nul</span>
<span class="comment">// Compute all data, in the vector (including virtual data), build a big bloc:</span>
      nblocs_left = 1;
      bloc_ptr = one_bloc;
      one_bloc[0] = 0;
      one_bloc[1] = vect_size_tot / line_size;
    }
  <span class="keywordflow">else</span>
    {
<span class="comment">// raccourci pour les tableaux vides (evite le cas particulier line_size == 0)</span>
      return ;
    }
  <span class="keywordtype">int</span> *resu_base = resu.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
  <span class="keywordflow">for</span> (; nblocs_left; nblocs_left--)
    {
<span class="comment">// Get index of next bloc start:</span>
      <span class="keyword">const</span> <span class="keywordtype">int</span> begin_bloc = (*(bloc_ptr++)) * line_size;
      <span class="keyword">const</span> <span class="keywordtype">int</span> end_bloc = (*(bloc_ptr++)) * line_size;
      assert(begin_bloc &gt;= 0 &amp;&amp; end_bloc &lt;= vect_size_tot &amp;&amp; end_bloc &gt;= begin_bloc);
      <span class="keywordtype">int</span>* resu_ptr = resu_base + begin_bloc;
      <span class="keywordtype">int</span> count = end_bloc - begin_bloc;
      <span class="keywordflow">for</span> (; count; count--)
        {
          <span class="keywordtype">int</span>&amp; p_resu = *(resu_ptr++);
          p_resu = x;
        }
    }
<span class="comment">// In debug mode, put invalid values where data has not been computed</span>
<span class="preprocessor">#ifndef NDEBUG</span>
<span class="preprocessor"></span>  <a class="code" href="IntVect_8cpp.html#a27f59c580905a55953c9aa2734a1fc73">invalidate_data</a>(resu,  opt);
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>  return ;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a6524c227e7647f6f1a3c80853e573c49"></a><!-- doxytag: member="IntVect.cpp::operator_egal" ref="a6524c227e7647f6f1a3c80853e573c49" args="(IntVect &amp;resu, const IntVect &amp;vx, Mp_vect_options opt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operator_egal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classIntVect.html">IntVect</a> &amp;&#160;</td>
          <td class="paramname"><em>resu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIntVect.html">IntVect</a> &amp;&#160;</td>
          <td class="paramname"><em>vx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a>&#160;</td>
          <td class="paramname"><em>opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>&lt; this test is necessary if md is null </p>
</p>

<p>Definition at line <a class="el" href="IntVect_8cpp_source.html#l01456">1456</a> of file <a class="el" href="IntVect_8cpp_source.html">IntVect.cpp</a>.</p>

<p>References <a class="el" href="ArrOfInt_8h_source.html#l00371">ArrOfInt::addr()</a>, <a class="el" href="classMD__Vector__base.html#a99334ac2566d9457c8d4890ba20883ea">MD_Vector_base::get_items_to_compute()</a>, <a class="el" href="classMD__Vector__base.html#a7f6b6d0b7babfec0cce590cdea5bca53">MD_Vector_base::get_items_to_sum()</a>, <a class="el" href="IntVect_8h_source.html#l00087">IntVect::get_md_vector()</a>, <a class="el" href="IntVect_8cpp_source.html#l00367">invalidate_data()</a>, <a class="el" href="IntVect_8h_source.html#l00150">IntVect::line_size()</a>, <a class="el" href="MD__Vector_8h_source.html#l00063">MD_Vector::non_nul()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00342">ArrOfInt::size_array()</a>, <a class="el" href="IntVect_8h_source.html#l00145">IntVect::size_totale()</a>, <a class="el" href="MD__Vector_8h_source.html#l00067">MD_Vector::valeur()</a>, <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_ALL_ITEMS</a>, <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_REAL_ITEMS</a>, and <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_SEQUENTIAL_ITEMS</a>.</p>
<div class="fragment"><pre class="fragment">{

<span class="comment">// Master vect donne la structure de reference, les autres vecteurs</span>
<span class="comment">// doivent avoir la meme structure.</span>
  <span class="keyword">const</span> <a class="code" href="classIntVect.html">IntVect</a>&amp; master_vect = resu;
  <span class="keywordtype">int</span> line_size = master_vect.<a class="code" href="classIntVect.html#a5ba680066169c8e057bb3e3b876e4a8c">line_size</a>();
  <span class="keyword">const</span> <a class="code" href="classMD__Vector.html" title=": Cette classe est un DERIV mais l&#39;objet pointe est partage entre plusieurs instances de cette classe...">MD_Vector</a>&amp; md = master_vect.<a class="code" href="classIntVect.html#ae74e1fee6aca124d32718267e33a40c6">get_md_vector</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> vect_size_tot = master_vect.<a class="code" href="classIntVect.html#afa716e1f0a1f0f74f4f73e95b5651412" title="Identique a size_array()">size_totale</a>();
  assert(vx.<a class="code" href="classIntVect.html#a5ba680066169c8e057bb3e3b876e4a8c">line_size</a>() == line_size);
  assert(vx.<a class="code" href="classIntVect.html#afa716e1f0a1f0f74f4f73e95b5651412" title="Identique a size_array()">size_totale</a>() == vect_size_tot); <span class="comment">//!&lt; this test is necessary if md is null</span>
<span class="comment"></span>  assert(vx.<a class="code" href="classIntVect.html#ae74e1fee6aca124d32718267e33a40c6">get_md_vector</a>() == md);
<span class="comment">// Determine blocs of data to process, depending on &quot; opt&quot;</span>
  <span class="keywordtype">int</span> nblocs_left = 1;
  <span class="keywordtype">int</span> one_bloc[2];
  <span class="keyword">const</span> <span class="keywordtype">int</span> *bloc_ptr;
  <span class="keywordflow">if</span> ( opt != <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caad18680091a9f62247573cb3caa6450b9">VECT_ALL_ITEMS</a> &amp;&amp; md.<a class="code" href="classMD__Vector.html#a4165c00904b7096274e38fdc7ca340f4">non_nul</a>())
    {
      assert( opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a> ||  opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caab47906d8d2e6c20f8ba32e4acb6edbe0">VECT_REAL_ITEMS</a>);
      <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; items_blocs = ( opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a>) ? md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a7f6b6d0b7babfec0cce590cdea5bca53">get_items_to_sum</a>() : md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a99334ac2566d9457c8d4890ba20883ea">get_items_to_compute</a>();
      assert(items_blocs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() % 2 == 0);
      nblocs_left = items_blocs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() &gt;&gt; 1;
      bloc_ptr = items_blocs.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
    }
  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (vect_size_tot &gt; 0)
    {
<span class="comment">// attention, si vect_size_tot est nul, line_size a le droit d&#39;etre nul</span>
<span class="comment">// Compute all data, in the vector (including virtual data), build a big bloc:</span>
      nblocs_left = 1;
      bloc_ptr = one_bloc;
      one_bloc[0] = 0;
      one_bloc[1] = vect_size_tot / line_size;
    }
  <span class="keywordflow">else</span>
    {
<span class="comment">// raccourci pour les tableaux vides (evite le cas particulier line_size == 0)</span>
      return ;
    }
  <span class="keywordtype">int</span> *resu_base = resu.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> *x_base = vx.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
  <span class="keywordflow">for</span> (; nblocs_left; nblocs_left--)
    {
<span class="comment">// Get index of next bloc start:</span>
      <span class="keyword">const</span> <span class="keywordtype">int</span> begin_bloc = (*(bloc_ptr++)) * line_size;
      <span class="keyword">const</span> <span class="keywordtype">int</span> end_bloc = (*(bloc_ptr++)) * line_size;
      assert(begin_bloc &gt;= 0 &amp;&amp; end_bloc &lt;= vect_size_tot &amp;&amp; end_bloc &gt;= begin_bloc);
      <span class="keywordtype">int</span>* resu_ptr = resu_base + begin_bloc;
      <span class="keyword">const</span> <span class="keywordtype">int</span>* x_ptr = x_base + begin_bloc;
      <span class="keywordtype">int</span> count = end_bloc - begin_bloc;
      <span class="keywordflow">for</span> (; count; count--)
        {
          <span class="keyword">const</span> <span class="keywordtype">int</span> x = *x_ptr;
          <span class="keywordtype">int</span>&amp; p_resu = *(resu_ptr++);
          p_resu = x;
          x_ptr++;
        }
    }
<span class="comment">// In debug mode, put invalid values where data has not been computed</span>
<span class="preprocessor">#ifndef NDEBUG</span>
<span class="preprocessor"></span>  <a class="code" href="IntVect_8cpp.html#a27f59c580905a55953c9aa2734a1fc73">invalidate_data</a>(resu,  opt);
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>  return ;
}
</pre></div>
</div>
</div>
<a class="anchor" id="afd42ad14b013f889cbd1fbd8938f8ed8"></a><!-- doxytag: member="IntVect.cpp::operator_multiply" ref="afd42ad14b013f889cbd1fbd8938f8ed8" args="(IntVect &amp;resu, const int x, Mp_vect_options opt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operator_multiply </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classIntVect.html">IntVect</a> &amp;&#160;</td>
          <td class="paramname"><em>resu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a>&#160;</td>
          <td class="paramname"><em>opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="IntVect_8cpp_source.html#l01288">1288</a> of file <a class="el" href="IntVect_8cpp_source.html">IntVect.cpp</a>.</p>

<p>References <a class="el" href="ArrOfInt_8h_source.html#l00371">ArrOfInt::addr()</a>, <a class="el" href="classMD__Vector__base.html#a99334ac2566d9457c8d4890ba20883ea">MD_Vector_base::get_items_to_compute()</a>, <a class="el" href="classMD__Vector__base.html#a7f6b6d0b7babfec0cce590cdea5bca53">MD_Vector_base::get_items_to_sum()</a>, <a class="el" href="IntVect_8h_source.html#l00087">IntVect::get_md_vector()</a>, <a class="el" href="IntVect_8cpp_source.html#l00367">invalidate_data()</a>, <a class="el" href="IntVect_8h_source.html#l00150">IntVect::line_size()</a>, <a class="el" href="MD__Vector_8h_source.html#l00063">MD_Vector::non_nul()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00342">ArrOfInt::size_array()</a>, <a class="el" href="IntVect_8h_source.html#l00145">IntVect::size_totale()</a>, <a class="el" href="MD__Vector_8h_source.html#l00067">MD_Vector::valeur()</a>, <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_ALL_ITEMS</a>, <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_REAL_ITEMS</a>, and <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_SEQUENTIAL_ITEMS</a>.</p>
<div class="fragment"><pre class="fragment">{

<span class="comment">// Master vect donne la structure de reference, les autres vecteurs</span>
<span class="comment">// doivent avoir la meme structure.</span>
  <span class="keyword">const</span> <a class="code" href="classIntVect.html">IntVect</a>&amp; master_vect = resu;
  <span class="keywordtype">int</span> line_size = master_vect.<a class="code" href="classIntVect.html#a5ba680066169c8e057bb3e3b876e4a8c">line_size</a>();
  <span class="keyword">const</span> <a class="code" href="classMD__Vector.html" title=": Cette classe est un DERIV mais l&#39;objet pointe est partage entre plusieurs instances de cette classe...">MD_Vector</a>&amp; md = master_vect.<a class="code" href="classIntVect.html#ae74e1fee6aca124d32718267e33a40c6">get_md_vector</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> vect_size_tot = master_vect.<a class="code" href="classIntVect.html#afa716e1f0a1f0f74f4f73e95b5651412" title="Identique a size_array()">size_totale</a>();
<span class="comment">// Determine blocs of data to process, depending on &quot; opt&quot;</span>
  <span class="keywordtype">int</span> nblocs_left = 1;
  <span class="keywordtype">int</span> one_bloc[2];
  <span class="keyword">const</span> <span class="keywordtype">int</span> *bloc_ptr;
  <span class="keywordflow">if</span> ( opt != <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caad18680091a9f62247573cb3caa6450b9">VECT_ALL_ITEMS</a> &amp;&amp; md.<a class="code" href="classMD__Vector.html#a4165c00904b7096274e38fdc7ca340f4">non_nul</a>())
    {
      assert( opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a> ||  opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caab47906d8d2e6c20f8ba32e4acb6edbe0">VECT_REAL_ITEMS</a>);
      <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; items_blocs = ( opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a>) ? md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a7f6b6d0b7babfec0cce590cdea5bca53">get_items_to_sum</a>() : md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a99334ac2566d9457c8d4890ba20883ea">get_items_to_compute</a>();
      assert(items_blocs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() % 2 == 0);
      nblocs_left = items_blocs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() &gt;&gt; 1;
      bloc_ptr = items_blocs.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
    }
  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (vect_size_tot &gt; 0)
    {
<span class="comment">// attention, si vect_size_tot est nul, line_size a le droit d&#39;etre nul</span>
<span class="comment">// Compute all data, in the vector (including virtual data), build a big bloc:</span>
      nblocs_left = 1;
      bloc_ptr = one_bloc;
      one_bloc[0] = 0;
      one_bloc[1] = vect_size_tot / line_size;
    }
  <span class="keywordflow">else</span>
    {
<span class="comment">// raccourci pour les tableaux vides (evite le cas particulier line_size == 0)</span>
      return ;
    }
  <span class="keywordtype">int</span> *resu_base = resu.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
  <span class="keywordflow">for</span> (; nblocs_left; nblocs_left--)
    {
<span class="comment">// Get index of next bloc start:</span>
      <span class="keyword">const</span> <span class="keywordtype">int</span> begin_bloc = (*(bloc_ptr++)) * line_size;
      <span class="keyword">const</span> <span class="keywordtype">int</span> end_bloc = (*(bloc_ptr++)) * line_size;
      assert(begin_bloc &gt;= 0 &amp;&amp; end_bloc &lt;= vect_size_tot &amp;&amp; end_bloc &gt;= begin_bloc);
      <span class="keywordtype">int</span>* resu_ptr = resu_base + begin_bloc;
      <span class="keywordtype">int</span> count = end_bloc - begin_bloc;
      <span class="keywordflow">for</span> (; count; count--)
        {
          <span class="keywordtype">int</span>&amp; p_resu = *(resu_ptr++);
          p_resu *= x;
        }
    }
<span class="comment">// In debug mode, put invalid values where data has not been computed</span>
<span class="preprocessor">#ifndef NDEBUG</span>
<span class="preprocessor"></span>  <a class="code" href="IntVect_8cpp.html#a27f59c580905a55953c9aa2734a1fc73">invalidate_data</a>(resu,  opt);
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>  return ;
}
</pre></div>
</div>
</div>
<a class="anchor" id="abe3fa2147bc123ba67a00607d6a69625"></a><!-- doxytag: member="IntVect.cpp::operator_multiply" ref="abe3fa2147bc123ba67a00607d6a69625" args="(IntVect &amp;resu, const IntVect &amp;vx, Mp_vect_options opt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operator_multiply </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classIntVect.html">IntVect</a> &amp;&#160;</td>
          <td class="paramname"><em>resu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIntVect.html">IntVect</a> &amp;&#160;</td>
          <td class="paramname"><em>vx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a>&#160;</td>
          <td class="paramname"><em>opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>&lt; this test is necessary if md is null </p>
</p>

<p>Definition at line <a class="el" href="IntVect_8cpp_source.html#l01225">1225</a> of file <a class="el" href="IntVect_8cpp_source.html">IntVect.cpp</a>.</p>

<p>References <a class="el" href="ArrOfInt_8h_source.html#l00371">ArrOfInt::addr()</a>, <a class="el" href="classMD__Vector__base.html#a99334ac2566d9457c8d4890ba20883ea">MD_Vector_base::get_items_to_compute()</a>, <a class="el" href="classMD__Vector__base.html#a7f6b6d0b7babfec0cce590cdea5bca53">MD_Vector_base::get_items_to_sum()</a>, <a class="el" href="IntVect_8h_source.html#l00087">IntVect::get_md_vector()</a>, <a class="el" href="IntVect_8cpp_source.html#l00367">invalidate_data()</a>, <a class="el" href="IntVect_8h_source.html#l00150">IntVect::line_size()</a>, <a class="el" href="MD__Vector_8h_source.html#l00063">MD_Vector::non_nul()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00342">ArrOfInt::size_array()</a>, <a class="el" href="IntVect_8h_source.html#l00145">IntVect::size_totale()</a>, <a class="el" href="MD__Vector_8h_source.html#l00067">MD_Vector::valeur()</a>, <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_ALL_ITEMS</a>, <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_REAL_ITEMS</a>, and <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_SEQUENTIAL_ITEMS</a>.</p>
<div class="fragment"><pre class="fragment">{

<span class="comment">// Master vect donne la structure de reference, les autres vecteurs</span>
<span class="comment">// doivent avoir la meme structure.</span>
  <span class="keyword">const</span> <a class="code" href="classIntVect.html">IntVect</a>&amp; master_vect = resu;
  <span class="keywordtype">int</span> line_size = master_vect.<a class="code" href="classIntVect.html#a5ba680066169c8e057bb3e3b876e4a8c">line_size</a>();
  <span class="keyword">const</span> <a class="code" href="classMD__Vector.html" title=": Cette classe est un DERIV mais l&#39;objet pointe est partage entre plusieurs instances de cette classe...">MD_Vector</a>&amp; md = master_vect.<a class="code" href="classIntVect.html#ae74e1fee6aca124d32718267e33a40c6">get_md_vector</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> vect_size_tot = master_vect.<a class="code" href="classIntVect.html#afa716e1f0a1f0f74f4f73e95b5651412" title="Identique a size_array()">size_totale</a>();
  assert(vx.<a class="code" href="classIntVect.html#a5ba680066169c8e057bb3e3b876e4a8c">line_size</a>() == line_size);
  assert(vx.<a class="code" href="classIntVect.html#afa716e1f0a1f0f74f4f73e95b5651412" title="Identique a size_array()">size_totale</a>() == vect_size_tot); <span class="comment">//!&lt; this test is necessary if md is null</span>
<span class="comment"></span>  assert(vx.<a class="code" href="classIntVect.html#ae74e1fee6aca124d32718267e33a40c6">get_md_vector</a>() == md);
<span class="comment">// Determine blocs of data to process, depending on &quot; opt&quot;</span>
  <span class="keywordtype">int</span> nblocs_left = 1;
  <span class="keywordtype">int</span> one_bloc[2];
  <span class="keyword">const</span> <span class="keywordtype">int</span> *bloc_ptr;
  <span class="keywordflow">if</span> ( opt != <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caad18680091a9f62247573cb3caa6450b9">VECT_ALL_ITEMS</a> &amp;&amp; md.<a class="code" href="classMD__Vector.html#a4165c00904b7096274e38fdc7ca340f4">non_nul</a>())
    {
      assert( opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a> ||  opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caab47906d8d2e6c20f8ba32e4acb6edbe0">VECT_REAL_ITEMS</a>);
      <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; items_blocs = ( opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a>) ? md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a7f6b6d0b7babfec0cce590cdea5bca53">get_items_to_sum</a>() : md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a99334ac2566d9457c8d4890ba20883ea">get_items_to_compute</a>();
      assert(items_blocs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() % 2 == 0);
      nblocs_left = items_blocs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() &gt;&gt; 1;
      bloc_ptr = items_blocs.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
    }
  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (vect_size_tot &gt; 0)
    {
<span class="comment">// attention, si vect_size_tot est nul, line_size a le droit d&#39;etre nul</span>
<span class="comment">// Compute all data, in the vector (including virtual data), build a big bloc:</span>
      nblocs_left = 1;
      bloc_ptr = one_bloc;
      one_bloc[0] = 0;
      one_bloc[1] = vect_size_tot / line_size;
    }
  <span class="keywordflow">else</span>
    {
<span class="comment">// raccourci pour les tableaux vides (evite le cas particulier line_size == 0)</span>
      return ;
    }
  <span class="keywordtype">int</span> *resu_base = resu.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> *x_base = vx.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
  <span class="keywordflow">for</span> (; nblocs_left; nblocs_left--)
    {
<span class="comment">// Get index of next bloc start:</span>
      <span class="keyword">const</span> <span class="keywordtype">int</span> begin_bloc = (*(bloc_ptr++)) * line_size;
      <span class="keyword">const</span> <span class="keywordtype">int</span> end_bloc = (*(bloc_ptr++)) * line_size;
      assert(begin_bloc &gt;= 0 &amp;&amp; end_bloc &lt;= vect_size_tot &amp;&amp; end_bloc &gt;= begin_bloc);
      <span class="keywordtype">int</span>* resu_ptr = resu_base + begin_bloc;
      <span class="keyword">const</span> <span class="keywordtype">int</span>* x_ptr = x_base + begin_bloc;
      <span class="keywordtype">int</span> count = end_bloc - begin_bloc;
      <span class="keywordflow">for</span> (; count; count--)
        {
          <span class="keyword">const</span> <span class="keywordtype">int</span> x = *x_ptr;
          <span class="keywordtype">int</span>&amp; p_resu = *(resu_ptr++);
          p_resu *= x;
          x_ptr++;
        }
    }
<span class="comment">// In debug mode, put invalid values where data has not been computed</span>
<span class="preprocessor">#ifndef NDEBUG</span>
<span class="preprocessor"></span>  <a class="code" href="IntVect_8cpp.html#a27f59c580905a55953c9aa2734a1fc73">invalidate_data</a>(resu,  opt);
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>  return ;
}
</pre></div>
</div>
</div>
<a class="anchor" id="af2456449b8237b76d4b371c9de1e4af2"></a><!-- doxytag: member="IntVect.cpp::operator_negate" ref="af2456449b8237b76d4b371c9de1e4af2" args="(IntVect &amp;resu, Mp_vect_options opt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operator_negate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classIntVect.html">IntVect</a> &amp;&#160;</td>
          <td class="paramname"><em>resu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a>&#160;</td>
          <td class="paramname"><em>opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="IntVect_8cpp_source.html#l01344">1344</a> of file <a class="el" href="IntVect_8cpp_source.html">IntVect.cpp</a>.</p>

<p>References <a class="el" href="ArrOfInt_8h_source.html#l00371">ArrOfInt::addr()</a>, <a class="el" href="classMD__Vector__base.html#a99334ac2566d9457c8d4890ba20883ea">MD_Vector_base::get_items_to_compute()</a>, <a class="el" href="classMD__Vector__base.html#a7f6b6d0b7babfec0cce590cdea5bca53">MD_Vector_base::get_items_to_sum()</a>, <a class="el" href="IntVect_8h_source.html#l00087">IntVect::get_md_vector()</a>, <a class="el" href="IntVect_8cpp_source.html#l00367">invalidate_data()</a>, <a class="el" href="IntVect_8h_source.html#l00150">IntVect::line_size()</a>, <a class="el" href="MD__Vector_8h_source.html#l00063">MD_Vector::non_nul()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00342">ArrOfInt::size_array()</a>, <a class="el" href="IntVect_8h_source.html#l00145">IntVect::size_totale()</a>, <a class="el" href="MD__Vector_8h_source.html#l00067">MD_Vector::valeur()</a>, <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_ALL_ITEMS</a>, <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_REAL_ITEMS</a>, and <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_SEQUENTIAL_ITEMS</a>.</p>
<div class="fragment"><pre class="fragment">{

<span class="comment">// Master vect donne la structure de reference, les autres vecteurs</span>
<span class="comment">// doivent avoir la meme structure.</span>
  <span class="keyword">const</span> <a class="code" href="classIntVect.html">IntVect</a>&amp; master_vect = resu;
  <span class="keywordtype">int</span> line_size = master_vect.<a class="code" href="classIntVect.html#a5ba680066169c8e057bb3e3b876e4a8c">line_size</a>();
  <span class="keyword">const</span> <a class="code" href="classMD__Vector.html" title=": Cette classe est un DERIV mais l&#39;objet pointe est partage entre plusieurs instances de cette classe...">MD_Vector</a>&amp; md = master_vect.<a class="code" href="classIntVect.html#ae74e1fee6aca124d32718267e33a40c6">get_md_vector</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> vect_size_tot = master_vect.<a class="code" href="classIntVect.html#afa716e1f0a1f0f74f4f73e95b5651412" title="Identique a size_array()">size_totale</a>();
<span class="comment">// Determine blocs of data to process, depending on &quot; opt&quot;</span>
  <span class="keywordtype">int</span> nblocs_left = 1;
  <span class="keywordtype">int</span> one_bloc[2];
  <span class="keyword">const</span> <span class="keywordtype">int</span> *bloc_ptr;
  <span class="keywordflow">if</span> ( opt != <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caad18680091a9f62247573cb3caa6450b9">VECT_ALL_ITEMS</a> &amp;&amp; md.<a class="code" href="classMD__Vector.html#a4165c00904b7096274e38fdc7ca340f4">non_nul</a>())
    {
      assert( opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a> ||  opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caab47906d8d2e6c20f8ba32e4acb6edbe0">VECT_REAL_ITEMS</a>);
      <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; items_blocs = ( opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a>) ? md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a7f6b6d0b7babfec0cce590cdea5bca53">get_items_to_sum</a>() : md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a99334ac2566d9457c8d4890ba20883ea">get_items_to_compute</a>();
      assert(items_blocs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() % 2 == 0);
      nblocs_left = items_blocs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() &gt;&gt; 1;
      bloc_ptr = items_blocs.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
    }
  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (vect_size_tot &gt; 0)
    {
<span class="comment">// attention, si vect_size_tot est nul, line_size a le droit d&#39;etre nul</span>
<span class="comment">// Compute all data, in the vector (including virtual data), build a big bloc:</span>
      nblocs_left = 1;
      bloc_ptr = one_bloc;
      one_bloc[0] = 0;
      one_bloc[1] = vect_size_tot / line_size;
    }
  <span class="keywordflow">else</span>
    {
<span class="comment">// raccourci pour les tableaux vides (evite le cas particulier line_size == 0)</span>
      return ;
    }
  <span class="keywordtype">int</span> *resu_base = resu.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
  <span class="keywordflow">for</span> (; nblocs_left; nblocs_left--)
    {
<span class="comment">// Get index of next bloc start:</span>
      <span class="keyword">const</span> <span class="keywordtype">int</span> begin_bloc = (*(bloc_ptr++)) * line_size;
      <span class="keyword">const</span> <span class="keywordtype">int</span> end_bloc = (*(bloc_ptr++)) * line_size;
      assert(begin_bloc &gt;= 0 &amp;&amp; end_bloc &lt;= vect_size_tot &amp;&amp; end_bloc &gt;= begin_bloc);
      <span class="keywordtype">int</span>* resu_ptr = resu_base + begin_bloc;
      <span class="keywordtype">int</span> count = end_bloc - begin_bloc;
      <span class="keywordflow">for</span> (; count; count--)
        {
          <span class="keywordtype">int</span>&amp; p_resu = *(resu_ptr++);
          p_resu = -p_resu;
        }
    }
<span class="comment">// In debug mode, put invalid values where data has not been computed</span>
<span class="preprocessor">#ifndef NDEBUG</span>
<span class="preprocessor"></span>  <a class="code" href="IntVect_8cpp.html#a27f59c580905a55953c9aa2734a1fc73">invalidate_data</a>(resu,  opt);
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>  return ;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a6c45faa85a0bdc6bd991b1829f046966"></a><!-- doxytag: member="IntVect.cpp::operator_sub" ref="a6c45faa85a0bdc6bd991b1829f046966" args="(IntVect &amp;resu, const int x, Mp_vect_options opt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operator_sub </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classIntVect.html">IntVect</a> &amp;&#160;</td>
          <td class="paramname"><em>resu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a>&#160;</td>
          <td class="paramname"><em>opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="IntVect_8cpp_source.html#l01169">1169</a> of file <a class="el" href="IntVect_8cpp_source.html">IntVect.cpp</a>.</p>

<p>References <a class="el" href="ArrOfInt_8h_source.html#l00371">ArrOfInt::addr()</a>, <a class="el" href="classMD__Vector__base.html#a99334ac2566d9457c8d4890ba20883ea">MD_Vector_base::get_items_to_compute()</a>, <a class="el" href="classMD__Vector__base.html#a7f6b6d0b7babfec0cce590cdea5bca53">MD_Vector_base::get_items_to_sum()</a>, <a class="el" href="IntVect_8h_source.html#l00087">IntVect::get_md_vector()</a>, <a class="el" href="IntVect_8cpp_source.html#l00367">invalidate_data()</a>, <a class="el" href="IntVect_8h_source.html#l00150">IntVect::line_size()</a>, <a class="el" href="MD__Vector_8h_source.html#l00063">MD_Vector::non_nul()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00342">ArrOfInt::size_array()</a>, <a class="el" href="IntVect_8h_source.html#l00145">IntVect::size_totale()</a>, <a class="el" href="MD__Vector_8h_source.html#l00067">MD_Vector::valeur()</a>, <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_ALL_ITEMS</a>, <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_REAL_ITEMS</a>, and <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_SEQUENTIAL_ITEMS</a>.</p>
<div class="fragment"><pre class="fragment">{

<span class="comment">// Master vect donne la structure de reference, les autres vecteurs</span>
<span class="comment">// doivent avoir la meme structure.</span>
  <span class="keyword">const</span> <a class="code" href="classIntVect.html">IntVect</a>&amp; master_vect = resu;
  <span class="keywordtype">int</span> line_size = master_vect.<a class="code" href="classIntVect.html#a5ba680066169c8e057bb3e3b876e4a8c">line_size</a>();
  <span class="keyword">const</span> <a class="code" href="classMD__Vector.html" title=": Cette classe est un DERIV mais l&#39;objet pointe est partage entre plusieurs instances de cette classe...">MD_Vector</a>&amp; md = master_vect.<a class="code" href="classIntVect.html#ae74e1fee6aca124d32718267e33a40c6">get_md_vector</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> vect_size_tot = master_vect.<a class="code" href="classIntVect.html#afa716e1f0a1f0f74f4f73e95b5651412" title="Identique a size_array()">size_totale</a>();
<span class="comment">// Determine blocs of data to process, depending on &quot; opt&quot;</span>
  <span class="keywordtype">int</span> nblocs_left = 1;
  <span class="keywordtype">int</span> one_bloc[2];
  <span class="keyword">const</span> <span class="keywordtype">int</span> *bloc_ptr;
  <span class="keywordflow">if</span> ( opt != <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caad18680091a9f62247573cb3caa6450b9">VECT_ALL_ITEMS</a> &amp;&amp; md.<a class="code" href="classMD__Vector.html#a4165c00904b7096274e38fdc7ca340f4">non_nul</a>())
    {
      assert( opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a> ||  opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caab47906d8d2e6c20f8ba32e4acb6edbe0">VECT_REAL_ITEMS</a>);
      <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; items_blocs = ( opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a>) ? md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a7f6b6d0b7babfec0cce590cdea5bca53">get_items_to_sum</a>() : md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a99334ac2566d9457c8d4890ba20883ea">get_items_to_compute</a>();
      assert(items_blocs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() % 2 == 0);
      nblocs_left = items_blocs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() &gt;&gt; 1;
      bloc_ptr = items_blocs.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
    }
  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (vect_size_tot &gt; 0)
    {
<span class="comment">// attention, si vect_size_tot est nul, line_size a le droit d&#39;etre nul</span>
<span class="comment">// Compute all data, in the vector (including virtual data), build a big bloc:</span>
      nblocs_left = 1;
      bloc_ptr = one_bloc;
      one_bloc[0] = 0;
      one_bloc[1] = vect_size_tot / line_size;
    }
  <span class="keywordflow">else</span>
    {
<span class="comment">// raccourci pour les tableaux vides (evite le cas particulier line_size == 0)</span>
      return ;
    }
  <span class="keywordtype">int</span> *resu_base = resu.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
  <span class="keywordflow">for</span> (; nblocs_left; nblocs_left--)
    {
<span class="comment">// Get index of next bloc start:</span>
      <span class="keyword">const</span> <span class="keywordtype">int</span> begin_bloc = (*(bloc_ptr++)) * line_size;
      <span class="keyword">const</span> <span class="keywordtype">int</span> end_bloc = (*(bloc_ptr++)) * line_size;
      assert(begin_bloc &gt;= 0 &amp;&amp; end_bloc &lt;= vect_size_tot &amp;&amp; end_bloc &gt;= begin_bloc);
      <span class="keywordtype">int</span>* resu_ptr = resu_base + begin_bloc;
      <span class="keywordtype">int</span> count = end_bloc - begin_bloc;
      <span class="keywordflow">for</span> (; count; count--)
        {
          <span class="keywordtype">int</span>&amp; p_resu = *(resu_ptr++);
          p_resu -= x;
        }
    }
<span class="comment">// In debug mode, put invalid values where data has not been computed</span>
<span class="preprocessor">#ifndef NDEBUG</span>
<span class="preprocessor"></span>  <a class="code" href="IntVect_8cpp.html#a27f59c580905a55953c9aa2734a1fc73">invalidate_data</a>(resu,  opt);
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>  return ;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a9dc30ad5fe3fcd14ea3e0420d395fb9e"></a><!-- doxytag: member="IntVect.cpp::operator_sub" ref="a9dc30ad5fe3fcd14ea3e0420d395fb9e" args="(IntVect &amp;resu, const IntVect &amp;vx, Mp_vect_options opt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operator_sub </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classIntVect.html">IntVect</a> &amp;&#160;</td>
          <td class="paramname"><em>resu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIntVect.html">IntVect</a> &amp;&#160;</td>
          <td class="paramname"><em>vx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a>&#160;</td>
          <td class="paramname"><em>opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>&lt; this test is necessary if md is null </p>
</p>

<p>Definition at line <a class="el" href="IntVect_8cpp_source.html#l01106">1106</a> of file <a class="el" href="IntVect_8cpp_source.html">IntVect.cpp</a>.</p>

<p>References <a class="el" href="ArrOfInt_8h_source.html#l00371">ArrOfInt::addr()</a>, <a class="el" href="classMD__Vector__base.html#a99334ac2566d9457c8d4890ba20883ea">MD_Vector_base::get_items_to_compute()</a>, <a class="el" href="classMD__Vector__base.html#a7f6b6d0b7babfec0cce590cdea5bca53">MD_Vector_base::get_items_to_sum()</a>, <a class="el" href="IntVect_8h_source.html#l00087">IntVect::get_md_vector()</a>, <a class="el" href="IntVect_8cpp_source.html#l00367">invalidate_data()</a>, <a class="el" href="IntVect_8h_source.html#l00150">IntVect::line_size()</a>, <a class="el" href="MD__Vector_8h_source.html#l00063">MD_Vector::non_nul()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00342">ArrOfInt::size_array()</a>, <a class="el" href="IntVect_8h_source.html#l00145">IntVect::size_totale()</a>, <a class="el" href="MD__Vector_8h_source.html#l00067">MD_Vector::valeur()</a>, <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_ALL_ITEMS</a>, <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_REAL_ITEMS</a>, and <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_SEQUENTIAL_ITEMS</a>.</p>
<div class="fragment"><pre class="fragment">{

<span class="comment">// Master vect donne la structure de reference, les autres vecteurs</span>
<span class="comment">// doivent avoir la meme structure.</span>
  <span class="keyword">const</span> <a class="code" href="classIntVect.html">IntVect</a>&amp; master_vect = resu;
  <span class="keywordtype">int</span> line_size = master_vect.<a class="code" href="classIntVect.html#a5ba680066169c8e057bb3e3b876e4a8c">line_size</a>();
  <span class="keyword">const</span> <a class="code" href="classMD__Vector.html" title=": Cette classe est un DERIV mais l&#39;objet pointe est partage entre plusieurs instances de cette classe...">MD_Vector</a>&amp; md = master_vect.<a class="code" href="classIntVect.html#ae74e1fee6aca124d32718267e33a40c6">get_md_vector</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> vect_size_tot = master_vect.<a class="code" href="classIntVect.html#afa716e1f0a1f0f74f4f73e95b5651412" title="Identique a size_array()">size_totale</a>();
  assert(vx.<a class="code" href="classIntVect.html#a5ba680066169c8e057bb3e3b876e4a8c">line_size</a>() == line_size);
  assert(vx.<a class="code" href="classIntVect.html#afa716e1f0a1f0f74f4f73e95b5651412" title="Identique a size_array()">size_totale</a>() == vect_size_tot); <span class="comment">//!&lt; this test is necessary if md is null</span>
<span class="comment"></span>  assert(vx.<a class="code" href="classIntVect.html#ae74e1fee6aca124d32718267e33a40c6">get_md_vector</a>() == md);
<span class="comment">// Determine blocs of data to process, depending on &quot; opt&quot;</span>
  <span class="keywordtype">int</span> nblocs_left = 1;
  <span class="keywordtype">int</span> one_bloc[2];
  <span class="keyword">const</span> <span class="keywordtype">int</span> *bloc_ptr;
  <span class="keywordflow">if</span> ( opt != <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caad18680091a9f62247573cb3caa6450b9">VECT_ALL_ITEMS</a> &amp;&amp; md.<a class="code" href="classMD__Vector.html#a4165c00904b7096274e38fdc7ca340f4">non_nul</a>())
    {
      assert( opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a> ||  opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caab47906d8d2e6c20f8ba32e4acb6edbe0">VECT_REAL_ITEMS</a>);
      <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; items_blocs = ( opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a>) ? md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a7f6b6d0b7babfec0cce590cdea5bca53">get_items_to_sum</a>() : md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a99334ac2566d9457c8d4890ba20883ea">get_items_to_compute</a>();
      assert(items_blocs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() % 2 == 0);
      nblocs_left = items_blocs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() &gt;&gt; 1;
      bloc_ptr = items_blocs.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
    }
  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (vect_size_tot &gt; 0)
    {
<span class="comment">// attention, si vect_size_tot est nul, line_size a le droit d&#39;etre nul</span>
<span class="comment">// Compute all data, in the vector (including virtual data), build a big bloc:</span>
      nblocs_left = 1;
      bloc_ptr = one_bloc;
      one_bloc[0] = 0;
      one_bloc[1] = vect_size_tot / line_size;
    }
  <span class="keywordflow">else</span>
    {
<span class="comment">// raccourci pour les tableaux vides (evite le cas particulier line_size == 0)</span>
      return ;
    }
  <span class="keywordtype">int</span> *resu_base = resu.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> *x_base = vx.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
  <span class="keywordflow">for</span> (; nblocs_left; nblocs_left--)
    {
<span class="comment">// Get index of next bloc start:</span>
      <span class="keyword">const</span> <span class="keywordtype">int</span> begin_bloc = (*(bloc_ptr++)) * line_size;
      <span class="keyword">const</span> <span class="keywordtype">int</span> end_bloc = (*(bloc_ptr++)) * line_size;
      assert(begin_bloc &gt;= 0 &amp;&amp; end_bloc &lt;= vect_size_tot &amp;&amp; end_bloc &gt;= begin_bloc);
      <span class="keywordtype">int</span>* resu_ptr = resu_base + begin_bloc;
      <span class="keyword">const</span> <span class="keywordtype">int</span>* x_ptr = x_base + begin_bloc;
      <span class="keywordtype">int</span> count = end_bloc - begin_bloc;
      <span class="keywordflow">for</span> (; count; count--)
        {
          <span class="keyword">const</span> <span class="keywordtype">int</span> x = *x_ptr;
          <span class="keywordtype">int</span>&amp; p_resu = *(resu_ptr++);
          p_resu -= x;
          x_ptr++;
        }
    }
<span class="comment">// In debug mode, put invalid values where data has not been computed</span>
<span class="preprocessor">#ifndef NDEBUG</span>
<span class="preprocessor"></span>  <a class="code" href="IntVect_8cpp.html#a27f59c580905a55953c9aa2734a1fc73">invalidate_data</a>(resu,  opt);
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>  return ;
}
</pre></div>
</div>
</div>
<hr/><h2>Variable Documentation</h2>
<a class="anchor" id="a26d5958ec73b0ea0949cfa0ea08cfbcc"></a><!-- doxytag: member="IntVect.cpp::IntVectbases" ref="a26d5958ec73b0ea0949cfa0ea08cfbcc" args="[1]" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classType__info.html">Type_info</a>* <a class="el" href="IntVect_8cpp.html#a26d5958ec73b0ea0949cfa0ea08cfbcc">IntVectbases</a>[1] = { &amp;( <a class="el" href="classArrOfInt.html">ArrOfInt</a> ::info_obj)}</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="IntVect_8cpp_source.html#l00038">38</a> of file <a class="el" href="IntVect_8cpp_source.html">IntVect.cpp</a>.</p>

</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Tue Dec 14 2021 19:35:52 for TRUST by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
