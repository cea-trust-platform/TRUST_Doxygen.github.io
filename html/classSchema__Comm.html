<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>TRUST: Schema_Comm Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">TRUST&#160;<span id="projectnumber">1.8.4</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-types">Protected Types</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-static-methods">Static Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pro-static-attribs">Static Protected Attributes</a> &#124;
<a href="#pri-static-attribs">Static Private Attributes</a>  </div>
  <div class="headertitle">
<div class="title">Schema_Comm Class Reference</div>  </div>
</div>
<div class="contents">
<!-- doxytag: class="Schema_Comm" -->
<p><code>#include &lt;<a class="el" href="Schema__Comm_8h_source.html">Schema_Comm.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Schema_Comm:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classSchema__Comm.png" usemap="#Schema_Comm_map" alt=""/>
  <map id="Schema_Comm_map" name="Schema_Comm_map">
<area href="classSchema__Comm__statique.html" alt="Schema_Comm_statique" shape="rect" coords="0,56,147,80"/>
</map>
 </div></div>

<p><a href="classSchema__Comm-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSchema__Comm.html#af2b4707c7ffae5a98fae11d6bf185d05">Schema_Comm</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Construction d'un nouveau schema de communication.  <a href="#af2b4707c7ffae5a98fae11d6bf185d05"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSchema__Comm.html#a8f7a71ce2536bf4b3fc52f77862fa01d">Schema_Comm</a> (const <a class="el" href="classSchema__Comm.html">Schema_Comm</a> &amp;)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructeur par copie (nouveau schema place en mode RESET).<br/>
Attention : tous les membres du <a class="el" href="classComm__Group.html" title=": Cette classe decrit un groupe de processeurs sur lesquels une portion de code s&#39;execute simultaneme...">Comm_Group</a> doivent executer<br/>
cette fonction simultanement.  <a href="#a8f7a71ce2536bf4b3fc52f77862fa01d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSchema__Comm.html#a5b8b9f4946cb1de5edad0721561c43f8">~Schema_Comm</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Destruction d'un schema de communication.  <a href="#a5b8b9f4946cb1de5edad0721561c43f8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSchema__Comm.html#a46dd131a48e83d289e078f163e7f5c9d">set_group</a> (const <a class="el" href="classComm__Group.html">Comm_Group</a> &amp;group)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Obsolete.  <a href="#a46dd131a48e83d289e078f163e7f5c9d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classComm__Group.html">Comm_Group</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSchema__Comm.html#af18c96784f01b84237cae0327a175fcf">get_group</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Renvoie le groupe auquel est associe le schema.  <a href="#af18c96784f01b84237cae0327a175fcf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSchema__Comm.html">Schema_Comm</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSchema__Comm.html#a0963ab78f7c26d5fb8e25b1a657ea414">operator=</a> (const <a class="el" href="classSchema__Comm.html">Schema_Comm</a> &amp;)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classOperateur.html" title="classe Operateur Classe generique de la hierarchie des operateurs. Cette classe generique est particu...">Operateur</a> copie : on copie la liste des processeurs qui<br/>
communiquent. Le nouveau schema est place dans l'etat RESET.<br/>
Attention : tous les membres du <a class="el" href="classComm__Group.html" title=": Cette classe decrit un groupe de processeurs sur lesquels une portion de code s&#39;execute simultaneme...">Comm_Group</a> doivent executer<br/>
cette fonction simultanement.  <a href="#a0963ab78f7c26d5fb8e25b1a657ea414"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSchema__Comm.html#ad11c9b47999c294c26ae4df8d2bbd57b">set_send_recv_pe_list</a> (const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;send_pe_list, const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;recv_pe_list, const int me_to_me=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Definit la liste des processeurs a qui on va envoyer<br/>
et de qui on va recevoir des donnees.<br/>
Si me_to_me est non nul, on autorise l'envoi des messages a soi-meme,<br/>
sinon non (argument optionnel : par defaut, me_to_me=0)  <a href="#ad11c9b47999c294c26ae4df8d2bbd57b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSchema__Comm.html#ac617b53de22748cdd9fa30a0cfd0f4a8">begin_comm</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Statut passe a WRITING Autorise si status_ == WRITING:  <a href="#ac617b53de22748cdd9fa30a0cfd0f4a8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSortie.html">Sortie</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSchema__Comm.html#a6c771eae3b46250ae0d2f0126a7d8065">send_buffer</a> (int num_PE) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">renvoie le buffer correspondant au processeur num_PE pour<br/>
y entasser des donnees a envoyer. Le schema doit etre dans l'etat WRITING.  <a href="#a6c771eae3b46250ae0d2f0126a7d8065"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSchema__Comm.html#abca0e8ac6c2b742d26f3cfaee0690c72">echange_taille_et_messages</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Statut passe a EXCHANGED.  <a href="#abca0e8ac6c2b742d26f3cfaee0690c72"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSchema__Comm.html#ae33a0b666e564e5f9996e2e39ebba7e1">echange_messages</a> (const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;recv_size) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Statut passe a EXCHANGED Autorise si status_ == EXCHANGED:  <a href="#ae33a0b666e564e5f9996e2e39ebba7e1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEntree.html">Entree</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSchema__Comm.html#a0c056eb81ab8fd513912b336b4d13a1a">recv_buffer</a> (int num_PE) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">renvoie le buffer correspondant au processeur num_PE pour<br/>
y lire les donnees recues. Le schema doit etre dans l'etat EXCHANGED.  <a href="#a0c056eb81ab8fd513912b336b4d13a1a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSchema__Comm.html#a73a981f88b6ffebc150fb46c5cce75d9">end_comm</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Statut passe a RESET Accesseurs:  <a href="#a73a981f88b6ffebc150fb46c5cce75d9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSchema__Comm.html#ad726332731df9b745cb6df8e1919d82a">get_send_pe_list</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSchema__Comm.html#abfde4d298c654f11891abfc3120be8fd">get_recv_pe_list</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSchema__Comm.html#add07304686600c10515b483eef6b8a08">set_all_to_allv_flag</a> (int x)</td></tr>
<tr><td colspan="2"><h2><a name="pro-types"></a>
Protected Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSchema__Comm.html#a513eef36a4603d995f2a04f166812470">Static_Status</a> { <a class="el" href="classSchema__Comm.html#a513eef36a4603d995f2a04f166812470ab8a8496bcb475aa3d59c4392d8fc08a9">UNINITIALIZED</a>, 
<a class="el" href="classSchema__Comm.html#a513eef36a4603d995f2a04f166812470a79ffb1835b68257288b75f8fbcb65178">RESET</a>, 
<a class="el" href="classSchema__Comm.html#a513eef36a4603d995f2a04f166812470a218bae4e3cf445666fb4c8d08d055f0d">WRITING</a>, 
<a class="el" href="classSchema__Comm.html#a513eef36a4603d995f2a04f166812470a40b4132b151da7359211aad2f3682c9f">EXCHANGED</a>
 }</td></tr>
<tr><td colspan="2"><h2><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSchema__Comm.html#a7988e23c0989bfa8a3980f16b591e41d">echange_taille</a> (const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;send_size, <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;recv_size) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Transmet la taille des messages a envoyer aux processeurs qui<br/>
vont les recevoir. La taille est le nombre de bytes des obuffers.<br/>
send_pe_list et recv_pe_list doivent etre initialises.<br/>
Le schema doit etre dans l'etat WRITING.  <a href="#a7988e23c0989bfa8a3980f16b591e41d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSchema__Comm.html#a6d7e026c5aa0af7f994aecf9d40d4079">echange_messages</a> (const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;send_size, const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;recv_size) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Cette methode lance l'echange de donnees entre tous les processeurs.<br/>
La taille des messages recus doit etre deja connue.<br/>
Le schema passe de WRITING a EXCHANGED.  <a href="#a6d7e026c5aa0af7f994aecf9d40d4079"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSchema__Comm.html#a10b238ae8ba1d3f6ed955fa7164c93ce">check_send_recv_pe_list</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Verifie que les send/recv_pe_list verifient la propriete<br/>
"tu m'ecoutes quand je te parle".  <a href="#a10b238ae8ba1d3f6ed955fa7164c93ce"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pro-static-methods"></a>
Static Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classOutputCommBuffer.html">OutputCommBuffer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSchema__Comm.html#a734080d1326e58abdc5731d1b3486d4b">obuffer</a> (int pe)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Accesseur a un membre du tableau obuffers_ (avec verification)  <a href="#a734080d1326e58abdc5731d1b3486d4b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classInputCommBuffer.html">InputCommBuffer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSchema__Comm.html#a0955c141014893e559b831ae33d55d56">ebuffer</a> (int pe)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Accesseur a un membre du tableau ebuffers_ (avec verification)  <a href="#a0955c141014893e559b831ae33d55d56"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classArrOfInt.html">ArrOfInt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSchema__Comm.html#a93eb7538476fa54ade96e88294feec8e">send_pe_list_</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Liste des processeurs a qui envoyer.  <a href="#a93eb7538476fa54ade96e88294feec8e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classArrOfInt.html">ArrOfInt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSchema__Comm.html#a24918eceb0ce15a6dae5a5a833480246">recv_pe_list_</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Liste des processeurs de qui recevoir.  <a href="#a24918eceb0ce15a6dae5a5a833480246"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSchema__Comm.html#aaa55ab78220cfcca058cf54a7ac14cc0">me_to_me_</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Drapeau: est-ce qu'on autorise a s'envoyer des messages a soi ?  <a href="#aaa55ab78220cfcca058cf54a7ac14cc0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRef__Comm__Group.html">Ref_Comm_Group</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSchema__Comm.html#adcd2cdb2d6ce76883858c8f6078fda56">ref_group_</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Groupe de processeurs qui vont discuter.  <a href="#adcd2cdb2d6ce76883858c8f6078fda56"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSchema__Comm.html#a88ddb051931c6d62f96d57ca2f79f7c1">use_all_to_allv_</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Drapeau, quel type de communication faut-il utiliser ?  <a href="#a88ddb051931c6d62f96d57ca2f79f7c1"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pro-static-attribs"></a>
Static Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSchema__Comm.html#a513eef36a4603d995f2a04f166812470">Static_Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSchema__Comm.html#ae56acaadf7a079ce874be628491593cb">status_</a> = UNINITIALIZED</td></tr>
<tr><td colspan="2"><h2><a name="pri-static-attribs"></a>
Static Private Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classInOutCommBuffers.html">InOutCommBuffers</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSchema__Comm.html#a6ce69882db45689247b677d5978d569e">buffers_</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSchema__Comm.html#ac4ab50424d6aa29ac87103aa7690e203">n_buffers_</a> = 0</td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock">
<p>Definition at line <a class="el" href="Schema__Comm_8h_source.html#l00084">84</a> of file <a class="el" href="Schema__Comm_8h_source.html">Schema_Comm.h</a>.</p>
</div><hr/><h2>Member Enumeration Documentation</h2>
<a class="anchor" id="a513eef36a4603d995f2a04f166812470"></a><!-- doxytag: member="Schema_Comm::Static_Status" ref="a513eef36a4603d995f2a04f166812470" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classSchema__Comm.html#a513eef36a4603d995f2a04f166812470">Schema_Comm::Static_Status</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a513eef36a4603d995f2a04f166812470ab8a8496bcb475aa3d59c4392d8fc08a9"></a><!-- doxytag: member="UNINITIALIZED" ref="a513eef36a4603d995f2a04f166812470ab8a8496bcb475aa3d59c4392d8fc08a9" args="" -->UNINITIALIZED</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a513eef36a4603d995f2a04f166812470a79ffb1835b68257288b75f8fbcb65178"></a><!-- doxytag: member="RESET" ref="a513eef36a4603d995f2a04f166812470a79ffb1835b68257288b75f8fbcb65178" args="" -->RESET</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a513eef36a4603d995f2a04f166812470a218bae4e3cf445666fb4c8d08d055f0d"></a><!-- doxytag: member="WRITING" ref="a513eef36a4603d995f2a04f166812470a218bae4e3cf445666fb4c8d08d055f0d" args="" -->WRITING</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a513eef36a4603d995f2a04f166812470a40b4132b151da7359211aad2f3682c9f"></a><!-- doxytag: member="EXCHANGED" ref="a513eef36a4603d995f2a04f166812470a40b4132b151da7359211aad2f3682c9f" args="" -->EXCHANGED</em>&nbsp;</td><td>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="Schema__Comm_8h_source.html#l00126">126</a> of file <a class="el" href="Schema__Comm_8h_source.html">Schema_Comm.h</a>.</p>
<div class="fragment"><pre class="fragment">{ <a class="code" href="classSchema__Comm.html#a513eef36a4603d995f2a04f166812470ab8a8496bcb475aa3d59c4392d8fc08a9">UNINITIALIZED</a>, <a class="code" href="classSchema__Comm.html#a513eef36a4603d995f2a04f166812470a79ffb1835b68257288b75f8fbcb65178">RESET</a>, <a class="code" href="classSchema__Comm.html#a513eef36a4603d995f2a04f166812470a218bae4e3cf445666fb4c8d08d055f0d">WRITING</a>, <a class="code" href="classSchema__Comm.html#a513eef36a4603d995f2a04f166812470a40b4132b151da7359211aad2f3682c9f">EXCHANGED</a> };
</pre></div>
</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="af2b4707c7ffae5a98fae11d6bf185d05"></a><!-- doxytag: member="Schema_Comm::Schema_Comm" ref="af2b4707c7ffae5a98fae11d6bf185d05" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Schema_Comm::Schema_Comm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construction d'un nouveau schema de communication. </p>

<p>Definition at line <a class="el" href="Schema__Comm_8cpp_source.html#l00063">63</a> of file <a class="el" href="Schema__Comm_8cpp_source.html">Schema_Comm.cpp</a>.</p>

<p>References <a class="el" href="Schema__Comm_8h_source.html#l00141">buffers_</a>, <a class="el" href="PE__Groups_8h_source.html#l00054">PE_Groups::current_group()</a>, <a class="el" href="InOutCommBuffers_8h_source.html#l00032">InOutCommBuffers::ebuffers_</a>, <a class="el" href="Schema__Comm_8h_source.html#l00133">me_to_me_</a>, <a class="el" href="Schema__Comm_8h_source.html#l00142">n_buffers_</a>, <a class="el" href="Process_8cpp_source.html#l00109">Process::nproc()</a>, <a class="el" href="InOutCommBuffers_8h_source.html#l00033">InOutCommBuffers::obuffers_</a>, <a class="el" href="Schema__Comm_8h_source.html#l00132">recv_pe_list_</a>, <a class="el" href="Schema__Comm_8h_source.html#l00134">ref_group_</a>, <a class="el" href="Schema__Comm_8h_source.html#l00126">RESET</a>, <a class="el" href="Schema__Comm_8h_source.html#l00131">send_pe_list_</a>, <a class="el" href="ArrOfInt_8cpp_source.html#l00443">ArrOfInt::set_smart_resize()</a>, <a class="el" href="Schema__Comm_8h_source.html#l00127">status_</a>, <a class="el" href="Schema__Comm_8h_source.html#l00126">UNINITIALIZED</a>, and <a class="el" href="Schema__Comm_8h_source.html#l00136">use_all_to_allv_</a>.</p>
<div class="fragment"><pre class="fragment">{
  <a class="code" href="classSchema__Comm.html#a93eb7538476fa54ade96e88294feec8e" title="Liste des processeurs a qui envoyer.">send_pe_list_</a>.<a class="code" href="classArrOfInt.html#a22d744bcd452d039580d1d9186f02b4e" title="Change le mode l&#39;allocation memoire: reallocation d&#39;un tableau a chaque changement de taille (flag = ...">set_smart_resize</a>(1);
  <a class="code" href="classSchema__Comm.html#a24918eceb0ce15a6dae5a5a833480246" title="Liste des processeurs de qui recevoir.">recv_pe_list_</a>.<a class="code" href="classArrOfInt.html#a22d744bcd452d039580d1d9186f02b4e" title="Change le mode l&#39;allocation memoire: reallocation d&#39;un tableau a chaque changement de taille (flag = ...">set_smart_resize</a>(1);
  <a class="code" href="classSchema__Comm.html#aaa55ab78220cfcca058cf54a7ac14cc0" title="Drapeau: est-ce qu&#39;on autorise a s&#39;envoyer des messages a soi ?">me_to_me_</a> = 0;
  <a class="code" href="classSchema__Comm.html#a88ddb051931c6d62f96d57ca2f79f7c1" title="Drapeau, quel type de communication faut-il utiliser ?">use_all_to_allv_</a> = 0;
<span class="comment">// Pour verifier plus tard qu&#39;on est toujours dans le bon groupe,</span>
<span class="comment">// on conserve une ref au groupe courant.</span>
  <a class="code" href="classSchema__Comm.html#adcd2cdb2d6ce76883858c8f6078fda56" title="Groupe de processeurs qui vont discuter.">ref_group_</a> = <a class="code" href="classPE__Groups.html#ae6ca0277a58f2ab34ebfb3216578fa75" title="renvoie une reference au groupe de processeurs actif courant">PE_Groups::current_group</a>();
  <span class="keywordflow">if</span> (<a class="code" href="classSchema__Comm.html#ae56acaadf7a079ce874be628491593cb">status_</a> == <a class="code" href="classSchema__Comm.html#a513eef36a4603d995f2a04f166812470ab8a8496bcb475aa3d59c4392d8fc08a9">UNINITIALIZED</a>)
    {
      <a class="code" href="classSchema__Comm.html#ac4ab50424d6aa29ac87103aa7690e203">n_buffers_</a> = <a class="code" href="classProcess.html#a6bf692ce58d9578aa62ac3c07b8caaa1" title="renvoie le nombre de processeurs dans le groupe courant Voir Comm_Group::nproc() et PE_Groups::curren...">Process::nproc</a>();
      <a class="code" href="classSchema__Comm.html#a6ce69882db45689247b677d5978d569e">buffers_</a>.<a class="code" href="classInOutCommBuffers.html#afb8912746dd19244b430fd26d874d5d4">obuffers_</a> = <span class="keyword">new</span> <a class="code" href="classOutputCommBuffer.html" title=": Classe outil utilisee exclusivement par Schema_Comm. C&#39;est une classe derivee de Entree dont le str...">OutputCommBuffer</a>[<a class="code" href="classSchema__Comm.html#ac4ab50424d6aa29ac87103aa7690e203">n_buffers_</a>];
      <a class="code" href="classSchema__Comm.html#a6ce69882db45689247b677d5978d569e">buffers_</a>.<a class="code" href="classInOutCommBuffers.html#a4f45d4ba0db13ce4aae52b93539b67ee">ebuffers_</a> = <span class="keyword">new</span> <a class="code" href="classInputCommBuffer.html" title=": Classe outil utilisee exclusivement par Schema_Comm. C&#39;est une classe derivee de Entree dont le str...">InputCommBuffer</a>[<a class="code" href="classSchema__Comm.html#ac4ab50424d6aa29ac87103aa7690e203">n_buffers_</a>];
      <a class="code" href="classSchema__Comm.html#ae56acaadf7a079ce874be628491593cb">status_</a> = <a class="code" href="classSchema__Comm.html#a513eef36a4603d995f2a04f166812470a79ffb1835b68257288b75f8fbcb65178">RESET</a>;
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a8f7a71ce2536bf4b3fc52f77862fa01d"></a><!-- doxytag: member="Schema_Comm::Schema_Comm" ref="a8f7a71ce2536bf4b3fc52f77862fa01d" args="(const Schema_Comm &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Schema_Comm::Schema_Comm </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSchema__Comm.html">Schema_Comm</a> &amp;&#160;</td>
          <td class="paramname"><em>schema</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructeur par copie (nouveau schema place en mode RESET).<br/>
Attention : tous les membres du <a class="el" href="classComm__Group.html" title=": Cette classe decrit un groupe de processeurs sur lesquels une portion de code s&#39;execute simultaneme...">Comm_Group</a> doivent executer<br/>
cette fonction simultanement. </p>

<p>Definition at line <a class="el" href="Schema__Comm_8cpp_source.html#l00091">91</a> of file <a class="el" href="Schema__Comm_8cpp_source.html">Schema_Comm.cpp</a>.</p>

<p>References <a class="el" href="Schema__Comm_8cpp_source.html#l00103">operator=()</a>, <a class="el" href="Schema__Comm_8h_source.html#l00132">recv_pe_list_</a>, <a class="el" href="Schema__Comm_8h_source.html#l00131">send_pe_list_</a>, and <a class="el" href="ArrOfInt_8cpp_source.html#l00443">ArrOfInt::set_smart_resize()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <a class="code" href="classSchema__Comm.html#a93eb7538476fa54ade96e88294feec8e" title="Liste des processeurs a qui envoyer.">send_pe_list_</a>.<a class="code" href="classArrOfInt.html#a22d744bcd452d039580d1d9186f02b4e" title="Change le mode l&#39;allocation memoire: reallocation d&#39;un tableau a chaque changement de taille (flag = ...">set_smart_resize</a>(1);
  <a class="code" href="classSchema__Comm.html#a24918eceb0ce15a6dae5a5a833480246" title="Liste des processeurs de qui recevoir.">recv_pe_list_</a>.<a class="code" href="classArrOfInt.html#a22d744bcd452d039580d1d9186f02b4e" title="Change le mode l&#39;allocation memoire: reallocation d&#39;un tableau a chaque changement de taille (flag = ...">set_smart_resize</a>(1);
  <a class="code" href="classSchema__Comm.html#a0963ab78f7c26d5fb8e25b1a657ea414" title="Operateur copie : on copie la liste des processeurs qui communiquent. Le nouveau schema est place dan...">operator= </a>(schema);
}
</pre></div>
</div>
</div>
<a class="anchor" id="a5b8b9f4946cb1de5edad0721561c43f8"></a><!-- doxytag: member="Schema_Comm::~Schema_Comm" ref="a5b8b9f4946cb1de5edad0721561c43f8" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Schema_Comm::~Schema_Comm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Destruction d'un schema de communication. </p>

<p>Definition at line <a class="el" href="Schema__Comm_8cpp_source.html#l00083">83</a> of file <a class="el" href="Schema__Comm_8cpp_source.html">Schema_Comm.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{
}
</pre></div>
</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="ac617b53de22748cdd9fa30a0cfd0f4a8"></a><!-- doxytag: member="Schema_Comm::begin_comm" ref="ac617b53de22748cdd9fa30a0cfd0f4a8" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Schema_Comm::begin_comm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Statut passe a WRITING Autorise si status_ == WRITING: </p>
<p>Reserve les buffers de comm pour une nouvelle communication.<br/>
Le schema passe de RESET a WRITING, on a maintenant le droit<br/>
d'appeler <a class="el" href="classSchema__Comm.html#a6c771eae3b46250ae0d2f0126a7d8065" title="renvoie le buffer correspondant au processeur num_PE pour y entasser des donnees a envoyer...">send_buffer()</a>. Interdiction d'appeler a nouveau begin_comm<br/>
sur tous les objets de comm avant d'avoir fini cette communication<br/>
avec <a class="el" href="classSchema__Comm.html#a73a981f88b6ffebc150fb46c5cce75d9" title="Statut passe a RESET Accesseurs:">end_comm()</a>. </p>

<p>Definition at line <a class="el" href="Schema__Comm_8cpp_source.html#l00166">166</a> of file <a class="el" href="Schema__Comm_8cpp_source.html">Schema_Comm.cpp</a>.</p>

<p>References <a class="el" href="classComm__Group.html#ac20236e71fc50066d225761ba1349c69">Comm_Group::barrier()</a>, <a class="el" href="Schema__Comm_8cpp_source.html#l00055">BEGIN_COMM_TAG</a>, <a class="el" href="Comm__Group_8h_source.html#l00143">Comm_Group::check_enabled()</a>, <a class="el" href="PE__Groups_8h_source.html#l00054">PE_Groups::current_group()</a>, <a class="el" href="O__U__Ptr_8cpp_source.html#l00098">O_U_Ptr::non_nul()</a>, <a class="el" href="Schema__Comm_8h_source.html#l00134">ref_group_</a>, <a class="el" href="Schema__Comm_8h_source.html#l00126">RESET</a>, <a class="el" href="Schema__Comm_8h_source.html#l00127">status_</a>, <a class="el" href="Ref__Comm__Group_8h_source.html#l00029">Ref_Comm_Group::valeur()</a>, and <a class="el" href="Schema__Comm_8h_source.html#l00126">WRITING</a>.</p>

<p>Referenced by <a class="el" href="Echange__contact__Correlation__VEF_8cpp_source.html#l00382">Echange_contact_Correlation_VEF::calculer_CL()</a>, <a class="el" href="Scatter_8cpp_source.html#l00937">Scatter::calculer_espace_distant()</a>, <a class="el" href="Scatter_8cpp_source.html#l02184">Scatter::calculer_espace_distant_elements()</a>, <a class="el" href="Scatter_8cpp_source.html#l02864">Scatter::calculer_nb_items_virtuels()</a>, <a class="el" href="Scatter_8cpp_source.html#l01353">Scatter::calculer_renum_items_communs()</a>, <a class="el" href="Scatter_8cpp_source.html#l00297">Scatter::check_consistancy_remote_items()</a>, <a class="el" href="Scatter_8cpp_source.html#l02653">Scatter::construire_correspondance_items_par_coordonnees()</a>, <a class="el" href="Faces__builder_8cpp_source.html#l00940">Zone::creer_aretes()</a>, <a class="el" href="MD__Vector__tools_8cpp_source.html#l00341">creer_md_vect_renum()</a>, <a class="el" href="communications_8cpp_source.html#l00427">envoyer_all_to_all_()</a>, <a class="el" href="MaillerParallel_8cpp_source.html#l00232">find_matching_coordinates()</a>, <a class="el" href="Raffiner__isotrope__parallele_8cpp_source.html#l00055">mon_construire_correspondance_items_par_coordonnees()</a>, <a class="el" href="Scatter_8cpp_source.html#l01807">Scatter::reordonner_faces_de_joint()</a>, <a class="el" href="Raccord__distant__homogene_8cpp_source.html#l00121">Raccord_distant_homogene::trace_elem_distant()</a>, and <a class="el" href="Raccord__distant__homogene_8cpp_source.html#l00167">Raccord_distant_homogene::trace_face_distant()</a>.</p>
<div class="fragment"><pre class="fragment">{
<span class="comment">// On verifie qu&#39;une autre communication n&#39;est pas en cours.</span>
  assert (<a class="code" href="classSchema__Comm.html#ae56acaadf7a079ce874be628491593cb">status_</a> == <a class="code" href="classSchema__Comm.html#a513eef36a4603d995f2a04f166812470a79ffb1835b68257288b75f8fbcb65178">RESET</a> &amp;&amp; <a class="code" href="classSchema__Comm.html#adcd2cdb2d6ce76883858c8f6078fda56" title="Groupe de processeurs qui vont discuter.">ref_group_</a>.<a class="code" href="classO__U__Ptr.html#a16f216b2d169e885876419182658ddcc" title="Renvoie 1 si le pointeur est non_nul Renvoie 0 sinon.">non_nul</a>());
  <a class="code" href="classSchema__Comm.html#ae56acaadf7a079ce874be628491593cb">status_</a> = <a class="code" href="classSchema__Comm.html#a513eef36a4603d995f2a04f166812470a218bae4e3cf445666fb4c8d08d055f0d">WRITING</a>;
<span class="comment">// On verifie que tous les membres du groupe executent ceci.</span>
<span class="comment">// Si ca plante ici, c&#39;est que tous les membres declares ne sont</span>
<span class="comment">// pas en train de faire la barriere.</span>
  <span class="keyword">const</span> <a class="code" href="classComm__Group.html" title=": Cette classe decrit un groupe de processeurs sur lesquels une portion de code s&#39;execute simultaneme...">Comm_Group</a>&amp; group = <a class="code" href="classSchema__Comm.html#adcd2cdb2d6ce76883858c8f6078fda56" title="Groupe de processeurs qui vont discuter.">ref_group_</a>.<a class="code" href="classRef__Comm__Group.html#a46f3361cb566b4a386f75f7f9570fe9a">valeur</a>();
  assert(&amp;group == &amp;<a class="code" href="classPE__Groups.html#ae6ca0277a58f2ab34ebfb3216578fa75" title="renvoie une reference au groupe de processeurs actif courant">PE_Groups::current_group</a>());
  <span class="keywordflow">if</span> (group.<a class="code" href="classComm__Group.html#a0f230fe65c9f52fd2a168a1ea70e7b15">check_enabled</a>()) group.<a class="code" href="classComm__Group.html#ac20236e71fc50066d225761ba1349c69">barrier</a>(<a class="code" href="Schema__Comm_8cpp.html#a85ca790bf7f3401ae365ae2f7ba1bdff">BEGIN_COMM_TAG</a>);
}
</pre></div>
</div>
</div>
<a class="anchor" id="a10b238ae8ba1d3f6ed955fa7164c93ce"></a><!-- doxytag: member="Schema_Comm::check_send_recv_pe_list" ref="a10b238ae8ba1d3f6ed955fa7164c93ce" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Schema_Comm::check_send_recv_pe_list </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Verifie que les send/recv_pe_list verifient la propriete<br/>
"tu m'ecoutes quand je te parle". </p>

<p>Definition at line <a class="el" href="Schema__Comm_8cpp_source.html#l00549">549</a> of file <a class="el" href="Schema__Comm_8cpp_source.html">Schema_Comm.cpp</a>.</p>

<p>References <a class="el" href="Process_8cpp_source.html#l00127">Process::barrier()</a>, <a class="el" href="EntreeSortie_8h_source.html#l00032">Cerr</a>, <a class="el" href="Process_8cpp_source.html#l00223">Process::exit()</a>, <a class="el" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>, <a class="el" href="Process_8cpp_source.html#l00095">Process::je_suis_maitre()</a>, <a class="el" href="Process_8cpp_source.html#l00345">Process::Journal()</a>, <a class="el" href="Process_8cpp_source.html#l00178">Process::mp_sum()</a>, <a class="el" href="Process_8cpp_source.html#l00109">Process::nproc()</a>, <a class="el" href="ArrOfInt_8cpp_source.html#l00897">ArrOfInt::ordonne_array()</a>, <a class="el" href="Schema__Comm_8h_source.html#l00132">recv_pe_list_</a>, <a class="el" href="Schema__Comm_8h_source.html#l00126">RESET</a>, <a class="el" href="communications_8cpp_source.html#l00561">reverse_send_recv_pe_list()</a>, <a class="el" href="Schema__Comm_8h_source.html#l00131">send_pe_list_</a>, <a class="el" href="ArrOfInt_8h_source.html#l00342">ArrOfInt::size_array()</a>, and <a class="el" href="Schema__Comm_8h_source.html#l00127">status_</a>.</p>

<p>Referenced by <a class="el" href="Schema__Comm_8cpp_source.html#l00146">set_send_recv_pe_list()</a>.</p>
<div class="fragment"><pre class="fragment">{
  assert(<a class="code" href="classSchema__Comm.html#ae56acaadf7a079ce874be628491593cb">status_</a> == <a class="code" href="classSchema__Comm.html#a513eef36a4603d995f2a04f166812470a79ffb1835b68257288b75f8fbcb65178">RESET</a>);
<span class="comment">// On verifie que les indices de processeurs sont dans le groupe</span>
  <span class="keywordtype">int</span> fail1 = 0;
  <span class="keyword">const</span> <span class="keywordtype">int</span> np = <a class="code" href="classProcess.html#a6bf692ce58d9578aa62ac3c07b8caaa1" title="renvoie le nombre de processeurs dans le groupe courant Voir Comm_Group::nproc() et PE_Groups::curren...">Process::nproc</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> n1 = <a class="code" href="classSchema__Comm.html#a93eb7538476fa54ade96e88294feec8e" title="Liste des processeurs a qui envoyer.">send_pe_list_</a>.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>();
  <span class="keywordtype">int</span> i;
  <span class="keywordflow">for</span> (i = 0; i &lt; n1; i++)
    <span class="keywordflow">if</span> (<a class="code" href="classSchema__Comm.html#a93eb7538476fa54ade96e88294feec8e" title="Liste des processeurs a qui envoyer.">send_pe_list_</a>[i] &lt; 0 || <a class="code" href="classSchema__Comm.html#a93eb7538476fa54ade96e88294feec8e" title="Liste des processeurs a qui envoyer.">send_pe_list_</a>[i] &gt;= np)
      fail1 = 1;
  <span class="keyword">const</span> <span class="keywordtype">int</span> n2 = <a class="code" href="classSchema__Comm.html#a24918eceb0ce15a6dae5a5a833480246" title="Liste des processeurs de qui recevoir.">recv_pe_list_</a>.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>();
  <span class="keywordflow">for</span> (i = 0; i &lt; n2; i++)
    <span class="keywordflow">if</span> (<a class="code" href="classSchema__Comm.html#a24918eceb0ce15a6dae5a5a833480246" title="Liste des processeurs de qui recevoir.">recv_pe_list_</a>[i] &lt; 0 || <a class="code" href="classSchema__Comm.html#a24918eceb0ce15a6dae5a5a833480246" title="Liste des processeurs de qui recevoir.">recv_pe_list_</a>[i] &gt;= np)
      fail1 = 1;
  <span class="keywordtype">int</span> fail2 = 0;
  <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> recv_list;
  <span class="keywordflow">if</span> (!fail1)
    {
      <a class="code" href="communications_8cpp.html#a38c9e2f958081bff6f390b56ec939523" title="Calcule la transposee d&#39;une liste de processeurs: On construit le tableau dest_list tel que: x est da...">reverse_send_recv_pe_list</a>(<a class="code" href="classSchema__Comm.html#a93eb7538476fa54ade96e88294feec8e" title="Liste des processeurs a qui envoyer.">send_pe_list_</a>, recv_list);
<span class="comment">// Le tableau recv_pe_list_ n&#39;est pas forcement trie alors que recv_list l&#39;est toujours</span>
<span class="comment">// On trie avant de comparer</span>
      <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> copie(<a class="code" href="classSchema__Comm.html#a24918eceb0ce15a6dae5a5a833480246" title="Liste des processeurs de qui recevoir.">recv_pe_list_</a>);
      copie.ordonne_array();
      fail2 = !(recv_list == copie);
    }
  <span class="keywordflow">if</span> (<a class="code" href="classProcess.html#a7d23bc1ef94b3f0623fbc79d034c27fd" title="Calcule la somme de x sur tous les processeurs du groupe courant. Voir aussi mp_max()">Process::mp_sum</a>(fail1+fail2))
    {
      <span class="keywordflow">if</span> (<a class="code" href="classProcess.html#acd052b99706c577f8a5b6656217cf4c2" title="renvoie 1 si on est sur le processeur maitre du groupe courant (c&#39;est a dire me() == 0)...">Process::je_suis_maitre</a>())
        <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Error in Schema_Comm::check_send_recv_pe_list(), see .log files&quot;</span> &lt;&lt; finl;
      <a class="code" href="classProcess.html#a57e0f54b11e6eaadbea224fa904b18dd" title="Renvoie un objet statique de type Sortie qui sert de journal d&#39;evenements. Si message_level &lt;= verbose...">Process::Journal</a>() &lt;&lt; <span class="stringliteral">&quot;Error in Schema_Comm::check_send_recv_pe_list() :\n&quot;</span>
                         &lt;&lt; <span class="stringliteral">&quot;send_list:\n&quot;</span> &lt;&lt; <a class="code" href="classSchema__Comm.html#a93eb7538476fa54ade96e88294feec8e" title="Liste des processeurs a qui envoyer.">send_pe_list_</a>
                         &lt;&lt; <span class="stringliteral">&quot;recv_list:\n&quot;</span> &lt;&lt; <a class="code" href="classSchema__Comm.html#a24918eceb0ce15a6dae5a5a833480246" title="Liste des processeurs de qui recevoir.">recv_pe_list_</a>;
      <span class="keywordflow">if</span> (fail1)
        <a class="code" href="classProcess.html#a57e0f54b11e6eaadbea224fa904b18dd" title="Renvoie un objet statique de type Sortie qui sert de journal d&#39;evenements. Si message_level &lt;= verbose...">Process::Journal</a>() &lt;&lt; <span class="stringliteral">&quot;processor ranks not in current group: current group size = &quot;</span> &lt;&lt; np;
      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (fail2)
        <a class="code" href="classProcess.html#a57e0f54b11e6eaadbea224fa904b18dd" title="Renvoie un objet statique de type Sortie qui sert de journal d&#39;evenements. Si message_level &lt;= verbose...">Process::Journal</a>() &lt;&lt; <span class="stringliteral">&quot;recv_list should be this one:\n&quot;</span> &lt;&lt; recv_list &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
      <span class="keywordflow">else</span>
        <a class="code" href="classProcess.html#a57e0f54b11e6eaadbea224fa904b18dd" title="Renvoie un objet statique de type Sortie qui sert de journal d&#39;evenements. Si message_level &lt;= verbose...">Process::Journal</a>() &lt;&lt; <span class="stringliteral">&quot;OK on this processor&quot;</span> &lt;&lt; finl;
      <a class="code" href="classProcess.html#aa9e74a5c06a68ea38298a08ea401e7b1" title="Synchronise tous les processeurs du groupe courant&lt;br&gt;(attend que tous les processeurs soient arrives...">Process::barrier</a>();
      <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">Process::exit</a>();
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a0955c141014893e559b831ae33d55d56"></a><!-- doxytag: member="Schema_Comm::ebuffer" ref="a0955c141014893e559b831ae33d55d56" args="(int pe)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classInputCommBuffer.html">InputCommBuffer</a> &amp; Schema_Comm::ebuffer </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pe</em></td><td>)</td>
          <td><code> [inline, static, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Accesseur a un membre du tableau ebuffers_ (avec verification) </p>

<p>Definition at line <a class="el" href="Schema__Comm_8cpp_source.html#l00048">48</a> of file <a class="el" href="Schema__Comm_8cpp_source.html">Schema_Comm.cpp</a>.</p>

<p>References <a class="el" href="Schema__Comm_8h_source.html#l00141">buffers_</a>, <a class="el" href="InOutCommBuffers_8h_source.html#l00032">InOutCommBuffers::ebuffers_</a>, and <a class="el" href="Schema__Comm_8h_source.html#l00142">n_buffers_</a>.</p>

<p>Referenced by <a class="el" href="Schema__Comm_8cpp_source.html#l00311">echange_messages()</a>, <a class="el" href="Schema__Comm_8cpp_source.html#l00430">end_comm()</a>, and <a class="el" href="Schema__Comm_8cpp_source.html#l00494">recv_buffer()</a>.</p>
<div class="fragment"><pre class="fragment">{
  assert(pe &gt;= 0 &amp;&amp; pe &lt; <a class="code" href="classSchema__Comm.html#ac4ab50424d6aa29ac87103aa7690e203">n_buffers_</a>);
  <span class="keywordflow">return</span> <a class="code" href="classSchema__Comm.html#a6ce69882db45689247b677d5978d569e">buffers_</a>.<a class="code" href="classInOutCommBuffers.html#a4f45d4ba0db13ce4aae52b93539b67ee">ebuffers_</a>[pe];
}
</pre></div>
</div>
</div>
<a class="anchor" id="ae33a0b666e564e5f9996e2e39ebba7e1"></a><!-- doxytag: member="Schema_Comm::echange_messages" ref="ae33a0b666e564e5f9996e2e39ebba7e1" args="(const ArrOfInt &amp;recv_size) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Schema_Comm::echange_messages </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>recv_size</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Statut passe a EXCHANGED Autorise si status_ == EXCHANGED: </p>
<p>Cette methode lance l'echange de donnees. On fournit la taille en octets<br/>
des messages recus dans recv_size (tableau de la meme taille que recv_pe_list)<br/>
En mode check_enabled, on verifie que la taille est correcte. </p>

<p>Definition at line <a class="el" href="Schema__Comm_8cpp_source.html#l00403">403</a> of file <a class="el" href="Schema__Comm_8cpp_source.html">Schema_Comm.cpp</a>.</p>

<p>References <a class="el" href="EntreeSortie_8h_source.html#l00032">Cerr</a>, <a class="el" href="PE__Groups_8h_source.html#l00054">PE_Groups::current_group()</a>, <a class="el" href="Schema__Comm_8cpp_source.html#l00261">echange_taille()</a>, <a class="el" href="Process_8cpp_source.html#l00223">Process::exit()</a>, <a class="el" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>, <a class="el" href="OutputCommBuffer_8cpp_source.html#l00049">OutputCommBuffer::get_buffer_size()</a>, <a class="el" href="Schema__Comm_8cpp_source.html#l00040">obuffer()</a>, <a class="el" href="Schema__Comm_8h_source.html#l00131">send_pe_list_</a>, and <a class="el" href="ArrOfInt_8h_source.html#l00342">ArrOfInt::size_array()</a>.</p>

<p>Referenced by <a class="el" href="Schema__Comm_8cpp_source.html#l00380">echange_taille_et_messages()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">const</span> <span class="keywordtype">int</span> n_send = <a class="code" href="classSchema__Comm.html#a93eb7538476fa54ade96e88294feec8e" title="Liste des processeurs a qui envoyer.">send_pe_list_</a>.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>();
  <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> send_size(n_send);
  <span class="keywordtype">int</span> i;
  <span class="keywordflow">for</span> (i = 0; i &lt; n_send; i++)
    {
      <span class="keywordtype">int</span> pe = <a class="code" href="classSchema__Comm.html#a93eb7538476fa54ade96e88294feec8e" title="Liste des processeurs a qui envoyer.">send_pe_list_</a>[i];
      send_size[i] = <a class="code" href="classSchema__Comm.html#a734080d1326e58abdc5731d1b3486d4b" title="Accesseur a un membre du tableau obuffers_ (avec verification)">obuffer</a>(pe).<a class="code" href="classOutputCommBuffer.html#a3dd24532686e8a731b2809b0049c7a4c">get_buffer_size</a>();
    }
  <span class="keywordflow">if</span> (<a class="code" href="classPE__Groups.html#ae6ca0277a58f2ab34ebfb3216578fa75" title="renvoie une reference au groupe de processeurs actif courant">PE_Groups::current_group</a>().check_enabled())
    {
      <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> check_recv_size;
      <a class="code" href="classSchema__Comm.html#a7988e23c0989bfa8a3980f16b591e41d" title="Transmet la taille des messages a envoyer aux processeurs qui vont les recevoir. La taille est le nom...">echange_taille</a>(send_size, check_recv_size);
      <span class="keywordflow">if</span> (!(check_recv_size == recv_size))
        {
          <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Error in Schema_Comm::echange_messages : bad recv_size&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
          <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">Process::exit</a>();
        }
    }
  <a class="code" href="classSchema__Comm.html#ae33a0b666e564e5f9996e2e39ebba7e1" title="Statut passe a EXCHANGED Autorise si status_ == EXCHANGED:">echange_messages</a>(send_size, recv_size);
}
</pre></div>
</div>
</div>
<a class="anchor" id="a6d7e026c5aa0af7f994aecf9d40d4079"></a><!-- doxytag: member="Schema_Comm::echange_messages" ref="a6d7e026c5aa0af7f994aecf9d40d4079" args="(const ArrOfInt &amp;send_size, const ArrOfInt &amp;recv_size) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Schema_Comm::echange_messages </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>send_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>recv_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Cette methode lance l'echange de donnees entre tous les processeurs.<br/>
La taille des messages recus doit etre deja connue.<br/>
Le schema passe de WRITING a EXCHANGED. </p>

<p>Definition at line <a class="el" href="Schema__Comm_8cpp_source.html#l00311">311</a> of file <a class="el" href="Schema__Comm_8cpp_source.html">Schema_Comm.cpp</a>.</p>

<p>References <a class="el" href="arch_8cpp_source.html#l00052">buf</a>, <a class="el" href="InputCommBuffer_8cpp_source.html#l00060">InputCommBuffer::create_stream()</a>, <a class="el" href="InputCommBuffer_8cpp_source.html#l00075">InputCommBuffer::create_stream_from_output_stream()</a>, <a class="el" href="PE__Groups_8h_source.html#l00054">PE_Groups::current_group()</a>, <a class="el" href="Schema__Comm_8cpp_source.html#l00048">ebuffer()</a>, <a class="el" href="Schema__Comm_8cpp_source.html#l00056">ECHANGE_MESSAGES_COMM_TAG</a>, <a class="el" href="Schema__Comm_8cpp_source.html#l00179">exchange_data()</a>, <a class="el" href="Schema__Comm_8h_source.html#l00126">EXCHANGED</a>, <a class="el" href="OutputCommBuffer_8cpp_source.html#l00042">OutputCommBuffer::get_buffer()</a>, <a class="el" href="OutputCommBuffer_8cpp_source.html#l00049">OutputCommBuffer::get_buffer_size()</a>, <a class="el" href="Process_8cpp_source.html#l00117">Process::me()</a>, <a class="el" href="Schema__Comm_8h_source.html#l00133">me_to_me_</a>, <a class="el" href="O__U__Ptr_8cpp_source.html#l00098">O_U_Ptr::non_nul()</a>, <a class="el" href="Schema__Comm_8cpp_source.html#l00040">obuffer()</a>, <a class="el" href="Schema__Comm_8h_source.html#l00132">recv_pe_list_</a>, <a class="el" href="Schema__Comm_8h_source.html#l00134">ref_group_</a>, <a class="el" href="InputCommBuffer_8cpp_source.html#l00047">InputCommBuffer::reserve_buffer()</a>, <a class="el" href="Schema__Comm_8h_source.html#l00131">send_pe_list_</a>, <a class="el" href="ArrOfInt_8h_source.html#l00342">ArrOfInt::size_array()</a>, <a class="el" href="Schema__Comm_8h_source.html#l00127">status_</a>, <a class="el" href="Schema__Comm_8h_source.html#l00136">use_all_to_allv_</a>, <a class="el" href="Ref__Comm__Group_8h_source.html#l00029">Ref_Comm_Group::valeur()</a>, and <a class="el" href="Schema__Comm_8h_source.html#l00126">WRITING</a>.</p>
<div class="fragment"><pre class="fragment">{
  assert(<a class="code" href="classSchema__Comm.html#ae56acaadf7a079ce874be628491593cb">status_</a> == <a class="code" href="classSchema__Comm.html#a513eef36a4603d995f2a04f166812470a218bae4e3cf445666fb4c8d08d055f0d">WRITING</a> &amp;&amp; <a class="code" href="classSchema__Comm.html#adcd2cdb2d6ce76883858c8f6078fda56" title="Groupe de processeurs qui vont discuter.">ref_group_</a>.<a class="code" href="classO__U__Ptr.html#a16f216b2d169e885876419182658ddcc" title="Renvoie 1 si le pointeur est non_nul Renvoie 0 sinon.">non_nul</a>());
  <span class="keyword">const</span> <a class="code" href="classComm__Group.html" title=": Cette classe decrit un groupe de processeurs sur lesquels une portion de code s&#39;execute simultaneme...">Comm_Group</a>&amp; group = <a class="code" href="classSchema__Comm.html#adcd2cdb2d6ce76883858c8f6078fda56" title="Groupe de processeurs qui vont discuter.">ref_group_</a>.<a class="code" href="classRef__Comm__Group.html#a46f3361cb566b4a386f75f7f9570fe9a">valeur</a>();
  assert(&amp;group == &amp;<a class="code" href="classPE__Groups.html#ae6ca0277a58f2ab34ebfb3216578fa75" title="renvoie une reference au groupe de processeurs actif courant">PE_Groups::current_group</a>());

<span class="comment">// On verifie que tous les membres du groupe executent ceci.</span>
<span class="comment">// Si ca plante ici, c&#39;est que tous les membres declares ne sont</span>
<span class="comment">// pas en train de faire la barriere.</span>
  <span class="keywordflow">if</span> (group.check_enabled()) group.barrier(<a class="code" href="Schema__Comm_8cpp.html#a4c41ba0edefa0cda76d623d2bee6099d">ECHANGE_MESSAGES_COMM_TAG</a>);

  <span class="keyword">const</span> <span class="keywordtype">int</span> n_send = <a class="code" href="classSchema__Comm.html#a93eb7538476fa54ade96e88294feec8e" title="Liste des processeurs a qui envoyer.">send_pe_list_</a>.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> n_recv = <a class="code" href="classSchema__Comm.html#a24918eceb0ce15a6dae5a5a833480246" title="Liste des processeurs de qui recevoir.">recv_pe_list_</a>.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>();
  <span class="keyword">const</span> <span class="keywordtype">char</span> ** send_buffers = <span class="keyword">new</span> <span class="keyword">const</span> <span class="keywordtype">char</span>* [n_send];
  <span class="keywordtype">char</span> ** recv_buffers = <span class="keyword">new</span> <span class="keywordtype">char</span>* [n_recv];

  <span class="keywordtype">int</span> i;
  <span class="keywordflow">for</span> (i = 0; i &lt; n_recv; i++)
    {
      <span class="keywordtype">int</span> pe = <a class="code" href="classSchema__Comm.html#a24918eceb0ce15a6dae5a5a833480246" title="Liste des processeurs de qui recevoir.">recv_pe_list_</a>[i];
      <span class="keywordtype">int</span> size = recv_size[i];
      <a class="code" href="classInputCommBuffer.html" title=": Classe outil utilisee exclusivement par Schema_Comm. C&#39;est une classe derivee de Entree dont le str...">InputCommBuffer</a>&amp; <a class="code" href="arch_8cpp.html#a1fe855c208bc17a51a4d34fefdb2d5b1">buf</a> = <a class="code" href="classSchema__Comm.html#a0955c141014893e559b831ae33d55d56" title="Accesseur a un membre du tableau ebuffers_ (avec verification)">ebuffer</a>(pe);
      recv_buffers[i] = buf.<a class="code" href="classInputCommBuffer.html#a1ea808033309fd6c3def0db5ac439fa4">reserve_buffer</a>(size);
    }
  <span class="keywordflow">for</span> (i = 0; i &lt; n_send; i++)
    {
      <span class="keywordtype">int</span> pe = <a class="code" href="classSchema__Comm.html#a93eb7538476fa54ade96e88294feec8e" title="Liste des processeurs a qui envoyer.">send_pe_list_</a>[i];
      <a class="code" href="classOutputCommBuffer.html" title=": Classe outil utilisee exclusivement par Schema_Comm. C&#39;est une classe derivee de Entree dont le str...">OutputCommBuffer</a>&amp; buf = <a class="code" href="classSchema__Comm.html#a734080d1326e58abdc5731d1b3486d4b" title="Accesseur a un membre du tableau obuffers_ (avec verification)">obuffer</a>(pe);
<span class="comment">// On verifie que la taille des messages en emission est la meme que</span>
<span class="comment">// celle enregistree dans send_size_, ce qui garantit que la taille</span>
<span class="comment">// en reception est juste elle-aussi.</span>
      assert(send_size[i] == buf.<a class="code" href="classOutputCommBuffer.html#a3dd24532686e8a731b2809b0049c7a4c">get_buffer_size</a>());
      send_buffers[i] = buf.<a class="code" href="classOutputCommBuffer.html#ad4526ebfe5863c4009c858d59576c638">get_buffer</a>();
    }

  <a class="code" href="Schema__Comm_8cpp.html#a269962dc3d54d1d174a7936f5fe41d72">exchange_data</a>(<a class="code" href="classSchema__Comm.html#a93eb7538476fa54ade96e88294feec8e" title="Liste des processeurs a qui envoyer.">send_pe_list_</a>, send_size, send_buffers,
                <a class="code" href="classSchema__Comm.html#a24918eceb0ce15a6dae5a5a833480246" title="Liste des processeurs de qui recevoir.">recv_pe_list_</a>, recv_size, recv_buffers,
                group,
                <a class="code" href="classSchema__Comm.html#a88ddb051931c6d62f96d57ca2f79f7c1" title="Drapeau, quel type de communication faut-il utiliser ?">use_all_to_allv_</a>);

  <span class="keyword">delete</span>[] recv_buffers;
  <span class="keyword">delete</span>[] send_buffers;

<span class="comment">// Creation des input streams a partir des buffers recus</span>
  <span class="keywordflow">for</span> (i = 0; i &lt; n_recv; i++)
    {
      <span class="keywordtype">int</span> pe = <a class="code" href="classSchema__Comm.html#a24918eceb0ce15a6dae5a5a833480246" title="Liste des processeurs de qui recevoir.">recv_pe_list_</a>[i];
      <a class="code" href="classInputCommBuffer.html" title=": Classe outil utilisee exclusivement par Schema_Comm. C&#39;est une classe derivee de Entree dont le str...">InputCommBuffer</a>&amp; buf = <a class="code" href="classSchema__Comm.html#a0955c141014893e559b831ae33d55d56" title="Accesseur a un membre du tableau ebuffers_ (avec verification)">ebuffer</a>(pe);
      buf.<a class="code" href="classInputCommBuffer.html#a3a272bcedfa78423e2fb29084334000a">create_stream</a>();
    }

<span class="comment">// Cas particulier des messages envoyes a moi-meme:</span>
  <span class="keywordflow">if</span> (<a class="code" href="classSchema__Comm.html#aaa55ab78220cfcca058cf54a7ac14cc0" title="Drapeau: est-ce qu&#39;on autorise a s&#39;envoyer des messages a soi ?">me_to_me_</a>)
    {
      <span class="keywordtype">int</span> pe = <a class="code" href="classProcess.html#ab55ba07167ec807ed3a145cac0f5dca4" title="renvoie mon rang dans le groupe de communication courant. Voir Comm_Group::rank() et PE_Groups::curre...">Process::me</a>();
      <a class="code" href="classInputCommBuffer.html" title=": Classe outil utilisee exclusivement par Schema_Comm. C&#39;est une classe derivee de Entree dont le str...">InputCommBuffer</a>&amp; buf = <a class="code" href="classSchema__Comm.html#a0955c141014893e559b831ae33d55d56" title="Accesseur a un membre du tableau ebuffers_ (avec verification)">ebuffer</a>(pe);
      <a class="code" href="classOutputCommBuffer.html" title=": Classe outil utilisee exclusivement par Schema_Comm. C&#39;est une classe derivee de Entree dont le str...">OutputCommBuffer</a>&amp; obuf = <a class="code" href="classSchema__Comm.html#a734080d1326e58abdc5731d1b3486d4b" title="Accesseur a un membre du tableau obuffers_ (avec verification)">obuffer</a>(pe);
      buf.<a class="code" href="classInputCommBuffer.html#af6a33480102d6d23f694da538798afd3">create_stream_from_output_stream</a>(obuf);
    }

  <a class="code" href="classSchema__Comm.html#ae56acaadf7a079ce874be628491593cb">status_</a> = <a class="code" href="classSchema__Comm.html#a513eef36a4603d995f2a04f166812470a40b4132b151da7359211aad2f3682c9f">EXCHANGED</a>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a7988e23c0989bfa8a3980f16b591e41d"></a><!-- doxytag: member="Schema_Comm::echange_taille" ref="a7988e23c0989bfa8a3980f16b591e41d" args="(const ArrOfInt &amp;send_size, ArrOfInt &amp;recv_size) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Schema_Comm::echange_taille </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>send_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>recv_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Transmet la taille des messages a envoyer aux processeurs qui<br/>
vont les recevoir. La taille est le nombre de bytes des obuffers.<br/>
send_pe_list et recv_pe_list doivent etre initialises.<br/>
Le schema doit etre dans l'etat WRITING. </p>

<p><p>&lt; Taille d'un int (on echange une taille) </p>
</p>

<p>Definition at line <a class="el" href="Schema__Comm_8cpp_source.html#l00261">261</a> of file <a class="el" href="Schema__Comm_8cpp_source.html">Schema_Comm.cpp</a>.</p>

<p>References <a class="el" href="PE__Groups_8h_source.html#l00054">PE_Groups::current_group()</a>, <a class="el" href="Schema__Comm_8cpp_source.html#l00056">ECHANGE_MESSAGES_COMM_TAG</a>, <a class="el" href="Schema__Comm_8cpp_source.html#l00179">exchange_data()</a>, <a class="el" href="O__U__Ptr_8cpp_source.html#l00098">O_U_Ptr::non_nul()</a>, <a class="el" href="Schema__Comm_8h_source.html#l00132">recv_pe_list_</a>, <a class="el" href="Schema__Comm_8h_source.html#l00134">ref_group_</a>, <a class="el" href="ArrOfInt_8h_source.html#l00240">ArrOfInt::resize_array()</a>, <a class="el" href="Schema__Comm_8h_source.html#l00131">send_pe_list_</a>, <a class="el" href="ArrOfInt_8cpp_source.html#l00443">ArrOfInt::set_smart_resize()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00342">ArrOfInt::size_array()</a>, <a class="el" href="Schema__Comm_8h_source.html#l00127">status_</a>, <a class="el" href="Schema__Comm_8h_source.html#l00136">use_all_to_allv_</a>, <a class="el" href="Ref__Comm__Group_8h_source.html#l00029">Ref_Comm_Group::valeur()</a>, and <a class="el" href="Schema__Comm_8h_source.html#l00126">WRITING</a>.</p>

<p>Referenced by <a class="el" href="Schema__Comm_8cpp_source.html#l00403">echange_messages()</a>, and <a class="el" href="Schema__Comm_8cpp_source.html#l00380">echange_taille_et_messages()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">static</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> send_sz;
  <span class="keyword">static</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> recv_sz;
  send_sz.<a class="code" href="classArrOfInt.html#a22d744bcd452d039580d1d9186f02b4e" title="Change le mode l&#39;allocation memoire: reallocation d&#39;un tableau a chaque changement de taille (flag = ...">set_smart_resize</a>(1);
  recv_sz.<a class="code" href="classArrOfInt.html#a22d744bcd452d039580d1d9186f02b4e" title="Change le mode l&#39;allocation memoire: reallocation d&#39;un tableau a chaque changement de taille (flag = ...">set_smart_resize</a>(1);

  assert(<a class="code" href="classSchema__Comm.html#ae56acaadf7a079ce874be628491593cb">status_</a> == <a class="code" href="classSchema__Comm.html#a513eef36a4603d995f2a04f166812470a218bae4e3cf445666fb4c8d08d055f0d">WRITING</a> &amp;&amp; <a class="code" href="classSchema__Comm.html#adcd2cdb2d6ce76883858c8f6078fda56" title="Groupe de processeurs qui vont discuter.">ref_group_</a>.<a class="code" href="classO__U__Ptr.html#a16f216b2d169e885876419182658ddcc" title="Renvoie 1 si le pointeur est non_nul Renvoie 0 sinon.">non_nul</a>());
  <span class="keyword">const</span> <a class="code" href="classComm__Group.html" title=": Cette classe decrit un groupe de processeurs sur lesquels une portion de code s&#39;execute simultaneme...">Comm_Group</a>&amp; group = <a class="code" href="classSchema__Comm.html#adcd2cdb2d6ce76883858c8f6078fda56" title="Groupe de processeurs qui vont discuter.">ref_group_</a>.<a class="code" href="classRef__Comm__Group.html#a46f3361cb566b4a386f75f7f9570fe9a">valeur</a>();
  assert(&amp;group == &amp;<a class="code" href="classPE__Groups.html#ae6ca0277a58f2ab34ebfb3216578fa75" title="renvoie une reference au groupe de processeurs actif courant">PE_Groups::current_group</a>());

<span class="comment">// On verifie que tous les membres du groupe executent ceci.</span>
<span class="comment">// Si ca plante ici, c&#39;est que tous les membres declares ne sont</span>
<span class="comment">// pas en train de faire la barriere.</span>
  <span class="keywordflow">if</span> (group.check_enabled()) group.barrier(<a class="code" href="Schema__Comm_8cpp.html#a4c41ba0edefa0cda76d623d2bee6099d">ECHANGE_MESSAGES_COMM_TAG</a>);

  <span class="keyword">const</span> <span class="keywordtype">int</span> n_send = <a class="code" href="classSchema__Comm.html#a93eb7538476fa54ade96e88294feec8e" title="Liste des processeurs a qui envoyer.">send_pe_list_</a>.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> n_recv = <a class="code" href="classSchema__Comm.html#a24918eceb0ce15a6dae5a5a833480246" title="Liste des processeurs de qui recevoir.">recv_pe_list_</a>.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>();

  recv_size.<a class="code" href="classArrOfInt.html#a9b3afbb46b16870dbd36236c8935b535">resize_array</a>(n_recv);

  <span class="keyword">const</span> <span class="keywordtype">char</span> ** send_buffers = <span class="keyword">new</span> <span class="keyword">const</span> <span class="keywordtype">char</span>* [n_send];
  <span class="keywordtype">char</span> ** recv_buffers = <span class="keyword">new</span> <span class="keywordtype">char</span>* [n_recv];

  send_sz.<a class="code" href="classArrOfInt.html#a9b3afbb46b16870dbd36236c8935b535">resize_array</a>(n_send);   <span class="comment">//!&lt; Taille d&#39;un int (on echange une taille)</span>
<span class="comment"></span>  send_sz = <span class="keyword">sizeof</span>(int);
  <span class="keywordtype">int</span> i;
  <span class="keywordflow">for</span> (i = 0; i &lt; n_send; i++)
    send_buffers[i] = (<span class="keywordtype">char</span>*) (&amp; send_size[i]);

  recv_sz.<a class="code" href="classArrOfInt.html#a9b3afbb46b16870dbd36236c8935b535">resize_array</a>(n_recv);
  recv_sz = <span class="keyword">sizeof</span>(int);
  recv_size.<a class="code" href="classArrOfInt.html#a9b3afbb46b16870dbd36236c8935b535">resize_array</a>(n_recv);
  <span class="keywordflow">for</span> (i = 0; i &lt; n_recv; i++)
    recv_buffers[i] = (<span class="keywordtype">char</span>*) (&amp; recv_size[i]);

  <a class="code" href="Schema__Comm_8cpp.html#a269962dc3d54d1d174a7936f5fe41d72">exchange_data</a>(<a class="code" href="classSchema__Comm.html#a93eb7538476fa54ade96e88294feec8e" title="Liste des processeurs a qui envoyer.">send_pe_list_</a>, send_sz, send_buffers,
                <a class="code" href="classSchema__Comm.html#a24918eceb0ce15a6dae5a5a833480246" title="Liste des processeurs de qui recevoir.">recv_pe_list_</a>, recv_sz, recv_buffers,
                group,
                <a class="code" href="classSchema__Comm.html#a88ddb051931c6d62f96d57ca2f79f7c1" title="Drapeau, quel type de communication faut-il utiliser ?">use_all_to_allv_</a>);

  <span class="keyword">delete</span>[] recv_buffers;
  <span class="keyword">delete</span>[] send_buffers;
}
</pre></div>
</div>
</div>
<a class="anchor" id="abca0e8ac6c2b742d26f3cfaee0690c72"></a><!-- doxytag: member="Schema_Comm::echange_taille_et_messages" ref="abca0e8ac6c2b742d26f3cfaee0690c72" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Schema_Comm::echange_taille_et_messages </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Statut passe a EXCHANGED. </p>
<p>Cette methode lance l'echange de donnees entre tous les processeurs.<br/>
La taille des messages recus n'a pas besoin d'etre connue a priori,<br/>
on la transmet.<br/>
Le schema passe de WRITING a EXCHANGED. </p>

<p>Definition at line <a class="el" href="Schema__Comm_8cpp_source.html#l00380">380</a> of file <a class="el" href="Schema__Comm_8cpp_source.html">Schema_Comm.cpp</a>.</p>

<p>References <a class="el" href="Schema__Comm_8cpp_source.html#l00403">echange_messages()</a>, <a class="el" href="Schema__Comm_8cpp_source.html#l00261">echange_taille()</a>, <a class="el" href="OutputCommBuffer_8cpp_source.html#l00049">OutputCommBuffer::get_buffer_size()</a>, <a class="el" href="Schema__Comm_8cpp_source.html#l00040">obuffer()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00240">ArrOfInt::resize_array()</a>, <a class="el" href="Schema__Comm_8h_source.html#l00131">send_pe_list_</a>, and <a class="el" href="ArrOfInt_8h_source.html#l00342">ArrOfInt::size_array()</a>.</p>

<p>Referenced by <a class="el" href="Echange__contact__Correlation__VEF_8cpp_source.html#l00382">Echange_contact_Correlation_VEF::calculer_CL()</a>, <a class="el" href="Scatter_8cpp_source.html#l00937">Scatter::calculer_espace_distant()</a>, <a class="el" href="Scatter_8cpp_source.html#l02184">Scatter::calculer_espace_distant_elements()</a>, <a class="el" href="Scatter_8cpp_source.html#l02864">Scatter::calculer_nb_items_virtuels()</a>, <a class="el" href="Scatter_8cpp_source.html#l01353">Scatter::calculer_renum_items_communs()</a>, <a class="el" href="Scatter_8cpp_source.html#l00297">Scatter::check_consistancy_remote_items()</a>, <a class="el" href="Scatter_8cpp_source.html#l02653">Scatter::construire_correspondance_items_par_coordonnees()</a>, <a class="el" href="Faces__builder_8cpp_source.html#l00940">Zone::creer_aretes()</a>, <a class="el" href="MD__Vector__tools_8cpp_source.html#l00341">creer_md_vect_renum()</a>, <a class="el" href="communications_8cpp_source.html#l00427">envoyer_all_to_all_()</a>, <a class="el" href="MaillerParallel_8cpp_source.html#l00232">find_matching_coordinates()</a>, <a class="el" href="Raffiner__isotrope__parallele_8cpp_source.html#l00055">mon_construire_correspondance_items_par_coordonnees()</a>, <a class="el" href="Scatter_8cpp_source.html#l01807">Scatter::reordonner_faces_de_joint()</a>, <a class="el" href="Raccord__distant__homogene_8cpp_source.html#l00121">Raccord_distant_homogene::trace_elem_distant()</a>, and <a class="el" href="Raccord__distant__homogene_8cpp_source.html#l00167">Raccord_distant_homogene::trace_face_distant()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">static</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> send_size;
  <span class="keyword">static</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> recv_size;
  <span class="keyword">const</span> <span class="keywordtype">int</span> n_send = <a class="code" href="classSchema__Comm.html#a93eb7538476fa54ade96e88294feec8e" title="Liste des processeurs a qui envoyer.">send_pe_list_</a>.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>();
  send_size.<a class="code" href="classArrOfInt.html#a9b3afbb46b16870dbd36236c8935b535">resize_array</a>(n_send);
  <span class="keywordtype">int</span> i;
  <span class="keywordflow">for</span> (i = 0; i &lt; n_send; i++)
    {
      <span class="keywordtype">int</span> pe = <a class="code" href="classSchema__Comm.html#a93eb7538476fa54ade96e88294feec8e" title="Liste des processeurs a qui envoyer.">send_pe_list_</a>[i];
      send_size[i] = <a class="code" href="classSchema__Comm.html#a734080d1326e58abdc5731d1b3486d4b" title="Accesseur a un membre du tableau obuffers_ (avec verification)">obuffer</a>(pe).<a class="code" href="classOutputCommBuffer.html#a3dd24532686e8a731b2809b0049c7a4c">get_buffer_size</a>();
    }

<span class="comment">// Methode non optimale: en MPI on pourrait utiliser MPI_Probe mais</span>
<span class="comment">// cette methode me parait peu sure.</span>
  <a class="code" href="classSchema__Comm.html#a7988e23c0989bfa8a3980f16b591e41d" title="Transmet la taille des messages a envoyer aux processeurs qui vont les recevoir. La taille est le nom...">echange_taille</a>(send_size, recv_size);
  <a class="code" href="classSchema__Comm.html#ae33a0b666e564e5f9996e2e39ebba7e1" title="Statut passe a EXCHANGED Autorise si status_ == EXCHANGED:">echange_messages</a>(send_size, recv_size);
}
</pre></div>
</div>
</div>
<a class="anchor" id="a73a981f88b6ffebc150fb46c5cce75d9"></a><!-- doxytag: member="Schema_Comm::end_comm" ref="a73a981f88b6ffebc150fb46c5cce75d9" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Schema_Comm::end_comm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Statut passe a RESET Accesseurs: </p>
<p>Vide les buffers et libere les ressources: on<br/>
a fini de lire les donnees recues dans les buffers.<br/>
Le schema passe de EXCHANGED a RESET. </p>

<p>Definition at line <a class="el" href="Schema__Comm_8cpp_source.html#l00430">430</a> of file <a class="el" href="Schema__Comm_8cpp_source.html">Schema_Comm.cpp</a>.</p>

<p>References <a class="el" href="InputCommBuffer_8cpp_source.html#l00092">InputCommBuffer::clear()</a>, <a class="el" href="OutputCommBuffer_8cpp_source.html#l00054">OutputCommBuffer::clear()</a>, <a class="el" href="PE__Groups_8h_source.html#l00054">PE_Groups::current_group()</a>, <a class="el" href="Schema__Comm_8cpp_source.html#l00048">ebuffer()</a>, <a class="el" href="Schema__Comm_8cpp_source.html#l00057">END_COMM_TAG</a>, <a class="el" href="Schema__Comm_8h_source.html#l00126">EXCHANGED</a>, <a class="el" href="Process_8cpp_source.html#l00117">Process::me()</a>, <a class="el" href="Schema__Comm_8h_source.html#l00133">me_to_me_</a>, <a class="el" href="O__U__Ptr_8cpp_source.html#l00098">O_U_Ptr::non_nul()</a>, <a class="el" href="Schema__Comm_8cpp_source.html#l00040">obuffer()</a>, <a class="el" href="Schema__Comm_8h_source.html#l00132">recv_pe_list_</a>, <a class="el" href="Schema__Comm_8h_source.html#l00134">ref_group_</a>, <a class="el" href="Schema__Comm_8h_source.html#l00126">RESET</a>, <a class="el" href="Schema__Comm_8h_source.html#l00131">send_pe_list_</a>, <a class="el" href="ArrOfInt_8h_source.html#l00342">ArrOfInt::size_array()</a>, <a class="el" href="Schema__Comm_8h_source.html#l00127">status_</a>, and <a class="el" href="Ref__Comm__Group_8h_source.html#l00029">Ref_Comm_Group::valeur()</a>.</p>

<p>Referenced by <a class="el" href="Echange__contact__Correlation__VEF_8cpp_source.html#l00382">Echange_contact_Correlation_VEF::calculer_CL()</a>, <a class="el" href="Scatter_8cpp_source.html#l00937">Scatter::calculer_espace_distant()</a>, <a class="el" href="Scatter_8cpp_source.html#l02184">Scatter::calculer_espace_distant_elements()</a>, <a class="el" href="Scatter_8cpp_source.html#l02864">Scatter::calculer_nb_items_virtuels()</a>, <a class="el" href="Scatter_8cpp_source.html#l01353">Scatter::calculer_renum_items_communs()</a>, <a class="el" href="Scatter_8cpp_source.html#l00297">Scatter::check_consistancy_remote_items()</a>, <a class="el" href="Scatter_8cpp_source.html#l02653">Scatter::construire_correspondance_items_par_coordonnees()</a>, <a class="el" href="Faces__builder_8cpp_source.html#l00940">Zone::creer_aretes()</a>, <a class="el" href="MD__Vector__tools_8cpp_source.html#l00341">creer_md_vect_renum()</a>, <a class="el" href="communications_8cpp_source.html#l00427">envoyer_all_to_all_()</a>, <a class="el" href="MaillerParallel_8cpp_source.html#l00232">find_matching_coordinates()</a>, <a class="el" href="Raffiner__isotrope__parallele_8cpp_source.html#l00055">mon_construire_correspondance_items_par_coordonnees()</a>, <a class="el" href="Scatter_8cpp_source.html#l01807">Scatter::reordonner_faces_de_joint()</a>, <a class="el" href="Raccord__distant__homogene_8cpp_source.html#l00121">Raccord_distant_homogene::trace_elem_distant()</a>, and <a class="el" href="Raccord__distant__homogene_8cpp_source.html#l00167">Raccord_distant_homogene::trace_face_distant()</a>.</p>
<div class="fragment"><pre class="fragment">{
  assert(<a class="code" href="classSchema__Comm.html#ae56acaadf7a079ce874be628491593cb">status_</a> == <a class="code" href="classSchema__Comm.html#a513eef36a4603d995f2a04f166812470a40b4132b151da7359211aad2f3682c9f">EXCHANGED</a> &amp;&amp; <a class="code" href="classSchema__Comm.html#adcd2cdb2d6ce76883858c8f6078fda56" title="Groupe de processeurs qui vont discuter.">ref_group_</a>.<a class="code" href="classO__U__Ptr.html#a16f216b2d169e885876419182658ddcc" title="Renvoie 1 si le pointeur est non_nul Renvoie 0 sinon.">non_nul</a>());
  <span class="keyword">const</span> <a class="code" href="classComm__Group.html" title=": Cette classe decrit un groupe de processeurs sur lesquels une portion de code s&#39;execute simultaneme...">Comm_Group</a>&amp; group = <a class="code" href="classSchema__Comm.html#adcd2cdb2d6ce76883858c8f6078fda56" title="Groupe de processeurs qui vont discuter.">ref_group_</a>.<a class="code" href="classRef__Comm__Group.html#a46f3361cb566b4a386f75f7f9570fe9a">valeur</a>();
  assert(&amp;group == &amp;<a class="code" href="classPE__Groups.html#ae6ca0277a58f2ab34ebfb3216578fa75" title="renvoie une reference au groupe de processeurs actif courant">PE_Groups::current_group</a>());

<span class="comment">// On verifie que tous les membres du groupe executent ceci.</span>
<span class="comment">// Si ca plante ici, c&#39;est que tous les membres declares ne sont</span>
<span class="comment">// pas en train de faire la barriere.</span>
  <span class="keywordflow">if</span> (group.check_enabled()) group.barrier(<a class="code" href="Schema__Comm_8cpp.html#aad8b15298bcd90d51ca68c28f25a4fbf">END_COMM_TAG</a>);

  <span class="keywordtype">int</span> i, n;
  n = <a class="code" href="classSchema__Comm.html#a93eb7538476fa54ade96e88294feec8e" title="Liste des processeurs a qui envoyer.">send_pe_list_</a>.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>();
  <span class="keywordflow">for</span> (i = 0; i &lt; n; i++)
    {
      <span class="keywordtype">int</span> pe = <a class="code" href="classSchema__Comm.html#a93eb7538476fa54ade96e88294feec8e" title="Liste des processeurs a qui envoyer.">send_pe_list_</a>[i];
      <a class="code" href="classSchema__Comm.html#a734080d1326e58abdc5731d1b3486d4b" title="Accesseur a un membre du tableau obuffers_ (avec verification)">obuffer</a>(pe).<a class="code" href="classOutputCommBuffer.html#a4a00e5a4325c667529c26a227ec269e7">clear</a>();
    }
  n = <a class="code" href="classSchema__Comm.html#a24918eceb0ce15a6dae5a5a833480246" title="Liste des processeurs de qui recevoir.">recv_pe_list_</a>.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>();
  <span class="keywordflow">for</span> (i = 0; i &lt; n; i++)
    {
      <span class="keywordtype">int</span> pe = <a class="code" href="classSchema__Comm.html#a24918eceb0ce15a6dae5a5a833480246" title="Liste des processeurs de qui recevoir.">recv_pe_list_</a>[i];
      <a class="code" href="classSchema__Comm.html#a0955c141014893e559b831ae33d55d56" title="Accesseur a un membre du tableau ebuffers_ (avec verification)">ebuffer</a>(pe).<a class="code" href="classInputCommBuffer.html#a4df9114080cacee52c46a14ad052509a">clear</a>();
    }

  <span class="keywordflow">if</span> (<a class="code" href="classSchema__Comm.html#aaa55ab78220cfcca058cf54a7ac14cc0" title="Drapeau: est-ce qu&#39;on autorise a s&#39;envoyer des messages a soi ?">me_to_me_</a>)
    {
      <span class="keywordtype">int</span> pe = <a class="code" href="classProcess.html#ab55ba07167ec807ed3a145cac0f5dca4" title="renvoie mon rang dans le groupe de communication courant. Voir Comm_Group::rank() et PE_Groups::curre...">Process::me</a>();
      <a class="code" href="classSchema__Comm.html#a734080d1326e58abdc5731d1b3486d4b" title="Accesseur a un membre du tableau obuffers_ (avec verification)">obuffer</a>(pe).<a class="code" href="classOutputCommBuffer.html#a4a00e5a4325c667529c26a227ec269e7">clear</a>();
      <a class="code" href="classSchema__Comm.html#a0955c141014893e559b831ae33d55d56" title="Accesseur a un membre du tableau ebuffers_ (avec verification)">ebuffer</a>(pe).<a class="code" href="classInputCommBuffer.html#a4df9114080cacee52c46a14ad052509a">clear</a>();
    }

  <a class="code" href="classSchema__Comm.html#ae56acaadf7a079ce874be628491593cb">status_</a> = <a class="code" href="classSchema__Comm.html#a513eef36a4603d995f2a04f166812470a79ffb1835b68257288b75f8fbcb65178">RESET</a>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="af18c96784f01b84237cae0327a175fcf"></a><!-- doxytag: member="Schema_Comm::get_group" ref="af18c96784f01b84237cae0327a175fcf" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classComm__Group.html">Comm_Group</a> &amp; Schema_Comm::get_group </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Renvoie le groupe auquel est associe le schema. </p>

<p>Definition at line <a class="el" href="Schema__Comm_8cpp_source.html#l00130">130</a> of file <a class="el" href="Schema__Comm_8cpp_source.html">Schema_Comm.cpp</a>.</p>

<p>References <a class="el" href="O__U__Ptr_8cpp_source.html#l00098">O_U_Ptr::non_nul()</a>, <a class="el" href="Schema__Comm_8h_source.html#l00134">ref_group_</a>, and <a class="el" href="Ref__Comm__Group_8h_source.html#l00029">Ref_Comm_Group::valeur()</a>.</p>
<div class="fragment"><pre class="fragment">{
  assert(<a class="code" href="classSchema__Comm.html#adcd2cdb2d6ce76883858c8f6078fda56" title="Groupe de processeurs qui vont discuter.">ref_group_</a>.<a class="code" href="classO__U__Ptr.html#a16f216b2d169e885876419182658ddcc" title="Renvoie 1 si le pointeur est non_nul Renvoie 0 sinon.">non_nul</a>());
  <span class="keywordflow">return</span> <a class="code" href="classSchema__Comm.html#adcd2cdb2d6ce76883858c8f6078fda56" title="Groupe de processeurs qui vont discuter.">ref_group_</a>.<a class="code" href="classRef__Comm__Group.html#a46f3361cb566b4a386f75f7f9570fe9a">valeur</a>();
}
</pre></div>
</div>
</div>
<a class="anchor" id="abfde4d298c654f11891abfc3120be8fd"></a><!-- doxytag: member="Schema_Comm::get_recv_pe_list" ref="abfde4d298c654f11891abfc3120be8fd" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp; Schema_Comm::get_recv_pe_list </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Schema__Comm_8cpp_source.html#l00514">514</a> of file <a class="el" href="Schema__Comm_8cpp_source.html">Schema_Comm.cpp</a>.</p>

<p>References <a class="el" href="O__U__Ptr_8cpp_source.html#l00098">O_U_Ptr::non_nul()</a>, <a class="el" href="Schema__Comm_8h_source.html#l00132">recv_pe_list_</a>, and <a class="el" href="Schema__Comm_8h_source.html#l00134">ref_group_</a>.</p>
<div class="fragment"><pre class="fragment">{
  assert(<a class="code" href="classSchema__Comm.html#adcd2cdb2d6ce76883858c8f6078fda56" title="Groupe de processeurs qui vont discuter.">ref_group_</a>.<a class="code" href="classO__U__Ptr.html#a16f216b2d169e885876419182658ddcc" title="Renvoie 1 si le pointeur est non_nul Renvoie 0 sinon.">non_nul</a>());
  <span class="keywordflow">return</span> <a class="code" href="classSchema__Comm.html#a24918eceb0ce15a6dae5a5a833480246" title="Liste des processeurs de qui recevoir.">recv_pe_list_</a>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="ad726332731df9b745cb6df8e1919d82a"></a><!-- doxytag: member="Schema_Comm::get_send_pe_list" ref="ad726332731df9b745cb6df8e1919d82a" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp; Schema_Comm::get_send_pe_list </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Schema__Comm_8cpp_source.html#l00508">508</a> of file <a class="el" href="Schema__Comm_8cpp_source.html">Schema_Comm.cpp</a>.</p>

<p>References <a class="el" href="O__U__Ptr_8cpp_source.html#l00098">O_U_Ptr::non_nul()</a>, <a class="el" href="Schema__Comm_8h_source.html#l00134">ref_group_</a>, and <a class="el" href="Schema__Comm_8h_source.html#l00131">send_pe_list_</a>.</p>
<div class="fragment"><pre class="fragment">{
  assert(<a class="code" href="classSchema__Comm.html#adcd2cdb2d6ce76883858c8f6078fda56" title="Groupe de processeurs qui vont discuter.">ref_group_</a>.<a class="code" href="classO__U__Ptr.html#a16f216b2d169e885876419182658ddcc" title="Renvoie 1 si le pointeur est non_nul Renvoie 0 sinon.">non_nul</a>());
  <span class="keywordflow">return</span> <a class="code" href="classSchema__Comm.html#a93eb7538476fa54ade96e88294feec8e" title="Liste des processeurs a qui envoyer.">send_pe_list_</a>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a734080d1326e58abdc5731d1b3486d4b"></a><!-- doxytag: member="Schema_Comm::obuffer" ref="a734080d1326e58abdc5731d1b3486d4b" args="(int pe)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOutputCommBuffer.html">OutputCommBuffer</a> &amp; Schema_Comm::obuffer </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pe</em></td><td>)</td>
          <td><code> [inline, static, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Accesseur a un membre du tableau obuffers_ (avec verification) </p>

<p>Definition at line <a class="el" href="Schema__Comm_8cpp_source.html#l00040">40</a> of file <a class="el" href="Schema__Comm_8cpp_source.html">Schema_Comm.cpp</a>.</p>

<p>References <a class="el" href="Schema__Comm_8h_source.html#l00141">buffers_</a>, <a class="el" href="Schema__Comm_8h_source.html#l00142">n_buffers_</a>, and <a class="el" href="InOutCommBuffers_8h_source.html#l00033">InOutCommBuffers::obuffers_</a>.</p>

<p>Referenced by <a class="el" href="Schema__Comm_8cpp_source.html#l00311">echange_messages()</a>, <a class="el" href="Schema__Comm_8cpp_source.html#l00380">echange_taille_et_messages()</a>, <a class="el" href="Schema__Comm_8cpp_source.html#l00430">end_comm()</a>, and <a class="el" href="Schema__Comm_8cpp_source.html#l00477">send_buffer()</a>.</p>
<div class="fragment"><pre class="fragment">{
  assert(pe &gt;= 0 &amp;&amp; pe &lt; <a class="code" href="classSchema__Comm.html#ac4ab50424d6aa29ac87103aa7690e203">n_buffers_</a>);
  <span class="keywordflow">return</span> <a class="code" href="classSchema__Comm.html#a6ce69882db45689247b677d5978d569e">buffers_</a>.<a class="code" href="classInOutCommBuffers.html#afb8912746dd19244b430fd26d874d5d4">obuffers_</a>[pe];
}
</pre></div>
</div>
</div>
<a class="anchor" id="a0963ab78f7c26d5fb8e25b1a657ea414"></a><!-- doxytag: member="Schema_Comm::operator=" ref="a0963ab78f7c26d5fb8e25b1a657ea414" args="(const Schema_Comm &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSchema__Comm.html">Schema_Comm</a> &amp; Schema_Comm::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSchema__Comm.html">Schema_Comm</a> &amp;&#160;</td>
          <td class="paramname"><em>schema</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><a class="el" href="classOperateur.html" title="classe Operateur Classe generique de la hierarchie des operateurs. Cette classe generique est particu...">Operateur</a> copie : on copie la liste des processeurs qui<br/>
communiquent. Le nouveau schema est place dans l'etat RESET.<br/>
Attention : tous les membres du <a class="el" href="classComm__Group.html" title=": Cette classe decrit un groupe de processeurs sur lesquels une portion de code s&#39;execute simultaneme...">Comm_Group</a> doivent executer<br/>
cette fonction simultanement. </p>

<p>Definition at line <a class="el" href="Schema__Comm_8cpp_source.html#l00103">103</a> of file <a class="el" href="Schema__Comm_8cpp_source.html">Schema_Comm.cpp</a>.</p>

<p>References <a class="el" href="classComm__Group.html#ac20236e71fc50066d225761ba1349c69">Comm_Group::barrier()</a>, <a class="el" href="Comm__Group_8h_source.html#l00143">Comm_Group::check_enabled()</a>, <a class="el" href="Schema__Comm_8cpp_source.html#l00058">COPY_OPERATOR_TAG</a>, <a class="el" href="PE__Groups_8h_source.html#l00054">PE_Groups::current_group()</a>, <a class="el" href="Schema__Comm_8h_source.html#l00133">me_to_me_</a>, <a class="el" href="Schema__Comm_8h_source.html#l00132">recv_pe_list_</a>, <a class="el" href="Schema__Comm_8h_source.html#l00134">ref_group_</a>, <a class="el" href="Schema__Comm_8h_source.html#l00126">RESET</a>, <a class="el" href="Schema__Comm_8h_source.html#l00131">send_pe_list_</a>, <a class="el" href="Schema__Comm_8h_source.html#l00127">status_</a>, <a class="el" href="Schema__Comm_8h_source.html#l00136">use_all_to_allv_</a>, and <a class="el" href="Ref__Comm__Group_8h_source.html#l00029">Ref_Comm_Group::valeur()</a>.</p>

<p>Referenced by <a class="el" href="Schema__Comm_8cpp_source.html#l00091">Schema_Comm()</a>.</p>
<div class="fragment"><pre class="fragment">{
  assert(<a class="code" href="classSchema__Comm.html#ae56acaadf7a079ce874be628491593cb">status_</a> == <a class="code" href="classSchema__Comm.html#a513eef36a4603d995f2a04f166812470a79ffb1835b68257288b75f8fbcb65178">RESET</a>);
  <a class="code" href="classSchema__Comm.html#adcd2cdb2d6ce76883858c8f6078fda56" title="Groupe de processeurs qui vont discuter.">ref_group_</a> = schema.<a class="code" href="classSchema__Comm.html#adcd2cdb2d6ce76883858c8f6078fda56" title="Groupe de processeurs qui vont discuter.">ref_group_</a>;
  assert(&amp;(<a class="code" href="classSchema__Comm.html#adcd2cdb2d6ce76883858c8f6078fda56" title="Groupe de processeurs qui vont discuter.">ref_group_</a>.<a class="code" href="classRef__Comm__Group.html#a46f3361cb566b4a386f75f7f9570fe9a">valeur</a>()) == &amp;<a class="code" href="classPE__Groups.html#ae6ca0277a58f2ab34ebfb3216578fa75" title="renvoie une reference au groupe de processeurs actif courant">PE_Groups::current_group</a>());
  <a class="code" href="classSchema__Comm.html#a93eb7538476fa54ade96e88294feec8e" title="Liste des processeurs a qui envoyer.">send_pe_list_</a> = schema.<a class="code" href="classSchema__Comm.html#a93eb7538476fa54ade96e88294feec8e" title="Liste des processeurs a qui envoyer.">send_pe_list_</a>;
  <a class="code" href="classSchema__Comm.html#a24918eceb0ce15a6dae5a5a833480246" title="Liste des processeurs de qui recevoir.">recv_pe_list_</a> = schema.<a class="code" href="classSchema__Comm.html#a24918eceb0ce15a6dae5a5a833480246" title="Liste des processeurs de qui recevoir.">recv_pe_list_</a>;
  <a class="code" href="classSchema__Comm.html#aaa55ab78220cfcca058cf54a7ac14cc0" title="Drapeau: est-ce qu&#39;on autorise a s&#39;envoyer des messages a soi ?">me_to_me_</a>     = schema.<a class="code" href="classSchema__Comm.html#aaa55ab78220cfcca058cf54a7ac14cc0" title="Drapeau: est-ce qu&#39;on autorise a s&#39;envoyer des messages a soi ?">me_to_me_</a>;
  <a class="code" href="classSchema__Comm.html#a88ddb051931c6d62f96d57ca2f79f7c1" title="Drapeau, quel type de communication faut-il utiliser ?">use_all_to_allv_</a> = schema.<a class="code" href="classSchema__Comm.html#a88ddb051931c6d62f96d57ca2f79f7c1" title="Drapeau, quel type de communication faut-il utiliser ?">use_all_to_allv_</a>;
  <span class="keyword">const</span> <a class="code" href="classComm__Group.html" title=": Cette classe decrit un groupe de processeurs sur lesquels une portion de code s&#39;execute simultaneme...">Comm_Group</a>&amp; group = <a class="code" href="classSchema__Comm.html#adcd2cdb2d6ce76883858c8f6078fda56" title="Groupe de processeurs qui vont discuter.">ref_group_</a>.<a class="code" href="classRef__Comm__Group.html#a46f3361cb566b4a386f75f7f9570fe9a">valeur</a>();
  <span class="keywordflow">if</span> (group.<a class="code" href="classComm__Group.html#a0f230fe65c9f52fd2a168a1ea70e7b15">check_enabled</a>()) group.<a class="code" href="classComm__Group.html#ac20236e71fc50066d225761ba1349c69">barrier</a>(<a class="code" href="Schema__Comm_8cpp.html#aeab2e35cc58325aa2499ebf416a90038">COPY_OPERATOR_TAG</a>);
  <span class="keywordflow">return</span> *<span class="keyword">this</span>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a0c056eb81ab8fd513912b336b4d13a1a"></a><!-- doxytag: member="Schema_Comm::recv_buffer" ref="a0c056eb81ab8fd513912b336b4d13a1a" args="(int num_PE) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEntree.html">Entree</a> &amp; Schema_Comm::recv_buffer </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_PE</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>renvoie le buffer correspondant au processeur num_PE pour<br/>
y lire les donnees recues. Le schema doit etre dans l'etat EXCHANGED. </p>

<p>Definition at line <a class="el" href="Schema__Comm_8cpp_source.html#l00494">494</a> of file <a class="el" href="Schema__Comm_8cpp_source.html">Schema_Comm.cpp</a>.</p>

<p>References <a class="el" href="Schema__Comm_8cpp_source.html#l00466">check_PE_in_list()</a>, <a class="el" href="Schema__Comm_8cpp_source.html#l00048">ebuffer()</a>, <a class="el" href="Schema__Comm_8h_source.html#l00126">EXCHANGED</a>, <a class="el" href="Process_8cpp_source.html#l00117">Process::me()</a>, <a class="el" href="Schema__Comm_8h_source.html#l00133">me_to_me_</a>, <a class="el" href="O__U__Ptr_8cpp_source.html#l00098">O_U_Ptr::non_nul()</a>, <a class="el" href="Schema__Comm_8h_source.html#l00132">recv_pe_list_</a>, <a class="el" href="Schema__Comm_8h_source.html#l00134">ref_group_</a>, and <a class="el" href="Schema__Comm_8h_source.html#l00127">status_</a>.</p>

<p>Referenced by <a class="el" href="Echange__contact__Correlation__VEF_8cpp_source.html#l00382">Echange_contact_Correlation_VEF::calculer_CL()</a>, <a class="el" href="Scatter_8cpp_source.html#l00937">Scatter::calculer_espace_distant()</a>, <a class="el" href="Scatter_8cpp_source.html#l02184">Scatter::calculer_espace_distant_elements()</a>, <a class="el" href="Scatter_8cpp_source.html#l02864">Scatter::calculer_nb_items_virtuels()</a>, <a class="el" href="Scatter_8cpp_source.html#l01353">Scatter::calculer_renum_items_communs()</a>, <a class="el" href="Scatter_8cpp_source.html#l00297">Scatter::check_consistancy_remote_items()</a>, <a class="el" href="Scatter_8cpp_source.html#l02653">Scatter::construire_correspondance_items_par_coordonnees()</a>, <a class="el" href="Faces__builder_8cpp_source.html#l00940">Zone::creer_aretes()</a>, <a class="el" href="MD__Vector__tools_8cpp_source.html#l00341">creer_md_vect_renum()</a>, <a class="el" href="communications_8cpp_source.html#l00427">envoyer_all_to_all_()</a>, <a class="el" href="MaillerParallel_8cpp_source.html#l00232">find_matching_coordinates()</a>, <a class="el" href="Raffiner__isotrope__parallele_8cpp_source.html#l00055">mon_construire_correspondance_items_par_coordonnees()</a>, <a class="el" href="Scatter_8cpp_source.html#l01807">Scatter::reordonner_faces_de_joint()</a>, <a class="el" href="Raccord__distant__homogene_8cpp_source.html#l00121">Raccord_distant_homogene::trace_elem_distant()</a>, and <a class="el" href="Raccord__distant__homogene_8cpp_source.html#l00167">Raccord_distant_homogene::trace_face_distant()</a>.</p>
<div class="fragment"><pre class="fragment">{
<span class="comment">// Si l&#39;assert suivant plante, c&#39;est qu&#39;on essaie de</span>
<span class="comment">// lire des donnees dans les buffers en dehors du bloc</span>
<span class="comment">// echange_xxx();</span>
<span class="comment">// ...</span>
<span class="comment">// end_comm();</span>
  assert(<a class="code" href="classSchema__Comm.html#ae56acaadf7a079ce874be628491593cb">status_</a> == <a class="code" href="classSchema__Comm.html#a513eef36a4603d995f2a04f166812470a40b4132b151da7359211aad2f3682c9f">EXCHANGED</a> &amp;&amp; <a class="code" href="classSchema__Comm.html#adcd2cdb2d6ce76883858c8f6078fda56" title="Groupe de processeurs qui vont discuter.">ref_group_</a>.<a class="code" href="classO__U__Ptr.html#a16f216b2d169e885876419182658ddcc" title="Renvoie 1 si le pointeur est non_nul Renvoie 0 sinon.">non_nul</a>());
<span class="comment">// On verifie que le PE demande est bien dans la liste</span>
<span class="comment">// des PEs declares en reception.</span>
  assert((<a class="code" href="classSchema__Comm.html#aaa55ab78220cfcca058cf54a7ac14cc0" title="Drapeau: est-ce qu&#39;on autorise a s&#39;envoyer des messages a soi ?">me_to_me_</a>&amp;&amp;num_PE==<a class="code" href="classProcess.html#ab55ba07167ec807ed3a145cac0f5dca4" title="renvoie mon rang dans le groupe de communication courant. Voir Comm_Group::rank() et PE_Groups::curre...">Process::me</a>()) || <a class="code" href="Schema__Comm_8cpp.html#a7014965a679ba90a3e95e5ef0f66f002">check_PE_in_list</a>(num_PE, <a class="code" href="classSchema__Comm.html#a24918eceb0ce15a6dae5a5a833480246" title="Liste des processeurs de qui recevoir.">recv_pe_list_</a>));
  <span class="keywordflow">return</span> <a class="code" href="classSchema__Comm.html#a0955c141014893e559b831ae33d55d56" title="Accesseur a un membre du tableau ebuffers_ (avec verification)">ebuffer</a>(num_PE);
}
</pre></div>
</div>
</div>
<a class="anchor" id="a6c771eae3b46250ae0d2f0126a7d8065"></a><!-- doxytag: member="Schema_Comm::send_buffer" ref="a6c771eae3b46250ae0d2f0126a7d8065" args="(int num_PE) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSortie.html">Sortie</a> &amp; Schema_Comm::send_buffer </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_PE</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>renvoie le buffer correspondant au processeur num_PE pour<br/>
y entasser des donnees a envoyer. Le schema doit etre dans l'etat WRITING. </p>

<p><p>!&lt; echange_xxx(); </p>
</p>

<p>Definition at line <a class="el" href="Schema__Comm_8cpp_source.html#l00477">477</a> of file <a class="el" href="Schema__Comm_8cpp_source.html">Schema_Comm.cpp</a>.</p>

<p>References <a class="el" href="Schema__Comm_8cpp_source.html#l00466">check_PE_in_list()</a>, <a class="el" href="Process_8cpp_source.html#l00117">Process::me()</a>, <a class="el" href="Schema__Comm_8h_source.html#l00133">me_to_me_</a>, <a class="el" href="O__U__Ptr_8cpp_source.html#l00098">O_U_Ptr::non_nul()</a>, <a class="el" href="Schema__Comm_8cpp_source.html#l00040">obuffer()</a>, <a class="el" href="Schema__Comm_8h_source.html#l00134">ref_group_</a>, <a class="el" href="Schema__Comm_8h_source.html#l00131">send_pe_list_</a>, <a class="el" href="Schema__Comm_8h_source.html#l00127">status_</a>, and <a class="el" href="Schema__Comm_8h_source.html#l00126">WRITING</a>.</p>

<p>Referenced by <a class="el" href="Echange__contact__Correlation__VEF_8cpp_source.html#l00382">Echange_contact_Correlation_VEF::calculer_CL()</a>, <a class="el" href="Scatter_8cpp_source.html#l00937">Scatter::calculer_espace_distant()</a>, <a class="el" href="Scatter_8cpp_source.html#l02184">Scatter::calculer_espace_distant_elements()</a>, <a class="el" href="Scatter_8cpp_source.html#l02864">Scatter::calculer_nb_items_virtuels()</a>, <a class="el" href="Scatter_8cpp_source.html#l01353">Scatter::calculer_renum_items_communs()</a>, <a class="el" href="Scatter_8cpp_source.html#l00297">Scatter::check_consistancy_remote_items()</a>, <a class="el" href="Scatter_8cpp_source.html#l02653">Scatter::construire_correspondance_items_par_coordonnees()</a>, <a class="el" href="Faces__builder_8cpp_source.html#l00940">Zone::creer_aretes()</a>, <a class="el" href="MD__Vector__tools_8cpp_source.html#l00341">creer_md_vect_renum()</a>, <a class="el" href="communications_8cpp_source.html#l00427">envoyer_all_to_all_()</a>, <a class="el" href="MaillerParallel_8cpp_source.html#l00232">find_matching_coordinates()</a>, <a class="el" href="Raffiner__isotrope__parallele_8cpp_source.html#l00055">mon_construire_correspondance_items_par_coordonnees()</a>, <a class="el" href="Scatter_8cpp_source.html#l01807">Scatter::reordonner_faces_de_joint()</a>, <a class="el" href="Raccord__distant__homogene_8cpp_source.html#l00121">Raccord_distant_homogene::trace_elem_distant()</a>, and <a class="el" href="Raccord__distant__homogene_8cpp_source.html#l00167">Raccord_distant_homogene::trace_face_distant()</a>.</p>
<div class="fragment"><pre class="fragment">{
<span class="comment">// Si l&#39;assert suivant plante, c&#39;est qu&#39;on essaie de</span>
<span class="comment">// mettre des donnees dans le buffer en dehors du bloc</span>
<span class="comment">// begin_comm();</span>
<span class="comment">// ...</span><span class="comment"></span>
<span class="comment">  ///!&lt;  echange_xxx();</span>
<span class="comment"></span>  assert(<a class="code" href="classSchema__Comm.html#ae56acaadf7a079ce874be628491593cb">status_</a> == <a class="code" href="classSchema__Comm.html#a513eef36a4603d995f2a04f166812470a218bae4e3cf445666fb4c8d08d055f0d">WRITING</a> &amp;&amp; <a class="code" href="classSchema__Comm.html#adcd2cdb2d6ce76883858c8f6078fda56" title="Groupe de processeurs qui vont discuter.">ref_group_</a>.<a class="code" href="classO__U__Ptr.html#a16f216b2d169e885876419182658ddcc" title="Renvoie 1 si le pointeur est non_nul Renvoie 0 sinon.">non_nul</a>());

<span class="comment">// On verifie que le PE demande est bien dans la liste</span>
<span class="comment">// des PEs declares en envoi.</span>
  assert((<a class="code" href="classSchema__Comm.html#aaa55ab78220cfcca058cf54a7ac14cc0" title="Drapeau: est-ce qu&#39;on autorise a s&#39;envoyer des messages a soi ?">me_to_me_</a>&amp;&amp;num_PE==<a class="code" href="classProcess.html#ab55ba07167ec807ed3a145cac0f5dca4" title="renvoie mon rang dans le groupe de communication courant. Voir Comm_Group::rank() et PE_Groups::curre...">Process::me</a>()) || <a class="code" href="Schema__Comm_8cpp.html#a7014965a679ba90a3e95e5ef0f66f002">check_PE_in_list</a>(num_PE, <a class="code" href="classSchema__Comm.html#a93eb7538476fa54ade96e88294feec8e" title="Liste des processeurs a qui envoyer.">send_pe_list_</a>));
  <span class="keywordflow">return</span> <a class="code" href="classSchema__Comm.html#a734080d1326e58abdc5731d1b3486d4b" title="Accesseur a un membre du tableau obuffers_ (avec verification)">obuffer</a>(num_PE);
}
</pre></div>
</div>
</div>
<a class="anchor" id="add07304686600c10515b483eef6b8a08"></a><!-- doxytag: member="Schema_Comm::set_all_to_allv_flag" ref="add07304686600c10515b483eef6b8a08" args="(int x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Schema_Comm::set_all_to_allv_flag </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Schema__Comm_8h_source.html#l00111">111</a> of file <a class="el" href="Schema__Comm_8h_source.html">Schema_Comm.h</a>.</p>

<p>References <a class="el" href="Schema__Comm_8h_source.html#l00136">use_all_to_allv_</a>.</p>
<div class="fragment"><pre class="fragment">  {
    <a class="code" href="classSchema__Comm.html#a88ddb051931c6d62f96d57ca2f79f7c1" title="Drapeau, quel type de communication faut-il utiliser ?">use_all_to_allv_</a> = x;
  }
</pre></div>
</div>
</div>
<a class="anchor" id="a46dd131a48e83d289e078f163e7f5c9d"></a><!-- doxytag: member="Schema_Comm::set_group" ref="a46dd131a48e83d289e078f163e7f5c9d" args="(const Comm_Group &amp;group)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Schema_Comm::set_group </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classComm__Group.html">Comm_Group</a> &amp;&#160;</td>
          <td class="paramname"><em>group</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Obsolete. </p>
<p>Methode obsolete, le groupe associe au schema est le groupe<br/>
courant au moment ou on cree le schema. L'appel a cette methode<br/>
n'est valide qu'avec le meme groupe que le groupe d'origine.<br/>
La methode ne fait rien. </p>

<p>Definition at line <a class="el" href="Schema__Comm_8cpp_source.html#l00122">122</a> of file <a class="el" href="Schema__Comm_8cpp_source.html">Schema_Comm.cpp</a>.</p>

<p>References <a class="el" href="PE__Groups_8h_source.html#l00054">PE_Groups::current_group()</a>, <a class="el" href="Schema__Comm_8h_source.html#l00134">ref_group_</a>, and <a class="el" href="Ref__Comm__Group_8h_source.html#l00029">Ref_Comm_Group::valeur()</a>.</p>
<div class="fragment"><pre class="fragment">{
  assert(&amp;group == &amp;(<a class="code" href="classSchema__Comm.html#adcd2cdb2d6ce76883858c8f6078fda56" title="Groupe de processeurs qui vont discuter.">ref_group_</a>.<a class="code" href="classRef__Comm__Group.html#a46f3361cb566b4a386f75f7f9570fe9a">valeur</a>()));
  assert(&amp;group == &amp;<a class="code" href="classPE__Groups.html#ae6ca0277a58f2ab34ebfb3216578fa75" title="renvoie une reference au groupe de processeurs actif courant">PE_Groups::current_group</a>());
}
</pre></div>
</div>
</div>
<a class="anchor" id="ad11c9b47999c294c26ae4df8d2bbd57b"></a><!-- doxytag: member="Schema_Comm::set_send_recv_pe_list" ref="ad11c9b47999c294c26ae4df8d2bbd57b" args="(const ArrOfInt &amp;send_pe_list, const ArrOfInt &amp;recv_pe_list, const int me_to_me=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Schema_Comm::set_send_recv_pe_list </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>send_pe_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>recv_pe_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>me_to_me</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definit la liste des processeurs a qui on va envoyer<br/>
et de qui on va recevoir des donnees.<br/>
Si me_to_me est non nul, on autorise l'envoi des messages a soi-meme,<br/>
sinon non (argument optionnel : par defaut, me_to_me=0) </p>

<p>Definition at line <a class="el" href="Schema__Comm_8cpp_source.html#l00146">146</a> of file <a class="el" href="Schema__Comm_8cpp_source.html">Schema_Comm.cpp</a>.</p>

<p>References <a class="el" href="Comm__Group_8h_source.html#l00143">Comm_Group::check_enabled()</a>, <a class="el" href="Schema__Comm_8cpp_source.html#l00549">check_send_recv_pe_list()</a>, <a class="el" href="PE__Groups_8h_source.html#l00054">PE_Groups::current_group()</a>, <a class="el" href="Schema__Comm_8h_source.html#l00133">me_to_me_</a>, <a class="el" href="Schema__Comm_8h_source.html#l00132">recv_pe_list_</a>, <a class="el" href="Schema__Comm_8h_source.html#l00134">ref_group_</a>, <a class="el" href="Schema__Comm_8h_source.html#l00126">RESET</a>, <a class="el" href="Schema__Comm_8h_source.html#l00131">send_pe_list_</a>, <a class="el" href="Schema__Comm_8h_source.html#l00127">status_</a>, and <a class="el" href="Ref__Comm__Group_8h_source.html#l00029">Ref_Comm_Group::valeur()</a>.</p>

<p>Referenced by <a class="el" href="Echange__contact__Correlation__VEF_8cpp_source.html#l00382">Echange_contact_Correlation_VEF::calculer_CL()</a>, <a class="el" href="Scatter_8cpp_source.html#l00937">Scatter::calculer_espace_distant()</a>, <a class="el" href="Scatter_8cpp_source.html#l02184">Scatter::calculer_espace_distant_elements()</a>, <a class="el" href="Scatter_8cpp_source.html#l02864">Scatter::calculer_nb_items_virtuels()</a>, <a class="el" href="Scatter_8cpp_source.html#l01353">Scatter::calculer_renum_items_communs()</a>, <a class="el" href="Scatter_8cpp_source.html#l00297">Scatter::check_consistancy_remote_items()</a>, <a class="el" href="Scatter_8cpp_source.html#l02653">Scatter::construire_correspondance_items_par_coordonnees()</a>, <a class="el" href="Faces__builder_8cpp_source.html#l00940">Zone::creer_aretes()</a>, <a class="el" href="MD__Vector__tools_8cpp_source.html#l00341">creer_md_vect_renum()</a>, <a class="el" href="communications_8cpp_source.html#l00427">envoyer_all_to_all_()</a>, <a class="el" href="MaillerParallel_8cpp_source.html#l00232">find_matching_coordinates()</a>, <a class="el" href="Raffiner__isotrope__parallele_8cpp_source.html#l00055">mon_construire_correspondance_items_par_coordonnees()</a>, <a class="el" href="Scatter_8cpp_source.html#l01807">Scatter::reordonner_faces_de_joint()</a>, <a class="el" href="Raccord__distant__homogene_8cpp_source.html#l00121">Raccord_distant_homogene::trace_elem_distant()</a>, and <a class="el" href="Raccord__distant__homogene_8cpp_source.html#l00167">Raccord_distant_homogene::trace_face_distant()</a>.</p>
<div class="fragment"><pre class="fragment">{
  assert(<a class="code" href="classSchema__Comm.html#ae56acaadf7a079ce874be628491593cb">status_</a> == <a class="code" href="classSchema__Comm.html#a513eef36a4603d995f2a04f166812470a79ffb1835b68257288b75f8fbcb65178">RESET</a>);
  <a class="code" href="classSchema__Comm.html#a93eb7538476fa54ade96e88294feec8e" title="Liste des processeurs a qui envoyer.">send_pe_list_</a> = send_pe_list;
  <a class="code" href="classSchema__Comm.html#a24918eceb0ce15a6dae5a5a833480246" title="Liste des processeurs de qui recevoir.">recv_pe_list_</a> = recv_pe_list;
  <a class="code" href="classSchema__Comm.html#aaa55ab78220cfcca058cf54a7ac14cc0" title="Drapeau: est-ce qu&#39;on autorise a s&#39;envoyer des messages a soi ?">me_to_me_</a> = me_to_me;
<span class="comment">// Verification du principe &quot;tu m&#39;ecoutes quand je te parle&quot;</span>
  <span class="keyword">const</span> <a class="code" href="classComm__Group.html" title=": Cette classe decrit un groupe de processeurs sur lesquels une portion de code s&#39;execute simultaneme...">Comm_Group</a>&amp; group = <a class="code" href="classSchema__Comm.html#adcd2cdb2d6ce76883858c8f6078fda56" title="Groupe de processeurs qui vont discuter.">ref_group_</a>.<a class="code" href="classRef__Comm__Group.html#a46f3361cb566b4a386f75f7f9570fe9a">valeur</a>();
  assert(&amp;group == &amp;<a class="code" href="classPE__Groups.html#ae6ca0277a58f2ab34ebfb3216578fa75" title="renvoie une reference au groupe de processeurs actif courant">PE_Groups::current_group</a>());
  <span class="keywordflow">if</span> (group.<a class="code" href="classComm__Group.html#a0f230fe65c9f52fd2a168a1ea70e7b15">check_enabled</a>()) <a class="code" href="classSchema__Comm.html#a10b238ae8ba1d3f6ed955fa7164c93ce" title="Verifie que les send/recv_pe_list verifient la propriete &quot;tu m&#39;ecoutes quand je te parle&quot;...">check_send_recv_pe_list</a>();
}
</pre></div>
</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="a6ce69882db45689247b677d5978d569e"></a><!-- doxytag: member="Schema_Comm::buffers_" ref="a6ce69882db45689247b677d5978d569e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classInOutCommBuffers.html">InOutCommBuffers</a> <a class="el" href="classSchema__Comm.html#a6ce69882db45689247b677d5978d569e">Schema_Comm::buffers_</a><code> [static, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Schema__Comm_8h_source.html#l00141">141</a> of file <a class="el" href="Schema__Comm_8h_source.html">Schema_Comm.h</a>.</p>

<p>Referenced by <a class="el" href="Schema__Comm_8cpp_source.html#l00048">ebuffer()</a>, <a class="el" href="Schema__Comm_8cpp_source.html#l00040">obuffer()</a>, and <a class="el" href="Schema__Comm_8cpp_source.html#l00063">Schema_Comm()</a>.</p>

</div>
</div>
<a class="anchor" id="aaa55ab78220cfcca058cf54a7ac14cc0"></a><!-- doxytag: member="Schema_Comm::me_to_me_" ref="aaa55ab78220cfcca058cf54a7ac14cc0" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classSchema__Comm.html#aaa55ab78220cfcca058cf54a7ac14cc0">Schema_Comm::me_to_me_</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Drapeau: est-ce qu'on autorise a s'envoyer des messages a soi ? </p>

<p>Definition at line <a class="el" href="Schema__Comm_8h_source.html#l00133">133</a> of file <a class="el" href="Schema__Comm_8h_source.html">Schema_Comm.h</a>.</p>

<p>Referenced by <a class="el" href="Schema__Comm_8cpp_source.html#l00311">echange_messages()</a>, <a class="el" href="Schema__Comm_8cpp_source.html#l00430">end_comm()</a>, <a class="el" href="Schema__Comm_8cpp_source.html#l00103">operator=()</a>, <a class="el" href="Schema__Comm_8cpp_source.html#l00494">recv_buffer()</a>, <a class="el" href="Schema__Comm_8cpp_source.html#l00063">Schema_Comm()</a>, <a class="el" href="Schema__Comm_8cpp_source.html#l00477">send_buffer()</a>, and <a class="el" href="Schema__Comm_8cpp_source.html#l00146">set_send_recv_pe_list()</a>.</p>

</div>
</div>
<a class="anchor" id="ac4ab50424d6aa29ac87103aa7690e203"></a><!-- doxytag: member="Schema_Comm::n_buffers_" ref="ac4ab50424d6aa29ac87103aa7690e203" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classSchema__Comm.html#ac4ab50424d6aa29ac87103aa7690e203">Schema_Comm::n_buffers_</a> = 0<code> [static, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Schema__Comm_8h_source.html#l00142">142</a> of file <a class="el" href="Schema__Comm_8h_source.html">Schema_Comm.h</a>.</p>

<p>Referenced by <a class="el" href="Schema__Comm_8cpp_source.html#l00048">ebuffer()</a>, <a class="el" href="Schema__Comm_8cpp_source.html#l00040">obuffer()</a>, and <a class="el" href="Schema__Comm_8cpp_source.html#l00063">Schema_Comm()</a>.</p>

</div>
</div>
<a class="anchor" id="a24918eceb0ce15a6dae5a5a833480246"></a><!-- doxytag: member="Schema_Comm::recv_pe_list_" ref="a24918eceb0ce15a6dae5a5a833480246" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classArrOfInt.html">ArrOfInt</a> <a class="el" href="classSchema__Comm.html#a24918eceb0ce15a6dae5a5a833480246">Schema_Comm::recv_pe_list_</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Liste des processeurs de qui recevoir. </p>

<p>Definition at line <a class="el" href="Schema__Comm_8h_source.html#l00132">132</a> of file <a class="el" href="Schema__Comm_8h_source.html">Schema_Comm.h</a>.</p>

<p>Referenced by <a class="el" href="Schema__Comm_8cpp_source.html#l00549">check_send_recv_pe_list()</a>, <a class="el" href="Schema__Comm_8cpp_source.html#l00311">echange_messages()</a>, <a class="el" href="Schema__Comm_8cpp_source.html#l00261">echange_taille()</a>, <a class="el" href="Schema__Comm_8cpp_source.html#l00430">end_comm()</a>, <a class="el" href="Schema__Comm_8cpp_source.html#l00514">get_recv_pe_list()</a>, <a class="el" href="Schema__Comm_8cpp_source.html#l00103">operator=()</a>, <a class="el" href="Schema__Comm_8cpp_source.html#l00494">recv_buffer()</a>, <a class="el" href="Schema__Comm_8cpp_source.html#l00063">Schema_Comm()</a>, and <a class="el" href="Schema__Comm_8cpp_source.html#l00146">set_send_recv_pe_list()</a>.</p>

</div>
</div>
<a class="anchor" id="adcd2cdb2d6ce76883858c8f6078fda56"></a><!-- doxytag: member="Schema_Comm::ref_group_" ref="adcd2cdb2d6ce76883858c8f6078fda56" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRef__Comm__Group.html">Ref_Comm_Group</a> <a class="el" href="classSchema__Comm.html#adcd2cdb2d6ce76883858c8f6078fda56">Schema_Comm::ref_group_</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Groupe de processeurs qui vont discuter. </p>

<p>Definition at line <a class="el" href="Schema__Comm_8h_source.html#l00134">134</a> of file <a class="el" href="Schema__Comm_8h_source.html">Schema_Comm.h</a>.</p>

<p>Referenced by <a class="el" href="Schema__Comm_8cpp_source.html#l00166">begin_comm()</a>, <a class="el" href="Schema__Comm_8cpp_source.html#l00311">echange_messages()</a>, <a class="el" href="Schema__Comm_8cpp_source.html#l00261">echange_taille()</a>, <a class="el" href="Schema__Comm_8cpp_source.html#l00430">end_comm()</a>, <a class="el" href="Schema__Comm_8cpp_source.html#l00130">get_group()</a>, <a class="el" href="Schema__Comm_8cpp_source.html#l00514">get_recv_pe_list()</a>, <a class="el" href="Schema__Comm_8cpp_source.html#l00508">get_send_pe_list()</a>, <a class="el" href="Schema__Comm_8cpp_source.html#l00103">operator=()</a>, <a class="el" href="Schema__Comm_8cpp_source.html#l00494">recv_buffer()</a>, <a class="el" href="Schema__Comm_8cpp_source.html#l00063">Schema_Comm()</a>, <a class="el" href="Schema__Comm_8cpp_source.html#l00477">send_buffer()</a>, <a class="el" href="Schema__Comm_8cpp_source.html#l00122">set_group()</a>, and <a class="el" href="Schema__Comm_8cpp_source.html#l00146">set_send_recv_pe_list()</a>.</p>

</div>
</div>
<a class="anchor" id="a93eb7538476fa54ade96e88294feec8e"></a><!-- doxytag: member="Schema_Comm::send_pe_list_" ref="a93eb7538476fa54ade96e88294feec8e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classArrOfInt.html">ArrOfInt</a> <a class="el" href="classSchema__Comm.html#a93eb7538476fa54ade96e88294feec8e">Schema_Comm::send_pe_list_</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Liste des processeurs a qui envoyer. </p>

<p>Definition at line <a class="el" href="Schema__Comm_8h_source.html#l00131">131</a> of file <a class="el" href="Schema__Comm_8h_source.html">Schema_Comm.h</a>.</p>

<p>Referenced by <a class="el" href="Schema__Comm_8cpp_source.html#l00549">check_send_recv_pe_list()</a>, <a class="el" href="Schema__Comm_8cpp_source.html#l00311">echange_messages()</a>, <a class="el" href="Schema__Comm_8cpp_source.html#l00261">echange_taille()</a>, <a class="el" href="Schema__Comm_8cpp_source.html#l00380">echange_taille_et_messages()</a>, <a class="el" href="Schema__Comm_8cpp_source.html#l00430">end_comm()</a>, <a class="el" href="Schema__Comm_8cpp_source.html#l00508">get_send_pe_list()</a>, <a class="el" href="Schema__Comm_8cpp_source.html#l00103">operator=()</a>, <a class="el" href="Schema__Comm_8cpp_source.html#l00063">Schema_Comm()</a>, <a class="el" href="Schema__Comm_8cpp_source.html#l00477">send_buffer()</a>, and <a class="el" href="Schema__Comm_8cpp_source.html#l00146">set_send_recv_pe_list()</a>.</p>

</div>
</div>
<a class="anchor" id="ae56acaadf7a079ce874be628491593cb"></a><!-- doxytag: member="Schema_Comm::status_" ref="ae56acaadf7a079ce874be628491593cb" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSchema__Comm.html#a513eef36a4603d995f2a04f166812470">Schema_Comm::Static_Status</a> <a class="el" href="classSchema__Comm.html#ae56acaadf7a079ce874be628491593cb">Schema_Comm::status_</a> = UNINITIALIZED<code> [static, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Schema__Comm_8h_source.html#l00127">127</a> of file <a class="el" href="Schema__Comm_8h_source.html">Schema_Comm.h</a>.</p>

<p>Referenced by <a class="el" href="Schema__Comm_8cpp_source.html#l00166">begin_comm()</a>, <a class="el" href="Schema__Comm_8cpp_source.html#l00549">check_send_recv_pe_list()</a>, <a class="el" href="Schema__Comm_8cpp_source.html#l00311">echange_messages()</a>, <a class="el" href="Schema__Comm_8cpp_source.html#l00261">echange_taille()</a>, <a class="el" href="Schema__Comm_8cpp_source.html#l00430">end_comm()</a>, <a class="el" href="Schema__Comm_8cpp_source.html#l00537">Schema_Comm_statique::get_recv_size()</a>, <a class="el" href="Schema__Comm_8cpp_source.html#l00525">Schema_Comm_statique::get_send_size()</a>, <a class="el" href="Schema__Comm_8cpp_source.html#l00103">operator=()</a>, <a class="el" href="Schema__Comm_8cpp_source.html#l00494">recv_buffer()</a>, <a class="el" href="Schema__Comm_8cpp_source.html#l00063">Schema_Comm()</a>, <a class="el" href="Schema__Comm_8cpp_source.html#l00477">send_buffer()</a>, and <a class="el" href="Schema__Comm_8cpp_source.html#l00146">set_send_recv_pe_list()</a>.</p>

</div>
</div>
<a class="anchor" id="a88ddb051931c6d62f96d57ca2f79f7c1"></a><!-- doxytag: member="Schema_Comm::use_all_to_allv_" ref="a88ddb051931c6d62f96d57ca2f79f7c1" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classSchema__Comm.html#a88ddb051931c6d62f96d57ca2f79f7c1">Schema_Comm::use_all_to_allv_</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Drapeau, quel type de communication faut-il utiliser ? </p>

<p>Definition at line <a class="el" href="Schema__Comm_8h_source.html#l00136">136</a> of file <a class="el" href="Schema__Comm_8h_source.html">Schema_Comm.h</a>.</p>

<p>Referenced by <a class="el" href="Schema__Comm_8cpp_source.html#l00311">echange_messages()</a>, <a class="el" href="Schema__Comm_8cpp_source.html#l00261">echange_taille()</a>, <a class="el" href="Schema__Comm_8cpp_source.html#l00103">operator=()</a>, <a class="el" href="Schema__Comm_8cpp_source.html#l00063">Schema_Comm()</a>, and <a class="el" href="Schema__Comm_8h_source.html#l00111">set_all_to_allv_flag()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/Kernel/Utilitaires/<a class="el" href="Schema__Comm_8h_source.html">Schema_Comm.h</a></li>
<li>src/Kernel/Utilitaires/<a class="el" href="Schema__Comm_8cpp_source.html">Schema_Comm.cpp</a></li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Tue Dec 14 2021 19:37:50 for TRUST by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
