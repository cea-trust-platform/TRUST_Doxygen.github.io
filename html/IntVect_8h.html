<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>TRUST: src/Kernel/Math/IntVect.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">TRUST&#160;<span id="projectnumber">1.8.4</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">src/Kernel/Math/IntVect.h File Reference</div>  </div>
</div>
<div class="contents">
<div class="textblock"><code>#include &lt;<a class="el" href="ArrOfInt_8h_source.html">ArrOfInt.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="MD__Vector_8h_source.html">MD_Vector.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="Vect_8h_source.html">Vect.h</a>&gt;</code><br/>
</div>
<p><a href="IntVect_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIntVect.html">IntVect</a></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="IntVect_8h.html#ade146e7b644bec7ea5b5c6fcb88fe2a9">operator==</a> (const <a class="el" href="classIntVect.html">IntVect</a> &amp;x, const <a class="el" href="classIntVect.html">IntVect</a> &amp;y)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">renvoie 1 si meme strucuture parallele et egalite au sens ArrOfInt&lt;br&gt;(y compris espaces virtuels)<br/>
BM: faut-il etre aussi strict, comparer uniquement size() elements ?  <a href="#ade146e7b644bec7ea5b5c6fcb88fe2a9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="IntVect_8h.html#afe7b6a7310bafb543df557a0d845e3e4">operator!=</a> (const <a class="el" href="classIntVect.html">IntVect</a> &amp;x, const <a class="el" href="classIntVect.html">IntVect</a> &amp;y)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="IntVect_8h.html#a69535a3761a101f07e53c6220adac4cd">local_imax_vect</a> (const <a class="el" href="classIntVect.html">IntVect</a> &amp;, <a class="el" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a> opt=VECT_REAL_ITEMS)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="IntVect_8h.html#ae7d1d4d11a93db7bcf2428d38788553d">local_max_vect</a> (const <a class="el" href="classIntVect.html">IntVect</a> &amp;, <a class="el" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a> opt=VECT_REAL_ITEMS)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="IntVect_8h.html#a967b9d1d43d557d2ab906666a05c3099">local_imin_vect</a> (const <a class="el" href="classIntVect.html">IntVect</a> &amp;, <a class="el" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a> opt=VECT_REAL_ITEMS)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="IntVect_8h.html#a3cda383eecf0ea0519cb11987f9fce5e">local_min_vect</a> (const <a class="el" href="classIntVect.html">IntVect</a> &amp;, <a class="el" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a> opt=VECT_REAL_ITEMS)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="IntVect_8h.html#adb6b63e7fa7b169be86029fc51493793">mp_max_vect</a> (const <a class="el" href="classIntVect.html">IntVect</a> &amp;, <a class="el" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a> opt=VECT_REAL_ITEMS)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="IntVect_8h.html#a6787d511d688ba4941a9fbb18787d75d">mp_min_vect</a> (const <a class="el" href="classIntVect.html">IntVect</a> &amp;, <a class="el" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a> opt=VECT_REAL_ITEMS)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="IntVect_8h.html#abd3d03efd4dfe79d4427a77341ad3c21">mp_somme_vect</a> (const <a class="el" href="classIntVect.html">IntVect</a> &amp;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="IntVect_8h.html#a35c931134570ea73742fa28eb0d5f34a">local_max_abs_vect</a> (const <a class="el" href="classIntVect.html">IntVect</a> &amp;, <a class="el" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a> opt=VECT_REAL_ITEMS)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="IntVect_8h.html#a87d021db5f2c90270512a568dae8a01e">local_min_abs_vect</a> (const <a class="el" href="classIntVect.html">IntVect</a> &amp;, <a class="el" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a> opt=VECT_REAL_ITEMS)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="IntVect_8h.html#acf47aa167cf325d601eddab757fa3bc6">mp_max_abs_vect</a> (const <a class="el" href="classIntVect.html">IntVect</a> &amp;, <a class="el" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a> opt=VECT_REAL_ITEMS)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="IntVect_8h.html#a17751a9b8a8fcf035e8aeeeb6daf74af">mp_min_abs_vect</a> (const <a class="el" href="classIntVect.html">IntVect</a> &amp;, <a class="el" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a> opt=VECT_REAL_ITEMS)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="IntVect_8h.html#a4c1ae372f23a6533b404cda3b2e70750">operator_add</a> (<a class="el" href="classIntVect.html">IntVect</a> &amp;resu, const <a class="el" href="classIntVect.html">IntVect</a> &amp;vx, <a class="el" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a> opt=VECT_ALL_ITEMS)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="IntVect_8h.html#a2c8d82cd6f9fdf707cb798984d6b2652">operator_add</a> (<a class="el" href="classIntVect.html">IntVect</a> &amp;resu, const int x, <a class="el" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a> opt=VECT_ALL_ITEMS)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="IntVect_8h.html#a0fbb812621f4a0d626e259bcfe234600">operator_sub</a> (<a class="el" href="classIntVect.html">IntVect</a> &amp;resu, const <a class="el" href="classIntVect.html">IntVect</a> &amp;vx, <a class="el" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a> opt=VECT_ALL_ITEMS)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="IntVect_8h.html#a56f7235fca2df79d0bf1563d0bc791b0">operator_sub</a> (<a class="el" href="classIntVect.html">IntVect</a> &amp;resu, const int x, <a class="el" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a> opt=VECT_ALL_ITEMS)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="IntVect_8h.html#aadbda73d2d8148e99b76d78e05a47654">operator_multiply</a> (<a class="el" href="classIntVect.html">IntVect</a> &amp;resu, const <a class="el" href="classIntVect.html">IntVect</a> &amp;vx, <a class="el" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a> opt=VECT_ALL_ITEMS)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="IntVect_8h.html#a606127253c2071dfd904942efbda1e77">operator_multiply</a> (<a class="el" href="classIntVect.html">IntVect</a> &amp;resu, const int x, <a class="el" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a> opt=VECT_ALL_ITEMS)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="IntVect_8h.html#a1ca4f82f2c2b489d8fb24470b8153ce9">operator_negate</a> (<a class="el" href="classIntVect.html">IntVect</a> &amp;resu, <a class="el" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a> opt=VECT_ALL_ITEMS)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="IntVect_8h.html#ab1f1db27f3c98b231cec2f91a17ef7c4">operator_egal</a> (<a class="el" href="classIntVect.html">IntVect</a> &amp;resu, int x, <a class="el" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a> opt=VECT_ALL_ITEMS)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="IntVect_8h.html#a5db7389ddd1536051f718fd55a35c59d">operator_egal</a> (<a class="el" href="classIntVect.html">IntVect</a> &amp;resu, const <a class="el" href="classIntVect.html">IntVect</a> &amp;vx, <a class="el" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a> opt=VECT_ALL_ITEMS)</td></tr>
</table>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a69535a3761a101f07e53c6220adac4cd"></a><!-- doxytag: member="IntVect.h::local_imax_vect" ref="a69535a3761a101f07e53c6220adac4cd" args="(const IntVect &amp;, Mp_vect_options opt=VECT_REAL_ITEMS)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int local_imax_vect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIntVect.html">IntVect</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a>&#160;</td>
          <td class="paramname"><em>opt</em> = <code>VECT_REAL_ITEMS</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>&lt; this test is necessary if md is null </p>
</p>

<p>Definition at line <a class="el" href="IntVect_8cpp_source.html#l00704">704</a> of file <a class="el" href="IntVect_8cpp_source.html">IntVect.cpp</a>.</p>

<p>References <a class="el" href="ArrOfInt_8h_source.html#l00371">ArrOfInt::addr()</a>, <a class="el" href="classMD__Vector__base.html#a99334ac2566d9457c8d4890ba20883ea">MD_Vector_base::get_items_to_compute()</a>, <a class="el" href="classMD__Vector__base.html#a7f6b6d0b7babfec0cce590cdea5bca53">MD_Vector_base::get_items_to_sum()</a>, <a class="el" href="IntVect_8h_source.html#l00087">IntVect::get_md_vector()</a>, <a class="el" href="IntVect_8h_source.html#l00150">IntVect::line_size()</a>, <a class="el" href="MD__Vector_8h_source.html#l00063">MD_Vector::non_nul()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00342">ArrOfInt::size_array()</a>, <a class="el" href="IntVect_8h_source.html#l00145">IntVect::size_totale()</a>, <a class="el" href="MD__Vector_8h_source.html#l00067">MD_Vector::valeur()</a>, <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_ALL_ITEMS</a>, <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_REAL_ITEMS</a>, and <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_SEQUENTIAL_ITEMS</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">int</span> max_val = INT_MIN;;
  <span class="keywordtype">int</span> i_max = -1;
<span class="comment">// Master vect donne la structure de reference, les autres vecteurs</span>
<span class="comment">// doivent avoir la meme structure.</span>
  <span class="keyword">const</span> <a class="code" href="classIntVect.html">IntVect</a>&amp; master_vect = vx;
  <span class="keywordtype">int</span> line_size = master_vect.<a class="code" href="classIntVect.html#a5ba680066169c8e057bb3e3b876e4a8c">line_size</a>();
  <span class="keyword">const</span> <a class="code" href="classMD__Vector.html" title=": Cette classe est un DERIV mais l&#39;objet pointe est partage entre plusieurs instances de cette classe...">MD_Vector</a>&amp; md = master_vect.<a class="code" href="classIntVect.html#ae74e1fee6aca124d32718267e33a40c6">get_md_vector</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> vect_size_tot = master_vect.<a class="code" href="classIntVect.html#afa716e1f0a1f0f74f4f73e95b5651412" title="Identique a size_array()">size_totale</a>();
  assert(vx.line_size() == line_size);
  assert(vx.size_totale() == vect_size_tot); <span class="comment">//!&lt; this test is necessary if md is null</span>
<span class="comment"></span>  assert(vx.get_md_vector() == md);
<span class="comment">// Determine blocs of data to process, depending on &quot; opt&quot;</span>
  <span class="keywordtype">int</span> nblocs_left = 1;
  <span class="keywordtype">int</span> one_bloc[2];
  <span class="keyword">const</span> <span class="keywordtype">int</span> *bloc_ptr;
  <span class="keywordflow">if</span> ( opt != <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caad18680091a9f62247573cb3caa6450b9">VECT_ALL_ITEMS</a> &amp;&amp; md.<a class="code" href="classMD__Vector.html#a4165c00904b7096274e38fdc7ca340f4">non_nul</a>())
    {
      assert( opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a> ||  opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caab47906d8d2e6c20f8ba32e4acb6edbe0">VECT_REAL_ITEMS</a>);
      <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; items_blocs = ( opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a>) ? md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a7f6b6d0b7babfec0cce590cdea5bca53">get_items_to_sum</a>() : md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a99334ac2566d9457c8d4890ba20883ea">get_items_to_compute</a>();
      assert(items_blocs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() % 2 == 0);
      nblocs_left = items_blocs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() &gt;&gt; 1;
      bloc_ptr = items_blocs.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
    }
  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (vect_size_tot &gt; 0)
    {
<span class="comment">// attention, si vect_size_tot est nul, line_size a le droit d&#39;etre nul</span>
<span class="comment">// Compute all data, in the vector (including virtual data), build a big bloc:</span>
      nblocs_left = 1;
      bloc_ptr = one_bloc;
      one_bloc[0] = 0;
      one_bloc[1] = vect_size_tot / line_size;
    }
  <span class="keywordflow">else</span>
    {
<span class="comment">// raccourci pour les tableaux vides (evite le cas particulier line_size == 0)</span>
      <span class="keywordflow">return</span>  i_max;
    }
  <span class="keyword">const</span> <span class="keywordtype">int</span> *x_base = vx.addr();
  <span class="keywordflow">for</span> (; nblocs_left; nblocs_left--)
    {
<span class="comment">// Get index of next bloc start:</span>
      <span class="keyword">const</span> <span class="keywordtype">int</span> begin_bloc = (*(bloc_ptr++)) * line_size;
      <span class="keyword">const</span> <span class="keywordtype">int</span> end_bloc = (*(bloc_ptr++)) * line_size;
      assert(begin_bloc &gt;= 0 &amp;&amp; end_bloc &lt;= vect_size_tot &amp;&amp; end_bloc &gt;= begin_bloc);
      <span class="keyword">const</span> <span class="keywordtype">int</span>* x_ptr = x_base + begin_bloc;
      <span class="keywordtype">int</span> count = end_bloc - begin_bloc;
      <span class="keywordflow">for</span> (; count; count--)
        {
          <span class="keyword">const</span> <span class="keywordtype">int</span> x = *x_ptr;
          <span class="keywordflow">if</span> (x &gt; max_val) { i_max = x_ptr - x_base; max_val = x; }
          x_ptr++;
        }
    }
  <span class="keywordflow">return</span>  i_max;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a967b9d1d43d557d2ab906666a05c3099"></a><!-- doxytag: member="IntVect.h::local_imin_vect" ref="a967b9d1d43d557d2ab906666a05c3099" args="(const IntVect &amp;, Mp_vect_options opt=VECT_REAL_ITEMS)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int local_imin_vect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIntVect.html">IntVect</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a>&#160;</td>
          <td class="paramname"><em>opt</em> = <code>VECT_REAL_ITEMS</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>&lt; this test is necessary if md is null </p>
</p>

<p>Definition at line <a class="el" href="IntVect_8cpp_source.html#l00591">591</a> of file <a class="el" href="IntVect_8cpp_source.html">IntVect.cpp</a>.</p>

<p>References <a class="el" href="ArrOfInt_8h_source.html#l00371">ArrOfInt::addr()</a>, <a class="el" href="classMD__Vector__base.html#a99334ac2566d9457c8d4890ba20883ea">MD_Vector_base::get_items_to_compute()</a>, <a class="el" href="classMD__Vector__base.html#a7f6b6d0b7babfec0cce590cdea5bca53">MD_Vector_base::get_items_to_sum()</a>, <a class="el" href="IntVect_8h_source.html#l00087">IntVect::get_md_vector()</a>, <a class="el" href="IntVect_8h_source.html#l00150">IntVect::line_size()</a>, <a class="el" href="MD__Vector_8h_source.html#l00063">MD_Vector::non_nul()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00342">ArrOfInt::size_array()</a>, <a class="el" href="IntVect_8h_source.html#l00145">IntVect::size_totale()</a>, <a class="el" href="MD__Vector_8h_source.html#l00067">MD_Vector::valeur()</a>, <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_ALL_ITEMS</a>, <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_REAL_ITEMS</a>, and <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_SEQUENTIAL_ITEMS</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">int</span> min_val = INT_MAX;;
  <span class="keywordtype">int</span> i_min = -1;
<span class="comment">// Master vect donne la structure de reference, les autres vecteurs</span>
<span class="comment">// doivent avoir la meme structure.</span>
  <span class="keyword">const</span> <a class="code" href="classIntVect.html">IntVect</a>&amp; master_vect = vx;
  <span class="keywordtype">int</span> line_size = master_vect.<a class="code" href="classIntVect.html#a5ba680066169c8e057bb3e3b876e4a8c">line_size</a>();
  <span class="keyword">const</span> <a class="code" href="classMD__Vector.html" title=": Cette classe est un DERIV mais l&#39;objet pointe est partage entre plusieurs instances de cette classe...">MD_Vector</a>&amp; md = master_vect.<a class="code" href="classIntVect.html#ae74e1fee6aca124d32718267e33a40c6">get_md_vector</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> vect_size_tot = master_vect.<a class="code" href="classIntVect.html#afa716e1f0a1f0f74f4f73e95b5651412" title="Identique a size_array()">size_totale</a>();
  assert(vx.line_size() == line_size);
  assert(vx.size_totale() == vect_size_tot); <span class="comment">//!&lt; this test is necessary if md is null</span>
<span class="comment"></span>  assert(vx.get_md_vector() == md);
<span class="comment">// Determine blocs of data to process, depending on &quot; opt&quot;</span>
  <span class="keywordtype">int</span> nblocs_left = 1;
  <span class="keywordtype">int</span> one_bloc[2];
  <span class="keyword">const</span> <span class="keywordtype">int</span> *bloc_ptr;
  <span class="keywordflow">if</span> ( opt != <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caad18680091a9f62247573cb3caa6450b9">VECT_ALL_ITEMS</a> &amp;&amp; md.<a class="code" href="classMD__Vector.html#a4165c00904b7096274e38fdc7ca340f4">non_nul</a>())
    {
      assert( opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a> ||  opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caab47906d8d2e6c20f8ba32e4acb6edbe0">VECT_REAL_ITEMS</a>);
      <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; items_blocs = ( opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a>) ? md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a7f6b6d0b7babfec0cce590cdea5bca53">get_items_to_sum</a>() : md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a99334ac2566d9457c8d4890ba20883ea">get_items_to_compute</a>();
      assert(items_blocs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() % 2 == 0);
      nblocs_left = items_blocs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() &gt;&gt; 1;
      bloc_ptr = items_blocs.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
    }
  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (vect_size_tot &gt; 0)
    {
<span class="comment">// attention, si vect_size_tot est nul, line_size a le droit d&#39;etre nul</span>
<span class="comment">// Compute all data, in the vector (including virtual data), build a big bloc:</span>
      nblocs_left = 1;
      bloc_ptr = one_bloc;
      one_bloc[0] = 0;
      one_bloc[1] = vect_size_tot / line_size;
    }
  <span class="keywordflow">else</span>
    {
<span class="comment">// raccourci pour les tableaux vides (evite le cas particulier line_size == 0)</span>
      <span class="keywordflow">return</span>  i_min;
    }
  <span class="keyword">const</span> <span class="keywordtype">int</span> *x_base = vx.addr();
  <span class="keywordflow">for</span> (; nblocs_left; nblocs_left--)
    {
<span class="comment">// Get index of next bloc start:</span>
      <span class="keyword">const</span> <span class="keywordtype">int</span> begin_bloc = (*(bloc_ptr++)) * line_size;
      <span class="keyword">const</span> <span class="keywordtype">int</span> end_bloc = (*(bloc_ptr++)) * line_size;
      assert(begin_bloc &gt;= 0 &amp;&amp; end_bloc &lt;= vect_size_tot &amp;&amp; end_bloc &gt;= begin_bloc);
      <span class="keyword">const</span> <span class="keywordtype">int</span>* x_ptr = x_base + begin_bloc;
      <span class="keywordtype">int</span> count = end_bloc - begin_bloc;
      <span class="keywordflow">for</span> (; count; count--)
        {
          <span class="keyword">const</span> <span class="keywordtype">int</span> x = *x_ptr;
          <span class="keywordflow">if</span> (x &lt; min_val) { i_min = x_ptr - x_base; min_val = x; }
          x_ptr++;
        }
    }
  <span class="keywordflow">return</span>  i_min;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a35c931134570ea73742fa28eb0d5f34a"></a><!-- doxytag: member="IntVect.h::local_max_abs_vect" ref="a35c931134570ea73742fa28eb0d5f34a" args="(const IntVect &amp;, Mp_vect_options opt=VECT_REAL_ITEMS)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int local_max_abs_vect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIntVect.html">IntVect</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a>&#160;</td>
          <td class="paramname"><em>opt</em> = <code>VECT_REAL_ITEMS</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>&lt; this test is necessary if md is null </p>
</p>

<p>Definition at line <a class="el" href="IntVect_8cpp_source.html#l00817">817</a> of file <a class="el" href="IntVect_8cpp_source.html">IntVect.cpp</a>.</p>

<p>References <a class="el" href="ArrOfInt_8h_source.html#l00371">ArrOfInt::addr()</a>, <a class="el" href="classMD__Vector__base.html#a99334ac2566d9457c8d4890ba20883ea">MD_Vector_base::get_items_to_compute()</a>, <a class="el" href="classMD__Vector__base.html#a7f6b6d0b7babfec0cce590cdea5bca53">MD_Vector_base::get_items_to_sum()</a>, <a class="el" href="IntVect_8h_source.html#l00087">IntVect::get_md_vector()</a>, <a class="el" href="IntVect_8h_source.html#l00150">IntVect::line_size()</a>, <a class="el" href="MD__Vector_8h_source.html#l00063">MD_Vector::non_nul()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00342">ArrOfInt::size_array()</a>, <a class="el" href="IntVect_8h_source.html#l00145">IntVect::size_totale()</a>, <a class="el" href="MD__Vector_8h_source.html#l00067">MD_Vector::valeur()</a>, <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_ALL_ITEMS</a>, <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_REAL_ITEMS</a>, and <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_SEQUENTIAL_ITEMS</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">int</span> max_val = 0;
<span class="comment">// Master vect donne la structure de reference, les autres vecteurs</span>
<span class="comment">// doivent avoir la meme structure.</span>
  <span class="keyword">const</span> <a class="code" href="classIntVect.html">IntVect</a>&amp; master_vect = vx;
  <span class="keywordtype">int</span> line_size = master_vect.<a class="code" href="classIntVect.html#a5ba680066169c8e057bb3e3b876e4a8c">line_size</a>();
  <span class="keyword">const</span> <a class="code" href="classMD__Vector.html" title=": Cette classe est un DERIV mais l&#39;objet pointe est partage entre plusieurs instances de cette classe...">MD_Vector</a>&amp; md = master_vect.<a class="code" href="classIntVect.html#ae74e1fee6aca124d32718267e33a40c6">get_md_vector</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> vect_size_tot = master_vect.<a class="code" href="classIntVect.html#afa716e1f0a1f0f74f4f73e95b5651412" title="Identique a size_array()">size_totale</a>();
  assert(vx.line_size() == line_size);
  assert(vx.size_totale() == vect_size_tot); <span class="comment">//!&lt; this test is necessary if md is null</span>
<span class="comment"></span>  assert(vx.get_md_vector() == md);
<span class="comment">// Determine blocs of data to process, depending on &quot; opt&quot;</span>
  <span class="keywordtype">int</span> nblocs_left = 1;
  <span class="keywordtype">int</span> one_bloc[2];
  <span class="keyword">const</span> <span class="keywordtype">int</span> *bloc_ptr;
  <span class="keywordflow">if</span> ( opt != <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caad18680091a9f62247573cb3caa6450b9">VECT_ALL_ITEMS</a> &amp;&amp; md.<a class="code" href="classMD__Vector.html#a4165c00904b7096274e38fdc7ca340f4">non_nul</a>())
    {
      assert( opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a> ||  opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caab47906d8d2e6c20f8ba32e4acb6edbe0">VECT_REAL_ITEMS</a>);
      <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; items_blocs = ( opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a>) ? md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a7f6b6d0b7babfec0cce590cdea5bca53">get_items_to_sum</a>() : md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a99334ac2566d9457c8d4890ba20883ea">get_items_to_compute</a>();
      assert(items_blocs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() % 2 == 0);
      nblocs_left = items_blocs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() &gt;&gt; 1;
      bloc_ptr = items_blocs.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
    }
  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (vect_size_tot &gt; 0)
    {
<span class="comment">// attention, si vect_size_tot est nul, line_size a le droit d&#39;etre nul</span>
<span class="comment">// Compute all data, in the vector (including virtual data), build a big bloc:</span>
      nblocs_left = 1;
      bloc_ptr = one_bloc;
      one_bloc[0] = 0;
      one_bloc[1] = vect_size_tot / line_size;
    }
  <span class="keywordflow">else</span>
    {
<span class="comment">// raccourci pour les tableaux vides (evite le cas particulier line_size == 0)</span>
      <span class="keywordflow">return</span>  max_val;
    }
  <span class="keyword">const</span> <span class="keywordtype">int</span> *x_base = vx.addr();
  <span class="keywordflow">for</span> (; nblocs_left; nblocs_left--)
    {
<span class="comment">// Get index of next bloc start:</span>
      <span class="keyword">const</span> <span class="keywordtype">int</span> begin_bloc = (*(bloc_ptr++)) * line_size;
      <span class="keyword">const</span> <span class="keywordtype">int</span> end_bloc = (*(bloc_ptr++)) * line_size;
      assert(begin_bloc &gt;= 0 &amp;&amp; end_bloc &lt;= vect_size_tot &amp;&amp; end_bloc &gt;= begin_bloc);
      <span class="keyword">const</span> <span class="keywordtype">int</span>* x_ptr = x_base + begin_bloc;
      <span class="keywordtype">int</span> count = end_bloc - begin_bloc;
      <span class="keywordflow">for</span> (; count; count--)
        {
          <span class="keyword">const</span> <span class="keywordtype">int</span> x = *x_ptr;
          <span class="keywordtype">int</span> xx = abs(x);
          max_val = (xx &gt; max_val) ? xx : max_val;
          x_ptr++;
        }
    }
  <span class="keywordflow">return</span>  max_val;
}
</pre></div>
</div>
</div>
<a class="anchor" id="ae7d1d4d11a93db7bcf2428d38788553d"></a><!-- doxytag: member="IntVect.h::local_max_vect" ref="ae7d1d4d11a93db7bcf2428d38788553d" args="(const IntVect &amp;, Mp_vect_options opt=VECT_REAL_ITEMS)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int local_max_vect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIntVect.html">IntVect</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a>&#160;</td>
          <td class="paramname"><em>opt</em> = <code>VECT_REAL_ITEMS</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>&lt; this test is necessary if md is null </p>
</p>

<p>Definition at line <a class="el" href="IntVect_8cpp_source.html#l00761">761</a> of file <a class="el" href="IntVect_8cpp_source.html">IntVect.cpp</a>.</p>

<p>References <a class="el" href="ArrOfInt_8h_source.html#l00371">ArrOfInt::addr()</a>, <a class="el" href="classMD__Vector__base.html#a99334ac2566d9457c8d4890ba20883ea">MD_Vector_base::get_items_to_compute()</a>, <a class="el" href="classMD__Vector__base.html#a7f6b6d0b7babfec0cce590cdea5bca53">MD_Vector_base::get_items_to_sum()</a>, <a class="el" href="IntVect_8h_source.html#l00087">IntVect::get_md_vector()</a>, <a class="el" href="IntVect_8h_source.html#l00150">IntVect::line_size()</a>, <a class="el" href="MD__Vector_8h_source.html#l00063">MD_Vector::non_nul()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00342">ArrOfInt::size_array()</a>, <a class="el" href="IntVect_8h_source.html#l00145">IntVect::size_totale()</a>, <a class="el" href="MD__Vector_8h_source.html#l00067">MD_Vector::valeur()</a>, <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_ALL_ITEMS</a>, <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_REAL_ITEMS</a>, and <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_SEQUENTIAL_ITEMS</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">int</span> max_val = INT_MIN;;
<span class="comment">// Master vect donne la structure de reference, les autres vecteurs</span>
<span class="comment">// doivent avoir la meme structure.</span>
  <span class="keyword">const</span> <a class="code" href="classIntVect.html">IntVect</a>&amp; master_vect = vx;
  <span class="keywordtype">int</span> line_size = master_vect.<a class="code" href="classIntVect.html#a5ba680066169c8e057bb3e3b876e4a8c">line_size</a>();
  <span class="keyword">const</span> <a class="code" href="classMD__Vector.html" title=": Cette classe est un DERIV mais l&#39;objet pointe est partage entre plusieurs instances de cette classe...">MD_Vector</a>&amp; md = master_vect.<a class="code" href="classIntVect.html#ae74e1fee6aca124d32718267e33a40c6">get_md_vector</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> vect_size_tot = master_vect.<a class="code" href="classIntVect.html#afa716e1f0a1f0f74f4f73e95b5651412" title="Identique a size_array()">size_totale</a>();
  assert(vx.line_size() == line_size);
  assert(vx.size_totale() == vect_size_tot); <span class="comment">//!&lt; this test is necessary if md is null</span>
<span class="comment"></span>  assert(vx.get_md_vector() == md);
<span class="comment">// Determine blocs of data to process, depending on &quot; opt&quot;</span>
  <span class="keywordtype">int</span> nblocs_left = 1;
  <span class="keywordtype">int</span> one_bloc[2];
  <span class="keyword">const</span> <span class="keywordtype">int</span> *bloc_ptr;
  <span class="keywordflow">if</span> ( opt != <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caad18680091a9f62247573cb3caa6450b9">VECT_ALL_ITEMS</a> &amp;&amp; md.<a class="code" href="classMD__Vector.html#a4165c00904b7096274e38fdc7ca340f4">non_nul</a>())
    {
      assert( opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a> ||  opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caab47906d8d2e6c20f8ba32e4acb6edbe0">VECT_REAL_ITEMS</a>);
      <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; items_blocs = ( opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a>) ? md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a7f6b6d0b7babfec0cce590cdea5bca53">get_items_to_sum</a>() : md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a99334ac2566d9457c8d4890ba20883ea">get_items_to_compute</a>();
      assert(items_blocs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() % 2 == 0);
      nblocs_left = items_blocs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() &gt;&gt; 1;
      bloc_ptr = items_blocs.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
    }
  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (vect_size_tot &gt; 0)
    {
<span class="comment">// attention, si vect_size_tot est nul, line_size a le droit d&#39;etre nul</span>
<span class="comment">// Compute all data, in the vector (including virtual data), build a big bloc:</span>
      nblocs_left = 1;
      bloc_ptr = one_bloc;
      one_bloc[0] = 0;
      one_bloc[1] = vect_size_tot / line_size;
    }
  <span class="keywordflow">else</span>
    {
<span class="comment">// raccourci pour les tableaux vides (evite le cas particulier line_size == 0)</span>
      <span class="keywordflow">return</span>  max_val;
    }
  <span class="keyword">const</span> <span class="keywordtype">int</span> *x_base = vx.addr();
  <span class="keywordflow">for</span> (; nblocs_left; nblocs_left--)
    {
<span class="comment">// Get index of next bloc start:</span>
      <span class="keyword">const</span> <span class="keywordtype">int</span> begin_bloc = (*(bloc_ptr++)) * line_size;
      <span class="keyword">const</span> <span class="keywordtype">int</span> end_bloc = (*(bloc_ptr++)) * line_size;
      assert(begin_bloc &gt;= 0 &amp;&amp; end_bloc &lt;= vect_size_tot &amp;&amp; end_bloc &gt;= begin_bloc);
      <span class="keyword">const</span> <span class="keywordtype">int</span>* x_ptr = x_base + begin_bloc;
      <span class="keywordtype">int</span> count = end_bloc - begin_bloc;
      <span class="keywordflow">for</span> (; count; count--)
        {
          <span class="keyword">const</span> <span class="keywordtype">int</span> x = *x_ptr;
          max_val = (x &gt; max_val) ? x : max_val;
          x_ptr++;
        }
    }
  <span class="keywordflow">return</span>  max_val;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a87d021db5f2c90270512a568dae8a01e"></a><!-- doxytag: member="IntVect.h::local_min_abs_vect" ref="a87d021db5f2c90270512a568dae8a01e" args="(const IntVect &amp;, Mp_vect_options opt=VECT_REAL_ITEMS)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int local_min_abs_vect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIntVect.html">IntVect</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a>&#160;</td>
          <td class="paramname"><em>opt</em> = <code>VECT_REAL_ITEMS</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>&lt; this test is necessary if md is null </p>
</p>

<p>Definition at line <a class="el" href="IntVect_8cpp_source.html#l00874">874</a> of file <a class="el" href="IntVect_8cpp_source.html">IntVect.cpp</a>.</p>

<p>References <a class="el" href="ArrOfInt_8h_source.html#l00371">ArrOfInt::addr()</a>, <a class="el" href="classMD__Vector__base.html#a99334ac2566d9457c8d4890ba20883ea">MD_Vector_base::get_items_to_compute()</a>, <a class="el" href="classMD__Vector__base.html#a7f6b6d0b7babfec0cce590cdea5bca53">MD_Vector_base::get_items_to_sum()</a>, <a class="el" href="IntVect_8h_source.html#l00087">IntVect::get_md_vector()</a>, <a class="el" href="IntVect_8h_source.html#l00150">IntVect::line_size()</a>, <a class="el" href="MD__Vector_8h_source.html#l00063">MD_Vector::non_nul()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00342">ArrOfInt::size_array()</a>, <a class="el" href="IntVect_8h_source.html#l00145">IntVect::size_totale()</a>, <a class="el" href="MD__Vector_8h_source.html#l00067">MD_Vector::valeur()</a>, <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_ALL_ITEMS</a>, <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_REAL_ITEMS</a>, and <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_SEQUENTIAL_ITEMS</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">int</span> min_val = INT_MAX;;
<span class="comment">// Master vect donne la structure de reference, les autres vecteurs</span>
<span class="comment">// doivent avoir la meme structure.</span>
  <span class="keyword">const</span> <a class="code" href="classIntVect.html">IntVect</a>&amp; master_vect = vx;
  <span class="keywordtype">int</span> line_size = master_vect.<a class="code" href="classIntVect.html#a5ba680066169c8e057bb3e3b876e4a8c">line_size</a>();
  <span class="keyword">const</span> <a class="code" href="classMD__Vector.html" title=": Cette classe est un DERIV mais l&#39;objet pointe est partage entre plusieurs instances de cette classe...">MD_Vector</a>&amp; md = master_vect.<a class="code" href="classIntVect.html#ae74e1fee6aca124d32718267e33a40c6">get_md_vector</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> vect_size_tot = master_vect.<a class="code" href="classIntVect.html#afa716e1f0a1f0f74f4f73e95b5651412" title="Identique a size_array()">size_totale</a>();
  assert(vx.line_size() == line_size);
  assert(vx.size_totale() == vect_size_tot); <span class="comment">//!&lt; this test is necessary if md is null</span>
<span class="comment"></span>  assert(vx.get_md_vector() == md);
<span class="comment">// Determine blocs of data to process, depending on &quot; opt&quot;</span>
  <span class="keywordtype">int</span> nblocs_left = 1;
  <span class="keywordtype">int</span> one_bloc[2];
  <span class="keyword">const</span> <span class="keywordtype">int</span> *bloc_ptr;
  <span class="keywordflow">if</span> ( opt != <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caad18680091a9f62247573cb3caa6450b9">VECT_ALL_ITEMS</a> &amp;&amp; md.<a class="code" href="classMD__Vector.html#a4165c00904b7096274e38fdc7ca340f4">non_nul</a>())
    {
      assert( opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a> ||  opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caab47906d8d2e6c20f8ba32e4acb6edbe0">VECT_REAL_ITEMS</a>);
      <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; items_blocs = ( opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a>) ? md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a7f6b6d0b7babfec0cce590cdea5bca53">get_items_to_sum</a>() : md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a99334ac2566d9457c8d4890ba20883ea">get_items_to_compute</a>();
      assert(items_blocs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() % 2 == 0);
      nblocs_left = items_blocs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() &gt;&gt; 1;
      bloc_ptr = items_blocs.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
    }
  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (vect_size_tot &gt; 0)
    {
<span class="comment">// attention, si vect_size_tot est nul, line_size a le droit d&#39;etre nul</span>
<span class="comment">// Compute all data, in the vector (including virtual data), build a big bloc:</span>
      nblocs_left = 1;
      bloc_ptr = one_bloc;
      one_bloc[0] = 0;
      one_bloc[1] = vect_size_tot / line_size;
    }
  <span class="keywordflow">else</span>
    {
<span class="comment">// raccourci pour les tableaux vides (evite le cas particulier line_size == 0)</span>
      <span class="keywordflow">return</span>  min_val;
    }
  <span class="keyword">const</span> <span class="keywordtype">int</span> *x_base = vx.addr();
  <span class="keywordflow">for</span> (; nblocs_left; nblocs_left--)
    {
<span class="comment">// Get index of next bloc start:</span>
      <span class="keyword">const</span> <span class="keywordtype">int</span> begin_bloc = (*(bloc_ptr++)) * line_size;
      <span class="keyword">const</span> <span class="keywordtype">int</span> end_bloc = (*(bloc_ptr++)) * line_size;
      assert(begin_bloc &gt;= 0 &amp;&amp; end_bloc &lt;= vect_size_tot &amp;&amp; end_bloc &gt;= begin_bloc);
      <span class="keyword">const</span> <span class="keywordtype">int</span>* x_ptr = x_base + begin_bloc;
      <span class="keywordtype">int</span> count = end_bloc - begin_bloc;
      <span class="keywordflow">for</span> (; count; count--)
        {
          <span class="keyword">const</span> <span class="keywordtype">int</span> x = *x_ptr;
          <span class="keywordtype">int</span> xx = abs(x);
          min_val = (xx &lt; min_val) ? xx : min_val;
          x_ptr++;
        }
    }
  <span class="keywordflow">return</span>  min_val;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a3cda383eecf0ea0519cb11987f9fce5e"></a><!-- doxytag: member="IntVect.h::local_min_vect" ref="a3cda383eecf0ea0519cb11987f9fce5e" args="(const IntVect &amp;, Mp_vect_options opt=VECT_REAL_ITEMS)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int local_min_vect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIntVect.html">IntVect</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a>&#160;</td>
          <td class="paramname"><em>opt</em> = <code>VECT_REAL_ITEMS</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>&lt; this test is necessary if md is null </p>
</p>

<p>Definition at line <a class="el" href="IntVect_8cpp_source.html#l00648">648</a> of file <a class="el" href="IntVect_8cpp_source.html">IntVect.cpp</a>.</p>

<p>References <a class="el" href="ArrOfInt_8h_source.html#l00371">ArrOfInt::addr()</a>, <a class="el" href="classMD__Vector__base.html#a99334ac2566d9457c8d4890ba20883ea">MD_Vector_base::get_items_to_compute()</a>, <a class="el" href="classMD__Vector__base.html#a7f6b6d0b7babfec0cce590cdea5bca53">MD_Vector_base::get_items_to_sum()</a>, <a class="el" href="IntVect_8h_source.html#l00087">IntVect::get_md_vector()</a>, <a class="el" href="IntVect_8h_source.html#l00150">IntVect::line_size()</a>, <a class="el" href="MD__Vector_8h_source.html#l00063">MD_Vector::non_nul()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00342">ArrOfInt::size_array()</a>, <a class="el" href="IntVect_8h_source.html#l00145">IntVect::size_totale()</a>, <a class="el" href="MD__Vector_8h_source.html#l00067">MD_Vector::valeur()</a>, <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_ALL_ITEMS</a>, <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_REAL_ITEMS</a>, and <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_SEQUENTIAL_ITEMS</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">int</span> min_val = INT_MAX;;
<span class="comment">// Master vect donne la structure de reference, les autres vecteurs</span>
<span class="comment">// doivent avoir la meme structure.</span>
  <span class="keyword">const</span> <a class="code" href="classIntVect.html">IntVect</a>&amp; master_vect = vx;
  <span class="keywordtype">int</span> line_size = master_vect.<a class="code" href="classIntVect.html#a5ba680066169c8e057bb3e3b876e4a8c">line_size</a>();
  <span class="keyword">const</span> <a class="code" href="classMD__Vector.html" title=": Cette classe est un DERIV mais l&#39;objet pointe est partage entre plusieurs instances de cette classe...">MD_Vector</a>&amp; md = master_vect.<a class="code" href="classIntVect.html#ae74e1fee6aca124d32718267e33a40c6">get_md_vector</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> vect_size_tot = master_vect.<a class="code" href="classIntVect.html#afa716e1f0a1f0f74f4f73e95b5651412" title="Identique a size_array()">size_totale</a>();
  assert(vx.line_size() == line_size);
  assert(vx.size_totale() == vect_size_tot); <span class="comment">//!&lt; this test is necessary if md is null</span>
<span class="comment"></span>  assert(vx.get_md_vector() == md);
<span class="comment">// Determine blocs of data to process, depending on &quot; opt&quot;</span>
  <span class="keywordtype">int</span> nblocs_left = 1;
  <span class="keywordtype">int</span> one_bloc[2];
  <span class="keyword">const</span> <span class="keywordtype">int</span> *bloc_ptr;
  <span class="keywordflow">if</span> ( opt != <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caad18680091a9f62247573cb3caa6450b9">VECT_ALL_ITEMS</a> &amp;&amp; md.<a class="code" href="classMD__Vector.html#a4165c00904b7096274e38fdc7ca340f4">non_nul</a>())
    {
      assert( opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a> ||  opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caab47906d8d2e6c20f8ba32e4acb6edbe0">VECT_REAL_ITEMS</a>);
      <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; items_blocs = ( opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a>) ? md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a7f6b6d0b7babfec0cce590cdea5bca53">get_items_to_sum</a>() : md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a99334ac2566d9457c8d4890ba20883ea">get_items_to_compute</a>();
      assert(items_blocs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() % 2 == 0);
      nblocs_left = items_blocs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() &gt;&gt; 1;
      bloc_ptr = items_blocs.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
    }
  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (vect_size_tot &gt; 0)
    {
<span class="comment">// attention, si vect_size_tot est nul, line_size a le droit d&#39;etre nul</span>
<span class="comment">// Compute all data, in the vector (including virtual data), build a big bloc:</span>
      nblocs_left = 1;
      bloc_ptr = one_bloc;
      one_bloc[0] = 0;
      one_bloc[1] = vect_size_tot / line_size;
    }
  <span class="keywordflow">else</span>
    {
<span class="comment">// raccourci pour les tableaux vides (evite le cas particulier line_size == 0)</span>
      <span class="keywordflow">return</span>  min_val;
    }
  <span class="keyword">const</span> <span class="keywordtype">int</span> *x_base = vx.addr();
  <span class="keywordflow">for</span> (; nblocs_left; nblocs_left--)
    {
<span class="comment">// Get index of next bloc start:</span>
      <span class="keyword">const</span> <span class="keywordtype">int</span> begin_bloc = (*(bloc_ptr++)) * line_size;
      <span class="keyword">const</span> <span class="keywordtype">int</span> end_bloc = (*(bloc_ptr++)) * line_size;
      assert(begin_bloc &gt;= 0 &amp;&amp; end_bloc &lt;= vect_size_tot &amp;&amp; end_bloc &gt;= begin_bloc);
      <span class="keyword">const</span> <span class="keywordtype">int</span>* x_ptr = x_base + begin_bloc;
      <span class="keywordtype">int</span> count = end_bloc - begin_bloc;
      <span class="keywordflow">for</span> (; count; count--)
        {
          <span class="keyword">const</span> <span class="keywordtype">int</span> x = *x_ptr;
          min_val = (x &lt; min_val) ? x : min_val;
          x_ptr++;
        }
    }
  <span class="keywordflow">return</span>  min_val;
}
</pre></div>
</div>
</div>
<a class="anchor" id="acf47aa167cf325d601eddab757fa3bc6"></a><!-- doxytag: member="IntVect.h::mp_max_abs_vect" ref="acf47aa167cf325d601eddab757fa3bc6" args="(const IntVect &amp;, Mp_vect_options opt=VECT_REAL_ITEMS)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mp_max_abs_vect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIntVect.html">IntVect</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a>&#160;</td>
          <td class="paramname"><em>opt</em> = <code>VECT_REAL_ITEMS</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="IntVect_8cpp_source.html#l01645">1645</a> of file <a class="el" href="IntVect_8cpp_source.html">IntVect.cpp</a>.</p>

<p>References <a class="el" href="DoubleVect_8cpp_source.html#l00829">local_max_abs_vect()</a>, and <a class="el" href="communications_8cpp_source.html#l00588">mp_max()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">int</span> s = <a class="code" href="DoubleVect_8cpp.html#aad339141fa6027fa3b627825a2407c12">local_max_abs_vect</a>(x, opt);
  s = <a class="code" href="communications_8cpp.html#a6b5d757052506cb052efbc14b268775b" title="renvoie le plus grand int i sur l&#39;ensemble des processeurs du groupe courant.">mp_max</a>(s);
  <span class="keywordflow">return</span> s;
}
</pre></div>
</div>
</div>
<a class="anchor" id="adb6b63e7fa7b169be86029fc51493793"></a><!-- doxytag: member="IntVect.h::mp_max_vect" ref="adb6b63e7fa7b169be86029fc51493793" args="(const IntVect &amp;, Mp_vect_options opt=VECT_REAL_ITEMS)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mp_max_vect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIntVect.html">IntVect</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a>&#160;</td>
          <td class="paramname"><em>opt</em> = <code>VECT_REAL_ITEMS</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="IntVect_8cpp_source.html#l01633">1633</a> of file <a class="el" href="IntVect_8cpp_source.html">IntVect.cpp</a>.</p>

<p>References <a class="el" href="DoubleVect_8cpp_source.html#l00773">local_max_vect()</a>, and <a class="el" href="communications_8cpp_source.html#l00588">mp_max()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">int</span> s = <a class="code" href="DoubleVect_8cpp.html#a6471e7e85cb0b00b67bd7ca9bb362371">local_max_vect</a>(x, opt);
  s =  <a class="code" href="communications_8cpp.html#a6b5d757052506cb052efbc14b268775b" title="renvoie le plus grand int i sur l&#39;ensemble des processeurs du groupe courant.">mp_max</a>(s);
  <span class="keywordflow">return</span> s;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a17751a9b8a8fcf035e8aeeeb6daf74af"></a><!-- doxytag: member="IntVect.h::mp_min_abs_vect" ref="a17751a9b8a8fcf035e8aeeeb6daf74af" args="(const IntVect &amp;, Mp_vect_options opt=VECT_REAL_ITEMS)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mp_min_abs_vect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIntVect.html">IntVect</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a>&#160;</td>
          <td class="paramname"><em>opt</em> = <code>VECT_REAL_ITEMS</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="IntVect_8cpp_source.html#l01651">1651</a> of file <a class="el" href="IntVect_8cpp_source.html">IntVect.cpp</a>.</p>

<p>References <a class="el" href="DoubleVect_8cpp_source.html#l00886">local_min_abs_vect()</a>, and <a class="el" href="communications_8cpp_source.html#l00598">mp_min()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">int</span> s = <a class="code" href="DoubleVect_8cpp.html#abbb6099a23e2ab39b2308423112f6a67">local_min_abs_vect</a>(x, opt);
  s = <a class="code" href="communications_8cpp.html#adb9fffe31bc56a52685e93ba06932547" title="renvoie le plus petit int i sur l&#39;ensemble des processeurs du groupe courant.">mp_min</a>(s);
  <span class="keywordflow">return</span> s;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a6787d511d688ba4941a9fbb18787d75d"></a><!-- doxytag: member="IntVect.h::mp_min_vect" ref="a6787d511d688ba4941a9fbb18787d75d" args="(const IntVect &amp;, Mp_vect_options opt=VECT_REAL_ITEMS)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mp_min_vect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIntVect.html">IntVect</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a>&#160;</td>
          <td class="paramname"><em>opt</em> = <code>VECT_REAL_ITEMS</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="IntVect_8cpp_source.html#l01639">1639</a> of file <a class="el" href="IntVect_8cpp_source.html">IntVect.cpp</a>.</p>

<p>References <a class="el" href="DoubleVect_8cpp_source.html#l00660">local_min_vect()</a>, and <a class="el" href="communications_8cpp_source.html#l00598">mp_min()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">int</span> s = <a class="code" href="DoubleVect_8cpp.html#a17be200c713a7031ede99b28391daa52">local_min_vect</a>(x, opt);
  s =  <a class="code" href="communications_8cpp.html#adb9fffe31bc56a52685e93ba06932547" title="renvoie le plus petit int i sur l&#39;ensemble des processeurs du groupe courant.">mp_min</a>(s);
  <span class="keywordflow">return</span> s;
}
</pre></div>
</div>
</div>
<a class="anchor" id="abd3d03efd4dfe79d4427a77341ad3c21"></a><!-- doxytag: member="IntVect.h::mp_somme_vect" ref="abd3d03efd4dfe79d4427a77341ad3c21" args="(const IntVect &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mp_somme_vect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIntVect.html">IntVect</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="IntVect_8cpp_source.html#l00585">585</a> of file <a class="el" href="IntVect_8cpp_source.html">IntVect.cpp</a>.</p>

<p>References <a class="el" href="DoubleVect_8cpp_source.html#l00541">local_somme_vect()</a>, and <a class="el" href="Process_8cpp_source.html#l00178">Process::mp_sum()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">int</span> x = <a class="code" href="DoubleVect_8cpp.html#aaaede7053cdab4cd6f12f0fa2c065e37">local_somme_vect</a>(vx);
  <span class="keywordtype">int</span> y = <a class="code" href="classProcess.html#a7d23bc1ef94b3f0623fbc79d034c27fd" title="Calcule la somme de x sur tous les processeurs du groupe courant. Voir aussi mp_max()">Process::mp_sum</a>(x);
  <span class="keywordflow">return</span> y;
}
</pre></div>
</div>
</div>
<a class="anchor" id="afe7b6a7310bafb543df557a0d845e3e4"></a><!-- doxytag: member="IntVect.h::operator!=" ref="afe7b6a7310bafb543df557a0d845e3e4" args="(const IntVect &amp;x, const IntVect &amp;y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIntVect.html">IntVect</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIntVect.html">IntVect</a> &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="IntVect_8cpp_source.html#l00359">359</a> of file <a class="el" href="IntVect_8cpp_source.html">IntVect.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">return</span> !(x == y);
}
</pre></div>
</div>
</div>
<a class="anchor" id="ade146e7b644bec7ea5b5c6fcb88fe2a9"></a><!-- doxytag: member="IntVect.h::operator==" ref="ade146e7b644bec7ea5b5c6fcb88fe2a9" args="(const IntVect &amp;x, const IntVect &amp;y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIntVect.html">IntVect</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIntVect.html">IntVect</a> &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>renvoie 1 si meme strucuture parallele et egalite au sens ArrOfInt&lt;br&gt;(y compris espaces virtuels)<br/>
BM: faut-il etre aussi strict, comparer uniquement size() elements ? </p>

<p>Definition at line <a class="el" href="IntVect_8cpp_source.html#l00350">350</a> of file <a class="el" href="IntVect_8cpp_source.html">IntVect.cpp</a>.</p>

<p>References <a class="el" href="IntVect_8h_source.html#l00087">IntVect::get_md_vector()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">if</span> (!(x.<a class="code" href="classIntVect.html#ae74e1fee6aca124d32718267e33a40c6">get_md_vector</a>() == y.<a class="code" href="classIntVect.html#ae74e1fee6aca124d32718267e33a40c6">get_md_vector</a>()))
    <span class="keywordflow">return</span> 0;
  <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; ax = x;
  <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; ay = y;
  <span class="keywordflow">return</span> ax == ay;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a2c8d82cd6f9fdf707cb798984d6b2652"></a><!-- doxytag: member="IntVect.h::operator_add" ref="a2c8d82cd6f9fdf707cb798984d6b2652" args="(IntVect &amp;resu, const int x, Mp_vect_options opt=VECT_ALL_ITEMS)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operator_add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classIntVect.html">IntVect</a> &amp;&#160;</td>
          <td class="paramname"><em>resu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a>&#160;</td>
          <td class="paramname"><em>opt</em> = <code>VECT_ALL_ITEMS</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="IntVect_8cpp_source.html#l01050">1050</a> of file <a class="el" href="IntVect_8cpp_source.html">IntVect.cpp</a>.</p>

<p>References <a class="el" href="ArrOfInt_8h_source.html#l00371">ArrOfInt::addr()</a>, <a class="el" href="classMD__Vector__base.html#a99334ac2566d9457c8d4890ba20883ea">MD_Vector_base::get_items_to_compute()</a>, <a class="el" href="classMD__Vector__base.html#a7f6b6d0b7babfec0cce590cdea5bca53">MD_Vector_base::get_items_to_sum()</a>, <a class="el" href="IntVect_8h_source.html#l00087">IntVect::get_md_vector()</a>, <a class="el" href="IntVect_8cpp_source.html#l00367">invalidate_data()</a>, <a class="el" href="IntVect_8h_source.html#l00150">IntVect::line_size()</a>, <a class="el" href="MD__Vector_8h_source.html#l00063">MD_Vector::non_nul()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00342">ArrOfInt::size_array()</a>, <a class="el" href="IntVect_8h_source.html#l00145">IntVect::size_totale()</a>, <a class="el" href="MD__Vector_8h_source.html#l00067">MD_Vector::valeur()</a>, <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_ALL_ITEMS</a>, <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_REAL_ITEMS</a>, and <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_SEQUENTIAL_ITEMS</a>.</p>
<div class="fragment"><pre class="fragment">{

<span class="comment">// Master vect donne la structure de reference, les autres vecteurs</span>
<span class="comment">// doivent avoir la meme structure.</span>
  <span class="keyword">const</span> <a class="code" href="classIntVect.html">IntVect</a>&amp; master_vect = resu;
  <span class="keywordtype">int</span> line_size = master_vect.<a class="code" href="classIntVect.html#a5ba680066169c8e057bb3e3b876e4a8c">line_size</a>();
  <span class="keyword">const</span> <a class="code" href="classMD__Vector.html" title=": Cette classe est un DERIV mais l&#39;objet pointe est partage entre plusieurs instances de cette classe...">MD_Vector</a>&amp; md = master_vect.<a class="code" href="classIntVect.html#ae74e1fee6aca124d32718267e33a40c6">get_md_vector</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> vect_size_tot = master_vect.<a class="code" href="classIntVect.html#afa716e1f0a1f0f74f4f73e95b5651412" title="Identique a size_array()">size_totale</a>();
<span class="comment">// Determine blocs of data to process, depending on &quot; opt&quot;</span>
  <span class="keywordtype">int</span> nblocs_left = 1;
  <span class="keywordtype">int</span> one_bloc[2];
  <span class="keyword">const</span> <span class="keywordtype">int</span> *bloc_ptr;
  <span class="keywordflow">if</span> ( opt != <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caad18680091a9f62247573cb3caa6450b9">VECT_ALL_ITEMS</a> &amp;&amp; md.<a class="code" href="classMD__Vector.html#a4165c00904b7096274e38fdc7ca340f4">non_nul</a>())
    {
      assert( opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a> ||  opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caab47906d8d2e6c20f8ba32e4acb6edbe0">VECT_REAL_ITEMS</a>);
      <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; items_blocs = ( opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a>) ? md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a7f6b6d0b7babfec0cce590cdea5bca53">get_items_to_sum</a>() : md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a99334ac2566d9457c8d4890ba20883ea">get_items_to_compute</a>();
      assert(items_blocs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() % 2 == 0);
      nblocs_left = items_blocs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() &gt;&gt; 1;
      bloc_ptr = items_blocs.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
    }
  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (vect_size_tot &gt; 0)
    {
<span class="comment">// attention, si vect_size_tot est nul, line_size a le droit d&#39;etre nul</span>
<span class="comment">// Compute all data, in the vector (including virtual data), build a big bloc:</span>
      nblocs_left = 1;
      bloc_ptr = one_bloc;
      one_bloc[0] = 0;
      one_bloc[1] = vect_size_tot / line_size;
    }
  <span class="keywordflow">else</span>
    {
<span class="comment">// raccourci pour les tableaux vides (evite le cas particulier line_size == 0)</span>
      return ;
    }
  <span class="keywordtype">int</span> *resu_base = resu.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
  <span class="keywordflow">for</span> (; nblocs_left; nblocs_left--)
    {
<span class="comment">// Get index of next bloc start:</span>
      <span class="keyword">const</span> <span class="keywordtype">int</span> begin_bloc = (*(bloc_ptr++)) * line_size;
      <span class="keyword">const</span> <span class="keywordtype">int</span> end_bloc = (*(bloc_ptr++)) * line_size;
      assert(begin_bloc &gt;= 0 &amp;&amp; end_bloc &lt;= vect_size_tot &amp;&amp; end_bloc &gt;= begin_bloc);
      <span class="keywordtype">int</span>* resu_ptr = resu_base + begin_bloc;
      <span class="keywordtype">int</span> count = end_bloc - begin_bloc;
      <span class="keywordflow">for</span> (; count; count--)
        {
          <span class="keywordtype">int</span>&amp; p_resu = *(resu_ptr++);
          p_resu += x;
        }
    }
<span class="comment">// In debug mode, put invalid values where data has not been computed</span>
<span class="preprocessor">#ifndef NDEBUG</span>
<span class="preprocessor"></span>  <a class="code" href="IntVect_8cpp.html#a27f59c580905a55953c9aa2734a1fc73">invalidate_data</a>(resu,  opt);
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>  return ;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a4c1ae372f23a6533b404cda3b2e70750"></a><!-- doxytag: member="IntVect.h::operator_add" ref="a4c1ae372f23a6533b404cda3b2e70750" args="(IntVect &amp;resu, const IntVect &amp;vx, Mp_vect_options opt=VECT_ALL_ITEMS)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operator_add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classIntVect.html">IntVect</a> &amp;&#160;</td>
          <td class="paramname"><em>resu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIntVect.html">IntVect</a> &amp;&#160;</td>
          <td class="paramname"><em>vx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a>&#160;</td>
          <td class="paramname"><em>opt</em> = <code>VECT_ALL_ITEMS</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>&lt; this test is necessary if md is null </p>
</p>

<p>Definition at line <a class="el" href="IntVect_8cpp_source.html#l00987">987</a> of file <a class="el" href="IntVect_8cpp_source.html">IntVect.cpp</a>.</p>

<p>References <a class="el" href="ArrOfInt_8h_source.html#l00371">ArrOfInt::addr()</a>, <a class="el" href="classMD__Vector__base.html#a99334ac2566d9457c8d4890ba20883ea">MD_Vector_base::get_items_to_compute()</a>, <a class="el" href="classMD__Vector__base.html#a7f6b6d0b7babfec0cce590cdea5bca53">MD_Vector_base::get_items_to_sum()</a>, <a class="el" href="IntVect_8h_source.html#l00087">IntVect::get_md_vector()</a>, <a class="el" href="IntVect_8cpp_source.html#l00367">invalidate_data()</a>, <a class="el" href="IntVect_8h_source.html#l00150">IntVect::line_size()</a>, <a class="el" href="MD__Vector_8h_source.html#l00063">MD_Vector::non_nul()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00342">ArrOfInt::size_array()</a>, <a class="el" href="IntVect_8h_source.html#l00145">IntVect::size_totale()</a>, <a class="el" href="MD__Vector_8h_source.html#l00067">MD_Vector::valeur()</a>, <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_ALL_ITEMS</a>, <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_REAL_ITEMS</a>, and <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_SEQUENTIAL_ITEMS</a>.</p>
<div class="fragment"><pre class="fragment">{

<span class="comment">// Master vect donne la structure de reference, les autres vecteurs</span>
<span class="comment">// doivent avoir la meme structure.</span>
  <span class="keyword">const</span> <a class="code" href="classIntVect.html">IntVect</a>&amp; master_vect = resu;
  <span class="keywordtype">int</span> line_size = master_vect.<a class="code" href="classIntVect.html#a5ba680066169c8e057bb3e3b876e4a8c">line_size</a>();
  <span class="keyword">const</span> <a class="code" href="classMD__Vector.html" title=": Cette classe est un DERIV mais l&#39;objet pointe est partage entre plusieurs instances de cette classe...">MD_Vector</a>&amp; md = master_vect.<a class="code" href="classIntVect.html#ae74e1fee6aca124d32718267e33a40c6">get_md_vector</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> vect_size_tot = master_vect.<a class="code" href="classIntVect.html#afa716e1f0a1f0f74f4f73e95b5651412" title="Identique a size_array()">size_totale</a>();
  assert(vx.<a class="code" href="classIntVect.html#a5ba680066169c8e057bb3e3b876e4a8c">line_size</a>() == line_size);
  assert(vx.<a class="code" href="classIntVect.html#afa716e1f0a1f0f74f4f73e95b5651412" title="Identique a size_array()">size_totale</a>() == vect_size_tot); <span class="comment">//!&lt; this test is necessary if md is null</span>
<span class="comment"></span>  assert(vx.<a class="code" href="classIntVect.html#ae74e1fee6aca124d32718267e33a40c6">get_md_vector</a>() == md);
<span class="comment">// Determine blocs of data to process, depending on &quot; opt&quot;</span>
  <span class="keywordtype">int</span> nblocs_left = 1;
  <span class="keywordtype">int</span> one_bloc[2];
  <span class="keyword">const</span> <span class="keywordtype">int</span> *bloc_ptr;
  <span class="keywordflow">if</span> ( opt != <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caad18680091a9f62247573cb3caa6450b9">VECT_ALL_ITEMS</a> &amp;&amp; md.<a class="code" href="classMD__Vector.html#a4165c00904b7096274e38fdc7ca340f4">non_nul</a>())
    {
      assert( opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a> ||  opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caab47906d8d2e6c20f8ba32e4acb6edbe0">VECT_REAL_ITEMS</a>);
      <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; items_blocs = ( opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a>) ? md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a7f6b6d0b7babfec0cce590cdea5bca53">get_items_to_sum</a>() : md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a99334ac2566d9457c8d4890ba20883ea">get_items_to_compute</a>();
      assert(items_blocs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() % 2 == 0);
      nblocs_left = items_blocs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() &gt;&gt; 1;
      bloc_ptr = items_blocs.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
    }
  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (vect_size_tot &gt; 0)
    {
<span class="comment">// attention, si vect_size_tot est nul, line_size a le droit d&#39;etre nul</span>
<span class="comment">// Compute all data, in the vector (including virtual data), build a big bloc:</span>
      nblocs_left = 1;
      bloc_ptr = one_bloc;
      one_bloc[0] = 0;
      one_bloc[1] = vect_size_tot / line_size;
    }
  <span class="keywordflow">else</span>
    {
<span class="comment">// raccourci pour les tableaux vides (evite le cas particulier line_size == 0)</span>
      return ;
    }
  <span class="keywordtype">int</span> *resu_base = resu.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> *x_base = vx.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
  <span class="keywordflow">for</span> (; nblocs_left; nblocs_left--)
    {
<span class="comment">// Get index of next bloc start:</span>
      <span class="keyword">const</span> <span class="keywordtype">int</span> begin_bloc = (*(bloc_ptr++)) * line_size;
      <span class="keyword">const</span> <span class="keywordtype">int</span> end_bloc = (*(bloc_ptr++)) * line_size;
      assert(begin_bloc &gt;= 0 &amp;&amp; end_bloc &lt;= vect_size_tot &amp;&amp; end_bloc &gt;= begin_bloc);
      <span class="keywordtype">int</span>* resu_ptr = resu_base + begin_bloc;
      <span class="keyword">const</span> <span class="keywordtype">int</span>* x_ptr = x_base + begin_bloc;
      <span class="keywordtype">int</span> count = end_bloc - begin_bloc;
      <span class="keywordflow">for</span> (; count; count--)
        {
          <span class="keyword">const</span> <span class="keywordtype">int</span> x = *x_ptr;
          <span class="keywordtype">int</span>&amp; p_resu = *(resu_ptr++);
          p_resu += x;
          x_ptr++;
        }
    }
<span class="comment">// In debug mode, put invalid values where data has not been computed</span>
<span class="preprocessor">#ifndef NDEBUG</span>
<span class="preprocessor"></span>  <a class="code" href="IntVect_8cpp.html#a27f59c580905a55953c9aa2734a1fc73">invalidate_data</a>(resu,  opt);
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>  return ;
}
</pre></div>
</div>
</div>
<a class="anchor" id="ab1f1db27f3c98b231cec2f91a17ef7c4"></a><!-- doxytag: member="IntVect.h::operator_egal" ref="ab1f1db27f3c98b231cec2f91a17ef7c4" args="(IntVect &amp;resu, int x, Mp_vect_options opt=VECT_ALL_ITEMS)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operator_egal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classIntVect.html">IntVect</a> &amp;&#160;</td>
          <td class="paramname"><em>resu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a>&#160;</td>
          <td class="paramname"><em>opt</em> = <code>VECT_ALL_ITEMS</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="IntVect_8cpp_source.html#l01400">1400</a> of file <a class="el" href="IntVect_8cpp_source.html">IntVect.cpp</a>.</p>

<p>References <a class="el" href="ArrOfInt_8h_source.html#l00371">ArrOfInt::addr()</a>, <a class="el" href="classMD__Vector__base.html#a99334ac2566d9457c8d4890ba20883ea">MD_Vector_base::get_items_to_compute()</a>, <a class="el" href="classMD__Vector__base.html#a7f6b6d0b7babfec0cce590cdea5bca53">MD_Vector_base::get_items_to_sum()</a>, <a class="el" href="IntVect_8h_source.html#l00087">IntVect::get_md_vector()</a>, <a class="el" href="IntVect_8cpp_source.html#l00367">invalidate_data()</a>, <a class="el" href="IntVect_8h_source.html#l00150">IntVect::line_size()</a>, <a class="el" href="MD__Vector_8h_source.html#l00063">MD_Vector::non_nul()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00342">ArrOfInt::size_array()</a>, <a class="el" href="IntVect_8h_source.html#l00145">IntVect::size_totale()</a>, <a class="el" href="MD__Vector_8h_source.html#l00067">MD_Vector::valeur()</a>, <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_ALL_ITEMS</a>, <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_REAL_ITEMS</a>, and <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_SEQUENTIAL_ITEMS</a>.</p>
<div class="fragment"><pre class="fragment">{

<span class="comment">// Master vect donne la structure de reference, les autres vecteurs</span>
<span class="comment">// doivent avoir la meme structure.</span>
  <span class="keyword">const</span> <a class="code" href="classIntVect.html">IntVect</a>&amp; master_vect = resu;
  <span class="keywordtype">int</span> line_size = master_vect.<a class="code" href="classIntVect.html#a5ba680066169c8e057bb3e3b876e4a8c">line_size</a>();
  <span class="keyword">const</span> <a class="code" href="classMD__Vector.html" title=": Cette classe est un DERIV mais l&#39;objet pointe est partage entre plusieurs instances de cette classe...">MD_Vector</a>&amp; md = master_vect.<a class="code" href="classIntVect.html#ae74e1fee6aca124d32718267e33a40c6">get_md_vector</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> vect_size_tot = master_vect.<a class="code" href="classIntVect.html#afa716e1f0a1f0f74f4f73e95b5651412" title="Identique a size_array()">size_totale</a>();
<span class="comment">// Determine blocs of data to process, depending on &quot; opt&quot;</span>
  <span class="keywordtype">int</span> nblocs_left = 1;
  <span class="keywordtype">int</span> one_bloc[2];
  <span class="keyword">const</span> <span class="keywordtype">int</span> *bloc_ptr;
  <span class="keywordflow">if</span> ( opt != <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caad18680091a9f62247573cb3caa6450b9">VECT_ALL_ITEMS</a> &amp;&amp; md.<a class="code" href="classMD__Vector.html#a4165c00904b7096274e38fdc7ca340f4">non_nul</a>())
    {
      assert( opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a> ||  opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caab47906d8d2e6c20f8ba32e4acb6edbe0">VECT_REAL_ITEMS</a>);
      <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; items_blocs = ( opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a>) ? md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a7f6b6d0b7babfec0cce590cdea5bca53">get_items_to_sum</a>() : md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a99334ac2566d9457c8d4890ba20883ea">get_items_to_compute</a>();
      assert(items_blocs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() % 2 == 0);
      nblocs_left = items_blocs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() &gt;&gt; 1;
      bloc_ptr = items_blocs.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
    }
  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (vect_size_tot &gt; 0)
    {
<span class="comment">// attention, si vect_size_tot est nul, line_size a le droit d&#39;etre nul</span>
<span class="comment">// Compute all data, in the vector (including virtual data), build a big bloc:</span>
      nblocs_left = 1;
      bloc_ptr = one_bloc;
      one_bloc[0] = 0;
      one_bloc[1] = vect_size_tot / line_size;
    }
  <span class="keywordflow">else</span>
    {
<span class="comment">// raccourci pour les tableaux vides (evite le cas particulier line_size == 0)</span>
      return ;
    }
  <span class="keywordtype">int</span> *resu_base = resu.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
  <span class="keywordflow">for</span> (; nblocs_left; nblocs_left--)
    {
<span class="comment">// Get index of next bloc start:</span>
      <span class="keyword">const</span> <span class="keywordtype">int</span> begin_bloc = (*(bloc_ptr++)) * line_size;
      <span class="keyword">const</span> <span class="keywordtype">int</span> end_bloc = (*(bloc_ptr++)) * line_size;
      assert(begin_bloc &gt;= 0 &amp;&amp; end_bloc &lt;= vect_size_tot &amp;&amp; end_bloc &gt;= begin_bloc);
      <span class="keywordtype">int</span>* resu_ptr = resu_base + begin_bloc;
      <span class="keywordtype">int</span> count = end_bloc - begin_bloc;
      <span class="keywordflow">for</span> (; count; count--)
        {
          <span class="keywordtype">int</span>&amp; p_resu = *(resu_ptr++);
          p_resu = x;
        }
    }
<span class="comment">// In debug mode, put invalid values where data has not been computed</span>
<span class="preprocessor">#ifndef NDEBUG</span>
<span class="preprocessor"></span>  <a class="code" href="IntVect_8cpp.html#a27f59c580905a55953c9aa2734a1fc73">invalidate_data</a>(resu,  opt);
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>  return ;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a5db7389ddd1536051f718fd55a35c59d"></a><!-- doxytag: member="IntVect.h::operator_egal" ref="a5db7389ddd1536051f718fd55a35c59d" args="(IntVect &amp;resu, const IntVect &amp;vx, Mp_vect_options opt=VECT_ALL_ITEMS)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operator_egal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classIntVect.html">IntVect</a> &amp;&#160;</td>
          <td class="paramname"><em>resu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIntVect.html">IntVect</a> &amp;&#160;</td>
          <td class="paramname"><em>vx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a>&#160;</td>
          <td class="paramname"><em>opt</em> = <code>VECT_ALL_ITEMS</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>&lt; this test is necessary if md is null </p>
</p>

<p>Definition at line <a class="el" href="IntVect_8cpp_source.html#l01456">1456</a> of file <a class="el" href="IntVect_8cpp_source.html">IntVect.cpp</a>.</p>

<p>References <a class="el" href="ArrOfInt_8h_source.html#l00371">ArrOfInt::addr()</a>, <a class="el" href="classMD__Vector__base.html#a99334ac2566d9457c8d4890ba20883ea">MD_Vector_base::get_items_to_compute()</a>, <a class="el" href="classMD__Vector__base.html#a7f6b6d0b7babfec0cce590cdea5bca53">MD_Vector_base::get_items_to_sum()</a>, <a class="el" href="IntVect_8h_source.html#l00087">IntVect::get_md_vector()</a>, <a class="el" href="IntVect_8cpp_source.html#l00367">invalidate_data()</a>, <a class="el" href="IntVect_8h_source.html#l00150">IntVect::line_size()</a>, <a class="el" href="MD__Vector_8h_source.html#l00063">MD_Vector::non_nul()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00342">ArrOfInt::size_array()</a>, <a class="el" href="IntVect_8h_source.html#l00145">IntVect::size_totale()</a>, <a class="el" href="MD__Vector_8h_source.html#l00067">MD_Vector::valeur()</a>, <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_ALL_ITEMS</a>, <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_REAL_ITEMS</a>, and <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_SEQUENTIAL_ITEMS</a>.</p>
<div class="fragment"><pre class="fragment">{

<span class="comment">// Master vect donne la structure de reference, les autres vecteurs</span>
<span class="comment">// doivent avoir la meme structure.</span>
  <span class="keyword">const</span> <a class="code" href="classIntVect.html">IntVect</a>&amp; master_vect = resu;
  <span class="keywordtype">int</span> line_size = master_vect.<a class="code" href="classIntVect.html#a5ba680066169c8e057bb3e3b876e4a8c">line_size</a>();
  <span class="keyword">const</span> <a class="code" href="classMD__Vector.html" title=": Cette classe est un DERIV mais l&#39;objet pointe est partage entre plusieurs instances de cette classe...">MD_Vector</a>&amp; md = master_vect.<a class="code" href="classIntVect.html#ae74e1fee6aca124d32718267e33a40c6">get_md_vector</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> vect_size_tot = master_vect.<a class="code" href="classIntVect.html#afa716e1f0a1f0f74f4f73e95b5651412" title="Identique a size_array()">size_totale</a>();
  assert(vx.<a class="code" href="classIntVect.html#a5ba680066169c8e057bb3e3b876e4a8c">line_size</a>() == line_size);
  assert(vx.<a class="code" href="classIntVect.html#afa716e1f0a1f0f74f4f73e95b5651412" title="Identique a size_array()">size_totale</a>() == vect_size_tot); <span class="comment">//!&lt; this test is necessary if md is null</span>
<span class="comment"></span>  assert(vx.<a class="code" href="classIntVect.html#ae74e1fee6aca124d32718267e33a40c6">get_md_vector</a>() == md);
<span class="comment">// Determine blocs of data to process, depending on &quot; opt&quot;</span>
  <span class="keywordtype">int</span> nblocs_left = 1;
  <span class="keywordtype">int</span> one_bloc[2];
  <span class="keyword">const</span> <span class="keywordtype">int</span> *bloc_ptr;
  <span class="keywordflow">if</span> ( opt != <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caad18680091a9f62247573cb3caa6450b9">VECT_ALL_ITEMS</a> &amp;&amp; md.<a class="code" href="classMD__Vector.html#a4165c00904b7096274e38fdc7ca340f4">non_nul</a>())
    {
      assert( opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a> ||  opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caab47906d8d2e6c20f8ba32e4acb6edbe0">VECT_REAL_ITEMS</a>);
      <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; items_blocs = ( opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a>) ? md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a7f6b6d0b7babfec0cce590cdea5bca53">get_items_to_sum</a>() : md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a99334ac2566d9457c8d4890ba20883ea">get_items_to_compute</a>();
      assert(items_blocs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() % 2 == 0);
      nblocs_left = items_blocs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() &gt;&gt; 1;
      bloc_ptr = items_blocs.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
    }
  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (vect_size_tot &gt; 0)
    {
<span class="comment">// attention, si vect_size_tot est nul, line_size a le droit d&#39;etre nul</span>
<span class="comment">// Compute all data, in the vector (including virtual data), build a big bloc:</span>
      nblocs_left = 1;
      bloc_ptr = one_bloc;
      one_bloc[0] = 0;
      one_bloc[1] = vect_size_tot / line_size;
    }
  <span class="keywordflow">else</span>
    {
<span class="comment">// raccourci pour les tableaux vides (evite le cas particulier line_size == 0)</span>
      return ;
    }
  <span class="keywordtype">int</span> *resu_base = resu.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> *x_base = vx.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
  <span class="keywordflow">for</span> (; nblocs_left; nblocs_left--)
    {
<span class="comment">// Get index of next bloc start:</span>
      <span class="keyword">const</span> <span class="keywordtype">int</span> begin_bloc = (*(bloc_ptr++)) * line_size;
      <span class="keyword">const</span> <span class="keywordtype">int</span> end_bloc = (*(bloc_ptr++)) * line_size;
      assert(begin_bloc &gt;= 0 &amp;&amp; end_bloc &lt;= vect_size_tot &amp;&amp; end_bloc &gt;= begin_bloc);
      <span class="keywordtype">int</span>* resu_ptr = resu_base + begin_bloc;
      <span class="keyword">const</span> <span class="keywordtype">int</span>* x_ptr = x_base + begin_bloc;
      <span class="keywordtype">int</span> count = end_bloc - begin_bloc;
      <span class="keywordflow">for</span> (; count; count--)
        {
          <span class="keyword">const</span> <span class="keywordtype">int</span> x = *x_ptr;
          <span class="keywordtype">int</span>&amp; p_resu = *(resu_ptr++);
          p_resu = x;
          x_ptr++;
        }
    }
<span class="comment">// In debug mode, put invalid values where data has not been computed</span>
<span class="preprocessor">#ifndef NDEBUG</span>
<span class="preprocessor"></span>  <a class="code" href="IntVect_8cpp.html#a27f59c580905a55953c9aa2734a1fc73">invalidate_data</a>(resu,  opt);
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>  return ;
}
</pre></div>
</div>
</div>
<a class="anchor" id="aadbda73d2d8148e99b76d78e05a47654"></a><!-- doxytag: member="IntVect.h::operator_multiply" ref="aadbda73d2d8148e99b76d78e05a47654" args="(IntVect &amp;resu, const IntVect &amp;vx, Mp_vect_options opt=VECT_ALL_ITEMS)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operator_multiply </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classIntVect.html">IntVect</a> &amp;&#160;</td>
          <td class="paramname"><em>resu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIntVect.html">IntVect</a> &amp;&#160;</td>
          <td class="paramname"><em>vx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a>&#160;</td>
          <td class="paramname"><em>opt</em> = <code>VECT_ALL_ITEMS</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>&lt; this test is necessary if md is null </p>
</p>

<p>Definition at line <a class="el" href="IntVect_8cpp_source.html#l01225">1225</a> of file <a class="el" href="IntVect_8cpp_source.html">IntVect.cpp</a>.</p>

<p>References <a class="el" href="ArrOfInt_8h_source.html#l00371">ArrOfInt::addr()</a>, <a class="el" href="classMD__Vector__base.html#a99334ac2566d9457c8d4890ba20883ea">MD_Vector_base::get_items_to_compute()</a>, <a class="el" href="classMD__Vector__base.html#a7f6b6d0b7babfec0cce590cdea5bca53">MD_Vector_base::get_items_to_sum()</a>, <a class="el" href="IntVect_8h_source.html#l00087">IntVect::get_md_vector()</a>, <a class="el" href="IntVect_8cpp_source.html#l00367">invalidate_data()</a>, <a class="el" href="IntVect_8h_source.html#l00150">IntVect::line_size()</a>, <a class="el" href="MD__Vector_8h_source.html#l00063">MD_Vector::non_nul()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00342">ArrOfInt::size_array()</a>, <a class="el" href="IntVect_8h_source.html#l00145">IntVect::size_totale()</a>, <a class="el" href="MD__Vector_8h_source.html#l00067">MD_Vector::valeur()</a>, <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_ALL_ITEMS</a>, <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_REAL_ITEMS</a>, and <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_SEQUENTIAL_ITEMS</a>.</p>
<div class="fragment"><pre class="fragment">{

<span class="comment">// Master vect donne la structure de reference, les autres vecteurs</span>
<span class="comment">// doivent avoir la meme structure.</span>
  <span class="keyword">const</span> <a class="code" href="classIntVect.html">IntVect</a>&amp; master_vect = resu;
  <span class="keywordtype">int</span> line_size = master_vect.<a class="code" href="classIntVect.html#a5ba680066169c8e057bb3e3b876e4a8c">line_size</a>();
  <span class="keyword">const</span> <a class="code" href="classMD__Vector.html" title=": Cette classe est un DERIV mais l&#39;objet pointe est partage entre plusieurs instances de cette classe...">MD_Vector</a>&amp; md = master_vect.<a class="code" href="classIntVect.html#ae74e1fee6aca124d32718267e33a40c6">get_md_vector</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> vect_size_tot = master_vect.<a class="code" href="classIntVect.html#afa716e1f0a1f0f74f4f73e95b5651412" title="Identique a size_array()">size_totale</a>();
  assert(vx.<a class="code" href="classIntVect.html#a5ba680066169c8e057bb3e3b876e4a8c">line_size</a>() == line_size);
  assert(vx.<a class="code" href="classIntVect.html#afa716e1f0a1f0f74f4f73e95b5651412" title="Identique a size_array()">size_totale</a>() == vect_size_tot); <span class="comment">//!&lt; this test is necessary if md is null</span>
<span class="comment"></span>  assert(vx.<a class="code" href="classIntVect.html#ae74e1fee6aca124d32718267e33a40c6">get_md_vector</a>() == md);
<span class="comment">// Determine blocs of data to process, depending on &quot; opt&quot;</span>
  <span class="keywordtype">int</span> nblocs_left = 1;
  <span class="keywordtype">int</span> one_bloc[2];
  <span class="keyword">const</span> <span class="keywordtype">int</span> *bloc_ptr;
  <span class="keywordflow">if</span> ( opt != <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caad18680091a9f62247573cb3caa6450b9">VECT_ALL_ITEMS</a> &amp;&amp; md.<a class="code" href="classMD__Vector.html#a4165c00904b7096274e38fdc7ca340f4">non_nul</a>())
    {
      assert( opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a> ||  opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caab47906d8d2e6c20f8ba32e4acb6edbe0">VECT_REAL_ITEMS</a>);
      <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; items_blocs = ( opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a>) ? md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a7f6b6d0b7babfec0cce590cdea5bca53">get_items_to_sum</a>() : md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a99334ac2566d9457c8d4890ba20883ea">get_items_to_compute</a>();
      assert(items_blocs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() % 2 == 0);
      nblocs_left = items_blocs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() &gt;&gt; 1;
      bloc_ptr = items_blocs.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
    }
  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (vect_size_tot &gt; 0)
    {
<span class="comment">// attention, si vect_size_tot est nul, line_size a le droit d&#39;etre nul</span>
<span class="comment">// Compute all data, in the vector (including virtual data), build a big bloc:</span>
      nblocs_left = 1;
      bloc_ptr = one_bloc;
      one_bloc[0] = 0;
      one_bloc[1] = vect_size_tot / line_size;
    }
  <span class="keywordflow">else</span>
    {
<span class="comment">// raccourci pour les tableaux vides (evite le cas particulier line_size == 0)</span>
      return ;
    }
  <span class="keywordtype">int</span> *resu_base = resu.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> *x_base = vx.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
  <span class="keywordflow">for</span> (; nblocs_left; nblocs_left--)
    {
<span class="comment">// Get index of next bloc start:</span>
      <span class="keyword">const</span> <span class="keywordtype">int</span> begin_bloc = (*(bloc_ptr++)) * line_size;
      <span class="keyword">const</span> <span class="keywordtype">int</span> end_bloc = (*(bloc_ptr++)) * line_size;
      assert(begin_bloc &gt;= 0 &amp;&amp; end_bloc &lt;= vect_size_tot &amp;&amp; end_bloc &gt;= begin_bloc);
      <span class="keywordtype">int</span>* resu_ptr = resu_base + begin_bloc;
      <span class="keyword">const</span> <span class="keywordtype">int</span>* x_ptr = x_base + begin_bloc;
      <span class="keywordtype">int</span> count = end_bloc - begin_bloc;
      <span class="keywordflow">for</span> (; count; count--)
        {
          <span class="keyword">const</span> <span class="keywordtype">int</span> x = *x_ptr;
          <span class="keywordtype">int</span>&amp; p_resu = *(resu_ptr++);
          p_resu *= x;
          x_ptr++;
        }
    }
<span class="comment">// In debug mode, put invalid values where data has not been computed</span>
<span class="preprocessor">#ifndef NDEBUG</span>
<span class="preprocessor"></span>  <a class="code" href="IntVect_8cpp.html#a27f59c580905a55953c9aa2734a1fc73">invalidate_data</a>(resu,  opt);
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>  return ;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a606127253c2071dfd904942efbda1e77"></a><!-- doxytag: member="IntVect.h::operator_multiply" ref="a606127253c2071dfd904942efbda1e77" args="(IntVect &amp;resu, const int x, Mp_vect_options opt=VECT_ALL_ITEMS)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operator_multiply </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classIntVect.html">IntVect</a> &amp;&#160;</td>
          <td class="paramname"><em>resu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a>&#160;</td>
          <td class="paramname"><em>opt</em> = <code>VECT_ALL_ITEMS</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="IntVect_8cpp_source.html#l01288">1288</a> of file <a class="el" href="IntVect_8cpp_source.html">IntVect.cpp</a>.</p>

<p>References <a class="el" href="ArrOfInt_8h_source.html#l00371">ArrOfInt::addr()</a>, <a class="el" href="classMD__Vector__base.html#a99334ac2566d9457c8d4890ba20883ea">MD_Vector_base::get_items_to_compute()</a>, <a class="el" href="classMD__Vector__base.html#a7f6b6d0b7babfec0cce590cdea5bca53">MD_Vector_base::get_items_to_sum()</a>, <a class="el" href="IntVect_8h_source.html#l00087">IntVect::get_md_vector()</a>, <a class="el" href="IntVect_8cpp_source.html#l00367">invalidate_data()</a>, <a class="el" href="IntVect_8h_source.html#l00150">IntVect::line_size()</a>, <a class="el" href="MD__Vector_8h_source.html#l00063">MD_Vector::non_nul()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00342">ArrOfInt::size_array()</a>, <a class="el" href="IntVect_8h_source.html#l00145">IntVect::size_totale()</a>, <a class="el" href="MD__Vector_8h_source.html#l00067">MD_Vector::valeur()</a>, <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_ALL_ITEMS</a>, <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_REAL_ITEMS</a>, and <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_SEQUENTIAL_ITEMS</a>.</p>
<div class="fragment"><pre class="fragment">{

<span class="comment">// Master vect donne la structure de reference, les autres vecteurs</span>
<span class="comment">// doivent avoir la meme structure.</span>
  <span class="keyword">const</span> <a class="code" href="classIntVect.html">IntVect</a>&amp; master_vect = resu;
  <span class="keywordtype">int</span> line_size = master_vect.<a class="code" href="classIntVect.html#a5ba680066169c8e057bb3e3b876e4a8c">line_size</a>();
  <span class="keyword">const</span> <a class="code" href="classMD__Vector.html" title=": Cette classe est un DERIV mais l&#39;objet pointe est partage entre plusieurs instances de cette classe...">MD_Vector</a>&amp; md = master_vect.<a class="code" href="classIntVect.html#ae74e1fee6aca124d32718267e33a40c6">get_md_vector</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> vect_size_tot = master_vect.<a class="code" href="classIntVect.html#afa716e1f0a1f0f74f4f73e95b5651412" title="Identique a size_array()">size_totale</a>();
<span class="comment">// Determine blocs of data to process, depending on &quot; opt&quot;</span>
  <span class="keywordtype">int</span> nblocs_left = 1;
  <span class="keywordtype">int</span> one_bloc[2];
  <span class="keyword">const</span> <span class="keywordtype">int</span> *bloc_ptr;
  <span class="keywordflow">if</span> ( opt != <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caad18680091a9f62247573cb3caa6450b9">VECT_ALL_ITEMS</a> &amp;&amp; md.<a class="code" href="classMD__Vector.html#a4165c00904b7096274e38fdc7ca340f4">non_nul</a>())
    {
      assert( opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a> ||  opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caab47906d8d2e6c20f8ba32e4acb6edbe0">VECT_REAL_ITEMS</a>);
      <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; items_blocs = ( opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a>) ? md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a7f6b6d0b7babfec0cce590cdea5bca53">get_items_to_sum</a>() : md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a99334ac2566d9457c8d4890ba20883ea">get_items_to_compute</a>();
      assert(items_blocs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() % 2 == 0);
      nblocs_left = items_blocs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() &gt;&gt; 1;
      bloc_ptr = items_blocs.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
    }
  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (vect_size_tot &gt; 0)
    {
<span class="comment">// attention, si vect_size_tot est nul, line_size a le droit d&#39;etre nul</span>
<span class="comment">// Compute all data, in the vector (including virtual data), build a big bloc:</span>
      nblocs_left = 1;
      bloc_ptr = one_bloc;
      one_bloc[0] = 0;
      one_bloc[1] = vect_size_tot / line_size;
    }
  <span class="keywordflow">else</span>
    {
<span class="comment">// raccourci pour les tableaux vides (evite le cas particulier line_size == 0)</span>
      return ;
    }
  <span class="keywordtype">int</span> *resu_base = resu.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
  <span class="keywordflow">for</span> (; nblocs_left; nblocs_left--)
    {
<span class="comment">// Get index of next bloc start:</span>
      <span class="keyword">const</span> <span class="keywordtype">int</span> begin_bloc = (*(bloc_ptr++)) * line_size;
      <span class="keyword">const</span> <span class="keywordtype">int</span> end_bloc = (*(bloc_ptr++)) * line_size;
      assert(begin_bloc &gt;= 0 &amp;&amp; end_bloc &lt;= vect_size_tot &amp;&amp; end_bloc &gt;= begin_bloc);
      <span class="keywordtype">int</span>* resu_ptr = resu_base + begin_bloc;
      <span class="keywordtype">int</span> count = end_bloc - begin_bloc;
      <span class="keywordflow">for</span> (; count; count--)
        {
          <span class="keywordtype">int</span>&amp; p_resu = *(resu_ptr++);
          p_resu *= x;
        }
    }
<span class="comment">// In debug mode, put invalid values where data has not been computed</span>
<span class="preprocessor">#ifndef NDEBUG</span>
<span class="preprocessor"></span>  <a class="code" href="IntVect_8cpp.html#a27f59c580905a55953c9aa2734a1fc73">invalidate_data</a>(resu,  opt);
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>  return ;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a1ca4f82f2c2b489d8fb24470b8153ce9"></a><!-- doxytag: member="IntVect.h::operator_negate" ref="a1ca4f82f2c2b489d8fb24470b8153ce9" args="(IntVect &amp;resu, Mp_vect_options opt=VECT_ALL_ITEMS)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operator_negate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classIntVect.html">IntVect</a> &amp;&#160;</td>
          <td class="paramname"><em>resu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a>&#160;</td>
          <td class="paramname"><em>opt</em> = <code>VECT_ALL_ITEMS</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="IntVect_8cpp_source.html#l01344">1344</a> of file <a class="el" href="IntVect_8cpp_source.html">IntVect.cpp</a>.</p>

<p>References <a class="el" href="ArrOfInt_8h_source.html#l00371">ArrOfInt::addr()</a>, <a class="el" href="classMD__Vector__base.html#a99334ac2566d9457c8d4890ba20883ea">MD_Vector_base::get_items_to_compute()</a>, <a class="el" href="classMD__Vector__base.html#a7f6b6d0b7babfec0cce590cdea5bca53">MD_Vector_base::get_items_to_sum()</a>, <a class="el" href="IntVect_8h_source.html#l00087">IntVect::get_md_vector()</a>, <a class="el" href="IntVect_8cpp_source.html#l00367">invalidate_data()</a>, <a class="el" href="IntVect_8h_source.html#l00150">IntVect::line_size()</a>, <a class="el" href="MD__Vector_8h_source.html#l00063">MD_Vector::non_nul()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00342">ArrOfInt::size_array()</a>, <a class="el" href="IntVect_8h_source.html#l00145">IntVect::size_totale()</a>, <a class="el" href="MD__Vector_8h_source.html#l00067">MD_Vector::valeur()</a>, <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_ALL_ITEMS</a>, <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_REAL_ITEMS</a>, and <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_SEQUENTIAL_ITEMS</a>.</p>
<div class="fragment"><pre class="fragment">{

<span class="comment">// Master vect donne la structure de reference, les autres vecteurs</span>
<span class="comment">// doivent avoir la meme structure.</span>
  <span class="keyword">const</span> <a class="code" href="classIntVect.html">IntVect</a>&amp; master_vect = resu;
  <span class="keywordtype">int</span> line_size = master_vect.<a class="code" href="classIntVect.html#a5ba680066169c8e057bb3e3b876e4a8c">line_size</a>();
  <span class="keyword">const</span> <a class="code" href="classMD__Vector.html" title=": Cette classe est un DERIV mais l&#39;objet pointe est partage entre plusieurs instances de cette classe...">MD_Vector</a>&amp; md = master_vect.<a class="code" href="classIntVect.html#ae74e1fee6aca124d32718267e33a40c6">get_md_vector</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> vect_size_tot = master_vect.<a class="code" href="classIntVect.html#afa716e1f0a1f0f74f4f73e95b5651412" title="Identique a size_array()">size_totale</a>();
<span class="comment">// Determine blocs of data to process, depending on &quot; opt&quot;</span>
  <span class="keywordtype">int</span> nblocs_left = 1;
  <span class="keywordtype">int</span> one_bloc[2];
  <span class="keyword">const</span> <span class="keywordtype">int</span> *bloc_ptr;
  <span class="keywordflow">if</span> ( opt != <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caad18680091a9f62247573cb3caa6450b9">VECT_ALL_ITEMS</a> &amp;&amp; md.<a class="code" href="classMD__Vector.html#a4165c00904b7096274e38fdc7ca340f4">non_nul</a>())
    {
      assert( opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a> ||  opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caab47906d8d2e6c20f8ba32e4acb6edbe0">VECT_REAL_ITEMS</a>);
      <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; items_blocs = ( opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a>) ? md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a7f6b6d0b7babfec0cce590cdea5bca53">get_items_to_sum</a>() : md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a99334ac2566d9457c8d4890ba20883ea">get_items_to_compute</a>();
      assert(items_blocs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() % 2 == 0);
      nblocs_left = items_blocs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() &gt;&gt; 1;
      bloc_ptr = items_blocs.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
    }
  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (vect_size_tot &gt; 0)
    {
<span class="comment">// attention, si vect_size_tot est nul, line_size a le droit d&#39;etre nul</span>
<span class="comment">// Compute all data, in the vector (including virtual data), build a big bloc:</span>
      nblocs_left = 1;
      bloc_ptr = one_bloc;
      one_bloc[0] = 0;
      one_bloc[1] = vect_size_tot / line_size;
    }
  <span class="keywordflow">else</span>
    {
<span class="comment">// raccourci pour les tableaux vides (evite le cas particulier line_size == 0)</span>
      return ;
    }
  <span class="keywordtype">int</span> *resu_base = resu.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
  <span class="keywordflow">for</span> (; nblocs_left; nblocs_left--)
    {
<span class="comment">// Get index of next bloc start:</span>
      <span class="keyword">const</span> <span class="keywordtype">int</span> begin_bloc = (*(bloc_ptr++)) * line_size;
      <span class="keyword">const</span> <span class="keywordtype">int</span> end_bloc = (*(bloc_ptr++)) * line_size;
      assert(begin_bloc &gt;= 0 &amp;&amp; end_bloc &lt;= vect_size_tot &amp;&amp; end_bloc &gt;= begin_bloc);
      <span class="keywordtype">int</span>* resu_ptr = resu_base + begin_bloc;
      <span class="keywordtype">int</span> count = end_bloc - begin_bloc;
      <span class="keywordflow">for</span> (; count; count--)
        {
          <span class="keywordtype">int</span>&amp; p_resu = *(resu_ptr++);
          p_resu = -p_resu;
        }
    }
<span class="comment">// In debug mode, put invalid values where data has not been computed</span>
<span class="preprocessor">#ifndef NDEBUG</span>
<span class="preprocessor"></span>  <a class="code" href="IntVect_8cpp.html#a27f59c580905a55953c9aa2734a1fc73">invalidate_data</a>(resu,  opt);
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>  return ;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a56f7235fca2df79d0bf1563d0bc791b0"></a><!-- doxytag: member="IntVect.h::operator_sub" ref="a56f7235fca2df79d0bf1563d0bc791b0" args="(IntVect &amp;resu, const int x, Mp_vect_options opt=VECT_ALL_ITEMS)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operator_sub </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classIntVect.html">IntVect</a> &amp;&#160;</td>
          <td class="paramname"><em>resu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a>&#160;</td>
          <td class="paramname"><em>opt</em> = <code>VECT_ALL_ITEMS</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="IntVect_8cpp_source.html#l01169">1169</a> of file <a class="el" href="IntVect_8cpp_source.html">IntVect.cpp</a>.</p>

<p>References <a class="el" href="ArrOfInt_8h_source.html#l00371">ArrOfInt::addr()</a>, <a class="el" href="classMD__Vector__base.html#a99334ac2566d9457c8d4890ba20883ea">MD_Vector_base::get_items_to_compute()</a>, <a class="el" href="classMD__Vector__base.html#a7f6b6d0b7babfec0cce590cdea5bca53">MD_Vector_base::get_items_to_sum()</a>, <a class="el" href="IntVect_8h_source.html#l00087">IntVect::get_md_vector()</a>, <a class="el" href="IntVect_8cpp_source.html#l00367">invalidate_data()</a>, <a class="el" href="IntVect_8h_source.html#l00150">IntVect::line_size()</a>, <a class="el" href="MD__Vector_8h_source.html#l00063">MD_Vector::non_nul()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00342">ArrOfInt::size_array()</a>, <a class="el" href="IntVect_8h_source.html#l00145">IntVect::size_totale()</a>, <a class="el" href="MD__Vector_8h_source.html#l00067">MD_Vector::valeur()</a>, <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_ALL_ITEMS</a>, <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_REAL_ITEMS</a>, and <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_SEQUENTIAL_ITEMS</a>.</p>
<div class="fragment"><pre class="fragment">{

<span class="comment">// Master vect donne la structure de reference, les autres vecteurs</span>
<span class="comment">// doivent avoir la meme structure.</span>
  <span class="keyword">const</span> <a class="code" href="classIntVect.html">IntVect</a>&amp; master_vect = resu;
  <span class="keywordtype">int</span> line_size = master_vect.<a class="code" href="classIntVect.html#a5ba680066169c8e057bb3e3b876e4a8c">line_size</a>();
  <span class="keyword">const</span> <a class="code" href="classMD__Vector.html" title=": Cette classe est un DERIV mais l&#39;objet pointe est partage entre plusieurs instances de cette classe...">MD_Vector</a>&amp; md = master_vect.<a class="code" href="classIntVect.html#ae74e1fee6aca124d32718267e33a40c6">get_md_vector</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> vect_size_tot = master_vect.<a class="code" href="classIntVect.html#afa716e1f0a1f0f74f4f73e95b5651412" title="Identique a size_array()">size_totale</a>();
<span class="comment">// Determine blocs of data to process, depending on &quot; opt&quot;</span>
  <span class="keywordtype">int</span> nblocs_left = 1;
  <span class="keywordtype">int</span> one_bloc[2];
  <span class="keyword">const</span> <span class="keywordtype">int</span> *bloc_ptr;
  <span class="keywordflow">if</span> ( opt != <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caad18680091a9f62247573cb3caa6450b9">VECT_ALL_ITEMS</a> &amp;&amp; md.<a class="code" href="classMD__Vector.html#a4165c00904b7096274e38fdc7ca340f4">non_nul</a>())
    {
      assert( opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a> ||  opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caab47906d8d2e6c20f8ba32e4acb6edbe0">VECT_REAL_ITEMS</a>);
      <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; items_blocs = ( opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a>) ? md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a7f6b6d0b7babfec0cce590cdea5bca53">get_items_to_sum</a>() : md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a99334ac2566d9457c8d4890ba20883ea">get_items_to_compute</a>();
      assert(items_blocs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() % 2 == 0);
      nblocs_left = items_blocs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() &gt;&gt; 1;
      bloc_ptr = items_blocs.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
    }
  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (vect_size_tot &gt; 0)
    {
<span class="comment">// attention, si vect_size_tot est nul, line_size a le droit d&#39;etre nul</span>
<span class="comment">// Compute all data, in the vector (including virtual data), build a big bloc:</span>
      nblocs_left = 1;
      bloc_ptr = one_bloc;
      one_bloc[0] = 0;
      one_bloc[1] = vect_size_tot / line_size;
    }
  <span class="keywordflow">else</span>
    {
<span class="comment">// raccourci pour les tableaux vides (evite le cas particulier line_size == 0)</span>
      return ;
    }
  <span class="keywordtype">int</span> *resu_base = resu.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
  <span class="keywordflow">for</span> (; nblocs_left; nblocs_left--)
    {
<span class="comment">// Get index of next bloc start:</span>
      <span class="keyword">const</span> <span class="keywordtype">int</span> begin_bloc = (*(bloc_ptr++)) * line_size;
      <span class="keyword">const</span> <span class="keywordtype">int</span> end_bloc = (*(bloc_ptr++)) * line_size;
      assert(begin_bloc &gt;= 0 &amp;&amp; end_bloc &lt;= vect_size_tot &amp;&amp; end_bloc &gt;= begin_bloc);
      <span class="keywordtype">int</span>* resu_ptr = resu_base + begin_bloc;
      <span class="keywordtype">int</span> count = end_bloc - begin_bloc;
      <span class="keywordflow">for</span> (; count; count--)
        {
          <span class="keywordtype">int</span>&amp; p_resu = *(resu_ptr++);
          p_resu -= x;
        }
    }
<span class="comment">// In debug mode, put invalid values where data has not been computed</span>
<span class="preprocessor">#ifndef NDEBUG</span>
<span class="preprocessor"></span>  <a class="code" href="IntVect_8cpp.html#a27f59c580905a55953c9aa2734a1fc73">invalidate_data</a>(resu,  opt);
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>  return ;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a0fbb812621f4a0d626e259bcfe234600"></a><!-- doxytag: member="IntVect.h::operator_sub" ref="a0fbb812621f4a0d626e259bcfe234600" args="(IntVect &amp;resu, const IntVect &amp;vx, Mp_vect_options opt=VECT_ALL_ITEMS)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operator_sub </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classIntVect.html">IntVect</a> &amp;&#160;</td>
          <td class="paramname"><em>resu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIntVect.html">IntVect</a> &amp;&#160;</td>
          <td class="paramname"><em>vx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a>&#160;</td>
          <td class="paramname"><em>opt</em> = <code>VECT_ALL_ITEMS</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>&lt; this test is necessary if md is null </p>
</p>

<p>Definition at line <a class="el" href="IntVect_8cpp_source.html#l01106">1106</a> of file <a class="el" href="IntVect_8cpp_source.html">IntVect.cpp</a>.</p>

<p>References <a class="el" href="ArrOfInt_8h_source.html#l00371">ArrOfInt::addr()</a>, <a class="el" href="classMD__Vector__base.html#a99334ac2566d9457c8d4890ba20883ea">MD_Vector_base::get_items_to_compute()</a>, <a class="el" href="classMD__Vector__base.html#a7f6b6d0b7babfec0cce590cdea5bca53">MD_Vector_base::get_items_to_sum()</a>, <a class="el" href="IntVect_8h_source.html#l00087">IntVect::get_md_vector()</a>, <a class="el" href="IntVect_8cpp_source.html#l00367">invalidate_data()</a>, <a class="el" href="IntVect_8h_source.html#l00150">IntVect::line_size()</a>, <a class="el" href="MD__Vector_8h_source.html#l00063">MD_Vector::non_nul()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00342">ArrOfInt::size_array()</a>, <a class="el" href="IntVect_8h_source.html#l00145">IntVect::size_totale()</a>, <a class="el" href="MD__Vector_8h_source.html#l00067">MD_Vector::valeur()</a>, <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_ALL_ITEMS</a>, <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_REAL_ITEMS</a>, and <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_SEQUENTIAL_ITEMS</a>.</p>
<div class="fragment"><pre class="fragment">{

<span class="comment">// Master vect donne la structure de reference, les autres vecteurs</span>
<span class="comment">// doivent avoir la meme structure.</span>
  <span class="keyword">const</span> <a class="code" href="classIntVect.html">IntVect</a>&amp; master_vect = resu;
  <span class="keywordtype">int</span> line_size = master_vect.<a class="code" href="classIntVect.html#a5ba680066169c8e057bb3e3b876e4a8c">line_size</a>();
  <span class="keyword">const</span> <a class="code" href="classMD__Vector.html" title=": Cette classe est un DERIV mais l&#39;objet pointe est partage entre plusieurs instances de cette classe...">MD_Vector</a>&amp; md = master_vect.<a class="code" href="classIntVect.html#ae74e1fee6aca124d32718267e33a40c6">get_md_vector</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> vect_size_tot = master_vect.<a class="code" href="classIntVect.html#afa716e1f0a1f0f74f4f73e95b5651412" title="Identique a size_array()">size_totale</a>();
  assert(vx.<a class="code" href="classIntVect.html#a5ba680066169c8e057bb3e3b876e4a8c">line_size</a>() == line_size);
  assert(vx.<a class="code" href="classIntVect.html#afa716e1f0a1f0f74f4f73e95b5651412" title="Identique a size_array()">size_totale</a>() == vect_size_tot); <span class="comment">//!&lt; this test is necessary if md is null</span>
<span class="comment"></span>  assert(vx.<a class="code" href="classIntVect.html#ae74e1fee6aca124d32718267e33a40c6">get_md_vector</a>() == md);
<span class="comment">// Determine blocs of data to process, depending on &quot; opt&quot;</span>
  <span class="keywordtype">int</span> nblocs_left = 1;
  <span class="keywordtype">int</span> one_bloc[2];
  <span class="keyword">const</span> <span class="keywordtype">int</span> *bloc_ptr;
  <span class="keywordflow">if</span> ( opt != <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caad18680091a9f62247573cb3caa6450b9">VECT_ALL_ITEMS</a> &amp;&amp; md.<a class="code" href="classMD__Vector.html#a4165c00904b7096274e38fdc7ca340f4">non_nul</a>())
    {
      assert( opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a> ||  opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caab47906d8d2e6c20f8ba32e4acb6edbe0">VECT_REAL_ITEMS</a>);
      <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; items_blocs = ( opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a>) ? md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a7f6b6d0b7babfec0cce590cdea5bca53">get_items_to_sum</a>() : md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a99334ac2566d9457c8d4890ba20883ea">get_items_to_compute</a>();
      assert(items_blocs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() % 2 == 0);
      nblocs_left = items_blocs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() &gt;&gt; 1;
      bloc_ptr = items_blocs.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
    }
  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (vect_size_tot &gt; 0)
    {
<span class="comment">// attention, si vect_size_tot est nul, line_size a le droit d&#39;etre nul</span>
<span class="comment">// Compute all data, in the vector (including virtual data), build a big bloc:</span>
      nblocs_left = 1;
      bloc_ptr = one_bloc;
      one_bloc[0] = 0;
      one_bloc[1] = vect_size_tot / line_size;
    }
  <span class="keywordflow">else</span>
    {
<span class="comment">// raccourci pour les tableaux vides (evite le cas particulier line_size == 0)</span>
      return ;
    }
  <span class="keywordtype">int</span> *resu_base = resu.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> *x_base = vx.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
  <span class="keywordflow">for</span> (; nblocs_left; nblocs_left--)
    {
<span class="comment">// Get index of next bloc start:</span>
      <span class="keyword">const</span> <span class="keywordtype">int</span> begin_bloc = (*(bloc_ptr++)) * line_size;
      <span class="keyword">const</span> <span class="keywordtype">int</span> end_bloc = (*(bloc_ptr++)) * line_size;
      assert(begin_bloc &gt;= 0 &amp;&amp; end_bloc &lt;= vect_size_tot &amp;&amp; end_bloc &gt;= begin_bloc);
      <span class="keywordtype">int</span>* resu_ptr = resu_base + begin_bloc;
      <span class="keyword">const</span> <span class="keywordtype">int</span>* x_ptr = x_base + begin_bloc;
      <span class="keywordtype">int</span> count = end_bloc - begin_bloc;
      <span class="keywordflow">for</span> (; count; count--)
        {
          <span class="keyword">const</span> <span class="keywordtype">int</span> x = *x_ptr;
          <span class="keywordtype">int</span>&amp; p_resu = *(resu_ptr++);
          p_resu -= x;
          x_ptr++;
        }
    }
<span class="comment">// In debug mode, put invalid values where data has not been computed</span>
<span class="preprocessor">#ifndef NDEBUG</span>
<span class="preprocessor"></span>  <a class="code" href="IntVect_8cpp.html#a27f59c580905a55953c9aa2734a1fc73">invalidate_data</a>(resu,  opt);
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>  return ;
}
</pre></div>
</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Tue Dec 14 2021 19:35:52 for TRUST by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
