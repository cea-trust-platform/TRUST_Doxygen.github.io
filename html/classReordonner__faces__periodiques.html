<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>TRUST: Reordonner_faces_periodiques Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">TRUST&#160;<span id="projectnumber">1.8.4</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-static-methods">Static Public Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">Reordonner_faces_periodiques Class Reference</div>  </div>
</div>
<div class="contents">
<!-- doxytag: class="Reordonner_faces_periodiques" --><!-- doxytag: inherits="Interprete_geometrique_base" -->
<p>Cet interprete permet de reordonner les faces d'un bord periodique selon la convention<br/>
utilisee dans le decoupeur (d'abord les faces d'une extremite du domaine, puis dans le<br/>
meme ordre, les faces jumelles sur le bord oppose).  
 <a href="classReordonner__faces__periodiques.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="Reordonner__faces__periodiques_8h_source.html">Reordonner_faces_periodiques.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Reordonner_faces_periodiques:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classReordonner__faces__periodiques.png" usemap="#Reordonner_faces_periodiques_map" alt=""/>
  <map id="Reordonner_faces_periodiques_map" name="Reordonner_faces_periodiques_map">
<area href="classInterprete__geometrique__base.html" title="classe Interprete_geometrique_base ." alt="Interprete_geometrique_base" shape="rect" coords="0,168,189,192"/>
<area href="classInterprete.html" title="Classe de base des objets &quot;interprete&quot;. Ces objets definissent des actions a realiser lorsqu&#39;on les..." alt="Interprete" shape="rect" coords="0,112,189,136"/>
<area href="classObjet__U.html" title="classe Objet_U Cette classe est la classe de base des Objets de TRUST Dans les classes derivees de Ob..." alt="Objet_U" shape="rect" coords="0,56,189,80"/>
<area href="classProcess.html" title="Classe de base de TRUST (notamment Objet_U). Elle fournit quelques services de base accessibles de pa..." alt="Process" shape="rect" coords="0,0,189,24"/>
</map>
 </div></div>

<p><a href="classReordonner__faces__periodiques-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classReordonner__faces__periodiques.html#a3d177f6fcafb470513dad54fe4d9f79a">reordonner_faces_periodiques</a> (const <a class="el" href="classDomaine.html">Domaine</a> &amp;domaine, <a class="el" href="classIntTab.html">IntTab</a> &amp;faces, const <a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;direction_perio, const double epsilon)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Reordonne le tableau "faces" selon la convention des faces periodiques:<br/>
D'abord les faces d'une extremite, puis dans le meme ordre, les faces jumelles.<br/>
Attention, l'algorithme est en n carre (lent), et ne fonctionne qu'en sequentiel.<br/>
Parametre: zone<br/>
Signification: la zone a laquelle appartiennent les faces<br/>
Parametre: direction_perio<br/>
Signification: le vecteur qui separe le centre d'une face au centre de la face opposee<br/>
Parametre: faces<br/>
Signification: le tableau des faces (pour chaque face, indices de ses sommets) a reordonner<br/>
Valeur de retour: 1 si ok, 0 si on n'a pas trouve de face jumelle a une face a precision_geom pres.  <a href="#a3d177f6fcafb470513dad54fe4d9f79a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classReordonner__faces__periodiques.html#aee6a67196132bed17c8d786d6c39316c">renum_som_perio</a> (const <a class="el" href="classDomaine.html">Domaine</a> &amp;, const <a class="el" href="classNoms.html">Noms</a> &amp;liste_bords_periodiques, <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;renum_som_perio, const int calculer_espace_virtuel)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classReordonner__faces__periodiques.html#a57cfec8f17ae27a831df8c1a6c27e8cf">check_faces_periodiques</a> (const <a class="el" href="classFrontiere.html">Frontiere</a> &amp;frontiere, <a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;vecteur_delta, <a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;erreur, const int <a class="el" href="Solv__Petsc_8cpp.html#ab3f078684998b83967d507d0f453f454">verbose</a>=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">essaie de verifier si les faces du bord num_bord sont ordonnees suivant la convention<br/>
des faces periodiques. On stocke dans vecteur_delta la direction de periodicite presumee (intervalle<br/>
mesure entre la premiere face et la face jumelle), et erreur le max de l'erreur par rapport a cette<br/>
mesure pour les autres faces.<br/>
En parallele, l'erreur est le max sur tous les processeurs<br/>
Valeur de retour: 1 si ok, 0 si l'erreur est superieure a precision_geom.  <a href="#a57cfec8f17ae27a831df8c1a6c27e8cf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classReordonner__faces__periodiques.html#ad93560d3838d3516deb892d88b47dedf">chercher_direction_perio</a> (<a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;direction_perio, const <a class="el" href="classDomaine.html">Domaine</a> &amp;dom, const <a class="el" href="classNom.html">Nom</a> &amp;bord)</td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Cet interprete permet de reordonner les faces d'un bord periodique selon la convention<br/>
utilisee dans le decoupeur (d'abord les faces d'une extremite du domaine, puis dans le<br/>
meme ordre, les faces jumelles sur le bord oppose). </p>

<p>Definition at line <a class="el" href="Reordonner__faces__periodiques_8h_source.html#l00038">38</a> of file <a class="el" href="Reordonner__faces__periodiques_8h_source.html">Reordonner_faces_periodiques.h</a>.</p>
</div><hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a57cfec8f17ae27a831df8c1a6c27e8cf"></a><!-- doxytag: member="Reordonner_faces_periodiques::check_faces_periodiques" ref="a57cfec8f17ae27a831df8c1a6c27e8cf" args="(const Frontiere &amp;frontiere, ArrOfDouble &amp;vecteur_delta, ArrOfDouble &amp;erreur, const int verbose=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Reordonner_faces_periodiques::check_faces_periodiques </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFrontiere.html">Frontiere</a> &amp;&#160;</td>
          <td class="paramname"><em>frontiere</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;&#160;</td>
          <td class="paramname"><em>vecteur_delta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;&#160;</td>
          <td class="paramname"><em>erreur</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>verbose</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>essaie de verifier si les faces du bord num_bord sont ordonnees suivant la convention<br/>
des faces periodiques. On stocke dans vecteur_delta la direction de periodicite presumee (intervalle<br/>
mesure entre la premiere face et la face jumelle), et erreur le max de l'erreur par rapport a cette<br/>
mesure pour les autres faces.<br/>
En parallele, l'erreur est le max sur tous les processeurs<br/>
Valeur de retour: 1 si ok, 0 si l'erreur est superieure a precision_geom. </p>

<p>Definition at line <a class="el" href="Reordonner__faces__periodiques_8cpp_source.html#l00216">216</a> of file <a class="el" href="Reordonner__faces__periodiques_8cpp_source.html">Reordonner_faces_periodiques.cpp</a>.</p>

<p>References <a class="el" href="Process_8cpp_source.html#l00127">Process::barrier()</a>, <a class="el" href="Reordonner__faces__periodiques_8cpp_source.html#l00034">calculer_vecteur_2faces()</a>, <a class="el" href="EntreeSortie_8h_source.html#l00032">Cerr</a>, <a class="el" href="Double_8h_source.html#l00255">dabs()</a>, <a class="el" href="IntTab_8h_source.html#l00233">IntTab::dimension()</a>, <a class="el" href="Objet__U_8h_source.html#l00079">Objet_U::dimension</a>, <a class="el" href="Zone_8cpp_source.html#l00262">Zone::domaine()</a>, <a class="el" href="Process_8cpp_source.html#l00223">Process::exit()</a>, <a class="el" href="Frontiere_8h_source.html#l00175">Frontiere::faces()</a>, <a class="el" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>, <a class="el" href="Process_8cpp_source.html#l00095">Process::je_suis_maitre()</a>, <a class="el" href="Frontiere_8h_source.html#l00155">Frontiere::le_nom()</a>, <a class="el" href="Domaine_8h_source.html#l00577">Domaine::les_sommets()</a>, <a class="el" href="Faces_8h_source.html#l00268">Faces::les_sommets()</a>, <a class="el" href="Double_8h_source.html#l00180">max()</a>, <a class="el" href="Reordonner__faces__periodiques_8cpp_source.html#l00028">message()</a>, <a class="el" href="Process_8cpp_source.html#l00156">Process::mp_max()</a>, <a class="el" href="Process_8cpp_source.html#l00109">Process::nproc()</a>, <a class="el" href="Objet__U_8h_source.html#l00080">Objet_U::precision_geom</a>, <a class="el" href="ArrOfDouble_8h_source.html#l00244">ArrOfDouble::resize_array()</a>, and <a class="el" href="Frontiere_8cpp_source.html#l00260">Frontiere::zone()</a>.</p>

<p>Referenced by <a class="el" href="Partitionneur__base_8cpp_source.html#l00147">Partitionneur_base::calculer_graphe_connexions_periodiques()</a>, <a class="el" href="Partitionneur__Tranche_8cpp_source.html#l00128">Partitionneur_Tranche::chercher_direction_perio()</a>, <a class="el" href="Periodique_8cpp_source.html#l00072">Periodique::completer()</a>, and <a class="el" href="Reordonner__faces__periodiques_8cpp_source.html#l00289">renum_som_perio()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">const</span> <span class="keywordtype">int</span> dim = <a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>;
  vecteur_delta.<a class="code" href="classArrOfDouble.html#a610464f4b3dccac6f814915b526783ed">resize_array</a>(dim);
  vecteur_delta = 0.;
  erreur.<a class="code" href="classArrOfDouble.html#a610464f4b3dccac6f814915b526783ed">resize_array</a>(dim);
  erreur = 0.;

  <span class="keywordflow">if</span> (<a class="code" href="Solv__Petsc_8cpp.html#ab3f078684998b83967d507d0f453f454">verbose</a> &amp;&amp; <a class="code" href="classProcess.html#acd052b99706c577f8a5b6656217cf4c2" title="renvoie 1 si on est sur le processeur maitre du groupe courant (c&#39;est a dire me() == 0)...">Process::je_suis_maitre</a>())
    {
      <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Check periodic faces to the boundary : &quot;</span> &lt;&lt; frontiere.<a class="code" href="classFrontiere.html#a2868774681d6f050479a95cbc7cd6fc9" title="Renvoie le nom de la frontiere.">le_nom</a>() &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
    }
  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; faces = frontiere.<a class="code" href="classFrontiere.html#ac64479069f0c43a17cb5766a39ce5ba8" title="Renvoie les faces de la frontiere&lt;br&gt;(version const)">faces</a>().<a class="code" href="classFaces.html#a07b8d8db9e3d656b93a21a49c063430c">les_sommets</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_faces = faces.<a class="code" href="classIntTab.html#abc3b32c94925a82f69d5b153a356e359" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(0);
  <span class="keywordflow">if</span> (nb_faces % 2 != 0)
    {
      <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Error in Check_faces_periodiques to the boundary &quot;</span> &lt;&lt; frontiere.<a class="code" href="classFrontiere.html#a2868774681d6f050479a95cbc7cd6fc9" title="Renvoie le nom de la frontiere.">le_nom</a>()
           &lt;&lt; <span class="stringliteral">&quot;\n The number of faces is odd : &quot;</span> &lt;&lt; nb_faces &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
      <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">Process::exit</a>();
    }
  <span class="keyword">const</span> <span class="keywordtype">int</span> n = nb_faces / 2;
  <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a> coord = frontiere.<a class="code" href="classFrontiere.html#a510866aace5f3ed9482553db1a08a3c9" title="Renvoie la Zone associee a la frontiere. (version const)">zone</a>().<a class="code" href="classZone.html#a379ad2206b5a13a4f4f3df6d44c7546a" title="Renvoie le domaine dont la zone fait partie. (version const)">domaine</a>().<a class="code" href="classDomaine.html#a0846ac03a10b65c4df911fe35a19c02f" title="Renvoie le nombre total de sommets.">les_sommets</a>();

  <span class="keywordtype">int</span> i;
<span class="comment">// Calculer un vecteur delta (tous les procs n&#39;ont pas forcement des faces de ce bord)</span>
  vecteur_delta = -1.e37;
  <span class="keywordflow">if</span> (n &gt; 0)
    <a class="code" href="Reordonner__faces__periodiques_8cpp.html#a9ccc16e361d118d704a6e7c93ec0b3df">calculer_vecteur_2faces</a>(coord, faces, 0, n, vecteur_delta);
  <span class="keywordflow">for</span> (i = 0; i &lt; dim; i++)
    vecteur_delta[i] = <a class="code" href="classProcess.html#a1e9d9f9899b71927cfafae14c7bd048d" title="Calcule le max de x sur tous les processeurs du groupe courant. Remarques : Cette methode doit etre a...">Process::mp_max</a>(vecteur_delta[i]);

<span class="comment">// Calculer pour chaque face l&#39;erreur par rapport a ce vecteur delta.</span>
  <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a> vect(dim);
  <span class="keywordflow">for</span> (i = 0; i &lt; n; i++)
    {
      <a class="code" href="Reordonner__faces__periodiques_8cpp.html#a9ccc16e361d118d704a6e7c93ec0b3df">calculer_vecteur_2faces</a>(coord, faces, i, i+n, vect);
<span class="comment">// Calcul de la difference entre vect et vecteur_delta:</span>
      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> compo = 0; compo &lt; dim; compo++)
        erreur[compo] = <a class="code" href="Double_8h.html#a1c45761573e6cbc97cfacac78d905016">max</a>(erreur[compo], <a class="code" href="Double_8h.html#aaecd4ca8a2fe69cc6568af2938b94d2e">dabs</a>(vecteur_delta[compo] - vect[compo]));
    }
  <span class="keywordtype">double</span> maxerr = 0.;
<span class="comment">// Calcul du max sur tous les procs:</span>
  <span class="keywordflow">for</span> (i = 0; i &lt; dim; i++)
    {
      erreur[i] = <a class="code" href="classProcess.html#a1e9d9f9899b71927cfafae14c7bd048d" title="Calcule le max de x sur tous les processeurs du groupe courant. Remarques : Cette methode doit etre a...">Process::mp_max</a>(erreur[i]);
      maxerr = <a class="code" href="Double_8h.html#a1c45761573e6cbc97cfacac78d905016">max</a>(maxerr, erreur[i]);
    }

  <span class="keywordflow">if</span> (<a class="code" href="Solv__Petsc_8cpp.html#ab3f078684998b83967d507d0f453f454">verbose</a> &amp;&amp; <a class="code" href="classProcess.html#acd052b99706c577f8a5b6656217cf4c2" title="renvoie 1 si on est sur le processeur maitre du groupe courant (c&#39;est a dire me() == 0)...">Process::je_suis_maitre</a>())
    {
      <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot; Delta vector = [ &quot;</span>;
      <span class="keywordflow">for</span> (i = 0; i &lt; dim; i++) <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; vecteur_delta[i] &lt;&lt; <span class="stringliteral">&quot; &quot;</span>;
      <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;]  error = [ &quot;</span>;
      <span class="keywordflow">for</span> (i = 0; i &lt; dim; i++) <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; erreur[i] &lt;&lt; <span class="stringliteral">&quot; &quot;</span>;
      <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;]&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
    }
  <span class="keywordflow">if</span> (!(maxerr &lt; <a class="code" href="classObjet__U.html#a7447e25c68cc8d3a1c06cf99f0565cff">Objet_U::precision_geom</a>))
    {
      <span class="keywordflow">if</span> (<a class="code" href="classProcess.html#acd052b99706c577f8a5b6656217cf4c2" title="renvoie 1 si on est sur le processeur maitre du groupe courant (c&#39;est a dire me() == 0)...">Process::je_suis_maitre</a>())
        {
          <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot; This boundary is not detected as periodic (geometric error &gt; precision_geom)&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
          <a class="code" href="Reordonner__faces__periodiques_8cpp.html#a137d78a01e63d3b66d1b2ed0de0f4c4c">message</a>();
          <span class="keywordflow">if</span> (<a class="code" href="classProcess.html#a6bf692ce58d9578aa62ac3c07b8caaa1" title="renvoie le nombre de processeurs dans le groupe courant Voir Comm_Group::nproc() et PE_Groups::curren...">Process::nproc</a>()&gt;1) <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Or you forgot to define the periodic boundary in the Decouper keyword.&quot;</span> &lt;&lt; finl;
        } <span class="comment">//!&lt; attendre qu&#39;on ait ecrit pour continuer (sinon risque de exit() avant d&#39;avoir affiche le message)</span>
<span class="comment"></span>      <a class="code" href="classProcess.html#aa9e74a5c06a68ea38298a08ea401e7b1" title="Synchronise tous les processeurs du groupe courant&lt;br&gt;(attend que tous les processeurs soient arrives...">Process::barrier</a>();
      <span class="keywordflow">return</span> 0;
    }
  <span class="keywordflow">return</span> 1;
}
</pre></div>
</div>
</div>
<a class="anchor" id="ad93560d3838d3516deb892d88b47dedf"></a><!-- doxytag: member="Reordonner_faces_periodiques::chercher_direction_perio" ref="ad93560d3838d3516deb892d88b47dedf" args="(ArrOfDouble &amp;direction_perio, const Domaine &amp;dom, const Nom &amp;bord)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Reordonner_faces_periodiques::chercher_direction_perio </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;&#160;</td>
          <td class="paramname"><em>direction_perio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDomaine.html">Domaine</a> &amp;&#160;</td>
          <td class="paramname"><em>dom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classNom.html">Nom</a> &amp;&#160;</td>
          <td class="paramname"><em>bord</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Reordonner__faces__periodiques_8cpp_source.html#l00065">65</a> of file <a class="el" href="Reordonner__faces__periodiques_8cpp_source.html">Reordonner_faces_periodiques.cpp</a>.</p>

<p>References <a class="el" href="Elem__geom_8h_source.html#l00244">Elem_geom::calculer_normales()</a>, <a class="el" href="Reordonner__faces__periodiques_8cpp_source.html#l00034">calculer_vecteur_2faces()</a>, <a class="el" href="EntreeSortie_8h_source.html#l00032">Cerr</a>, <a class="el" href="Domaine_8h_source.html#l00500">Domaine::coord_sommets()</a>, <a class="el" href="Double_8h_source.html#l00255">dabs()</a>, <a class="el" href="IntTab_8h_source.html#l00233">IntTab::dimension()</a>, <a class="el" href="DoubleTab_8h_source.html#l00243">DoubleTab::dimension()</a>, <a class="el" href="Frontiere_8h_source.html#l00175">Frontiere::faces()</a>, <a class="el" href="Zone_8h_source.html#l00840">Zone::frontiere()</a>, <a class="el" href="Domaine_8h_source.html#l00204">Domaine::le_nom()</a>, <a class="el" href="Faces_8h_source.html#l00268">Faces::les_sommets()</a>, <a class="el" href="Reordonner__faces__periodiques_8cpp_source.html#l00056">local_norme_vect()</a>, <a class="el" href="Double_8h_source.html#l00180">max()</a>, <a class="el" href="ArrOfDouble_8cpp_source.html#l00814">max_array()</a>, <a class="el" href="Double_8h_source.html#l00199">min()</a>, <a class="el" href="ArrOfDouble_8cpp_source.html#l00792">min_array()</a>, <a class="el" href="Frontiere_8h_source.html#l00114">Frontiere::nb_faces()</a>, <a class="el" href="ArrOfDouble_8h_source.html#l00244">ArrOfDouble::resize_array()</a>, <a class="el" href="Zone_8h_source.html#l00491">Zone::type_elem()</a>, and <a class="el" href="Domaine_8h_source.html#l00272">Domaine::zone()</a>.</p>

<p>Referenced by <a class="el" href="Corriger__frontiere__periodique_8cpp_source.html#l00060">Corriger_frontiere_periodique::interpreter_()</a>, and <a class="el" href="Scatter_8cpp_source.html#l00513">Scatter::lire_domaine()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; sommets = dom.<a class="code" href="classDomaine.html#aecd32c3eecc15cce7d1a0e468dadbf96" title="Renvoie le tableau des coordonnees des noeuds (sommets). (acces en lecture)">coord_sommets</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> dim = sommets.<a class="code" href="classDoubleTab.html#ac3805e2637a3b880ba2d3e650c69dac4" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(1);
  direction_perio.<a class="code" href="classArrOfDouble.html#a610464f4b3dccac6f814915b526783ed">resize_array</a>(dim);
  direction_perio = 0.;
  <span class="keyword">const</span> <a class="code" href="classFrontiere.html" title="Classe Frontiere. Une Frontiere decrit une partie de la frontiere d&#39;une Zone, elle possede un Nom...">Frontiere</a>&amp; front = dom.<a class="code" href="classDomaine.html#a0e62f2bc829542fafa29e3f2c614159c" title="Renvoie la i-ieme zone du domaine. (version const)">zone</a>(0).<a class="code" href="classZone.html#ac338b119d4b0bc4f510a223b9086fe5e">frontiere</a>(bord);
  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_faces = front.<a class="code" href="classFrontiere.html#aa073fe9dbdddde59471ee7032b256aa2" title="Renvoie le nombre de faces de la frontiere.">nb_faces</a>();
  <span class="keywordflow">if</span> (nb_faces == 0)
    <span class="keywordflow">return</span>;
  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; faces = front.<a class="code" href="classFrontiere.html#ac64479069f0c43a17cb5766a39ce5ba8" title="Renvoie les faces de la frontiere&lt;br&gt;(version const)">faces</a>().<a class="code" href="classFaces.html#a07b8d8db9e3d656b93a21a49c063430c">les_sommets</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_som_face = faces.<a class="code" href="classIntTab.html#abc3b32c94925a82f69d5b153a356e359" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(1);
  <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a> normale(1, dim);
  <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a> une_face(1, nb_som_face);
  <span class="keywordtype">int</span> i;
  <span class="keywordflow">for</span> (i = 0; i &lt; nb_som_face; i++)
    une_face(0, i) = faces(0, i);
  dom.<a class="code" href="classDomaine.html#a0e62f2bc829542fafa29e3f2c614159c" title="Renvoie la i-ieme zone du domaine. (version const)">zone</a>(0).<a class="code" href="classZone.html#a18cf83cd0f9c368dcfa32fb802a0ac94" title="Renvoie un element geometrique du type de ceux qui constituent la zone. (version const)">type_elem</a>().<a class="code" href="classElem__geom.html#ae13918e636dd8b8b6b3c3e033d1bd047" title="Appel a l&#39;objet sous-jacent Calcule les normales aux faces des elements de la zone associee...">calculer_normales</a>(une_face, normale);
  normale /= <a class="code" href="Reordonner__faces__periodiques_8cpp.html#a01a9b5b584c7cfcd7362404cea1d69a9">local_norme_vect</a>(normale);

  <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a> delta(nb_faces);
  <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a> vect(dim);
  <span class="keywordflow">for</span> (i = 1; i &lt; nb_faces; i++)
    {
      <a class="code" href="Reordonner__faces__periodiques_8cpp.html#a9ccc16e361d118d704a6e7c93ec0b3df">calculer_vecteur_2faces</a>(sommets, faces, 0, i, vect);
      <span class="keywordtype">double</span> x = 0.;
      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; dim; j++)
        x += vect[j] * normale(0,j);
      delta[i] = x;
    }
  <span class="keyword">const</span> <span class="keywordtype">double</span> <a class="code" href="Double_8h.html#a2f8edc4561e9744ed4233b205fa7ec32">min</a> = <a class="code" href="ArrOfDouble_8cpp.html#abd3998749a1a8dab00dd6ac1798327fb" title="Retourne la valeur minimale.">min_array</a>(delta);
  <span class="keyword">const</span> <span class="keywordtype">double</span> <a class="code" href="Double_8h.html#a1c45761573e6cbc97cfacac78d905016">max</a> = <a class="code" href="ArrOfDouble_8cpp.html#a95241fccf4bed7fb7a4e2340b7735f14" title="Retourne la valeur maximale.">max_array</a>(delta);
  <span class="keywordtype">double</span> facteur = (<a class="code" href="Double_8h.html#aaecd4ca8a2fe69cc6568af2938b94d2e">dabs</a>(min) &gt; <a class="code" href="Double_8h.html#aaecd4ca8a2fe69cc6568af2938b94d2e">dabs</a>(max)) ? min : max;
  <span class="keywordflow">for</span> (i = 0; i &lt; dim; i++)
    direction_perio[i] = normale(0, i) * facteur;
  <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Periodicity direction for &quot;</span> &lt;&lt; dom.<a class="code" href="classDomaine.html#a87e2cdc035a26565e6fe481446aa4cd3" title="Renvoie le nom du domaine.">le_nom</a>() &lt;&lt; <span class="stringliteral">&quot;/&quot;</span> &lt;&lt; bord &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; direction_perio;
}
</pre></div>
</div>
</div>
<a class="anchor" id="aee6a67196132bed17c8d786d6c39316c"></a><!-- doxytag: member="Reordonner_faces_periodiques::renum_som_perio" ref="aee6a67196132bed17c8d786d6c39316c" args="(const Domaine &amp;, const Noms &amp;liste_bords_periodiques, ArrOfInt &amp;renum_som_perio, const int calculer_espace_virtuel)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Reordonner_faces_periodiques::renum_som_perio </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDomaine.html">Domaine</a> &amp;&#160;</td>
          <td class="paramname"><em>domaine</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classNoms.html">Noms</a> &amp;&#160;</td>
          <td class="paramname"><em>liste_bords_periodiques</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>renum_som_perio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>calculer_espace_virtuel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Reordonner__faces__periodiques_8cpp_source.html#l00289">289</a> of file <a class="el" href="Reordonner__faces__periodiques_8cpp_source.html">Reordonner_faces_periodiques.cpp</a>.</p>

<p>References <a class="el" href="Zone_8h_source.html#l00836">Zone::bord()</a>, <a class="el" href="EntreeSortie_8h_source.html#l00032">Cerr</a>, <a class="el" href="Reordonner__faces__periodiques_8cpp_source.html#l00216">check_faces_periodiques()</a>, <a class="el" href="Scatter_8cpp_source.html#l01762">Scatter::construire_espace_virtuel_traduction()</a>, <a class="el" href="Domaine_8h_source.html#l00500">Domaine::coord_sommets()</a>, <a class="el" href="Double_8h_source.html#l00255">dabs()</a>, <a class="el" href="IntTab_8h_source.html#l00233">IntTab::dimension()</a>, <a class="el" href="DoubleTab_8h_source.html#l00243">DoubleTab::dimension()</a>, <a class="el" href="IntTab_8h_source.html#l00244">IntTab::dimension_tot()</a>, <a class="el" href="Solv__GCP__NS_8cpp_source.html#l00141">erreur()</a>, <a class="el" href="Process_8cpp_source.html#l00223">Process::exit()</a>, <a class="el" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>, <a class="el" href="DoubleVect_8h_source.html#l00101">DoubleVect::get_md_vector()</a>, <a class="el" href="Domaine_8h_source.html#l00577">Domaine::les_sommets()</a>, <a class="el" href="Frontiere_8cpp_source.html#l00197">Frontiere::les_sommets_des_faces()</a>, <a class="el" href="Process_8cpp_source.html#l00117">Process::me()</a>, <a class="el" href="Reordonner__faces__periodiques_8cpp_source.html#l00028">message()</a>, <a class="el" href="Domaine_8cpp_source.html#l00184">Domaine::nb_som()</a>, <a class="el" href="Domaine_8cpp_source.html#l00177">Domaine::nb_som_tot()</a>, <a class="el" href="Objet__U_8h_source.html#l00080">Objet_U::precision_geom</a>, <a class="el" href="vect__impl_8h_source.html#l00057">vect_impl::size()</a>, and <a class="el" href="Domaine_8h_source.html#l00272">Domaine::zone()</a>.</p>

<p>Referenced by <a class="el" href="Scatter_8cpp_source.html#l01289">Scatter::calculer_espace_distant_sommets()</a>, and <a class="el" href="Partitionneur__base_8cpp_source.html#l00630">Partitionneur_base::corriger_bords_avec_graphe()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">int</span> i;
  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_som = domaine.<a class="code" href="classDomaine.html#abc4abc8b8db5bebeb161fae4162a89ce" title="Renvoie le nombre de sommets.">nb_som</a>();
  <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a> renum(nb_som);
  <span class="keywordflow">for</span> (i = 0; i &lt; nb_som; i++)
    renum[i] = renum_som_perio[i];

  <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a> coord = domaine.<a class="code" href="classDomaine.html#aecd32c3eecc15cce7d1a0e468dadbf96" title="Renvoie le tableau des coordonnees des noeuds (sommets). (acces en lecture)">coord_sommets</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> dim = coord.<a class="code" href="classDoubleTab.html#ac3805e2637a3b880ba2d3e650c69dac4" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(1);

<span class="comment">// Etape 1: pour chaque sommet reel, trouver un sommet associe (si plusieurs directions</span>
<span class="comment">// de periodicite, un sommet peut etre associe a plusieurs autres).</span>

  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_bords_perio = liste_bords_periodiques.<a class="code" href="classvect__impl.html#a78155bfbd6b61f4710b9830641ed1694">size</a>();
  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i_bord = 0; i_bord &lt; nb_bords_perio; i_bord++)
    {
      <span class="keyword">const</span> <a class="code" href="classNom.html" title="class Nom Une chaine de caractere pour nommer les objets de TRUST">Nom</a>&amp; nom_bord = liste_bords_periodiques[i_bord];
      <span class="keyword">const</span> <a class="code" href="classFrontiere.html" title="Classe Frontiere. Une Frontiere decrit une partie de la frontiere d&#39;une Zone, elle possede un Nom...">Frontiere</a>&amp; front = domaine.<a class="code" href="classDomaine.html#a0e62f2bc829542fafa29e3f2c614159c" title="Renvoie la i-ieme zone du domaine. (version const)">zone</a>(0).<a class="code" href="classZone.html#af2f1e6a14af55249979da674e7aac11a" title="Renvoie le i-ieme bord de la zone&lt;br&gt;(version const)">bord</a>(nom_bord);
<span class="comment">// Direction periodique de ce bord:</span>
      <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a> delta;
      <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a> <a class="code" href="Solv__GCP__NS_8cpp.html#ab6aa1075b965c7713d8db20dd3a8e09b">erreur</a>;
      <span class="keywordflow">if</span> (!<a class="code" href="classReordonner__faces__periodiques.html#a57cfec8f17ae27a831df8c1a6c27e8cf" title="essaie de verifier si les faces du bord num_bord sont ordonnees suivant la convention des faces perio...">check_faces_periodiques</a>(front, delta, erreur, 1 <span class="comment">/* verbose */</span>))
        <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">exit</a>();
<span class="comment">// Tableau pointant vers tous les sommets de toutes les faces</span>
<span class="comment">// (on cast le IntTab en ArrOfInt)</span>
      <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; faces_sommets = front.<a class="code" href="classFrontiere.html#a6d1f96137ddae39a46985a8c3e53bcf5" title="Renvoie les sommets des faces de la frontiere.">les_sommets_des_faces</a>();
      <span class="keyword">const</span> <span class="keywordtype">int</span> nb_som_face = faces_sommets.<a class="code" href="classIntTab.html#abc3b32c94925a82f69d5b153a356e359" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(1);
      <span class="keyword">const</span> <span class="keywordtype">int</span> nb_faces = faces_sommets.<a class="code" href="classIntTab.html#abc3b32c94925a82f69d5b153a356e359" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(0) / 2;
<span class="comment">// Boucle sur les faces d&#39;un cote du domaine (premiere moitie des faces)</span>
      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i_face = 0; i_face &lt; nb_faces; i_face++)
        {

          <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i_som = 0; i_som &lt; nb_som_face; i_som++)
            {
              <span class="keyword">const</span> <span class="keywordtype">int</span> sommet = faces_sommets(i_face, i_som);

<span class="comment">// Trouver le sommet associe</span>
<span class="comment">// Comme les frontieres sont ordonnees (voir check_faces_periodiques),</span>
<span class="comment">// le sommet est forcement un des sommets de la face opposee.</span>
<span class="comment">// Le vecteur qui va de &quot;sommet&quot; a &quot;sommet_oppose&quot; doit etre egal a &quot;delta&quot;</span>
<span class="comment">// la direction de periodicite.</span>
              <span class="keyword">const</span> <span class="keywordtype">int</span> i_face_opposee = i_face + nb_faces;
              <span class="keywordtype">int</span> sommet_opp = -1;
              <span class="keywordtype">int</span> i_som_opp;
              <span class="keywordflow">for</span> (i_som_opp = 0; i_som_opp &lt; nb_som_face; i_som_opp++)
                {
                  sommet_opp = faces_sommets(i_face_opposee, i_som_opp);
                  <span class="keywordflow">for</span> (i = 0; i &lt; dim; i++)
                    {
                      <span class="keywordtype">double</span> epsilon = <a class="code" href="Double_8h.html#aaecd4ca8a2fe69cc6568af2938b94d2e">dabs</a>((coord(sommet_opp, i) - coord(sommet, i)) - delta[i]);
                      <span class="keywordflow">if</span> (epsilon &gt; <a class="code" href="classObjet__U.html#a7447e25c68cc8d3a1c06cf99f0565cff">Objet_U::precision_geom</a>)
                        <span class="keywordflow">break</span>;
                    }
                  <span class="keywordflow">if</span> (i == dim)
<span class="comment">// On a trouve le sommet oppose</span>
                    <span class="keywordflow">break</span>;
                }
              <span class="keywordflow">if</span> (i_som_opp &gt;= nb_som_face)
                {
                  <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;[PE&quot;</span> &lt;&lt; <a class="code" href="classProcess.html#ab55ba07167ec807ed3a145cac0f5dca4" title="renvoie mon rang dans le groupe de communication courant. Voir Comm_Group::rank() et PE_Groups::curre...">Process::me</a>() &lt;&lt; <span class="stringliteral">&quot;] Error in Reordonner_faces_periodiques::renum_som_perio\n&quot;</span>
                       &lt;&lt; <span class="stringliteral">&quot; An opposite node has not been found\n&quot;</span>
                       &lt;&lt; <span class="stringliteral">&quot; Boundary &quot;</span> &lt;&lt; nom_bord &lt;&lt; <span class="stringliteral">&quot;\n Face 1: &quot;</span> &lt;&lt; i_face &lt;&lt; <span class="stringliteral">&quot;\n Node: &quot;</span> &lt;&lt; sommet &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
                  <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot; May be you should define the periodic boundary &quot;</span> &lt;&lt; nom_bord &lt;&lt; finl;
                  <a class="code" href="Reordonner__faces__periodiques_8cpp.html#a137d78a01e63d3b66d1b2ed0de0f4c4c">message</a>();
                  <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">exit</a>();
                }
              renum[sommet_opp] = sommet;
            }
        }
    }

<span class="comment">// Deuxieme etape: faire pointer tous les sommets periodiques lies entre eux vers le meme sommet</span>

  <span class="keywordflow">for</span> (i = 0; i &lt; nb_som; i++)
    {
      <span class="keywordtype">int</span> j = renum[i];
<span class="comment">// Parcourir les sommet relies pour cette chaine:</span>
      <span class="keywordflow">while</span> (j != renum[j])
        j = renum[j];
      renum[i] = j;
    }
<span class="comment">// Calcul des valeurs pour les sommets virtuels.</span>
<span class="comment">// Les sommets opposes aux sommets virtuels doivent etre connus, donc erreurs fatales.</span>
  <span class="keywordflow">if</span> (calculer_espace_virtuel)
    {
      <span class="keyword">const</span> <a class="code" href="classMD__Vector.html" title=": Cette classe est un DERIV mais l&#39;objet pointe est partage entre plusieurs instances de cette classe...">MD_Vector</a>&amp; md_sommets = domaine.<a class="code" href="classDomaine.html#a0846ac03a10b65c4df911fe35a19c02f" title="Renvoie le nombre total de sommets.">les_sommets</a>().<a class="code" href="classDoubleVect.html#a0d16d30580c90526e4895388fb44be5d">get_md_vector</a>();
      <a class="code" href="classScatter.html#a33c68e7eff97ee92b457b50e8e3ad58d" title="Construit la structure items_communs + espaces virtuels d&#39;un tableau contenant des indices d&#39;items ge...">Scatter::construire_espace_virtuel_traduction</a>(md_sommets, md_sommets, renum, 1 <span class="comment">/* erreurs fatales */</span>);
    }

<span class="comment">// Recopie du resultat dans le tableau renum_som_perio</span>
  assert(renum.dimension_tot(0) == domaine.<a class="code" href="classDomaine.html#a394e61cf1993665886de0fbbd0c0178e" title="Renvoie le nombre total de sommets.">nb_som_tot</a>());
  renum_som_perio = renum;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a3d177f6fcafb470513dad54fe4d9f79a"></a><!-- doxytag: member="Reordonner_faces_periodiques::reordonner_faces_periodiques" ref="a3d177f6fcafb470513dad54fe4d9f79a" args="(const Domaine &amp;domaine, IntTab &amp;faces, const ArrOfDouble &amp;direction_perio, const double epsilon)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Reordonner_faces_periodiques::reordonner_faces_periodiques </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDomaine.html">Domaine</a> &amp;&#160;</td>
          <td class="paramname"><em>domaine</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classIntTab.html">IntTab</a> &amp;&#160;</td>
          <td class="paramname"><em>faces</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;&#160;</td>
          <td class="paramname"><em>direction_perio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>epsilon</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reordonne le tableau "faces" selon la convention des faces periodiques:<br/>
D'abord les faces d'une extremite, puis dans le meme ordre, les faces jumelles.<br/>
Attention, l'algorithme est en n carre (lent), et ne fonctionne qu'en sequentiel.<br/>
Parametre: zone<br/>
Signification: la zone a laquelle appartiennent les faces<br/>
Parametre: direction_perio<br/>
Signification: le vecteur qui separe le centre d'une face au centre de la face opposee<br/>
Parametre: faces<br/>
Signification: le tableau des faces (pour chaque face, indices de ses sommets) a reordonner<br/>
Valeur de retour: 1 si ok, 0 si on n'a pas trouve de face jumelle a une face a precision_geom pres. </p>

<p><p>&lt; Face deja traitee, on passe Cherche la face opposee dans les deux directions (-1. et +1.) </p>
</p>

<p>Definition at line <a class="el" href="Reordonner__faces__periodiques_8cpp_source.html#l00114">114</a> of file <a class="el" href="Reordonner__faces__periodiques_8cpp_source.html">Reordonner_faces_periodiques.cpp</a>.</p>

<p>References <a class="el" href="Octree__Double_8cpp_source.html#l00154">Octree_Double::build_nodes()</a>, <a class="el" href="EntreeSortie_8h_source.html#l00032">Cerr</a>, <a class="el" href="DoubleTab_8h_source.html#l00243">DoubleTab::dimension()</a>, <a class="el" href="IntTab_8h_source.html#l00233">IntTab::dimension()</a>, <a class="el" href="Lois__sodium_8h_source.html#l00183">f1</a>, <a class="el" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>, <a class="el" href="Domaine_8h_source.html#l00577">Domaine::les_sommets()</a>, <a class="el" href="Octree__Double_8cpp_source.html#l00244">Octree_Double::search_elements_box()</a>, <a class="el" href="Octree__Double_8cpp_source.html#l00289">Octree_Double::search_nodes_close_to()</a>, and <a class="el" href="ArrOfInt_8cpp_source.html#l00443">ArrOfInt::set_smart_resize()</a>.</p>

<p>Referenced by <a class="el" href="MaillerParallel_8cpp_source.html#l00534">MaillerParallel::interpreter()</a>, <a class="el" href="Corriger__frontiere__periodique_8cpp_source.html#l00060">Corriger_frontiere_periodique::interpreter_()</a>, and <a class="el" href="Scatter_8cpp_source.html#l00513">Scatter::lire_domaine()</a>.</p>
<div class="fragment"><pre class="fragment">{
<span class="comment">// Modif B.M. 04/06/2010: j&#39;autorise l&#39;operation en parallele car c&#39;est utilise par</span>
<span class="comment">// l&#39;interprete MaillerParallel...</span>
<span class="comment">// PL 18/11/2010: Je deplace neanmoins l&#39;interdiction de l&#39;utilisation de l&#39;interprete en // dans le jeu de donnees (voir ::interpreter_)</span>
  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_faces = faces.<a class="code" href="classIntTab.html#abc3b32c94925a82f69d5b153a356e359" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(0);
  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_som_faces = faces.<a class="code" href="classIntTab.html#abc3b32c94925a82f69d5b153a356e359" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(1);
  <span class="keyword">const</span> <span class="keywordtype">int</span> dim = domaine.<a class="code" href="classDomaine.html#a0846ac03a10b65c4df911fe35a19c02f" title="Renvoie le nombre total de sommets.">les_sommets</a>().<a class="code" href="classDoubleTab.html#ac3805e2637a3b880ba2d3e650c69dac4" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(1);
<span class="comment">// Calcul des coordonnees des centres des faces:</span>
  <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a> centres(nb_faces, 3);
  {
    <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; coord = domaine.<a class="code" href="classDomaine.html#a0846ac03a10b65c4df911fe35a19c02f" title="Renvoie le nombre total de sommets.">les_sommets</a>();
    <span class="keyword">const</span> <span class="keywordtype">double</span> inv_nb_som = 1. / (double) nb_som_faces;
    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; nb_faces; i++)
      {
        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; nb_som_faces; j++)
          {
            <span class="keyword">const</span> <span class="keywordtype">int</span> sommet = faces(i, j);
            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k = 0; k &lt; dim; k++)
              centres(i, k) += coord(sommet, k) * inv_nb_som;
          }
      }
  }

<span class="comment">// Construction d&#39;un octree contenant les centres des faces:</span>
  <a class="code" href="classOctree__Double.html" title=": Un octree permettant de chercher dans l&#39;espace des elements ou des points decrits par des coordonne...">Octree_Double</a> octree;
  octree.<a class="code" href="classOctree__Double.html#a0b66bd315e7f45a024695b6a2764e7d4" title="construit un octree contenant les points de coordonnees coords. Si include_virtual=1, on stocke coords.dimension_tot(0) elements, sinon on en stocke coords.dimension(0) Si epsilon = 0, on construit un octree de points de taille nulle (chaque point se trouve dans un seul octree_floor) Sinon, on construit un octree d&#39;elements cubiques centres sur les coords, de demie-largeur epsilon. Un point peut alors se trouver dans plusieurs octree_floor.">build_nodes</a>(centres, 0 <span class="comment">/* do not include virtual nodes */</span>);

<span class="comment">// Pour chaque face, on cherche sa face periodique associee (dont le centre</span>
<span class="comment">// est decale de direction_perio).</span>

<span class="comment">// Pour chaque face, son nouvel indice dans le tableau des faces</span>
  <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> renum_faces(nb_faces);
  renum_faces= -1;
  <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> nodes_list;
  nodes_list.<a class="code" href="classArrOfInt.html#a22d744bcd452d039580d1d9186f02b4e" title="Change le mode l&#39;allocation memoire: reallocation d&#39;un tableau a chaque changement de taille (flag = ...">set_smart_resize</a>(1);
  <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a> coord(dim);
  <span class="keywordtype">int</span> count = 0;
  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i_face = 0; i_face &lt; nb_faces; i_face++)
    {
      <span class="keywordflow">if</span> (renum_faces[i_face] &gt;= 0)
        <span class="keywordflow">continue</span>; <span class="comment">//!&lt; Face deja traitee, on passe Cherche la face opposee dans les deux directions (-1. et +1.)</span>
<span class="comment"></span><span class="comment">//</span>
      <span class="keywordtype">double</span> facteur;
      <span class="keywordtype">int</span> i_face2 = -1;
      <span class="keywordflow">for</span> (facteur = -1.; facteur &lt; 1.5; facteur += 2.)
        {
          <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; dim; i++)
            coord[i] = centres(i_face, i) + facteur * direction_perio[i];
          octree.<a class="code" href="classOctree__Double.html#a1dffcace51ca06cb52ff6e2330ab4b2e" title="cherche tous les elements ou points ayant potentiellement une intersection non vide avec la boite don...">search_elements_box</a>(coord, epsilon, nodes_list);
          i_face2 = octree.<a class="code" href="classOctree__Double.html#a8ba1f6ceba5dae2af587d2f9a766aac2" title="Methode hors classe Cherche parmi les sommets de la liste node_list ceux qui sont a une distance infe...">search_nodes_close_to</a>(coord, centres, nodes_list, epsilon);
          <span class="keywordflow">if</span> (i_face2 &gt;= 0)
            <span class="keywordflow">break</span>;
        }
      <span class="keywordflow">if</span> (i_face2 &gt;= 0)
        {
          <span class="keywordflow">if</span> (renum_faces[i_face2] &gt;= 0)
            {
              <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;====================================================&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
              <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Error in reordonner_faces_periodiques: the face &quot;</span> &lt;&lt; i_face
                   &lt;&lt; <span class="stringliteral">&quot; of &quot;</span> &lt;&lt; centres(i_face,0) &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; centres(i_face,1) &lt;&lt; <span class="stringliteral">&quot; &quot;</span>
                   &lt;&lt; ((dim==3)?centres(i_face,2):0.)
                   &lt;&lt; <span class="stringliteral">&quot; center already has a face twin.&quot;</span>
                   &lt;&lt; finl;
              <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Possible problem: the boundary is not periodic. Check your mesh.&quot;</span> &lt;&lt; finl;
              <span class="keywordflow">return</span> 0;
            }
          <span class="keywordtype">int</span> f0 = (facteur &gt; 0.) ? i_face : i_face2;
          <span class="keywordtype">int</span> <a class="code" href="Lois__sodium_8h.html#a3034a1fb8c782842a2b9473c0f02a448">f1</a> = (facteur &gt; 0.) ? i_face2: i_face;
          renum_faces(f0) = count;
          renum_faces(f1) = count + nb_faces / 2;
          count++;
        }
      <span class="keywordflow">else</span>
        {
          <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;====================================================&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
          <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Error in reordonner_faces_periodiques: the face &quot;</span> &lt;&lt; i_face &lt;&lt; <span class="stringliteral">&quot; of &quot;</span> &lt;&lt; centres(i_face,0) &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; centres(i_face,1) &lt;&lt; <span class="stringliteral">&quot; &quot;</span>
               &lt;&lt; ((dim==3)?centres(i_face,2):0.) &lt;&lt; finl;
          <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;center has no face twin into the specified direction in the list of faces.&quot;</span> &lt;&lt; finl;
          <span class="keywordflow">return</span> 0;
        }
    }
<span class="comment">// Reordonner les faces:</span>
  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a> oldfaces(faces);
  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; nb_faces; i++)
    {
      <span class="keyword">const</span> <span class="keywordtype">int</span> new_i = renum_faces(i);
      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; nb_som_faces; j++)
        faces(new_i, j) = oldfaces(i, j);
    }
  <span class="keywordflow">return</span> 1;
}
</pre></div>
</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/Kernel/Geometrie/<a class="el" href="Reordonner__faces__periodiques_8h_source.html">Reordonner_faces_periodiques.h</a></li>
<li>src/Kernel/Geometrie/<a class="el" href="Reordonner__faces__periodiques_8cpp_source.html">Reordonner_faces_periodiques.cpp</a></li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Tue Dec 14 2021 19:37:47 for TRUST by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
