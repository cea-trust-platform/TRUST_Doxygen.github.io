<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>TRUST: Zone_Cl_VEFP1B Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">TRUST&#160;<span id="projectnumber">1.8.4</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">Zone_Cl_VEFP1B Class Reference</div>  </div>
</div>
<div class="contents">
<!-- doxytag: class="Zone_Cl_VEFP1B" --><!-- doxytag: inherits="Zone_Cl_VEF" -->
<p><code>#include &lt;<a class="el" href="Zone__Cl__VEFP1B_8h_source.html">Zone_Cl_VEFP1B.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Zone_Cl_VEFP1B:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classZone__Cl__VEFP1B.png" usemap="#Zone_Cl_VEFP1B_map" alt=""/>
  <map id="Zone_Cl_VEFP1B_map" name="Zone_Cl_VEFP1B_map">
<area href="classZone__Cl__VEF.html" alt="Zone_Cl_VEF" shape="rect" coords="64,168,182,192"/>
<area href="classZone__Cl__dis__base.html" title="classe Zone_Cl_dis_base Les objets Zone_Cl_dis_base representent les conditions aux limites discretis..." alt="Zone_Cl_dis_base" shape="rect" coords="64,112,182,136"/>
<area href="classMorEqn.html" title="classe MorEqn Classe qui regroupe les fonctionnalites de liaison avec une Equation. Le membre MorEqn::mon_equation contient une reference vers un objet Equation_base. Les classes qui sont des &quot;Morceaux d&#39;equation&quot; sont associe par une liaison 1-1 a leur equation en heritant de MorEqn, par exemple: Operateur_base, Solveur_Masse, Source_base ..." alt="MorEqn" shape="rect" coords="0,56,118,80"/>
<area href="classObjet__U.html" title="classe Objet_U Cette classe est la classe de base des Objets de TRUST Dans les classes derivees de Ob..." alt="Objet_U" shape="rect" coords="128,56,246,80"/>
<area href="classProcess.html" title="Classe de base de TRUST (notamment Objet_U). Elle fournit quelques services de base accessibles de pa..." alt="Process" shape="rect" coords="128,0,246,24"/>
</map>
 </div></div>

<p><a href="classZone__Cl__VEFP1B-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classZone__Cl__VEFP1B.html#ae87e9a0e30ae0743d4e49a0c011ed713">Zone_Cl_VEFP1B</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classZone__Cl__VEFP1B.html#ab57e4711f7363d6c959a13d77500a421">~Zone_Cl_VEFP1B</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classZone__Cl__VEFP1B.html#a2c18614ea942d5260b516ac354f898d3">taille_memoire</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classZone__Cl__VEFP1B.html#aade99f66b5ea74856c266ba996a84279">duplique</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classType__info.html">Type_info</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classZone__Cl__VEFP1B.html#ac8e498acbcae8f54d84cd2b25be675dc">get_info</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Donne des informations sur le type de l'Objet_U.  <a href="#ac8e498acbcae8f54d84cd2b25be675dc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classZone__Cl__VEFP1B.html#a000b3c6a248677679f4be6d07ce90587">remplir_volumes_entrelaces_Cl</a> (const <a class="el" href="classZone__VEF.html">Zone_VEF</a> &amp;)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">appele par <a class="el" href="classZone__Cl__dis__base.html#a8bfb3fea47744d520e6e774d554f9484" title="Appel Cond_lim_base::completer() sur chaque condition aux limites.">completer()</a> : remplissage de type_elem_Cl_ et<br/>
volumes_entrelaces_Cl_  <a href="#a000b3c6a248677679f4be6d07ce90587"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classZone__Cl__VEFP1B.html#af10997ac53f710592ad196e095238442">imposer_cond_lim</a> (<a class="el" href="classChamp__Inc.html">Champ_Inc</a> &amp;, double)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Impose les conditions aux limites a la valeur temporelle "temps" du<br/>
<a class="el" href="classChamp__Inc.html">Champ_Inc</a>.  <a href="#af10997ac53f710592ad196e095238442"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classObjet__U.html">Objet_U</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classZone__Cl__VEFP1B.html#abd3680f1aac698f4d6364d7ebfaf3cfb">cree_instance</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classType__info.html">Type_info</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classZone__Cl__VEFP1B.html#a45d3e32caae8df1ca0d1f7c01df74888">info</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Donne des informations sur le type de l'Objet_U.  <a href="#a45d3e32caae8df1ca0d1f7c01df74888"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classZone__Cl__VEFP1B.html">Zone_Cl_VEFP1B</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classZone__Cl__VEFP1B.html#a9e3313c116827764bb5e3fde5d5fb514">self_cast</a> (<a class="el" href="classObjet__U.html">Objet_U</a> &amp;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classZone__Cl__VEFP1B.html">Zone_Cl_VEFP1B</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classZone__Cl__VEFP1B.html#ad3125a7cef2672b93550518ff73a256c">self_cast</a> (const <a class="el" href="classObjet__U.html">Objet_U</a> &amp;)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">methode ajoutee pour caster en python  <a href="#ad3125a7cef2672b93550518ff73a256c"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classType__info.html">Type_info</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classZone__Cl__VEFP1B.html#ada9fa7a792e960e566a18c69cb6fe9c8">info_obj</a></td></tr>
<tr><td colspan="2"><h2><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classSortie.html">Sortie</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classZone__Cl__VEFP1B.html#a8c4a1aba406537f647659ebb0e7d1f56">printOn</a> (<a class="el" href="classSortie.html">Sortie</a> &amp;x) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Surcharge <a class="el" href="classObjet__U.html#a68f520bd9ba3e848370861d6610720b5" title="Ecriture de l&#39;objet sur un flot de sortie Methode a surcharger.">Objet_U::printOn</a>(<a class="el" href="classSortie.html" title="Classe de base des flux de sortie. Elle sait ecrire des types simples&lt;br&gt;(entiers, flottants) et des Ob...">Sortie</a>&amp;)<br/>
NE FAIT RIEN<br/>
A surcharger dans les classes derivees.<br/>
Imprime les conditions aux limites discretisees sur un flot de sortie.  <a href="#a8c4a1aba406537f647659ebb0e7d1f56"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classEntree.html">Entree</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classZone__Cl__VEFP1B.html#a54c1a66de2fcbd688613bb1c53059e6c">readOn</a> (<a class="el" href="classEntree.html">Entree</a> &amp;)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Surcharge <a class="el" href="classObjet__U.html#a6f4c7788efee2dce629ebd1628b73288" title="Lecture d&#39;un Objet_U sur un flot d&#39;entree Methode a surcharger.">Objet_U::readOn</a>(<a class="el" href="classSortie.html" title="Classe de base des flux de sortie. Elle sait ecrire des types simples&lt;br&gt;(entiers, flottants) et des Ob...">Sortie</a>&amp;)<br/>
Lit les conditions aux limites discretisees a partir d'un flot d'entree<br/>
Le format attendu est le suivant:<br/>
{<br/>
<a class="el" href="classNom.html" title="class Nom Une chaine de caractere pour nommer les objets de TRUST">Nom</a> <a class="el" href="classCond__lim.html" title="classe Cond_lim Classe generique servant a representer n&#39;importe quelle classe derivee de la classe C...">Cond_lim</a> [REPETER LECTURE AUTANT DE FOIS QUE NECESSAIRE]<br/>
}.  <a href="#a54c1a66de2fcbd688613bb1c53059e6c"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock">
<p>Definition at line <a class="el" href="Zone__Cl__VEFP1B_8h_source.html#l00029">29</a> of file <a class="el" href="Zone__Cl__VEFP1B_8h_source.html">Zone_Cl_VEFP1B.h</a>.</p>
</div><hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ae87e9a0e30ae0743d4e49a0c011ed713"></a><!-- doxytag: member="Zone_Cl_VEFP1B::Zone_Cl_VEFP1B" ref="ae87e9a0e30ae0743d4e49a0c011ed713" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Zone_Cl_VEFP1B::Zone_Cl_VEFP1B </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Zone__Cl__VEFP1B_8cpp_source.html#l00030">30</a> of file <a class="el" href="Zone__Cl__VEFP1B_8cpp_source.html">Zone_Cl_VEFP1B.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab57e4711f7363d6c959a13d77500a421"></a><!-- doxytag: member="Zone_Cl_VEFP1B::~Zone_Cl_VEFP1B" ref="ab57e4711f7363d6c959a13d77500a421" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Zone_Cl_VEFP1B::~Zone_Cl_VEFP1B </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Zone__Cl__VEFP1B_8cpp_source.html#l00030">30</a> of file <a class="el" href="Zone__Cl__VEFP1B_8cpp_source.html">Zone_Cl_VEFP1B.cpp</a>.</p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="abd3680f1aac698f4d6364d7ebfaf3cfb"></a><!-- doxytag: member="Zone_Cl_VEFP1B::cree_instance" ref="abd3680f1aac698f4d6364d7ebfaf3cfb" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classObjet__U.html">Objet_U</a> * Zone_Cl_VEFP1B::cree_instance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="classZone__Cl__VEF.html#acdd9a5de2e6ff0fab6c9802c1c582172">Zone_Cl_VEF</a>.</p>

<p>Definition at line <a class="el" href="Zone__Cl__VEFP1B_8cpp_source.html#l00030">30</a> of file <a class="el" href="Zone__Cl__VEFP1B_8cpp_source.html">Zone_Cl_VEFP1B.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="aade99f66b5ea74856c266ba996a84279"></a><!-- doxytag: member="Zone_Cl_VEFP1B::duplique" ref="aade99f66b5ea74856c266ba996a84279" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Zone_Cl_VEFP1B::duplique </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="classZone__Cl__VEF.html#a21314b9d44c6d9af25293c36cf903aa1">Zone_Cl_VEF</a>.</p>

<p>Definition at line <a class="el" href="Zone__Cl__VEFP1B_8cpp_source.html#l00030">30</a> of file <a class="el" href="Zone__Cl__VEFP1B_8cpp_source.html">Zone_Cl_VEFP1B.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac8e498acbcae8f54d84cd2b25be675dc"></a><!-- doxytag: member="Zone_Cl_VEFP1B::get_info" ref="ac8e498acbcae8f54d84cd2b25be675dc" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classType__info.html">Type_info</a> * Zone_Cl_VEFP1B::get_info </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Donne des informations sur le type de l'Objet_U. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>const Type_info*<br/>
 Signification: structure regroupant les informations sur le type de l'Objet_U<br/>
 Contraintes: </dd></dl>

<p>Reimplemented from <a class="el" href="classZone__Cl__VEF.html#a771f41b694aefc9b936ebece99177bba">Zone_Cl_VEF</a>.</p>

<p>Definition at line <a class="el" href="Zone__Cl__VEFP1B_8cpp_source.html#l00030">30</a> of file <a class="el" href="Zone__Cl__VEFP1B_8cpp_source.html">Zone_Cl_VEFP1B.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="af10997ac53f710592ad196e095238442"></a><!-- doxytag: member="Zone_Cl_VEFP1B::imposer_cond_lim" ref="af10997ac53f710592ad196e095238442" args="(Champ_Inc &amp;, double)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Zone_Cl_VEFP1B::imposer_cond_lim </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classChamp__Inc.html">Champ_Inc</a> &amp;&#160;</td>
          <td class="paramname"><em>ch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>temps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Impose les conditions aux limites a la valeur temporelle "temps" du<br/>
<a class="el" href="classChamp__Inc.html">Champ_Inc</a>. </p>

<p>Reimplemented from <a class="el" href="classZone__Cl__VEF.html#a52127dc0942214d2759315a7f037f854">Zone_Cl_VEF</a>.</p>

<p>Definition at line <a class="el" href="Zone__Cl__VEFP1B_8cpp_source.html#l00044">44</a> of file <a class="el" href="Zone__Cl__VEFP1B_8cpp_source.html">Zone_Cl_VEFP1B.cpp</a>.</p>

<p>References <a class="el" href="DoubleVect_8cpp_source.html#l00277">DoubleVect::echange_espace_virtuel()</a>, <a class="el" href="MorEqn_8h_source.html#l00082">MorEqn::equation()</a>, <a class="el" href="Zone__VF_8h_source.html#l00609">Zone_VF::face_sommets()</a>, <a class="el" href="Zone__VF_8h_source.html#l00054">Zone_VF::face_surfaces()</a>, <a class="el" href="Neumann_8cpp_source.html#l00081">Neumann::flux_impose()</a>, <a class="el" href="Cond__lim__base_8h_source.html#l00123">Cond_lim_base::frontiere_dis()</a>, <a class="el" href="Zone__VEF__PreP1b_8h_source.html#l00066">Zone_VEF_PreP1b::get_alphaS()</a>, <a class="el" href="Zone__VEF__PreP1b_8h_source.html#l00081">Zone_VEF_PreP1b::get_cl_pression_sommet_faible()</a>, <a class="el" href="Zone__Cl__dis__base_8cpp_source.html#l00562">Zone_Cl_dis_base::les_conditions_limites()</a>, <a class="el" href="Zone__Cl__dis__base_8cpp_source.html#l00603">Zone_Cl_dis_base::nb_cond_lim()</a>, <a class="el" href="Front__VF_8h_source.html#l00066">Front_VF::nb_faces_tot()</a>, <a class="el" href="Zone__dis__base_8h_source.html#l00152">Zone_dis_base::nb_som_tot()</a>, <a class="el" href="Front__VF_8h_source.html#l00076">Front_VF::num_face()</a>, <a class="el" href="Zone__VEF__PreP1b_8h_source.html#l00137">Zone_VEF_PreP1b::numero_premier_sommet()</a>, <a class="el" href="Cast_8h_source.html#l00059">ref_cast</a>, <a class="el" href="Cast_8h_source.html#l00054">sub_type</a>, <a class="el" href="Source__Generique__Face__PolyMAC_8cpp_source.html#l00045">valeur()</a>, <a class="el" href="Champ__Inc_8h_source.html#l00043">Deriv_Champ_Inc_base::valeur()</a>, <a class="el" href="Op__Div__VEFP1B__Elem_8cpp_source.html#l00081">verifier()</a>, and <a class="el" href="Zone__Cl__dis__base_8cpp_source.html#l00225">Zone_Cl_dis_base::zone_dis()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <a class="code" href="classZone__Cl__VEFP1B.html#af10997ac53f710592ad196e095238442" title="Impose les conditions aux limites a la valeur temporelle &quot;temps&quot; du Champ_Inc.">Zone_Cl_VEF::imposer_cond_lim</a>(ch,temps);
<span class="comment">// dans le cas Navier stokes et si la condition est forte en pression aux sommets on impose la valeur aux sommets</span>

  <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classNavier__Stokes__std.html" title="classe Navier_Stokes_std Cette classe porte les termes de l&#39;equation de la dynamique pour un fluide s...">Navier_Stokes_std</a>,ch.<a class="code" href="classDeriv__Champ__Inc__base.html#a9e0b743a3e124e7114fa977b36b68225">valeur</a>().<a class="code" href="classMorEqn.html#a615dd9abff96edcb625fa0424a489864" title="Renvoie la reference sur l&#39;equation pointe par MorEqn::mon_equation. (version const)">equation</a>()))
    {
      <span class="keyword">const</span> <a class="code" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a>&amp; zone_vef=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a>,<a class="code" href="classMorEqn.html#a615dd9abff96edcb625fa0424a489864" title="Renvoie la reference sur l&#39;equation pointe par MorEqn::mon_equation. (version const)">equation</a>().<a class="code" href="classZone__Cl__dis__base.html#a20ea8fc29bc5a157ee957925db285972" title="Renvoie une reference sur la zone discretisee associee aux conditions aux limites. Cette Zone_dis est associee au travers de l&#39;equation associee et pas directement a l&#39;objet Zone_Cl_dis_base.">zone_dis</a>().<a class="code" href="Source__Generique__Face__PolyMAC_8cpp.html#a7d7b5d77a3caa1af70f5e1c9108de5a1">valeur</a>());
      <span class="keywordflow">if</span> ((zone_vef.<a class="code" href="classZone__VEF__PreP1b.html#aed6f98596f13c0c4df7a7d9f57235b56">get_cl_pression_sommet_faible</a>()==0) &amp;&amp; (zone_vef.<a class="code" href="classZone__VEF__PreP1b.html#ad7fbcb5567dcc2e6f0a0ed85ce90a4fa">get_alphaS</a>()))
        {
          <span class="keywordtype">int</span> nps=zone_vef.<a class="code" href="classZone__VEF__PreP1b.html#ab469e7b0d67ddcc27e5cf16c3c85e8f4">numero_premier_sommet</a>();
          <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; pression=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classNavier__Stokes__std.html" title="classe Navier_Stokes_std Cette classe porte les termes de l&#39;equation de la dynamique pour un fluide s...">Navier_Stokes_std</a>,ch-&gt;equation()).pression().valeurs();
          <span class="keywordtype">int</span> nbsom_tot = zone_vef.<a class="code" href="classZone__dis__base.html#a8f793341b7a41d67561ba563ae0f69a0">nb_som_tot</a>();
          <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a> surf_loc(nbsom_tot);
          <span class="keywordtype">int</span> nb_cond_lims = <a class="code" href="classZone__Cl__dis__base.html#aa6f1df56cfd6e2eae83cc991c7cc9b41" title="Renvoie le nombre de conditions aux limites.">nb_cond_lim</a>();
<span class="comment">// On boucle une premiere fois pour mettre a zero la pression aux sommets</span>
          <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;nb_cond_lims; i++)
            {
              <span class="keyword">const</span> <a class="code" href="classCond__lim__base.html" title="classe Cond_lim_base Classe de base pour la hierarchie des classes qui representent les differentes c...">Cond_lim_base</a>&amp; la_cl = <a class="code" href="classZone__Cl__dis__base.html#aed515ad23bdfca2368ffe08f2746a653" title="Renvoie le tableaux des conditions aux limites.">les_conditions_limites</a>(i).valeur();
              <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classNeumann__sortie__libre.html" title="classe Neumann_sortie_libre Cette classe represente une frontiere ouverte sans vitesse imposee Pour l...">Neumann_sortie_libre</a>,la_cl))
                {
                  <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp; le_bord = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>,la_cl.<a class="code" href="classCond__lim__base.html#ad88b3b516351146c85e8fce1df0f691a" title="Renvoie la frontiere discretisee a laquelle les conditions aux limites s&#39;appliquent.">frontiere_dis</a>());
                  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; faces = zone_vef.<a class="code" href="classZone__VF.html#a298e73b18e17da55f421b1fb0879bd46" title="renvoie le numero du ieme sommet de la face num_face.">face_sommets</a>();
                  <span class="keywordtype">int</span> nbsf = faces.dimension(1);
                  <span class="keywordtype">int</span> num2 = le_bord.<a class="code" href="classFront__VF.html#aed4006d91bf2ef3af2b9f7933d863a09" title="Nombre de faces reelles et virtuelles du bord.">nb_faces_tot</a>();
                  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> ind_face=0; ind_face&lt;num2; ind_face++)
                    {
                      <span class="keywordtype">int</span> face = le_bord.<a class="code" href="classFront__VF.html#a3402a19d7e54ed797d2b18e9a47ead1e" title="Renvoie le numero de face de la ieme face du bord.">num_face</a>(ind_face);
                      <span class="keywordflow">for</span>(<span class="keywordtype">int</span> som=0; som&lt;nbsf; som++)
                        {
                          <span class="keywordtype">int</span> som_glob = faces(face,som);
                          pression(nps+som_glob) = 0;
                        }
                    }
                }
            }

<span class="comment">// On boucle une deuxieme fois pour ajouter la contribution de chaque face</span>
          <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;nb_cond_lims; i++)
            {
              <span class="keyword">const</span> <a class="code" href="classCond__lim__base.html" title="classe Cond_lim_base Classe de base pour la hierarchie des classes qui representent les differentes c...">Cond_lim_base</a>&amp; la_cl = <a class="code" href="classZone__Cl__dis__base.html#aed515ad23bdfca2368ffe08f2746a653" title="Renvoie le tableaux des conditions aux limites.">les_conditions_limites</a>(i).valeur();
              <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classNeumann__sortie__libre.html" title="classe Neumann_sortie_libre Cette classe represente une frontiere ouverte sans vitesse imposee Pour l...">Neumann_sortie_libre</a>,la_cl))
                {
                  <span class="keyword">const</span> <a class="code" href="classNeumann__sortie__libre.html" title="classe Neumann_sortie_libre Cette classe represente une frontiere ouverte sans vitesse imposee Pour l...">Neumann_sortie_libre</a>&amp; la_sortie_libre = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classNeumann__sortie__libre.html" title="classe Neumann_sortie_libre Cette classe represente une frontiere ouverte sans vitesse imposee Pour l...">Neumann_sortie_libre</a>, la_cl);
                  <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp; le_bord = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>,la_cl.<a class="code" href="classCond__lim__base.html#ad88b3b516351146c85e8fce1df0f691a" title="Renvoie la frontiere discretisee a laquelle les conditions aux limites s&#39;appliquent.">frontiere_dis</a>());
                  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; faces = zone_vef.<a class="code" href="classZone__VF.html#a298e73b18e17da55f421b1fb0879bd46" title="renvoie le numero du ieme sommet de la face num_face.">face_sommets</a>();
                  <span class="keywordtype">int</span> nbsf = faces.dimension(1);
                  <span class="keywordtype">int</span> num2 = le_bord.<a class="code" href="classFront__VF.html#aed4006d91bf2ef3af2b9f7933d863a09" title="Nombre de faces reelles et virtuelles du bord.">nb_faces_tot</a>();
                  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> ind_face=0; ind_face&lt;num2; ind_face++)
                    {
                      <span class="keywordtype">int</span> face = le_bord.<a class="code" href="classFront__VF.html#a3402a19d7e54ed797d2b18e9a47ead1e" title="Renvoie le numero de face de la ieme face du bord.">num_face</a>(ind_face);
                      <span class="keywordtype">double</span> P_imp = la_sortie_libre.<a class="code" href="classNeumann.html#a4f6ee6cc54ca6471254c2a530c5b70b5" title="Renvoie la valeur du flux impose sur la i-eme composante du champ representant le flux a la frontiere...">flux_impose</a>(ind_face);
                      <span class="keywordtype">double</span> face_surf = zone_vef.<a class="code" href="classZone__VF.html#a40c3382b189a4fc508cf1c3e37b04b21">face_surfaces</a>(face);
                      <span class="keywordflow">for</span>(<span class="keywordtype">int</span> som=0; som&lt;nbsf; som++)
                        {
                          <span class="keywordtype">int</span> som_glob = faces(face,som);
                          pression(nps+som_glob) += P_imp*face_surf;
                          surf_loc(som_glob) += face_surf;
                        }
                    }
                }
            }
<span class="comment">// On boucle une troisieme fois pour diviser par la surface</span>
          <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;nb_cond_lims; i++)
            {
              <span class="keyword">const</span> <a class="code" href="classCond__lim__base.html" title="classe Cond_lim_base Classe de base pour la hierarchie des classes qui representent les differentes c...">Cond_lim_base</a>&amp; la_cl = <a class="code" href="classZone__Cl__dis__base.html#aed515ad23bdfca2368ffe08f2746a653" title="Renvoie le tableaux des conditions aux limites.">les_conditions_limites</a>(i).valeur();
              <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classNeumann__sortie__libre.html" title="classe Neumann_sortie_libre Cette classe represente une frontiere ouverte sans vitesse imposee Pour l...">Neumann_sortie_libre</a>,la_cl))
                {
                  <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp; le_bord = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>,la_cl.<a class="code" href="classCond__lim__base.html#ad88b3b516351146c85e8fce1df0f691a" title="Renvoie la frontiere discretisee a laquelle les conditions aux limites s&#39;appliquent.">frontiere_dis</a>());
                  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; faces = zone_vef.<a class="code" href="classZone__VF.html#a298e73b18e17da55f421b1fb0879bd46" title="renvoie le numero du ieme sommet de la face num_face.">face_sommets</a>();
                  <span class="keywordtype">int</span> nbsf = faces.dimension(1);
                  <span class="keywordtype">int</span> num2 = le_bord.<a class="code" href="classFront__VF.html#aed4006d91bf2ef3af2b9f7933d863a09" title="Nombre de faces reelles et virtuelles du bord.">nb_faces_tot</a>();
                  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> ind_face=0; ind_face&lt;num2; ind_face++)
                    {
                      <span class="keywordtype">int</span> face = le_bord.<a class="code" href="classFront__VF.html#a3402a19d7e54ed797d2b18e9a47ead1e" title="Renvoie le numero de face de la ieme face du bord.">num_face</a>(ind_face);
                      <span class="keywordflow">for</span>(<span class="keywordtype">int</span> som=0; som&lt;nbsf; som++)
                        {
                          <span class="keywordtype">int</span> som_glob = faces(face,som);
                          <span class="keywordtype">double</span>&amp; surf = surf_loc(som_glob);
                          <span class="keywordflow">if</span> (surf&gt;0)
                            {
                              pression(nps+som_glob) /= surf;
                              surf = -1;
                            }
                        }
                    }
                }
            }
          pression.<a class="code" href="classDoubleVect.html#abfebbc2f685ce7bc4b80c720d7da9bf3">echange_espace_virtuel</a>();
          <a class="code" href="Op__Div__VEFP1B__Elem_8cpp.html#a45261662b3b88d5db461b3fc99246e5a">Debog::verifier</a>(<span class="stringliteral">&quot;pression dans Zone_Cl_VEFP1B::imposer_cond_lim&quot;</span>,pression);
        }
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a45d3e32caae8df1ca0d1f7c01df74888"></a><!-- doxytag: member="Zone_Cl_VEFP1B::info" ref="a45d3e32caae8df1ca0d1f7c01df74888" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classType__info.html">Type_info</a> * Zone_Cl_VEFP1B::info </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Donne des informations sur le type de l'Objet_U. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>const Type_info*<br/>
 Signification: structure regroupant les informations sur le type de l'Objet_U<br/>
 Contraintes: </dd></dl>

<p>Reimplemented from <a class="el" href="classZone__Cl__VEF.html#a30a947dc8238cd82c76b3888da5f2b70">Zone_Cl_VEF</a>.</p>

<p>Definition at line <a class="el" href="Zone__Cl__VEFP1B_8cpp_source.html#l00030">30</a> of file <a class="el" href="Zone__Cl__VEFP1B_8cpp_source.html">Zone_Cl_VEFP1B.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8c4a1aba406537f647659ebb0e7d1f56"></a><!-- doxytag: member="Zone_Cl_VEFP1B::printOn" ref="a8c4a1aba406537f647659ebb0e7d1f56" args="(Sortie &amp;x) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSortie.html">Sortie</a> &amp; Zone_Cl_VEFP1B::printOn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSortie.html">Sortie</a> &amp;&#160;</td>
          <td class="paramname"><em>os</em></td><td>)</td>
          <td> const<code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Surcharge <a class="el" href="classObjet__U.html#a68f520bd9ba3e848370861d6610720b5" title="Ecriture de l&#39;objet sur un flot de sortie Methode a surcharger.">Objet_U::printOn</a>(<a class="el" href="classSortie.html" title="Classe de base des flux de sortie. Elle sait ecrire des types simples&lt;br&gt;(entiers, flottants) et des Ob...">Sortie</a>&amp;)<br/>
NE FAIT RIEN<br/>
A surcharger dans les classes derivees.<br/>
Imprime les conditions aux limites discretisees sur un flot de sortie. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="classSortie.html" title="Classe de base des flux de sortie. Elle sait ecrire des types simples&lt;br&gt;(entiers, flottants) et des Ob...">Sortie</a>&amp;<br/>
 Signification: le flot de sortie modifie<br/>
 Contraintes: </dd></dl>

<p>Reimplemented from <a class="el" href="classZone__Cl__VEF.html#a5b27e3652d3c1bb25a9c0630d51ba172">Zone_Cl_VEF</a>.</p>

<p>Definition at line <a class="el" href="Zone__Cl__VEFP1B_8cpp_source.html#l00034">34</a> of file <a class="el" href="Zone__Cl__VEFP1B_8cpp_source.html">Zone_Cl_VEFP1B.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">return</span> <a class="code" href="classZone__Cl__VEFP1B.html#a8c4a1aba406537f647659ebb0e7d1f56" title="Surcharge Objet_U::printOn(Sortie&amp;) NE FAIT RIEN A surcharger dans les classes derivees. Imprime les conditions aux limites discretisees sur un flot de sortie.">Zone_Cl_VEF::printOn</a>(s) ;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a54c1a66de2fcbd688613bb1c53059e6c"></a><!-- doxytag: member="Zone_Cl_VEFP1B::readOn" ref="a54c1a66de2fcbd688613bb1c53059e6c" args="(Entree &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEntree.html">Entree</a> &amp; Zone_Cl_VEFP1B::readOn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEntree.html">Entree</a> &amp;&#160;</td>
          <td class="paramname"><em>is</em></td><td>)</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Surcharge <a class="el" href="classObjet__U.html#a6f4c7788efee2dce629ebd1628b73288" title="Lecture d&#39;un Objet_U sur un flot d&#39;entree Methode a surcharger.">Objet_U::readOn</a>(<a class="el" href="classSortie.html" title="Classe de base des flux de sortie. Elle sait ecrire des types simples&lt;br&gt;(entiers, flottants) et des Ob...">Sortie</a>&amp;)<br/>
Lit les conditions aux limites discretisees a partir d'un flot d'entree<br/>
Le format attendu est le suivant:<br/>
{<br/>
<a class="el" href="classNom.html" title="class Nom Une chaine de caractere pour nommer les objets de TRUST">Nom</a> <a class="el" href="classCond__lim.html" title="classe Cond_lim Classe generique servant a representer n&#39;importe quelle classe derivee de la classe C...">Cond_lim</a> [REPETER LECTURE AUTANT DE FOIS QUE NECESSAIRE]<br/>
}. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="classEntree.html" title="Classe de definition des operateurs et methodes pour toute lecture dans un flot d&#39;entree (fichier...">Entree</a>&amp;<br/>
 Signification: le flot d'entree modifie<br/>
 Contraintes: </dd></dl>

<p>Reimplemented from <a class="el" href="classZone__Cl__VEF.html#a0cbd1094cb6188cffb4c2d54b060781b">Zone_Cl_VEF</a>.</p>

<p>Definition at line <a class="el" href="Zone__Cl__VEFP1B_8cpp_source.html#l00039">39</a> of file <a class="el" href="Zone__Cl__VEFP1B_8cpp_source.html">Zone_Cl_VEFP1B.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">return</span> <a class="code" href="classZone__Cl__VEFP1B.html#a54c1a66de2fcbd688613bb1c53059e6c" title="Surcharge Objet_U::readOn(Sortie&amp;) Lit les conditions aux limites discretisees a partir d&#39;un flot d&#39;e...">Zone_Cl_VEF::readOn</a>(is)  ;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a000b3c6a248677679f4be6d07ce90587"></a><!-- doxytag: member="Zone_Cl_VEFP1B::remplir_volumes_entrelaces_Cl" ref="a000b3c6a248677679f4be6d07ce90587" args="(const Zone_VEF &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Zone_Cl_VEFP1B::remplir_volumes_entrelaces_Cl </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classZone__VEF.html">Zone_VEF</a> &amp;&#160;</td>
          <td class="paramname"><em>la_zone_VEF</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>appele par <a class="el" href="classZone__Cl__dis__base.html#a8bfb3fea47744d520e6e774d554f9484" title="Appel Cond_lim_base::completer() sur chaque condition aux limites.">completer()</a> : remplissage de type_elem_Cl_ et<br/>
volumes_entrelaces_Cl_ </p>

<p>Reimplemented from <a class="el" href="classZone__Cl__VEF.html#ae9f8f1bc6df16e55d4fb0f5b8067a0ad">Zone_Cl_VEF</a>.</p>

<p>Definition at line <a class="el" href="Zone__Cl__VEFP1B_8cpp_source.html#l00138">138</a> of file <a class="el" href="Zone__Cl__VEFP1B_8cpp_source.html">Zone_Cl_VEFP1B.cpp</a>.</p>

<p>References <a class="el" href="EntreeSortie_8h_source.html#l00032">Cerr</a>, <a class="el" href="MorEqn_8h_source.html#l00082">MorEqn::equation()</a>, <a class="el" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>, <a class="el" href="Zone__VEF__PreP1b_8h_source.html#l00071">Zone_VEF_PreP1b::get_alphaA()</a>, <a class="el" href="Zone__VEF__PreP1b_8h_source.html#l00061">Zone_VEF_PreP1b::get_alphaE()</a>, <a class="el" href="Zone__VEF__PreP1b_8h_source.html#l00066">Zone_VEF_PreP1b::get_alphaS()</a>, <a class="el" href="Zone__VEF__PreP1b_8h_source.html#l00076">Zone_VEF_PreP1b::get_modif_div_face_dirichlet()</a>, <a class="el" href="Zone__VEF_8h_source.html#l00209">Zone_VEF::nb_faces_non_std()</a>, <a class="el" href="Cast_8h_source.html#l00059">ref_cast</a>, <a class="el" href="Cast_8h_source.html#l00054">sub_type</a>, <a class="el" href="Zone__VF_8h_source.html#l00736">Zone_VF::volumes_entrelaces()</a>, and <a class="el" href="Zone__Cl__VEF_8h_source.html#l00110">Zone_Cl_VEF::volumes_entrelaces_Cl()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;On passe dans Zone_Cl_VEFP1B::remplir_volumes_entrelaces&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
<span class="comment">// On rappelle la methode de la classe mere pour etendre les volumes de controles sur les faces non standard.</span>
<span class="comment">// Uniquement en conduction pour l&#39;instant ou en P0 seul</span>
  <span class="keyword">const</span> <a class="code" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a>&amp; z=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a>, la_zone_VEF);
  <span class="keywordflow">if</span> ((z.<a class="code" href="classZone__VEF__PreP1b.html#aa2b3f7b3fcebdd13aa386170a840780b">get_modif_div_face_dirichlet</a>())||<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classConduction.html" title="Classe Conduction Cette classe represente l&#39;equation d&#39;evolution de la temperature dans un solide de ...">Conduction</a>, <a class="code" href="classMorEqn.html#a615dd9abff96edcb625fa0424a489864" title="Renvoie la reference sur l&#39;equation pointe par MorEqn::mon_equation. (version const)">equation</a>()) || (z.<a class="code" href="classZone__VEF__PreP1b.html#aee2def53aa92584d7945e7c3d0d98963">get_alphaE</a>() &amp;&amp; !z.<a class="code" href="classZone__VEF__PreP1b.html#ad7fbcb5567dcc2e6f0a0ed85ce90a4fa">get_alphaS</a>() &amp;&amp; !z.<a class="code" href="classZone__VEF__PreP1b.html#a9d02e2431efb6e75c3d733ff06f89549">get_alphaA</a>()))
    <span class="keywordflow">return</span> <a class="code" href="classZone__Cl__VEFP1B.html#a000b3c6a248677679f4be6d07ce90587" title="appele par completer() : remplissage de type_elem_Cl_ et volumes_entrelaces_Cl_">Zone_Cl_VEF::remplir_volumes_entrelaces_Cl</a>(la_zone_VEF);
  <span class="keywordflow">else</span>
    {
      <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; volumes_entrelaces = la_zone_VEF.<a class="code" href="classZone__VF.html#a64f0b549e5aea1656855113e3510f418">volumes_entrelaces</a>();
<span class="comment">// Initialisation du tableau volumes_entrelaces_Cl</span>
<span class="comment">// a priori les faces non standard ne sont pas touchees par les C.L</span>
      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;la_zone_VEF.<a class="code" href="classZone__VEF.html#a0ac71492d527961068dab905f3bd9533">nb_faces_non_std</a>(); i++)
        <a class="code" href="classZone__Cl__VEF.html#a90472bd1eab30a131535571a567508e4">volumes_entrelaces_Cl</a>(i) = volumes_entrelaces(i);
      <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Fin creation esp. virtuel volumes_entrelaces_Cl_&quot;</span> &lt;&lt; finl;
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="ad3125a7cef2672b93550518ff73a256c"></a><!-- doxytag: member="Zone_Cl_VEFP1B::self_cast" ref="ad3125a7cef2672b93550518ff73a256c" args="(const Objet_U &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classZone__Cl__VEFP1B.html">Zone_Cl_VEFP1B</a> &amp; Zone_Cl_VEFP1B::self_cast </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classObjet__U.html">Objet_U</a> &amp;&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>methode ajoutee pour caster en python </p>

<p>Reimplemented from <a class="el" href="classZone__Cl__VEF.html#a1a1f766a46284419bb9ef49bd3036bc6">Zone_Cl_VEF</a>.</p>

<p>Definition at line <a class="el" href="Zone__Cl__VEFP1B_8cpp_source.html#l00030">30</a> of file <a class="el" href="Zone__Cl__VEFP1B_8cpp_source.html">Zone_Cl_VEFP1B.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9e3313c116827764bb5e3fde5d5fb514"></a><!-- doxytag: member="Zone_Cl_VEFP1B::self_cast" ref="a9e3313c116827764bb5e3fde5d5fb514" args="(Objet_U &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classZone__Cl__VEFP1B.html">Zone_Cl_VEFP1B</a> &amp; Zone_Cl_VEFP1B::self_cast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classObjet__U.html">Objet_U</a> &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="classZone__Cl__VEF.html#a3fe431dd82fbe008b42d382a928a6f60">Zone_Cl_VEF</a>.</p>

<p>Definition at line <a class="el" href="Zone__Cl__VEFP1B_8cpp_source.html#l00030">30</a> of file <a class="el" href="Zone__Cl__VEFP1B_8cpp_source.html">Zone_Cl_VEFP1B.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2c18614ea942d5260b516ac354f898d3"></a><!-- doxytag: member="Zone_Cl_VEFP1B::taille_memoire" ref="a2c18614ea942d5260b516ac354f898d3" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned Zone_Cl_VEFP1B::taille_memoire </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="classZone__Cl__VEF.html#a86f0875561fd284aaeb2b9aca9d1bc88">Zone_Cl_VEF</a>.</p>

<p>Definition at line <a class="el" href="Zone__Cl__VEFP1B_8cpp_source.html#l00030">30</a> of file <a class="el" href="Zone__Cl__VEFP1B_8cpp_source.html">Zone_Cl_VEFP1B.cpp</a>.</p>

</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="ada9fa7a792e960e566a18c69cb6fe9c8"></a><!-- doxytag: member="Zone_Cl_VEFP1B::info_obj" ref="ada9fa7a792e960e566a18c69cb6fe9c8" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classType__info.html">Type_info</a> <a class="el" href="classZone__Cl__VEFP1B.html#ada9fa7a792e960e566a18c69cb6fe9c8">Zone_Cl_VEFP1B::info_obj</a><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="classZone__Cl__VEF.html#af417d23c2ed3d48e573b3e6dd4fe305d">Zone_Cl_VEF</a>.</p>

<p>Definition at line <a class="el" href="Zone__Cl__VEFP1B_8h_source.html#l00031">31</a> of file <a class="el" href="Zone__Cl__VEFP1B_8h_source.html">Zone_Cl_VEFP1B.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/P1NCP1B/Zones/<a class="el" href="Zone__Cl__VEFP1B_8h_source.html">Zone_Cl_VEFP1B.h</a></li>
<li>src/P1NCP1B/Zones/<a class="el" href="Zone__Cl__VEFP1B_8cpp_source.html">Zone_Cl_VEFP1B.cpp</a></li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Tue Dec 14 2021 19:38:12 for TRUST by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
