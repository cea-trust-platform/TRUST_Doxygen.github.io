<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>TRUST: src/P1NCP1B/Solveurs/AssembleurPP1BUtil.cpp File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">TRUST&#160;<span id="projectnumber">1.8.4</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">src/P1NCP1B/Solveurs/AssembleurPP1BUtil.cpp File Reference</div>  </div>
</div>
<div class="contents">
<div class="textblock"><code>#include &lt;<a class="el" href="Assembleur__P__VEFPreP1B_8h_source.html">Assembleur_P_VEFPreP1B.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="Matrice__Bloc__Sym_8h_source.html">Matrice_Bloc_Sym.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="Domaine_8h_source.html">Domaine.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="Dirichlet_8h_source.html">Dirichlet.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="Dirichlet__homogene_8h_source.html">Dirichlet_homogene.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="Periodique_8h_source.html">Periodique.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="Neumann__sortie__libre_8h_source.html">Neumann_sortie_libre.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="Symetrie_8h_source.html">Symetrie.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="LecFicDistribueBin_8h_source.html">LecFicDistribueBin.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="EcrFicCollecteBin_8h_source.html">EcrFicCollecteBin.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="DoubleLists_8h_source.html">DoubleLists.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="Navier__Stokes__std_8h_source.html">Navier_Stokes_std.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="Op__Div__VEFP1B__Elem_8h_source.html">Op_Div_VEFP1B_Elem.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="Champ__front__instationnaire__base_8h_source.html">Champ_front_instationnaire_base.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="Champ__front__var_8h_source.html">Champ_front_var.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="Op__Grad__VEF__P1B__Face_8h_source.html">Op_Grad_VEF_P1B_Face.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="Milieu__base_8h_source.html">Milieu_base.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="IntLists_8h_source.html">IntLists.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="Debog_8h_source.html">Debog.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="Check__espace__virtuel_8h_source.html">Check_espace_virtuel.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="Scatter_8h_source.html">Scatter.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="communications_8h_source.html">communications.h</a>&gt;</code><br/>
</div>
<p><a href="AssembleurPP1BUtil_8cpp_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="AssembleurPP1BUtil_8cpp.html#a67ce6f1ce2314223209eca2d6ef7ac06">projette</a> (<a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;gradi, int face, const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;normales)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="AssembleurPP1BUtil_8cpp.html#a40cf40213663174bb24649e51832bf3e">okface</a> (int &amp;ind_face, int &amp;face, const <a class="el" href="classCond__lim.html">Cond_lim</a> &amp;la_cl)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="AssembleurPP1BUtil_8cpp.html#add6cc8459f10f15a9a6bac24d1727880">verifier_complet</a> (const <a class="el" href="classAssembleur__P__VEFPreP1B.html">Assembleur_P_VEFPreP1B</a> &amp;ass, const <a class="el" href="classMatrice__Bloc__Sym.html">Matrice_Bloc_Sym</a> &amp;matrice, const <a class="el" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a> &amp;zone_VEF)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="AssembleurPP1BUtil_8cpp.html#ab3f0bf1b466f4f73f7c106a25a0ce950">verifier</a> (const <a class="el" href="classAssembleur__P__VEFPreP1B.html">Assembleur_P_VEFPreP1B</a> &amp;ass, const <a class="el" href="classMatrice__Bloc__Sym.html">Matrice_Bloc_Sym</a> &amp;matrice, const <a class="el" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a> &amp;zone_VEF, const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;inverse_quantitee_entrelacee)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="AssembleurPP1BUtil_8cpp.html#acff816d35f8d4ce978f860e0cd958b8a">sort</a> (<a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;sommets, <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;faces_op1, <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;faces_op2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="AssembleurPP1BUtil_8cpp.html#ae1c00f10faaf4da3ffdea8f881565a1b">chercher_arete</a> (const <a class="el" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a> &amp;zone_VEF, int elem, int somi, int somj, const <a class="el" href="classIntTab.html">IntTab</a> &amp;elem_aretes, const <a class="el" href="classIntTab.html">IntTab</a> &amp;aretes_som)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="AssembleurPP1BUtil_8cpp.html#a3117b050530c46b4a15b6ab9ce6d0b41">swap</a> (int &amp;i, int &amp;j)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="AssembleurPP1BUtil_8cpp.html#afd0a249a235b161c5267e7574e199a82">remplir_sommets</a> (const <a class="el" href="classZone__VEF.html">Zone_VEF</a> &amp;zone_VEF, int face, int elem1, int elem2, <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;sommets, <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;faces_op1, <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;faces_op2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="AssembleurPP1BUtil_8cpp.html#a556b82e62a565319fb25218f97cfc50c">calculer_grad</a> (const <a class="el" href="classIntTab.html">IntTab</a> &amp;face_voisins, int elem1, int elem2, const <a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;coef_som, int s, int fop1, int fop2, const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;normales, <a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;grad)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="AssembleurPP1BUtil_8cpp.html#aa26334c33fd016e71cbab82de7ef2fe5">calculer_grad_arete</a> (int face, const <a class="el" href="classIntTab.html">IntTab</a> &amp;face_voisins, int i, int j, int elem1, int elem2, int fop1, int fop2, int fop3, int fop4, const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;normales, <a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;grad)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="AssembleurPP1BUtil_8cpp.html#a828055cfc33e4c56db8e2f5beb059862">dotproduct_array_fois_inverse_quantitee_entrelacee</a> (const <a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;gradi, const <a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;gradE, const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;inverse_quantitee_entrelacee, int face)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="AssembleurPP1BUtil_8cpp.html#ae2056e931f2d24d03da578b6af30cd54">contribuer_matriceP0P1</a> (const <a class="el" href="classZone__VEF.html">Zone_VEF</a> &amp;zone_VEF, const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;inverse_quantitee_entrelacee, int face, int elem1, int elem2, <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;sommets, <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;faces_op1, <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;faces_op2, const <a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;coef_som, <a class="el" href="classIntLists.html">IntLists</a> &amp;voisins, <a class="el" href="classDoubleLists.html">DoubleLists</a> &amp;coeffs, int &amp;nnz)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="AssembleurPP1BUtil_8cpp.html#ab68e858c58953d7d372ea8deee92fc6a">range</a> (int &amp;i, int &amp;n, int &amp;j, int &amp;m, <a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;ARR, <a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;ARV, <a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;AVR, <a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;AVV, double <a class="el" href="Champ__P1iP1B__implementation_8cpp.html#aa8c8f49390c3cf7c702d71a71bc977e3">coeff</a>)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="AssembleurPP1BUtil_8cpp.html#aa7aef5562f5fe1f2d5b1eeb6664bca53">update_matriceP0P1</a> (const <a class="el" href="classZone__VEF.html">Zone_VEF</a> &amp;zone_VEF, const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;inverse_quantitee_entrelacee, int face, int elem1, int elem2, <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;sommets, <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;faces_op1, <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;faces_op2, const <a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;coef_som, <a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;ARR, <a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;ARV, <a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;AVR, <a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;AVV)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="AssembleurPP1BUtil_8cpp.html#ae9226a0247d37eab885c3915814c82c7">contribuer_matriceP1P1</a> (const <a class="el" href="classZone__VEF.html">Zone_VEF</a> &amp;zone_VEF, const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;inverse_quantitee_entrelacee, int face, int elem1, int elem2, <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;sommets, <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;faces_op1, <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;faces_op2, const <a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;coef_som, <a class="el" href="classIntLists.html">IntLists</a> &amp;voisins, <a class="el" href="classDoubleLists.html">DoubleLists</a> &amp;coeffs, <a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;diag, int &amp;nnz)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="AssembleurPP1BUtil_8cpp.html#a77351839245012751e4d90a39922356a">update_matriceP1P1</a> (const <a class="el" href="classZone__VEF.html">Zone_VEF</a> &amp;zone_VEF, const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;inverse_quantitee_entrelacee, int face, int elem1, int elem2, <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;sommets, <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;faces_op1, <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;faces_op2, const <a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;coef_som, <a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;ARR, <a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;ARV, <a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;AVR, <a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;AVV)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="AssembleurPP1BUtil_8cpp.html#a59992a437cf7e18b4b9ce353d77d0bda">contribuer_matricePaPa</a> (const <a class="el" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a> &amp;zone_VEF, const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;inverse_quantitee_entrelacee, int face, int elem1, int elem2, <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;sommets, <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;faces_op1, <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;faces_op2, <a class="el" href="classIntLists.html">IntLists</a> &amp;voisins, <a class="el" href="classDoubleLists.html">DoubleLists</a> &amp;coeffs, <a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;diag, int &amp;nnz)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="AssembleurPP1BUtil_8cpp.html#a76d676949fb80bc3c7f1ab5f7f8078c0">update_matricePaPa</a> (const <a class="el" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a> &amp;zone_VEF, const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;inverse_quantitee_entrelacee, int face, int elem1, int elem2, <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;sommets, <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;faces_op1, <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;faces_op2, <a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;ARR, <a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;ARV, <a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;AVR, <a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;AVV)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="AssembleurPP1BUtil_8cpp.html#a5e6fc2e2157dce70a345b3d8c1294477">contribuer_matrice_NeumannP0P1</a> (const <a class="el" href="classZone__VEF.html">Zone_VEF</a> &amp;zone_VEF, const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;inverse_quantitee_entrelacee, int face, int elem, <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;sommets, <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;faces_op1, const <a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;coef_som, <a class="el" href="classIntLists.html">IntLists</a> &amp;voisins, <a class="el" href="classDoubleLists.html">DoubleLists</a> &amp;coeffs, int &amp;nnz)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="AssembleurPP1BUtil_8cpp.html#a1aa97c31d5b8f95ae899f599d606a1da">update_matrice_NeumannP0P1</a> (const <a class="el" href="classZone__VEF.html">Zone_VEF</a> &amp;zone_VEF, const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;inverse_quantitee_entrelacee, int face, int elem, <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;sommets, <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;faces_op1, const <a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;coef_som, <a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;ARR, <a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;ARV, <a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;AVR, <a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;AVV)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="AssembleurPP1BUtil_8cpp.html#ad9eeb295c62a30fa2305edf29ad7cfd5">contribuer_matrice_NeumannP1P1</a> (const <a class="el" href="classZone__VEF.html">Zone_VEF</a> &amp;zone_VEF, const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;inverse_quantitee_entrelacee, int face, int elem, <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;sommets, <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;faces_op1, const <a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;coef_som, <a class="el" href="classIntLists.html">IntLists</a> &amp;voisins, <a class="el" href="classDoubleLists.html">DoubleLists</a> &amp;coeffs, <a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;diag, int &amp;nnz)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="AssembleurPP1BUtil_8cpp.html#affe9938bfd355c4e19b608c286c0293b">update_matrice_NeumannP1P1</a> (const <a class="el" href="classZone__VEF.html">Zone_VEF</a> &amp;zone_VEF, const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;inverse_quantitee_entrelacee, int face, int elem, <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;sommets, <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;faces_op1, const <a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;coef_som, <a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;ARR, <a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;ARV, <a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;AVR, <a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;AVV)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="AssembleurPP1BUtil_8cpp.html#a9568a5e0cbf3b9e2b60ad3f3bdac25df">contribuer_matrice_SymetrieP1P1</a> (const <a class="el" href="classZone__VEF.html">Zone_VEF</a> &amp;zone_VEF, const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;inverse_quantitee_entrelacee, int face, int elem, <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;sommets, <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;faces_op1, const <a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;coef_som, <a class="el" href="classIntLists.html">IntLists</a> &amp;voisins, <a class="el" href="classDoubleLists.html">DoubleLists</a> &amp;coeffs, <a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;diag, int &amp;nnz)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="AssembleurPP1BUtil_8cpp.html#ade1c92b286a861f3920664b658ba3fb1">update_matrice_SymetrieP1P1</a> (const <a class="el" href="classZone__VEF.html">Zone_VEF</a> &amp;zone_VEF, const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;inverse_quantitee_entrelacee, int face, int elem, <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;sommets, <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;faces_op1, const <a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;coef_som, <a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;ARR, <a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;ARV, <a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;AVR, <a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;AVV)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="AssembleurPP1BUtil_8cpp.html#a80033228b3ed99e778b70c35cda5e4e6">contribuer_matrice_NeumannPaPa</a> (const <a class="el" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a> &amp;zone_VEF, const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;inverse_quantitee_entrelacee, int face, int elem, <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;sommets, <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;faces_op1, <a class="el" href="classIntLists.html">IntLists</a> &amp;voisins, <a class="el" href="classDoubleLists.html">DoubleLists</a> &amp;coeffs, <a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;diag, int &amp;nnz)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="AssembleurPP1BUtil_8cpp.html#a6a26a390dab2336113f60275e5978aaf">update_matrice_NeumannPaPa</a> (const <a class="el" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a> &amp;zone_VEF, const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;inverse_quantitee_entrelacee, int face, int elem, <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;sommets, <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;faces_op1, <a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;ARR, <a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;ARV, <a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;AVR, <a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;AVV)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="AssembleurPP1BUtil_8cpp.html#ac51ccb6fe9aac0200f1b08da9d81c65b">contribuer_matrice_SymetriePaPa</a> (const <a class="el" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a> &amp;zone_VEF, const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;inverse_quantitee_entrelacee, int face, int elem, <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;sommets, <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;faces_op1, <a class="el" href="classIntLists.html">IntLists</a> &amp;voisins, <a class="el" href="classDoubleLists.html">DoubleLists</a> &amp;coeffs, <a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;diag, int &amp;nnz)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="AssembleurPP1BUtil_8cpp.html#a6e9d49381847c5756d002970ca6441b8">update_matrice_SymetriePaPa</a> (const <a class="el" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a> &amp;zone_VEF, const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;inverse_quantitee_entrelacee, int face, int elem, <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;sommets, <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;faces_op1, <a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;ARR, <a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;ARV, <a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;AVR, <a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;AVV)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="AssembleurPP1BUtil_8cpp.html#a36c4cdf9e6baa421844cf7cffa1396df">contribuer_matriceP0Pa</a> (const <a class="el" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a> &amp;zone_VEF, const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;inverse_quantitee_entrelacee, int face, int elem1, int elem2, <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;sommets, <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;faces_op1, <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;faces_op2, <a class="el" href="classIntLists.html">IntLists</a> &amp;voisins, <a class="el" href="classDoubleLists.html">DoubleLists</a> &amp;coeffs, int &amp;nnz)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="AssembleurPP1BUtil_8cpp.html#a68f4b5d510b37d5518ed576764da2611">update_matriceP0Pa</a> (const <a class="el" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a> &amp;zone_VEF, const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;inverse_quantitee_entrelacee, int face, int elem1, int elem2, <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;sommets, <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;faces_op1, <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;faces_op2, <a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;ARR, <a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;ARV, <a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;AVR, <a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;AVV)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="AssembleurPP1BUtil_8cpp.html#ae709048ec2f850b47b8601c013ed8550">contribuer_matrice_NeumannP0Pa</a> (const <a class="el" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a> &amp;zone_VEF, const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;inverse_quantitee_entrelacee, int face, int elem, <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;sommets, <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;faces_op1, <a class="el" href="classIntLists.html">IntLists</a> &amp;voisins, <a class="el" href="classDoubleLists.html">DoubleLists</a> &amp;coeffs, int &amp;nnz)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="AssembleurPP1BUtil_8cpp.html#a45b45851ba59992d7eb7a25c002a9f73">update_matrice_NeumannP0Pa</a> (const <a class="el" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a> &amp;zone_VEF, const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;inverse_quantitee_entrelacee, int face, int elem, <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;sommets, <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;faces_op1, <a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;ARR, <a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;ARV, <a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;AVR, <a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;AVV)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="AssembleurPP1BUtil_8cpp.html#a0000fbbb1165039c7071352be4a35877">contribuer_matriceP1Pa</a> (const <a class="el" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a> &amp;zone_VEF, const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;inverse_quantitee_entrelacee, int face, int elem1, int elem2, <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;sommets, <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;faces_op1, <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;faces_op2, const <a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;coef_som, <a class="el" href="classIntLists.html">IntLists</a> &amp;voisins, <a class="el" href="classDoubleLists.html">DoubleLists</a> &amp;coeffs, int &amp;nnz)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="AssembleurPP1BUtil_8cpp.html#ac499159b3caa7be06c8c9fddfdb5c8c1">update_matriceP1Pa</a> (const <a class="el" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a> &amp;zone_VEF, const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;inverse_quantitee_entrelacee, int face, int elem1, int elem2, <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;sommets, <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;faces_op1, <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;faces_op2, const <a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;coef_som, <a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;ARR, <a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;ARV, <a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;AVR, <a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;AVV)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="AssembleurPP1BUtil_8cpp.html#a1ee529d67fc174bfe005efe590812122">contribuer_matrice_NeumannP1Pa</a> (const <a class="el" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a> &amp;zone_VEF, const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;inverse_quantitee_entrelacee, int face, int elem, <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;sommets, <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;faces_op1, const <a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;coef_som, <a class="el" href="classIntLists.html">IntLists</a> &amp;voisins, <a class="el" href="classDoubleLists.html">DoubleLists</a> &amp;coeffs, int &amp;nnz)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="AssembleurPP1BUtil_8cpp.html#a7da454ba757d1b7ed7ccc39954e6cab5">update_matrice_NeumannP1Pa</a> (const <a class="el" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a> &amp;zone_VEF, const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;inverse_quantitee_entrelacee, int face, int elem, <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;sommets, <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;faces_op1, const <a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;coef_som, <a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;ARR, <a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;ARV, <a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;AVR, <a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;AVV)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="AssembleurPP1BUtil_8cpp.html#ae3056a39c9c01f3a2727f0dbf4b5e331">contribuer_matrice_SymetrieP1Pa</a> (const <a class="el" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a> &amp;zone_VEF, const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;inverse_quantitee_entrelacee, int face, int elem, <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;sommets, <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;faces_op1, const <a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;coef_som, <a class="el" href="classIntLists.html">IntLists</a> &amp;voisins, <a class="el" href="classDoubleLists.html">DoubleLists</a> &amp;coeffs, int &amp;nnz)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="AssembleurPP1BUtil_8cpp.html#aa18f9eabe40c3c77172253c07802c05f">update_matrice_SymetrieP1Pa</a> (const <a class="el" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a> &amp;zone_VEF, const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;inverse_quantitee_entrelacee, int face, int elem, <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;sommets, <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;faces_op1, const <a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;coef_som, <a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;ARR, <a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;ARV, <a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;AVR, <a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;AVV)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="AssembleurPP1BUtil_8cpp.html#a31e2d4bc38d5bc0bbf9e2c36d15b589b">assemblerP0P0</a> (const <a class="el" href="classZone__dis__base.html">Zone_dis_base</a> &amp;z, const <a class="el" href="classZone__Cl__dis__base.html">Zone_Cl_dis_base</a> &amp;zcl, <a class="el" href="classMatrice.html">Matrice</a> &amp;matrice, const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;inverse_quantitee_entrelacee)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="AssembleurPP1BUtil_8cpp.html#a48eaaecaa31bdde228ea5e3995db4771">updateP0P0</a> (const <a class="el" href="classZone__dis__base.html">Zone_dis_base</a> &amp;z, const <a class="el" href="classZone__Cl__dis__base.html">Zone_Cl_dis_base</a> &amp;zcl, <a class="el" href="classMatrice.html">Matrice</a> &amp;matrice, const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;inverse_quantitee_entrelacee)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="AssembleurPP1BUtil_8cpp.html#a31f132f3fda04d8428de212c63fd902f">assemblerP1P1</a> (const <a class="el" href="classZone__dis__base.html">Zone_dis_base</a> &amp;z, const <a class="el" href="classZone__Cl__dis__base.html">Zone_Cl_dis_base</a> &amp;zcl, <a class="el" href="classMatrice.html">Matrice</a> &amp;matrice, const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;inverse_quantitee_entrelacee, const <a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;coef_som)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="AssembleurPP1BUtil_8cpp.html#ab3c25c4172223f48fd2f9d433b005e0c">updateP1P1</a> (const <a class="el" href="classZone__dis__base.html">Zone_dis_base</a> &amp;z, const <a class="el" href="classZone__Cl__dis__base.html">Zone_Cl_dis_base</a> &amp;zcl, <a class="el" href="classMatrice.html">Matrice</a> &amp;matrice, const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;inverse_quantitee_entrelacee, const <a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;coef_som)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="AssembleurPP1BUtil_8cpp.html#a1ce15acad922bef2d305d970c13c68c8">modifieP1P1neumann</a> (const <a class="el" href="classZone__dis__base.html">Zone_dis_base</a> &amp;z, const <a class="el" href="classZone__Cl__dis__base.html">Zone_Cl_dis_base</a> &amp;zcl, <a class="el" href="classMatrice.html">Matrice</a> &amp;matrice, const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;inverse_quantitee_entrelacee, const <a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;coef_som)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="AssembleurPP1BUtil_8cpp.html#a7840f924363ed7d3fbd50a59d9d990c0">assemblerPaPa</a> (const <a class="el" href="classZone__dis__base.html">Zone_dis_base</a> &amp;z, const <a class="el" href="classZone__Cl__dis__base.html">Zone_Cl_dis_base</a> &amp;zcl, <a class="el" href="classMatrice.html">Matrice</a> &amp;matrice, const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;inverse_quantitee_entrelacee)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="AssembleurPP1BUtil_8cpp.html#a4e0c0752e80915fd8b0143b70f08e718">updatePaPa</a> (const <a class="el" href="classZone__dis__base.html">Zone_dis_base</a> &amp;z, const <a class="el" href="classZone__Cl__dis__base.html">Zone_Cl_dis_base</a> &amp;zcl, <a class="el" href="classMatrice.html">Matrice</a> &amp;matrice, const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;inverse_quantitee_entrelacee)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="AssembleurPP1BUtil_8cpp.html#a30b5e404b46e2a239584ee19835c88bf">assemblerP0Pa</a> (const <a class="el" href="classZone__dis__base.html">Zone_dis_base</a> &amp;z, const <a class="el" href="classZone__Cl__dis__base.html">Zone_Cl_dis_base</a> &amp;zcl, <a class="el" href="classMatrice.html">Matrice</a> &amp;matrice, const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;inverse_quantitee_entrelacee)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="AssembleurPP1BUtil_8cpp.html#aacede92ea2595a5546e6357fbd1e1498">updateP0Pa</a> (const <a class="el" href="classZone__dis__base.html">Zone_dis_base</a> &amp;z, const <a class="el" href="classZone__Cl__dis__base.html">Zone_Cl_dis_base</a> &amp;zcl, <a class="el" href="classMatrice.html">Matrice</a> &amp;matrice, const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;inverse_quantitee_entrelacee)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="AssembleurPP1BUtil_8cpp.html#a5dcfee4400f896bcbb100259f53a5de1">assemblerP1Pa</a> (const <a class="el" href="classZone__dis__base.html">Zone_dis_base</a> &amp;z, const <a class="el" href="classZone__Cl__dis__base.html">Zone_Cl_dis_base</a> &amp;zcl, <a class="el" href="classMatrice.html">Matrice</a> &amp;matrice, const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;inverse_quantitee_entrelacee, const <a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;coef_som)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="AssembleurPP1BUtil_8cpp.html#a8d9349eb29399f4ac72dc10543a4005a">updateP1Pa</a> (const <a class="el" href="classZone__dis__base.html">Zone_dis_base</a> &amp;z, const <a class="el" href="classZone__Cl__dis__base.html">Zone_Cl_dis_base</a> &amp;zcl, <a class="el" href="classMatrice.html">Matrice</a> &amp;matrice, const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;inverse_quantitee_entrelacee, const <a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;coef_som)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="AssembleurPP1BUtil_8cpp.html#a3774b1608aeee56152e7e1e5f385bfe1">assemblerP0P1</a> (const <a class="el" href="classZone__dis__base.html">Zone_dis_base</a> &amp;z, const <a class="el" href="classZone__Cl__dis__base.html">Zone_Cl_dis_base</a> &amp;zcl, <a class="el" href="classMatrice.html">Matrice</a> &amp;matrice, const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;inverse_quantitee_entrelacee, const <a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;coef_som)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="AssembleurPP1BUtil_8cpp.html#af30661e8e1b45bf522a5595f65ecc741">updateP0P1</a> (const <a class="el" href="classZone__dis__base.html">Zone_dis_base</a> &amp;z, const <a class="el" href="classZone__Cl__dis__base.html">Zone_Cl_dis_base</a> &amp;zcl, <a class="el" href="classMatrice.html">Matrice</a> &amp;matrice, const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;inverse_quantitee_entrelacee, const <a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;coef_som)</td></tr>
<tr><td colspan="2"><h2><a name="var-members"></a>
Variables</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="AssembleurPP1BUtil_8cpp.html#a3e374d53ebc7860e1c2f0b7906f2936d">face_associee</a> = -1</td></tr>
</table>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a31e2d4bc38d5bc0bbf9e2c36d15b589b"></a><!-- doxytag: member="AssembleurPP1BUtil.cpp::assemblerP0P0" ref="a31e2d4bc38d5bc0bbf9e2c36d15b589b" args="(const Zone_dis_base &amp;z, const Zone_Cl_dis_base &amp;zcl, Matrice &amp;matrice, const DoubleTab &amp;inverse_quantitee_entrelacee)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void assemblerP0P0 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classZone__dis__base.html">Zone_dis_base</a> &amp;&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classZone__Cl__dis__base.html">Zone_Cl_dis_base</a> &amp;&#160;</td>
          <td class="paramname"><em>zcl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatrice.html">Matrice</a> &amp;&#160;</td>
          <td class="paramname"><em>matrice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>inverse_quantitee_entrelacee</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l02222">2222</a> of file <a class="el" href="AssembleurPP1BUtil_8cpp_source.html">AssembleurPP1BUtil.cpp</a>.</p>

<p>References <a class="el" href="Assembleur__P__VEF_8cpp_source.html#l00755">Assembleur_P_VEF::associer_zone_cl_dis_base()</a>, <a class="el" href="Assembleur__P__VEF_8cpp_source.html#l00750">Assembleur_P_VEF::associer_zone_dis_base()</a>, <a class="el" href="EntreeSortie_8h_source.html#l00032">Cerr</a>, <a class="el" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>, and <a class="el" href="Assembleur__P__VEF_8cpp_source.html#l00134">Assembleur_P_VEF::remplir()</a>.</p>

<p>Referenced by <a class="el" href="Assembleur__P__VEFPreP1B_8cpp_source.html#l00230">Assembleur_P_VEFPreP1B::assembler_mat()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <a class="code" href="classAssembleur__P__VEF.html">Assembleur_P_VEF</a> Assembleur_P0;
  Assembleur_P0.<a class="code" href="classAssembleur__P__VEF.html#a5b2a8af584466c11399b032515921978">associer_zone_dis_base</a>(z);
  Assembleur_P0.<a class="code" href="classAssembleur__P__VEF.html#a69468e49c8496eda05508c8e8477493b">associer_zone_cl_dis_base</a>(zcl);
  Assembleur_P0.<a class="code" href="classAssembleur__P__VEF.html#abe02c31a6c1ada8d05996def7f43ea58">remplir</a>(matrice,inverse_quantitee_entrelacee);
  <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Assemblage P0 OK&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a3774b1608aeee56152e7e1e5f385bfe1"></a><!-- doxytag: member="AssembleurPP1BUtil.cpp::assemblerP0P1" ref="a3774b1608aeee56152e7e1e5f385bfe1" args="(const Zone_dis_base &amp;z, const Zone_Cl_dis_base &amp;zcl, Matrice &amp;matrice, const DoubleTab &amp;inverse_quantitee_entrelacee, const ArrOfDouble &amp;coef_som)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void assemblerP0P1 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classZone__dis__base.html">Zone_dis_base</a> &amp;&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classZone__Cl__dis__base.html">Zone_Cl_dis_base</a> &amp;&#160;</td>
          <td class="paramname"><em>zcl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatrice.html">Matrice</a> &amp;&#160;</td>
          <td class="paramname"><em>matrice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>inverse_quantitee_entrelacee</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;&#160;</td>
          <td class="paramname"><em>coef_som</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>&lt; RIEN</p>
<p>&lt; On ne traite que les faces internes </p>
</p>

<p>Definition at line <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l02968">2968</a> of file <a class="el" href="AssembleurPP1BUtil_8cpp_source.html">AssembleurPP1BUtil.cpp</a>.</p>

<p>References <a class="el" href="EntreeSortie_8h_source.html#l00032">Cerr</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00939">contribuer_matrice_NeumannP0P1()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00528">contribuer_matriceP0P1()</a>, <a class="el" href="Objet__U_8h_source.html#l00079">Objet_U::dimension</a>, <a class="el" href="Zone__VF_8h_source.html#l00773">Zone_VF::est_une_face_virt_bord()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00046">face_associee</a>, <a class="el" href="Zone__VF_8h_source.html#l00458">Zone_VF::face_voisins()</a>, <a class="el" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>, <a class="el" href="Cond__lim_8h_source.html#l00130">Cond_lim::frontiere_dis()</a>, <a class="el" href="Zone__Cl__dis__base_8cpp_source.html#l00522">Zone_Cl_dis_base::les_conditions_limites()</a>, <a class="el" href="Zone_8h_source.html#l00300">Zone::nb_elem()</a>, <a class="el" href="Zone_8h_source.html#l00319">Zone::nb_elem_tot()</a>, <a class="el" href="Front__VF_8h_source.html#l00066">Front_VF::nb_faces_tot()</a>, <a class="el" href="Zone__VF_8h_source.html#l00527">Zone_VF::nb_faces_tot()</a>, <a class="el" href="Zone_8cpp_source.html#l00586">Zone::nb_som()</a>, <a class="el" href="Zone_8cpp_source.html#l00608">Zone::nb_som_tot()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00081">okface()</a>, <a class="el" href="Zone__VF_8h_source.html#l00512">Zone_VF::premiere_face_int()</a>, <a class="el" href="Cast_8h_source.html#l00059">ref_cast</a>, <a class="el" href="Matrice__Bloc_8cpp_source.html#l00647">Matrice_Bloc::remplir()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00349">remplir_sommets()</a>, <a class="el" href="vect__impl_8h_source.html#l00057">vect_impl::size()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00286">sort()</a>, <a class="el" href="Deriv___8cpp_source.html#l00091">Deriv_::typer()</a>, <a class="el" href="Deriv__Matrice__Base_8h_source.html#l00028">Deriv_Matrice_Base::valeur()</a>, and <a class="el" href="Zone__dis__base_8h_source.html#l00106">Zone_dis_base::zone()</a>.</p>

<p>Referenced by <a class="el" href="Assembleur__P__VEFPreP1B_8cpp_source.html#l00230">Assembleur_P_VEFPreP1B::assembler_mat()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">int</span> dimension=<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>;
  <span class="keyword">const</span> <a class="code" href="classZone__VEF.html" title="class Zone_VEF Classe instanciable qui derive de Zone_VF. Cette classe contient les informations geom...">Zone_VEF</a>&amp; zone_VEF=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a>, z);
  <span class="keyword">const</span> <a class="code" href="classZone.html" title="classe Zone Une Zone est un maillage compose d&#39;un ensemble d&#39;elements geometriques de meme type...">Zone</a>&amp; zone=zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>();
  <span class="keyword">const</span> <a class="code" href="classZone__Cl__VEF.html">Zone_Cl_VEF</a>&amp; zone_Cl_VEF=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classZone__Cl__VEF.html">Zone_Cl_VEF</a>, zcl);
  <span class="keyword">const</span> <a class="code" href="classConds__lim.html">Conds_lim</a>&amp; les_cl = zone_Cl_VEF.<a class="code" href="classZone__Cl__dis__base.html#af75e0ed7786863e4d333bfb29d67c323" title="Renvoie la i-ieme condition aux limites. (version const)">les_conditions_limites</a>();
  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; face_voisins = zone_VEF.<a class="code" href="classZone__VF.html#a49d4322f5585a8fa95748ca785b70702" title="renvoie l&#39;element voisin de numface dans la direction i. i=0 : dans le sens oppose de l&#39;axe orthogona...">face_voisins</a>();
  <span class="keywordtype">int</span> nint = zone_VEF.<a class="code" href="classZone__VF.html#a12869806fa4834aca8f2964e16509dfd" title="une face est interne ssi elle separe deux elements. renvoie le numero de la premiere face interne...">premiere_face_int</a>();
  <span class="keywordtype">int</span> nb_faces = zone_VEF.<a class="code" href="classZone__VF.html#a50fd21c9535680489015a3c8b88c685a" title="renvoie le nombre total de faces. C&#39;est-a-dire faces reelles + faces virtuelles">nb_faces_tot</a>();
  <span class="keywordtype">int</span> nb_elem = zone.<a class="code" href="classZone.html#aa3a33e8b723618b9092460007153e42d" title="Renvoie le nombre total d&#39;elements de la zone.">nb_elem_tot</a>();
  <span class="keywordtype">int</span> elem1, elem2, face, ok;
  <span class="keywordtype">int</span> nnz=0;
  <a class="code" href="classIntLists.html" title="Un tableau de listes de type IntList.">IntLists</a> voisins(nb_elem);
  <a class="code" href="classDoubleLists.html" title="Un tableau de listes de type DoubleList.">DoubleLists</a> coeffs(nb_elem);
  <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> sommets(dimension+2);
  <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> face_opp1(dimension+2);
  <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> face_opp2(dimension+2);
<span class="comment">// Faces de bord :</span>
  <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;les_cl.<a class="code" href="classvect__impl.html#a78155bfbd6b61f4710b9830641ed1694">size</a>(); i++)
    {
      <span class="keyword">const</span> <a class="code" href="classCond__lim.html" title="classe Cond_lim Classe generique servant a representer n&#39;importe quelle classe derivee de la classe C...">Cond_lim</a>&amp; la_cl = les_cl[i];
      <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp; le_bord = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>,la_cl.<a class="code" href="classCond__lim.html#a5b2d24809cee07727006a891d4ce8d22" title="Appel a l&#39;objet sous-jacent Renvoie la frontiere discretisee associee a la condition aux limites...">frontiere_dis</a>());
      <span class="keywordtype">int</span> nb_faces_bord_tot = le_bord.<a class="code" href="classFront__VF.html#aed4006d91bf2ef3af2b9f7933d863a09" title="Nombre de faces reelles et virtuelles du bord.">nb_faces_tot</a>();
      <span class="keywordflow">for</span>(<span class="keywordtype">int</span> ind_face=0; ind_face&lt;nb_faces_bord_tot; ind_face++)
        {
          ok=<a class="code" href="AssembleurPP1BUtil_8cpp.html#a40cf40213663174bb24649e51832bf3e">okface</a>(ind_face, face, la_cl);
          <span class="keywordflow">if</span> (ok==-1) <span class="keywordflow">break</span>;
          elem1=face_voisins(face, 0);
          elem2=face_voisins(face, 1);
          <a class="code" href="AssembleurPP1BUtil_8cpp.html#afd0a249a235b161c5267e7574e199a82">remplir_sommets</a>(zone_VEF, face, elem1, elem2, sommets,
                          face_opp1, face_opp2);
          <a class="code" href="AssembleurPP1BUtil_8cpp.html#acff816d35f8d4ce978f860e0cd958b8a">sort</a>(sommets, face_opp1, face_opp2);
          <span class="keywordflow">if</span>(ok==3)
            {
              <a class="code" href="AssembleurPP1BUtil_8cpp.html#a5e6fc2e2157dce70a345b3d8c1294477">contribuer_matrice_NeumannP0P1</a>(zone_VEF,
                                             inverse_quantitee_entrelacee,
                                             face, elem1, sommets,
                                             face_opp1, coef_som,
                                             voisins, coeffs, nnz);
            }
          <span class="keywordflow">else</span> <span class="keywordflow">if</span>(ok==4)
            {
              ;<span class="comment">//!&lt; RIEN</span>
<span class="comment"></span>            }
          <span class="keywordflow">else</span>
            <a class="code" href="AssembleurPP1BUtil_8cpp.html#ae2056e931f2d24d03da578b6af30cd54">contribuer_matriceP0P1</a>(zone_VEF,
                                   inverse_quantitee_entrelacee,
                                   face, elem1, elem2, sommets,
                                   face_opp1, face_opp2, coef_som,
                                   voisins, coeffs, nnz);
        }
    }
  <a class="code" href="AssembleurPP1BUtil_8cpp.html#a3e374d53ebc7860e1c2f0b7906f2936d">face_associee</a>=-1;
  <span class="keywordflow">for</span>(face=nint; face&lt;nb_faces; face++)
    {
      elem1=face_voisins(face, 0);
      elem2=face_voisins(face, 1);
      <span class="keywordflow">if</span> (!zone_VEF.<a class="code" href="classZone__VF.html#a33909d3880435e82e84639b51482d2c6" title="renvoie 1 si face est une face virtuelle de bord, 0 sinon">est_une_face_virt_bord</a>(face)) <span class="comment">//!&lt; On ne traite que les faces internes</span>
<span class="comment"></span>        {
          <a class="code" href="AssembleurPP1BUtil_8cpp.html#afd0a249a235b161c5267e7574e199a82">remplir_sommets</a>(zone_VEF, face, elem1, elem2, sommets,
                          face_opp1, face_opp2);
          <a class="code" href="AssembleurPP1BUtil_8cpp.html#acff816d35f8d4ce978f860e0cd958b8a">sort</a>(sommets, face_opp1, face_opp2);
          <a class="code" href="AssembleurPP1BUtil_8cpp.html#ae2056e931f2d24d03da578b6af30cd54">contribuer_matriceP0P1</a>(zone_VEF,
                                 inverse_quantitee_entrelacee,
                                 face, elem1, elem2, sommets,
                                 face_opp1, face_opp2, coef_som,
                                 voisins, coeffs, nnz);
        }
    }

  matrice.<a class="code" href="classDeriv__.html#ad1d33400ed15b6ff96579ed82d9e2719" title="Essaie de creer une instance du type &quot;type&quot;. si type n&#39;est pas un type ou type n&#39;est pas instanciab...">typer</a>(<span class="stringliteral">&quot;Matrice_Bloc&quot;</span>);
  <a class="code" href="classMatrice__Bloc.html">Matrice_Bloc</a>&amp; matrice_bloc=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Bloc.html">Matrice_Bloc</a>, matrice.<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>());
  matrice_bloc.<a class="code" href="classMatrice__Bloc.html#a7d624ebd3f141e34502e59f6d1b1d601">remplir</a>(voisins, coeffs, zone.<a class="code" href="classZone.html#a7f249429803b27139a1c54436f6164a5" title="Renvoie le nombre d&#39;elements de la zone.">nb_elem</a>(), zone.<a class="code" href="classZone.html#aa3a33e8b723618b9092460007153e42d" title="Renvoie le nombre total d&#39;elements de la zone.">nb_elem_tot</a>(), zone.<a class="code" href="classZone.html#ad340f571f81fa5c2e028b88c00b5c2ca" title="Renvoie le nombre de sommets de la zone.">nb_som</a>(), zone.<a class="code" href="classZone.html#a01ed67af826d6045ef4eacfb87a663e8" title="Renvoie le nombre total de sommets de la zone. i.e. le nombre de sommets reels et virtuels sur le pro...">nb_som_tot</a>());
  <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Assemblage POP1 OK&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a30b5e404b46e2a239584ee19835c88bf"></a><!-- doxytag: member="AssembleurPP1BUtil.cpp::assemblerP0Pa" ref="a30b5e404b46e2a239584ee19835c88bf" args="(const Zone_dis_base &amp;z, const Zone_Cl_dis_base &amp;zcl, Matrice &amp;matrice, const DoubleTab &amp;inverse_quantitee_entrelacee)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void assemblerP0Pa </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classZone__dis__base.html">Zone_dis_base</a> &amp;&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classZone__Cl__dis__base.html">Zone_Cl_dis_base</a> &amp;&#160;</td>
          <td class="paramname"><em>zcl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatrice.html">Matrice</a> &amp;&#160;</td>
          <td class="paramname"><em>matrice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>inverse_quantitee_entrelacee</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>&lt; RIEN</p>
<p>&lt; On ne traite que les faces internes </p>
</p>

<p>Definition at line <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l02655">2655</a> of file <a class="el" href="AssembleurPP1BUtil_8cpp_source.html">AssembleurPP1BUtil.cpp</a>.</p>

<p>References <a class="el" href="EntreeSortie_8h_source.html#l00032">Cerr</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l01710">contribuer_matrice_NeumannP0Pa()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l01558">contribuer_matriceP0Pa()</a>, <a class="el" href="Objet__U_8h_source.html#l00079">Objet_U::dimension</a>, <a class="el" href="Zone__VF_8h_source.html#l00773">Zone_VF::est_une_face_virt_bord()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00046">face_associee</a>, <a class="el" href="Zone__VF_8h_source.html#l00458">Zone_VF::face_voisins()</a>, <a class="el" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>, <a class="el" href="Cond__lim_8h_source.html#l00130">Cond_lim::frontiere_dis()</a>, <a class="el" href="Zone__Cl__dis__base_8cpp_source.html#l00522">Zone_Cl_dis_base::les_conditions_limites()</a>, <a class="el" href="Zone_8h_source.html#l01258">Zone::nb_aretes()</a>, <a class="el" href="Zone_8h_source.html#l01266">Zone::nb_aretes_tot()</a>, <a class="el" href="Zone_8h_source.html#l00300">Zone::nb_elem()</a>, <a class="el" href="Zone_8h_source.html#l00319">Zone::nb_elem_tot()</a>, <a class="el" href="Front__VF_8h_source.html#l00066">Front_VF::nb_faces_tot()</a>, <a class="el" href="Zone__VF_8h_source.html#l00527">Zone_VF::nb_faces_tot()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00081">okface()</a>, <a class="el" href="Zone__VF_8h_source.html#l00512">Zone_VF::premiere_face_int()</a>, <a class="el" href="Cast_8h_source.html#l00059">ref_cast</a>, <a class="el" href="Matrice__Bloc_8cpp_source.html#l00647">Matrice_Bloc::remplir()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00349">remplir_sommets()</a>, <a class="el" href="vect__impl_8h_source.html#l00057">vect_impl::size()</a>, <a class="el" href="Deriv___8cpp_source.html#l00091">Deriv_::typer()</a>, <a class="el" href="Deriv__Matrice__Base_8h_source.html#l00028">Deriv_Matrice_Base::valeur()</a>, and <a class="el" href="Zone__dis__base_8h_source.html#l00106">Zone_dis_base::zone()</a>.</p>

<p>Referenced by <a class="el" href="Assembleur__P__VEFPreP1B_8cpp_source.html#l00230">Assembleur_P_VEFPreP1B::assembler_mat()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">int</span> dimension=<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>;
  <span class="keyword">const</span> <a class="code" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a>&amp; zone_VEF=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a>, z);
  <span class="keyword">const</span> <a class="code" href="classZone.html" title="classe Zone Une Zone est un maillage compose d&#39;un ensemble d&#39;elements geometriques de meme type...">Zone</a>&amp; zone=zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>();
  <span class="keyword">const</span> <a class="code" href="classZone__Cl__VEF.html">Zone_Cl_VEF</a>&amp; zone_Cl_VEF=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classZone__Cl__VEF.html">Zone_Cl_VEF</a>, zcl);
  <span class="keyword">const</span> <a class="code" href="classConds__lim.html">Conds_lim</a>&amp; les_cl = zone_Cl_VEF.<a class="code" href="classZone__Cl__dis__base.html#af75e0ed7786863e4d333bfb29d67c323" title="Renvoie la i-ieme condition aux limites. (version const)">les_conditions_limites</a>();
  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; face_voisins = zone_VEF.<a class="code" href="classZone__VF.html#a49d4322f5585a8fa95748ca785b70702" title="renvoie l&#39;element voisin de numface dans la direction i. i=0 : dans le sens oppose de l&#39;axe orthogona...">face_voisins</a>();
  <span class="keywordtype">int</span> nint = zone_VEF.<a class="code" href="classZone__VF.html#a12869806fa4834aca8f2964e16509dfd" title="une face est interne ssi elle separe deux elements. renvoie le numero de la premiere face interne...">premiere_face_int</a>();
  <span class="keywordtype">int</span> nb_faces = zone_VEF.<a class="code" href="classZone__VF.html#a50fd21c9535680489015a3c8b88c685a" title="renvoie le nombre total de faces. C&#39;est-a-dire faces reelles + faces virtuelles">nb_faces_tot</a>();
  <span class="keywordtype">int</span> nb_elem = zone.<a class="code" href="classZone.html#aa3a33e8b723618b9092460007153e42d" title="Renvoie le nombre total d&#39;elements de la zone.">nb_elem_tot</a>();
  <span class="keywordtype">int</span> elem1, elem2, face, ok;
  <span class="keywordtype">int</span> nnz=0;
  <a class="code" href="classIntLists.html" title="Un tableau de listes de type IntList.">IntLists</a> voisins(nb_elem);
  <a class="code" href="classDoubleLists.html" title="Un tableau de listes de type DoubleList.">DoubleLists</a> coeffs(nb_elem);
  <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> sommets(dimension+2);
  <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> face_opp1(dimension+2);
  <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> face_opp2(dimension+2);
<span class="comment">// Faces de bord :</span>
  <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;les_cl.<a class="code" href="classvect__impl.html#a78155bfbd6b61f4710b9830641ed1694">size</a>(); i++)
    {
      <span class="keyword">const</span> <a class="code" href="classCond__lim.html" title="classe Cond_lim Classe generique servant a representer n&#39;importe quelle classe derivee de la classe C...">Cond_lim</a>&amp; la_cl = les_cl[i];
      <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp; le_bord = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>,la_cl.<a class="code" href="classCond__lim.html#a5b2d24809cee07727006a891d4ce8d22" title="Appel a l&#39;objet sous-jacent Renvoie la frontiere discretisee associee a la condition aux limites...">frontiere_dis</a>());
      <span class="keywordtype">int</span> nb_faces_bord_tot = le_bord.<a class="code" href="classFront__VF.html#aed4006d91bf2ef3af2b9f7933d863a09" title="Nombre de faces reelles et virtuelles du bord.">nb_faces_tot</a>();
      <span class="keywordflow">for</span>(<span class="keywordtype">int</span> ind_face=0; ind_face&lt;nb_faces_bord_tot; ind_face++)
        {
          ok=<a class="code" href="AssembleurPP1BUtil_8cpp.html#a40cf40213663174bb24649e51832bf3e">okface</a>(ind_face, face, la_cl);
          <span class="keywordflow">if</span> (ok==-1) <span class="keywordflow">break</span>;
          elem1=face_voisins(face, 0);
          elem2=face_voisins(face, 1);
          <a class="code" href="AssembleurPP1BUtil_8cpp.html#afd0a249a235b161c5267e7574e199a82">remplir_sommets</a>(zone_VEF, face, elem1, elem2, sommets,
                          face_opp1, face_opp2);
          <span class="keywordflow">if</span>(ok==3)
            {
              <a class="code" href="AssembleurPP1BUtil_8cpp.html#ae709048ec2f850b47b8601c013ed8550">contribuer_matrice_NeumannP0Pa</a>(zone_VEF,
                                             inverse_quantitee_entrelacee,
                                             face, elem1, sommets,
                                             face_opp1,
                                             voisins, coeffs, nnz);
            }
          <span class="keywordflow">else</span> <span class="keywordflow">if</span>(ok==4)
            {
              ; <span class="comment">//!&lt; RIEN</span>
<span class="comment"></span>            }
          <span class="keywordflow">else</span>
            <a class="code" href="AssembleurPP1BUtil_8cpp.html#a36c4cdf9e6baa421844cf7cffa1396df">contribuer_matriceP0Pa</a>(zone_VEF, inverse_quantitee_entrelacee, face, elem1, elem2, sommets,
                                   face_opp1, face_opp2,
                                   voisins, coeffs, nnz);
        }
    }
  <a class="code" href="AssembleurPP1BUtil_8cpp.html#a3e374d53ebc7860e1c2f0b7906f2936d">face_associee</a>=-1;
  <span class="keywordflow">for</span>(face=nint; face&lt;nb_faces; face++)
    {
      elem1=face_voisins(face, 0);
      elem2=face_voisins(face, 1);
      <span class="keywordflow">if</span> (!zone_VEF.<a class="code" href="classZone__VF.html#a33909d3880435e82e84639b51482d2c6" title="renvoie 1 si face est une face virtuelle de bord, 0 sinon">est_une_face_virt_bord</a>(face)) <span class="comment">//!&lt; On ne traite que les faces internes</span>
<span class="comment"></span>        {
          <a class="code" href="AssembleurPP1BUtil_8cpp.html#afd0a249a235b161c5267e7574e199a82">remplir_sommets</a>(zone_VEF, face, elem1, elem2, sommets,
                          face_opp1, face_opp2);
          <a class="code" href="AssembleurPP1BUtil_8cpp.html#a36c4cdf9e6baa421844cf7cffa1396df">contribuer_matriceP0Pa</a>(zone_VEF,
                                 inverse_quantitee_entrelacee,
                                 face, elem1, elem2, sommets,
                                 face_opp1, face_opp2,
                                 voisins, coeffs, nnz);
        }
    }
  matrice.<a class="code" href="classDeriv__.html#ad1d33400ed15b6ff96579ed82d9e2719" title="Essaie de creer une instance du type &quot;type&quot;. si type n&#39;est pas un type ou type n&#39;est pas instanciab...">typer</a>(<span class="stringliteral">&quot;Matrice_Bloc&quot;</span>);
  <a class="code" href="classMatrice__Bloc.html">Matrice_Bloc</a>&amp; matrice_bloc=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Bloc.html">Matrice_Bloc</a>, matrice.<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>());
  matrice_bloc.<a class="code" href="classMatrice__Bloc.html#a7d624ebd3f141e34502e59f6d1b1d601">remplir</a>(voisins, coeffs, zone.<a class="code" href="classZone.html#a7f249429803b27139a1c54436f6164a5" title="Renvoie le nombre d&#39;elements de la zone.">nb_elem</a>(), zone.<a class="code" href="classZone.html#aa3a33e8b723618b9092460007153e42d" title="Renvoie le nombre total d&#39;elements de la zone.">nb_elem_tot</a>(), zone.<a class="code" href="classZone.html#a3e3b48691911fd85574c7bc10a1a4fb8" title="renvoie le nombre d&#39;aretes reelles.">nb_aretes</a>(), zone.<a class="code" href="classZone.html#a59ae0ababf85ce303a7c6f339430e335" title="renvoie le nombre d&#39;aretes total (reelles+virtuelles).">nb_aretes_tot</a>());
  <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Assemblage P0Pa OK&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a31f132f3fda04d8428de212c63fd902f"></a><!-- doxytag: member="AssembleurPP1BUtil.cpp::assemblerP1P1" ref="a31f132f3fda04d8428de212c63fd902f" args="(const Zone_dis_base &amp;z, const Zone_Cl_dis_base &amp;zcl, Matrice &amp;matrice, const DoubleTab &amp;inverse_quantitee_entrelacee, const ArrOfDouble &amp;coef_som)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void assemblerP1P1 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classZone__dis__base.html">Zone_dis_base</a> &amp;&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classZone__Cl__dis__base.html">Zone_Cl_dis_base</a> &amp;&#160;</td>
          <td class="paramname"><em>zcl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatrice.html">Matrice</a> &amp;&#160;</td>
          <td class="paramname"><em>matrice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>inverse_quantitee_entrelacee</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;&#160;</td>
          <td class="paramname"><em>coef_som</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>&lt; On ne traite que les faces internes </p>
</p>

<p>Definition at line <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l02247">2247</a> of file <a class="el" href="AssembleurPP1BUtil_8cpp_source.html">AssembleurPP1BUtil.cpp</a>.</p>

<p>References <a class="el" href="EntreeSortie_8h_source.html#l00032">Cerr</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l01028">contribuer_matrice_NeumannP1P1()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l01138">contribuer_matrice_SymetrieP1P1()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00638">contribuer_matriceP1P1()</a>, <a class="el" href="Objet__U_8h_source.html#l00079">Objet_U::dimension</a>, <a class="el" href="Zone__VF_8h_source.html#l00773">Zone_VF::est_une_face_virt_bord()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00046">face_associee</a>, <a class="el" href="Zone__VF_8h_source.html#l00458">Zone_VF::face_voisins()</a>, <a class="el" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>, <a class="el" href="Cond__lim_8h_source.html#l00130">Cond_lim::frontiere_dis()</a>, <a class="el" href="Zone__Cl__dis__base_8cpp_source.html#l00522">Zone_Cl_dis_base::les_conditions_limites()</a>, <a class="el" href="Front__VF_8h_source.html#l00066">Front_VF::nb_faces_tot()</a>, <a class="el" href="Zone__VF_8h_source.html#l00527">Zone_VF::nb_faces_tot()</a>, <a class="el" href="Zone_8cpp_source.html#l00586">Zone::nb_som()</a>, <a class="el" href="Zone_8cpp_source.html#l00608">Zone::nb_som_tot()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00081">okface()</a>, <a class="el" href="Zone__VF_8h_source.html#l00512">Zone_VF::premiere_face_int()</a>, <a class="el" href="Cast_8h_source.html#l00059">ref_cast</a>, <a class="el" href="Matrice__Bloc_8cpp_source.html#l00647">Matrice_Bloc::remplir()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00349">remplir_sommets()</a>, <a class="el" href="vect__impl_8h_source.html#l00057">vect_impl::size()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00286">sort()</a>, <a class="el" href="Deriv___8cpp_source.html#l00091">Deriv_::typer()</a>, <a class="el" href="Deriv__Matrice__Base_8h_source.html#l00028">Deriv_Matrice_Base::valeur()</a>, and <a class="el" href="Zone__dis__base_8h_source.html#l00106">Zone_dis_base::zone()</a>.</p>

<p>Referenced by <a class="el" href="Assembleur__P__VEFPreP1B_8cpp_source.html#l00230">Assembleur_P_VEFPreP1B::assembler_mat()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">int</span> dimension=<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>;
  <span class="keyword">const</span> <a class="code" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a>&amp; zone_VEF=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a>, z);
  <span class="keyword">const</span> <a class="code" href="classZone.html" title="classe Zone Une Zone est un maillage compose d&#39;un ensemble d&#39;elements geometriques de meme type...">Zone</a>&amp; zone=zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>();
  <span class="keyword">const</span> <a class="code" href="classZone__Cl__VEF.html">Zone_Cl_VEF</a>&amp; zone_Cl_VEF=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classZone__Cl__VEF.html">Zone_Cl_VEF</a>, zcl);
  <span class="keyword">const</span> <a class="code" href="classConds__lim.html">Conds_lim</a>&amp; les_cl = zone_Cl_VEF.<a class="code" href="classZone__Cl__dis__base.html#af75e0ed7786863e4d333bfb29d67c323" title="Renvoie la i-ieme condition aux limites. (version const)">les_conditions_limites</a>();
  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; face_voisins = zone_VEF.<a class="code" href="classZone__VF.html#a49d4322f5585a8fa95748ca785b70702" title="renvoie l&#39;element voisin de numface dans la direction i. i=0 : dans le sens oppose de l&#39;axe orthogona...">face_voisins</a>();
  <span class="keywordtype">int</span> nint = zone_VEF.<a class="code" href="classZone__VF.html#a12869806fa4834aca8f2964e16509dfd" title="une face est interne ssi elle separe deux elements. renvoie le numero de la premiere face interne...">premiere_face_int</a>();
  <span class="keywordtype">int</span> nb_faces = zone_VEF.<a class="code" href="classZone__VF.html#a50fd21c9535680489015a3c8b88c685a" title="renvoie le nombre total de faces. C&#39;est-a-dire faces reelles + faces virtuelles">nb_faces_tot</a>();
  <span class="keywordtype">int</span> nb_som = zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#a01ed67af826d6045ef4eacfb87a663e8" title="Renvoie le nombre total de sommets de la zone. i.e. le nombre de sommets reels et virtuels sur le pro...">nb_som_tot</a>();
  <span class="keywordtype">int</span> elem1, elem2, face, ok;
  <span class="keywordtype">int</span> nnz=nb_som;
  <a class="code" href="classIntLists.html" title="Un tableau de listes de type IntList.">IntLists</a> voisins(nb_som);
  <a class="code" href="classDoubleLists.html" title="Un tableau de listes de type DoubleList.">DoubleLists</a> coeffs(nb_som);
  <a class="code" href="classDoubleVect.html">DoubleVect</a> diag(nb_som);
  <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> sommets(dimension+2);
  <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> face_opp1(dimension+2);
  <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> face_opp2(dimension+2);
<span class="comment">// Faces de bord :</span>
  <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;les_cl.<a class="code" href="classvect__impl.html#a78155bfbd6b61f4710b9830641ed1694">size</a>(); i++)
    {
      <span class="keyword">const</span> <a class="code" href="classCond__lim.html" title="classe Cond_lim Classe generique servant a representer n&#39;importe quelle classe derivee de la classe C...">Cond_lim</a>&amp; la_cl = les_cl[i];
      <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp; le_bord = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>,la_cl.<a class="code" href="classCond__lim.html#a5b2d24809cee07727006a891d4ce8d22" title="Appel a l&#39;objet sous-jacent Renvoie la frontiere discretisee associee a la condition aux limites...">frontiere_dis</a>());
      <span class="keywordtype">int</span> nb_faces_bord_tot = le_bord.<a class="code" href="classFront__VF.html#aed4006d91bf2ef3af2b9f7933d863a09" title="Nombre de faces reelles et virtuelles du bord.">nb_faces_tot</a>();
      <span class="keywordflow">for</span>(<span class="keywordtype">int</span> ind_face=0; ind_face&lt;nb_faces_bord_tot; ind_face++)
        {
          ok=<a class="code" href="AssembleurPP1BUtil_8cpp.html#a40cf40213663174bb24649e51832bf3e">okface</a>(ind_face, face, la_cl);
          <span class="keywordflow">if</span> (ok==-1) <span class="keywordflow">break</span>;
          elem1=face_voisins(face, 0);
          elem2=face_voisins(face, 1);
          <a class="code" href="AssembleurPP1BUtil_8cpp.html#afd0a249a235b161c5267e7574e199a82">remplir_sommets</a>(zone_VEF, face, elem1, elem2, sommets,
                          face_opp1, face_opp2);
          <a class="code" href="AssembleurPP1BUtil_8cpp.html#acff816d35f8d4ce978f860e0cd958b8a">sort</a>(sommets, face_opp1, face_opp2);
          <span class="keywordflow">if</span>(ok==3)
            {
              <a class="code" href="AssembleurPP1BUtil_8cpp.html#ad9eeb295c62a30fa2305edf29ad7cfd5">contribuer_matrice_NeumannP1P1</a>(zone_VEF,
                                             inverse_quantitee_entrelacee,
                                             face, elem1, sommets,
                                             face_opp1, coef_som,
                                             voisins, coeffs, diag, nnz);
            }
          <span class="keywordflow">else</span> <span class="keywordflow">if</span>(ok==4)
            {
              <a class="code" href="AssembleurPP1BUtil_8cpp.html#a9568a5e0cbf3b9e2b60ad3f3bdac25df">contribuer_matrice_SymetrieP1P1</a>(zone_VEF,
                                              inverse_quantitee_entrelacee,
                                              face, elem1, sommets,
                                              face_opp1, coef_som,
                                              voisins, coeffs, diag, nnz);
            }
          <span class="keywordflow">else</span>
            <a class="code" href="AssembleurPP1BUtil_8cpp.html#ae9226a0247d37eab885c3915814c82c7">contribuer_matriceP1P1</a>(zone_VEF,
                                   inverse_quantitee_entrelacee,
                                   face, elem1, elem2, sommets,
                                   face_opp1, face_opp2, coef_som,
                                   voisins, coeffs, diag, nnz);
        }
    }
  <a class="code" href="AssembleurPP1BUtil_8cpp.html#a3e374d53ebc7860e1c2f0b7906f2936d">face_associee</a>=-1;
  <span class="keywordflow">for</span>(face=nint; face&lt;nb_faces; face++)
    {
      elem1=face_voisins(face, 0);
      elem2=face_voisins(face, 1);
      <span class="keywordflow">if</span> (!zone_VEF.<a class="code" href="classZone__VF.html#a33909d3880435e82e84639b51482d2c6" title="renvoie 1 si face est une face virtuelle de bord, 0 sinon">est_une_face_virt_bord</a>(face)) <span class="comment">//!&lt; On ne traite que les faces internes</span>
<span class="comment"></span>        {
          <a class="code" href="AssembleurPP1BUtil_8cpp.html#afd0a249a235b161c5267e7574e199a82">remplir_sommets</a>(zone_VEF, face, elem1, elem2, sommets,
                          face_opp1, face_opp2);
          <a class="code" href="AssembleurPP1BUtil_8cpp.html#acff816d35f8d4ce978f860e0cd958b8a">sort</a>(sommets, face_opp1, face_opp2);
          <a class="code" href="AssembleurPP1BUtil_8cpp.html#ae9226a0247d37eab885c3915814c82c7">contribuer_matriceP1P1</a>(zone_VEF,
                                 inverse_quantitee_entrelacee,
                                 face, elem1, elem2, sommets,
                                 face_opp1, face_opp2, coef_som,
                                 voisins, coeffs, diag, nnz);
        }
    }

  <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;nb_som; i++)
    <span class="keywordflow">if</span>(diag(i)==0)
      {
<span class="comment">// Cerr &lt;&lt; &quot;On modifie la ligne (sommet) orpheline &quot; &lt;&lt; i &lt;&lt; finl;</span>
        diag(i)=1.;
      }

  matrice.<a class="code" href="classDeriv__.html#ad1d33400ed15b6ff96579ed82d9e2719" title="Essaie de creer une instance du type &quot;type&quot;. si type n&#39;est pas un type ou type n&#39;est pas instanciab...">typer</a>(<span class="stringliteral">&quot;Matrice_Bloc&quot;</span>);
  <a class="code" href="classMatrice__Bloc.html">Matrice_Bloc</a>&amp; matrice_bloc=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Bloc.html">Matrice_Bloc</a>, matrice.<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>());
  matrice_bloc.<a class="code" href="classMatrice__Bloc.html#a7d624ebd3f141e34502e59f6d1b1d601">remplir</a>(voisins, coeffs, diag, zone.<a class="code" href="classZone.html#ad340f571f81fa5c2e028b88c00b5c2ca" title="Renvoie le nombre de sommets de la zone.">nb_som</a>(), zone.<a class="code" href="classZone.html#a01ed67af826d6045ef4eacfb87a663e8" title="Renvoie le nombre total de sommets de la zone. i.e. le nombre de sommets reels et virtuels sur le pro...">nb_som_tot</a>());
  <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Assemblage P1 OK&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a5dcfee4400f896bcbb100259f53a5de1"></a><!-- doxytag: member="AssembleurPP1BUtil.cpp::assemblerP1Pa" ref="a5dcfee4400f896bcbb100259f53a5de1" args="(const Zone_dis_base &amp;z, const Zone_Cl_dis_base &amp;zcl, Matrice &amp;matrice, const DoubleTab &amp;inverse_quantitee_entrelacee, const ArrOfDouble &amp;coef_som)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void assemblerP1Pa </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classZone__dis__base.html">Zone_dis_base</a> &amp;&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classZone__Cl__dis__base.html">Zone_Cl_dis_base</a> &amp;&#160;</td>
          <td class="paramname"><em>zcl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatrice.html">Matrice</a> &amp;&#160;</td>
          <td class="paramname"><em>matrice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>inverse_quantitee_entrelacee</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;&#160;</td>
          <td class="paramname"><em>coef_som</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>&lt; On ne traite que les faces internes </p>
</p>

<p>Definition at line <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l02803">2803</a> of file <a class="el" href="AssembleurPP1BUtil_8cpp_source.html">AssembleurPP1BUtil.cpp</a>.</p>

<p>References <a class="el" href="EntreeSortie_8h_source.html#l00032">Cerr</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l01958">contribuer_matrice_NeumannP1Pa()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l02092">contribuer_matrice_SymetrieP1Pa()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l01819">contribuer_matriceP1Pa()</a>, <a class="el" href="Objet__U_8h_source.html#l00079">Objet_U::dimension</a>, <a class="el" href="Zone__VF_8h_source.html#l00773">Zone_VF::est_une_face_virt_bord()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00046">face_associee</a>, <a class="el" href="Zone__VF_8h_source.html#l00458">Zone_VF::face_voisins()</a>, <a class="el" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>, <a class="el" href="Cond__lim_8h_source.html#l00130">Cond_lim::frontiere_dis()</a>, <a class="el" href="Zone__Cl__dis__base_8cpp_source.html#l00522">Zone_Cl_dis_base::les_conditions_limites()</a>, <a class="el" href="Zone_8h_source.html#l01258">Zone::nb_aretes()</a>, <a class="el" href="Zone_8h_source.html#l01266">Zone::nb_aretes_tot()</a>, <a class="el" href="Front__VF_8h_source.html#l00066">Front_VF::nb_faces_tot()</a>, <a class="el" href="Zone__VF_8h_source.html#l00527">Zone_VF::nb_faces_tot()</a>, <a class="el" href="Zone_8cpp_source.html#l00586">Zone::nb_som()</a>, <a class="el" href="Zone_8cpp_source.html#l00608">Zone::nb_som_tot()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00081">okface()</a>, <a class="el" href="Zone__VF_8h_source.html#l00512">Zone_VF::premiere_face_int()</a>, <a class="el" href="Cast_8h_source.html#l00059">ref_cast</a>, <a class="el" href="Matrice__Bloc_8cpp_source.html#l00647">Matrice_Bloc::remplir()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00349">remplir_sommets()</a>, <a class="el" href="vect__impl_8h_source.html#l00057">vect_impl::size()</a>, <a class="el" href="Deriv___8cpp_source.html#l00091">Deriv_::typer()</a>, <a class="el" href="Deriv__Matrice__Base_8h_source.html#l00028">Deriv_Matrice_Base::valeur()</a>, and <a class="el" href="Zone__dis__base_8h_source.html#l00106">Zone_dis_base::zone()</a>.</p>

<p>Referenced by <a class="el" href="Assembleur__P__VEFPreP1B_8cpp_source.html#l00230">Assembleur_P_VEFPreP1B::assembler_mat()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">int</span> dimension=<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>;
  <span class="keyword">const</span> <a class="code" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a>&amp; zone_VEF=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a>, z);
  <span class="keyword">const</span> <a class="code" href="classZone.html" title="classe Zone Une Zone est un maillage compose d&#39;un ensemble d&#39;elements geometriques de meme type...">Zone</a>&amp; zone=zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>();
  <span class="keyword">const</span> <a class="code" href="classZone__Cl__VEF.html">Zone_Cl_VEF</a>&amp; zone_Cl_VEF=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classZone__Cl__VEF.html">Zone_Cl_VEF</a>, zcl);
  <span class="keyword">const</span> <a class="code" href="classConds__lim.html">Conds_lim</a>&amp; les_cl = zone_Cl_VEF.<a class="code" href="classZone__Cl__dis__base.html#af75e0ed7786863e4d333bfb29d67c323" title="Renvoie la i-ieme condition aux limites. (version const)">les_conditions_limites</a>();
  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; face_voisins = zone_VEF.<a class="code" href="classZone__VF.html#a49d4322f5585a8fa95748ca785b70702" title="renvoie l&#39;element voisin de numface dans la direction i. i=0 : dans le sens oppose de l&#39;axe orthogona...">face_voisins</a>();
  <span class="keywordtype">int</span> nint = zone_VEF.<a class="code" href="classZone__VF.html#a12869806fa4834aca8f2964e16509dfd" title="une face est interne ssi elle separe deux elements. renvoie le numero de la premiere face interne...">premiere_face_int</a>();
  <span class="keywordtype">int</span> nb_faces = zone_VEF.<a class="code" href="classZone__VF.html#a50fd21c9535680489015a3c8b88c685a" title="renvoie le nombre total de faces. C&#39;est-a-dire faces reelles + faces virtuelles">nb_faces_tot</a>();
  <span class="keywordtype">int</span> elem1, elem2, face, ok;
  <span class="keywordtype">int</span> nnz=0;
  <span class="keywordtype">int</span> nb_som = zone.<a class="code" href="classZone.html#a01ed67af826d6045ef4eacfb87a663e8" title="Renvoie le nombre total de sommets de la zone. i.e. le nombre de sommets reels et virtuels sur le pro...">nb_som_tot</a>();
  <a class="code" href="classIntLists.html" title="Un tableau de listes de type IntList.">IntLists</a> voisins(nb_som);
  <a class="code" href="classDoubleLists.html" title="Un tableau de listes de type DoubleList.">DoubleLists</a> coeffs(nb_som);
  <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> sommets(dimension+2);
  <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> face_opp1(dimension+2);
  <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> face_opp2(dimension+2);
<span class="comment">// Faces de bord :</span>
  <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;les_cl.<a class="code" href="classvect__impl.html#a78155bfbd6b61f4710b9830641ed1694">size</a>(); i++)
    {
      <span class="keyword">const</span> <a class="code" href="classCond__lim.html" title="classe Cond_lim Classe generique servant a representer n&#39;importe quelle classe derivee de la classe C...">Cond_lim</a>&amp; la_cl = les_cl[i];
      <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp; le_bord = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>,la_cl.<a class="code" href="classCond__lim.html#a5b2d24809cee07727006a891d4ce8d22" title="Appel a l&#39;objet sous-jacent Renvoie la frontiere discretisee associee a la condition aux limites...">frontiere_dis</a>());
      <span class="keywordtype">int</span> nb_faces_bord_tot = le_bord.<a class="code" href="classFront__VF.html#aed4006d91bf2ef3af2b9f7933d863a09" title="Nombre de faces reelles et virtuelles du bord.">nb_faces_tot</a>();
      <span class="keywordflow">for</span>(<span class="keywordtype">int</span> ind_face=0; ind_face&lt;nb_faces_bord_tot; ind_face++)
        {
          ok=<a class="code" href="AssembleurPP1BUtil_8cpp.html#a40cf40213663174bb24649e51832bf3e">okface</a>(ind_face, face, la_cl);
          <span class="keywordflow">if</span> (ok==-1) <span class="keywordflow">break</span>;
          elem1=face_voisins(face, 0);
          elem2=face_voisins(face, 1);
          <a class="code" href="AssembleurPP1BUtil_8cpp.html#afd0a249a235b161c5267e7574e199a82">remplir_sommets</a>(zone_VEF, face, elem1, elem2, sommets,
                          face_opp1, face_opp2);
          <span class="keywordflow">if</span>(ok==3)
            {
              <a class="code" href="AssembleurPP1BUtil_8cpp.html#a1ee529d67fc174bfe005efe590812122">contribuer_matrice_NeumannP1Pa</a>(zone_VEF,
                                             inverse_quantitee_entrelacee,
                                             face, elem1, sommets,
                                             face_opp1,coef_som,
                                             voisins, coeffs, nnz);
            }
          <span class="keywordflow">else</span> <span class="keywordflow">if</span>(ok==4)
            {
              <a class="code" href="AssembleurPP1BUtil_8cpp.html#ae3056a39c9c01f3a2727f0dbf4b5e331">contribuer_matrice_SymetrieP1Pa</a>(zone_VEF,
                                              inverse_quantitee_entrelacee,
                                              face, elem1, sommets,
                                              face_opp1, coef_som,
                                              voisins, coeffs, nnz);
            }
          <span class="keywordflow">else</span>
            <a class="code" href="AssembleurPP1BUtil_8cpp.html#a0000fbbb1165039c7071352be4a35877">contribuer_matriceP1Pa</a>(zone_VEF,
                                   inverse_quantitee_entrelacee,
                                   face, elem1, elem2, sommets,
                                   face_opp1, face_opp2, coef_som,
                                   voisins, coeffs, nnz);
        }
    }
  <a class="code" href="AssembleurPP1BUtil_8cpp.html#a3e374d53ebc7860e1c2f0b7906f2936d">face_associee</a>=-1;
  <span class="keywordflow">for</span>(face=nint; face&lt;nb_faces; face++)
    {
      elem1=face_voisins(face, 0);
      elem2=face_voisins(face, 1);
      <span class="keywordflow">if</span> (!zone_VEF.<a class="code" href="classZone__VF.html#a33909d3880435e82e84639b51482d2c6" title="renvoie 1 si face est une face virtuelle de bord, 0 sinon">est_une_face_virt_bord</a>(face)) <span class="comment">//!&lt; On ne traite que les faces internes</span>
<span class="comment"></span>        {
          <a class="code" href="AssembleurPP1BUtil_8cpp.html#afd0a249a235b161c5267e7574e199a82">remplir_sommets</a>(zone_VEF, face, elem1, elem2, sommets,
                          face_opp1, face_opp2);
          <a class="code" href="AssembleurPP1BUtil_8cpp.html#a0000fbbb1165039c7071352be4a35877">contribuer_matriceP1Pa</a>(zone_VEF,
                                 inverse_quantitee_entrelacee,
                                 face, elem1, elem2, sommets,
                                 face_opp1, face_opp2, coef_som,
                                 voisins, coeffs, nnz);
        }
    }

  matrice.<a class="code" href="classDeriv__.html#ad1d33400ed15b6ff96579ed82d9e2719" title="Essaie de creer une instance du type &quot;type&quot;. si type n&#39;est pas un type ou type n&#39;est pas instanciab...">typer</a>(<span class="stringliteral">&quot;Matrice_Bloc&quot;</span>);
  <a class="code" href="classMatrice__Bloc.html">Matrice_Bloc</a>&amp; matrice_bloc=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Bloc.html">Matrice_Bloc</a>, matrice.<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>());
  matrice_bloc.<a class="code" href="classMatrice__Bloc.html#a7d624ebd3f141e34502e59f6d1b1d601">remplir</a>(voisins, coeffs, zone.<a class="code" href="classZone.html#ad340f571f81fa5c2e028b88c00b5c2ca" title="Renvoie le nombre de sommets de la zone.">nb_som</a>(), zone.<a class="code" href="classZone.html#a01ed67af826d6045ef4eacfb87a663e8" title="Renvoie le nombre total de sommets de la zone. i.e. le nombre de sommets reels et virtuels sur le pro...">nb_som_tot</a>(), zone.<a class="code" href="classZone.html#a3e3b48691911fd85574c7bc10a1a4fb8" title="renvoie le nombre d&#39;aretes reelles.">nb_aretes</a>(), zone.<a class="code" href="classZone.html#a59ae0ababf85ce303a7c6f339430e335" title="renvoie le nombre d&#39;aretes total (reelles+virtuelles).">nb_aretes_tot</a>());
  <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Assemblage P1Pa OK&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a7840f924363ed7d3fbd50a59d9d990c0"></a><!-- doxytag: member="AssembleurPP1BUtil.cpp::assemblerPaPa" ref="a7840f924363ed7d3fbd50a59d9d990c0" args="(const Zone_dis_base &amp;z, const Zone_Cl_dis_base &amp;zcl, Matrice &amp;matrice, const DoubleTab &amp;inverse_quantitee_entrelacee)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void assemblerPaPa </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classZone__dis__base.html">Zone_dis_base</a> &amp;&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classZone__Cl__dis__base.html">Zone_Cl_dis_base</a> &amp;&#160;</td>
          <td class="paramname"><em>zcl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatrice.html">Matrice</a> &amp;&#160;</td>
          <td class="paramname"><em>matrice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>inverse_quantitee_entrelacee</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>&lt; On ne traite que les faces internes </p>
</p>

<p>Definition at line <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l02477">2477</a> of file <a class="el" href="AssembleurPP1BUtil_8cpp_source.html">AssembleurPP1BUtil.cpp</a>.</p>

<p>References <a class="el" href="EntreeSortie_8h_source.html#l00032">Cerr</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l01241">contribuer_matrice_NeumannPaPa()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l01398">contribuer_matrice_SymetriePaPa()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00748">contribuer_matricePaPa()</a>, <a class="el" href="Objet__U_8h_source.html#l00079">Objet_U::dimension</a>, <a class="el" href="Zone__VF_8h_source.html#l00773">Zone_VF::est_une_face_virt_bord()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00046">face_associee</a>, <a class="el" href="Zone__VF_8h_source.html#l00458">Zone_VF::face_voisins()</a>, <a class="el" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>, <a class="el" href="Cond__lim_8h_source.html#l00130">Cond_lim::frontiere_dis()</a>, <a class="el" href="Zone__Cl__dis__base_8cpp_source.html#l00522">Zone_Cl_dis_base::les_conditions_limites()</a>, <a class="el" href="Zone_8h_source.html#l01258">Zone::nb_aretes()</a>, <a class="el" href="Zone_8h_source.html#l01266">Zone::nb_aretes_tot()</a>, <a class="el" href="Front__VF_8h_source.html#l00066">Front_VF::nb_faces_tot()</a>, <a class="el" href="Zone__VF_8h_source.html#l00527">Zone_VF::nb_faces_tot()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00081">okface()</a>, <a class="el" href="Zone__VF_8h_source.html#l00512">Zone_VF::premiere_face_int()</a>, <a class="el" href="Cast_8h_source.html#l00059">ref_cast</a>, <a class="el" href="Matrice__Bloc_8cpp_source.html#l00647">Matrice_Bloc::remplir()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00349">remplir_sommets()</a>, <a class="el" href="vect__impl_8h_source.html#l00057">vect_impl::size()</a>, <a class="el" href="Deriv___8cpp_source.html#l00091">Deriv_::typer()</a>, <a class="el" href="Deriv__Matrice__Base_8h_source.html#l00028">Deriv_Matrice_Base::valeur()</a>, and <a class="el" href="Zone__dis__base_8h_source.html#l00106">Zone_dis_base::zone()</a>.</p>

<p>Referenced by <a class="el" href="Assembleur__P__VEFPreP1B_8cpp_source.html#l00230">Assembleur_P_VEFPreP1B::assembler_mat()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">int</span> dimension=<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>;
  <span class="keyword">const</span> <a class="code" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a>&amp; zone_VEF=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a>, z);
  <span class="keyword">const</span> <a class="code" href="classZone.html" title="classe Zone Une Zone est un maillage compose d&#39;un ensemble d&#39;elements geometriques de meme type...">Zone</a>&amp; zone=zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>();
  <span class="keyword">const</span> <a class="code" href="classZone__Cl__VEF.html">Zone_Cl_VEF</a>&amp; zone_Cl_VEF=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classZone__Cl__VEF.html">Zone_Cl_VEF</a>, zcl);
  <span class="keyword">const</span> <a class="code" href="classConds__lim.html">Conds_lim</a>&amp; les_cl = zone_Cl_VEF.<a class="code" href="classZone__Cl__dis__base.html#af75e0ed7786863e4d333bfb29d67c323" title="Renvoie la i-ieme condition aux limites. (version const)">les_conditions_limites</a>();
  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; face_voisins = zone_VEF.<a class="code" href="classZone__VF.html#a49d4322f5585a8fa95748ca785b70702" title="renvoie l&#39;element voisin de numface dans la direction i. i=0 : dans le sens oppose de l&#39;axe orthogona...">face_voisins</a>();
  <span class="keywordtype">int</span> nint = zone_VEF.<a class="code" href="classZone__VF.html#a12869806fa4834aca8f2964e16509dfd" title="une face est interne ssi elle separe deux elements. renvoie le numero de la premiere face interne...">premiere_face_int</a>();
  <span class="keywordtype">int</span> nb_faces = zone_VEF.<a class="code" href="classZone__VF.html#a50fd21c9535680489015a3c8b88c685a" title="renvoie le nombre total de faces. C&#39;est-a-dire faces reelles + faces virtuelles">nb_faces_tot</a>();
  <span class="keywordtype">int</span> nb_arete = zone.<a class="code" href="classZone.html#a59ae0ababf85ce303a7c6f339430e335" title="renvoie le nombre d&#39;aretes total (reelles+virtuelles).">nb_aretes_tot</a>();
  <span class="keywordtype">int</span> elem1, elem2, face, ok;
  <span class="keywordtype">int</span> nnz=nb_arete;
  <a class="code" href="classIntLists.html" title="Un tableau de listes de type IntList.">IntLists</a> voisins(nb_arete);
  <a class="code" href="classDoubleLists.html" title="Un tableau de listes de type DoubleList.">DoubleLists</a> coeffs(nb_arete);
  <a class="code" href="classDoubleVect.html">DoubleVect</a> diag(nb_arete);
  <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> sommets(dimension+2);
  <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> face_opp1(dimension+2);
  <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> face_opp2(dimension+2);
<span class="comment">// Faces de bord :</span>
  <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;les_cl.<a class="code" href="classvect__impl.html#a78155bfbd6b61f4710b9830641ed1694">size</a>(); i++)
    {
      <span class="keyword">const</span> <a class="code" href="classCond__lim.html" title="classe Cond_lim Classe generique servant a representer n&#39;importe quelle classe derivee de la classe C...">Cond_lim</a>&amp; la_cl = les_cl[i];
      <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp; le_bord = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>,la_cl.<a class="code" href="classCond__lim.html#a5b2d24809cee07727006a891d4ce8d22" title="Appel a l&#39;objet sous-jacent Renvoie la frontiere discretisee associee a la condition aux limites...">frontiere_dis</a>());
      <span class="keywordtype">int</span> nb_faces_bord_tot = le_bord.<a class="code" href="classFront__VF.html#aed4006d91bf2ef3af2b9f7933d863a09" title="Nombre de faces reelles et virtuelles du bord.">nb_faces_tot</a>();
      <span class="keywordflow">for</span>(<span class="keywordtype">int</span> ind_face=0; ind_face&lt;nb_faces_bord_tot; ind_face++)
        {
          ok=<a class="code" href="AssembleurPP1BUtil_8cpp.html#a40cf40213663174bb24649e51832bf3e">okface</a>(ind_face, face, la_cl);
          <span class="keywordflow">if</span> (ok==-1) <span class="keywordflow">break</span>;
          elem1=face_voisins(face, 0);
          elem2=face_voisins(face, 1);
          <a class="code" href="AssembleurPP1BUtil_8cpp.html#afd0a249a235b161c5267e7574e199a82">remplir_sommets</a>(zone_VEF, face, elem1, elem2, sommets,
                          face_opp1, face_opp2);
          <span class="keywordflow">if</span>(ok==3)
            {
              <a class="code" href="AssembleurPP1BUtil_8cpp.html#a80033228b3ed99e778b70c35cda5e4e6">contribuer_matrice_NeumannPaPa</a>(zone_VEF,
                                             inverse_quantitee_entrelacee,
                                             face, elem1, sommets,
                                             face_opp1,
                                             voisins, coeffs, diag, nnz);
            }
          <span class="keywordflow">else</span> <span class="keywordflow">if</span>(ok==4)
            {
              <a class="code" href="AssembleurPP1BUtil_8cpp.html#ac51ccb6fe9aac0200f1b08da9d81c65b">contribuer_matrice_SymetriePaPa</a>(zone_VEF,
                                              inverse_quantitee_entrelacee,
                                              face, elem1, sommets,
                                              face_opp1,
                                              voisins, coeffs, diag, nnz);
            }
          <span class="keywordflow">else</span>
            <a class="code" href="AssembleurPP1BUtil_8cpp.html#a59992a437cf7e18b4b9ce353d77d0bda">contribuer_matricePaPa</a>(zone_VEF,
                                   inverse_quantitee_entrelacee,
                                   face, elem1, elem2, sommets,
                                   face_opp1, face_opp2,
                                   voisins, coeffs, diag, nnz);
        }
    }
  <a class="code" href="AssembleurPP1BUtil_8cpp.html#a3e374d53ebc7860e1c2f0b7906f2936d">face_associee</a>=-1;
  <span class="keywordflow">for</span>(face=nint; face&lt;nb_faces; face++)
    {
      elem1=face_voisins(face, 0);
      elem2=face_voisins(face, 1);
      <span class="keywordflow">if</span> (!zone_VEF.<a class="code" href="classZone__VF.html#a33909d3880435e82e84639b51482d2c6" title="renvoie 1 si face est une face virtuelle de bord, 0 sinon">est_une_face_virt_bord</a>(face)) <span class="comment">//!&lt; On ne traite que les faces internes</span>
<span class="comment"></span>        {
          <a class="code" href="AssembleurPP1BUtil_8cpp.html#afd0a249a235b161c5267e7574e199a82">remplir_sommets</a>(zone_VEF, face, elem1, elem2, sommets,
                          face_opp1, face_opp2);
          <a class="code" href="AssembleurPP1BUtil_8cpp.html#a59992a437cf7e18b4b9ce353d77d0bda">contribuer_matricePaPa</a>(zone_VEF,
                                 inverse_quantitee_entrelacee,
                                 face, elem1, elem2, sommets,
                                 face_opp1, face_opp2,
                                 voisins, coeffs, diag, nnz);
        }
    }
  <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;nb_arete; i++)
    <span class="keywordflow">if</span>(diag(i)==0)
      {
<span class="comment">// On n&#39;affiche pas car trop sur de gros maillages</span>
<span class="comment">// Cerr &lt;&lt; &quot;On modifie la ligne (arete) orpheline &quot; &lt;&lt; i &lt;&lt; finl;</span>
        diag(i)=1;
      }

  matrice.<a class="code" href="classDeriv__.html#ad1d33400ed15b6ff96579ed82d9e2719" title="Essaie de creer une instance du type &quot;type&quot;. si type n&#39;est pas un type ou type n&#39;est pas instanciab...">typer</a>(<span class="stringliteral">&quot;Matrice_Bloc&quot;</span>);
  <a class="code" href="classMatrice__Bloc.html">Matrice_Bloc</a>&amp; matrice_bloc=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Bloc.html">Matrice_Bloc</a>, matrice.<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>());
  matrice_bloc.<a class="code" href="classMatrice__Bloc.html#a7d624ebd3f141e34502e59f6d1b1d601">remplir</a>(voisins, coeffs, diag, zone.<a class="code" href="classZone.html#a3e3b48691911fd85574c7bc10a1a4fb8" title="renvoie le nombre d&#39;aretes reelles.">nb_aretes</a>(), zone.<a class="code" href="classZone.html#a59ae0ababf85ce303a7c6f339430e335" title="renvoie le nombre d&#39;aretes total (reelles+virtuelles).">nb_aretes_tot</a>());
  <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Assemblage Pa OK&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a556b82e62a565319fb25218f97cfc50c"></a><!-- doxytag: member="AssembleurPP1BUtil.cpp::calculer_grad" ref="a556b82e62a565319fb25218f97cfc50c" args="(const IntTab &amp;face_voisins, int elem1, int elem2, const ArrOfDouble &amp;coef_som, int s, int fop1, int fop2, const DoubleTab &amp;normales, ArrOfDouble &amp;grad)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void calculer_grad </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIntTab.html">IntTab</a> &amp;&#160;</td>
          <td class="paramname"><em>face_voisins</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>elem1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>elem2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;&#160;</td>
          <td class="paramname"><em>coef_som</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fop1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fop2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>normales</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;&#160;</td>
          <td class="paramname"><em>grad</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00429">429</a> of file <a class="el" href="AssembleurPP1BUtil_8cpp_source.html">AssembleurPP1BUtil.cpp</a>.</p>

<p>References <a class="el" href="Objet__U_8h_source.html#l00079">Objet_U::dimension</a>.</p>

<p>Referenced by <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00939">contribuer_matrice_NeumannP0P1()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l01028">contribuer_matrice_NeumannP1P1()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l01958">contribuer_matrice_NeumannP1Pa()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l01138">contribuer_matrice_SymetrieP1P1()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l02092">contribuer_matrice_SymetrieP1Pa()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00528">contribuer_matriceP0P1()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00638">contribuer_matriceP1P1()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l01819">contribuer_matriceP1Pa()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00983">update_matrice_NeumannP0P1()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l01084">update_matrice_NeumannP1P1()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l02025">update_matrice_NeumannP1Pa()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l01191">update_matrice_SymetrieP1P1()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l02157">update_matrice_SymetrieP1Pa()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00600">update_matriceP0P1()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00694">update_matriceP1P1()</a>, and <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l01888">update_matriceP1Pa()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">int</span> dimension=<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>;
  <span class="keywordtype">double</span> signe=1;
  <span class="keywordflow">if</span>(fop1!=-1)
    {
      <span class="keywordflow">if</span>(elem1!=face_voisins(fop1,0))
        signe=-1;
      signe*=coef_som[elem1];
      <span class="keywordflow">for</span>(<span class="keywordtype">int</span> comp=0; comp&lt;dimension; comp++)
        grad[comp]=signe*normales(fop1,comp);
    }
  <span class="keywordflow">else</span>
    grad=0;
  <span class="keywordflow">if</span>((elem2!=-1)&amp;&amp;(fop2!=-1))
    {
      signe=1;
      <span class="keywordflow">if</span>(elem2!=face_voisins(fop2,0))
        signe=-1;
      signe*=coef_som[elem2];
      <span class="keywordflow">for</span>(<span class="keywordtype">int</span> comp=0; comp&lt;dimension; comp++)
        grad[comp]+=signe*normales(fop2,comp);
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="aa26334c33fd016e71cbab82de7ef2fe5"></a><!-- doxytag: member="AssembleurPP1BUtil.cpp::calculer_grad_arete" ref="aa26334c33fd016e71cbab82de7ef2fe5" args="(int face, const IntTab &amp;face_voisins, int i, int j, int elem1, int elem2, int fop1, int fop2, int fop3, int fop4, const DoubleTab &amp;normales, ArrOfDouble &amp;grad)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void calculer_grad_arete </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIntTab.html">IntTab</a> &amp;&#160;</td>
          <td class="paramname"><em>face_voisins</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>elem1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>elem2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fop1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fop2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fop3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fop4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>normales</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;&#160;</td>
          <td class="paramname"><em>grad</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>&lt; une arete de la face</p>
<p>&lt; une arete de elem1 mais pas de face</p>
<p>&lt; une arete de elem2 mais pas de face </p>
</p>

<p>Definition at line <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00462">462</a> of file <a class="el" href="AssembleurPP1BUtil_8cpp_source.html">AssembleurPP1BUtil.cpp</a>.</p>

<p>Referenced by <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l01710">contribuer_matrice_NeumannP0Pa()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l01958">contribuer_matrice_NeumannP1Pa()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l01241">contribuer_matrice_NeumannPaPa()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l02092">contribuer_matrice_SymetrieP1Pa()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l01398">contribuer_matrice_SymetriePaPa()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l01558">contribuer_matriceP0Pa()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l01819">contribuer_matriceP1Pa()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00748">contribuer_matricePaPa()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l01765">update_matrice_NeumannP0Pa()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l02025">update_matrice_NeumannP1Pa()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l01319">update_matrice_NeumannPaPa()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l02157">update_matrice_SymetrieP1Pa()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l01478">update_matrice_SymetriePaPa()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l01634">update_matriceP0Pa()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l01888">update_matriceP1Pa()</a>, and <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00843">update_matricePaPa()</a>.</p>
<div class="fragment"><pre class="fragment">{
  assert(face_voisins(face,0)==elem1);
  <span class="keywordtype">int</span> signe1=1,signe2=1,signe3=1,signe4=1;
  <span class="keywordflow">if</span>((!(fop1==-1) &amp;&amp; !(face_voisins(fop1,0)==elem1)))
    signe1=-1;
  <span class="keywordflow">if</span>(!(fop3==-1) &amp;&amp; !(face_voisins(fop3,0)==elem1))
    signe3=-1;
  <span class="keywordflow">if</span>(elem2!=-1)
    {
      <span class="keywordflow">if</span>((!(fop2==-1) &amp;&amp; !(face_voisins(fop2,0)==elem2)))
        signe2=-1;
      <span class="keywordflow">if</span>(!(fop4==-1) &amp;&amp; !( face_voisins(fop4,0)==elem2))
        signe4=-1;
    }
  <span class="keywordflow">if</span>(j&lt;3) <span class="comment">//!&lt; une arete de la face</span>
<span class="comment"></span>    {
      <span class="keywordflow">if</span>(elem2!=-1)
        {
          <span class="keywordflow">for</span>(<span class="keywordtype">int</span> comp=0; comp&lt;3; comp++)
            grad(comp)=-2./15.*(signe1*normales(fop1,comp)
                                +signe2*normales(fop2,comp)
                                +signe3*normales(fop3,comp)
                                +signe4*normales(fop4,comp));
        }
      <span class="keywordflow">else</span>
        {
          <span class="keywordflow">for</span>(<span class="keywordtype">int</span> comp=0; comp&lt;3; comp++)
            grad(comp)=-2./15.*(signe1*normales(fop1,comp)
                                +signe3*normales(fop3,comp)
                                +normales(face,comp));
        }

    }
  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (j==3) <span class="comment">//!&lt; une arete de elem1 mais pas de face</span>
<span class="comment"></span>    {
      <span class="keywordflow">for</span>(<span class="keywordtype">int</span> comp=0; comp&lt;3; comp++)
        grad(comp)=1./15.*(signe1*normales(fop1,comp)
                           +signe3*normales(fop3,comp));
    }
  <span class="keywordflow">else</span> <span class="comment">//!&lt; une arete de elem2 mais pas de face</span>
<span class="comment"></span>    {
      assert(j==4);
      <span class="keywordflow">for</span>(<span class="keywordtype">int</span> comp=0; comp&lt;3; comp++)
        grad(comp)=1./15.*(signe2*normales(fop2,comp)
                           +signe4*normales(fop4,comp));
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="ae1c00f10faaf4da3ffdea8f881565a1b"></a><!-- doxytag: member="AssembleurPP1BUtil.cpp::chercher_arete" ref="ae1c00f10faaf4da3ffdea8f881565a1b" args="(const Zone_VEF_PreP1b &amp;zone_VEF, int elem, int somi, int somj, const IntTab &amp;elem_aretes, const IntTab &amp;aretes_som)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int chercher_arete </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a> &amp;&#160;</td>
          <td class="paramname"><em>zone_VEF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>somi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>somj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIntTab.html">IntTab</a> &amp;&#160;</td>
          <td class="paramname"><em>elem_aretes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIntTab.html">IntTab</a> &amp;&#160;</td>
          <td class="paramname"><em>aretes_som</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00306">306</a> of file <a class="el" href="AssembleurPP1BUtil_8cpp_source.html">AssembleurPP1BUtil.cpp</a>.</p>

<p>References <a class="el" href="Zone_8cpp_source.html#l00262">Zone::domaine()</a>, <a class="el" href="Zone__VEF__PreP1b_8h_source.html#l00086">Zone_VEF_PreP1b::get_renum_arete_perio()</a>, <a class="el" href="Domaine_8h_source.html#l00613">Domaine::get_renum_som_perio()</a>, and <a class="el" href="Zone__dis__base_8h_source.html#l00106">Zone_dis_base::zone()</a>.</p>

<p>Referenced by <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l01710">contribuer_matrice_NeumannP0Pa()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l01958">contribuer_matrice_NeumannP1Pa()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l01241">contribuer_matrice_NeumannPaPa()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l02092">contribuer_matrice_SymetrieP1Pa()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l01398">contribuer_matrice_SymetriePaPa()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l01558">contribuer_matriceP0Pa()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l01819">contribuer_matriceP1Pa()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00748">contribuer_matricePaPa()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l01765">update_matrice_NeumannP0Pa()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l02025">update_matrice_NeumannP1Pa()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l01319">update_matrice_NeumannPaPa()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l02157">update_matrice_SymetrieP1Pa()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l01478">update_matrice_SymetriePaPa()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l01634">update_matriceP0Pa()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l01888">update_matriceP1Pa()</a>, and <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00843">update_matricePaPa()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; renum_arete_perio=zone_VEF.<a class="code" href="classZone__VEF__PreP1b.html#a43767f8684512d1ee950dc07eea76c5b">get_renum_arete_perio</a>();
  <span class="keyword">const</span> <a class="code" href="classDomaine.html" title="Classe Domaine Un Domaine represente le domaine (spatial) de resolution d&#39;un Probleme. Un Domaine a un Nom, il est constitue d&#39;une ou plusieurs Zone qui peuvent etre eventuellement decoupees en Sous_Zone. Un Domaine porte l&#39;ensemble des sommets utilises par ses Zones. On peut vouloir resoudre des problemes de type different sur plusieurs domaines, geometriquement les domaines sont alors couples par des surfaces qu&#39;on appelle Raccord.">Domaine</a>&amp; dom=zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#a379ad2206b5a13a4f4f3df6d44c7546a" title="Renvoie le domaine dont la zone fait partie. (version const)">domaine</a>();
  <span class="keywordflow">if</span>(somi&gt;somj)
    {
      <span class="keywordtype">int</span> k=somi;
      somi=somj;
      somj=k;
    }
  <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i_arete=0; i_arete&lt;6; i_arete++)
    {
      <span class="keywordtype">int</span> arete=elem_aretes(elem, i_arete);
      <span class="keywordtype">int</span> som1=dom.<a class="code" href="classDomaine.html#a37cc657f1907d53b0d5a573da862af80">get_renum_som_perio</a>(aretes_som(arete,0));
      <span class="keywordtype">int</span> som2=dom.<a class="code" href="classDomaine.html#a37cc657f1907d53b0d5a573da862af80">get_renum_som_perio</a>(aretes_som(arete,1));
      somi=dom.<a class="code" href="classDomaine.html#a37cc657f1907d53b0d5a573da862af80">get_renum_som_perio</a>(somi);
      somj=dom.<a class="code" href="classDomaine.html#a37cc657f1907d53b0d5a573da862af80">get_renum_som_perio</a>(somj);
      <span class="keywordflow">if</span>( (somi==som1)
          &amp;&amp; (somj==som2) )
        <span class="keywordflow">return</span> renum_arete_perio(arete);
      <span class="keywordflow">if</span>( (somi==som2)
          &amp;&amp; (somj==som1) )
        <span class="keywordflow">return</span> renum_arete_perio(arete);
    }
  <span class="keywordflow">return</span> -1;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a5e6fc2e2157dce70a345b3d8c1294477"></a><!-- doxytag: member="AssembleurPP1BUtil.cpp::contribuer_matrice_NeumannP0P1" ref="a5e6fc2e2157dce70a345b3d8c1294477" args="(const Zone_VEF &amp;zone_VEF, const DoubleTab &amp;inverse_quantitee_entrelacee, int face, int elem, ArrOfInt &amp;sommets, ArrOfInt &amp;faces_op1, const ArrOfDouble &amp;coef_som, IntLists &amp;voisins, DoubleLists &amp;coeffs, int &amp;nnz)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void contribuer_matrice_NeumannP0P1 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classZone__VEF.html">Zone_VEF</a> &amp;&#160;</td>
          <td class="paramname"><em>zone_VEF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>inverse_quantitee_entrelacee</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>sommets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>faces_op1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;&#160;</td>
          <td class="paramname"><em>coef_som</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classIntLists.html">IntLists</a> &amp;&#160;</td>
          <td class="paramname"><em>voisins</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDoubleLists.html">DoubleLists</a> &amp;&#160;</td>
          <td class="paramname"><em>coeffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>nnz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00939">939</a> of file <a class="el" href="AssembleurPP1BUtil_8cpp_source.html">AssembleurPP1BUtil.cpp</a>.</p>

<p>References <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00429">calculer_grad()</a>, <a class="el" href="Objet__U_8h_source.html#l00079">Objet_U::dimension</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00518">dotproduct_array_fois_inverse_quantitee_entrelacee()</a>, <a class="el" href="Zone__VEF_8h_source.html#l00145">Zone_VEF::face_normales()</a>, and <a class="el" href="Zone__VF_8h_source.html#l00458">Zone_VF::face_voisins()</a>.</p>

<p>Referenced by <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l02968">assemblerP0P1()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; normales = zone_VEF.<a class="code" href="classZone__VEF.html#a5742d75972e4846bf9fbb6ed5715053e">face_normales</a>();
  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; face_voisins = zone_VEF.<a class="code" href="classZone__VF.html#a49d4322f5585a8fa95748ca785b70702" title="renvoie l&#39;element voisin de numface dans la direction i. i=0 : dans le sens oppose de l&#39;axe orthogona...">face_voisins</a>();

  <span class="keywordtype">int</span> dimension=<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>,
      dplusun=dimension+1;
  <span class="keywordtype">double</span> unsurdim=1./<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>;
  <span class="keywordtype">double</span> psc;
<span class="comment">// double coeff_som=1./(dimension)/(dplusun);</span>
  <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a> gradi(dimension);
  <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a> gradE(dimension);
  <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;dplusun; i++)
    {
      <span class="keywordtype">int</span> si=sommets(i);
      <a class="code" href="AssembleurPP1BUtil_8cpp.html#a556b82e62a565319fb25218f97cfc50c">calculer_grad</a>(face_voisins, elem, -1, coef_som,si, faces_op1(i),
                    -1, normales, gradi);
      <span class="keywordflow">if</span>(faces_op1(i)!=face)
        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> comp=0; comp&lt;dimension; comp++)
          gradi(comp)+=normales(face,comp)*unsurdim;
      <span class="keywordflow">for</span>(<span class="keywordtype">int</span> k=0; k&lt;dimension; k++)
        gradE(k)=normales(face,k);
      psc=<a class="code" href="AssembleurPP1BUtil_8cpp.html#a828055cfc33e4c56db8e2f5beb059862">dotproduct_array_fois_inverse_quantitee_entrelacee</a>(gradi,gradE,
                                                             inverse_quantitee_entrelacee,face);
      <span class="keywordtype">int</span> rang1=voisins[elem].rang(si);
      <span class="keywordflow">if</span>(rang1==-1)
        {
          voisins[elem].add(si);
          coeffs[elem].add(psc);
          nnz++;
        }
      <span class="keywordflow">else</span>
        {
          coeffs[elem][rang1]+=psc;
        }
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="ae709048ec2f850b47b8601c013ed8550"></a><!-- doxytag: member="AssembleurPP1BUtil.cpp::contribuer_matrice_NeumannP0Pa" ref="ae709048ec2f850b47b8601c013ed8550" args="(const Zone_VEF_PreP1b &amp;zone_VEF, const DoubleTab &amp;inverse_quantitee_entrelacee, int face, int elem, ArrOfInt &amp;sommets, ArrOfInt &amp;faces_op1, IntLists &amp;voisins, DoubleLists &amp;coeffs, int &amp;nnz)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void contribuer_matrice_NeumannP0Pa </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a> &amp;&#160;</td>
          <td class="paramname"><em>zone_VEF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>inverse_quantitee_entrelacee</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>sommets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>faces_op1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classIntLists.html">IntLists</a> &amp;&#160;</td>
          <td class="paramname"><em>voisins</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDoubleLists.html">DoubleLists</a> &amp;&#160;</td>
          <td class="paramname"><em>coeffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>nnz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l01710">1710</a> of file <a class="el" href="AssembleurPP1BUtil_8cpp_source.html">AssembleurPP1BUtil.cpp</a>.</p>

<p>References <a class="el" href="Zone_8h_source.html#l01290">Zone::aretes_som()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00462">calculer_grad_arete()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00306">chercher_arete()</a>, <a class="el" href="Zone_8h_source.html#l01282">Zone::elem_aretes()</a>, <a class="el" href="Zone__VEF_8h_source.html#l00145">Zone_VEF::face_normales()</a>, <a class="el" href="Zone__VF_8h_source.html#l00458">Zone_VF::face_voisins()</a>, <a class="el" href="Zone__VEF__PreP1b_8h_source.html#l00090">Zone_VEF_PreP1b::get_ok_arete()</a>, and <a class="el" href="Zone__dis__base_8h_source.html#l00106">Zone_dis_base::zone()</a>.</p>

<p>Referenced by <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l02655">assemblerP0Pa()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; elem_aretes=zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#a1e1e86ef5b088c4d33d42cd38a967b4a" title="renvoie le numero de la jeme arete du ieme element.">elem_aretes</a>();
  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; aretes_som=zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#affa60690e1b372fa4c01d6088267dbe4" title="renvoie le tableau de connectivite aretes/sommets.">aretes_som</a>();
  <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; ok_arete=zone_VEF.<a class="code" href="classZone__VEF__PreP1b.html#a83771f784d487e346b2ef22a389472a2">get_ok_arete</a>();
  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; face_voisins=zone_VEF.<a class="code" href="classZone__VF.html#a49d4322f5585a8fa95748ca785b70702" title="renvoie l&#39;element voisin de numface dans la direction i. i=0 : dans le sens oppose de l&#39;axe orthogona...">face_voisins</a>();
  <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; normales = zone_VEF.<a class="code" href="classZone__VEF.html#a5742d75972e4846bf9fbb6ed5715053e">face_normales</a>();
  <span class="keywordtype">int</span> i, j;
  <span class="keywordtype">double</span> psc;
  <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a> grad1(3);
  <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a> grad2(3);
  <span class="keywordflow">for</span>(i=0; i&lt;3; i++)
    {
      <span class="keywordtype">int</span> si=sommets(i);
      <span class="keywordflow">for</span>(j=i+1; j&lt;4; j++)
        {
          <span class="keywordtype">int</span> sj=sommets(j);
          <span class="keywordtype">int</span> arete1;
          arete1 = <a class="code" href="AssembleurPP1BUtil_8cpp.html#ae1c00f10faaf4da3ffdea8f881565a1b">chercher_arete</a>(zone_VEF,elem, si, sj,
                                  elem_aretes, aretes_som);
          <span class="keywordflow">if</span>(ok_arete(arete1))
            {
              <a class="code" href="AssembleurPP1BUtil_8cpp.html#aa26334c33fd016e71cbab82de7ef2fe5">calculer_grad_arete</a>(face, face_voisins, i, j,
                                  elem, -1,
                                  faces_op1(i), -1,
                                  faces_op1(j), -1,
                                  normales, grad1);
              psc=0;
              <span class="keywordflow">for</span>(<span class="keywordtype">int</span> comp=0; comp&lt;3; comp++)
                psc+=grad1(comp)*normales(face, comp)
                     *(-inverse_quantitee_entrelacee(face,comp));
              <span class="keywordtype">int</span> rang=voisins[elem].rang(arete1);
              <span class="keywordflow">if</span>(rang==-1)
                {
                  voisins[elem].add(arete1);
                  coeffs[elem].add(psc);
                  nnz++;
                }
              <span class="keywordflow">else</span>
                {
                  coeffs[elem][rang]+=psc;
                }
            }
        }
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="ad9eeb295c62a30fa2305edf29ad7cfd5"></a><!-- doxytag: member="AssembleurPP1BUtil.cpp::contribuer_matrice_NeumannP1P1" ref="ad9eeb295c62a30fa2305edf29ad7cfd5" args="(const Zone_VEF &amp;zone_VEF, const DoubleTab &amp;inverse_quantitee_entrelacee, int face, int elem, ArrOfInt &amp;sommets, ArrOfInt &amp;faces_op1, const ArrOfDouble &amp;coef_som, IntLists &amp;voisins, DoubleLists &amp;coeffs, DoubleVect &amp;diag, int &amp;nnz)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void contribuer_matrice_NeumannP1P1 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classZone__VEF.html">Zone_VEF</a> &amp;&#160;</td>
          <td class="paramname"><em>zone_VEF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>inverse_quantitee_entrelacee</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>sommets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>faces_op1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;&#160;</td>
          <td class="paramname"><em>coef_som</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classIntLists.html">IntLists</a> &amp;&#160;</td>
          <td class="paramname"><em>voisins</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDoubleLists.html">DoubleLists</a> &amp;&#160;</td>
          <td class="paramname"><em>coeffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;&#160;</td>
          <td class="paramname"><em>diag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>nnz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l01028">1028</a> of file <a class="el" href="AssembleurPP1BUtil_8cpp_source.html">AssembleurPP1BUtil.cpp</a>.</p>

<p>References <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00429">calculer_grad()</a>, <a class="el" href="Objet__U_8h_source.html#l00079">Objet_U::dimension</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00518">dotproduct_array_fois_inverse_quantitee_entrelacee()</a>, <a class="el" href="Zone__VEF_8h_source.html#l00145">Zone_VEF::face_normales()</a>, and <a class="el" href="Zone__VF_8h_source.html#l00458">Zone_VF::face_voisins()</a>.</p>

<p>Referenced by <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l02247">assemblerP1P1()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; normales = zone_VEF.<a class="code" href="classZone__VEF.html#a5742d75972e4846bf9fbb6ed5715053e">face_normales</a>();
  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; face_voisins = zone_VEF.<a class="code" href="classZone__VF.html#a49d4322f5585a8fa95748ca785b70702" title="renvoie l&#39;element voisin de numface dans la direction i. i=0 : dans le sens oppose de l&#39;axe orthogona...">face_voisins</a>();

  <span class="keywordtype">int</span> dimension=<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>,
      dplusun=dimension+1;
  <span class="keywordtype">double</span> unsurdim=1./<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>;
  <span class="keywordtype">double</span> psc;
<span class="comment">// double coeff_som=1./(dimension)/(dplusun);</span>
<span class="comment">// coeff_som*=coeff_som;</span>
  <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a> gradi(dimension);
  <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a> gradj(dimension);
  <span class="keywordtype">int</span> i,j;
  <span class="keywordflow">for</span>(i=0; i&lt;dplusun; i++)
    {
      <span class="keywordtype">int</span> si=sommets(i);
      <a class="code" href="AssembleurPP1BUtil_8cpp.html#a556b82e62a565319fb25218f97cfc50c">calculer_grad</a>(face_voisins, elem, -1, coef_som, si, faces_op1(i),
                    -1, normales, gradi);
      <span class="keywordflow">if</span>(faces_op1(i)!=face)
        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> comp=0; comp&lt;dimension; comp++)
          gradi(comp)+= normales(face,comp)*unsurdim;
      diag[si]+=<a class="code" href="AssembleurPP1BUtil_8cpp.html#a828055cfc33e4c56db8e2f5beb059862">dotproduct_array_fois_inverse_quantitee_entrelacee</a>(gradi,gradi,
                                                                   inverse_quantitee_entrelacee,face);
      <span class="keywordflow">for</span>(j=i+1; j&lt;dplusun; j++)
        {
          <span class="keywordtype">int</span> sj=sommets(j);
          <a class="code" href="AssembleurPP1BUtil_8cpp.html#a556b82e62a565319fb25218f97cfc50c">calculer_grad</a>(face_voisins, elem, -1,  coef_som,sj, faces_op1(j),
                        -1, normales, gradj);
          <span class="keywordflow">if</span>(faces_op1(j)!=face)
            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> comp=0; comp&lt;dimension; comp++)
              gradj(comp)+= normales(face,comp)*unsurdim;
          psc=<a class="code" href="AssembleurPP1BUtil_8cpp.html#a828055cfc33e4c56db8e2f5beb059862">dotproduct_array_fois_inverse_quantitee_entrelacee</a>(gradi,gradj,inverse_quantitee_entrelacee,face);
          <span class="keywordtype">int</span> rang=voisins[si].rang(sj);
          <span class="keywordflow">if</span>(rang==-1)
            {
              voisins[si].add(sj);
              coeffs[si].add(psc);
              nnz++;
            }
          <span class="keywordflow">else</span>
            {

              coeffs[si][rang]+=psc;
            }
        }
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a1ee529d67fc174bfe005efe590812122"></a><!-- doxytag: member="AssembleurPP1BUtil.cpp::contribuer_matrice_NeumannP1Pa" ref="a1ee529d67fc174bfe005efe590812122" args="(const Zone_VEF_PreP1b &amp;zone_VEF, const DoubleTab &amp;inverse_quantitee_entrelacee, int face, int elem, ArrOfInt &amp;sommets, ArrOfInt &amp;faces_op1, const ArrOfDouble &amp;coef_som, IntLists &amp;voisins, DoubleLists &amp;coeffs, int &amp;nnz)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void contribuer_matrice_NeumannP1Pa </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a> &amp;&#160;</td>
          <td class="paramname"><em>zone_VEF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>inverse_quantitee_entrelacee</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>sommets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>faces_op1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;&#160;</td>
          <td class="paramname"><em>coef_som</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classIntLists.html">IntLists</a> &amp;&#160;</td>
          <td class="paramname"><em>voisins</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDoubleLists.html">DoubleLists</a> &amp;&#160;</td>
          <td class="paramname"><em>coeffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>nnz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l01958">1958</a> of file <a class="el" href="AssembleurPP1BUtil_8cpp_source.html">AssembleurPP1BUtil.cpp</a>.</p>

<p>References <a class="el" href="Zone_8h_source.html#l01290">Zone::aretes_som()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00429">calculer_grad()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00462">calculer_grad_arete()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00306">chercher_arete()</a>, <a class="el" href="Objet__U_8h_source.html#l00079">Objet_U::dimension</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00518">dotproduct_array_fois_inverse_quantitee_entrelacee()</a>, <a class="el" href="Zone_8h_source.html#l01282">Zone::elem_aretes()</a>, <a class="el" href="Zone__VEF_8h_source.html#l00145">Zone_VEF::face_normales()</a>, <a class="el" href="Zone__VF_8h_source.html#l00458">Zone_VF::face_voisins()</a>, <a class="el" href="Zone__VEF__PreP1b_8h_source.html#l00090">Zone_VEF_PreP1b::get_ok_arete()</a>, and <a class="el" href="Zone__dis__base_8h_source.html#l00106">Zone_dis_base::zone()</a>.</p>

<p>Referenced by <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l02803">assemblerP1Pa()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">int</span> dimension=<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>;
<span class="comment">// dplusun=dimension+1;</span>
<span class="comment">// double coeff_som=1./(dimension)/(dplusun);</span>
  <span class="keywordtype">double</span> unsurdim=1./<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>;
  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; elem_aretes=zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#a1e1e86ef5b088c4d33d42cd38a967b4a" title="renvoie le numero de la jeme arete du ieme element.">elem_aretes</a>();
  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; aretes_som=zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#affa60690e1b372fa4c01d6088267dbe4" title="renvoie le tableau de connectivite aretes/sommets.">aretes_som</a>();
  <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; ok_arete=zone_VEF.<a class="code" href="classZone__VEF__PreP1b.html#a83771f784d487e346b2ef22a389472a2">get_ok_arete</a>();
  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; face_voisins=zone_VEF.<a class="code" href="classZone__VF.html#a49d4322f5585a8fa95748ca785b70702" title="renvoie l&#39;element voisin de numface dans la direction i. i=0 : dans le sens oppose de l&#39;axe orthogona...">face_voisins</a>();
  <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; normales = zone_VEF.<a class="code" href="classZone__VEF.html#a5742d75972e4846bf9fbb6ed5715053e">face_normales</a>();
  <span class="keywordtype">int</span> i, j, k;
  <span class="keywordtype">double</span> psc;
  <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a> grad1(3);
  <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a> grad2(3);
  <span class="keywordflow">for</span>(i=0; i&lt;3; i++)
    {
      <span class="keywordtype">int</span> si=sommets(i);
      <span class="keywordflow">for</span>(j=i+1; j&lt;4; j++)
        {
          <span class="keywordtype">int</span> sj=sommets(j);
          <span class="keywordtype">int</span> arete1;
          arete1 = <a class="code" href="AssembleurPP1BUtil_8cpp.html#ae1c00f10faaf4da3ffdea8f881565a1b">chercher_arete</a>(zone_VEF,elem, si, sj,
                                  elem_aretes, aretes_som);
          <span class="keywordflow">if</span>(ok_arete(arete1))
            {
              <a class="code" href="AssembleurPP1BUtil_8cpp.html#aa26334c33fd016e71cbab82de7ef2fe5">calculer_grad_arete</a>(face, face_voisins, i, j,
                                  elem, -1,
                                  faces_op1(i), -1,
                                  faces_op1(j), -1,
                                  normales, grad1);
              <span class="keywordflow">for</span>(k=0; k&lt;4; k++)
                {
                  <span class="keywordtype">int</span> sk=sommets(k);
                  <a class="code" href="AssembleurPP1BUtil_8cpp.html#a556b82e62a565319fb25218f97cfc50c">calculer_grad</a>(face_voisins, elem, -1, coef_som, sk,
                                faces_op1(k), -1,
                                normales, grad2);
                  <span class="keywordflow">if</span>(faces_op1(k)!=face)
                    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> comp=0; comp&lt;dimension; comp++)
                      grad2(comp)+= normales(face,comp)*unsurdim;
                  psc=-<a class="code" href="AssembleurPP1BUtil_8cpp.html#a828055cfc33e4c56db8e2f5beb059862">dotproduct_array_fois_inverse_quantitee_entrelacee</a>(grad1,grad2,
                                                                          inverse_quantitee_entrelacee,face);
                  <span class="keywordtype">int</span> rang1=voisins[sk].rang(arete1);
                  <span class="keywordflow">if</span>(rang1==-1)
                    {
                      voisins[sk].add(arete1);
                      coeffs[sk].add(psc);
                      nnz++;
                    }
                  <span class="keywordflow">else</span>
                    {
                      coeffs[sk][rang1]+=psc;
                    }
                }
            }
        }
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a80033228b3ed99e778b70c35cda5e4e6"></a><!-- doxytag: member="AssembleurPP1BUtil.cpp::contribuer_matrice_NeumannPaPa" ref="a80033228b3ed99e778b70c35cda5e4e6" args="(const Zone_VEF_PreP1b &amp;zone_VEF, const DoubleTab &amp;inverse_quantitee_entrelacee, int face, int elem, ArrOfInt &amp;sommets, ArrOfInt &amp;faces_op1, IntLists &amp;voisins, DoubleLists &amp;coeffs, DoubleVect &amp;diag, int &amp;nnz)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void contribuer_matrice_NeumannPaPa </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a> &amp;&#160;</td>
          <td class="paramname"><em>zone_VEF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>inverse_quantitee_entrelacee</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>sommets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>faces_op1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classIntLists.html">IntLists</a> &amp;&#160;</td>
          <td class="paramname"><em>voisins</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDoubleLists.html">DoubleLists</a> &amp;&#160;</td>
          <td class="paramname"><em>coeffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;&#160;</td>
          <td class="paramname"><em>diag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>nnz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l01241">1241</a> of file <a class="el" href="AssembleurPP1BUtil_8cpp_source.html">AssembleurPP1BUtil.cpp</a>.</p>

<p>References <a class="el" href="Zone_8h_source.html#l01290">Zone::aretes_som()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00462">calculer_grad_arete()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00306">chercher_arete()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00518">dotproduct_array_fois_inverse_quantitee_entrelacee()</a>, <a class="el" href="Zone_8h_source.html#l01282">Zone::elem_aretes()</a>, <a class="el" href="Zone__VEF_8h_source.html#l00145">Zone_VEF::face_normales()</a>, <a class="el" href="Zone__VF_8h_source.html#l00458">Zone_VF::face_voisins()</a>, <a class="el" href="Zone__VEF__PreP1b_8h_source.html#l00090">Zone_VEF_PreP1b::get_ok_arete()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00335">swap()</a>, and <a class="el" href="Zone__dis__base_8h_source.html#l00106">Zone_dis_base::zone()</a>.</p>

<p>Referenced by <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l02477">assemblerPaPa()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; elem_aretes=zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#a1e1e86ef5b088c4d33d42cd38a967b4a" title="renvoie le numero de la jeme arete du ieme element.">elem_aretes</a>();
  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; aretes_som=zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#affa60690e1b372fa4c01d6088267dbe4" title="renvoie le tableau de connectivite aretes/sommets.">aretes_som</a>();
  <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; ok_arete=zone_VEF.<a class="code" href="classZone__VEF__PreP1b.html#a83771f784d487e346b2ef22a389472a2">get_ok_arete</a>();
  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; face_voisins=zone_VEF.<a class="code" href="classZone__VF.html#a49d4322f5585a8fa95748ca785b70702" title="renvoie l&#39;element voisin de numface dans la direction i. i=0 : dans le sens oppose de l&#39;axe orthogona...">face_voisins</a>();
  <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; normales = zone_VEF.<a class="code" href="classZone__VEF.html#a5742d75972e4846bf9fbb6ed5715053e">face_normales</a>();
  <span class="keywordtype">int</span> i, j, k, l;
  <span class="keywordtype">double</span> psc;
  <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a> grad1(3);
  <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a> grad2(3);
  <span class="keywordflow">for</span>(i=0; i&lt;3; i++)
    {
      <span class="keywordtype">int</span> si=sommets(i);
      <span class="keywordflow">for</span>(j=i+1; j&lt;4; j++)
        {
          <span class="keywordtype">int</span> sj=sommets(j);
          <span class="keywordtype">int</span> arete1;
          arete1 = <a class="code" href="AssembleurPP1BUtil_8cpp.html#ae1c00f10faaf4da3ffdea8f881565a1b">chercher_arete</a>(zone_VEF,elem, si, sj,
                                  elem_aretes, aretes_som);
          <span class="keywordflow">if</span>(ok_arete(arete1))
            {
              <a class="code" href="AssembleurPP1BUtil_8cpp.html#aa26334c33fd016e71cbab82de7ef2fe5">calculer_grad_arete</a>(face, face_voisins, i, j,
                                  elem, -1,
                                  faces_op1(i), -1,
                                  faces_op1(j), -1,
                                  normales, grad1);
              diag[arete1]+=<a class="code" href="AssembleurPP1BUtil_8cpp.html#a828055cfc33e4c56db8e2f5beb059862">dotproduct_array_fois_inverse_quantitee_entrelacee</a>(grad1,grad1,
                                                                               inverse_quantitee_entrelacee,face);
              <span class="keywordtype">int</span> jj=j;
              <span class="keywordflow">for</span>(k=i; k&lt;3; k++)
                {
                  <span class="keywordtype">int</span> sk=sommets(k);
                  <span class="keywordflow">for</span>(l=jj+1; l&lt;4; l++)
                    {
                      <span class="keywordtype">int</span> sl=sommets(l);
                      <span class="keywordtype">int</span> arete2= <a class="code" href="AssembleurPP1BUtil_8cpp.html#ae1c00f10faaf4da3ffdea8f881565a1b">chercher_arete</a>(zone_VEF,elem, sl, sk,
                                                 elem_aretes,
                                                 aretes_som);
                      assert(arete2!=-1);
                      <span class="keywordflow">if</span>(ok_arete(arete2))
                        {
                          <a class="code" href="AssembleurPP1BUtil_8cpp.html#aa26334c33fd016e71cbab82de7ef2fe5">calculer_grad_arete</a>(face, face_voisins, k, l,
                                              elem, -1,
                                              faces_op1(k), -1,
                                              faces_op1(l), -1,
                                              normales, grad2);
                          psc=<a class="code" href="AssembleurPP1BUtil_8cpp.html#a828055cfc33e4c56db8e2f5beb059862">dotproduct_array_fois_inverse_quantitee_entrelacee</a>(grad1,grad2,
                                                                                 inverse_quantitee_entrelacee,face);
                          <span class="keywordtype">int</span> tmp=arete1;
                          <span class="keywordflow">if</span>(arete1&gt;arete2) <a class="code" href="AssembleurPP1BUtil_8cpp.html#a3117b050530c46b4a15b6ab9ce6d0b41">swap</a>(arete1, arete2);
                          <span class="keywordtype">int</span> rang=voisins[arete1].rang(arete2);
                          <span class="keywordflow">if</span>(rang==-1)
                            {
                              voisins[arete1].add(arete2);
                              coeffs[arete1].add(psc);
                              nnz++;
                            }
                          <span class="keywordflow">else</span>
                            {
                              coeffs[arete1][rang]+=psc;
                            }
                          arete1=tmp;
                        }
                    }
                  jj=k+1;
                }
            }
        }
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a9568a5e0cbf3b9e2b60ad3f3bdac25df"></a><!-- doxytag: member="AssembleurPP1BUtil.cpp::contribuer_matrice_SymetrieP1P1" ref="a9568a5e0cbf3b9e2b60ad3f3bdac25df" args="(const Zone_VEF &amp;zone_VEF, const DoubleTab &amp;inverse_quantitee_entrelacee, int face, int elem, ArrOfInt &amp;sommets, ArrOfInt &amp;faces_op1, const ArrOfDouble &amp;coef_som, IntLists &amp;voisins, DoubleLists &amp;coeffs, DoubleVect &amp;diag, int &amp;nnz)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void contribuer_matrice_SymetrieP1P1 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classZone__VEF.html">Zone_VEF</a> &amp;&#160;</td>
          <td class="paramname"><em>zone_VEF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>inverse_quantitee_entrelacee</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>sommets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>faces_op1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;&#160;</td>
          <td class="paramname"><em>coef_som</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classIntLists.html">IntLists</a> &amp;&#160;</td>
          <td class="paramname"><em>voisins</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDoubleLists.html">DoubleLists</a> &amp;&#160;</td>
          <td class="paramname"><em>coeffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;&#160;</td>
          <td class="paramname"><em>diag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>nnz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l01138">1138</a> of file <a class="el" href="AssembleurPP1BUtil_8cpp_source.html">AssembleurPP1BUtil.cpp</a>.</p>

<p>References <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00429">calculer_grad()</a>, <a class="el" href="Objet__U_8h_source.html#l00079">Objet_U::dimension</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00518">dotproduct_array_fois_inverse_quantitee_entrelacee()</a>, <a class="el" href="Zone__VEF_8h_source.html#l00145">Zone_VEF::face_normales()</a>, <a class="el" href="Zone__VF_8h_source.html#l00458">Zone_VF::face_voisins()</a>, and <a class="el" href="Champ__Generique__Transformation_8cpp_source.html#l00456">projette()</a>.</p>

<p>Referenced by <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l02247">assemblerP1P1()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; normales = zone_VEF.<a class="code" href="classZone__VEF.html#a5742d75972e4846bf9fbb6ed5715053e">face_normales</a>();
  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; face_voisins = zone_VEF.<a class="code" href="classZone__VF.html#a49d4322f5585a8fa95748ca785b70702" title="renvoie l&#39;element voisin de numface dans la direction i. i=0 : dans le sens oppose de l&#39;axe orthogona...">face_voisins</a>();

  <span class="keywordtype">int</span> dimension=<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>,
      dplusun=dimension+1;

  <span class="keywordtype">double</span> psc;
<span class="comment">// double coeff_som=1./(dimension)/(dplusun);</span>
<span class="comment">// coeff_som*=coeff_som;</span>
  <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a> gradi(dimension);
  <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a> gradj(dimension);
  <span class="keywordtype">int</span> i,j;
  <span class="keywordflow">for</span>(i=0; i&lt;dplusun; i++)
    {
      <span class="keywordtype">int</span> si=sommets(i);
      <a class="code" href="AssembleurPP1BUtil_8cpp.html#a556b82e62a565319fb25218f97cfc50c">calculer_grad</a>(face_voisins, elem, -1, coef_som, si, faces_op1(i),
                    -1, normales, gradi);
      <a class="code" href="Champ__Generique__Transformation_8cpp.html#a0705a900f8a8003047df2f59d6cd4bae">projette</a>(gradi, face, normales);
      diag[si]+=<a class="code" href="AssembleurPP1BUtil_8cpp.html#a828055cfc33e4c56db8e2f5beb059862">dotproduct_array_fois_inverse_quantitee_entrelacee</a>(gradi,gradi,
                                                                   inverse_quantitee_entrelacee,face);
      <span class="keywordflow">for</span>(j=i+1; j&lt;dplusun; j++)
        {
          <span class="keywordtype">int</span> sj=sommets(j);
          <a class="code" href="AssembleurPP1BUtil_8cpp.html#a556b82e62a565319fb25218f97cfc50c">calculer_grad</a>(face_voisins, elem,  -1, coef_som, sj, faces_op1(j),
                        -1, normales, gradj);
          <a class="code" href="Champ__Generique__Transformation_8cpp.html#a0705a900f8a8003047df2f59d6cd4bae">projette</a>(gradj, face, normales);
          psc=<a class="code" href="AssembleurPP1BUtil_8cpp.html#a828055cfc33e4c56db8e2f5beb059862">dotproduct_array_fois_inverse_quantitee_entrelacee</a>(gradi,gradj,
                                                                 inverse_quantitee_entrelacee,face);
          <span class="keywordtype">int</span> rang=voisins[si].rang(sj);
          <span class="keywordflow">if</span>(rang==-1)
            {
              voisins[si].add(sj);
              coeffs[si].add(psc);
              nnz++;
            }
          <span class="keywordflow">else</span>
            {

              coeffs[si][rang]+=psc;
            }
        }
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="ae3056a39c9c01f3a2727f0dbf4b5e331"></a><!-- doxytag: member="AssembleurPP1BUtil.cpp::contribuer_matrice_SymetrieP1Pa" ref="ae3056a39c9c01f3a2727f0dbf4b5e331" args="(const Zone_VEF_PreP1b &amp;zone_VEF, const DoubleTab &amp;inverse_quantitee_entrelacee, int face, int elem, ArrOfInt &amp;sommets, ArrOfInt &amp;faces_op1, const ArrOfDouble &amp;coef_som, IntLists &amp;voisins, DoubleLists &amp;coeffs, int &amp;nnz)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void contribuer_matrice_SymetrieP1Pa </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a> &amp;&#160;</td>
          <td class="paramname"><em>zone_VEF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>inverse_quantitee_entrelacee</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>sommets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>faces_op1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;&#160;</td>
          <td class="paramname"><em>coef_som</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classIntLists.html">IntLists</a> &amp;&#160;</td>
          <td class="paramname"><em>voisins</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDoubleLists.html">DoubleLists</a> &amp;&#160;</td>
          <td class="paramname"><em>coeffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>nnz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l02092">2092</a> of file <a class="el" href="AssembleurPP1BUtil_8cpp_source.html">AssembleurPP1BUtil.cpp</a>.</p>

<p>References <a class="el" href="Zone_8h_source.html#l01290">Zone::aretes_som()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00429">calculer_grad()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00462">calculer_grad_arete()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00306">chercher_arete()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00518">dotproduct_array_fois_inverse_quantitee_entrelacee()</a>, <a class="el" href="Zone_8h_source.html#l01282">Zone::elem_aretes()</a>, <a class="el" href="Zone__VEF_8h_source.html#l00145">Zone_VEF::face_normales()</a>, <a class="el" href="Zone__VF_8h_source.html#l00458">Zone_VF::face_voisins()</a>, <a class="el" href="Zone__VEF__PreP1b_8h_source.html#l00090">Zone_VEF_PreP1b::get_ok_arete()</a>, <a class="el" href="Champ__Generique__Transformation_8cpp_source.html#l00456">projette()</a>, and <a class="el" href="Zone__dis__base_8h_source.html#l00106">Zone_dis_base::zone()</a>.</p>

<p>Referenced by <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l02803">assemblerP1Pa()</a>.</p>
<div class="fragment"><pre class="fragment">{
<span class="comment">// int dimension=Objet_U::dimension,</span>
<span class="comment">// dplusun=dimension+1;</span>
<span class="comment">// double coeff_som=1./(dimension)/(dplusun);</span>
  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; elem_aretes=zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#a1e1e86ef5b088c4d33d42cd38a967b4a" title="renvoie le numero de la jeme arete du ieme element.">elem_aretes</a>();
  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; aretes_som=zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#affa60690e1b372fa4c01d6088267dbe4" title="renvoie le tableau de connectivite aretes/sommets.">aretes_som</a>();
  <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; ok_arete=zone_VEF.<a class="code" href="classZone__VEF__PreP1b.html#a83771f784d487e346b2ef22a389472a2">get_ok_arete</a>();
  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; face_voisins=zone_VEF.<a class="code" href="classZone__VF.html#a49d4322f5585a8fa95748ca785b70702" title="renvoie l&#39;element voisin de numface dans la direction i. i=0 : dans le sens oppose de l&#39;axe orthogona...">face_voisins</a>();
  <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; normales = zone_VEF.<a class="code" href="classZone__VEF.html#a5742d75972e4846bf9fbb6ed5715053e">face_normales</a>();
  <span class="keywordtype">int</span> i, j, k;
  <span class="keywordtype">double</span> psc;
  <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a> grad1(3);
  <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a> grad2(3);
  <span class="keywordflow">for</span>(i=0; i&lt;3; i++)
    {
      <span class="keywordtype">int</span> si=sommets(i);
      <span class="keywordflow">for</span>(j=i+1; j&lt;4; j++)
        {
          <span class="keywordtype">int</span> sj=sommets(j);
          <span class="keywordtype">int</span> arete1;
          arete1 = <a class="code" href="AssembleurPP1BUtil_8cpp.html#ae1c00f10faaf4da3ffdea8f881565a1b">chercher_arete</a>(zone_VEF,elem, si, sj,
                                  elem_aretes, aretes_som);
          <span class="keywordflow">if</span>(ok_arete(arete1))
            {
              <a class="code" href="AssembleurPP1BUtil_8cpp.html#aa26334c33fd016e71cbab82de7ef2fe5">calculer_grad_arete</a>(face, face_voisins, i, j,
                                  elem, -1,
                                  faces_op1(i), -1,
                                  faces_op1(j), -1,
                                  normales, grad1);
              <a class="code" href="Champ__Generique__Transformation_8cpp.html#a0705a900f8a8003047df2f59d6cd4bae">projette</a>(grad1, face, normales);
              <span class="keywordflow">for</span>(k=0; k&lt;4; k++)
                {
                  <span class="keywordtype">int</span> sk=sommets(k);
                  <a class="code" href="AssembleurPP1BUtil_8cpp.html#a556b82e62a565319fb25218f97cfc50c">calculer_grad</a>(face_voisins, elem, -1, coef_som, sk,
                                faces_op1(k), -1,
                                normales, grad2);
                  <a class="code" href="Champ__Generique__Transformation_8cpp.html#a0705a900f8a8003047df2f59d6cd4bae">projette</a>(grad2, face, normales);
                  psc=-<a class="code" href="AssembleurPP1BUtil_8cpp.html#a828055cfc33e4c56db8e2f5beb059862">dotproduct_array_fois_inverse_quantitee_entrelacee</a>(grad1,grad2,
                                                                          inverse_quantitee_entrelacee,face);
                  <span class="keywordtype">int</span> rang1=voisins[sk].rang(arete1);
                  <span class="keywordflow">if</span>(rang1==-1)
                    {
                      voisins[sk].add(arete1);
                      coeffs[sk].add(psc);
                      nnz++;
                    }
                  <span class="keywordflow">else</span>
                    {
                      coeffs[sk][rang1]+=psc;
                    }
                }
            }
        }
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="ac51ccb6fe9aac0200f1b08da9d81c65b"></a><!-- doxytag: member="AssembleurPP1BUtil.cpp::contribuer_matrice_SymetriePaPa" ref="ac51ccb6fe9aac0200f1b08da9d81c65b" args="(const Zone_VEF_PreP1b &amp;zone_VEF, const DoubleTab &amp;inverse_quantitee_entrelacee, int face, int elem, ArrOfInt &amp;sommets, ArrOfInt &amp;faces_op1, IntLists &amp;voisins, DoubleLists &amp;coeffs, DoubleVect &amp;diag, int &amp;nnz)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void contribuer_matrice_SymetriePaPa </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a> &amp;&#160;</td>
          <td class="paramname"><em>zone_VEF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>inverse_quantitee_entrelacee</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>sommets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>faces_op1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classIntLists.html">IntLists</a> &amp;&#160;</td>
          <td class="paramname"><em>voisins</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDoubleLists.html">DoubleLists</a> &amp;&#160;</td>
          <td class="paramname"><em>coeffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;&#160;</td>
          <td class="paramname"><em>diag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>nnz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l01398">1398</a> of file <a class="el" href="AssembleurPP1BUtil_8cpp_source.html">AssembleurPP1BUtil.cpp</a>.</p>

<p>References <a class="el" href="Zone_8h_source.html#l01290">Zone::aretes_som()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00462">calculer_grad_arete()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00306">chercher_arete()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00518">dotproduct_array_fois_inverse_quantitee_entrelacee()</a>, <a class="el" href="Zone_8h_source.html#l01282">Zone::elem_aretes()</a>, <a class="el" href="Zone__VEF_8h_source.html#l00145">Zone_VEF::face_normales()</a>, <a class="el" href="Zone__VF_8h_source.html#l00458">Zone_VF::face_voisins()</a>, <a class="el" href="Zone__VEF__PreP1b_8h_source.html#l00090">Zone_VEF_PreP1b::get_ok_arete()</a>, <a class="el" href="Champ__Generique__Transformation_8cpp_source.html#l00456">projette()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00335">swap()</a>, and <a class="el" href="Zone__dis__base_8h_source.html#l00106">Zone_dis_base::zone()</a>.</p>

<p>Referenced by <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l02477">assemblerPaPa()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; elem_aretes=zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#a1e1e86ef5b088c4d33d42cd38a967b4a" title="renvoie le numero de la jeme arete du ieme element.">elem_aretes</a>();
  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; aretes_som=zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#affa60690e1b372fa4c01d6088267dbe4" title="renvoie le tableau de connectivite aretes/sommets.">aretes_som</a>();
  <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; ok_arete=zone_VEF.<a class="code" href="classZone__VEF__PreP1b.html#a83771f784d487e346b2ef22a389472a2">get_ok_arete</a>();
  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; face_voisins=zone_VEF.<a class="code" href="classZone__VF.html#a49d4322f5585a8fa95748ca785b70702" title="renvoie l&#39;element voisin de numface dans la direction i. i=0 : dans le sens oppose de l&#39;axe orthogona...">face_voisins</a>();
  <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; normales = zone_VEF.<a class="code" href="classZone__VEF.html#a5742d75972e4846bf9fbb6ed5715053e">face_normales</a>();
  <span class="keywordtype">int</span> i, j, k, l;
  <span class="keywordtype">double</span> psc;
  <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a> grad1(3);
  <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a> grad2(3);
  <span class="keywordflow">for</span>(i=0; i&lt;3; i++)
    {
      <span class="keywordtype">int</span> si=sommets(i);
      <span class="keywordflow">for</span>(j=i+1; j&lt;4; j++)
        {
          <span class="keywordtype">int</span> sj=sommets(j);
          <span class="keywordtype">int</span> arete1;
          arete1 = <a class="code" href="AssembleurPP1BUtil_8cpp.html#ae1c00f10faaf4da3ffdea8f881565a1b">chercher_arete</a>(zone_VEF,elem, si, sj,
                                  elem_aretes, aretes_som);
          <span class="keywordflow">if</span>(ok_arete(arete1))
            {
              <a class="code" href="AssembleurPP1BUtil_8cpp.html#aa26334c33fd016e71cbab82de7ef2fe5">calculer_grad_arete</a>(face, face_voisins, i, j,
                                  elem, -1,
                                  faces_op1(i), -1,
                                  faces_op1(j), -1,
                                  normales, grad1);
              <a class="code" href="Champ__Generique__Transformation_8cpp.html#a0705a900f8a8003047df2f59d6cd4bae">projette</a>(grad1, face, normales);
              diag[arete1]+=<a class="code" href="AssembleurPP1BUtil_8cpp.html#a828055cfc33e4c56db8e2f5beb059862">dotproduct_array_fois_inverse_quantitee_entrelacee</a>(grad1,grad1,
                                                                               inverse_quantitee_entrelacee,face);
              <span class="keywordtype">int</span> jj=j;
              <span class="keywordflow">for</span>(k=i; k&lt;3; k++)
                {
                  <span class="keywordtype">int</span> sk=sommets(k);
                  <span class="keywordflow">for</span>(l=jj+1; l&lt;4; l++)
                    {
                      <span class="keywordtype">int</span> sl=sommets(l);
                      <span class="keywordtype">int</span> arete2= <a class="code" href="AssembleurPP1BUtil_8cpp.html#ae1c00f10faaf4da3ffdea8f881565a1b">chercher_arete</a>(zone_VEF,elem, sl, sk,
                                                 elem_aretes,
                                                 aretes_som);
                      assert(arete2!=-1);
                      <span class="keywordflow">if</span>(ok_arete(arete2))
                        {
                          <a class="code" href="AssembleurPP1BUtil_8cpp.html#aa26334c33fd016e71cbab82de7ef2fe5">calculer_grad_arete</a>(face, face_voisins, k, l,
                                              elem, -1,
                                              faces_op1(k), -1,
                                              faces_op1(l), -1,
                                              normales, grad2);
                          <a class="code" href="Champ__Generique__Transformation_8cpp.html#a0705a900f8a8003047df2f59d6cd4bae">projette</a>(grad2, face, normales);
                          psc=<a class="code" href="AssembleurPP1BUtil_8cpp.html#a828055cfc33e4c56db8e2f5beb059862">dotproduct_array_fois_inverse_quantitee_entrelacee</a>(grad1,grad2,
                                                                                 inverse_quantitee_entrelacee,face);
                          <span class="keywordtype">int</span> tmp=arete1;
                          <span class="keywordflow">if</span>(arete1&gt;arete2) <a class="code" href="AssembleurPP1BUtil_8cpp.html#a3117b050530c46b4a15b6ab9ce6d0b41">swap</a>(arete1, arete2);
                          <span class="keywordtype">int</span> rang=voisins[arete1].rang(arete2);
                          <span class="keywordflow">if</span>(rang==-1)
                            {
                              voisins[arete1].add(arete2);
                              coeffs[arete1].add(psc);
                              nnz++;
                            }
                          <span class="keywordflow">else</span>
                            {
                              coeffs[arete1][rang]+=psc;
                            }
                          arete1=tmp;
                        }
                    }
                  jj=k+1;
                }
            }
        }
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="ae2056e931f2d24d03da578b6af30cd54"></a><!-- doxytag: member="AssembleurPP1BUtil.cpp::contribuer_matriceP0P1" ref="ae2056e931f2d24d03da578b6af30cd54" args="(const Zone_VEF &amp;zone_VEF, const DoubleTab &amp;inverse_quantitee_entrelacee, int face, int elem1, int elem2, ArrOfInt &amp;sommets, ArrOfInt &amp;faces_op1, ArrOfInt &amp;faces_op2, const ArrOfDouble &amp;coef_som, IntLists &amp;voisins, DoubleLists &amp;coeffs, int &amp;nnz)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void contribuer_matriceP0P1 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classZone__VEF.html">Zone_VEF</a> &amp;&#160;</td>
          <td class="paramname"><em>zone_VEF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>inverse_quantitee_entrelacee</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>elem1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>elem2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>sommets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>faces_op1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>faces_op2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;&#160;</td>
          <td class="paramname"><em>coef_som</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classIntLists.html">IntLists</a> &amp;&#160;</td>
          <td class="paramname"><em>voisins</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDoubleLists.html">DoubleLists</a> &amp;&#160;</td>
          <td class="paramname"><em>coeffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>nnz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00528">528</a> of file <a class="el" href="AssembleurPP1BUtil_8cpp_source.html">AssembleurPP1BUtil.cpp</a>.</p>

<p>References <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00429">calculer_grad()</a>, <a class="el" href="Objet__U_8h_source.html#l00079">Objet_U::dimension</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00518">dotproduct_array_fois_inverse_quantitee_entrelacee()</a>, <a class="el" href="Zone__VEF_8h_source.html#l00145">Zone_VEF::face_normales()</a>, and <a class="el" href="Zone__VF_8h_source.html#l00458">Zone_VF::face_voisins()</a>.</p>

<p>Referenced by <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l02968">assemblerP0P1()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; normales = zone_VEF.<a class="code" href="classZone__VEF.html#a5742d75972e4846bf9fbb6ed5715053e">face_normales</a>();
  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; face_voisins = zone_VEF.<a class="code" href="classZone__VF.html#a49d4322f5585a8fa95748ca785b70702" title="renvoie l&#39;element voisin de numface dans la direction i. i=0 : dans le sens oppose de l&#39;axe orthogona...">face_voisins</a>();
  assert(elem1==face_voisins(face, 0));
  assert(elem2==face_voisins(face, 1));

  <span class="keywordtype">int</span> dimension=<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>,
      dplusdeux=dimension+2;
  <span class="keywordtype">double</span> psc;
<span class="comment">// double coeff_som=1./(dimension)/(dimension+1);</span>

  <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a> gradi(dimension);
  <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a> gradE(dimension);

  <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;dplusdeux; i++)
    {
      <span class="keywordtype">int</span> si=sommets(i);
      <span class="keywordflow">if</span> (si&lt;0) <span class="keywordflow">break</span>;
      <a class="code" href="AssembleurPP1BUtil_8cpp.html#a556b82e62a565319fb25218f97cfc50c">calculer_grad</a>(face_voisins, elem1, elem2,coef_som, si, faces_op1(i),
                    faces_op2(i), normales, gradi);
      <span class="keywordflow">for</span>(<span class="keywordtype">int</span> k=0; k&lt;dimension; k++)
        gradE(k)=normales(face,k);
      psc=<a class="code" href="AssembleurPP1BUtil_8cpp.html#a828055cfc33e4c56db8e2f5beb059862">dotproduct_array_fois_inverse_quantitee_entrelacee</a>(gradi,gradE,
                                                             inverse_quantitee_entrelacee,face);
      <span class="keywordtype">int</span> rang1=voisins[elem1].rang(si);
      <span class="keywordflow">if</span>(rang1==-1)
        {
          voisins[elem1].add(si);
          coeffs[elem1].add(psc);
          nnz++;
        }
      <span class="keywordflow">else</span>
        {
          coeffs[elem1][rang1]+=psc;
        }
      <span class="keywordflow">if</span> (elem2!=-1)
        {
          <span class="keywordtype">int</span> rang2=voisins[elem2].rang(si);
          psc*=-1;
          <span class="keywordflow">if</span>(rang2==-1)
            {
              voisins[elem2].add(si);
              coeffs[elem2].add(psc);
              nnz++;
            }
          <span class="keywordflow">else</span>
            {
              coeffs[elem2][rang2]+=psc;
            }
        }
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a36c4cdf9e6baa421844cf7cffa1396df"></a><!-- doxytag: member="AssembleurPP1BUtil.cpp::contribuer_matriceP0Pa" ref="a36c4cdf9e6baa421844cf7cffa1396df" args="(const Zone_VEF_PreP1b &amp;zone_VEF, const DoubleTab &amp;inverse_quantitee_entrelacee, int face, int elem1, int elem2, ArrOfInt &amp;sommets, ArrOfInt &amp;faces_op1, ArrOfInt &amp;faces_op2, IntLists &amp;voisins, DoubleLists &amp;coeffs, int &amp;nnz)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void contribuer_matriceP0Pa </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a> &amp;&#160;</td>
          <td class="paramname"><em>zone_VEF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>inverse_quantitee_entrelacee</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>elem1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>elem2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>sommets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>faces_op1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>faces_op2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classIntLists.html">IntLists</a> &amp;&#160;</td>
          <td class="paramname"><em>voisins</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDoubleLists.html">DoubleLists</a> &amp;&#160;</td>
          <td class="paramname"><em>coeffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>nnz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l01558">1558</a> of file <a class="el" href="AssembleurPP1BUtil_8cpp_source.html">AssembleurPP1BUtil.cpp</a>.</p>

<p>References <a class="el" href="Zone_8h_source.html#l01290">Zone::aretes_som()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00462">calculer_grad_arete()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00306">chercher_arete()</a>, <a class="el" href="Zone_8h_source.html#l01282">Zone::elem_aretes()</a>, <a class="el" href="Zone__VEF_8h_source.html#l00145">Zone_VEF::face_normales()</a>, <a class="el" href="Zone__VF_8h_source.html#l00458">Zone_VF::face_voisins()</a>, <a class="el" href="Zone__VEF__PreP1b_8h_source.html#l00090">Zone_VEF_PreP1b::get_ok_arete()</a>, and <a class="el" href="Zone__dis__base_8h_source.html#l00106">Zone_dis_base::zone()</a>.</p>

<p>Referenced by <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l02655">assemblerP0Pa()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; elem_aretes=zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#a1e1e86ef5b088c4d33d42cd38a967b4a" title="renvoie le numero de la jeme arete du ieme element.">elem_aretes</a>();
  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; aretes_som=zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#affa60690e1b372fa4c01d6088267dbe4" title="renvoie le tableau de connectivite aretes/sommets.">aretes_som</a>();
  <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; ok_arete=zone_VEF.<a class="code" href="classZone__VEF__PreP1b.html#a83771f784d487e346b2ef22a389472a2">get_ok_arete</a>();
  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; face_voisins=zone_VEF.<a class="code" href="classZone__VF.html#a49d4322f5585a8fa95748ca785b70702" title="renvoie l&#39;element voisin de numface dans la direction i. i=0 : dans le sens oppose de l&#39;axe orthogona...">face_voisins</a>();
  <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; normales = zone_VEF.<a class="code" href="classZone__VEF.html#a5742d75972e4846bf9fbb6ed5715053e">face_normales</a>();
  <span class="keywordtype">int</span> i, j;
  <span class="keywordtype">double</span> psc;
  <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a> grad1(3);
  <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a> grad2(3);
  <span class="keywordtype">int</span> jmax=5;
  <span class="keywordflow">if</span>(elem2==-1) jmax=4;
  <span class="keywordflow">for</span>(i=0; i&lt;3; i++)
    {
      <span class="keywordtype">int</span> si=sommets(i);
      <span class="keywordflow">for</span>(j=i+1; j&lt;jmax; j++)
        {
          <span class="keywordtype">int</span> sj=sommets(j);
          <span class="keywordtype">int</span> arete1;
          <span class="keywordflow">if</span>(j&lt;4)
            arete1 = <a class="code" href="AssembleurPP1BUtil_8cpp.html#ae1c00f10faaf4da3ffdea8f881565a1b">chercher_arete</a>(zone_VEF,elem1, si, sj,
                                    elem_aretes, aretes_som);
          <span class="keywordflow">else</span>
            arete1 = <a class="code" href="AssembleurPP1BUtil_8cpp.html#ae1c00f10faaf4da3ffdea8f881565a1b">chercher_arete</a>(zone_VEF,elem2, si, sj,
                                    elem_aretes, aretes_som);
          <span class="keywordflow">if</span>(ok_arete(arete1))
            {
              <a class="code" href="AssembleurPP1BUtil_8cpp.html#aa26334c33fd016e71cbab82de7ef2fe5">calculer_grad_arete</a>(face, face_voisins, i, j,
                                  elem1, elem2,
                                  faces_op1(i), faces_op2(i),
                                  faces_op1(j), faces_op2(j),
                                  normales, grad1);
              psc=0;
              <span class="keywordflow">for</span>(<span class="keywordtype">int</span> comp=0; comp&lt;3; comp++)
                psc+=grad1(comp)*normales(face, comp)*
                     (-inverse_quantitee_entrelacee(face,comp));
              <span class="keywordtype">int</span> rang=voisins[elem1].rang(arete1);
              <span class="keywordflow">if</span>(rang==-1)
                {
                  voisins[elem1].add(arete1);
                  coeffs[elem1].add(psc);
                  nnz++;
                }
              <span class="keywordflow">else</span>
                {
                  coeffs[elem1][rang]+=psc;
                }
              <span class="keywordflow">if</span>(elem2!=-1)
                {
                  psc*=-1.0;
                  <span class="keywordtype">int</span> rangbis=voisins[elem2].rang(arete1);
                  <span class="keywordflow">if</span>(rangbis==-1)
                    {
                      voisins[elem2].add(arete1);
                      coeffs[elem2].add(psc);
                      nnz++;
                    }
                  <span class="keywordflow">else</span>
                    {
                      coeffs[elem2][rangbis]+=psc;
                    }
                }
            }
        }
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="ae9226a0247d37eab885c3915814c82c7"></a><!-- doxytag: member="AssembleurPP1BUtil.cpp::contribuer_matriceP1P1" ref="ae9226a0247d37eab885c3915814c82c7" args="(const Zone_VEF &amp;zone_VEF, const DoubleTab &amp;inverse_quantitee_entrelacee, int face, int elem1, int elem2, ArrOfInt &amp;sommets, ArrOfInt &amp;faces_op1, ArrOfInt &amp;faces_op2, const ArrOfDouble &amp;coef_som, IntLists &amp;voisins, DoubleLists &amp;coeffs, DoubleVect &amp;diag, int &amp;nnz)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void contribuer_matriceP1P1 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classZone__VEF.html">Zone_VEF</a> &amp;&#160;</td>
          <td class="paramname"><em>zone_VEF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>inverse_quantitee_entrelacee</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>elem1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>elem2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>sommets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>faces_op1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>faces_op2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;&#160;</td>
          <td class="paramname"><em>coef_som</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classIntLists.html">IntLists</a> &amp;&#160;</td>
          <td class="paramname"><em>voisins</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDoubleLists.html">DoubleLists</a> &amp;&#160;</td>
          <td class="paramname"><em>coeffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;&#160;</td>
          <td class="paramname"><em>diag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>nnz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00638">638</a> of file <a class="el" href="AssembleurPP1BUtil_8cpp_source.html">AssembleurPP1BUtil.cpp</a>.</p>

<p>References <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00429">calculer_grad()</a>, <a class="el" href="Objet__U_8h_source.html#l00079">Objet_U::dimension</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00518">dotproduct_array_fois_inverse_quantitee_entrelacee()</a>, <a class="el" href="Zone__VEF_8h_source.html#l00145">Zone_VEF::face_normales()</a>, and <a class="el" href="Zone__VF_8h_source.html#l00458">Zone_VF::face_voisins()</a>.</p>

<p>Referenced by <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l02247">assemblerP1P1()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; normales = zone_VEF.<a class="code" href="classZone__VEF.html#a5742d75972e4846bf9fbb6ed5715053e">face_normales</a>();
  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; face_voisins = zone_VEF.<a class="code" href="classZone__VF.html#a49d4322f5585a8fa95748ca785b70702" title="renvoie l&#39;element voisin de numface dans la direction i. i=0 : dans le sens oppose de l&#39;axe orthogona...">face_voisins</a>();

  <span class="keywordtype">int</span> dimension=<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>,
      dplusdeux=dimension+2;
  <span class="keywordtype">double</span> psc;
<span class="comment">// double coeff_som=1./(dimension)/(dimension+1);</span>
<span class="comment">// coeff_som*=coeff_som;</span>
  <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a> gradi(dimension);
  <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a> gradj(dimension);
  <span class="keywordtype">int</span> i,j;

<span class="comment">// On ne traite pas les sommets -1 qui</span>
<span class="comment">// sont en fin de tableau sommets:</span>
  <span class="keywordflow">while</span> (sommets(dplusdeux-1)==-1)
    dplusdeux--;

  <span class="keywordflow">for</span>(i=0; i&lt;dplusdeux; i++)
    {
      <span class="keywordtype">int</span> si=sommets(i);
      <a class="code" href="AssembleurPP1BUtil_8cpp.html#a556b82e62a565319fb25218f97cfc50c">calculer_grad</a>(face_voisins, elem1, elem2,  coef_som,si, faces_op1(i),
                    faces_op2(i), normales, gradi);
      diag[si]+=<a class="code" href="AssembleurPP1BUtil_8cpp.html#a828055cfc33e4c56db8e2f5beb059862">dotproduct_array_fois_inverse_quantitee_entrelacee</a>(gradi,gradi,
                                                                   inverse_quantitee_entrelacee,face);
      <span class="keywordflow">for</span>(j=i+1; j&lt;dplusdeux; j++)
        {
          <span class="keywordtype">int</span> sj=sommets(j);
          <a class="code" href="AssembleurPP1BUtil_8cpp.html#a556b82e62a565319fb25218f97cfc50c">calculer_grad</a>(face_voisins, elem1, elem2,  coef_som,sj, faces_op1(j),
                        faces_op2(j), normales, gradj);
          psc=<a class="code" href="AssembleurPP1BUtil_8cpp.html#a828055cfc33e4c56db8e2f5beb059862">dotproduct_array_fois_inverse_quantitee_entrelacee</a>(gradi,gradj,inverse_quantitee_entrelacee,face);
          <span class="keywordtype">int</span> rang=voisins[si].rang(sj);
          <span class="keywordflow">if</span> (sj&gt;si)
            {
              <span class="keywordflow">if</span>(rang==-1)
                {
                  voisins[si].add(sj);
                  coeffs[si].add(psc);
                  nnz++;
                }
              <span class="keywordflow">else</span>
                {
                  coeffs[si][rang]+=psc;
                }
            }
        }
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a0000fbbb1165039c7071352be4a35877"></a><!-- doxytag: member="AssembleurPP1BUtil.cpp::contribuer_matriceP1Pa" ref="a0000fbbb1165039c7071352be4a35877" args="(const Zone_VEF_PreP1b &amp;zone_VEF, const DoubleTab &amp;inverse_quantitee_entrelacee, int face, int elem1, int elem2, ArrOfInt &amp;sommets, ArrOfInt &amp;faces_op1, ArrOfInt &amp;faces_op2, const ArrOfDouble &amp;coef_som, IntLists &amp;voisins, DoubleLists &amp;coeffs, int &amp;nnz)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void contribuer_matriceP1Pa </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a> &amp;&#160;</td>
          <td class="paramname"><em>zone_VEF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>inverse_quantitee_entrelacee</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>elem1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>elem2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>sommets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>faces_op1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>faces_op2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;&#160;</td>
          <td class="paramname"><em>coef_som</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classIntLists.html">IntLists</a> &amp;&#160;</td>
          <td class="paramname"><em>voisins</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDoubleLists.html">DoubleLists</a> &amp;&#160;</td>
          <td class="paramname"><em>coeffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>nnz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l01819">1819</a> of file <a class="el" href="AssembleurPP1BUtil_8cpp_source.html">AssembleurPP1BUtil.cpp</a>.</p>

<p>References <a class="el" href="Zone_8h_source.html#l01290">Zone::aretes_som()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00429">calculer_grad()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00462">calculer_grad_arete()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00306">chercher_arete()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00518">dotproduct_array_fois_inverse_quantitee_entrelacee()</a>, <a class="el" href="Zone_8h_source.html#l01282">Zone::elem_aretes()</a>, <a class="el" href="Zone__VEF_8h_source.html#l00145">Zone_VEF::face_normales()</a>, <a class="el" href="Zone__VF_8h_source.html#l00458">Zone_VF::face_voisins()</a>, <a class="el" href="Zone__VEF__PreP1b_8h_source.html#l00090">Zone_VEF_PreP1b::get_ok_arete()</a>, and <a class="el" href="Zone__dis__base_8h_source.html#l00106">Zone_dis_base::zone()</a>.</p>

<p>Referenced by <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l02803">assemblerP1Pa()</a>.</p>
<div class="fragment"><pre class="fragment">{
<span class="comment">// int dimension=Objet_U::dimension,</span>
<span class="comment">// dplusun=dimension+1;</span>
<span class="comment">// double coeff_som=1./(dimension)/(dplusun);</span>
  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; elem_aretes=zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#a1e1e86ef5b088c4d33d42cd38a967b4a" title="renvoie le numero de la jeme arete du ieme element.">elem_aretes</a>();
  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; aretes_som=zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#affa60690e1b372fa4c01d6088267dbe4" title="renvoie le tableau de connectivite aretes/sommets.">aretes_som</a>();
  <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; ok_arete=zone_VEF.<a class="code" href="classZone__VEF__PreP1b.html#a83771f784d487e346b2ef22a389472a2">get_ok_arete</a>();
  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; face_voisins=zone_VEF.<a class="code" href="classZone__VF.html#a49d4322f5585a8fa95748ca785b70702" title="renvoie l&#39;element voisin de numface dans la direction i. i=0 : dans le sens oppose de l&#39;axe orthogona...">face_voisins</a>();
  <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; normales = zone_VEF.<a class="code" href="classZone__VEF.html#a5742d75972e4846bf9fbb6ed5715053e">face_normales</a>();
  <span class="keywordtype">int</span> i, j, k;
  <span class="keywordtype">double</span> psc;
  <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a> grad1(3);
  <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a> grad2(3);
  <span class="keywordtype">int</span> jmax=5;
  <span class="keywordflow">if</span>(elem2==-1) jmax=4;
  <span class="keywordflow">for</span>(i=0; i&lt;3; i++)
    {
      <span class="keywordtype">int</span> si=sommets(i);
      <span class="keywordflow">for</span>(j=i+1; j&lt;jmax; j++)
        {
          <span class="keywordtype">int</span> sj=sommets(j);
          <span class="keywordtype">int</span> arete1;
          <span class="keywordflow">if</span>(j&lt;4)
            arete1 = <a class="code" href="AssembleurPP1BUtil_8cpp.html#ae1c00f10faaf4da3ffdea8f881565a1b">chercher_arete</a>(zone_VEF,elem1, si, sj,
                                    elem_aretes, aretes_som);
          <span class="keywordflow">else</span>
            arete1 = <a class="code" href="AssembleurPP1BUtil_8cpp.html#ae1c00f10faaf4da3ffdea8f881565a1b">chercher_arete</a>(zone_VEF,elem2, si, sj,
                                    elem_aretes, aretes_som);
          <span class="keywordflow">if</span>(ok_arete(arete1))
            {
              <a class="code" href="AssembleurPP1BUtil_8cpp.html#aa26334c33fd016e71cbab82de7ef2fe5">calculer_grad_arete</a>(face, face_voisins, i, j,
                                  elem1, elem2,
                                  faces_op1(i), faces_op2(i),
                                  faces_op1(j), faces_op2(j),
                                  normales, grad1);
              <span class="keywordflow">for</span>(k=0; k&lt;jmax; k++)
                {
                  <span class="keywordtype">int</span> sk=sommets(k);
                  <a class="code" href="AssembleurPP1BUtil_8cpp.html#a556b82e62a565319fb25218f97cfc50c">calculer_grad</a>(face_voisins, elem1, elem2, coef_som, sk,
                                faces_op1(k), faces_op2(k),
                                normales, grad2);
                  psc=-<a class="code" href="AssembleurPP1BUtil_8cpp.html#a828055cfc33e4c56db8e2f5beb059862">dotproduct_array_fois_inverse_quantitee_entrelacee</a>(grad1,grad2,
                                                                          inverse_quantitee_entrelacee,face);
                  <span class="keywordtype">int</span> rang1=voisins[sk].rang(arete1);
                  <span class="keywordflow">if</span>(rang1==-1)
                    {
                      voisins[sk].add(arete1);
                      coeffs[sk].add(psc);
                      nnz++;
                    }
                  <span class="keywordflow">else</span>
                    {
                      coeffs[sk][rang1]+=psc;
                    }
                }
            }
        }
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a59992a437cf7e18b4b9ce353d77d0bda"></a><!-- doxytag: member="AssembleurPP1BUtil.cpp::contribuer_matricePaPa" ref="a59992a437cf7e18b4b9ce353d77d0bda" args="(const Zone_VEF_PreP1b &amp;zone_VEF, const DoubleTab &amp;inverse_quantitee_entrelacee, int face, int elem1, int elem2, ArrOfInt &amp;sommets, ArrOfInt &amp;faces_op1, ArrOfInt &amp;faces_op2, IntLists &amp;voisins, DoubleLists &amp;coeffs, DoubleVect &amp;diag, int &amp;nnz)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void contribuer_matricePaPa </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a> &amp;&#160;</td>
          <td class="paramname"><em>zone_VEF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>inverse_quantitee_entrelacee</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>elem1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>elem2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>sommets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>faces_op1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>faces_op2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classIntLists.html">IntLists</a> &amp;&#160;</td>
          <td class="paramname"><em>voisins</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDoubleLists.html">DoubleLists</a> &amp;&#160;</td>
          <td class="paramname"><em>coeffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;&#160;</td>
          <td class="paramname"><em>diag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>nnz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00748">748</a> of file <a class="el" href="AssembleurPP1BUtil_8cpp_source.html">AssembleurPP1BUtil.cpp</a>.</p>

<p>References <a class="el" href="Zone_8h_source.html#l01290">Zone::aretes_som()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00462">calculer_grad_arete()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00306">chercher_arete()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00518">dotproduct_array_fois_inverse_quantitee_entrelacee()</a>, <a class="el" href="Zone_8h_source.html#l01282">Zone::elem_aretes()</a>, <a class="el" href="Zone__VEF_8h_source.html#l00145">Zone_VEF::face_normales()</a>, <a class="el" href="Zone__VF_8h_source.html#l00458">Zone_VF::face_voisins()</a>, <a class="el" href="Zone__VEF__PreP1b_8h_source.html#l00090">Zone_VEF_PreP1b::get_ok_arete()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00335">swap()</a>, and <a class="el" href="Zone__dis__base_8h_source.html#l00106">Zone_dis_base::zone()</a>.</p>

<p>Referenced by <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l02477">assemblerPaPa()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; elem_aretes=zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#a1e1e86ef5b088c4d33d42cd38a967b4a" title="renvoie le numero de la jeme arete du ieme element.">elem_aretes</a>();
  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; aretes_som=zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#affa60690e1b372fa4c01d6088267dbe4" title="renvoie le tableau de connectivite aretes/sommets.">aretes_som</a>();
  <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; ok_arete=zone_VEF.<a class="code" href="classZone__VEF__PreP1b.html#a83771f784d487e346b2ef22a389472a2">get_ok_arete</a>();
  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; face_voisins=zone_VEF.<a class="code" href="classZone__VF.html#a49d4322f5585a8fa95748ca785b70702" title="renvoie l&#39;element voisin de numface dans la direction i. i=0 : dans le sens oppose de l&#39;axe orthogona...">face_voisins</a>();
  <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; normales = zone_VEF.<a class="code" href="classZone__VEF.html#a5742d75972e4846bf9fbb6ed5715053e">face_normales</a>();
  <span class="keywordtype">int</span> i, j, k, l;
  <span class="keywordtype">double</span> psc;
<span class="comment">// On ne traite pas les sommets -1 qui</span>
<span class="comment">// sont en fin de tableau sommets:</span>
<span class="comment">// while (sommets(dplusdeux-1)==-1)</span>
<span class="comment">// dplusdeux--;</span>

  <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a> grad1(3);
  <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a> grad2(3);
  <span class="keywordtype">int</span> jmax=5;
  <span class="keywordflow">if</span>(elem2==-1) jmax=4;
  <span class="keywordflow">for</span>(i=0; i&lt;3; i++)
    {
      <span class="keywordtype">int</span> si=sommets(i);
      <span class="keywordflow">for</span>(j=i+1; j&lt;jmax; j++)
        {
          <span class="keywordtype">int</span> sj=sommets(j);
          <span class="keywordtype">int</span> arete1;
          <span class="keywordflow">if</span>(j&lt;4)
            arete1 = <a class="code" href="AssembleurPP1BUtil_8cpp.html#ae1c00f10faaf4da3ffdea8f881565a1b">chercher_arete</a>(zone_VEF,elem1, si, sj,
                                    elem_aretes, aretes_som);
          <span class="keywordflow">else</span>
            arete1 = <a class="code" href="AssembleurPP1BUtil_8cpp.html#ae1c00f10faaf4da3ffdea8f881565a1b">chercher_arete</a>(zone_VEF,elem2, si, sj,
                                    elem_aretes, aretes_som);
          assert(arete1!=-1);
          <span class="keywordflow">if</span>(ok_arete(arete1))
            {
              <a class="code" href="AssembleurPP1BUtil_8cpp.html#aa26334c33fd016e71cbab82de7ef2fe5">calculer_grad_arete</a>(face, face_voisins, i, j,
                                  elem1, elem2,
                                  faces_op1(i), faces_op2(i),
                                  faces_op1(j), faces_op2(j),
                                  normales, grad1);
              diag[arete1]+=<a class="code" href="AssembleurPP1BUtil_8cpp.html#a828055cfc33e4c56db8e2f5beb059862">dotproduct_array_fois_inverse_quantitee_entrelacee</a>(grad1,grad1,
                                                                               inverse_quantitee_entrelacee,face);
              <span class="keywordtype">int</span> jj=j;
              <span class="keywordflow">for</span>(k=i; k&lt;3; k++)
                {
                  <span class="keywordtype">int</span> sk=sommets(k);
                  <span class="keywordflow">for</span>(l=jj+1; l&lt;jmax; l++)
                    {
                      <span class="keywordtype">int</span> sl=sommets(l);
                      <span class="keywordtype">int</span> arete2;
                      <span class="keywordflow">if</span>(l&lt;4)
                        arete2 = <a class="code" href="AssembleurPP1BUtil_8cpp.html#ae1c00f10faaf4da3ffdea8f881565a1b">chercher_arete</a>(zone_VEF,elem1, sl, sk,
                                                elem_aretes,
                                                aretes_som);
                      <span class="keywordflow">else</span>
                        arete2 = <a class="code" href="AssembleurPP1BUtil_8cpp.html#ae1c00f10faaf4da3ffdea8f881565a1b">chercher_arete</a>(zone_VEF,elem2, sl, sk,
                                                elem_aretes,
                                                aretes_som);
                      assert(arete2!=-1);
                      <span class="keywordflow">if</span>(ok_arete(arete2))
                        {
                          <a class="code" href="AssembleurPP1BUtil_8cpp.html#aa26334c33fd016e71cbab82de7ef2fe5">calculer_grad_arete</a>(face, face_voisins, k, l,
                                              elem1, elem2,
                                              faces_op1(k), faces_op2(k),
                                              faces_op1(l), faces_op2(l),
                                              normales, grad2);
                          psc=<a class="code" href="AssembleurPP1BUtil_8cpp.html#a828055cfc33e4c56db8e2f5beb059862">dotproduct_array_fois_inverse_quantitee_entrelacee</a>(grad1,grad2,
                                                                                 inverse_quantitee_entrelacee,face);
                          <span class="keywordtype">int</span> tmp=arete1;
                          <span class="keywordflow">if</span>(arete1&gt;arete2) <a class="code" href="AssembleurPP1BUtil_8cpp.html#a3117b050530c46b4a15b6ab9ce6d0b41">swap</a>(arete1, arete2);
                          <span class="keywordtype">int</span> rang=voisins[arete1].rang(arete2);
                          <span class="keywordflow">if</span>(rang==-1)
                            {
                              voisins[arete1].add(arete2);
                              coeffs[arete1].add(psc);
                              nnz++;
                            }
                          <span class="keywordflow">else</span>
                            {
                              coeffs[arete1][rang]+=psc;
                            }
                          arete1=tmp;
                        }
                    }
                  jj=k+1;
                }
            }
        }
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a828055cfc33e4c56db8e2f5beb059862"></a><!-- doxytag: member="AssembleurPP1BUtil.cpp::dotproduct_array_fois_inverse_quantitee_entrelacee" ref="a828055cfc33e4c56db8e2f5beb059862" args="(const ArrOfDouble &amp;gradi, const ArrOfDouble &amp;gradE, const DoubleTab &amp;inverse_quantitee_entrelacee, int face)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static double dotproduct_array_fois_inverse_quantitee_entrelacee </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;&#160;</td>
          <td class="paramname"><em>gradi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;&#160;</td>
          <td class="paramname"><em>gradE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>inverse_quantitee_entrelacee</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>face</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00518">518</a> of file <a class="el" href="AssembleurPP1BUtil_8cpp_source.html">AssembleurPP1BUtil.cpp</a>.</p>

<p>References <a class="el" href="ArrOfDouble_8cpp_source.html#l01277">dotproduct_array()</a>, and <a class="el" href="ArrOfDouble_8h_source.html#l00350">ArrOfDouble::size_array()</a>.</p>

<p>Referenced by <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00939">contribuer_matrice_NeumannP0P1()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l01028">contribuer_matrice_NeumannP1P1()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l01958">contribuer_matrice_NeumannP1Pa()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l01241">contribuer_matrice_NeumannPaPa()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l01138">contribuer_matrice_SymetrieP1P1()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l02092">contribuer_matrice_SymetrieP1Pa()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l01398">contribuer_matrice_SymetriePaPa()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00528">contribuer_matriceP0P1()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00638">contribuer_matriceP1P1()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l01819">contribuer_matriceP1Pa()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00748">contribuer_matricePaPa()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00983">update_matrice_NeumannP0P1()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l01084">update_matrice_NeumannP1P1()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l02025">update_matrice_NeumannP1Pa()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l01319">update_matrice_NeumannPaPa()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l01191">update_matrice_SymetrieP1P1()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l02157">update_matrice_SymetrieP1Pa()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l01478">update_matrice_SymetriePaPa()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00600">update_matriceP0P1()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00694">update_matriceP1P1()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l01888">update_matriceP1Pa()</a>, and <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00843">update_matricePaPa()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">double</span> dot=0;
  <span class="keywordtype">int</span> size=gradi.<a class="code" href="classArrOfDouble.html#a3c3b33bea0e88b87315c21ee94bee05f" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>();
  assert(size == gradE.<a class="code" href="classArrOfDouble.html#a3c3b33bea0e88b87315c21ee94bee05f" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>());
  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;size; i++) dot+=gradi(i)*gradE(i)*inverse_quantitee_entrelacee(face,i);
  <span class="keywordflow">return</span> dot;
  <span class="keywordflow">return</span>  <a class="code" href="ArrOfDouble_8cpp.html#af541bfdadae7483016c96f13760598ac" title="Produit scalaire de deux &quot;array&quot;. (dotproduct_array remplace operator* car le nom indique clairemen...">dotproduct_array</a>(gradi,gradE)*inverse_quantitee_entrelacee(face,0);
}
</pre></div>
</div>
</div>
<a class="anchor" id="a1ce15acad922bef2d305d970c13c68c8"></a><!-- doxytag: member="AssembleurPP1BUtil.cpp::modifieP1P1neumann" ref="a1ce15acad922bef2d305d970c13c68c8" args="(const Zone_dis_base &amp;z, const Zone_Cl_dis_base &amp;zcl, Matrice &amp;matrice, const DoubleTab &amp;inverse_quantitee_entrelacee, const ArrOfDouble &amp;coef_som)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void modifieP1P1neumann </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classZone__dis__base.html">Zone_dis_base</a> &amp;&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classZone__Cl__dis__base.html">Zone_Cl_dis_base</a> &amp;&#160;</td>
          <td class="paramname"><em>zcl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatrice.html">Matrice</a> &amp;&#160;</td>
          <td class="paramname"><em>matrice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>inverse_quantitee_entrelacee</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;&#160;</td>
          <td class="paramname"><em>coef_som</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l02429">2429</a> of file <a class="el" href="AssembleurPP1BUtil_8cpp_source.html">AssembleurPP1BUtil.cpp</a>.</p>

<p>References <a class="el" href="EntreeSortie_8h_source.html#l00032">Cerr</a>, <a class="el" href="IntTab_8h_source.html#l00233">IntTab::dimension()</a>, <a class="el" href="Objet__U_8h_source.html#l00079">Objet_U::dimension</a>, <a class="el" href="Zone__VF_8h_source.html#l00609">Zone_VF::face_sommets()</a>, <a class="el" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>, <a class="el" href="Cond__lim__base_8h_source.html#l00123">Cond_lim_base::frontiere_dis()</a>, <a class="el" href="Matrice__Bloc_8cpp_source.html#l00568">Matrice_Bloc::get_bloc()</a>, <a class="el" href="Zone__Cl__dis__base_8cpp_source.html#l00522">Zone_Cl_dis_base::les_conditions_limites()</a>, <a class="el" href="Front__VF_8h_source.html#l00066">Front_VF::nb_faces_tot()</a>, <a class="el" href="Zone__dis__base_8h_source.html#l00148">Zone_dis_base::nb_som()</a>, <a class="el" href="Front__VF_8h_source.html#l00076">Front_VF::num_face()</a>, <a class="el" href="Cast_8h_source.html#l00059">ref_cast</a>, <a class="el" href="vect__impl_8h_source.html#l00057">vect_impl::size()</a>, <a class="el" href="Cast_8h_source.html#l00054">sub_type</a>, and <a class="el" href="Deriv__Matrice__Base_8h_source.html#l00028">Deriv_Matrice_Base::valeur()</a>.</p>

<p>Referenced by <a class="el" href="Assembleur__P__VEFPreP1B_8cpp_source.html#l00230">Assembleur_P_VEFPreP1B::assembler_mat()</a>.</p>
<div class="fragment"><pre class="fragment">{

  <span class="keywordtype">int</span> dimension=<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>;
  <span class="keyword">const</span> <a class="code" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a>&amp; zone_VEF=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a>, z);
<span class="comment">// const Zone&amp; zone=zone_VEF.zone();</span>
  <span class="keyword">const</span> <a class="code" href="classZone__Cl__VEF.html">Zone_Cl_VEF</a>&amp; zone_Cl_VEF=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classZone__Cl__VEF.html">Zone_Cl_VEF</a>, zcl);
  <span class="keyword">const</span> <a class="code" href="classConds__lim.html">Conds_lim</a>&amp; les_cl = zone_Cl_VEF.<a class="code" href="classZone__Cl__dis__base.html#af75e0ed7786863e4d333bfb29d67c323" title="Renvoie la i-ieme condition aux limites. (version const)">les_conditions_limites</a>();

<span class="comment">// int nnz=nb_som;</span>
  <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> sommets(dimension+2);
  <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> face_opp1(dimension+2);
  <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> face_opp2(dimension+2);
  <a class="code" href="classMatrice__Bloc.html">Matrice_Bloc</a>&amp; A=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Bloc.html">Matrice_Bloc</a>, matrice.<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>());
  <a class="code" href="classMatrice__Morse__Sym.html" title="Classe Matrice_Morse_Sym Represente une matrice M (creuse) symetrique stockee au format Morse Symetri...">Matrice_Morse_Sym</a>&amp; ARR=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Morse__Sym.html" title="Classe Matrice_Morse_Sym Represente une matrice M (creuse) symetrique stockee au format Morse Symetri...">Matrice_Morse_Sym</a>, A.<a class="code" href="classMatrice__Bloc.html#a7ffa38f7b93454432b2df7c616ed0a4e">get_bloc</a>(0,0).<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>());
<span class="comment">// Faces de bord :</span>
  assert(<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a>, z).get_cl_pression_sommet_faible()==0);
  <span class="keywordtype">int</span> nb_som_tot=z.<a class="code" href="classZone__dis__base.html#acc9921d6a29cb719fd832fd573e47825">nb_som</a>();
  <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;les_cl.<a class="code" href="classvect__impl.html#a78155bfbd6b61f4710b9830641ed1694">size</a>(); i++)
    {

      <span class="keyword">const</span> <a class="code" href="classCond__lim__base.html" title="classe Cond_lim_base Classe de base pour la hierarchie des classes qui representent les differentes c...">Cond_lim_base</a>&amp; la_cl = les_cl[i].valeur();
      <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classNeumann__sortie__libre.html" title="classe Neumann_sortie_libre Cette classe represente une frontiere ouverte sans vitesse imposee Pour l...">Neumann_sortie_libre</a>,la_cl))
        {
          <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp; le_bord = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>,la_cl.<a class="code" href="classCond__lim__base.html#ad88b3b516351146c85e8fce1df0f691a" title="Renvoie la frontiere discretisee a laquelle les conditions aux limites s&#39;appliquent.">frontiere_dis</a>());
          <span class="keywordtype">int</span> nb_faces_bord = le_bord.<a class="code" href="classFront__VF.html#aed4006d91bf2ef3af2b9f7933d863a09" title="Nombre de faces reelles et virtuelles du bord.">nb_faces_tot</a>();
          <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; faces=zone_VEF.<a class="code" href="classZone__VF.html#a298e73b18e17da55f421b1fb0879bd46" title="renvoie le numero du ieme sommet de la face num_face.">face_sommets</a>();
          <span class="keywordtype">int</span> nbsf=faces.<a class="code" href="classIntTab.html#abc3b32c94925a82f69d5b153a356e359" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(1);
          <span class="keywordflow">for</span>(<span class="keywordtype">int</span> ind_face=0; ind_face&lt;nb_faces_bord; ind_face++)
            {
              <span class="keywordtype">int</span> face=le_bord.<a class="code" href="classFront__VF.html#a3402a19d7e54ed797d2b18e9a47ead1e" title="Renvoie le numero de face de la ieme face du bord.">num_face</a>(ind_face);
              <span class="keywordflow">for</span>(<span class="keywordtype">int</span> som=0; som&lt;nbsf; som++)
                {

                  <span class="keywordtype">int</span> som_glob=faces(face,som);
                  <span class="keywordflow">if</span> (som_glob&lt;nb_som_tot)
                    ARR(som_glob,som_glob)=1e12;
<span class="comment">// Cout&lt;&lt;ref_cast(Zone_VEF_PreP1b, z).numero_premier_sommet()&lt;&lt;&quot; ici &quot;&lt;&lt;som_glob&lt;&lt;finl;</span>
                }
            }
        }
    }
  <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Modifie P1P1 Neumann OK&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a40cf40213663174bb24649e51832bf3e"></a><!-- doxytag: member="AssembleurPP1BUtil.cpp::okface" ref="a40cf40213663174bb24649e51832bf3e" args="(int &amp;ind_face, int &amp;face, const Cond_lim &amp;la_cl)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int okface </td>
          <td>(</td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>ind_face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCond__lim.html">Cond_lim</a> &amp;&#160;</td>
          <td class="paramname"><em>la_cl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00081">81</a> of file <a class="el" href="AssembleurPP1BUtil_8cpp_source.html">AssembleurPP1BUtil.cpp</a>.</p>

<p>References <a class="el" href="Periodique_8h_source.html#l00056">Periodique::face_associee()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00046">face_associee</a>, <a class="el" href="Cond__lim_8h_source.html#l00130">Cond_lim::frontiere_dis()</a>, <a class="el" href="Front__VF_8h_source.html#l00066">Front_VF::nb_faces_tot()</a>, <a class="el" href="Front__VF_8h_source.html#l00076">Front_VF::num_face()</a>, <a class="el" href="Cast_8h_source.html#l00059">ref_cast</a>, <a class="el" href="Cast_8h_source.html#l00054">sub_type</a>, and <a class="el" href="Cond__lim_8h_source.html#l00031">Deriv_Cond_lim_base::valeur()</a>.</p>

<p>Referenced by <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l02968">assemblerP0P1()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l02655">assemblerP0Pa()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l02247">assemblerP1P1()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l02803">assemblerP1Pa()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l02477">assemblerPaPa()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l03048">updateP0P1()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l02730">updateP0Pa()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l02339">updateP1P1()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l02885">updateP1Pa()</a>, and <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l02567">updatePaPa()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <a class="code" href="AssembleurPP1BUtil_8cpp.html#a3e374d53ebc7860e1c2f0b7906f2936d">face_associee</a>=-1;
  <span class="keywordtype">int</span> ok=1;
  <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp; le_bord = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>,la_cl.<a class="code" href="classCond__lim.html#a5b2d24809cee07727006a891d4ce8d22" title="Appel a l&#39;objet sous-jacent Renvoie la frontiere discretisee associee a la condition aux limites...">frontiere_dis</a>());
  <span class="keywordtype">int</span> nb_faces_bord_tot = le_bord.<a class="code" href="classFront__VF.html#aed4006d91bf2ef3af2b9f7933d863a09" title="Nombre de faces reelles et virtuelles du bord.">nb_faces_tot</a>();
  <span class="keywordflow">do</span>
    {
      face=le_bord.<a class="code" href="classFront__VF.html#a3402a19d7e54ed797d2b18e9a47ead1e" title="Renvoie le numero de face de la ieme face du bord.">num_face</a>(ind_face);
      <span class="keywordflow">if</span> ((<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classDirichlet.html" title="classe Dirichlet Cette classe est la classe de base de la hierarchie des conditions aux limites de ty...">Dirichlet</a>, la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>()))
          || (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classDirichlet__homogene.html" title="Classe Dirichlet_homogene Cette classe est la classe de base de la hierarchie des conditions aux limi...">Dirichlet_homogene</a>, la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>())))
        {
          ok=0;
        }
      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>()))
        {
<span class="comment">// periodicite</span>
          <span class="keyword">const</span> <a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>&amp; la_cl_perio = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>, la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>());
          <a class="code" href="AssembleurPP1BUtil_8cpp.html#a3e374d53ebc7860e1c2f0b7906f2936d">face_associee</a>=le_bord.<a class="code" href="classFront__VF.html#a3402a19d7e54ed797d2b18e9a47ead1e" title="Renvoie le numero de face de la ieme face du bord.">num_face</a>(la_cl_perio.<a class="code" href="classPeriodique.html#a207b86556f199a63ea059b841851ca6a">face_associee</a>(ind_face));
          ok=2;
        }
      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classNeumann__sortie__libre.html" title="classe Neumann_sortie_libre Cette classe represente une frontiere ouverte sans vitesse imposee Pour l...">Neumann_sortie_libre</a>, la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>()))
        {
<span class="comment">// sortie_libre</span>
          ok=3;
        }
      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classSymetrie.html" title="classe Symetrie Sur les faces de symetrie on a les proprietes suivantes: - composante normale de la v...">Symetrie</a>, la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>()))
        {
<span class="comment">// symetrie</span>
          ok=4;
        }
    }
  <span class="keywordflow">while</span> ( ( (ok==0) || ((ok==2)&amp;&amp;(face_associee&lt;face)) ) &amp;&amp; (++ind_face&lt;nb_faces_bord_tot) );
  <span class="keywordflow">if</span> (ind_face==nb_faces_bord_tot) ok=-1;
  <span class="keywordflow">return</span> ok;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a67ce6f1ce2314223209eca2d6ef7ac06"></a><!-- doxytag: member="AssembleurPP1BUtil.cpp::projette" ref="a67ce6f1ce2314223209eca2d6ef7ac06" args="(ArrOfDouble &amp;gradi, int face, const DoubleTab &amp;normales)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void projette </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;&#160;</td>
          <td class="paramname"><em>gradi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>normales</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00051">51</a> of file <a class="el" href="AssembleurPP1BUtil_8cpp_source.html">AssembleurPP1BUtil.cpp</a>.</p>

<p>References <a class="el" href="Double_8h_source.html#l00255">dabs()</a>, <a class="el" href="Objet__U_8h_source.html#l00079">Objet_U::dimension</a>, and <a class="el" href="Double_8h_source.html#l00075">DMINFLOAT</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">double</span> psc=0, norm=0;
  <span class="keywordtype">int</span> dimension=<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>, comp;
  <span class="keywordflow">for</span>(comp=0; comp&lt;dimension; comp++)
    {
      psc+=gradi(comp)*normales(face,comp);
      norm+=normales(face,comp)*normales(face,comp);
    }
<span class="comment">// psc/=norm; // Fixed bug: Arithmetic exception</span>
  <span class="keywordflow">if</span> (<a class="code" href="Double_8h.html#aaecd4ca8a2fe69cc6568af2938b94d2e">dabs</a>(norm)&gt;=<a class="code" href="Double_8h.html#a0a3fffa6d17ad8f7de4bb337c6266561">DMINFLOAT</a>) psc/=norm;
  <span class="keywordflow">for</span>(comp=0; comp&lt;dimension; comp++)
    {
      gradi(comp)-=psc*normales(face,comp);
    }
  psc=0;
<span class="comment">// for(comp=0; comp&lt;dimension; comp++)</span>
<span class="comment">// {</span>
<span class="comment">// psc+=gradi(comp)*normales(face,comp);</span>
<span class="comment">// }</span>
<span class="comment">// assert(psc &lt; 1.e-10);</span>
}
</pre></div>
</div>
</div>
<a class="anchor" id="ab68e858c58953d7d372ea8deee92fc6a"></a><!-- doxytag: member="AssembleurPP1BUtil.cpp::range" ref="ab68e858c58953d7d372ea8deee92fc6a" args="(int &amp;i, int &amp;n, int &amp;j, int &amp;m, Matrice_Morse &amp;ARR, Matrice_Morse &amp;ARV, Matrice_Morse &amp;AVR, Matrice_Morse &amp;AVV, double coeff)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void range </td>
          <td>(</td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;&#160;</td>
          <td class="paramname"><em>ARR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;&#160;</td>
          <td class="paramname"><em>ARV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;&#160;</td>
          <td class="paramname"><em>AVR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;&#160;</td>
          <td class="paramname"><em>AVV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>coeff</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00588">588</a> of file <a class="el" href="AssembleurPP1BUtil_8cpp_source.html">AssembleurPP1BUtil.cpp</a>.</p>

<p>References <a class="el" href="Champ__P1iP1B__implementation_8cpp_source.html#l00331">coeff</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">if</span>(i&lt;n)
    <span class="keywordflow">if</span>(j&lt;m)
      ARR(i,j)+=<a class="code" href="Champ__P1iP1B__implementation_8cpp.html#aa8c8f49390c3cf7c702d71a71bc977e3">coeff</a>;
    <span class="keywordflow">else</span>
      ARV(i,j-m)+=<a class="code" href="Champ__P1iP1B__implementation_8cpp.html#aa8c8f49390c3cf7c702d71a71bc977e3">coeff</a>;
  <span class="keywordflow">else</span> <span class="keywordflow">if</span>(j&lt;m)
    AVR(i-n,j)+=<a class="code" href="Champ__P1iP1B__implementation_8cpp.html#aa8c8f49390c3cf7c702d71a71bc977e3">coeff</a>;
  <span class="keywordflow">else</span>
    AVV(i-n,j-m)+=<a class="code" href="Champ__P1iP1B__implementation_8cpp.html#aa8c8f49390c3cf7c702d71a71bc977e3">coeff</a>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="afd0a249a235b161c5267e7574e199a82"></a><!-- doxytag: member="AssembleurPP1BUtil.cpp::remplir_sommets" ref="afd0a249a235b161c5267e7574e199a82" args="(const Zone_VEF &amp;zone_VEF, int face, int elem1, int elem2, ArrOfInt &amp;sommets, ArrOfInt &amp;faces_op1, ArrOfInt &amp;faces_op2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void remplir_sommets </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classZone__VEF.html">Zone_VEF</a> &amp;&#160;</td>
          <td class="paramname"><em>zone_VEF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>elem1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>elem2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>sommets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>faces_op1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>faces_op2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00349">349</a> of file <a class="el" href="AssembleurPP1BUtil_8cpp_source.html">AssembleurPP1BUtil.cpp</a>.</p>

<p>References <a class="el" href="EntreeSortie_8h_source.html#l00032">Cerr</a>, <a class="el" href="Objet__U_8h_source.html#l00079">Objet_U::dimension</a>, <a class="el" href="Zone_8cpp_source.html#l00262">Zone::domaine()</a>, <a class="el" href="Zone__VF_8h_source.html#l00574">Zone_VF::elem_faces()</a>, <a class="el" href="Process_8cpp_source.html#l00223">Process::exit()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00046">face_associee</a>, <a class="el" href="Zone__VF_8h_source.html#l00609">Zone_VF::face_sommets()</a>, <a class="el" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>, <a class="el" href="Domaine_8h_source.html#l00613">Domaine::get_renum_som_perio()</a>, <a class="el" href="Zone_8h_source.html#l00402">Zone::les_elems()</a>, and <a class="el" href="Zone__dis__base_8h_source.html#l00106">Zone_dis_base::zone()</a>.</p>

<p>Referenced by <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l02968">assemblerP0P1()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l02655">assemblerP0Pa()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l02247">assemblerP1P1()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l02803">assemblerP1Pa()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l02477">assemblerPaPa()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l03048">updateP0P1()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l02730">updateP0Pa()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l02339">updateP1P1()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l02885">updateP1Pa()</a>, and <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l02567">updatePaPa()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">int</span> dplusun=<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>+1;
  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; elem_som = zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#ac115e8342be89afb882b7b61cc343267" title="Renvoie le tableau des sommets des elements.">les_elems</a>();
  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; face_som = zone_VEF.<a class="code" href="classZone__VF.html#a298e73b18e17da55f421b1fb0879bd46" title="renvoie le numero du ieme sommet de la face num_face.">face_sommets</a>();
  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; elem_faces = zone_VEF.<a class="code" href="classZone__VF.html#a067e462dcd3ab92b0f6d945b19e4eb37" title="renvoie le numero de le ieme face de la maille num_elem la facon dont ces faces sont numerotees est l...">elem_faces</a>();
  <span class="keyword">const</span> <a class="code" href="classDomaine.html" title="Classe Domaine Un Domaine represente le domaine (spatial) de resolution d&#39;un Probleme. Un Domaine a un Nom, il est constitue d&#39;une ou plusieurs Zone qui peuvent etre eventuellement decoupees en Sous_Zone. Un Domaine porte l&#39;ensemble des sommets utilises par ses Zones. On peut vouloir resoudre des problemes de type different sur plusieurs domaines, geometriquement les domaines sont alors couples par des surfaces qu&#39;on appelle Raccord.">Domaine</a>&amp; dom=zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#a379ad2206b5a13a4f4f3df6d44c7546a" title="Renvoie le domaine dont la zone fait partie. (version const)">domaine</a>();
  <span class="keywordtype">int</span> i,j,k;
  <span class="keywordflow">for</span>(i=0; i&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>; i++)
    sommets(i)=dom.<a class="code" href="classDomaine.html#a37cc657f1907d53b0d5a573da862af80">get_renum_som_perio</a>(face_som(face,i));
  <span class="keywordflow">if</span>(elem1!=-1)
    {
      <span class="keywordtype">int</span> ok=0;
      <span class="keywordflow">for</span>(i=0; i&lt;dplusun; i++)
        <span class="keywordflow">if</span>( (elem_faces(elem1,i)==face) ||
            (elem_faces(elem1,i)==<a class="code" href="AssembleurPP1BUtil_8cpp.html#a3e374d53ebc7860e1c2f0b7906f2936d">face_associee</a>) )
          {
            sommets(Objet_U::dimension)=
              dom.<a class="code" href="classDomaine.html#a37cc657f1907d53b0d5a573da862af80">get_renum_som_perio</a>(elem_som(elem1, i));
            faces_op1(Objet_U::dimension)=face;
            faces_op2(Objet_U::dimension)=-1;
            ok=1;
          }
        <span class="keywordflow">else</span>
          {
            j=dom.<a class="code" href="classDomaine.html#a37cc657f1907d53b0d5a573da862af80">get_renum_som_perio</a>(elem_som(elem1, i));
            <span class="keywordflow">for</span>(k=0; k&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>; k++)
              <span class="keywordflow">if</span>(j==sommets(k))
                faces_op1(k)=elem_faces(elem1, i);
          }
      <span class="keywordflow">if</span> (ok!=1)
        {
          <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;The discretization used has a P1 component&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
          <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;which is not available to deal your mesh.&quot;</span> &lt;&lt; finl;
          <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;The mesh with this discretization must contain only &quot;</span>;
          <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; (Objet_U::dimension==2?<span class="stringliteral">&quot;triangles&quot;</span>:<span class="stringliteral">&quot;tetraedras&quot;</span>) &lt;&lt; <span class="stringliteral">&quot;.&quot;</span> &lt;&lt; finl;
          <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">Process::exit</a>();
        }
    }
  <span class="keywordflow">else</span>
    {
      <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;pas prevu ... &quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
      <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">Process::exit</a>();
    }
  <span class="keywordflow">if</span>(elem2!=-1)
    {
<span class="comment">// int ok=0;</span>
      <span class="keywordflow">for</span>(i=0; i&lt;dplusun; i++)
        <span class="keywordflow">if</span>( (elem_faces(elem2,i)==face)||
            (elem_faces(elem2,i)==<a class="code" href="AssembleurPP1BUtil_8cpp.html#a3e374d53ebc7860e1c2f0b7906f2936d">face_associee</a>) )
          {
            sommets(dplusun)=dom.<a class="code" href="classDomaine.html#a37cc657f1907d53b0d5a573da862af80">get_renum_som_perio</a>(elem_som(elem2, i));
            faces_op2(dplusun)=face;
            faces_op1(dplusun)=-1;
<span class="comment">// ok=1;</span>
          }
        <span class="keywordflow">else</span>
          {
            j=dom.<a class="code" href="classDomaine.html#a37cc657f1907d53b0d5a573da862af80">get_renum_som_perio</a>(elem_som(elem2, i));
            <span class="keywordflow">for</span>(k=0; k&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>; k++)
              <span class="keywordflow">if</span>(j==sommets(k))
                faces_op2(k)=elem_faces(elem2, i);
          }
<span class="comment">// A cause de mise en commentaire de ok=1 assert(ok==1);</span>
    }
  <span class="keywordflow">else</span>
    {
      sommets(dplusun)=-1;
      faces_op2(dplusun)=-1;
      faces_op1(dplusun)=-1;
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="acff816d35f8d4ce978f860e0cd958b8a"></a><!-- doxytag: member="AssembleurPP1BUtil.cpp::sort" ref="acff816d35f8d4ce978f860e0cd958b8a" args="(ArrOfInt &amp;sommets, ArrOfInt &amp;faces_op1, ArrOfInt &amp;faces_op2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void sort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>sommets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>faces_op1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>faces_op2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00286">286</a> of file <a class="el" href="AssembleurPP1BUtil_8cpp_source.html">AssembleurPP1BUtil.cpp</a>.</p>

<p>References <a class="el" href="ArrOfInt_8h_source.html#l00342">ArrOfInt::size_array()</a>, and <a class="el" href="Nom_8cpp_source.html#l00040">sz</a>.</p>

<p>Referenced by <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l02968">assemblerP0P1()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l02247">assemblerP1P1()</a>, <a class="el" href="Zone__CoviMAC_8cpp_source.html#l00837">Zone_CoviMAC::fgrad()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l03048">updateP0P1()</a>, and <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l02339">updateP1P1()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">int</span> <a class="code" href="Nom_8cpp.html#a0e1ea19fb9fa7881d15d84eff4c090e1">sz</a>=sommets.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>();
  <span class="keywordflow">if</span>(sommets(sz-1)==-1) sz--;
  <span class="keywordtype">int</span> i,j;
  <span class="keywordflow">for</span>(i=0; i&lt;<a class="code" href="Nom_8cpp.html#a0e1ea19fb9fa7881d15d84eff4c090e1">sz</a>; i++)
    <span class="keywordflow">for</span>(j=i; j&lt;<a class="code" href="Nom_8cpp.html#a0e1ea19fb9fa7881d15d84eff4c090e1">sz</a>; j++)
      <span class="keywordflow">if</span>(sommets(i)&gt;sommets(j))
        {
          <span class="keywordtype">int</span> tmp=sommets(i);
          sommets(i)=sommets(j);
          sommets(j)=tmp;
          tmp=faces_op1(i);
          faces_op1(i)=faces_op1(j);
          faces_op1(j)=tmp;
          tmp=faces_op2(i);
          faces_op2(i)=faces_op2(j);
          faces_op2(j)=tmp;
        }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a3117b050530c46b4a15b6ab9ce6d0b41"></a><!-- doxytag: member="AssembleurPP1BUtil.cpp::swap" ref="a3117b050530c46b4a15b6ab9ce6d0b41" args="(int &amp;i, int &amp;j)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void swap </td>
          <td>(</td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00335">335</a> of file <a class="el" href="AssembleurPP1BUtil_8cpp_source.html">AssembleurPP1BUtil.cpp</a>.</p>

<p>Referenced by <a class="el" href="Polyedre_8cpp_source.html#l00585">Polyedre::ajouter_elements()</a>, <a class="el" href="Raffiner__Simplexes_8cpp_source.html#l00512">build_edges()</a>, <a class="el" href="Tetraedre_8cpp_source.html#l00129">Tetraedre::contient()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l01241">contribuer_matrice_NeumannPaPa()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l01398">contribuer_matrice_SymetriePaPa()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00748">contribuer_matricePaPa()</a>, <a class="el" href="Zone__CoviMAC_8cpp_source.html#l00341">Zone_CoviMAC::discretiser()</a>, <a class="el" href="Matrice__Morse_8h_source.html#l00245">Matrice_Morse::operator()()</a>, <a class="el" href="Raffiner__Simplexes_8cpp_source.html#l00788">Raffiner_Simplexes::refine_domain()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l01319">update_matrice_NeumannPaPa()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l01478">update_matrice_SymetriePaPa()</a>, and <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00843">update_matricePaPa()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">int</span> k=i;
  i=j;
  j=k;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a1aa97c31d5b8f95ae899f599d606a1da"></a><!-- doxytag: member="AssembleurPP1BUtil.cpp::update_matrice_NeumannP0P1" ref="a1aa97c31d5b8f95ae899f599d606a1da" args="(const Zone_VEF &amp;zone_VEF, const DoubleTab &amp;inverse_quantitee_entrelacee, int face, int elem, ArrOfInt &amp;sommets, ArrOfInt &amp;faces_op1, const ArrOfDouble &amp;coef_som, Matrice_Morse &amp;ARR, Matrice_Morse &amp;ARV, Matrice_Morse &amp;AVR, Matrice_Morse &amp;AVV)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void update_matrice_NeumannP0P1 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classZone__VEF.html">Zone_VEF</a> &amp;&#160;</td>
          <td class="paramname"><em>zone_VEF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>inverse_quantitee_entrelacee</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>sommets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>faces_op1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;&#160;</td>
          <td class="paramname"><em>coef_som</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;&#160;</td>
          <td class="paramname"><em>ARR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;&#160;</td>
          <td class="paramname"><em>ARV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;&#160;</td>
          <td class="paramname"><em>AVR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;&#160;</td>
          <td class="paramname"><em>AVV</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00983">983</a> of file <a class="el" href="AssembleurPP1BUtil_8cpp_source.html">AssembleurPP1BUtil.cpp</a>.</p>

<p>References <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00429">calculer_grad()</a>, <a class="el" href="Objet__U_8h_source.html#l00079">Objet_U::dimension</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00518">dotproduct_array_fois_inverse_quantitee_entrelacee()</a>, <a class="el" href="Zone__VEF_8h_source.html#l00145">Zone_VEF::face_normales()</a>, <a class="el" href="Zone__VF_8h_source.html#l00458">Zone_VF::face_voisins()</a>, <a class="el" href="Zone__dis__base_8h_source.html#l00140">Zone_dis_base::nb_elem()</a>, and <a class="el" href="Zone__dis__base_8h_source.html#l00148">Zone_dis_base::nb_som()</a>.</p>

<p>Referenced by <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l03048">updateP0P1()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; normales = zone_VEF.<a class="code" href="classZone__VEF.html#a5742d75972e4846bf9fbb6ed5715053e">face_normales</a>();
  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; face_voisins = zone_VEF.<a class="code" href="classZone__VF.html#a49d4322f5585a8fa95748ca785b70702" title="renvoie l&#39;element voisin de numface dans la direction i. i=0 : dans le sens oppose de l&#39;axe orthogona...">face_voisins</a>();

  <span class="keywordtype">int</span> nb_elem_tot=zone_VEF.<a class="code" href="classZone__dis__base.html#a790cb2f6bc2928518799e748313d0eb3">nb_elem</a>();
  <span class="keywordtype">int</span> nb_som_tot=zone_VEF.<a class="code" href="classZone__dis__base.html#acc9921d6a29cb719fd832fd573e47825">nb_som</a>();

  <span class="keywordtype">int</span> dimension=<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>,
      dplusun=dimension+1;
  <span class="keywordtype">double</span> unsurdim=1./<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>;
  <span class="keywordtype">double</span> psc;
<span class="comment">// double coeff_som=1./(dimension)/(dplusun);</span>
  <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a> gradi(dimension);
  <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a> gradE(dimension);
  <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;dplusun; i++)
    {
      <span class="keywordtype">int</span> si=sommets(i);
      <a class="code" href="AssembleurPP1BUtil_8cpp.html#a556b82e62a565319fb25218f97cfc50c">calculer_grad</a>(face_voisins, elem, -1,  coef_som,si, faces_op1(i),
                    -1, normales, gradi);
      <span class="keywordflow">if</span>(faces_op1(i)!=face)
        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> comp=0; comp&lt;dimension; comp++)
          gradi(comp)+= normales(face,comp)*unsurdim;
      <span class="keywordflow">for</span>(<span class="keywordtype">int</span> k=0; k&lt;dimension; k++)
        gradE(k)=normales(face,k);
      psc=<a class="code" href="AssembleurPP1BUtil_8cpp.html#a828055cfc33e4c56db8e2f5beb059862">dotproduct_array_fois_inverse_quantitee_entrelacee</a>(gradi,gradE,
                                                             inverse_quantitee_entrelacee,face);
      <span class="keywordflow">if</span>(elem&lt;nb_elem_tot)
        <span class="keywordflow">if</span>(si&lt;nb_som_tot)
          ARR(elem,si)+=psc;
        <span class="keywordflow">else</span>
          ARV(elem,si-nb_som_tot)+=psc;
      <span class="keywordflow">else</span> <span class="keywordflow">if</span>(si&lt;nb_som_tot)
        AVR(elem-nb_elem_tot,si)+=psc;
      <span class="keywordflow">else</span>
        AVV(elem-nb_elem_tot,si-nb_som_tot)+=psc;
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a45b45851ba59992d7eb7a25c002a9f73"></a><!-- doxytag: member="AssembleurPP1BUtil.cpp::update_matrice_NeumannP0Pa" ref="a45b45851ba59992d7eb7a25c002a9f73" args="(const Zone_VEF_PreP1b &amp;zone_VEF, const DoubleTab &amp;inverse_quantitee_entrelacee, int face, int elem, ArrOfInt &amp;sommets, ArrOfInt &amp;faces_op1, Matrice_Morse &amp;ARR, Matrice_Morse &amp;ARV, Matrice_Morse &amp;AVR, Matrice_Morse &amp;AVV)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void update_matrice_NeumannP0Pa </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a> &amp;&#160;</td>
          <td class="paramname"><em>zone_VEF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>inverse_quantitee_entrelacee</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>sommets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>faces_op1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;&#160;</td>
          <td class="paramname"><em>ARR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;&#160;</td>
          <td class="paramname"><em>ARV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;&#160;</td>
          <td class="paramname"><em>AVR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;&#160;</td>
          <td class="paramname"><em>AVV</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l01765">1765</a> of file <a class="el" href="AssembleurPP1BUtil_8cpp_source.html">AssembleurPP1BUtil.cpp</a>.</p>

<p>References <a class="el" href="Zone_8h_source.html#l01290">Zone::aretes_som()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00462">calculer_grad_arete()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00306">chercher_arete()</a>, <a class="el" href="Zone_8h_source.html#l01282">Zone::elem_aretes()</a>, <a class="el" href="Zone__VEF_8h_source.html#l00145">Zone_VEF::face_normales()</a>, <a class="el" href="Zone__VF_8h_source.html#l00458">Zone_VF::face_voisins()</a>, <a class="el" href="Zone__VEF__PreP1b_8h_source.html#l00090">Zone_VEF_PreP1b::get_ok_arete()</a>, <a class="el" href="Zone_8h_source.html#l01258">Zone::nb_aretes()</a>, <a class="el" href="Zone_8h_source.html#l00300">Zone::nb_elem()</a>, and <a class="el" href="Zone__dis__base_8h_source.html#l00106">Zone_dis_base::zone()</a>.</p>

<p>Referenced by <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l02730">updateP0Pa()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; elem_aretes=zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#a1e1e86ef5b088c4d33d42cd38a967b4a" title="renvoie le numero de la jeme arete du ieme element.">elem_aretes</a>();
  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; aretes_som=zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#affa60690e1b372fa4c01d6088267dbe4" title="renvoie le tableau de connectivite aretes/sommets.">aretes_som</a>();
  <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; ok_arete=zone_VEF.<a class="code" href="classZone__VEF__PreP1b.html#a83771f784d487e346b2ef22a389472a2">get_ok_arete</a>();
  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; face_voisins=zone_VEF.<a class="code" href="classZone__VF.html#a49d4322f5585a8fa95748ca785b70702" title="renvoie l&#39;element voisin de numface dans la direction i. i=0 : dans le sens oppose de l&#39;axe orthogona...">face_voisins</a>();
  <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; normales = zone_VEF.<a class="code" href="classZone__VEF.html#a5742d75972e4846bf9fbb6ed5715053e">face_normales</a>();
  <span class="keywordtype">int</span> nb_aretes_tot=zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#a3e3b48691911fd85574c7bc10a1a4fb8" title="renvoie le nombre d&#39;aretes reelles.">nb_aretes</a>();
  <span class="keywordtype">int</span> nb_elem_tot=zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#a7f249429803b27139a1c54436f6164a5" title="Renvoie le nombre d&#39;elements de la zone.">nb_elem</a>();

  <span class="keywordtype">int</span> i, j;
  <span class="keywordtype">double</span> psc;
  <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a> grad1(3);
  <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a> grad2(3);
  <span class="keywordflow">for</span>(i=0; i&lt;3; i++)
    {
      <span class="keywordtype">int</span> si=sommets(i);
      <span class="keywordflow">for</span>(j=i+1; j&lt;4; j++)
        {
          <span class="keywordtype">int</span> sj=sommets(j);
          <span class="keywordtype">int</span> arete1;
          arete1 = <a class="code" href="AssembleurPP1BUtil_8cpp.html#ae1c00f10faaf4da3ffdea8f881565a1b">chercher_arete</a>(zone_VEF,elem, si, sj,
                                  elem_aretes, aretes_som);
          <span class="keywordflow">if</span>(ok_arete(arete1))
            {
              <a class="code" href="AssembleurPP1BUtil_8cpp.html#aa26334c33fd016e71cbab82de7ef2fe5">calculer_grad_arete</a>(face, face_voisins, i, j,
                                  elem, -1,
                                  faces_op1(i), -1,
                                  faces_op1(j), -1,
                                  normales, grad1);
              psc=0;
              <span class="keywordflow">for</span>(<span class="keywordtype">int</span> comp=0; comp&lt;3; comp++)
                psc+=grad1(comp)*normales(face, comp)
                     *(-inverse_quantitee_entrelacee(face,comp));
              <span class="keywordflow">if</span>(elem&lt;nb_elem_tot)
                <span class="keywordflow">if</span>(arete1&lt;nb_aretes_tot)
                  ARR(elem,arete1)+=psc;
                <span class="keywordflow">else</span>
                  ARV(elem,arete1-nb_aretes_tot)+=psc;
              <span class="keywordflow">else</span> <span class="keywordflow">if</span>(arete1&lt;nb_aretes_tot)
                AVR(elem-nb_elem_tot,arete1)+=psc;
              <span class="keywordflow">else</span>
                AVV(elem-nb_elem_tot,arete1-nb_aretes_tot)+=psc;
            }
        }
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="affe9938bfd355c4e19b608c286c0293b"></a><!-- doxytag: member="AssembleurPP1BUtil.cpp::update_matrice_NeumannP1P1" ref="affe9938bfd355c4e19b608c286c0293b" args="(const Zone_VEF &amp;zone_VEF, const DoubleTab &amp;inverse_quantitee_entrelacee, int face, int elem, ArrOfInt &amp;sommets, ArrOfInt &amp;faces_op1, const ArrOfDouble &amp;coef_som, Matrice_Morse &amp;ARR, Matrice_Morse &amp;ARV, Matrice_Morse &amp;AVR, Matrice_Morse &amp;AVV)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void update_matrice_NeumannP1P1 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classZone__VEF.html">Zone_VEF</a> &amp;&#160;</td>
          <td class="paramname"><em>zone_VEF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>inverse_quantitee_entrelacee</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>sommets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>faces_op1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;&#160;</td>
          <td class="paramname"><em>coef_som</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;&#160;</td>
          <td class="paramname"><em>ARR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;&#160;</td>
          <td class="paramname"><em>ARV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;&#160;</td>
          <td class="paramname"><em>AVR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;&#160;</td>
          <td class="paramname"><em>AVV</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l01084">1084</a> of file <a class="el" href="AssembleurPP1BUtil_8cpp_source.html">AssembleurPP1BUtil.cpp</a>.</p>

<p>References <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00429">calculer_grad()</a>, <a class="el" href="Objet__U_8h_source.html#l00079">Objet_U::dimension</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00518">dotproduct_array_fois_inverse_quantitee_entrelacee()</a>, <a class="el" href="Zone__VEF_8h_source.html#l00145">Zone_VEF::face_normales()</a>, <a class="el" href="Zone__VF_8h_source.html#l00458">Zone_VF::face_voisins()</a>, and <a class="el" href="Zone__dis__base_8h_source.html#l00148">Zone_dis_base::nb_som()</a>.</p>

<p>Referenced by <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l02339">updateP1P1()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; normales = zone_VEF.<a class="code" href="classZone__VEF.html#a5742d75972e4846bf9fbb6ed5715053e">face_normales</a>();
  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; face_voisins = zone_VEF.<a class="code" href="classZone__VF.html#a49d4322f5585a8fa95748ca785b70702" title="renvoie l&#39;element voisin de numface dans la direction i. i=0 : dans le sens oppose de l&#39;axe orthogona...">face_voisins</a>();

  <span class="keywordtype">int</span> dimension=<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>,
      dplusun=dimension+1;
  <span class="keywordtype">double</span> unsurdim=1./<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>;
  <span class="keywordtype">double</span> psc;
<span class="comment">// double coeff_som=1./(dimension)/(dplusun);</span>
<span class="comment">// coeff_som*=coeff_som;</span>
  <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a> gradi(dimension);
  <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a> gradj(dimension);
  <span class="keywordtype">int</span> nb_som_tot=zone_VEF.<a class="code" href="classZone__dis__base.html#acc9921d6a29cb719fd832fd573e47825">nb_som</a>();
  <span class="keywordtype">int</span> i,j;
  <span class="keywordflow">for</span>(i=0; i&lt;dplusun; i++)
    {
      <span class="keywordtype">int</span> si=sommets(i);
      <a class="code" href="AssembleurPP1BUtil_8cpp.html#a556b82e62a565319fb25218f97cfc50c">calculer_grad</a>(face_voisins, elem, -1,  coef_som,si, faces_op1(i),
                    -1, normales, gradi);
      <span class="keywordflow">if</span>(faces_op1(i)!=face)
        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> comp=0; comp&lt;dimension; comp++)
          gradi(comp)+= normales(face,comp)*unsurdim;
      <span class="keywordflow">if</span>(si&lt;nb_som_tot)
        ARR(si,si)+=<a class="code" href="AssembleurPP1BUtil_8cpp.html#a828055cfc33e4c56db8e2f5beb059862">dotproduct_array_fois_inverse_quantitee_entrelacee</a>(gradi,gradi,
                                                                       inverse_quantitee_entrelacee,face);
      <span class="keywordflow">for</span>(j=i+1; j&lt;dplusun; j++)
        {
          <span class="keywordtype">int</span> sj=sommets(j);
          <a class="code" href="AssembleurPP1BUtil_8cpp.html#a556b82e62a565319fb25218f97cfc50c">calculer_grad</a>(face_voisins, elem, -1,  coef_som,sj, faces_op1(j),
                        -1, normales, gradj);
          <span class="keywordflow">if</span>(faces_op1(j)!=face)
            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> comp=0; comp&lt;dimension; comp++)
              gradj(comp)+= normales(face,comp)*unsurdim;
          psc=<a class="code" href="AssembleurPP1BUtil_8cpp.html#a828055cfc33e4c56db8e2f5beb059862">dotproduct_array_fois_inverse_quantitee_entrelacee</a>(gradi,gradj,inverse_quantitee_entrelacee,face);
          <span class="keywordflow">if</span>(si&lt;nb_som_tot)
            <span class="keywordflow">if</span>(sj&lt;nb_som_tot)
              ARR(si,sj)+=psc;
            <span class="keywordflow">else</span>
              ARV(si,sj-nb_som_tot)+=psc;
          <span class="keywordflow">else</span> <span class="keywordflow">if</span>(sj&lt;nb_som_tot)
            AVR(si-nb_som_tot,sj)+=psc;
          <span class="keywordflow">else</span>
            AVV(si-nb_som_tot,sj-nb_som_tot)+=psc;
        }
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a7da454ba757d1b7ed7ccc39954e6cab5"></a><!-- doxytag: member="AssembleurPP1BUtil.cpp::update_matrice_NeumannP1Pa" ref="a7da454ba757d1b7ed7ccc39954e6cab5" args="(const Zone_VEF_PreP1b &amp;zone_VEF, const DoubleTab &amp;inverse_quantitee_entrelacee, int face, int elem, ArrOfInt &amp;sommets, ArrOfInt &amp;faces_op1, const ArrOfDouble &amp;coef_som, Matrice_Morse &amp;ARR, Matrice_Morse &amp;ARV, Matrice_Morse &amp;AVR, Matrice_Morse &amp;AVV)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void update_matrice_NeumannP1Pa </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a> &amp;&#160;</td>
          <td class="paramname"><em>zone_VEF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>inverse_quantitee_entrelacee</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>sommets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>faces_op1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;&#160;</td>
          <td class="paramname"><em>coef_som</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;&#160;</td>
          <td class="paramname"><em>ARR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;&#160;</td>
          <td class="paramname"><em>ARV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;&#160;</td>
          <td class="paramname"><em>AVR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;&#160;</td>
          <td class="paramname"><em>AVV</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l02025">2025</a> of file <a class="el" href="AssembleurPP1BUtil_8cpp_source.html">AssembleurPP1BUtil.cpp</a>.</p>

<p>References <a class="el" href="Zone_8h_source.html#l01290">Zone::aretes_som()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00429">calculer_grad()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00462">calculer_grad_arete()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00306">chercher_arete()</a>, <a class="el" href="Objet__U_8h_source.html#l00079">Objet_U::dimension</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00518">dotproduct_array_fois_inverse_quantitee_entrelacee()</a>, <a class="el" href="Zone_8h_source.html#l01282">Zone::elem_aretes()</a>, <a class="el" href="Zone__VEF_8h_source.html#l00145">Zone_VEF::face_normales()</a>, <a class="el" href="Zone__VF_8h_source.html#l00458">Zone_VF::face_voisins()</a>, <a class="el" href="Zone__VEF__PreP1b_8h_source.html#l00090">Zone_VEF_PreP1b::get_ok_arete()</a>, <a class="el" href="Zone_8h_source.html#l01258">Zone::nb_aretes()</a>, <a class="el" href="Zone_8cpp_source.html#l00586">Zone::nb_som()</a>, and <a class="el" href="Zone__dis__base_8h_source.html#l00106">Zone_dis_base::zone()</a>.</p>

<p>Referenced by <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l02885">updateP1Pa()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">int</span> dimension=<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>;
<span class="comment">// dplusun=dimension+1;</span>
<span class="comment">// double coeff_som=1./(dimension)/(dplusun);</span>
  <span class="keywordtype">double</span> unsurdim=1./<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>;
  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; elem_aretes=zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#a1e1e86ef5b088c4d33d42cd38a967b4a" title="renvoie le numero de la jeme arete du ieme element.">elem_aretes</a>();
  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; aretes_som=zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#affa60690e1b372fa4c01d6088267dbe4" title="renvoie le tableau de connectivite aretes/sommets.">aretes_som</a>();
  <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; ok_arete=zone_VEF.<a class="code" href="classZone__VEF__PreP1b.html#a83771f784d487e346b2ef22a389472a2">get_ok_arete</a>();
  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; face_voisins=zone_VEF.<a class="code" href="classZone__VF.html#a49d4322f5585a8fa95748ca785b70702" title="renvoie l&#39;element voisin de numface dans la direction i. i=0 : dans le sens oppose de l&#39;axe orthogona...">face_voisins</a>();
  <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; normales = zone_VEF.<a class="code" href="classZone__VEF.html#a5742d75972e4846bf9fbb6ed5715053e">face_normales</a>();
  <span class="keywordtype">int</span> nb_aretes_tot=zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#a3e3b48691911fd85574c7bc10a1a4fb8" title="renvoie le nombre d&#39;aretes reelles.">nb_aretes</a>();
  <span class="keywordtype">int</span> nb_som_tot=zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#ad340f571f81fa5c2e028b88c00b5c2ca" title="Renvoie le nombre de sommets de la zone.">nb_som</a>();

  <span class="keywordtype">int</span> i, j, k;
  <span class="keywordtype">double</span> psc;
  <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a> grad1(3);
  <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a> grad2(3);
  <span class="keywordflow">for</span>(i=0; i&lt;3; i++)
    {
      <span class="keywordtype">int</span> si=sommets(i);
      <span class="keywordflow">for</span>(j=i+1; j&lt;4; j++)
        {
          <span class="keywordtype">int</span> sj=sommets(j);
          <span class="keywordtype">int</span> arete1;
          arete1 = <a class="code" href="AssembleurPP1BUtil_8cpp.html#ae1c00f10faaf4da3ffdea8f881565a1b">chercher_arete</a>(zone_VEF,elem, si, sj,
                                  elem_aretes, aretes_som);
          <span class="keywordflow">if</span>(ok_arete(arete1))
            {
              <a class="code" href="AssembleurPP1BUtil_8cpp.html#aa26334c33fd016e71cbab82de7ef2fe5">calculer_grad_arete</a>(face, face_voisins, i, j,
                                  elem, -1,
                                  faces_op1(i), -1,
                                  faces_op1(j), -1,
                                  normales, grad1);
              <span class="keywordflow">for</span>(k=0; k&lt;4; k++)
                {
                  <span class="keywordtype">int</span> sk=sommets(k);
                  <a class="code" href="AssembleurPP1BUtil_8cpp.html#a556b82e62a565319fb25218f97cfc50c">calculer_grad</a>(face_voisins, elem, -1,  coef_som,sk,
                                faces_op1(k), -1,
                                normales, grad2);
                  <span class="keywordflow">if</span>(faces_op1(k)!=face)
                    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> comp=0; comp&lt;dimension; comp++)
                      grad2(comp)+= normales(face,comp)*unsurdim;
                  psc=-<a class="code" href="AssembleurPP1BUtil_8cpp.html#a828055cfc33e4c56db8e2f5beb059862">dotproduct_array_fois_inverse_quantitee_entrelacee</a>(grad1,grad2,
                                                                          inverse_quantitee_entrelacee,face);
                  <span class="keywordflow">if</span>(sk&lt;nb_som_tot)
                    <span class="keywordflow">if</span>(arete1&lt;nb_aretes_tot)
                      ARR(sk,arete1)+=psc;
                    <span class="keywordflow">else</span>
                      ARV(sk,arete1-nb_aretes_tot)+=psc;
                  <span class="keywordflow">else</span> <span class="keywordflow">if</span>(arete1&lt;nb_aretes_tot)
                    AVR(sk-nb_som_tot,arete1)+=psc;
                  <span class="keywordflow">else</span>
                    AVV(sk-nb_som_tot,arete1-nb_aretes_tot)+=psc;
                }
            }
        }
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a6a26a390dab2336113f60275e5978aaf"></a><!-- doxytag: member="AssembleurPP1BUtil.cpp::update_matrice_NeumannPaPa" ref="a6a26a390dab2336113f60275e5978aaf" args="(const Zone_VEF_PreP1b &amp;zone_VEF, const DoubleTab &amp;inverse_quantitee_entrelacee, int face, int elem, ArrOfInt &amp;sommets, ArrOfInt &amp;faces_op1, Matrice_Morse &amp;ARR, Matrice_Morse &amp;ARV, Matrice_Morse &amp;AVR, Matrice_Morse &amp;AVV)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void update_matrice_NeumannPaPa </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a> &amp;&#160;</td>
          <td class="paramname"><em>zone_VEF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>inverse_quantitee_entrelacee</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>sommets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>faces_op1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;&#160;</td>
          <td class="paramname"><em>ARR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;&#160;</td>
          <td class="paramname"><em>ARV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;&#160;</td>
          <td class="paramname"><em>AVR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;&#160;</td>
          <td class="paramname"><em>AVV</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l01319">1319</a> of file <a class="el" href="AssembleurPP1BUtil_8cpp_source.html">AssembleurPP1BUtil.cpp</a>.</p>

<p>References <a class="el" href="Zone_8h_source.html#l01290">Zone::aretes_som()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00462">calculer_grad_arete()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00306">chercher_arete()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00518">dotproduct_array_fois_inverse_quantitee_entrelacee()</a>, <a class="el" href="Zone_8h_source.html#l01282">Zone::elem_aretes()</a>, <a class="el" href="Zone__VEF_8h_source.html#l00145">Zone_VEF::face_normales()</a>, <a class="el" href="Zone__VF_8h_source.html#l00458">Zone_VF::face_voisins()</a>, <a class="el" href="Zone__VEF__PreP1b_8h_source.html#l00090">Zone_VEF_PreP1b::get_ok_arete()</a>, <a class="el" href="Zone_8h_source.html#l01258">Zone::nb_aretes()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00335">swap()</a>, and <a class="el" href="Zone__dis__base_8h_source.html#l00106">Zone_dis_base::zone()</a>.</p>

<p>Referenced by <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l02567">updatePaPa()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; elem_aretes=zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#a1e1e86ef5b088c4d33d42cd38a967b4a" title="renvoie le numero de la jeme arete du ieme element.">elem_aretes</a>();
  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; aretes_som=zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#affa60690e1b372fa4c01d6088267dbe4" title="renvoie le tableau de connectivite aretes/sommets.">aretes_som</a>();
  <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; ok_arete=zone_VEF.<a class="code" href="classZone__VEF__PreP1b.html#a83771f784d487e346b2ef22a389472a2">get_ok_arete</a>();
  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; face_voisins=zone_VEF.<a class="code" href="classZone__VF.html#a49d4322f5585a8fa95748ca785b70702" title="renvoie l&#39;element voisin de numface dans la direction i. i=0 : dans le sens oppose de l&#39;axe orthogona...">face_voisins</a>();
  <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; normales = zone_VEF.<a class="code" href="classZone__VEF.html#a5742d75972e4846bf9fbb6ed5715053e">face_normales</a>();
  <span class="keywordtype">int</span> nb_aretes_tot=zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#a3e3b48691911fd85574c7bc10a1a4fb8" title="renvoie le nombre d&#39;aretes reelles.">nb_aretes</a>();

  <span class="keywordtype">int</span> i, j, k, l;
  <span class="keywordtype">double</span> psc;
  <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a> grad1(3);
  <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a> grad2(3);
  <span class="keywordflow">for</span>(i=0; i&lt;3; i++)
    {
      <span class="keywordtype">int</span> si=sommets(i);
      <span class="keywordflow">for</span>(j=i+1; j&lt;4; j++)
        {
          <span class="keywordtype">int</span> sj=sommets(j);
          <span class="keywordtype">int</span> arete1;
          arete1 = <a class="code" href="AssembleurPP1BUtil_8cpp.html#ae1c00f10faaf4da3ffdea8f881565a1b">chercher_arete</a>(zone_VEF,elem, si, sj,
                                  elem_aretes, aretes_som);
          <span class="keywordflow">if</span>(ok_arete(arete1))
            {
              <a class="code" href="AssembleurPP1BUtil_8cpp.html#aa26334c33fd016e71cbab82de7ef2fe5">calculer_grad_arete</a>(face, face_voisins, i, j,
                                  elem, -1,
                                  faces_op1(i), -1,
                                  faces_op1(j), -1,
                                  normales, grad1);
              <span class="keywordflow">if</span>(arete1&lt;nb_aretes_tot)
                ARR(arete1,arete1)+=<a class="code" href="AssembleurPP1BUtil_8cpp.html#a828055cfc33e4c56db8e2f5beb059862">dotproduct_array_fois_inverse_quantitee_entrelacee</a>(grad1,grad1,
                                                                                       inverse_quantitee_entrelacee,face);
              <span class="keywordtype">int</span> jj=j;
              <span class="keywordflow">for</span>(k=i; k&lt;3; k++)
                {
                  <span class="keywordtype">int</span> sk=sommets(k);
                  <span class="keywordflow">for</span>(l=jj+1; l&lt;4; l++)
                    {
                      <span class="keywordtype">int</span> sl=sommets(l);
                      <span class="keywordtype">int</span> arete2= <a class="code" href="AssembleurPP1BUtil_8cpp.html#ae1c00f10faaf4da3ffdea8f881565a1b">chercher_arete</a>(zone_VEF,elem, sl, sk,
                                                 elem_aretes,
                                                 aretes_som);
                      assert(arete2!=-1);
                      <span class="keywordflow">if</span>(ok_arete(arete2))
                        {
                          <a class="code" href="AssembleurPP1BUtil_8cpp.html#aa26334c33fd016e71cbab82de7ef2fe5">calculer_grad_arete</a>(face, face_voisins, k, l,
                                              elem, -1,
                                              faces_op1(k), -1,
                                              faces_op1(l), -1,
                                              normales, grad2);
                          psc=<a class="code" href="AssembleurPP1BUtil_8cpp.html#a828055cfc33e4c56db8e2f5beb059862">dotproduct_array_fois_inverse_quantitee_entrelacee</a>(grad1,grad2,
                                                                                 inverse_quantitee_entrelacee,face);
                          <span class="keywordtype">int</span> tmp=arete1;
                          <span class="keywordflow">if</span>(arete1&gt;arete2) <a class="code" href="AssembleurPP1BUtil_8cpp.html#a3117b050530c46b4a15b6ab9ce6d0b41">swap</a>(arete1, arete2);
                          <span class="keywordflow">if</span>(arete1&lt;nb_aretes_tot)
                            <span class="keywordflow">if</span>(arete2&lt;nb_aretes_tot)
                              ARR(arete1,arete2)+=psc;
                            <span class="keywordflow">else</span>
                              ARV(arete1,arete2-nb_aretes_tot)+=psc;
                          <span class="keywordflow">else</span> <span class="keywordflow">if</span>(arete2&lt;nb_aretes_tot)
                            AVR(arete1-nb_aretes_tot,arete2)+=psc;
                          <span class="keywordflow">else</span>
                            AVV(arete1-nb_aretes_tot,arete2-nb_aretes_tot)+=psc;
                          arete1=tmp;
                        }
                    }
                  jj=k+1;
                }
            }
        }
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="ade1c92b286a861f3920664b658ba3fb1"></a><!-- doxytag: member="AssembleurPP1BUtil.cpp::update_matrice_SymetrieP1P1" ref="ade1c92b286a861f3920664b658ba3fb1" args="(const Zone_VEF &amp;zone_VEF, const DoubleTab &amp;inverse_quantitee_entrelacee, int face, int elem, ArrOfInt &amp;sommets, ArrOfInt &amp;faces_op1, const ArrOfDouble &amp;coef_som, Matrice_Morse &amp;ARR, Matrice_Morse &amp;ARV, Matrice_Morse &amp;AVR, Matrice_Morse &amp;AVV)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void update_matrice_SymetrieP1P1 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classZone__VEF.html">Zone_VEF</a> &amp;&#160;</td>
          <td class="paramname"><em>zone_VEF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>inverse_quantitee_entrelacee</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>sommets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>faces_op1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;&#160;</td>
          <td class="paramname"><em>coef_som</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;&#160;</td>
          <td class="paramname"><em>ARR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;&#160;</td>
          <td class="paramname"><em>ARV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;&#160;</td>
          <td class="paramname"><em>AVR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;&#160;</td>
          <td class="paramname"><em>AVV</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l01191">1191</a> of file <a class="el" href="AssembleurPP1BUtil_8cpp_source.html">AssembleurPP1BUtil.cpp</a>.</p>

<p>References <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00429">calculer_grad()</a>, <a class="el" href="Objet__U_8h_source.html#l00079">Objet_U::dimension</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00518">dotproduct_array_fois_inverse_quantitee_entrelacee()</a>, <a class="el" href="Zone__VEF_8h_source.html#l00145">Zone_VEF::face_normales()</a>, <a class="el" href="Zone__VF_8h_source.html#l00458">Zone_VF::face_voisins()</a>, <a class="el" href="Zone__dis__base_8h_source.html#l00148">Zone_dis_base::nb_som()</a>, and <a class="el" href="Champ__Generique__Transformation_8cpp_source.html#l00456">projette()</a>.</p>

<p>Referenced by <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l02339">updateP1P1()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; normales = zone_VEF.<a class="code" href="classZone__VEF.html#a5742d75972e4846bf9fbb6ed5715053e">face_normales</a>();
  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; face_voisins = zone_VEF.<a class="code" href="classZone__VF.html#a49d4322f5585a8fa95748ca785b70702" title="renvoie l&#39;element voisin de numface dans la direction i. i=0 : dans le sens oppose de l&#39;axe orthogona...">face_voisins</a>();

  <span class="keywordtype">int</span> dimension=<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>,
      dplusun=dimension+1;
  <span class="keywordtype">double</span> psc;
<span class="comment">// double coeff_som=1./(dimension)/(dplusun);</span>
<span class="comment">// coeff_som*=coeff_som;</span>
  <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a> gradi(dimension);
  <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a> gradj(dimension);
  <span class="keywordtype">int</span> nb_som_tot=zone_VEF.<a class="code" href="classZone__dis__base.html#acc9921d6a29cb719fd832fd573e47825">nb_som</a>();
  <span class="keywordtype">int</span> i,j;
  <span class="keywordflow">for</span>(i=0; i&lt;dplusun; i++)
    {
      <span class="keywordtype">int</span> si=sommets(i);
      <a class="code" href="AssembleurPP1BUtil_8cpp.html#a556b82e62a565319fb25218f97cfc50c">calculer_grad</a>(face_voisins, elem, -1, coef_som, si, faces_op1(i),
                    -1, normales, gradi);
      <a class="code" href="Champ__Generique__Transformation_8cpp.html#a0705a900f8a8003047df2f59d6cd4bae">projette</a>(gradi, face, normales);
      <span class="keywordflow">if</span>(si&lt;nb_som_tot)
        ARR(si,si)+=<a class="code" href="AssembleurPP1BUtil_8cpp.html#a828055cfc33e4c56db8e2f5beb059862">dotproduct_array_fois_inverse_quantitee_entrelacee</a>(gradi,gradi,
                                                                       inverse_quantitee_entrelacee,face);
      <span class="keywordflow">for</span>(j=i+1; j&lt;dplusun; j++)
        {
          <span class="keywordtype">int</span> sj=sommets(j);
          <a class="code" href="AssembleurPP1BUtil_8cpp.html#a556b82e62a565319fb25218f97cfc50c">calculer_grad</a>(face_voisins, elem, -1,  coef_som,sj, faces_op1(j),
                        -1, normales, gradj);
          <a class="code" href="Champ__Generique__Transformation_8cpp.html#a0705a900f8a8003047df2f59d6cd4bae">projette</a>(gradj, face, normales);
          psc=<a class="code" href="AssembleurPP1BUtil_8cpp.html#a828055cfc33e4c56db8e2f5beb059862">dotproduct_array_fois_inverse_quantitee_entrelacee</a>(gradi,gradj,
                                                                 inverse_quantitee_entrelacee,face);
          <span class="keywordflow">if</span>(si&lt;nb_som_tot)
            <span class="keywordflow">if</span>(sj&lt;nb_som_tot)
              ARR(si,sj)+=psc;
            <span class="keywordflow">else</span>
              ARV(si,sj-nb_som_tot)+=psc;
          <span class="keywordflow">else</span> <span class="keywordflow">if</span>(sj&lt;nb_som_tot)
            AVR(si-nb_som_tot,sj)+=psc;
          <span class="keywordflow">else</span>
            AVV(si-nb_som_tot,sj-nb_som_tot)+=psc;
        }
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="aa18f9eabe40c3c77172253c07802c05f"></a><!-- doxytag: member="AssembleurPP1BUtil.cpp::update_matrice_SymetrieP1Pa" ref="aa18f9eabe40c3c77172253c07802c05f" args="(const Zone_VEF_PreP1b &amp;zone_VEF, const DoubleTab &amp;inverse_quantitee_entrelacee, int face, int elem, ArrOfInt &amp;sommets, ArrOfInt &amp;faces_op1, const ArrOfDouble &amp;coef_som, Matrice_Morse &amp;ARR, Matrice_Morse &amp;ARV, Matrice_Morse &amp;AVR, Matrice_Morse &amp;AVV)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void update_matrice_SymetrieP1Pa </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a> &amp;&#160;</td>
          <td class="paramname"><em>zone_VEF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>inverse_quantitee_entrelacee</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>sommets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>faces_op1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;&#160;</td>
          <td class="paramname"><em>coef_som</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;&#160;</td>
          <td class="paramname"><em>ARR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;&#160;</td>
          <td class="paramname"><em>ARV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;&#160;</td>
          <td class="paramname"><em>AVR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;&#160;</td>
          <td class="paramname"><em>AVV</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l02157">2157</a> of file <a class="el" href="AssembleurPP1BUtil_8cpp_source.html">AssembleurPP1BUtil.cpp</a>.</p>

<p>References <a class="el" href="Zone_8h_source.html#l01290">Zone::aretes_som()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00429">calculer_grad()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00462">calculer_grad_arete()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00306">chercher_arete()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00518">dotproduct_array_fois_inverse_quantitee_entrelacee()</a>, <a class="el" href="Zone_8h_source.html#l01282">Zone::elem_aretes()</a>, <a class="el" href="Zone__VEF_8h_source.html#l00145">Zone_VEF::face_normales()</a>, <a class="el" href="Zone__VF_8h_source.html#l00458">Zone_VF::face_voisins()</a>, <a class="el" href="Zone__VEF__PreP1b_8h_source.html#l00090">Zone_VEF_PreP1b::get_ok_arete()</a>, <a class="el" href="Zone_8h_source.html#l01258">Zone::nb_aretes()</a>, <a class="el" href="Zone_8cpp_source.html#l00586">Zone::nb_som()</a>, <a class="el" href="Champ__Generique__Transformation_8cpp_source.html#l00456">projette()</a>, and <a class="el" href="Zone__dis__base_8h_source.html#l00106">Zone_dis_base::zone()</a>.</p>

<p>Referenced by <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l02885">updateP1Pa()</a>.</p>
<div class="fragment"><pre class="fragment">{
<span class="comment">// int dimension=Objet_U::dimension,</span>
<span class="comment">// dplusun=dimension+1;</span>
<span class="comment">// double coeff_som=1./(dimension)/(dplusun);</span>
  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; elem_aretes=zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#a1e1e86ef5b088c4d33d42cd38a967b4a" title="renvoie le numero de la jeme arete du ieme element.">elem_aretes</a>();
  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; aretes_som=zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#affa60690e1b372fa4c01d6088267dbe4" title="renvoie le tableau de connectivite aretes/sommets.">aretes_som</a>();
  <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; ok_arete=zone_VEF.<a class="code" href="classZone__VEF__PreP1b.html#a83771f784d487e346b2ef22a389472a2">get_ok_arete</a>();
  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; face_voisins=zone_VEF.<a class="code" href="classZone__VF.html#a49d4322f5585a8fa95748ca785b70702" title="renvoie l&#39;element voisin de numface dans la direction i. i=0 : dans le sens oppose de l&#39;axe orthogona...">face_voisins</a>();
  <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; normales = zone_VEF.<a class="code" href="classZone__VEF.html#a5742d75972e4846bf9fbb6ed5715053e">face_normales</a>();
  <span class="keywordtype">int</span> nb_aretes_tot=zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#a3e3b48691911fd85574c7bc10a1a4fb8" title="renvoie le nombre d&#39;aretes reelles.">nb_aretes</a>();
  <span class="keywordtype">int</span> nb_som_tot=zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#ad340f571f81fa5c2e028b88c00b5c2ca" title="Renvoie le nombre de sommets de la zone.">nb_som</a>();

  <span class="keywordtype">int</span> i, j, k;
  <span class="keywordtype">double</span> psc;
  <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a> grad1(3);
  <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a> grad2(3);
  <span class="keywordflow">for</span>(i=0; i&lt;3; i++)
    {
      <span class="keywordtype">int</span> si=sommets(i);
      <span class="keywordflow">for</span>(j=i+1; j&lt;4; j++)
        {
          <span class="keywordtype">int</span> sj=sommets(j);
          <span class="keywordtype">int</span> arete1;
          arete1 = <a class="code" href="AssembleurPP1BUtil_8cpp.html#ae1c00f10faaf4da3ffdea8f881565a1b">chercher_arete</a>(zone_VEF,elem, si, sj,
                                  elem_aretes, aretes_som);
          <span class="keywordflow">if</span>(ok_arete(arete1))
            {
              <a class="code" href="AssembleurPP1BUtil_8cpp.html#aa26334c33fd016e71cbab82de7ef2fe5">calculer_grad_arete</a>(face, face_voisins, i, j,
                                  elem, -1,
                                  faces_op1(i), -1,
                                  faces_op1(j), -1,
                                  normales, grad1);
              <a class="code" href="Champ__Generique__Transformation_8cpp.html#a0705a900f8a8003047df2f59d6cd4bae">projette</a>(grad1, face, normales);
              <span class="keywordflow">for</span>(k=0; k&lt;4; k++)
                {
                  <span class="keywordtype">int</span> sk=sommets(k);
                  <a class="code" href="AssembleurPP1BUtil_8cpp.html#a556b82e62a565319fb25218f97cfc50c">calculer_grad</a>(face_voisins, elem, -1,  coef_som,sk,
                                faces_op1(k), -1,
                                normales, grad2);
                  <a class="code" href="Champ__Generique__Transformation_8cpp.html#a0705a900f8a8003047df2f59d6cd4bae">projette</a>(grad2, face, normales);
                  psc=-<a class="code" href="AssembleurPP1BUtil_8cpp.html#a828055cfc33e4c56db8e2f5beb059862">dotproduct_array_fois_inverse_quantitee_entrelacee</a>(grad1,grad2,
                                                                          inverse_quantitee_entrelacee,face);
                  <span class="keywordflow">if</span>(sk&lt;nb_som_tot)
                    <span class="keywordflow">if</span>(arete1&lt;nb_aretes_tot)
                      ARR(sk,arete1)+=psc;
                    <span class="keywordflow">else</span>
                      ARV(sk,arete1-nb_aretes_tot)+=psc;
                  <span class="keywordflow">else</span> <span class="keywordflow">if</span>(arete1&lt;nb_aretes_tot)
                    AVR(sk-nb_som_tot,arete1)+=psc;
                  <span class="keywordflow">else</span>
                    AVV(sk-nb_som_tot,arete1-nb_aretes_tot)+=psc;
                }
            }
        }
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a6e9d49381847c5756d002970ca6441b8"></a><!-- doxytag: member="AssembleurPP1BUtil.cpp::update_matrice_SymetriePaPa" ref="a6e9d49381847c5756d002970ca6441b8" args="(const Zone_VEF_PreP1b &amp;zone_VEF, const DoubleTab &amp;inverse_quantitee_entrelacee, int face, int elem, ArrOfInt &amp;sommets, ArrOfInt &amp;faces_op1, Matrice_Morse &amp;ARR, Matrice_Morse &amp;ARV, Matrice_Morse &amp;AVR, Matrice_Morse &amp;AVV)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void update_matrice_SymetriePaPa </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a> &amp;&#160;</td>
          <td class="paramname"><em>zone_VEF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>inverse_quantitee_entrelacee</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>sommets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>faces_op1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;&#160;</td>
          <td class="paramname"><em>ARR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;&#160;</td>
          <td class="paramname"><em>ARV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;&#160;</td>
          <td class="paramname"><em>AVR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;&#160;</td>
          <td class="paramname"><em>AVV</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l01478">1478</a> of file <a class="el" href="AssembleurPP1BUtil_8cpp_source.html">AssembleurPP1BUtil.cpp</a>.</p>

<p>References <a class="el" href="Zone_8h_source.html#l01290">Zone::aretes_som()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00462">calculer_grad_arete()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00306">chercher_arete()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00518">dotproduct_array_fois_inverse_quantitee_entrelacee()</a>, <a class="el" href="Zone_8h_source.html#l01282">Zone::elem_aretes()</a>, <a class="el" href="Zone__VEF_8h_source.html#l00145">Zone_VEF::face_normales()</a>, <a class="el" href="Zone__VF_8h_source.html#l00458">Zone_VF::face_voisins()</a>, <a class="el" href="Zone__VEF__PreP1b_8h_source.html#l00090">Zone_VEF_PreP1b::get_ok_arete()</a>, <a class="el" href="Zone_8h_source.html#l01258">Zone::nb_aretes()</a>, <a class="el" href="Champ__Generique__Transformation_8cpp_source.html#l00456">projette()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00335">swap()</a>, and <a class="el" href="Zone__dis__base_8h_source.html#l00106">Zone_dis_base::zone()</a>.</p>

<p>Referenced by <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l02567">updatePaPa()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; elem_aretes=zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#a1e1e86ef5b088c4d33d42cd38a967b4a" title="renvoie le numero de la jeme arete du ieme element.">elem_aretes</a>();
  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; aretes_som=zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#affa60690e1b372fa4c01d6088267dbe4" title="renvoie le tableau de connectivite aretes/sommets.">aretes_som</a>();
  <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; ok_arete=zone_VEF.<a class="code" href="classZone__VEF__PreP1b.html#a83771f784d487e346b2ef22a389472a2">get_ok_arete</a>();
  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; face_voisins=zone_VEF.<a class="code" href="classZone__VF.html#a49d4322f5585a8fa95748ca785b70702" title="renvoie l&#39;element voisin de numface dans la direction i. i=0 : dans le sens oppose de l&#39;axe orthogona...">face_voisins</a>();
  <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; normales = zone_VEF.<a class="code" href="classZone__VEF.html#a5742d75972e4846bf9fbb6ed5715053e">face_normales</a>();
  <span class="keywordtype">int</span> i, j, k, l;
  <span class="keywordtype">int</span> nb_aretes_tot=zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#a3e3b48691911fd85574c7bc10a1a4fb8" title="renvoie le nombre d&#39;aretes reelles.">nb_aretes</a>();

  <span class="keywordtype">double</span> psc;
  <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a> grad1(3);
  <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a> grad2(3);
  <span class="keywordflow">for</span>(i=0; i&lt;3; i++)
    {
      <span class="keywordtype">int</span> si=sommets(i);
      <span class="keywordflow">for</span>(j=i+1; j&lt;4; j++)
        {
          <span class="keywordtype">int</span> sj=sommets(j);
          <span class="keywordtype">int</span> arete1;
          arete1 = <a class="code" href="AssembleurPP1BUtil_8cpp.html#ae1c00f10faaf4da3ffdea8f881565a1b">chercher_arete</a>(zone_VEF,elem, si, sj,
                                  elem_aretes, aretes_som);
          <span class="keywordflow">if</span>(ok_arete(arete1))
            {
              <a class="code" href="AssembleurPP1BUtil_8cpp.html#aa26334c33fd016e71cbab82de7ef2fe5">calculer_grad_arete</a>(face, face_voisins, i, j,
                                  elem, -1,
                                  faces_op1(i), -1,
                                  faces_op1(j), -1,
                                  normales, grad1);
              <a class="code" href="Champ__Generique__Transformation_8cpp.html#a0705a900f8a8003047df2f59d6cd4bae">projette</a>(grad1, face, normales);
              <span class="keywordflow">if</span>(arete1&lt;nb_aretes_tot)
                ARR(arete1,arete1)+=<a class="code" href="AssembleurPP1BUtil_8cpp.html#a828055cfc33e4c56db8e2f5beb059862">dotproduct_array_fois_inverse_quantitee_entrelacee</a>(grad1,grad1,
                                                                                       inverse_quantitee_entrelacee,face);
              <span class="keywordtype">int</span> jj=j;
              <span class="keywordflow">for</span>(k=i; k&lt;3; k++)
                {
                  <span class="keywordtype">int</span> sk=sommets(k);
                  <span class="keywordflow">for</span>(l=jj+1; l&lt;4; l++)
                    {
                      <span class="keywordtype">int</span> sl=sommets(l);
                      <span class="keywordtype">int</span> arete2= <a class="code" href="AssembleurPP1BUtil_8cpp.html#ae1c00f10faaf4da3ffdea8f881565a1b">chercher_arete</a>(zone_VEF,elem, sl, sk,
                                                 elem_aretes,
                                                 aretes_som);
                      assert(arete2!=-1);
                      <span class="keywordflow">if</span>(ok_arete(arete2))
                        {
                          <a class="code" href="AssembleurPP1BUtil_8cpp.html#aa26334c33fd016e71cbab82de7ef2fe5">calculer_grad_arete</a>(face, face_voisins, k, l,
                                              elem, -1,
                                              faces_op1(k), -1,
                                              faces_op1(l), -1,
                                              normales, grad2);
                          <a class="code" href="Champ__Generique__Transformation_8cpp.html#a0705a900f8a8003047df2f59d6cd4bae">projette</a>(grad2, face, normales);
                          psc=<a class="code" href="AssembleurPP1BUtil_8cpp.html#a828055cfc33e4c56db8e2f5beb059862">dotproduct_array_fois_inverse_quantitee_entrelacee</a>(grad1,grad2,
                                                                                 inverse_quantitee_entrelacee,face);
                          <span class="keywordtype">int</span> tmp=arete1;
                          <span class="keywordflow">if</span>(arete1&gt;arete2) <a class="code" href="AssembleurPP1BUtil_8cpp.html#a3117b050530c46b4a15b6ab9ce6d0b41">swap</a>(arete1, arete2);
                          <span class="keywordflow">if</span>(arete1&lt;nb_aretes_tot)
                            <span class="keywordflow">if</span>(arete2&lt;nb_aretes_tot)
                              ARR(arete1,arete2)+=psc;
                            <span class="keywordflow">else</span>
                              ARV(arete1,arete2-nb_aretes_tot)+=psc;
                          <span class="keywordflow">else</span> <span class="keywordflow">if</span>(arete2&lt;nb_aretes_tot)
                            AVR(arete1-nb_aretes_tot,arete2)+=psc;
                          <span class="keywordflow">else</span>
                            AVV(arete1-nb_aretes_tot,arete2-nb_aretes_tot)+=psc;
                          arete1=tmp;
                        }
                    }
                  jj=k+1;
                }
            }
        }
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="aa7aef5562f5fe1f2d5b1eeb6664bca53"></a><!-- doxytag: member="AssembleurPP1BUtil.cpp::update_matriceP0P1" ref="aa7aef5562f5fe1f2d5b1eeb6664bca53" args="(const Zone_VEF &amp;zone_VEF, const DoubleTab &amp;inverse_quantitee_entrelacee, int face, int elem1, int elem2, ArrOfInt &amp;sommets, ArrOfInt &amp;faces_op1, ArrOfInt &amp;faces_op2, const ArrOfDouble &amp;coef_som, Matrice_Morse &amp;ARR, Matrice_Morse &amp;ARV, Matrice_Morse &amp;AVR, Matrice_Morse &amp;AVV)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void update_matriceP0P1 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classZone__VEF.html">Zone_VEF</a> &amp;&#160;</td>
          <td class="paramname"><em>zone_VEF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>inverse_quantitee_entrelacee</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>elem1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>elem2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>sommets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>faces_op1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>faces_op2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;&#160;</td>
          <td class="paramname"><em>coef_som</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;&#160;</td>
          <td class="paramname"><em>ARR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;&#160;</td>
          <td class="paramname"><em>ARV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;&#160;</td>
          <td class="paramname"><em>AVR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;&#160;</td>
          <td class="paramname"><em>AVV</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00600">600</a> of file <a class="el" href="AssembleurPP1BUtil_8cpp_source.html">AssembleurPP1BUtil.cpp</a>.</p>

<p>References <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00429">calculer_grad()</a>, <a class="el" href="Objet__U_8h_source.html#l00079">Objet_U::dimension</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00518">dotproduct_array_fois_inverse_quantitee_entrelacee()</a>, <a class="el" href="Zone__VEF_8h_source.html#l00145">Zone_VEF::face_normales()</a>, <a class="el" href="Zone__VF_8h_source.html#l00458">Zone_VF::face_voisins()</a>, <a class="el" href="Zone__dis__base_8h_source.html#l00140">Zone_dis_base::nb_elem()</a>, <a class="el" href="Zone__dis__base_8h_source.html#l00148">Zone_dis_base::nb_som()</a>, and <a class="el" href="Assembleur__P__VEFPreP1B_8cpp_source.html#l01005">range()</a>.</p>

<p>Referenced by <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l03048">updateP0P1()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; normales = zone_VEF.<a class="code" href="classZone__VEF.html#a5742d75972e4846bf9fbb6ed5715053e">face_normales</a>();
  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; face_voisins = zone_VEF.<a class="code" href="classZone__VF.html#a49d4322f5585a8fa95748ca785b70702" title="renvoie l&#39;element voisin de numface dans la direction i. i=0 : dans le sens oppose de l&#39;axe orthogona...">face_voisins</a>();
  assert(elem1==face_voisins(face, 0));
  assert(elem2==face_voisins(face, 1));

  <span class="keywordtype">int</span> dimension=<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>,
      dplusdeux=dimension+2;
  <span class="keywordtype">double</span> psc;
<span class="comment">// double coeff_som=1./(dimension)/(dimension+1);</span>
  <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a> gradi(dimension);
  <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a> gradE(dimension);

  <span class="keywordtype">int</span> nb_elem=zone_VEF.<a class="code" href="classZone__dis__base.html#a790cb2f6bc2928518799e748313d0eb3">nb_elem</a>();
  <span class="keywordtype">int</span> nb_som=zone_VEF.<a class="code" href="classZone__dis__base.html#acc9921d6a29cb719fd832fd573e47825">nb_som</a>();
  <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;dplusdeux; i++)
    {
      <span class="keywordtype">int</span> si=sommets(i);
      <span class="keywordflow">if</span> (si&lt;0) <span class="keywordflow">break</span>;
      <a class="code" href="AssembleurPP1BUtil_8cpp.html#a556b82e62a565319fb25218f97cfc50c">calculer_grad</a>(face_voisins, elem1, elem2, coef_som,si, faces_op1(i),
                    faces_op2(i), normales, gradi);
      <span class="keywordflow">for</span>(<span class="keywordtype">int</span> k=0; k&lt;dimension; k++)
        gradE(k)=normales(face,k);
      psc=<a class="code" href="AssembleurPP1BUtil_8cpp.html#a828055cfc33e4c56db8e2f5beb059862">dotproduct_array_fois_inverse_quantitee_entrelacee</a>(gradi,gradE,
                                                             inverse_quantitee_entrelacee,face);
      <a class="code" href="Assembleur__P__VEFPreP1B_8cpp.html#a1ba6a21d7cd10f7974541a879696c5db">range</a>(elem1,nb_elem,si,nb_som,ARR,ARV,AVR,AVV,psc);
      <span class="keywordflow">if</span> (elem2!=-1)
        <a class="code" href="Assembleur__P__VEFPreP1B_8cpp.html#a1ba6a21d7cd10f7974541a879696c5db">range</a>(elem2,nb_elem,si,nb_som,ARR,ARV,AVR,AVV,-psc);
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a68f4b5d510b37d5518ed576764da2611"></a><!-- doxytag: member="AssembleurPP1BUtil.cpp::update_matriceP0Pa" ref="a68f4b5d510b37d5518ed576764da2611" args="(const Zone_VEF_PreP1b &amp;zone_VEF, const DoubleTab &amp;inverse_quantitee_entrelacee, int face, int elem1, int elem2, ArrOfInt &amp;sommets, ArrOfInt &amp;faces_op1, ArrOfInt &amp;faces_op2, Matrice_Morse &amp;ARR, Matrice_Morse &amp;ARV, Matrice_Morse &amp;AVR, Matrice_Morse &amp;AVV)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void update_matriceP0Pa </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a> &amp;&#160;</td>
          <td class="paramname"><em>zone_VEF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>inverse_quantitee_entrelacee</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>elem1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>elem2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>sommets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>faces_op1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>faces_op2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;&#160;</td>
          <td class="paramname"><em>ARR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;&#160;</td>
          <td class="paramname"><em>ARV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;&#160;</td>
          <td class="paramname"><em>AVR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;&#160;</td>
          <td class="paramname"><em>AVV</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l01634">1634</a> of file <a class="el" href="AssembleurPP1BUtil_8cpp_source.html">AssembleurPP1BUtil.cpp</a>.</p>

<p>References <a class="el" href="Zone_8h_source.html#l01290">Zone::aretes_som()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00462">calculer_grad_arete()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00306">chercher_arete()</a>, <a class="el" href="Zone_8h_source.html#l01282">Zone::elem_aretes()</a>, <a class="el" href="Zone__VEF_8h_source.html#l00145">Zone_VEF::face_normales()</a>, <a class="el" href="Zone__VF_8h_source.html#l00458">Zone_VF::face_voisins()</a>, <a class="el" href="Zone__VEF__PreP1b_8h_source.html#l00090">Zone_VEF_PreP1b::get_ok_arete()</a>, <a class="el" href="Zone_8h_source.html#l01258">Zone::nb_aretes()</a>, <a class="el" href="Zone_8h_source.html#l00300">Zone::nb_elem()</a>, and <a class="el" href="Zone__dis__base_8h_source.html#l00106">Zone_dis_base::zone()</a>.</p>

<p>Referenced by <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l02730">updateP0Pa()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; elem_aretes=zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#a1e1e86ef5b088c4d33d42cd38a967b4a" title="renvoie le numero de la jeme arete du ieme element.">elem_aretes</a>();
  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; aretes_som=zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#affa60690e1b372fa4c01d6088267dbe4" title="renvoie le tableau de connectivite aretes/sommets.">aretes_som</a>();
  <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; ok_arete=zone_VEF.<a class="code" href="classZone__VEF__PreP1b.html#a83771f784d487e346b2ef22a389472a2">get_ok_arete</a>();
  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; face_voisins=zone_VEF.<a class="code" href="classZone__VF.html#a49d4322f5585a8fa95748ca785b70702" title="renvoie l&#39;element voisin de numface dans la direction i. i=0 : dans le sens oppose de l&#39;axe orthogona...">face_voisins</a>();
  <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; normales = zone_VEF.<a class="code" href="classZone__VEF.html#a5742d75972e4846bf9fbb6ed5715053e">face_normales</a>();
  <span class="keywordtype">int</span> nb_aretes_tot=zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#a3e3b48691911fd85574c7bc10a1a4fb8" title="renvoie le nombre d&#39;aretes reelles.">nb_aretes</a>();
  <span class="keywordtype">int</span> nb_elem_tot=zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#a7f249429803b27139a1c54436f6164a5" title="Renvoie le nombre d&#39;elements de la zone.">nb_elem</a>();

  <span class="keywordtype">int</span> i, j;
  <span class="keywordtype">double</span> psc;
  <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a> grad1(3);
  <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a> grad2(3);
  <span class="keywordtype">int</span> jmax=5;
  <span class="keywordflow">if</span>(elem2==-1) jmax=4;
  <span class="keywordflow">for</span>(i=0; i&lt;3; i++)
    {
      <span class="keywordtype">int</span> si=sommets(i);
      <span class="keywordflow">for</span>(j=i+1; j&lt;jmax; j++)
        {
          <span class="keywordtype">int</span> sj=sommets(j);
          <span class="keywordtype">int</span> arete1;
          <span class="keywordflow">if</span>(j&lt;4)
            arete1 = <a class="code" href="AssembleurPP1BUtil_8cpp.html#ae1c00f10faaf4da3ffdea8f881565a1b">chercher_arete</a>(zone_VEF,elem1, si, sj,
                                    elem_aretes, aretes_som);
          <span class="keywordflow">else</span>
            arete1 = <a class="code" href="AssembleurPP1BUtil_8cpp.html#ae1c00f10faaf4da3ffdea8f881565a1b">chercher_arete</a>(zone_VEF,elem2, si, sj,
                                    elem_aretes, aretes_som);
          <span class="keywordflow">if</span>(ok_arete(arete1))
            {
              <a class="code" href="AssembleurPP1BUtil_8cpp.html#aa26334c33fd016e71cbab82de7ef2fe5">calculer_grad_arete</a>(face, face_voisins, i, j,
                                  elem1, elem2,
                                  faces_op1(i), faces_op2(i),
                                  faces_op1(j), faces_op2(j),
                                  normales, grad1);
              psc=0;
              <span class="keywordflow">for</span>(<span class="keywordtype">int</span> comp=0; comp&lt;3; comp++)
                psc+=grad1(comp)*normales(face, comp)
                     *(-inverse_quantitee_entrelacee(face,comp));
              <span class="keywordflow">if</span>(elem1&lt;nb_elem_tot)
                <span class="keywordflow">if</span>(arete1&lt;nb_aretes_tot)
                  ARR(elem1,arete1)+=psc;
                <span class="keywordflow">else</span>
                  ARV(elem1,arete1-nb_aretes_tot)+=psc;
              <span class="keywordflow">else</span> <span class="keywordflow">if</span>(arete1&lt;nb_aretes_tot)
                AVR(elem1-nb_elem_tot,arete1)+=psc;
              <span class="keywordflow">else</span>
                AVV(elem1-nb_elem_tot,arete1-nb_aretes_tot)+=psc;

              <span class="keywordflow">if</span>(elem2!=-1)
                {
                  psc*=-1.0;
                  <span class="keywordflow">if</span>(elem2&lt;nb_elem_tot)
                    <span class="keywordflow">if</span>(arete1&lt;nb_aretes_tot)
                      ARR(elem2,arete1)+=psc;
                    <span class="keywordflow">else</span>
                      ARV(elem2,arete1-nb_aretes_tot)+=psc;
                  <span class="keywordflow">else</span> <span class="keywordflow">if</span>(arete1&lt;nb_aretes_tot)
                    AVR(elem2-nb_elem_tot,arete1)+=psc;
                  <span class="keywordflow">else</span>
                    AVV(elem2-nb_elem_tot,arete1-nb_aretes_tot)+=psc;
                }
            }
        }
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a77351839245012751e4d90a39922356a"></a><!-- doxytag: member="AssembleurPP1BUtil.cpp::update_matriceP1P1" ref="a77351839245012751e4d90a39922356a" args="(const Zone_VEF &amp;zone_VEF, const DoubleTab &amp;inverse_quantitee_entrelacee, int face, int elem1, int elem2, ArrOfInt &amp;sommets, ArrOfInt &amp;faces_op1, ArrOfInt &amp;faces_op2, const ArrOfDouble &amp;coef_som, Matrice_Morse &amp;ARR, Matrice_Morse &amp;ARV, Matrice_Morse &amp;AVR, Matrice_Morse &amp;AVV)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void update_matriceP1P1 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classZone__VEF.html">Zone_VEF</a> &amp;&#160;</td>
          <td class="paramname"><em>zone_VEF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>inverse_quantitee_entrelacee</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>elem1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>elem2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>sommets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>faces_op1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>faces_op2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;&#160;</td>
          <td class="paramname"><em>coef_som</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;&#160;</td>
          <td class="paramname"><em>ARR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;&#160;</td>
          <td class="paramname"><em>ARV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;&#160;</td>
          <td class="paramname"><em>AVR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;&#160;</td>
          <td class="paramname"><em>AVV</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00694">694</a> of file <a class="el" href="AssembleurPP1BUtil_8cpp_source.html">AssembleurPP1BUtil.cpp</a>.</p>

<p>References <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00429">calculer_grad()</a>, <a class="el" href="Objet__U_8h_source.html#l00079">Objet_U::dimension</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00518">dotproduct_array_fois_inverse_quantitee_entrelacee()</a>, <a class="el" href="Zone__VEF_8h_source.html#l00145">Zone_VEF::face_normales()</a>, <a class="el" href="Zone__VF_8h_source.html#l00458">Zone_VF::face_voisins()</a>, and <a class="el" href="Zone__dis__base_8h_source.html#l00148">Zone_dis_base::nb_som()</a>.</p>

<p>Referenced by <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l02339">updateP1P1()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; normales = zone_VEF.<a class="code" href="classZone__VEF.html#a5742d75972e4846bf9fbb6ed5715053e">face_normales</a>();
  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; face_voisins = zone_VEF.<a class="code" href="classZone__VF.html#a49d4322f5585a8fa95748ca785b70702" title="renvoie l&#39;element voisin de numface dans la direction i. i=0 : dans le sens oppose de l&#39;axe orthogona...">face_voisins</a>();

  <span class="keywordtype">int</span> dimension=<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>,
      dplusdeux=dimension+2;
  <span class="keywordtype">double</span> psc;
<span class="comment">// double coeff_som=1./(dimension)/(dimension+1);</span>
<span class="comment">// coeff_som*=coeff_som;</span>
  <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a> gradi(dimension);
  <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a> gradj(dimension);
  <span class="keywordtype">int</span> nb_som_tot=zone_VEF.<a class="code" href="classZone__dis__base.html#acc9921d6a29cb719fd832fd573e47825">nb_som</a>();
  <span class="keywordtype">int</span> i,j;

<span class="comment">// On ne traite pas les sommets -1 qui</span>
<span class="comment">// sont en fin de tableau sommets:</span>
  <span class="keywordflow">while</span> (sommets(dplusdeux-1)==-1)
    dplusdeux--;

  <span class="keywordflow">for</span>(i=0; i&lt;dplusdeux; i++)
    {
      <span class="keywordtype">int</span> si=sommets(i);
      <a class="code" href="AssembleurPP1BUtil_8cpp.html#a556b82e62a565319fb25218f97cfc50c">calculer_grad</a>(face_voisins, elem1, elem2, coef_som,si, faces_op1(i),
                    faces_op2(i), normales, gradi);
      <span class="keywordflow">if</span>(si&lt;nb_som_tot)
        ARR(si,si)+=<a class="code" href="AssembleurPP1BUtil_8cpp.html#a828055cfc33e4c56db8e2f5beb059862">dotproduct_array_fois_inverse_quantitee_entrelacee</a>(gradi,gradi,
                                                                       inverse_quantitee_entrelacee,face);
      <span class="keywordflow">for</span>(j=i+1; j&lt;dplusdeux; j++)
        {
          <span class="keywordtype">int</span> sj=sommets(j);
          <a class="code" href="AssembleurPP1BUtil_8cpp.html#a556b82e62a565319fb25218f97cfc50c">calculer_grad</a>(face_voisins, elem1, elem2,coef_som, sj, faces_op1(j),
                        faces_op2(j), normales, gradj);
          psc=<a class="code" href="AssembleurPP1BUtil_8cpp.html#a828055cfc33e4c56db8e2f5beb059862">dotproduct_array_fois_inverse_quantitee_entrelacee</a>(gradi,gradj,inverse_quantitee_entrelacee,face);
<span class="comment">// assert(sj&gt;si);</span>
          <span class="keywordflow">if</span>(si&lt;nb_som_tot)
            <span class="keywordflow">if</span>(sj&lt;nb_som_tot)
              ARR(si,sj)+=psc;
            <span class="keywordflow">else</span>
              ARV(si,sj-nb_som_tot)+=psc;
          <span class="keywordflow">else</span> <span class="keywordflow">if</span>(sj&lt;nb_som_tot)
            AVR(si-nb_som_tot,sj)+=psc;
          <span class="keywordflow">else</span>
            AVV(si-nb_som_tot,sj-nb_som_tot)+=psc;
        }
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="ac499159b3caa7be06c8c9fddfdb5c8c1"></a><!-- doxytag: member="AssembleurPP1BUtil.cpp::update_matriceP1Pa" ref="ac499159b3caa7be06c8c9fddfdb5c8c1" args="(const Zone_VEF_PreP1b &amp;zone_VEF, const DoubleTab &amp;inverse_quantitee_entrelacee, int face, int elem1, int elem2, ArrOfInt &amp;sommets, ArrOfInt &amp;faces_op1, ArrOfInt &amp;faces_op2, const ArrOfDouble &amp;coef_som, Matrice_Morse &amp;ARR, Matrice_Morse &amp;ARV, Matrice_Morse &amp;AVR, Matrice_Morse &amp;AVV)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void update_matriceP1Pa </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a> &amp;&#160;</td>
          <td class="paramname"><em>zone_VEF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>inverse_quantitee_entrelacee</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>elem1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>elem2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>sommets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>faces_op1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>faces_op2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;&#160;</td>
          <td class="paramname"><em>coef_som</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;&#160;</td>
          <td class="paramname"><em>ARR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;&#160;</td>
          <td class="paramname"><em>ARV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;&#160;</td>
          <td class="paramname"><em>AVR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;&#160;</td>
          <td class="paramname"><em>AVV</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l01888">1888</a> of file <a class="el" href="AssembleurPP1BUtil_8cpp_source.html">AssembleurPP1BUtil.cpp</a>.</p>

<p>References <a class="el" href="Zone_8h_source.html#l01290">Zone::aretes_som()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00429">calculer_grad()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00462">calculer_grad_arete()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00306">chercher_arete()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00518">dotproduct_array_fois_inverse_quantitee_entrelacee()</a>, <a class="el" href="Zone_8h_source.html#l01282">Zone::elem_aretes()</a>, <a class="el" href="Zone__VEF_8h_source.html#l00145">Zone_VEF::face_normales()</a>, <a class="el" href="Zone__VF_8h_source.html#l00458">Zone_VF::face_voisins()</a>, <a class="el" href="Zone__VEF__PreP1b_8h_source.html#l00090">Zone_VEF_PreP1b::get_ok_arete()</a>, <a class="el" href="Zone_8h_source.html#l01258">Zone::nb_aretes()</a>, <a class="el" href="Zone_8cpp_source.html#l00586">Zone::nb_som()</a>, and <a class="el" href="Zone__dis__base_8h_source.html#l00106">Zone_dis_base::zone()</a>.</p>

<p>Referenced by <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l02885">updateP1Pa()</a>.</p>
<div class="fragment"><pre class="fragment">{
<span class="comment">// int dimension=Objet_U::dimension,</span>
<span class="comment">// dplusun=dimension+1;</span>
<span class="comment">// double coeff_som=1./(dimension)/(dplusun);</span>
  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; elem_aretes=zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#a1e1e86ef5b088c4d33d42cd38a967b4a" title="renvoie le numero de la jeme arete du ieme element.">elem_aretes</a>();
  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; aretes_som=zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#affa60690e1b372fa4c01d6088267dbe4" title="renvoie le tableau de connectivite aretes/sommets.">aretes_som</a>();
  <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; ok_arete=zone_VEF.<a class="code" href="classZone__VEF__PreP1b.html#a83771f784d487e346b2ef22a389472a2">get_ok_arete</a>();
  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; face_voisins=zone_VEF.<a class="code" href="classZone__VF.html#a49d4322f5585a8fa95748ca785b70702" title="renvoie l&#39;element voisin de numface dans la direction i. i=0 : dans le sens oppose de l&#39;axe orthogona...">face_voisins</a>();
  <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; normales = zone_VEF.<a class="code" href="classZone__VEF.html#a5742d75972e4846bf9fbb6ed5715053e">face_normales</a>();
  <span class="keywordtype">int</span> nb_aretes_tot=zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#a3e3b48691911fd85574c7bc10a1a4fb8" title="renvoie le nombre d&#39;aretes reelles.">nb_aretes</a>();
  <span class="keywordtype">int</span> nb_som_tot=zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#ad340f571f81fa5c2e028b88c00b5c2ca" title="Renvoie le nombre de sommets de la zone.">nb_som</a>();

  <span class="keywordtype">int</span> i, j, k;
  <span class="keywordtype">double</span> psc;
  <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a> grad1(3);
  <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a> grad2(3);
  <span class="keywordtype">int</span> jmax=5;
  <span class="keywordflow">if</span>(elem2==-1) jmax=4;
  <span class="keywordflow">for</span>(i=0; i&lt;3; i++)
    {
      <span class="keywordtype">int</span> si=sommets(i);
      <span class="keywordflow">for</span>(j=i+1; j&lt;jmax; j++)
        {
          <span class="keywordtype">int</span> sj=sommets(j);
          <span class="keywordtype">int</span> arete1;
          <span class="keywordflow">if</span>(j&lt;4)
            arete1 = <a class="code" href="AssembleurPP1BUtil_8cpp.html#ae1c00f10faaf4da3ffdea8f881565a1b">chercher_arete</a>(zone_VEF,elem1, si, sj,
                                    elem_aretes, aretes_som);
          <span class="keywordflow">else</span>
            arete1 = <a class="code" href="AssembleurPP1BUtil_8cpp.html#ae1c00f10faaf4da3ffdea8f881565a1b">chercher_arete</a>(zone_VEF,elem2, si, sj,
                                    elem_aretes, aretes_som);
          <span class="keywordflow">if</span>(ok_arete(arete1))
            {
              <a class="code" href="AssembleurPP1BUtil_8cpp.html#aa26334c33fd016e71cbab82de7ef2fe5">calculer_grad_arete</a>(face, face_voisins, i, j,
                                  elem1, elem2,
                                  faces_op1(i), faces_op2(i),
                                  faces_op1(j), faces_op2(j),
                                  normales, grad1);
              <span class="keywordflow">for</span>(k=0; k&lt;jmax; k++)
                {
                  <span class="keywordtype">int</span> sk=sommets(k);
                  <a class="code" href="AssembleurPP1BUtil_8cpp.html#a556b82e62a565319fb25218f97cfc50c">calculer_grad</a>(face_voisins, elem1, elem2, coef_som, sk,
                                faces_op1(k), faces_op2(k),
                                normales, grad2);
                  psc=-<a class="code" href="AssembleurPP1BUtil_8cpp.html#a828055cfc33e4c56db8e2f5beb059862">dotproduct_array_fois_inverse_quantitee_entrelacee</a>(grad1,grad2,
                                                                          inverse_quantitee_entrelacee,face);
                  <span class="keywordflow">if</span>(sk&lt;nb_som_tot)
                    <span class="keywordflow">if</span>(arete1&lt;nb_aretes_tot)
                      ARR(sk,arete1)+=psc;
                    <span class="keywordflow">else</span>
                      ARV(sk,arete1-nb_aretes_tot)+=psc;
                  <span class="keywordflow">else</span> <span class="keywordflow">if</span>(arete1&lt;nb_aretes_tot)
                    AVR(sk-nb_som_tot,arete1)+=psc;
                  <span class="keywordflow">else</span>
                    AVV(sk-nb_som_tot,arete1-nb_aretes_tot)+=psc;
                }
            }
        }
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a76d676949fb80bc3c7f1ab5f7f8078c0"></a><!-- doxytag: member="AssembleurPP1BUtil.cpp::update_matricePaPa" ref="a76d676949fb80bc3c7f1ab5f7f8078c0" args="(const Zone_VEF_PreP1b &amp;zone_VEF, const DoubleTab &amp;inverse_quantitee_entrelacee, int face, int elem1, int elem2, ArrOfInt &amp;sommets, ArrOfInt &amp;faces_op1, ArrOfInt &amp;faces_op2, Matrice_Morse &amp;ARR, Matrice_Morse &amp;ARV, Matrice_Morse &amp;AVR, Matrice_Morse &amp;AVV)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void update_matricePaPa </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a> &amp;&#160;</td>
          <td class="paramname"><em>zone_VEF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>inverse_quantitee_entrelacee</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>elem1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>elem2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>sommets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>faces_op1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>faces_op2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;&#160;</td>
          <td class="paramname"><em>ARR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;&#160;</td>
          <td class="paramname"><em>ARV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;&#160;</td>
          <td class="paramname"><em>AVR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;&#160;</td>
          <td class="paramname"><em>AVV</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00843">843</a> of file <a class="el" href="AssembleurPP1BUtil_8cpp_source.html">AssembleurPP1BUtil.cpp</a>.</p>

<p>References <a class="el" href="Zone_8h_source.html#l01290">Zone::aretes_som()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00462">calculer_grad_arete()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00306">chercher_arete()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00518">dotproduct_array_fois_inverse_quantitee_entrelacee()</a>, <a class="el" href="Zone_8h_source.html#l01282">Zone::elem_aretes()</a>, <a class="el" href="Zone__VEF_8h_source.html#l00145">Zone_VEF::face_normales()</a>, <a class="el" href="Zone__VF_8h_source.html#l00458">Zone_VF::face_voisins()</a>, <a class="el" href="Zone__VEF__PreP1b_8h_source.html#l00090">Zone_VEF_PreP1b::get_ok_arete()</a>, <a class="el" href="Zone_8h_source.html#l01258">Zone::nb_aretes()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00335">swap()</a>, and <a class="el" href="Zone__dis__base_8h_source.html#l00106">Zone_dis_base::zone()</a>.</p>

<p>Referenced by <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l02567">updatePaPa()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; elem_aretes=zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#a1e1e86ef5b088c4d33d42cd38a967b4a" title="renvoie le numero de la jeme arete du ieme element.">elem_aretes</a>();
  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; aretes_som=zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#affa60690e1b372fa4c01d6088267dbe4" title="renvoie le tableau de connectivite aretes/sommets.">aretes_som</a>();
  <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; ok_arete=zone_VEF.<a class="code" href="classZone__VEF__PreP1b.html#a83771f784d487e346b2ef22a389472a2">get_ok_arete</a>();
  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; face_voisins=zone_VEF.<a class="code" href="classZone__VF.html#a49d4322f5585a8fa95748ca785b70702" title="renvoie l&#39;element voisin de numface dans la direction i. i=0 : dans le sens oppose de l&#39;axe orthogona...">face_voisins</a>();
  <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; normales = zone_VEF.<a class="code" href="classZone__VEF.html#a5742d75972e4846bf9fbb6ed5715053e">face_normales</a>();
  <span class="keywordtype">int</span> nb_aretes_tot=zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#a3e3b48691911fd85574c7bc10a1a4fb8" title="renvoie le nombre d&#39;aretes reelles.">nb_aretes</a>();
  <span class="keywordtype">int</span> i, j, k, l;
  <span class="keywordtype">double</span> psc;
<span class="comment">// On ne traite pas les sommets -1 qui</span>
<span class="comment">// sont en fin de tableau sommets:</span>
<span class="comment">// while (sommets(dplusdeux-1)==-1)</span>
<span class="comment">// dplusdeux--;</span>

  <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a> grad1(3);
  <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a> grad2(3);
  <span class="keywordtype">int</span> jmax=5;
  <span class="keywordflow">if</span>(elem2==-1) jmax=4;
  <span class="keywordflow">for</span>(i=0; i&lt;3; i++)
    {
      <span class="keywordtype">int</span> si=sommets(i);
      <span class="keywordflow">for</span>(j=i+1; j&lt;jmax; j++)
        {
          <span class="keywordtype">int</span> sj=sommets(j);
          <span class="keywordtype">int</span> arete1;
          <span class="keywordflow">if</span>(j&lt;4)
            arete1 = <a class="code" href="AssembleurPP1BUtil_8cpp.html#ae1c00f10faaf4da3ffdea8f881565a1b">chercher_arete</a>(zone_VEF,elem1, si, sj,
                                    elem_aretes, aretes_som);
          <span class="keywordflow">else</span>
            arete1 = <a class="code" href="AssembleurPP1BUtil_8cpp.html#ae1c00f10faaf4da3ffdea8f881565a1b">chercher_arete</a>(zone_VEF,elem2, si, sj,
                                    elem_aretes, aretes_som);
          assert(arete1!=-1);
          <span class="keywordflow">if</span>(ok_arete(arete1))
            {
              <a class="code" href="AssembleurPP1BUtil_8cpp.html#aa26334c33fd016e71cbab82de7ef2fe5">calculer_grad_arete</a>(face, face_voisins, i, j,
                                  elem1, elem2,
                                  faces_op1(i), faces_op2(i),
                                  faces_op1(j), faces_op2(j),
                                  normales, grad1);
              <span class="keywordflow">if</span>(arete1&lt;nb_aretes_tot)
                ARR(arete1,arete1)+=<a class="code" href="AssembleurPP1BUtil_8cpp.html#a828055cfc33e4c56db8e2f5beb059862">dotproduct_array_fois_inverse_quantitee_entrelacee</a>(grad1,grad1,
                                                                                       inverse_quantitee_entrelacee,face);
              <span class="keywordtype">int</span> jj=j;
              <span class="keywordflow">for</span>(k=i; k&lt;3; k++)
                {
                  <span class="keywordtype">int</span> sk=sommets(k);
                  <span class="keywordflow">for</span>(l=jj+1; l&lt;jmax; l++)
                    {
                      <span class="keywordtype">int</span> sl=sommets(l);
                      <span class="keywordtype">int</span> arete2;
                      <span class="keywordflow">if</span>(l&lt;4)
                        arete2 = <a class="code" href="AssembleurPP1BUtil_8cpp.html#ae1c00f10faaf4da3ffdea8f881565a1b">chercher_arete</a>(zone_VEF,elem1, sl, sk,
                                                elem_aretes,
                                                aretes_som);
                      <span class="keywordflow">else</span>
                        arete2 = <a class="code" href="AssembleurPP1BUtil_8cpp.html#ae1c00f10faaf4da3ffdea8f881565a1b">chercher_arete</a>(zone_VEF,elem2, sl, sk,
                                                elem_aretes,
                                                aretes_som);
                      assert(arete2!=-1);
                      <span class="keywordflow">if</span>(ok_arete(arete2))
                        {
                          <a class="code" href="AssembleurPP1BUtil_8cpp.html#aa26334c33fd016e71cbab82de7ef2fe5">calculer_grad_arete</a>(face, face_voisins, k, l,
                                              elem1, elem2,
                                              faces_op1(k), faces_op2(k),
                                              faces_op1(l), faces_op2(l),
                                              normales, grad2);
                          psc=<a class="code" href="AssembleurPP1BUtil_8cpp.html#a828055cfc33e4c56db8e2f5beb059862">dotproduct_array_fois_inverse_quantitee_entrelacee</a>(grad1,grad2,
                                                                                 inverse_quantitee_entrelacee,face);
                          <span class="keywordtype">int</span> tmp=arete1;
                          <span class="keywordflow">if</span>(arete1&gt;arete2) <a class="code" href="AssembleurPP1BUtil_8cpp.html#a3117b050530c46b4a15b6ab9ce6d0b41">swap</a>(arete1, arete2);
                          <span class="keywordflow">if</span>(arete1&lt;nb_aretes_tot)
                            <span class="keywordflow">if</span>(arete2&lt;nb_aretes_tot)
                              ARR(arete1,arete2)+=psc;
                            <span class="keywordflow">else</span>
                              ARV(arete1,arete2-nb_aretes_tot)+=psc;
                          <span class="keywordflow">else</span> <span class="keywordflow">if</span>(arete2&lt;nb_aretes_tot)
                            AVR(arete1-nb_aretes_tot,arete2)+=psc;
                          <span class="keywordflow">else</span>
                            AVV(arete1-nb_aretes_tot,arete2-nb_aretes_tot)+=psc;
                          arete1=tmp;
                        }
                    }
                  jj=k+1;
                }
            }
        }
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a48eaaecaa31bdde228ea5e3995db4771"></a><!-- doxytag: member="AssembleurPP1BUtil.cpp::updateP0P0" ref="a48eaaecaa31bdde228ea5e3995db4771" args="(const Zone_dis_base &amp;z, const Zone_Cl_dis_base &amp;zcl, Matrice &amp;matrice, const DoubleTab &amp;inverse_quantitee_entrelacee)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void updateP0P0 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classZone__dis__base.html">Zone_dis_base</a> &amp;&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classZone__Cl__dis__base.html">Zone_Cl_dis_base</a> &amp;&#160;</td>
          <td class="paramname"><em>zcl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatrice.html">Matrice</a> &amp;&#160;</td>
          <td class="paramname"><em>matrice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>inverse_quantitee_entrelacee</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l02235">2235</a> of file <a class="el" href="AssembleurPP1BUtil_8cpp_source.html">AssembleurPP1BUtil.cpp</a>.</p>

<p>References <a class="el" href="Assembleur__P__VEF_8cpp_source.html#l00755">Assembleur_P_VEF::associer_zone_cl_dis_base()</a>, <a class="el" href="Assembleur__P__VEF_8cpp_source.html#l00750">Assembleur_P_VEF::associer_zone_dis_base()</a>, <a class="el" href="EntreeSortie_8h_source.html#l00032">Cerr</a>, <a class="el" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>, and <a class="el" href="Assembleur__P__VEF_8cpp_source.html#l00134">Assembleur_P_VEF::remplir()</a>.</p>

<p>Referenced by <a class="el" href="Assembleur__P__VEFPreP1B_8cpp_source.html#l00230">Assembleur_P_VEFPreP1B::assembler_mat()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <a class="code" href="classAssembleur__P__VEF.html">Assembleur_P_VEF</a> Assembleur_P0;
  Assembleur_P0.<a class="code" href="classAssembleur__P__VEF.html#a5b2a8af584466c11399b032515921978">associer_zone_dis_base</a>(z);
  Assembleur_P0.<a class="code" href="classAssembleur__P__VEF.html#a69468e49c8496eda05508c8e8477493b">associer_zone_cl_dis_base</a>(zcl);
  Assembleur_P0.<a class="code" href="classAssembleur__P__VEF.html#abe02c31a6c1ada8d05996def7f43ea58">remplir</a>(matrice,inverse_quantitee_entrelacee);
  <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Update P0 OK&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="af30661e8e1b45bf522a5595f65ecc741"></a><!-- doxytag: member="AssembleurPP1BUtil.cpp::updateP0P1" ref="af30661e8e1b45bf522a5595f65ecc741" args="(const Zone_dis_base &amp;z, const Zone_Cl_dis_base &amp;zcl, Matrice &amp;matrice, const DoubleTab &amp;inverse_quantitee_entrelacee, const ArrOfDouble &amp;coef_som)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void updateP0P1 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classZone__dis__base.html">Zone_dis_base</a> &amp;&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classZone__Cl__dis__base.html">Zone_Cl_dis_base</a> &amp;&#160;</td>
          <td class="paramname"><em>zcl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatrice.html">Matrice</a> &amp;&#160;</td>
          <td class="paramname"><em>matrice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>inverse_quantitee_entrelacee</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;&#160;</td>
          <td class="paramname"><em>coef_som</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>&lt; RIEN</p>
<p>&lt; On ne traite que les faces internes </p>
</p>

<p>Definition at line <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l03048">3048</a> of file <a class="el" href="AssembleurPP1BUtil_8cpp_source.html">AssembleurPP1BUtil.cpp</a>.</p>

<p>References <a class="el" href="EntreeSortie_8h_source.html#l00032">Cerr</a>, <a class="el" href="Objet__U_8h_source.html#l00079">Objet_U::dimension</a>, <a class="el" href="Zone__VF_8h_source.html#l00773">Zone_VF::est_une_face_virt_bord()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00046">face_associee</a>, <a class="el" href="Zone__VF_8h_source.html#l00458">Zone_VF::face_voisins()</a>, <a class="el" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>, <a class="el" href="Cond__lim_8h_source.html#l00130">Cond_lim::frontiere_dis()</a>, <a class="el" href="Matrice__Bloc_8cpp_source.html#l00568">Matrice_Bloc::get_bloc()</a>, <a class="el" href="Zone__Cl__dis__base_8cpp_source.html#l00522">Zone_Cl_dis_base::les_conditions_limites()</a>, <a class="el" href="Front__VF_8h_source.html#l00066">Front_VF::nb_faces_tot()</a>, <a class="el" href="Zone__VF_8h_source.html#l00527">Zone_VF::nb_faces_tot()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00081">okface()</a>, <a class="el" href="Zone__VF_8h_source.html#l00512">Zone_VF::premiere_face_int()</a>, <a class="el" href="Cast_8h_source.html#l00059">ref_cast</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00349">remplir_sommets()</a>, <a class="el" href="vect__impl_8h_source.html#l00057">vect_impl::size()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00286">sort()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00983">update_matrice_NeumannP0P1()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00600">update_matriceP0P1()</a>, and <a class="el" href="Deriv__Matrice__Base_8h_source.html#l00028">Deriv_Matrice_Base::valeur()</a>.</p>

<p>Referenced by <a class="el" href="Assembleur__P__VEFPreP1B_8cpp_source.html#l00230">Assembleur_P_VEFPreP1B::assembler_mat()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">int</span> dimension=<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>;
  <span class="keyword">const</span> <a class="code" href="classZone__VEF.html" title="class Zone_VEF Classe instanciable qui derive de Zone_VF. Cette classe contient les informations geom...">Zone_VEF</a>&amp; zone_VEF=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a>, z);
  <span class="keyword">const</span> <a class="code" href="classZone__Cl__VEF.html">Zone_Cl_VEF</a>&amp; zone_Cl_VEF=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classZone__Cl__VEF.html">Zone_Cl_VEF</a>, zcl);
  <span class="keyword">const</span> <a class="code" href="classConds__lim.html">Conds_lim</a>&amp; les_cl = zone_Cl_VEF.<a class="code" href="classZone__Cl__dis__base.html#af75e0ed7786863e4d333bfb29d67c323" title="Renvoie la i-ieme condition aux limites. (version const)">les_conditions_limites</a>();
  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; face_voisins = zone_VEF.<a class="code" href="classZone__VF.html#a49d4322f5585a8fa95748ca785b70702" title="renvoie l&#39;element voisin de numface dans la direction i. i=0 : dans le sens oppose de l&#39;axe orthogona...">face_voisins</a>();
  <span class="keywordtype">int</span> nint = zone_VEF.<a class="code" href="classZone__VF.html#a12869806fa4834aca8f2964e16509dfd" title="une face est interne ssi elle separe deux elements. renvoie le numero de la premiere face interne...">premiere_face_int</a>();
  <span class="keywordtype">int</span> nb_faces = zone_VEF.<a class="code" href="classZone__VF.html#a50fd21c9535680489015a3c8b88c685a" title="renvoie le nombre total de faces. C&#39;est-a-dire faces reelles + faces virtuelles">nb_faces_tot</a>();
  <span class="keywordtype">int</span> elem1, elem2, face, ok;
  <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> sommets(dimension+2);
  <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> face_opp1(dimension+2);
  <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> face_opp2(dimension+2);
  <a class="code" href="classMatrice__Bloc.html">Matrice_Bloc</a>&amp; A=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Bloc.html">Matrice_Bloc</a>, matrice.<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>());
  <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; ARR=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>, A.<a class="code" href="classMatrice__Bloc.html#a7ffa38f7b93454432b2df7c616ed0a4e">get_bloc</a>(0,0).<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>());
  <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; ARV=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>, A.<a class="code" href="classMatrice__Bloc.html#a7ffa38f7b93454432b2df7c616ed0a4e">get_bloc</a>(0,1).<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>());
  <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; AVR=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>, A.<a class="code" href="classMatrice__Bloc.html#a7ffa38f7b93454432b2df7c616ed0a4e">get_bloc</a>(1,0).<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>());
  <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; AVV=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>, A.<a class="code" href="classMatrice__Bloc.html#a7ffa38f7b93454432b2df7c616ed0a4e">get_bloc</a>(1,1).<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>());
<span class="comment">// Faces de bord :</span>
  <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;les_cl.<a class="code" href="classvect__impl.html#a78155bfbd6b61f4710b9830641ed1694">size</a>(); i++)
    {
      <span class="keyword">const</span> <a class="code" href="classCond__lim.html" title="classe Cond_lim Classe generique servant a representer n&#39;importe quelle classe derivee de la classe C...">Cond_lim</a>&amp; la_cl = les_cl[i];
      <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp; le_bord = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>,la_cl.<a class="code" href="classCond__lim.html#a5b2d24809cee07727006a891d4ce8d22" title="Appel a l&#39;objet sous-jacent Renvoie la frontiere discretisee associee a la condition aux limites...">frontiere_dis</a>());
      <span class="keywordtype">int</span> nb_faces_bord_tot = le_bord.<a class="code" href="classFront__VF.html#aed4006d91bf2ef3af2b9f7933d863a09" title="Nombre de faces reelles et virtuelles du bord.">nb_faces_tot</a>();
      <span class="keywordflow">for</span>(<span class="keywordtype">int</span> ind_face=0; ind_face&lt;nb_faces_bord_tot; ind_face++)
        {
          ok=<a class="code" href="AssembleurPP1BUtil_8cpp.html#a40cf40213663174bb24649e51832bf3e">okface</a>(ind_face, face, la_cl);
          <span class="keywordflow">if</span> (ok==-1) <span class="keywordflow">break</span>;
          elem1=face_voisins(face, 0);
          elem2=face_voisins(face, 1);
          <a class="code" href="AssembleurPP1BUtil_8cpp.html#afd0a249a235b161c5267e7574e199a82">remplir_sommets</a>(zone_VEF, face, elem1, elem2, sommets,
                          face_opp1, face_opp2);
          <a class="code" href="AssembleurPP1BUtil_8cpp.html#acff816d35f8d4ce978f860e0cd958b8a">sort</a>(sommets, face_opp1, face_opp2);
          <span class="keywordflow">if</span>(ok==3)
            {
              <a class="code" href="AssembleurPP1BUtil_8cpp.html#a1aa97c31d5b8f95ae899f599d606a1da">update_matrice_NeumannP0P1</a>(zone_VEF,
                                         inverse_quantitee_entrelacee,
                                         face, elem1, sommets,
                                         face_opp1, coef_som,
                                         ARR,ARV,AVR,AVV);
            }
          <span class="keywordflow">else</span> <span class="keywordflow">if</span>(ok==4)
            {
              ;<span class="comment">//!&lt; RIEN</span>
<span class="comment"></span>            }
          <span class="keywordflow">else</span>
            <a class="code" href="AssembleurPP1BUtil_8cpp.html#aa7aef5562f5fe1f2d5b1eeb6664bca53">update_matriceP0P1</a>(zone_VEF,
                               inverse_quantitee_entrelacee,
                               face, elem1, elem2, sommets,
                               face_opp1, face_opp2, coef_som,
                               ARR,ARV,AVR,AVV);
        }
    }
  <a class="code" href="AssembleurPP1BUtil_8cpp.html#a3e374d53ebc7860e1c2f0b7906f2936d">face_associee</a>=-1;
  <span class="keywordflow">for</span>(face=nint; face&lt;nb_faces; face++)
    {
      elem1=face_voisins(face, 0);
      elem2=face_voisins(face, 1);
      <span class="keywordflow">if</span> (!zone_VEF.<a class="code" href="classZone__VF.html#a33909d3880435e82e84639b51482d2c6" title="renvoie 1 si face est une face virtuelle de bord, 0 sinon">est_une_face_virt_bord</a>(face)) <span class="comment">//!&lt; On ne traite que les faces internes</span>
<span class="comment"></span>        {
          <a class="code" href="AssembleurPP1BUtil_8cpp.html#afd0a249a235b161c5267e7574e199a82">remplir_sommets</a>(zone_VEF, face, elem1, elem2, sommets,
                          face_opp1, face_opp2);
          <a class="code" href="AssembleurPP1BUtil_8cpp.html#acff816d35f8d4ce978f860e0cd958b8a">sort</a>(sommets, face_opp1, face_opp2);
          <a class="code" href="AssembleurPP1BUtil_8cpp.html#aa7aef5562f5fe1f2d5b1eeb6664bca53">update_matriceP0P1</a>(zone_VEF,
                             inverse_quantitee_entrelacee,
                             face, elem1, elem2, sommets,
                             face_opp1, face_opp2, coef_som,
                             ARR,ARV,AVR,AVV);
        }
    }
  <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Update POP1 OK&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="aacede92ea2595a5546e6357fbd1e1498"></a><!-- doxytag: member="AssembleurPP1BUtil.cpp::updateP0Pa" ref="aacede92ea2595a5546e6357fbd1e1498" args="(const Zone_dis_base &amp;z, const Zone_Cl_dis_base &amp;zcl, Matrice &amp;matrice, const DoubleTab &amp;inverse_quantitee_entrelacee)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void updateP0Pa </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classZone__dis__base.html">Zone_dis_base</a> &amp;&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classZone__Cl__dis__base.html">Zone_Cl_dis_base</a> &amp;&#160;</td>
          <td class="paramname"><em>zcl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatrice.html">Matrice</a> &amp;&#160;</td>
          <td class="paramname"><em>matrice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>inverse_quantitee_entrelacee</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>&lt; RIEN</p>
<p>&lt; On ne traite que les faces internes </p>
</p>

<p>Definition at line <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l02730">2730</a> of file <a class="el" href="AssembleurPP1BUtil_8cpp_source.html">AssembleurPP1BUtil.cpp</a>.</p>

<p>References <a class="el" href="EntreeSortie_8h_source.html#l00032">Cerr</a>, <a class="el" href="Objet__U_8h_source.html#l00079">Objet_U::dimension</a>, <a class="el" href="Zone__VF_8h_source.html#l00773">Zone_VF::est_une_face_virt_bord()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00046">face_associee</a>, <a class="el" href="Zone__VF_8h_source.html#l00458">Zone_VF::face_voisins()</a>, <a class="el" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>, <a class="el" href="Cond__lim_8h_source.html#l00130">Cond_lim::frontiere_dis()</a>, <a class="el" href="Matrice__Bloc_8cpp_source.html#l00568">Matrice_Bloc::get_bloc()</a>, <a class="el" href="Zone__Cl__dis__base_8cpp_source.html#l00522">Zone_Cl_dis_base::les_conditions_limites()</a>, <a class="el" href="Front__VF_8h_source.html#l00066">Front_VF::nb_faces_tot()</a>, <a class="el" href="Zone__VF_8h_source.html#l00527">Zone_VF::nb_faces_tot()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00081">okface()</a>, <a class="el" href="Zone__VF_8h_source.html#l00512">Zone_VF::premiere_face_int()</a>, <a class="el" href="Cast_8h_source.html#l00059">ref_cast</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00349">remplir_sommets()</a>, <a class="el" href="vect__impl_8h_source.html#l00057">vect_impl::size()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l01765">update_matrice_NeumannP0Pa()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l01634">update_matriceP0Pa()</a>, and <a class="el" href="Deriv__Matrice__Base_8h_source.html#l00028">Deriv_Matrice_Base::valeur()</a>.</p>

<p>Referenced by <a class="el" href="Assembleur__P__VEFPreP1B_8cpp_source.html#l00230">Assembleur_P_VEFPreP1B::assembler_mat()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">int</span> dimension=<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>;
  <span class="keyword">const</span> <a class="code" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a>&amp; zone_VEF=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a>, z);
  <span class="keyword">const</span> <a class="code" href="classZone__Cl__VEF.html">Zone_Cl_VEF</a>&amp; zone_Cl_VEF=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classZone__Cl__VEF.html">Zone_Cl_VEF</a>, zcl);
  <span class="keyword">const</span> <a class="code" href="classConds__lim.html">Conds_lim</a>&amp; les_cl = zone_Cl_VEF.<a class="code" href="classZone__Cl__dis__base.html#af75e0ed7786863e4d333bfb29d67c323" title="Renvoie la i-ieme condition aux limites. (version const)">les_conditions_limites</a>();
  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; face_voisins = zone_VEF.<a class="code" href="classZone__VF.html#a49d4322f5585a8fa95748ca785b70702" title="renvoie l&#39;element voisin de numface dans la direction i. i=0 : dans le sens oppose de l&#39;axe orthogona...">face_voisins</a>();
  <span class="keywordtype">int</span> nint = zone_VEF.<a class="code" href="classZone__VF.html#a12869806fa4834aca8f2964e16509dfd" title="une face est interne ssi elle separe deux elements. renvoie le numero de la premiere face interne...">premiere_face_int</a>();
  <span class="keywordtype">int</span> nb_faces = zone_VEF.<a class="code" href="classZone__VF.html#a50fd21c9535680489015a3c8b88c685a" title="renvoie le nombre total de faces. C&#39;est-a-dire faces reelles + faces virtuelles">nb_faces_tot</a>();
  <span class="keywordtype">int</span> elem1, elem2, face, ok;
  <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> sommets(dimension+2);
  <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> face_opp1(dimension+2);
  <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> face_opp2(dimension+2);
  <a class="code" href="classMatrice__Bloc.html">Matrice_Bloc</a>&amp; A=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Bloc.html">Matrice_Bloc</a>, matrice.<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>());
  <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; ARR=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>, A.<a class="code" href="classMatrice__Bloc.html#a7ffa38f7b93454432b2df7c616ed0a4e">get_bloc</a>(0,0).<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>());
  <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; ARV=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>, A.<a class="code" href="classMatrice__Bloc.html#a7ffa38f7b93454432b2df7c616ed0a4e">get_bloc</a>(0,1).<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>());
  <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; AVR=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>, A.<a class="code" href="classMatrice__Bloc.html#a7ffa38f7b93454432b2df7c616ed0a4e">get_bloc</a>(1,0).<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>());
  <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; AVV=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>, A.<a class="code" href="classMatrice__Bloc.html#a7ffa38f7b93454432b2df7c616ed0a4e">get_bloc</a>(1,1).<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>());
<span class="comment">// Faces de bord :</span>
  <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;les_cl.<a class="code" href="classvect__impl.html#a78155bfbd6b61f4710b9830641ed1694">size</a>(); i++)
    {
      <span class="keyword">const</span> <a class="code" href="classCond__lim.html" title="classe Cond_lim Classe generique servant a representer n&#39;importe quelle classe derivee de la classe C...">Cond_lim</a>&amp; la_cl = les_cl[i];
      <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp; le_bord = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>,la_cl.<a class="code" href="classCond__lim.html#a5b2d24809cee07727006a891d4ce8d22" title="Appel a l&#39;objet sous-jacent Renvoie la frontiere discretisee associee a la condition aux limites...">frontiere_dis</a>());
      <span class="keywordtype">int</span> nb_faces_bord_tot = le_bord.<a class="code" href="classFront__VF.html#aed4006d91bf2ef3af2b9f7933d863a09" title="Nombre de faces reelles et virtuelles du bord.">nb_faces_tot</a>();
      <span class="keywordflow">for</span>(<span class="keywordtype">int</span> ind_face=0; ind_face&lt;nb_faces_bord_tot; ind_face++)
        {
          ok=<a class="code" href="AssembleurPP1BUtil_8cpp.html#a40cf40213663174bb24649e51832bf3e">okface</a>(ind_face, face, la_cl);
          <span class="keywordflow">if</span> (ok==-1) <span class="keywordflow">break</span>;
          elem1=face_voisins(face, 0);
          elem2=face_voisins(face, 1);
          <a class="code" href="AssembleurPP1BUtil_8cpp.html#afd0a249a235b161c5267e7574e199a82">remplir_sommets</a>(zone_VEF, face, elem1, elem2, sommets,
                          face_opp1, face_opp2);
          <span class="keywordflow">if</span>(ok==3)
            {
              <a class="code" href="AssembleurPP1BUtil_8cpp.html#a45b45851ba59992d7eb7a25c002a9f73">update_matrice_NeumannP0Pa</a>(zone_VEF,
                                         inverse_quantitee_entrelacee,
                                         face, elem1, sommets,
                                         face_opp1,
                                         ARR,ARV,AVR,AVV);
            }
          <span class="keywordflow">else</span> <span class="keywordflow">if</span>(ok==4)
            {
              ; <span class="comment">//!&lt; RIEN</span>
<span class="comment"></span>            }
          <span class="keywordflow">else</span>
            <a class="code" href="AssembleurPP1BUtil_8cpp.html#a68f4b5d510b37d5518ed576764da2611">update_matriceP0Pa</a>(zone_VEF, inverse_quantitee_entrelacee,
                               face, elem1, elem2, sommets,
                               face_opp1, face_opp2,
                               ARR,ARV,AVR,AVV);
        }
    }
  <a class="code" href="AssembleurPP1BUtil_8cpp.html#a3e374d53ebc7860e1c2f0b7906f2936d">face_associee</a>=-1;
  <span class="keywordflow">for</span>(face=nint; face&lt;nb_faces; face++)
    {
      elem1=face_voisins(face, 0);
      elem2=face_voisins(face, 1);
      <span class="keywordflow">if</span> (!zone_VEF.<a class="code" href="classZone__VF.html#a33909d3880435e82e84639b51482d2c6" title="renvoie 1 si face est une face virtuelle de bord, 0 sinon">est_une_face_virt_bord</a>(face)) <span class="comment">//!&lt; On ne traite que les faces internes</span>
<span class="comment"></span>        {
          <a class="code" href="AssembleurPP1BUtil_8cpp.html#afd0a249a235b161c5267e7574e199a82">remplir_sommets</a>(zone_VEF, face, elem1, elem2, sommets,
                          face_opp1, face_opp2);
          <a class="code" href="AssembleurPP1BUtil_8cpp.html#a68f4b5d510b37d5518ed576764da2611">update_matriceP0Pa</a>(zone_VEF,
                             inverse_quantitee_entrelacee,
                             face, elem1, elem2, sommets,
                             face_opp1, face_opp2,
                             ARR,ARV,AVR,AVV);
        }
    }
  <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Update P0Pa OK&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="ab3c25c4172223f48fd2f9d433b005e0c"></a><!-- doxytag: member="AssembleurPP1BUtil.cpp::updateP1P1" ref="ab3c25c4172223f48fd2f9d433b005e0c" args="(const Zone_dis_base &amp;z, const Zone_Cl_dis_base &amp;zcl, Matrice &amp;matrice, const DoubleTab &amp;inverse_quantitee_entrelacee, const ArrOfDouble &amp;coef_som)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void updateP1P1 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classZone__dis__base.html">Zone_dis_base</a> &amp;&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classZone__Cl__dis__base.html">Zone_Cl_dis_base</a> &amp;&#160;</td>
          <td class="paramname"><em>zcl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatrice.html">Matrice</a> &amp;&#160;</td>
          <td class="paramname"><em>matrice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>inverse_quantitee_entrelacee</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;&#160;</td>
          <td class="paramname"><em>coef_som</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>&lt; On ne traite que les faces internes </p>
</p>

<p>Definition at line <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l02339">2339</a> of file <a class="el" href="AssembleurPP1BUtil_8cpp_source.html">AssembleurPP1BUtil.cpp</a>.</p>

<p>References <a class="el" href="EntreeSortie_8h_source.html#l00032">Cerr</a>, <a class="el" href="Objet__U_8h_source.html#l00079">Objet_U::dimension</a>, <a class="el" href="Zone__VF_8h_source.html#l00773">Zone_VF::est_une_face_virt_bord()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00046">face_associee</a>, <a class="el" href="Zone__VF_8h_source.html#l00458">Zone_VF::face_voisins()</a>, <a class="el" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>, <a class="el" href="Cond__lim_8h_source.html#l00130">Cond_lim::frontiere_dis()</a>, <a class="el" href="Matrice__Bloc_8cpp_source.html#l00568">Matrice_Bloc::get_bloc()</a>, <a class="el" href="Zone__Cl__dis__base_8cpp_source.html#l00522">Zone_Cl_dis_base::les_conditions_limites()</a>, <a class="el" href="Front__VF_8h_source.html#l00066">Front_VF::nb_faces_tot()</a>, <a class="el" href="Zone__VF_8h_source.html#l00527">Zone_VF::nb_faces_tot()</a>, <a class="el" href="Zone_8cpp_source.html#l00586">Zone::nb_som()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00081">okface()</a>, <a class="el" href="Zone__VF_8h_source.html#l00512">Zone_VF::premiere_face_int()</a>, <a class="el" href="Cast_8h_source.html#l00059">ref_cast</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00349">remplir_sommets()</a>, <a class="el" href="vect__impl_8h_source.html#l00057">vect_impl::size()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00286">sort()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l01084">update_matrice_NeumannP1P1()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l01191">update_matrice_SymetrieP1P1()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00694">update_matriceP1P1()</a>, <a class="el" href="Deriv__Matrice__Base_8h_source.html#l00028">Deriv_Matrice_Base::valeur()</a>, and <a class="el" href="Zone__dis__base_8h_source.html#l00106">Zone_dis_base::zone()</a>.</p>

<p>Referenced by <a class="el" href="Assembleur__P__VEFPreP1B_8cpp_source.html#l00230">Assembleur_P_VEFPreP1B::assembler_mat()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">int</span> dimension=<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>;
  <span class="keyword">const</span> <a class="code" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a>&amp; zone_VEF=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a>, z);
<span class="comment">// const Zone&amp; zone=zone_VEF.zone();</span>
  <span class="keyword">const</span> <a class="code" href="classZone__Cl__VEF.html">Zone_Cl_VEF</a>&amp; zone_Cl_VEF=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classZone__Cl__VEF.html">Zone_Cl_VEF</a>, zcl);
  <span class="keyword">const</span> <a class="code" href="classConds__lim.html">Conds_lim</a>&amp; les_cl = zone_Cl_VEF.<a class="code" href="classZone__Cl__dis__base.html#af75e0ed7786863e4d333bfb29d67c323" title="Renvoie la i-ieme condition aux limites. (version const)">les_conditions_limites</a>();
  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; face_voisins = zone_VEF.<a class="code" href="classZone__VF.html#a49d4322f5585a8fa95748ca785b70702" title="renvoie l&#39;element voisin de numface dans la direction i. i=0 : dans le sens oppose de l&#39;axe orthogona...">face_voisins</a>();
  <span class="keywordtype">int</span> nint = zone_VEF.<a class="code" href="classZone__VF.html#a12869806fa4834aca8f2964e16509dfd" title="une face est interne ssi elle separe deux elements. renvoie le numero de la premiere face interne...">premiere_face_int</a>();
  <span class="keywordtype">int</span> nb_faces = zone_VEF.<a class="code" href="classZone__VF.html#a50fd21c9535680489015a3c8b88c685a" title="renvoie le nombre total de faces. C&#39;est-a-dire faces reelles + faces virtuelles">nb_faces_tot</a>();
<span class="comment">// int nb_som = zone_VEF.zone().nb_som_tot();</span>
  <span class="keywordtype">int</span> elem1, elem2, face, ok;
<span class="comment">// int nnz=nb_som;</span>
  <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> sommets(dimension+2);
  <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> face_opp1(dimension+2);
  <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> face_opp2(dimension+2);
  <a class="code" href="classMatrice__Bloc.html">Matrice_Bloc</a>&amp; A=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Bloc.html">Matrice_Bloc</a>, matrice.<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>());
  <a class="code" href="classMatrice__Morse__Sym.html" title="Classe Matrice_Morse_Sym Represente une matrice M (creuse) symetrique stockee au format Morse Symetri...">Matrice_Morse_Sym</a>&amp; ARR=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Morse__Sym.html" title="Classe Matrice_Morse_Sym Represente une matrice M (creuse) symetrique stockee au format Morse Symetri...">Matrice_Morse_Sym</a>, A.<a class="code" href="classMatrice__Bloc.html#a7ffa38f7b93454432b2df7c616ed0a4e">get_bloc</a>(0,0).<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>());
  <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; ARV=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>, A.<a class="code" href="classMatrice__Bloc.html#a7ffa38f7b93454432b2df7c616ed0a4e">get_bloc</a>(0,1).<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>());
  <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; AVR=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>, A.<a class="code" href="classMatrice__Bloc.html#a7ffa38f7b93454432b2df7c616ed0a4e">get_bloc</a>(1,0).<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>());
  <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; AVV=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>, A.<a class="code" href="classMatrice__Bloc.html#a7ffa38f7b93454432b2df7c616ed0a4e">get_bloc</a>(1,1).<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>());
<span class="comment">// Faces de bord :</span>
  <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;les_cl.<a class="code" href="classvect__impl.html#a78155bfbd6b61f4710b9830641ed1694">size</a>(); i++)
    {
      <span class="keyword">const</span> <a class="code" href="classCond__lim.html" title="classe Cond_lim Classe generique servant a representer n&#39;importe quelle classe derivee de la classe C...">Cond_lim</a>&amp; la_cl = les_cl[i];
      <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp; le_bord = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>,la_cl.<a class="code" href="classCond__lim.html#a5b2d24809cee07727006a891d4ce8d22" title="Appel a l&#39;objet sous-jacent Renvoie la frontiere discretisee associee a la condition aux limites...">frontiere_dis</a>());
      <span class="keywordtype">int</span> nb_faces_bord_tot = le_bord.<a class="code" href="classFront__VF.html#aed4006d91bf2ef3af2b9f7933d863a09" title="Nombre de faces reelles et virtuelles du bord.">nb_faces_tot</a>();
      <span class="keywordflow">for</span>(<span class="keywordtype">int</span> ind_face=0; ind_face&lt;nb_faces_bord_tot; ind_face++)
        {
          ok=<a class="code" href="AssembleurPP1BUtil_8cpp.html#a40cf40213663174bb24649e51832bf3e">okface</a>(ind_face, face, la_cl);
          <span class="keywordflow">if</span> (ok==-1) <span class="keywordflow">break</span>;
          elem1=face_voisins(face, 0);
          elem2=face_voisins(face, 1);
          <a class="code" href="AssembleurPP1BUtil_8cpp.html#afd0a249a235b161c5267e7574e199a82">remplir_sommets</a>(zone_VEF, face, elem1, elem2, sommets,
                          face_opp1, face_opp2);
          <a class="code" href="AssembleurPP1BUtil_8cpp.html#acff816d35f8d4ce978f860e0cd958b8a">sort</a>(sommets, face_opp1, face_opp2);
          <span class="keywordflow">if</span>(ok==3)
            {
              <a class="code" href="AssembleurPP1BUtil_8cpp.html#affe9938bfd355c4e19b608c286c0293b">update_matrice_NeumannP1P1</a>(zone_VEF,
                                         inverse_quantitee_entrelacee,
                                         face, elem1, sommets,
                                         face_opp1, coef_som,
                                         ARR,ARV,AVR,AVV);
            }
          <span class="keywordflow">else</span> <span class="keywordflow">if</span>(ok==4)
            {
              <a class="code" href="AssembleurPP1BUtil_8cpp.html#ade1c92b286a861f3920664b658ba3fb1">update_matrice_SymetrieP1P1</a>(zone_VEF,
                                          inverse_quantitee_entrelacee,
                                          face, elem1, sommets,
                                          face_opp1, coef_som,
                                          ARR,ARV,AVR,AVV);
            }
          <span class="keywordflow">else</span>
            <a class="code" href="AssembleurPP1BUtil_8cpp.html#a77351839245012751e4d90a39922356a">update_matriceP1P1</a>(zone_VEF,
                               inverse_quantitee_entrelacee,
                               face, elem1, elem2, sommets,
                               face_opp1, face_opp2, coef_som,
                               ARR,ARV,AVR,AVV);
        }
    }
  <a class="code" href="AssembleurPP1BUtil_8cpp.html#a3e374d53ebc7860e1c2f0b7906f2936d">face_associee</a>=-1;
  <span class="keywordflow">for</span>(face=nint; face&lt;nb_faces; face++)
    {
      elem1=face_voisins(face, 0);
      elem2=face_voisins(face, 1);
      <span class="keywordflow">if</span> (!zone_VEF.<a class="code" href="classZone__VF.html#a33909d3880435e82e84639b51482d2c6" title="renvoie 1 si face est une face virtuelle de bord, 0 sinon">est_une_face_virt_bord</a>(face)) <span class="comment">//!&lt; On ne traite que les faces internes</span>
<span class="comment"></span>        {
          <a class="code" href="AssembleurPP1BUtil_8cpp.html#afd0a249a235b161c5267e7574e199a82">remplir_sommets</a>(zone_VEF, face, elem1, elem2, sommets,
                          face_opp1, face_opp2);
          <a class="code" href="AssembleurPP1BUtil_8cpp.html#acff816d35f8d4ce978f860e0cd958b8a">sort</a>(sommets, face_opp1, face_opp2);
          <a class="code" href="AssembleurPP1BUtil_8cpp.html#a77351839245012751e4d90a39922356a">update_matriceP1P1</a>(zone_VEF, inverse_quantitee_entrelacee,
                             face, elem1, elem2, sommets,
                             face_opp1, face_opp2, coef_som,
                             ARR,ARV,AVR,AVV);
        }
    }
  <span class="keywordtype">int</span> nb_som=zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#ad340f571f81fa5c2e028b88c00b5c2ca" title="Renvoie le nombre de sommets de la zone.">nb_som</a>();
  <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;nb_som; i++)
    <span class="keywordflow">if</span>(ARR(i,i)==0)
      {
<span class="comment">// Cerr &lt;&lt; &quot;On modifie la ligne (sommet) orpheline &quot; &lt;&lt; i &lt;&lt; finl;</span>
        ARR(i,i)=1.;
      }
  <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Update P1 OK&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a8d9349eb29399f4ac72dc10543a4005a"></a><!-- doxytag: member="AssembleurPP1BUtil.cpp::updateP1Pa" ref="a8d9349eb29399f4ac72dc10543a4005a" args="(const Zone_dis_base &amp;z, const Zone_Cl_dis_base &amp;zcl, Matrice &amp;matrice, const DoubleTab &amp;inverse_quantitee_entrelacee, const ArrOfDouble &amp;coef_som)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void updateP1Pa </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classZone__dis__base.html">Zone_dis_base</a> &amp;&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classZone__Cl__dis__base.html">Zone_Cl_dis_base</a> &amp;&#160;</td>
          <td class="paramname"><em>zcl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatrice.html">Matrice</a> &amp;&#160;</td>
          <td class="paramname"><em>matrice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>inverse_quantitee_entrelacee</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;&#160;</td>
          <td class="paramname"><em>coef_som</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>&lt; On ne traite que les faces internes </p>
</p>

<p>Definition at line <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l02885">2885</a> of file <a class="el" href="AssembleurPP1BUtil_8cpp_source.html">AssembleurPP1BUtil.cpp</a>.</p>

<p>References <a class="el" href="EntreeSortie_8h_source.html#l00032">Cerr</a>, <a class="el" href="Objet__U_8h_source.html#l00079">Objet_U::dimension</a>, <a class="el" href="Zone__VF_8h_source.html#l00773">Zone_VF::est_une_face_virt_bord()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00046">face_associee</a>, <a class="el" href="Zone__VF_8h_source.html#l00458">Zone_VF::face_voisins()</a>, <a class="el" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>, <a class="el" href="Cond__lim_8h_source.html#l00130">Cond_lim::frontiere_dis()</a>, <a class="el" href="Matrice__Bloc_8cpp_source.html#l00568">Matrice_Bloc::get_bloc()</a>, <a class="el" href="Zone__Cl__dis__base_8cpp_source.html#l00522">Zone_Cl_dis_base::les_conditions_limites()</a>, <a class="el" href="Front__VF_8h_source.html#l00066">Front_VF::nb_faces_tot()</a>, <a class="el" href="Zone__VF_8h_source.html#l00527">Zone_VF::nb_faces_tot()</a>, <a class="el" href="Zone_8cpp_source.html#l00608">Zone::nb_som_tot()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00081">okface()</a>, <a class="el" href="Zone__VF_8h_source.html#l00512">Zone_VF::premiere_face_int()</a>, <a class="el" href="Cast_8h_source.html#l00059">ref_cast</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00349">remplir_sommets()</a>, <a class="el" href="vect__impl_8h_source.html#l00057">vect_impl::size()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l02025">update_matrice_NeumannP1Pa()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l02157">update_matrice_SymetrieP1Pa()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l01888">update_matriceP1Pa()</a>, <a class="el" href="Deriv__Matrice__Base_8h_source.html#l00028">Deriv_Matrice_Base::valeur()</a>, and <a class="el" href="Zone__dis__base_8h_source.html#l00106">Zone_dis_base::zone()</a>.</p>

<p>Referenced by <a class="el" href="Assembleur__P__VEFPreP1B_8cpp_source.html#l00230">Assembleur_P_VEFPreP1B::assembler_mat()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">int</span> dimension=<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>;
  <span class="keyword">const</span> <a class="code" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a>&amp; zone_VEF=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a>, z);
  <span class="keyword">const</span> <a class="code" href="classZone.html" title="classe Zone Une Zone est un maillage compose d&#39;un ensemble d&#39;elements geometriques de meme type...">Zone</a>&amp; zone=zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>();
  <span class="keyword">const</span> <a class="code" href="classZone__Cl__VEF.html">Zone_Cl_VEF</a>&amp; zone_Cl_VEF=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classZone__Cl__VEF.html">Zone_Cl_VEF</a>, zcl);
  <span class="keyword">const</span> <a class="code" href="classConds__lim.html">Conds_lim</a>&amp; les_cl = zone_Cl_VEF.<a class="code" href="classZone__Cl__dis__base.html#af75e0ed7786863e4d333bfb29d67c323" title="Renvoie la i-ieme condition aux limites. (version const)">les_conditions_limites</a>();
  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; face_voisins = zone_VEF.<a class="code" href="classZone__VF.html#a49d4322f5585a8fa95748ca785b70702" title="renvoie l&#39;element voisin de numface dans la direction i. i=0 : dans le sens oppose de l&#39;axe orthogona...">face_voisins</a>();
  <span class="keywordtype">int</span> nint = zone_VEF.<a class="code" href="classZone__VF.html#a12869806fa4834aca8f2964e16509dfd" title="une face est interne ssi elle separe deux elements. renvoie le numero de la premiere face interne...">premiere_face_int</a>();
  <span class="keywordtype">int</span> nb_faces = zone_VEF.<a class="code" href="classZone__VF.html#a50fd21c9535680489015a3c8b88c685a" title="renvoie le nombre total de faces. C&#39;est-a-dire faces reelles + faces virtuelles">nb_faces_tot</a>();
  <span class="keywordtype">int</span> elem1, elem2, face, ok;
  <span class="keywordtype">int</span> nb_som = zone.<a class="code" href="classZone.html#a01ed67af826d6045ef4eacfb87a663e8" title="Renvoie le nombre total de sommets de la zone. i.e. le nombre de sommets reels et virtuels sur le pro...">nb_som_tot</a>();
  <a class="code" href="classIntLists.html" title="Un tableau de listes de type IntList.">IntLists</a> voisins(nb_som);
  <a class="code" href="classDoubleLists.html" title="Un tableau de listes de type DoubleList.">DoubleLists</a> coeffs(nb_som);
  <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> sommets(dimension+2);
  <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> face_opp1(dimension+2);
  <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> face_opp2(dimension+2);
  <a class="code" href="classMatrice__Bloc.html">Matrice_Bloc</a>&amp; A=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Bloc.html">Matrice_Bloc</a>, matrice.<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>());
  <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; ARR=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>, A.<a class="code" href="classMatrice__Bloc.html#a7ffa38f7b93454432b2df7c616ed0a4e">get_bloc</a>(0,0).<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>());
  <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; ARV=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>, A.<a class="code" href="classMatrice__Bloc.html#a7ffa38f7b93454432b2df7c616ed0a4e">get_bloc</a>(0,1).<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>());
  <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; AVR=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>, A.<a class="code" href="classMatrice__Bloc.html#a7ffa38f7b93454432b2df7c616ed0a4e">get_bloc</a>(1,0).<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>());
  <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; AVV=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>, A.<a class="code" href="classMatrice__Bloc.html#a7ffa38f7b93454432b2df7c616ed0a4e">get_bloc</a>(1,1).<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>());
<span class="comment">// Faces de bord :</span>
  <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;les_cl.<a class="code" href="classvect__impl.html#a78155bfbd6b61f4710b9830641ed1694">size</a>(); i++)
    {
      <span class="keyword">const</span> <a class="code" href="classCond__lim.html" title="classe Cond_lim Classe generique servant a representer n&#39;importe quelle classe derivee de la classe C...">Cond_lim</a>&amp; la_cl = les_cl[i];
      <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp; le_bord = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>,la_cl.<a class="code" href="classCond__lim.html#a5b2d24809cee07727006a891d4ce8d22" title="Appel a l&#39;objet sous-jacent Renvoie la frontiere discretisee associee a la condition aux limites...">frontiere_dis</a>());
      <span class="keywordtype">int</span> nb_faces_bord_tot = le_bord.<a class="code" href="classFront__VF.html#aed4006d91bf2ef3af2b9f7933d863a09" title="Nombre de faces reelles et virtuelles du bord.">nb_faces_tot</a>();
      <span class="keywordflow">for</span>(<span class="keywordtype">int</span> ind_face=0; ind_face&lt;nb_faces_bord_tot; ind_face++)
        {
          ok=<a class="code" href="AssembleurPP1BUtil_8cpp.html#a40cf40213663174bb24649e51832bf3e">okface</a>(ind_face, face, la_cl);
          <span class="keywordflow">if</span> (ok==-1) <span class="keywordflow">break</span>;
          elem1=face_voisins(face, 0);
          elem2=face_voisins(face, 1);
          <a class="code" href="AssembleurPP1BUtil_8cpp.html#afd0a249a235b161c5267e7574e199a82">remplir_sommets</a>(zone_VEF, face, elem1, elem2, sommets,
                          face_opp1, face_opp2);
          <span class="keywordflow">if</span>(ok==3)
            {
              <a class="code" href="AssembleurPP1BUtil_8cpp.html#a7da454ba757d1b7ed7ccc39954e6cab5">update_matrice_NeumannP1Pa</a>(zone_VEF,
                                         inverse_quantitee_entrelacee,
                                         face, elem1, sommets,
                                         face_opp1, coef_som,
                                         ARR,ARV,AVR,AVV);
            }
          <span class="keywordflow">else</span> <span class="keywordflow">if</span>(ok==4)
            {
              <a class="code" href="AssembleurPP1BUtil_8cpp.html#aa18f9eabe40c3c77172253c07802c05f">update_matrice_SymetrieP1Pa</a>(zone_VEF,
                                          inverse_quantitee_entrelacee,
                                          face, elem1, sommets,
                                          face_opp1, coef_som,
                                          ARR,ARV,AVR,AVV);
            }
          <span class="keywordflow">else</span>
            <a class="code" href="AssembleurPP1BUtil_8cpp.html#ac499159b3caa7be06c8c9fddfdb5c8c1">update_matriceP1Pa</a>(zone_VEF,
                               inverse_quantitee_entrelacee,
                               face, elem1, elem2, sommets,
                               face_opp1, face_opp2, coef_som,
                               ARR,ARV,AVR,AVV);
        }
    }
  <a class="code" href="AssembleurPP1BUtil_8cpp.html#a3e374d53ebc7860e1c2f0b7906f2936d">face_associee</a>=-1;
  <span class="keywordflow">for</span>(face=nint; face&lt;nb_faces; face++)
    {
      elem1=face_voisins(face, 0);
      elem2=face_voisins(face, 1);
      <span class="keywordflow">if</span> (!zone_VEF.<a class="code" href="classZone__VF.html#a33909d3880435e82e84639b51482d2c6" title="renvoie 1 si face est une face virtuelle de bord, 0 sinon">est_une_face_virt_bord</a>(face)) <span class="comment">//!&lt; On ne traite que les faces internes</span>
<span class="comment"></span>        {
          <a class="code" href="AssembleurPP1BUtil_8cpp.html#afd0a249a235b161c5267e7574e199a82">remplir_sommets</a>(zone_VEF, face, elem1, elem2, sommets,
                          face_opp1, face_opp2);
          <a class="code" href="AssembleurPP1BUtil_8cpp.html#ac499159b3caa7be06c8c9fddfdb5c8c1">update_matriceP1Pa</a>(zone_VEF,
                             inverse_quantitee_entrelacee,
                             face, elem1, elem2, sommets,
                             face_opp1, face_opp2,coef_som,
                             ARR,ARV,AVR,AVV);
        }
    }

  <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Update P1Pa OK&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a4e0c0752e80915fd8b0143b70f08e718"></a><!-- doxytag: member="AssembleurPP1BUtil.cpp::updatePaPa" ref="a4e0c0752e80915fd8b0143b70f08e718" args="(const Zone_dis_base &amp;z, const Zone_Cl_dis_base &amp;zcl, Matrice &amp;matrice, const DoubleTab &amp;inverse_quantitee_entrelacee)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void updatePaPa </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classZone__dis__base.html">Zone_dis_base</a> &amp;&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classZone__Cl__dis__base.html">Zone_Cl_dis_base</a> &amp;&#160;</td>
          <td class="paramname"><em>zcl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatrice.html">Matrice</a> &amp;&#160;</td>
          <td class="paramname"><em>matrice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>inverse_quantitee_entrelacee</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>&lt; On ne traite que les faces internes </p>
</p>

<p>Definition at line <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l02567">2567</a> of file <a class="el" href="AssembleurPP1BUtil_8cpp_source.html">AssembleurPP1BUtil.cpp</a>.</p>

<p>References <a class="el" href="EntreeSortie_8h_source.html#l00032">Cerr</a>, <a class="el" href="Objet__U_8h_source.html#l00079">Objet_U::dimension</a>, <a class="el" href="Zone__VF_8h_source.html#l00773">Zone_VF::est_une_face_virt_bord()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00046">face_associee</a>, <a class="el" href="Zone__VF_8h_source.html#l00458">Zone_VF::face_voisins()</a>, <a class="el" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>, <a class="el" href="Cond__lim_8h_source.html#l00130">Cond_lim::frontiere_dis()</a>, <a class="el" href="Matrice__Bloc_8cpp_source.html#l00568">Matrice_Bloc::get_bloc()</a>, <a class="el" href="Zone__Cl__dis__base_8cpp_source.html#l00522">Zone_Cl_dis_base::les_conditions_limites()</a>, <a class="el" href="Zone_8h_source.html#l01258">Zone::nb_aretes()</a>, <a class="el" href="Front__VF_8h_source.html#l00066">Front_VF::nb_faces_tot()</a>, <a class="el" href="Zone__VF_8h_source.html#l00527">Zone_VF::nb_faces_tot()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00081">okface()</a>, <a class="el" href="Zone__VF_8h_source.html#l00512">Zone_VF::premiere_face_int()</a>, <a class="el" href="Cast_8h_source.html#l00059">ref_cast</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00349">remplir_sommets()</a>, <a class="el" href="vect__impl_8h_source.html#l00057">vect_impl::size()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l01319">update_matrice_NeumannPaPa()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l01478">update_matrice_SymetriePaPa()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00843">update_matricePaPa()</a>, <a class="el" href="Deriv__Matrice__Base_8h_source.html#l00028">Deriv_Matrice_Base::valeur()</a>, and <a class="el" href="Zone__dis__base_8h_source.html#l00106">Zone_dis_base::zone()</a>.</p>

<p>Referenced by <a class="el" href="Assembleur__P__VEFPreP1B_8cpp_source.html#l00230">Assembleur_P_VEFPreP1B::assembler_mat()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">int</span> dimension=<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>;
  <span class="keyword">const</span> <a class="code" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a>&amp; zone_VEF=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a>, z);
  <span class="keyword">const</span> <a class="code" href="classZone.html" title="classe Zone Une Zone est un maillage compose d&#39;un ensemble d&#39;elements geometriques de meme type...">Zone</a>&amp; zone=zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>();
  <span class="keyword">const</span> <a class="code" href="classZone__Cl__VEF.html">Zone_Cl_VEF</a>&amp; zone_Cl_VEF=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classZone__Cl__VEF.html">Zone_Cl_VEF</a>, zcl);
  <span class="keyword">const</span> <a class="code" href="classConds__lim.html">Conds_lim</a>&amp; les_cl = zone_Cl_VEF.<a class="code" href="classZone__Cl__dis__base.html#af75e0ed7786863e4d333bfb29d67c323" title="Renvoie la i-ieme condition aux limites. (version const)">les_conditions_limites</a>();
  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; face_voisins = zone_VEF.<a class="code" href="classZone__VF.html#a49d4322f5585a8fa95748ca785b70702" title="renvoie l&#39;element voisin de numface dans la direction i. i=0 : dans le sens oppose de l&#39;axe orthogona...">face_voisins</a>();
  <span class="keywordtype">int</span> nint = zone_VEF.<a class="code" href="classZone__VF.html#a12869806fa4834aca8f2964e16509dfd" title="une face est interne ssi elle separe deux elements. renvoie le numero de la premiere face interne...">premiere_face_int</a>();
  <span class="keywordtype">int</span> nb_faces = zone_VEF.<a class="code" href="classZone__VF.html#a50fd21c9535680489015a3c8b88c685a" title="renvoie le nombre total de faces. C&#39;est-a-dire faces reelles + faces virtuelles">nb_faces_tot</a>();
  <span class="keywordtype">int</span> nb_arete = zone.<a class="code" href="classZone.html#a3e3b48691911fd85574c7bc10a1a4fb8" title="renvoie le nombre d&#39;aretes reelles.">nb_aretes</a>();
  <span class="keywordtype">int</span> elem1, elem2, face, ok;
  <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> sommets(dimension+2);
  <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> face_opp1(dimension+2);
  <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> face_opp2(dimension+2);
  <a class="code" href="classMatrice__Bloc.html">Matrice_Bloc</a>&amp; A=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Bloc.html">Matrice_Bloc</a>, matrice.<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>());
  <a class="code" href="classMatrice__Morse__Sym.html" title="Classe Matrice_Morse_Sym Represente une matrice M (creuse) symetrique stockee au format Morse Symetri...">Matrice_Morse_Sym</a>&amp; ARR=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Morse__Sym.html" title="Classe Matrice_Morse_Sym Represente une matrice M (creuse) symetrique stockee au format Morse Symetri...">Matrice_Morse_Sym</a>, A.<a class="code" href="classMatrice__Bloc.html#a7ffa38f7b93454432b2df7c616ed0a4e">get_bloc</a>(0,0).<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>());
  <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; ARV=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>, A.<a class="code" href="classMatrice__Bloc.html#a7ffa38f7b93454432b2df7c616ed0a4e">get_bloc</a>(0,1).<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>());
  <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; AVR=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>, A.<a class="code" href="classMatrice__Bloc.html#a7ffa38f7b93454432b2df7c616ed0a4e">get_bloc</a>(1,0).<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>());
  <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; AVV=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>, A.<a class="code" href="classMatrice__Bloc.html#a7ffa38f7b93454432b2df7c616ed0a4e">get_bloc</a>(1,1).<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>());
<span class="comment">// Faces de bord :</span>
  <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;les_cl.<a class="code" href="classvect__impl.html#a78155bfbd6b61f4710b9830641ed1694">size</a>(); i++)
    {
      <span class="keyword">const</span> <a class="code" href="classCond__lim.html" title="classe Cond_lim Classe generique servant a representer n&#39;importe quelle classe derivee de la classe C...">Cond_lim</a>&amp; la_cl = les_cl[i];
      <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp; le_bord = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>,la_cl.<a class="code" href="classCond__lim.html#a5b2d24809cee07727006a891d4ce8d22" title="Appel a l&#39;objet sous-jacent Renvoie la frontiere discretisee associee a la condition aux limites...">frontiere_dis</a>());
      <span class="keywordtype">int</span> nb_faces_bord_tot = le_bord.<a class="code" href="classFront__VF.html#aed4006d91bf2ef3af2b9f7933d863a09" title="Nombre de faces reelles et virtuelles du bord.">nb_faces_tot</a>();
      <span class="keywordflow">for</span>(<span class="keywordtype">int</span> ind_face=0; ind_face&lt;nb_faces_bord_tot; ind_face++)
        {
          ok=<a class="code" href="AssembleurPP1BUtil_8cpp.html#a40cf40213663174bb24649e51832bf3e">okface</a>(ind_face, face, la_cl);
          <span class="keywordflow">if</span> (ok==-1) <span class="keywordflow">break</span>;
          elem1=face_voisins(face, 0);
          elem2=face_voisins(face, 1);
          <a class="code" href="AssembleurPP1BUtil_8cpp.html#afd0a249a235b161c5267e7574e199a82">remplir_sommets</a>(zone_VEF, face, elem1, elem2, sommets,
                          face_opp1, face_opp2);
          <span class="keywordflow">if</span>(ok==3)
            {
              <a class="code" href="AssembleurPP1BUtil_8cpp.html#a6a26a390dab2336113f60275e5978aaf">update_matrice_NeumannPaPa</a>(zone_VEF,
                                         inverse_quantitee_entrelacee,
                                         face, elem1, sommets,
                                         face_opp1,
                                         ARR, ARV, AVR, AVV);
            }
          <span class="keywordflow">else</span> <span class="keywordflow">if</span>(ok==4)
            {
              <a class="code" href="AssembleurPP1BUtil_8cpp.html#a6e9d49381847c5756d002970ca6441b8">update_matrice_SymetriePaPa</a>(zone_VEF,
                                          inverse_quantitee_entrelacee,
                                          face, elem1, sommets,
                                          face_opp1,
                                          ARR, ARV, AVR, AVV);
            }
          <span class="keywordflow">else</span>
            <a class="code" href="AssembleurPP1BUtil_8cpp.html#a76d676949fb80bc3c7f1ab5f7f8078c0">update_matricePaPa</a>(zone_VEF,
                               inverse_quantitee_entrelacee,
                               face, elem1, elem2, sommets,
                               face_opp1, face_opp2,
                               ARR, ARV, AVR, AVV);
        }
    }
  <a class="code" href="AssembleurPP1BUtil_8cpp.html#a3e374d53ebc7860e1c2f0b7906f2936d">face_associee</a>=-1;
  <span class="keywordflow">for</span>(face=nint; face&lt;nb_faces; face++)
    {
      elem1=face_voisins(face, 0);
      elem2=face_voisins(face, 1);
      <span class="keywordflow">if</span> (!zone_VEF.<a class="code" href="classZone__VF.html#a33909d3880435e82e84639b51482d2c6" title="renvoie 1 si face est une face virtuelle de bord, 0 sinon">est_une_face_virt_bord</a>(face)) <span class="comment">//!&lt; On ne traite que les faces internes</span>
<span class="comment"></span>        {
          <a class="code" href="AssembleurPP1BUtil_8cpp.html#afd0a249a235b161c5267e7574e199a82">remplir_sommets</a>(zone_VEF, face, elem1, elem2, sommets,
                          face_opp1, face_opp2);
          <a class="code" href="AssembleurPP1BUtil_8cpp.html#a76d676949fb80bc3c7f1ab5f7f8078c0">update_matricePaPa</a>(zone_VEF,
                             inverse_quantitee_entrelacee,
                             face, elem1, elem2, sommets,
                             face_opp1, face_opp2,
                             ARR,ARV,AVR,AVV);
        }
    }
  <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;nb_arete; i++)
    <span class="keywordflow">if</span>(ARR(i,i)==0)
      {
<span class="comment">// On n&#39;affiche pas car trop sur de gros maillages</span>
<span class="comment">// Cerr &lt;&lt; &quot;On modifie la ligne (arete) orpheline &quot; &lt;&lt; i &lt;&lt; finl;</span>
        ARR(i,i)=1;
      }

  <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Update Pa OK&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="ab3f0bf1b466f4f73f7c106a25a0ce950"></a><!-- doxytag: member="AssembleurPP1BUtil.cpp::verifier" ref="ab3f0bf1b466f4f73f7c106a25a0ce950" args="(const Assembleur_P_VEFPreP1B &amp;ass, const Matrice_Bloc_Sym &amp;matrice, const Zone_VEF_PreP1b &amp;zone_VEF, const DoubleTab &amp;inverse_quantitee_entrelacee)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int verifier </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAssembleur__P__VEFPreP1B.html">Assembleur_P_VEFPreP1B</a> &amp;&#160;</td>
          <td class="paramname"><em>ass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMatrice__Bloc__Sym.html">Matrice_Bloc_Sym</a> &amp;&#160;</td>
          <td class="paramname"><em>matrice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a> &amp;&#160;</td>
          <td class="paramname"><em>zone_VEF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>inverse_quantitee_entrelacee</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00146">146</a> of file <a class="el" href="AssembleurPP1BUtil_8cpp_source.html">AssembleurPP1BUtil.cpp</a>.</p>

<p>References <a class="el" href="Op__Div__VEF__Elem_8cpp_source.html#l00072">Op_Div_VEF_Elem::calculer()</a>, <a class="el" href="Op__Grad__VEF__Face_8cpp_source.html#l00069">Op_Grad_VEF_Face::calculer()</a>, <a class="el" href="EntreeSortie_8h_source.html#l00032">Cerr</a>, <a class="el" href="Objet__U_8h_source.html#l00079">Objet_U::dimension</a>, <a class="el" href="DoubleTab_8h_source.html#l00254">DoubleTab::dimension_tot()</a>, <a class="el" href="Double_8h_source.html#l00075">DMINFLOAT</a>, <a class="el" href="DoubleVect_8cpp_source.html#l00277">DoubleVect::echange_espace_virtuel()</a>, <a class="el" href="DoubleTab_8cpp_source.html#l00534">DoubleTab::ecrit()</a>, <a class="el" href="communications_8cpp_source.html#l00375">envoyer_broadcast()</a>, <a class="el" href="Assembleur__P__VEFPreP1B_8h_source.html#l00047">Assembleur_P_VEFPreP1B::equation()</a>, <a class="el" href="Solv__GCP__NS_8cpp_source.html#l00141">erreur()</a>, <a class="el" href="Double_8h_source.html#l00273">est_egal()</a>, <a class="el" href="Process_8cpp_source.html#l00223">Process::exit()</a>, <a class="el" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>, <a class="el" href="Zone__VEF__PreP1b_8h_source.html#l00071">Zone_VEF_PreP1b::get_alphaA()</a>, <a class="el" href="Zone__VEF__PreP1b_8h_source.html#l00061">Zone_VEF_PreP1b::get_alphaE()</a>, <a class="el" href="Zone__VEF__PreP1b_8h_source.html#l00066">Zone_VEF_PreP1b::get_alphaS()</a>, <a class="el" href="Zone__VEF__PreP1b_8h_source.html#l00090">Zone_VEF_PreP1b::get_ok_arete()</a>, <a class="el" href="Zone__VEF__PreP1b_8h_source.html#l00086">Zone_VEF_PreP1b::get_renum_arete_perio()</a>, <a class="el" href="Matrice__Bloc__Sym_8cpp_source.html#l00064">Matrice_Bloc_Sym::imprimer_formatte()</a>, <a class="el" href="Navier__Stokes__std_8cpp_source.html#l00748">Navier_Stokes_std::inconnue()</a>, <a class="el" href="Process_8cpp_source.html#l00117">Process::me()</a>, <a class="el" href="DoubleVect_8cpp_source.html#l02265">mp_max_vect()</a>, <a class="el" href="DoubleVect_8cpp_source.html#l02353">mp_norme_vect()</a>, <a class="el" href="DoubleVect_8cpp_source.html#l02342">mp_prodscal()</a>, <a class="el" href="Matrice__Base_8h_source.html#l00127">Matrice_Base::multvect()</a>, <a class="el" href="Zone_8h_source.html#l00300">Zone::nb_elem()</a>, <a class="el" href="Process_8cpp_source.html#l00109">Process::nproc()</a>, <a class="el" href="Navier__Stokes__std_8cpp_source.html#l00665">Navier_Stokes_std::operateur_divergence()</a>, <a class="el" href="Navier__Stokes__std_8cpp_source.html#l00706">Navier_Stokes_std::operateur_gradient()</a>, <a class="el" href="Navier__Stokes__std_8h_source.html#l00268">Navier_Stokes_std::pression()</a>, <a class="el" href="Cast_8h_source.html#l00059">ref_cast</a>, <a class="el" href="DoubleVect_8h_source.html#l00153">DoubleVect::size()</a>, <a class="el" href="Champ__Inc_8cpp_source.html#l00245">Champ_Inc::valeurs()</a>, <a class="el" href="Type__Verifie_8cpp_source.html#l00029">verifie()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00118">verifier_complet()</a>, and <a class="el" href="Zone__dis__base_8h_source.html#l00106">Zone_dis_base::zone()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">if</span> (zone_VEF.<a class="code" href="classZone__VEF__PreP1b.html#aee2def53aa92584d7945e7c3d0d98963">get_alphaE</a>()+zone_VEF.<a class="code" href="classZone__VEF__PreP1b.html#ad7fbcb5567dcc2e6f0a0ed85ce90a4fa">get_alphaS</a>()+zone_VEF.<a class="code" href="classZone__VEF__PreP1b.html#a9d02e2431efb6e75c3d733ff06f89549">get_alphaA</a>()!=<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>)
    {
      <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Assembleur_P_VEFPreP1B::verifier n&#39;est pas prevu pour verifier votre discretisation.&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
      <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">Process::exit</a>();
    }
  <span class="keyword">const</span> <a class="code" href="classNavier__Stokes__std.html" title="classe Navier_Stokes_std Cette classe porte les termes de l&#39;equation de la dynamique pour un fluide s...">Navier_Stokes_std</a>&amp; eqn=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classNavier__Stokes__std.html" title="classe Navier_Stokes_std Cette classe porte les termes de l&#39;equation de la dynamique pour un fluide s...">Navier_Stokes_std</a>, ass.<a class="code" href="classAssembleur__P__VEFPreP1B.html#a9a85837c29e80d1bcbc3a7f740f93807">equation</a>());
  <span class="keyword">const</span> <a class="code" href="classOperateur__Div.html" title="classe Operateur_Div Classe generique de la hierarchie des operateurs calculant la divergence d&#39;un ch...">Operateur_Div</a>&amp; opdiv=eqn.<a class="code" href="classNavier__Stokes__std.html#a614d41350181667ee295b87a72779c1a" title="Renvoie l&#39;operateur de calcul de la divergence associe a l&#39;equation.">operateur_divergence</a>();
  <span class="keyword">const</span> <a class="code" href="classOp__Div__VEFP1B__Elem.html">Op_Div_VEFP1B_Elem</a>&amp; div=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classOp__Div__VEFP1B__Elem.html">Op_Div_VEFP1B_Elem</a>,
                                         opdiv.valeur());
<span class="comment">// div.verifier();</span>
  <span class="keyword">const</span> <a class="code" href="classOperateur__Grad.html" title="Classe Operateur_Grad Classe generique de la hierarchie des operateurs calculant le gradient d&#39;un cha...">Operateur_Grad</a>&amp; opgrad=eqn.<a class="code" href="classNavier__Stokes__std.html#a840295836fce939b7861f1353da595ff" title="Renvoie l&#39;operateur de calcul du gradient associe a l&#39;equation.">operateur_gradient</a>();
  <span class="keyword">const</span> <a class="code" href="classOp__Grad__VEF__P1B__Face.html">Op_Grad_VEF_P1B_Face</a>&amp; grad=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classOp__Grad__VEF__P1B__Face.html">Op_Grad_VEF_P1B_Face</a>,
                                            opgrad.valeur());
<span class="comment">// grad.verifier();</span>
<span class="comment">// const Solveur_Masse&amp; solvm=eqn.solv_masse();</span>
  <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; pression=eqn.<a class="code" href="classNavier__Stokes__std.html#afbb8f39bdfd70328dfad21bf2b9dd45a" title="Renvoie le champ de pression.">pression</a>().<a class="code" href="classChamp__Inc.html#a28ef3d411d12cb5684ac5e799efb7d24" title="Appel a l&#39;objet sous-jacent Renvoie le tableau des valeurs au temps courant.">valeurs</a>();
  <span class="keywordtype">int</span> ko=0;
  ko=<a class="code" href="AssembleurPP1BUtil_8cpp.html#add6cc8459f10f15a9a6bac24d1727880">verifier_complet</a>(ass, matrice, zone_VEF);
  <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a> pre(pression);
  <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a> resu(pre), resu2(pre), <a class="code" href="Solv__GCP__NS_8cpp.html#ab6aa1075b965c7713d8db20dd3a8e09b">erreur</a>(pre);
  <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a> gradP(eqn.<a class="code" href="classNavier__Stokes__std.html#a743b777e6185faee7837326844c8fca1" title="Renvoie la vitesse (champ inconnue de l&#39;equation) (version const)">inconnue</a>().<a class="code" href="classChamp__Inc.html#a28ef3d411d12cb5684ac5e799efb7d24" title="Appel a l&#39;objet sous-jacent Renvoie le tableau des valeurs au temps courant.">valeurs</a>());
  <span class="keyword">const</span> <a class="code" href="classZone.html" title="classe Zone Une Zone est un maillage compose d&#39;un ensemble d&#39;elements geometriques de meme type...">Zone</a>&amp; zone=zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>();
  <span class="keywordtype">int</span> nb_elem=zone.<a class="code" href="classZone.html#a7f249429803b27139a1c54436f6164a5" title="Renvoie le nombre d&#39;elements de la zone.">nb_elem</a>();
  <span class="keywordtype">int</span> nb_elem_tot=zone.nb_elem_tot();
  <span class="keywordtype">int</span> nb_som=zone.domaine().nb_som();
  <span class="keywordtype">int</span> nb_som_tot=zone.domaine().nb_som_tot();
  <span class="keywordtype">int</span> nb_aretes=zone.nb_aretes();
  <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; ok_arete=zone_VEF.<a class="code" href="classZone__VEF__PreP1b.html#a83771f784d487e346b2ef22a389472a2">get_ok_arete</a>();
  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> proc=0; proc&lt;<a class="code" href="classProcess.html#a6bf692ce58d9578aa62ac3c07b8caaa1" title="renvoie le nombre de processeurs dans le groupe courant Voir Comm_Group::nproc() et PE_Groups::curren...">Process::nproc</a>(); proc++)
    {
      <span class="keywordtype">int</span> n = pre.dimension_tot(0);
<span class="comment">// Le processeur proc impose sa valeur de n a tout le monde</span>
      <a class="code" href="communications_8cpp.html#a2335b36078ae87e23dab400a6e129a3c">envoyer_broadcast</a>(n, proc);

      <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;n; i++)
        {
<span class="comment">// Cerr &lt;&lt; &quot;[&quot; &lt;&lt; Process::me() &lt;&lt; &quot;] On verifie la ligne &quot; &lt;&lt; i &lt;&lt; &quot; de la matrice.&quot; &lt;&lt; finl;</span>
          pre=0;
          <span class="keywordflow">if</span> (<a class="code" href="classProcess.html#ab55ba07167ec807ed3a145cac0f5dca4" title="renvoie mon rang dans le groupe de communication courant. Voir Comm_Group::rank() et PE_Groups::curre...">Process::me</a>()==proc)
            {
              <span class="keywordflow">if</span> (0&lt;=i &amp;&amp; i&lt;nb_elem)
                {
                  <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;On verifie l&#39;element reel &quot;</span> &lt;&lt; i &lt;&lt; <span class="stringliteral">&quot; du processeur &quot;</span> &lt;&lt; proc;
                  pre(i)=1;
                }
              <span class="keywordflow">else</span> <span class="keywordflow">if</span> (nb_elem_tot&lt;=i &amp;&amp; i&lt;nb_elem_tot+nb_som)
                {
                  <span class="keywordtype">int</span> sommet=i-nb_elem_tot;
                  <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;On verifie le sommet reel &quot;</span>;
                  <span class="keywordflow">if</span> (zone.domaine().get_renum_som_perio(sommet)!=sommet) <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;periodique &quot;</span>;
                  <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; i-nb_elem_tot &lt;&lt; <span class="stringliteral">&quot; du processeur &quot;</span> &lt;&lt; proc;
                  pre(i)=1;
                }
              <span class="keywordflow">else</span> <span class="keywordflow">if</span> (nb_elem_tot+nb_som_tot&lt;=i &amp;&amp; i&lt;nb_elem_tot+nb_som_tot+nb_aretes &amp;&amp; ok_arete(i-nb_elem_tot-nb_som_tot))
                {
                  <span class="keywordtype">int</span> arete=i-nb_elem_tot-nb_som_tot;
                  <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; renum_arete_perio=zone_VEF.<a class="code" href="classZone__VEF__PreP1b.html#a43767f8684512d1ee950dc07eea76c5b">get_renum_arete_perio</a>();
                  <span class="keywordflow">if</span> (renum_arete_perio(arete)==arete)
                    {
                      <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;On verifie l&#39;arete reelle non superflue et non periodique &quot;</span> &lt;&lt; arete &lt;&lt; <span class="stringliteral">&quot; du processeur &quot;</span> &lt;&lt; proc;
                      pre(i)=1;
                    }
                }
              <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot; &quot;</span>;
<span class="comment">// Cerr &lt;&lt; finl;</span>
            }
          <span class="keywordtype">double</span> <a class="code" href="Type__Verifie_8cpp.html#ad3531c82596e15d1af86ea6b2713ef51">verifie</a>=<a class="code" href="DoubleVect_8cpp.html#adcc29a107bd1ad77828da317da293203">mp_max_vect</a>(pre);
<span class="comment">// verifie=1;pre(i)=1; // On teste tout</span>
          <span class="keywordflow">if</span> (verifie)
            {
              pre.echange_espace_virtuel();
              <span class="comment">/* Inutile le debog ce n&#39;est pas comparable le sequentiel et le parallele</span>
<span class="comment">                 Nom ch;</span>
<span class="comment">                 ch=&quot;pre pour la ligne &quot;;</span>
<span class="comment">                 ch+=(Nom)i+&quot; du processeur &quot;;</span>
<span class="comment">                 ch+=(Nom)proc+&quot; =&quot;;</span>
<span class="comment">                 Debog::verifier(ch,pre);</span>
<span class="comment">              */</span>
<span class="comment">// Calcul par Div(Grad(P))</span>
              grad.<a class="code" href="classOp__Grad__VEF__Face.html#a06e2a3259889b939f7a0b8d7420d16f3">calculer</a>(pre, gradP);
              {
                <span class="keywordtype">int</span> nbf=inverse_quantitee_entrelacee.<a class="code" href="classDoubleVect.html#a392c1f20b462563365389d28e0853867" title="Identique a size_reelle()">size</a>();
                <span class="keywordtype">int</span> d = <a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>;
                <span class="keywordflow">for</span> (<span class="keywordtype">int</span> face=0; face&lt;nbf; face++)
                  <span class="keywordflow">for</span>(<span class="keywordtype">int</span> k=0; k&lt;d; k++)
                    gradP(face,k)*=inverse_quantitee_entrelacee(face,k);
              }
<span class="comment">// solvm.appliquer(gradP);</span>
              div.<a class="code" href="classOp__Div__VEF__Elem.html#ab28b31e5146e5774e799093c3aaffa19">calculer</a>(gradP, resu);
<span class="comment">// Calcul par -Lap(P)</span>
              matrice.<a class="code" href="classMatrice__Base.html#a05caa487a25a6d5e7fbd38d4b2f4ee1e" title="Multiplication d&#39;un vecteur par la matrice. Operation: r = A*x.">multvect</a>(pre, resu2);
<span class="comment">// On doit trouver erreur nul</span>
              <a class="code" href="Solv__GCP__NS_8cpp.html#ab6aa1075b965c7713d8db20dd3a8e09b">erreur</a>=resu2;
              <a class="code" href="Solv__GCP__NS_8cpp.html#ab6aa1075b965c7713d8db20dd3a8e09b">erreur</a>+=resu;
              resu*=-1;
<span class="comment">// Cas ou la diagonale est *2, on corrige:</span>
              <span class="keywordflow">if</span> (<a class="code" href="Double_8h.html#ac86f5f350b0f95fd8c34b0ac8d720f6f">est_egal</a>(2*resu(i),resu2(i))) <a class="code" href="Solv__GCP__NS_8cpp.html#ab6aa1075b965c7713d8db20dd3a8e09b">erreur</a>(i)=0;
              <span class="keywordtype">double</span> erreur_absolue=<a class="code" href="DoubleVect_8cpp.html#afaa33f0032aa927d8d54ff9fb002b749">mp_norme_vect</a>(<a class="code" href="Solv__GCP__NS_8cpp.html#ab6aa1075b965c7713d8db20dd3a8e09b">erreur</a>);
              <span class="keywordtype">double</span> erreur_relative=erreur_absolue/(<a class="code" href="DoubleVect_8cpp.html#afaa33f0032aa927d8d54ff9fb002b749">mp_norme_vect</a>(resu2)+<a class="code" href="DoubleVect_8cpp.html#afaa33f0032aa927d8d54ff9fb002b749">mp_norme_vect</a>(resu)+<a class="code" href="Double_8h.html#a0a3fffa6d17ad8f7de4bb337c6266561">DMINFLOAT</a>);
              <span class="keywordtype">double</span> app=<a class="code" href="DoubleVect_8cpp.html#a07d13cbdadca6b60d5e128653f52a4bb">mp_prodscal</a>(resu,pre);
              <span class="keywordflow">if</span>(erreur_absolue&gt;1.e-12 &amp;&amp; erreur_relative&gt;1.e-6)
                {
                  <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;[&quot;</span> &lt;&lt; <a class="code" href="classProcess.html#ab55ba07167ec807ed3a145cac0f5dca4" title="renvoie mon rang dans le groupe de communication courant. Voir Comm_Group::rank() et PE_Groups::curre...">Process::me</a>() &lt;&lt; <span class="stringliteral">&quot;] KO a la ligne &quot;</span> &lt;&lt; i &lt;&lt; <span class="stringliteral">&quot; pour le proc &quot;</span> &lt;&lt; proc &lt;&lt; <span class="stringliteral">&quot; (AP,P)= &quot;</span> &lt;&lt; app &lt;&lt; <span class="stringliteral">&quot; erreur= &quot;</span> &lt;&lt; erreur_absolue &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
                  ko=1;
                  <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;[&quot;</span> &lt;&lt; <a class="code" href="classProcess.html#ab55ba07167ec807ed3a145cac0f5dca4" title="renvoie mon rang dans le groupe de communication courant. Voir Comm_Group::rank() et PE_Groups::curre...">Process::me</a>() &lt;&lt; <span class="stringliteral">&quot;] pre= &quot;</span>;
                  pre.ecrit(<a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a>);
                  <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;[&quot;</span> &lt;&lt; <a class="code" href="classProcess.html#ab55ba07167ec807ed3a145cac0f5dca4" title="renvoie mon rang dans le groupe de communication courant. Voir Comm_Group::rank() et PE_Groups::curre...">Process::me</a>() &lt;&lt; <span class="stringliteral">&quot;] Div(gradP) = &quot;</span>;
                  resu.ecrit(<a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a>);
                  <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;[&quot;</span> &lt;&lt; <a class="code" href="classProcess.html#ab55ba07167ec807ed3a145cac0f5dca4" title="renvoie mon rang dans le groupe de communication courant. Voir Comm_Group::rank() et PE_Groups::curre...">Process::me</a>() &lt;&lt; <span class="stringliteral">&quot;] Lap(P) = &quot;</span>;
                  resu2.ecrit(<a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a>);
                  <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;[&quot;</span> &lt;&lt; <a class="code" href="classProcess.html#ab55ba07167ec807ed3a145cac0f5dca4" title="renvoie mon rang dans le groupe de communication courant. Voir Comm_Group::rank() et PE_Groups::curre...">Process::me</a>() &lt;&lt; <span class="stringliteral">&quot;] erreur = &quot;</span>;
                  <a class="code" href="Solv__GCP__NS_8cpp.html#ab6aa1075b965c7713d8db20dd3a8e09b">erreur</a>.ecrit(<a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a>);
                  <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;[&quot;</span> &lt;&lt; <a class="code" href="classProcess.html#ab55ba07167ec807ed3a145cac0f5dca4" title="renvoie mon rang dans le groupe de communication courant. Voir Comm_Group::rank() et PE_Groups::curre...">Process::me</a>() &lt;&lt; <span class="stringliteral">&quot;] invqtentrelacee = &quot;</span>;
                  inverse_quantitee_entrelacee.<a class="code" href="classDoubleTab.html#ab7588e94792cc0be3a3288573c44ca18" title="ecriture des valeurs du tableau &quot;raw&quot; sans structure parallele">ecrit</a>(<a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a>);
                }
              <span class="keywordflow">else</span>
                {
                  <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;[&quot;</span> &lt;&lt; <a class="code" href="classProcess.html#ab55ba07167ec807ed3a145cac0f5dca4" title="renvoie mon rang dans le groupe de communication courant. Voir Comm_Group::rank() et PE_Groups::curre...">Process::me</a>() &lt;&lt; <span class="stringliteral">&quot;] OK a la ligne &quot;</span> &lt;&lt; i &lt;&lt; <span class="stringliteral">&quot; pour le proc &quot;</span> &lt;&lt; proc &lt;&lt; <span class="stringliteral">&quot; (AP,P)= &quot;</span> &lt;&lt; app &lt;&lt; <span class="stringliteral">&quot; erreur= &quot;</span> &lt;&lt; erreur_absolue &lt;&lt; finl;
                }
            }
        }
    }
  <span class="keywordflow">if</span> (ko)
    {
      <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;[&quot;</span> &lt;&lt; <a class="code" href="classProcess.html#ab55ba07167ec807ed3a145cac0f5dca4" title="renvoie mon rang dans le groupe de communication courant. Voir Comm_Group::rank() et PE_Groups::curre...">Process::me</a>() &lt;&lt; <span class="stringliteral">&quot;] Matrice en pression:&quot;</span> &lt;&lt; finl;
      matrice.<a class="code" href="classMatrice__Bloc__Sym.html#a6218305c5024cbfa78d29c229cb6340f">imprimer_formatte</a>(<a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a>);
      <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Echec de la methode verifier de l&#39;assembleur. Voir les KO.&quot;</span> &lt;&lt; finl;
      <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">Process::exit</a>();
    }
  <span class="keywordflow">return</span> 1;
}
</pre></div>
</div>
</div>
<a class="anchor" id="add6cc8459f10f15a9a6bac24d1727880"></a><!-- doxytag: member="AssembleurPP1BUtil.cpp::verifier_complet" ref="add6cc8459f10f15a9a6bac24d1727880" args="(const Assembleur_P_VEFPreP1B &amp;ass, const Matrice_Bloc_Sym &amp;matrice, const Zone_VEF_PreP1b &amp;zone_VEF)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int verifier_complet </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAssembleur__P__VEFPreP1B.html">Assembleur_P_VEFPreP1B</a> &amp;&#160;</td>
          <td class="paramname"><em>ass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMatrice__Bloc__Sym.html">Matrice_Bloc_Sym</a> &amp;&#160;</td>
          <td class="paramname"><em>matrice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a> &amp;&#160;</td>
          <td class="paramname"><em>zone_VEF</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00118">118</a> of file <a class="el" href="AssembleurPP1BUtil_8cpp_source.html">AssembleurPP1BUtil.cpp</a>.</p>

<p>References <a class="el" href="Op__Div__VEF__Elem_8cpp_source.html#l00072">Op_Div_VEF_Elem::calculer()</a>, <a class="el" href="Op__Grad__VEF__Face_8cpp_source.html#l00069">Op_Grad_VEF_Face::calculer()</a>, <a class="el" href="Assembleur__P__VEFPreP1B_8h_source.html#l00047">Assembleur_P_VEFPreP1B::equation()</a>, <a class="el" href="Solv__GCP__NS_8cpp_source.html#l00141">erreur()</a>, <a class="el" href="Zone__VEF__PreP1b_8cpp_source.html#l00287">exemple_champ_non_homogene()</a>, <a class="el" href="Navier__Stokes__std_8cpp_source.html#l00748">Navier_Stokes_std::inconnue()</a>, <a class="el" href="Matrice__Base_8h_source.html#l00127">Matrice_Base::multvect()</a>, <a class="el" href="Navier__Stokes__std_8cpp_source.html#l00665">Navier_Stokes_std::operateur_divergence()</a>, <a class="el" href="Navier__Stokes__std_8cpp_source.html#l00706">Navier_Stokes_std::operateur_gradient()</a>, <a class="el" href="Navier__Stokes__std_8h_source.html#l00268">Navier_Stokes_std::pression()</a>, <a class="el" href="Cast_8h_source.html#l00059">ref_cast</a>, <a class="el" href="Equation__base_8h_source.html#l00432">Equation_base::solv_masse()</a>, and <a class="el" href="Champ__Inc_8cpp_source.html#l00245">Champ_Inc::valeurs()</a>.</p>

<p>Referenced by <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00146">verifier()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">const</span> <a class="code" href="classNavier__Stokes__std.html" title="classe Navier_Stokes_std Cette classe porte les termes de l&#39;equation de la dynamique pour un fluide s...">Navier_Stokes_std</a>&amp; eqn=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classNavier__Stokes__std.html" title="classe Navier_Stokes_std Cette classe porte les termes de l&#39;equation de la dynamique pour un fluide s...">Navier_Stokes_std</a>, ass.<a class="code" href="classAssembleur__P__VEFPreP1B.html#a9a85837c29e80d1bcbc3a7f740f93807">equation</a>());
  <span class="keyword">const</span> <a class="code" href="classOperateur__Div.html" title="classe Operateur_Div Classe generique de la hierarchie des operateurs calculant la divergence d&#39;un ch...">Operateur_Div</a>&amp; opdiv=eqn.<a class="code" href="classNavier__Stokes__std.html#a614d41350181667ee295b87a72779c1a" title="Renvoie l&#39;operateur de calcul de la divergence associe a l&#39;equation.">operateur_divergence</a>();
  <span class="keyword">const</span> <a class="code" href="classOp__Div__VEFP1B__Elem.html">Op_Div_VEFP1B_Elem</a>&amp; div=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classOp__Div__VEFP1B__Elem.html">Op_Div_VEFP1B_Elem</a>,
                                         opdiv.valeur());
<span class="comment">// div.verifier();</span>
  <span class="keyword">const</span> <a class="code" href="classOperateur__Grad.html" title="Classe Operateur_Grad Classe generique de la hierarchie des operateurs calculant le gradient d&#39;un cha...">Operateur_Grad</a>&amp; opgrad=eqn.<a class="code" href="classNavier__Stokes__std.html#a840295836fce939b7861f1353da595ff" title="Renvoie l&#39;operateur de calcul du gradient associe a l&#39;equation.">operateur_gradient</a>();
  <span class="keyword">const</span> <a class="code" href="classOp__Grad__VEF__P1B__Face.html">Op_Grad_VEF_P1B_Face</a>&amp; grad=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classOp__Grad__VEF__P1B__Face.html">Op_Grad_VEF_P1B_Face</a>,
                                            opgrad.valeur());
<span class="comment">// grad.verifier();</span>
  <span class="keyword">const</span> <a class="code" href="classSolveur__Masse.html" title="classe Solveur_Masse Classe generique de la hierarchie des solveurs de masse, un objet Solveur_Masse ...">Solveur_Masse</a>&amp; solvm=eqn.<a class="code" href="classEquation__base.html#adfedf474c07a92f6b2261ca2f1cee80e" title="Renvoie le solveur de masse associe a l&#39;equation.">solv_masse</a>();
  <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; pression=eqn.<a class="code" href="classNavier__Stokes__std.html#afbb8f39bdfd70328dfad21bf2b9dd45a" title="Renvoie le champ de pression.">pression</a>().<a class="code" href="classChamp__Inc.html#a28ef3d411d12cb5684ac5e799efb7d24" title="Appel a l&#39;objet sous-jacent Renvoie le tableau des valeurs au temps courant.">valeurs</a>();
  <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a> tab(pression);
  <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a> resu(tab), resu2(tab), <a class="code" href="Solv__GCP__NS_8cpp.html#ab6aa1075b965c7713d8db20dd3a8e09b">erreur</a>(tab);

<span class="comment">// On calcule un champ de pression quelconque</span>
  <a class="code" href="Zone__VEF__PreP1b_8cpp.html#ad8ba71244ad9a61cd78b6f388d7e503a">exemple_champ_non_homogene</a>(zone_VEF, tab);

  <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a> gradP(eqn.<a class="code" href="classNavier__Stokes__std.html#a743b777e6185faee7837326844c8fca1" title="Renvoie la vitesse (champ inconnue de l&#39;equation) (version const)">inconnue</a>().<a class="code" href="classChamp__Inc.html#a28ef3d411d12cb5684ac5e799efb7d24" title="Appel a l&#39;objet sous-jacent Renvoie le tableau des valeurs au temps courant.">valeurs</a>());
  grad.<a class="code" href="classOp__Grad__VEF__Face.html#a06e2a3259889b939f7a0b8d7420d16f3">calculer</a>(tab, gradP);
  solvm.appliquer(gradP);
  div.<a class="code" href="classOp__Div__VEF__Elem.html#ab28b31e5146e5774e799093c3aaffa19">calculer</a>(gradP, resu);
  matrice.<a class="code" href="classMatrice__Base.html#a05caa487a25a6d5e7fbd38d4b2f4ee1e" title="Multiplication d&#39;un vecteur par la matrice. Operation: r = A*x.">multvect</a>(tab, resu2);
  <span class="keywordflow">return</span> 0;
}
</pre></div>
</div>
</div>
<hr/><h2>Variable Documentation</h2>
<a class="anchor" id="a3e374d53ebc7860e1c2f0b7906f2936d"></a><!-- doxytag: member="AssembleurPP1BUtil.cpp::face_associee" ref="a3e374d53ebc7860e1c2f0b7906f2936d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="AssembleurPP1BUtil_8cpp.html#a3e374d53ebc7860e1c2f0b7906f2936d">face_associee</a> = -1<code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00046">46</a> of file <a class="el" href="AssembleurPP1BUtil_8cpp_source.html">AssembleurPP1BUtil.cpp</a>.</p>

<p>Referenced by <a class="el" href="Terme__Source__Qdm__VEF__Face_8cpp_source.html#l00079">Terme_Source_Qdm_VEF_Face::ajouter()</a>, <a class="el" href="Terme__Source__Acceleration__VEF__Face_8cpp_source.html#l00136">Terme_Source_Acceleration_VEF_Face::ajouter()</a>, <a class="el" href="Terme__Boussinesq__VEFPreP1B__Face_8cpp_source.html#l00052">Terme_Boussinesq_VEFPreP1B_Face::ajouter()</a>, <a class="el" href="Op__Conv__EF__VEF__P1NC_8cpp_source.html#l00109">Op_Conv_EF_VEF_P1NC::ajouter()</a>, <a class="el" href="Terme__Source__Acceleration__VDF__Face_8cpp_source.html#l00122">Terme_Source_Acceleration_VDF_Face::ajouter()</a>, <a class="el" href="Op__Div__VEFP1B__Elem_8cpp_source.html#l00573">Op_Div_VEFP1B_Elem::ajouter()</a>, <a class="el" href="Op__Conv__EF__VEF__P1NC__Stab_8cpp_source.html#l01606">Op_Conv_EF_VEF_P1NC_Stab::ajouter_old()</a>, <a class="el" href="Op__Div__VEFP1B__Elem_8cpp_source.html#l00306">Op_Div_VEFP1B_Elem::ajouter_som()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l02968">assemblerP0P1()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l02655">assemblerP0Pa()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l02247">assemblerP1P1()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l02803">assemblerP1Pa()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l02477">assemblerPaPa()</a>, <a class="el" href="BilanQdmVEF_8cpp_source.html#l00114">BilanQdmVEF::bilan_energie()</a>, <a class="el" href="BilanQdmVEF_8cpp_source.html#l00031">BilanQdmVEF::bilan_qdm()</a>, <a class="el" href="Op__Dift__standard__VEF__Face_8cpp_source.html#l00156">Op_Dift_standard_VEF_Face::calcul_divergence()</a>, <a class="el" href="Op__Diff__P1NC__barprim_8cpp_source.html#l00112">Op_Diff_P1NC_barprim::calculer_divergence()</a>, <a class="el" href="Op__Conv__VEF__base_8cpp_source.html#l00273">Op_Conv_VEF_base::calculer_dt_local()</a>, <a class="el" href="Op__Conv__VDF__base_8cpp_source.html#l00145">Op_Conv_VDF_base::calculer_dt_local()</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l03912">Op_Diff_VEFP1NCP1B_Face::corriger_Cl_test()</a>, <a class="el" href="Op__Dift__VEF__P1NCP1B__Face_8cpp_source.html#l00368">Op_Dift_VEF_P1NCP1B_Face::corriger_div_pour_Cl()</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l00731">Op_Diff_VEFP1NCP1B_Face::corriger_div_pour_Cl()</a>, <a class="el" href="Champ__P1NC__implementation_8cpp_source.html#l01124">Champ_P1NC_implementation::filtrer_resu()</a>, <a class="el" href="Assembleur__P__VDF_8cpp_source.html#l00065">Assembleur_P_VDF::liste_faces_periodiques()</a>, <a class="el" href="Op__Dift__Stab__VEF__Face_8cpp_source.html#l00222">Op_Dift_Stab_VEF_Face::modifie_pour_Cl()</a>, <a class="el" href="Op__Diff__VEF__Face__Stab_8cpp_source.html#l00189">Op_Diff_VEF_Face_Stab::modifie_pour_Cl()</a>, <a class="el" href="Op__Grad__VEF__P1B__Face_8cpp_source.html#l00220">Op_Grad_VEF_P1B_Face::modifier_grad_pour_Cl()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00081">okface()</a>, <a class="el" href="Perte__Charge__Reguliere__VDF__Face_8cpp_source.html#l00066">Perte_Charge_Reguliere_VDF_Face::remplir_num_faces()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00349">remplir_sommets()</a>, <a class="el" href="Op__Conv__EF__VEF__P1NC__Stab_8cpp_source.html#l01169">Op_Conv_EF_VEF_P1NC_Stab::test_difference_resu()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l03048">updateP0P1()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l02730">updateP0Pa()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l02339">updateP1P1()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l02885">updateP1Pa()</a>, and <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l02567">updatePaPa()</a>.</p>

</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Tue Dec 14 2021 19:35:56 for TRUST by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
