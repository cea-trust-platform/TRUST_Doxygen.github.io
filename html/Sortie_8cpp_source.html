<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>TRUST: src/Kernel/Utilitaires/Sortie.cpp Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">TRUST&#160;<span id="projectnumber">1.8.4</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
<div class="header">
  <div class="headertitle">
<div class="title">src/Kernel/Utilitaires/Sortie.cpp</div>  </div>
</div>
<div class="contents">
<a href="Sortie_8cpp.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/****************************************************************************</span>
<a name="l00002"></a>00002 <span class="comment">* Copyright (c) 2019, CEA</span>
<a name="l00003"></a>00003 <span class="comment">* All rights reserved.</span>
<a name="l00004"></a>00004 <span class="comment">*</span>
<a name="l00005"></a>00005 <span class="comment">* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</span>
<a name="l00006"></a>00006 <span class="comment">* 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.</span>
<a name="l00007"></a>00007 <span class="comment">* 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.</span>
<a name="l00008"></a>00008 <span class="comment">* 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.</span>
<a name="l00009"></a>00009 <span class="comment">*</span>
<a name="l00010"></a>00010 <span class="comment">* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.</span>
<a name="l00011"></a>00011 <span class="comment">* IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;</span>
<a name="l00012"></a>00012 <span class="comment">* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>
<a name="l00013"></a>00013 <span class="comment">*</span>
<a name="l00014"></a>00014 <span class="comment">*****************************************************************************/</span>
<a name="l00015"></a>00015 <span class="comment">//</span>
<a name="l00016"></a>00016 <span class="comment">// </span>
<a name="l00017"></a>00017 <span class="comment">// File:        Sortie.cpp</span>
<a name="l00018"></a>00018 <span class="comment">// Directory:   $TRUST_ROOT/src/Kernel/Utilitaires</span>
<a name="l00019"></a>00019 <span class="comment">// Version:     /main/portage_windows/1</span>
<a name="l00020"></a>00020 <span class="comment">// </span>
<a name="l00021"></a>00021 <span class="comment">//</span>
<a name="l00022"></a>00022 <span class="comment">// </span>
<a name="l00023"></a>00023 <span class="comment">// WARNING: DO NOT EDIT THIS FILE! Only edit the template file Sortie.cpp.P</span>
<a name="l00024"></a>00024 <span class="comment">// </span>
<a name="l00025"></a>00025 
<a name="l00026"></a>00026 <span class="preprocessor">#include &lt;<a class="code" href="Sortie_8h.html">Sortie.h</a>&gt;</span>
<a name="l00027"></a>00027 <span class="preprocessor">#include &lt;<a class="code" href="Objet__U_8h.html">Objet_U.h</a>&gt;</span>
<a name="l00028"></a>00028 <span class="preprocessor">#include &lt;<a class="code" href="Separateur_8h.html">Separateur.h</a>&gt;</span>
<a name="l00029"></a>00029 <span class="preprocessor">#include &lt;assert.h&gt;</span>
<a name="l00030"></a>00030 <span class="preprocessor">#include &lt;iostream&gt;</span>
<a name="l00031"></a>00031 <span class="preprocessor">#include &lt;iomanip&gt;</span>
<a name="l00032"></a>00032 
<a name="l00033"></a>00033 <span class="keyword">const</span> <a class="code" href="classSeparateur.html" title="Separateur pour les fichiers. Ce sont des objets speciaux que l&#39;on peut inserer dans une sortie comme...">Separateur</a> <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>(<a class="code" href="classSeparateur.html#a106ba609d6c2f8fe68b04e797d521137a6fe582122578def6fba11ae4fbdec38e">Separateur::ENDL</a>);
<a name="l00034"></a>00034 <span class="keyword">const</span> <a class="code" href="classSeparateur.html" title="Separateur pour les fichiers. Ce sont des objets speciaux que l&#39;on peut inserer dans une sortie comme...">Separateur</a> <a class="code" href="EntreeSortie_8h.html#ae67efc620265981e3385b5f75837d3ef">space</a>(<a class="code" href="classSeparateur.html#a106ba609d6c2f8fe68b04e797d521137aabe5fe56826fb90ca06a76dc3f74c7ca">Separateur::SPACE</a>);
<a name="l00035"></a>00035 
<a name="l00036"></a>00036 <span class="comment">// Constructeurs</span>
<a name="l00037"></a><a class="code" href="classSortie.html#a3886e900d597e5a721ba73c0ebe5ff4d">00037</a> <a class="code" href="classSortie.html#a3886e900d597e5a721ba73c0ebe5ff4d">Sortie::Sortie</a>()
<a name="l00038"></a>00038 {
<a name="l00039"></a>00039   <a class="code" href="classSortie.html#a7291aca32660e875543da1f0260b3773">bin_</a>=0;
<a name="l00040"></a>00040   <a class="code" href="classSortie.html#aa9c371bbb0f88e0f18f7209a7d32f4c6">ostream_</a>=0;
<a name="l00041"></a>00041   <a class="code" href="classSortie.html#ac2e0050005d6348bcd6c558df9b26b48">col_width_</a> = -1;
<a name="l00042"></a>00042 }
<a name="l00043"></a>00043 
<a name="l00044"></a><a class="code" href="classSortie.html#a05322f1a56de2325a18095d3eea2e0a3">00044</a> <span class="keywordtype">void</span> <a class="code" href="classSortie.html#a05322f1a56de2325a18095d3eea2e0a3">Sortie::setf</a>(<a class="code" href="arch_8h.html#a9473f58f39a903067d794bb5ddce4b06">IOS_FORMAT</a> code)
<a name="l00045"></a>00045 {
<a name="l00046"></a>00046   <span class="keywordflow">if</span>(<a class="code" href="classSortie.html#aa9c371bbb0f88e0f18f7209a7d32f4c6">ostream_</a>)
<a name="l00047"></a>00047     <a class="code" href="classSortie.html#aa9c371bbb0f88e0f18f7209a7d32f4c6">ostream_</a>-&gt;setf(code);
<a name="l00048"></a>00048 }
<a name="l00049"></a>00049 
<a name="l00050"></a><a class="code" href="classSortie.html#a846ea173fd5e5b18fa2a0764f39724e3">00050</a> <span class="keywordtype">void</span> <a class="code" href="classSortie.html#a846ea173fd5e5b18fa2a0764f39724e3">Sortie::precision</a>(<span class="keywordtype">int</span> pre)
<a name="l00051"></a>00051 {
<a name="l00052"></a>00052   <span class="keywordflow">if</span>(<a class="code" href="classSortie.html#aa9c371bbb0f88e0f18f7209a7d32f4c6">ostream_</a>)
<a name="l00053"></a>00053     <a class="code" href="classSortie.html#aa9c371bbb0f88e0f18f7209a7d32f4c6">ostream_</a>-&gt;precision(pre);
<a name="l00054"></a>00054 }
<a name="l00055"></a>00055 
<a name="l00056"></a><a class="code" href="classSortie.html#abe94d93b9b47ea0dda9a961a6eff45c5">00056</a> <span class="keywordtype">void</span> <a class="code" href="classSortie.html#abe94d93b9b47ea0dda9a961a6eff45c5">Sortie::set_col_width</a>(<span class="keywordtype">int</span> w)
<a name="l00057"></a>00057 {
<a name="l00058"></a>00058   <a class="code" href="classSortie.html#ac2e0050005d6348bcd6c558df9b26b48">col_width_</a> = w;
<a name="l00059"></a>00059 }
<a name="l00060"></a>00060 
<a name="l00061"></a><a class="code" href="classSortie.html#a8a8b78ca4eef5618751bd24be4d64648">00061</a> <a class="code" href="classSortie.html#a3886e900d597e5a721ba73c0ebe5ff4d">Sortie::Sortie</a>(ostream&amp; os)
<a name="l00062"></a>00062 {
<a name="l00063"></a>00063   <a class="code" href="classSortie.html#a7291aca32660e875543da1f0260b3773">bin_</a>=0;
<a name="l00064"></a>00064   <span class="keywordflow">if</span>(os.rdbuf())
<a name="l00065"></a>00065     {
<a name="l00066"></a>00066       <a class="code" href="classSortie.html#aa9c371bbb0f88e0f18f7209a7d32f4c6">ostream_</a> = <span class="keyword">new</span> ostream(os.rdbuf());
<a name="l00067"></a>00067     }
<a name="l00068"></a>00068   <span class="keywordflow">else</span>
<a name="l00069"></a>00069     {
<a name="l00070"></a>00070       <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">Process::exit</a>();
<a name="l00071"></a>00071     }
<a name="l00072"></a>00072 }
<a name="l00073"></a>00073 
<a name="l00074"></a><a class="code" href="classSortie.html#afa0d3f50482b08ecd840af398883f6cd">00074</a> <a class="code" href="classSortie.html#a3886e900d597e5a721ba73c0ebe5ff4d">Sortie::Sortie</a>(<span class="keyword">const</span> <a class="code" href="classSortie.html" title="Classe de base des flux de sortie. Elle sait ecrire des types simples&lt;br&gt;(entiers, flottants) et des Ob...">Sortie</a>&amp; os)
<a name="l00075"></a>00075 {
<a name="l00076"></a>00076   <a class="code" href="classSortie.html#a7291aca32660e875543da1f0260b3773">bin_</a>=0;
<a name="l00077"></a>00077   <span class="keywordflow">if</span> (os.<a class="code" href="classSortie.html#aab73ebc5756f6b82376a4714a56d2911">has_ostream</a>())
<a name="l00078"></a>00078     {
<a name="l00079"></a>00079       <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a>&lt;&lt;<span class="stringliteral">&quot;we try to copy a Sortie with ostream !!!&quot;</span>&lt;&lt;<a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
<a name="l00080"></a>00080       abort();
<a name="l00081"></a>00081       <a class="code" href="classSortie.html#aa9c371bbb0f88e0f18f7209a7d32f4c6">ostream_</a> = <span class="keyword">new</span> ostream(os.<a class="code" href="classSortie.html#a2b296619da65cf49f0e8934ee51ad3ed">get_ostream</a>().rdbuf());
<a name="l00082"></a>00082     }
<a name="l00083"></a>00083   <span class="keywordflow">else</span>
<a name="l00084"></a>00084     <a class="code" href="classSortie.html#aa9c371bbb0f88e0f18f7209a7d32f4c6">ostream_</a>=0;
<a name="l00085"></a>00085 }
<a name="l00086"></a>00086 
<a name="l00087"></a>00087 <span class="comment">// Operateurs d&#39;affectation</span>
<a name="l00088"></a><a class="code" href="classSortie.html#ad461b012c55dc9630b4c36a22877a611">00088</a> <a class="code" href="classSortie.html" title="Classe de base des flux de sortie. Elle sait ecrire des types simples&lt;br&gt;(entiers, flottants) et des Ob...">Sortie</a>&amp; <a class="code" href="classSortie.html#ad461b012c55dc9630b4c36a22877a611">Sortie::operator=</a>(ostream&amp; os)
<a name="l00089"></a>00089 {
<a name="l00090"></a>00090   <span class="keywordflow">if</span>(<a class="code" href="classSortie.html#aa9c371bbb0f88e0f18f7209a7d32f4c6">ostream_</a>)
<a name="l00091"></a>00091     <span class="keyword">delete</span> <a class="code" href="classSortie.html#aa9c371bbb0f88e0f18f7209a7d32f4c6">ostream_</a>;
<a name="l00092"></a>00092   <a class="code" href="classSortie.html#aa9c371bbb0f88e0f18f7209a7d32f4c6">ostream_</a> = <span class="keyword">new</span> ostream(os.rdbuf());
<a name="l00093"></a>00093   <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00094"></a>00094 }
<a name="l00095"></a>00095 
<a name="l00096"></a><a class="code" href="classSortie.html#aeb027142835229f30ea20add9096ba52">00096</a> <a class="code" href="classSortie.html" title="Classe de base des flux de sortie. Elle sait ecrire des types simples&lt;br&gt;(entiers, flottants) et des Ob...">Sortie</a>&amp; <a class="code" href="classSortie.html#ad461b012c55dc9630b4c36a22877a611">Sortie::operator=</a>(<a class="code" href="classSortie.html" title="Classe de base des flux de sortie. Elle sait ecrire des types simples&lt;br&gt;(entiers, flottants) et des Ob...">Sortie</a>&amp; os)
<a name="l00097"></a>00097 {
<a name="l00098"></a>00098   <span class="keywordflow">if</span>(<a class="code" href="classSortie.html#aa9c371bbb0f88e0f18f7209a7d32f4c6">ostream_</a>)
<a name="l00099"></a>00099     <span class="keyword">delete</span> <a class="code" href="classSortie.html#aa9c371bbb0f88e0f18f7209a7d32f4c6">ostream_</a>;
<a name="l00100"></a>00100   <span class="keywordflow">if</span> (os.<a class="code" href="classSortie.html#aab73ebc5756f6b82376a4714a56d2911">has_ostream</a>())
<a name="l00101"></a>00101     {
<a name="l00102"></a>00102       <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a>&lt;&lt;<span class="stringliteral">&quot;we try to copy a Sortie with ostream !!!&quot;</span>&lt;&lt;<a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
<a name="l00103"></a>00103       abort();
<a name="l00104"></a>00104       <a class="code" href="classSortie.html#aa9c371bbb0f88e0f18f7209a7d32f4c6">ostream_</a> = <span class="keyword">new</span> ostream(os.<a class="code" href="classSortie.html#a2b296619da65cf49f0e8934ee51ad3ed">get_ostream</a>().rdbuf());
<a name="l00105"></a>00105     }
<a name="l00106"></a>00106   <span class="keywordflow">else</span>
<a name="l00107"></a>00107     <a class="code" href="classSortie.html#aa9c371bbb0f88e0f18f7209a7d32f4c6">ostream_</a>=0;
<a name="l00108"></a>00108   <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00109"></a>00109 }
<a name="l00110"></a>00110 
<a name="l00111"></a><a class="code" href="classSortie.html#a2b296619da65cf49f0e8934ee51ad3ed">00111</a> ostream&amp; <a class="code" href="classSortie.html#a2b296619da65cf49f0e8934ee51ad3ed">Sortie::get_ostream</a>()
<a name="l00112"></a>00112 {
<a name="l00113"></a>00113   <span class="keywordflow">return</span> *<a class="code" href="classSortie.html#aa9c371bbb0f88e0f18f7209a7d32f4c6">ostream_</a>;
<a name="l00114"></a>00114 }
<a name="l00115"></a>00115 
<a name="l00116"></a><a class="code" href="classSortie.html#a0a9209bfb301e710cf5c4ac8e8fed2b5">00116</a> <span class="keyword">const</span> ostream&amp; <a class="code" href="classSortie.html#a2b296619da65cf49f0e8934ee51ad3ed">Sortie::get_ostream</a>()<span class="keyword"> const</span>
<a name="l00117"></a>00117 <span class="keyword"></span>{
<a name="l00118"></a>00118   <span class="keywordflow">return</span> *<a class="code" href="classSortie.html#aa9c371bbb0f88e0f18f7209a7d32f4c6">ostream_</a>;
<a name="l00119"></a>00119 }
<a name="l00120"></a>00120 
<a name="l00121"></a><a class="code" href="classSortie.html#aa14aacea640e791a25dc7ba38757cb4d">00121</a> <span class="keywordtype">void</span> <a class="code" href="classSortie.html#aa14aacea640e791a25dc7ba38757cb4d">Sortie::set_ostream</a>(ostream* os)
<a name="l00122"></a>00122 {
<a name="l00123"></a>00123   <a class="code" href="classSortie.html#aa9c371bbb0f88e0f18f7209a7d32f4c6">ostream_</a> = os;
<a name="l00124"></a>00124 }
<a name="l00125"></a>00125 
<a name="l00126"></a><a class="code" href="classSortie.html#aed397f2acfa499f2c34be9657a724de0">00126</a> <span class="keywordtype">int</span> <a class="code" href="classSortie.html#aed397f2acfa499f2c34be9657a724de0">Sortie::add_col</a>(<span class="keyword">const</span> <span class="keywordtype">double</span>&amp; ob)
<a name="l00127"></a>00127 {
<a name="l00128"></a>00128   <span class="keywordflow">if</span> (<a class="code" href="classSortie.html#a7291aca32660e875543da1f0260b3773">bin_</a> or <a class="code" href="classSortie.html#ac2e0050005d6348bcd6c558df9b26b48">col_width_</a> == -1)
<a name="l00129"></a>00129     abort();
<a name="l00130"></a>00130   <span class="keywordflow">else</span>
<a name="l00131"></a>00131     {
<a name="l00132"></a>00132       (*ostream_) &lt;&lt; std::right &lt;&lt; std::setw(<a class="code" href="classSortie.html#ac2e0050005d6348bcd6c558df9b26b48">col_width_</a>) &lt;&lt; ob;
<a name="l00133"></a>00133     }
<a name="l00134"></a>00134   <span class="keywordflow">return</span> <a class="code" href="classSortie.html#aa9c371bbb0f88e0f18f7209a7d32f4c6">ostream_</a>-&gt;good();
<a name="l00135"></a>00135 }
<a name="l00136"></a>00136 
<a name="l00137"></a><a class="code" href="classSortie.html#ad2cee2c3ed7a8cb0c1c5bce63e0efb26">00137</a> <span class="keywordtype">int</span> <a class="code" href="classSortie.html#aed397f2acfa499f2c34be9657a724de0">Sortie::add_col</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> * ob)
<a name="l00138"></a>00138 {
<a name="l00139"></a>00139   <span class="keywordflow">if</span> (<a class="code" href="classSortie.html#a7291aca32660e875543da1f0260b3773">bin_</a> or <a class="code" href="classSortie.html#ac2e0050005d6348bcd6c558df9b26b48">col_width_</a> == -1)
<a name="l00140"></a>00140     abort();
<a name="l00141"></a>00141   <span class="keywordflow">else</span>
<a name="l00142"></a>00142     {
<a name="l00143"></a>00143       (*ostream_) &lt;&lt; std::right &lt;&lt; std::setw(<a class="code" href="classSortie.html#ac2e0050005d6348bcd6c558df9b26b48">col_width_</a>) &lt;&lt; ob;
<a name="l00144"></a>00144     }
<a name="l00145"></a>00145   <span class="keywordflow">return</span> <a class="code" href="classSortie.html#aa9c371bbb0f88e0f18f7209a7d32f4c6">ostream_</a>-&gt;good();
<a name="l00146"></a>00146 }
<a name="l00147"></a>00147 
<a name="l00148"></a>00148 
<a name="l00149"></a>00149 <span class="comment">//</span>
<a name="l00150"></a>00150 <span class="comment">//</span>
<a name="l00151"></a>00151 <span class="comment">//</span><span class="comment"></span>
<a name="l00152"></a>00152 <span class="comment">//! Methode de bas niveau pour ecrire un int ou flottant dans le stream.&lt;br&gt;Dans l&#39;implementation de la classe de base, on ecrit dans ostream_.&lt;br&gt;En binaire on utilise ostream::write(), en ascii ostream::operato&lt;&lt;()</span>
<a name="l00153"></a><a class="code" href="classSortie.html#adcd343c7639877812a5822bb3b8cb49c">00153</a> <span class="comment"></span><a class="code" href="classSortie.html" title="Classe de base des flux de sortie. Elle sait ecrire des types simples&lt;br&gt;(entiers, flottants) et des Ob...">Sortie</a>&amp; <a class="code" href="classSortie.html#a5affb80ee844b1032a7dba4bf05ffd7e">Sortie::operator&lt;&lt;</a>(<span class="keyword">const</span> <span class="keywordtype">unsigned</span>&amp; ob)
<a name="l00154"></a>00154 {
<a name="l00155"></a>00155   <span class="keywordflow">if</span>(<a class="code" href="classSortie.html#a7291aca32660e875543da1f0260b3773">bin_</a>)
<a name="l00156"></a>00156     {
<a name="l00157"></a>00157       <span class="comment">/* Ecriture en mode binaire */</span>
<a name="l00158"></a>00158       <a class="code" href="classSortie.html#aa9c371bbb0f88e0f18f7209a7d32f4c6">ostream_</a>-&gt;write((<span class="keywordtype">char</span> *) &amp; ob, <span class="keyword">sizeof</span>(<span class="keywordtype">unsigned</span>));
<a name="l00159"></a>00159     }
<a name="l00160"></a>00160   <span class="keywordflow">else</span>
<a name="l00161"></a>00161     {
<a name="l00162"></a>00162       <span class="comment">/* Ecriture avec conversion en ascii */</span>
<a name="l00163"></a>00163       (*ostream_) &lt;&lt; ob;
<a name="l00164"></a>00164     }
<a name="l00165"></a>00165   <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00166"></a>00166 }
<a name="l00167"></a>00167 
<a name="l00168"></a>00168 
<a name="l00169"></a>00169 <span class="comment">//</span>
<a name="l00170"></a>00170 <span class="comment">//</span>
<a name="l00171"></a>00171 <span class="comment">//</span>
<a name="l00172"></a>00172 <span class="comment">//</span>
<a name="l00173"></a>00173 <span class="comment">//</span>
<a name="l00174"></a>00174 <span class="comment">//</span><span class="comment"></span>
<a name="l00175"></a>00175 <span class="comment">//! Methode de bas niveau pour ecrire un tableau d&#39;ints ou reels dans le stream.&lt;br&gt;Dans l&#39;implementation de la classe de base, on ecrit dans ostream_.&lt;br&gt;En binaire on utilise ostream::write(), en ascii ostream::operato&lt;&lt;()&lt;br&gt;En ascii, on revient a la ligne chaque fois qu&#39;on a ecrit &quot;nb_col&quot; valeurs et a la&lt;br&gt;fin du tableau.&lt;br&gt;Valeur de retour : ostream_-&gt;good()</span>
<a name="l00176"></a><a class="code" href="classSortie.html#aa3f46aaccaff0f83c018784b50d8ea24">00176</a> <span class="comment"></span><span class="keywordtype">int</span> <a class="code" href="classSortie.html#aa3f46aaccaff0f83c018784b50d8ea24" title="Methode de bas niveau pour ecrire un tableau d&#39;ints ou reels dans le stream. Dans l&#39;implementation de...">Sortie::put</a>(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> * ob, <span class="keywordtype">int</span> n, <span class="keywordtype">int</span> nb_col)
<a name="l00177"></a>00177 {
<a name="l00178"></a>00178   assert(n &gt;= 0);
<a name="l00179"></a>00179   <span class="keywordflow">if</span> (<a class="code" href="classSortie.html#a7291aca32660e875543da1f0260b3773">bin_</a>)
<a name="l00180"></a>00180     {
<a name="l00181"></a>00181       std::streamsize <a class="code" href="Nom_8cpp.html#a0e1ea19fb9fa7881d15d84eff4c090e1">sz</a> = <span class="keyword">sizeof</span>(unsigned);
<a name="l00182"></a>00182       sz *= n;
<a name="l00183"></a>00183 <span class="comment">// Overflow checking :</span>
<a name="l00184"></a>00184       assert(sz / (std::streamsize)<span class="keyword">sizeof</span>(<span class="keywordtype">unsigned</span>) == (std::streamsize)n);
<a name="l00185"></a>00185       <a class="code" href="classSortie.html#aa9c371bbb0f88e0f18f7209a7d32f4c6">ostream_</a>-&gt;write((<span class="keyword">const</span> <span class="keywordtype">char</span> *) ob, sz);
<a name="l00186"></a>00186     }
<a name="l00187"></a>00187   <span class="keywordflow">else</span>
<a name="l00188"></a>00188     {
<a name="l00189"></a>00189       <span class="keywordtype">int</span> j = nb_col;
<a name="l00190"></a>00190       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; n; i++)
<a name="l00191"></a>00191         {
<a name="l00192"></a>00192           (*ostream_) &lt;&lt; (ob[i]) &lt;&lt; (<span class="charliteral">&#39; &#39;</span>);
<a name="l00193"></a>00193           j--;
<a name="l00194"></a>00194           <span class="keywordflow">if</span> (j &lt;= 0)
<a name="l00195"></a>00195             {
<a name="l00196"></a>00196               (*ostream_) &lt;&lt; (endl);
<a name="l00197"></a>00197               j = nb_col;
<a name="l00198"></a>00198             }
<a name="l00199"></a>00199         }
<a name="l00200"></a>00200 <span class="comment">// Si on n&#39;a pas fini pas un retour a la ligne, en ajouter un</span>
<a name="l00201"></a>00201       <span class="keywordflow">if</span> (j != nb_col &amp;&amp; n &gt; 0)
<a name="l00202"></a>00202         (*ostream_) &lt;&lt; (endl);
<a name="l00203"></a>00203       <a class="code" href="classSortie.html#aa9c371bbb0f88e0f18f7209a7d32f4c6">ostream_</a>-&gt;flush();
<a name="l00204"></a>00204     }
<a name="l00205"></a>00205   <span class="keywordflow">return</span> <a class="code" href="classSortie.html#aa9c371bbb0f88e0f18f7209a7d32f4c6">ostream_</a>-&gt;good();
<a name="l00206"></a>00206 }
<a name="l00207"></a>00207 <span class="comment">//</span>
<a name="l00208"></a>00208 <span class="comment">//</span>
<a name="l00209"></a>00209 <span class="comment">//</span><span class="comment"></span>
<a name="l00210"></a>00210 <span class="comment">//! Methode de bas niveau pour ecrire un int ou flottant dans le stream.&lt;br&gt;Dans l&#39;implementation de la classe de base, on ecrit dans ostream_.&lt;br&gt;En binaire on utilise ostream::write(), en ascii ostream::operato&lt;&lt;()</span>
<a name="l00211"></a><a class="code" href="classSortie.html#a1c0e2f2fe5f2c09566033dc2a3e861b9">00211</a> <span class="comment"></span><a class="code" href="classSortie.html" title="Classe de base des flux de sortie. Elle sait ecrire des types simples&lt;br&gt;(entiers, flottants) et des Ob...">Sortie</a>&amp; <a class="code" href="classSortie.html#a5affb80ee844b1032a7dba4bf05ffd7e">Sortie::operator&lt;&lt;</a>(<span class="keyword">const</span> <span class="keywordtype">int</span>&amp; ob)
<a name="l00212"></a>00212 {
<a name="l00213"></a>00213   <span class="keywordflow">if</span>(<a class="code" href="classSortie.html#a7291aca32660e875543da1f0260b3773">bin_</a>)
<a name="l00214"></a>00214     {
<a name="l00215"></a>00215       <span class="comment">/* Ecriture en mode binaire */</span>
<a name="l00216"></a>00216       <a class="code" href="classSortie.html#aa9c371bbb0f88e0f18f7209a7d32f4c6">ostream_</a>-&gt;write((<span class="keywordtype">char</span> *) &amp; ob, <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>));
<a name="l00217"></a>00217     }
<a name="l00218"></a>00218   <span class="keywordflow">else</span>
<a name="l00219"></a>00219     {
<a name="l00220"></a>00220       <span class="comment">/* Ecriture avec conversion en ascii */</span>
<a name="l00221"></a>00221       (*ostream_) &lt;&lt; ob;
<a name="l00222"></a>00222     }
<a name="l00223"></a>00223   <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00224"></a>00224 }
<a name="l00225"></a>00225 
<a name="l00226"></a>00226 
<a name="l00227"></a>00227 <span class="comment">//</span>
<a name="l00228"></a>00228 <span class="comment">//</span>
<a name="l00229"></a>00229 <span class="comment">//</span>
<a name="l00230"></a>00230 <span class="comment">//</span>
<a name="l00231"></a>00231 <span class="comment">//</span>
<a name="l00232"></a>00232 <span class="comment">//</span><span class="comment"></span>
<a name="l00233"></a>00233 <span class="comment">//! Methode de bas niveau pour ecrire un tableau d&#39;ints ou reels dans le stream.&lt;br&gt;Dans l&#39;implementation de la classe de base, on ecrit dans ostream_.&lt;br&gt;En binaire on utilise ostream::write(), en ascii ostream::operato&lt;&lt;()&lt;br&gt;En ascii, on revient a la ligne chaque fois qu&#39;on a ecrit &quot;nb_col&quot; valeurs et a la&lt;br&gt;fin du tableau.&lt;br&gt;Valeur de retour : ostream_-&gt;good()</span>
<a name="l00234"></a><a class="code" href="classSortie.html#accee158a4354a9f13a3e21f7d73d4b3d">00234</a> <span class="comment"></span><span class="keywordtype">int</span> <a class="code" href="classSortie.html#aa3f46aaccaff0f83c018784b50d8ea24" title="Methode de bas niveau pour ecrire un tableau d&#39;ints ou reels dans le stream. Dans l&#39;implementation de...">Sortie::put</a>(<span class="keyword">const</span> <span class="keywordtype">int</span> * ob, <span class="keywordtype">int</span> n, <span class="keywordtype">int</span> nb_col)
<a name="l00235"></a>00235 {
<a name="l00236"></a>00236   assert(n &gt;= 0);
<a name="l00237"></a>00237   <span class="keywordflow">if</span> (<a class="code" href="classSortie.html#a7291aca32660e875543da1f0260b3773">bin_</a>)
<a name="l00238"></a>00238     {
<a name="l00239"></a>00239       std::streamsize <a class="code" href="Nom_8cpp.html#a0e1ea19fb9fa7881d15d84eff4c090e1">sz</a> = <span class="keyword">sizeof</span>(int);
<a name="l00240"></a>00240       sz *= n;
<a name="l00241"></a>00241 <span class="comment">// Overflow checking :</span>
<a name="l00242"></a>00242       assert(sz / (std::streamsize)<span class="keyword">sizeof</span>(<span class="keywordtype">int</span>) == (std::streamsize)n);
<a name="l00243"></a>00243       <a class="code" href="classSortie.html#aa9c371bbb0f88e0f18f7209a7d32f4c6">ostream_</a>-&gt;write((<span class="keyword">const</span> <span class="keywordtype">char</span> *) ob, sz);
<a name="l00244"></a>00244     }
<a name="l00245"></a>00245   <span class="keywordflow">else</span>
<a name="l00246"></a>00246     {
<a name="l00247"></a>00247       <span class="keywordtype">int</span> j = nb_col;
<a name="l00248"></a>00248       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; n; i++)
<a name="l00249"></a>00249         {
<a name="l00250"></a>00250           (*ostream_) &lt;&lt; (ob[i]) &lt;&lt; (<span class="charliteral">&#39; &#39;</span>);
<a name="l00251"></a>00251           j--;
<a name="l00252"></a>00252           <span class="keywordflow">if</span> (j &lt;= 0)
<a name="l00253"></a>00253             {
<a name="l00254"></a>00254               (*ostream_) &lt;&lt; (endl);
<a name="l00255"></a>00255               j = nb_col;
<a name="l00256"></a>00256             }
<a name="l00257"></a>00257         }
<a name="l00258"></a>00258 <span class="comment">// Si on n&#39;a pas fini pas un retour a la ligne, en ajouter un</span>
<a name="l00259"></a>00259       <span class="keywordflow">if</span> (j != nb_col &amp;&amp; n &gt; 0)
<a name="l00260"></a>00260         (*ostream_) &lt;&lt; (endl);
<a name="l00261"></a>00261       <a class="code" href="classSortie.html#aa9c371bbb0f88e0f18f7209a7d32f4c6">ostream_</a>-&gt;flush();
<a name="l00262"></a>00262     }
<a name="l00263"></a>00263   <span class="keywordflow">return</span> <a class="code" href="classSortie.html#aa9c371bbb0f88e0f18f7209a7d32f4c6">ostream_</a>-&gt;good();
<a name="l00264"></a>00264 }
<a name="l00265"></a>00265 <span class="preprocessor">#ifndef INT_is_64_</span>
<a name="l00266"></a>00266 <span class="preprocessor"></span><span class="comment">//</span>
<a name="l00267"></a>00267 <span class="comment">//</span>
<a name="l00268"></a>00268 <span class="comment">//</span><span class="comment"></span>
<a name="l00269"></a>00269 <span class="comment">//! Methode de bas niveau pour ecrire un int ou flottant dans le stream.&lt;br&gt;Dans l&#39;implementation de la classe de base, on ecrit dans ostream_.&lt;br&gt;En binaire on utilise ostream::write(), en ascii ostream::operato&lt;&lt;()</span>
<a name="l00270"></a><a class="code" href="classSortie.html#a496d561284b31eafddf17d209ab89ebb">00270</a> <span class="comment"></span><a class="code" href="classSortie.html" title="Classe de base des flux de sortie. Elle sait ecrire des types simples&lt;br&gt;(entiers, flottants) et des Ob...">Sortie</a>&amp; <a class="code" href="classSortie.html#a5affb80ee844b1032a7dba4bf05ffd7e">Sortie::operator&lt;&lt;</a>(<span class="keyword">const</span> <span class="keywordtype">long</span>&amp; ob)
<a name="l00271"></a>00271 {
<a name="l00272"></a>00272   <span class="keywordflow">if</span>(<a class="code" href="classSortie.html#a7291aca32660e875543da1f0260b3773">bin_</a>)
<a name="l00273"></a>00273     {
<a name="l00274"></a>00274       <span class="comment">/* Ecriture en mode binaire */</span>
<a name="l00275"></a>00275       <a class="code" href="classSortie.html#aa9c371bbb0f88e0f18f7209a7d32f4c6">ostream_</a>-&gt;write((<span class="keywordtype">char</span> *) &amp; ob, <span class="keyword">sizeof</span>(<span class="keywordtype">long</span>));
<a name="l00276"></a>00276     }
<a name="l00277"></a>00277   <span class="keywordflow">else</span>
<a name="l00278"></a>00278     {
<a name="l00279"></a>00279       <span class="comment">/* Ecriture avec conversion en ascii */</span>
<a name="l00280"></a>00280       (*ostream_) &lt;&lt; ob;
<a name="l00281"></a>00281     }
<a name="l00282"></a>00282   <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00283"></a>00283 }
<a name="l00284"></a>00284 
<a name="l00285"></a>00285 
<a name="l00286"></a>00286 <span class="comment">//</span>
<a name="l00287"></a>00287 <span class="comment">//</span>
<a name="l00288"></a>00288 <span class="comment">//</span>
<a name="l00289"></a>00289 <span class="comment">//</span>
<a name="l00290"></a>00290 <span class="comment">//</span>
<a name="l00291"></a>00291 <span class="comment">//</span><span class="comment"></span>
<a name="l00292"></a>00292 <span class="comment">//! Methode de bas niveau pour ecrire un tableau d&#39;ints ou reels dans le stream.&lt;br&gt;Dans l&#39;implementation de la classe de base, on ecrit dans ostream_.&lt;br&gt;En binaire on utilise ostream::write(), en ascii ostream::operato&lt;&lt;()&lt;br&gt;En ascii, on revient a la ligne chaque fois qu&#39;on a ecrit &quot;nb_col&quot; valeurs et a la&lt;br&gt;fin du tableau.&lt;br&gt;Valeur de retour : ostream_-&gt;good()</span>
<a name="l00293"></a><a class="code" href="classSortie.html#a2cfe3a4ebb18061eb88d1375b43aa839">00293</a> <span class="comment"></span><span class="keywordtype">int</span> <a class="code" href="classSortie.html#aa3f46aaccaff0f83c018784b50d8ea24" title="Methode de bas niveau pour ecrire un tableau d&#39;ints ou reels dans le stream. Dans l&#39;implementation de...">Sortie::put</a>(<span class="keyword">const</span> <span class="keywordtype">long</span> * ob, <span class="keywordtype">int</span> n, <span class="keywordtype">int</span> nb_col)
<a name="l00294"></a>00294 {
<a name="l00295"></a>00295   assert(n &gt;= 0);
<a name="l00296"></a>00296   <span class="keywordflow">if</span> (<a class="code" href="classSortie.html#a7291aca32660e875543da1f0260b3773">bin_</a>)
<a name="l00297"></a>00297     {
<a name="l00298"></a>00298       std::streamsize <a class="code" href="Nom_8cpp.html#a0e1ea19fb9fa7881d15d84eff4c090e1">sz</a> = <span class="keyword">sizeof</span>(long);
<a name="l00299"></a>00299       sz *= n;
<a name="l00300"></a>00300 <span class="comment">// Overflow checking :</span>
<a name="l00301"></a>00301       assert(sz / (std::streamsize)<span class="keyword">sizeof</span>(<span class="keywordtype">long</span>) == (std::streamsize)n);
<a name="l00302"></a>00302       <a class="code" href="classSortie.html#aa9c371bbb0f88e0f18f7209a7d32f4c6">ostream_</a>-&gt;write((<span class="keyword">const</span> <span class="keywordtype">char</span> *) ob, sz);
<a name="l00303"></a>00303     }
<a name="l00304"></a>00304   <span class="keywordflow">else</span>
<a name="l00305"></a>00305     {
<a name="l00306"></a>00306       <span class="keywordtype">int</span> j = nb_col;
<a name="l00307"></a>00307       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; n; i++)
<a name="l00308"></a>00308         {
<a name="l00309"></a>00309           (*ostream_) &lt;&lt; (ob[i]) &lt;&lt; (<span class="charliteral">&#39; &#39;</span>);
<a name="l00310"></a>00310           j--;
<a name="l00311"></a>00311           <span class="keywordflow">if</span> (j &lt;= 0)
<a name="l00312"></a>00312             {
<a name="l00313"></a>00313               (*ostream_) &lt;&lt; (endl);
<a name="l00314"></a>00314               j = nb_col;
<a name="l00315"></a>00315             }
<a name="l00316"></a>00316         }
<a name="l00317"></a>00317 <span class="comment">// Si on n&#39;a pas fini pas un retour a la ligne, en ajouter un</span>
<a name="l00318"></a>00318       <span class="keywordflow">if</span> (j != nb_col &amp;&amp; n &gt; 0)
<a name="l00319"></a>00319         (*ostream_) &lt;&lt; (endl);
<a name="l00320"></a>00320       <a class="code" href="classSortie.html#aa9c371bbb0f88e0f18f7209a7d32f4c6">ostream_</a>-&gt;flush();
<a name="l00321"></a>00321     }
<a name="l00322"></a>00322   <span class="keywordflow">return</span> <a class="code" href="classSortie.html#aa9c371bbb0f88e0f18f7209a7d32f4c6">ostream_</a>-&gt;good();
<a name="l00323"></a>00323 }
<a name="l00324"></a>00324 <span class="preprocessor">#endif</span>
<a name="l00325"></a>00325 <span class="preprocessor"></span><span class="comment">//</span>
<a name="l00326"></a>00326 <span class="comment">//</span>
<a name="l00327"></a>00327 <span class="comment">//</span><span class="comment"></span>
<a name="l00328"></a>00328 <span class="comment">//! Methode de bas niveau pour ecrire un int ou flottant dans le stream.&lt;br&gt;Dans l&#39;implementation de la classe de base, on ecrit dans ostream_.&lt;br&gt;En binaire on utilise ostream::write(), en ascii ostream::operato&lt;&lt;()</span>
<a name="l00329"></a><a class="code" href="classSortie.html#ae86c4be35ac9aea5bd8e8115fb0feae5">00329</a> <span class="comment"></span><a class="code" href="classSortie.html" title="Classe de base des flux de sortie. Elle sait ecrire des types simples&lt;br&gt;(entiers, flottants) et des Ob...">Sortie</a>&amp; <a class="code" href="classSortie.html#a5affb80ee844b1032a7dba4bf05ffd7e">Sortie::operator&lt;&lt;</a>(<span class="keyword">const</span> <span class="keywordtype">float</span>&amp; ob)
<a name="l00330"></a>00330 {
<a name="l00331"></a>00331   <span class="keywordflow">if</span>(<a class="code" href="classSortie.html#a7291aca32660e875543da1f0260b3773">bin_</a>)
<a name="l00332"></a>00332     {
<a name="l00333"></a>00333       <span class="comment">/* Ecriture en mode binaire */</span>
<a name="l00334"></a>00334       <a class="code" href="classSortie.html#aa9c371bbb0f88e0f18f7209a7d32f4c6">ostream_</a>-&gt;write((<span class="keywordtype">char</span> *) &amp; ob, <span class="keyword">sizeof</span>(<span class="keywordtype">float</span>));
<a name="l00335"></a>00335     }
<a name="l00336"></a>00336   <span class="keywordflow">else</span>
<a name="l00337"></a>00337     {
<a name="l00338"></a>00338       <span class="comment">/* Ecriture avec conversion en ascii */</span>
<a name="l00339"></a>00339       (*ostream_) &lt;&lt; ob;
<a name="l00340"></a>00340     }
<a name="l00341"></a>00341   <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00342"></a>00342 }
<a name="l00343"></a>00343 
<a name="l00344"></a>00344 
<a name="l00345"></a>00345 <span class="comment">//</span>
<a name="l00346"></a>00346 <span class="comment">//</span>
<a name="l00347"></a>00347 <span class="comment">//</span>
<a name="l00348"></a>00348 <span class="comment">//</span>
<a name="l00349"></a>00349 <span class="comment">//</span>
<a name="l00350"></a>00350 <span class="comment">//</span><span class="comment"></span>
<a name="l00351"></a>00351 <span class="comment">//! Methode de bas niveau pour ecrire un tableau d&#39;ints ou reels dans le stream.&lt;br&gt;Dans l&#39;implementation de la classe de base, on ecrit dans ostream_.&lt;br&gt;En binaire on utilise ostream::write(), en ascii ostream::operato&lt;&lt;()&lt;br&gt;En ascii, on revient a la ligne chaque fois qu&#39;on a ecrit &quot;nb_col&quot; valeurs et a la&lt;br&gt;fin du tableau.&lt;br&gt;Valeur de retour : ostream_-&gt;good()</span>
<a name="l00352"></a><a class="code" href="classSortie.html#a0dc36cb9e13f5be19a28b5e763e67e60">00352</a> <span class="comment"></span><span class="keywordtype">int</span> <a class="code" href="classSortie.html#aa3f46aaccaff0f83c018784b50d8ea24" title="Methode de bas niveau pour ecrire un tableau d&#39;ints ou reels dans le stream. Dans l&#39;implementation de...">Sortie::put</a>(<span class="keyword">const</span> <span class="keywordtype">float</span> * ob, <span class="keywordtype">int</span> n, <span class="keywordtype">int</span> nb_col)
<a name="l00353"></a>00353 {
<a name="l00354"></a>00354   assert(n &gt;= 0);
<a name="l00355"></a>00355   <span class="keywordflow">if</span> (<a class="code" href="classSortie.html#a7291aca32660e875543da1f0260b3773">bin_</a>)
<a name="l00356"></a>00356     {
<a name="l00357"></a>00357       std::streamsize <a class="code" href="Nom_8cpp.html#a0e1ea19fb9fa7881d15d84eff4c090e1">sz</a> = <span class="keyword">sizeof</span>(float);
<a name="l00358"></a>00358       sz *= n;
<a name="l00359"></a>00359 <span class="comment">// Overflow checking :</span>
<a name="l00360"></a>00360       assert(sz / (std::streamsize)<span class="keyword">sizeof</span>(<span class="keywordtype">float</span>) == (std::streamsize)n);
<a name="l00361"></a>00361       <a class="code" href="classSortie.html#aa9c371bbb0f88e0f18f7209a7d32f4c6">ostream_</a>-&gt;write((<span class="keyword">const</span> <span class="keywordtype">char</span> *) ob, sz);
<a name="l00362"></a>00362     }
<a name="l00363"></a>00363   <span class="keywordflow">else</span>
<a name="l00364"></a>00364     {
<a name="l00365"></a>00365       <span class="keywordtype">int</span> j = nb_col;
<a name="l00366"></a>00366       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; n; i++)
<a name="l00367"></a>00367         {
<a name="l00368"></a>00368           (*ostream_) &lt;&lt; (ob[i]) &lt;&lt; (<span class="charliteral">&#39; &#39;</span>);
<a name="l00369"></a>00369           j--;
<a name="l00370"></a>00370           <span class="keywordflow">if</span> (j &lt;= 0)
<a name="l00371"></a>00371             {
<a name="l00372"></a>00372               (*ostream_) &lt;&lt; (endl);
<a name="l00373"></a>00373               j = nb_col;
<a name="l00374"></a>00374             }
<a name="l00375"></a>00375         }
<a name="l00376"></a>00376 <span class="comment">// Si on n&#39;a pas fini pas un retour a la ligne, en ajouter un</span>
<a name="l00377"></a>00377       <span class="keywordflow">if</span> (j != nb_col &amp;&amp; n &gt; 0)
<a name="l00378"></a>00378         (*ostream_) &lt;&lt; (endl);
<a name="l00379"></a>00379       <a class="code" href="classSortie.html#aa9c371bbb0f88e0f18f7209a7d32f4c6">ostream_</a>-&gt;flush();
<a name="l00380"></a>00380     }
<a name="l00381"></a>00381   <span class="keywordflow">return</span> <a class="code" href="classSortie.html#aa9c371bbb0f88e0f18f7209a7d32f4c6">ostream_</a>-&gt;good();
<a name="l00382"></a>00382 }
<a name="l00383"></a>00383 <span class="comment">//</span>
<a name="l00384"></a>00384 <span class="comment">//</span>
<a name="l00385"></a>00385 <span class="comment">//</span><span class="comment"></span>
<a name="l00386"></a>00386 <span class="comment">//! Methode de bas niveau pour ecrire un int ou flottant dans le stream.&lt;br&gt;Dans l&#39;implementation de la classe de base, on ecrit dans ostream_.&lt;br&gt;En binaire on utilise ostream::write(), en ascii ostream::operato&lt;&lt;()</span>
<a name="l00387"></a><a class="code" href="classSortie.html#a549c4d26ca7d420bad336c0edf13492d">00387</a> <span class="comment"></span><a class="code" href="classSortie.html" title="Classe de base des flux de sortie. Elle sait ecrire des types simples&lt;br&gt;(entiers, flottants) et des Ob...">Sortie</a>&amp; <a class="code" href="classSortie.html#a5affb80ee844b1032a7dba4bf05ffd7e">Sortie::operator&lt;&lt;</a>(<span class="keyword">const</span> <span class="keywordtype">double</span>&amp; ob)
<a name="l00388"></a>00388 {
<a name="l00389"></a>00389   <span class="keywordflow">if</span>(<a class="code" href="classSortie.html#a7291aca32660e875543da1f0260b3773">bin_</a>)
<a name="l00390"></a>00390     {
<a name="l00391"></a>00391       <span class="comment">/* Ecriture en mode binaire */</span>
<a name="l00392"></a>00392       <a class="code" href="classSortie.html#aa9c371bbb0f88e0f18f7209a7d32f4c6">ostream_</a>-&gt;write((<span class="keywordtype">char</span> *) &amp; ob, <span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));
<a name="l00393"></a>00393     }
<a name="l00394"></a>00394   <span class="keywordflow">else</span>
<a name="l00395"></a>00395     {
<a name="l00396"></a>00396       <span class="comment">/* Ecriture avec conversion en ascii */</span>
<a name="l00397"></a>00397       (*ostream_) &lt;&lt; ob;
<a name="l00398"></a>00398     }
<a name="l00399"></a>00399   <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00400"></a>00400 }
<a name="l00401"></a>00401 
<a name="l00402"></a>00402 
<a name="l00403"></a>00403 <span class="comment">//</span>
<a name="l00404"></a>00404 <span class="comment">//</span>
<a name="l00405"></a>00405 <span class="comment">//</span>
<a name="l00406"></a>00406 <span class="comment">//</span>
<a name="l00407"></a>00407 <span class="comment">//</span>
<a name="l00408"></a>00408 <span class="comment">//</span><span class="comment"></span>
<a name="l00409"></a>00409 <span class="comment">//! Methode de bas niveau pour ecrire un tableau d&#39;ints ou reels dans le stream.&lt;br&gt;Dans l&#39;implementation de la classe de base, on ecrit dans ostream_.&lt;br&gt;En binaire on utilise ostream::write(), en ascii ostream::operato&lt;&lt;()&lt;br&gt;En ascii, on revient a la ligne chaque fois qu&#39;on a ecrit &quot;nb_col&quot; valeurs et a la&lt;br&gt;fin du tableau.&lt;br&gt;Valeur de retour : ostream_-&gt;good()</span>
<a name="l00410"></a><a class="code" href="classSortie.html#a3ccfdd7f9f0e258d5193758d25b28b1d">00410</a> <span class="comment"></span><span class="keywordtype">int</span> <a class="code" href="classSortie.html#aa3f46aaccaff0f83c018784b50d8ea24" title="Methode de bas niveau pour ecrire un tableau d&#39;ints ou reels dans le stream. Dans l&#39;implementation de...">Sortie::put</a>(<span class="keyword">const</span> <span class="keywordtype">double</span> * ob, <span class="keywordtype">int</span> n, <span class="keywordtype">int</span> nb_col)
<a name="l00411"></a>00411 {
<a name="l00412"></a>00412   assert(n &gt;= 0);
<a name="l00413"></a>00413   <span class="keywordflow">if</span> (<a class="code" href="classSortie.html#a7291aca32660e875543da1f0260b3773">bin_</a>)
<a name="l00414"></a>00414     {
<a name="l00415"></a>00415       std::streamsize <a class="code" href="Nom_8cpp.html#a0e1ea19fb9fa7881d15d84eff4c090e1">sz</a> = <span class="keyword">sizeof</span>(double);
<a name="l00416"></a>00416       sz *= n;
<a name="l00417"></a>00417 <span class="comment">// Overflow checking :</span>
<a name="l00418"></a>00418       assert(sz / (std::streamsize)<span class="keyword">sizeof</span>(<span class="keywordtype">double</span>) == (std::streamsize)n);
<a name="l00419"></a>00419       <a class="code" href="classSortie.html#aa9c371bbb0f88e0f18f7209a7d32f4c6">ostream_</a>-&gt;write((<span class="keyword">const</span> <span class="keywordtype">char</span> *) ob, sz);
<a name="l00420"></a>00420     }
<a name="l00421"></a>00421   <span class="keywordflow">else</span>
<a name="l00422"></a>00422     {
<a name="l00423"></a>00423       <span class="keywordtype">int</span> j = nb_col;
<a name="l00424"></a>00424       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; n; i++)
<a name="l00425"></a>00425         {
<a name="l00426"></a>00426           (*ostream_) &lt;&lt; (ob[i]) &lt;&lt; (<span class="charliteral">&#39; &#39;</span>);
<a name="l00427"></a>00427           j--;
<a name="l00428"></a>00428           <span class="keywordflow">if</span> (j &lt;= 0)
<a name="l00429"></a>00429             {
<a name="l00430"></a>00430               (*ostream_) &lt;&lt; (endl);
<a name="l00431"></a>00431               j = nb_col;
<a name="l00432"></a>00432             }
<a name="l00433"></a>00433         }
<a name="l00434"></a>00434 <span class="comment">// Si on n&#39;a pas fini pas un retour a la ligne, en ajouter un</span>
<a name="l00435"></a>00435       <span class="keywordflow">if</span> (j != nb_col &amp;&amp; n &gt; 0)
<a name="l00436"></a>00436         (*ostream_) &lt;&lt; (endl);
<a name="l00437"></a>00437       <a class="code" href="classSortie.html#aa9c371bbb0f88e0f18f7209a7d32f4c6">ostream_</a>-&gt;flush();
<a name="l00438"></a>00438     }
<a name="l00439"></a>00439   <span class="keywordflow">return</span> <a class="code" href="classSortie.html#aa9c371bbb0f88e0f18f7209a7d32f4c6">ostream_</a>-&gt;good();
<a name="l00440"></a>00440 }
<a name="l00441"></a>00441 
<a name="l00442"></a><a class="code" href="classSortie.html#a5affb80ee844b1032a7dba4bf05ffd7e">00442</a> <a class="code" href="classSortie.html" title="Classe de base des flux de sortie. Elle sait ecrire des types simples&lt;br&gt;(entiers, flottants) et des Ob...">Sortie</a>&amp; <a class="code" href="classSortie.html#a5affb80ee844b1032a7dba4bf05ffd7e">Sortie::operator &lt;&lt;</a>(ostream&amp; (*f)(ostream&amp;))
<a name="l00443"></a>00443 {
<a name="l00444"></a>00444 <span class="comment">// Ca c&#39;est pas genial, c&#39;est pour permettre  &quot;&lt;&lt; endl&quot;</span>
<a name="l00445"></a>00445 <span class="comment">// Probleme: ca ne marche pas si ostream_ == 0.</span>
<a name="l00446"></a>00446   <span class="keywordflow">if</span>(<a class="code" href="classSortie.html#aa9c371bbb0f88e0f18f7209a7d32f4c6">ostream_</a> &amp;&amp; !<a class="code" href="classSortie.html#a7291aca32660e875543da1f0260b3773">bin_</a>)
<a name="l00447"></a>00447     (*f)(*ostream_);
<a name="l00448"></a>00448   <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00449"></a>00449 }
<a name="l00450"></a>00450 
<a name="l00451"></a><a class="code" href="classSortie.html#ae28a765a6a5bc1ce14e6db89ef31836d">00451</a> <a class="code" href="classSortie.html" title="Classe de base des flux de sortie. Elle sait ecrire des types simples&lt;br&gt;(entiers, flottants) et des Ob...">Sortie</a>&amp; <a class="code" href="classSortie.html#a5affb80ee844b1032a7dba4bf05ffd7e">Sortie::operator &lt;&lt;</a>(<a class="code" href="classSortie.html" title="Classe de base des flux de sortie. Elle sait ecrire des types simples&lt;br&gt;(entiers, flottants) et des Ob...">Sortie</a>&amp; (*f)(<a class="code" href="classSortie.html" title="Classe de base des flux de sortie. Elle sait ecrire des types simples&lt;br&gt;(entiers, flottants) et des Ob...">Sortie</a>&amp;))
<a name="l00452"></a>00452 {
<a name="l00453"></a>00453   (*f)(*this);
<a name="l00454"></a>00454   <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00455"></a>00455 }
<a name="l00456"></a>00456 
<a name="l00457"></a><a class="code" href="classSortie.html#a18558853ca355b79d9036ec2d3265f58">00457</a> <a class="code" href="classSortie.html" title="Classe de base des flux de sortie. Elle sait ecrire des types simples&lt;br&gt;(entiers, flottants) et des Ob...">Sortie</a>&amp; <a class="code" href="classSortie.html#a5affb80ee844b1032a7dba4bf05ffd7e">Sortie::operator &lt;&lt;</a>(ios&amp; (*f)(ios&amp;))
<a name="l00458"></a>00458 {
<a name="l00459"></a>00459   <span class="keywordflow">if</span> (<a class="code" href="classSortie.html#aa9c371bbb0f88e0f18f7209a7d32f4c6">ostream_</a>)
<a name="l00460"></a>00460     (*f)(*ostream_);
<a name="l00461"></a>00461   <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00462"></a>00462 }
<a name="l00463"></a>00463 
<a name="l00464"></a><a class="code" href="classSortie.html#a2456baf1997d9a7a6310349929bccf30">00464</a> <a class="code" href="classSortie.html" title="Classe de base des flux de sortie. Elle sait ecrire des types simples&lt;br&gt;(entiers, flottants) et des Ob...">Sortie</a>&amp; <a class="code" href="classSortie.html#a2456baf1997d9a7a6310349929bccf30">Sortie::flush</a>()
<a name="l00465"></a>00465 {
<a name="l00466"></a>00466 <span class="comment">// get_ostream().flush();</span>
<a name="l00467"></a>00467   <a class="code" href="classSortie.html#aa9c371bbb0f88e0f18f7209a7d32f4c6">ostream_</a>-&gt;flush();
<a name="l00468"></a>00468   <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00469"></a>00469 }
<a name="l00470"></a>00470 
<a name="l00471"></a><a class="code" href="classSortie.html#a36ef2c9f55625cb7652c74d81f2d76de">00471</a> <a class="code" href="classSortie.html" title="Classe de base des flux de sortie. Elle sait ecrire des types simples&lt;br&gt;(entiers, flottants) et des Ob...">Sortie</a>&amp; <a class="code" href="classSortie.html#a5affb80ee844b1032a7dba4bf05ffd7e">Sortie::operator&lt;&lt;</a>(<span class="keyword">const</span> <a class="code" href="classSeparateur.html" title="Separateur pour les fichiers. Ce sont des objets speciaux que l&#39;on peut inserer dans une sortie comme...">Separateur</a>&amp; ob)
<a name="l00472"></a>00472 {
<a name="l00473"></a>00473   <span class="keywordflow">if</span> (<a class="code" href="classSortie.html#a7291aca32660e875543da1f0260b3773">bin_</a>)
<a name="l00474"></a>00474     {
<a name="l00475"></a>00475 <span class="comment">// En binaire on n&#39;ecrit pas les separateurs</span>
<a name="l00476"></a>00476     }
<a name="l00477"></a>00477   <span class="keywordflow">else</span>
<a name="l00478"></a>00478     {
<a name="l00479"></a>00479       <span class="keywordflow">switch</span> (ob.<a class="code" href="classSeparateur.html#a52a1527f2491e0e5b7a2ebbe87d7c903">get_type</a>())
<a name="l00480"></a>00480         {
<a name="l00481"></a>00481         <span class="keywordflow">case</span> <a class="code" href="classSeparateur.html#a106ba609d6c2f8fe68b04e797d521137a6fe582122578def6fba11ae4fbdec38e">Separateur::ENDL</a>:
<a name="l00482"></a>00482 <span class="comment">// On ecrit &quot;\n&quot; et pas endl...</span>
<a name="l00483"></a>00483 <span class="comment">// C&#39;est peut-etre une mauvaise idee</span>
<a name="l00484"></a>00484 <span class="comment">// (*ostream_) &lt;&lt; &#39;\n&#39;;</span>
<a name="l00485"></a>00485 <span class="comment">// GF pb sous windows avec ancienne ligne</span>
<a name="l00486"></a>00486           (*ostream_)&lt;&lt;endl;
<a name="l00487"></a>00487 <span class="comment">// Flush (important pour les fichiers de log)</span>
<a name="l00488"></a>00488           <a class="code" href="classSortie.html#aa9c371bbb0f88e0f18f7209a7d32f4c6">ostream_</a>-&gt;flush();
<a name="l00489"></a>00489           <span class="keywordflow">break</span>;
<a name="l00490"></a>00490         <span class="keywordflow">case</span> <a class="code" href="classSeparateur.html#a106ba609d6c2f8fe68b04e797d521137aabe5fe56826fb90ca06a76dc3f74c7ca">Separateur::SPACE</a>:
<a name="l00491"></a>00491           (*ostream_) &lt;&lt; <span class="charliteral">&#39; &#39;</span>;
<a name="l00492"></a>00492           <span class="keywordflow">break</span>;
<a name="l00493"></a>00493         }
<a name="l00494"></a>00494     }
<a name="l00495"></a>00495   <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00496"></a>00496 }
<a name="l00497"></a>00497 
<a name="l00498"></a><a class="code" href="classSortie.html#a835d483aba6ab6351414e92f891bad81">00498</a> <a class="code" href="classSortie.html" title="Classe de base des flux de sortie. Elle sait ecrire des types simples&lt;br&gt;(entiers, flottants) et des Ob...">Sortie</a>&amp; <a class="code" href="classSortie.html#a835d483aba6ab6351414e92f891bad81">Sortie::lockfile</a>()
<a name="l00499"></a>00499 {
<a name="l00500"></a>00500   <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a>&lt;&lt;<span class="stringliteral">&quot;Sortie::lockfile() : we should not go through it !!&quot;</span>&lt;&lt;<a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
<a name="l00501"></a>00501   <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">Process::exit</a>();
<a name="l00502"></a>00502   <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00503"></a>00503 }
<a name="l00504"></a>00504 
<a name="l00505"></a><a class="code" href="classSortie.html#a542584d49a2cd8f74aebb9ab4a0f469b">00505</a> <a class="code" href="classSortie.html" title="Classe de base des flux de sortie. Elle sait ecrire des types simples&lt;br&gt;(entiers, flottants) et des Ob...">Sortie</a>&amp; <a class="code" href="classSortie.html#a542584d49a2cd8f74aebb9ab4a0f469b">Sortie::unlockfile</a>()
<a name="l00506"></a>00506 {
<a name="l00507"></a>00507   <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a>&lt;&lt;<span class="stringliteral">&quot;Sortie::unlockfile() : we should not go through it !!&quot;</span>&lt;&lt;<a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
<a name="l00508"></a>00508   <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">Process::exit</a>();
<a name="l00509"></a>00509   <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00510"></a>00510 }
<a name="l00511"></a>00511 
<a name="l00512"></a><a class="code" href="classSortie.html#ae98acb70e7f3886cab47a51f2de6a976">00512</a> <a class="code" href="classSortie.html" title="Classe de base des flux de sortie. Elle sait ecrire des types simples&lt;br&gt;(entiers, flottants) et des Ob...">Sortie</a>&amp; <a class="code" href="classSortie.html#ae98acb70e7f3886cab47a51f2de6a976">Sortie::syncfile</a>()
<a name="l00513"></a>00513 {
<a name="l00514"></a>00514   <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a>&lt;&lt;<span class="stringliteral">&quot;Sortie::syncfile() : we should not go through it !!&quot;</span>&lt;&lt;<a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
<a name="l00515"></a>00515   <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">Process::exit</a>();
<a name="l00516"></a>00516   <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00517"></a>00517 }
<a name="l00518"></a>00518 
<a name="l00519"></a>00519 <span class="comment">//</span>
<a name="l00520"></a>00520 <span class="comment">//</span>
<a name="l00521"></a>00521 <span class="comment">//</span>
<a name="l00522"></a>00522 <span class="comment">//</span>
<a name="l00523"></a>00523 <span class="comment">//</span><span class="comment"></span>
<a name="l00524"></a>00524 <span class="comment">//! Ecriture d&#39;un objet ou d&#39;une variable.&lt;br&gt;Dans cette implementation (et dans la plupart des classes derivees)&lt;br&gt;on appelle simplement ob.printOn (a l&#39;exception de Sortie_Nulle)&lt;br&gt;Attention, si on veut que le flux puisse etre indifferemment ASCII ou BINAIRE,&lt;br&gt;il faut inserer &quot;&lt;&lt; space &lt;&lt;&quot;  ou &quot;&lt;&lt; finl &lt;&lt;&quot; pour separer les objets.</span>
<a name="l00525"></a><a class="code" href="classSortie.html#a7f429425dc28cee3daa801dbcb976b1c">00525</a> <span class="comment"></span><a class="code" href="classSortie.html" title="Classe de base des flux de sortie. Elle sait ecrire des types simples&lt;br&gt;(entiers, flottants) et des Ob...">Sortie</a>&amp; <a class="code" href="classSortie.html#a5affb80ee844b1032a7dba4bf05ffd7e">Sortie::operator&lt;&lt;</a>(<span class="keyword">const</span> <a class="code" href="classObjet__U.html" title="classe Objet_U Cette classe est la classe de base des Objets de TRUST Dans les classes derivees de Ob...">Objet_U</a>&amp; ob)
<a name="l00526"></a>00526 {
<a name="l00527"></a>00527   ob.<a class="code" href="classObjet__U.html#a68f520bd9ba3e848370861d6610720b5" title="Ecriture de l&#39;objet sur un flot de sortie Methode a surcharger.">printOn</a>(*<span class="keyword">this</span>);
<a name="l00528"></a>00528   <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00529"></a>00529 }
<a name="l00530"></a>00530 
<a name="l00531"></a>00531 <span class="comment">//</span>
<a name="l00532"></a>00532 <span class="comment">//</span>
<a name="l00533"></a>00533 <span class="comment">//</span><span class="comment"></span>
<a name="l00534"></a>00534 <span class="comment">//! Ecriture d&#39;une chaine de caracteres. Attention, pour pouvoir&lt;br&gt;relire correctement la chaine en mode ascii, celle-ci ne doit&lt;br&gt;pas contenir de separateur (ni espace, ni retour a la ligne, ...)</span>
<a name="l00535"></a><a class="code" href="classSortie.html#a42d6162d4c64ce999be1bcb4509912d0">00535</a> <span class="comment"></span><a class="code" href="classSortie.html" title="Classe de base des flux de sortie. Elle sait ecrire des types simples&lt;br&gt;(entiers, flottants) et des Ob...">Sortie</a>&amp; <a class="code" href="classSortie.html#a5affb80ee844b1032a7dba4bf05ffd7e">Sortie::operator &lt;&lt;</a>(<span class="keyword">const</span> <span class="keywordtype">char</span>* ob)
<a name="l00536"></a>00536 {
<a name="l00537"></a>00537   <span class="keywordflow">if</span>(<a class="code" href="classSortie.html#a7291aca32660e875543da1f0260b3773">bin_</a>)
<a name="l00538"></a>00538     {
<a name="l00539"></a>00539 <span class="comment">// Ca c&#39;est dommage : dans LIST, il y a &quot;&lt;&lt; blanc &lt;&lt;&quot;</span>
<a name="l00540"></a>00540 <span class="comment">// qui oblige a mettre ce test :</span>
<a name="l00541"></a>00541 <span class="comment">// Il faudrait mettre &quot;&lt;&lt; space &lt;&lt;&quot;  mais cela change les fichiers</span>
<a name="l00542"></a>00542 <span class="comment">// .Zones binaires...</span>
<a name="l00543"></a>00543       <span class="keywordflow">if</span> (strcmp(ob, <span class="stringliteral">&quot; &quot;</span>))
<a name="l00544"></a>00544         {
<a name="l00545"></a>00545           <span class="keyword">const</span> <span class="keywordtype">int</span> n = strlen(ob) + 1;
<a name="l00546"></a>00546           <a class="code" href="classSortie.html#aa9c371bbb0f88e0f18f7209a7d32f4c6">ostream_</a>-&gt;write((<span class="keywordtype">char</span> *) ob, n * <span class="keyword">sizeof</span>(<span class="keywordtype">char</span>));
<a name="l00547"></a>00547         }
<a name="l00548"></a>00548     }
<a name="l00549"></a>00549   <span class="keywordflow">else</span>
<a name="l00550"></a>00550     {
<a name="l00551"></a>00551       (*ostream_) &lt;&lt; ob;
<a name="l00552"></a>00552     }
<a name="l00553"></a>00553 <span class="comment">// B.Mathieu, 7/10/2004 : je supprime l&#39;espace apres ecrire(ob).</span>
<a name="l00554"></a>00554 <span class="comment">// Attention, maintenant, il faut faire</span>
<a name="l00555"></a>00555 <span class="comment">// fichier &lt;&lt; &quot;chaine&quot; &lt;&lt; space &lt;&lt; nombre;</span>
<a name="l00556"></a>00556 <span class="comment">// pour pouvoir relire le fichier de facon transparente avec</span>
<a name="l00557"></a>00557 <span class="comment">// fichier &gt;&gt; motcle &gt;&gt; nombre;</span>
<a name="l00558"></a>00558 <span class="comment">// Ancien code:</span>
<a name="l00559"></a>00559 <span class="comment">// if(!bin_)</span>
<a name="l00560"></a>00560 <span class="comment">// ecrire(&quot; &quot;);</span>
<a name="l00561"></a>00561   <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00562"></a>00562 }
<a name="l00563"></a>00563 <span class="preprocessor">#ifdef IO_avec_string</span>
<a name="l00564"></a>00564 <span class="preprocessor"></span><a class="code" href="classSortie.html" title="Classe de base des flux de sortie. Elle sait ecrire des types simples&lt;br&gt;(entiers, flottants) et des Ob...">Sortie</a>&amp; <a class="code" href="classSortie.html#a5affb80ee844b1032a7dba4bf05ffd7e">Sortie::operator &lt;&lt;</a>(<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; str)
<a name="l00565"></a>00565 {
<a name="l00566"></a>00566   (*ostream_) &lt;&lt; str;
<a name="l00567"></a>00567   <span class="keywordflow">return</span> (*<span class="keyword">this</span>);
<a name="l00568"></a>00568 }
<a name="l00569"></a>00569 <span class="preprocessor">#endif</span>
<a name="l00570"></a><a class="code" href="classSortie.html#a021623694e47b867faf7de179b551e06">00570</a> <span class="preprocessor"></span><a class="code" href="classSortie.html#a021623694e47b867faf7de179b551e06">Sortie::~Sortie</a>()
<a name="l00571"></a>00571 {
<a name="l00572"></a>00572   <span class="keywordflow">if</span>(<a class="code" href="classSortie.html#aa9c371bbb0f88e0f18f7209a7d32f4c6">ostream_</a>)
<a name="l00573"></a>00573     <span class="keyword">delete</span> <a class="code" href="classSortie.html#aa9c371bbb0f88e0f18f7209a7d32f4c6">ostream_</a>;
<a name="l00574"></a>00574   <a class="code" href="classSortie.html#aa9c371bbb0f88e0f18f7209a7d32f4c6">ostream_</a>=0;
<a name="l00575"></a>00575 }
<a name="l00576"></a>00576 
<a name="l00577"></a>00577 <span class="comment">//</span>
<a name="l00578"></a>00578 <span class="comment">//</span>
<a name="l00579"></a>00579 <span class="comment">//</span>
<a name="l00580"></a>00580 <span class="comment">//</span>
<a name="l00581"></a>00581 <span class="comment">//</span>
<a name="l00582"></a>00582 <span class="comment">//</span><span class="comment"></span>
<a name="l00583"></a>00583 <span class="comment">//! Change le mode d&#39;ecriture du fichier.&lt;br&gt;Cette methode peut etre appelee n&#39;importe quand. Attention&lt;br&gt;cependant pour les fichiers Ecrire_Fichier_Partage :&lt;br&gt;il faut faire le changement uniquement au debut de l&#39;ecriture&lt;br&gt;d&#39;un bloc, juste apres syncfile() (sinon, mauvaise traduction&lt;br&gt;des retours a la ligne lors du syncfile suivant).</span>
<a name="l00584"></a><a class="code" href="classSortie.html#a1b830c79a55971e0ae7281d13e06cb44">00584</a> <span class="comment"></span><span class="keywordtype">int</span> <a class="code" href="classSortie.html#a1b830c79a55971e0ae7281d13e06cb44" title="Change le mode d&#39;ecriture du fichier. Cette methode peut etre appelee n&#39;importe quand. Attention cependant pour les fichiers Ecrire_Fichier_Partage : il faut faire le changement uniquement au debut de l&#39;ecriture d&#39;un bloc, juste apres syncfile() (sinon, mauvaise traduction des retours a la ligne lors du syncfile suivant).">Sortie::set_bin</a>(<span class="keywordtype">int</span> bin)
<a name="l00585"></a>00585 {
<a name="l00586"></a>00586   assert(bin==0 || bin==1);
<a name="l00587"></a>00587   <a class="code" href="classSortie.html#a7291aca32660e875543da1f0260b3773">bin_</a> = bin;
<a name="l00588"></a>00588   <span class="keywordflow">if</span> (<a class="code" href="classSortie.html#aa9c371bbb0f88e0f18f7209a7d32f4c6">ostream_</a>)
<a name="l00589"></a>00589     {
<a name="l00590"></a>00590       <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a>&lt;&lt;<span class="stringliteral">&quot;Error you cant change binary format after open &quot;</span>&lt;&lt;<a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
<a name="l00591"></a>00591       assert(0);
<a name="l00592"></a>00592       <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">Process::exit</a>();
<a name="l00593"></a>00593     }
<a name="l00594"></a>00594   <span class="keywordflow">return</span> <a class="code" href="classSortie.html#a7291aca32660e875543da1f0260b3773">bin_</a>;
<a name="l00595"></a>00595 }
<a name="l00596"></a><a class="code" href="classSortie.html#aab73ebc5756f6b82376a4714a56d2911">00596</a> <span class="keywordtype">bool</span> <a class="code" href="classSortie.html#aab73ebc5756f6b82376a4714a56d2911">Sortie::has_ostream</a>()<span class="keyword"> const</span>
<a name="l00597"></a>00597 <span class="keyword"></span>{
<a name="l00598"></a>00598   <span class="keywordflow">return</span> (<a class="code" href="classSortie.html#aa9c371bbb0f88e0f18f7209a7d32f4c6">ostream_</a>!=0);
<a name="l00599"></a>00599 }
<a name="l00600"></a>00600 
<a name="l00601"></a><a class="code" href="classSortie.html#a6817e8b717155359b75a03d3b8c4e4e1">00601</a> <span class="keywordtype">int</span> <a class="code" href="classSortie.html#a6817e8b717155359b75a03d3b8c4e4e1">Sortie::is_bin</a>()
<a name="l00602"></a>00602 {
<a name="l00603"></a>00603   <span class="keywordflow">return</span> <a class="code" href="classSortie.html#a7291aca32660e875543da1f0260b3773">bin_</a>;
<a name="l00604"></a>00604 }
<a name="l00605"></a>00605 
<a name="l00606"></a>00606 
</pre></div></div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Tue Dec 14 2021 19:35:27 for TRUST by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
