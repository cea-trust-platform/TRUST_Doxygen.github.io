<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>TRUST: src/Kernel/Math/ArrOfDouble.cpp Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">TRUST&#160;<span id="projectnumber">1.8.4</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
<div class="header">
  <div class="headertitle">
<div class="title">src/Kernel/Math/ArrOfDouble.cpp</div>  </div>
</div>
<div class="contents">
<a href="ArrOfDouble_8cpp.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/****************************************************************************</span>
<a name="l00002"></a>00002 <span class="comment">* Copyright (c) 2015 - 2016, CEA</span>
<a name="l00003"></a>00003 <span class="comment">* All rights reserved.</span>
<a name="l00004"></a>00004 <span class="comment">*</span>
<a name="l00005"></a>00005 <span class="comment">* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</span>
<a name="l00006"></a>00006 <span class="comment">* 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.</span>
<a name="l00007"></a>00007 <span class="comment">* 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.</span>
<a name="l00008"></a>00008 <span class="comment">* 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.</span>
<a name="l00009"></a>00009 <span class="comment">*</span>
<a name="l00010"></a>00010 <span class="comment">* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.</span>
<a name="l00011"></a>00011 <span class="comment">* IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;</span>
<a name="l00012"></a>00012 <span class="comment">* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>
<a name="l00013"></a>00013 <span class="comment">*</span>
<a name="l00014"></a>00014 <span class="comment">*****************************************************************************/</span>
<a name="l00015"></a>00015 <span class="comment">//</span>
<a name="l00016"></a>00016 <span class="comment">// </span>
<a name="l00017"></a>00017 <span class="comment">// File:        ArrOfDouble.cpp</span>
<a name="l00018"></a>00018 <span class="comment">// Directory:   $TRUST_ROOT/src/Kernel/Math</span>
<a name="l00019"></a>00019 <span class="comment">// Version:     /main/10</span>
<a name="l00020"></a>00020 <span class="comment">// </span>
<a name="l00021"></a>00021 <span class="comment">//</span>
<a name="l00022"></a>00022 <span class="comment">// </span>
<a name="l00023"></a>00023 <span class="comment">// WARNING: DO NOT EDIT THIS FILE! Only edit the template file ArrOfDouble.cpp.P</span>
<a name="l00024"></a>00024 <span class="comment">// </span>
<a name="l00025"></a>00025 <span class="comment">// </span>
<a name="l00026"></a>00026 <span class="preprocessor">#include &lt;<a class="code" href="ArrOfDouble_8h.html">ArrOfDouble.h</a>&gt;</span>
<a name="l00027"></a>00027 <span class="comment">// #include &lt;FArrOfDouble.h&gt;</span>
<a name="l00028"></a>00028 <span class="preprocessor">#include &lt;math.h&gt;</span>
<a name="l00029"></a>00029 <span class="preprocessor">#ifdef SGI_</span>
<a name="l00030"></a>00030 <span class="preprocessor"></span><span class="preprocessor">#include &lt;bstring.h&gt;</span>
<a name="l00031"></a>00031 <span class="preprocessor">#endif</span>
<a name="l00032"></a>00032 <span class="preprocessor"></span><span class="preprocessor">#include &lt;<a class="code" href="Memoire_8h.html">Memoire.h</a>&gt;</span>
<a name="l00033"></a>00033 <span class="preprocessor">#include &lt;<a class="code" href="Vect__ArrOfDouble_8h.html">Vect_ArrOfDouble.h</a>&gt;</span>
<a name="l00034"></a>00034 <span class="preprocessor">#include &lt;<a class="code" href="Ref__ArrOfDouble_8h.html">Ref_ArrOfDouble.h</a>&gt;</span>
<a name="l00035"></a>00035 <span class="preprocessor">#include &lt;climits&gt;</span>
<a name="l00036"></a>00036 
<a name="l00037"></a><a class="code" href="ArrOfDouble_8cpp.html#a7e8070e6406f95d911b21e75e941ce5a">00037</a> <a class="code" href="Declare__Inst_8h.html#a1a414570e3c7a7f9787a0eba4e9366e8">Implemente_instanciable_sans_constructeur_ni_destructeur</a>(<a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a>,<span class="stringliteral">&quot;ArrOfDouble&quot;</span>,<a class="code" href="classArray__base.html" title=": classe vide servant de base a tous les tableaux. (permet de passer un type generique quel que soit ...">Array_base</a>);
<a name="l00038"></a>00038 
<a name="l00039"></a><a class="code" href="ArrOfDouble_8cpp.html#aa27cd2d6a52e585ad8f4145012021d30">00039</a> <a class="code" href="MacVect_8h.html#a0c9b693e7e6836489732c32b7a972a03">Implemente_vect</a>(<a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a>);
<a name="l00040"></a>00040 
<a name="l00041"></a><a class="code" href="ArrOfDouble_8cpp.html#ae4fccab866afd1437d3941160dd24582">00041</a> <a class="code" href="MacRef_8h.html#a67b571ae2caa2f388a7d532cf57553fe">Implemente_ref</a>(<a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a>);
<a name="l00042"></a>00042 
<a name="l00043"></a>00043 <span class="comment">// ******************************************************************</span>
<a name="l00044"></a>00044 <span class="comment">// </span>
<a name="l00045"></a>00045 <span class="comment">// Implementation des methodes de VDoubledata</span>
<a name="l00046"></a>00046 <span class="comment">// </span>
<a name="l00047"></a>00047 <span class="comment">// ******************************************************************</span>
<a name="l00048"></a>00048 <span class="comment">//</span>
<a name="l00049"></a>00049 <span class="comment">// </span>
<a name="l00050"></a>00050 <span class="comment">// </span>
<a name="l00051"></a>00051 <span class="comment">//</span>
<a name="l00052"></a>00052 <span class="comment">//</span>
<a name="l00053"></a>00053 <span class="comment">//</span>
<a name="l00054"></a>00054 <span class="comment">//</span>
<a name="l00055"></a>00055 <span class="comment">//</span>
<a name="l00056"></a>00056 <span class="comment">//</span>
<a name="l00057"></a>00057 <span class="comment">//</span>
<a name="l00058"></a>00058 <span class="comment">//</span>
<a name="l00059"></a>00059 <span class="comment">//</span><span class="comment"></span>
<a name="l00060"></a>00060 <span class="comment">//! VDoubledata alloue une zone de memoire de la taille specifiee au&lt;br&gt;constructeur, et libere la zone de memoire a la destruction.&lt;br&gt;La memoire peut etre allouee sur le tas (avec new) ou par le&lt;br&gt;mecanisme Memoire::add_trav_double.&lt;br&gt;&quot;ref_count&quot; compte le nombre de pointeurs qui font reference a &quot;this&quot;.&lt;br&gt;(permet au dernier utilisateur de l&#39;objet de le detruire), voir&lt;br&gt;ArrOfDouble.</span>
<a name="l00061"></a>00061 <span class="comment"></span><span class="comment">//</span>
<a name="l00062"></a>00062 
<a name="l00063"></a><a class="code" href="classVDoubledata.html">00063</a> <span class="keyword">class </span><a class="code" href="classVDoubledata.html" title="VDoubledata alloue une zone de memoire de la taille specifiee au constructeur, et libere la zone de m...">VDoubledata</a>
<a name="l00064"></a>00064 {
<a name="l00065"></a>00065 <span class="keyword">public</span>:
<a name="l00066"></a>00066   <a class="code" href="classVDoubledata.html#af62afeb49bd08703144c1206bbf4cbb2" title="Construit un VDoubledata de taille size &gt;= 0 Parametre: int s Signification: taille du VDoubledata...">VDoubledata</a>(<span class="keywordtype">int</span> size, <a class="code" href="classArrOfDouble.html#aa6c9b9bbc6bc40ecd74d10411dc560de">ArrOfDouble::Storage</a> storage);
<a name="l00067"></a>00067   <a class="code" href="classVDoubledata.html#a37fca1e7a631a83557bd5f7eee0f52b3" title="Detruit la zone de memoire allouee.">~VDoubledata</a>();
<a name="l00068"></a>00068   <span class="keywordtype">int</span>          <a class="code" href="classVDoubledata.html#a15b5bc0cf033070e4670245e2c3789ab" title="Un nouveau tableau utilise cette zone memoire : incremente ref_count.">add_one_ref</a>();
<a name="l00069"></a>00069   <span class="keywordtype">int</span>          <a class="code" href="classVDoubledata.html#ad09f0a1c617ee9eb1b0af8cc324c7348" title="Un tableau de moins utilise cette zone memoire decremente ref_count.">suppr_one_ref</a>();
<a name="l00070"></a>00070   <span class="keywordtype">double</span> *        <a class="code" href="classVDoubledata.html#a554af3f6bbf09270b1c4862de9654c17" title="renvoie data_">get_data</a>();
<a name="l00071"></a>00071   <span class="keyword">const</span> <span class="keywordtype">double</span> *  <a class="code" href="classVDoubledata.html#a554af3f6bbf09270b1c4862de9654c17" title="renvoie data_">get_data</a>() <span class="keyword">const</span>;
<a name="l00072"></a>00072   <span class="keyword">inline</span> <span class="keywordtype">int</span>   <a class="code" href="classVDoubledata.html#a9a5ad2abd6b9a242dea253941b3c9448" title="renvoie ref_count_">ref_count</a>() <span class="keyword">const</span>;
<a name="l00073"></a>00073   <span class="keyword">inline</span> <span class="keywordtype">int</span>   <a class="code" href="classVDoubledata.html#aa4024084623369d62bfc24a70fdec663" title="renvoie size_">get_size</a>() <span class="keyword">const</span>;
<a name="l00074"></a>00074 <span class="keyword">private</span>:
<a name="l00075"></a>00075 <span class="comment">// Le constructeur par copie et l&#39;operateur= sont interdits.</span>
<a name="l00076"></a>00076   <a class="code" href="classVDoubledata.html#af62afeb49bd08703144c1206bbf4cbb2" title="Construit un VDoubledata de taille size &gt;= 0 Parametre: int s Signification: taille du VDoubledata...">VDoubledata</a>(<span class="keyword">const</span> <a class="code" href="classVDoubledata.html" title="VDoubledata alloue une zone de memoire de la taille specifiee au constructeur, et libere la zone de m...">VDoubledata</a>&amp; v);
<a name="l00077"></a>00077   <a class="code" href="classVDoubledata.html" title="VDoubledata alloue une zone de memoire de la taille specifiee au constructeur, et libere la zone de m...">VDoubledata</a>&amp; <a class="code" href="classVDoubledata.html#aa0970e3e1901638cf026a2f686754d9a" title="Operateur= interdit. Genere une erreur !">operator=</a>(<span class="keyword">const</span> <a class="code" href="classVDoubledata.html" title="VDoubledata alloue une zone de memoire de la taille specifiee au constructeur, et libere la zone de m...">VDoubledata</a>&amp; v);
<a name="l00078"></a>00078 
<a name="l00079"></a>00079 <span class="comment">// &quot;data&quot; est un pointeur sur une zone de memoire de taille</span>
<a name="l00080"></a>00080 <span class="comment">// sz * sizeof(double), allouee par le</span>
<a name="l00081"></a>00081 <span class="comment">// constructeur et liberee par le destructeur.</span>
<a name="l00082"></a>00082 <span class="comment">// Ce pointeur n&#39;est jamais nul meme si size_==0</span>
<a name="l00083"></a><a class="code" href="classVDoubledata.html#a8d340b8683a741e3761f605e47a00075">00083</a>   <span class="keywordtype">double</span> * <a class="code" href="classVDoubledata.html#a8d340b8683a741e3761f605e47a00075">data_</a>;
<a name="l00084"></a>00084 <span class="comment">// Compteur incremente par add_one_ref et decremente par suppr_one_ref.</span>
<a name="l00085"></a>00085 <span class="comment">// Contient le nombre d&#39;objets ArrOfDouble dont le membre &quot;p&quot; pointe</span>
<a name="l00086"></a>00086 <span class="comment">// vers &quot;this&quot;. On a ref_count_ &gt;= 0.</span>
<a name="l00087"></a><a class="code" href="classVDoubledata.html#aa1a01658aeaf9683691fb3ea98f20459">00087</a>   <span class="keywordtype">int</span> <a class="code" href="classVDoubledata.html#aa1a01658aeaf9683691fb3ea98f20459">ref_count_</a>;
<a name="l00088"></a>00088 <span class="comment">// &quot;sz&quot; est la taille du tableau &quot;data_&quot; alloue</span>
<a name="l00089"></a>00089 <span class="comment">// On a sz &gt;= 0.</span>
<a name="l00090"></a><a class="code" href="classVDoubledata.html#a5ad414e959037e02041f93f9a093637c">00090</a>   <span class="keywordtype">int</span> <a class="code" href="classVDoubledata.html#a5ad414e959037e02041f93f9a093637c">size_</a>;
<a name="l00091"></a>00091 <span class="comment">// Si storage est de type TEMP_STORAGE, d_ptr_trav porte la reference</span>
<a name="l00092"></a>00092 <span class="comment">// a la zone allouee, sinon le pointeur est nul.</span>
<a name="l00093"></a><a class="code" href="classVDoubledata.html#a3ee57ae91bc986695cae7d7174291bda">00093</a>   <a class="code" href="classDouble__ptr__trav.html" title="Une zone de travail de la Memoire TRUST composee d&#39;elements de type double.">Double_ptr_trav</a> * <a class="code" href="classVDoubledata.html#a3ee57ae91bc986695cae7d7174291bda">d_ptr_trav_</a>;
<a name="l00094"></a>00094 };
<a name="l00095"></a>00095 
<a name="l00096"></a>00096 
<a name="l00097"></a>00097 <span class="comment">// Postcondition:</span>
<a name="l00098"></a>00098 <span class="comment">// data_ n&#39;est jamais nul, meme si size==0</span>
<a name="l00099"></a>00099 <span class="comment">//</span>
<a name="l00100"></a>00100 <span class="comment">//</span>
<a name="l00101"></a>00101 <span class="comment">//</span>
<a name="l00102"></a>00102 <span class="comment">//</span>
<a name="l00103"></a>00103 <span class="comment">//</span>
<a name="l00104"></a>00104 <span class="comment">//</span>
<a name="l00105"></a>00105 <span class="comment">//</span><span class="comment"></span>
<a name="l00106"></a>00106 <span class="comment">//! Construit un VDoubledata de taille size &gt;= 0&lt;br&gt;Parametre: int s&lt;br&gt;Signification: taille du VDoubledata, il faut size &gt;= 0&lt;br&gt;Parametre: Storage storage&lt;br&gt;Signification: indique si la memoire doit etre allouee&lt;br&gt;avec &quot;new&quot; ou avec &quot;memoire.add_trav_double()&quot;&lt;br&gt;Valeurs par defaut: STANDARD (allocation avec &quot;new&quot;)</span>
<a name="l00107"></a><a class="code" href="classVDoubledata.html#af62afeb49bd08703144c1206bbf4cbb2">00107</a> <span class="comment"></span><a class="code" href="classVDoubledata.html#af62afeb49bd08703144c1206bbf4cbb2" title="Construit un VDoubledata de taille size &gt;= 0 Parametre: int s Signification: taille du VDoubledata...">VDoubledata::VDoubledata</a>(<span class="keywordtype">int</span> size, <a class="code" href="classArrOfDouble.html#aa6c9b9bbc6bc40ecd74d10411dc560de">ArrOfDouble::Storage</a> storage)
<a name="l00108"></a>00108 {
<a name="l00109"></a>00109   <span class="keywordtype">int</span> size_warning=100000000;
<a name="l00110"></a>00110   assert(size &gt;= 0);
<a name="l00111"></a>00111   <span class="keywordflow">if</span> (size == 0)
<a name="l00112"></a>00112     storage = <a class="code" href="classArrOfDouble.html#aa6c9b9bbc6bc40ecd74d10411dc560dead35388f27e20e247aaeaf8797437d110">ArrOfDouble::STANDARD</a>;
<a name="l00113"></a>00113 
<a name="l00114"></a>00114   <span class="keywordflow">switch</span> (storage)
<a name="l00115"></a>00115     {
<a name="l00116"></a>00116     <span class="keywordflow">case</span> <a class="code" href="classArrOfDouble.html#aa6c9b9bbc6bc40ecd74d10411dc560dead35388f27e20e247aaeaf8797437d110">ArrOfDouble::STANDARD</a>:
<a name="l00117"></a>00117       {
<a name="l00118"></a>00118         <a class="code" href="classVDoubledata.html#a3ee57ae91bc986695cae7d7174291bda">d_ptr_trav_</a> = 0;
<a name="l00119"></a>00119         <span class="keywordflow">if</span> (size&gt;size_warning) <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Warning: Allocating an array of &quot;</span> &lt;&lt; size &lt;&lt; <span class="stringliteral">&quot; Double ...&quot;</span>;
<a name="l00120"></a>00120 <span class="preprocessor">#ifdef _EXCEPTION_</span>
<a name="l00121"></a>00121 <span class="preprocessor"></span><span class="comment">// Allocation de la memoire sur le tas</span>
<a name="l00122"></a>00122         <span class="keywordflow">try</span>
<a name="l00123"></a>00123           {
<a name="l00124"></a>00124             <a class="code" href="classVDoubledata.html#a8d340b8683a741e3761f605e47a00075">data_</a> = <span class="keyword">new</span> <span class="keywordtype">double</span>[size];
<a name="l00125"></a>00125           }
<a name="l00126"></a>00126         <span class="keywordflow">catch</span>(...)
<a name="l00127"></a>00127           {
<a name="l00128"></a>00128             <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;unable to allocate &quot;</span> &lt;&lt; size &lt;&lt; <span class="stringliteral">&quot; double &quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
<a name="l00129"></a>00129             <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">Process::exit</a>();
<a name="l00130"></a>00130           }
<a name="l00131"></a>00131 <span class="preprocessor">#else</span>
<a name="l00132"></a>00132 <span class="preprocessor"></span>        <a class="code" href="classVDoubledata.html#a8d340b8683a741e3761f605e47a00075">data_</a> = <span class="keyword">new</span> <span class="keywordtype">double</span>[size];
<a name="l00133"></a>00133         <span class="keywordflow">if</span>(!<a class="code" href="classVDoubledata.html#a8d340b8683a741e3761f605e47a00075">data_</a>)
<a name="l00134"></a>00134           {
<a name="l00135"></a>00135             <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;unable to allocate &quot;</span> &lt;&lt; size &lt;&lt; <span class="stringliteral">&quot;double &quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
<a name="l00136"></a>00136             <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">Process::exit</a>();
<a name="l00137"></a>00137           }
<a name="l00138"></a>00138 <span class="preprocessor">#endif</span>
<a name="l00139"></a>00139 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (size&gt;size_warning) <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot; OK&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
<a name="l00140"></a>00140         <span class="keywordflow">break</span>;
<a name="l00141"></a>00141       }
<a name="l00142"></a>00142     <span class="keywordflow">case</span> <a class="code" href="classArrOfDouble.html#aa6c9b9bbc6bc40ecd74d10411dc560dea86f97b783db46940466f21da61664650">ArrOfDouble::TEMP_STORAGE</a>:
<a name="l00143"></a>00143       {
<a name="l00144"></a>00144 <span class="comment">// Allocation de la memoire sur un tas special.</span>
<a name="l00145"></a>00145 <span class="comment">// La memoire ne sera pas rendue au systeme mais conservee pour une</span>
<a name="l00146"></a>00146 <span class="comment">// reutilisation ulterieure.</span>
<a name="l00147"></a>00147         <a class="code" href="classMemoire.html" title="La memoire de Trio-U.">Memoire</a>&amp; memoire = <a class="code" href="classMemoire.html#a552329c7ffbaff5dd8395af9489fa05b" title="Retourne un pointeur sur l&#39;instance de la memoire Cree un nouvel objet memoire si aucune instance n&#39;a...">Memoire::Instance</a>();
<a name="l00148"></a>00148         <span class="keywordflow">if</span> (size&gt;size_warning) <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Warning: Allocating or reusing a DoubleTrav of &quot;</span> &lt;&lt; size &lt;&lt; <span class="stringliteral">&quot; elements ...&quot;</span>;
<a name="l00149"></a>00149         <a class="code" href="classVDoubledata.html#a3ee57ae91bc986695cae7d7174291bda">d_ptr_trav_</a> = memoire.<a class="code" href="classMemoire.html#a6179a345baa1e44d3eb5d8e59ac70f55" title="Ajoute une zone de travail &quot;double&quot; dans la memoire.">add_trav_double</a>(size);
<a name="l00150"></a>00150         assert(<a class="code" href="classVDoubledata.html#a3ee57ae91bc986695cae7d7174291bda">d_ptr_trav_</a> != 0);
<a name="l00151"></a>00151         <a class="code" href="classVDoubledata.html#a8d340b8683a741e3761f605e47a00075">data_</a> = <a class="code" href="classVDoubledata.html#a3ee57ae91bc986695cae7d7174291bda">d_ptr_trav_</a>-&gt;<a class="code" href="classDouble__ptr__trav.html#a7f711dcbf01aa1b7baff7211d63a3dbf" title="Retourne un pointeur sur les donnees de la zone de travail.">d_ptr_</a>();
<a name="l00152"></a>00152         <span class="keywordflow">if</span> (size&gt;size_warning) <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot; OK&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
<a name="l00153"></a>00153         <span class="keywordflow">break</span>;
<a name="l00154"></a>00154 
<a name="l00155"></a>00155       }
<a name="l00156"></a>00156     <span class="keywordflow">default</span>:
<a name="l00157"></a>00157       <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">Process::exit</a>();
<a name="l00158"></a>00158     }
<a name="l00159"></a>00159   <a class="code" href="classVDoubledata.html#aa1a01658aeaf9683691fb3ea98f20459">ref_count_</a> = 1;
<a name="l00160"></a>00160   <a class="code" href="classVDoubledata.html#a5ad414e959037e02041f93f9a093637c">size_</a> = size;
<a name="l00161"></a>00161 
<a name="l00162"></a>00162   assert(<a class="code" href="classVDoubledata.html#a8d340b8683a741e3761f605e47a00075">data_</a> != 0);
<a name="l00163"></a>00163 }
<a name="l00164"></a>00164 
<a name="l00165"></a>00165 <span class="comment">// Precondition:</span>
<a name="l00166"></a>00166 <span class="comment">// ref_count == 0 (la zone de memoire ne doit etre referencee nulle part)</span>
<a name="l00167"></a>00167 <span class="comment">//</span><span class="comment"></span>
<a name="l00168"></a>00168 <span class="comment">//! Detruit la zone de memoire allouee.</span>
<a name="l00169"></a><a class="code" href="classVDoubledata.html#a37fca1e7a631a83557bd5f7eee0f52b3">00169</a> <span class="comment"></span><a class="code" href="classVDoubledata.html#a37fca1e7a631a83557bd5f7eee0f52b3" title="Detruit la zone de memoire allouee.">VDoubledata::~VDoubledata</a>()
<a name="l00170"></a>00170 {
<a name="l00171"></a>00171   assert(<a class="code" href="classVDoubledata.html#aa1a01658aeaf9683691fb3ea98f20459">ref_count_</a> == 0);
<a name="l00172"></a>00172   <span class="keywordflow">if</span> (<a class="code" href="classVDoubledata.html#a3ee57ae91bc986695cae7d7174291bda">d_ptr_trav_</a> == 0)
<a name="l00173"></a>00173     {
<a name="l00174"></a>00174 <span class="comment">// Stockage STANDARD</span>
<a name="l00175"></a>00175       <span class="keyword">delete</span>[] <a class="code" href="classVDoubledata.html#a8d340b8683a741e3761f605e47a00075">data_</a>;
<a name="l00176"></a>00176     }
<a name="l00177"></a>00177   <span class="keywordflow">else</span>
<a name="l00178"></a>00178     {
<a name="l00179"></a>00179 <span class="comment">// Stockage TEMP_STORAGE</span>
<a name="l00180"></a>00180       <a class="code" href="classVDoubledata.html#a3ee57ae91bc986695cae7d7174291bda">d_ptr_trav_</a>-&gt;<a class="code" href="classDouble__ptr__trav.html#a54ec9c808c90b8be1748ea0d490a0121" title="Deverrouille la zone de travail.">unlock</a>();
<a name="l00181"></a>00181       <a class="code" href="classVDoubledata.html#a3ee57ae91bc986695cae7d7174291bda">d_ptr_trav_</a> = 0;
<a name="l00182"></a>00182     }
<a name="l00183"></a>00183   <a class="code" href="classVDoubledata.html#a8d340b8683a741e3761f605e47a00075">data_</a> = 0;  <span class="comment">//!&lt; paranoia: si size_==-1 c&#39;est qu&#39;on pointe sur un zombie</span>
<a name="l00184"></a>00184 <span class="comment"></span>  <a class="code" href="classVDoubledata.html#a5ad414e959037e02041f93f9a093637c">size_</a> = -1; <span class="comment">//!&lt;  (pointeur vers un objet qui a ete detruit)</span>
<a name="l00185"></a>00185 <span class="comment"></span>}
<a name="l00186"></a>00186 <span class="comment"></span>
<a name="l00187"></a>00187 <span class="comment">//! renvoie ref_count_</span>
<a name="l00188"></a><a class="code" href="classVDoubledata.html#a9a5ad2abd6b9a242dea253941b3c9448">00188</a> <span class="comment"></span><span class="keyword">inline</span> <span class="keywordtype">int</span> <a class="code" href="classVDoubledata.html#a9a5ad2abd6b9a242dea253941b3c9448" title="renvoie ref_count_">VDoubledata::ref_count</a>()<span class="keyword"> const</span>
<a name="l00189"></a>00189 <span class="keyword"></span>{
<a name="l00190"></a>00190   <span class="keywordflow">return</span> <a class="code" href="classVDoubledata.html#aa1a01658aeaf9683691fb3ea98f20459">ref_count_</a>;
<a name="l00191"></a>00191 }
<a name="l00192"></a>00192 <span class="comment"></span>
<a name="l00193"></a>00193 <span class="comment">//! renvoie size_</span>
<a name="l00194"></a><a class="code" href="classVDoubledata.html#aa4024084623369d62bfc24a70fdec663">00194</a> <span class="comment"></span><span class="keyword">inline</span> <span class="keywordtype">int</span> <a class="code" href="classVDoubledata.html#aa4024084623369d62bfc24a70fdec663" title="renvoie size_">VDoubledata::get_size</a>()<span class="keyword"> const</span>
<a name="l00195"></a>00195 <span class="keyword"></span>{
<a name="l00196"></a>00196   <span class="keywordflow">return</span> <a class="code" href="classVDoubledata.html#a5ad414e959037e02041f93f9a093637c">size_</a>;
<a name="l00197"></a>00197 }
<a name="l00198"></a>00198 
<a name="l00199"></a>00199 <span class="comment">//</span>
<a name="l00200"></a>00200 <span class="comment">//</span><span class="comment"></span>
<a name="l00201"></a>00201 <span class="comment">//! Un nouveau tableau utilise cette zone memoire :&lt;br&gt;incremente ref_count</span>
<a name="l00202"></a>00202 <span class="comment"></span><span class="comment">/** \return int&lt;br&gt;</span>
<a name="l00203"></a>00203 <span class="comment">Signification: ref_count */</span>
<a name="l00204"></a><a class="code" href="classVDoubledata.html#a15b5bc0cf033070e4670245e2c3789ab">00204</a> <span class="keyword">inline</span> <span class="keywordtype">int</span> <a class="code" href="classVDoubledata.html#a15b5bc0cf033070e4670245e2c3789ab" title="Un nouveau tableau utilise cette zone memoire : incremente ref_count.">VDoubledata::add_one_ref</a>()
<a name="l00205"></a>00205 {
<a name="l00206"></a>00206   <span class="keywordflow">return</span> ++<a class="code" href="classVDoubledata.html#aa1a01658aeaf9683691fb3ea98f20459">ref_count_</a>;
<a name="l00207"></a>00207 }
<a name="l00208"></a>00208 
<a name="l00209"></a>00209 <span class="comment">// Precondition:</span>
<a name="l00210"></a>00210 <span class="comment">// ref_count_ &gt; 0</span>
<a name="l00211"></a>00211 <span class="comment">//</span>
<a name="l00212"></a>00212 <span class="comment">//</span><span class="comment"></span>
<a name="l00213"></a>00213 <span class="comment">//! Un tableau de moins utilise cette zone memoire&lt;br&gt;decremente ref_count</span>
<a name="l00214"></a>00214 <span class="comment"></span><span class="comment">/** \return int&lt;br&gt;</span>
<a name="l00215"></a>00215 <span class="comment">Signification: ref_count */</span>
<a name="l00216"></a><a class="code" href="classVDoubledata.html#ad09f0a1c617ee9eb1b0af8cc324c7348">00216</a> <span class="keyword">inline</span> <span class="keywordtype">int</span> <a class="code" href="classVDoubledata.html#ad09f0a1c617ee9eb1b0af8cc324c7348" title="Un tableau de moins utilise cette zone memoire decremente ref_count.">VDoubledata::suppr_one_ref</a>()
<a name="l00217"></a>00217 {
<a name="l00218"></a>00218   assert(<a class="code" href="classVDoubledata.html#aa1a01658aeaf9683691fb3ea98f20459">ref_count_</a> &gt; 0);
<a name="l00219"></a>00219   <span class="keywordflow">return</span> (--<a class="code" href="classVDoubledata.html#aa1a01658aeaf9683691fb3ea98f20459">ref_count_</a>);
<a name="l00220"></a>00220 }
<a name="l00221"></a>00221 <span class="comment"></span>
<a name="l00222"></a>00222 <span class="comment">//! renvoie data_</span>
<a name="l00223"></a><a class="code" href="classVDoubledata.html#a554af3f6bbf09270b1c4862de9654c17">00223</a> <span class="comment"></span><span class="keyword">inline</span> <span class="keywordtype">double</span> * <a class="code" href="classVDoubledata.html#a554af3f6bbf09270b1c4862de9654c17" title="renvoie data_">VDoubledata::get_data</a>()
<a name="l00224"></a>00224 {
<a name="l00225"></a>00225   <span class="keywordflow">return</span> <a class="code" href="classVDoubledata.html#a8d340b8683a741e3761f605e47a00075">data_</a>;
<a name="l00226"></a>00226 }
<a name="l00227"></a>00227 <span class="comment"></span>
<a name="l00228"></a>00228 <span class="comment">//! renvoie data_</span>
<a name="l00229"></a><a class="code" href="classVDoubledata.html#a028e1dacc162c70edf9d0cb920b53d66">00229</a> <span class="comment"></span><span class="keyword">inline</span> <span class="keyword">const</span> <span class="keywordtype">double</span> * <a class="code" href="classVDoubledata.html#a554af3f6bbf09270b1c4862de9654c17" title="renvoie data_">VDoubledata::get_data</a>()<span class="keyword"> const</span>
<a name="l00230"></a>00230 <span class="keyword"></span>{
<a name="l00231"></a>00231   <span class="keywordflow">return</span> <a class="code" href="classVDoubledata.html#a8d340b8683a741e3761f605e47a00075">data_</a>;
<a name="l00232"></a>00232 }
<a name="l00233"></a>00233 <span class="comment"></span>
<a name="l00234"></a>00234 <span class="comment">//! Constructeur par copie. Interdit : genere une erreur !</span>
<a name="l00235"></a><a class="code" href="classVDoubledata.html#a6ff1367718942132c3b44b2bd764303c">00235</a> <span class="comment"></span><a class="code" href="classVDoubledata.html#af62afeb49bd08703144c1206bbf4cbb2" title="Construit un VDoubledata de taille size &gt;= 0 Parametre: int s Signification: taille du VDoubledata...">VDoubledata::VDoubledata</a>(<span class="keyword">const</span> <a class="code" href="classVDoubledata.html" title="VDoubledata alloue une zone de memoire de la taille specifiee au constructeur, et libere la zone de m...">VDoubledata</a>&amp; v)
<a name="l00236"></a>00236 {
<a name="l00237"></a>00237   <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Error in VDoubledata: VDoubledata (const VDoubledata &amp; v)&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
<a name="l00238"></a>00238   <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">Process::exit</a>();
<a name="l00239"></a>00239 }
<a name="l00240"></a>00240 <span class="comment"></span>
<a name="l00241"></a>00241 <span class="comment">//! Operateur= interdit. Genere une erreur !</span>
<a name="l00242"></a><a class="code" href="classVDoubledata.html#aa0970e3e1901638cf026a2f686754d9a">00242</a> <span class="comment"></span><a class="code" href="classVDoubledata.html" title="VDoubledata alloue une zone de memoire de la taille specifiee au constructeur, et libere la zone de m...">VDoubledata</a>&amp; <a class="code" href="classVDoubledata.html#aa0970e3e1901638cf026a2f686754d9a" title="Operateur= interdit. Genere une erreur !">VDoubledata::operator=</a>(<span class="keyword">const</span> <a class="code" href="classVDoubledata.html" title="VDoubledata alloue une zone de memoire de la taille specifiee au constructeur, et libere la zone de m...">VDoubledata</a>&amp; v)
<a name="l00243"></a>00243 {
<a name="l00244"></a>00244   <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Error in VDoubledata::operator=(const VDoubledata &amp; v)&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
<a name="l00245"></a>00245   <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">Process::exit</a>();
<a name="l00246"></a>00246   <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00247"></a>00247 }
<a name="l00248"></a>00248 
<a name="l00249"></a>00249 <span class="comment">// ******************************************************************</span>
<a name="l00250"></a>00250 <span class="comment">// </span>
<a name="l00251"></a>00251 <span class="comment">// Implementation des methodes de ArrOfDouble</span>
<a name="l00252"></a>00252 <span class="comment">// </span>
<a name="l00253"></a>00253 <span class="comment">// ******************************************************************</span>
<a name="l00254"></a>00254 
<a name="l00255"></a>00255 <span class="comment">// Precondition:</span>
<a name="l00256"></a>00256 <span class="comment">// Parametre: Sortie&amp; os</span>
<a name="l00257"></a>00257 <span class="comment">// Signification: le flot de sortie a utiliser</span>
<a name="l00258"></a>00258 <span class="comment">//</span>
<a name="l00259"></a>00259 <span class="comment">//</span><span class="comment"></span>
<a name="l00260"></a>00260 <span class="comment">//! Ecriture du tableau sur &quot;os&quot; :&lt;br&gt;ecrit le nombre d&#39;elements suivi des valeurs du tableau</span>
<a name="l00261"></a>00261 <span class="comment"></span><span class="comment">/** \return Sortie\&amp;&lt;br&gt;</span>
<a name="l00262"></a>00262 <span class="comment">Signification: le flot de sortie modifie */</span>
<a name="l00263"></a><a class="code" href="classArrOfDouble.html#a9dc3bfa20c1ddf76911449fcb5746c6d">00263</a> <a class="code" href="classSortie.html" title="Classe de base des flux de sortie. Elle sait ecrire des types simples&lt;br&gt;(entiers, flottants) et des Ob...">Sortie</a>&amp; <a class="code" href="classArrOfDouble.html#a9dc3bfa20c1ddf76911449fcb5746c6d" title="Ecriture du tableau sur &quot;os&quot; : ecrit le nombre d&#39;elements suivi des valeurs du tableau.">ArrOfDouble::printOn</a>(<a class="code" href="classSortie.html" title="Classe de base des flux de sortie. Elle sait ecrire des types simples&lt;br&gt;(entiers, flottants) et des Ob...">Sortie</a>&amp; os)<span class="keyword"> const</span>
<a name="l00264"></a>00264 <span class="keyword"></span>{
<a name="l00265"></a>00265   <span class="keywordtype">int</span> <a class="code" href="Nom_8cpp.html#a0e1ea19fb9fa7881d15d84eff4c090e1">sz</a>=<a class="code" href="classArrOfDouble.html#a3c3b33bea0e88b87315c21ee94bee05f" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>();
<a name="l00266"></a>00266   os &lt;&lt; sz &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
<a name="l00267"></a>00267   <span class="keywordflow">if</span> (sz &gt; 0)
<a name="l00268"></a>00268     {
<a name="l00269"></a>00269       <span class="keyword">const</span> <span class="keywordtype">double</span>* v = <a class="code" href="classArrOfDouble.html#a77419df7d43ac2ce76b9388a39ad90e9">data_</a>;
<a name="l00270"></a>00270       os.<a class="code" href="classSortie.html#aa3f46aaccaff0f83c018784b50d8ea24" title="Methode de bas niveau pour ecrire un tableau d&#39;ints ou reels dans le stream. Dans l&#39;implementation de...">put</a>(v,sz,sz);
<a name="l00271"></a>00271     }
<a name="l00272"></a>00272   <span class="keywordflow">return</span> os;
<a name="l00273"></a>00273 }
<a name="l00274"></a>00274 
<a name="l00275"></a>00275 <span class="comment">// Precondition:</span>
<a name="l00276"></a>00276 <span class="comment">// Le tableau doit etre &quot;resizable&quot; (voir precondition de resize_array_)</span>
<a name="l00277"></a>00277 <span class="comment">// Parametre: Entree&amp; is</span>
<a name="l00278"></a>00278 <span class="comment">// Signification: le flot d&#39;entree a utiliser</span>
<a name="l00279"></a>00279 <span class="comment">// Valeurs par defaut:</span>
<a name="l00280"></a>00280 <span class="comment">// Contraintes:</span>
<a name="l00281"></a>00281 <span class="comment">// Acces:</span>
<a name="l00282"></a>00282 <span class="comment">// Exception:</span>
<a name="l00283"></a>00283 <span class="comment">// Si la taille lue est negative, erreur.</span>
<a name="l00284"></a>00284 <span class="comment">//</span>
<a name="l00285"></a>00285 <span class="comment">//</span><span class="comment"></span>
<a name="l00286"></a>00286 <span class="comment">//! Lecture d&#39;un tableau dans un flot d&#39;entree&lt;br&gt;Lit le nombre d&#39;elements suivi des elements eux-memes</span>
<a name="l00287"></a>00287 <span class="comment"></span><span class="comment">/** \return Entree\&amp;&lt;br&gt;</span>
<a name="l00288"></a>00288 <span class="comment">Signification: le flot d&#39;entree modifie&lt;br&gt;</span>
<a name="l00289"></a>00289 <span class="comment">Contraintes: */</span>
<a name="l00290"></a><a class="code" href="classArrOfDouble.html#a5e51c4df4648b6e1aaeee466f3be0044">00290</a> <a class="code" href="classEntree.html" title="Classe de definition des operateurs et methodes pour toute lecture dans un flot d&#39;entree (fichier...">Entree</a>&amp; <a class="code" href="classArrOfDouble.html#a5e51c4df4648b6e1aaeee466f3be0044" title="Lecture d&#39;un tableau dans un flot d&#39;entree Lit le nombre d&#39;elements suivi des elements eux-memes...">ArrOfDouble::readOn</a>(<a class="code" href="classEntree.html" title="Classe de definition des operateurs et methodes pour toute lecture dans un flot d&#39;entree (fichier...">Entree</a>&amp; is)
<a name="l00291"></a>00291 {
<a name="l00292"></a>00292   <span class="keywordtype">int</span> <a class="code" href="Nom_8cpp.html#a0e1ea19fb9fa7881d15d84eff4c090e1">sz</a>;
<a name="l00293"></a>00293   is &gt;&gt; <a class="code" href="Nom_8cpp.html#a0e1ea19fb9fa7881d15d84eff4c090e1">sz</a>;
<a name="l00294"></a>00294   <span class="keywordflow">if</span> (sz &gt;= 0)
<a name="l00295"></a>00295     {
<a name="l00296"></a>00296 <span class="comment">// Appel a la methode sans precondition sur le type derive</span>
<a name="l00297"></a>00297 <span class="comment">// (car readOn est virtuelle, les autres proprietes seront initialisees correctement)</span>
<a name="l00298"></a>00298       <a class="code" href="classArrOfDouble.html#af6aaac97844f02d467f6b84286e1cf1b" title="methode protegee de changement de taille, appelable par les classes derivees (idem que resize_array()...">resize_array_</a>(sz);
<a name="l00299"></a>00299       <span class="keywordflow">if</span> (sz &gt; 0)
<a name="l00300"></a>00300         {
<a name="l00301"></a>00301           <span class="keywordtype">double</span>* v = <a class="code" href="classArrOfDouble.html#a77419df7d43ac2ce76b9388a39ad90e9">data_</a>;
<a name="l00302"></a>00302           is.<a class="code" href="classEntree.html#aa434f5ceb8169e469613d1f6cd1fd99f" title="methode virtuelle pour lire un tableau d&#39;ints ou reels&lt;br&gt;(le tableau doit avoir la bonne dimension: ...">get</a>(v,sz);
<a name="l00303"></a>00303         }
<a name="l00304"></a>00304     }
<a name="l00305"></a>00305   <span class="keywordflow">else</span>
<a name="l00306"></a>00306     {
<a name="l00307"></a>00307       <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Error in ArrOfDouble:readOn : size = &quot;</span> &lt;&lt; sz &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
<a name="l00308"></a>00308       assert(0);
<a name="l00309"></a>00309       <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">exit</a>();
<a name="l00310"></a>00310     }
<a name="l00311"></a>00311   <span class="keywordflow">return</span> is;
<a name="l00312"></a>00312 }
<a name="l00313"></a>00313 
<a name="l00314"></a>00314 <span class="comment">//</span><span class="comment"></span>
<a name="l00315"></a>00315 <span class="comment">//! Destructeur : appelle detach_array()</span>
<a name="l00316"></a><a class="code" href="classArrOfDouble.html#a71ad0b1778d7c3df7f37c51f1a9c7844">00316</a> <span class="comment"></span><a class="code" href="classArrOfDouble.html#a71ad0b1778d7c3df7f37c51f1a9c7844" title="Destructeur : appelle detach_array()">ArrOfDouble::~ArrOfDouble</a>()
<a name="l00317"></a>00317 {
<a name="l00318"></a>00318   <a class="code" href="classArrOfDouble.html#a30d7509eec18c3ef46cc0140bdcdc48f" title="Amene le tableau dans l&#39;etat &quot;detache&quot;. C&#39;est a dire: Si le tableau est &quot;detache&quot; : * ne rien faire...">detach_array</a>();
<a name="l00319"></a>00319   <a class="code" href="classArrOfDouble.html#ae201cdbdbf9f840376398199e5f737a0">size_array_</a> = -1; <span class="comment">//!&lt; Paranoia: si size_array_==-1, c&#39;est un zombie</span>
<a name="l00320"></a>00320 <span class="comment"></span>}
<a name="l00321"></a>00321 
<a name="l00322"></a>00322 <span class="comment">//</span>
<a name="l00323"></a>00323 <span class="comment">//</span><span class="comment"></span>
<a name="l00324"></a>00324 <span class="comment">//! Constructeur par defaut: cree un tableau &quot;detache&quot;,&lt;br&gt;soit p_==0, data_==0, size_array_==0, smart_resize_==0</span>
<a name="l00325"></a><a class="code" href="classArrOfDouble.html#a8890dc9a68c33a7862e776f411adaa02">00325</a> <span class="comment"></span><a class="code" href="classArrOfDouble.html#a8890dc9a68c33a7862e776f411adaa02" title="Constructeur par defaut: cree un tableau &quot;detache&quot;, soit p_==0, data_==0, size_array_==0, smart_resize_==0.">ArrOfDouble::ArrOfDouble</a>() :
<a name="l00326"></a>00326   p_(0),
<a name="l00327"></a>00327   data_(0),
<a name="l00328"></a>00328   size_array_(0),
<a name="l00329"></a>00329   memory_size_(0),
<a name="l00330"></a>00330   smart_resize_(0),
<a name="l00331"></a>00331   storage_type_(STANDARD)
<a name="l00332"></a>00332 {
<a name="l00333"></a>00333 }
<a name="l00334"></a>00334 
<a name="l00335"></a>00335 <span class="comment">//</span>
<a name="l00336"></a>00336 <span class="comment">//</span>
<a name="l00337"></a>00337 <span class="comment">//</span>
<a name="l00338"></a>00338 <span class="comment">//</span>
<a name="l00339"></a>00339 <span class="comment">//</span>
<a name="l00340"></a>00340 <span class="comment">//</span><span class="comment"></span>
<a name="l00341"></a>00341 <span class="comment">//! Cree un tableau de taille n avec allocation standard (voir set_mem_storage).&lt;br&gt;Le tableau est rempli avec zero par defaut. Pour creer un tableau non initialise, utiliser:&lt;br&gt;ArrOfDouble toto;&lt;br&gt;toto.resize_array(n, NOCOPY_NOINIT);&lt;br&gt;Parametre: int n&lt;br&gt;Signification: taille du tableau</span>
<a name="l00342"></a><a class="code" href="classArrOfDouble.html#a8501f69b54146bfd7dac7d11539e931f">00342</a> <span class="comment"></span><a class="code" href="classArrOfDouble.html#a8890dc9a68c33a7862e776f411adaa02" title="Constructeur par defaut: cree un tableau &quot;detache&quot;, soit p_==0, data_==0, size_array_==0, smart_resize_==0.">ArrOfDouble::ArrOfDouble</a>(<span class="keywordtype">int</span> n) :
<a name="l00343"></a>00343   p_(0),
<a name="l00344"></a>00344   data_(0),
<a name="l00345"></a>00345   size_array_(n),
<a name="l00346"></a>00346   memory_size_(n),
<a name="l00347"></a>00347   smart_resize_(0),
<a name="l00348"></a>00348   storage_type_(STANDARD)
<a name="l00349"></a>00349 {
<a name="l00350"></a>00350   <span class="keywordflow">if</span> (n)
<a name="l00351"></a>00351     {
<a name="l00352"></a>00352       <a class="code" href="classArrOfDouble.html#a16cc4d79375188b7cb389fce2c920186">p_</a> = <span class="keyword">new</span> <a class="code" href="classVDoubledata.html" title="VDoubledata alloue une zone de memoire de la taille specifiee au constructeur, et libere la zone de m...">VDoubledata</a>(n, <a class="code" href="classArrOfDouble.html#aa6c9b9bbc6bc40ecd74d10411dc560dead35388f27e20e247aaeaf8797437d110">STANDARD</a>);
<a name="l00353"></a>00353       <a class="code" href="classArrOfDouble.html#a77419df7d43ac2ce76b9388a39ad90e9">data_</a> = <a class="code" href="classArrOfDouble.html#a16cc4d79375188b7cb389fce2c920186">p_</a>-&gt;<a class="code" href="classVDoubledata.html#a554af3f6bbf09270b1c4862de9654c17" title="renvoie data_">get_data</a>();
<a name="l00354"></a>00354       <a class="code" href="classArrOfDouble.html#a67d30f4f02d7656362fce21d8e0e9745" title="Remplit &quot;nb&quot; cases consecutives du tableau a partir de la case &quot;first&quot; avec une valeur par defaut...">fill_default_value</a>(<a class="code" href="classArray__base.html#abee342aa9ac59623c4c782dc9d7877ffa9a675e25b5b7accff8d861e05060547b">COPY_INIT</a>, 0, n);
<a name="l00355"></a>00355     }
<a name="l00356"></a>00356 }
<a name="l00357"></a>00357 
<a name="l00358"></a>00358 <span class="comment">/*</span>
<a name="l00359"></a>00359 <span class="comment">ArrOfDouble::ArrOfDouble(int n, double x) :</span>
<a name="l00360"></a>00360 <span class="comment">  p_(0),</span>
<a name="l00361"></a>00361 <span class="comment">  data_(0),</span>
<a name="l00362"></a>00362 <span class="comment">  size_array_(n),</span>
<a name="l00363"></a>00363 <span class="comment">  memory_size_(n),</span>
<a name="l00364"></a>00364 <span class="comment">  smart_resize_(0),</span>
<a name="l00365"></a>00365 <span class="comment">  storage_type_(STANDARD)</span>
<a name="l00366"></a>00366 <span class="comment">{</span>
<a name="l00367"></a>00367 <span class="comment">  if (n) {</span>
<a name="l00368"></a>00368 <span class="comment">    p_ = new VDoubledata(n, STANDARD);</span>
<a name="l00369"></a>00369 <span class="comment">    data_ = p_-&gt;get_data();</span>
<a name="l00370"></a>00370 <span class="comment">    *this = x;</span>
<a name="l00371"></a>00371 <span class="comment">  }</span>
<a name="l00372"></a>00372 <span class="comment">}</span>
<a name="l00373"></a>00373 <span class="comment">// Precondition:</span>
<a name="l00374"></a>00374 <span class="comment">// Parametre: int n</span>
<a name="l00375"></a>00375 <span class="comment">// Signification: taille du tableau</span>
<a name="l00376"></a>00376 <span class="comment">// Parametre: double x</span>
<a name="l00377"></a>00377 <span class="comment">// Signification: valeur pour initialiser le tableau</span>
<a name="l00378"></a>00378 <span class="comment">//</span>
<a name="l00379"></a>00379 <span class="comment">//</span><span class="comment"></span>
<a name="l00380"></a>00380 <span class="comment">//! Cree un tableau de taille n&lt;br&gt;toutes les cases sont initialisees a x</span>
<a name="l00381"></a>00381 <span class="comment"></span>*/
<a name="l00382"></a>00382 <span class="comment">//</span>
<a name="l00383"></a>00383 <span class="comment">//</span>
<a name="l00384"></a>00384 <span class="comment">//</span>
<a name="l00385"></a>00385 <span class="comment">//</span>
<a name="l00386"></a>00386 <span class="comment">//</span>
<a name="l00387"></a>00387 <span class="comment">//</span>
<a name="l00388"></a>00388 <span class="comment">//</span><span class="comment"></span>
<a name="l00389"></a>00389 <span class="comment">//! Constructeur par copie. On alloue une nouvelle zone de memoire&lt;br&gt;et on copie le contenu du tableau (il s&#39;agit d&#39;un &quot;deep copy&quot;).&lt;br&gt;L&#39;attribut smart_resize_ est copie aussi.&lt;br&gt;Si le tableau A est de taille nulle, on cree un tableau &quot;detache&quot;,&lt;br&gt;sinon on cree un tableau &quot;normal&quot;.&lt;br&gt;Parametre: const ArrOfDouble\&amp; A&lt;br&gt;Signification: le tableau a copier</span>
<a name="l00390"></a><a class="code" href="classArrOfDouble.html#a3cc20f7f8fe3bc9cd924e73838307887">00390</a> <span class="comment"></span><a class="code" href="classArrOfDouble.html#a8890dc9a68c33a7862e776f411adaa02" title="Constructeur par defaut: cree un tableau &quot;detache&quot;, soit p_==0, data_==0, size_array_==0, smart_resize_==0.">ArrOfDouble::ArrOfDouble</a>(<span class="keyword">const</span> <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a>&amp; A): <a class="code" href="classArray__base.html" title=": classe vide servant de base a tous les tableaux. (permet de passer un type generique quel que soit ...">Array_base</a>()
<a name="l00391"></a>00391 {
<a name="l00392"></a>00392   <span class="keyword">const</span> <span class="keywordtype">int</span> size = A.<a class="code" href="classArrOfDouble.html#a3c3b33bea0e88b87315c21ee94bee05f" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>();
<a name="l00393"></a>00393   <span class="keywordflow">if</span> (size &gt; 0)
<a name="l00394"></a>00394     {
<a name="l00395"></a>00395 <span class="comment">// Creation d&#39;un tableau &quot;normal&quot;</span>
<a name="l00396"></a>00396       <a class="code" href="classArrOfDouble.html#a9724d501cbca852e174ef0a7351698b1">storage_type_</a> = <a class="code" href="classArrOfDouble.html#aa6c9b9bbc6bc40ecd74d10411dc560dead35388f27e20e247aaeaf8797437d110">STANDARD</a>;
<a name="l00397"></a>00397       <a class="code" href="classArrOfDouble.html#a16cc4d79375188b7cb389fce2c920186">p_</a> = <span class="keyword">new</span> <a class="code" href="classVDoubledata.html" title="VDoubledata alloue une zone de memoire de la taille specifiee au constructeur, et libere la zone de m...">VDoubledata</a>(size, <a class="code" href="classArrOfDouble.html#aa6c9b9bbc6bc40ecd74d10411dc560dead35388f27e20e247aaeaf8797437d110">STANDARD</a>);
<a name="l00398"></a>00398       <a class="code" href="classArrOfDouble.html#a77419df7d43ac2ce76b9388a39ad90e9">data_</a> = <a class="code" href="classArrOfDouble.html#a16cc4d79375188b7cb389fce2c920186">p_</a>-&gt;<a class="code" href="classVDoubledata.html#a554af3f6bbf09270b1c4862de9654c17" title="renvoie data_">get_data</a>();
<a name="l00399"></a>00399       <a class="code" href="classArrOfDouble.html#ae201cdbdbf9f840376398199e5f737a0">size_array_</a> = size;
<a name="l00400"></a>00400       <a class="code" href="classArrOfDouble.html#a952e7436d209c8957ea0209f1fa66976">memory_size_</a> = size;
<a name="l00401"></a>00401       <a class="code" href="classArrOfDouble.html#a527b3aabfef167644bb124f8255245b3">smart_resize_</a> = A.<a class="code" href="classArrOfDouble.html#a527b3aabfef167644bb124f8255245b3">smart_resize_</a>;
<a name="l00402"></a>00402       <a class="code" href="classArrOfDouble.html#a2fcb2a2d3b59425c6cb37526ea6af6a3" title="Copie les elements source[first_element_source + i] dans les elements (*this)[first_element_dest + i]...">inject_array</a>(A);
<a name="l00403"></a>00403     }
<a name="l00404"></a>00404   <span class="keywordflow">else</span>
<a name="l00405"></a>00405     {
<a name="l00406"></a>00406 <span class="comment">// Creation d&#39;un tableau &quot;detache&quot;</span>
<a name="l00407"></a>00407       <a class="code" href="classArrOfDouble.html#a16cc4d79375188b7cb389fce2c920186">p_</a> = 0;
<a name="l00408"></a>00408       <a class="code" href="classArrOfDouble.html#a77419df7d43ac2ce76b9388a39ad90e9">data_</a> = 0;
<a name="l00409"></a>00409       <a class="code" href="classArrOfDouble.html#ae201cdbdbf9f840376398199e5f737a0">size_array_</a> = 0;
<a name="l00410"></a>00410       <a class="code" href="classArrOfDouble.html#a952e7436d209c8957ea0209f1fa66976">memory_size_</a> = 0;
<a name="l00411"></a>00411       <a class="code" href="classArrOfDouble.html#a527b3aabfef167644bb124f8255245b3">smart_resize_</a> = 0;
<a name="l00412"></a>00412       <a class="code" href="classArrOfDouble.html#a9724d501cbca852e174ef0a7351698b1">storage_type_</a> = <a class="code" href="classArrOfDouble.html#aa6c9b9bbc6bc40ecd74d10411dc560dead35388f27e20e247aaeaf8797437d110">STANDARD</a>;
<a name="l00413"></a>00413     }
<a name="l00414"></a>00414 }
<a name="l00415"></a>00415 
<a name="l00416"></a>00416 <span class="comment">//</span>
<a name="l00417"></a>00417 <span class="comment">//</span>
<a name="l00418"></a>00418 <span class="comment">//</span>
<a name="l00419"></a>00419 <span class="comment">//</span>
<a name="l00420"></a>00420 <span class="comment">//</span>
<a name="l00421"></a>00421 <span class="comment">//</span><span class="comment"></span>
<a name="l00422"></a>00422 <span class="comment">//! Change le mode d&#39;allocation memoire lors des resize&lt;br&gt;(voir VDoubledata et Double_ptr_trav)&lt;br&gt;Exemple pour creer un tableau avec allocation temporaire:&lt;br&gt;DoubleTab tab; // Creation d&#39;un tableau vide&lt;br&gt;tab.set_mem_storage(TEMP_STORAGE); // Changement de mode d&#39;allocation&lt;br&gt;tab.resize(n); // Allocation memoire</span>
<a name="l00423"></a><a class="code" href="classArrOfDouble.html#a716c70fbed9c253e2deb5732c9f0601b">00423</a> <span class="comment"></span><span class="keywordtype">void</span> <a class="code" href="classArrOfDouble.html#a716c70fbed9c253e2deb5732c9f0601b" title="Change le mode d&#39;allocation memoire lors des resize&lt;br&gt;(voir VDoubledata et Double_ptr_trav) Exemple po...">ArrOfDouble::set_mem_storage</a>(<span class="keyword">const</span> <a class="code" href="classArrOfDouble.html#aa6c9b9bbc6bc40ecd74d10411dc560de">Storage</a> storage)
<a name="l00424"></a>00424 {
<a name="l00425"></a>00425   <a class="code" href="classArrOfDouble.html#a9724d501cbca852e174ef0a7351698b1">storage_type_</a> = storage;
<a name="l00426"></a>00426 }
<a name="l00427"></a>00427 
<a name="l00428"></a>00428 <span class="comment">//</span>
<a name="l00429"></a>00429 <span class="comment">//</span>
<a name="l00430"></a>00430 <span class="comment">//</span><span class="comment"></span>
<a name="l00431"></a>00431 <span class="comment">//! Renvoie le mode d&#39;allocation du tableau (qui sera utilise&lt;br&gt;lors du prochain resize si changement de taille).&lt;br&gt;(voir VDoubledata et Double_ptr_trav)</span>
<a name="l00432"></a><a class="code" href="classArrOfDouble.html#a2b905fb71100ad2c00ada973435d3cea">00432</a> <span class="comment"></span><span class="keyword">enum</span> <a class="code" href="classArrOfDouble.html#aa6c9b9bbc6bc40ecd74d10411dc560de">ArrOfDouble::Storage</a> <a class="code" href="classArrOfDouble.html#a2b905fb71100ad2c00ada973435d3cea" title="Renvoie le mode d&#39;allocation du tableau (qui sera utilise lors du prochain resize si changement de ta...">ArrOfDouble::get_mem_storage</a>()<span class="keyword"> const</span>
<a name="l00433"></a>00433 <span class="keyword"></span>{
<a name="l00434"></a>00434   <span class="keywordflow">return</span> <a class="code" href="classArrOfDouble.html#a9724d501cbca852e174ef0a7351698b1">storage_type_</a>;
<a name="l00435"></a>00435 }
<a name="l00436"></a>00436 
<a name="l00437"></a>00437 <span class="comment">//</span>
<a name="l00438"></a>00438 <span class="comment">//</span>
<a name="l00439"></a>00439 <span class="comment">//</span>
<a name="l00440"></a>00440 <span class="comment">//</span><span class="comment"></span>
<a name="l00441"></a>00441 <span class="comment">//! Change le mode l&#39;allocation memoire: reallocation d&#39;un tableau&lt;br&gt;a chaque changement de taille (flag = 0) ou reallocation&lt;br&gt;uniquement si la taille augmente et par doublement de la taille&lt;br&gt;du tableau (flag = 1).</span>
<a name="l00442"></a><a class="code" href="classArrOfDouble.html#ab49f6cae96be9d3f597468d8a53b67b6">00442</a> <span class="comment"></span><span class="keywordtype">void</span> <a class="code" href="classArrOfDouble.html#ab49f6cae96be9d3f597468d8a53b67b6" title="Change le mode l&#39;allocation memoire: reallocation d&#39;un tableau a chaque changement de taille (flag = ...">ArrOfDouble::set_smart_resize</a>(<span class="keywordtype">int</span> flag)
<a name="l00443"></a>00443 {
<a name="l00444"></a>00444   assert(flag == 0 || flag == 1);
<a name="l00445"></a>00445   <a class="code" href="classArrOfDouble.html#a527b3aabfef167644bb124f8255245b3">smart_resize_</a> = flag;
<a name="l00446"></a>00446 }
<a name="l00447"></a>00447 
<a name="l00448"></a>00448 <span class="comment">//</span>
<a name="l00449"></a>00449 <span class="comment">//</span><span class="comment"></span>
<a name="l00450"></a>00450 <span class="comment">//! Remet le tableau dans l&#39;etat obtenu avec le constructeur par defaut&lt;br&gt;(libere la memoire mais conserve le mode d&#39;allocation memoire actuel)</span>
<a name="l00451"></a><a class="code" href="classArrOfDouble.html#a8c937710d2664d65500f24ce5f7e0ce0">00451</a> <span class="comment"></span><span class="keywordtype">void</span> <a class="code" href="classArrOfDouble.html#a8c937710d2664d65500f24ce5f7e0ce0" title="Remet le tableau dans l&#39;etat obtenu avec le constructeur par defaut (libere la memoire mais conserve ...">ArrOfDouble::reset</a>()
<a name="l00452"></a>00452 {
<a name="l00453"></a>00453   <a class="code" href="classArrOfDouble.html#a30d7509eec18c3ef46cc0140bdcdc48f" title="Amene le tableau dans l&#39;etat &quot;detache&quot;. C&#39;est a dire: Si le tableau est &quot;detache&quot; : * ne rien faire...">detach_array</a>();
<a name="l00454"></a>00454 }
<a name="l00455"></a>00455 
<a name="l00456"></a>00456 <span class="comment">// Precondition:</span>
<a name="l00457"></a>00457 <span class="comment">// preconditions identiques a resize_array()</span>
<a name="l00458"></a>00458 <span class="comment">// Parametre: const ArrOfDouble&amp; m</span>
<a name="l00459"></a>00459 <span class="comment">// Signification: la tableau a copier</span>
<a name="l00460"></a>00460 <span class="comment">//</span>
<a name="l00461"></a>00461 <span class="comment">//</span>
<a name="l00462"></a>00462 <span class="comment">//</span>
<a name="l00463"></a>00463 <span class="comment">//</span><span class="comment"></span>
<a name="l00464"></a>00464 <span class="comment">//! Copie les donnees du tableau m.&lt;br&gt;Si &quot;m&quot; n&#39;a pas la meme taille que &quot;*this&quot;, on fait un resize_array.&lt;br&gt;Ensuite, on copie les valeurs de &quot;m&quot; dans &quot;*this&quot;.&lt;br&gt;Le type de tableau (methode d&#39;allocation) n&#39;est pas copie.</span>
<a name="l00465"></a>00465 <span class="comment"></span><span class="comment">/** \return ArrOfDouble\&amp;&lt;br&gt;</span>
<a name="l00466"></a>00466 <span class="comment">Signification: *this */</span>
<a name="l00467"></a><a class="code" href="classArrOfDouble.html#a433dc3b67b6d6e70f7dda611e67c45ac">00467</a> <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a>&amp; <a class="code" href="classArrOfDouble.html#a433dc3b67b6d6e70f7dda611e67c45ac" title="Copie les donnees du tableau m. Si &quot;m&quot; n&#39;a pas la meme taille que &quot;*this&quot;, on fait un resize_arra...">ArrOfDouble::operator=</a>(<span class="keyword">const</span> <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a>&amp; m)
<a name="l00468"></a>00468 {
<a name="l00469"></a>00469   <span class="keywordflow">if</span> (&amp;m != <span class="keyword">this</span>)
<a name="l00470"></a>00470     {
<a name="l00471"></a>00471       <span class="keyword">const</span> <span class="keywordtype">int</span> new_size = m.<a class="code" href="classArrOfDouble.html#a3c3b33bea0e88b87315c21ee94bee05f" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>();
<a name="l00472"></a>00472 <span class="comment">// On utilise la methode resize_array() qui teste le type derive de l&#39;objet</span>
<a name="l00473"></a>00473 <span class="comment">// (resize interdit sur un type derive)</span>
<a name="l00474"></a>00474       <a class="code" href="classArrOfDouble.html#a610464f4b3dccac6f814915b526783ed">resize_array</a>(new_size, <a class="code" href="classArray__base.html#abee342aa9ac59623c4c782dc9d7877ffaf6ae9ba7eb51c5f298ce693345b3ec68">NOCOPY_NOINIT</a>);
<a name="l00475"></a>00475       <a class="code" href="classArrOfDouble.html#a2fcb2a2d3b59425c6cb37526ea6af6a3" title="Copie les elements source[first_element_source + i] dans les elements (*this)[first_element_dest + i]...">inject_array</a>(m);
<a name="l00476"></a>00476     }
<a name="l00477"></a>00477   <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00478"></a>00478 }
<a name="l00479"></a>00479 <span class="comment">/*</span>
<a name="l00480"></a>00480 <span class="comment">// Description:</span>
<a name="l00481"></a>00481 <span class="comment">//   Affectation d&#39;un tableau de type FArrOfDouble</span>
<a name="l00482"></a>00482 <span class="comment">//   (tableau stocke sur disque).</span>
<a name="l00483"></a>00483 <span class="comment">// Precondition:</span>
<a name="l00484"></a>00484 <span class="comment">//   Identiques a resize_array()</span>
<a name="l00485"></a>00485 <span class="comment">// Parametre: const FArrOfDouble&amp; A</span>
<a name="l00486"></a>00486 <span class="comment">//    Signification: le tableau a copier</span>
<a name="l00487"></a>00487 <span class="comment">ArrOfDouble&amp; ArrOfDouble::operator=(const FArrOfDouble&amp; m)</span>
<a name="l00488"></a>00488 <span class="comment">{</span>
<a name="l00489"></a>00489 <span class="comment">  const int new_size = m.size_array();</span>
<a name="l00490"></a>00490 <span class="comment">  resize_array(new_size, NOCOPY_NOINIT);</span>
<a name="l00491"></a>00491 <span class="comment">  double * data = data_;</span>
<a name="l00492"></a>00492 <span class="comment">  for(int i=0; i&lt;new_size; i++)</span>
<a name="l00493"></a>00493 <span class="comment">    data[i] = m[i];</span>
<a name="l00494"></a>00494 <span class="comment"></span>
<a name="l00495"></a>00495 <span class="comment">  return *this;</span>
<a name="l00496"></a>00496 <span class="comment">}</span>
<a name="l00497"></a>00497 <span class="comment">*/</span>
<a name="l00498"></a>00498 <span class="comment"></span>
<a name="l00499"></a>00499 <span class="comment">//! appelle operator=(a)</span>
<a name="l00500"></a><a class="code" href="classArrOfDouble.html#a89ba688c107e2f6089501983dfa051b0">00500</a> <span class="comment"></span><a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a>&amp; <a class="code" href="classArrOfDouble.html#a89ba688c107e2f6089501983dfa051b0" title="appelle operator=(a)">ArrOfDouble::copy_array</a>(<span class="keyword">const</span> <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a>&amp; a)
<a name="l00501"></a>00501 {
<a name="l00502"></a>00502   <a class="code" href="classArrOfDouble.html#a433dc3b67b6d6e70f7dda611e67c45ac" title="Copie les donnees du tableau m. Si &quot;m&quot; n&#39;a pas la meme taille que &quot;*this&quot;, on fait un resize_arra...">operator=</a>(a);
<a name="l00503"></a>00503   <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00504"></a>00504 }
<a name="l00505"></a>00505 
<a name="l00506"></a>00506 <span class="comment">//</span>
<a name="l00507"></a>00507 <span class="comment">//</span>
<a name="l00508"></a>00508 <span class="comment">//</span>
<a name="l00509"></a>00509 <span class="comment">//</span>
<a name="l00510"></a>00510 <span class="comment">//</span><span class="comment"></span>
<a name="l00511"></a>00511 <span class="comment">//! methode virtuelle identique a resize_array(), permet de traiter&lt;br&gt;de facon generique les ArrOf, Vect et Tab.&lt;br&gt;Si l&#39;objet est de type ArrOfDouble, appel a resize_array(n)&lt;br&gt;Prerequis: le tableau doit etre &quot;resizable&quot; (voir resize_array()).&lt;br&gt;S&#39;il est d&#39;un type derive (Vect ou Tab), il ne doit pas avoir de descripteur&lt;br&gt;parallele si la taille est effectivement modifiee.</span>
<a name="l00512"></a><a class="code" href="classArrOfDouble.html#a03c0eaca0e960a1f59cc077deb9fd4b2">00512</a> <span class="comment"></span><span class="keywordtype">void</span> <a class="code" href="classArrOfDouble.html#a03c0eaca0e960a1f59cc077deb9fd4b2" title="methode virtuelle identique a resize_array(), permet de traiter de facon generique les ArrOf...">ArrOfDouble::resize_tab</a>(<span class="keywordtype">int</span> n, <a class="code" href="classArray__base.html#abee342aa9ac59623c4c782dc9d7877ff">Array_base::Resize_Options</a> opt)
<a name="l00513"></a>00513 {
<a name="l00514"></a>00514   <a class="code" href="classArrOfDouble.html#a610464f4b3dccac6f814915b526783ed">resize_array</a>(n, opt);
<a name="l00515"></a>00515 }
<a name="l00516"></a>00516 
<a name="l00517"></a>00517 <span class="comment">// Precondition:</span>
<a name="l00518"></a>00518 <span class="comment">// Le tableau doit etre de type &quot;detache&quot; ou &quot;normal&quot; avec</span>
<a name="l00519"></a>00519 <span class="comment">// ref_count==1, et il faut new_size &gt;= 0</span>
<a name="l00520"></a>00520 <span class="comment">// On suppose que size_array contient encore le nombre d&#39;elements</span>
<a name="l00521"></a>00521 <span class="comment">// valides avant changement de taille.</span>
<a name="l00522"></a>00522 <span class="comment">// Parametre: new_size</span>
<a name="l00523"></a>00523 <span class="comment">// Signification: nouvelle taille demandee pour le tableau.</span>
<a name="l00524"></a>00524 <span class="comment">// Parametre: options</span>
<a name="l00525"></a>00525 <span class="comment">// Signification: voir ArrOfDouble::Resize_Options</span>
<a name="l00526"></a>00526 <span class="comment">// Postcondition:</span>
<a name="l00527"></a>00527 <span class="comment">// p_ et data_ sont mis a jour, mais pas size_array_ !!!</span>
<a name="l00528"></a>00528 <span class="comment">// (on suppose que c&#39;est fait dans resize_array()).</span>
<a name="l00529"></a>00529 <span class="comment">// Si la nouvelle taille est nulle, on detache le tableau.</span>
<a name="l00530"></a>00530 <span class="comment">//</span>
<a name="l00531"></a>00531 <span class="comment">//</span>
<a name="l00532"></a>00532 <span class="comment">//</span>
<a name="l00533"></a>00533 <span class="comment">//</span>
<a name="l00534"></a>00534 <span class="comment">//</span>
<a name="l00535"></a>00535 <span class="comment">//</span>
<a name="l00536"></a>00536 <span class="comment">//</span>
<a name="l00537"></a>00537 <span class="comment">//</span>
<a name="l00538"></a>00538 <span class="comment">//</span>
<a name="l00539"></a>00539 <span class="comment">//</span><span class="comment"></span>
<a name="l00540"></a>00540 <span class="comment">//! Si besoin, alloue une nouvelle zone de memoire,&lt;br&gt;copie les donnees et efface l&#39;ancienne zone de memoire.&lt;br&gt;Attention, on suppose que cette methode est appelee par&lt;br&gt;resize_array().&lt;br&gt;Attention: si ref_count_&gt;1, l&#39;appel a resize_array() est&lt;br&gt;autorise uniquement si la nouvelle taille est identique&lt;br&gt;a la precedente (auquel cas on ne fait rien)&lt;br&gt;Si ref_count_ == 1, l&#39;appel est invalide si p_-&gt;data_ est&lt;br&gt;different de data_ (le tableau a ete construit avec ref_array()&lt;br&gt;avec start &gt; 0)</span>
<a name="l00541"></a><a class="code" href="classArrOfDouble.html#a98d8a5b5486b130787f95664ee8127e6">00541</a> <span class="comment"></span><span class="keywordtype">void</span>  <a class="code" href="classArrOfDouble.html#a98d8a5b5486b130787f95664ee8127e6" title="Si besoin, alloue une nouvelle zone de memoire, copie les donnees et efface l&#39;ancienne zone de memoir...">ArrOfDouble::memory_resize</a>(<span class="keywordtype">int</span> new_size, <a class="code" href="classArray__base.html#abee342aa9ac59623c4c782dc9d7877ff">Array_base::Resize_Options</a> opt)
<a name="l00542"></a>00542 {
<a name="l00543"></a>00543   assert(new_size &gt;= 0);
<a name="l00544"></a>00544 
<a name="l00545"></a>00545 <span class="comment">// Si new_size==size_array_, on ne fait rien, c&#39;est toujours autorise</span>
<a name="l00546"></a>00546   <span class="keywordflow">if</span> (new_size == <a class="code" href="classArrOfDouble.html#ae201cdbdbf9f840376398199e5f737a0">size_array_</a>)
<a name="l00547"></a>00547     <span class="keywordflow">return</span>;
<a name="l00548"></a>00548 
<a name="l00549"></a>00549 <span class="comment">// Sinon, il faut que le resize soit autorise, c&#39;est a dire</span>
<a name="l00550"></a>00550 <span class="comment">// - soit le tableau est detache</span>
<a name="l00551"></a>00551 <span class="comment">// - soit le tableau est normal et il n&#39;y a pas d&#39;autre reference au tableau</span>
<a name="l00552"></a>00552   assert((<a class="code" href="classArrOfDouble.html#a77419df7d43ac2ce76b9388a39ad90e9">data_</a> == 0) || ((<a class="code" href="classArrOfDouble.html#a16cc4d79375188b7cb389fce2c920186">p_</a> != 0) &amp;&amp; (<a class="code" href="classArrOfDouble.html#a16cc4d79375188b7cb389fce2c920186">p_</a>-&gt;<a class="code" href="classVDoubledata.html#a554af3f6bbf09270b1c4862de9654c17" title="renvoie data_">get_data</a>() == <a class="code" href="classArrOfDouble.html#a77419df7d43ac2ce76b9388a39ad90e9">data_</a>) &amp;&amp; (<a class="code" href="classArrOfDouble.html#a324a6714dc9d9a7b5997fda646d24974" title="Retourne le nombre de references des donnees du tableau si le tableau est &quot;normal&quot;, -1 s&#39;il est &quot;detache&quot; ou &quot;ref_data&quot;.">ref_count</a>() == 1)));
<a name="l00553"></a>00553 
<a name="l00554"></a>00554 <span class="comment">// Occupation memoire de l&#39;ancien tableau:</span>
<a name="l00555"></a>00555   <span class="keywordtype">int</span> old_mem_size = <a class="code" href="classArrOfDouble.html#a952e7436d209c8957ea0209f1fa66976">memory_size_</a>;
<a name="l00556"></a>00556   assert((!<a class="code" href="classArrOfDouble.html#a16cc4d79375188b7cb389fce2c920186">p_</a>) || (<a class="code" href="classArrOfDouble.html#a16cc4d79375188b7cb389fce2c920186">p_</a>-&gt;<a class="code" href="classVDoubledata.html#aa4024084623369d62bfc24a70fdec663" title="renvoie size_">get_size</a>() == <a class="code" href="classArrOfDouble.html#a952e7436d209c8957ea0209f1fa66976">memory_size_</a>));
<a name="l00557"></a>00557   assert(<a class="code" href="classArrOfDouble.html#a952e7436d209c8957ea0209f1fa66976">memory_size_</a> &gt;= <a class="code" href="classArrOfDouble.html#ae201cdbdbf9f840376398199e5f737a0">size_array_</a>);
<a name="l00558"></a>00558 
<a name="l00559"></a>00559 <span class="comment">// Occupation memoire du nouveau tableau :</span>
<a name="l00560"></a>00560 <span class="comment">// Si smart_resize, on prend au moins deux fois la taille</span>
<a name="l00561"></a>00561 <span class="comment">// precedente, ou new_size</span>
<a name="l00562"></a>00562   <span class="keywordtype">int</span> new_mem_size = new_size;
<a name="l00563"></a>00563   <span class="keywordflow">if</span> (<a class="code" href="classArrOfDouble.html#a527b3aabfef167644bb124f8255245b3">smart_resize_</a>)
<a name="l00564"></a>00564     {
<a name="l00565"></a>00565       <span class="keywordflow">if</span> (new_size &lt;= old_mem_size)
<a name="l00566"></a>00566         new_mem_size = old_mem_size;
<a name="l00567"></a>00567       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (new_size &lt; old_mem_size * 2)
<a name="l00568"></a>00568         new_mem_size = old_mem_size * 2;
<a name="l00569"></a>00569       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (new_size &gt; old_mem_size &amp;&amp; old_mem_size &gt; INT_MAX / 2)
<a name="l00570"></a>00570         new_mem_size = INT_MAX;
<a name="l00571"></a>00571     }
<a name="l00572"></a>00572 
<a name="l00573"></a>00573   <span class="keywordflow">if</span> (new_mem_size != old_mem_size)
<a name="l00574"></a>00574     {
<a name="l00575"></a>00575 <span class="comment">// detach_array() efface le contenu de size_array_. On le met de cote:</span>
<a name="l00576"></a>00576       <span class="keyword">const</span> <span class="keywordtype">int</span> old_size_array = <a class="code" href="classArrOfDouble.html#ae201cdbdbf9f840376398199e5f737a0">size_array_</a>;
<a name="l00577"></a>00577       <span class="keywordflow">if</span> (new_mem_size == 0)
<a name="l00578"></a>00578         {
<a name="l00579"></a>00579 <span class="comment">// La nouvelle taille est nulle, on cree un tableau &quot;detache&quot;</span>
<a name="l00580"></a>00580           <a class="code" href="classArrOfDouble.html#a30d7509eec18c3ef46cc0140bdcdc48f" title="Amene le tableau dans l&#39;etat &quot;detache&quot;. C&#39;est a dire: Si le tableau est &quot;detache&quot; : * ne rien faire...">detach_array</a>();
<a name="l00581"></a>00581         }
<a name="l00582"></a>00582       <span class="keywordflow">else</span>
<a name="l00583"></a>00583         {
<a name="l00584"></a>00584 <span class="comment">// Allocation d&#39;une nouvelle zone</span>
<a name="l00585"></a>00585           <a class="code" href="classVDoubledata.html" title="VDoubledata alloue une zone de memoire de la taille specifiee au constructeur, et libere la zone de m...">VDoubledata</a> * new_p = <span class="keyword">new</span> <a class="code" href="classVDoubledata.html" title="VDoubledata alloue une zone de memoire de la taille specifiee au constructeur, et libere la zone de m...">VDoubledata</a>(new_mem_size, <a class="code" href="classArrOfDouble.html#a9724d501cbca852e174ef0a7351698b1">storage_type_</a>);
<a name="l00586"></a>00586           <span class="keywordtype">double</span> * new_data = new_p-&gt;<a class="code" href="classVDoubledata.html#a554af3f6bbf09270b1c4862de9654c17" title="renvoie data_">get_data</a>();
<a name="l00587"></a>00587 <span class="comment">// Raccourci si le tableau etait &quot;detache&quot;, inutile de copier</span>
<a name="l00588"></a>00588 <span class="comment">// les anciennes donnees. On copie si COPY_OLD est demande</span>
<a name="l00589"></a>00589           <span class="keywordtype">int</span> copy_size = 0;
<a name="l00590"></a>00590           <span class="keywordflow">if</span> (<a class="code" href="classArrOfDouble.html#a77419df7d43ac2ce76b9388a39ad90e9">data_</a> != 0)
<a name="l00591"></a>00591             {
<a name="l00592"></a>00592 <span class="comment">// Calcul du nombre d&#39;elements a copier vers la nouvelle</span>
<a name="l00593"></a>00593 <span class="comment">// zone de memoire : c&#39;est le min de l&#39;ancienne et de</span>
<a name="l00594"></a>00594 <span class="comment">// la nouvelle taille.</span>
<a name="l00595"></a>00595               <span class="keywordflow">if</span> (opt != <a class="code" href="classArray__base.html#abee342aa9ac59623c4c782dc9d7877ffaf6ae9ba7eb51c5f298ce693345b3ec68">NOCOPY_NOINIT</a>)
<a name="l00596"></a>00596                 {
<a name="l00597"></a>00597                   copy_size = <a class="code" href="classArrOfDouble.html#ae201cdbdbf9f840376398199e5f737a0">size_array_</a>;
<a name="l00598"></a>00598                   <span class="keywordflow">if</span> (new_size &lt; copy_size)
<a name="l00599"></a>00599                     copy_size = new_size;
<a name="l00600"></a>00600 <span class="comment">// Copie des valeurs dans le nouveau tableau</span>
<a name="l00601"></a>00601                   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; copy_size; i++)
<a name="l00602"></a>00602                     new_data[i] = <a class="code" href="classArrOfDouble.html#a77419df7d43ac2ce76b9388a39ad90e9">data_</a>[i];
<a name="l00603"></a>00603                 }
<a name="l00604"></a>00604 <span class="comment">// Destruction de l&#39;ancienne zone (si plus aucune reference)</span>
<a name="l00605"></a>00605               <a class="code" href="classArrOfDouble.html#a30d7509eec18c3ef46cc0140bdcdc48f" title="Amene le tableau dans l&#39;etat &quot;detache&quot;. C&#39;est a dire: Si le tableau est &quot;detache&quot; : * ne rien faire...">detach_array</a>();
<a name="l00606"></a>00606             }
<a name="l00607"></a>00607 <span class="comment">// On attache la nouvelle zone de memoire</span>
<a name="l00608"></a>00608           <a class="code" href="classArrOfDouble.html#a16cc4d79375188b7cb389fce2c920186">p_</a> = new_p;
<a name="l00609"></a>00609           <a class="code" href="classArrOfDouble.html#a77419df7d43ac2ce76b9388a39ad90e9">data_</a> = new_data;
<a name="l00610"></a>00610           <a class="code" href="classArrOfDouble.html#a952e7436d209c8957ea0209f1fa66976">memory_size_</a> = new_mem_size;
<a name="l00611"></a>00611 <span class="comment">// Initialisation des cases supplementaires avec une valeur par defaut</span>
<a name="l00612"></a>00612           <a class="code" href="classArrOfDouble.html#a67d30f4f02d7656362fce21d8e0e9745" title="Remplit &quot;nb&quot; cases consecutives du tableau a partir de la case &quot;first&quot; avec une valeur par defaut...">fill_default_value</a>(opt, copy_size, new_mem_size - copy_size);
<a name="l00613"></a>00613 <span class="comment">// Restaure l&#39;ancienne valeur de size_array_</span>
<a name="l00614"></a>00614           <a class="code" href="classArrOfDouble.html#ae201cdbdbf9f840376398199e5f737a0">size_array_</a> = old_size_array;
<a name="l00615"></a>00615         }
<a name="l00616"></a>00616     }
<a name="l00617"></a>00617   <span class="keywordflow">else</span>
<a name="l00618"></a>00618     {
<a name="l00619"></a>00619 <span class="comment">// Pas de reallocation, initialisation si besoin</span>
<a name="l00620"></a>00620       <span class="keywordflow">if</span> (opt == <a class="code" href="classArray__base.html#abee342aa9ac59623c4c782dc9d7877ffa9a675e25b5b7accff8d861e05060547b">COPY_INIT</a> &amp;&amp; new_size &gt; <a class="code" href="classArrOfDouble.html#ae201cdbdbf9f840376398199e5f737a0">size_array_</a>)
<a name="l00621"></a>00621         {
<a name="l00622"></a>00622           <a class="code" href="classArrOfDouble.html#a67d30f4f02d7656362fce21d8e0e9745" title="Remplit &quot;nb&quot; cases consecutives du tableau a partir de la case &quot;first&quot; avec une valeur par defaut...">fill_default_value</a>(opt, <a class="code" href="classArrOfDouble.html#ae201cdbdbf9f840376398199e5f737a0">size_array_</a>, new_size - <a class="code" href="classArrOfDouble.html#ae201cdbdbf9f840376398199e5f737a0">size_array_</a>);
<a name="l00623"></a>00623         }
<a name="l00624"></a>00624     }
<a name="l00625"></a>00625 }
<a name="l00626"></a>00626 
<a name="l00627"></a>00627 <span class="comment">//</span>
<a name="l00628"></a>00628 <span class="comment">//</span>
<a name="l00629"></a>00629 <span class="comment">//</span>
<a name="l00630"></a>00630 <span class="comment">//</span>
<a name="l00631"></a>00631 <span class="comment">//</span>
<a name="l00632"></a>00632 <span class="comment">//</span>
<a name="l00633"></a>00633 <span class="comment">//</span>
<a name="l00634"></a>00634 <span class="comment">//</span>
<a name="l00635"></a>00635 <span class="comment">//</span>
<a name="l00636"></a>00636 <span class="comment">//</span>
<a name="l00637"></a>00637 <span class="comment">//</span>
<a name="l00638"></a>00638 <span class="comment">//</span>
<a name="l00639"></a>00639 <span class="comment">//</span>
<a name="l00640"></a>00640 <span class="comment">//</span>
<a name="l00641"></a>00641 <span class="comment">//</span>
<a name="l00642"></a>00642 <span class="comment">//</span>
<a name="l00643"></a>00643 <span class="comment">//</span>
<a name="l00644"></a>00644 <span class="comment">//</span>
<a name="l00645"></a>00645 <span class="comment">//</span>
<a name="l00646"></a>00646 <span class="comment">//</span>
<a name="l00647"></a>00647 <span class="comment">//</span>
<a name="l00648"></a>00648 <span class="comment">//</span><span class="comment"></span>
<a name="l00649"></a>00649 <span class="comment">//! Remplit &quot;nb&quot; cases consecutives du tableau a partir de la case &quot;first&quot;&lt;br&gt;avec une valeur par defaut.&lt;br&gt;Cette fonction est appelee lors d&#39;un resize pour initialiser les&lt;br&gt;cases nouvellement creees.&lt;br&gt;Le comportement depend actuellement du type de tableau :&lt;br&gt;* Tableau de type &quot;smart_resize&quot;:&lt;br&gt;* en mode debug (macro NDEBUG non definie) le tableau est initialise&lt;br&gt;avec une valeur invalide.&lt;br&gt;* en optimise, le tableau n&#39;est pas initialise&lt;br&gt;* Tableau normal :&lt;br&gt;Le tableau est initialise avec la valeur 0. Ce comportement est choisi&lt;br&gt;pour des raisons de compatibilite avec l&#39;implementation precedente.&lt;br&gt;Cette specification pourrait etre modifiee prochainement pour des raisons&lt;br&gt;de performances (pour ne pas avoir a initialiser inutilement les tableaux).&lt;br&gt;DONC: il faut supposer desormais que les nouvelles cases ne sont pas&lt;br&gt;initialisees lors d&#39;un resize.&lt;br&gt;Parametre: first&lt;br&gt;Signification: premiere case a initialiser.&lt;br&gt;Contrainte:    (nb==0) ou (0 &lt;= first &lt; memory_size_)&lt;br&gt;Parametre: nb&lt;br&gt;Signification: nombre de cases a initialiser.&lt;br&gt;Contrainte:    (nb==0) ou (0 &lt; nb &lt;= memory_size_ - first)</span>
<a name="l00650"></a><a class="code" href="classArrOfDouble.html#a67d30f4f02d7656362fce21d8e0e9745">00650</a> <span class="comment"></span><span class="keywordtype">void</span>  <a class="code" href="classArrOfDouble.html#a67d30f4f02d7656362fce21d8e0e9745" title="Remplit &quot;nb&quot; cases consecutives du tableau a partir de la case &quot;first&quot; avec une valeur par defaut...">ArrOfDouble::fill_default_value</a>(<a class="code" href="classArray__base.html#abee342aa9ac59623c4c782dc9d7877ff">Array_base::Resize_Options</a> opt, <span class="keywordtype">int</span> first, <span class="keywordtype">int</span> nb)
<a name="l00651"></a>00651 {
<a name="l00652"></a>00652   assert((nb == 0) || (first &gt;= 0 &amp;&amp; first &lt; <a class="code" href="classArrOfDouble.html#a952e7436d209c8957ea0209f1fa66976">memory_size_</a>));
<a name="l00653"></a>00653   assert((nb == 0) || (nb &gt; 0 &amp;&amp; nb &lt;= <a class="code" href="classArrOfDouble.html#a952e7436d209c8957ea0209f1fa66976">memory_size_</a> - first));
<a name="l00654"></a>00654   <span class="keywordtype">double</span> * data = <a class="code" href="classArrOfDouble.html#a77419df7d43ac2ce76b9388a39ad90e9">data_</a>;
<a name="l00655"></a>00655   assert(data!=0 || nb==0);
<a name="l00656"></a>00656   data += first;
<a name="l00657"></a>00657   <span class="keywordflow">if</span> (opt != <a class="code" href="classArray__base.html#abee342aa9ac59623c4c782dc9d7877ffa9a675e25b5b7accff8d861e05060547b">COPY_INIT</a>)
<a name="l00658"></a>00658     {
<a name="l00659"></a>00659 <span class="comment">// On initialise uniquement en mode debug</span>
<a name="l00660"></a>00660 <span class="preprocessor">#ifndef NDEBUG</span>
<a name="l00661"></a>00661 <span class="preprocessor"></span><span class="comment">// B.M. L&#39;utilisation de NAN n&#39;est pas possible car elle provoque une erreur</span>
<a name="l00662"></a>00662 <span class="comment">// dans double &amp; operator[] a cause de assert(...DMAXFLOAT). Du coup il est</span>
<a name="l00663"></a>00663 <span class="comment">// impossible de mettre une valeur dans le tableau autrement qu&#39;avec append_array()</span>
<a name="l00664"></a>00664 <span class="preprocessor">#if 0</span>
<a name="l00665"></a>00665 <span class="preprocessor"></span><span class="comment">// Ceci represente un NAN. N&#39;importe quelle operation avec ca fait encore un NAN.</span>
<a name="l00666"></a>00666 <span class="comment">// Si c&#39;est pas portable, on peut remplacer par DMAX_FLOAT sur les autres machines.</span>
<a name="l00667"></a>00667 <span class="comment">// Attention, il faut long long car sinon warning sur gcc 4.1 et i686</span>
<a name="l00668"></a>00668       <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> VALEUR_INVALIDE =
<a name="l00669"></a>00669         0x7ff7ffffffffffffULL;
<a name="l00670"></a>00670       <span class="comment">/* static const double VALEUR_INVALIDE = DMAXFLOAT;    */</span>
<a name="l00671"></a>00671 
<a name="l00672"></a>00672 <span class="comment">// On utilise &quot;memcpy&quot; et non &quot;=&quot; car &quot;=&quot; peut provoquer une exception</span>
<a name="l00673"></a>00673 <span class="comment">// si la copie passe par le fpu.</span>
<a name="l00674"></a>00674       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; nb; i++)
<a name="l00675"></a>00675         memcpy(data + i, &amp; VALEUR_INVALIDE, <span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));
<a name="l00676"></a>00676 <span class="preprocessor">#else</span>
<a name="l00677"></a>00677 <span class="preprocessor"></span><span class="comment">// Alternative acceptable... ?</span>
<a name="l00678"></a>00678       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; nb; i++)
<a name="l00679"></a>00679         data[i] = <a class="code" href="Double_8h.html#ae0ee0cebfad5968da0ad6cc7a49e16b6">DMAXFLOAT</a>*0.999;
<a name="l00680"></a>00680 <span class="preprocessor">#endif</span>
<a name="l00681"></a>00681 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00682"></a>00682 <span class="preprocessor"></span>    }
<a name="l00683"></a>00683   <span class="keywordflow">else</span>
<a name="l00684"></a>00684     {
<a name="l00685"></a>00685 <span class="comment">// Comportement pour les tableaux normaux : compatibilite avec la</span>
<a name="l00686"></a>00686 <span class="comment">// version precedente : on initialise avec 0.</span>
<a name="l00687"></a>00687       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; nb; i++)
<a name="l00688"></a>00688         data[i] = (<span class="keywordtype">double</span>) 0;
<a name="l00689"></a>00689     }
<a name="l00690"></a>00690 }
<a name="l00691"></a>00691 
<a name="l00692"></a>00692 <span class="comment">// ****************************************************************</span>
<a name="l00693"></a>00693 <span class="comment">// </span>
<a name="l00694"></a>00694 <span class="comment">// Fonctions non membres de la classe ArrOfDouble</span>
<a name="l00695"></a>00695 <span class="comment">// </span>
<a name="l00696"></a>00696 <span class="comment">// ****************************************************************</span>
<a name="l00697"></a>00697 
<a name="l00698"></a>00698 <span class="comment">//</span>
<a name="l00699"></a>00699 <span class="comment">//</span>
<a name="l00700"></a>00700 <span class="comment">//</span><span class="comment"></span>
<a name="l00701"></a>00701 <span class="comment">//! Renvoie 1 si les tableaux &quot;v&quot; et &quot;a&quot; sont de la meme taille&lt;br&gt;et contiennent les memes valeurs au sens strict, sinon renvoie 0.&lt;br&gt;Le test est !(v[i]!=a[i])</span>
<a name="l00702"></a><a class="code" href="ArrOfDouble_8h.html#a3ee62c0da2d3240d5693abbdd8adb24d">00702</a> <span class="comment"></span><span class="keywordtype">int</span> <a class="code" href="Ref__Champ__Face__CoviMAC_8cpp.html#a6f8a92408a5a8f1ef5479e7f3c4c63ec">operator==</a>(<span class="keyword">const</span> <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a>&amp; v, <span class="keyword">const</span> <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a>&amp; a)
<a name="l00703"></a>00703 {
<a name="l00704"></a>00704   <span class="keyword">const</span> <span class="keywordtype">int</span> n = v.<a class="code" href="classArrOfDouble.html#a3c3b33bea0e88b87315c21ee94bee05f" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>();
<a name="l00705"></a>00705   <span class="keyword">const</span> <span class="keywordtype">int</span> na = a.<a class="code" href="classArrOfDouble.html#a3c3b33bea0e88b87315c21ee94bee05f" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>();
<a name="l00706"></a>00706   <span class="keywordtype">int</span> resu = 1;
<a name="l00707"></a>00707   <span class="keywordflow">if</span> (n != na)
<a name="l00708"></a>00708     {
<a name="l00709"></a>00709       resu = 0;
<a name="l00710"></a>00710     }
<a name="l00711"></a>00711   <span class="keywordflow">else</span>
<a name="l00712"></a>00712     {
<a name="l00713"></a>00713       <span class="keyword">const</span> <span class="keywordtype">double</span>* vv = v.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
<a name="l00714"></a>00714       <span class="keyword">const</span> <span class="keywordtype">double</span>* av = a.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
<a name="l00715"></a>00715       <span class="keywordtype">int</span> i;
<a name="l00716"></a>00716       <span class="keywordflow">for</span> (i = 0; i &lt; n; i++)
<a name="l00717"></a>00717         {
<a name="l00718"></a>00718           <span class="keywordflow">if</span> (av[i] != vv[i])
<a name="l00719"></a>00719             {
<a name="l00720"></a>00720               resu = 0;
<a name="l00721"></a>00721               <span class="keywordflow">break</span>;
<a name="l00722"></a>00722             }
<a name="l00723"></a>00723         }
<a name="l00724"></a>00724     }
<a name="l00725"></a>00725   <span class="keywordflow">return</span> resu;
<a name="l00726"></a>00726 }
<a name="l00727"></a>00727 
<a name="l00728"></a>00728 <span class="comment">// Precondition:</span>
<a name="l00729"></a>00729 <span class="comment">// Parametre: const ArrOfDouble&amp; dx</span>
<a name="l00730"></a>00730 <span class="comment">// Signification: tableau a utiliser</span>
<a name="l00731"></a>00731 <span class="comment">//</span><span class="comment"></span>
<a name="l00732"></a>00732 <span class="comment">//! Retourne l&#39;indice du min ou -1 si le tableau est vide</span>
<a name="l00733"></a>00733 <span class="comment"></span><span class="comment">/** \return int&lt;br&gt;</span>
<a name="l00734"></a>00734 <span class="comment">Signification: indice du min */</span>
<a name="l00735"></a><a class="code" href="ArrOfDouble_8h.html#a31fd7878f6adc188f645d5552fc3d28c">00735</a> <span class="keywordtype">int</span> <a class="code" href="ArrOfDouble_8cpp.html#afe9f20f22a4feecff7412bbcd71cafea" title="Retourne l&#39;indice du min ou -1 si le tableau est vide.">imin_array</a>(<span class="keyword">const</span> <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a>&amp; dx)
<a name="l00736"></a>00736 {
<a name="l00737"></a>00737   <span class="keywordtype">int</span> indice_min = -1;
<a name="l00738"></a>00738   <span class="keyword">const</span> <span class="keywordtype">int</span> size = dx.<a class="code" href="classArrOfDouble.html#a3c3b33bea0e88b87315c21ee94bee05f" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>();
<a name="l00739"></a>00739   <span class="keywordflow">if</span> (size &gt; 0)
<a name="l00740"></a>00740     {
<a name="l00741"></a>00741       indice_min = 0;
<a name="l00742"></a>00742       <span class="keywordtype">double</span> valeur_min = dx[0];
<a name="l00743"></a>00743       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 1; i &lt; size; i++)
<a name="l00744"></a>00744         {
<a name="l00745"></a>00745           <span class="keyword">const</span> <span class="keywordtype">double</span> val = dx[i];
<a name="l00746"></a>00746           <span class="keywordflow">if</span>(val &lt; valeur_min)
<a name="l00747"></a>00747             {
<a name="l00748"></a>00748               indice_min = i;
<a name="l00749"></a>00749               valeur_min = val;
<a name="l00750"></a>00750             }
<a name="l00751"></a>00751         }
<a name="l00752"></a>00752     }
<a name="l00753"></a>00753   <span class="keywordflow">return</span> indice_min;
<a name="l00754"></a>00754 }
<a name="l00755"></a>00755 
<a name="l00756"></a>00756 <span class="comment">// Precondition:</span>
<a name="l00757"></a>00757 <span class="comment">// Parametre: const ArrOfDouble&amp; dx</span>
<a name="l00758"></a>00758 <span class="comment">// Signification: tableau a utiliser</span>
<a name="l00759"></a>00759 <span class="comment">//</span><span class="comment"></span>
<a name="l00760"></a>00760 <span class="comment">//! Retourne l&#39;indice du max ou -1 si le tableau est vide</span>
<a name="l00761"></a>00761 <span class="comment"></span><span class="comment">/** \return int&lt;br&gt;</span>
<a name="l00762"></a>00762 <span class="comment">Signification: indice du max */</span>
<a name="l00763"></a><a class="code" href="ArrOfDouble_8h.html#a886a745756981f679e1568ce3eea8288">00763</a> <span class="keywordtype">int</span> <a class="code" href="ArrOfDouble_8cpp.html#ace2773782c6cf82f52e226ca32314ae4" title="Retourne l&#39;indice du max ou -1 si le tableau est vide.">imax_array</a>(<span class="keyword">const</span> <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a>&amp; dx)
<a name="l00764"></a>00764 {
<a name="l00765"></a>00765   <span class="keywordtype">int</span> indice_max = -1;
<a name="l00766"></a>00766   <span class="keyword">const</span> <span class="keywordtype">int</span> size = dx.<a class="code" href="classArrOfDouble.html#a3c3b33bea0e88b87315c21ee94bee05f" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>();
<a name="l00767"></a>00767   <span class="keywordflow">if</span> (size &gt; 0)
<a name="l00768"></a>00768     {
<a name="l00769"></a>00769       indice_max = 0;
<a name="l00770"></a>00770       <span class="keywordtype">double</span> valeur_max = dx[0];
<a name="l00771"></a>00771       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 1; i &lt; size; i++)
<a name="l00772"></a>00772         {
<a name="l00773"></a>00773           <span class="keyword">const</span> <span class="keywordtype">double</span> val = dx[i];
<a name="l00774"></a>00774           <span class="keywordflow">if</span>(val &gt; valeur_max)
<a name="l00775"></a>00775             {
<a name="l00776"></a>00776               indice_max = i;
<a name="l00777"></a>00777               valeur_max = val;
<a name="l00778"></a>00778             }
<a name="l00779"></a>00779         }
<a name="l00780"></a>00780     }
<a name="l00781"></a>00781   <span class="keywordflow">return</span> indice_max;
<a name="l00782"></a>00782 }
<a name="l00783"></a>00783 
<a name="l00784"></a>00784 <span class="comment">// Precondition:</span>
<a name="l00785"></a>00785 <span class="comment">// Le tableau doit contenir au moins une valeur</span>
<a name="l00786"></a>00786 <span class="comment">// Parametre: const ArrOfDouble&amp; dx</span>
<a name="l00787"></a>00787 <span class="comment">// Signification: tableau a utiliser</span>
<a name="l00788"></a>00788 <span class="comment">//</span><span class="comment"></span>
<a name="l00789"></a>00789 <span class="comment">//! Retourne la valeur minimale</span>
<a name="l00790"></a>00790 <span class="comment"></span><span class="comment">/** \return double&lt;br&gt;</span>
<a name="l00791"></a>00791 <span class="comment">Signification: valeur du min */</span>
<a name="l00792"></a><a class="code" href="ArrOfDouble_8h.html#a646199b8d240909b3e8ef803af0a9a18">00792</a> <span class="keywordtype">double</span> <a class="code" href="ArrOfDouble_8cpp.html#abd3998749a1a8dab00dd6ac1798327fb" title="Retourne la valeur minimale.">min_array</a>(<span class="keyword">const</span> <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a>&amp; dx)
<a name="l00793"></a>00793 {
<a name="l00794"></a>00794   <span class="keyword">const</span> <span class="keywordtype">int</span> size = dx.<a class="code" href="classArrOfDouble.html#a3c3b33bea0e88b87315c21ee94bee05f" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>();
<a name="l00795"></a>00795   assert(size &gt; 0);
<a name="l00796"></a>00796   <span class="keywordtype">double</span> valeur_min = dx[0];
<a name="l00797"></a>00797   <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 1; i &lt; size; i++)
<a name="l00798"></a>00798     {
<a name="l00799"></a>00799       <span class="keyword">const</span> <span class="keywordtype">double</span> val = dx[i];
<a name="l00800"></a>00800       <span class="keywordflow">if</span> (val &lt; valeur_min)
<a name="l00801"></a>00801         valeur_min = val;
<a name="l00802"></a>00802     }
<a name="l00803"></a>00803   <span class="keywordflow">return</span> valeur_min;
<a name="l00804"></a>00804 }
<a name="l00805"></a>00805 
<a name="l00806"></a>00806 <span class="comment">// Precondition:</span>
<a name="l00807"></a>00807 <span class="comment">// Le tableau doit contenir au moins une valeur</span>
<a name="l00808"></a>00808 <span class="comment">// Parametre: const ArrOfDouble&amp; dx</span>
<a name="l00809"></a>00809 <span class="comment">// Signification: tableau a utiliser</span>
<a name="l00810"></a>00810 <span class="comment">//</span><span class="comment"></span>
<a name="l00811"></a>00811 <span class="comment">//! Retourne la valeur maximale</span>
<a name="l00812"></a>00812 <span class="comment"></span><span class="comment">/** \return double&lt;br&gt;</span>
<a name="l00813"></a>00813 <span class="comment">Signification: valeur du max */</span>
<a name="l00814"></a><a class="code" href="ArrOfDouble_8h.html#af031bd060e7097d5e66ca03d97387bcd">00814</a> <span class="keywordtype">double</span> <a class="code" href="ArrOfDouble_8cpp.html#a95241fccf4bed7fb7a4e2340b7735f14" title="Retourne la valeur maximale.">max_array</a>(<span class="keyword">const</span> <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a>&amp; dx)
<a name="l00815"></a>00815 {
<a name="l00816"></a>00816   <span class="keyword">const</span> <span class="keywordtype">int</span> size = dx.<a class="code" href="classArrOfDouble.html#a3c3b33bea0e88b87315c21ee94bee05f" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>();
<a name="l00817"></a>00817   assert(size &gt; 0);
<a name="l00818"></a>00818   <span class="keywordtype">double</span> valeur_max = dx[0];
<a name="l00819"></a>00819   <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 1; i &lt; size; i++)
<a name="l00820"></a>00820     {
<a name="l00821"></a>00821       <span class="keyword">const</span> <span class="keywordtype">double</span> val = dx[i];
<a name="l00822"></a>00822       <span class="keywordflow">if</span> (val &gt; valeur_max)
<a name="l00823"></a>00823         valeur_max = val;
<a name="l00824"></a>00824     }
<a name="l00825"></a>00825   <span class="keywordflow">return</span> valeur_max;
<a name="l00826"></a>00826 }
<a name="l00827"></a>00827 
<a name="l00828"></a><a class="code" href="ArrOfDouble_8cpp.html#a746b68bbcf9c36790272f4b512f02017">00828</a> <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">double</span> <a class="code" href="ArrOfDouble_8cpp.html#a746b68bbcf9c36790272f4b512f02017">scalar_abs</a>(<span class="keywordtype">double</span> x)
<a name="l00829"></a>00829 {
<a name="l00830"></a>00830   <span class="keywordflow">return</span> <a class="code" href="Double_8h.html#aaecd4ca8a2fe69cc6568af2938b94d2e">dabs</a>(x);
<a name="l00831"></a>00831 }
<a name="l00832"></a>00832 
<a name="l00833"></a>00833 <span class="comment">// Precondition:</span>
<a name="l00834"></a>00834 <span class="comment">// Le tableau doit contenir au moins une valeur</span>
<a name="l00835"></a>00835 <span class="comment">// Parametre: const ArrOfDouble&amp; dx</span>
<a name="l00836"></a>00836 <span class="comment">// Signification: tableau a utiliser</span>
<a name="l00837"></a>00837 <span class="comment">// Valeurs par defaut:</span>
<a name="l00838"></a>00838 <span class="comment">// Contraintes:</span>
<a name="l00839"></a>00839 <span class="comment">// Acces:</span>
<a name="l00840"></a>00840 <span class="comment">// Exception:</span>
<a name="l00841"></a>00841 <span class="comment">// Effets de bord:</span>
<a name="l00842"></a>00842 <span class="comment">// Postcondition:</span>
<a name="l00843"></a>00843 <span class="comment">//</span><span class="comment"></span>
<a name="l00844"></a>00844 <span class="comment">//! Retourne le max des abs(i)</span>
<a name="l00845"></a>00845 <span class="comment"></span><span class="comment">/** \return double&lt;br&gt;</span>
<a name="l00846"></a>00846 <span class="comment">Signification: valeur du max des valeurs absolues&lt;br&gt;</span>
<a name="l00847"></a>00847 <span class="comment">Contraintes: */</span>
<a name="l00848"></a><a class="code" href="ArrOfDouble_8h.html#a9b39d6cade643f98adf92af20fb84bc4">00848</a> <span class="keywordtype">double</span> <a class="code" href="ArrOfDouble_8cpp.html#a22ce24a1e68db94b2e023b6eb200c92b" title="Retourne le max des abs(i)">max_abs_array</a>(<span class="keyword">const</span> <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a>&amp; dx)
<a name="l00849"></a>00849 {
<a name="l00850"></a>00850   <span class="keyword">const</span> <span class="keywordtype">int</span> size = dx.<a class="code" href="classArrOfDouble.html#a3c3b33bea0e88b87315c21ee94bee05f" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>();
<a name="l00851"></a>00851   assert(size &gt; 0);
<a name="l00852"></a>00852   <span class="keywordtype">double</span> valeur_max = <a class="code" href="ArrOfDouble_8cpp.html#a746b68bbcf9c36790272f4b512f02017">scalar_abs</a>(dx[0]);
<a name="l00853"></a>00853   <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 1; i &lt; size; i++)
<a name="l00854"></a>00854     {
<a name="l00855"></a>00855       <span class="keyword">const</span> <span class="keywordtype">double</span> val = <a class="code" href="ArrOfDouble_8cpp.html#a746b68bbcf9c36790272f4b512f02017">scalar_abs</a>(dx[i]);
<a name="l00856"></a>00856       <span class="keywordflow">if</span> (val &gt; valeur_max)
<a name="l00857"></a>00857         valeur_max = val;
<a name="l00858"></a>00858     }
<a name="l00859"></a>00859   <span class="keywordflow">return</span> valeur_max;
<a name="l00860"></a>00860 }
<a name="l00861"></a>00861 
<a name="l00862"></a>00862 <span class="comment">// Precondition:</span>
<a name="l00863"></a>00863 <span class="comment">// Le tableau doit contenir au moins une valeur</span>
<a name="l00864"></a>00864 <span class="comment">// Parametre: const ArrOfDouble&amp; dx</span>
<a name="l00865"></a>00865 <span class="comment">// Signification: tableau a utiliser</span>
<a name="l00866"></a>00866 <span class="comment">// Valeurs par defaut:</span>
<a name="l00867"></a>00867 <span class="comment">// Contraintes:</span>
<a name="l00868"></a>00868 <span class="comment">// Acces:</span>
<a name="l00869"></a>00869 <span class="comment">// Exception:</span>
<a name="l00870"></a>00870 <span class="comment">// Effets de bord:</span>
<a name="l00871"></a>00871 <span class="comment">// Postcondition:</span>
<a name="l00872"></a>00872 <span class="comment">//</span><span class="comment"></span>
<a name="l00873"></a>00873 <span class="comment">//! Retourne le min des abs(i)</span>
<a name="l00874"></a>00874 <span class="comment"></span><span class="comment">/** \return double&lt;br&gt;</span>
<a name="l00875"></a>00875 <span class="comment">Signification: valeur du min des valeurs absolues&lt;br&gt;</span>
<a name="l00876"></a>00876 <span class="comment">Contraintes: */</span>
<a name="l00877"></a><a class="code" href="ArrOfDouble_8h.html#afc7110da752a542cf5ed450725f9dc6c">00877</a> <span class="keywordtype">double</span> <a class="code" href="ArrOfDouble_8cpp.html#af20891ba89d3aaf70f060e470b8c673b" title="Retourne le min des abs(i)">min_abs_array</a>(<span class="keyword">const</span> <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a>&amp; dx)
<a name="l00878"></a>00878 {
<a name="l00879"></a>00879   <span class="keyword">const</span> <span class="keywordtype">int</span> size = dx.<a class="code" href="classArrOfDouble.html#a3c3b33bea0e88b87315c21ee94bee05f" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>();
<a name="l00880"></a>00880   assert(size &gt; 0);
<a name="l00881"></a>00881   <span class="keywordtype">double</span> v = <a class="code" href="ArrOfDouble_8cpp.html#a746b68bbcf9c36790272f4b512f02017">scalar_abs</a>(dx[0]);
<a name="l00882"></a>00882   <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 1; i &lt; size; i++)
<a name="l00883"></a>00883     {
<a name="l00884"></a>00884       <span class="keyword">const</span> <span class="keywordtype">double</span> val = <a class="code" href="ArrOfDouble_8cpp.html#a746b68bbcf9c36790272f4b512f02017">scalar_abs</a>(dx[i]);
<a name="l00885"></a>00885       <span class="keywordflow">if</span> (val &lt; v)
<a name="l00886"></a>00886         v = val;
<a name="l00887"></a>00887     }
<a name="l00888"></a>00888   <span class="keywordflow">return</span> v;
<a name="l00889"></a>00889 }
<a name="l00890"></a>00890 
<a name="l00891"></a>00891 <span class="comment">//</span>
<a name="l00892"></a>00892 <span class="comment">//</span><span class="comment"></span>
<a name="l00893"></a>00893 <span class="comment">//! Fonction de comparaison utilisee pour trier le tableau&lt;br&gt;dans ArrOfDouble::trier(). Voir man qsort</span>
<a name="l00894"></a><a class="code" href="ArrOfDouble_8cpp.html#ac6c1c13b23da42455b5364d7737df70a">00894</a> <span class="comment"></span><span class="keyword">static</span> <a class="code" href="arch_8h.html#a1caaf369d9c5f0817dbaa76b43b8d87b">True_int</a>  <a class="code" href="ArrOfDouble_8cpp.html#ac6c1c13b23da42455b5364d7737df70a" title="Fonction de comparaison utilisee pour trier le tableau dans ArrOfDouble::trier(). Voir man qsort...">fonction_compare_arrofdouble_ordonner</a>(<span class="keyword">const</span> <span class="keywordtype">void</span> * data1, <span class="keyword">const</span> <span class="keywordtype">void</span> * data2)
<a name="l00895"></a>00895 {
<a name="l00896"></a>00896   <span class="keyword">const</span> <span class="keywordtype">double</span> x = *(<span class="keyword">const</span> <span class="keywordtype">double</span>*)data1;
<a name="l00897"></a>00897   <span class="keyword">const</span> <span class="keywordtype">double</span> y = *(<span class="keyword">const</span> <span class="keywordtype">double</span>*)data2;
<a name="l00898"></a>00898   <span class="keywordflow">if</span> (x &lt; y)
<a name="l00899"></a>00899     <span class="keywordflow">return</span> -1;
<a name="l00900"></a>00900   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (x &gt; y)
<a name="l00901"></a>00901     <span class="keywordflow">return</span> 1;
<a name="l00902"></a>00902   <span class="keywordflow">else</span>
<a name="l00903"></a>00903     <span class="keywordflow">return</span> 0;
<a name="l00904"></a>00904 }
<a name="l00905"></a>00905 
<a name="l00906"></a>00906 <span class="comment">//</span>
<a name="l00907"></a>00907 <span class="comment">//</span><span class="comment"></span>
<a name="l00908"></a>00908 <span class="comment">//! Tri des valeurs du tableau dans l&#39;ordre croissant.&lt;br&gt;La fonction utilisee est qsort de stdlib (elle est en n*log(n)).</span>
<a name="l00909"></a><a class="code" href="classArrOfDouble.html#a779184ebb5056c91f6185acf7c10088c">00909</a> <span class="comment"></span><span class="keywordtype">void</span> <a class="code" href="classArrOfDouble.html#a779184ebb5056c91f6185acf7c10088c" title="Tri des valeurs du tableau dans l&#39;ordre croissant. La fonction utilisee est qsort de stdlib (elle est...">ArrOfDouble::ordonne_array</a>()
<a name="l00910"></a>00910 {
<a name="l00911"></a>00911   <span class="keyword">const</span> <span class="keywordtype">int</span> size = <a class="code" href="classArrOfDouble.html#ae201cdbdbf9f840376398199e5f737a0">size_array_</a>;
<a name="l00912"></a>00912   <span class="keywordflow">if</span> (size &gt; 1)
<a name="l00913"></a>00913     {
<a name="l00914"></a>00914       <span class="keywordtype">double</span> * data = <a class="code" href="classArrOfDouble.html#a77419df7d43ac2ce76b9388a39ad90e9">data_</a>;
<a name="l00915"></a>00915       qsort(data, size, <span class="keyword">sizeof</span>(<span class="keywordtype">double</span>),
<a name="l00916"></a>00916             <a class="code" href="ArrOfDouble_8cpp.html#ac6c1c13b23da42455b5364d7737df70a" title="Fonction de comparaison utilisee pour trier le tableau dans ArrOfDouble::trier(). Voir man qsort...">fonction_compare_arrofdouble_ordonner</a>);
<a name="l00917"></a>00917     }
<a name="l00918"></a>00918 }
<a name="l00919"></a>00919 
<a name="l00920"></a>00920 <span class="comment">//</span>
<a name="l00921"></a>00921 <span class="comment">//</span><span class="comment"></span>
<a name="l00922"></a>00922 <span class="comment">//! Tri des valeurs du tableau dans l&#39;ordre croissant et suppresion des doublons&lt;br&gt;La fonction utilisee est qsort de stdlib (elle est en n*log(n)).</span>
<a name="l00923"></a><a class="code" href="classArrOfDouble.html#aee755ade0ca203a8490ef2b29e1136cd">00923</a> <span class="comment"></span><span class="keywordtype">void</span> <a class="code" href="classArrOfDouble.html#aee755ade0ca203a8490ef2b29e1136cd" title="Tri des valeurs du tableau dans l&#39;ordre croissant et suppresion des doublons La fonction utilisee est...">ArrOfDouble::array_trier_retirer_doublons</a>()
<a name="l00924"></a>00924 {
<a name="l00925"></a>00925   <span class="keyword">const</span> <span class="keywordtype">int</span> size_ = <a class="code" href="classArrOfDouble.html#ae201cdbdbf9f840376398199e5f737a0">size_array_</a>;
<a name="l00926"></a>00926   <span class="keywordflow">if</span> (size_ &lt;= 0)
<a name="l00927"></a>00927     <span class="keywordflow">return</span>;
<a name="l00928"></a>00928 <span class="comment">// Tri dans l&#39;ordre croissant</span>
<a name="l00929"></a>00929   <a class="code" href="classArrOfDouble.html#a779184ebb5056c91f6185acf7c10088c" title="Tri des valeurs du tableau dans l&#39;ordre croissant. La fonction utilisee est qsort de stdlib (elle est...">ordonne_array</a>();
<a name="l00930"></a>00930 <span class="comment">// Retire les doublons (codage optimise en pointeurs)</span>
<a name="l00931"></a>00931   <span class="keywordtype">double</span> last_value = *<a class="code" href="classArrOfDouble.html#a77419df7d43ac2ce76b9388a39ad90e9">data_</a>;
<a name="l00932"></a>00932   <span class="keywordtype">double</span> *src = <a class="code" href="classArrOfDouble.html#a77419df7d43ac2ce76b9388a39ad90e9">data_</a> + 1;
<a name="l00933"></a>00933   <span class="keywordtype">double</span> *dest = <a class="code" href="classArrOfDouble.html#a77419df7d43ac2ce76b9388a39ad90e9">data_</a> + 1;
<a name="l00934"></a>00934   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = size_ - 1; i != 0; i--)
<a name="l00935"></a>00935     {
<a name="l00936"></a>00936       <span class="keywordtype">double</span> x = *(src++);
<a name="l00937"></a>00937       <span class="keywordflow">if</span> (x != last_value)
<a name="l00938"></a>00938         {
<a name="l00939"></a>00939           *(dest++) = x;
<a name="l00940"></a>00940           last_value = x;
<a name="l00941"></a>00941         }
<a name="l00942"></a>00942     }
<a name="l00943"></a>00943   <span class="keywordtype">int</span> new_size_ = dest - <a class="code" href="classArrOfDouble.html#a77419df7d43ac2ce76b9388a39ad90e9">data_</a>;
<a name="l00944"></a>00944   <a class="code" href="classArrOfDouble.html#a610464f4b3dccac6f814915b526783ed">resize_array</a>(new_size_);
<a name="l00945"></a>00945 }
<a name="l00946"></a>00946 
<a name="l00947"></a>00947 <span class="comment">// Exception:</span>
<a name="l00948"></a>00948 <span class="comment">// Effets de bord:</span>
<a name="l00949"></a>00949 <span class="comment">// Postcondition:</span>
<a name="l00950"></a>00950 <span class="comment">//</span>
<a name="l00951"></a>00951 <span class="comment">//</span>
<a name="l00952"></a>00952 <span class="comment">//</span>
<a name="l00953"></a>00953 <span class="comment">//</span>
<a name="l00954"></a>00954 <span class="comment">//</span>
<a name="l00955"></a>00955 <span class="comment">//</span>
<a name="l00956"></a>00956 <span class="comment">//</span>
<a name="l00957"></a>00957 <span class="comment">//</span>
<a name="l00958"></a>00958 <span class="comment">//</span>
<a name="l00959"></a>00959 <span class="comment">//</span><span class="comment"></span>
<a name="l00960"></a>00960 <span class="comment">//! Fait pointer le tableau vers les memes donnees qu&#39;un tableau&lt;br&gt;existant. Le tableau sera du meme type que le tableau m (&quot;detache&quot;,&lt;br&gt;&quot;normal&quot;). Le tableau m ne doit pas etre de type &quot;ref_data&quot;&lt;br&gt;Attention, le tableau source et *this sont ensuite figes (resize_array()&lt;br&gt;interdit).&lt;br&gt;Attention: methode virtuelle: dans les classes derivee, cette methode&lt;br&gt;initialise les structures pour creer un tableau sequentiel.&lt;br&gt;Parametre: const ArrOfDouble\&amp; m&lt;br&gt;Signification: le tableau a referencer (pas de type &quot;ref_data&quot;&lt;br&gt;et different de *this !!!)</span>
<a name="l00961"></a>00961 <span class="comment"></span><span class="comment">/** \return ArrOfDouble\&amp;&lt;br&gt;</span>
<a name="l00962"></a>00962 <span class="comment">Signification: *this&lt;br&gt;</span>
<a name="l00963"></a>00963 <span class="comment">Contraintes: */</span>
<a name="l00964"></a><a class="code" href="classArrOfDouble.html#a1831984f45c77967bf13fe67b97e95a9">00964</a> <span class="keywordtype">void</span> <a class="code" href="classArrOfDouble.html#a1831984f45c77967bf13fe67b97e95a9" title="Fait pointer le tableau vers les memes donnees qu&#39;un tableau existant. Le tableau sera du meme type q...">ArrOfDouble::ref_array</a>(<a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a>&amp; m, <span class="keywordtype">int</span> start, <span class="keywordtype">int</span> size)
<a name="l00965"></a>00965 {
<a name="l00966"></a>00966   assert(&amp;m != <span class="keyword">this</span>);
<a name="l00967"></a>00967 <span class="comment">// La condition &#39;m n&#39;est pas de type &quot;ref_data&quot;&#39; est necessaire pour</span>
<a name="l00968"></a>00968 <span class="comment">// attach_array().</span>
<a name="l00969"></a>00969   <a class="code" href="classArrOfDouble.html#a30d7509eec18c3ef46cc0140bdcdc48f" title="Amene le tableau dans l&#39;etat &quot;detache&quot;. C&#39;est a dire: Si le tableau est &quot;detache&quot; : * ne rien faire...">detach_array</a>();
<a name="l00970"></a>00970   <a class="code" href="classArrOfDouble.html#af59467d8ccfc8e5cdac8e24e1c8a1e66" title="Amene le tableau dans l&#39;etat &quot;normal&quot;, &quot;detache&quot; ou &quot;ref_array&quot; en associant une sous-zone de m...">attach_array</a>(m, start, size);
<a name="l00971"></a>00971 }
<a name="l00972"></a>00972 
<a name="l00973"></a>00973 <span class="comment">//</span>
<a name="l00974"></a>00974 <span class="comment">//</span>
<a name="l00975"></a>00975 <span class="comment">//</span>
<a name="l00976"></a>00976 <span class="comment">//</span>
<a name="l00977"></a>00977 <span class="comment">//</span>
<a name="l00978"></a>00978 <span class="comment">//</span>
<a name="l00979"></a>00979 <span class="comment">//</span>
<a name="l00980"></a>00980 <span class="comment">//</span>
<a name="l00981"></a>00981 <span class="comment">//</span>
<a name="l00982"></a>00982 <span class="comment">//</span>
<a name="l00983"></a>00983 <span class="comment">//</span>
<a name="l00984"></a>00984 <span class="comment">//</span><span class="comment"></span>
<a name="l00985"></a>00985 <span class="comment">//! Fait pointer le tableau vers la zone de memoire &quot;data_&quot;.&lt;br&gt;On detache la zone de memoire existante. Le tableau devient&lt;br&gt;de type &quot;ref_data&quot;. Attention : ptr doit etre non nul.&lt;br&gt;La taille est initialisee avec size.&lt;br&gt;Attention: methode virtuelle: dans les classes derivee, cette methode&lt;br&gt;initialise les structures pour creer un tableau sequentiel.&lt;br&gt;Pour faire une ref sur un tableau parallele utiliser DoubleVect::ref()&lt;br&gt;Parametre: double*&lt;br&gt;Signification: le tableau a recuperer. Si pointeur nul alors size&lt;br&gt;doit etre nulle aussi et le tableau reste detache&lt;br&gt;Parametre: int size&lt;br&gt;Signification: le nombre d&#39;elements du tableau.</span>
<a name="l00986"></a>00986 <span class="comment"></span><span class="comment">/** \return ArrOfDouble\&amp;&lt;br&gt;</span>
<a name="l00987"></a>00987 <span class="comment">Signification: *this */</span>
<a name="l00988"></a><a class="code" href="classArrOfDouble.html#a8cc97dbe67c8001dad97008b10fa7690">00988</a> <span class="keywordtype">void</span> <a class="code" href="classArrOfDouble.html#a8cc97dbe67c8001dad97008b10fa7690" title="Fait pointer le tableau vers la zone de memoire &quot;data_&quot;. On detache la zone de memoire existante...">ArrOfDouble::ref_data</a>(<span class="keywordtype">double</span>* ptr, <span class="keywordtype">int</span> size)
<a name="l00989"></a>00989 {
<a name="l00990"></a>00990   assert(ptr != 0 || size == 0);
<a name="l00991"></a>00991   assert(size &gt;= 0);
<a name="l00992"></a>00992   <a class="code" href="classArrOfDouble.html#a30d7509eec18c3ef46cc0140bdcdc48f" title="Amene le tableau dans l&#39;etat &quot;detache&quot;. C&#39;est a dire: Si le tableau est &quot;detache&quot; : * ne rien faire...">detach_array</a>();
<a name="l00993"></a>00993   <a class="code" href="classArrOfDouble.html#a77419df7d43ac2ce76b9388a39ad90e9">data_</a> = ptr;
<a name="l00994"></a>00994   <a class="code" href="classArrOfDouble.html#ae201cdbdbf9f840376398199e5f737a0">size_array_</a> = size;
<a name="l00995"></a>00995   <a class="code" href="classArrOfDouble.html#a952e7436d209c8957ea0209f1fa66976">memory_size_</a> = size; <span class="comment">//!&lt; Pour passer les tests si on resize a la meme taille</span>
<a name="l00996"></a>00996 <span class="comment"></span>}
<a name="l00997"></a>00997 
<a name="l00998"></a>00998 <span class="comment">// Precondition:</span>
<a name="l00999"></a>00999 <span class="comment">// Postcondition:</span>
<a name="l01000"></a>01000 <span class="comment">// On a p_==0, data_==0 et size_array_==0, memory_size_ = 0</span>
<a name="l01001"></a>01001 <span class="comment">// L&#39;attribut smart_resize_ est conserve.</span>
<a name="l01002"></a>01002 <span class="comment">//</span>
<a name="l01003"></a>01003 <span class="comment">//</span>
<a name="l01004"></a>01004 <span class="comment">//</span>
<a name="l01005"></a>01005 <span class="comment">//</span>
<a name="l01006"></a>01006 <span class="comment">//</span>
<a name="l01007"></a>01007 <span class="comment">//</span>
<a name="l01008"></a>01008 <span class="comment">//</span>
<a name="l01009"></a>01009 <span class="comment">//</span>
<a name="l01010"></a>01010 <span class="comment">//</span><span class="comment"></span>
<a name="l01011"></a>01011 <span class="comment">//! Amene le tableau dans l&#39;etat &quot;detache&quot;. C&#39;est a dire:&lt;br&gt;Si le tableau est &quot;detache&quot; :&lt;br&gt;* ne rien faire&lt;br&gt;Si le tableau est &quot;normal&quot; :&lt;br&gt;* decremente le nombre de references a *p&lt;br&gt;* detruit *p si p-&gt;ref_count==0&lt;br&gt;* annule p_, data_ et size_array_&lt;br&gt;Si le tableau est &quot;ref_data&quot; :&lt;br&gt;* annule data_ et size_array_</span>
<a name="l01012"></a>01012 <span class="comment"></span><span class="comment">/** \return int&lt;br&gt;</span>
<a name="l01013"></a>01013 <span class="comment">Signification: 1 si les donnees du tableau ont ete supprimees */</span>
<a name="l01014"></a><a class="code" href="classArrOfDouble.html#a30d7509eec18c3ef46cc0140bdcdc48f">01014</a> <span class="keywordtype">int</span> <a class="code" href="classArrOfDouble.html#a30d7509eec18c3ef46cc0140bdcdc48f" title="Amene le tableau dans l&#39;etat &quot;detache&quot;. C&#39;est a dire: Si le tableau est &quot;detache&quot; : * ne rien faire...">ArrOfDouble::detach_array</a>()
<a name="l01015"></a>01015 {
<a name="l01016"></a>01016   <span class="keywordtype">int</span> retour = 0;
<a name="l01017"></a>01017   <span class="keywordflow">if</span> (<a class="code" href="classArrOfDouble.html#a16cc4d79375188b7cb389fce2c920186">p_</a>)
<a name="l01018"></a>01018     {
<a name="l01019"></a>01019 <span class="comment">// Le tableau est de type &quot;normal&quot;</span>
<a name="l01020"></a>01020 <span class="comment">// Si la zone de memoire n&#39;est plus utilisee par personne,</span>
<a name="l01021"></a>01021 <span class="comment">// on la detruit.</span>
<a name="l01022"></a>01022       <span class="keywordflow">if</span> ((<a class="code" href="classArrOfDouble.html#a16cc4d79375188b7cb389fce2c920186">p_</a>-&gt;<a class="code" href="classVDoubledata.html#ad09f0a1c617ee9eb1b0af8cc324c7348" title="Un tableau de moins utilise cette zone memoire decremente ref_count.">suppr_one_ref</a>()) == 0)
<a name="l01023"></a>01023         {
<a name="l01024"></a>01024           <span class="keyword">delete</span> <a class="code" href="classArrOfDouble.html#a16cc4d79375188b7cb389fce2c920186">p_</a>;
<a name="l01025"></a>01025           retour = 1;
<a name="l01026"></a>01026         }
<a name="l01027"></a>01027       <a class="code" href="classArrOfDouble.html#a16cc4d79375188b7cb389fce2c920186">p_</a> = 0;
<a name="l01028"></a>01028     }
<a name="l01029"></a>01029   <a class="code" href="classArrOfDouble.html#a77419df7d43ac2ce76b9388a39ad90e9">data_</a> = 0;
<a name="l01030"></a>01030   <a class="code" href="classArrOfDouble.html#ae201cdbdbf9f840376398199e5f737a0">size_array_</a> = 0;
<a name="l01031"></a>01031   <a class="code" href="classArrOfDouble.html#a952e7436d209c8957ea0209f1fa66976">memory_size_</a> = 0;
<a name="l01032"></a>01032   <span class="keywordflow">return</span> retour;
<a name="l01033"></a>01033 }
<a name="l01034"></a>01034 
<a name="l01035"></a>01035 <span class="comment">// Precondition:</span>
<a name="l01036"></a>01036 <span class="comment">// Le tableau doit etre &quot;detache&quot;</span>
<a name="l01037"></a>01037 <span class="comment">// Parametre: const ArrOfDouble&amp; m</span>
<a name="l01038"></a>01038 <span class="comment">// Signification: tableau a utiliser</span>
<a name="l01039"></a>01039 <span class="comment">// le tableau doit etre different de *this !!!</span>
<a name="l01040"></a>01040 <span class="comment">// </span>
<a name="l01041"></a>01041 <span class="comment">// Signification:</span>
<a name="l01042"></a>01042 <span class="comment">// Contraintes:</span>
<a name="l01043"></a>01043 <span class="comment">// Exception:</span>
<a name="l01044"></a>01044 <span class="comment">// Effets de bord:</span>
<a name="l01045"></a>01045 <span class="comment">// Postcondition:</span>
<a name="l01046"></a>01046 <span class="comment">// Si m est detache, le tableau reste detache,</span>
<a name="l01047"></a>01047 <span class="comment">// si m est &quot;ref_array&quot;, le tableau devient &quot;ref_array&quot;,</span>
<a name="l01048"></a>01048 <span class="comment">// sinon le tableau est &quot;normal&quot;, avec ref_count &gt; 1</span>
<a name="l01049"></a>01049 <span class="comment">// Si m est de taille nulle, le tableau reste detache + Warning dans fichier .log</span>
<a name="l01050"></a>01050 <span class="comment">//</span>
<a name="l01051"></a>01051 <span class="comment">//</span>
<a name="l01052"></a>01052 <span class="comment">//</span><span class="comment"></span>
<a name="l01053"></a>01053 <span class="comment">//! Amene le tableau dans l&#39;etat &quot;normal&quot;, &quot;detache&quot; ou &quot;ref_array&quot;&lt;br&gt;en associant une sous-zone de memoire du tableau m, definie par start et size&lt;br&gt;Si size &lt; 0, on prend le tableau m jusqu&#39;a la fin.</span>
<a name="l01054"></a><a class="code" href="classArrOfDouble.html#af59467d8ccfc8e5cdac8e24e1c8a1e66">01054</a> <span class="comment"></span><span class="keywordtype">void</span> <a class="code" href="classArrOfDouble.html#af59467d8ccfc8e5cdac8e24e1c8a1e66" title="Amene le tableau dans l&#39;etat &quot;normal&quot;, &quot;detache&quot; ou &quot;ref_array&quot; en associant une sous-zone de m...">ArrOfDouble::attach_array</a>(<span class="keyword">const</span> <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a>&amp; m, <span class="keywordtype">int</span> start, <span class="keywordtype">int</span> size)
<a name="l01055"></a>01055 {
<a name="l01056"></a>01056 <span class="comment">// Le tableau doit etre detache</span>
<a name="l01057"></a>01057   assert(<a class="code" href="classArrOfDouble.html#a77419df7d43ac2ce76b9388a39ad90e9">data_</a> == 0 &amp;&amp; <a class="code" href="classArrOfDouble.html#a16cc4d79375188b7cb389fce2c920186">p_</a> == 0);
<a name="l01058"></a>01058 <span class="comment">// Le tableau doit etre different de *this</span>
<a name="l01059"></a>01059   assert(&amp;m != <span class="keyword">this</span>);
<a name="l01060"></a>01060   <span class="keywordflow">if</span> (size &lt; 0)
<a name="l01061"></a>01061     size = m.<a class="code" href="classArrOfDouble.html#ae201cdbdbf9f840376398199e5f737a0">size_array_</a> - start;
<a name="l01062"></a>01062   assert(start &gt;= 0 &amp;&amp; size &gt;=0 &amp;&amp; start + size &lt;= m.<a class="code" href="classArrOfDouble.html#ae201cdbdbf9f840376398199e5f737a0">size_array_</a>);
<a name="l01063"></a>01063   <span class="keywordflow">if</span> (m.<a class="code" href="classArrOfDouble.html#a3c3b33bea0e88b87315c21ee94bee05f" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() &gt; 0)
<a name="l01064"></a>01064     {
<a name="l01065"></a>01065       <a class="code" href="classArrOfDouble.html#a16cc4d79375188b7cb389fce2c920186">p_</a> = m.<a class="code" href="classArrOfDouble.html#a16cc4d79375188b7cb389fce2c920186">p_</a>;
<a name="l01066"></a>01066       <span class="keywordflow">if</span> (<a class="code" href="classArrOfDouble.html#a16cc4d79375188b7cb389fce2c920186">p_</a>)
<a name="l01067"></a>01067         <a class="code" href="classArrOfDouble.html#a16cc4d79375188b7cb389fce2c920186">p_</a>-&gt;<a class="code" href="classVDoubledata.html#a15b5bc0cf033070e4670245e2c3789ab" title="Un nouveau tableau utilise cette zone memoire : incremente ref_count.">add_one_ref</a>();
<a name="l01068"></a>01068       <a class="code" href="classArrOfDouble.html#a77419df7d43ac2ce76b9388a39ad90e9">data_</a> = m.<a class="code" href="classArrOfDouble.html#a77419df7d43ac2ce76b9388a39ad90e9">data_</a> + start;
<a name="l01069"></a>01069       <a class="code" href="classArrOfDouble.html#ae201cdbdbf9f840376398199e5f737a0">size_array_</a> = size;
<a name="l01070"></a>01070       <a class="code" href="classArrOfDouble.html#a952e7436d209c8957ea0209f1fa66976">memory_size_</a> = m.<a class="code" href="classArrOfDouble.html#a952e7436d209c8957ea0209f1fa66976">memory_size_</a> - start;
<a name="l01071"></a>01071       <a class="code" href="classArrOfDouble.html#a527b3aabfef167644bb124f8255245b3">smart_resize_</a> = m.<a class="code" href="classArrOfDouble.html#a527b3aabfef167644bb124f8255245b3">smart_resize_</a>;
<a name="l01072"></a>01072     }
<a name="l01073"></a>01073   <span class="keywordflow">else</span>
<a name="l01074"></a>01074     {
<a name="l01075"></a>01075 <span class="comment">// Cas particulier ou on attache un tableau de taille nulle:</span>
<a name="l01076"></a>01076 <span class="comment">// en theorie, c&#39;est pareil qu&#39;un tableau de taille non nulle, MAIS</span>
<a name="l01077"></a>01077 <span class="comment">// dans les operateurs (ex:Op_Dift_VDF_Face_Axi), une ref est construite</span>
<a name="l01078"></a>01078 <span class="comment">// avant que le tableau ne prenne sa taille definitive. Donc, pour ne pas</span>
<a name="l01079"></a>01079 <span class="comment">// empecher le resize, il ne faut pas attacher le tableau s&#39;il n&#39;a pas</span>
<a name="l01080"></a>01080 <span class="comment">// encore la bonne taille. Solution propre: reecrire les operateurs pour</span>
<a name="l01081"></a>01081 <span class="comment">// qu&#39;ils ne prennent pas une ref avant que le tableau ne soit valide</span>
<a name="l01082"></a>01082 <span class="comment">// et faire p_ = m.p_ dans tous les cas.</span>
<a name="l01083"></a>01083 <span class="comment">// Process::Journal() &lt;&lt; &quot;Warning ArrOfDouble::attach_array(m), m.size_array()==0, on n attache pas le tableau&quot; &lt;&lt; finl;</span>
<a name="l01084"></a>01084     }
<a name="l01085"></a>01085 }
<a name="l01086"></a>01086 
<a name="l01087"></a>01087 <span class="comment">// Precondition:</span>
<a name="l01088"></a>01088 <span class="comment">// Parametre:       const ArrOfDouble&amp; m</span>
<a name="l01089"></a>01089 <span class="comment">// Signification:   le tableau a utiliser, doit etre different de *this !</span>
<a name="l01090"></a>01090 <span class="comment">// Parametre:       int nb_elements</span>
<a name="l01091"></a>01091 <span class="comment">// Signification:   nombre d&#39;elements a copier, nb_elements &gt;= -1.</span>
<a name="l01092"></a>01092 <span class="comment">// Si nb_elements==-1, on copie tout le tableau m.</span>
<a name="l01093"></a>01093 <span class="comment">// Valeurs par defaut: -1</span>
<a name="l01094"></a>01094 <span class="comment">// Parametre:       int first_element_dest</span>
<a name="l01095"></a>01095 <span class="comment">// Valeurs par defaut: 0</span>
<a name="l01096"></a>01096 <span class="comment">// Parametre:       int first_element_source</span>
<a name="l01097"></a>01097 <span class="comment">// Valeurs par defaut: 0</span>
<a name="l01098"></a>01098 <span class="comment">// Exception:</span>
<a name="l01099"></a>01099 <span class="comment">// Sort en erreur si la taille du tableau m est plus grande que la</span>
<a name="l01100"></a>01100 <span class="comment">// taille de tableau this.</span>
<a name="l01101"></a>01101 <span class="comment">// Effets de bord:</span>
<a name="l01102"></a>01102 <span class="comment">// Postcondition:</span>
<a name="l01103"></a>01103 <span class="comment">//</span>
<a name="l01104"></a>01104 <span class="comment">//</span>
<a name="l01105"></a>01105 <span class="comment">//</span><span class="comment"></span>
<a name="l01106"></a>01106 <span class="comment">//! Copie les elements source[first_element_source + i]&lt;br&gt;dans les elements  (*this)[first_element_dest + i] pour 0 &lt;= i &lt; nb_elements&lt;br&gt;Les autres elements de (*this) sont inchanges.</span>
<a name="l01107"></a>01107 <span class="comment"></span><span class="comment">/** \return ArrOfDouble\&amp;&lt;br&gt;</span>
<a name="l01108"></a>01108 <span class="comment">Signification: *this&lt;br&gt;</span>
<a name="l01109"></a>01109 <span class="comment">Contraintes: */</span>
<a name="l01110"></a><a class="code" href="classArrOfDouble.html#a2fcb2a2d3b59425c6cb37526ea6af6a3">01110</a> <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a>&amp; <a class="code" href="classArrOfDouble.html#a2fcb2a2d3b59425c6cb37526ea6af6a3" title="Copie les elements source[first_element_source + i] dans les elements (*this)[first_element_dest + i]...">ArrOfDouble::inject_array</a>(<span class="keyword">const</span> <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a>&amp; source,
<a name="l01111"></a>01111                                        <span class="keywordtype">int</span> nb_elements,
<a name="l01112"></a>01112                                        <span class="keywordtype">int</span> first_element_dest,
<a name="l01113"></a>01113                                        <span class="keywordtype">int</span> first_element_source)
<a name="l01114"></a>01114 {
<a name="l01115"></a>01115   assert(&amp;source != <span class="keyword">this</span>);
<a name="l01116"></a>01116   assert(nb_elements &gt;= -1);
<a name="l01117"></a>01117   assert(first_element_dest &gt;= 0);
<a name="l01118"></a>01118   assert(first_element_source &gt;= 0);
<a name="l01119"></a>01119 
<a name="l01120"></a>01120   <span class="keywordflow">if</span> (nb_elements &lt; 0)
<a name="l01121"></a>01121     nb_elements = source.<a class="code" href="classArrOfDouble.html#a3c3b33bea0e88b87315c21ee94bee05f" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>();
<a name="l01122"></a>01122 
<a name="l01123"></a>01123   assert(first_element_source + nb_elements &lt;= source.<a class="code" href="classArrOfDouble.html#a3c3b33bea0e88b87315c21ee94bee05f" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>());
<a name="l01124"></a>01124   assert(first_element_dest + nb_elements &lt;= <a class="code" href="classArrOfDouble.html#a3c3b33bea0e88b87315c21ee94bee05f" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>());
<a name="l01125"></a>01125 
<a name="l01126"></a>01126   <span class="keywordflow">if</span> (nb_elements &gt; 0)
<a name="l01127"></a>01127     {
<a name="l01128"></a>01128       <span class="keywordtype">double</span> * addr_dest = <a class="code" href="classArrOfDouble.html#a77419df7d43ac2ce76b9388a39ad90e9">data_</a> + first_element_dest;
<a name="l01129"></a>01129       <span class="keyword">const</span> <span class="keywordtype">double</span> * addr_source = source.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() + first_element_source;
<a name="l01130"></a>01130 <span class="comment">// PL: On utilise le memcpy car c&#39;est VRAIMENT plus rapide (10% +vite sur RNR_G20)</span>
<a name="l01131"></a>01131       memcpy(addr_dest , addr_source, nb_elements * <span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));
<a name="l01132"></a>01132       <span class="comment">/*</span>
<a name="l01133"></a>01133 <span class="comment">        int i;</span>
<a name="l01134"></a>01134 <span class="comment">        for (i = 0; i &lt; nb_elements; i++) {</span>
<a name="l01135"></a>01135 <span class="comment">        addr_dest[i] = addr_source[i];</span>
<a name="l01136"></a>01136 <span class="comment">        } */</span>
<a name="l01137"></a>01137     }
<a name="l01138"></a>01138   <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l01139"></a>01139 }
<a name="l01140"></a>01140 
<a name="l01141"></a>01141 <span class="comment">//</span>
<a name="l01142"></a>01142 <span class="comment">//</span><span class="comment"></span>
<a name="l01143"></a>01143 <span class="comment">//! Retourne le nombre de references des donnees du tableau&lt;br&gt;si le tableau est &quot;normal&quot;, -1 s&#39;il est &quot;detache&quot; ou &quot;ref_data&quot;</span>
<a name="l01144"></a>01144 <span class="comment"></span><span class="comment">/** \return int&lt;br&gt;</span>
<a name="l01145"></a>01145 <span class="comment">Signification: ref_count_ */</span>
<a name="l01146"></a><a class="code" href="classArrOfDouble.html#a324a6714dc9d9a7b5997fda646d24974">01146</a> <span class="keywordtype">int</span> <a class="code" href="classArrOfDouble.html#a324a6714dc9d9a7b5997fda646d24974" title="Retourne le nombre de references des donnees du tableau si le tableau est &quot;normal&quot;, -1 s&#39;il est &quot;detache&quot; ou &quot;ref_data&quot;.">ArrOfDouble::ref_count</a>()<span class="keyword"> const</span>
<a name="l01147"></a>01147 <span class="keyword"></span>{
<a name="l01148"></a>01148   <span class="keywordflow">if</span> (<a class="code" href="classArrOfDouble.html#a16cc4d79375188b7cb389fce2c920186">p_</a>)
<a name="l01149"></a>01149     <span class="keywordflow">return</span> <a class="code" href="classArrOfDouble.html#a16cc4d79375188b7cb389fce2c920186">p_</a>-&gt;<a class="code" href="classVDoubledata.html#a9a5ad2abd6b9a242dea253941b3c9448" title="renvoie ref_count_">ref_count</a>();
<a name="l01150"></a>01150   <span class="keywordflow">else</span>
<a name="l01151"></a>01151     <span class="keywordflow">return</span> -1;
<a name="l01152"></a>01152 }
<a name="l01153"></a>01153 
<a name="l01154"></a>01154 <span class="comment">// Precondition:</span>
<a name="l01155"></a>01155 <span class="comment">// la taille de y doit etre au moins egale a la taille de this</span>
<a name="l01156"></a>01156 <span class="comment">// Parametre: const ArrOfDouble&amp; y</span>
<a name="l01157"></a>01157 <span class="comment">// Signification: tableau a ajouter</span>
<a name="l01158"></a>01158 <span class="comment">// Valeurs par defaut:</span>
<a name="l01159"></a>01159 <span class="comment">// Contraintes:</span>
<a name="l01160"></a>01160 <span class="comment">// Acces:</span>
<a name="l01161"></a>01161 <span class="comment">// Exception:</span>
<a name="l01162"></a>01162 <span class="comment">// Effets de bord:</span>
<a name="l01163"></a>01163 <span class="comment">// Postcondition:</span>
<a name="l01164"></a>01164 <span class="comment">//</span><span class="comment"></span>
<a name="l01165"></a>01165 <span class="comment">//! Addition case a case sur toutes les cases du tableau</span>
<a name="l01166"></a>01166 <span class="comment"></span><span class="comment">/** \return ArrOfDouble\&amp;&lt;br&gt;</span>
<a name="l01167"></a>01167 <span class="comment">Signification: *this&lt;br&gt;</span>
<a name="l01168"></a>01168 <span class="comment">Contraintes: */</span>
<a name="l01169"></a><a class="code" href="classArrOfDouble.html#a2d092d5c1a7d8523c65ca2e85507fd0d">01169</a> <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a>&amp; <a class="code" href="classArrOfDouble.html#a2d092d5c1a7d8523c65ca2e85507fd0d" title="Addition case a case sur toutes les cases du tableau.">ArrOfDouble::operator+=</a>(<span class="keyword">const</span> <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a>&amp; y)
<a name="l01170"></a>01170 {
<a name="l01171"></a>01171   assert(<a class="code" href="classArrOfDouble.html#a3c3b33bea0e88b87315c21ee94bee05f" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>()==y.<a class="code" href="classArrOfDouble.html#a3c3b33bea0e88b87315c21ee94bee05f" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>());
<a name="l01172"></a>01172   <span class="keywordtype">double</span>* dx = <a class="code" href="classArrOfDouble.html#a77419df7d43ac2ce76b9388a39ad90e9">data_</a>;
<a name="l01173"></a>01173   <span class="keyword">const</span> <span class="keywordtype">double</span>* dy = y.<a class="code" href="classArrOfDouble.html#a77419df7d43ac2ce76b9388a39ad90e9">data_</a>;
<a name="l01174"></a>01174   <span class="keyword">const</span> <span class="keywordtype">int</span> n = <a class="code" href="classArrOfDouble.html#a3c3b33bea0e88b87315c21ee94bee05f" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>();
<a name="l01175"></a>01175   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;n; i++)
<a name="l01176"></a>01176     dx[i] += dy[i];
<a name="l01177"></a>01177   <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l01178"></a>01178 }
<a name="l01179"></a>01179 
<a name="l01180"></a>01180 <span class="comment">// Precondition:</span>
<a name="l01181"></a>01181 <span class="comment">// Parametre: const double dy</span>
<a name="l01182"></a>01182 <span class="comment">// Signification: valeur a ajouter</span>
<a name="l01183"></a>01183 <span class="comment">// Valeurs par defaut:</span>
<a name="l01184"></a>01184 <span class="comment">// Contraintes:</span>
<a name="l01185"></a>01185 <span class="comment">// Acces:</span>
<a name="l01186"></a>01186 <span class="comment">// Exception:</span>
<a name="l01187"></a>01187 <span class="comment">// Effets de bord:</span>
<a name="l01188"></a>01188 <span class="comment">// Postcondition:</span>
<a name="l01189"></a>01189 <span class="comment">//</span><span class="comment"></span>
<a name="l01190"></a>01190 <span class="comment">//! ajoute la meme valeur a toutes les cases du tableau</span>
<a name="l01191"></a>01191 <span class="comment"></span><span class="comment">/** \return ArrOfDouble&lt;br&gt;</span>
<a name="l01192"></a>01192 <span class="comment">Signification: *this&lt;br&gt;</span>
<a name="l01193"></a>01193 <span class="comment">Contraintes: */</span>
<a name="l01194"></a><a class="code" href="classArrOfDouble.html#a688855b6b9ccf42e2b4f51c3ba4edc59">01194</a> <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a>&amp; <a class="code" href="classArrOfDouble.html#a2d092d5c1a7d8523c65ca2e85507fd0d" title="Addition case a case sur toutes les cases du tableau.">ArrOfDouble::operator+=</a>(<span class="keyword">const</span> <span class="keywordtype">double</span> dy)
<a name="l01195"></a>01195 {
<a name="l01196"></a>01196   <span class="keywordtype">double</span> * data = <a class="code" href="classArrOfDouble.html#a77419df7d43ac2ce76b9388a39ad90e9">data_</a>;
<a name="l01197"></a>01197   <span class="keyword">const</span> <span class="keywordtype">int</span> n = <a class="code" href="classArrOfDouble.html#a3c3b33bea0e88b87315c21ee94bee05f" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>();
<a name="l01198"></a>01198   <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i &lt; n; i++)
<a name="l01199"></a>01199     data[i] += dy;
<a name="l01200"></a>01200   <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l01201"></a>01201 }
<a name="l01202"></a>01202 <span class="comment">//</span>
<a name="l01203"></a>01203 <span class="comment">//</span>
<a name="l01204"></a>01204 <span class="comment">//</span><span class="comment"></span>
<a name="l01205"></a>01205 <span class="comment">//! Soustraction case a case sur toutes les cases du tableau&lt;br&gt;Parametre: const ArrOfDouble\&amp; y&lt;br&gt;Signification: tableau de meme taille que *this</span>
<a name="l01206"></a>01206 <span class="comment"></span><span class="comment">/** \return ArrOfDouble\&amp;&lt;br&gt;</span>
<a name="l01207"></a>01207 <span class="comment">Signification: *this */</span>
<a name="l01208"></a><a class="code" href="classArrOfDouble.html#a94cc5d4c485cc75070ec3a041288c0bd">01208</a> <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a>&amp; <a class="code" href="classArrOfDouble.html#a94cc5d4c485cc75070ec3a041288c0bd" title="Soustraction case a case sur toutes les cases du tableau Parametre: const ArrOfDouble&amp; y Significatio...">ArrOfDouble::operator-=</a>(<span class="keyword">const</span> <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a>&amp; y)
<a name="l01209"></a>01209 {
<a name="l01210"></a>01210   <span class="keyword">const</span> <span class="keywordtype">int</span> size = <a class="code" href="classArrOfDouble.html#a3c3b33bea0e88b87315c21ee94bee05f" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>();
<a name="l01211"></a>01211   assert(size == y.<a class="code" href="classArrOfDouble.html#a3c3b33bea0e88b87315c21ee94bee05f" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>());
<a name="l01212"></a>01212   <span class="keywordtype">double</span> * data = <a class="code" href="classArrOfDouble.html#a77419df7d43ac2ce76b9388a39ad90e9">data_</a>;
<a name="l01213"></a>01213   <span class="keyword">const</span> <span class="keywordtype">double</span> * data_y = y.<a class="code" href="classArrOfDouble.html#a77419df7d43ac2ce76b9388a39ad90e9">data_</a>;
<a name="l01214"></a>01214   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i &lt; size; i++)
<a name="l01215"></a>01215     data[i] -= data_y[i];
<a name="l01216"></a>01216   <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l01217"></a>01217 }
<a name="l01218"></a>01218 
<a name="l01219"></a>01219 
<a name="l01220"></a>01220 <span class="comment">//</span><span class="comment"></span>
<a name="l01221"></a>01221 <span class="comment">//! soustrait la meme valeur a toutes les cases</span>
<a name="l01222"></a>01222 <span class="comment"></span><span class="comment">/** \return ArrOfDouble \&amp;&lt;br&gt;</span>
<a name="l01223"></a>01223 <span class="comment">Signification: *this */</span>
<a name="l01224"></a><a class="code" href="classArrOfDouble.html#ae19bfdc7b46e16daa1f26333ceaa4e32">01224</a> <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a>&amp; <a class="code" href="classArrOfDouble.html#a94cc5d4c485cc75070ec3a041288c0bd" title="Soustraction case a case sur toutes les cases du tableau Parametre: const ArrOfDouble&amp; y Significatio...">ArrOfDouble::operator-=</a>(<span class="keyword">const</span> <span class="keywordtype">double</span> dy)
<a name="l01225"></a>01225 {
<a name="l01226"></a>01226   <span class="keywordtype">double</span> * data = <a class="code" href="classArrOfDouble.html#a77419df7d43ac2ce76b9388a39ad90e9">data_</a>;
<a name="l01227"></a>01227   <span class="keyword">const</span> <span class="keywordtype">int</span> n = <a class="code" href="classArrOfDouble.html#a3c3b33bea0e88b87315c21ee94bee05f" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>();
<a name="l01228"></a>01228   <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i &lt; n; i++)
<a name="l01229"></a>01229     data[i] -= dy;
<a name="l01230"></a>01230   <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l01231"></a>01231 }
<a name="l01232"></a>01232 
<a name="l01233"></a>01233 
<a name="l01234"></a>01234 <span class="comment">//</span><span class="comment"></span>
<a name="l01235"></a>01235 <span class="comment">//! muliplie toutes les cases par dy</span>
<a name="l01236"></a>01236 <span class="comment"></span><span class="comment">/** \return ArrOfDouble \&amp;&lt;br&gt;</span>
<a name="l01237"></a>01237 <span class="comment">Signification: *this */</span>
<a name="l01238"></a><a class="code" href="classArrOfDouble.html#a6ec3428662ddd818f935ffe1b6c57347">01238</a> <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a>&amp; <a class="code" href="classArrOfDouble.html#a6ec3428662ddd818f935ffe1b6c57347" title="muliplie toutes les cases par dy">ArrOfDouble::operator*= </a>(<span class="keyword">const</span> <span class="keywordtype">double</span> dy)
<a name="l01239"></a>01239 {
<a name="l01240"></a>01240   <span class="keywordtype">double</span> * data = <a class="code" href="classArrOfDouble.html#a77419df7d43ac2ce76b9388a39ad90e9">data_</a>;
<a name="l01241"></a>01241   <span class="keyword">const</span> <span class="keywordtype">int</span> n = <a class="code" href="classArrOfDouble.html#a3c3b33bea0e88b87315c21ee94bee05f" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>();
<a name="l01242"></a>01242   <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i &lt; n; i++)
<a name="l01243"></a>01243     data[i] *= dy;
<a name="l01244"></a>01244   <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l01245"></a>01245 }
<a name="l01246"></a>01246 
<a name="l01247"></a>01247 
<a name="l01248"></a>01248 <span class="comment">//</span><span class="comment"></span>
<a name="l01249"></a>01249 <span class="comment">//! divise toutes les cases par dy</span>
<a name="l01250"></a>01250 <span class="comment"></span><span class="comment">/** \return ArrOfDouble \&amp;&lt;br&gt;</span>
<a name="l01251"></a>01251 <span class="comment">Signification: *this */</span>
<a name="l01252"></a><a class="code" href="classArrOfDouble.html#a98ad403cfd1de7934a9ebd66751666c2">01252</a> <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a>&amp; <a class="code" href="classArrOfDouble.html#a98ad403cfd1de7934a9ebd66751666c2" title="divise toutes les cases par dy">ArrOfDouble::operator/= </a>(<span class="keyword">const</span> <span class="keywordtype">double</span> dy)
<a name="l01253"></a>01253 {
<a name="l01254"></a>01254   <span class="keyword">const</span> <span class="keywordtype">double</span> i_dy = 1. / dy;
<a name="l01255"></a>01255   <a class="code" href="classArrOfDouble.html#a6ec3428662ddd818f935ffe1b6c57347" title="muliplie toutes les cases par dy">operator*=</a>(i_dy);
<a name="l01256"></a>01256   <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l01257"></a>01257 }
<a name="l01258"></a>01258 
<a name="l01259"></a>01259 <span class="comment">// Precondition:</span>
<a name="l01260"></a>01260 <span class="comment">// Parametre: const ArrOfDouble&amp; dx</span>
<a name="l01261"></a>01261 <span class="comment">// Signification: premier tableau</span>
<a name="l01262"></a>01262 <span class="comment">// Valeurs par defaut:</span>
<a name="l01263"></a>01263 <span class="comment">// Contraintes:</span>
<a name="l01264"></a>01264 <span class="comment">// Acces:</span>
<a name="l01265"></a>01265 <span class="comment">// Parametre: const ArrOfDouble&amp; dy</span>
<a name="l01266"></a>01266 <span class="comment">// Signification: second tableau (obligatoirement de meme taille)</span>
<a name="l01267"></a>01267 <span class="comment">// Valeurs par defaut:</span>
<a name="l01268"></a>01268 <span class="comment">// Contraintes:</span>
<a name="l01269"></a>01269 <span class="comment">// Acces:</span>
<a name="l01270"></a>01270 <span class="comment">//</span>
<a name="l01271"></a>01271 <span class="comment">//</span>
<a name="l01272"></a>01272 <span class="comment">//</span><span class="comment"></span>
<a name="l01273"></a>01273 <span class="comment">//! Produit scalaire de deux &quot;array&quot;.&lt;br&gt;(dotproduct_array remplace operator* car le nom indique clairement&lt;br&gt;que l&#39;on fait un produit scalaire non distribue)</span>
<a name="l01274"></a>01274 <span class="comment"></span><span class="comment">/** \return double&lt;br&gt;</span>
<a name="l01275"></a>01275 <span class="comment">Signification: produit scalaire&lt;br&gt;</span>
<a name="l01276"></a>01276 <span class="comment">Contraintes: */</span>
<a name="l01277"></a><a class="code" href="ArrOfDouble_8h.html#abd508766c58c5e4a3cc52af828764909">01277</a> <span class="keywordtype">double</span> <a class="code" href="ArrOfDouble_8cpp.html#af541bfdadae7483016c96f13760598ac" title="Produit scalaire de deux &quot;array&quot;. (dotproduct_array remplace operator* car le nom indique clairemen...">dotproduct_array</a> (<span class="keyword">const</span> <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a>&amp; dx, <span class="keyword">const</span> <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a>&amp; dy)
<a name="l01278"></a>01278 {
<a name="l01279"></a>01279   <span class="keyword">const</span> <span class="keywordtype">int</span> size = dx.<a class="code" href="classArrOfDouble.html#a3c3b33bea0e88b87315c21ee94bee05f" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>();
<a name="l01280"></a>01280   assert(size == dy.<a class="code" href="classArrOfDouble.html#a3c3b33bea0e88b87315c21ee94bee05f" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>());
<a name="l01281"></a>01281   <span class="keywordtype">double</span> resultat = 0.;
<a name="l01282"></a>01282   <span class="keywordflow">if</span> (size &gt; 0)
<a name="l01283"></a>01283     {
<a name="l01284"></a>01284       <a class="code" href="arch_8h.html#a3b6ee100a473e8866bcea6d1fc4041d9">integer</a> n = size;
<a name="l01285"></a>01285       <a class="code" href="arch_8h.html#a3b6ee100a473e8866bcea6d1fc4041d9">integer</a> incx = 1;
<a name="l01286"></a>01286       resultat = <a class="code" href="arch_8h.html#a9b91c72ded7de2f0b393ea75de53929b">F77NAME</a>(DDOT)(&amp;n, dx.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>(), &amp;incx, dy.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>(), &amp;incx);
<a name="l01287"></a>01287     }
<a name="l01288"></a>01288   <span class="keywordflow">return</span> resultat;
<a name="l01289"></a>01289 }
<a name="l01290"></a>01290 
<a name="l01291"></a>01291 <span class="comment">//</span>
<a name="l01292"></a>01292 <span class="comment">//</span><span class="comment"></span>
<a name="l01293"></a>01293 <span class="comment">//! Calcul de la norme du vecteur dx (fonction blas DNRM2,&lt;br&gt;soit racine carree(somme des dx[i]*dx[i]).</span>
<a name="l01294"></a><a class="code" href="ArrOfDouble_8h.html#a2b0d50ab7d9c19468bd80ab110482d56">01294</a> <span class="comment"></span><span class="keywordtype">double</span> <a class="code" href="ArrOfDouble_8cpp.html#af3b2ac08cde80e3eadd7a83f5fd06ab7" title="Calcul de la norme du vecteur dx (fonction blas DNRM2, soit racine carree(somme des dx[i]*dx[i])...">norme_array</a>(<span class="keyword">const</span> <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a>&amp; dx)
<a name="l01295"></a>01295 {
<a name="l01296"></a>01296   <a class="code" href="arch_8h.html#a3b6ee100a473e8866bcea6d1fc4041d9">integer</a> n = dx.<a class="code" href="classArrOfDouble.html#a3c3b33bea0e88b87315c21ee94bee05f" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>();
<a name="l01297"></a>01297   <span class="keywordtype">double</span> resultat = 0.;
<a name="l01298"></a>01298   <span class="keywordflow">if</span> (n &gt; 0)
<a name="l01299"></a>01299     {
<a name="l01300"></a>01300       <a class="code" href="arch_8h.html#a3b6ee100a473e8866bcea6d1fc4041d9">integer</a> incx = 1;
<a name="l01301"></a>01301       resultat = <a class="code" href="arch_8h.html#a9b91c72ded7de2f0b393ea75de53929b">F77NAME</a>(DNRM2)(&amp;n, &amp;dx(0), &amp;incx);
<a name="l01302"></a>01302     }
<a name="l01303"></a>01303   <span class="keywordflow">return</span> resultat;
<a name="l01304"></a>01304 }
<a name="l01305"></a>01305 
<a name="l01306"></a>01306 
</pre></div></div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Tue Dec 14 2021 19:35:21 for TRUST by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
