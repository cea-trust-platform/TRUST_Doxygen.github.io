<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>TRUST: Scatter Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">TRUST&#160;<span id="projectnumber">1.8.4</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pri-methods">Private Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">Scatter Class Reference</div>  </div>
</div>
<div class="contents">
<!-- doxytag: class="Scatter" --><!-- doxytag: inherits="Interprete" -->
<p><code>#include &lt;<a class="el" href="Scatter_8h_source.html">Scatter.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Scatter:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classScatter.png" usemap="#Scatter_map" alt=""/>
  <map id="Scatter_map" name="Scatter_map">
<area href="classInterprete.html" title="Classe de base des objets &quot;interprete&quot;. Ces objets definissent des actions a realiser lorsqu&#39;on les..." alt="Interprete" shape="rect" coords="0,112,80,136"/>
<area href="classObjet__U.html" title="classe Objet_U Cette classe est la classe de base des Objets de TRUST Dans les classes derivees de Ob..." alt="Objet_U" shape="rect" coords="0,56,80,80"/>
<area href="classProcess.html" title="Classe de base de TRUST (notamment Objet_U). Elle fournit quelques services de base accessibles de pa..." alt="Process" shape="rect" coords="0,0,80,24"/>
<area href="classScatterMED.html" alt="ScatterMED" shape="rect" coords="0,224,80,248"/>
</map>
 </div></div>

<p><a href="classScatter-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScatter.html#a0e24345864dcf8d50cae40695f8daa86">~Scatter</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScatter.html#a8e06123f63d327a3f98423c4c66dd570">taille_memoire</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScatter.html#abf43b072d4e11e1eb287c991ca700fc5">duplique</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classType__info.html">Type_info</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScatter.html#aa333f78af4e89f219a6bd6af16839021">get_info</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Donne des informations sur le type de l'Objet_U.  <a href="#aa333f78af4e89f219a6bd6af16839021"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScatter.html#a97e6291a932815a6cafbed40d6c98c4a">Scatter</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEntree.html">Entree</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScatter.html#ada2699448b4deae55f43998af585d603">interpreter</a> (<a class="el" href="classEntree.html">Entree</a> &amp;)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Lit et complete un domaine parallele selon les motcles lus<br/>
dans le jeu de donnees. Format:<br/>
<a class="el" href="classScatter.html">Scatter</a> [debug] file_name domain_name<br/>
On lit les sommets, les elements et les sommets et faces de joint,<br/>
On construit les espaces distants et virtuels en fonction<br/>
de l'epaisseur de joint.  <a href="#ada2699448b4deae55f43998af585d603"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScatter.html#a0c740e8b05e31947a4f49d630f1302ec">lire_domaine</a> (<a class="el" href="classNom.html">Nom</a> &amp;, <a class="el" href="classNoms.html">Noms</a> &amp;liste_bords_periodiques)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Lit le domaine dans le fichier de nom "nomentree",<br/>
de type <a class="el" href="classLecFicDistribueBin.html" title="Lecture dans un fichier au format binaire. Cette classe implemente les operateurs et les methodes vir...">LecFicDistribueBin</a> ou <a class="el" href="classLecFicDistribue.html" title="Cette classe implemente les operateurs et les methodes virtuelles de la classe EFichier de la facon s...">LecFicDistribue</a><br/>
Format attendu : Domaine::ReadOn<br/>
La zone est renommee comme le domaine (pour lance_test_seq_par)  <a href="#a0c740e8b05e31947a4f49d630f1302ec"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDomaine.html">Domaine</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScatter.html#ac33aacdb609dcc870faeb93500ed017f">domaine</a> ()</td></tr>
<tr><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classObjet__U.html">Objet_U</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScatter.html#a002db6ff87448cb33d80b0e2158652a6">cree_instance</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classType__info.html">Type_info</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScatter.html#a131b9467aadcab7a960ceb68d05c9a08">info</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Donne des informations sur le type de l'Objet_U.  <a href="#a131b9467aadcab7a960ceb68d05c9a08"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classScatter.html">Scatter</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScatter.html#aff07c916d6e09f9338ba4057c9e075bb">self_cast</a> (<a class="el" href="classObjet__U.html">Objet_U</a> &amp;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classScatter.html">Scatter</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScatter.html#ad9d737e018e92e9424e07ef55642df9b">self_cast</a> (const <a class="el" href="classObjet__U.html">Objet_U</a> &amp;)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">methode ajoutee pour caster en python  <a href="#ad9d737e018e92e9424e07ef55642df9b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScatter.html#a16a9000e31ccecd2438c8f05e41cc302">Chercher_Correspondance</a> (const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;sommets1, const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;sommets2, <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;correspondance, const double epsilon)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Construit le tableau "correspondance" tel que<br/>
Pour 0 &lt;= i &lt; sommets2.size_array(),<br/>
Si sommet2(i) existe dans le tableau sommet1, alors<br/>
sommets2(i, ...) == sommets1(correspondance[i], ...)<br/>
Sinon<br/>
correspondance[i] = -1<br/>
L'egalite est verifiee a epsilon pres en absolu (soit abs(x1-x2)&lt;epsilon)<br/>
L'algorithme est generalement en n1*log(n1) + n2*log(n1)<br/>
(recherche basee sur un quicksort).<br/>
En cas d'echec du tri, on utilise un algorithme en n1*n2.<br/>
Les tableaux sommets1 et sommets2 doivent etre de dimension 2<br/>
Le tableau correspondance doit etre de taille sommets2.size_array().<br/>
Valeur de retour: nombre de sommets de sommets2 non trouves dans le tableau sommets1.  <a href="#a16a9000e31ccecd2438c8f05e41cc302"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScatter.html#acafac38fc2983e19398c403a9235bb4c">construire_correspondance_sommets_par_coordonnees</a> (<a class="el" href="classDomaine.html">Domaine</a> &amp;dom)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Construction des tableaux joint_item(Joint::SOMMET).items_communs de tous les joints de la zone(0) du domaine dom.  <a href="#acafac38fc2983e19398c403a9235bb4c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScatter.html#a12daf3ea958d39cbeb04c87ec60369f7">construire_correspondance_aretes_par_coordonnees</a> (<a class="el" href="classZone__VF.html">Zone_VF</a> &amp;zvf)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScatter.html#a06ae2df37becb17fe4e7b2e8c9c07cbd">construire_correspondance_items_par_coordonnees</a> (<a class="el" href="classJoints.html">Joints</a> &amp;joints, const <a class="el" href="classJoint.html#a1e2d15d088c27c9b7b11c02bf4d2c926">Joint::Type_Item</a> type_item, const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;coord_items)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Methode obsolete (utilisee avec l'ancien decoupeur).<br/>
On suppose que le domaine contient les structures suivantes:<br/>
* zone(0).faces_joint[i].sommets() (les sommets de joint isoles)<br/>
* zone(0).faces_joint[i].faces().les_sommets (les sommets des faces de joint)<br/>
et que chaque processeur contient une portion d'un domaine complet.<br/>
On remplit les tableaux joint_item(Joint::Type_Item).items_communs pour tous les joints de la<br/>
zone 0 du domaine et renum_items_communs.<br/>
Ordre d'apparition des items : ordre croissant de l'indice du<br/>
sommet sur le processeur de rang le plus petit<br/>
Cette methode doit etre appelee simultanement sur tous les processeurs<br/>
du groupe et ne s'applique qu'aux items ARETE et SOMMET<br/>
L'algorithme utilise les coordonnees des items pour retrouver la<br/>
correspondance entre les items de joint.  <a href="#a06ae2df37becb17fe4e7b2e8c9c07cbd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScatter.html#af6b88297583bd92c6ca3814bc532b8be">construire_structures_paralleles</a> (<a class="el" href="classDomaine.html">Domaine</a> &amp;dom, const <a class="el" href="classNoms.html">Noms</a> &amp;liste_bords_perio)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Construction des structures paralleles du domaine et de la zone<br/>
(determination des elements distants en fonction de l'epaisseur de joint,<br/>
determination des sommets distants,<br/>
creation des sommets et des elements virtuels)  <a href="#af6b88297583bd92c6ca3814bc532b8be"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScatter.html#aa160f8c25dcf4bf1aa2cd9ead7cf51e3">calculer_espace_distant</a> (<a class="el" href="classZone.html">Zone</a> &amp;zone, const int nb_items_reels, const <a class="el" href="classVect__ArrOfInt.html">Vect_ArrOfInt</a> &amp;items_to_send, const <a class="el" href="classJoint.html#a1e2d15d088c27c9b7b11c02bf4d2c926">Joint::Type_Item</a> type_item)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Determination des items distants en fonction d'une liste d'items<br/>
a envoyer et de listes d'items communs.<br/>
exemple:<br/>
calculer_espace_distant_sommets<br/>
calculer_espace_distant_faces<br/>
Pour les sommets: les "items_to_send" sont les sommets des elements distants,<br/>
Si le processeur A veut que le processeur B connaisse le sommet i,<br/>
il faut que le processeur qui possede le sommet l'envoie a B.<br/>
Le processeur qui "possede" le sommet est le plus petit parmi les PEs<br/>
qui partagent ce sommet (item commun) (requis pour pouvoir faire<br/>
echange_item_commun et echange_espace_virtuel en une seule passe).<br/>
De plus, si plusieurs processeurs demandent a envoyer le meme sommet<br/>
au meme processeur, il ne faut l'inserer qu'une seule fois dans l'espace<br/>
distant.<br/>
Parametre: joints<br/>
Signification: les joints dans lesquels on veut calculer un espace distant<br/>
Parametre: nb_items_reels<br/>
Signification: le nombre d'items reels (sommets, faces, ...)<br/>
Parametre: items_to_send<br/>
Signification: un vecteur de "nproc()" tableaux, pour chaque processeur,<br/>
la liste des items qu'on veut lui envoyer (exemple:tous les sommets des<br/>
elements distants, ou toutes les faces)<br/>
Parametre: type_item<br/>
Signification: les items dont on veut calculer l'espace distant.  <a href="#aa160f8c25dcf4bf1aa2cd9ead7cf51e3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScatter.html#ab8e91081aefb68562533279f2446e988">calculer_nb_items_virtuels</a> (<a class="el" href="classJoints.html">Joints</a> &amp;joints, const <a class="el" href="classJoint.html#a1e2d15d088c27c9b7b11c02bf4d2c926">Joint::Type_Item</a> type_item)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">!&lt; Description Pour un item geometrique "type_item", remplit le champ nb_items_virtuels_ des joints en fonction du nombre d'items distants : Le nombre d'items virtuels sur un joint i du processeur j est le nombre d'items distants du joint j sur le processeur i.  <a href="#ab8e91081aefb68562533279f2446e988"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScatter.html#a21f166c05df9be1fc1f02b0604624fe5">calculer_renum_items_communs</a> (<a class="el" href="classJoints.html">Joints</a> &amp;joints, const <a class="el" href="classJoint.html#a1e2d15d088c27c9b7b11c02bf4d2c926">Joint::Type_Item</a> type_item)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">On suppose que chaque joint[i].joint_item(type_item).items_communs()<br/>
contient les indices locaux des items de joint communs dans le meme<br/>
ordre sur les deux processeurs (local et voisin)<br/>
On remplit renum_items_communs :<br/>
colonne 0=contenu du tableau items_communs sur le PE voisin<br/>
colonne 1=contenu du tableau items_communs sur le PE local.  <a href="#a21f166c05df9be1fc1f02b0604624fe5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScatter.html#af8e062885ea7bbeaffb320e7f718e282">calculer_espace_distant_faces</a> (<a class="el" href="classZone.html">Zone</a> &amp;zone, const int nb_faces_reelles, const <a class="el" href="classIntTab.html">IntTab</a> &amp;elem_faces)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Idem que <a class="el" href="classScatter.html#a9cbfa7bf4fe3b741a56309931f4cf752" title="En fonction de l&#39;espace distant des elements, calcule l&#39;espace distant des sommets. Pour chaque joint, on envoie au processeur voisin l&#39;ensemble des sommets de tous les elements du joint. C&#39;est le processeur proprietaire du sommet&lt;br&gt;(plus petit pe qui le possede) qui le met dans son espace distant. Attention, on cree de nouveaux joints. On remplit les tableaux dom.zone(0).faces_joint(i).joint_item(Joint::SOMMET).items_distants();.">Scatter::calculer_espace_distant_sommets</a> pour les faces.  <a href="#af8e062885ea7bbeaffb320e7f718e282"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScatter.html#a340353829751017d210326537f662b68">calculer_espace_distant_aretes</a> (<a class="el" href="classZone.html">Zone</a> &amp;zone, const int nb_aretes_reelles, const <a class="el" href="classIntTab.html">IntTab</a> &amp;elem_aretes)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Idem que <a class="el" href="classScatter.html#a9cbfa7bf4fe3b741a56309931f4cf752" title="En fonction de l&#39;espace distant des elements, calcule l&#39;espace distant des sommets. Pour chaque joint, on envoie au processeur voisin l&#39;ensemble des sommets de tous les elements du joint. C&#39;est le processeur proprietaire du sommet&lt;br&gt;(plus petit pe qui le possede) qui le met dans son espace distant. Attention, on cree de nouveaux joints. On remplit les tableaux dom.zone(0).faces_joint(i).joint_item(Joint::SOMMET).items_distants();.">Scatter::calculer_espace_distant_sommets</a> pour les aretes.  <a href="#a340353829751017d210326537f662b68"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScatter.html#a589c34e38a91b69c2e4b43c77bf2bd9d">calculer_espace_distant_elements</a> (<a class="el" href="classDomaine.html">Domaine</a> &amp;dom)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Remplissage du tableau "espace_distant()" des elements dans les joints.<br/>
C'est ici qu'on determine les elements de joint en fonction de l'epaisseur de joint.<br/>
Le tableau espace_distant contient les<br/>
indices locaux des elements distants (a envoyer aux processeurs voisins)<br/>
Pour un joint d'epaisseur 1, ce sont tous les elements voisins d'un<br/>
sommet de joint (sommet sur un face de joint ou sommet isole).<br/>
Pour un joint d'epaisseur n&gt;1, ce sont tous les elements voisins d'un<br/>
sommet d'un element du joint d'epaisseur n-1.<br/>
Le voisinage s'entend sur le domaine global (toutes zones confondues)<br/>
Historique: premiere version B.Mathieu le 16/01/2007.<br/>
Il existe une methode qui determine les elements distants au moment du decoupage&lt;br&gt;(DomaineCutter::construire_elements_distants_ssdom).<br/>
La methode ci-dessous a ete validee par comparaison avec la methode du decoupeur.<br/>
Les sorties ont ete verifiees pour des epaisseurs jusqu'a 5 sur des maillages tetra.<br/>
La difficulte de l'algorithme est d'obtenir les elements virtuels d'epaisseur &gt; 1 qui se<br/>
trouvent sur des sous-domaines qui ne sont pas en contact direct avec le sous-domaine<br/>
local. Difficulte resolue par l'algorithme ci-dessous.  <a href="#a589c34e38a91b69c2e4b43c77bf2bd9d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScatter.html#a07723d3697739057d469082a4c4a554f">corriger_espace_distant_elements_perio</a> (<a class="el" href="classDomaine.html">Domaine</a> &amp;dom, const <a class="el" href="classNoms.html">Noms</a> &amp;liste_bords_periodiques)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Les algorithmes actuels pour le periodique (assembleur P1B, OpDivElem P1B)<br/>
ont besoin que pour chaque face virtuelle periodique, la face opposee soit<br/>
aussi virtuelle. Ceci n'est pas assure a la sortie de la methode<br/>
calculer_elements_distants. Cette methode ajoute aux elements distants les<br/>
elements manquants pour assurer cette condition:<br/>
Si un element est distant pour un PE donne est voisin d'une face periodique,<br/>
on ajoute a l'espace distant l'element adjacent a la face opposee.  <a href="#a07723d3697739057d469082a4c4a554f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScatter.html#a9cbfa7bf4fe3b741a56309931f4cf752">calculer_espace_distant_sommets</a> (<a class="el" href="classDomaine.html">Domaine</a> &amp;dom, const <a class="el" href="classNoms.html">Noms</a> &amp;liste_bords_periodiques)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">En fonction de l'espace distant des elements, calcule l'espace<br/>
distant des sommets. Pour chaque joint, on envoie au processeur voisin<br/>
l'ensemble des sommets de tous les elements du joint.<br/>
C'est le processeur proprietaire du sommet&lt;br&gt;(plus petit pe qui le possede) qui le met dans son espace distant.<br/>
Attention, on cree de nouveaux joints.<br/>
On remplit les tableaux<br/>
dom.zone(0).faces_joint(i).joint_item(Joint::SOMMET).items_distants();.  <a href="#a9cbfa7bf4fe3b741a56309931f4cf752"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScatter.html#a33c68e7eff97ee92b457b50e8e3ad58d">construire_espace_virtuel_traduction</a> (const <a class="el" href="classMD__Vector.html">MD_Vector</a> &amp;md_indice, const <a class="el" href="classMD__Vector.html">MD_Vector</a> &amp;md_valeur, <a class="el" href="classIntTab.html">IntTab</a> &amp;tableau, const int error_is_fatal=1)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Construit la structure items_communs + espaces virtuels d'un tableau contenant<br/>
des indices d'items geometriques, indexe par un autre type d'item geometrique.<br/>
Exemple: tableau indexe par md_indice, contenant des indices md_valeur:<br/>
type_indice type_valeur exemple de tableau:<br/>
element sommet zone.les_elems()<br/>
face sommet faces_sommets<br/>
element face elem_faces<br/>
face element faces_voisins<br/>
element element ?<br/>
element arete elem_aretes<br/>
Nb_valeurs_max est le nombre d'items reels de type "type_valeur".  <a href="#a33c68e7eff97ee92b457b50e8e3ad58d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScatter.html#a0a86d55709f7e53fcf40a09de74033cf">reordonner_faces_de_joint</a> (<a class="el" href="classDomaine.html">Domaine</a> &amp;dom)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Reordonne les faces de joint de sorte qu'elles apparaissent dans le meme<br/>
ordre sur chaque couple de processeur voisin. En pratique, pour un couple<br/>
pe1 &lt; pe2, pe1 envoie ses faces de joint a pe2 et pe2 les traduit en indices<br/>
de sommets locaux. Les faces de joint du PE2 ne sont donc pas utilisees.  <a href="#a0a86d55709f7e53fcf40a09de74033cf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScatter.html#a472e9375c5a64518e7b50542d2209995">ajouter_joints</a> (<a class="el" href="classZone.html">Zone</a> &amp;zone, <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;pe_voisins)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Ajoute des joints avec tous les pe de pe_voisins.<br/>
Pour que l'ensemble des joints soit symetrique,<br/>
on en cree aussi un joint sur le processeur destination:<br/>
Si A ajoute un joint avec B, alors B ajoute un joint avec A.<br/>
On trie les joints par ordre croissant du numero de PE.<br/>
ATTENTION: les joints sont donc reordonnes !<br/>
On met dans pe_voisins la liste des joints effectivement crees.  <a href="#a472e9375c5a64518e7b50542d2209995"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScatter.html#ac5dd6d7661490708649976cde509f480">trier_les_joints</a> (<a class="el" href="classJoints.html">Joints</a> &amp;joints)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Tri des joints dans l'ordre croissant des processeurs.  <a href="#ac5dd6d7661490708649976cde509f480"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScatter.html#ae226bc9cab92d0a02b88e2fe014e4a44">construire_md_vector</a> (const <a class="el" href="classDomaine.html">Domaine</a> &amp;, int nb_items_reels, const <a class="el" href="classJoint.html#a1e2d15d088c27c9b7b11c02bf4d2c926">Joint::Type_Item</a>, <a class="el" href="classMD__Vector.html">MD_Vector</a> &amp;)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">construction d'un <a class="el" href="classMD__Vector__std.html" title="C&#39;est le plus simple des descripteurs, utilise pour les tableaux de valeurs aux sommets, elements, faces, aretes, faces de bord, etc... Il supporte la notion d&#39;items &quot;communs&quot; (sommets du maillage partages entre plusieurs processeurs) et d&#39;items &quot;distants&quot; et &quot;virtuels&quot; (sommets, elements dans l&#39;epaisseur de joint). Voir aussi MD_Vector_composite (descripteur compose d&#39;une reunion de plusieurs descripteurs, pour le P1Bulle par exemple)">MD_Vector_std</a> a partir des informations de joint du domaine<br/>
pour le type d'item demande.  <a href="#ae226bc9cab92d0a02b88e2fe014e4a44"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScatter.html#a1874139ffd29d5a68191bc7828d3a5bd">init_sequential_domain</a> (<a class="el" href="classDomaine.html">Domaine</a> &amp;)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">cree des descripteurs sequentiels pour les tableaux sommets<br/>
et elements du domaine (necessaire car <a class="el" href="classScatter.html">Scatter</a> n'est pas appele pour les<br/>
domaines en sequentiel)  <a href="#a1874139ffd29d5a68191bc7828d3a5bd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScatter.html#a8cf934a9b5f7ecb7ef89f61c09804f45">uninit_sequential_domain</a> (<a class="el" href="classDomaine.html">Domaine</a> &amp;)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">methode utilisee par les interpretes qui modifient le domaine&lt;br&gt;(sequentiel), detruit les descripteurs des sommets et elements pour permettre<br/>
la modification de ces tableaux.  <a href="#a8cf934a9b5f7ecb7ef89f61c09804f45"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScatter.html#a86c9311713284ed6591da95c7eb9411d">check_consistancy_remote_items</a> (<a class="el" href="classDomaine.html">Domaine</a> &amp;dom, const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;mergedZones)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Merged zones receive joints information from their neighbours<br/>
to ensure that their common items (vertices) appear in the same order<br/>
If it's not the case, the merged zone reorders its common items so that it matches the neighbour's order<br/>
When 2 neighbouring zones have each been merged,<br/>
only the processor with the lowest rank proceeds to reordering.  <a href="#a86c9311713284ed6591da95c7eb9411d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScatter.html#ad8cdf7a8e4ad0065e9c3e1351aec8a1b">readDomainWithoutCollComm</a> (<a class="el" href="classDomaine.html">Domaine</a> &amp;dom, <a class="el" href="classEntree.html">Entree</a> &amp;fic)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Does the exact same thing as the readOn of the class <a class="el" href="classDomaine.html" title="Classe Domaine Un Domaine represente le domaine (spatial) de resolution d&#39;un Probleme. Un Domaine a un Nom, il est constitue d&#39;une ou plusieurs Zone qui peuvent etre eventuellement decoupees en Sous_Zone. Un Domaine porte l&#39;ensemble des sommets utilises par ses Zones. On peut vouloir resoudre des problemes de type different sur plusieurs domaines, geometriquement les domaines sont alors couples par des surfaces qu&#39;on appelle Raccord.">Domaine</a><br/>
but without collective communication<br/>
Necessary when the processors don't have the same numbers of file to read.  <a href="#ad8cdf7a8e4ad0065e9c3e1351aec8a1b"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classType__info.html">Type_info</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScatter.html#a0f6e0e8a9794242ad98d6fb3dbd670dc">info_obj</a></td></tr>
<tr><td colspan="2"><h2><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classSortie.html">Sortie</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScatter.html#a9e06b9a31bb668cffc13a5e817272345">printOn</a> (<a class="el" href="classSortie.html">Sortie</a> &amp;x) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classSimple.html">Simple</a> appel a: <a class="el" href="classInterprete.html#a822d9b5447b696582ad3fab3e15e72fb" title="Ecriture de l&#39;objet sur un flot de sortie Methode a surcharger.">Interprete::printOn</a>(<a class="el" href="classSortie.html" title="Classe de base des flux de sortie. Elle sait ecrire des types simples&lt;br&gt;(entiers, flottants) et des Ob...">Sortie</a>&amp;)  <a href="#a9e06b9a31bb668cffc13a5e817272345"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classEntree.html">Entree</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScatter.html#ad7c35f0d98c6d4de8511f87743fe5dbc">readOn</a> (<a class="el" href="classEntree.html">Entree</a> &amp;)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classSimple.html">Simple</a> appel a: <a class="el" href="classInterprete.html#ab6030ea24bc88c367b753eb89c2b0439" title="Lecture d&#39;un Objet_U sur un flot d&#39;entree Methode a surcharger.">Interprete::readOn</a>(<a class="el" href="classEntree.html" title="Classe de definition des operateurs et methodes pour toute lecture dans un flot d&#39;entree (fichier...">Entree</a>&amp;)  <a href="#ad7c35f0d98c6d4de8511f87743fe5dbc"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRef__Domaine.html">Ref_Domaine</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScatter.html#a82a0e561610415e2f6c5615846a96f87">le_domaine</a></td></tr>
<tr><td colspan="2"><h2><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScatter.html#ace98ccb7d5fd754b2ae527ce96876977">mergeDomains</a> (<a class="el" href="classDomaine.html">Domaine</a> &amp;dom, <a class="el" href="classDomaine.html">Domaine</a> &amp;part_dom)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Merging dom_to_add with dom.  <a href="#ace98ccb7d5fd754b2ae527ce96876977"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock">
<p>Definition at line <a class="el" href="Scatter_8h_source.html#l00035">35</a> of file <a class="el" href="Scatter_8h_source.html">Scatter.h</a>.</p>
</div><hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a0e24345864dcf8d50cae40695f8daa86"></a><!-- doxytag: member="Scatter::~Scatter" ref="a0e24345864dcf8d50cae40695f8daa86" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Scatter::~Scatter </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Scatter_8cpp_source.html#l00051">51</a> of file <a class="el" href="Scatter_8cpp_source.html">Scatter.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a97e6291a932815a6cafbed40d6c98c4a"></a><!-- doxytag: member="Scatter::Scatter" ref="a97e6291a932815a6cafbed40d6c98c4a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Scatter::Scatter </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Scatter_8cpp_source.html#l00052">52</a> of file <a class="el" href="Scatter_8cpp_source.html">Scatter.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{}
</pre></div>
</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a472e9375c5a64518e7b50542d2209995"></a><!-- doxytag: member="Scatter::ajouter_joints" ref="a472e9375c5a64518e7b50542d2209995" args="(Zone &amp;zone, ArrOfInt &amp;pe_voisins)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Scatter::ajouter_joints </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classZone.html">Zone</a> &amp;&#160;</td>
          <td class="paramname"><em>zone</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>pe_voisins</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Ajoute des joints avec tous les pe de pe_voisins.<br/>
Pour que l'ensemble des joints soit symetrique,<br/>
on en cree aussi un joint sur le processeur destination:<br/>
Si A ajoute un joint avec B, alors B ajoute un joint avec A.<br/>
On trie les joints par ordre croissant du numero de PE.<br/>
ATTENTION: les joints sont donc reordonnes !<br/>
On met dans pe_voisins la liste des joints effectivement crees. </p>

<p>Definition at line <a class="el" href="Scatter_8cpp_source.html#l01151">1151</a> of file <a class="el" href="Scatter_8cpp_source.html">Scatter.cpp</a>.</p>

<p>References <a class="el" href="Scatter_8cpp_source.html#l00848">ajouter_joint()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00355">ArrOfInt::append_array()</a>, <a class="el" href="Scatter_8cpp_source.html#l00806">array_retirer_elements()</a>, <a class="el" href="Scatter_8cpp_source.html#l00778">array_trier_retirer_doublons()</a>, <a class="el" href="Zone_8h_source.html#l01098">Zone::faces_joint()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00240">ArrOfInt::resize_array()</a>, <a class="el" href="communications_8cpp_source.html#l00561">reverse_send_recv_pe_list()</a>, <a class="el" href="ArrOfInt_8cpp_source.html#l00443">ArrOfInt::set_smart_resize()</a>, <a class="el" href="liste_8cpp_source.html#l00175">liste::size()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00342">ArrOfInt::size_array()</a>, and <a class="el" href="Scatter_8cpp_source.html#l00752">trier_les_joints()</a>.</p>

<p>Referenced by <a class="el" href="Scatter_8cpp_source.html#l00937">calculer_espace_distant()</a>, and <a class="el" href="Scatter_8cpp_source.html#l02184">calculer_espace_distant_elements()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <a class="code" href="classJoints.html" title="Classe Joints Cette classe represente une liste d&#39;objet de type Joint.">Joints</a>&amp; joints = zone.<a class="code" href="classZone.html#a16f273a76321d31435995cdad664285a" title="Renvoie la liste des joints de la zone. (version const)">faces_joint</a>();
  <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> liste_pe;
  pe_voisins.<a class="code" href="classArrOfInt.html#a22d744bcd452d039580d1d9186f02b4e" title="Change le mode l&#39;allocation memoire: reallocation d&#39;un tableau a chaque changement de taille (flag = ...">set_smart_resize</a>(1);
  liste_pe.<a class="code" href="classArrOfInt.html#a22d744bcd452d039580d1d9186f02b4e" title="Change le mode l&#39;allocation memoire: reallocation d&#39;un tableau a chaque changement de taille (flag = ...">set_smart_resize</a>(1);
<span class="comment">// Rendre les joints symetriques (si A-&gt;B alors B-&gt;A) :</span>
  {
<span class="comment">// On met dans liste pe la &quot;transposee&quot; de la liste des pe_voisins:</span>
<span class="comment">// liste des processeurs chez qui mon numero est dans &quot;pe_voisins&quot;.</span>
    <a class="code" href="communications_8cpp.html#a38c9e2f958081bff6f390b56ec939523" title="Calcule la transposee d&#39;une liste de processeurs: On construit le tableau dest_list tel que: x est da...">reverse_send_recv_pe_list</a>(pe_voisins, liste_pe);
    <span class="keyword">const</span> <span class="keywordtype">int</span> n = liste_pe.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>();
<span class="comment">// On concatene les deux listes.</span>
    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; n; i++)
      pe_voisins.<a class="code" href="classArrOfInt.html#a3f39d0966599416e7b1f7cd8159d8d01" title="Ajoute une case en fin de tableau et y stocke la &quot;valeur&quot;.">append_array</a>(liste_pe[i]);
    <a class="code" href="Scatter_8cpp.html#a23c4d19dc90caae2323f04de90621709" title="Methode outil pour retirer les doublons dans un tableau.">array_trier_retirer_doublons</a>(pe_voisins);
    liste_pe.<a class="code" href="classArrOfInt.html#a9b3afbb46b16870dbd36236c8935b535">resize_array</a>(0);
  }
<span class="comment">// On retire de pe_voisins les pe pour lesquels un joint existe deja</span>
  {
    <span class="keyword">const</span> <span class="keywordtype">int</span> n = joints.<a class="code" href="classliste.html#ab47f280662ff68f9aa2e00e50431c5dc" title="Renvoie la taille de la liste Une liste vide est de taille nulle.">size</a>();
    liste_pe.<a class="code" href="classArrOfInt.html#a9b3afbb46b16870dbd36236c8935b535">resize_array</a>(n);
    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; n; i++)
      liste_pe[i] = joints[i].PEvoisin();
    <a class="code" href="Scatter_8cpp.html#ab0ae6267baccb3a639f4a8ff795edd35" title="Retire de &quot;sorted_array&quot; les elements qui figurent dans &quot;sorted_elements&quot;. Les deux tableaux doiv...">array_retirer_elements</a>(pe_voisins, liste_pe);
  }
<span class="comment">// Ajouter les nouveaux joints et trier par ordre croissant</span>
<span class="comment">// Aujourd&#39;hui (2/11/2005) Liste::inserer ne permet pas d&#39;inserer</span>
<span class="comment">// en debut de liste. Donc inutilisable. Methode bourrin:</span>
  {
    <span class="keyword">const</span> <span class="keywordtype">int</span> n = pe_voisins.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>();
    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; n; i++)
      <a class="code" href="Scatter_8cpp.html#aad63bf1e3d986487b1fa8bc7e482c368">ajouter_joint</a>(zone, pe_voisins[i]);
    <a class="code" href="classScatter.html#ac5dd6d7661490708649976cde509f480" title="Tri des joints dans l&#39;ordre croissant des processeurs.">trier_les_joints</a>(joints);
  }
}
</pre></div>
</div>
</div>
<a class="anchor" id="aa160f8c25dcf4bf1aa2cd9ead7cf51e3"></a><!-- doxytag: member="Scatter::calculer_espace_distant" ref="aa160f8c25dcf4bf1aa2cd9ead7cf51e3" args="(Zone &amp;zone, const int nb_items_reels, const Vect_ArrOfInt &amp;items_to_send, const Joint::Type_Item type_item)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Scatter::calculer_espace_distant </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classZone.html">Zone</a> &amp;&#160;</td>
          <td class="paramname"><em>zone</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>nb_items_reels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVect__ArrOfInt.html">Vect_ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>items_to_send</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classJoint.html#a1e2d15d088c27c9b7b11c02bf4d2c926">Joint::Type_Item</a>&#160;</td>
          <td class="paramname"><em>type_item</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Determination des items distants en fonction d'une liste d'items<br/>
a envoyer et de listes d'items communs.<br/>
exemple:<br/>
calculer_espace_distant_sommets<br/>
calculer_espace_distant_faces<br/>
Pour les sommets: les "items_to_send" sont les sommets des elements distants,<br/>
Si le processeur A veut que le processeur B connaisse le sommet i,<br/>
il faut que le processeur qui possede le sommet l'envoie a B.<br/>
Le processeur qui "possede" le sommet est le plus petit parmi les PEs<br/>
qui partagent ce sommet (item commun) (requis pour pouvoir faire<br/>
echange_item_commun et echange_espace_virtuel en une seule passe).<br/>
De plus, si plusieurs processeurs demandent a envoyer le meme sommet<br/>
au meme processeur, il ne faut l'inserer qu'une seule fois dans l'espace<br/>
distant.<br/>
Parametre: joints<br/>
Signification: les joints dans lesquels on veut calculer un espace distant<br/>
Parametre: nb_items_reels<br/>
Signification: le nombre d'items reels (sommets, faces, ...)<br/>
Parametre: items_to_send<br/>
Signification: un vecteur de "nproc()" tableaux, pour chaque processeur,<br/>
la liste des items qu'on veut lui envoyer (exemple:tous les sommets des<br/>
elements distants, ou toutes les faces)<br/>
Parametre: type_item<br/>
Signification: les items dont on veut calculer l'espace distant. </p>

<p><p>&lt; Indice du item distant</p>
<p>&lt; Numero du pe a qui il faut envoyer le item </p>
</p>

<p>Definition at line <a class="el" href="Scatter_8cpp_source.html#l00937">937</a> of file <a class="el" href="Scatter_8cpp_source.html">Scatter.cpp</a>.</p>

<p>References <a class="el" href="Scatter_8cpp_source.html#l01151">ajouter_joints()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00355">ArrOfInt::append_array()</a>, <a class="el" href="Scatter_8cpp_source.html#l00806">array_retirer_elements()</a>, <a class="el" href="Scatter_8cpp_source.html#l00778">array_trier_retirer_doublons()</a>, <a class="el" href="Schema__Comm_8cpp_source.html#l00166">Schema_Comm::begin_comm()</a>, <a class="el" href="Scatter_8cpp_source.html#l02864">calculer_nb_items_virtuels()</a>, <a class="el" href="IntTab_8h_source.html#l00233">IntTab::dimension()</a>, <a class="el" href="Schema__Comm_8cpp_source.html#l00380">Schema_Comm::echange_taille_et_messages()</a>, <a class="el" href="Schema__Comm_8cpp_source.html#l00430">Schema_Comm::end_comm()</a>, <a class="el" href="Entree_8cpp_source.html#l00549">Entree::eof()</a>, <a class="el" href="Zone_8h_source.html#l01098">Zone::faces_joint()</a>, <a class="el" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>, <a class="el" href="Joint_8cpp_source.html#l00186">Joint::joint_item()</a>, <a class="el" href="Process_8cpp_source.html#l00345">Process::Journal()</a>, <a class="el" href="Process_8cpp_source.html#l00117">Process::me()</a>, <a class="el" href="Process_8cpp_source.html#l00109">Process::nproc()</a>, <a class="el" href="ArrOfInt_8cpp_source.html#l00897">ArrOfInt::ordonne_array()</a>, <a class="el" href="Joint_8cpp_source.html#l00099">Joint::PEvoisin()</a>, <a class="el" href="Schema__Comm_8cpp_source.html#l00494">Schema_Comm::recv_buffer()</a>, <a class="el" href="Joint__Items_8cpp_source.html#l00104">Joint_Items::renum_items_communs()</a>, <a class="el" href="Schema__Comm_8cpp_source.html#l00477">Schema_Comm::send_buffer()</a>, <a class="el" href="Joint__Items_8cpp_source.html#l00073">Joint_Items::set_items_distants()</a>, <a class="el" href="Joint_8cpp_source.html#l00159">Joint::set_joint_item()</a>, <a class="el" href="Schema__Comm_8cpp_source.html#l00146">Schema_Comm::set_send_recv_pe_list()</a>, <a class="el" href="ArrOfInt_8cpp_source.html#l00443">ArrOfInt::set_smart_resize()</a>, <a class="el" href="liste_8cpp_source.html#l00175">liste::size()</a>, <a class="el" href="IntVect_8h_source.html#l00139">IntVect::size()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00342">ArrOfInt::size_array()</a>, and <a class="el" href="Vect_8h_source.html#l00026">VECT</a>.</p>

<p>Referenced by <a class="el" href="Scatter_8cpp_source.html#l01219">calculer_espace_distant_item()</a>.</p>
<div class="fragment"><pre class="fragment">{
  assert(items_to_send.<a class="code" href="classvect__impl.html#a78155bfbd6b61f4710b9830641ed1694">size</a>() == <a class="code" href="classProcess.html#a6bf692ce58d9578aa62ac3c07b8caaa1" title="renvoie le nombre de processeurs dans le groupe courant Voir Comm_Group::nproc() et PE_Groups::curren...">Process::nproc</a>());

  <a class="code" href="classProcess.html#a57e0f54b11e6eaadbea224fa904b18dd" title="Renvoie un objet statique de type Sortie qui sert de journal d&#39;evenements. Si message_level &lt;= verbose...">Process::Journal</a>() &lt;&lt; <span class="stringliteral">&quot;Scatter::calculer_espace_distant type_item=&quot;</span>
                     &lt;&lt; (int)type_item &lt;&lt; finl;

  <a class="code" href="classJoints.html" title="Classe Joints Cette classe represente une liste d&#39;objet de type Joint.">Joints</a>&amp; joints = zone.<a class="code" href="classZone.html#a16f273a76321d31435995cdad664285a" title="Renvoie la liste des joints de la zone. (version const)">faces_joint</a>();

<span class="comment">// D&#39;abord, on determine pour tous les items le numero du PE proprietaire:</span>
<span class="comment">// Pour chaque item du domaine:</span>
<span class="comment">// colonne 0 : indice du item sur le PE proprietaire (index_on_pe_owner)</span>
<span class="comment">// colonne 1 : numero du PE proprietaire (le plus petit pe qui partage l&#39;item)</span>
  <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a> num_global_items(nb_items_reels, 2);
  {
    <span class="keywordtype">int</span> i;
    <span class="keyword">const</span> <span class="keywordtype">int</span> moi = <a class="code" href="classProcess.html#ab55ba07167ec807ed3a145cac0f5dca4" title="renvoie mon rang dans le groupe de communication courant. Voir Comm_Group::rank() et PE_Groups::curre...">Process::me</a>();
    <span class="keywordflow">for</span> (i = 0; i &lt; nb_items_reels; i++)
      {
        num_global_items(i, 0) = i;
        num_global_items(i, 1) = moi;
      }
    <span class="keyword">const</span> <span class="keywordtype">int</span> nb_joints = joints.size();
    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i_joint = 0; i_joint &lt; nb_joints; i_joint++)
      {
        <span class="keyword">const</span> <a class="code" href="classJoint.html" title="La classe Joint est une Frontiere qui contient les faces et les sommets de joint avec la zone PEvoisi...">Joint</a>&amp;   joint              = joints[i_joint];
        <span class="keyword">const</span> <span class="keywordtype">int</span>   pe_voisin          = joint.<a class="code" href="classJoint.html#a0952bc5c7805434ccd8cd5c9b01e3747" title="Renvoie PEvoisin (numero de la zone voisine)">PEvoisin</a>();
        <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; renum_items_communs= joint.<a class="code" href="classJoint.html#a3f49fb1150967b436a115a7373ab27a0" title="Renvoie les informations de joint pour le type demande.">joint_item</a>(type_item).<a class="code" href="classJoint__Items.html#a11b6064b7fd16c1366c4c1e3a88ac2a5" title="Voir renum_items_communs_.">renum_items_communs</a>();
        <span class="keyword">const</span> <span class="keywordtype">int</span>   nb_items_communs   = renum_items_communs.<a class="code" href="classIntTab.html#abc3b32c94925a82f69d5b153a356e359" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(0);
        <span class="keywordflow">for</span> (i = 0; i &lt; nb_items_communs; i++)
          {
            <span class="keyword">const</span> <span class="keywordtype">int</span> num_item_distant = renum_items_communs(i, 0);
            <span class="keyword">const</span> <span class="keywordtype">int</span> num_item_local   = renum_items_communs(i, 1);
            <span class="keyword">const</span> <span class="keywordtype">int</span> pe_actuel = num_global_items(num_item_local, 1);
            <span class="keywordflow">if</span> (pe_voisin &lt; pe_actuel)
              {
                num_global_items(num_item_local, 0) = num_item_distant;
                num_global_items(num_item_local, 1) = pe_voisin;
              }
          }
      }
  }

  <a class="code" href="classSchema__Comm.html">Schema_Comm</a> schema_comm;
  <span class="keyword">const</span> <span class="keywordtype">int</span> <a class="code" href="classProcess.html#a6bf692ce58d9578aa62ac3c07b8caaa1" title="renvoie le nombre de processeurs dans le groupe courant Voir Comm_Group::nproc() et PE_Groups::curren...">nproc</a> = <a class="code" href="classProcess.html#a6bf692ce58d9578aa62ac3c07b8caaa1" title="renvoie le nombre de processeurs dans le groupe courant Voir Comm_Group::nproc() et PE_Groups::curren...">Process::nproc</a>();

<span class="comment">// Premiere etape : on envoie au processeur proprietaire des items</span>
<span class="comment">// la liste des items qu&#39;il faut envoyer et a quel processeur il</span>
<span class="comment">// faut les envoyer.</span>
<span class="comment">// Si le processeur A doit envoyer l&#39;element E au processeur B,</span>
<span class="comment">// et que cet element utilise un item S qui appartient au processeur C,</span>
<span class="comment">// alors on envoie a C le message :</span>
<span class="comment">// &quot;tu dois mettre le item S dans l&#39;espace distant du processeur B&quot;</span>

<span class="comment">// On prepare un schema de communication entre les voisins:</span>
<span class="comment">// Processeur emetteur : le processeur qui possede l&#39;element distant,</span>
<span class="comment">// Processeur recepteur: le processeur qui possede un item de l&#39;element.</span>
<span class="comment">// Ces processeurs sont voisins par les joints existants.</span>
  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_joints = joints.size();
  <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> liste_voisins(nb_joints);
<span class="comment">// int i_joint;</span>
  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i_joint = 0; i_joint &lt; nb_joints; i_joint++)
    liste_voisins[i_joint] = joints[i_joint].PEvoisin();

  schema_comm.<a class="code" href="classSchema__Comm.html#ad11c9b47999c294c26ae4df8d2bbd57b" title="Definit la liste des processeurs a qui on va envoyer et de qui on va recevoir des donnees...">set_send_recv_pe_list</a>(liste_voisins, liste_voisins, 1 <span class="comment">/* me_to_me */</span>);
  schema_comm.<a class="code" href="classSchema__Comm.html#ac617b53de22748cdd9fa30a0cfd0f4a8" title="Statut passe a WRITING Autorise si status_ == WRITING:">begin_comm</a>();
  {
<span class="comment">// et pour chaque item a envoyer, on envoie au processeur qui possede l&#39;item (pe_item_owner):</span>
<span class="comment">// - l&#39;indice local du item chez lui (item_distant),</span>
<span class="comment">// - le numero du processeur a qui il doit l&#39;envoyer (pe_destination)</span>
    <span class="keyword">const</span> <span class="keywordtype">int</span> nb_procs = <a class="code" href="classProcess.html#a6bf692ce58d9578aa62ac3c07b8caaa1" title="renvoie le nombre de processeurs dans le groupe courant Voir Comm_Group::nproc() et PE_Groups::curren...">Process::nproc</a>();
    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> pe_destination = 0; pe_destination &lt; nb_procs; pe_destination++)
      {
        <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; items    = items_to_send[pe_destination];
        <span class="keyword">const</span> <span class="keywordtype">int</span>     nb_items = items.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>();
        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i_item = 0; i_item &lt; nb_items; i_item++)
          {
            <span class="keyword">const</span> <span class="keywordtype">int</span> item          = items[i_item];
            <span class="keyword">const</span> <span class="keywordtype">int</span> item_distant  = num_global_items(item, 0);
            <span class="keyword">const</span> <span class="keywordtype">int</span> pe_item_owner = num_global_items(item, 1);
<span class="comment">// On envoie le numero du item distant et dans quel joint il</span>
<span class="comment">// faut le mettre.</span>
<span class="comment">// Si pe_joint == pe_destination, litem est forcement deja</span>
<span class="comment">// connu par l&#39;autre processeur, inutile de l&#39;envoyer</span>
            <span class="keywordflow">if</span> (pe_item_owner != pe_destination)
              schema_comm.<a class="code" href="classSchema__Comm.html#a6c771eae3b46250ae0d2f0126a7d8065" title="renvoie le buffer correspondant au processeur num_PE pour y entasser des donnees a envoyer...">send_buffer</a>(pe_item_owner) &lt;&lt; item_distant &lt;&lt; pe_destination;
          }
      }
  }

<span class="comment">// Echange des messages</span>
  schema_comm.<a class="code" href="classSchema__Comm.html#abca0e8ac6c2b742d26f3cfaee0690c72" title="Statut passe a EXCHANGED.">echange_taille_et_messages</a>();

<span class="comment">// Reception des items distants. On lit tous les buffers et on</span>
<span class="comment">// range les items dans &quot;items_distants&quot; par processeur destination.</span>
<span class="comment">// Pour chaque processeur voisin, la liste des items distants a envoyer:</span>
  <a class="code" href="Vect_8h.html#adc7c7b04809c9aec2cb897cd2ef06378">VECT</a>(<a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>) items_distants(nproc);
  {
<span class="comment">// Pour append_array</span>
    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> pe = 0; pe &lt; <a class="code" href="classProcess.html#a6bf692ce58d9578aa62ac3c07b8caaa1" title="renvoie le nombre de processeurs dans le groupe courant Voir Comm_Group::nproc() et PE_Groups::curren...">nproc</a>; pe++)
      items_distants[pe].set_smart_resize(1);
  }

<span class="comment">// Boucle sur tous les processeurs (pe_source) qui m&#39;ont envoye des messages:</span>
<span class="comment">// On boucle sur les processeurs voisins, plus moi-meme:</span>
  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i_source = 0; i_source &lt; nb_joints + 1; i_source++)
    {
      <span class="keyword">const</span> <span class="keywordtype">int</span> pe_source =
        (i_source &lt; nb_joints) ? liste_voisins[i_source] : <a class="code" href="classProcess.html#ab55ba07167ec807ed3a145cac0f5dca4" title="renvoie mon rang dans le groupe de communication courant. Voir Comm_Group::rank() et PE_Groups::curre...">Process::me</a>();

      <a class="code" href="classEntree.html" title="Classe de definition des operateurs et methodes pour toute lecture dans un flot d&#39;entree (fichier...">Entree</a>&amp; buffer = schema_comm.<a class="code" href="classSchema__Comm.html#a0c056eb81ab8fd513912b336b4d13a1a" title="renvoie le buffer correspondant au processeur num_PE pour y lire les donnees recues. Le schema doit etre dans l&#39;etat EXCHANGED.">recv_buffer</a>(pe_source);
<span class="comment">// Boucle &quot;tant que le buffer n&#39;est pas vide&quot;</span>
      <span class="keywordflow">while</span>(1)
        {
          <span class="keywordtype">int</span> item_distant; <span class="comment">//!&lt; Indice du item distant</span>
<span class="comment"></span>          <span class="keywordtype">int</span> pe_distant;   <span class="comment">//!&lt; Numero du pe a qui il faut envoyer le item</span>
<span class="comment"></span>          buffer &gt;&gt; item_distant &gt;&gt; pe_distant;
          <span class="keywordflow">if</span> (buffer.<a class="code" href="classEntree.html#abcd397cb0b99fbe7c6f01047d8cec89c">eof</a>())
            <span class="keywordflow">break</span>;
          assert(pe_distant != <a class="code" href="classProcess.html#ab55ba07167ec807ed3a145cac0f5dca4" title="renvoie mon rang dans le groupe de communication courant. Voir Comm_Group::rank() et PE_Groups::curre...">Process::me</a>());
          <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; array = items_distants[pe_distant];
          array.<a class="code" href="classArrOfInt.html#a3f39d0966599416e7b1f7cd8159d8d01" title="Ajoute une case en fin de tableau et y stocke la &quot;valeur&quot;.">append_array</a>(item_distant);
        }
    }
  schema_comm.<a class="code" href="classSchema__Comm.html#a73a981f88b6ffebc150fb46c5cce75d9" title="Statut passe a RESET Accesseurs:">end_comm</a>();

<span class="comment">// On retire les doublons et les items deja connus par le processeur voisin:</span>
  {
<span class="comment">// Liste des joints correspondant a chaque pe</span>
    <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> joint_of_pe(nproc);
    joint_of_pe = -1;
    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i_joint = 0; i_joint &lt; nb_joints; i_joint++)
      {
        <span class="keyword">const</span> <span class="keywordtype">int</span> pe = joints[i_joint].PEvoisin();
        joint_of_pe[pe] = i_joint;
      }
<span class="comment">// Liste des items deja connus par le processeur voisin (items communs)</span>
<span class="comment">// tries dans l&#39;ordre croissant</span>
    <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> items_communs_tri;
    items_communs_tri.<a class="code" href="classArrOfInt.html#a22d744bcd452d039580d1d9186f02b4e" title="Change le mode l&#39;allocation memoire: reallocation d&#39;un tableau a chaque changement de taille (flag = ...">set_smart_resize</a>(1);
    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> pe = 0; pe &lt; <a class="code" href="classProcess.html#a6bf692ce58d9578aa62ac3c07b8caaa1" title="renvoie le nombre de processeurs dans le groupe courant Voir Comm_Group::nproc() et PE_Groups::curren...">nproc</a>; pe++)
      {
        <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; items = items_distants[pe];
<span class="comment">// Retirer les doublons:</span>
        <a class="code" href="Scatter_8cpp.html#a23c4d19dc90caae2323f04de90621709" title="Methode outil pour retirer les doublons dans un tableau.">array_trier_retirer_doublons</a>(items);
<span class="comment">// Retirer les items deja connus:</span>
        <span class="keyword">const</span> <span class="keywordtype">int</span> i_joint = joint_of_pe[pe];
        <span class="keywordflow">if</span> (i_joint &gt;= 0)
          {
            items_communs_tri =
              joints[i_joint].joint_item(type_item).items_communs();
            items_communs_tri.<a class="code" href="classArrOfInt.html#abb0f48cf5a4be4b70edcc90baaebd521" title="Tri des valeurs du tableau dans l&#39;ordre croissant. La fonction utilisee est qsort de stdlib (elle est...">ordonne_array</a>();
            <a class="code" href="Scatter_8cpp.html#ab0ae6267baccb3a639f4a8ff795edd35" title="Retire de &quot;sorted_array&quot; les elements qui figurent dans &quot;sorted_elements&quot;. Les deux tableaux doiv...">array_retirer_elements</a>(items, items_communs_tri);
          }
        <span class="keywordflow">else</span>
          {
<span class="comment">// Pas d&#39;item commun avec ce pe.</span>
          }
      }
  }

<span class="comment">// Des espaces distants peuvent etre crees sur des processeurs avec</span>
<span class="comment">// qui il n&#39;existe pas encore de joint. On ajoute les nouveaux joints.</span>
  {
    <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> nouveaux_voisins;
    nouveaux_voisins.<a class="code" href="classArrOfInt.html#a22d744bcd452d039580d1d9186f02b4e" title="Change le mode l&#39;allocation memoire: reallocation d&#39;un tableau a chaque changement de taille (flag = ...">set_smart_resize</a>(1);
    <span class="keywordtype">int</span> i;
    <span class="keywordflow">for</span> (i = 0; i &lt; <a class="code" href="classProcess.html#a6bf692ce58d9578aa62ac3c07b8caaa1" title="renvoie le nombre de processeurs dans le groupe courant Voir Comm_Group::nproc() et PE_Groups::curren...">nproc</a>; i++)
      <span class="keywordflow">if</span> (items_distants[i].size_array() &gt; 0)
        nouveaux_voisins.<a class="code" href="classArrOfInt.html#a3f39d0966599416e7b1f7cd8159d8d01" title="Ajoute une case en fin de tableau et y stocke la &quot;valeur&quot;.">append_array</a>(i);

<span class="comment">// On ajoute les nouveaux joints</span>
    <a class="code" href="classScatter.html#a472e9375c5a64518e7b50542d2209995" title="Ajoute des joints avec tous les pe de pe_voisins. Pour que l&#39;ensemble des joints soit symetrique...">ajouter_joints</a>(zone, nouveaux_voisins);
    <a class="code" href="classProcess.html#a57e0f54b11e6eaadbea224fa904b18dd" title="Renvoie un objet statique de type Sortie qui sert de journal d&#39;evenements. Si message_level &lt;= verbose...">Process::Journal</a>() &lt;&lt; <span class="stringliteral">&quot; News joints created : (ArrOfInt) &quot;</span>
                       &lt;&lt; nouveaux_voisins &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
  }

  <a class="code" href="classJoints.html" title="Classe Joints Cette classe represente une liste d&#39;objet de type Joint.">Joints</a>&amp; joints_non_const = zone.<a class="code" href="classZone.html#a16f273a76321d31435995cdad664285a" title="Renvoie la liste des joints de la zone. (version const)">faces_joint</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_new_joints = joints_non_const.<a class="code" href="classliste.html#ab47f280662ff68f9aa2e00e50431c5dc" title="Renvoie la taille de la liste Une liste vide est de taille nulle.">size</a>();
<span class="comment">// Remplissage des tableaux d&#39;items distants</span>
  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i_joint = 0; i_joint &lt; nb_new_joints; i_joint++)
    {
      <a class="code" href="classJoint.html" title="La classe Joint est une Frontiere qui contient les faces et les sommets de joint avec la zone PEvoisi...">Joint</a>&amp; joint = joints_non_const[i_joint];
      <span class="keyword">const</span> <span class="keywordtype">int</span> pe = joint.<a class="code" href="classJoint.html#a0952bc5c7805434ccd8cd5c9b01e3747" title="Renvoie PEvoisin (numero de la zone voisine)">PEvoisin</a>();
      <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; joint_items_distants = joint.<a class="code" href="classJoint.html#aa1c4d729a3017082d26907d82ad1d7de" title="Renvoie les informations de joint pour un type d&#39;item geometrique donne, pour remplissage des structu...">set_joint_item</a>(type_item).<a class="code" href="classJoint__Items.html#a13add264f4ad36ef4bddbfc1b7bdb817" title="Renvoie le tableau items_distants_ pour le remplir Voir Scatter::calculer_espace_distant, Scatter::calculer_espace_distant_faces_frontieres, Scatter::calculer_espace_distant_elements.">set_items_distants</a>();
      joint_items_distants = items_distants[pe];
      <a class="code" href="classProcess.html#a57e0f54b11e6eaadbea224fa904b18dd" title="Renvoie un objet statique de type Sortie qui sert de journal d&#39;evenements. Si message_level &lt;= verbose...">Process::Journal</a>() &lt;&lt; <span class="stringliteral">&quot; Joint with PE:&quot;</span> &lt;&lt; pe
                         &lt;&lt; <span class="stringliteral">&quot; Number of remote items : &quot;</span>
                         &lt;&lt; joint_items_distants.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
    }
<span class="comment">// Remplissage du nombre d&#39;items virtuels</span>
  <a class="code" href="classScatter.html#ab8e91081aefb68562533279f2446e988" title="!&lt; Description Pour un item geometrique &quot;type_item&quot;, remplit le champ nb_items_virtuels_ des joints ...">calculer_nb_items_virtuels</a>(joints_non_const, type_item);
}
</pre></div>
</div>
</div>
<a class="anchor" id="a340353829751017d210326537f662b68"></a><!-- doxytag: member="Scatter::calculer_espace_distant_aretes" ref="a340353829751017d210326537f662b68" args="(Zone &amp;zone, const int nb_aretes_reelles, const IntTab &amp;elem_aretes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Scatter::calculer_espace_distant_aretes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classZone.html">Zone</a> &amp;&#160;</td>
          <td class="paramname"><em>zone</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>nb_aretes_reelles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIntTab.html">IntTab</a> &amp;&#160;</td>
          <td class="paramname"><em>elem_aretes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Idem que <a class="el" href="classScatter.html#a9cbfa7bf4fe3b741a56309931f4cf752" title="En fonction de l&#39;espace distant des elements, calcule l&#39;espace distant des sommets. Pour chaque joint, on envoie au processeur voisin l&#39;ensemble des sommets de tous les elements du joint. C&#39;est le processeur proprietaire du sommet&lt;br&gt;(plus petit pe qui le possede) qui le met dans son espace distant. Attention, on cree de nouveaux joints. On remplit les tableaux dom.zone(0).faces_joint(i).joint_item(Joint::SOMMET).items_distants();.">Scatter::calculer_espace_distant_sommets</a> pour les aretes. </p>

<p>Definition at line <a class="el" href="Scatter_8cpp_source.html#l01332">1332</a> of file <a class="el" href="Scatter_8cpp_source.html">Scatter.cpp</a>.</p>

<p>References <a class="el" href="Joint_8h_source.html#l00066">Joint::ARETE</a>, <a class="el" href="Scatter_8cpp_source.html#l01219">calculer_espace_distant_item()</a>, <a class="el" href="EntreeSortie_8h_source.html#l00032">Cerr</a>, <a class="el" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>, and <a class="el" href="Process_8cpp_source.html#l00095">Process::je_suis_maitre()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">if</span> (<a class="code" href="classProcess.html#acd052b99706c577f8a5b6656217cf4c2" title="renvoie 1 si on est sur le processeur maitre du groupe courant (c&#39;est a dire me() == 0)...">Process::je_suis_maitre</a>())
    <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Scatter::calculer_espace_distant_aretes : start&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
  <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> tableau_vide;
  <a class="code" href="Scatter_8cpp.html#aaf22a425af9ec9c52eca3d13f3ecea9f" title="Methode generique pour calculer l&#39;espace distant d&#39;un type d&#39;items geometrique&lt;br&gt;(sommet, face, arete) en fonction de l&#39;espace distant des elements: Les &quot;type_item&quot; distants (pour type_item = sommet face ou arete) sont les &quot;type_item&quot; attaches aux elements distants. Exemple : les sommets distants sont tous les sommets de tous les elements distants. Voir aussi: Scatter::calculer_espace_distant_sommets Scatter::calculer_espace_distant_faces Parametre: zone Signification: bah, la zone quoi... Parametre: type_item Signification: le type des items dont on veut calculer l&#39;espace distant Parametre: connectivite_elem_item Signification: le tableau qui donne pour chaque element de la zone les indices des items de cet element. On n&#39;utilise que la partie reele du tableau (logiquement, la partie virtuelle n&#39;existe pas encore). (exemple: zone().les_elems() pour type_item==SOMMET ou zone_VF().face_sommets() pour type_item==FACE) Parametre: nb_items_reels Signification: le nombre de &quot;type_item&quot; reels Parametre: items_lies Signification: si le tableau est non vide, il doit etre de taille nb_items_reels. Dans ce cas, il permet de forcer la propriete suivante : &quot;si l&#39;item i est distant, alors l&#39;item items_lies[i] est distant aussi&quot;. Ce tableau est utilise pour inclure les sommets periodiques virtuels associes. (voir calculer_espace_distant_sommets).">calculer_espace_distant_item</a>(zone,
                               <a class="code" href="classJoint.html#a1e2d15d088c27c9b7b11c02bf4d2c926a7816c69408b98e1161f1f54e7b6b1cb4">Joint::ARETE</a>,
                               elem_aretes,
                               nb_aretes_reelles,
                               tableau_vide);
}
</pre></div>
</div>
</div>
<a class="anchor" id="a589c34e38a91b69c2e4b43c77bf2bd9d"></a><!-- doxytag: member="Scatter::calculer_espace_distant_elements" ref="a589c34e38a91b69c2e4b43c77bf2bd9d" args="(Domaine &amp;dom)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Scatter::calculer_espace_distant_elements </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDomaine.html">Domaine</a> &amp;&#160;</td>
          <td class="paramname"><em>dom</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Remplissage du tableau "espace_distant()" des elements dans les joints.<br/>
C'est ici qu'on determine les elements de joint en fonction de l'epaisseur de joint.<br/>
Le tableau espace_distant contient les<br/>
indices locaux des elements distants (a envoyer aux processeurs voisins)<br/>
Pour un joint d'epaisseur 1, ce sont tous les elements voisins d'un<br/>
sommet de joint (sommet sur un face de joint ou sommet isole).<br/>
Pour un joint d'epaisseur n&gt;1, ce sont tous les elements voisins d'un<br/>
sommet d'un element du joint d'epaisseur n-1.<br/>
Le voisinage s'entend sur le domaine global (toutes zones confondues)<br/>
Historique: premiere version B.Mathieu le 16/01/2007.<br/>
Il existe une methode qui determine les elements distants au moment du decoupage&lt;br&gt;(DomaineCutter::construire_elements_distants_ssdom).<br/>
La methode ci-dessous a ete validee par comparaison avec la methode du decoupeur.<br/>
Les sorties ont ete verifiees pour des epaisseurs jusqu'a 5 sur des maillages tetra.<br/>
La difficulte de l'algorithme est d'obtenir les elements virtuels d'epaisseur &gt; 1 qui se<br/>
trouvent sur des sous-domaines qui ne sont pas en contact direct avec le sous-domaine<br/>
local. Difficulte resolue par l'algorithme ci-dessous. </p>

<p><p>&lt; On stocke 2 entiers par sommets commun </p>
</p>

<p>Definition at line <a class="el" href="Scatter_8cpp_source.html#l02184">2184</a> of file <a class="el" href="Scatter_8cpp_source.html">Scatter.cpp</a>.</p>

<p>References <a class="el" href="Scatter_8cpp_source.html#l01151">ajouter_joints()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00355">ArrOfInt::append_array()</a>, <a class="el" href="Scatter_8cpp_source.html#l00778">array_trier_retirer_doublons()</a>, <a class="el" href="Schema__Comm_8cpp_source.html#l00166">Schema_Comm::begin_comm()</a>, <a class="el" href="EntreeSortie_8h_source.html#l00032">Cerr</a>, <a class="el" href="Connectivite__som__elem_8cpp_source.html#l00042">construire_connectivite_som_elem()</a>, <a class="el" href="IntTab_8h_source.html#l00233">IntTab::dimension()</a>, <a class="el" href="Schema__Comm_8cpp_source.html#l00380">Schema_Comm::echange_taille_et_messages()</a>, <a class="el" href="Joint_8h_source.html#l00066">Joint::ELEMENT</a>, <a class="el" href="Schema__Comm_8cpp_source.html#l00430">Schema_Comm::end_comm()</a>, <a class="el" href="Entree_8cpp_source.html#l00549">Entree::eof()</a>, <a class="el" href="Joint_8cpp_source.html#l00106">Joint::epaisseur()</a>, <a class="el" href="Solv__GCP__NS_8cpp_source.html#l00141">erreur()</a>, <a class="el" href="Process_8cpp_source.html#l00223">Process::exit()</a>, <a class="el" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>, <a class="el" href="Static__Int__Lists_8h_source.html#l00106">Static_Int_Lists::get_list_size()</a>, <a class="el" href="Joint__Items_8cpp_source.html#l00049">Joint_Items::items_communs()</a>, <a class="el" href="Joint__Items_8cpp_source.html#l00063">Joint_Items::items_distants()</a>, <a class="el" href="Process_8cpp_source.html#l00095">Process::je_suis_maitre()</a>, <a class="el" href="Zone_8h_source.html#l00909">Zone::joint()</a>, <a class="el" href="Joint_8cpp_source.html#l00186">Joint::joint_item()</a>, <a class="el" href="Process_8cpp_source.html#l00345">Process::Journal()</a>, <a class="el" href="Zone_8h_source.html#l00402">Zone::les_elems()</a>, <a class="el" href="Process_8cpp_source.html#l00117">Process::me()</a>, <a class="el" href="Process_8cpp_source.html#l00156">Process::mp_max()</a>, <a class="el" href="Process_8cpp_source.html#l00178">Process::mp_sum()</a>, <a class="el" href="Zone_8h_source.html#l00550">Zone::nb_joints()</a>, <a class="el" href="Domaine_8cpp_source.html#l00184">Domaine::nb_som()</a>, <a class="el" href="Zone_8h_source.html#l00445">Zone::nb_som_elem()</a>, <a class="el" href="Process_8cpp_source.html#l00109">Process::nproc()</a>, <a class="el" href="Joint_8cpp_source.html#l00099">Joint::PEvoisin()</a>, <a class="el" href="Schema__Comm_8cpp_source.html#l00494">Schema_Comm::recv_buffer()</a>, <a class="el" href="Joint__Items_8cpp_source.html#l00104">Joint_Items::renum_items_communs()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00240">ArrOfInt::resize_array()</a>, <a class="el" href="Schema__Comm_8cpp_source.html#l00477">Schema_Comm::send_buffer()</a>, <a class="el" href="Joint__Items_8cpp_source.html#l00073">Joint_Items::set_items_distants()</a>, <a class="el" href="Joint_8cpp_source.html#l00159">Joint::set_joint_item()</a>, <a class="el" href="Static__Int__Lists_8cpp_source.html#l00036">Static_Int_Lists::set_list_sizes()</a>, <a class="el" href="Schema__Comm_8cpp_source.html#l00146">Schema_Comm::set_send_recv_pe_list()</a>, <a class="el" href="ArrOfInt_8cpp_source.html#l00443">ArrOfInt::set_smart_resize()</a>, <a class="el" href="Static__Int__Lists_8h_source.html#l00088">Static_Int_Lists::set_value()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00342">ArrOfInt::size_array()</a>, <a class="el" href="Joint_8h_source.html#l00066">Joint::SOMMET</a>, <a class="el" href="Vect_8h_source.html#l00026">VECT</a>, and <a class="el" href="Domaine_8h_source.html#l00272">Domaine::zone()</a>.</p>

<p>Referenced by <a class="el" href="Scatter_8cpp_source.html#l00714">construire_structures_paralleles()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <a class="code" href="classZone.html" title="classe Zone Une Zone est un maillage compose d&#39;un ensemble d&#39;elements geometriques de meme type...">Zone</a>&amp;        zone         = dom.<a class="code" href="classDomaine.html#a0e62f2bc829542fafa29e3f2c614159c" title="Renvoie la i-ieme zone du domaine. (version const)">zone</a>(0);
  <span class="keyword">const</span> <span class="keywordtype">int</span> nbjoints    = zone.<a class="code" href="classZone.html#ab096afb61e89705709a4ae6d3576a644" title="Renvoie le nombre de joints de la zone.">nb_joints</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_som_elem  = zone.<a class="code" href="classZone.html#ae0b34a93b9ae8146df2d1884157afe9f" title="Renvoie le nombre de sommets des elements geometriques constituants la zone. Tous les elements de la ...">nb_som_elem</a>();
  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; les_elems    = zone.<a class="code" href="classZone.html#ac115e8342be89afb882b7b61cc343267" title="Renvoie le tableau des sommets des elements.">les_elems</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> <a class="code" href="classProcess.html#a6bf692ce58d9578aa62ac3c07b8caaa1" title="renvoie le nombre de processeurs dans le groupe courant Voir Comm_Group::nproc() et PE_Groups::curren...">nproc</a>        = <a class="code" href="classProcess.html#a6bf692ce58d9578aa62ac3c07b8caaa1" title="renvoie le nombre de processeurs dans le groupe courant Voir Comm_Group::nproc() et PE_Groups::curren...">Process::nproc</a>();
<span class="comment">// PL on doit avoir la meme epaisseur_joint sur chaque processeur pour l&#39;algorithme suivant</span>
<span class="comment">// utilisant un echange de donnees avec schema_comm.begin_comm() schema_comm.end_comm()</span>
<span class="comment">// sinon il y&#39;a un blocage en mode debug a cause de la sortie de la ligne 1866 (voir cas Quasi_Comp_Coupl_Incomp)</span>
<span class="comment">// const int epaisseur_joint = (nb_joints &gt; 0) ? zone.joint(0).epaisseur() : 1;</span>
  <span class="keyword">const</span> <span class="keywordtype">int</span> epaisseur_joint = (int) <a class="code" href="classProcess.html#a1e9d9f9899b71927cfafae14c7bd048d" title="Calcule le max de x sur tous les processeurs du groupe courant. Remarques : Cette methode doit etre a...">mp_max</a>((nbjoints &gt; 0) ? zone.<a class="code" href="classZone.html#acec4c61032df8b55a95f9e7197ef6e3c" title="Renvoie le i-ieme joint de la zone&lt;br&gt;(version const)">joint</a>(0).<a class="code" href="classJoint.html#a67445a0294ff0e77d2d990ba0f493a17" title="Renvoie l&#39;epaisseur du joint.">epaisseur</a>() : 1);

  <span class="keywordflow">if</span> (<a class="code" href="classProcess.html#acd052b99706c577f8a5b6656217cf4c2" title="renvoie 1 si on est sur le processeur maitre du groupe courant (c&#39;est a dire me() == 0)...">Process::je_suis_maitre</a>())
    <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Calculation of remote space of elements : thickness &quot;</span> &lt;&lt; epaisseur_joint &lt;&lt; finl;

<span class="comment">// L&#39;algorithme repose sur la construction progressive du tableau &quot;liste_sommets&quot;.</span>
<span class="comment">// liste_sommets(pe) contient a un instant donne la liste des sommets possedes par me()</span>
<span class="comment">// dont le &quot;pe&quot; veut connaitre les elements voisins.</span>
<span class="comment">// Chaque pe commence par reclamer ses elements voisins directs, c&#39;est a dire les elements</span>
<span class="comment">// voisins des sommets de joint. On sait qu&#39;il voudra ensuite les elements voisins des elements</span>
<span class="comment">// ainsi trouves, donc on ajoutera aux listes les sommets des elements distants trouves</span>
<span class="comment">// a l&#39;iteration precedente.</span>
  <a class="code" href="Vect_8h.html#adc7c7b04809c9aec2cb897cd2ef06378">VECT</a>(<a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>) liste_sommets(nproc);

<span class="comment">// Pour chaque processeur, la liste des elements locaux qu&#39;il faut lui envoyer</span>
  <a class="code" href="Vect_8h.html#adc7c7b04809c9aec2cb897cd2ef06378">VECT</a>(<a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>) elements_distants(nproc);
  {
<span class="comment">// smart_resize car on va faire append_array sur ces tableaux</span>
    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; <a class="code" href="classProcess.html#a6bf692ce58d9578aa62ac3c07b8caaa1" title="renvoie le nombre de processeurs dans le groupe courant Voir Comm_Group::nproc() et PE_Groups::curren...">nproc</a>; i++)
      {
        liste_sommets[i].set_smart_resize(1);
        elements_distants[i].set_smart_resize(1);
      }
  }

  <a class="code" href="classStatic__Int__Lists.html" title="Cette classe permet de stocker des listes d&#39;entiers accessibles en temps constant. La taille des listes ne peut pas changer sans perdre le contenu (ce sont des listes statiques). Exemple: Static_Int_List l; ArrOfInt tailles(3); tailles[0] = 2; tailles[1] = 3; tailles[2] = 0; // On reserve la memoire pour trois listes de taille 2, 3 et 0: l.set_list_sizes(tailles); // On affecte une valeur au deuxieme element de la premiere liste: l.set_value(0,1,765); // Affiche la valeur Cout &lt;&lt; l(0,1);.">Static_Int_Lists</a> som_elem;
  {
    <span class="keywordflow">if</span> (<a class="code" href="classProcess.html#acd052b99706c577f8a5b6656217cf4c2" title="renvoie 1 si on est sur le processeur maitre du groupe courant (c&#39;est a dire me() == 0)...">Process::je_suis_maitre</a>())
      <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Nodes-elements connectivity ...&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
    <span class="keyword">const</span> <span class="keywordtype">int</span> nb_sommets = dom.<a class="code" href="classDomaine.html#abc4abc8b8db5bebeb161fae4162a89ce" title="Renvoie le nombre de sommets.">nb_som</a>();
    <a class="code" href="Connectivite__som__elem_8cpp.html#a82161461a228e43ae236c31101ff3ce6" title="construction de la structure som_elem pour la zone donnee On cree pour chaque sommet i la liste des e...">construire_connectivite_som_elem</a>(nb_sommets,
                                     les_elems,
                                     som_elem,
                                     0 <span class="comment">/* ne pas inclure les sommets virtuels */</span>);
  }

  <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> liste_pe_voisins(nbjoints);

<span class="comment">// Initialisation de liste_pe_voisins et</span>
<span class="comment">// initialisation de la liste de sommets: chaque processeur requiert tous les elements</span>
<span class="comment">// voisins de ses sommets de joint. Le processeur local sait que pour l&#39;epaisseur 1,</span>
<span class="comment">// chaque processeur voisin par un joint veut connaitre tous les elements voisins</span>
<span class="comment">// des sommets de joint. Donc on met dans liste_sommets(pe) les sommets de joint avec ce pe,</span>
<span class="comment">// se sorte a lui envoyer les elements locaux voisins de ces sommets.</span>
  {
    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i_joint = 0; i_joint &lt; nbjoints; i_joint++)
      {
        <span class="keyword">const</span> <a class="code" href="classJoint.html" title="La classe Joint est une Frontiere qui contient les faces et les sommets de joint avec la zone PEvoisi...">Joint</a>&amp; joint = zone.<a class="code" href="classZone.html#acec4c61032df8b55a95f9e7197ef6e3c" title="Renvoie le i-ieme joint de la zone&lt;br&gt;(version const)">joint</a>(i_joint);
        <span class="keyword">const</span> <span class="keywordtype">int</span> pe = joint.<a class="code" href="classJoint.html#a0952bc5c7805434ccd8cd5c9b01e3747" title="Renvoie PEvoisin (numero de la zone voisine)">PEvoisin</a>();
        liste_pe_voisins[i_joint] = pe;
        <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; sommets_joint = joint.<a class="code" href="classJoint.html#a3f49fb1150967b436a115a7373ab27a0" title="Renvoie les informations de joint pour le type demande.">joint_item</a>(<a class="code" href="classJoint.html#a1e2d15d088c27c9b7b11c02bf4d2c926a050aa4faf237e25faef6fff15ffc20f8">Joint::SOMMET</a>).<a class="code" href="classJoint__Items.html#a435fb1629f6dafb089605913517e73c4" title="Voir items_communs_.">items_communs</a>();
        liste_sommets[pe] = sommets_joint;
      }
  }

<span class="comment">// On va avoir besoin d&#39;un schema de communication ou chaque processeur envoie et recoit</span>
<span class="comment">// des donnees a ses voisins directs (voisins par un sommet)</span>
  <a class="code" href="classSchema__Comm.html">Schema_Comm</a> schema_comm;
  schema_comm.<a class="code" href="classSchema__Comm.html#ad11c9b47999c294c26ae4df8d2bbd57b" title="Definit la liste des processeurs a qui on va envoyer et de qui on va recevoir des donnees...">set_send_recv_pe_list</a>(liste_pe_voisins, liste_pe_voisins);

<span class="comment">// On va avoir besoin d&#39;un acces rapide a la liste des processeurs qui partagent un</span>
<span class="comment">// sommet et a l&#39;indice de ce sommet sur ce processeur.</span>
<span class="comment">// Contenu de la structure:</span>
<span class="comment">// data_sommets_communs.get_list_size(sommet) = 2*le nombre de procs qui partagent le sommet</span>
<span class="comment">// data_sommets_communs(sommet, 2*i) = numero du pe voisin</span>
<span class="comment">// data_sommets_communs(sommet, 2*i+1) = indice du sommet sur ce pe.</span>
  <a class="code" href="classStatic__Int__Lists.html" title="Cette classe permet de stocker des listes d&#39;entiers accessibles en temps constant. La taille des listes ne peut pas changer sans perdre le contenu (ce sont des listes statiques). Exemple: Static_Int_List l; ArrOfInt tailles(3); tailles[0] = 2; tailles[1] = 3; tailles[2] = 0; // On reserve la memoire pour trois listes de taille 2, 3 et 0: l.set_list_sizes(tailles); // On affecte une valeur au deuxieme element de la premiere liste: l.set_value(0,1,765); // Affiche la valeur Cout &lt;&lt; l(0,1);.">Static_Int_Lists</a> data_sommets_communs;
<span class="comment">// Remplissage : la structure n&#39;est utilisee que si l&#39;epaisseur de joint est &gt; 1</span>
  <span class="keywordflow">if</span> (epaisseur_joint &gt; 1)
    {
      <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> count(dom.<a class="code" href="classDomaine.html#abc4abc8b8db5bebeb161fae4162a89ce" title="Renvoie le nombre de sommets.">nb_som</a>());
<span class="comment">// Etape 1 : avec combien de processeurs chaque sommet est-il partage ?</span>
      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> ijoint = 0; ijoint &lt; nbjoints; ijoint++)
        {
          <span class="keyword">const</span> <a class="code" href="classJoint.html" title="La classe Joint est une Frontiere qui contient les faces et les sommets de joint avec la zone PEvoisi...">Joint</a>&amp; joint = zone.<a class="code" href="classZone.html#acec4c61032df8b55a95f9e7197ef6e3c" title="Renvoie le i-ieme joint de la zone&lt;br&gt;(version const)">joint</a>(ijoint);
          <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; sommets_joint = joint.<a class="code" href="classJoint.html#a3f49fb1150967b436a115a7373ab27a0" title="Renvoie les informations de joint pour le type demande.">joint_item</a>(<a class="code" href="classJoint.html#a1e2d15d088c27c9b7b11c02bf4d2c926a050aa4faf237e25faef6fff15ffc20f8">Joint::SOMMET</a>).<a class="code" href="classJoint__Items.html#a435fb1629f6dafb089605913517e73c4" title="Voir items_communs_.">items_communs</a>();
          <span class="keyword">const</span> <span class="keywordtype">int</span> n = sommets_joint.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>();
          <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; n; i++)
            {
              <span class="keyword">const</span> <span class="keywordtype">int</span> som = sommets_joint[i];
              count[som] += 2; <span class="comment">//!&lt; On stocke 2 entiers par sommets commun</span>
<span class="comment"></span>            }
        }
      data_sommets_communs.<a class="code" href="classStatic__Int__Lists.html#a60da63cb1970f5b87d1e1fdf6d65dcb2" title="detruit les listes existantes et en cree de nouvelles. On cree autant de listes que d&#39;elements dans l...">set_list_sizes</a>(count);
      count = 0;
<span class="comment">// Etape 2 : remplissage de la structure:</span>
      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> ijoint = 0; ijoint &lt; nbjoints; ijoint++)
        {
          <span class="keyword">const</span> <a class="code" href="classJoint.html" title="La classe Joint est une Frontiere qui contient les faces et les sommets de joint avec la zone PEvoisi...">Joint</a>&amp; joint = zone.<a class="code" href="classZone.html#acec4c61032df8b55a95f9e7197ef6e3c" title="Renvoie le i-ieme joint de la zone&lt;br&gt;(version const)">joint</a>(ijoint);
          <span class="keyword">const</span> <span class="keywordtype">int</span> pe = joint.<a class="code" href="classJoint.html#a0952bc5c7805434ccd8cd5c9b01e3747" title="Renvoie PEvoisin (numero de la zone voisine)">PEvoisin</a>();
          <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; renum_sommets = joint.<a class="code" href="classJoint.html#a3f49fb1150967b436a115a7373ab27a0" title="Renvoie les informations de joint pour le type demande.">joint_item</a>(<a class="code" href="classJoint.html#a1e2d15d088c27c9b7b11c02bf4d2c926a050aa4faf237e25faef6fff15ffc20f8">Joint::SOMMET</a>).<a class="code" href="classJoint__Items.html#a11b6064b7fd16c1366c4c1e3a88ac2a5" title="Voir renum_items_communs_.">renum_items_communs</a>();
          <span class="keyword">const</span> <span class="keywordtype">int</span> n = renum_sommets.<a class="code" href="classIntTab.html#abc3b32c94925a82f69d5b153a356e359" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(0);
          <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; n; i++)
            {
<span class="comment">// Indice du sommet partage sur le pe voisin</span>
              <span class="keyword">const</span> <span class="keywordtype">int</span> i_sommet_distant = renum_sommets(i, 0);
<span class="comment">// Indice du sommet partage sur ma zone locale</span>
              <span class="keyword">const</span> <span class="keywordtype">int</span> i_sommet_local = renum_sommets(i, 1);
              <span class="keyword">const</span> <span class="keywordtype">int</span> j = count[i_sommet_local]++;
              data_sommets_communs.<a class="code" href="classStatic__Int__Lists.html#ab56f42945e3057185cc1086e1cbc1bbb" title="affecte la &quot;valeur&quot; au j-ieme element de la i-ieme liste avec 0 &lt;= i &lt; get_nb_lists() et 0 &lt;= j &lt; get...">set_value</a>(i_sommet_local, j*2, pe);
              data_sommets_communs.<a class="code" href="classStatic__Int__Lists.html#ab56f42945e3057185cc1086e1cbc1bbb" title="affecte la &quot;valeur&quot; au j-ieme element de la i-ieme liste avec 0 &lt;= i &lt; get_nb_lists() et 0 &lt;= j &lt; get...">set_value</a>(i_sommet_local, j*2+1, i_sommet_distant);
            }
        }
    }

<span class="comment">// Boucle sur l&#39;epaisseur de joint:</span>
<span class="comment">// A l&#39;entree de la boucle, on suppose que liste_sommets contient, pour chaque processeur</span>
<span class="comment">// qui requiert des elements virtuels, la liste des sommets de me() dont il veut les voisins.</span>
  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> epaisseur = 1; ; epaisseur++)
    {
      <span class="keywordflow">if</span> (<a class="code" href="classProcess.html#acd052b99706c577f8a5b6656217cf4c2" title="renvoie 1 si on est sur le processeur maitre du groupe courant (c&#39;est a dire me() == 0)...">Process::je_suis_maitre</a>())
        <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot; Calculation of the thickness &quot;</span> &lt;&lt; epaisseur &lt;&lt; finl;

<span class="comment">// Pour chaque liste de sommets, mettre dans les elements distants du meme processeur</span>
<span class="comment">// les elements voisins des sommets de la liste.</span>
      <span class="keywordtype">int</span> pe;
      <span class="keywordflow">for</span> (pe = 0; pe &lt; <a class="code" href="classProcess.html#a6bf692ce58d9578aa62ac3c07b8caaa1" title="renvoie le nombre de processeurs dans le groupe courant Voir Comm_Group::nproc() et PE_Groups::curren...">nproc</a>; pe++)
        {
          <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; elems_dist = elements_distants[pe];
          <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; sommets = liste_sommets[pe];
          elems_dist.<a class="code" href="classArrOfInt.html#a9b3afbb46b16870dbd36236c8935b535">resize_array</a>(0);
          <span class="keyword">const</span> <span class="keywordtype">int</span> nb_som_liste = sommets.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>();
          <span class="keywordflow">for</span> (<span class="keywordtype">int</span> isom = 0; isom &lt; nb_som_liste; isom++)
            {
              <span class="keyword">const</span> <span class="keywordtype">int</span> som = sommets[isom];
              <span class="keywordflow">if</span> (som&lt;0)
                <span class="keywordflow">continue</span>;
              <span class="keyword">const</span> <span class="keywordtype">int</span> nb_elem_som = som_elem.<a class="code" href="classStatic__Int__Lists.html#adbf6903737c3c30bf87e05b29f5a5b56" title="renvoie le nombre d&#39;elements de la liste i">get_list_size</a>(som);
              <span class="keywordflow">for</span> (<span class="keywordtype">int</span> ielem = 0; ielem &lt; nb_elem_som; ielem++)
                {
                  <span class="keyword">const</span> <span class="keywordtype">int</span> elem = som_elem(som, ielem);
                  elems_dist.<a class="code" href="classArrOfInt.html#a3f39d0966599416e7b1f7cd8159d8d01" title="Ajoute une case en fin de tableau et y stocke la &quot;valeur&quot;.">append_array</a>(elem);
                }
            }
          <a class="code" href="Scatter_8cpp.html#a23c4d19dc90caae2323f04de90621709" title="Methode outil pour retirer les doublons dans un tableau.">array_trier_retirer_doublons</a>(elems_dist);
        }

<span class="comment">// La suite est la mise a jour de liste_sommets pour l&#39;iteration suivante.</span>
<span class="comment">// Inutile de le faire si on est a la derniere iteration:</span>
      <span class="keywordflow">if</span> (epaisseur == epaisseur_joint)
        <span class="keywordflow">break</span>;

<span class="comment">// Mettre dans les listes de sommets les sommets des elements distants trouves</span>
      <span class="keywordflow">for</span> (pe = 0; pe &lt; <a class="code" href="classProcess.html#a6bf692ce58d9578aa62ac3c07b8caaa1" title="renvoie le nombre de processeurs dans le groupe courant Voir Comm_Group::nproc() et PE_Groups::curren...">nproc</a>; pe++)
        {
          <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; sommets = liste_sommets[pe];
          <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; elems_dist = elements_distants[pe];
          sommets.<a class="code" href="classArrOfInt.html#a9b3afbb46b16870dbd36236c8935b535">resize_array</a>(0);
          <span class="keyword">const</span> <span class="keywordtype">int</span> nb_elems_dist = elems_dist.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>();
          <span class="keywordflow">for</span> (<span class="keywordtype">int</span> ielem = 0; ielem &lt; nb_elems_dist; ielem++)
            {
              <span class="keyword">const</span> <span class="keywordtype">int</span> elem = elems_dist[ielem];
              <span class="keywordflow">for</span> (<span class="keywordtype">int</span> isom = 0; isom &lt; nb_som_elem; isom++)
                {
                  <span class="keyword">const</span> <span class="keywordtype">int</span> som = les_elems(elem, isom);
                  sommets.<a class="code" href="classArrOfInt.html#a3f39d0966599416e7b1f7cd8159d8d01" title="Ajoute une case en fin de tableau et y stocke la &quot;valeur&quot;.">append_array</a>(som);
                }
            }
          <a class="code" href="Scatter_8cpp.html#a23c4d19dc90caae2323f04de90621709" title="Methode outil pour retirer les doublons dans un tableau.">array_trier_retirer_doublons</a>(sommets);
        }
<span class="comment">// Parcourir les listes de sommets. Pour chaque sommet, s&#39;il est de joint,</span>
<span class="comment">// envoyer aux processeurs possedant ce sommet une requete &quot;le processeur i</span>
<span class="comment">// veut tous les voisins de ce sommet&quot;.</span>
<span class="comment">// Ne pas envoyer la requete au processeur &quot;i&quot; pour la liste &quot;i&quot;: il connait</span>
<span class="comment">// deja ses propres elements !</span>
      schema_comm.<a class="code" href="classSchema__Comm.html#ac617b53de22748cdd9fa30a0cfd0f4a8" title="Statut passe a WRITING Autorise si status_ == WRITING:">begin_comm</a>();
<span class="comment">// Premiere phase de communication: empiler les donnees a envoyer dans des buffers</span>
      <span class="keywordflow">for</span> (pe = 0; pe &lt; <a class="code" href="classProcess.html#a6bf692ce58d9578aa62ac3c07b8caaa1" title="renvoie le nombre de processeurs dans le groupe courant Voir Comm_Group::nproc() et PE_Groups::curren...">nproc</a>; pe++)
        {
          <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; sommets = liste_sommets[pe];
          <span class="keyword">const</span> <span class="keywordtype">int</span> nb_som_liste = sommets.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>();
          <span class="keywordflow">for</span> (<span class="keywordtype">int</span> isom = 0; isom &lt; nb_som_liste; isom++)
            {
              <span class="keyword">const</span> <span class="keywordtype">int</span> i_sommet_local = sommets[isom];
              <span class="keywordflow">if</span> (i_sommet_local&lt;0)
                <span class="keywordflow">continue</span>;
              <span class="keyword">const</span> <span class="keywordtype">int</span> nb_pe_voisins = data_sommets_communs.<a class="code" href="classStatic__Int__Lists.html#adbf6903737c3c30bf87e05b29f5a5b56" title="renvoie le nombre d&#39;elements de la liste i">get_list_size</a>(i_sommet_local) / 2;
              <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; nb_pe_voisins; i++)
                {
                  <span class="keyword">const</span> <span class="keywordtype">int</span> pe_voisin = data_sommets_communs(i_sommet_local, i*2);
<span class="comment">// Indice du sommet sur le processeur voisin.</span>
                  <span class="keyword">const</span> <span class="keywordtype">int</span> i_sommet_distant = data_sommets_communs(i_sommet_local, i*2+1);
                  <span class="keywordflow">if</span> (pe_voisin != pe)
                    {
<span class="comment">// Envoyer au processeur &quot;pe_voisin&quot; le message : &quot;le processeur PE a besoin</span>
<span class="comment">// des elements voisins du sommet i_sommet_distant&quot;</span>
                      schema_comm.<a class="code" href="classSchema__Comm.html#a6c771eae3b46250ae0d2f0126a7d8065" title="renvoie le buffer correspondant au processeur num_PE pour y entasser des donnees a envoyer...">send_buffer</a>(pe_voisin) &lt;&lt; pe &lt;&lt; i_sommet_distant;
                    }
                }
            }
        }
      schema_comm.<a class="code" href="classSchema__Comm.html#abca0e8ac6c2b742d26f3cfaee0690c72" title="Statut passe a EXCHANGED.">echange_taille_et_messages</a>();
      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i_pevoisin = 0; i_pevoisin &lt; nbjoints; i_pevoisin++)
        {
          <span class="keyword">const</span> <span class="keywordtype">int</span> pe_voisin = liste_pe_voisins[i_pevoisin];
          <a class="code" href="classEntree.html" title="Classe de definition des operateurs et methodes pour toute lecture dans un flot d&#39;entree (fichier...">Entree</a>&amp; buffer = schema_comm.<a class="code" href="classSchema__Comm.html#a0c056eb81ab8fd513912b336b4d13a1a" title="renvoie le buffer correspondant au processeur num_PE pour y lire les donnees recues. Le schema doit etre dans l&#39;etat EXCHANGED.">recv_buffer</a>(pe_voisin);
          <span class="keywordflow">for</span> (;;)
            {
              <span class="keywordtype">int</span> pe2, sommet;
<span class="comment">// On recupere le message &quot;le processeur PE a besoin des elements voisins de SOMMET&quot;.</span>
              buffer &gt;&gt; pe2 &gt;&gt; sommet;
              <span class="keywordflow">if</span> (buffer.<a class="code" href="classEntree.html#abcd397cb0b99fbe7c6f01047d8cec89c">eof</a>())
                <span class="keywordflow">break</span>;
              liste_sommets[pe2].append_array(sommet);
            }
        }
      schema_comm.<a class="code" href="classSchema__Comm.html#a73a981f88b6ffebc150fb46c5cce75d9" title="Statut passe a RESET Accesseurs:">end_comm</a>();
<span class="comment">// Supprimer les doublons dans les listes de sommets</span>
      <span class="keywordflow">for</span> (pe = 0; pe &lt; <a class="code" href="classProcess.html#a6bf692ce58d9578aa62ac3c07b8caaa1" title="renvoie le nombre de processeurs dans le groupe courant Voir Comm_Group::nproc() et PE_Groups::curren...">nproc</a>; pe++)
        {
          <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; sommets = liste_sommets[pe];
          <a class="code" href="Scatter_8cpp.html#a23c4d19dc90caae2323f04de90621709" title="Methode outil pour retirer les doublons dans un tableau.">array_trier_retirer_doublons</a>(sommets);
        }
    }

<span class="comment">// Creation des nouveaux joints si besoin, et stockage des elements distants dans les joints</span>
  {
    <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> voisins;
    voisins.<a class="code" href="classArrOfInt.html#a22d744bcd452d039580d1d9186f02b4e" title="Change le mode l&#39;allocation memoire: reallocation d&#39;un tableau a chaque changement de taille (flag = ...">set_smart_resize</a>(1);

    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> pe = 0; pe &lt; <a class="code" href="classProcess.html#a6bf692ce58d9578aa62ac3c07b8caaa1" title="renvoie le nombre de processeurs dans le groupe courant Voir Comm_Group::nproc() et PE_Groups::curren...">nproc</a>; pe++)
      <span class="keywordflow">if</span> (elements_distants[pe].size_array() &gt; 0)
        voisins.<a class="code" href="classArrOfInt.html#a3f39d0966599416e7b1f7cd8159d8d01" title="Ajoute une case en fin de tableau et y stocke la &quot;valeur&quot;.">append_array</a>(pe);
    <a class="code" href="classScatter.html#a472e9375c5a64518e7b50542d2209995" title="Ajoute des joints avec tous les pe de pe_voisins. Pour que l&#39;ensemble des joints soit symetrique...">ajouter_joints</a>(zone, voisins);

<span class="preprocessor">#ifdef CHECK_ALGO_ESPACE_VIRTUEL</span>
<span class="preprocessor"></span><span class="comment">// On n&#39;utilise pas les espaces virtuels calcules ci-dessus, on se</span>
<span class="comment">// contente de les comparer aux espaces virtuels calcules lors du decoupage</span>
<span class="comment">// par l&#39;algorithme sequentiel.</span>
<span class="comment">// Pour l&#39;instant, l&#39;algorithme parallele a l&#39;air de fonctionner sans probleme</span>
<span class="comment">// je desactive ce test. (Benoit Mathieu)</span>
    <span class="keywordtype">int</span> <a class="code" href="Solv__GCP__NS_8cpp.html#ab6aa1075b965c7713d8db20dd3a8e09b">erreur</a> = 0;
    <span class="keyword">const</span> <span class="keywordtype">int</span> nbjoints = zone.nbjoints();
    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; nbjoints; i++)
      {
        <a class="code" href="classJoint.html" title="La classe Joint est une Frontiere qui contient les faces et les sommets de joint avec la zone PEvoisi...">Joint</a>&amp; joint = zone.<a class="code" href="classZone.html#acec4c61032df8b55a95f9e7197ef6e3c" title="Renvoie le i-ieme joint de la zone&lt;br&gt;(version const)">joint</a>(i);
        <span class="keyword">const</span> <span class="keywordtype">int</span> pe = joint.<a class="code" href="classJoint.html#a0952bc5c7805434ccd8cd5c9b01e3747" title="Renvoie PEvoisin (numero de la zone voisine)">PEvoisin</a>();
        <span class="keywordflow">if</span> (!(joint.<a class="code" href="classJoint.html#a3f49fb1150967b436a115a7373ab27a0" title="Renvoie les informations de joint pour le type demande.">joint_item</a>(<a class="code" href="classJoint.html#a1e2d15d088c27c9b7b11c02bf4d2c926ae32de3a01fdb3ad6c506b8058a7f6173">Joint::ELEMENT</a>).<a class="code" href="classJoint__Items.html#ae51b330de79fcaae9c88166e3eee7cb8" title="Voir items_distants_.">items_distants</a>() == elements_distants[pe]))
          {
            <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Error in Scatter, PE &quot;</span> &lt;&lt; <a class="code" href="classProcess.html#ab55ba07167ec807ed3a145cac0f5dca4" title="renvoie mon rang dans le groupe de communication courant. Voir Comm_Group::rank() et PE_Groups::curre...">Process::me</a>() &lt;&lt; finl;
            <a class="code" href="classProcess.html#a57e0f54b11e6eaadbea224fa904b18dd" title="Renvoie un objet statique de type Sortie qui sert de journal d&#39;evenements. Si message_level &lt;= verbose...">Process::Journal</a>() &lt;&lt; <span class="stringliteral">&quot;Error scatter, remote elements pe &quot;</span> &lt;&lt; pe &lt;&lt; finl
                               &lt;&lt; <span class="stringliteral">&quot; Splitting algorithm: &quot;</span> &lt;&lt; joint.<a class="code" href="classJoint.html#a3f49fb1150967b436a115a7373ab27a0" title="Renvoie les informations de joint pour le type demande.">joint_item</a>(<a class="code" href="classJoint.html#a1e2d15d088c27c9b7b11c02bf4d2c926ae32de3a01fdb3ad6c506b8058a7f6173">Joint::ELEMENT</a>).<a class="code" href="classJoint__Items.html#ae51b330de79fcaae9c88166e3eee7cb8" title="Voir items_distants_.">items_distants</a>()
                               &lt;&lt; <span class="stringliteral">&quot; Scatter algorithm  : &quot;</span> &lt;&lt; elements_distants[pe] &lt;&lt; finl;

            erreur = 1;
          }
      }
    <span class="keywordflow">if</span> (<a class="code" href="classProcess.html#a7d23bc1ef94b3f0623fbc79d034c27fd" title="Calcule la somme de x sur tous les processeurs du groupe courant. Voir aussi mp_max()">mp_sum</a>(erreur))
      <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">Process::exit</a>();
<span class="preprocessor">#else</span>
<span class="preprocessor"></span><span class="comment">// Stockage du resultat</span>
    <span class="keyword">const</span> <span class="keywordtype">int</span> nb_joints = zone.<a class="code" href="classZone.html#ab096afb61e89705709a4ae6d3576a644" title="Renvoie le nombre de joints de la zone.">nb_joints</a>();
    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; nb_joints; i++)
      {
        <a class="code" href="classJoint.html" title="La classe Joint est une Frontiere qui contient les faces et les sommets de joint avec la zone PEvoisi...">Joint</a>&amp; joint = zone.<a class="code" href="classZone.html#acec4c61032df8b55a95f9e7197ef6e3c" title="Renvoie le i-ieme joint de la zone&lt;br&gt;(version const)">joint</a>(i);
        <span class="keyword">const</span> <span class="keywordtype">int</span> pe = joint.<a class="code" href="classJoint.html#a0952bc5c7805434ccd8cd5c9b01e3747" title="Renvoie PEvoisin (numero de la zone voisine)">PEvoisin</a>();
        joint.<a class="code" href="classJoint.html#aa1c4d729a3017082d26907d82ad1d7de" title="Renvoie les informations de joint pour un type d&#39;item geometrique donne, pour remplissage des structu...">set_joint_item</a>(<a class="code" href="classJoint.html#a1e2d15d088c27c9b7b11c02bf4d2c926ae32de3a01fdb3ad6c506b8058a7f6173">Joint::ELEMENT</a>).<a class="code" href="classJoint__Items.html#a13add264f4ad36ef4bddbfc1b7bdb817" title="Renvoie le tableau items_distants_ pour le remplir Voir Scatter::calculer_espace_distant, Scatter::calculer_espace_distant_faces_frontieres, Scatter::calculer_espace_distant_elements.">set_items_distants</a>() = elements_distants[pe];
      }
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>  }
}
</pre></div>
</div>
</div>
<a class="anchor" id="af8e062885ea7bbeaffb320e7f718e282"></a><!-- doxytag: member="Scatter::calculer_espace_distant_faces" ref="af8e062885ea7bbeaffb320e7f718e282" args="(Zone &amp;zone, const int nb_faces_reelles, const IntTab &amp;elem_faces)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Scatter::calculer_espace_distant_faces </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classZone.html">Zone</a> &amp;&#160;</td>
          <td class="paramname"><em>zone</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>nb_faces_reelles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIntTab.html">IntTab</a> &amp;&#160;</td>
          <td class="paramname"><em>elem_faces</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Idem que <a class="el" href="classScatter.html#a9cbfa7bf4fe3b741a56309931f4cf752" title="En fonction de l&#39;espace distant des elements, calcule l&#39;espace distant des sommets. Pour chaque joint, on envoie au processeur voisin l&#39;ensemble des sommets de tous les elements du joint. C&#39;est le processeur proprietaire du sommet&lt;br&gt;(plus petit pe qui le possede) qui le met dans son espace distant. Attention, on cree de nouveaux joints. On remplit les tableaux dom.zone(0).faces_joint(i).joint_item(Joint::SOMMET).items_distants();.">Scatter::calculer_espace_distant_sommets</a> pour les faces. </p>

<p>Definition at line <a class="el" href="Scatter_8cpp_source.html#l01314">1314</a> of file <a class="el" href="Scatter_8cpp_source.html">Scatter.cpp</a>.</p>

<p>References <a class="el" href="Scatter_8cpp_source.html#l01219">calculer_espace_distant_item()</a>, <a class="el" href="EntreeSortie_8h_source.html#l00032">Cerr</a>, <a class="el" href="Joint_8h_source.html#l00066">Joint::FACE</a>, <a class="el" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>, and <a class="el" href="Process_8cpp_source.html#l00095">Process::je_suis_maitre()</a>.</p>

<p>Referenced by <a class="el" href="Zone__VF_8cpp_source.html#l00112">Zone_VF::discretiser()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">if</span> (<a class="code" href="classProcess.html#acd052b99706c577f8a5b6656217cf4c2" title="renvoie 1 si on est sur le processeur maitre du groupe courant (c&#39;est a dire me() == 0)...">Process::je_suis_maitre</a>())
    <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Scatter::calculer_espace_distant_faces : start&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;

  <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> tableau_vide;

  <a class="code" href="Scatter_8cpp.html#aaf22a425af9ec9c52eca3d13f3ecea9f" title="Methode generique pour calculer l&#39;espace distant d&#39;un type d&#39;items geometrique&lt;br&gt;(sommet, face, arete) en fonction de l&#39;espace distant des elements: Les &quot;type_item&quot; distants (pour type_item = sommet face ou arete) sont les &quot;type_item&quot; attaches aux elements distants. Exemple : les sommets distants sont tous les sommets de tous les elements distants. Voir aussi: Scatter::calculer_espace_distant_sommets Scatter::calculer_espace_distant_faces Parametre: zone Signification: bah, la zone quoi... Parametre: type_item Signification: le type des items dont on veut calculer l&#39;espace distant Parametre: connectivite_elem_item Signification: le tableau qui donne pour chaque element de la zone les indices des items de cet element. On n&#39;utilise que la partie reele du tableau (logiquement, la partie virtuelle n&#39;existe pas encore). (exemple: zone().les_elems() pour type_item==SOMMET ou zone_VF().face_sommets() pour type_item==FACE) Parametre: nb_items_reels Signification: le nombre de &quot;type_item&quot; reels Parametre: items_lies Signification: si le tableau est non vide, il doit etre de taille nb_items_reels. Dans ce cas, il permet de forcer la propriete suivante : &quot;si l&#39;item i est distant, alors l&#39;item items_lies[i] est distant aussi&quot;. Ce tableau est utilise pour inclure les sommets periodiques virtuels associes. (voir calculer_espace_distant_sommets).">calculer_espace_distant_item</a>(zone,
                               <a class="code" href="classJoint.html#a1e2d15d088c27c9b7b11c02bf4d2c926ab255b88987fc7f64c215c958cbe2af6b">Joint::FACE</a>,
                               elem_faces,
                               nb_faces_reelles,
                               tableau_vide);
}
</pre></div>
</div>
</div>
<a class="anchor" id="a9cbfa7bf4fe3b741a56309931f4cf752"></a><!-- doxytag: member="Scatter::calculer_espace_distant_sommets" ref="a9cbfa7bf4fe3b741a56309931f4cf752" args="(Domaine &amp;dom, const Noms &amp;liste_bords_periodiques)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Scatter::calculer_espace_distant_sommets </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDomaine.html">Domaine</a> &amp;&#160;</td>
          <td class="paramname"><em>dom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classNoms.html">Noms</a> &amp;&#160;</td>
          <td class="paramname"><em>liste_bords_periodiques</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>En fonction de l'espace distant des elements, calcule l'espace<br/>
distant des sommets. Pour chaque joint, on envoie au processeur voisin<br/>
l'ensemble des sommets de tous les elements du joint.<br/>
C'est le processeur proprietaire du sommet&lt;br&gt;(plus petit pe qui le possede) qui le met dans son espace distant.<br/>
Attention, on cree de nouveaux joints.<br/>
On remplit les tableaux<br/>
dom.zone(0).faces_joint(i).joint_item(Joint::SOMMET).items_distants();. </p>

<p>Definition at line <a class="el" href="Scatter_8cpp_source.html#l01289">1289</a> of file <a class="el" href="Scatter_8cpp_source.html">Scatter.cpp</a>.</p>

<p>References <a class="el" href="Scatter_8cpp_source.html#l01219">calculer_espace_distant_item()</a>, <a class="el" href="EntreeSortie_8h_source.html#l00032">Cerr</a>, <a class="el" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>, <a class="el" href="Process_8cpp_source.html#l00095">Process::je_suis_maitre()</a>, <a class="el" href="Zone_8h_source.html#l00402">Zone::les_elems()</a>, <a class="el" href="Domaine_8cpp_source.html#l00184">Domaine::nb_som()</a>, <a class="el" href="Reordonner__faces__periodiques_8cpp_source.html#l00289">Reordonner_faces_periodiques::renum_som_perio()</a>, <a class="el" href="Joint_8h_source.html#l00066">Joint::SOMMET</a>, and <a class="el" href="Domaine_8h_source.html#l00272">Domaine::zone()</a>.</p>

<p>Referenced by <a class="el" href="Scatter_8cpp_source.html#l00714">construire_structures_paralleles()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">if</span> (<a class="code" href="classProcess.html#acd052b99706c577f8a5b6656217cf4c2" title="renvoie 1 si on est sur le processeur maitre du groupe courant (c&#39;est a dire me() == 0)...">Process::je_suis_maitre</a>())
    <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Scatter::calculer_espace_distant_sommets : start&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;

  <a class="code" href="classZone.html" title="classe Zone Une Zone est un maillage compose d&#39;un ensemble d&#39;elements geometriques de meme type...">Zone</a>&amp;          zone                  = dom.<a class="code" href="classDomaine.html#a0e62f2bc829542fafa29e3f2c614159c" title="Renvoie la i-ieme zone du domaine. (version const)">zone</a>(0);
  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; connectivite_elem_som = zone.<a class="code" href="classZone.html#ac115e8342be89afb882b7b61cc343267" title="Renvoie le tableau des sommets des elements.">les_elems</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span>   nb_sommets_reels      = dom.<a class="code" href="classDomaine.html#abc4abc8b8db5bebeb161fae4162a89ce" title="Renvoie le nombre de sommets.">nb_som</a>();

  <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> renum_som_perio(nb_sommets_reels);
<span class="comment">// Initialisation du tableau renum_som_perio</span>
  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; nb_sommets_reels; i++)
    renum_som_perio[i] = i;
  <a class="code" href="classReordonner__faces__periodiques.html#aee6a67196132bed17c8d786d6c39316c">Reordonner_faces_periodiques::renum_som_perio</a>(dom, liste_bords_perio, renum_som_perio,
                                                0 <span class="comment">/* ne pas calculer pour les sommets virtuels */</span>);

  <a class="code" href="Scatter_8cpp.html#aaf22a425af9ec9c52eca3d13f3ecea9f" title="Methode generique pour calculer l&#39;espace distant d&#39;un type d&#39;items geometrique&lt;br&gt;(sommet, face, arete) en fonction de l&#39;espace distant des elements: Les &quot;type_item&quot; distants (pour type_item = sommet face ou arete) sont les &quot;type_item&quot; attaches aux elements distants. Exemple : les sommets distants sont tous les sommets de tous les elements distants. Voir aussi: Scatter::calculer_espace_distant_sommets Scatter::calculer_espace_distant_faces Parametre: zone Signification: bah, la zone quoi... Parametre: type_item Signification: le type des items dont on veut calculer l&#39;espace distant Parametre: connectivite_elem_item Signification: le tableau qui donne pour chaque element de la zone les indices des items de cet element. On n&#39;utilise que la partie reele du tableau (logiquement, la partie virtuelle n&#39;existe pas encore). (exemple: zone().les_elems() pour type_item==SOMMET ou zone_VF().face_sommets() pour type_item==FACE) Parametre: nb_items_reels Signification: le nombre de &quot;type_item&quot; reels Parametre: items_lies Signification: si le tableau est non vide, il doit etre de taille nb_items_reels. Dans ce cas, il permet de forcer la propriete suivante : &quot;si l&#39;item i est distant, alors l&#39;item items_lies[i] est distant aussi&quot;. Ce tableau est utilise pour inclure les sommets periodiques virtuels associes. (voir calculer_espace_distant_sommets).">calculer_espace_distant_item</a>(zone,
                               <a class="code" href="classJoint.html#a1e2d15d088c27c9b7b11c02bf4d2c926a050aa4faf237e25faef6fff15ffc20f8">Joint::SOMMET</a>,
                               connectivite_elem_som,
                               nb_sommets_reels,
                               renum_som_perio);
}
</pre></div>
</div>
</div>
<a class="anchor" id="ab8e91081aefb68562533279f2446e988"></a><!-- doxytag: member="Scatter::calculer_nb_items_virtuels" ref="ab8e91081aefb68562533279f2446e988" args="(Joints &amp;joints, const Joint::Type_Item type_item)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Scatter::calculer_nb_items_virtuels </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classJoints.html">Joints</a> &amp;&#160;</td>
          <td class="paramname"><em>joints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classJoint.html#a1e2d15d088c27c9b7b11c02bf4d2c926">Joint::Type_Item</a>&#160;</td>
          <td class="paramname"><em>type_item</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>!&lt; Description Pour un item geometrique "type_item", remplit le champ nb_items_virtuels_ des joints en fonction du nombre d'items distants : Le nombre d'items virtuels sur un joint i du processeur j est le nombre d'items distants du joint j sur le processeur i. </p>

<p>Definition at line <a class="el" href="Scatter_8cpp_source.html#l02864">2864</a> of file <a class="el" href="Scatter_8cpp_source.html">Scatter.cpp</a>.</p>

<p>References <a class="el" href="Schema__Comm_8cpp_source.html#l00166">Schema_Comm::begin_comm()</a>, <a class="el" href="Schema__Comm_8cpp_source.html#l00380">Schema_Comm::echange_taille_et_messages()</a>, <a class="el" href="Schema__Comm_8cpp_source.html#l00430">Schema_Comm::end_comm()</a>, <a class="el" href="Joint__Items_8cpp_source.html#l00063">Joint_Items::items_distants()</a>, <a class="el" href="Joint_8cpp_source.html#l00186">Joint::joint_item()</a>, <a class="el" href="Joint_8cpp_source.html#l00099">Joint::PEvoisin()</a>, <a class="el" href="Schema__Comm_8cpp_source.html#l00494">Schema_Comm::recv_buffer()</a>, <a class="el" href="Schema__Comm_8cpp_source.html#l00477">Schema_Comm::send_buffer()</a>, <a class="el" href="Joint_8cpp_source.html#l00159">Joint::set_joint_item()</a>, <a class="el" href="Joint__Items_8cpp_source.html#l00081">Joint_Items::set_nb_items_virtuels()</a>, <a class="el" href="Schema__Comm_8cpp_source.html#l00146">Schema_Comm::set_send_recv_pe_list()</a>, <a class="el" href="liste_8cpp_source.html#l00175">liste::size()</a>, and <a class="el" href="ArrOfInt_8h_source.html#l00342">ArrOfInt::size_array()</a>.</p>

<p>Referenced by <a class="el" href="Scatter_8cpp_source.html#l00937">calculer_espace_distant()</a>, and <a class="el" href="Scatter_8cpp_source.html#l00714">construire_structures_paralleles()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <a class="code" href="classSchema__Comm.html">Schema_Comm</a> schema_comm;
  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_joints = joints.<a class="code" href="classliste.html#ab47f280662ff68f9aa2e00e50431c5dc" title="Renvoie la taille de la liste Une liste vide est de taille nulle.">size</a>();
  <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> liste_voisins(nb_joints);
  <span class="keywordtype">int</span> i_joint;
  <span class="keywordflow">for</span> (i_joint = 0; i_joint &lt; nb_joints; i_joint++)
    liste_voisins[i_joint] = joints[i_joint].PEvoisin();

<span class="comment">// On envoie le nombre d&#39;items distants au PE voisin</span>
  schema_comm.<a class="code" href="classSchema__Comm.html#ad11c9b47999c294c26ae4df8d2bbd57b" title="Definit la liste des processeurs a qui on va envoyer et de qui on va recevoir des donnees...">set_send_recv_pe_list</a>(liste_voisins, liste_voisins);
  schema_comm.<a class="code" href="classSchema__Comm.html#ac617b53de22748cdd9fa30a0cfd0f4a8" title="Statut passe a WRITING Autorise si status_ == WRITING:">begin_comm</a>();
  <span class="keywordflow">for</span> (i_joint = 0; i_joint &lt; nb_joints; i_joint++)
    {
      <span class="keyword">const</span> <a class="code" href="classJoint.html" title="La classe Joint est une Frontiere qui contient les faces et les sommets de joint avec la zone PEvoisi...">Joint</a>&amp;        joint = joints[i_joint];
      <span class="keyword">const</span> <a class="code" href="classJoint__Items.html" title="Joint_Items contient les informations de distribution parallele d&#39;un item geometrique particulier ave...">Joint_Items</a>&amp; items = joint.<a class="code" href="classJoint.html#a3f49fb1150967b436a115a7373ab27a0" title="Renvoie les informations de joint pour le type demande.">joint_item</a>(type_item);
      <span class="keyword">const</span> <span class="keywordtype">int</span> n  = items.<a class="code" href="classJoint__Items.html#ae51b330de79fcaae9c88166e3eee7cb8" title="Voir items_distants_.">items_distants</a>().<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>();
      <span class="keyword">const</span> <span class="keywordtype">int</span> pe = joint.<a class="code" href="classJoint.html#a0952bc5c7805434ccd8cd5c9b01e3747" title="Renvoie PEvoisin (numero de la zone voisine)">PEvoisin</a>();
      schema_comm.<a class="code" href="classSchema__Comm.html#a6c771eae3b46250ae0d2f0126a7d8065" title="renvoie le buffer correspondant au processeur num_PE pour y entasser des donnees a envoyer...">send_buffer</a>(pe) &lt;&lt; n;
    }
<span class="comment">// Echange des messages</span>
  schema_comm.<a class="code" href="classSchema__Comm.html#abca0e8ac6c2b742d26f3cfaee0690c72" title="Statut passe a EXCHANGED.">echange_taille_et_messages</a>();
<span class="comment">// Le PE voisin recoit ce nombre d&#39;items et le stocke.</span>
  <span class="keywordflow">for</span> (i_joint = 0; i_joint &lt; nb_joints; i_joint++)
    {
      <a class="code" href="classJoint.html" title="La classe Joint est une Frontiere qui contient les faces et les sommets de joint avec la zone PEvoisi...">Joint</a>&amp;        joint = joints[i_joint];
      <a class="code" href="classJoint__Items.html" title="Joint_Items contient les informations de distribution parallele d&#39;un item geometrique particulier ave...">Joint_Items</a>&amp; items = joint.<a class="code" href="classJoint.html#aa1c4d729a3017082d26907d82ad1d7de" title="Renvoie les informations de joint pour un type d&#39;item geometrique donne, pour remplissage des structu...">set_joint_item</a>(type_item);
      <span class="keyword">const</span> <span class="keywordtype">int</span> pe = joint.<a class="code" href="classJoint.html#a0952bc5c7805434ccd8cd5c9b01e3747" title="Renvoie PEvoisin (numero de la zone voisine)">PEvoisin</a>();
      <span class="keywordtype">int</span> n;
      schema_comm.<a class="code" href="classSchema__Comm.html#a0c056eb81ab8fd513912b336b4d13a1a" title="renvoie le buffer correspondant au processeur num_PE pour y lire les donnees recues. Le schema doit etre dans l&#39;etat EXCHANGED.">recv_buffer</a>(pe) &gt;&gt; n;
      items.<a class="code" href="classJoint__Items.html#a956b3926baa83e9d5ab9848adf7f822a" title="Voir nb_items_virtuels_ Voir Scatter::calculer_nb_items_virtuels.">set_nb_items_virtuels</a>(n);
    }
  schema_comm.<a class="code" href="classSchema__Comm.html#a73a981f88b6ffebc150fb46c5cce75d9" title="Statut passe a RESET Accesseurs:">end_comm</a>();
}
</pre></div>
</div>
</div>
<a class="anchor" id="a21f166c05df9be1fc1f02b0604624fe5"></a><!-- doxytag: member="Scatter::calculer_renum_items_communs" ref="a21f166c05df9be1fc1f02b0604624fe5" args="(Joints &amp;joints, const Joint::Type_Item type_item)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Scatter::calculer_renum_items_communs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classJoints.html">Joints</a> &amp;&#160;</td>
          <td class="paramname"><em>joints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classJoint.html#a1e2d15d088c27c9b7b11c02bf4d2c926">Joint::Type_Item</a>&#160;</td>
          <td class="paramname"><em>type_item</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>On suppose que chaque joint[i].joint_item(type_item).items_communs()<br/>
contient les indices locaux des items de joint communs dans le meme<br/>
ordre sur les deux processeurs (local et voisin)<br/>
On remplit renum_items_communs :<br/>
colonne 0=contenu du tableau items_communs sur le PE voisin<br/>
colonne 1=contenu du tableau items_communs sur le PE local. </p>

<p>Definition at line <a class="el" href="Scatter_8cpp_source.html#l01353">1353</a> of file <a class="el" href="Scatter_8cpp_source.html">Scatter.cpp</a>.</p>

<p>References <a class="el" href="Schema__Comm_8cpp_source.html#l00166">Schema_Comm::begin_comm()</a>, <a class="el" href="Schema__Comm_8cpp_source.html#l00380">Schema_Comm::echange_taille_et_messages()</a>, <a class="el" href="Schema__Comm_8cpp_source.html#l00430">Schema_Comm::end_comm()</a>, <a class="el" href="Joint__Items_8cpp_source.html#l00049">Joint_Items::items_communs()</a>, <a class="el" href="Joint_8cpp_source.html#l00186">Joint::joint_item()</a>, <a class="el" href="Joint_8cpp_source.html#l00099">Joint::PEvoisin()</a>, <a class="el" href="Schema__Comm_8cpp_source.html#l00494">Schema_Comm::recv_buffer()</a>, <a class="el" href="IntTab_8cpp_source.html#l00353">IntTab::resize()</a>, <a class="el" href="Schema__Comm_8cpp_source.html#l00477">Schema_Comm::send_buffer()</a>, <a class="el" href="Joint_8cpp_source.html#l00159">Joint::set_joint_item()</a>, <a class="el" href="Joint__Items_8cpp_source.html#l00097">Joint_Items::set_renum_items_communs()</a>, <a class="el" href="Schema__Comm_8cpp_source.html#l00146">Schema_Comm::set_send_recv_pe_list()</a>, <a class="el" href="ArrOfInt_8cpp_source.html#l00443">ArrOfInt::set_smart_resize()</a>, <a class="el" href="liste_8cpp_source.html#l00175">liste::size()</a>, and <a class="el" href="ArrOfInt_8h_source.html#l00342">ArrOfInt::size_array()</a>.</p>

<p>Referenced by <a class="el" href="Scatter_8cpp_source.html#l02653">construire_correspondance_items_par_coordonnees()</a>, <a class="el" href="Zone__VF_8cpp_source.html#l00112">Zone_VF::discretiser()</a>, <a class="el" href="Scatter_8cpp_source.html#l00150">interpreter()</a>, <a class="el" href="Raffiner__isotrope__parallele_8cpp_source.html#l00198">Raffiner_isotrope_parallele::interpreter()</a>, and <a class="el" href="MaillerParallel_8cpp_source.html#l00534">MaillerParallel::interpreter()</a>.</p>
<div class="fragment"><pre class="fragment">{
<span class="comment">// Il suffit d&#39;envoyer au voisin le tableau _faces dans l&#39;ordre</span>
<span class="comment">// pour qu&#39;il ait les indices des faces sur l&#39;autre pe.</span>

  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_joints = joints.<a class="code" href="classliste.html#ab47f280662ff68f9aa2e00e50431c5dc" title="Renvoie la taille de la liste Une liste vide est de taille nulle.">size</a>();
  <span class="keywordtype">int</span>       i_joint;
  <a class="code" href="classSchema__Comm.html">Schema_Comm</a>  schema_comm;
  <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> liste_voisins(nb_joints);
  <span class="keywordflow">for</span> (i_joint = 0; i_joint &lt; nb_joints; i_joint++)
    liste_voisins[i_joint] = joints[i_joint].PEvoisin();
  schema_comm.<a class="code" href="classSchema__Comm.html#ad11c9b47999c294c26ae4df8d2bbd57b" title="Definit la liste des processeurs a qui on va envoyer et de qui on va recevoir des donnees...">set_send_recv_pe_list</a>(liste_voisins, liste_voisins);

  schema_comm.<a class="code" href="classSchema__Comm.html#ac617b53de22748cdd9fa30a0cfd0f4a8" title="Statut passe a WRITING Autorise si status_ == WRITING:">begin_comm</a>();

  <span class="keywordflow">for</span> (i_joint = 0; i_joint &lt; nb_joints; i_joint++)
    {
      <span class="keyword">const</span> <a class="code" href="classJoint.html" title="La classe Joint est une Frontiere qui contient les faces et les sommets de joint avec la zone PEvoisi...">Joint</a>&amp; joint     = joints[i_joint];
      <span class="keyword">const</span> <span class="keywordtype">int</span>  pe_voisin = joint.<a class="code" href="classJoint.html#a0952bc5c7805434ccd8cd5c9b01e3747" title="Renvoie PEvoisin (numero de la zone voisine)">PEvoisin</a>();
      <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; items_communs =
        joint.<a class="code" href="classJoint.html#a3f49fb1150967b436a115a7373ab27a0" title="Renvoie les informations de joint pour le type demande.">joint_item</a>(type_item).<a class="code" href="classJoint__Items.html#a435fb1629f6dafb089605913517e73c4" title="Voir items_communs_.">items_communs</a>();
      schema_comm.<a class="code" href="classSchema__Comm.html#a6c771eae3b46250ae0d2f0126a7d8065" title="renvoie le buffer correspondant au processeur num_PE pour y entasser des donnees a envoyer...">send_buffer</a>(pe_voisin) &lt;&lt; items_communs;
    }

  schema_comm.<a class="code" href="classSchema__Comm.html#abca0e8ac6c2b742d26f3cfaee0690c72" title="Statut passe a EXCHANGED.">echange_taille_et_messages</a>();

<span class="comment">// Le tableau items communs recu du pe voisin:</span>
  <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> items_communs_voisin;
  items_communs_voisin.<a class="code" href="classArrOfInt.html#a22d744bcd452d039580d1d9186f02b4e" title="Change le mode l&#39;allocation memoire: reallocation d&#39;un tableau a chaque changement de taille (flag = ...">set_smart_resize</a>(1);

  <span class="keywordflow">for</span> (i_joint = 0; i_joint &lt; nb_joints; i_joint++)
    {
      <a class="code" href="classJoint.html" title="La classe Joint est une Frontiere qui contient les faces et les sommets de joint avec la zone PEvoisi...">Joint</a>&amp;           joint         = joints[i_joint];
      <span class="keyword">const</span> <span class="keywordtype">int</span>     pe_voisin     = joint.<a class="code" href="classJoint.html#a0952bc5c7805434ccd8cd5c9b01e3747" title="Renvoie PEvoisin (numero de la zone voisine)">PEvoisin</a>();
      <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; items_communs = joint.<a class="code" href="classJoint.html#a3f49fb1150967b436a115a7373ab27a0" title="Renvoie les informations de joint pour le type demande.">joint_item</a>(type_item).<a class="code" href="classJoint__Items.html#a435fb1629f6dafb089605913517e73c4" title="Voir items_communs_.">items_communs</a>();
      <span class="keyword">const</span> <span class="keywordtype">int</span>     nb_items      = items_communs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>();
      schema_comm.<a class="code" href="classSchema__Comm.html#a0c056eb81ab8fd513912b336b4d13a1a" title="renvoie le buffer correspondant au processeur num_PE pour y lire les donnees recues. Le schema doit etre dans l&#39;etat EXCHANGED.">recv_buffer</a>(pe_voisin) &gt;&gt; items_communs_voisin;

      assert(nb_items == items_communs_voisin.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>());

      <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; renum_items_communs = joint.<a class="code" href="classJoint.html#aa1c4d729a3017082d26907d82ad1d7de" title="Renvoie les informations de joint pour un type d&#39;item geometrique donne, pour remplissage des structu...">set_joint_item</a>(type_item).<a class="code" href="classJoint__Items.html#a95cc27c0fd65e2444a468df69a211057" title="Voir renum_items_communs_ Voir Scatter::calculer_colonne0_renum_faces_communes Scatter::construire_co...">set_renum_items_communs</a>();
      renum_items_communs.<a class="code" href="classIntTab.html#a22e6bed6826b3688d4d0181cbf3b7a38" title="Change la taille du vecteur (identique a resize_array() pour le traitement des anciennes valeurs et d...">resize</a>(nb_items, 2);
<span class="comment">// L&#39;indice de la face de joint sur l&#39;autre PE est dans tmp(i,1)</span>
      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; nb_items; i++)
        {
          renum_items_communs(i,0) = items_communs_voisin[i];
          renum_items_communs(i,1) = items_communs[i];
        }
    }

  schema_comm.<a class="code" href="classSchema__Comm.html#a73a981f88b6ffebc150fb46c5cce75d9" title="Statut passe a RESET Accesseurs:">end_comm</a>();
}
</pre></div>
</div>
</div>
<a class="anchor" id="a86c9311713284ed6591da95c7eb9411d"></a><!-- doxytag: member="Scatter::check_consistancy_remote_items" ref="a86c9311713284ed6591da95c7eb9411d" args="(Domaine &amp;dom, const ArrOfInt &amp;mergedZones)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Scatter::check_consistancy_remote_items </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDomaine.html">Domaine</a> &amp;&#160;</td>
          <td class="paramname"><em>dom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>mergedZones</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Merged zones receive joints information from their neighbours<br/>
to ensure that their common items (vertices) appear in the same order<br/>
If it's not the case, the merged zone reorders its common items so that it matches the neighbour's order<br/>
When 2 neighbouring zones have each been merged,<br/>
only the processor with the lowest rank proceeds to reordering. </p>

<p>Definition at line <a class="el" href="Scatter_8cpp_source.html#l00297">297</a> of file <a class="el" href="Scatter_8cpp_source.html">Scatter.cpp</a>.</p>

<p>References <a class="el" href="ArrOfInt_8h_source.html#l00355">ArrOfInt::append_array()</a>, <a class="el" href="Schema__Comm_8cpp_source.html#l00166">Schema_Comm::begin_comm()</a>, <a class="el" href="Objet__U_8h_source.html#l00079">Objet_U::dimension</a>, <a class="el" href="Schema__Comm_8cpp_source.html#l00380">Schema_Comm::echange_taille_et_messages()</a>, <a class="el" href="Schema__Comm_8cpp_source.html#l00430">Schema_Comm::end_comm()</a>, <a class="el" href="Double_8h_source.html#l00273">est_egal()</a>, <a class="el" href="Zone_8h_source.html#l01098">Zone::faces_joint()</a>, <a class="el" href="Joint__Items_8cpp_source.html#l00049">Joint_Items::items_communs()</a>, <a class="el" href="Joint_8cpp_source.html#l00186">Joint::joint_item()</a>, <a class="el" href="Domaine_8h_source.html#l00577">Domaine::les_sommets()</a>, <a class="el" href="Process_8cpp_source.html#l00117">Process::me()</a>, <a class="el" href="Schema__Comm_8cpp_source.html#l00494">Schema_Comm::recv_buffer()</a>, <a class="el" href="DoubleTab_8cpp_source.html#l00335">DoubleTab::resize()</a>, <a class="el" href="Schema__Comm_8cpp_source.html#l00477">Schema_Comm::send_buffer()</a>, <a class="el" href="Schema__Comm_8cpp_source.html#l00146">Schema_Comm::set_send_recv_pe_list()</a>, <a class="el" href="ArrOfInt_8cpp_source.html#l00443">ArrOfInt::set_smart_resize()</a>, <a class="el" href="liste_8cpp_source.html#l00175">liste::size()</a>, <a class="el" href="ArrOfDouble_8h_source.html#l00350">ArrOfDouble::size_array()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00342">ArrOfInt::size_array()</a>, <a class="el" href="Joint_8h_source.html#l00066">Joint::SOMMET</a>, <a class="el" href="Vect_8h_source.html#l00026">VECT</a>, and <a class="el" href="Domaine_8h_source.html#l00272">Domaine::zone()</a>.</p>

<p>Referenced by <a class="el" href="Scatter_8cpp_source.html#l00513">lire_domaine()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">const</span> <a class="code" href="classJoints.html" title="Classe Joints Cette classe represente une liste d&#39;objet de type Joint.">Joints</a>&amp; joints     = dom.<a class="code" href="classDomaine.html#a0e62f2bc829542fafa29e3f2c614159c" title="Renvoie la i-ieme zone du domaine. (version const)">zone</a>(0).<a class="code" href="classZone.html#a16f273a76321d31435995cdad664285a" title="Renvoie la liste des joints de la zone. (version const)">faces_joint</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_joints = joints.<a class="code" href="classliste.html#ab47f280662ff68f9aa2e00e50431c5dc" title="Renvoie la taille de la liste Une liste vide est de taille nulle.">size</a>();

  <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; coords = dom.<a class="code" href="classDomaine.html#a0846ac03a10b65c4df911fe35a19c02f" title="Renvoie le nombre total de sommets.">les_sommets</a>();
  <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> liste_send;
  <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> liste_recv;
  liste_send.<a class="code" href="classArrOfInt.html#a22d744bcd452d039580d1d9186f02b4e" title="Change le mode l&#39;allocation memoire: reallocation d&#39;un tableau a chaque changement de taille (flag = ...">set_smart_resize</a>(1);
  liste_recv.<a class="code" href="classArrOfInt.html#a22d744bcd452d039580d1d9186f02b4e" title="Change le mode l&#39;allocation memoire: reallocation d&#39;un tableau a chaque changement de taille (flag = ...">set_smart_resize</a>(1);

  <span class="keyword">const</span> <span class="keywordtype">int</span>&amp; moi = <a class="code" href="classProcess.html#ab55ba07167ec807ed3a145cac0f5dca4" title="renvoie mon rang dans le groupe de communication courant. Voir Comm_Group::rank() et PE_Groups::curre...">Process::me</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span>&amp; myZoneWasMerged = mergedZones[moi];

  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i_joint = 0; i_joint &lt; nb_joints; i_joint++)
    {

      <span class="keyword">const</span> <span class="keywordtype">int</span>&amp; pe_voisin = joints[i_joint].PEvoisin();
      <span class="keyword">const</span> <span class="keywordtype">int</span>&amp; neighbourZoneWasMerged = mergedZones[pe_voisin];
      <span class="keywordflow">if</span>(myZoneWasMerged &amp;&amp; neighbourZoneWasMerged)
        {
          <span class="keywordflow">if</span>(pe_voisin &lt; moi)
            liste_recv.<a class="code" href="classArrOfInt.html#a3f39d0966599416e7b1f7cd8159d8d01" title="Ajoute une case en fin de tableau et y stocke la &quot;valeur&quot;.">append_array</a>(pe_voisin);
          <span class="keywordflow">else</span>
            liste_send.<a class="code" href="classArrOfInt.html#a3f39d0966599416e7b1f7cd8159d8d01" title="Ajoute une case en fin de tableau et y stocke la &quot;valeur&quot;.">append_array</a>(pe_voisin);
        }
      <span class="keywordflow">else</span> <span class="keywordflow">if</span>(myZoneWasMerged &amp;&amp; !neighbourZoneWasMerged)
        liste_recv.<a class="code" href="classArrOfInt.html#a3f39d0966599416e7b1f7cd8159d8d01" title="Ajoute une case en fin de tableau et y stocke la &quot;valeur&quot;.">append_array</a>(pe_voisin);
      <span class="keywordflow">else</span> <span class="keywordflow">if</span>(!myZoneWasMerged &amp;&amp; neighbourZoneWasMerged)
        liste_send.<a class="code" href="classArrOfInt.html#a3f39d0966599416e7b1f7cd8159d8d01" title="Ajoute une case en fin de tableau et y stocke la &quot;valeur&quot;.">append_array</a>(pe_voisin);
      <span class="keywordflow">else</span>
        {
<span class="comment">// nothing to exchange</span>
        }
    }

  <a class="code" href="Vect_8h.html#adc7c7b04809c9aec2cb897cd2ef06378">VECT</a>(<a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>) coord_items_locaux(nb_joints);
  <a class="code" href="Vect_8h.html#adc7c7b04809c9aec2cb897cd2ef06378">VECT</a>(<a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>) coord_items_distants(nb_joints);
  for (<span class="keywordtype">int</span> i_joint = 0; i_joint &lt; nb_joints; i_joint++)
    {
      <span class="keyword">const</span> <a class="code" href="classJoint.html" title="La classe Joint est une Frontiere qui contient les faces et les sommets de joint avec la zone PEvoisi...">Joint</a>&amp; joint     = joints[i_joint];
      <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; items_communs = joint.<a class="code" href="classJoint.html#a3f49fb1150967b436a115a7373ab27a0" title="Renvoie les informations de joint pour le type demande.">joint_item</a>(<a class="code" href="classJoint.html#a1e2d15d088c27c9b7b11c02bf4d2c926a050aa4faf237e25faef6fff15ffc20f8">Joint::SOMMET</a>).<a class="code" href="classJoint__Items.html#a435fb1629f6dafb089605913517e73c4" title="Voir items_communs_.">items_communs</a>();
      <span class="keyword">const</span> <span class="keywordtype">int</span> nb_items_communs = items_communs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>();

      <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp;   coord   = coord_items_locaux[i_joint];
      coord.<a class="code" href="classDoubleTab.html#ae83b4d31205c53d9c8d2b43da178ce75" title="Change la taille du vecteur (identique a resize_array() pour le traitement des anciennes valeurs et d...">resize</a>(nb_items_communs, <a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>);
      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; nb_items_communs; i++)
        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; <a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; j++)
          coord(i,j) = coords(items_communs[i], j);
    }

<span class="comment">// Envoi des coordonnees locales au processeur voisin</span>
  {
    <a class="code" href="classSchema__Comm.html">Schema_Comm</a> schema_comm;
    schema_comm.<a class="code" href="classSchema__Comm.html#ad11c9b47999c294c26ae4df8d2bbd57b" title="Definit la liste des processeurs a qui on va envoyer et de qui on va recevoir des donnees...">set_send_recv_pe_list</a>(liste_send, liste_recv);
    schema_comm.<a class="code" href="classSchema__Comm.html#ac617b53de22748cdd9fa30a0cfd0f4a8" title="Statut passe a WRITING Autorise si status_ == WRITING:">begin_comm</a>();
    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; nb_joints; i++)
      {
        <span class="keyword">const</span> <span class="keywordtype">int</span> pe_voisin = joints[i].PEvoisin();
        <span class="keyword">const</span> <span class="keywordtype">int</span>&amp; neighbourZoneWasMerged = mergedZones[pe_voisin];
        <span class="keywordflow">if</span>( neighbourZoneWasMerged &amp;&amp; !(myZoneWasMerged &amp;&amp; pe_voisin&lt;moi) )
          {
            <a class="code" href="classSortie.html" title="Classe de base des flux de sortie. Elle sait ecrire des types simples&lt;br&gt;(entiers, flottants) et des Ob...">Sortie</a>&amp; buffer = schema_comm.<a class="code" href="classSchema__Comm.html#a6c771eae3b46250ae0d2f0126a7d8065" title="renvoie le buffer correspondant au processeur num_PE pour y entasser des donnees a envoyer...">send_buffer</a>(pe_voisin);
            buffer &lt;&lt; coord_items_locaux[i];
          }
      }
    schema_comm.<a class="code" href="classSchema__Comm.html#abca0e8ac6c2b742d26f3cfaee0690c72" title="Statut passe a EXCHANGED.">echange_taille_et_messages</a>();

    <span class="keywordflow">if</span>(myZoneWasMerged)
      {
        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; nb_joints; i++)
          {
            <span class="keyword">const</span> <span class="keywordtype">int</span> pe_voisin = joints[i].PEvoisin();
            <span class="keyword">const</span> <span class="keywordtype">int</span>&amp; neighbourZoneWasMerged = mergedZones[pe_voisin];
            <span class="keywordflow">if</span>(!(neighbourZoneWasMerged &amp;&amp; pe_voisin&gt;moi))
              {
                <a class="code" href="classEntree.html" title="Classe de definition des operateurs et methodes pour toute lecture dans un flot d&#39;entree (fichier...">Entree</a>&amp; buffer = schema_comm.<a class="code" href="classSchema__Comm.html#a0c056eb81ab8fd513912b336b4d13a1a" title="renvoie le buffer correspondant au processeur num_PE pour y lire les donnees recues. Le schema doit etre dans l&#39;etat EXCHANGED.">recv_buffer</a>(pe_voisin);
                buffer &gt;&gt; coord_items_distants[i];
              }
          }
      }

    schema_comm.<a class="code" href="classSchema__Comm.html#a73a981f88b6ffebc150fb46c5cce75d9" title="Statut passe a RESET Accesseurs:">end_comm</a>();
  }

<span class="comment">// check if the vertices in my joints appear in the same order as my neighbour joint</span>
  <span class="keywordflow">if</span>(myZoneWasMerged)
    {
      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i_joint = 0; i_joint &lt; nb_joints; i_joint++)
        {

          <span class="keyword">const</span> <span class="keywordtype">int</span> pe_voisin = joints[i_joint].PEvoisin();
          <span class="keyword">const</span> <span class="keywordtype">int</span>&amp; neighbourZoneWasMerged = mergedZones[pe_voisin];
          <span class="keywordflow">if</span>(neighbourZoneWasMerged &amp;&amp; pe_voisin&gt;moi)
            <span class="keywordflow">continue</span>;
          <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; items_communs = dom.<a class="code" href="classDomaine.html#a0e62f2bc829542fafa29e3f2c614159c" title="Renvoie la i-ieme zone du domaine. (version const)">zone</a>(0).<a class="code" href="classZone.html#a16f273a76321d31435995cdad664285a" title="Renvoie la liste des joints de la zone. (version const)">faces_joint</a>()[i_joint].set_joint_item(<a class="code" href="classJoint.html#a1e2d15d088c27c9b7b11c02bf4d2c926a050aa4faf237e25faef6fff15ffc20f8">Joint::SOMMET</a>).set_items_communs();
          <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> old_items_communs = joints[i_joint].joint_item(<a class="code" href="classJoint.html#a1e2d15d088c27c9b7b11c02bf4d2c926a050aa4faf237e25faef6fff15ffc20f8">Joint::SOMMET</a>).items_communs();
          <span class="keyword">const</span> <span class="keywordtype">int</span>     nb_items      = items_communs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>();
          <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; coord_voisin = coord_items_distants[i_joint];
          <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; my_coord = coord_items_locaux[i_joint];
          assert(my_coord.<a class="code" href="classArrOfDouble.html#a3c3b33bea0e88b87315c21ee94bee05f" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() ==  coord_voisin.<a class="code" href="classArrOfDouble.html#a3c3b33bea0e88b87315c21ee94bee05f" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>());
          <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;nb_items; i++)
            {
              <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j=0; j&lt;nb_items; j++)
                {
                  <span class="keywordtype">int</span> ok=1;
                  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> dir=0; dir&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>; dir++)
                    ok=ok&amp;&amp;(<a class="code" href="Double_8h.html#ac86f5f350b0f95fd8c34b0ac8d720f6f">est_egal</a>(coord_voisin(i,dir),my_coord(j,dir)));
                  <span class="keywordflow">if</span> (ok)
                    {
                      items_communs[i] = old_items_communs[j];
                      <span class="keywordflow">break</span>;
                    }
                }
            }
        }
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a16a9000e31ccecd2438c8f05e41cc302"></a><!-- doxytag: member="Scatter::Chercher_Correspondance" ref="a16a9000e31ccecd2438c8f05e41cc302" args="(const DoubleTab &amp;sommets1, const DoubleTab &amp;sommets2, ArrOfInt &amp;correspondance, const double epsilon)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Scatter::Chercher_Correspondance </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>sommets1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>sommets2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>correspondance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>epsilon</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construit le tableau "correspondance" tel que<br/>
Pour 0 &lt;= i &lt; sommets2.size_array(),<br/>
Si sommet2(i) existe dans le tableau sommet1, alors<br/>
sommets2(i, ...) == sommets1(correspondance[i], ...)<br/>
Sinon<br/>
correspondance[i] = -1<br/>
L'egalite est verifiee a epsilon pres en absolu (soit abs(x1-x2)&lt;epsilon)<br/>
L'algorithme est generalement en n1*log(n1) + n2*log(n1)<br/>
(recherche basee sur un quicksort).<br/>
En cas d'echec du tri, on utilise un algorithme en n1*n2.<br/>
Les tableaux sommets1 et sommets2 doivent etre de dimension 2<br/>
Le tableau correspondance doit etre de taille sommets2.size_array().<br/>
Valeur de retour: nombre de sommets de sommets2 non trouves dans le tableau sommets1. </p>

<p><p>&lt; (min+max)/2</p>
<p>&lt; s1&lt;s2</p>
<p>&lt; s1&gt;s2</p>
<p>&lt; s1==s2 </p>
</p>

<p>Definition at line <a class="el" href="Scatter_8cpp_source.html#l02512">2512</a> of file <a class="el" href="Scatter_8cpp_source.html">Scatter.cpp</a>.</p>

<p>References <a class="el" href="ArrOfInt_8h_source.html#l00371">ArrOfInt::addr()</a>, <a class="el" href="EntreeSortie_8h_source.html#l00032">Cerr</a>, <a class="el" href="DoubleTab_8h_source.html#l00243">DoubleTab::dimension()</a>, <a class="el" href="Process_8cpp_source.html#l00223">Process::exit()</a>, <a class="el" href="Scatter_8cpp_source.html#l02460">fct_cmp_coordonnees()</a>, <a class="el" href="Scatter_8cpp_source.html#l02488">fct_cmp_index_coord()</a>, <a class="el" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>, <a class="el" href="Process_8cpp_source.html#l00345">Process::Journal()</a>, <a class="el" href="DoubleTab_8h_source.html#l00264">DoubleTab::nb_dim()</a>, and <a class="el" href="ArrOfInt_8h_source.html#l00342">ArrOfInt::size_array()</a>.</p>

<p>Referenced by <a class="el" href="Scatter_8cpp_source.html#l02653">construire_correspondance_items_par_coordonnees()</a>, and <a class="el" href="Raffiner__isotrope__parallele_8cpp_source.html#l00055">mon_construire_correspondance_items_par_coordonnees()</a>.</p>
<div class="fragment"><pre class="fragment">{
<span class="comment">// Methode non threadsafe a cause des static. On teste</span>
  <span class="keywordflow">if</span> (<a class="code" href="Scatter_8cpp.html#a107a2fbce3e368271c492cfcf7cfca10">fct_cmp_coord_tableau</a>)
    {
      <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Thread error in Chercher_Correspondance&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
      <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">exit</a>();
    }
  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_sommets1 = sommets1.<a class="code" href="classDoubleTab.html#ac3805e2637a3b880ba2d3e650c69dac4" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(0);
  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_sommets2 = sommets2.<a class="code" href="classDoubleTab.html#ac3805e2637a3b880ba2d3e650c69dac4" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(0);
<span class="comment">// Precondition necessaire pour fct_cmp_index_coord</span>
  assert(sommets1.<a class="code" href="classDoubleTab.html#ae6dda48778e7107e1beb723beef1f75b" title="Returns the number of dimensions of the array (&gt;= 1)">nb_dim</a>() == 2);
  assert(sommets2.<a class="code" href="classDoubleTab.html#ae6dda48778e7107e1beb723beef1f75b" title="Returns the number of dimensions of the array (&gt;= 1)">nb_dim</a>() == 2);
  assert(correspondance.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() == nb_sommets2);
  <span class="keywordflow">if</span> (nb_sommets1 &lt; 1)
    {
      correspondance = -1;
      <span class="keywordflow">return</span> nb_sommets2;
    }

  <a class="code" href="Scatter_8cpp.html#a107a2fbce3e368271c492cfcf7cfca10">fct_cmp_coord_tableau</a>   = &amp;sommets1;
  <a class="code" href="Scatter_8cpp.html#a09e112f8a32312a1675f7e33b94df122">fct_cmp_coord_dimension</a> = sommets1.<a class="code" href="classDoubleTab.html#ac3805e2637a3b880ba2d3e650c69dac4" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(1);
  <a class="code" href="Scatter_8cpp.html#a81c1304205b09abc2acc284f8adc390c">fct_cmp_coord_epsilon</a>   = epsilon;

<span class="comment">// Tableau d&#39;indirection trie, tel que les coordonnees sommets1(index[i], .) soient</span>
<span class="comment">// tiees dans l&#39;ordre lexicographique.</span>
  <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> index(nb_sommets1);
  {
    <span class="keywordtype">int</span> i;
    <span class="keywordflow">for</span> (i = 0; i &lt; nb_sommets1; i++)
      index[i] = i;
  }

<span class="comment">// Tri du tableau d&#39;index</span>
<span class="comment">// On trie les sommets par ordre lexicographique des coordonnees.</span>
<span class="comment">// Comme on fait un test a epsilon pres, le tri peut echouer:</span>
<span class="comment">// Si x=1, y=1.01, z=1.02 et epsilon=0.01, on a</span>
<span class="comment">// x==y (a epsilon pres)</span>
<span class="comment">// y==z (a epsilon pres)</span>
<span class="comment">// mais x!=z</span>
<span class="comment">// Donc la recherche par dichotomie peut echouer par la suite.</span>

  qsort(index.addr(), nb_sommets1, <span class="keyword">sizeof</span>(int),
        <a class="code" href="Scatter_8cpp.html#a727b40392ca2280ef4b3f158a4225b48">fct_cmp_index_coord</a>);

<span class="comment">// Construction du tableau de correspondance tel que</span>
<span class="comment">// sommet1(correspondance[i], ...) == sommet2(i, ...)</span>
  <span class="keywordtype">int</span> nb_sommets_non_trouves = 0;
  <span class="keywordtype">int</span> nb_echec_dichotomie = 0;
  {
    <span class="keywordtype">int</span> i;
    <span class="keywordflow">for</span> (i = 0; i &lt; nb_sommets2; i++)
      {
        <span class="keyword">const</span> <span class="keywordtype">double</span> * s2 = &amp; sommets2(i,0);
        <span class="keywordtype">int</span> num_sommet = -1;

<span class="comment">// D&#39;abord recherche du sommet dans le tableau sommets1 par dichotomie (bsearch)</span>
        <span class="keywordtype">int</span> imin = 0;
        <span class="keywordtype">int</span> imax = nb_sommets1 - 1;
        <span class="keywordtype">int</span> resu_cmp = -1;
        <span class="keywordtype">int</span> k = -1;
        <span class="keywordflow">while</span> (imax &gt; imin)
          {
            <span class="keyword">const</span> <span class="keywordtype">int</span> milieu = (imin + imax) &gt;&gt; 1; <span class="comment">//!&lt; (min+max)/2</span>
<span class="comment"></span>            k = index[milieu];
            <span class="keyword">const</span> <span class="keywordtype">double</span> * s1 = &amp; sommets1(k, 0);
            resu_cmp = <a class="code" href="Scatter_8cpp.html#a06420c19a824af0906036ca04758d81c">fct_cmp_coordonnees</a>(s1, s2);
            <span class="keywordflow">switch</span>(resu_cmp)
              {
              <span class="keywordflow">case</span> -1:
                imin = milieu + 1;
                <span class="keywordflow">break</span>; <span class="comment">//!&lt; s1&lt;s2</span>
<span class="comment"></span>              <span class="keywordflow">case</span> 1 :
                imax = milieu - 1;
                <span class="keywordflow">break</span>; <span class="comment">//!&lt; s1&gt;s2</span>
<span class="comment"></span>              <span class="keywordflow">default</span>:
                imin = imax = milieu;
                <span class="keywordflow">break</span>; <span class="comment">//!&lt; s1==s2</span>
<span class="comment"></span>              }
          }
        <span class="keywordflow">if</span> (resu_cmp != 0)
          {
            k = index[imin];
            <span class="keyword">const</span> <span class="keywordtype">double</span> * s1 = &amp; sommets1(k, 0);
            resu_cmp = <a class="code" href="Scatter_8cpp.html#a06420c19a824af0906036ca04758d81c">fct_cmp_coordonnees</a>(s1, s2);
          }
        <span class="keywordflow">if</span> (resu_cmp == 0)
          {
            num_sommet = k;
          }
        <span class="keywordflow">else</span>
          {
            nb_echec_dichotomie++;
<span class="comment">// Si echec, c&#39;est peut-etre que le tableau n&#39;est pas ordonne correctement</span>
<span class="comment">// =&gt; recherche du sommet en parcourant tout le tableau</span>
            <span class="keywordtype">int</span> j;
            <span class="keywordflow">for</span> (j = 0; j &lt; nb_sommets1; j++)
              {
                <span class="keyword">const</span> <span class="keywordtype">double</span> * s1 = &amp; sommets1(j,0);
                resu_cmp = <a class="code" href="Scatter_8cpp.html#a06420c19a824af0906036ca04758d81c">fct_cmp_coordonnees</a>(s1, s2);
                <span class="keywordflow">if</span> (resu_cmp == 0)
                  <span class="keywordflow">break</span>;
              }
            <span class="keywordflow">if</span> (j &lt; nb_sommets1)
              num_sommet = j;
            <span class="keywordflow">else</span>
              nb_sommets_non_trouves++;
          }

        correspondance[i] = num_sommet;
      }
  }
  <a class="code" href="Scatter_8cpp.html#a09e112f8a32312a1675f7e33b94df122">fct_cmp_coord_dimension</a> = 0;
  <a class="code" href="Scatter_8cpp.html#a81c1304205b09abc2acc284f8adc390c">fct_cmp_coord_epsilon</a>   = -1.;
  <a class="code" href="Scatter_8cpp.html#a107a2fbce3e368271c492cfcf7cfca10">fct_cmp_coord_tableau</a>   = 0;

  <span class="keywordflow">if</span> (nb_echec_dichotomie &gt; 0)
    <a class="code" href="classProcess.html#a57e0f54b11e6eaadbea224fa904b18dd" title="Renvoie un objet statique de type Sortie qui sert de journal d&#39;evenements. Si message_level &lt;= verbose...">Process::Journal</a>() &lt;&lt; <span class="stringliteral">&quot;Chercher_Correspondance Dichotomy failure rate &quot;</span>
                       &lt;&lt; nb_echec_dichotomie &lt;&lt; <span class="stringliteral">&quot; / &quot;</span> &lt;&lt; nb_sommets2 &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;

  <span class="keywordflow">return</span> nb_sommets_non_trouves;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a12daf3ea958d39cbeb04c87ec60369f7"></a><!-- doxytag: member="Scatter::construire_correspondance_aretes_par_coordonnees" ref="a12daf3ea958d39cbeb04c87ec60369f7" args="(Zone_VF &amp;zvf)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Scatter::construire_correspondance_aretes_par_coordonnees </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classZone__VF.html">Zone_VF</a> &amp;&#160;</td>
          <td class="paramname"><em>zvf</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Scatter_8cpp_source.html#l02840">2840</a> of file <a class="el" href="Scatter_8cpp_source.html">Scatter.cpp</a>.</p>

<p>References <a class="el" href="Joint_8h_source.html#l00066">Joint::ARETE</a>, <a class="el" href="Scatter_8cpp_source.html#l02653">construire_correspondance_items_par_coordonnees()</a>, <a class="el" href="Zone_8h_source.html#l01098">Zone::faces_joint()</a>, <a class="el" href="Zone__VF_8h_source.html#l00718">Zone_VF::xa()</a>, and <a class="el" href="Zone__dis__base_8h_source.html#l00106">Zone_dis_base::zone()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <a class="code" href="classScatter.html#a06ae2df37becb17fe4e7b2e8c9c07cbd" title="Methode obsolete (utilisee avec l&#39;ancien decoupeur). On suppose que le domaine contient les structure...">construire_correspondance_items_par_coordonnees</a>(zvf.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#a16f273a76321d31435995cdad664285a" title="Renvoie la liste des joints de la zone. (version const)">faces_joint</a>(), <a class="code" href="classJoint.html#a1e2d15d088c27c9b7b11c02bf4d2c926a7816c69408b98e1161f1f54e7b6b1cb4">Joint::ARETE</a>, zvf.<a class="code" href="classZone__VF.html#a6ad5a2a03fc2cba4247a6ebe662b1320">xa</a>());
}
</pre></div>
</div>
</div>
<a class="anchor" id="a06ae2df37becb17fe4e7b2e8c9c07cbd"></a><!-- doxytag: member="Scatter::construire_correspondance_items_par_coordonnees" ref="a06ae2df37becb17fe4e7b2e8c9c07cbd" args="(Joints &amp;joints, const Joint::Type_Item type_item, const DoubleTab &amp;coord_items)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Scatter::construire_correspondance_items_par_coordonnees </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classJoints.html">Joints</a> &amp;&#160;</td>
          <td class="paramname"><em>joints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classJoint.html#a1e2d15d088c27c9b7b11c02bf4d2c926">Joint::Type_Item</a>&#160;</td>
          <td class="paramname"><em>type_item</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>coord_items</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Methode obsolete (utilisee avec l'ancien decoupeur).<br/>
On suppose que le domaine contient les structures suivantes:<br/>
* zone(0).faces_joint[i].sommets() (les sommets de joint isoles)<br/>
* zone(0).faces_joint[i].faces().les_sommets (les sommets des faces de joint)<br/>
et que chaque processeur contient une portion d'un domaine complet.<br/>
On remplit les tableaux joint_item(Joint::Type_Item).items_communs pour tous les joints de la<br/>
zone 0 du domaine et renum_items_communs.<br/>
Ordre d'apparition des items : ordre croissant de l'indice du<br/>
sommet sur le processeur de rang le plus petit<br/>
Cette methode doit etre appelee simultanement sur tous les processeurs<br/>
du groupe et ne s'applique qu'aux items ARETE et SOMMET<br/>
L'algorithme utilise les coordonnees des items pour retrouver la<br/>
correspondance entre les items de joint. </p>

<p>Definition at line <a class="el" href="Scatter_8cpp_source.html#l02653">2653</a> of file <a class="el" href="Scatter_8cpp_source.html">Scatter.cpp</a>.</p>

<p>References <a class="el" href="Joint_8h_source.html#l00066">Joint::ARETE</a>, <a class="el" href="Schema__Comm_8cpp_source.html#l00166">Schema_Comm::begin_comm()</a>, <a class="el" href="Scatter_8cpp_source.html#l02010">calculer_liste_complete_items_joint()</a>, <a class="el" href="Scatter_8cpp_source.html#l01353">calculer_renum_items_communs()</a>, <a class="el" href="EntreeSortie_8h_source.html#l00032">Cerr</a>, <a class="el" href="Scatter_8cpp_source.html#l02512">Chercher_Correspondance()</a>, <a class="el" href="Objet__U_8h_source.html#l00079">Objet_U::dimension</a>, <a class="el" href="Schema__Comm_8cpp_source.html#l00380">Schema_Comm::echange_taille_et_messages()</a>, <a class="el" href="Schema__Comm_8cpp_source.html#l00430">Schema_Comm::end_comm()</a>, <a class="el" href="Process_8cpp_source.html#l00223">Process::exit()</a>, <a class="el" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>, <a class="el" href="Process_8cpp_source.html#l00117">Process::me()</a>, <a class="el" href="Joint_8cpp_source.html#l00099">Joint::PEvoisin()</a>, <a class="el" href="Objet__U_8h_source.html#l00080">Objet_U::precision_geom</a>, <a class="el" href="Schema__Comm_8cpp_source.html#l00494">Schema_Comm::recv_buffer()</a>, <a class="el" href="DoubleTab_8cpp_source.html#l00335">DoubleTab::resize()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00240">ArrOfInt::resize_array()</a>, <a class="el" href="Schema__Comm_8cpp_source.html#l00477">Schema_Comm::send_buffer()</a>, <a class="el" href="Joint__Items_8cpp_source.html#l00056">Joint_Items::set_items_communs()</a>, <a class="el" href="Joint_8cpp_source.html#l00159">Joint::set_joint_item()</a>, <a class="el" href="Schema__Comm_8cpp_source.html#l00146">Schema_Comm::set_send_recv_pe_list()</a>, <a class="el" href="liste_8cpp_source.html#l00175">liste::size()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00342">ArrOfInt::size_array()</a>, <a class="el" href="Joint_8h_source.html#l00066">Joint::SOMMET</a>, and <a class="el" href="Vect_8h_source.html#l00026">VECT</a>.</p>

<p>Referenced by <a class="el" href="Scatter_8cpp_source.html#l02840">construire_correspondance_aretes_par_coordonnees()</a>, and <a class="el" href="Scatter_8cpp_source.html#l02832">construire_correspondance_sommets_par_coordonnees()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">switch</span>(type_item)
    {
    <span class="keywordflow">case</span> <a class="code" href="classJoint.html#a1e2d15d088c27c9b7b11c02bf4d2c926a050aa4faf237e25faef6fff15ffc20f8">Joint::SOMMET</a>:
      ;
      <span class="keywordflow">break</span>;
    <span class="keywordflow">case</span> <a class="code" href="classJoint.html#a1e2d15d088c27c9b7b11c02bf4d2c926a7816c69408b98e1161f1f54e7b6b1cb4">Joint::ARETE</a>:
      ;
      <span class="keywordflow">break</span>;
    <span class="keywordflow">default</span>:
      <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Scatter::construire_correspondance_items_par_coordonnees unusable for item &quot;</span>
           &lt;&lt; (int)type_item
           &lt;&lt; finl;
      <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">Process::exit</a>();
    }
  <span class="keyword">const</span> <span class="keywordtype">int</span> dim = <a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>;
  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_joints = joints.<a class="code" href="classliste.html#ab47f280662ff68f9aa2e00e50431c5dc" title="Renvoie la taille de la liste Une liste vide est de taille nulle.">size</a>();

<span class="comment">// Indices des items de joints dans le domaine sur mon processeur</span>
  <a class="code" href="Vect_8h.html#adc7c7b04809c9aec2cb897cd2ef06378">VECT</a>(<a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>)  indices_items_locaux(nb_joints);
<span class="comment">// Indices des items de joints dans le domaine sur le processeur voisin</span>
  <a class="code" href="Vect_8h.html#adc7c7b04809c9aec2cb897cd2ef06378">VECT</a>(<a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>)  indices_items_distants(nb_joints);
<span class="comment">// Coordonnees des items correspondants (dans le meme ordre que indices_items_xxx)</span>
  <a class="code" href="Vect_8h.html#adc7c7b04809c9aec2cb897cd2ef06378">VECT</a>(<a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>) coord_items_locaux(nb_joints);
  <a class="code" href="Vect_8h.html#adc7c7b04809c9aec2cb897cd2ef06378">VECT</a>(<a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>) coord_items_distants(nb_joints);

<span class="comment">// Remplissage des tableaux indices_items_locaux</span>
<span class="comment">// et coord_items_locaux</span>
  {
    <span class="keywordtype">int</span> i_joint;
    <span class="keywordflow">for</span> (i_joint = 0; i_joint &lt; nb_joints; i_joint++)
      {
        <span class="keyword">const</span> <a class="code" href="classJoint.html" title="La classe Joint est une Frontiere qui contient les faces et les sommets de joint avec la zone PEvoisi...">Joint</a>&amp; joint = joints[i_joint];
        <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; items = indices_items_locaux[i_joint];
<span class="comment">// Remarque: **LISTE_TRI** les indices_items_locaux sont</span>
<span class="comment">// tries dans l&#39;ordre croissant:</span>
        <a class="code" href="Scatter_8cpp.html#a9ce09df49a63406b606ce247e3880d96">calculer_liste_complete_items_joint</a>(joint, type_item, items);

        <span class="keyword">const</span> <span class="keywordtype">int</span> n       = items.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>();
        <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp;   coord   = coord_items_locaux[i_joint];
        <span class="keywordtype">int</span> i, j;
        coord.<a class="code" href="classDoubleTab.html#ae83b4d31205c53d9c8d2b43da178ce75" title="Change la taille du vecteur (identique a resize_array() pour le traitement des anciennes valeurs et d...">resize</a>(n, dim);
        <span class="keywordflow">for</span> (i = 0; i &lt; n; i++)
          <span class="keywordflow">for</span> (j = 0; j &lt; dim; j++)
            coord(i,j) = coord_items(items[i], j);
      }
  }

<span class="comment">// Envoi des indices et coordonnees locaux au processeur voisin</span>
  {
    <a class="code" href="classSchema__Comm.html">Schema_Comm</a> schema_comm;
    <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> liste_pe_voisins(nb_joints);
    <span class="keywordtype">int</span> i;
    <span class="keywordflow">for</span> (i = 0; i &lt; nb_joints; i++)
      liste_pe_voisins[i] = joints[i].PEvoisin();
    schema_comm.<a class="code" href="classSchema__Comm.html#ad11c9b47999c294c26ae4df8d2bbd57b" title="Definit la liste des processeurs a qui on va envoyer et de qui on va recevoir des donnees...">set_send_recv_pe_list</a>(liste_pe_voisins, liste_pe_voisins);
    schema_comm.<a class="code" href="classSchema__Comm.html#ac617b53de22748cdd9fa30a0cfd0f4a8" title="Statut passe a WRITING Autorise si status_ == WRITING:">begin_comm</a>();
    <span class="keywordflow">for</span> (i = 0; i &lt; nb_joints; i++)
      {
        <span class="keyword">const</span> <span class="keywordtype">int</span> pe = liste_pe_voisins[i];
        <a class="code" href="classSortie.html" title="Classe de base des flux de sortie. Elle sait ecrire des types simples&lt;br&gt;(entiers, flottants) et des Ob...">Sortie</a>&amp; buffer = schema_comm.<a class="code" href="classSchema__Comm.html#a6c771eae3b46250ae0d2f0126a7d8065" title="renvoie le buffer correspondant au processeur num_PE pour y entasser des donnees a envoyer...">send_buffer</a>(pe);
        buffer &lt;&lt; indices_items_locaux[i];
        buffer &lt;&lt; coord_items_locaux[i];
      }
    schema_comm.<a class="code" href="classSchema__Comm.html#abca0e8ac6c2b742d26f3cfaee0690c72" title="Statut passe a EXCHANGED.">echange_taille_et_messages</a>();
    <span class="keywordflow">for</span> (i = 0; i &lt; nb_joints; i++)
      {
        <span class="keyword">const</span> <span class="keywordtype">int</span> pe = liste_pe_voisins[i];
        <a class="code" href="classEntree.html" title="Classe de definition des operateurs et methodes pour toute lecture dans un flot d&#39;entree (fichier...">Entree</a>&amp; buffer = schema_comm.<a class="code" href="classSchema__Comm.html#a0c056eb81ab8fd513912b336b4d13a1a" title="renvoie le buffer correspondant au processeur num_PE pour y lire les donnees recues. Le schema doit etre dans l&#39;etat EXCHANGED.">recv_buffer</a>(pe);
        buffer &gt;&gt; indices_items_distants[i];
        buffer &gt;&gt; coord_items_distants[i];
      }
    schema_comm.<a class="code" href="classSchema__Comm.html#a73a981f88b6ffebc150fb46c5cce75d9" title="Statut passe a RESET Accesseurs:">end_comm</a>();
  }

<span class="comment">// Boucle sur les joints</span>
  {
<span class="comment">// Cette fois, on modifie les joints (remplissage de renum_virt_loc)</span>
    <span class="keyword">const</span> <span class="keywordtype">int</span> moi = <a class="code" href="classProcess.html#ab55ba07167ec807ed3a145cac0f5dca4" title="renvoie mon rang dans le groupe de communication courant. Voir Comm_Group::rank() et PE_Groups::curre...">Process::me</a>();
    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i_joint = 0; i_joint &lt; nb_joints; i_joint++)
      {
        <a class="code" href="classJoint.html" title="La classe Joint est une Frontiere qui contient les faces et les sommets de joint avec la zone PEvoisi...">Joint</a>&amp;           joint           = joints[i_joint];
        <span class="keyword">const</span> <span class="keywordtype">int</span>     PEvoisin        = joint.<a class="code" href="classJoint.html#a0952bc5c7805434ccd8cd5c9b01e3747" title="Renvoie PEvoisin (numero de la zone voisine)">PEvoisin</a>();
        <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; indices_locaux  = indices_items_locaux[i_joint];
<span class="comment">// ArrOfInt &amp;       indices_distants= indices_items_distants[i_joint];</span>
        <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; coord_locaux    = coord_items_locaux[i_joint];
        <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; coord_distants  = coord_items_distants[i_joint];
        <span class="keyword">const</span> <span class="keywordtype">int</span> n = indices_locaux.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>();
        <span class="comment">/*</span>
<span class="comment">          if (n != indices_distants.size_array()) {</span>
<span class="comment">          Cerr &lt;&lt; &quot;Error in Scatter::remplir_renum_virt_loc on PE &quot;</span>
<span class="comment">          &lt;&lt; Process::me();</span>
<span class="comment">          Cerr &lt;&lt; &quot;\n Joint with PE &quot; &lt;&lt; joint.PEvoisin()</span>
<span class="comment">          &lt;&lt; &quot;\n Number of items &quot; &lt;&lt; type_item &lt;&lt; &quot; on my joint : &quot; &lt;&lt; n;</span>
<span class="comment">          Cerr &lt;&lt; &quot;\n Number of items &quot; &lt;&lt; type_item &lt;&lt; &quot; on the remote joint : &quot;</span>
<span class="comment">          &lt;&lt; indices_distants.size_array()</span>
<span class="comment">          &lt;&lt; finl;</span>
<span class="comment">          exit();</span>
<span class="comment">          } */</span>
<span class="comment">// Recherche des correspondances entre items</span>
        <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> corresp(n);
        <span class="keyword">const</span> <span class="keywordtype">double</span> epsilon = <a class="code" href="classObjet__U.html#a7447e25c68cc8d3a1c06cf99f0565cff">Objet_U::precision_geom</a>;
        <a class="code" href="classScatter.html#a16a9000e31ccecd2438c8f05e41cc302" title="Construit le tableau &quot;correspondance&quot; tel que Pour 0 &lt;= i &lt; sommets2.size_array(), Si sommet2(i) existe dans le tableau sommet1, alors sommets2(i, ...) == sommets1(correspondance[i], ...) Sinon correspondance[i] = -1 L&#39;egalite est verifiee a epsilon pres en absolu (soit abs(x1-x2)&lt;epsilon) L&#39;algorithme est generalement en n1*log(n1) + n2*log(n1) (recherche basee sur un quicksort). En cas d&#39;echec du tri, on utilise un algorithme en n1*n2. Les tableaux sommets1 et sommets2 doivent etre de dimension 2 Le tableau correspondance doit etre de taille sommets2.size_array(). Valeur de retour: nombre de sommets de sommets2 non trouves dans le tableau sommets1.">Chercher_Correspondance</a>(coord_distants, coord_locaux, corresp, epsilon);

        <span class="keywordtype">int</span> nb_items_communs_trouves=0;
        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k = 0; k &lt; n; k++)
          <span class="keywordflow">if</span> (corresp[k]&gt;=0) nb_items_communs_trouves++;

        <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; items_communs = joint.<a class="code" href="classJoint.html#aa1c4d729a3017082d26907d82ad1d7de" title="Renvoie les informations de joint pour un type d&#39;item geometrique donne, pour remplissage des structu...">set_joint_item</a>(type_item).<a class="code" href="classJoint__Items.html#aa01c4601d506c658f4f1d45e66951ce0" title="Renvoie le tableau items_communs_ pour le remplir. (BM: ce tableau n&#39;est pas encore rempli)...">set_items_communs</a>();
        items_communs.<a class="code" href="classArrOfInt.html#a9b3afbb46b16870dbd36236c8935b535">resize_array</a>(nb_items_communs_trouves);
        items_communs = -1;
        <span class="keywordtype">int</span> i=0;
        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k = 0; k &lt; n; k++)
          {
            <span class="keyword">const</span> <span class="keywordtype">int</span> i_local = indices_locaux[k];
<span class="comment">// Le j-ieme item distant est identique au k-ieme item local</span>
            <span class="keyword">const</span> <span class="keywordtype">int</span> j = corresp[k];

<span class="comment">// Pas trouve ? Erreur possible</span>
            <span class="keywordflow">if</span> (j &lt; 0)
              {
                <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Error in Scatter::remplir_renum_virt_loc on PE &quot;</span> &lt;&lt; moi &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>
                     &lt;&lt; <span class="stringliteral">&quot;The item of type &quot;</span> &lt;&lt; (int)type_item &lt;&lt; <span class="stringliteral">&quot; number &quot;</span> &lt;&lt; i_local &lt;&lt; <span class="stringliteral">&quot; with coordinates &quot;</span>;
                <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k2 = 0; k2 &lt; dim; k2++)
                  <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; coord_locaux(i, k2) &lt;&lt; <span class="stringliteral">&quot; &quot;</span>;
                <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a> &lt;&lt; <span class="stringliteral">&quot;was not found in the joint with the PE &quot;</span> &lt;&lt; PEvoisin &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
                <span class="keywordflow">if</span> (type_item==3)
                  {
                    <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;The searching algorithm of the isolated edges on a joint&quot;</span> &lt;&lt; finl;
                    <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;does not work yet in some cases. Two isolated nodes of a joint (example below&quot;</span> &lt;&lt; finl;
                    <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;joint between 0 and 2) can be those of an edge not belonging to this joint (below&quot;</span> &lt;&lt; finl;
                    <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;the edge belongs to the joint 0-1 but not 0-2):&quot;</span> &lt;&lt; finl;
<span class="comment">// Cerr &lt;&lt; &quot;  ________    &quot; &lt;&lt; finl;</span>
<span class="comment">// Cerr &lt;&lt; &quot;1\ 2/1\2 /1\  &quot; &lt;&lt; finl;</span>
<span class="comment">// Cerr &lt;&lt; &quot;__\/___\/___\ &quot; &lt;&lt; finl;</span>
<span class="comment">// Cerr &lt;&lt; &quot; 0/\ 0 /\ 0   &quot; &lt;&lt; finl;</span>
<span class="comment">// Cerr &lt;&lt; &quot; / 0\ / 0\    &quot; &lt;&lt; finl;</span>
                    <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;  ________      &quot;</span> &lt;&lt; finl;
                    <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;1\\ 2/1\\2 /1\\ &quot;</span> &lt;&lt; finl;
                    <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;__\\/___\\/___\\&quot;</span> &lt;&lt; finl;
                    <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot; 0/\\ 0 /\\ 0   &quot;</span> &lt;&lt; finl;
                    <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot; / 0\\ / 0\\    &quot;</span> &lt;&lt; finl;
                    <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; finl;
                    <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;One way to by-pass this problem is to split again your domain with&quot;</span> &lt;&lt; finl;
                    <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;different options of splitting or with another splitter to do not fall&quot;</span> &lt;&lt; finl;
                    <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;on the same configuration.&quot;</span> &lt;&lt; finl;
                  }
                <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">exit</a>();
              }
            <span class="keywordflow">else</span>
              {
                <span class="keywordflow">if</span> (moi &lt; PEvoisin)
                  {
<span class="comment">// items communs dans l&#39;ordre des items de joint locaux:</span>
                    items_communs[i] = i_local;
<span class="comment">// On verifie que c&#39;est bien l&#39;ordre croissant de l&#39;indice local</span>
<span class="comment">// (voir **LISTE_TRI**)</span>
                    assert(i==0 || items_communs[i] &gt; items_communs[i-1]);
                  }
                <span class="keywordflow">else</span>
                  {
<span class="comment">// items communs dans l&#39;ordre des items sur le voisin:</span>
                    assert(items_communs[j] &lt; 0);
                    items_communs[j] = i_local;
                  }
                i++;
              }
          }
        assert(i==nb_items_communs_trouves);
      }
<span class="comment">// Remplissage de renum_items_communs:</span>
    <a class="code" href="classScatter.html#a21f166c05df9be1fc1f02b0604624fe5" title="On suppose que chaque joint[i].joint_item(type_item).items_communs() contient les indices locaux des ...">calculer_renum_items_communs</a>(joints, type_item);
  }
}
</pre></div>
</div>
</div>
<a class="anchor" id="acafac38fc2983e19398c403a9235bb4c"></a><!-- doxytag: member="Scatter::construire_correspondance_sommets_par_coordonnees" ref="acafac38fc2983e19398c403a9235bb4c" args="(Domaine &amp;dom)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Scatter::construire_correspondance_sommets_par_coordonnees </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDomaine.html">Domaine</a> &amp;&#160;</td>
          <td class="paramname"><em>dom</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construction des tableaux joint_item(Joint::SOMMET).items_communs de tous les joints de la zone(0) du domaine dom. </p>

<p>Definition at line <a class="el" href="Scatter_8cpp_source.html#l02832">2832</a> of file <a class="el" href="Scatter_8cpp_source.html">Scatter.cpp</a>.</p>

<p>References <a class="el" href="Scatter_8cpp_source.html#l02653">construire_correspondance_items_par_coordonnees()</a>, <a class="el" href="Domaine_8h_source.html#l00500">Domaine::coord_sommets()</a>, <a class="el" href="Zone_8h_source.html#l01098">Zone::faces_joint()</a>, <a class="el" href="Joint_8h_source.html#l00066">Joint::SOMMET</a>, and <a class="el" href="Domaine_8h_source.html#l00272">Domaine::zone()</a>.</p>

<p>Referenced by <a class="el" href="Raffiner__isotrope__parallele_8cpp_source.html#l00198">Raffiner_isotrope_parallele::interpreter()</a>, and <a class="el" href="MaillerParallel_8cpp_source.html#l00534">MaillerParallel::interpreter()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <a class="code" href="classScatter.html#a06ae2df37becb17fe4e7b2e8c9c07cbd" title="Methode obsolete (utilisee avec l&#39;ancien decoupeur). On suppose que le domaine contient les structure...">construire_correspondance_items_par_coordonnees</a>(dom.<a class="code" href="classDomaine.html#a0e62f2bc829542fafa29e3f2c614159c" title="Renvoie la i-ieme zone du domaine. (version const)">zone</a>(0).<a class="code" href="classZone.html#a16f273a76321d31435995cdad664285a" title="Renvoie la liste des joints de la zone. (version const)">faces_joint</a>(), <a class="code" href="classJoint.html#a1e2d15d088c27c9b7b11c02bf4d2c926a050aa4faf237e25faef6fff15ffc20f8">Joint::SOMMET</a>, dom.<a class="code" href="classDomaine.html#aecd32c3eecc15cce7d1a0e468dadbf96" title="Renvoie le tableau des coordonnees des noeuds (sommets). (acces en lecture)">coord_sommets</a>());
}
</pre></div>
</div>
</div>
<a class="anchor" id="a33c68e7eff97ee92b457b50e8e3ad58d"></a><!-- doxytag: member="Scatter::construire_espace_virtuel_traduction" ref="a33c68e7eff97ee92b457b50e8e3ad58d" args="(const MD_Vector &amp;md_indice, const MD_Vector &amp;md_valeur, IntTab &amp;tableau, const int error_is_fatal=1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Scatter::construire_espace_virtuel_traduction </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMD__Vector.html">MD_Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>md_indice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMD__Vector.html">MD_Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>md_valeur</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classIntTab.html">IntTab</a> &amp;&#160;</td>
          <td class="paramname"><em>tableau</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>error_is_fatal</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construit la structure items_communs + espaces virtuels d'un tableau contenant<br/>
des indices d'items geometriques, indexe par un autre type d'item geometrique.<br/>
Exemple: tableau indexe par md_indice, contenant des indices md_valeur:<br/>
type_indice type_valeur exemple de tableau:<br/>
element sommet zone.les_elems()<br/>
face sommet faces_sommets<br/>
element face elem_faces<br/>
face element faces_voisins<br/>
element element ?<br/>
element arete elem_aretes<br/>
Nb_valeurs_max est le nombre d'items reels de type "type_valeur". </p>

<p>Definition at line <a class="el" href="Scatter_8cpp_source.html#l01762">1762</a> of file <a class="el" href="Scatter_8cpp_source.html">Scatter.cpp</a>.</p>

<p>References <a class="el" href="EntreeSortie_8h_source.html#l00032">Cerr</a>, <a class="el" href="Array__base_8h_source.html#l00038">Array_base::COPY_NOINIT</a>, <a class="el" href="MD__Vector__tools_8cpp_source.html#l00039">creer_tableau_distribue()</a>, <a class="el" href="IntTab_8h_source.html#l00244">IntTab::dimension_tot()</a>, <a class="el" href="Process_8cpp_source.html#l00223">Process::exit()</a>, <a class="el" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>, <a class="el" href="IntVect_8h_source.html#l00087">IntVect::get_md_vector()</a>, <a class="el" href="classMD__Vector__base.html#ade0ef13d456f8aa11d02f51fd7912145">MD_Vector_base::get_nb_items_reels()</a>, <a class="el" href="classMD__Vector__base.html#a27d5ace2aee5ecf1d78accb7b321108d">MD_Vector_base::get_nb_items_tot()</a>, <a class="el" href="Scatter_8cpp_source.html#l01561">Traduction_Indice_Global_Local::initialiser()</a>, <a class="el" href="Process_8cpp_source.html#l00117">Process::me()</a>, <a class="el" href="Scatter_8cpp_source.html#l01725">Traduction_Indice_Global_Local::traduire_espace_virtuel()</a>, and <a class="el" href="MD__Vector_8h_source.html#l00067">MD_Vector::valeur()</a>.</p>

<p>Referenced by <a class="el" href="Periodique_8cpp_source.html#l00072">Periodique::completer()</a>, <a class="el" href="Scatter_8cpp_source.html#l00714">construire_structures_paralleles()</a>, <a class="el" href="Zone__VF_8cpp_source.html#l00112">Zone_VF::discretiser()</a>, <a class="el" href="Faces__builder_8cpp_source.html#l00751">Zone::init_faces_virt_bord()</a>, and <a class="el" href="Reordonner__faces__periodiques_8cpp_source.html#l00289">Reordonner_faces_periodiques::renum_som_perio()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">if</span> (tableau.<a class="code" href="classIntTab.html#a71e9b9ddc1793094b1b3f109377952b1" title="Returns the total dimensions of the multi-dimensionnal array, including virtual items (used in parall...">dimension_tot</a>(0) != md_indice.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#ade0ef13d456f8aa11d02f51fd7912145">get_nb_items_reels</a>()
      &amp;&amp; (tableau.<a class="code" href="classIntTab.html#a71e9b9ddc1793094b1b3f109377952b1" title="Returns the total dimensions of the multi-dimensionnal array, including virtual items (used in parall...">dimension_tot</a>(0) != md_indice.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a27d5ace2aee5ecf1d78accb7b321108d">get_nb_items_tot</a>()))
    {
      <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;[PE &quot;</span> &lt;&lt; <a class="code" href="classProcess.html#ab55ba07167ec807ed3a145cac0f5dca4" title="renvoie mon rang dans le groupe de communication courant. Voir Comm_Group::rank() et PE_Groups::curre...">Process::me</a>()
           &lt;&lt; <span class="stringliteral">&quot;] Error in Scatter::construire_espace_virtuel_traduction\n&quot;</span>
           &lt;&lt; <span class="stringliteral">&quot; the array does not have the good dimension on input&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
      <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">exit</a>();
    }
<span class="comment">// Construction du dictionnaire indice global/indice local</span>
<span class="comment">// pour les valeurs du tableau</span>
  <a class="code" href="classTraduction__Indice__Global__Local.html" title="Cette classe fournit les outils pour construire l&#39;espace virtuel d&#39;un tableau contenant des indices d...">Traduction_Indice_Global_Local</a> dictionnaire_indices;
  dictionnaire_indices.<a class="code" href="classTraduction__Indice__Global__Local.html#af8aae1bb5e815066c64937bde87b7e8a" title="Initialise le dictionnaire Precontition: Les espaces distants des entites utilisees doivent avoir ete...">initialiser</a>(md_valeur);

<span class="comment">// Construit la structure d&#39;espaces virtuels du &quot;tableau&quot;</span>
  <span class="keywordflow">if</span> (!(tableau.<a class="code" href="classIntVect.html#ae74e1fee6aca124d32718267e33a40c6">get_md_vector</a>() == md_indice))
    <a class="code" href="MD__Vector__tools_8cpp.html#aff1ed2791dba1a76fdb300920147cfdf">MD_Vector_tools::creer_tableau_distribue</a>(md_indice, tableau, <a class="code" href="classArray__base.html#abee342aa9ac59623c4c782dc9d7877ffac85954f9768f1ed2b14e58cea8ddb7c5">Array_base::COPY_NOINIT</a>);

<span class="comment">// Remplissage des valeurs vituelles du &quot;tableau&quot;</span>
  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_erreurs =
    dictionnaire_indices.<a class="code" href="classTraduction__Indice__Global__Local.html#a9a0510ebef5ce63dcfcf00e35c0578c3" title="A partir d&#39;un tableau dont la structure d&#39;espace virtuel est initialisee&lt;br&gt;(descripteurs elements dist...">traduire_espace_virtuel</a>(tableau);

  <span class="keywordflow">if</span> (nb_erreurs &gt; 0 &amp;&amp; error_is_fatal)
    {
      <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;[PE &quot;</span> &lt;&lt; <a class="code" href="classProcess.html#ab55ba07167ec807ed3a145cac0f5dca4" title="renvoie mon rang dans le groupe de communication courant. Voir Comm_Group::rank() et PE_Groups::curre...">Process::me</a>()
           &lt;&lt; <span class="stringliteral">&quot;] Error in Scatter::construire_espace_virtuel_traduction\n&quot;</span>
           &lt;&lt; <span class="stringliteral">&quot; some indices of values were not found in\n&quot;</span>
           &lt;&lt; <span class="stringliteral">&quot; the local area : it missing virtual items&quot;</span>
           &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
      <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">exit</a>();
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="ae226bc9cab92d0a02b88e2fe014e4a44"></a><!-- doxytag: member="Scatter::construire_md_vector" ref="ae226bc9cab92d0a02b88e2fe014e4a44" args="(const Domaine &amp;, int nb_items_reels, const Joint::Type_Item, MD_Vector &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Scatter::construire_md_vector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDomaine.html">Domaine</a> &amp;&#160;</td>
          <td class="paramname"><em>dom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nb_items_reels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classJoint.html#a1e2d15d088c27c9b7b11c02bf4d2c926">Joint::Type_Item</a>&#160;</td>
          <td class="paramname"><em>type_item</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMD__Vector.html">MD_Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>md_vector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>construction d'un <a class="el" href="classMD__Vector__std.html" title="C&#39;est le plus simple des descripteurs, utilise pour les tableaux de valeurs aux sommets, elements, faces, aretes, faces de bord, etc... Il supporte la notion d&#39;items &quot;communs&quot; (sommets du maillage partages entre plusieurs processeurs) et d&#39;items &quot;distants&quot; et &quot;virtuels&quot; (sommets, elements dans l&#39;epaisseur de joint). Voir aussi MD_Vector_composite (descripteur compose d&#39;une reunion de plusieurs descripteurs, pour le P1Bulle par exemple)">MD_Vector_std</a> a partir des informations de joint du domaine<br/>
pour le type d'item demande. </p>

<p><p>&lt; copier les anciennes valeurs ! </p>
</p>

<p>Definition at line <a class="el" href="Scatter_8cpp_source.html#l01409">1409</a> of file <a class="el" href="Scatter_8cpp_source.html">Scatter.cpp</a>.</p>

<p>References <a class="el" href="ArrOfInt_8h_source.html#l00355">ArrOfInt::append_array()</a>, <a class="el" href="communications_8cpp_source.html#l00717">comm_check_enabled()</a>, <a class="el" href="MD__Vector_8cpp_source.html#l00031">MD_Vector::copy()</a>, <a class="el" href="Array__base_8h_source.html#l00038">Array_base::COPY_NOINIT</a>, <a class="el" href="MD__Vector__tools_8cpp_source.html#l00039">creer_tableau_distribue()</a>, <a class="el" href="IntVect_8cpp_source.html#l00276">IntVect::echange_espace_virtuel()</a>, <a class="el" href="Zone_8h_source.html#l01098">Zone::faces_joint()</a>, <a class="el" href="ArrOfInt_8cpp_source.html#l01098">ArrOfInt::inject_array()</a>, <a class="el" href="Joint__Items_8cpp_source.html#l00049">Joint_Items::items_communs()</a>, <a class="el" href="Joint__Items_8cpp_source.html#l00063">Joint_Items::items_distants()</a>, <a class="el" href="Process_8cpp_source.html#l00117">Process::me()</a>, <a class="el" href="Joint__Items_8cpp_source.html#l00088">Joint_Items::nb_items_virtuels()</a>, <a class="el" href="Array__base_8h_source.html#l00038">Array_base::NOCOPY_NOINIT</a>, <a class="el" href="ArrOfInt_8h_source.html#l00240">ArrOfInt::resize_array()</a>, <a class="el" href="ArrOfInt_8cpp_source.html#l00443">ArrOfInt::set_smart_resize()</a>, <a class="el" href="liste_8cpp_source.html#l00175">liste::size()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00342">ArrOfInt::size_array()</a>, <a class="el" href="ArrOfBit_8h_source.html#l00073">ArrOfBit::testsetbit()</a>, <a class="el" href="Vect_8h_source.html#l00026">VECT</a>, and <a class="el" href="Domaine_8h_source.html#l00272">Domaine::zone()</a>.</p>

<p>Referenced by <a class="el" href="Scatter_8cpp_source.html#l00714">construire_structures_paralleles()</a>, and <a class="el" href="Zone__VF_8cpp_source.html#l00112">Zone_VF::discretiser()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">const</span> <a class="code" href="classJoints.html" title="Classe Joints Cette classe represente une liste d&#39;objet de type Joint.">Joints</a>&amp; joints  = dom.<a class="code" href="classDomaine.html#a0e62f2bc829542fafa29e3f2c614159c" title="Renvoie la i-ieme zone du domaine. (version const)">zone</a>(0).<a class="code" href="classZone.html#a16f273a76321d31435995cdad664285a" title="Renvoie la liste des joints de la zone. (version const)">faces_joint</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_joints = joints.<a class="code" href="classliste.html#ab47f280662ff68f9aa2e00e50431c5dc" title="Renvoie la taille de la liste Une liste vide est de taille nulle.">size</a>();

  <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> pe_voisins(nb_joints);
  <a class="code" href="Vect_8h.html#adc7c7b04809c9aec2cb897cd2ef06378">VECT</a>(<a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>) items_to_send(nb_joints);
  <a class="code" href="Vect_8h.html#adc7c7b04809c9aec2cb897cd2ef06378">VECT</a>(<a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>) items_to_recv(nb_joints);
  <a class="code" href="Vect_8h.html#adc7c7b04809c9aec2cb897cd2ef06378">VECT</a>(<a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>) blocs_to_recv(nb_joints);

<span class="comment">// drapeau indique si l&#39;item (commun) est recu d&#39;un processeur</span>
  <a class="code" href="classArrOfBit.html">ArrOfBit</a> flags(nb_items_reels);
  flags = 0;

  <span class="keywordtype">int</span> nitems_tot = nb_items_reels;
  const <span class="keywordtype">int</span> moi = <a class="code" href="classProcess.html#ab55ba07167ec807ed3a145cac0f5dca4" title="renvoie mon rang dans le groupe de communication courant. Voir Comm_Group::rank() et PE_Groups::curre...">me</a>();

  for (<span class="keywordtype">int</span> i_joint = 0; i_joint &lt; nb_joints; i_joint++)
    {
      <span class="keyword">const</span> <span class="keywordtype">int</span> pe = joints[i_joint].PEvoisin();
      pe_voisins[i_joint] = pe;
      <span class="keyword">const</span> <a class="code" href="classJoint__Items.html" title="Joint_Items contient les informations de distribution parallele d&#39;un item geometrique particulier ave...">Joint_Items</a>&amp; joint = joints[i_joint].joint_item(type_item);
      {
<span class="comment">// Traitement des items communs</span>
        <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; items_communs = joint.<a class="code" href="classJoint__Items.html#a435fb1629f6dafb089605913517e73c4" title="Voir items_communs_.">items_communs</a>();
        <span class="keyword">const</span> <span class="keywordtype">int</span> n = items_communs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>();

<span class="comment">// Les joints doivent arriver dans l&#39;ordre croissant du numero de pe</span>
<span class="comment">// sinon l&#39;algo suivant ne marche pas:</span>
        assert((i_joint == 0) || (pe &gt; joints[i_joint-1].PEvoisin()));
        <span class="keywordflow">if</span> (pe &gt; moi)
          {
<span class="comment">// Je dois envoyer ces items au processeur voisin</span>
            <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; dest = items_to_send[i_joint];
            dest.<a class="code" href="classArrOfInt.html#a22d744bcd452d039580d1d9186f02b4e" title="Change le mode l&#39;allocation memoire: reallocation d&#39;un tableau a chaque changement de taille (flag = ...">set_smart_resize</a>(1);
            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; n; i++)
              {
                <span class="keyword">const</span> <span class="keywordtype">int</span> item = items_communs[i];
                <span class="keywordflow">if</span> (!flags[item])
                  {
<span class="comment">// item pas recu d&#39;un processeur</span>
                    dest.<a class="code" href="classArrOfInt.html#a3f39d0966599416e7b1f7cd8159d8d01" title="Ajoute une case en fin de tableau et y stocke la &quot;valeur&quot;.">append_array</a>(item);
                  }
              }
          }
        <span class="keywordflow">else</span>
          {
<span class="comment">// Je recois cet item d&#39;un autre processeur</span>
            <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; dest = items_to_recv[i_joint];
            dest.<a class="code" href="classArrOfInt.html#a22d744bcd452d039580d1d9186f02b4e" title="Change le mode l&#39;allocation memoire: reallocation d&#39;un tableau a chaque changement de taille (flag = ...">set_smart_resize</a>(1);
            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; n; i++)
              {
                <span class="keyword">const</span> <span class="keywordtype">int</span> item = items_communs[i];
                <span class="keywordflow">if</span> (!flags.testsetbit(item))
                  {
<span class="comment">// item pas encore recu d&#39;un processeur</span>
                    dest.<a class="code" href="classArrOfInt.html#a3f39d0966599416e7b1f7cd8159d8d01" title="Ajoute une case en fin de tableau et y stocke la &quot;valeur&quot;.">append_array</a>(item);
                  }
              }
          }
      }
<span class="comment">// Traitement des items distants et virtuels</span>
      {
        <span class="keyword">const</span> <span class="keywordtype">int</span> nitems_virt = joint.<a class="code" href="classJoint__Items.html#aaaea01b8fe49417e565fff9700cacf2e" title="Voir nb_items_virtuels_.">nb_items_virtuels</a>();
        <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; dest = blocs_to_recv[i_joint];
        <span class="keywordflow">if</span> (nitems_virt &gt; 0)
          {
            dest.<a class="code" href="classArrOfInt.html#a9b3afbb46b16870dbd36236c8935b535">resize_array</a>(2, <a class="code" href="classArray__base.html#abee342aa9ac59623c4c782dc9d7877ffaf6ae9ba7eb51c5f298ce693345b3ec68">Array_base::NOCOPY_NOINIT</a>);
<span class="comment">// Definition du bloc d&#39;items virtuels pour le processeur voisin</span>
            dest[0] = nitems_tot;
            dest[1] = nitems_tot + nitems_virt;
            nitems_tot += nitems_virt;
          }
      }
      {
        <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; items_distants = joint.<a class="code" href="classJoint__Items.html#ae51b330de79fcaae9c88166e3eee7cb8" title="Voir items_distants_.">items_distants</a>();
        <span class="keyword">const</span> <span class="keywordtype">int</span> n = items_distants.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>();
        <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; dest = items_to_send[i_joint];
        <span class="keyword">const</span> <span class="keywordtype">int</span> index = dest.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>();
        dest.<a class="code" href="classArrOfInt.html#a9b3afbb46b16870dbd36236c8935b535">resize_array</a>(index + n, <a class="code" href="classArray__base.html#abee342aa9ac59623c4c782dc9d7877ffac85954f9768f1ed2b14e58cea8ddb7c5">Array_base::COPY_NOINIT</a>); <span class="comment">//!&lt; copier les anciennes valeurs !</span>
<span class="comment"></span>        dest.<a class="code" href="classArrOfInt.html#a195c644d98bf2da2fe4f8aede4e02262" title="Copie les elements source[first_element_source + i] dans les elements (*this)[first_element_dest + i]...">inject_array</a>(items_distants, n, index <span class="comment">/* dest index */</span>, 0 <span class="comment">/* src index */</span>);
      }
    }

  <a class="code" href="classMD__Vector__std.html" title="C&#39;est le plus simple des descripteurs, utilise pour les tableaux de valeurs aux sommets, elements, faces, aretes, faces de bord, etc... Il supporte la notion d&#39;items &quot;communs&quot; (sommets du maillage partages entre plusieurs processeurs) et d&#39;items &quot;distants&quot; et &quot;virtuels&quot; (sommets, elements dans l&#39;epaisseur de joint). Voir aussi MD_Vector_composite (descripteur compose d&#39;une reunion de plusieurs descripteurs, pour le P1Bulle par exemple)">MD_Vector_std</a> md(nitems_tot, nb_items_reels, pe_voisins, items_to_send, items_to_recv, blocs_to_recv);
  md_vector.<a class="code" href="classMD__Vector.html#a063644dd8ca62e707a2d059eedeb58a7" title="construction d&#39;un objet MD_Vector par copie d&#39;un objet existant. C&#39;est la methode recommandee pour cr...">copy</a>(md);

<span class="comment">// Verification que le md_vector est valide (tailles en send correspondant aux tailles en recv)</span>
  <span class="keywordflow">if</span> (<a class="code" href="communications_8cpp.html#a40943dd8a0e3ea77b7f2e7d404d9cd53" title="renvoie le drapeau Comm_Group::check_enabled(). Ce drapeau indique si le code tourne en mode DEBUG du...">comm_check_enabled</a>())
    {
      <a class="code" href="classIntVect.html">IntVect</a> toto;
      <a class="code" href="MD__Vector__tools_8cpp.html#aff1ed2791dba1a76fdb300920147cfdf">MD_Vector_tools::creer_tableau_distribue</a>(md_vector, toto);
      toto = 0;
      toto.<a class="code" href="classIntVect.html#ad12bea67621d1a0ee82b27c9a37ca4ef">echange_espace_virtuel</a>();
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="af6b88297583bd92c6ca3814bc532b8be"></a><!-- doxytag: member="Scatter::construire_structures_paralleles" ref="af6b88297583bd92c6ca3814bc532b8be" args="(Domaine &amp;dom, const Noms &amp;liste_bords_perio)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Scatter::construire_structures_paralleles </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDomaine.html">Domaine</a> &amp;&#160;</td>
          <td class="paramname"><em>dom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classNoms.html">Noms</a> &amp;&#160;</td>
          <td class="paramname"><em>liste_bords_perio</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construction des structures paralleles du domaine et de la zone<br/>
(determination des elements distants en fonction de l'epaisseur de joint,<br/>
determination des sommets distants,<br/>
creation des sommets et des elements virtuels) </p>

<p>Definition at line <a class="el" href="Scatter_8cpp_source.html#l00714">714</a> of file <a class="el" href="Scatter_8cpp_source.html">Scatter.cpp</a>.</p>

<p>References <a class="el" href="Scatter_8cpp_source.html#l02184">calculer_espace_distant_elements()</a>, <a class="el" href="Scatter_8cpp_source.html#l01289">calculer_espace_distant_sommets()</a>, <a class="el" href="Scatter_8cpp_source.html#l02864">calculer_nb_items_virtuels()</a>, <a class="el" href="Scatter_8cpp_source.html#l01762">construire_espace_virtuel_traduction()</a>, <a class="el" href="Scatter_8cpp_source.html#l01409">construire_md_vector()</a>, <a class="el" href="Scatter_8cpp_source.html#l02035">corriger_espace_distant_elements_perio()</a>, <a class="el" href="MD__Vector__tools_8cpp_source.html#l00039">creer_tableau_distribue()</a>, <a class="el" href="IntTab_8h_source.html#l00233">IntTab::dimension()</a>, <a class="el" href="DoubleTab_8h_source.html#l00243">DoubleTab::dimension()</a>, <a class="el" href="DoubleVect_8cpp_source.html#l00277">DoubleVect::echange_espace_virtuel()</a>, <a class="el" href="Champ__Generique__base_8h_source.html#l00035">ELEMENT</a>, <a class="el" href="Zone_8h_source.html#l01098">Zone::faces_joint()</a>, <a class="el" href="Zone_8h_source.html#l00402">Zone::les_elems()</a>, <a class="el" href="Domaine_8h_source.html#l00577">Domaine::les_sommets()</a>, <a class="el" href="Scatter_8cpp_source.html#l01807">reordonner_faces_de_joint()</a>, <a class="el" href="IntTab_8cpp_source.html#l00553">IntTab::set_md_vector()</a>, <a class="el" href="DoubleTab_8cpp_source.html#l00520">DoubleTab::set_md_vector()</a>, <a class="el" href="vect__impl_8h_source.html#l00057">vect_impl::size()</a>, <a class="el" href="Joint_8h_source.html#l00066">Joint::SOMMET</a>, and <a class="el" href="Domaine_8h_source.html#l00272">Domaine::zone()</a>.</p>

<p>Referenced by <a class="el" href="Scatter_8cpp_source.html#l00150">interpreter()</a>, <a class="el" href="Raffiner__isotrope__parallele_8cpp_source.html#l00198">Raffiner_isotrope_parallele::interpreter()</a>, and <a class="el" href="MaillerParallel_8cpp_source.html#l00534">MaillerParallel::interpreter()</a>.</p>
<div class="fragment"><pre class="fragment">{
<span class="comment">// D&#39;abord: supprimer les structures &quot;sequentielles&quot; associees aux sommets et elements lors de la lecture:</span>
  {
    <a class="code" href="classMD__Vector.html" title=": Cette classe est un DERIV mais l&#39;objet pointe est partage entre plusieurs instances de cette classe...">MD_Vector</a> md_nul;
    dom.<a class="code" href="classDomaine.html#a0846ac03a10b65c4df911fe35a19c02f" title="Renvoie le nombre total de sommets.">les_sommets</a>().<a class="code" href="classDoubleTab.html#a2f40241acb678b0dd0dac7ee4f421b1d" title="associe le md_vector au vecteur (voir DoubleVect::set_md_vector()) dimension(0) sera initialise a md_...">set_md_vector</a>(md_nul);
    dom.<a class="code" href="classDomaine.html#a0e62f2bc829542fafa29e3f2c614159c" title="Renvoie la i-ieme zone du domaine. (version const)">zone</a>(0).<a class="code" href="classZone.html#ac115e8342be89afb882b7b61cc343267" title="Renvoie le tableau des sommets des elements.">les_elems</a>().<a class="code" href="classIntTab.html#a02470d5d5921700f4daee05a5b3d2601" title="associe le md_vector au vecteur (voir IntVect::set_md_vector()) dimension(0) sera initialise a md_vec...">set_md_vector</a>(md_nul);
  }

<span class="comment">// L&#39;ordre d&#39;appel est important:</span>
  <a class="code" href="classScatter.html#a589c34e38a91b69c2e4b43c77bf2bd9d" title="Remplissage du tableau &quot;espace_distant()&quot; des elements dans les joints. C&#39;est ici qu&#39;on determine l...">calculer_espace_distant_elements</a>(dom);

  <span class="keywordflow">if</span> (liste_bords_periodiques.size() &gt; 0)
    <a class="code" href="classScatter.html#a07723d3697739057d469082a4c4a554f" title="Les algorithmes actuels pour le periodique (assembleur P1B, OpDivElem P1B) ont besoin que pour chaque...">corriger_espace_distant_elements_perio</a>(dom, liste_bords_periodiques);

  <a class="code" href="classScatter.html#ab8e91081aefb68562533279f2446e988" title="!&lt; Description Pour un item geometrique &quot;type_item&quot;, remplit le champ nb_items_virtuels_ des joints ...">calculer_nb_items_virtuels</a>(dom.<a class="code" href="classDomaine.html#a0e62f2bc829542fafa29e3f2c614159c" title="Renvoie la i-ieme zone du domaine. (version const)">zone</a>(0).<a class="code" href="classZone.html#a16f273a76321d31435995cdad664285a" title="Renvoie la liste des joints de la zone. (version const)">faces_joint</a>(), <a class="code" href="Champ__Generique__base_8h.html#a2228f5f8d54732b2077779d47c6f5ffba3d10bfe84917127ab3347aa5c6309f33">Joint::ELEMENT</a>);

<span class="comment">// Determination des sommets distants en fonction des elements distants</span>
  <a class="code" href="classScatter.html#a9cbfa7bf4fe3b741a56309931f4cf752" title="En fonction de l&#39;espace distant des elements, calcule l&#39;espace distant des sommets. Pour chaque joint, on envoie au processeur voisin l&#39;ensemble des sommets de tous les elements du joint. C&#39;est le processeur proprietaire du sommet&lt;br&gt;(plus petit pe qui le possede) qui le met dans son espace distant. Attention, on cree de nouveaux joints. On remplit les tableaux dom.zone(0).faces_joint(i).joint_item(Joint::SOMMET).items_distants();.">calculer_espace_distant_sommets</a>(dom, liste_bords_periodiques);

<span class="comment">// Creation des espaces distants virtuels et items communs pour les tableaux</span>
<span class="comment">// sommets et elements:</span>
  <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; sommets = dom.<a class="code" href="classDomaine.html#a0846ac03a10b65c4df911fe35a19c02f" title="Renvoie le nombre total de sommets.">les_sommets</a>();
  <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; elements = dom.<a class="code" href="classDomaine.html#a0e62f2bc829542fafa29e3f2c614159c" title="Renvoie la i-ieme zone du domaine. (version const)">zone</a>(0).<a class="code" href="classZone.html#ac115e8342be89afb882b7b61cc343267" title="Renvoie le tableau des sommets des elements.">les_elems</a>();
  <a class="code" href="classMD__Vector.html" title=": Cette classe est un DERIV mais l&#39;objet pointe est partage entre plusieurs instances de cette classe...">MD_Vector</a> md_sommets, md_elements;
  <a class="code" href="classScatter.html#ae226bc9cab92d0a02b88e2fe014e4a44" title="construction d&#39;un MD_Vector_std a partir des informations de joint du domaine pour le type d&#39;item dem...">construire_md_vector</a>(dom, sommets.<a class="code" href="classDoubleTab.html#ac3805e2637a3b880ba2d3e650c69dac4" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(0), <a class="code" href="classJoint.html#a1e2d15d088c27c9b7b11c02bf4d2c926a050aa4faf237e25faef6fff15ffc20f8">Joint::SOMMET</a>, md_sommets);
  <a class="code" href="classScatter.html#ae226bc9cab92d0a02b88e2fe014e4a44" title="construction d&#39;un MD_Vector_std a partir des informations de joint du domaine pour le type d&#39;item dem...">construire_md_vector</a>(dom, elements.<a class="code" href="classIntTab.html#abc3b32c94925a82f69d5b153a356e359" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(0), <a class="code" href="Champ__Generique__base_8h.html#a2228f5f8d54732b2077779d47c6f5ffba3d10bfe84917127ab3347aa5c6309f33">Joint::ELEMENT</a>, md_elements);
  <a class="code" href="MD__Vector__tools_8cpp.html#aff1ed2791dba1a76fdb300920147cfdf">MD_Vector_tools::creer_tableau_distribue</a>(md_sommets, sommets);
  sommets.<a class="code" href="classDoubleVect.html#abfebbc2f685ce7bc4b80c720d7da9bf3">echange_espace_virtuel</a>();
  <a class="code" href="classScatter.html#a33c68e7eff97ee92b457b50e8e3ad58d" title="Construit la structure items_communs + espaces virtuels d&#39;un tableau contenant des indices d&#39;items ge...">construire_espace_virtuel_traduction</a>(md_elements <span class="comment">/* type index */</span>,
                                       md_sommets <span class="comment">/* type valeur */</span>,
                                       elements);
<span class="comment">// Reordonner les faces de joint (correspondance implicite avec le pe voisin)</span>
  <a class="code" href="classScatter.html#a0a86d55709f7e53fcf40a09de74033cf" title="Reordonne les faces de joint de sorte qu&#39;elles apparaissent dans le meme ordre sur chaque couple de p...">reordonner_faces_de_joint</a>(dom);
}
</pre></div>
</div>
</div>
<a class="anchor" id="a07723d3697739057d469082a4c4a554f"></a><!-- doxytag: member="Scatter::corriger_espace_distant_elements_perio" ref="a07723d3697739057d469082a4c4a554f" args="(Domaine &amp;dom, const Noms &amp;liste_bords_periodiques)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Scatter::corriger_espace_distant_elements_perio </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDomaine.html">Domaine</a> &amp;&#160;</td>
          <td class="paramname"><em>dom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classNoms.html">Noms</a> &amp;&#160;</td>
          <td class="paramname"><em>liste_bords_periodiques</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Les algorithmes actuels pour le periodique (assembleur P1B, OpDivElem P1B)<br/>
ont besoin que pour chaque face virtuelle periodique, la face opposee soit<br/>
aussi virtuelle. Ceci n'est pas assure a la sortie de la methode<br/>
calculer_elements_distants. Cette methode ajoute aux elements distants les<br/>
elements manquants pour assurer cette condition:<br/>
Si un element est distant pour un PE donne est voisin d'une face periodique,<br/>
on ajoute a l'espace distant l'element adjacent a la face opposee. </p>

<p><p>&lt; Les deux elements opposes de cette face periodique </p>
</p>

<p>Definition at line <a class="el" href="Scatter_8cpp_source.html#l02035">2035</a> of file <a class="el" href="Scatter_8cpp_source.html">Scatter.cpp</a>.</p>

<p>References <a class="el" href="ArrOfInt_8h_source.html#l00355">ArrOfInt::append_array()</a>, <a class="el" href="Zone_8h_source.html#l00836">Zone::bord()</a>, <a class="el" href="EntreeSortie_8h_source.html#l00032">Cerr</a>, <a class="el" href="ArrOfBit_8h_source.html#l00085">ArrOfBit::clearbit()</a>, <a class="el" href="Connectivite__som__elem_8cpp_source.html#l00042">construire_connectivite_som_elem()</a>, <a class="el" href="Joint_8h_source.html#l00066">Joint::ELEMENT</a>, <a class="el" href="Process_8cpp_source.html#l00223">Process::exit()</a>, <a class="el" href="Connectivite__som__elem_8cpp_source.html#l00108">find_adjacent_elements()</a>, <a class="el" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>, <a class="el" href="Process_8cpp_source.html#l00095">Process::je_suis_maitre()</a>, <a class="el" href="Zone_8h_source.html#l00909">Zone::joint()</a>, <a class="el" href="Zone_8h_source.html#l00402">Zone::les_elems()</a>, <a class="el" href="Frontiere_8cpp_source.html#l00197">Frontiere::les_sommets_des_faces()</a>, <a class="el" href="Zone_8h_source.html#l00300">Zone::nb_elem()</a>, <a class="el" href="Frontiere_8h_source.html#l00114">Frontiere::nb_faces()</a>, <a class="el" href="Zone_8h_source.html#l00550">Zone::nb_joints()</a>, <a class="el" href="Domaine_8cpp_source.html#l00184">Domaine::nb_som()</a>, <a class="el" href="Elem__geom_8h_source.html#l00309">Elem_geom::nb_som_face()</a>, <a class="el" href="ArrOfInt_8cpp_source.html#l00897">ArrOfInt::ordonne_array()</a>, <a class="el" href="Joint__Items_8cpp_source.html#l00073">Joint_Items::set_items_distants()</a>, <a class="el" href="Joint_8cpp_source.html#l00159">Joint::set_joint_item()</a>, <a class="el" href="ArrOfInt_8cpp_source.html#l00443">ArrOfInt::set_smart_resize()</a>, <a class="el" href="ArrOfBit_8h_source.html#l00064">ArrOfBit::setbit()</a>, <a class="el" href="vect__impl_8h_source.html#l00057">vect_impl::size()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00342">ArrOfInt::size_array()</a>, <a class="el" href="ArrOfBit_8h_source.html#l00073">ArrOfBit::testsetbit()</a>, <a class="el" href="Zone_8h_source.html#l00491">Zone::type_elem()</a>, and <a class="el" href="Domaine_8h_source.html#l00272">Domaine::zone()</a>.</p>

<p>Referenced by <a class="el" href="Scatter_8cpp_source.html#l00714">construire_structures_paralleles()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">if</span> (<a class="code" href="classProcess.html#acd052b99706c577f8a5b6656217cf4c2" title="renvoie 1 si on est sur le processeur maitre du groupe courant (c&#39;est a dire me() == 0)...">Process::je_suis_maitre</a>())
    <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Correction of remote spaces of the elements for the periodic faces&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;

  <a class="code" href="classZone.html" title="classe Zone Une Zone est un maillage compose d&#39;un ensemble d&#39;elements geometriques de meme type...">Zone</a>&amp; zone = dom.<a class="code" href="classDomaine.html#a0e62f2bc829542fafa29e3f2c614159c" title="Renvoie la i-ieme zone du domaine. (version const)">zone</a>(0);
  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_elem = zone.<a class="code" href="classZone.html#a7f249429803b27139a1c54436f6164a5" title="Renvoie le nombre d&#39;elements de la zone.">nb_elem</a>();
  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; les_elems = zone.<a class="code" href="classZone.html#ac115e8342be89afb882b7b61cc343267" title="Renvoie le tableau des sommets des elements.">les_elems</a>();

<span class="comment">// Ce tableau contiendra pour un bord periodique donne:</span>
<span class="comment">// si l&#39;element i est adjacent a une face de ce bord,</span>
<span class="comment">// element_oppose[i] est le numero de l&#39;element adjacent a la face</span>
<span class="comment">// opposee sur ce bord.</span>
<span class="comment">// -1 sinon.</span>
  <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> element_oppose(nb_elem);

  <a class="code" href="classStatic__Int__Lists.html" title="Cette classe permet de stocker des listes d&#39;entiers accessibles en temps constant. La taille des listes ne peut pas changer sans perdre le contenu (ce sont des listes statiques). Exemple: Static_Int_List l; ArrOfInt tailles(3); tailles[0] = 2; tailles[1] = 3; tailles[2] = 0; // On reserve la memoire pour trois listes de taille 2, 3 et 0: l.set_list_sizes(tailles); // On affecte une valeur au deuxieme element de la premiere liste: l.set_value(0,1,765); // Affiche la valeur Cout &lt;&lt; l(0,1);.">Static_Int_Lists</a> connectivite_som_elem;
  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_sommets = dom.<a class="code" href="classDomaine.html#abc4abc8b8db5bebeb161fae4162a89ce" title="Renvoie le nombre de sommets.">nb_som</a>();
  <a class="code" href="Connectivite__som__elem_8cpp.html#a82161461a228e43ae236c31101ff3ce6" title="construction de la structure som_elem pour la zone donnee On cree pour chaque sommet i la liste des e...">construire_connectivite_som_elem</a>(nb_sommets,
                                   les_elems,
                                   connectivite_som_elem,
                                   0 <span class="comment">/* ne pas inclure les sommets virtuels */</span>);

  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_som_face = zone.<a class="code" href="classZone.html#a18cf83cd0f9c368dcfa32fb802a0ac94" title="Renvoie un element geometrique du type de ceux qui constituent la zone. (version const)">type_elem</a>().<a class="code" href="classElem__geom.html#ab55aa8b4ec6aa60cfde5d5fc134c5333" title="Appel a l&#39;objet sous-jacent Renvoie le nombre de sommets des faces du type specifie.">nb_som_face</a>();
  <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> une_face(nb_som_face);
  <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> elems_voisins;
  elems_voisins.<a class="code" href="classArrOfInt.html#a22d744bcd452d039580d1d9186f02b4e" title="Change le mode l&#39;allocation memoire: reallocation d&#39;un tableau a chaque changement de taille (flag = ...">set_smart_resize</a>(1);

  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_joints = zone.<a class="code" href="classZone.html#ab096afb61e89705709a4ae6d3576a644" title="Renvoie le nombre de joints de la zone.">nb_joints</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_bords_perio = liste_bords_periodiques.<a class="code" href="classvect__impl.html#a78155bfbd6b61f4710b9830641ed1694">size</a>();

<span class="comment">// Marqueurs des elements distants existants:</span>
  <a class="code" href="classArrOfBit.html">ArrOfBit</a> marqueurs_elements_distants(nb_elem);
  marqueurs_elements_distants = 0;

<span class="comment">// Le fait d&#39;ajouter un element dans un espace distant pour un bord donne</span>
<span class="comment">// peut entrainer un probleme sur un autre bord (l&#39;element oppose de l&#39;element</span>
<span class="comment">// ainsi ajoute peut manquer pour une autre direction de periodicite).</span>
<span class="comment">// Il faut dont iterer jusqu&#39;a ce que plus rien ne bouge</span>
  <span class="keywordtype">int</span> nb_elements_ajoutes = 0;
  <span class="keywordflow">do</span>
    {
      nb_elements_ajoutes = 0;
      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i_bord_perio = 0; i_bord_perio &lt; nb_bords_perio; i_bord_perio++)
        {
          <span class="keyword">const</span> <a class="code" href="classNom.html" title="class Nom Une chaine de caractere pour nommer les objets de TRUST">Nom</a>&amp; nom_bord = liste_bords_periodiques[i_bord_perio];
          <span class="keyword">const</span> <a class="code" href="classBord.html" title="Classe Bord Cette classe represente un bord d&#39;une zone, c&#39;est un type de frontiere&lt;br&gt;(derive de Fronti...">Bord</a>&amp; bord = zone.<a class="code" href="classZone.html#af2f1e6a14af55249979da674e7aac11a" title="Renvoie le i-ieme bord de la zone&lt;br&gt;(version const)">bord</a>(nom_bord);
          <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; faces_sommets = bord.<a class="code" href="classFrontiere.html#a6d1f96137ddae39a46985a8c3e53bcf5" title="Renvoie les sommets des faces de la frontiere.">les_sommets_des_faces</a>();
          <span class="keyword">const</span> <span class="keywordtype">int</span> nb_faces = bord.<a class="code" href="classFrontiere.html#aa073fe9dbdddde59471ee7032b256aa2" title="Renvoie le nombre de faces de la frontiere.">nb_faces</a>();

<span class="comment">// Premiere etape, reperer les element opposes pour ce bord periodique</span>
<span class="comment">// On boucle sur la premiere moitie de la frontiere.</span>
<span class="comment">// ATTENTION: on suppose que les faces de bords sont ordonnees : d&#39;abord toutes les faces</span>
<span class="comment">// d&#39;un cote du domaine periodique, puis, dans le meme ordre, les faces opposees.</span>
          element_oppose = -1;

          <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i_face = 0; i_face &lt; nb_faces / 2; i_face++)
            {
<span class="comment">// Pour chaque face, trouver l&#39;element adjacent a cette face et a la face opposee</span>
<span class="comment">// Boucle sur la face et la face opposee</span>
              <span class="keywordtype">int</span> elem0 = -1; <span class="comment">//!&lt; Les deux elements opposes de cette face periodique</span>
<span class="comment"></span>              <span class="keywordtype">int</span> elem1 = -1;
              <span class="keywordflow">for</span> (<span class="keywordtype">int</span> quel_cote = 0; quel_cote &lt; 2; quel_cote++)
                {
                  <span class="keyword">const</span> <span class="keywordtype">int</span> face = i_face + quel_cote * nb_faces / 2;
                  <span class="keywordtype">int</span> i;
                  <span class="keywordflow">for</span> (i = 0; i &lt; nb_som_face; i++)
                    une_face[i] = faces_sommets(face, i);
                  <a class="code" href="Connectivite__som__elem_8cpp.html#afccbadf5344a16154a56b33dbddf88c1" title="Cherche les elements qui contiennent tous les sommets du tableau sommets_to_find (permet de trouver l...">find_adjacent_elements</a>(connectivite_som_elem, une_face, elems_voisins);
                  <span class="keyword">const</span> <span class="keywordtype">int</span> n = elems_voisins.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>();
                  <span class="keywordflow">if</span> (n != 1)
                    {
                      <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Error in Scatter::corriger_espace_distant_elements_perio: \n&quot;</span>
                           &lt;&lt; <span class="stringliteral">&quot; The face &quot;</span> &lt;&lt; i_face &lt;&lt; <span class="stringliteral">&quot; of boundary &quot;</span> &lt;&lt; nom_bord &lt;&lt; <span class="stringliteral">&quot; has &quot;</span>
                           &lt;&lt; n &lt;&lt; <span class="stringliteral">&quot; neighbors.&quot;</span> &lt;&lt; finl;
                      <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">Process::exit</a>();
                    }
                  <span class="keywordflow">if</span> (quel_cote == 0)
                    elem0 = elems_voisins[0];
                  <span class="keywordflow">else</span>
                    elem1 = elems_voisins[0];
                }
              element_oppose[elem0] = elem1;
              element_oppose[elem1] = elem0;
            }
<span class="comment">// Deuxieme etape: parcourir les elements distants. Si un element distant est</span>
<span class="comment">// dans les elements jumeaux, ajouter l&#39;autre jumeau dans les elements distants</span>
          <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i_joint = 0; i_joint &lt; nb_joints; i_joint++)
            {
              <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; elements_distants = zone.<a class="code" href="classZone.html#acec4c61032df8b55a95f9e7197ef6e3c" title="Renvoie le i-ieme joint de la zone&lt;br&gt;(version const)">joint</a>(i_joint).<a class="code" href="classJoint.html#aa1c4d729a3017082d26907d82ad1d7de" title="Renvoie les informations de joint pour un type d&#39;item geometrique donne, pour remplissage des structu...">set_joint_item</a>(<a class="code" href="classJoint.html#a1e2d15d088c27c9b7b11c02bf4d2c926ae32de3a01fdb3ad6c506b8058a7f6173">Joint::ELEMENT</a>).<a class="code" href="classJoint__Items.html#a13add264f4ad36ef4bddbfc1b7bdb817" title="Renvoie le tableau items_distants_ pour le remplir Voir Scatter::calculer_espace_distant, Scatter::calculer_espace_distant_faces_frontieres, Scatter::calculer_espace_distant_elements.">set_items_distants</a>();
              <span class="keywordtype">int</span> n = elements_distants.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>();
<span class="comment">// Marquer les elements distants existants:</span>
              <span class="keywordtype">int</span> i;
              <span class="keywordflow">for</span> (i = 0; i &lt; n; i++)
                {
                  <span class="keyword">const</span> <span class="keywordtype">int</span> elem = elements_distants[i];
                  marqueurs_elements_distants.setbit(elem);
                }
              elements_distants.<a class="code" href="classArrOfInt.html#a22d744bcd452d039580d1d9186f02b4e" title="Change le mode l&#39;allocation memoire: reallocation d&#39;un tableau a chaque changement de taille (flag = ...">set_smart_resize</a>(1);
              <span class="keywordflow">for</span> (i = 0; i &lt; n; i++)
                {
                  <span class="keyword">const</span> <span class="keywordtype">int</span> elem = elements_distants[i];
                  <span class="keyword">const</span> <span class="keywordtype">int</span> elem_oppose = element_oppose[elem];
                  <span class="keywordflow">if</span> (elem_oppose &gt;= 0 &amp;&amp; (!marqueurs_elements_distants.testsetbit(elem_oppose)))
                    {
                      elements_distants.<a class="code" href="classArrOfInt.html#a3f39d0966599416e7b1f7cd8159d8d01" title="Ajoute une case en fin de tableau et y stocke la &quot;valeur&quot;.">append_array</a>(elem_oppose);
                      nb_elements_ajoutes++;
                    }
                }
<span class="comment">// Remettre a zero le tableau de marqueurs:</span>
              n = elements_distants.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>();
              <span class="keywordflow">for</span> (i = 0; i &lt; n; i++)
                {
                  <span class="keyword">const</span> <span class="keywordtype">int</span> elem = elements_distants[i];
                  marqueurs_elements_distants.clearbit(elem);
                }
            }
        }

    }
  <span class="keywordflow">while</span> (nb_elements_ajoutes &gt; 0);
<span class="comment">// Dernier tri des elements distants dans l&#39;ordre croissant</span>
  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i_joint = 0; i_joint &lt; nb_joints; i_joint++)
    {
      <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; elements_distants = zone.<a class="code" href="classZone.html#acec4c61032df8b55a95f9e7197ef6e3c" title="Renvoie le i-ieme joint de la zone&lt;br&gt;(version const)">joint</a>(i_joint).<a class="code" href="classJoint.html#aa1c4d729a3017082d26907d82ad1d7de" title="Renvoie les informations de joint pour un type d&#39;item geometrique donne, pour remplissage des structu...">set_joint_item</a>(<a class="code" href="classJoint.html#a1e2d15d088c27c9b7b11c02bf4d2c926ae32de3a01fdb3ad6c506b8058a7f6173">Joint::ELEMENT</a>).<a class="code" href="classJoint__Items.html#a13add264f4ad36ef4bddbfc1b7bdb817" title="Renvoie le tableau items_distants_ pour le remplir Voir Scatter::calculer_espace_distant, Scatter::calculer_espace_distant_faces_frontieres, Scatter::calculer_espace_distant_elements.">set_items_distants</a>();
      elements_distants.<a class="code" href="classArrOfInt.html#a22d744bcd452d039580d1d9186f02b4e" title="Change le mode l&#39;allocation memoire: reallocation d&#39;un tableau a chaque changement de taille (flag = ...">set_smart_resize</a>(0);
      elements_distants.<a class="code" href="classArrOfInt.html#abb0f48cf5a4be4b70edcc90baaebd521" title="Tri des valeurs du tableau dans l&#39;ordre croissant. La fonction utilisee est qsort de stdlib (elle est...">ordonne_array</a>();
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a002db6ff87448cb33d80b0e2158652a6"></a><!-- doxytag: member="Scatter::cree_instance" ref="a002db6ff87448cb33d80b0e2158652a6" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classObjet__U.html">Objet_U</a> * Scatter::cree_instance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="classInterprete.html#aab5edb577f929850223835604e663299">Interprete</a>.</p>

<p>Reimplemented in <a class="el" href="classScatterMED.html#a315eebb7d6c83a00bae6f5140ed92337">ScatterMED</a>.</p>

<p>Definition at line <a class="el" href="Scatter_8cpp_source.html#l00051">51</a> of file <a class="el" href="Scatter_8cpp_source.html">Scatter.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac33aacdb609dcc870faeb93500ed017f"></a><!-- doxytag: member="Scatter::domaine" ref="ac33aacdb609dcc870faeb93500ed017f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDomaine.html">Domaine</a> &amp; Scatter::domaine </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Scatter_8cpp_source.html#l00096">96</a> of file <a class="el" href="Scatter_8cpp_source.html">Scatter.cpp</a>.</p>

<p>References <a class="el" href="Scatter_8h_source.html#l00092">le_domaine</a>, and <a class="el" href="Ref__Domaine_8h_source.html#l00032">Ref_Domaine::valeur()</a>.</p>

<p>Referenced by <a class="el" href="ScatterMED_8cpp_source.html#l00064">ScatterMED::lire_domaine()</a>, and <a class="el" href="Scatter_8cpp_source.html#l00513">lire_domaine()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">return</span> <a class="code" href="classScatter.html#a82a0e561610415e2f6c5615846a96f87">le_domaine</a>.<a class="code" href="classRef__Domaine.html#a89e1c374ada79faa2c7e9a76c3393ad8">valeur</a>();
}
</pre></div>
</div>
</div>
<a class="anchor" id="abf43b072d4e11e1eb287c991ca700fc5"></a><!-- doxytag: member="Scatter::duplique" ref="abf43b072d4e11e1eb287c991ca700fc5" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Scatter::duplique </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="classInterprete.html#a2d8f2438b1acad83f4483b2fc2cc9b6c">Interprete</a>.</p>

<p>Reimplemented in <a class="el" href="classScatterMED.html#a296e676f444a9f20cb6592726bdf316e">ScatterMED</a>.</p>

<p>Definition at line <a class="el" href="Scatter_8cpp_source.html#l00051">51</a> of file <a class="el" href="Scatter_8cpp_source.html">Scatter.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa333f78af4e89f219a6bd6af16839021"></a><!-- doxytag: member="Scatter::get_info" ref="aa333f78af4e89f219a6bd6af16839021" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classType__info.html">Type_info</a> * Scatter::get_info </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Donne des informations sur le type de l'Objet_U. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>const Type_info*<br/>
 Signification: structure regroupant les informations sur le type de l'Objet_U<br/>
 Contraintes: </dd></dl>

<p>Reimplemented from <a class="el" href="classInterprete.html#a763fd02e129cd7e6790ca93ceb6e2be1">Interprete</a>.</p>

<p>Reimplemented in <a class="el" href="classScatterMED.html#a97fe985bdc8d30bb0f920e0aab42ecf2">ScatterMED</a>.</p>

<p>Definition at line <a class="el" href="Scatter_8cpp_source.html#l00051">51</a> of file <a class="el" href="Scatter_8cpp_source.html">Scatter.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a131b9467aadcab7a960ceb68d05c9a08"></a><!-- doxytag: member="Scatter::info" ref="a131b9467aadcab7a960ceb68d05c9a08" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classType__info.html">Type_info</a> * Scatter::info </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Donne des informations sur le type de l'Objet_U. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>const Type_info*<br/>
 Signification: structure regroupant les informations sur le type de l'Objet_U<br/>
 Contraintes: </dd></dl>

<p>Reimplemented from <a class="el" href="classInterprete.html#a3ce8319a40ae40defa4ee80d53e1bfff">Interprete</a>.</p>

<p>Reimplemented in <a class="el" href="classScatterMED.html#ae16d87f521165e3eaf9717b837589add">ScatterMED</a>.</p>

<p>Definition at line <a class="el" href="Scatter_8cpp_source.html#l00051">51</a> of file <a class="el" href="Scatter_8cpp_source.html">Scatter.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1874139ffd29d5a68191bc7828d3a5bd"></a><!-- doxytag: member="Scatter::init_sequential_domain" ref="a1874139ffd29d5a68191bc7828d3a5bd" args="(Domaine &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Scatter::init_sequential_domain </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDomaine.html">Domaine</a> &amp;&#160;</td>
          <td class="paramname"><em>dom</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>cree des descripteurs sequentiels pour les tableaux sommets<br/>
et elements du domaine (necessaire car <a class="el" href="classScatter.html">Scatter</a> n'est pas appele pour les<br/>
domaines en sequentiel) </p>

<p>Definition at line <a class="el" href="Scatter_8cpp_source.html#l02903">2903</a> of file <a class="el" href="Scatter_8cpp_source.html">Scatter.cpp</a>.</p>

<p>References <a class="el" href="MD__Vector_8cpp_source.html#l00031">MD_Vector::copy()</a>, <a class="el" href="Scatter_8cpp_source.html#l02845">init_simple_md_vector()</a>, <a class="el" href="Zone_8h_source.html#l00402">Zone::les_elems()</a>, <a class="el" href="Domaine_8h_source.html#l00577">Domaine::les_sommets()</a>, <a class="el" href="Zone_8h_source.html#l00300">Zone::nb_elem()</a>, <a class="el" href="Domaine_8cpp_source.html#l00184">Domaine::nb_som()</a>, <a class="el" href="Domaine_8h_source.html#l00242">Domaine::nb_zones()</a>, <a class="el" href="IntTab_8cpp_source.html#l00553">IntTab::set_md_vector()</a>, <a class="el" href="DoubleTab_8cpp_source.html#l00520">DoubleTab::set_md_vector()</a>, and <a class="el" href="Domaine_8h_source.html#l00272">Domaine::zone()</a>.</p>

<p>Referenced by <a class="el" href="Refine__Mesh_8cpp_source.html#l00110">Refine_Mesh::apply_2D()</a>, <a class="el" href="Rectify__Mesh_8cpp_source.html#l00106">Rectify_Mesh::apply_2D()</a>, <a class="el" href="Refine__Mesh_8cpp_source.html#l00160">Refine_Mesh::apply_3D()</a>, <a class="el" href="Rectify__Mesh_8cpp_source.html#l00119">Rectify_Mesh::apply_3D()</a>, <a class="el" href="Decouper__Bord__coincident_8cpp_source.html#l00060">Decouper_Bord_coincident::Decouper_Bord_coincident_()</a>, <a class="el" href="Scatter_8cpp_source.html#l00150">interpreter()</a>, <a class="el" href="Raffiner__isotrope__parallele_8cpp_source.html#l00198">Raffiner_isotrope_parallele::interpreter()</a>, <a class="el" href="MaillerParallel_8cpp_source.html#l00534">MaillerParallel::interpreter()</a>, <a class="el" href="VerifierCoin_8cpp_source.html#l00094">VerifierCoin::interpreter_()</a>, <a class="el" href="TroisDto2D_8cpp_source.html#l00089">TroisDto2D::interpreter_()</a>, <a class="el" href="Triangulation__base_8cpp_source.html#l00039">Triangulation_base::interpreter_()</a>, <a class="el" href="Reorienter__triangles_8cpp_source.html#l00038">Reorienter_triangles::interpreter_()</a>, <a class="el" href="Reorienter__tetraedres_8cpp_source.html#l00038">Reorienter_tetraedres::interpreter_()</a>, <a class="el" href="Remove__Invalid__Internal__Boundaries_8cpp_source.html#l00044">Remove_Invalid_Internal_Boundaries::interpreter_()</a>, <a class="el" href="Remove__elem_8cpp_source.html#l00062">Remove_elem::interpreter_()</a>, <a class="el" href="Raffiner__Simplexes_8cpp_source.html#l01071">Raffiner_Simplexes::interpreter_()</a>, <a class="el" href="Raffiner__anisotrope_8cpp_source.html#l00038">Raffiner_anisotrope::interpreter_()</a>, <a class="el" href="Polyedriser_8cpp_source.html#l00252">Polyedriser::interpreter_()</a>, <a class="el" href="Orienter__Simplexes_8cpp_source.html#l00261">Orienter_Simplexes::interpreter_()</a>, <a class="el" href="Mailler_8cpp_source.html#l00107">Mailler::interpreter_()</a>, <a class="el" href="Lire__Ideas_8cpp_source.html#l00042">Lire_Ideas::interpreter_()</a>, <a class="el" href="Extruder__en3_8cpp_source.html#l00100">Extruder_en3::interpreter_()</a>, <a class="el" href="Extruder__en20_8cpp_source.html#l00098">Extruder_en20::interpreter_()</a>, <a class="el" href="Extruder_8cpp_source.html#l00097">Extruder::interpreter_()</a>, <a class="el" href="ExtrudeParoi_8cpp_source.html#l00127">ExtrudeParoi::interpreter_()</a>, <a class="el" href="ExtrudeBord_8cpp_source.html#l00053">ExtrudeBord::interpreter_()</a>, <a class="el" href="Create__domain__from__sous__zone_8cpp_source.html#l00045">Create_domain_from_sous_zone::interpreter_()</a>, <a class="el" href="Scatter_8cpp_source.html#l00513">lire_domaine()</a>, <a class="el" href="NettoieNoeuds_8cpp_source.html#l00103">NettoieNoeuds::nettoie()</a>, <a class="el" href="Domaine_8cpp_source.html#l00090">Domaine::readOn()</a>, and <a class="el" href="Transformer_8cpp_source.html#l00150">Transformer::transformation_complete()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <a class="code" href="classMD__Vector__std.html" title="C&#39;est le plus simple des descripteurs, utilise pour les tableaux de valeurs aux sommets, elements, faces, aretes, faces de bord, etc... Il supporte la notion d&#39;items &quot;communs&quot; (sommets du maillage partages entre plusieurs processeurs) et d&#39;items &quot;distants&quot; et &quot;virtuels&quot; (sommets, elements dans l&#39;epaisseur de joint). Voir aussi MD_Vector_composite (descripteur compose d&#39;une reunion de plusieurs descripteurs, pour le P1Bulle par exemple)">MD_Vector_std</a> mdstd;
  <a class="code" href="classMD__Vector.html" title=": Cette classe est un DERIV mais l&#39;objet pointe est partage entre plusieurs instances de cette classe...">MD_Vector</a> md;
  <span class="keyword">const</span> <span class="keywordtype">int</span> nbsom = dom.<a class="code" href="classDomaine.html#abc4abc8b8db5bebeb161fae4162a89ce" title="Renvoie le nombre de sommets.">nb_som</a>();
  <a class="code" href="Scatter_8cpp.html#a4c215e3cfff2963def44e300a58b513b">init_simple_md_vector</a>(mdstd, nbsom);
  md.<a class="code" href="classMD__Vector.html#a063644dd8ca62e707a2d059eedeb58a7" title="construction d&#39;un objet MD_Vector par copie d&#39;un objet existant. C&#39;est la methode recommandee pour cr...">copy</a>(mdstd);
  dom.<a class="code" href="classDomaine.html#a0846ac03a10b65c4df911fe35a19c02f" title="Renvoie le nombre total de sommets.">les_sommets</a>().<a class="code" href="classDoubleTab.html#a2f40241acb678b0dd0dac7ee4f421b1d" title="associe le md_vector au vecteur (voir DoubleVect::set_md_vector()) dimension(0) sera initialise a md_...">set_md_vector</a>(md);

  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_zones = dom.<a class="code" href="classDomaine.html#a9f3fc389a1310d1fc8b4b27976855376" title="Renvoie le nombre de zone du domaine.">nb_zones</a>();
  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; nb_zones; i++)
    {
      <span class="keyword">const</span> <span class="keywordtype">int</span> nb_elem = dom.<a class="code" href="classDomaine.html#a0e62f2bc829542fafa29e3f2c614159c" title="Renvoie la i-ieme zone du domaine. (version const)">zone</a>(i).<a class="code" href="classZone.html#a7f249429803b27139a1c54436f6164a5" title="Renvoie le nombre d&#39;elements de la zone.">nb_elem</a>();
      <a class="code" href="Scatter_8cpp.html#a4c215e3cfff2963def44e300a58b513b">init_simple_md_vector</a>(mdstd, nb_elem);
      md.<a class="code" href="classMD__Vector.html#a063644dd8ca62e707a2d059eedeb58a7" title="construction d&#39;un objet MD_Vector par copie d&#39;un objet existant. C&#39;est la methode recommandee pour cr...">copy</a>(mdstd);
      dom.<a class="code" href="classDomaine.html#a0e62f2bc829542fafa29e3f2c614159c" title="Renvoie la i-ieme zone du domaine. (version const)">zone</a>(i).<a class="code" href="classZone.html#ac115e8342be89afb882b7b61cc343267" title="Renvoie le tableau des sommets des elements.">les_elems</a>().<a class="code" href="classIntTab.html#a02470d5d5921700f4daee05a5b3d2601" title="associe le md_vector au vecteur (voir IntVect::set_md_vector()) dimension(0) sera initialise a md_vec...">set_md_vector</a>(md);
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="ada2699448b4deae55f43998af585d603"></a><!-- doxytag: member="Scatter::interpreter" ref="ada2699448b4deae55f43998af585d603" args="(Entree &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEntree.html">Entree</a> &amp; Scatter::interpreter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEntree.html">Entree</a> &amp;&#160;</td>
          <td class="paramname"><em>is</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Lit et complete un domaine parallele selon les motcles lus<br/>
dans le jeu de donnees. Format:<br/>
<a class="el" href="classScatter.html">Scatter</a> [debug] file_name domain_name<br/>
On lit les sommets, les elements et les sommets et faces de joint,<br/>
On construit les espaces distants et virtuels en fonction<br/>
de l'epaisseur de joint. </p>

<p>Reimplemented from <a class="el" href="classInterprete.html#adeb51024344c86b4320c7847a5165e03">Interprete</a>.</p>

<p>Definition at line <a class="el" href="Scatter_8cpp_source.html#l00150">150</a> of file <a class="el" href="Scatter_8cpp_source.html">Scatter.cpp</a>.</p>

<p>References <a class="el" href="Process_8cpp_source.html#l00127">Process::barrier()</a>, <a class="el" href="Statistiques_8h_source.html#l00219">Statistiques::begin_count()</a>, <a class="el" href="Scatter_8cpp_source.html#l01353">calculer_renum_items_communs()</a>, <a class="el" href="EntreeSortie_8h_source.html#l00032">Cerr</a>, <a class="el" href="Scatter_8cpp_source.html#l00714">construire_structures_paralleles()</a>, <a class="el" href="Scatter_8cpp_source.html#l00101">dump_lata()</a>, <a class="el" href="Statistiques_8h_source.html#l00237">Statistiques::end_count()</a>, <a class="el" href="Process_8cpp_source.html#l00223">Process::exit()</a>, <a class="el" href="Zone_8h_source.html#l01098">Zone::faces_joint()</a>, <a class="el" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>, <a class="el" href="Scatter_8cpp_source.html#l02903">init_sequential_domain()</a>, <a class="el" href="Process_8cpp_source.html#l00095">Process::je_suis_maitre()</a>, <a class="el" href="Statistiques_8cpp_source.html#l00517">Statistiques::last_time()</a>, <a class="el" href="Scatter_8h_source.html#l00092">le_domaine</a>, <a class="el" href="Scatter_8cpp_source.html#l00513">lire_domaine()</a>, <a class="el" href="Process_8cpp_source.html#l00117">Process::me()</a>, <a class="el" href="Process_8cpp_source.html#l00156">Process::mp_max()</a>, <a class="el" href="Process_8cpp_source.html#l00167">Process::mp_min()</a>, <a class="el" href="Process_8cpp_source.html#l00178">Process::mp_sum()</a>, <a class="el" href="Zone_8h_source.html#l00300">Zone::nb_elem()</a>, <a class="el" href="Process_8cpp_source.html#l00109">Process::nproc()</a>, <a class="el" href="Interprete_8cpp_source.html#l00048">Interprete::objet()</a>, <a class="el" href="Cast_8h_source.html#l00059">ref_cast</a>, <a class="el" href="Joint_8h_source.html#l00066">Joint::SOMMET</a>, <a class="el" href="Statistiques_8h_source.html#l00190">statistiques()</a>, <a class="el" href="Cast_8h_source.html#l00054">sub_type</a>, <a class="el" href="Zone_8h_source.html#l00491">Zone::type_elem()</a>, <a class="el" href="Scatter_8cpp_source.html#l02925">uninit_sequential_domain()</a>, <a class="el" href="Elem__geom_8h_source.html#l00044">Deriv_Elem_geom_base::valeur()</a>, and <a class="el" href="Domaine_8h_source.html#l00272">Domaine::zone()</a>.</p>
<div class="fragment"><pre class="fragment">{
<span class="comment">// Nom des fichiers de decoupage : nomentree.xxxx</span>
  <a class="code" href="classNom.html" title="class Nom Une chaine de caractere pour nommer les objets de TRUST">Nom</a> nomentree;
  is &gt;&gt; nomentree;
  <span class="keywordflow">if</span> (<a class="code" href="classProcess.html#a6bf692ce58d9578aa62ac3c07b8caaa1" title="renvoie le nombre de processeurs dans le groupe courant Voir Comm_Group::nproc() et PE_Groups::curren...">Process::nproc</a>()==1)
    {
      <a class="code" href="classMotcle.html" title="Une chaine de caractere (Nom) en majuscules.">Motcle</a> n(nomentree);
      <span class="keywordflow">if</span> (n != <span class="stringliteral">&quot;;&quot;</span> &amp;&amp; n != <span class="stringliteral">&quot;unlock;&quot;</span>)
        {
          <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Error ! You ran a sequential calculation and can&#39;t use Scatter keyword here. Run a parallel calculation or remove this keyword.&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
          <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">exit</a>();
        }
      <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Scatter: preparing domain structure\n&quot;</span>
           &lt;&lt; <span class="stringliteral">&quot; (this is workaround for bugged domain operators that don&#39;t do it)&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
      <a class="code" href="classNom.html" title="class Nom Une chaine de caractere pour nommer les objets de TRUST">Nom</a> nomdomaine;
      is &gt;&gt; nomdomaine;
      <a class="code" href="classObjet__U.html" title="classe Objet_U Cette classe est la classe de base des Objets de TRUST Dans les classes derivees de Ob...">Objet_U</a>&amp; obj = <a class="code" href="classInterprete.html#a3ca248609f0b72eac68baca14621b4ee" title="Voir Interprete_bloc::objet_global() BM: la classe Interprete n&#39;est pas le meilleur endroit pour cett...">objet</a>(nomdomaine);
      <span class="keywordflow">if</span>(!<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classDomaine.html" title="Classe Domaine Un Domaine represente le domaine (spatial) de resolution d&#39;un Probleme. Un Domaine a un Nom, il est constitue d&#39;une ou plusieurs Zone qui peuvent etre eventuellement decoupees en Sous_Zone. Un Domaine porte l&#39;ensemble des sommets utilises par ses Zones. On peut vouloir resoudre des problemes de type different sur plusieurs domaines, geometriquement les domaines sont alors couples par des surfaces qu&#39;on appelle Raccord.">Domaine</a>, obj))
        {
          <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;obj : &quot;</span> &lt;&lt; obj &lt;&lt; <span class="stringliteral">&quot; is not an object of type Domain !&quot;</span> &lt;&lt; finl;
          <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">exit</a>();
        }
      <a class="code" href="classDomaine.html" title="Classe Domaine Un Domaine represente le domaine (spatial) de resolution d&#39;un Probleme. Un Domaine a un Nom, il est constitue d&#39;une ou plusieurs Zone qui peuvent etre eventuellement decoupees en Sous_Zone. Un Domaine porte l&#39;ensemble des sommets utilises par ses Zones. On peut vouloir resoudre des problemes de type different sur plusieurs domaines, geometriquement les domaines sont alors couples par des surfaces qu&#39;on appelle Raccord.">Domaine</a>&amp; dom = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classDomaine.html" title="Classe Domaine Un Domaine represente le domaine (spatial) de resolution d&#39;un Probleme. Un Domaine a un Nom, il est constitue d&#39;une ou plusieurs Zone qui peuvent etre eventuellement decoupees en Sous_Zone. Un Domaine porte l&#39;ensemble des sommets utilises par ses Zones. On peut vouloir resoudre des problemes de type different sur plusieurs domaines, geometriquement les domaines sont alors couples par des surfaces qu&#39;on appelle Raccord.">Domaine</a>, obj);
      <span class="keywordflow">if</span> (n == <span class="stringliteral">&quot;;&quot;</span>)
        <a class="code" href="classScatter.html#a1874139ffd29d5a68191bc7828d3a5bd" title="cree des descripteurs sequentiels pour les tableaux sommets et elements du domaine (necessaire car Sc...">init_sequential_domain</a>(dom);
      <span class="keywordflow">else</span>
        <a class="code" href="classScatter.html#a8cf934a9b5f7ecb7ef89f61c09804f45" title="methode utilisee par les interpretes qui modifient le domaine&lt;br&gt;(sequentiel), detruit les descripteu...">uninit_sequential_domain</a>(dom);
      <span class="keywordflow">return</span> is;
    }
<span class="comment">// Pour debugger sur linux en parallele</span>
<span class="preprocessor">#ifdef linux</span>
<span class="preprocessor"></span>  <span class="keyword">static</span> <span class="keywordtype">int</span> gdb_non_lance=1;
  <span class="keywordtype">char</span>* TRUST_GDB=getenv(<span class="stringliteral">&quot;TRUST_GDB&quot;</span>);
  <span class="keywordflow">if</span> (gdb_non_lance &amp;&amp; ((<a class="code" href="classMotcle.html" title="Une chaine de caractere (Nom) en majuscules.">Motcle</a>)nomentree==<span class="stringliteral">&quot;DEBUG&quot;</span> || TRUST_GDB!=NULL))
    {
      gdb_non_lance=0;
      <span class="keywordflow">if</span> ((<a class="code" href="classMotcle.html" title="Une chaine de caractere (Nom) en majuscules.">Motcle</a>)nomentree==<span class="stringliteral">&quot;DEBUG&quot;</span>) is &gt;&gt; nomentree;
      <span class="keywordflow">if</span> (<a class="code" href="classProcess.html#acd052b99706c577f8a5b6656217cf4c2" title="renvoie 1 si on est sur le processeur maitre du groupe courant (c&#39;est a dire me() == 0)...">je_suis_maitre</a>())
        {
          <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Enter \&quot;return\&quot; to this window after&quot;</span> &lt;&lt; finl;
          <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;typing \&quot;cont\&quot; in other gdb windows.&quot;</span> &lt;&lt; finl;
          <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; (int)system (<span class="stringliteral">&quot;sh -c read ok&quot;</span>) &lt;&lt; finl;
        }
      <span class="keywordflow">else</span>
        {
          <a class="code" href="classNom.html" title="class Nom Une chaine de caractere pour nommer les objets de TRUST">Nom</a> getpidn((<span class="keywordtype">int</span>)getpid());
          <a class="code" href="classNom.html" title="class Nom Une chaine de caractere pour nommer les objets de TRUST">Nom</a> cmdfile=getpidn;
          <a class="code" href="classNom.html" title="class Nom Une chaine de caractere pour nommer les objets de TRUST">Nom</a> command0=<span class="stringliteral">&quot;echo attach &quot;</span>;
          command0+=getpidn;
          command0+=<span class="stringliteral">&quot; &gt; &quot;</span>;
          command0+=cmdfile;
          <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; (int)system(command0) &lt;&lt; finl;
          command0=<span class="stringliteral">&quot; ls -l /proc/&quot;</span>;
          command0+=getpidn;
          command0+=<span class="stringliteral">&quot;/exe | awk &#39;{print $NF}&#39; &gt; execname&quot;</span>;
          <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; (int)system(command0) &lt;&lt; finl;
          <a class="code" href="classNom.html" title="class Nom Une chaine de caractere pour nommer les objets de TRUST">Nom</a> command=<span class="stringliteral">&quot;[ -f /usr/X11R6/bin/xterm ] &amp;&amp; x=\&quot;/usr/X11R6/bin/xterm -exec gdb -x \&quot;;&quot;</span>;
          command+=<span class="stringliteral">&quot;[ -f /usr/bin/konsole ] &amp;&amp; x=\&quot;/usr/bin/konsole -e gdb -x \&quot;;&quot;</span>;
          command+=<span class="stringliteral">&quot;$x &quot;</span>;
          command+=cmdfile;
          command+=<span class="stringliteral">&quot; `cat execname` &quot;</span>;
          command+=<span class="stringliteral">&quot; &amp;&quot;</span>;
          <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a>&lt;&lt;<span class="stringliteral">&quot;command: &quot;</span> &lt;&lt;command&lt;&lt;finl;
          <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; (int)system(command) &lt;&lt; finl;
        }
    }
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>  <a class="code" href="classProcess.html#aa9e74a5c06a68ea38298a08ea401e7b1" title="Synchronise tous les processeurs du groupe courant&lt;br&gt;(attend que tous les processeurs soient arrives...">barrier</a>();

  <span class="keywordflow">if</span> (<a class="code" href="classProcess.html#acd052b99706c577f8a5b6656217cf4c2" title="renvoie 1 si on est sur le processeur maitre du groupe courant (c&#39;est a dire me() == 0)...">Process::je_suis_maitre</a>())
    <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Execution of the Scatter module.&quot;</span> &lt;&lt; finl;

  <a class="code" href="Statistiques_8h.html#a7bb2ce53a9ec088bba93ddcfce2b8cb1">statistiques</a>().<a class="code" href="classStatistiques.html#affcd058809786918ed173aaf681d0843">begin_count</a>(<a class="code" href="Scatter_8cpp.html#a5aa23d1c4a41bce37e5e06efb5e8c9e1" title="&lt; PGI">interprete_scatter_counter_</a>);

<span class="comment">// On recupere le domaine:</span>
  <a class="code" href="classNom.html" title="class Nom Une chaine de caractere pour nommer les objets de TRUST">Nom</a> nomdomaine;
  is &gt;&gt; nomdomaine;
  <a class="code" href="classObjet__U.html" title="classe Objet_U Cette classe est la classe de base des Objets de TRUST Dans les classes derivees de Ob...">Objet_U</a>&amp; obj = <a class="code" href="classInterprete.html#a3ca248609f0b72eac68baca14621b4ee" title="Voir Interprete_bloc::objet_global() BM: la classe Interprete n&#39;est pas le meilleur endroit pour cett...">objet</a>(nomdomaine);
  <span class="keywordflow">if</span>(!<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classDomaine.html" title="Classe Domaine Un Domaine represente le domaine (spatial) de resolution d&#39;un Probleme. Un Domaine a un Nom, il est constitue d&#39;une ou plusieurs Zone qui peuvent etre eventuellement decoupees en Sous_Zone. Un Domaine porte l&#39;ensemble des sommets utilises par ses Zones. On peut vouloir resoudre des problemes de type different sur plusieurs domaines, geometriquement les domaines sont alors couples par des surfaces qu&#39;on appelle Raccord.">Domaine</a>, obj))
    {
      <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;obj : &quot;</span> &lt;&lt; obj &lt;&lt; <span class="stringliteral">&quot; is not an object of type Domain !&quot;</span> &lt;&lt; finl;
      <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">exit</a>();
    }
  <a class="code" href="classDomaine.html" title="Classe Domaine Un Domaine represente le domaine (spatial) de resolution d&#39;un Probleme. Un Domaine a un Nom, il est constitue d&#39;une ou plusieurs Zone qui peuvent etre eventuellement decoupees en Sous_Zone. Un Domaine porte l&#39;ensemble des sommets utilises par ses Zones. On peut vouloir resoudre des problemes de type different sur plusieurs domaines, geometriquement les domaines sont alors couples par des surfaces qu&#39;on appelle Raccord.">Domaine</a>&amp; dom = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classDomaine.html" title="Classe Domaine Un Domaine represente le domaine (spatial) de resolution d&#39;un Probleme. Un Domaine a un Nom, il est constitue d&#39;une ou plusieurs Zone qui peuvent etre eventuellement decoupees en Sous_Zone. Un Domaine porte l&#39;ensemble des sommets utilises par ses Zones. On peut vouloir resoudre des problemes de type different sur plusieurs domaines, geometriquement les domaines sont alors couples par des surfaces qu&#39;on appelle Raccord.">Domaine</a>, obj);
  <a class="code" href="classScatter.html#a82a0e561610415e2f6c5615846a96f87">le_domaine</a> = dom;

<span class="comment">// Lecture des fichiers de decoupage :</span>
  <a class="code" href="classProcess.html#aa9e74a5c06a68ea38298a08ea401e7b1" title="Synchronise tous les processeurs du groupe courant&lt;br&gt;(attend que tous les processeurs soient arrives...">barrier</a>();
  <span class="keywordflow">if</span> (<a class="code" href="classProcess.html#acd052b99706c577f8a5b6656217cf4c2" title="renvoie 1 si on est sur le processeur maitre du groupe courant (c&#39;est a dire me() == 0)...">Process::je_suis_maitre</a>())
    <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Reading the domain&quot;</span> &lt;&lt; finl;

  <a class="code" href="classNoms.html" title="Un tableau de chaine de caracteres (VECT(Nom))">Noms</a> liste_bords_periodiques;
  <a class="code" href="classScatter.html#a0c740e8b05e31947a4f49d630f1302ec" title="Lit le domaine dans le fichier de nom &quot;nomentree&quot;, de type LecFicDistribueBin ou LecFicDistribue Form...">lire_domaine</a>(nomentree, liste_bords_periodiques);

  <a class="code" href="classProcess.html#aa9e74a5c06a68ea38298a08ea401e7b1" title="Synchronise tous les processeurs du groupe courant&lt;br&gt;(attend que tous les processeurs soient arrives...">barrier</a>();
  <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Calculation of renum_items_communs for the nodes&quot;</span> &lt;&lt; finl;
  <a class="code" href="classScatter.html#a21f166c05df9be1fc1f02b0604624fe5" title="On suppose que chaque joint[i].joint_item(type_item).items_communs() contient les indices locaux des ...">calculer_renum_items_communs</a>(dom.<a class="code" href="classDomaine.html#a0e62f2bc829542fafa29e3f2c614159c" title="Renvoie la i-ieme zone du domaine. (version const)">zone</a>(0).<a class="code" href="classZone.html#a16f273a76321d31435995cdad664285a" title="Renvoie la liste des joints de la zone. (version const)">faces_joint</a>(), <a class="code" href="classJoint.html#a1e2d15d088c27c9b7b11c02bf4d2c926a050aa4faf237e25faef6fff15ffc20f8">Joint::SOMMET</a>);

<span class="comment">// Pas encore code: on verifie que les sommets communs ont des coordonnees identiques</span>
<span class="comment">// sur tous les processeurs.</span>
<span class="comment">// check_sommets_joints(dom);</span>

  <a class="code" href="classProcess.html#aa9e74a5c06a68ea38298a08ea401e7b1" title="Synchronise tous les processeurs du groupe courant&lt;br&gt;(attend que tous les processeurs soient arrives...">barrier</a>();
  <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Construire_structures_paralleles&quot;</span> &lt;&lt; finl;
  <a class="code" href="classScatter.html#af6b88297583bd92c6ca3814bc532b8be" title="Construction des structures paralleles du domaine et de la zone (determination des elements distants ...">construire_structures_paralleles</a>(dom, liste_bords_periodiques);

  <span class="keywordflow">if</span> (0)
    <a class="code" href="Scatter_8cpp.html#a600ea51e50b762812904598f72bc12b6">dump_lata</a>(dom);

  <a class="code" href="classProcess.html#aa9e74a5c06a68ea38298a08ea401e7b1" title="Synchronise tous les processeurs du groupe courant&lt;br&gt;(attend que tous les processeurs soient arrives...">barrier</a>();
  <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;End Distribue_zones&quot;</span> &lt;&lt; finl;

  <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;\nQuality of partitioning --------------------------------------------&quot;</span> &lt;&lt; finl;
  <span class="keywordtype">int</span> total_nb_elem = <a class="code" href="classProcess.html#a7d23bc1ef94b3f0623fbc79d034c27fd" title="Calcule la somme de x sur tous les processeurs du groupe courant. Voir aussi mp_max()">Process::mp_sum</a>(dom.<a class="code" href="classDomaine.html#a0e62f2bc829542fafa29e3f2c614159c" title="Renvoie la i-ieme zone du domaine. (version const)">zone</a>(0).<a class="code" href="classZone.html#a7f249429803b27139a1c54436f6164a5" title="Renvoie le nombre d&#39;elements de la zone.">nb_elem</a>());
  <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;\nTotal number of elements = &quot;</span> &lt;&lt; total_nb_elem &lt;&lt; finl;
  <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Number of Zones : &quot;</span> &lt;&lt; <a class="code" href="classProcess.html#a6bf692ce58d9578aa62ac3c07b8caaa1" title="renvoie le nombre de processeurs dans le groupe courant Voir Comm_Group::nproc() et PE_Groups::curren...">Process::nproc</a>() &lt;&lt; finl;
  <span class="keywordtype">double</span> min_element_zone = <a class="code" href="classProcess.html#a05de57db7288d95f9e67046af585d5ff" title="Calcule le min de x sur tous les processeurs du groupe courant. Voir aussi mp_max()">mp_min</a>(dom.<a class="code" href="classDomaine.html#a0e62f2bc829542fafa29e3f2c614159c" title="Renvoie la i-ieme zone du domaine. (version const)">zone</a>(0).<a class="code" href="classZone.html#a7f249429803b27139a1c54436f6164a5" title="Renvoie le nombre d&#39;elements de la zone.">nb_elem</a>());
  <span class="keywordtype">double</span> max_element_zone = <a class="code" href="classProcess.html#a1e9d9f9899b71927cfafae14c7bd048d" title="Calcule le max de x sur tous les processeurs du groupe courant. Remarques : Cette methode doit etre a...">mp_max</a>(dom.<a class="code" href="classDomaine.html#a0e62f2bc829542fafa29e3f2c614159c" title="Renvoie la i-ieme zone du domaine. (version const)">zone</a>(0).<a class="code" href="classZone.html#a7f249429803b27139a1c54436f6164a5" title="Renvoie le nombre d&#39;elements de la zone.">nb_elem</a>());
  <span class="keywordtype">double</span> mean_element_zone = total_nb_elem / <a class="code" href="classProcess.html#a6bf692ce58d9578aa62ac3c07b8caaa1" title="renvoie le nombre de processeurs dans le groupe courant Voir Comm_Group::nproc() et PE_Groups::curren...">Process::nproc</a>();
  <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Min number of elements on a Zone = &quot;</span> &lt;&lt; min_element_zone &lt;&lt; finl;
  <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Max number of elements on a Zone = &quot;</span> &lt;&lt; max_element_zone &lt;&lt; finl;
  <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Mean number of elements per Zone = &quot;</span> &lt;&lt; (int)(mean_element_zone) &lt;&lt; finl;
  <span class="keywordtype">double</span> load_imbalance = max_element_zone / mean_element_zone;
  <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Load imbalance = &quot;</span> &lt;&lt; load_imbalance &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span> &lt;&lt; finl;

  <a class="code" href="classElem__geom__base.html" title="Classe Elem_geom_base Cette classe est la classe de base pour la definition d&#39;elements geometriques c...">Elem_geom_base</a>&amp; elem=dom.<a class="code" href="classDomaine.html#a0e62f2bc829542fafa29e3f2c614159c" title="Renvoie la i-ieme zone du domaine. (version const)">zone</a>(0).<a class="code" href="classZone.html#a18cf83cd0f9c368dcfa32fb802a0ac94" title="Renvoie un element geometrique du type de ceux qui constituent la zone. (version const)">type_elem</a>().<a class="code" href="classDeriv__Elem__geom__base.html#a384b487459a33f9f521fb16539ec81de">valeur</a>();
  <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classPoly__geom__base.html" title=": class Poly_geom_base &lt;Description of class Poly_geom_base&gt;">Poly_geom_base</a>,elem))
    {
      <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classPoly__geom__base.html" title=": class Poly_geom_base &lt;Description of class Poly_geom_base&gt;">Poly_geom_base</a>,elem).compute_virtual_index();
    }
  <a class="code" href="Statistiques_8h.html#a7bb2ce53a9ec088bba93ddcfce2b8cb1">statistiques</a>().<a class="code" href="classStatistiques.html#a0faf52d1b518f5b0b2177f22efcc222d" title="Arret du compteur counter_id. On ajoute quantity a la somme des &#39;quantity&#39; (par defaut 0) stockees po...">end_count</a>(<a class="code" href="Scatter_8cpp.html#a5aa23d1c4a41bce37e5e06efb5e8c9e1" title="&lt; PGI">interprete_scatter_counter_</a>);
  <span class="keywordflow">if</span>(<a class="code" href="classProcess.html#ab55ba07167ec807ed3a145cac0f5dca4" title="renvoie mon rang dans le groupe de communication courant. Voir Comm_Group::rank() et PE_Groups::curre...">Process::me</a>()==0)
    {
      <span class="keywordtype">double</span> temps = <a class="code" href="Statistiques_8h.html#a7bb2ce53a9ec088bba93ddcfce2b8cb1">statistiques</a>().<a class="code" href="classStatistiques.html#a21c24113a2042f33ce1134b473ebc1ac">last_time</a>(<a class="code" href="Scatter_8cpp.html#a5aa23d1c4a41bce37e5e06efb5e8c9e1" title="&lt; PGI">interprete_scatter_counter_</a>);
      <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Scatter time : &quot;</span> &lt;&lt; temps &lt;&lt; finl;
    }

  <span class="keywordflow">return</span> is;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a0c740e8b05e31947a4f49d630f1302ec"></a><!-- doxytag: member="Scatter::lire_domaine" ref="a0c740e8b05e31947a4f49d630f1302ec" args="(Nom &amp;, Noms &amp;liste_bords_periodiques)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Scatter::lire_domaine </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classNom.html">Nom</a> &amp;&#160;</td>
          <td class="paramname"><em>nomentree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classNoms.html">Noms</a> &amp;&#160;</td>
          <td class="paramname"><em>liste_bords_periodiques</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Lit le domaine dans le fichier de nom "nomentree",<br/>
de type <a class="el" href="classLecFicDistribueBin.html" title="Lecture dans un fichier au format binaire. Cette classe implemente les operateurs et les methodes vir...">LecFicDistribueBin</a> ou <a class="el" href="classLecFicDistribue.html" title="Cette classe implemente les operateurs et les methodes virtuelles de la classe EFichier de la facon s...">LecFicDistribue</a><br/>
Format attendu : Domaine::ReadOn<br/>
La zone est renommee comme le domaine (pour lance_test_seq_par) </p>

<p><p>&lt; Attendre que le message soit affiche </p>
</p>

<p>Reimplemented in <a class="el" href="classScatterMED.html#ada27f22765e17d42a2fbaa765ba211fd">ScatterMED</a>.</p>

<p>Definition at line <a class="el" href="Scatter_8cpp_source.html#l00513">513</a> of file <a class="el" href="Scatter_8cpp_source.html">Scatter.cpp</a>.</p>

<p>References <a class="el" href="Zones_8cpp_source.html#l00083">Zones::associer_domaine()</a>, <a class="el" href="Process_8cpp_source.html#l00127">Process::barrier()</a>, <a class="el" href="Statistiques_8h_source.html#l00219">Statistiques::begin_count()</a>, <a class="el" href="Zone_8h_source.html#l00836">Zone::bord()</a>, <a class="el" href="EntreeSortie_8h_source.html#l00032">Cerr</a>, <a class="el" href="Scatter_8cpp_source.html#l00297">check_consistancy_remote_items()</a>, <a class="el" href="Zone_8cpp_source.html#l00158">Zone::check_zone()</a>, <a class="el" href="Reordonner__faces__periodiques_8cpp_source.html#l00065">Reordonner_faces_periodiques::chercher_direction_perio()</a>, <a class="el" href="Entree__Fichier__base_8cpp_source.html#l00118">Entree_Fichier_base::close()</a>, <a class="el" href="FichierHDF_8cpp_source.html#l00037">FichierHDF::close()</a>, <a class="el" href="Objet__U_8h_source.html#l00079">Objet_U::dimension</a>, <a class="el" href="DoubleTab_8h_source.html#l00243">DoubleTab::dimension()</a>, <a class="el" href="Scatter_8cpp_source.html#l00096">domaine()</a>, <a class="el" href="Statistiques_8h_source.html#l00237">Statistiques::end_count()</a>, <a class="el" href="communications_8cpp_source.html#l00452">envoyer_all_to_all()</a>, <a class="el" href="FichierHDF_8cpp_source.html#l00046">FichierHDF::exists()</a>, <a class="el" href="Process_8cpp_source.html#l00223">Process::exit()</a>, <a class="el" href="Frontiere_8h_source.html#l00175">Frontiere::faces()</a>, <a class="el" href="Zone_8h_source.html#l01098">Zone::faces_joint()</a>, <a class="el" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>, <a class="el" href="Nom_8cpp_source.html#l00496">Nom::getPrefix()</a>, <a class="el" href="Nom_8h_source.html#l00092">Nom::getString()</a>, <a class="el" href="Scatter_8cpp_source.html#l02903">init_sequential_domain()</a>, <a class="el" href="FichierHDF_8cpp_source.html#l00050">FichierHDF::is_hdf5()</a>, <a class="el" href="Process_8cpp_source.html#l00095">Process::je_suis_maitre()</a>, <a class="el" href="Faces_8h_source.html#l00268">Faces::les_sommets()</a>, <a class="el" href="Domaine_8h_source.html#l00577">Domaine::les_sommets()</a>, <a class="el" href="Process_8cpp_source.html#l00117">Process::me()</a>, <a class="el" href="Scatter_8cpp_source.html#l00463">mergeDomains()</a>, <a class="el" href="Process_8cpp_source.html#l00156">Process::mp_max()</a>, <a class="el" href="Process_8cpp_source.html#l00178">Process::mp_sum()</a>, <a class="el" href="Frontiere_8h_source.html#l00114">Frontiere::nb_faces()</a>, <a class="el" href="Statistiques_8cpp_source.html#l00404">Statistiques::new_counter()</a>, <a class="el" href="Nom_8cpp_source.html#l00566">Nom::nom_me()</a>, <a class="el" href="Process_8cpp_source.html#l00109">Process::nproc()</a>, <a class="el" href="FichierHDF_8cpp_source.html#l00036">FichierHDF::open()</a>, <a class="el" href="Entree__Fichier__base_8cpp_source.html#l00067">Entree_Fichier_base::ouvrir()</a>, <a class="el" href="LecFicDistribue_8cpp_source.html#l00108">LecFicDistribue::ouvrir()</a>, <a class="el" href="LecFicDiffuse_8cpp_source.html#l00064">LecFicDiffuse::ouvrir()</a>, <a class="el" href="Objet__U_8h_source.html#l00080">Objet_U::precision_geom</a>, <a class="el" href="FichierHDF_8cpp_source.html#l00044">FichierHDF::read_dataset()</a>, <a class="el" href="Scatter_8cpp_source.html#l00421">readDomainWithoutCollComm()</a>, <a class="el" href="Reordonner__faces__periodiques_8cpp_source.html#l00114">Reordonner_faces_periodiques::reordonner_faces_periodiques()</a>, <a class="el" href="Domaine_8h_source.html#l00116">Domaine::set_fichier_lu()</a>, <a class="el" href="vect__impl_8h_source.html#l00057">vect_impl::size()</a>, <a class="el" href="liste_8cpp_source.html#l00175">liste::size()</a>, <a class="el" href="Statistiques_8h_source.html#l00190">statistiques()</a>, <a class="el" href="Op__Grad__EF_8cpp_source.html#l00099">test()</a>, <a class="el" href="Scatter_8cpp_source.html#l00752">trier_les_joints()</a>, <a class="el" href="Domaine_8h_source.html#l00272">Domaine::zone()</a>, and <a class="el" href="Domaine_8h_source.html#l00600">Domaine::zones()</a>.</p>

<p>Referenced by <a class="el" href="Scatter_8cpp_source.html#l00150">interpreter()</a>.</p>
<div class="fragment"><pre class="fragment">{
<span class="comment">// On determine si le fichier est au nouveau format ou a l&#39;ancien</span>
  <span class="keywordflow">if</span> (<a class="code" href="classProcess.html#acd052b99706c577f8a5b6656217cf4c2" title="renvoie 1 si on est sur le processeur maitre du groupe courant (c&#39;est a dire me() == 0)...">Process::je_suis_maitre</a>())
    <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Reading geometry from .Zones file(s) ...&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
  <a class="code" href="classProcess.html#aa9e74a5c06a68ea38298a08ea401e7b1" title="Synchronise tous les processeurs du groupe courant&lt;br&gt;(attend que tous les processeurs soient arrives...">barrier</a>(); <span class="comment">//!&lt; Attendre que le message soit affiche</span>
<span class="comment"></span>
  <a class="code" href="classDomaine.html" title="Classe Domaine Un Domaine represente le domaine (spatial) de resolution d&#39;un Probleme. Un Domaine a un Nom, il est constitue d&#39;une ou plusieurs Zone qui peuvent etre eventuellement decoupees en Sous_Zone. Un Domaine porte l&#39;ensemble des sommets utilises par ses Zones. On peut vouloir resoudre des problemes de type different sur plusieurs domaines, geometriquement les domaines sont alors couples par des surfaces qu&#39;on appelle Raccord.">Domaine</a>&amp; dom = <a class="code" href="classScatter.html#ac33aacdb609dcc870faeb93500ed017f">domaine</a>();

  <a class="code" href="classNom.html" title="class Nom Une chaine de caractere pour nommer les objets de TRUST">Nom</a> copy(nomentree);
  copy = copy.nom_me(<a class="code" href="classProcess.html#a6bf692ce58d9578aa62ac3c07b8caaa1" title="renvoie le nombre de processeurs dans le groupe courant Voir Comm_Group::nproc() et PE_Groups::curren...">Process::nproc</a>(), <span class="stringliteral">&quot;p&quot;</span>, 1);

<span class="comment">// bool is_hdf = FichierHDF::is_hdf5(copy);</span>
  <a class="code" href="classLecFicDiffuse.html" title="Cette classe implemente les operateurs et les methodes virtuelles de la classe EFichier de la facon s...">LecFicDiffuse</a> <a class="code" href="Op__Grad__EF_8cpp.html#abc0897c211f7aa4541da5833388f868b">test</a>;
  <span class="keywordtype">bool</span> is_hdf = test.<a class="code" href="classLecFicDiffuse.html#a2e4f3199de5e1b47edcffc68952c7be8" title="Ouverture du fichier. Cette methode doit etre appelee par tous les processeurs du groupe...">ouvrir</a>(copy) &amp;&amp; <a class="code" href="classFichierHDF.html#a0ad22bc624e64d0fecd33abb64b4881a">FichierHDF::is_hdf5</a>(copy);

  <span class="keyword">static</span> <a class="code" href="classStat__Counter__Id.html">Stat_Counter_Id</a> stats = <a class="code" href="Statistiques_8h.html#a7bb2ce53a9ec088bba93ddcfce2b8cb1">statistiques</a>().<a class="code" href="classStatistiques.html#ae1d5ab3d7354d4f748173dde67f9912d">new_counter</a>(0 <span class="comment">/* Level */</span>, <span class="stringliteral">&quot;Scatter::lire_domaine&quot;</span>, 0 <span class="comment">/* Group */</span>);

  <a class="code" href="Statistiques_8h.html#a7bb2ce53a9ec088bba93ddcfce2b8cb1">statistiques</a>().<a class="code" href="classStatistiques.html#affcd058809786918ed173aaf681d0843">begin_count</a>(stats);
  <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> mergedZones(<a class="code" href="classProcess.html#a6bf692ce58d9578aa62ac3c07b8caaa1" title="renvoie le nombre de processeurs dans le groupe courant Voir Comm_Group::nproc() et PE_Groups::curren...">Process::nproc</a>());
  mergedZones = 0;
  <span class="keywordtype">bool</span> domain_not_built = <span class="keyword">true</span>;
  <span class="keywordflow">if</span> (is_hdf)
    {
      <a class="code" href="classFichierHDFPar.html" title="Parallel collective version of FichierHDF, to be used for all concurrent reading/writing on HDF files...">FichierHDFPar</a> fic_hdf;
<span class="comment">// FichierHDF fic_hdf;</span>
      nomentree = copy;
      fic_hdf.<a class="code" href="classFichierHDF.html#a55803f961da3af25680be6cec26e85ec">open</a>(nomentree, <span class="keyword">true</span>);

      std::string dname = <span class="stringliteral">&quot;/zone_&quot;</span>  + std::to_string(<a class="code" href="classProcess.html#ab55ba07167ec807ed3a145cac0f5dca4" title="renvoie mon rang dans le groupe de communication courant. Voir Comm_Group::rank() et PE_Groups::curre...">Process::me</a>());
      <span class="keywordtype">bool</span> ok = fic_hdf.<a class="code" href="classFichierHDF.html#a5731b503f5e1472ad9ab934f759dcf7b">exists</a>(dname.c_str());
      <span class="keywordflow">if</span>(!ok)
        {
          mergedZones = 1;
          <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;<a class="code" href="classProcess.html#a6bf692ce58d9578aa62ac3c07b8caaa1" title="renvoie le nombre de processeurs dans le groupe courant Voir Comm_Group::nproc() et PE_Groups::curren...">Process::nproc</a>(); i++)
            {
              <a class="code" href="classEntree__Brute.html" title="An Entree whose main source of data is an arbitrary binary buffer set using the set_data() method...">Entree_Brute</a> data_part;
              <a class="code" href="classDomaine.html" title="Classe Domaine Un Domaine represente le domaine (spatial) de resolution d&#39;un Probleme. Un Domaine a un Nom, il est constitue d&#39;une ou plusieurs Zone qui peuvent etre eventuellement decoupees en Sous_Zone. Un Domaine porte l&#39;ensemble des sommets utilises par ses Zones. On peut vouloir resoudre des problemes de type different sur plusieurs domaines, geometriquement les domaines sont alors couples par des surfaces qu&#39;on appelle Raccord.">Domaine</a> part_dom;
              std::string tmp = dname + <span class="stringliteral">&quot;_&quot;</span> + std::to_string(i);

              <span class="keywordtype">bool</span> exists = fic_hdf.<a class="code" href="classFichierHDF.html#a5731b503f5e1472ad9ab934f759dcf7b">exists</a>(tmp.c_str());
              <span class="keywordflow">if</span>(exists)
                {
                  <a class="code" href="classNom.html" title="class Nom Une chaine de caractere pour nommer les objets de TRUST">Nom</a> dataset_name(dname.c_str());
                  fic_hdf.<a class="code" href="classFichierHDF.html#a4b1e63bb02aebe3cd085af22cdd870af">read_dataset</a>(dataset_name, i, data_part);
                  <a class="code" href="classScatter.html#ad8cdf7a8e4ad0065e9c3e1351aec8a1b" title="Does the exact same thing as the readOn of the class Domaine but without collective communication Nec...">readDomainWithoutCollComm</a>( part_dom, data_part );
                  <a class="code" href="classScatter.html#ace98ccb7d5fd754b2ae527ce96876977" title="Merging dom_to_add with dom.">mergeDomains</a>(dom, part_dom);

<span class="comment">// Renseigne dans quel fichier le domaine a ete lu</span>
                  dom.<a class="code" href="classDomaine.html#a092a7a09cc39770fb7549ff29fcd8c8e">set_fichier_lu</a>(nomentree);
                  data_part &gt;&gt; liste_bords_periodiques;
                  domain_not_built = <span class="keyword">false</span>;
                }
              <span class="keywordflow">else</span>
                <span class="keywordflow">break</span>;

            }
        }
      <span class="keywordflow">else</span>
        {
          <a class="code" href="classEntree__Brute.html" title="An Entree whose main source of data is an arbitrary binary buffer set using the set_data() method...">Entree_Brute</a> data;
          fic_hdf.<a class="code" href="classFichierHDF.html#a4b1e63bb02aebe3cd085af22cdd870af">read_dataset</a>(<span class="stringliteral">&quot;/zone&quot;</span>, <a class="code" href="classProcess.html#ab55ba07167ec807ed3a145cac0f5dca4" title="renvoie mon rang dans le groupe de communication courant. Voir Comm_Group::rank() et PE_Groups::curre...">Process::me</a>(), data);

<span class="comment">// Feed TRUST objects:</span>
          <a class="code" href="classScatter.html#ad8cdf7a8e4ad0065e9c3e1351aec8a1b" title="Does the exact same thing as the readOn of the class Domaine but without collective communication Nec...">readDomainWithoutCollComm</a>(dom, data);
          dom.<a class="code" href="classDomaine.html#a1a2b46771e991fe1d8a68bbb13a96cd0">zones</a>().<a class="code" href="classZones.html#a858a7732989d35d6899c47857ac135a6" title="Associe toutes les zones de la liste au domaine specifie.">associer_domaine</a>(dom);
          dom.<a class="code" href="classDomaine.html#a092a7a09cc39770fb7549ff29fcd8c8e">set_fichier_lu</a>(nomentree);
          data &gt;&gt; liste_bords_periodiques;
          domain_not_built = <span class="keyword">false</span>;
        }

      fic_hdf.<a class="code" href="classFichierHDF.html#ac5d8eb389ee60109c2d60029f442487f">close</a>();
    }
  <span class="keywordflow">else</span>
    {
      <a class="code" href="classLecFicDistribueBin.html" title="Lecture dans un fichier au format binaire. Cette classe implemente les operateurs et les methodes vir...">LecFicDistribueBin</a> fichier_binaire;
      <span class="keywordtype">int</span> isSingleZone = fichier_binaire.<a class="code" href="classLecFicDistribue.html#a2186b78886c1a8630c7f69af03141087" title="Ouvre le fichier avec les parametres mode et prot donnes Ces parametres sont les parametres de la met...">ouvrir</a>(nomentree);
      <span class="keywordflow">if</span> (!isSingleZone)
        {
          mergedZones = 1;
          <a class="code" href="classNom.html" title="class Nom Une chaine de caractere pour nommer les objets de TRUST">Nom</a> nomentree_with_suffix=nomentree.<a class="code" href="classNom.html#a49a5c6438b6efe73ab314900c60a329c" title="Insere _prefix000n (n=me() ou nproc()) dans un nom de fichier (par ex:toto.titi) pour donner toto_pre...">nom_me</a>(<a class="code" href="classProcess.html#ab55ba07167ec807ed3a145cac0f5dca4" title="renvoie mon rang dans le groupe de communication courant. Voir Comm_Group::rank() et PE_Groups::curre...">Process::me</a>());
          <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;<a class="code" href="classProcess.html#a6bf692ce58d9578aa62ac3c07b8caaa1" title="renvoie le nombre de processeurs dans le groupe courant Voir Comm_Group::nproc() et PE_Groups::curren...">Process::nproc</a>(); i++)
            {
              <a class="code" href="classEFichierBin.html" title="Lecture dans un fichier d&#39;objets ecrits au format binaire.">EFichierBin</a> fichier_binaire_part;
              <a class="code" href="classDomaine.html" title="Classe Domaine Un Domaine represente le domaine (spatial) de resolution d&#39;un Probleme. Un Domaine a un Nom, il est constitue d&#39;une ou plusieurs Zone qui peuvent etre eventuellement decoupees en Sous_Zone. Un Domaine porte l&#39;ensemble des sommets utilises par ses Zones. On peut vouloir resoudre des problemes de type different sur plusieurs domaines, geometriquement les domaines sont alors couples par des surfaces qu&#39;on appelle Raccord.">Domaine</a> part_dom;
              std::string tmp = nomentree_with_suffix.<a class="code" href="classNom.html#aad3086ebfdd912dadd099cd05cc45ee9">getPrefix</a>(<span class="stringliteral">&quot;.Zones&quot;</span>).<a class="code" href="classNom.html#a855d8cd96b5c73c2aa55cb7c0a870640">getString</a>();
              tmp += <span class="stringliteral">&quot;_&quot;</span>;
              tmp += std::to_string(i);
              tmp += <span class="stringliteral">&quot;.Zones&quot;</span>;
              <a class="code" href="classNom.html" title="class Nom Une chaine de caractere pour nommer les objets de TRUST">Nom</a> nomentree_part(tmp.c_str());
              <span class="keywordtype">int</span> ok = fichier_binaire_part.<a class="code" href="classEntree__Fichier__base.html#a8e34b235668e94f335cc9ab18dd4e427">ouvrir</a>(nomentree_part);
              <span class="keywordflow">if</span>(ok)
                {
                  <a class="code" href="classScatter.html#ad8cdf7a8e4ad0065e9c3e1351aec8a1b" title="Does the exact same thing as the readOn of the class Domaine but without collective communication Nec...">readDomainWithoutCollComm</a>( part_dom, fichier_binaire_part );
                  <a class="code" href="classScatter.html#ace98ccb7d5fd754b2ae527ce96876977" title="Merging dom_to_add with dom.">mergeDomains</a>(dom, part_dom);

<span class="comment">// Renseigne dans quel fichier le domaine a ete lu</span>
                  dom.<a class="code" href="classDomaine.html#a092a7a09cc39770fb7549ff29fcd8c8e">set_fichier_lu</a>(nomentree);
                  fichier_binaire_part &gt;&gt; liste_bords_periodiques;
                  fichier_binaire_part.<a class="code" href="classEntree__Fichier__base.html#aca9165bc1712c1057b4d4b91a7ea4fb4">close</a>();
                  domain_not_built = <span class="keyword">false</span>;
                }
              <span class="keywordflow">else</span>
                <span class="keywordflow">break</span>;
            }
        }
      <span class="keywordflow">else</span>
        {
          <a class="code" href="classScatter.html#ad8cdf7a8e4ad0065e9c3e1351aec8a1b" title="Does the exact same thing as the readOn of the class Domaine but without collective communication Nec...">readDomainWithoutCollComm</a>(dom, fichier_binaire );

          dom.<a class="code" href="classDomaine.html#a1a2b46771e991fe1d8a68bbb13a96cd0">zones</a>().<a class="code" href="classZones.html#a858a7732989d35d6899c47857ac135a6" title="Associe toutes les zones de la liste au domaine specifie.">associer_domaine</a>(dom);
<span class="comment">// Renseigne dans quel fichier le domaine a ete lu</span>
          dom.<a class="code" href="classDomaine.html#a092a7a09cc39770fb7549ff29fcd8c8e">set_fichier_lu</a>(nomentree);
          fichier_binaire &gt;&gt; liste_bords_periodiques;
          fichier_binaire.<a class="code" href="classEntree__Fichier__base.html#aca9165bc1712c1057b4d4b91a7ea4fb4">close</a>();
          domain_not_built = <span class="keyword">false</span>;
        }
    }

  <span class="keywordflow">if</span>(domain_not_built)
    {
      <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Error in Scatter::lire_domaine\n&quot;</span>;
      <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;The domain on the current process hasn&#39;t been built&quot;</span> &lt;&lt; finl;
      <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;The number of processes you mentionned is probaly higher than the number of zones&quot;</span> &lt;&lt; finl;
      <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">Process::exit</a>();
    }

<span class="comment">// Verification sanitaire: nombre de processeurs = nombre de zones</span>
<span class="comment">// (on verifie qu&#39;il n&#39;y a pas de joint avec un processeur inexistant)</span>
<span class="comment">// (le check precedent n&#39;est pas suffisant:</span>
<span class="comment">// il verifie seulement que le nombre de processeurs n&#39;est pas superieur au nombre de zones)</span>
  {

    <span class="keyword">const</span> <a class="code" href="classJoints.html" title="Classe Joints Cette classe represente une liste d&#39;objet de type Joint.">Joints</a>&amp; joints = dom.<a class="code" href="classDomaine.html#a0e62f2bc829542fafa29e3f2c614159c" title="Renvoie la i-ieme zone du domaine. (version const)">zone</a>(0).<a class="code" href="classZone.html#a16f273a76321d31435995cdad664285a" title="Renvoie la liste des joints de la zone. (version const)">faces_joint</a>();
    <span class="keyword">const</span> <span class="keywordtype">int</span> nb_joints = joints.<a class="code" href="classliste.html#ab47f280662ff68f9aa2e00e50431c5dc" title="Renvoie la taille de la liste Une liste vide est de taille nulle.">size</a>();
    <span class="keywordtype">int</span> max_pe_voisin = 0;
    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; nb_joints; i++)
      {
        <span class="keyword">const</span> <span class="keywordtype">int</span> pe_voisin = joints[i].PEvoisin();
        <span class="keywordflow">if</span> (pe_voisin &gt;= max_pe_voisin)
          max_pe_voisin = pe_voisin;
      }

    max_pe_voisin = (int) <a class="code" href="classProcess.html#a1e9d9f9899b71927cfafae14c7bd048d" title="Calcule le max de x sur tous les processeurs du groupe courant. Remarques : Cette methode doit etre a...">mp_max</a>(max_pe_voisin);
    <span class="keywordtype">double</span> ok=1;
    <span class="keywordflow">if</span> (max_pe_voisin &gt;= <a class="code" href="classProcess.html#a6bf692ce58d9578aa62ac3c07b8caaa1" title="renvoie le nombre de processeurs dans le groupe courant Voir Comm_Group::nproc() et PE_Groups::curren...">nproc</a>()) ok=0;
    <span class="keywordflow">if</span> (!ok)
      {
        <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Error in Scatter::lire_domaine\n&quot;</span>
             &lt;&lt; <span class="stringliteral">&quot;The domain has been partitioned with at least &quot;</span> &lt;&lt; max_pe_voisin &lt;&lt; <span class="stringliteral">&quot; &quot;</span>
             &lt;&lt; <span class="stringliteral">&quot;zones whereas the number of processes asked is &quot;</span> &lt;&lt; <a class="code" href="classProcess.html#a6bf692ce58d9578aa62ac3c07b8caaa1" title="renvoie le nombre de processeurs dans le groupe courant Voir Comm_Group::nproc() et PE_Groups::curren...">Process::nproc</a>() &lt;&lt; <span class="stringliteral">&quot;.&quot;</span> &lt;&lt; finl;
        <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;The number of zones and number of processes must match.&quot;</span> &lt;&lt; finl;
        <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">exit</a>();
      }
  }

<span class="comment">// tri des joints dans l&#39;ordre croissant des procs</span>
  <a class="code" href="classJoints.html" title="Classe Joints Cette classe represente une liste d&#39;objet de type Joint.">Joints</a>&amp; joints = dom.<a class="code" href="classDomaine.html#a0e62f2bc829542fafa29e3f2c614159c" title="Renvoie la i-ieme zone du domaine. (version const)">zone</a>(0).<a class="code" href="classZone.html#a16f273a76321d31435995cdad664285a" title="Renvoie la liste des joints de la zone. (version const)">faces_joint</a>();
  <a class="code" href="classScatter.html#ac5dd6d7661490708649976cde509f480" title="Tri des joints dans l&#39;ordre croissant des processeurs.">trier_les_joints</a>(joints);
  <a class="code" href="communications_8cpp.html#a5ceda011ec527d63b691f62cd2fb61c8">envoyer_all_to_all</a>(mergedZones, mergedZones);
  <a class="code" href="classScatter.html#a86c9311713284ed6591da95c7eb9411d" title="Merged zones receive joints information from their neighbours to ensure that their common items (vert...">check_consistancy_remote_items</a>( dom, mergedZones );
  dom.<a class="code" href="classDomaine.html#a0e62f2bc829542fafa29e3f2c614159c" title="Renvoie la i-ieme zone du domaine. (version const)">zone</a>(0).<a class="code" href="classZone.html#a7299f36361dd10ed56d008143f517bfe" title="associate the read objects to the zone and check that the reading objects are coherent">check_zone</a>();

<span class="comment">// PL : pas tout a fait exact le nombre affiche de sommets, on compte plusieurs fois les sommets des joints...</span>
  <span class="keywordtype">int</span> nbsom = <a class="code" href="classProcess.html#a7d23bc1ef94b3f0623fbc79d034c27fd" title="Calcule la somme de x sur tous les processeurs du groupe courant. Voir aussi mp_max()">mp_sum</a>(dom.<a class="code" href="classDomaine.html#a0846ac03a10b65c4df911fe35a19c02f" title="Renvoie le nombre total de sommets.">les_sommets</a>().<a class="code" href="classDoubleTab.html#ac3805e2637a3b880ba2d3e650c69dac4" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(0));
  <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot; Number of nodes: &quot;</span> &lt;&lt; nbsom &lt;&lt; finl;

  <a class="code" href="classScatter.html#a1874139ffd29d5a68191bc7828d3a5bd" title="cree des descripteurs sequentiels pour les tableaux sommets et elements du domaine (necessaire car Sc...">init_sequential_domain</a>(dom);

<span class="comment">// merged zones need to reorder faces of periodic borders</span>
  <span class="keyword">const</span> <span class="keywordtype">int</span> myZoneWasMerged = mergedZones[<a class="code" href="classProcess.html#ab55ba07167ec807ed3a145cac0f5dca4" title="renvoie mon rang dans le groupe de communication courant. Voir Comm_Group::rank() et PE_Groups::curre...">Process::me</a>()];
  <span class="keywordflow">if</span>(myZoneWasMerged)
    {
      <span class="keywordflow">for</span>(<span class="keywordtype">int</span> bord_perio = 0; bord_perio &lt; liste_bords_periodiques.<a class="code" href="classvect__impl.html#a78155bfbd6b61f4710b9830641ed1694">size</a>(); bord_perio++)
        {
          <a class="code" href="classNom.html" title="class Nom Une chaine de caractere pour nommer les objets de TRUST">Nom</a> bp_nom = liste_bords_periodiques(bord_perio);
          <a class="code" href="classBord.html" title="Classe Bord Cette classe represente un bord d&#39;une zone, c&#39;est un type de frontiere&lt;br&gt;(derive de Fronti...">Bord</a>&amp; bord = dom.<a class="code" href="classDomaine.html#a0e62f2bc829542fafa29e3f2c614159c" title="Renvoie la i-ieme zone du domaine. (version const)">zone</a>(0).<a class="code" href="classZone.html#af2f1e6a14af55249979da674e7aac11a" title="Renvoie le i-ieme bord de la zone&lt;br&gt;(version const)">bord</a>(bp_nom);
          <span class="keywordflow">if</span>(bord.<a class="code" href="classFrontiere.html#aa073fe9dbdddde59471ee7032b256aa2" title="Renvoie le nombre de faces de la frontiere.">nb_faces</a>() == 0)
            <span class="keywordflow">continue</span>;

          <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a> direction_perio(<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>);
          <a class="code" href="classReordonner__faces__periodiques.html#ad93560d3838d3516deb892d88b47dedf">Reordonner_faces_periodiques::chercher_direction_perio</a>(direction_perio, dom, bp_nom);
          <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; faces = bord.<a class="code" href="classFrontiere.html#ac64479069f0c43a17cb5766a39ce5ba8" title="Renvoie les faces de la frontiere&lt;br&gt;(version const)">faces</a>().<a class="code" href="classFaces.html#a07b8d8db9e3d656b93a21a49c063430c">les_sommets</a>();
          <span class="keywordtype">double</span> epsilon = <a class="code" href="classObjet__U.html#a7447e25c68cc8d3a1c06cf99f0565cff">precision_geom</a>;
          <a class="code" href="classReordonner__faces__periodiques.html#a3d177f6fcafb470513dad54fe4d9f79a" title="Reordonne le tableau &quot;faces&quot; selon la convention des faces periodiques: D&#39;abord les faces d&#39;une ext...">Reordonner_faces_periodiques::reordonner_faces_periodiques</a>(dom, faces, direction_perio, epsilon);
        }
    }

  <a class="code" href="Statistiques_8h.html#a7bb2ce53a9ec088bba93ddcfce2b8cb1">statistiques</a>().<a class="code" href="classStatistiques.html#a0faf52d1b518f5b0b2177f22efcc222d" title="Arret du compteur counter_id. On ajoute quantity a la somme des &#39;quantity&#39; (par defaut 0) stockees po...">end_count</a>(stats);
  <a class="code" href="classProcess.html#aa9e74a5c06a68ea38298a08ea401e7b1" title="Synchronise tous les processeurs du groupe courant&lt;br&gt;(attend que tous les processeurs soient arrives...">barrier</a>();
}
</pre></div>
</div>
</div>
<a class="anchor" id="ace98ccb7d5fd754b2ae527ce96876977"></a><!-- doxytag: member="Scatter::mergeDomains" ref="ace98ccb7d5fd754b2ae527ce96876977" args="(Domaine &amp;dom, Domaine &amp;part_dom)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Scatter::mergeDomains </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDomaine.html">Domaine</a> &amp;&#160;</td>
          <td class="paramname"><em>dom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDomaine.html">Domaine</a> &amp;&#160;</td>
          <td class="paramname"><em>part_dom</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Merging dom_to_add with dom. </p>

<p>Definition at line <a class="el" href="Scatter_8cpp_source.html#l00463">463</a> of file <a class="el" href="Scatter_8cpp_source.html">Scatter.cpp</a>.</p>

<p>References <a class="el" href="Domaine_8cpp_source.html#l00392">Domaine::add()</a>, <a class="el" href="Domaine_8cpp_source.html#l00259">Domaine::ajouter()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00355">ArrOfInt::append_array()</a>, <a class="el" href="ArrOfInt_8cpp_source.html#l00911">ArrOfInt::array_trier_retirer_doublons()</a>, <a class="el" href="Zone_8cpp_source.html#l00489">Zone::associer_domaine()</a>, <a class="el" href="Domaine_8h_source.html#l00500">Domaine::coord_sommets()</a>, <a class="el" href="Joint_8h_source.html#l00066">Joint::ELEMENT</a>, <a class="el" href="Zone_8h_source.html#l01098">Zone::faces_joint()</a>, <a class="el" href="Joint__Items_8cpp_source.html#l00049">Joint_Items::items_communs()</a>, <a class="el" href="Joint__Items_8cpp_source.html#l00063">Joint_Items::items_distants()</a>, <a class="el" href="Joint_8cpp_source.html#l00186">Joint::joint_item()</a>, <a class="el" href="Zones_8cpp_source.html#l00246">Zones::merge()</a>, <a class="el" href="Zone_8h_source.html#l00300">Zone::nb_elem()</a>, <a class="el" href="Zone_8h_source.html#l00550">Zone::nb_joints()</a>, <a class="el" href="Domaine_8h_source.html#l00242">Domaine::nb_zones()</a>, <a class="el" href="Joint_8cpp_source.html#l00099">Joint::PEvoisin()</a>, <a class="el" href="Zone_8cpp_source.html#l00711">Zone::renum()</a>, <a class="el" href="Zone_8cpp_source.html#l00747">Zone::renum_joint_common_items()</a>, <a class="el" href="ArrOfInt_8cpp_source.html#l00443">ArrOfInt::set_smart_resize()</a>, <a class="el" href="liste_8cpp_source.html#l00175">liste::size()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00342">ArrOfInt::size_array()</a>, <a class="el" href="Joint_8h_source.html#l00066">Joint::SOMMET</a>, <a class="el" href="Scatter_8cpp_source.html#l02925">uninit_sequential_domain()</a>, <a class="el" href="Domaine_8h_source.html#l00272">Domaine::zone()</a>, and <a class="el" href="Domaine_8h_source.html#l00600">Domaine::zones()</a>.</p>

<p>Referenced by <a class="el" href="Scatter_8cpp_source.html#l00513">lire_domaine()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">int</span> old_nb_elems = dom.<a class="code" href="classDomaine.html#a9f3fc389a1310d1fc8b4b27976855376" title="Renvoie le nombre de zone du domaine.">nb_zones</a>() ? dom.<a class="code" href="classDomaine.html#a0e62f2bc829542fafa29e3f2c614159c" title="Renvoie la i-ieme zone du domaine. (version const)">zone</a>(0).<a class="code" href="classZone.html#a7f249429803b27139a1c54436f6164a5" title="Renvoie le nombre d&#39;elements de la zone.">nb_elem</a>() : 0;
<span class="comment">// merging vertices</span>
  <a class="code" href="classIntVect.html">IntVect</a> nums;
  <a class="code" href="classZone.html" title="classe Zone Une Zone est un maillage compose d&#39;un ensemble d&#39;elements geometriques de meme type...">Zone</a>&amp; zone=dom.<a class="code" href="classDomaine.html#a6204a2b89860bfd74ca2858d1d8750bf" title="Ajoute une Sous_Zone au domaine.">add</a>(dom_to_add.zone(0));
  zone.<a class="code" href="classZone.html#a68a215145852861f2d513c959f52a1a5" title="Specifie le domaine dont la zone fait partie.">associer_domaine</a>(dom);
  dom.<a class="code" href="classDomaine.html#a9e067ee24e1952315722374190c8cb06" title="Ajoute des noeuds au domaine avec elimination des noeuds double au retour nums contient les nouveaux ...">ajouter</a>(dom_to_add.coord_sommets(), nums);
  <a class="code" href="classScatter.html#a8cf934a9b5f7ecb7ef89f61c09804f45" title="methode utilisee par les interpretes qui modifient le domaine&lt;br&gt;(sequentiel), detruit les descripteu...">Scatter::uninit_sequential_domain</a>(dom);
  zone.<a class="code" href="classZone.html#ade842749f28689fdf39c3a5ea2757e3f" title="Renumerotation des noeuds: Le noeud de numero k devient le noeud de numero Les_Nums[k].">renum</a>(nums);
  zone.<a class="code" href="classZone.html#ac59b5ace8b4112340624d4b1cb9aa627" title="Renumerotation des noeuds et des elements presents dans les items communs des joints Le noeud de nume...">renum_joint_common_items</a>(nums, old_nb_elems);
  zone.<a class="code" href="classZone.html#a68a215145852861f2d513c959f52a1a5" title="Specifie le domaine dont la zone fait partie.">associer_domaine</a>(dom);

  <span class="keywordflow">if</span>(dom.<a class="code" href="classDomaine.html#a1a2b46771e991fe1d8a68bbb13a96cd0">zones</a>().<a class="code" href="classliste.html#ab47f280662ff68f9aa2e00e50431c5dc" title="Renvoie la taille de la liste Une liste vide est de taille nulle.">size</a>() &gt; 1)
    {
      <span class="keywordtype">int</span> new_nb_elems = dom.<a class="code" href="classDomaine.html#a0e62f2bc829542fafa29e3f2c614159c" title="Renvoie la i-ieme zone du domaine. (version const)">zone</a>(0).<a class="code" href="classZone.html#a7f249429803b27139a1c54436f6164a5" title="Renvoie le nombre d&#39;elements de la zone.">nb_elem</a>();
<span class="comment">// merging zones</span>
      dom.<a class="code" href="classDomaine.html#a1a2b46771e991fe1d8a68bbb13a96cd0">zones</a>().<a class="code" href="classZones.html#aa1bcac020bceac5afecd16add50cc364" title="Merge all the zones of my processor in a single one is not tested when the zones are dispatched on mu...">merge</a>();

<span class="comment">// merging common vertices and remote items</span>
      <span class="keyword">const</span> <span class="keywordtype">int</span>&amp; nb_joints = dom_to_add.zone(0).nb_joints();
      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i_joint = 0; i_joint &lt; nb_joints; i_joint++)
        {
          <span class="keyword">const</span> <a class="code" href="classJoint.html" title="La classe Joint est une Frontiere qui contient les faces et les sommets de joint avec la zone PEvoisi...">Joint</a>&amp; joint_to_add  = dom_to_add.<a class="code" href="classFrontiere.html#a510866aace5f3ed9482553db1a08a3c9" title="Renvoie la Zone associee a la frontiere. (version const)">zone</a>(0).<a class="code" href="classZone.html#a16f273a76321d31435995cdad664285a" title="Renvoie la liste des joints de la zone. (version const)">faces_joint</a>()[i_joint];

          <span class="keywordtype">int</span> my_joint_index = 0;
          <span class="keywordflow">while</span>(joint_to_add.<a class="code" href="classJoint.html#a0952bc5c7805434ccd8cd5c9b01e3747" title="Renvoie PEvoisin (numero de la zone voisine)">PEvoisin</a>() != dom.<a class="code" href="classDomaine.html#a0e62f2bc829542fafa29e3f2c614159c" title="Renvoie la i-ieme zone du domaine. (version const)">zone</a>(0).<a class="code" href="classZone.html#a16f273a76321d31435995cdad664285a" title="Renvoie la liste des joints de la zone. (version const)">faces_joint</a>()[my_joint_index].PEvoisin())
            my_joint_index++;

          <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; sommets_to_add = joint_to_add.<a class="code" href="classJoint.html#a3f49fb1150967b436a115a7373ab27a0" title="Renvoie les informations de joint pour le type demande.">joint_item</a>(<a class="code" href="classJoint.html#a1e2d15d088c27c9b7b11c02bf4d2c926a050aa4faf237e25faef6fff15ffc20f8">Joint::SOMMET</a>).<a class="code" href="classJoint__Items.html#a435fb1629f6dafb089605913517e73c4" title="Voir items_communs_.">items_communs</a>();
          <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; items_communs = dom.<a class="code" href="classDomaine.html#a0e62f2bc829542fafa29e3f2c614159c" title="Renvoie la i-ieme zone du domaine. (version const)">zone</a>(0).<a class="code" href="classZone.html#a16f273a76321d31435995cdad664285a" title="Renvoie la liste des joints de la zone. (version const)">faces_joint</a>()[my_joint_index].set_joint_item(<a class="code" href="classJoint.html#a1e2d15d088c27c9b7b11c02bf4d2c926a050aa4faf237e25faef6fff15ffc20f8">Joint::SOMMET</a>).set_items_communs();
          items_communs.<a class="code" href="classArrOfInt.html#a22d744bcd452d039580d1d9186f02b4e" title="Change le mode l&#39;allocation memoire: reallocation d&#39;un tableau a chaque changement de taille (flag = ...">set_smart_resize</a>(1);
          <span class="keywordflow">for</span>(<span class="keywordtype">int</span> index=0; index&lt;sommets_to_add.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>(); index++)
            items_communs.<a class="code" href="classArrOfInt.html#a3f39d0966599416e7b1f7cd8159d8d01" title="Ajoute une case en fin de tableau et y stocke la &quot;valeur&quot;.">append_array</a>(nums[sommets_to_add[index]]);
          items_communs.<a class="code" href="classArrOfInt.html#a62f590c7e6998144131b7dbd8eb9a2a1" title="Tri des valeurs du tableau dans l&#39;ordre croissant et suppresion des doublons La fonction utilisee est...">array_trier_retirer_doublons</a>();

          <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; elements_to_add = joint_to_add.<a class="code" href="classJoint.html#a3f49fb1150967b436a115a7373ab27a0" title="Renvoie les informations de joint pour le type demande.">joint_item</a>(<a class="code" href="classJoint.html#a1e2d15d088c27c9b7b11c02bf4d2c926ae32de3a01fdb3ad6c506b8058a7f6173">Joint::ELEMENT</a>).<a class="code" href="classJoint__Items.html#ae51b330de79fcaae9c88166e3eee7cb8" title="Voir items_distants_.">items_distants</a>();
          <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; items_distants = dom.<a class="code" href="classDomaine.html#a0e62f2bc829542fafa29e3f2c614159c" title="Renvoie la i-ieme zone du domaine. (version const)">zone</a>(0).<a class="code" href="classZone.html#a16f273a76321d31435995cdad664285a" title="Renvoie la liste des joints de la zone. (version const)">faces_joint</a>()[my_joint_index].set_joint_item(<a class="code" href="classJoint.html#a1e2d15d088c27c9b7b11c02bf4d2c926ae32de3a01fdb3ad6c506b8058a7f6173">Joint::ELEMENT</a>).set_items_distants();
          items_distants.<a class="code" href="classArrOfInt.html#a22d744bcd452d039580d1d9186f02b4e" title="Change le mode l&#39;allocation memoire: reallocation d&#39;un tableau a chaque changement de taille (flag = ...">set_smart_resize</a>(1);
          <span class="keywordflow">for</span>(<span class="keywordtype">int</span> index=0; index&lt;elements_to_add.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>(); index++)
            items_distants.<a class="code" href="classArrOfInt.html#a3f39d0966599416e7b1f7cd8159d8d01" title="Ajoute une case en fin de tableau et y stocke la &quot;valeur&quot;.">append_array</a>(new_nb_elems + elements_to_add[index]);
        }
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a9e06b9a31bb668cffc13a5e817272345"></a><!-- doxytag: member="Scatter::printOn" ref="a9e06b9a31bb668cffc13a5e817272345" args="(Sortie &amp;x) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSortie.html">Sortie</a> &amp; Scatter::printOn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSortie.html">Sortie</a> &amp;&#160;</td>
          <td class="paramname"><em>os</em></td><td>)</td>
          <td> const<code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><a class="el" href="classSimple.html">Simple</a> appel a: <a class="el" href="classInterprete.html#a822d9b5447b696582ad3fab3e15e72fb" title="Ecriture de l&#39;objet sur un flot de sortie Methode a surcharger.">Interprete::printOn</a>(<a class="el" href="classSortie.html" title="Classe de base des flux de sortie. Elle sait ecrire des types simples&lt;br&gt;(entiers, flottants) et des Ob...">Sortie</a>&amp;) </p>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="classSortie.html" title="Classe de base des flux de sortie. Elle sait ecrire des types simples&lt;br&gt;(entiers, flottants) et des Ob...">Sortie</a>&amp;<br/>
 Signification: le flot de sortie modifie<br/>
 Contraintes: </dd></dl>

<p>Reimplemented from <a class="el" href="classInterprete.html#a822d9b5447b696582ad3fab3e15e72fb">Interprete</a>.</p>

<p>Reimplemented in <a class="el" href="classScatterMED.html#abfe5ae8b314c29fb55627bd683eaedc0">ScatterMED</a>.</p>

<p>Definition at line <a class="el" href="Scatter_8cpp_source.html#l00069">69</a> of file <a class="el" href="Scatter_8cpp_source.html">Scatter.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">return</span> <a class="code" href="classScatter.html#a9e06b9a31bb668cffc13a5e817272345" title="Simple appel a: Interprete::printOn(Sortie&amp;)">Interprete::printOn</a>(os);
}
</pre></div>
</div>
</div>
<a class="anchor" id="ad8cdf7a8e4ad0065e9c3e1351aec8a1b"></a><!-- doxytag: member="Scatter::readDomainWithoutCollComm" ref="ad8cdf7a8e4ad0065e9c3e1351aec8a1b" args="(Domaine &amp;dom, Entree &amp;fic)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Scatter::readDomainWithoutCollComm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDomaine.html">Domaine</a> &amp;&#160;</td>
          <td class="paramname"><em>dom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEntree.html">Entree</a> &amp;&#160;</td>
          <td class="paramname"><em>fic</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Does the exact same thing as the readOn of the class <a class="el" href="classDomaine.html" title="Classe Domaine Un Domaine represente le domaine (spatial) de resolution d&#39;un Probleme. Un Domaine a un Nom, il est constitue d&#39;une ou plusieurs Zone qui peuvent etre eventuellement decoupees en Sous_Zone. Un Domaine porte l&#39;ensemble des sommets utilises par ses Zones. On peut vouloir resoudre des problemes de type different sur plusieurs domaines, geometriquement les domaines sont alors couples par des surfaces qu&#39;on appelle Raccord.">Domaine</a><br/>
but without collective communication<br/>
Necessary when the processors don't have the same numbers of file to read. </p>

<p>Definition at line <a class="el" href="Scatter_8cpp_source.html#l00421">421</a> of file <a class="el" href="Scatter_8cpp_source.html">Scatter.cpp</a>.</p>

<p>References <a class="el" href="Domaine_8cpp_source.html#l00392">Domaine::add()</a>, <a class="el" href="EntreeSortie_8h_source.html#l00032">Cerr</a>, <a class="el" href="Process_8cpp_source.html#l00223">Process::exit()</a>, <a class="el" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>, <a class="el" href="Domaine_8cpp_source.html#l00132">Domaine::read_vertices()</a>, and <a class="el" href="Zone_8cpp_source.html#l00143">Zone::read_zone()</a>.</p>

<p>Referenced by <a class="el" href="Scatter_8cpp_source.html#l00513">lire_domaine()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;reading vertices...&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
  dom.<a class="code" href="classDomaine.html#a5ebe2a9e34ba2e1b8b54541e7418e08b" title="only read vertices from the stream s">read_vertices</a>(fic);

  <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Done !\nreading zones...&quot;</span> &lt;&lt; finl;

  <a class="code" href="classNom.html" title="class Nom Une chaine de caractere pour nommer les objets de TRUST">Nom</a> accouverte=<span class="stringliteral">&quot;{&quot;</span>;
  <a class="code" href="classNom.html" title="class Nom Une chaine de caractere pour nommer les objets de TRUST">Nom</a> accfermee=<span class="stringliteral">&quot;}&quot;</span>;
  <a class="code" href="classNom.html" title="class Nom Une chaine de caractere pour nommer les objets de TRUST">Nom</a> virgule=<span class="stringliteral">&quot;,&quot;</span>;
  <a class="code" href="classMotcle.html" title="Une chaine de caractere (Nom) en majuscules.">Motcle</a> nom;
  fic &gt;&gt; nom;
  <span class="keywordflow">if</span>(nom!=(<span class="keyword">const</span> <span class="keywordtype">char</span>*)<span class="stringliteral">&quot;vide&quot;</span>)
    {
      <span class="keywordflow">if</span> (nom!=accouverte)
        {
          <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Error while reading a list.&quot;</span> &lt;&lt; finl;
          <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;One expected an opened bracket { to start.&quot;</span> &lt;&lt; finl;
          <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">exit</a>();
        }
      <span class="keywordflow">while</span>(1)
        {
          <a class="code" href="classZone.html" title="classe Zone Une Zone est un maillage compose d&#39;un ensemble d&#39;elements geometriques de meme type...">Zone</a> zone_tmp;
          zone_tmp.<a class="code" href="classZone.html#a6a0068f3a0e3b45340f9dcbcef01e00a" title="read zone from the input stream">read_zone</a>(fic);
          dom.<a class="code" href="classDomaine.html#a6204a2b89860bfd74ca2858d1d8750bf" title="Ajoute une Sous_Zone au domaine.">add</a>(zone_tmp);

          fic &gt;&gt; nom;
          <span class="keywordflow">if</span>(nom==accfermee)
            <span class="keywordflow">break</span>;
          <span class="keywordflow">if</span>(nom!=virgule)
            {
              <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; nom &lt;&lt; <span class="stringliteral">&quot; one expected a &#39;,&#39; or a &#39;}&#39;&quot;</span> &lt;&lt; finl;
              <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">exit</a>();
            }
        }

    }
  <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Done!&quot;</span> &lt;&lt; finl;
}
</pre></div>
</div>
</div>
<a class="anchor" id="ad7c35f0d98c6d4de8511f87743fe5dbc"></a><!-- doxytag: member="Scatter::readOn" ref="ad7c35f0d98c6d4de8511f87743fe5dbc" args="(Entree &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEntree.html">Entree</a> &amp; Scatter::readOn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEntree.html">Entree</a> &amp;&#160;</td>
          <td class="paramname"><em>is</em></td><td>)</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><a class="el" href="classSimple.html">Simple</a> appel a: <a class="el" href="classInterprete.html#ab6030ea24bc88c367b753eb89c2b0439" title="Lecture d&#39;un Objet_U sur un flot d&#39;entree Methode a surcharger.">Interprete::readOn</a>(<a class="el" href="classEntree.html" title="Classe de definition des operateurs et methodes pour toute lecture dans un flot d&#39;entree (fichier...">Entree</a>&amp;) </p>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="classEntree.html" title="Classe de definition des operateurs et methodes pour toute lecture dans un flot d&#39;entree (fichier...">Entree</a>&amp;<br/>
 Signification: le flot d'entree modifie<br/>
 Contraintes: </dd></dl>

<p>Reimplemented from <a class="el" href="classInterprete.html#ab6030ea24bc88c367b753eb89c2b0439">Interprete</a>.</p>

<p>Reimplemented in <a class="el" href="classScatterMED.html#a569afd7c138685b89e7f6f70e47b25fc">ScatterMED</a>.</p>

<p>Definition at line <a class="el" href="Scatter_8cpp_source.html#l00089">89</a> of file <a class="el" href="Scatter_8cpp_source.html">Scatter.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">return</span> <a class="code" href="classScatter.html#ad7c35f0d98c6d4de8511f87743fe5dbc" title="Simple appel a: Interprete::readOn(Entree&amp;)">Interprete::readOn</a>(is);
}
</pre></div>
</div>
</div>
<a class="anchor" id="a0a86d55709f7e53fcf40a09de74033cf"></a><!-- doxytag: member="Scatter::reordonner_faces_de_joint" ref="a0a86d55709f7e53fcf40a09de74033cf" args="(Domaine &amp;dom)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Scatter::reordonner_faces_de_joint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDomaine.html">Domaine</a> &amp;&#160;</td>
          <td class="paramname"><em>dom</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reordonne les faces de joint de sorte qu'elles apparaissent dans le meme<br/>
ordre sur chaque couple de processeur voisin. En pratique, pour un couple<br/>
pe1 &lt; pe2, pe1 envoie ses faces de joint a pe2 et pe2 les traduit en indices<br/>
de sommets locaux. Les faces de joint du PE2 ne sont donc pas utilisees. </p>

<p>Definition at line <a class="el" href="Scatter_8cpp_source.html#l01807">1807</a> of file <a class="el" href="Scatter_8cpp_source.html">Scatter.cpp</a>.</p>

<p>References <a class="el" href="ArrOfInt_8h_source.html#l00355">ArrOfInt::append_array()</a>, <a class="el" href="Schema__Comm_8cpp_source.html#l00166">Schema_Comm::begin_comm()</a>, <a class="el" href="EntreeSortie_8h_source.html#l00032">Cerr</a>, <a class="el" href="IntTab_8h_source.html#l00233">IntTab::dimension()</a>, <a class="el" href="Schema__Comm_8cpp_source.html#l00380">Schema_Comm::echange_taille_et_messages()</a>, <a class="el" href="Schema__Comm_8cpp_source.html#l00430">Schema_Comm::end_comm()</a>, <a class="el" href="Process_8cpp_source.html#l00223">Process::exit()</a>, <a class="el" href="Frontiere_8h_source.html#l00175">Frontiere::faces()</a>, <a class="el" href="Zone_8h_source.html#l01098">Zone::faces_joint()</a>, <a class="el" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>, <a class="el" href="DoubleVect_8h_source.html#l00101">DoubleVect::get_md_vector()</a>, <a class="el" href="Scatter_8cpp_source.html#l01561">Traduction_Indice_Global_Local::initialiser()</a>, <a class="el" href="Faces_8h_source.html#l00268">Faces::les_sommets()</a>, <a class="el" href="Domaine_8h_source.html#l00577">Domaine::les_sommets()</a>, <a class="el" href="Process_8cpp_source.html#l00117">Process::me()</a>, <a class="el" href="Joint_8cpp_source.html#l00099">Joint::PEvoisin()</a>, <a class="el" href="Schema__Comm_8cpp_source.html#l00494">Schema_Comm::recv_buffer()</a>, <a class="el" href="IntTab_8cpp_source.html#l00353">IntTab::resize()</a>, <a class="el" href="Schema__Comm_8cpp_source.html#l00477">Schema_Comm::send_buffer()</a>, <a class="el" href="Schema__Comm_8cpp_source.html#l00146">Schema_Comm::set_send_recv_pe_list()</a>, <a class="el" href="ArrOfInt_8cpp_source.html#l00443">ArrOfInt::set_smart_resize()</a>, <a class="el" href="liste_8cpp_source.html#l00175">liste::size()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00342">ArrOfInt::size_array()</a>, <a class="el" href="Scatter_8cpp_source.html#l01678">Traduction_Indice_Global_Local::traduire_indice_global_vers_local()</a>, <a class="el" href="Scatter_8cpp_source.html#l01655">Traduction_Indice_Global_Local::traduire_indice_local_vers_global()</a>, and <a class="el" href="Domaine_8h_source.html#l00272">Domaine::zone()</a>.</p>

<p>Referenced by <a class="el" href="Scatter_8cpp_source.html#l00714">construire_structures_paralleles()</a>.</p>
<div class="fragment"><pre class="fragment">{
<span class="comment">// Construction du dictionnaire indice global/indice local</span>
<span class="comment">// pour les sommets du domaine:</span>
  <a class="code" href="classTraduction__Indice__Global__Local.html" title="Cette classe fournit les outils pour construire l&#39;espace virtuel d&#39;un tableau contenant des indices d...">Traduction_Indice_Global_Local</a> dictionnaire_indices;
  dictionnaire_indices.<a class="code" href="classTraduction__Indice__Global__Local.html#af8aae1bb5e815066c64937bde87b7e8a" title="Initialise le dictionnaire Precontition: Les espaces distants des entites utilisees doivent avoir ete...">initialiser</a>(dom.<a class="code" href="classDomaine.html#a0846ac03a10b65c4df911fe35a19c02f" title="Renvoie le nombre total de sommets.">les_sommets</a>().<a class="code" href="classDoubleVect.html#a0d16d30580c90526e4895388fb44be5d">get_md_vector</a>());

  <a class="code" href="classSchema__Comm.html">Schema_Comm</a> schema_comm;
  <a class="code" href="classJoints.html" title="Classe Joints Cette classe represente une liste d&#39;objet de type Joint.">Joints</a>&amp;      joints    = dom.<a class="code" href="classDomaine.html#a0e62f2bc829542fafa29e3f2c614159c" title="Renvoie la i-ieme zone du domaine. (version const)">zone</a>(0).<a class="code" href="classZone.html#a16f273a76321d31435995cdad664285a" title="Renvoie la liste des joints de la zone. (version const)">faces_joint</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_joints = joints.<a class="code" href="classliste.html#ab47f280662ff68f9aa2e00e50431c5dc" title="Renvoie la taille de la liste Une liste vide est de taille nulle.">size</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> moi       = <a class="code" href="classProcess.html#ab55ba07167ec807ed3a145cac0f5dca4" title="renvoie mon rang dans le groupe de communication courant. Voir Comm_Group::rank() et PE_Groups::curre...">Process::me</a>();
  <span class="keywordtype">int</span>       i_joint;

<span class="comment">// Remplissage des listes de destinataires:</span>
<span class="comment">// on envoie aux voisins de rang superieur et on recoit des voisins de rang inf.</span>
  <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> send_list;
  <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> recv_list;
  send_list.<a class="code" href="classArrOfInt.html#a22d744bcd452d039580d1d9186f02b4e" title="Change le mode l&#39;allocation memoire: reallocation d&#39;un tableau a chaque changement de taille (flag = ...">set_smart_resize</a>(1);
  recv_list.<a class="code" href="classArrOfInt.html#a22d744bcd452d039580d1d9186f02b4e" title="Change le mode l&#39;allocation memoire: reallocation d&#39;un tableau a chaque changement de taille (flag = ...">set_smart_resize</a>(1);

  <span class="keywordflow">for</span> (i_joint = 0; i_joint &lt; nb_joints; i_joint++)
    {
      <span class="keyword">const</span> <span class="keywordtype">int</span> pe_voisin = joints[i_joint].PEvoisin();
      <span class="keywordflow">if</span> (pe_voisin &gt; moi)
        send_list.<a class="code" href="classArrOfInt.html#a3f39d0966599416e7b1f7cd8159d8d01" title="Ajoute une case en fin de tableau et y stocke la &quot;valeur&quot;.">append_array</a>(pe_voisin);
      <span class="keywordflow">else</span>
        recv_list.<a class="code" href="classArrOfInt.html#a3f39d0966599416e7b1f7cd8159d8d01" title="Ajoute une case en fin de tableau et y stocke la &quot;valeur&quot;.">append_array</a>(pe_voisin);
    }

  schema_comm.<a class="code" href="classSchema__Comm.html#ad11c9b47999c294c26ae4df8d2bbd57b" title="Definit la liste des processeurs a qui on va envoyer et de qui on va recevoir des donnees...">set_send_recv_pe_list</a>(send_list, recv_list);

  schema_comm.<a class="code" href="classSchema__Comm.html#ac617b53de22748cdd9fa30a0cfd0f4a8" title="Statut passe a WRITING Autorise si status_ == WRITING:">begin_comm</a>();
<span class="comment">// Envoi des faces de joint, traduites en indices de sommets globaux</span>
  <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a> faces_num_global;
  faces_num_global.<a class="code" href="classArrOfInt.html#a22d744bcd452d039580d1d9186f02b4e" title="Change le mode l&#39;allocation memoire: reallocation d&#39;un tableau a chaque changement de taille (flag = ...">set_smart_resize</a>(1);
  <span class="keywordflow">for</span> (i_joint = 0; i_joint &lt; nb_joints; i_joint++)
    {
      <span class="keyword">const</span> <a class="code" href="classJoint.html" title="La classe Joint est une Frontiere qui contient les faces et les sommets de joint avec la zone PEvoisi...">Joint</a>&amp;   joint         = joints[i_joint];
      <span class="keyword">const</span> <span class="keywordtype">int</span>   pe_voisin     = joint.<a class="code" href="classJoint.html#a0952bc5c7805434ccd8cd5c9b01e3747" title="Renvoie PEvoisin (numero de la zone voisine)">PEvoisin</a>();
      <span class="keywordflow">if</span> (pe_voisin &gt; moi)
        {
          <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; faces_sommets = joint.<a class="code" href="classFrontiere.html#ac64479069f0c43a17cb5766a39ce5ba8" title="Renvoie les faces de la frontiere&lt;br&gt;(version const)">faces</a>().<a class="code" href="classFaces.html#a07b8d8db9e3d656b93a21a49c063430c">les_sommets</a>();
          <span class="keywordflow">if</span> (faces_sommets.<a class="code" href="classIntTab.html#abc3b32c94925a82f69d5b153a356e359" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(0) &gt; 0)
            {
              faces_num_global.<a class="code" href="classIntTab.html#a22e6bed6826b3688d4d0181cbf3b7a38" title="Change la taille du vecteur (identique a resize_array() pour le traitement des anciennes valeurs et d...">resize</a>(faces_sommets.<a class="code" href="classIntTab.html#abc3b32c94925a82f69d5b153a356e359" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(0), faces_sommets.<a class="code" href="classIntTab.html#abc3b32c94925a82f69d5b153a356e359" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(1));
              dictionnaire_indices.<a class="code" href="classTraduction__Indice__Global__Local.html#a633b4d9dc27e092f08bb2918401a4c7b" title="Transforme les indices locaux en indices globaux a l&#39;aide la &quot;table_&quot; (voir initialiser). On fait : Pour debut &lt;= i &lt; debut+nb indices_globaux[i] = table_[indices_locaux[i]] si indices_locaux[i] &lt; 0 alors indices_globaux[i] = -1.">traduire_indice_local_vers_global</a>(faces_sommets,
                                                                     faces_num_global,
                                                                     faces_sommets.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>());
            }
          <span class="keywordflow">else</span>
            faces_num_global.<a class="code" href="classIntTab.html#a22e6bed6826b3688d4d0181cbf3b7a38" title="Change la taille du vecteur (identique a resize_array() pour le traitement des anciennes valeurs et d...">resize</a>(0);

          schema_comm.<a class="code" href="classSchema__Comm.html#a6c771eae3b46250ae0d2f0126a7d8065" title="renvoie le buffer correspondant au processeur num_PE pour y entasser des donnees a envoyer...">send_buffer</a>(pe_voisin) &lt;&lt; faces_num_global;
        }
    }
  schema_comm.<a class="code" href="classSchema__Comm.html#abca0e8ac6c2b742d26f3cfaee0690c72" title="Statut passe a EXCHANGED.">echange_taille_et_messages</a>();
<span class="comment">// Reception des faces de joint et traduction en indices locaux</span>
  <span class="keywordflow">for</span> (i_joint = 0; i_joint &lt; nb_joints; i_joint++)
    {
      <a class="code" href="classJoint.html" title="La classe Joint est une Frontiere qui contient les faces et les sommets de joint avec la zone PEvoisi...">Joint</a>&amp;       joint     = joints[i_joint];
      <span class="keyword">const</span> <span class="keywordtype">int</span> pe_voisin = joint.<a class="code" href="classJoint.html#a0952bc5c7805434ccd8cd5c9b01e3747" title="Renvoie PEvoisin (numero de la zone voisine)">PEvoisin</a>();
      <span class="keywordflow">if</span> (pe_voisin &lt; moi)
        {
          <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; faces_sommets = joint.<a class="code" href="classFrontiere.html#ac64479069f0c43a17cb5766a39ce5ba8" title="Renvoie les faces de la frontiere&lt;br&gt;(version const)">faces</a>().<a class="code" href="classFaces.html#a07b8d8db9e3d656b93a21a49c063430c">les_sommets</a>();
          schema_comm.<a class="code" href="classSchema__Comm.html#a0c056eb81ab8fd513912b336b4d13a1a" title="renvoie le buffer correspondant au processeur num_PE pour y lire les donnees recues. Le schema doit etre dans l&#39;etat EXCHANGED.">recv_buffer</a>(pe_voisin) &gt;&gt; faces_num_global;
          <span class="keywordflow">if</span> (faces_sommets.<a class="code" href="classIntTab.html#abc3b32c94925a82f69d5b153a356e359" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(0) != faces_num_global.<a class="code" href="classIntTab.html#abc3b32c94925a82f69d5b153a356e359" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(0))
            {
              <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;[PE &quot;</span> &lt;&lt; moi
                   &lt;&lt; <span class="stringliteral">&quot;] Error in Scatter::reordonner_faces_de_joint:\n&quot;</span>
                   &lt;&lt; <span class="stringliteral">&quot; the number of joint faces is not identical to the PE &quot;</span>
                   &lt;&lt; pe_voisin &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
              <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">exit</a>();
            }
          <span class="keyword">const</span> <span class="keywordtype">int</span> nb_erreurs =
            dictionnaire_indices.<a class="code" href="classTraduction__Indice__Global__Local.html#af7d70b1f6312872791271392881768d5" title="Pour debut &lt;= i &lt; debut+nb indices_locaux[i] = chercher l&#39;indice local de &quot;indices_globaux[i]&quot; Parame...">traduire_indice_global_vers_local</a>(faces_num_global,
                                                                   faces_sommets);
          <span class="keywordflow">if</span> (nb_erreurs &gt; 0)
            {
              <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;[PE &quot;</span> &lt;&lt; moi
                   &lt;&lt; <span class="stringliteral">&quot;] Error in Scatter::reordonner_faces_de_joint:\n&quot;</span>
                   &lt;&lt; <span class="stringliteral">&quot; The faces of the joint with PE &quot;</span> &lt;&lt; pe_voisin
                   &lt;&lt; <span class="stringliteral">&quot; use of unknown nodes&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
              <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">exit</a>();
            }
        }
    }
  schema_comm.<a class="code" href="classSchema__Comm.html#a73a981f88b6ffebc150fb46c5cce75d9" title="Statut passe a RESET Accesseurs:">end_comm</a>();
}
</pre></div>
</div>
</div>
<a class="anchor" id="ad9d737e018e92e9424e07ef55642df9b"></a><!-- doxytag: member="Scatter::self_cast" ref="ad9d737e018e92e9424e07ef55642df9b" args="(const Objet_U &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classScatter.html">Scatter</a> &amp; Scatter::self_cast </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classObjet__U.html">Objet_U</a> &amp;&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>methode ajoutee pour caster en python </p>

<p>Reimplemented from <a class="el" href="classInterprete.html#a1a53871854ab9a23ef781206c1ee07e8">Interprete</a>.</p>

<p>Reimplemented in <a class="el" href="classScatterMED.html#ac1900acd5ac28ad18817387eb58a96d9">ScatterMED</a>.</p>

<p>Definition at line <a class="el" href="Scatter_8cpp_source.html#l00051">51</a> of file <a class="el" href="Scatter_8cpp_source.html">Scatter.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="aff07c916d6e09f9338ba4057c9e075bb"></a><!-- doxytag: member="Scatter::self_cast" ref="aff07c916d6e09f9338ba4057c9e075bb" args="(Objet_U &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classScatter.html">Scatter</a> &amp; Scatter::self_cast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classObjet__U.html">Objet_U</a> &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="classInterprete.html#af573ba7e07468ec16bb29d33a6b20c2b">Interprete</a>.</p>

<p>Reimplemented in <a class="el" href="classScatterMED.html#a3c5563097ea27f90ee2e0b50ed12d294">ScatterMED</a>.</p>

<p>Definition at line <a class="el" href="Scatter_8cpp_source.html#l00051">51</a> of file <a class="el" href="Scatter_8cpp_source.html">Scatter.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8e06123f63d327a3f98423c4c66dd570"></a><!-- doxytag: member="Scatter::taille_memoire" ref="a8e06123f63d327a3f98423c4c66dd570" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned Scatter::taille_memoire </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="classInterprete.html#af3e6e9c280f01fcb2144048a195886ee">Interprete</a>.</p>

<p>Reimplemented in <a class="el" href="classScatterMED.html#a0412d3c72dd99bddce8fe8bbfde3e194">ScatterMED</a>.</p>

<p>Definition at line <a class="el" href="Scatter_8cpp_source.html#l00051">51</a> of file <a class="el" href="Scatter_8cpp_source.html">Scatter.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac5dd6d7661490708649976cde509f480"></a><!-- doxytag: member="Scatter::trier_les_joints" ref="ac5dd6d7661490708649976cde509f480" args="(Joints &amp;joints)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Scatter::trier_les_joints </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classJoints.html">Joints</a> &amp;&#160;</td>
          <td class="paramname"><em>joints</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Tri des joints dans l'ordre croissant des processeurs. </p>

<p>Definition at line <a class="el" href="Scatter_8cpp_source.html#l00752">752</a> of file <a class="el" href="Scatter_8cpp_source.html">Scatter.cpp</a>.</p>

<p>References <a class="el" href="ArrOfInt_8cpp_source.html#l00897">ArrOfInt::ordonne_array()</a>, and <a class="el" href="liste_8cpp_source.html#l00175">liste::size()</a>.</p>

<p>Referenced by <a class="el" href="Scatter_8cpp_source.html#l01151">ajouter_joints()</a>, <a class="el" href="MaillerParallel_8cpp_source.html#l00421">auto_build_joints()</a>, <a class="el" href="DomaineCutter_8cpp_source.html#l01115">DomaineCutter::construire_sous_domaine()</a>, <a class="el" href="Raffiner__isotrope__parallele_8cpp_source.html#l00198">Raffiner_isotrope_parallele::interpreter()</a>, and <a class="el" href="Scatter_8cpp_source.html#l00513">lire_domaine()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_joints = joints.<a class="code" href="classliste.html#ab47f280662ff68f9aa2e00e50431c5dc" title="Renvoie la taille de la liste Une liste vide est de taille nulle.">size</a>();
  <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> pe_voisins(nb_joints);
  <span class="keywordtype">int</span> i;
  <span class="keywordflow">for</span> (i = 0; i &lt; nb_joints; i++)
    pe_voisins[i] = joints[i].PEvoisin();
  pe_voisins.ordonne_array();
<span class="comment">// Copie la liste des joints</span>
  <a class="code" href="classJoints.html" title="Classe Joints Cette classe represente une liste d&#39;objet de type Joint.">Joints</a> anciens_joints(joints);
  <span class="keywordflow">for</span> (i = 0; i &lt; nb_joints; i++)
    {
<span class="comment">// On traite le processeur pe_voisin:</span>
      <span class="keyword">const</span> <span class="keywordtype">int</span> pe_voisin = pe_voisins[i];
<span class="comment">// Ou est le joint avec ce processeur dans l&#39;ancienne liste ?</span>
      <span class="keywordtype">int</span> i_old;
      <span class="keywordflow">for</span> (i_old = 0; i_old &lt; nb_joints; i_old++)
        <span class="keywordflow">if</span> (anciens_joints[i_old].PEvoisin() == pe_voisin)
          <span class="keywordflow">break</span>;
      assert(i_old &lt; nb_joints);
      joints[i] = anciens_joints[i_old];
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a8cf934a9b5f7ecb7ef89f61c09804f45"></a><!-- doxytag: member="Scatter::uninit_sequential_domain" ref="a8cf934a9b5f7ecb7ef89f61c09804f45" args="(Domaine &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Scatter::uninit_sequential_domain </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDomaine.html">Domaine</a> &amp;&#160;</td>
          <td class="paramname"><em>dom</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>methode utilisee par les interpretes qui modifient le domaine&lt;br&gt;(sequentiel), detruit les descripteurs des sommets et elements pour permettre<br/>
la modification de ces tableaux. </p>

<p><p>&lt; descripteur nul </p>
</p>

<p>Definition at line <a class="el" href="Scatter_8cpp_source.html#l02925">2925</a> of file <a class="el" href="Scatter_8cpp_source.html">Scatter.cpp</a>.</p>

<p>References <a class="el" href="Zone_8h_source.html#l00402">Zone::les_elems()</a>, <a class="el" href="Domaine_8h_source.html#l00577">Domaine::les_sommets()</a>, <a class="el" href="Domaine_8h_source.html#l00242">Domaine::nb_zones()</a>, <a class="el" href="IntTab_8cpp_source.html#l00553">IntTab::set_md_vector()</a>, <a class="el" href="DoubleTab_8cpp_source.html#l00520">DoubleTab::set_md_vector()</a>, and <a class="el" href="Domaine_8h_source.html#l00272">Domaine::zone()</a>.</p>

<p>Referenced by <a class="el" href="Refine__Mesh_8cpp_source.html#l00110">Refine_Mesh::apply_2D()</a>, <a class="el" href="Rectify__Mesh_8cpp_source.html#l00106">Rectify_Mesh::apply_2D()</a>, <a class="el" href="Refine__Mesh_8cpp_source.html#l00160">Refine_Mesh::apply_3D()</a>, <a class="el" href="Rectify__Mesh_8cpp_source.html#l00119">Rectify_Mesh::apply_3D()</a>, <a class="el" href="Domaine_8cpp_source.html#l00468">Domaine::creer_mes_domaines_frontieres()</a>, <a class="el" href="Decouper__Bord__coincident_8cpp_source.html#l00060">Decouper_Bord_coincident::Decouper_Bord_coincident_()</a>, <a class="el" href="Scatter_8cpp_source.html#l00150">interpreter()</a>, <a class="el" href="Raffiner__isotrope__parallele_8cpp_source.html#l00198">Raffiner_isotrope_parallele::interpreter()</a>, <a class="el" href="VerifierCoin_8cpp_source.html#l00094">VerifierCoin::interpreter_()</a>, <a class="el" href="TroisDto2D_8cpp_source.html#l00089">TroisDto2D::interpreter_()</a>, <a class="el" href="Triangulation__base_8cpp_source.html#l00039">Triangulation_base::interpreter_()</a>, <a class="el" href="Reorienter__triangles_8cpp_source.html#l00038">Reorienter_triangles::interpreter_()</a>, <a class="el" href="Reorienter__tetraedres_8cpp_source.html#l00038">Reorienter_tetraedres::interpreter_()</a>, <a class="el" href="Remove__Invalid__Internal__Boundaries_8cpp_source.html#l00044">Remove_Invalid_Internal_Boundaries::interpreter_()</a>, <a class="el" href="Remove__elem_8cpp_source.html#l00062">Remove_elem::interpreter_()</a>, <a class="el" href="Raffiner__Simplexes_8cpp_source.html#l01071">Raffiner_Simplexes::interpreter_()</a>, <a class="el" href="Raffiner__anisotrope_8cpp_source.html#l00038">Raffiner_anisotrope::interpreter_()</a>, <a class="el" href="Polyedriser_8cpp_source.html#l00252">Polyedriser::interpreter_()</a>, <a class="el" href="Orienter__Simplexes_8cpp_source.html#l00261">Orienter_Simplexes::interpreter_()</a>, <a class="el" href="Mailler_8cpp_source.html#l00107">Mailler::interpreter_()</a>, <a class="el" href="Extruder__en3_8cpp_source.html#l00100">Extruder_en3::interpreter_()</a>, <a class="el" href="Extruder__en20_8cpp_source.html#l00098">Extruder_en20::interpreter_()</a>, <a class="el" href="Extruder_8cpp_source.html#l00097">Extruder::interpreter_()</a>, <a class="el" href="ExtrudeParoi_8cpp_source.html#l00127">ExtrudeParoi::interpreter_()</a>, <a class="el" href="Scatter_8cpp_source.html#l00463">mergeDomains()</a>, <a class="el" href="NettoieNoeuds_8cpp_source.html#l00103">NettoieNoeuds::nettoie()</a>, and <a class="el" href="Transformer_8cpp_source.html#l00150">Transformer::transformation_complete()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <a class="code" href="classMD__Vector.html" title=": Cette classe est un DERIV mais l&#39;objet pointe est partage entre plusieurs instances de cette classe...">MD_Vector</a> md; <span class="comment">//!&lt; descripteur nul</span>
<span class="comment"></span>  dom.<a class="code" href="classDomaine.html#a0846ac03a10b65c4df911fe35a19c02f" title="Renvoie le nombre total de sommets.">les_sommets</a>().<a class="code" href="classDoubleTab.html#a2f40241acb678b0dd0dac7ee4f421b1d" title="associe le md_vector au vecteur (voir DoubleVect::set_md_vector()) dimension(0) sera initialise a md_...">set_md_vector</a>(md);
  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_zones = dom.<a class="code" href="classDomaine.html#a9f3fc389a1310d1fc8b4b27976855376" title="Renvoie le nombre de zone du domaine.">nb_zones</a>();
  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; nb_zones; i++)
    {
      dom.<a class="code" href="classDomaine.html#a0e62f2bc829542fafa29e3f2c614159c" title="Renvoie la i-ieme zone du domaine. (version const)">zone</a>(i).<a class="code" href="classZone.html#ac115e8342be89afb882b7b61cc343267" title="Renvoie le tableau des sommets des elements.">les_elems</a>().<a class="code" href="classIntTab.html#a02470d5d5921700f4daee05a5b3d2601" title="associe le md_vector au vecteur (voir IntVect::set_md_vector()) dimension(0) sera initialise a md_vec...">set_md_vector</a>(md);
    }
}
</pre></div>
</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="a0f6e0e8a9794242ad98d6fb3dbd670dc"></a><!-- doxytag: member="Scatter::info_obj" ref="a0f6e0e8a9794242ad98d6fb3dbd670dc" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classType__info.html">Type_info</a> <a class="el" href="classScatter.html#a0f6e0e8a9794242ad98d6fb3dbd670dc">Scatter::info_obj</a><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="classInterprete.html#af664a53980415f133ed7395da0274179">Interprete</a>.</p>

<p>Reimplemented in <a class="el" href="classScatterMED.html#aed7aaae29e46d8ca2608942bd4ae2930">ScatterMED</a>.</p>

<p>Definition at line <a class="el" href="Scatter_8h_source.html#l00037">37</a> of file <a class="el" href="Scatter_8h_source.html">Scatter.h</a>.</p>

</div>
</div>
<a class="anchor" id="a82a0e561610415e2f6c5615846a96f87"></a><!-- doxytag: member="Scatter::le_domaine" ref="a82a0e561610415e2f6c5615846a96f87" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRef__Domaine.html">Ref_Domaine</a> <a class="el" href="classScatter.html#a82a0e561610415e2f6c5615846a96f87">Scatter::le_domaine</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Scatter_8h_source.html#l00092">92</a> of file <a class="el" href="Scatter_8h_source.html">Scatter.h</a>.</p>

<p>Referenced by <a class="el" href="Scatter_8cpp_source.html#l00096">domaine()</a>, and <a class="el" href="Scatter_8cpp_source.html#l00150">interpreter()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/Kernel/Geometrie/<a class="el" href="Scatter_8h_source.html">Scatter.h</a></li>
<li>src/Kernel/Geometrie/<a class="el" href="Scatter_8cpp_source.html">Scatter.cpp</a></li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Tue Dec 14 2021 19:37:49 for TRUST by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
