<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>TRUST: src/Kernel/Geometrie/Scatter.cpp File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">TRUST&#160;<span id="projectnumber">1.8.4</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">src/Kernel/Geometrie/Scatter.cpp File Reference</div>  </div>
</div>
<div class="contents">
<div class="textblock"><code>#include &lt;<a class="el" href="Scatter_8h_source.html">Scatter.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="Domaine_8h_source.html">Domaine.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="LecFicDistribueBin_8h_source.html">LecFicDistribueBin.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="Statistiques_8h_source.html">Statistiques.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="DoubleTabs_8h_source.html">DoubleTabs.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="Connectivite__som__elem_8h_source.html">Connectivite_som_elem.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="Schema__Comm_8h_source.html">Schema_Comm.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="Faces__builder_8h_source.html">Faces_builder.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="Zone__VF_8h_source.html">Zone_VF.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="Reordonner__faces__periodiques_8h_source.html">Reordonner_faces_periodiques.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="Postraitement__lata_8h_source.html">Postraitement_lata.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="communications_8h_source.html">communications.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="MD__Vector__tools_8h_source.html">MD_Vector_tools.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="MD__Vector__std_8h_source.html">MD_Vector_std.h</a>&gt;</code><br/>
<code>#include &lt;unistd.h&gt;</code><br/>
<code>#include &lt;<a class="el" href="Poly__geom__base_8h_source.html">Poly_geom_base.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="Entree__Brute_8h_source.html">Entree_Brute.h</a>&gt;</code><br/>
<code>#include &lt;hdf5.h&gt;</code><br/>
<code>#include &lt;<a class="el" href="Comm__Group__MPI_8h_source.html">Comm_Group_MPI.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="FichierHDFPar_8h_source.html">FichierHDFPar.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="LecFicDiffuse_8h_source.html">LecFicDiffuse.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="EFichierBin_8h_source.html">EFichierBin.h</a>&gt;</code><br/>
</div>
<p><a href="Scatter_8cpp_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTraduction__Indice__Global__Local.html">Traduction_Indice_Global_Local</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Cette classe fournit les outils pour construire l'espace<br/>
virtuel d'un tableau contenant des indices d'entites geometriques&lt;br&gt;(sommets, elements, faces). Elle gere en particulier la<br/>
renumerotation des elements virtuels.  <a href="classTraduction__Indice__Global__Local.html#details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Scatter_8cpp.html#a600ea51e50b762812904598f72bc12b6">dump_lata</a> (const <a class="el" href="classDomaine.html">Domaine</a> &amp;dom)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Scatter_8cpp.html#a23c4d19dc90caae2323f04de90621709">array_trier_retirer_doublons</a> (<a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;array)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Methode outil pour retirer les doublons dans un tableau.  <a href="#a23c4d19dc90caae2323f04de90621709"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Scatter_8cpp.html#ab0ae6267baccb3a639f4a8ff795edd35">array_retirer_elements</a> (<a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;sorted_array, const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;sorted_elements_list)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Retire de "sorted_array" les elements qui figurent dans "sorted_elements".<br/>
Les deux tableaux doivent etre initialement ordonnes dans l'ordre croissant.<br/>
Exemple:<br/>
En entree sorted_array=[1,4,9,10,12,18], sorted_elements=[3,5,9,10,18,25]<br/>
En sortie sorted_array=[1,4,12].  <a href="#ab0ae6267baccb3a639f4a8ff795edd35"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Scatter_8cpp.html#aad63bf1e3d986487b1fa8bc7e482c368">ajouter_joint</a> (<a class="el" href="classZone.html">Zone</a> &amp;zone, int pe)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classNom.html">Nom</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Scatter_8cpp.html#a554d338bda1a27579f9fb08e6a0168b9">endian</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Scatter_8cpp.html#aaf22a425af9ec9c52eca3d13f3ecea9f">calculer_espace_distant_item</a> (<a class="el" href="classZone.html">Zone</a> &amp;la_zone, const <a class="el" href="classJoint.html#a1e2d15d088c27c9b7b11c02bf4d2c926">Joint::Type_Item</a> type_item, const <a class="el" href="classIntTab.html">IntTab</a> &amp;connectivite_elem_item, const int nb_items_reels, const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;items_lies)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Methode generique pour calculer l'espace distant d'un type d'items geometrique&lt;br&gt;(sommet, face, arete) en fonction de l'espace distant des elements:<br/>
Les "type_item" distants (pour type_item = sommet face ou arete) sont<br/>
les "type_item" attaches aux elements distants.<br/>
Exemple : les sommets distants sont tous les sommets de tous les elements<br/>
distants.<br/>
Voir aussi:<br/>
<a class="el" href="classScatter.html#a9cbfa7bf4fe3b741a56309931f4cf752" title="En fonction de l&#39;espace distant des elements, calcule l&#39;espace distant des sommets. Pour chaque joint, on envoie au processeur voisin l&#39;ensemble des sommets de tous les elements du joint. C&#39;est le processeur proprietaire du sommet&lt;br&gt;(plus petit pe qui le possede) qui le met dans son espace distant. Attention, on cree de nouveaux joints. On remplit les tableaux dom.zone(0).faces_joint(i).joint_item(Joint::SOMMET).items_distants();.">Scatter::calculer_espace_distant_sommets</a><br/>
<a class="el" href="classScatter.html#af8e062885ea7bbeaffb320e7f718e282" title="Idem que Scatter::calculer_espace_distant_sommets pour les faces.">Scatter::calculer_espace_distant_faces</a><br/>
Parametre: zone<br/>
Signification: bah, la zone quoi...<br/>
Parametre: type_item<br/>
Signification: le type des items dont on veut calculer l'espace distant<br/>
Parametre: connectivite_elem_item<br/>
Signification: le tableau qui donne pour chaque element de la zone les<br/>
indices des items de cet element. On n'utilise que la partie reele du<br/>
tableau (logiquement, la partie virtuelle n'existe pas encore).<br/>
(exemple: zone().les_elems() pour type_item==SOMMET ou zone_VF().face_sommets()<br/>
pour type_item==FACE)<br/>
Parametre: nb_items_reels<br/>
Signification: le nombre de "type_item" reels<br/>
Parametre: items_lies<br/>
Signification: si le tableau est non vide, il doit etre de taille nb_items_reels.<br/>
Dans ce cas, il permet de forcer la propriete suivante :<br/>
"si l'item i est distant, alors l'item items_lies[i] est distant aussi".<br/>
Ce tableau est utilise pour inclure les sommets periodiques virtuels associes.<br/>
(voir calculer_espace_distant_sommets).  <a href="#aaf22a425af9ec9c52eca3d13f3ecea9f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="arch_8h.html#a1caaf369d9c5f0817dbaa76b43b8d87b">True_int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Scatter_8cpp.html#a944250a2c83f0a472deb1c18072b9b69">fct_tri_table_inverse</a> (const void *ptr1, const void *ptr2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Scatter_8cpp.html#a4286544562bceff2d921dc707678463f">calculer_liste_complete_sommets_joint</a> (const <a class="el" href="classJoint.html">Joint</a> &amp;joint, <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;liste_sommets)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Methode outil: renvoie une liste complete de tous les<br/>
sommets de joint (sommets des faces + sommets isoles), triee et<br/>
sans doublons.  <a href="#a4286544562bceff2d921dc707678463f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Scatter_8cpp.html#a161e660f58270346277422596ef9c7b3">arete_de_sommets_Si_et_Sj</a> (const int &amp;Si, const int &amp;Sj, const int &amp;arete, const <a class="el" href="classIntTab.html">IntTab</a> &amp;aretes_som)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Scatter_8cpp.html#a984d3b204fb849a38f321769e58a5ef1">calculer_liste_complete_aretes_joint</a> (const <a class="el" href="classJoint.html">Joint</a> &amp;joint, <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;liste_aretes)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Methode outil: renvoie une liste complete de tous les<br/>
aretes de joint (aretes des faces + aretes isolees), triee et<br/>
sans doublons.  <a href="#a984d3b204fb849a38f321769e58a5ef1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Scatter_8cpp.html#a9ce09df49a63406b606ce247e3880d96">calculer_liste_complete_items_joint</a> (const <a class="el" href="classJoint.html">Joint</a> &amp;joint, const <a class="el" href="classJoint.html#a1e2d15d088c27c9b7b11c02bf4d2c926">Joint::Type_Item</a> type_item, <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;liste_items)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="arch_8h.html#a1caaf369d9c5f0817dbaa76b43b8d87b">True_int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Scatter_8cpp.html#a06420c19a824af0906036ca04758d81c">fct_cmp_coordonnees</a> (const double *s1, const double *s2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="arch_8h.html#a1caaf369d9c5f0817dbaa76b43b8d87b">True_int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Scatter_8cpp.html#a727b40392ca2280ef4b3f158a4225b48">fct_cmp_index_coord</a> (const void *ptr1, const void *ptr2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Scatter_8cpp.html#a4c215e3cfff2963def44e300a58b513b">init_simple_md_vector</a> (<a class="el" href="classMD__Vector__std.html">MD_Vector_std</a> &amp;md, const int n)</td></tr>
<tr><td colspan="2"><h2><a name="var-members"></a>
Variables</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classStat__Counter__Id.html">Stat_Counter_Id</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Scatter_8cpp.html#a5aa23d1c4a41bce37e5e06efb5e8c9e1">interprete_scatter_counter_</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">&lt; PGI  <a href="#a5aa23d1c4a41bce37e5e06efb5e8c9e1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classType__info.html">Type_info</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Scatter_8cpp.html#a6b0bce9d4399a0b851de1bf50e6e0761">Scatterbases</a> [1] = { &amp;( <a class="el" href="classInterprete.html">Interprete</a> ::info_obj)}</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Scatter_8cpp.html#a09e112f8a32312a1675f7e33b94df122">fct_cmp_coord_dimension</a> = -1</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Scatter_8cpp.html#a81c1304205b09abc2acc284f8adc390c">fct_cmp_coord_epsilon</a> = -1.</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classDoubleTab.html">DoubleTab</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Scatter_8cpp.html#a107a2fbce3e368271c492cfcf7cfca10">fct_cmp_coord_tableau</a> = 0</td></tr>
</table>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="aad63bf1e3d986487b1fa8bc7e482c368"></a><!-- doxytag: member="Scatter.cpp::ajouter_joint" ref="aad63bf1e3d986487b1fa8bc7e482c368" args="(Zone &amp;zone, int pe)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int ajouter_joint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classZone.html">Zone</a> &amp;&#160;</td>
          <td class="paramname"><em>zone</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pe</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Scatter_8cpp_source.html#l00848">848</a> of file <a class="el" href="Scatter_8cpp_source.html">Scatter.cpp</a>.</p>

<p>References <a class="el" href="Joints_8h_source.html#l00028">List_Joint::add()</a>, <a class="el" href="Joint_8cpp_source.html#l00092">Joint::affecte_epaisseur()</a>, <a class="el" href="Joint_8cpp_source.html#l00085">Joint::affecte_PEvoisin()</a>, <a class="el" href="Joint_8h_source.html#l00066">Joint::ARETE</a>, <a class="el" href="Frontiere_8cpp_source.html#l00093">Frontiere::associer_zone()</a>, <a class="el" href="EntreeSortie_8h_source.html#l00032">Cerr</a>, <a class="el" href="Joint_8h_source.html#l00066">Joint::ELEMENT</a>, <a class="el" href="Process_8cpp_source.html#l00223">Process::exit()</a>, <a class="el" href="Joint_8h_source.html#l00066">Joint::FACE</a>, <a class="el" href="Joint_8h_source.html#l00066">Joint::FACE_FRONT</a>, <a class="el" href="Zone_8h_source.html#l01098">Zone::faces_joint()</a>, <a class="el" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>, <a class="el" href="Frontiere_8cpp_source.html#l00113">Frontiere::nommer()</a>, <a class="el" href="IntTab_8cpp_source.html#l00353">IntTab::resize()</a>, <a class="el" href="Joint__Items_8cpp_source.html#l00056">Joint_Items::set_items_communs()</a>, <a class="el" href="Joint__Items_8cpp_source.html#l00073">Joint_Items::set_items_distants()</a>, <a class="el" href="Joint_8cpp_source.html#l00159">Joint::set_joint_item()</a>, <a class="el" href="Joint__Items_8cpp_source.html#l00081">Joint_Items::set_nb_items_virtuels()</a>, <a class="el" href="Joint__Items_8cpp_source.html#l00097">Joint_Items::set_renum_items_communs()</a>, <a class="el" href="liste_8cpp_source.html#l00175">liste::size()</a>, and <a class="el" href="Joint_8h_source.html#l00066">Joint::SOMMET</a>.</p>

<p>Referenced by <a class="el" href="Scatter_8cpp_source.html#l01151">Scatter::ajouter_joints()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <a class="code" href="classJoints.html" title="Classe Joints Cette classe represente une liste d&#39;objet de type Joint.">Joints</a>&amp; joints = zone.<a class="code" href="classZone.html#a16f273a76321d31435995cdad664285a" title="Renvoie la liste des joints de la zone. (version const)">faces_joint</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> i_joint = joints.<a class="code" href="classliste.html#ab47f280662ff68f9aa2e00e50431c5dc" title="Renvoie la taille de la liste Une liste vide est de taille nulle.">size</a>();

  {
    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; i_joint; i++)
      <span class="keywordflow">if</span> (joints[i].PEvoisin() == pe)
        <span class="keywordflow">return</span> i;
  }

  <a class="code" href="classJoint.html" title="La classe Joint est une Frontiere qui contient les faces et les sommets de joint avec la zone PEvoisi...">Joint</a>&amp; joint = joints.<a class="code" href="classList__Joint.html#af5bca88a907fbe4086842805696cfe2f">add</a>(<a class="code" href="classJoint.html" title="La classe Joint est une Frontiere qui contient les faces et les sommets de joint avec la zone PEvoisi...">Joint</a>());
  joint.<a class="code" href="classFrontiere.html#a714e3cc26d7e59f3a65d80de23ea21ac" title="Donne un nom a la frontiere.">nommer</a>(<a class="code" href="classNom.html" title="class Nom Une chaine de caractere pour nommer les objets de TRUST">Nom</a>(<span class="stringliteral">&quot;Joint_&quot;</span>)+<a class="code" href="classNom.html" title="class Nom Une chaine de caractere pour nommer les objets de TRUST">Nom</a>(pe));
  joint.<a class="code" href="classFrontiere.html#af927b5d4fc1fd086ba91e916f61badee" title="Associe la frontiere a la zone dont elle depend.">associer_zone</a>(zone);
  <span class="keywordtype">int</span> ep = (i_joint &gt; 0) ? joints[0].epaisseur() : 1;
  joint.<a class="code" href="classJoint.html#a130c206de5fddabf173bb3e4604cefa3" title="Fixe l&#39;epaisseur du joint.">affecte_epaisseur</a>(ep);
  joint.<a class="code" href="classJoint.html#a3c4ef6a648dd0b5d4aa072a1f4e3c64e" title="Fixe le numero du PE voisin.">affecte_PEvoisin</a>(pe);

<span class="comment">// Initialiser tous les tableaux des joints supplementaires.</span>
<span class="comment">// Note BM: pour bien faire, il faudrait initialiser uniquement</span>
<span class="comment">// certains tableaux (ceux qui sont deja initialises pour les</span>
<span class="comment">// joints existants), mais c&#39;est plus complique a faire...</span>
  {
    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> t = 0; t &lt; 5; t++)
      {
        <a class="code" href="classJoint.html#a1e2d15d088c27c9b7b11c02bf4d2c926">Joint::Type_Item</a> type;
        <span class="keywordflow">switch</span>(t)
          {
          <span class="keywordflow">case</span> 0:
            type = <a class="code" href="classJoint.html#a1e2d15d088c27c9b7b11c02bf4d2c926a050aa4faf237e25faef6fff15ffc20f8">Joint::SOMMET</a>;
            <span class="keywordflow">break</span>;
          <span class="keywordflow">case</span> 1:
            type = <a class="code" href="classJoint.html#a1e2d15d088c27c9b7b11c02bf4d2c926ae32de3a01fdb3ad6c506b8058a7f6173">Joint::ELEMENT</a>;
            <span class="keywordflow">break</span>;
          <span class="keywordflow">case</span> 2:
            type = <a class="code" href="classJoint.html#a1e2d15d088c27c9b7b11c02bf4d2c926ab255b88987fc7f64c215c958cbe2af6b">Joint::FACE</a>;
            <span class="keywordflow">break</span>;
          <span class="keywordflow">case</span> 3:
            type = <a class="code" href="classJoint.html#a1e2d15d088c27c9b7b11c02bf4d2c926a7816c69408b98e1161f1f54e7b6b1cb4">Joint::ARETE</a>;
            <span class="keywordflow">break</span>;
          <span class="keywordflow">case</span> 4:
            type = <a class="code" href="classJoint.html#a1e2d15d088c27c9b7b11c02bf4d2c926af1ca60fd524298b1cb3e07b26a2d63c8">Joint::FACE_FRONT</a>;
            <span class="keywordflow">break</span>;
          <span class="keywordflow">default</span>:
            <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Error in Scatter.cpp : ajouter_joint&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
<span class="comment">// Pour eviter le warning suivant sur gcc 3.4:</span>
<span class="comment">// Scatter.cpp:416: warning: &#39;type&#39; might be used uninitialized in this function</span>
            type = <a class="code" href="classJoint.html#a1e2d15d088c27c9b7b11c02bf4d2c926a050aa4faf237e25faef6fff15ffc20f8">Joint::SOMMET</a>;
            <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">Process::exit</a>();
          }
        <a class="code" href="classJoint__Items.html" title="Joint_Items contient les informations de distribution parallele d&#39;un item geometrique particulier ave...">Joint_Items</a>&amp; data = joint.<a class="code" href="classJoint.html#aa1c4d729a3017082d26907d82ad1d7de" title="Renvoie les informations de joint pour un type d&#39;item geometrique donne, pour remplissage des structu...">set_joint_item</a>(type);
        data.<a class="code" href="classJoint__Items.html#aa01c4601d506c658f4f1d45e66951ce0" title="Renvoie le tableau items_communs_ pour le remplir. (BM: ce tableau n&#39;est pas encore rempli)...">set_items_communs</a>();
        data.<a class="code" href="classJoint__Items.html#a13add264f4ad36ef4bddbfc1b7bdb817" title="Renvoie le tableau items_distants_ pour le remplir Voir Scatter::calculer_espace_distant, Scatter::calculer_espace_distant_faces_frontieres, Scatter::calculer_espace_distant_elements.">set_items_distants</a>();
        data.<a class="code" href="classJoint__Items.html#a956b3926baa83e9d5ab9848adf7f822a" title="Voir nb_items_virtuels_ Voir Scatter::calculer_nb_items_virtuels.">set_nb_items_virtuels</a>(0);
        data.<a class="code" href="classJoint__Items.html#a95cc27c0fd65e2444a468df69a211057" title="Voir renum_items_communs_ Voir Scatter::calculer_colonne0_renum_faces_communes Scatter::construire_co...">set_renum_items_communs</a>().<a class="code" href="classIntTab.html#a22e6bed6826b3688d4d0181cbf3b7a38" title="Change la taille du vecteur (identique a resize_array() pour le traitement des anciennes valeurs et d...">resize</a>(0,2);
      }
  }

  <span class="keywordflow">return</span> i_joint;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a161e660f58270346277422596ef9c7b3"></a><!-- doxytag: member="Scatter.cpp::arete_de_sommets_Si_et_Sj" ref="a161e660f58270346277422596ef9c7b3" args="(const int &amp;Si, const int &amp;Sj, const int &amp;arete, const IntTab &amp;aretes_som)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int arete_de_sommets_Si_et_Sj </td>
          <td>(</td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>Si</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>Sj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>arete</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIntTab.html">IntTab</a> &amp;&#160;</td>
          <td class="paramname"><em>aretes_som</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Scatter_8cpp_source.html#l01917">1917</a> of file <a class="el" href="Scatter_8cpp_source.html">Scatter.cpp</a>.</p>

<p>Referenced by <a class="el" href="Scatter_8cpp_source.html#l01929">calculer_liste_complete_aretes_joint()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">if</span> ( (aretes_som(arete,0) == Si &amp;&amp; aretes_som(arete,1) == Sj)
       || (aretes_som(arete,1) == Si &amp;&amp; aretes_som(arete,0) == Sj) )
    <span class="keywordflow">return</span> 1;
  <span class="keywordflow">else</span>
    <span class="keywordflow">return</span> 0;
}
</pre></div>
</div>
</div>
<a class="anchor" id="ab0ae6267baccb3a639f4a8ff795edd35"></a><!-- doxytag: member="Scatter.cpp::array_retirer_elements" ref="ab0ae6267baccb3a639f4a8ff795edd35" args="(ArrOfInt &amp;sorted_array, const ArrOfInt &amp;sorted_elements_list)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void array_retirer_elements </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>sorted_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>sorted_elements_list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retire de "sorted_array" les elements qui figurent dans "sorted_elements".<br/>
Les deux tableaux doivent etre initialement ordonnes dans l'ordre croissant.<br/>
Exemple:<br/>
En entree sorted_array=[1,4,9,10,12,18], sorted_elements=[3,5,9,10,18,25]<br/>
En sortie sorted_array=[1,4,12]. </p>

<p><p>&lt; Index dans sorted_array (en lecture)</p>
<p>&lt; Index dans sorted_array (la ou on ecrit)</p>
<p>&lt; Index dans sorted_elements</p>
<p>&lt; Tableau trie ? </p>
</p>

<p>Definition at line <a class="el" href="Scatter_8cpp_source.html#l00806">806</a> of file <a class="el" href="Scatter_8cpp_source.html">Scatter.cpp</a>.</p>

<p>References <a class="el" href="ArrOfInt_8h_source.html#l00240">ArrOfInt::resize_array()</a>, and <a class="el" href="ArrOfInt_8h_source.html#l00342">ArrOfInt::size_array()</a>.</p>

<p>Referenced by <a class="el" href="Scatter_8cpp_source.html#l01151">Scatter::ajouter_joints()</a>, <a class="el" href="Scatter_8cpp_source.html#l00937">Scatter::calculer_espace_distant()</a>, and <a class="el" href="Scatter_8cpp_source.html#l01929">calculer_liste_complete_aretes_joint()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">int</span> i_read;      <span class="comment">//!&lt; Index dans sorted_array (en lecture)</span>
<span class="comment"></span>  <span class="keywordtype">int</span> i_write = 0; <span class="comment">//!&lt; Index dans sorted_array (la ou on ecrit)</span>
<span class="comment"></span>  <span class="keywordtype">int</span> j = 0;       <span class="comment">//!&lt; Index dans sorted_elements</span>
<span class="comment"></span>  <span class="keyword">const</span> <span class="keywordtype">int</span> n = sorted_array.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> m = sorted_elements_list.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>();
  <span class="keywordflow">if</span> (m == 0)
    <span class="keywordflow">return</span>;

  <span class="keywordtype">int</span> j_value = sorted_elements_list[j];
  <span class="keywordflow">for</span> (i_read = 0; i_read &lt; n; i_read++)
    {
<span class="comment">// Tableau trie ?</span>
      assert(i_read == 0 || sorted_array[i_read] &gt; sorted_array[i_read-1]);
      <span class="keyword">const</span> <span class="keywordtype">int</span> i_value = sorted_array[i_read];

<span class="comment">// On avance dans la liste sorted_elements jusqu&#39;a trouver ou depasser</span>
<span class="comment">// l&#39;element i_value</span>
      <span class="keywordflow">while</span> ((j_value &lt; i_value) &amp;&amp; (j &lt; m))
        {
          j++;
          <span class="keywordflow">if</span> (j == m)
            <span class="keywordflow">break</span>;
          assert(sorted_elements_list[j] &gt; j_value); <span class="comment">//!&lt; Tableau trie ?</span>
<span class="comment"></span>          j_value = sorted_elements_list[j];
        }

      <span class="keywordflow">if</span> (j == m || j_value != i_value)
        {
<span class="comment">// i_value ne figure pas dans le tableau sorted_elements, on le garde</span>
          sorted_array[i_write] = i_value;
          i_write++;
        }
    }
  sorted_array.<a class="code" href="classArrOfInt.html#a9b3afbb46b16870dbd36236c8935b535">resize_array</a>(i_write);
}
</pre></div>
</div>
</div>
<a class="anchor" id="a23c4d19dc90caae2323f04de90621709"></a><!-- doxytag: member="Scatter.cpp::array_trier_retirer_doublons" ref="a23c4d19dc90caae2323f04de90621709" args="(ArrOfInt &amp;array)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void array_trier_retirer_doublons </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>array</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Methode outil pour retirer les doublons dans un tableau. </p>

<p>Definition at line <a class="el" href="Scatter_8cpp_source.html#l00778">778</a> of file <a class="el" href="Scatter_8cpp_source.html">Scatter.cpp</a>.</p>

<p>References <a class="el" href="ArrOfInt_8cpp_source.html#l00897">ArrOfInt::ordonne_array()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00240">ArrOfInt::resize_array()</a>, and <a class="el" href="ArrOfInt_8h_source.html#l00342">ArrOfInt::size_array()</a>.</p>

<p>Referenced by <a class="el" href="Scatter_8cpp_source.html#l01151">Scatter::ajouter_joints()</a>, <a class="el" href="MD__Vector__composite_8cpp_source.html#l00136">append_global_md()</a>, <a class="el" href="MaillerParallel_8cpp_source.html#l00421">auto_build_joints()</a>, <a class="el" href="Scatter_8cpp_source.html#l00937">Scatter::calculer_espace_distant()</a>, <a class="el" href="Scatter_8cpp_source.html#l02184">Scatter::calculer_espace_distant_elements()</a>, <a class="el" href="Scatter_8cpp_source.html#l01219">calculer_espace_distant_item()</a>, <a class="el" href="Scatter_8cpp_source.html#l01929">calculer_liste_complete_aretes_joint()</a>, <a class="el" href="Scatter_8cpp_source.html#l01899">calculer_liste_complete_sommets_joint()</a>, <a class="el" href="DomaineCutter_8cpp_source.html#l00517">DomaineCutter::construire_elements_distants_ssdom()</a>, <a class="el" href="DomaineCutter_8cpp_source.html#l00643">DomaineCutter::construire_sommets_joints_ssdom()</a>, <a class="el" href="Partitionneur__base_8cpp_source.html#l00260">Partitionneur_base::corriger_sommets_bord()</a>, <a class="el" href="Faces__builder_8cpp_source.html#l00940">Zone::creer_aretes()</a>, and <a class="el" href="Raffiner__Simplexes_8cpp_source.html#l00788">Raffiner_Simplexes::refine_domain()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">const</span> <span class="keywordtype">int</span> size_ = array.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>();
  <span class="keywordflow">if</span> (size_ == 0)
    <span class="keywordflow">return</span>;
<span class="comment">// Tri dans l&#39;ordre croissant</span>
  array.<a class="code" href="classArrOfInt.html#abb0f48cf5a4be4b70edcc90baaebd521" title="Tri des valeurs du tableau dans l&#39;ordre croissant. La fonction utilisee est qsort de stdlib (elle est...">ordonne_array</a>();
<span class="comment">// Retire les doublons</span>
  <span class="keywordtype">int</span> new_size_ = 1;
  <span class="keywordtype">int</span> last_value = array[0];
  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 1; i &lt; size_; i++)
    {
      <span class="keywordflow">if</span> (array[i] != last_value)
        {
          array[new_size_] = last_value = array[i];
          new_size_++;
        }
    }
  array.<a class="code" href="classArrOfInt.html#a9b3afbb46b16870dbd36236c8935b535">resize_array</a>(new_size_);
}
</pre></div>
</div>
</div>
<a class="anchor" id="aaf22a425af9ec9c52eca3d13f3ecea9f"></a><!-- doxytag: member="Scatter.cpp::calculer_espace_distant_item" ref="aaf22a425af9ec9c52eca3d13f3ecea9f" args="(Zone &amp;la_zone, const Joint::Type_Item type_item, const IntTab &amp;connectivite_elem_item, const int nb_items_reels, const ArrOfInt &amp;items_lies)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void calculer_espace_distant_item </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classZone.html">Zone</a> &amp;&#160;</td>
          <td class="paramname"><em>la_zone</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classJoint.html#a1e2d15d088c27c9b7b11c02bf4d2c926">Joint::Type_Item</a>&#160;</td>
          <td class="paramname"><em>type_item</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIntTab.html">IntTab</a> &amp;&#160;</td>
          <td class="paramname"><em>connectivite_elem_item</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>nb_items_reels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>items_lies</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Methode generique pour calculer l'espace distant d'un type d'items geometrique&lt;br&gt;(sommet, face, arete) en fonction de l'espace distant des elements:<br/>
Les "type_item" distants (pour type_item = sommet face ou arete) sont<br/>
les "type_item" attaches aux elements distants.<br/>
Exemple : les sommets distants sont tous les sommets de tous les elements<br/>
distants.<br/>
Voir aussi:<br/>
<a class="el" href="classScatter.html#a9cbfa7bf4fe3b741a56309931f4cf752" title="En fonction de l&#39;espace distant des elements, calcule l&#39;espace distant des sommets. Pour chaque joint, on envoie au processeur voisin l&#39;ensemble des sommets de tous les elements du joint. C&#39;est le processeur proprietaire du sommet&lt;br&gt;(plus petit pe qui le possede) qui le met dans son espace distant. Attention, on cree de nouveaux joints. On remplit les tableaux dom.zone(0).faces_joint(i).joint_item(Joint::SOMMET).items_distants();.">Scatter::calculer_espace_distant_sommets</a><br/>
<a class="el" href="classScatter.html#af8e062885ea7bbeaffb320e7f718e282" title="Idem que Scatter::calculer_espace_distant_sommets pour les faces.">Scatter::calculer_espace_distant_faces</a><br/>
Parametre: zone<br/>
Signification: bah, la zone quoi...<br/>
Parametre: type_item<br/>
Signification: le type des items dont on veut calculer l'espace distant<br/>
Parametre: connectivite_elem_item<br/>
Signification: le tableau qui donne pour chaque element de la zone les<br/>
indices des items de cet element. On n'utilise que la partie reele du<br/>
tableau (logiquement, la partie virtuelle n'existe pas encore).<br/>
(exemple: zone().les_elems() pour type_item==SOMMET ou zone_VF().face_sommets()<br/>
pour type_item==FACE)<br/>
Parametre: nb_items_reels<br/>
Signification: le nombre de "type_item" reels<br/>
Parametre: items_lies<br/>
Signification: si le tableau est non vide, il doit etre de taille nb_items_reels.<br/>
Dans ce cas, il permet de forcer la propriete suivante :<br/>
"si l'item i est distant, alors l'item items_lies[i] est distant aussi".<br/>
Ce tableau est utilise pour inclure les sommets periodiques virtuels associes.<br/>
(voir calculer_espace_distant_sommets). </p>

<p><p>&lt; chaine de liaisons interdite </p>
</p>

<p>Definition at line <a class="el" href="Scatter_8cpp_source.html#l01219">1219</a> of file <a class="el" href="Scatter_8cpp_source.html">Scatter.cpp</a>.</p>

<p>References <a class="el" href="ArrOfInt_8h_source.html#l00355">ArrOfInt::append_array()</a>, <a class="el" href="Scatter_8cpp_source.html#l00778">array_trier_retirer_doublons()</a>, <a class="el" href="Scatter_8cpp_source.html#l00937">Scatter::calculer_espace_distant()</a>, <a class="el" href="IntTab_8h_source.html#l00233">IntTab::dimension()</a>, <a class="el" href="Joint_8h_source.html#l00066">Joint::ELEMENT</a>, <a class="el" href="Zone_8h_source.html#l01098">Zone::faces_joint()</a>, <a class="el" href="Joint__Items_8cpp_source.html#l00063">Joint_Items::items_distants()</a>, <a class="el" href="Joint_8cpp_source.html#l00186">Joint::joint_item()</a>, <a class="el" href="Process_8cpp_source.html#l00109">Process::nproc()</a>, <a class="el" href="Joint_8cpp_source.html#l00099">Joint::PEvoisin()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00240">ArrOfInt::resize_array()</a>, <a class="el" href="ArrOfInt_8cpp_source.html#l00443">ArrOfInt::set_smart_resize()</a>, <a class="el" href="liste_8cpp_source.html#l00175">liste::size()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00342">ArrOfInt::size_array()</a>, and <a class="el" href="Vect_8h_source.html#l00026">VECT</a>.</p>

<p>Referenced by <a class="el" href="Scatter_8cpp_source.html#l01332">Scatter::calculer_espace_distant_aretes()</a>, <a class="el" href="Scatter_8cpp_source.html#l01314">Scatter::calculer_espace_distant_faces()</a>, and <a class="el" href="Scatter_8cpp_source.html#l01289">Scatter::calculer_espace_distant_sommets()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">const</span> <a class="code" href="classJoints.html" title="Classe Joints Cette classe represente une liste d&#39;objet de type Joint.">Joints</a>&amp; joints                 = la_zone.<a class="code" href="classZone.html#a16f273a76321d31435995cdad664285a" title="Renvoie la liste des joints de la zone. (version const)">faces_joint</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span>   nb_joints              = joints.<a class="code" href="classliste.html#ab47f280662ff68f9aa2e00e50431c5dc" title="Renvoie la taille de la liste Une liste vide est de taille nulle.">size</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span>   nproc                  = <a class="code" href="classProcess.html#a6bf692ce58d9578aa62ac3c07b8caaa1" title="renvoie le nombre de processeurs dans le groupe courant Voir Comm_Group::nproc() et PE_Groups::curren...">Process::nproc</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span>   nb_items_par_element   = connectivite_elem_item.<a class="code" href="classIntTab.html#abc3b32c94925a82f69d5b153a356e359" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(1);
<span class="comment">// Les type_item a envoyer a chaque processeur:</span>
  <a class="code" href="Vect_8h.html#adc7c7b04809c9aec2cb897cd2ef06378">VECT</a>(<a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>) items_to_send(nproc);
<span class="comment">// Un tableau temporaire;</span>
  <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> liste_items;
  liste_items.set_smart_resize(1);

<span class="comment">// Est-ce qu&#39;il y a des items lies ?</span>
  const <span class="keywordtype">int</span> flag_items_lies = (items_lies.size_array() &gt; 0);
  assert(flag_items_lies == 0 || items_lies.size_array() == nb_items_reels);


  for (<span class="keywordtype">int</span> i_joint = 0; i_joint &lt; nb_joints; i_joint++)
    {
      <span class="keyword">const</span> <a class="code" href="classJoint.html" title="La classe Joint est une Frontiere qui contient les faces et les sommets de joint avec la zone PEvoisi...">Joint</a>&amp;     joint          = joints[i_joint];
      <span class="keyword">const</span> <span class="keywordtype">int</span>     pe_voisin      = joint.<a class="code" href="classJoint.html#a0952bc5c7805434ccd8cd5c9b01e3747" title="Renvoie PEvoisin (numero de la zone voisine)">PEvoisin</a>();
      <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; esp_dist_elems = joint.<a class="code" href="classJoint.html#a3f49fb1150967b436a115a7373ab27a0" title="Renvoie les informations de joint pour le type demande.">joint_item</a>(<a class="code" href="classJoint.html#a1e2d15d088c27c9b7b11c02bf4d2c926ae32de3a01fdb3ad6c506b8058a7f6173">Joint::ELEMENT</a>).<a class="code" href="classJoint__Items.html#ae51b330de79fcaae9c88166e3eee7cb8" title="Voir items_distants_.">items_distants</a>();
      <span class="keyword">const</span> <span class="keywordtype">int</span>     nb_elems_dist  = esp_dist_elems.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>();
      liste_items.<a class="code" href="classArrOfInt.html#a9b3afbb46b16870dbd36236c8935b535">resize_array</a>(0);
<span class="comment">// On met dans liste_items tous les items de tous les elements</span>
<span class="comment">// qui sont dans esp_dist_elems:</span>
      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i_elem = 0; i_elem &lt; nb_elems_dist; i_elem++)
        {
          <span class="keyword">const</span> <span class="keywordtype">int</span> elem = esp_dist_elems[i_elem];
          <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i_item = 0; i_item &lt; nb_items_par_element; i_item++)
            {
              <span class="keyword">const</span> <span class="keywordtype">int</span> item = connectivite_elem_item(elem, i_item);
              <span class="keywordflow">if</span> (item&gt;-1)
                {
                  liste_items.<a class="code" href="classArrOfInt.html#a3f39d0966599416e7b1f7cd8159d8d01" title="Ajoute une case en fin de tableau et y stocke la &quot;valeur&quot;.">append_array</a>(item);
<span class="comment">// Si un item est lie a l&#39;item courant, on envoie aussi l&#39;item lie.</span>
                  <span class="keywordflow">if</span> (flag_items_lies)
                    {
                      <span class="keyword">const</span> <span class="keywordtype">int</span> item_lie = items_lies[item];
                      <span class="keywordflow">if</span> (item_lie != item)
                        {
                          assert(item_lie &gt;= 0 &amp;&amp; item_lie &lt; nb_items_reels);
                          assert(items_lies[item_lie] == item_lie); <span class="comment">//!&lt; chaine de liaisons interdite</span>
<span class="comment"></span>                          liste_items.<a class="code" href="classArrOfInt.html#a3f39d0966599416e7b1f7cd8159d8d01" title="Ajoute une case en fin de tableau et y stocke la &quot;valeur&quot;.">append_array</a>(item_lie);
                        }
                    }
                }
            }
        }
      <a class="code" href="Scatter_8cpp.html#a23c4d19dc90caae2323f04de90621709" title="Methode outil pour retirer les doublons dans un tableau.">array_trier_retirer_doublons</a>(liste_items);
<span class="comment">// Ces items doivent etre envoyes au processeur voisin:</span>
      items_to_send[pe_voisin] = liste_items;
    }
<span class="comment">// Calcul des espaces distants en fonction de &quot;items_to_send&quot;</span>
  <a class="code" href="classScatter.html#aa160f8c25dcf4bf1aa2cd9ead7cf51e3" title="Determination des items distants en fonction d&#39;une liste d&#39;items a envoyer et de listes d&#39;items commu...">Scatter::calculer_espace_distant</a>(la_zone, nb_items_reels, items_to_send, type_item);
}
</pre></div>
</div>
</div>
<a class="anchor" id="a984d3b204fb849a38f321769e58a5ef1"></a><!-- doxytag: member="Scatter.cpp::calculer_liste_complete_aretes_joint" ref="a984d3b204fb849a38f321769e58a5ef1" args="(const Joint &amp;joint, ArrOfInt &amp;liste_aretes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void calculer_liste_complete_aretes_joint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classJoint.html">Joint</a> &amp;&#160;</td>
          <td class="paramname"><em>joint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>liste_aretes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Methode outil: renvoie une liste complete de tous les<br/>
aretes de joint (aretes des faces + aretes isolees), triee et<br/>
sans doublons. </p>

<p>Definition at line <a class="el" href="Scatter_8cpp_source.html#l01929">1929</a> of file <a class="el" href="Scatter_8cpp_source.html">Scatter.cpp</a>.</p>

<p>References <a class="el" href="ArrOfInt_8h_source.html#l00355">ArrOfInt::append_array()</a>, <a class="el" href="Scatter_8cpp_source.html#l01917">arete_de_sommets_Si_et_Sj()</a>, <a class="el" href="Zone_8h_source.html#l01290">Zone::aretes_som()</a>, <a class="el" href="Scatter_8cpp_source.html#l00806">array_retirer_elements()</a>, <a class="el" href="Scatter_8cpp_source.html#l00778">array_trier_retirer_doublons()</a>, <a class="el" href="Scatter_8cpp_source.html#l01899">calculer_liste_complete_sommets_joint()</a>, <a class="el" href="Zone_8cpp_source.html#l01262">Zone::chercher_aretes()</a>, <a class="el" href="Memoire_8cpp_source.html#l00026">compteur</a>, <a class="el" href="Domaine_8h_source.html#l00500">Domaine::coord_sommets()</a>, <a class="el" href="IntTab_8h_source.html#l00233">IntTab::dimension()</a>, <a class="el" href="Objet__U_8h_source.html#l00079">Objet_U::dimension</a>, <a class="el" href="Zone_8cpp_source.html#l00262">Zone::domaine()</a>, <a class="el" href="Frontiere_8h_source.html#l00175">Frontiere::faces()</a>, <a class="el" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>, <a class="el" href="Process_8cpp_source.html#l00345">Process::Journal()</a>, <a class="el" href="Faces_8h_source.html#l00268">Faces::les_sommets()</a>, <a class="el" href="Faces_8h_source.html#l00152">Faces::nb_faces()</a>, <a class="el" href="Faces_8h_source.html#l00242">Faces::nb_som_faces()</a>, <a class="el" href="Joint_8cpp_source.html#l00099">Joint::PEvoisin()</a>, <a class="el" href="ArrOfInt_8cpp_source.html#l00443">ArrOfInt::set_smart_resize()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00342">ArrOfInt::size_array()</a>, <a class="el" href="Domaine_8h_source.html#l00272">Domaine::zone()</a>, and <a class="el" href="Frontiere_8cpp_source.html#l00260">Frontiere::zone()</a>.</p>

<p>Referenced by <a class="el" href="Scatter_8cpp_source.html#l02010">calculer_liste_complete_items_joint()</a>.</p>
<div class="fragment"><pre class="fragment">{
<span class="comment">// Construction de la liste des aretes communes liste_aretes</span>
  liste_aretes.<a class="code" href="classArrOfInt.html#a22d744bcd452d039580d1d9186f02b4e" title="Change le mode l&#39;allocation memoire: reallocation d&#39;un tableau a chaque changement de taille (flag = ...">set_smart_resize</a>(1);
<span class="comment">//</span>
<span class="comment">// Recherche des aretes de joint sur les faces de joint</span>
<span class="comment">//</span>
  <span class="keywordtype">int</span> nb_faces_joint=joint.<a class="code" href="classFrontiere.html#ac64479069f0c43a17cb5766a39ce5ba8" title="Renvoie les faces de la frontiere&lt;br&gt;(version const)">faces</a>().<a class="code" href="classFaces.html#a64d898edb20c3687d357018f1821c50a" title="Renvoie le nombre de Faces.">nb_faces</a>();
  <span class="keywordtype">int</span> nb_som_faces=joint.<a class="code" href="classFrontiere.html#ac64479069f0c43a17cb5766a39ce5ba8" title="Renvoie les faces de la frontiere&lt;br&gt;(version const)">faces</a>().<a class="code" href="classFaces.html#a1361d27e4c8b239c48de671fad23428c" title="Renvoie le nombre de sommet par face.">nb_som_faces</a>();
  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; sommet=joint.<a class="code" href="classFrontiere.html#ac64479069f0c43a17cb5766a39ce5ba8" title="Renvoie les faces de la frontiere&lt;br&gt;(version const)">faces</a>().<a class="code" href="classFaces.html#a07b8d8db9e3d656b93a21a49c063430c">les_sommets</a>();
  <span class="keyword">const</span> <a class="code" href="classDomaine.html" title="Classe Domaine Un Domaine represente le domaine (spatial) de resolution d&#39;un Probleme. Un Domaine a un Nom, il est constitue d&#39;une ou plusieurs Zone qui peuvent etre eventuellement decoupees en Sous_Zone. Un Domaine porte l&#39;ensemble des sommets utilises par ses Zones. On peut vouloir resoudre des problemes de type different sur plusieurs domaines, geometriquement les domaines sont alors couples par des surfaces qu&#39;on appelle Raccord.">Domaine</a>&amp; dom=joint.<a class="code" href="classFrontiere.html#a510866aace5f3ed9482553db1a08a3c9" title="Renvoie la Zone associee a la frontiere. (version const)">zone</a>().<a class="code" href="classZone.html#a379ad2206b5a13a4f4f3df6d44c7546a" title="Renvoie le domaine dont la zone fait partie. (version const)">domaine</a>();
  <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; coord=dom.<a class="code" href="classDomaine.html#aecd32c3eecc15cce7d1a0e468dadbf96" title="Renvoie le tableau des coordonnees des noeuds (sommets). (acces en lecture)">coord_sommets</a>();
  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; aretes_som=joint.<a class="code" href="classFrontiere.html#a510866aace5f3ed9482553db1a08a3c9" title="Renvoie la Zone associee a la frontiere. (version const)">zone</a>().<a class="code" href="classZone.html#affa60690e1b372fa4c01d6088267dbe4" title="renvoie le tableau de connectivite aretes/sommets.">aretes_som</a>();
  <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> aretes(1);
  <span class="keywordtype">int</span> <a class="code" href="Memoire_8cpp.html#ade857a99d48bcb8cfaa57c4cd8d7d2e8">compteur</a>=0;
  <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a> positions(1,<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>);
  <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> som_faces(nb_faces_joint*nb_som_faces);
<span class="comment">// On parcourt 2 a 2 les sommets de chaque face du joint</span>
  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> face=0; face&lt;nb_faces_joint; face++)
    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;nb_som_faces; i++)
      {
        <span class="keywordtype">int</span> Si = sommet(face,i);
        som_faces(face*nb_som_faces+i)=Si;
        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j=i; j&lt;nb_som_faces; j++)
          {
            <span class="keywordtype">int</span> Sj = sommet(face,j);
<span class="comment">// Calcul du point C entre 2 sommets Si et Sj</span>
            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> comp=0; comp&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>; comp++)
              positions(0,comp)=0.5*(coord(Si,comp)+coord(Sj,comp));
            dom.<a class="code" href="classDomaine.html#a0e62f2bc829542fafa29e3f2c614159c" title="Renvoie la i-ieme zone du domaine. (version const)">zone</a>(0).<a class="code" href="classZone.html#a94575800622f4900d6c92289f01c5fa5">chercher_aretes</a>(positions,aretes);
<span class="comment">// Si on trouve une arete dont le centre coincide avec le point C</span>
<span class="comment">// et dont les sommets sont identiques a Si et Sj, on ajoute l&#39;arete a la liste</span>
            <span class="keywordflow">if</span> (aretes(0)&gt;=0 &amp;&amp; <a class="code" href="Scatter_8cpp.html#a161e660f58270346277422596ef9c7b3">arete_de_sommets_Si_et_Sj</a>(Si, Sj, aretes[0], aretes_som))
              {
                compteur++;
                liste_aretes.<a class="code" href="classArrOfInt.html#a3f39d0966599416e7b1f7cd8159d8d01" title="Ajoute une case en fin de tableau et y stocke la &quot;valeur&quot;.">append_array</a>(aretes[0]);
              }
          }
      }
  <a class="code" href="classProcess.html#a57e0f54b11e6eaadbea224fa904b18dd" title="Renvoie un objet statique de type Sortie qui sert de journal d&#39;evenements. Si message_level &lt;= verbose...">Process::Journal</a>() &lt;&lt; <span class="stringliteral">&quot;common edges found on faces of joint with &quot;</span> &lt;&lt; joint.<a class="code" href="classJoint.html#a0952bc5c7805434ccd8cd5c9b01e3747" title="Renvoie PEvoisin (numero de la zone voisine)">PEvoisin</a>() &lt;&lt; <span class="stringliteral">&quot; :&quot;</span> &lt;&lt; compteur &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
<span class="comment">//</span>
<span class="comment">// Recherche des aretes de joint isolees sur les sommets de joints isoles</span>
<span class="comment">//</span>
<span class="comment">// joint.sommets() contient parfois tous les sommets !</span>
<span class="comment">// Donc on construit un tableau som_isoles</span>
  <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> som_isoles;
<span class="comment">// Met tous les sommets dans som_isoles (isoles+issus des faces de joint):</span>
  <a class="code" href="Scatter_8cpp.html#a4286544562bceff2d921dc707678463f" title="Methode outil: renvoie une liste complete de tous les sommets de joint (sommets des faces + sommets i...">calculer_liste_complete_sommets_joint</a>(joint, som_isoles);
<span class="comment">// On trie som_faces et on supprime les doublons</span>
  <a class="code" href="Scatter_8cpp.html#a23c4d19dc90caae2323f04de90621709" title="Methode outil pour retirer les doublons dans un tableau.">array_trier_retirer_doublons</a>(som_faces);
<span class="comment">// Supprime tous les sommets de som_isoles contenus dans som_faces</span>
  <a class="code" href="Scatter_8cpp.html#ab0ae6267baccb3a639f4a8ff795edd35" title="Retire de &quot;sorted_array&quot; les elements qui figurent dans &quot;sorted_elements&quot;. Les deux tableaux doiv...">array_retirer_elements</a>(som_isoles, som_faces);
<span class="comment">// Supprime les sommets des faces de joint</span>
  <span class="keyword">const</span> <span class="keywordtype">int</span> n = som_isoles.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>();
  <a class="code" href="classProcess.html#a57e0f54b11e6eaadbea224fa904b18dd" title="Renvoie un objet statique de type Sortie qui sert de journal d&#39;evenements. Si message_level &lt;= verbose...">Process::Journal</a>() &lt;&lt; <span class="stringliteral">&quot;number of isolated nodes: &quot;</span> &lt;&lt; n &lt;&lt; finl;
  <a class="code" href="classProcess.html#a57e0f54b11e6eaadbea224fa904b18dd" title="Renvoie un objet statique de type Sortie qui sert de journal d&#39;evenements. Si message_level &lt;= verbose...">Process::Journal</a>() &lt;&lt; <span class="stringliteral">&quot;number of nodes of faces of joint: &quot;</span> &lt;&lt; 3*sommet.<a class="code" href="classIntTab.html#abc3b32c94925a82f69d5b153a356e359" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(0) &lt;&lt; finl;

  compteur=0;
<span class="comment">// On parcourt 2 a 2 les sommets isoles</span>
  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; n; i++)
    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = i; j &lt; n; j++)
      {
<span class="comment">// Calcul du point C entre 2 sommets Si et Sj</span>
        <span class="keywordtype">int</span> Si = som_isoles(i);
        <span class="keywordtype">int</span> Sj = som_isoles(j);
        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> comp=0; comp&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>; comp++)
          positions(0,comp)=0.5*(coord(Si,comp)+coord(Sj,comp));
        dom.<a class="code" href="classDomaine.html#a0e62f2bc829542fafa29e3f2c614159c" title="Renvoie la i-ieme zone du domaine. (version const)">zone</a>(0).<a class="code" href="classZone.html#a94575800622f4900d6c92289f01c5fa5">chercher_aretes</a>(positions,aretes);
<span class="comment">// Si on trouve une arete dont le centre coincide avec le point C</span>
<span class="comment">// et dont les sommets sont identiques a Si et Sj, on ajoute l&#39;arete a la liste</span>
        <span class="keywordflow">if</span> (aretes(0)&gt;=0 &amp;&amp; <a class="code" href="Scatter_8cpp.html#a161e660f58270346277422596ef9c7b3">arete_de_sommets_Si_et_Sj</a>(Si, Sj, aretes[0], aretes_som))
          {
            compteur++;
            liste_aretes.<a class="code" href="classArrOfInt.html#a3f39d0966599416e7b1f7cd8159d8d01" title="Ajoute une case en fin de tableau et y stocke la &quot;valeur&quot;.">append_array</a>(aretes[0]);
          }
      }
  <a class="code" href="classProcess.html#a57e0f54b11e6eaadbea224fa904b18dd" title="Renvoie un objet statique de type Sortie qui sert de journal d&#39;evenements. Si message_level &lt;= verbose...">Process::Journal</a>() &lt;&lt; <span class="stringliteral">&quot;common edges found isolated on joint with &quot;</span> &lt;&lt; joint.<a class="code" href="classJoint.html#a0952bc5c7805434ccd8cd5c9b01e3747" title="Renvoie PEvoisin (numero de la zone voisine)">PEvoisin</a>() &lt;&lt; <span class="stringliteral">&quot; :&quot;</span> &lt;&lt; compteur &lt;&lt; finl;
<span class="comment">// Retirer les doublons de la liste</span>
  <a class="code" href="Scatter_8cpp.html#a23c4d19dc90caae2323f04de90621709" title="Methode outil pour retirer les doublons dans un tableau.">array_trier_retirer_doublons</a>(liste_aretes);
}
</pre></div>
</div>
</div>
<a class="anchor" id="a9ce09df49a63406b606ce247e3880d96"></a><!-- doxytag: member="Scatter.cpp::calculer_liste_complete_items_joint" ref="a9ce09df49a63406b606ce247e3880d96" args="(const Joint &amp;joint, const Joint::Type_Item type_item, ArrOfInt &amp;liste_items)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void calculer_liste_complete_items_joint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classJoint.html">Joint</a> &amp;&#160;</td>
          <td class="paramname"><em>joint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classJoint.html#a1e2d15d088c27c9b7b11c02bf4d2c926">Joint::Type_Item</a>&#160;</td>
          <td class="paramname"><em>type_item</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>liste_items</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Scatter_8cpp_source.html#l02010">2010</a> of file <a class="el" href="Scatter_8cpp_source.html">Scatter.cpp</a>.</p>

<p>References <a class="el" href="Joint_8h_source.html#l00066">Joint::ARETE</a>, <a class="el" href="Scatter_8cpp_source.html#l01929">calculer_liste_complete_aretes_joint()</a>, <a class="el" href="Scatter_8cpp_source.html#l01899">calculer_liste_complete_sommets_joint()</a>, <a class="el" href="EntreeSortie_8h_source.html#l00032">Cerr</a>, <a class="el" href="Process_8cpp_source.html#l00223">Process::exit()</a>, <a class="el" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>, and <a class="el" href="Joint_8h_source.html#l00066">Joint::SOMMET</a>.</p>

<p>Referenced by <a class="el" href="Scatter_8cpp_source.html#l02653">Scatter::construire_correspondance_items_par_coordonnees()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">switch</span>(type_item)
    {
    <span class="keywordflow">case</span> <a class="code" href="classJoint.html#a1e2d15d088c27c9b7b11c02bf4d2c926a050aa4faf237e25faef6fff15ffc20f8">Joint::SOMMET</a>:
      <a class="code" href="Scatter_8cpp.html#a4286544562bceff2d921dc707678463f" title="Methode outil: renvoie une liste complete de tous les sommets de joint (sommets des faces + sommets i...">calculer_liste_complete_sommets_joint</a>(joint, liste_items);
      <span class="keywordflow">break</span>;
    <span class="keywordflow">case</span> <a class="code" href="classJoint.html#a1e2d15d088c27c9b7b11c02bf4d2c926a7816c69408b98e1161f1f54e7b6b1cb4">Joint::ARETE</a>:
      <a class="code" href="Scatter_8cpp.html#a984d3b204fb849a38f321769e58a5ef1" title="Methode outil: renvoie une liste complete de tous les aretes de joint (aretes des faces + aretes isol...">calculer_liste_complete_aretes_joint</a>(joint, liste_items);
      <span class="keywordflow">break</span>;
    <span class="keywordflow">default</span>:
      <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Error in Scatter::calculer_liste_complete_items_joint&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
      <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Type of item not expected.&quot;</span> &lt;&lt; finl;
      <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">Process::exit</a>();
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a4286544562bceff2d921dc707678463f"></a><!-- doxytag: member="Scatter.cpp::calculer_liste_complete_sommets_joint" ref="a4286544562bceff2d921dc707678463f" args="(const Joint &amp;joint, ArrOfInt &amp;liste_sommets)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void calculer_liste_complete_sommets_joint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classJoint.html">Joint</a> &amp;&#160;</td>
          <td class="paramname"><em>joint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>liste_sommets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Methode outil: renvoie une liste complete de tous les<br/>
sommets de joint (sommets des faces + sommets isoles), triee et<br/>
sans doublons. </p>

<p>Definition at line <a class="el" href="Scatter_8cpp_source.html#l01899">1899</a> of file <a class="el" href="Scatter_8cpp_source.html">Scatter.cpp</a>.</p>

<p>References <a class="el" href="ArrOfInt_8h_source.html#l00355">ArrOfInt::append_array()</a>, <a class="el" href="Scatter_8cpp_source.html#l00778">array_trier_retirer_doublons()</a>, <a class="el" href="Frontiere_8h_source.html#l00175">Frontiere::faces()</a>, <a class="el" href="Joint__Items_8cpp_source.html#l00049">Joint_Items::items_communs()</a>, <a class="el" href="Joint_8cpp_source.html#l00186">Joint::joint_item()</a>, <a class="el" href="Faces_8h_source.html#l00268">Faces::les_sommets()</a>, <a class="el" href="Cast_8h_source.html#l00059">ref_cast</a>, <a class="el" href="ArrOfInt_8cpp_source.html#l00443">ArrOfInt::set_smart_resize()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00342">ArrOfInt::size_array()</a>, and <a class="el" href="Joint_8h_source.html#l00066">Joint::SOMMET</a>.</p>

<p>Referenced by <a class="el" href="Scatter_8cpp_source.html#l01929">calculer_liste_complete_aretes_joint()</a>, and <a class="el" href="Scatter_8cpp_source.html#l02010">calculer_liste_complete_items_joint()</a>.</p>
<div class="fragment"><pre class="fragment">{
  liste_sommets = joint.<a class="code" href="classJoint.html#a3f49fb1150967b436a115a7373ab27a0" title="Renvoie les informations de joint pour le type demande.">joint_item</a>(<a class="code" href="classJoint.html#a1e2d15d088c27c9b7b11c02bf4d2c926a050aa4faf237e25faef6fff15ffc20f8">Joint::SOMMET</a>).<a class="code" href="classJoint__Items.html#a435fb1629f6dafb089605913517e73c4" title="Voir items_communs_.">items_communs</a>();
<span class="preprocessor">#if 0</span>
<span class="preprocessor"></span>  liste_sommets.<a class="code" href="classArrOfInt.html#a22d744bcd452d039580d1d9186f02b4e" title="Change le mode l&#39;allocation memoire: reallocation d&#39;un tableau a chaque changement de taille (flag = ...">set_smart_resize</a>(1);
<span class="comment">// On prend tous les sommets des faces de joint:</span>
  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; som_faces = joint.<a class="code" href="classFrontiere.html#ac64479069f0c43a17cb5766a39ce5ba8" title="Renvoie les faces de la frontiere&lt;br&gt;(version const)">faces</a>().<a class="code" href="classFaces.html#a07b8d8db9e3d656b93a21a49c063430c">les_sommets</a>();
  liste_sommets = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>,som_faces);
<span class="comment">// On ajoute tous les sommets isoles :</span>
  <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; som_isoles = joint.sommets();
  <span class="keyword">const</span> <span class="keywordtype">int</span> n = som_isoles.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>();
  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; n; i++)
    liste_sommets.<a class="code" href="classArrOfInt.html#a3f39d0966599416e7b1f7cd8159d8d01" title="Ajoute une case en fin de tableau et y stocke la &quot;valeur&quot;.">append_array</a>(som_isoles[i]);
<span class="comment">// Retirer les doublons de la liste</span>
  <a class="code" href="Scatter_8cpp.html#a23c4d19dc90caae2323f04de90621709" title="Methode outil pour retirer les doublons dans un tableau.">array_trier_retirer_doublons</a>(liste_sommets);
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>}
</pre></div>
</div>
</div>
<a class="anchor" id="a600ea51e50b762812904598f72bc12b6"></a><!-- doxytag: member="Scatter.cpp::dump_lata" ref="a600ea51e50b762812904598f72bc12b6" args="(const Domaine &amp;dom)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void dump_lata </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDomaine.html">Domaine</a> &amp;&#160;</td>
          <td class="paramname"><em>dom</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Scatter_8cpp_source.html#l00101">101</a> of file <a class="el" href="Scatter_8cpp_source.html">Scatter.cpp</a>.</p>

<p>References <a class="el" href="Postraitement__lata_8h_source.html#l00067">Postraitement_lata::BINAIRE</a>, <a class="el" href="Postraitement__lata_8h_source.html#l00068">Postraitement_lata::CHAMP</a>, <a class="el" href="classPostraitement__lata.html#ab2b823bb7b2fe7a93a029c1e48951d90">Postraitement_lata::ecrire_champ()</a>, <a class="el" href="classPostraitement__lata.html#a08ea725ea30ac1458a855f9f0a0ffbc1">Postraitement_lata::ecrire_entete()</a>, <a class="el" href="classPostraitement__lata.html#aa5c7fa28338c2ee6fdf95560687d0854">Postraitement_lata::ecrire_temps()</a>, <a class="el" href="Postraitement__lata_8cpp_source.html#l00084">Postraitement_lata::ecrire_zone()</a>, <a class="el" href="Joint_8h_source.html#l00066">Joint::ELEMENT</a>, <a class="el" href="Postraitement__base_8h_source.html#l00061">Postraitement_base::ELEMENTS</a>, <a class="el" href="Joint__Items_8cpp_source.html#l00063">Joint_Items::items_distants()</a>, <a class="el" href="Zone_8h_source.html#l00909">Zone::joint()</a>, <a class="el" href="Joint_8cpp_source.html#l00186">Joint::joint_item()</a>, <a class="el" href="Domaine_8h_source.html#l00204">Domaine::le_nom()</a>, <a class="el" href="Zone_8h_source.html#l00300">Zone::nb_elem()</a>, <a class="el" href="Zone_8h_source.html#l00550">Zone::nb_joints()</a>, <a class="el" href="Joint_8cpp_source.html#l00099">Joint::PEvoisin()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00342">ArrOfInt::size_array()</a>, and <a class="el" href="Domaine_8h_source.html#l00272">Domaine::zone()</a>.</p>

<p>Referenced by <a class="el" href="Scatter_8cpp_source.html#l00150">Scatter::interpreter()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">const</span> <a class="code" href="classZone.html" title="classe Zone Une Zone est un maillage compose d&#39;un ensemble d&#39;elements geometriques de meme type...">Zone</a>&amp; zone = dom.<a class="code" href="classDomaine.html#a0e62f2bc829542fafa29e3f2c614159c" title="Renvoie la i-ieme zone du domaine. (version const)">zone</a>(0);
  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_joints = zone.<a class="code" href="classZone.html#ab096afb61e89705709a4ae6d3576a644" title="Renvoie le nombre de joints de la zone.">nb_joints</a>();

  <span class="keyword">const</span> <a class="code" href="classComm__Group.html" title=": Cette classe decrit un groupe de processeurs sur lesquels une portion de code s&#39;execute simultaneme...">Comm_Group</a> *cg = 0;
  <a class="code" href="classNom.html" title="class Nom Une chaine de caractere pour nommer les objets de TRUST">Nom</a> nom_fichier_lata(<span class="stringliteral">&quot;espaces_virtuels&quot;</span>);
  <a class="code" href="classPostraitement__lata.html#a5a0f028169251f7e1736d60601ef77f9">Postraitement_lata::Format</a> format = <a class="code" href="classPostraitement__lata.html#a5a0f028169251f7e1736d60601ef77f9a3384124d5051d9c93ed5e30a57be2642">Postraitement_lata::BINAIRE</a>;
  <a class="code" href="classPostraitement__lata.html#a08ea725ea30ac1458a855f9f0a0ffbc1">Postraitement_lata::ecrire_entete</a>(nom_fichier_lata,
                                    <span class="stringliteral">&quot;Discretisation_inconnue&quot;</span>,
                                    format, cg);
  <a class="code" href="classPostraitement__lata.html#abddde8cf0136be3345a4e3b6b0174997">Postraitement_lata::ecrire_zone</a>(nom_fichier_lata,
                                  zone,
                                  format, cg);

  <a class="code" href="classPostraitement__lata.html#aa5c7fa28338c2ee6fdf95560687d0854">Postraitement_lata::ecrire_temps</a>(nom_fichier_lata,
                                   0.,
                                   format, cg);
  <span class="keyword">const</span> <span class="keywordtype">int</span> n = zone.<a class="code" href="classZone.html#a7f249429803b27139a1c54436f6164a5" title="Renvoie le nombre d&#39;elements de la zone.">nb_elem</a>();
  <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a> data(n);
  <span class="keywordflow">for</span>(<span class="keywordtype">int</span> ij = 0; ij &lt; nb_joints; ij++)
    {
      <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; t1 = zone.<a class="code" href="classZone.html#acec4c61032df8b55a95f9e7197ef6e3c" title="Renvoie le i-ieme joint de la zone&lt;br&gt;(version const)">joint</a>(ij).<a class="code" href="classJoint.html#a3f49fb1150967b436a115a7373ab27a0" title="Renvoie les informations de joint pour le type demande.">joint_item</a>(<a class="code" href="classJoint.html#a1e2d15d088c27c9b7b11c02bf4d2c926ae32de3a01fdb3ad6c506b8058a7f6173">Joint::ELEMENT</a>).<a class="code" href="classJoint__Items.html#ae51b330de79fcaae9c88166e3eee7cb8" title="Voir items_distants_.">items_distants</a>();
      data = 0.;
      {
        <span class="keyword">const</span> <span class="keywordtype">int</span> nt1 = t1.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>();
        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; nt1; i++)
          data(t1[i]) += 1;
      }
      <a class="code" href="classPostraitement__lata.html#ab2b823bb7b2fe7a93a029c1e48951d90">Postraitement_lata::ecrire_champ</a>(nom_fichier_lata,
                                       <a class="code" href="classNom.html" title="class Nom Une chaine de caractere pour nommer les objets de TRUST">Nom</a>(<span class="stringliteral">&quot;partition&quot;</span>) + <a class="code" href="classNom.html" title="class Nom Une chaine de caractere pour nommer les objets de TRUST">Nom</a>(zone.<a class="code" href="classZone.html#acec4c61032df8b55a95f9e7197ef6e3c" title="Renvoie le i-ieme joint de la zone&lt;br&gt;(version const)">joint</a>(ij).<a class="code" href="classJoint.html#a0952bc5c7805434ccd8cd5c9b01e3747" title="Renvoie PEvoisin (numero de la zone voisine)">PEvoisin</a>()),
                                       <a class="code" href="classPostraitement__lata.html#a012d35ff1c9b7bb8a7c59587b4c3e4f0addb3b63849292cc4575b2ee02340dded">Postraitement_lata::CHAMP</a>,
                                       <span class="charliteral">&#39;I&#39;</span>,
                                       dom.<a class="code" href="classDomaine.html#a87e2cdc035a26565e6fe481446aa4cd3" title="Renvoie le nom du domaine.">le_nom</a>(),
                                       <span class="stringliteral">&quot;pb&quot;</span>,
                                       0., <span class="comment">/* temps */</span>
                                       <a class="code" href="classPostraitement__base.html#a6a43e4c7caaafa57902a067e706d56e9a72278646074c45c57de008b5deda3037">Postraitement_base::ELEMENTS</a>,
                                       data,
                                       format);
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a554d338bda1a27579f9fb08e6a0168b9"></a><!-- doxytag: member="Scatter.cpp::endian" ref="a554d338bda1a27579f9fb08e6a0168b9" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNom.html">Nom</a> endian </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Scatter_8cpp_source.html#l01133">1133</a> of file <a class="el" href="Scatter_8cpp_source.html">Scatter.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">int</span> x = 1;
  <span class="keywordflow">if</span>(*(<span class="keywordtype">char</span> *)&amp;x == 1)
    <span class="keywordflow">return</span> <span class="stringliteral">&quot;little-endian&quot;</span>;
  <span class="keywordflow">else</span>
    <span class="keywordflow">return</span> <span class="stringliteral">&quot;big-endian&quot;</span>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a06420c19a824af0906036ca04758d81c"></a><!-- doxytag: member="Scatter.cpp::fct_cmp_coordonnees" ref="a06420c19a824af0906036ca04758d81c" args="(const double *s1, const double *s2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="arch_8h.html#a1caaf369d9c5f0817dbaa76b43b8d87b">True_int</a> fct_cmp_coordonnees </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>s2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Scatter_8cpp_source.html#l02460">2460</a> of file <a class="el" href="Scatter_8cpp_source.html">Scatter.cpp</a>.</p>

<p>References <a class="el" href="Scatter_8cpp_source.html#l02457">fct_cmp_coord_dimension</a>, and <a class="el" href="Scatter_8cpp_source.html#l02458">fct_cmp_coord_epsilon</a>.</p>

<p>Referenced by <a class="el" href="Scatter_8cpp_source.html#l02512">Scatter::Chercher_Correspondance()</a>, and <a class="el" href="Scatter_8cpp_source.html#l02488">fct_cmp_index_coord()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">const</span> <span class="keywordtype">int</span> dim = <a class="code" href="Scatter_8cpp.html#a09e112f8a32312a1675f7e33b94df122">fct_cmp_coord_dimension</a>;
  <span class="keyword">const</span> <span class="keywordtype">double</span> epsilon = <a class="code" href="Scatter_8cpp.html#a81c1304205b09abc2acc284f8adc390c">fct_cmp_coord_epsilon</a>;
  assert(dim==2 || dim==3);
  <span class="keywordflow">if</span> (s1[0] &lt; s2[0] - epsilon)
    <span class="keywordflow">return</span> -1;
  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (s1[0] &gt; s2[0] + epsilon)
    <span class="keywordflow">return</span> 1;
  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (s1[1] &lt; s2[1] - epsilon)
    <span class="keywordflow">return</span> -1;
  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (s1[1] &gt; s2[1] + epsilon)
    <span class="keywordflow">return</span> 1;
  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (dim&lt;3)
    <span class="keywordflow">return</span> 0;
  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (s1[2] &lt; s2[2] - epsilon)
    <span class="keywordflow">return</span> -1;
  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (s1[2] &gt; s2[2] + epsilon)
    <span class="keywordflow">return</span> 1;
  <span class="keywordflow">else</span>
    <span class="keywordflow">return</span> 0;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a727b40392ca2280ef4b3f158a4225b48"></a><!-- doxytag: member="Scatter.cpp::fct_cmp_index_coord" ref="a727b40392ca2280ef4b3f158a4225b48" args="(const void *ptr1, const void *ptr2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="arch_8h.html#a1caaf369d9c5f0817dbaa76b43b8d87b">True_int</a> fct_cmp_index_coord </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>ptr1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>ptr2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Scatter_8cpp_source.html#l02488">2488</a> of file <a class="el" href="Scatter_8cpp_source.html">Scatter.cpp</a>.</p>

<p>References <a class="el" href="Scatter_8cpp_source.html#l02460">fct_cmp_coordonnees()</a>.</p>

<p>Referenced by <a class="el" href="Scatter_8cpp_source.html#l02512">Scatter::Chercher_Correspondance()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">const</span> <span class="keywordtype">int</span> i1 = *(<span class="keyword">const</span> <span class="keywordtype">int</span> *)ptr1;
  <span class="keyword">const</span> <span class="keywordtype">int</span> i2 = *(<span class="keyword">const</span> <span class="keywordtype">int</span> *)ptr2;
  <span class="keyword">const</span> <span class="keywordtype">double</span> * s1 = &amp; (*fct_cmp_coord_tableau)(i1,0);
  <span class="keyword">const</span> <span class="keywordtype">double</span> * s2 = &amp; (*fct_cmp_coord_tableau)(i2,0);
  <span class="keyword">const</span> <a class="code" href="arch_8h.html#a1caaf369d9c5f0817dbaa76b43b8d87b">True_int</a> resu = <a class="code" href="Scatter_8cpp.html#a06420c19a824af0906036ca04758d81c">fct_cmp_coordonnees</a>(s1, s2);
  <span class="keywordflow">return</span> resu;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a944250a2c83f0a472deb1c18072b9b69"></a><!-- doxytag: member="Scatter.cpp::fct_tri_table_inverse" ref="a944250a2c83f0a472deb1c18072b9b69" args="(const void *ptr1, const void *ptr2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="arch_8h.html#a1caaf369d9c5f0817dbaa76b43b8d87b">True_int</a> fct_tri_table_inverse </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>ptr1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>ptr2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Scatter_8cpp_source.html#l01507">1507</a> of file <a class="el" href="Scatter_8cpp_source.html">Scatter.cpp</a>.</p>

<p>Referenced by <a class="el" href="Scatter_8cpp_source.html#l01561">Traduction_Indice_Global_Local::initialiser()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">const</span> <span class="keywordtype">int</span> i1 = *(<span class="keywordtype">int</span>*)ptr1;
  <span class="keyword">const</span> <span class="keywordtype">int</span> i2 = *(<span class="keywordtype">int</span>*)ptr2;
<span class="preprocessor">#ifdef INT_is_64_</span>
<span class="preprocessor"></span>  <span class="keywordflow">if</span> (i1 == i2)
    <span class="keywordflow">return</span> 0;
  <span class="keywordflow">if</span> (i1&gt;i2)
    <span class="keywordflow">return</span> 1;
  <span class="keywordflow">return</span> -1;
<span class="preprocessor">#else</span>
<span class="preprocessor"></span>  <span class="keywordflow">return</span> i1 - i2;
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>
}
</pre></div>
</div>
</div>
<a class="anchor" id="a4c215e3cfff2963def44e300a58b513b"></a><!-- doxytag: member="Scatter.cpp::init_simple_md_vector" ref="a4c215e3cfff2963def44e300a58b513b" args="(MD_Vector_std &amp;md, const int n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void init_simple_md_vector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMD__Vector__std.html">MD_Vector_std</a> &amp;&#160;</td>
          <td class="paramname"><em>md</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Scatter_8cpp_source.html#l02845">2845</a> of file <a class="el" href="Scatter_8cpp_source.html">Scatter.cpp</a>.</p>

<p>References <a class="el" href="MD__Vector__base2_8h_source.html#l00086">MD_Vector_base2::blocs_items_to_compute_</a>, <a class="el" href="MD__Vector__base2_8h_source.html#l00080">MD_Vector_base2::blocs_items_to_sum_</a>, <a class="el" href="MD__Vector__base2_8h_source.html#l00066">MD_Vector_base2::nb_items_reels_</a>, <a class="el" href="MD__Vector__base2_8h_source.html#l00071">MD_Vector_base2::nb_items_seq_local_</a>, <a class="el" href="MD__Vector__base2_8h_source.html#l00069">MD_Vector_base2::nb_items_seq_tot_</a>, <a class="el" href="MD__Vector__base2_8h_source.html#l00060">MD_Vector_base2::nb_items_tot_</a>, <a class="el" href="Array__base_8h_source.html#l00038">Array_base::NOCOPY_NOINIT</a>, and <a class="el" href="ArrOfInt_8h_source.html#l00240">ArrOfInt::resize_array()</a>.</p>

<p>Referenced by <a class="el" href="Scatter_8cpp_source.html#l02903">Scatter::init_sequential_domain()</a>.</p>
<div class="fragment"><pre class="fragment">{
  md.<a class="code" href="classMD__Vector__base2.html#ae222cd70f0be4da64d0aa7fcd89df0f4">nb_items_tot_</a> = n;
  md.<a class="code" href="classMD__Vector__base2.html#a87c423fabd116249cb1dab31887193c9">nb_items_reels_</a> = n;
  md.<a class="code" href="classMD__Vector__base2.html#a7cf9dbd94db6c0ba49e87681d207aef0">nb_items_seq_tot_</a> = n;
  md.<a class="code" href="classMD__Vector__base2.html#a2bb5e578b35a03544342e963d2adec35">nb_items_seq_local_</a> = n;
  md.<a class="code" href="classMD__Vector__base2.html#afb3898aebe081ff8c87759822946ece7">blocs_items_to_sum_</a>.<a class="code" href="classArrOfInt.html#a9b3afbb46b16870dbd36236c8935b535">resize_array</a>(2, <a class="code" href="classArray__base.html#abee342aa9ac59623c4c782dc9d7877ffaf6ae9ba7eb51c5f298ce693345b3ec68">Array_base::NOCOPY_NOINIT</a>);
  md.<a class="code" href="classMD__Vector__base2.html#afb3898aebe081ff8c87759822946ece7">blocs_items_to_sum_</a>[0] = 0;
  md.<a class="code" href="classMD__Vector__base2.html#afb3898aebe081ff8c87759822946ece7">blocs_items_to_sum_</a>[1] = n;
  md.<a class="code" href="classMD__Vector__base2.html#ac19dad1f73b786033a9911cbfe3ae440">blocs_items_to_compute_</a>.<a class="code" href="classArrOfInt.html#a9b3afbb46b16870dbd36236c8935b535">resize_array</a>(2, <a class="code" href="classArray__base.html#abee342aa9ac59623c4c782dc9d7877ffaf6ae9ba7eb51c5f298ce693345b3ec68">Array_base::NOCOPY_NOINIT</a>);
  md.<a class="code" href="classMD__Vector__base2.html#ac19dad1f73b786033a9911cbfe3ae440">blocs_items_to_compute_</a>[0] = 0;
  md.<a class="code" href="classMD__Vector__base2.html#ac19dad1f73b786033a9911cbfe3ae440">blocs_items_to_compute_</a>[1] = n;
}
</pre></div>
</div>
</div>
<hr/><h2>Variable Documentation</h2>
<a class="anchor" id="a09e112f8a32312a1675f7e33b94df122"></a><!-- doxytag: member="Scatter.cpp::fct_cmp_coord_dimension" ref="a09e112f8a32312a1675f7e33b94df122" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="Scatter_8cpp.html#a09e112f8a32312a1675f7e33b94df122">fct_cmp_coord_dimension</a> = -1<code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Scatter_8cpp_source.html#l02457">2457</a> of file <a class="el" href="Scatter_8cpp_source.html">Scatter.cpp</a>.</p>

<p>Referenced by <a class="el" href="Scatter_8cpp_source.html#l02460">fct_cmp_coordonnees()</a>.</p>

</div>
</div>
<a class="anchor" id="a81c1304205b09abc2acc284f8adc390c"></a><!-- doxytag: member="Scatter.cpp::fct_cmp_coord_epsilon" ref="a81c1304205b09abc2acc284f8adc390c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="Scatter_8cpp.html#a81c1304205b09abc2acc284f8adc390c">fct_cmp_coord_epsilon</a> = -1.<code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Scatter_8cpp_source.html#l02458">2458</a> of file <a class="el" href="Scatter_8cpp_source.html">Scatter.cpp</a>.</p>

<p>Referenced by <a class="el" href="Scatter_8cpp_source.html#l02460">fct_cmp_coordonnees()</a>.</p>

</div>
</div>
<a class="anchor" id="a107a2fbce3e368271c492cfcf7cfca10"></a><!-- doxytag: member="Scatter.cpp::fct_cmp_coord_tableau" ref="a107a2fbce3e368271c492cfcf7cfca10" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classDoubleTab.html">DoubleTab</a>* <a class="el" href="Scatter_8cpp.html#a107a2fbce3e368271c492cfcf7cfca10">fct_cmp_coord_tableau</a> = 0<code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Scatter_8cpp_source.html#l02483">2483</a> of file <a class="el" href="Scatter_8cpp_source.html">Scatter.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5aa23d1c4a41bce37e5e06efb5e8c9e1"></a><!-- doxytag: member="Scatter.cpp::interprete_scatter_counter_" ref="a5aa23d1c4a41bce37e5e06efb5e8c9e1" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classStat__Counter__Id.html">Stat_Counter_Id</a> <a class="el" href="stat__counters_8h.html#a5aa23d1c4a41bce37e5e06efb5e8c9e1">interprete_scatter_counter_</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>&lt; PGI </p>

<p>Definition at line <a class="el" href="stat__counters_8cpp_source.html#l00072">72</a> of file <a class="el" href="stat__counters_8cpp_source.html">stat_counters.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6b0bce9d4399a0b851de1bf50e6e0761"></a><!-- doxytag: member="Scatter.cpp::Scatterbases" ref="a6b0bce9d4399a0b851de1bf50e6e0761" args="[1]" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classType__info.html">Type_info</a>* <a class="el" href="Scatter_8cpp.html#a6b0bce9d4399a0b851de1bf50e6e0761">Scatterbases</a>[1] = { &amp;( <a class="el" href="classInterprete.html">Interprete</a> ::info_obj)}</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Scatter_8cpp_source.html#l00051">51</a> of file <a class="el" href="Scatter_8cpp_source.html">Scatter.cpp</a>.</p>

</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Tue Dec 14 2021 19:35:51 for TRUST by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
