<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>TRUST: src/CoviMAC/Cond_Lim/Echange_contact_CoviMAC.cpp Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">TRUST&#160;<span id="projectnumber">1.8.4</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
<div class="header">
  <div class="headertitle">
<div class="title">src/CoviMAC/Cond_Lim/Echange_contact_CoviMAC.cpp</div>  </div>
</div>
<div class="contents">
<a href="Echange__contact__CoviMAC_8cpp.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/****************************************************************************</span>
<a name="l00002"></a>00002 <span class="comment">* Copyright (c) 2021, CEA</span>
<a name="l00003"></a>00003 <span class="comment">* All rights reserved.</span>
<a name="l00004"></a>00004 <span class="comment">*</span>
<a name="l00005"></a>00005 <span class="comment">* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</span>
<a name="l00006"></a>00006 <span class="comment">* 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.</span>
<a name="l00007"></a>00007 <span class="comment">* 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.</span>
<a name="l00008"></a>00008 <span class="comment">* 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.</span>
<a name="l00009"></a>00009 <span class="comment">*</span>
<a name="l00010"></a>00010 <span class="comment">* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.</span>
<a name="l00011"></a>00011 <span class="comment">* IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;</span>
<a name="l00012"></a>00012 <span class="comment">* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>
<a name="l00013"></a>00013 <span class="comment">*</span>
<a name="l00014"></a>00014 <span class="comment">*****************************************************************************/</span>
<a name="l00015"></a>00015 <span class="comment">//</span>
<a name="l00016"></a>00016 <span class="comment">// </span>
<a name="l00017"></a>00017 <span class="comment">// File:        Echange_contact_CoviMAC.cpp</span>
<a name="l00018"></a>00018 <span class="comment">// Directory:   $TRUST_ROOT/src/CoviMAC/Cond_Lim</span>
<a name="l00019"></a>00019 <span class="comment">// Version:     /main/32</span>
<a name="l00020"></a>00020 <span class="comment">// </span>
<a name="l00021"></a>00021 <span class="comment">//</span>
<a name="l00022"></a>00022 
<a name="l00023"></a>00023 <span class="preprocessor">#include &lt;<a class="code" href="Echange__contact__CoviMAC_8h.html">Echange_contact_CoviMAC.h</a>&gt;</span>
<a name="l00024"></a>00024 <span class="preprocessor">#include &lt;<a class="code" href="Champ__front__calc_8h.html">Champ_front_calc.h</a>&gt;</span>
<a name="l00025"></a>00025 <span class="preprocessor">#include &lt;<a class="code" href="Probleme__base_8h.html">Probleme_base.h</a>&gt;</span>
<a name="l00026"></a>00026 <span class="preprocessor">#include &lt;<a class="code" href="Champ__Uniforme_8h.html">Champ_Uniforme.h</a>&gt;</span>
<a name="l00027"></a>00027 <span class="preprocessor">#include &lt;<a class="code" href="Schema__Euler__Implicite_8h.html">Schema_Euler_Implicite.h</a>&gt;</span>
<a name="l00028"></a>00028 <span class="preprocessor">#include &lt;<a class="code" href="Milieu__base_8h.html">Milieu_base.h</a>&gt;</span>
<a name="l00029"></a>00029 
<a name="l00030"></a>00030 <span class="preprocessor">#include &lt;<a class="code" href="Zone__CoviMAC_8h.html">Zone_CoviMAC.h</a>&gt;</span>
<a name="l00031"></a>00031 <span class="preprocessor">#include &lt;<a class="code" href="Equation__base_8h.html">Equation_base.h</a>&gt;</span>
<a name="l00032"></a>00032 <span class="preprocessor">#include &lt;<a class="code" href="Champ__P0__CoviMAC_8h.html">Champ_P0_CoviMAC.h</a>&gt;</span>
<a name="l00033"></a>00033 <span class="preprocessor">#include &lt;<a class="code" href="Operateur_8h.html">Operateur.h</a>&gt;</span>
<a name="l00034"></a>00034 <span class="preprocessor">#include &lt;<a class="code" href="Op__Diff__CoviMAC__Elem_8h.html">Op_Diff_CoviMAC_Elem.h</a>&gt;</span>
<a name="l00035"></a>00035 <span class="preprocessor">#include &lt;<a class="code" href="Front__VF_8h.html">Front_VF.h</a>&gt;</span>
<a name="l00036"></a>00036 
<a name="l00037"></a>00037 <span class="preprocessor">#include &lt;cmath&gt;</span>
<a name="l00038"></a>00038 
<a name="l00039"></a><a class="code" href="Echange__contact__CoviMAC_8cpp.html#a10d243bcae6332b1e58abed6a4385544">00039</a> <a class="code" href="Op__Diff__CoviMAC__Face_8cpp.html#aa86ec8ba612a969d9b4370b775037144">Implemente_instanciable</a>(<a class="code" href="classEchange__contact__CoviMAC.html">Echange_contact_CoviMAC</a>,<span class="stringliteral">&quot;Paroi_Echange_contact_CoviMAC&quot;</span>,<a class="code" href="classEchange__externe__impose.html" title="Classe Echange_externe_impose: Cette classe represente le cas particulier de la classe Echange_impose...">Echange_externe_impose</a>);
<a name="l00040"></a>00040 <span class="keyword">using namespace </span>MEDCoupling;
<a name="l00041"></a>00041 
<a name="l00042"></a><a class="code" href="classEchange__contact__CoviMAC.html#ab46a00a2c9b3cb7b56c612da94088561">00042</a> <a class="code" href="classSortie.html" title="Classe de base des flux de sortie. Elle sait ecrire des types simples&lt;br&gt;(entiers, flottants) et des Ob...">Sortie</a>&amp; <a class="code" href="classChamp__P0__CoviMAC.html#ac39ed908fdecf08ada9fb6557689e1a0" title="Surcharge Champ_base::printOn(Sortie&amp;) const Imprime le champ sur un flot de sortie. Simple appel a Champ_base::printOn(Sortie&amp;) const.">Echange_contact_CoviMAC::printOn</a>(<a class="code" href="classSortie.html" title="Classe de base des flux de sortie. Elle sait ecrire des types simples&lt;br&gt;(entiers, flottants) et des Ob...">Sortie</a>&amp; s )<span class="keyword"> const</span>
<a name="l00043"></a>00043 <span class="keyword"></span>{
<a name="l00044"></a>00044   <span class="keywordflow">return</span> s &lt;&lt; <a class="code" href="classObjet__U.html#aa58e9a81c0ddc2c1149053b8f96698ac" title="renvoie la chaine identifiant la classe.">que_suis_je</a>() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;
<a name="l00045"></a>00045 }
<a name="l00046"></a>00046 
<a name="l00047"></a><a class="code" href="classEchange__contact__CoviMAC.html#a9cc5e88f53103be22b924cf706bac993">00047</a> <a class="code" href="classEntree.html" title="Classe de definition des operateurs et methodes pour toute lecture dans un flot d&#39;entree (fichier...">Entree</a>&amp; <a class="code" href="classChamp__P0__CoviMAC.html#afc2528171640f27c3d3229ca8944fdce" title="Lit un champ inconnue sur un flot d&#39;entree. Simple appel a Champ_base::readOn(Entree&amp;)">Echange_contact_CoviMAC::readOn</a>(<a class="code" href="classEntree.html" title="Classe de definition des operateurs et methodes pour toute lecture dans un flot d&#39;entree (fichier...">Entree</a>&amp; s )
<a name="l00048"></a>00048 {
<a name="l00049"></a>00049   <a class="code" href="classNom.html" title="class Nom Une chaine de caractere pour nommer les objets de TRUST">Nom</a> nom_bord;
<a name="l00050"></a>00050   <a class="code" href="classMotcle.html" title="Une chaine de caractere (Nom) en majuscules.">Motcle</a> nom_champ;
<a name="l00051"></a>00051   s &gt;&gt; nom_autre_pb_ &gt;&gt; nom_bord_ &gt;&gt; nom_champ_ &gt;&gt; invh_paroi_;
<a name="l00052"></a>00052   invh_paroi_ = invh_paroi_ &gt; 1e8 ? 0 : 1. / invh_paroi_;
<a name="l00053"></a>00053   T_ext().typer(<span class="stringliteral">&quot;Ch_front_var_instationnaire_dep&quot;</span>);
<a name="l00054"></a>00054   T_ext()-&gt;fixer_nb_comp(1);
<a name="l00055"></a>00055   <span class="keywordflow">return</span> s;
<a name="l00056"></a>00056 }
<a name="l00057"></a>00057 
<a name="l00058"></a><a class="code" href="classEchange__contact__CoviMAC.html#a921ace5561d88edf86ab45e40d792556">00058</a> <span class="keywordtype">int</span> <a class="code" href="classEchange__contact__CoviMAC.html#a921ace5561d88edf86ab45e40d792556" title="Initialisation en debut de calcul. A appeler avant tout calculer_coeffs_echange ou mettre_a_jour Cont...">Echange_contact_CoviMAC::initialiser</a>(<span class="keywordtype">double</span> <a class="code" href="classChamp__base.html#ada7350aecb7b6f20dcaee2d1106ab1a0" title="Renvoie le temps du champ.">temps</a>)
<a name="l00059"></a>00059 {
<a name="l00060"></a>00060   <a class="code" href="classEchange__impose__base.html#af91ea61919a62920c069484d76c67e6c" title="Initialisation en debut de calcul. A appeler avant tout calculer_coeffs_echange ou mettre_a_jour Cont...">Echange_externe_impose::initialiser</a>(temps);
<a name="l00061"></a>00061   <a class="code" href="classChamp__front__calc.html" title="classe Champ_front_calc Classe derivee de Champ_front_var qui represente les champs a la frontiere ob...">Champ_front_calc</a> ch;
<a name="l00062"></a>00062   ch.<a class="code" href="classChamp__front__calc.html#a384d283ccda150286263d0539c541118" title="Cree l&#39;objet Champ_front_calc representant la trace d&#39;un champ inconnue sur une frontiere a partir de...">creer</a>(nom_autre_pb_, nom_bord_, nom_champ_);
<a name="l00063"></a>00063   fvf = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>, frontiere_dis()), o_fvf = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>, ch.<a class="code" href="classChamp__front__calc.html#ac155878740179b362deaeb348b7deca8" title="Renvoie la frontiere discretisee correspondante au domaine sur lequel prend la trace.">front_dis</a>()); <span class="comment">//frontieres</span>
<a name="l00064"></a>00064   <span class="keyword">const</span> <a class="code" href="classEquation__base.html">Equation_base</a>&amp; eqn = <a class="code" href="classChamp__Inc__base.html#a8d729b89f1854471101bd0a47ddaf45a">zone_Cl_dis</a>().equation(), &amp;o_eqn = ch.<a class="code" href="classChamp__front__calc.html#a922bf951b57569ffbc59b0ce1f7e9029" title="Renvoie l&#39;equation associee a l&#39;inconnue dont on prend la trace.">equation</a>(); <span class="comment">//equations</span>
<a name="l00065"></a>00065   i_fvf = eqn.<a class="code" href="classEquation__base.html#a12d97ae801edc18f614523677921346e" title="Renvoie la zone discretisee associee a l&#39;equation.">zone_dis</a>()-&gt;rang_frontiere(fvf.le_nom()), i_o_fvf = o_eqn.zone_dis()-&gt;rang_frontiere(nom_bord_);
<a name="l00066"></a>00066 
<a name="l00067"></a>00067   <span class="keywordtype">int</span> i_op = -1, o_i_op = -1, i; <span class="comment">//indice de l&#39;operateur de diffusion dans l&#39;autre equation</span>
<a name="l00068"></a>00068   <span class="keywordflow">for</span> (i = 0; i &lt; eqn.nombre_d_operateurs(); i++)
<a name="l00069"></a>00069     <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classOp__Diff__CoviMAC__base.html" title="class Op_Diff_CoviMAC_base Classe de base des operateurs de diffusion CoviMAC">Op_Diff_CoviMAC_base</a>, eqn.operateur(i).l_op_base())) i_op = i;
<a name="l00070"></a>00070   <span class="keywordflow">if</span> (i_op &lt; 0) <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">Process::exit</a>(<a class="code" href="classField__base.html#ae1377124eabe8387aced762115b062bb" title="Renvoie le nom du champ.">le_nom</a>() + <span class="stringliteral">&quot; : no diffusion operator found in &quot;</span> + eqn.probleme().<a class="code" href="classNom.html#a4fcffbaa80271df0d9674f2a2751efb9" title="Renvoie *this;.">le_nom</a>() + <span class="stringliteral">&quot; !&quot;</span>);
<a name="l00071"></a>00071   <span class="keywordflow">for</span> (i = 0; i &lt; o_eqn.nombre_d_operateurs(); i++)
<a name="l00072"></a>00072     <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classOp__Diff__CoviMAC__base.html" title="class Op_Diff_CoviMAC_base Classe de base des operateurs de diffusion CoviMAC">Op_Diff_CoviMAC_base</a>, o_eqn.operateur(i).l_op_base())) o_i_op = i;
<a name="l00073"></a>00073   <span class="keywordflow">if</span> (o_i_op &lt; 0) <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">Process::exit</a>(<a class="code" href="classField__base.html#ae1377124eabe8387aced762115b062bb" title="Renvoie le nom du champ.">le_nom</a>() + <span class="stringliteral">&quot; : no diffusion operator found in &quot;</span> + o_eqn.probleme().<a class="code" href="classNom.html#a4fcffbaa80271df0d9674f2a2751efb9" title="Renvoie *this;.">le_nom</a>() + <span class="stringliteral">&quot; !&quot;</span>);
<a name="l00074"></a>00074   diff = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classOp__Diff__CoviMAC__base.html" title="class Op_Diff_CoviMAC_base Classe de base des operateurs de diffusion CoviMAC">Op_Diff_CoviMAC_base</a>, eqn.operateur(i_op).l_op_base());
<a name="l00075"></a>00075   o_diff = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classOp__Diff__CoviMAC__base.html" title="class Op_Diff_CoviMAC_base Classe de base des operateurs de diffusion CoviMAC">Op_Diff_CoviMAC_base</a>, o_eqn.operateur(o_i_op).l_op_base());
<a name="l00076"></a>00076 
<a name="l00077"></a>00077   fe_init_ = 0;
<a name="l00078"></a>00078   <span class="keywordflow">return</span> 1;
<a name="l00079"></a>00079 }
<a name="l00080"></a>00080 
<a name="l00081"></a>00081 <span class="comment">/* identification des elements / faces de l&#39;autre cote de la frontiere, avec offsets */</span>
<a name="l00082"></a><a class="code" href="classEchange__contact__CoviMAC.html#a71993b1d3e0e5355f34e3ad099b757a5">00082</a> <span class="keywordtype">void</span> <a class="code" href="classEchange__contact__CoviMAC.html#a71993b1d3e0e5355f34e3ad099b757a5">Echange_contact_CoviMAC::init_fe_dist</a>()<span class="keyword"> const</span>
<a name="l00083"></a>00083 <span class="keyword"></span>{
<a name="l00084"></a>00084   <span class="keywordflow">if</span> (fe_init_) <span class="keywordflow">return</span>; <span class="comment">//deja fait</span>
<a name="l00085"></a>00085   <span class="keyword">const</span> <a class="code" href="classZone__CoviMAC.html" title="class Zone_CoviMAC Classe instanciable qui derive de Zone_VF. Cette classe contient les informations ...">Zone_CoviMAC</a>&amp; zone = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classZone__CoviMAC.html" title="class Zone_CoviMAC Classe instanciable qui derive de Zone_VF. Cette classe contient les informations ...">Zone_CoviMAC</a>, fvf-&gt;zone_dis()), &amp;o_zone = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classZone__CoviMAC.html" title="class Zone_CoviMAC Classe instanciable qui derive de Zone_VF. Cette classe contient les informations ...">Zone_CoviMAC</a>, o_fvf-&gt;zone_dis());
<a name="l00086"></a>00086   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; o_f_e = o_zone.face_voisins();
<a name="l00087"></a>00087   <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; xv = zone.<a class="code" href="classZone__VF.html#a918c0885a9b67317fcce3a0535306542">xv</a>(), &amp;o_xv = o_zone.xv();
<a name="l00088"></a>00088 
<a name="l00089"></a>00089   <span class="keywordtype">int</span> i, f, o_f, nf_tot = fvf-&gt;nb_faces_tot(), o_nf_tot = o_fvf-&gt;nb_faces_tot(), d, D = <a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>;
<a name="l00090"></a>00090   fe_dist_.resize(nf_tot, 2);
<a name="l00091"></a>00091 
<a name="l00092"></a>00092   <a class="code" href="classDoubleTrav.html" title="Tableau de travail a n entrees pour n&lt;= 4 C&#39;est un DoubleTab avec allocation dans un pool de memoire g...">DoubleTrav</a> xyz(nf_tot, D), o_xyz(o_nf_tot, D); <span class="comment">//positions locales/distantes -&gt; pour calcul de correspondance</span>
<a name="l00093"></a>00093   <span class="keywordflow">for</span> (i = 0; i &lt;   nf_tot; i++) <span class="keywordflow">for</span> (d = 0; d &lt; D; d++)   xyz(i, d) =   xv(  fvf-&gt;num_face(i), d);
<a name="l00094"></a>00094   <span class="keywordflow">for</span> (i = 0; i &lt; o_nf_tot; i++) <span class="keywordflow">for</span> (d = 0; d &lt; D; d++) o_xyz(i, d) = o_xv(o_fvf-&gt;num_face(i), d);
<a name="l00095"></a>00095 <span class="preprocessor">#ifdef MEDCOUPLING_</span>
<a name="l00096"></a>00096 <span class="preprocessor"></span>  MCAuto&lt;DataArrayDouble&gt; dad(DataArrayDouble::New()), o_dad(DataArrayDouble::New());
<a name="l00097"></a>00097   dad-&gt;useExternalArrayWithRWAccess(xyz.addr(), nf_tot, D), o_dad-&gt;useExternalArrayWithRWAccess(o_xyz.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>(), o_nf_tot, D);
<a name="l00098"></a>00098 <span class="comment">// point de o_xyz le plus proche de chaque point de xyz</span>
<a name="l00099"></a>00099   MCAuto&lt;DataArrayInt&gt; idx(o_dad-&gt;findClosestTupleId(dad));
<a name="l00100"></a>00100 
<a name="l00101"></a>00101   <span class="keywordflow">for</span> (i = 0; i &lt; nf_tot; i++) <span class="comment">//remplissage : (face distante, elem distant) si coincidence, -1 sinon</span>
<a name="l00102"></a>00102     {
<a name="l00103"></a>00103       f = fvf-&gt;num_face(i), o_f = o_fvf-&gt;num_face(idx-&gt;getIJ(i, 0));
<a name="l00104"></a>00104       <span class="keywordtype">double</span> d2 = zone.<a class="code" href="classZone__CoviMAC.html#a7a5ffb545c8b97f0ed2cd0026707350f">dot</a>(&amp;xv(f, 0), &amp;xv(f, 0), &amp;o_xv(o_f, 0), &amp;o_xv(o_f, 0));
<a name="l00105"></a>00105       <span class="keywordflow">if</span> (d2 &lt; 1e-12) fe_dist_(i, 0) = o_f, fe_dist_(i, 1) = o_f_e(o_f, 0);
<a name="l00106"></a>00106       <span class="keywordflow">else</span> fe_dist_(i, 0) = fe_dist_(i, 1) = -1;
<a name="l00107"></a>00107       <span class="keywordflow">if</span> (i &lt; fvf-&gt;nb_faces() &amp;&amp; d2 &gt;= 1e-12)
<a name="l00108"></a>00108         <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">Process::exit</a>(<a class="code" href="classNom.html" title="class Nom Une chaine de caractere pour nommer les objets de TRUST">Nom</a>(<span class="stringliteral">&quot;Echange_contact_CoviMAC: missing opposite faces detected between &quot;</span>) + fvf-&gt;<a class="code" href="classNom.html#a4fcffbaa80271df0d9674f2a2751efb9" title="Renvoie *this;.">le_nom</a>() + <span class="stringliteral">&quot; and &quot;</span> + o_fvf-&gt;<a class="code" href="classNom.html#a4fcffbaa80271df0d9674f2a2751efb9" title="Renvoie *this;.">le_nom</a>()
<a name="l00109"></a>00109                       + <span class="stringliteral">&quot; ! Have you used Decouper_multi?&quot;</span>);
<a name="l00110"></a>00110     }
<a name="l00111"></a>00111 <span class="preprocessor">#else</span>
<a name="l00112"></a>00112 <span class="preprocessor"></span>  <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">Process::exit</a>(<span class="stringliteral">&quot;Echange_contact_CoviMAC : MEDCoupling is required!&quot;</span>);
<a name="l00113"></a>00113 <span class="preprocessor">#endif</span>
<a name="l00114"></a>00114 <span class="preprocessor"></span>  fe_init_ = 1;
<a name="l00115"></a>00115 }
<a name="l00116"></a>00116 
<a name="l00117"></a><a class="code" href="classEchange__contact__CoviMAC.html#a14207fa2975f52e438ac1ce21d070f5e">00117</a> <span class="keywordtype">void</span> <a class="code" href="classEchange__contact__CoviMAC.html#a14207fa2975f52e438ac1ce21d070f5e">Echange_contact_CoviMAC::harmonic_points</a>(<a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; xh, <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; wh, <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; whm)<span class="keyword"> const</span>
<a name="l00118"></a>00118 <span class="keyword"></span>{
<a name="l00119"></a>00119   <span class="keywordtype">int</span> i, f, o_f, fb, o_fb, e, o_e, nf_tot = fvf-&gt;nb_faces_tot(), d, D = <a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>, i_mono, n, m,
<a name="l00120"></a>00120                                    N = diff-&gt;equation().inconnue().valeurs().line_size(),
<a name="l00121"></a>00121                                    oN = o_diff-&gt;equation().inconnue().valeurs().line_size(), M = <a class="code" href="Double_8h.html#a1c45761573e6cbc97cfacac78d905016">max</a>(N, oN);
<a name="l00122"></a>00122   <span class="keyword">const</span> <a class="code" href="classZone__CoviMAC.html" title="class Zone_CoviMAC Classe instanciable qui derive de Zone_VF. Cette classe contient les informations ...">Zone_CoviMAC</a>&amp; zone = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classZone__CoviMAC.html" title="class Zone_CoviMAC Classe instanciable qui derive de Zone_VF. Cette classe contient les informations ...">Zone_CoviMAC</a>, fvf-&gt;zone_dis()), &amp;o_zone = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classZone__CoviMAC.html" title="class Zone_CoviMAC Classe instanciable qui derive de Zone_VF. Cette classe contient les informations ...">Zone_CoviMAC</a>, o_fvf-&gt;zone_dis());
<a name="l00123"></a>00123   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; f_e = zone.<a class="code" href="classZone__VF.html#a49d4322f5585a8fa95748ca785b70702" title="renvoie l&#39;element voisin de numface dans la direction i. i=0 : dans le sens oppose de l&#39;axe orthogona...">face_voisins</a>(), &amp;pe_ext = diff-&gt;pe_ext, &amp;fe_d = fe_dist();
<a name="l00124"></a>00124   <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; xv = zone.<a class="code" href="classZone__VF.html#a918c0885a9b67317fcce3a0535306542">xv</a>(), &amp;o_xv = o_zone.xv(), &amp;xp = zone.<a class="code" href="classZone__VF.html#a87a29f0223c71256a25ee343c9277599">xp</a>(), &amp;o_xp = o_zone.xp(), &amp;nf = zone.<a class="code" href="classZone__CoviMAC.html#a079b965aaef7bfcbb3dcd49981ba2c8d">face_normales</a>(),
<a name="l00125"></a>00125                    &amp;nu = diff-&gt;nu(), &amp;invh =  diff-&gt;invh(), &amp;o_nu = o_diff-&gt;nu(), &amp;o_invh = o_diff-&gt;invh();
<a name="l00126"></a>00126   <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; fs = zone.<a class="code" href="classZone__VF.html#a40c3382b189a4fc508cf1c3e37b04b21">face_surfaces</a>();
<a name="l00127"></a>00127   <a class="code" href="classDoubleTrav.html" title="Tableau de travail a n entrees pour n&lt;= 4 C&#39;est un DoubleTab avec allocation dans un pool de memoire g...">DoubleTrav</a> def(2), xef(2, D), lambda(2, M), lambda_t(2, M, D), xh_c(D), wh_c(2, M);
<a name="l00128"></a>00128   <span class="keywordtype">double</span> i3[3][3] = { { 1, 0, 0 }, { 0, 1, 0 }, { 0, 0, 1 }}, den;
<a name="l00129"></a>00129 
<a name="l00130"></a>00130   <span class="keywordflow">for</span> (i = 0; i &lt; nf_tot; i++) if ((o_f = fe_d(i, 0)) &gt;= 0) <span class="comment">/* il faut que la face / element de l&#39;autre cote soient presents */</span>
<a name="l00131"></a>00131       {
<a name="l00132"></a>00132         f = fvf-&gt;num_face(i), e = f_e(f, 0), o_e = fe_d(i, 1), fb = zone.<a class="code" href="classZone__VF.html#a9cfb439ce3b58852ba3beec40b2b8c4e">fbord</a>(f), o_fb = o_zone.fbord(o_f), i_mono = pe_ext(fb, 2);
<a name="l00133"></a>00133 <span class="comment">// distances / projections</span>
<a name="l00134"></a>00134         <span class="keywordflow">for</span> (def(0) = zone.<a class="code" href="classZone__CoviMAC.html#a7a5ffb545c8b97f0ed2cd0026707350f">dot</a>(&amp;xv(f, 0), &amp;nf(f, 0), &amp;xp(e, 0)) / fs(f), d = 0; d &lt; D; d++)
<a name="l00135"></a>00135           xef(0, d) = xp(e, d) + def(0) * nf(f, d) / fs(f);
<a name="l00136"></a>00136         <span class="keywordflow">for</span> (def(1) = - zone.<a class="code" href="classZone__CoviMAC.html#a7a5ffb545c8b97f0ed2cd0026707350f">dot</a>(&amp;o_xv(o_f, 0), &amp;nf(f, 0), &amp;o_xp(o_e, 0)) / fs(f), d = 0; d &lt; D; d++)
<a name="l00137"></a>00137           xef(1, d) = o_xp(o_e, d) - def(1) * nf(f, d) / fs(f);
<a name="l00138"></a>00138 <span class="comment">// diffusivites de chaque cote : partie normale, partie transverse</span>
<a name="l00139"></a>00139         <span class="keywordflow">for</span> (n = 0; n &lt;  N; n++) <span class="keywordflow">for</span> (lambda(0, n) = zone.<a class="code" href="classZone__CoviMAC.html#adb355629a4e62710130ee231b2e5866f">nu_dot</a>(&amp;nu, e, n, &amp;nf(f, 0), &amp;nf(f, 0)) / (fs(f) * fs(f)), d = 0; d &lt; D; d++)
<a name="l00140"></a>00140             lambda_t(0, n, d) = (zone.<a class="code" href="classZone__CoviMAC.html#adb355629a4e62710130ee231b2e5866f">nu_dot</a>(&amp;nu, e, n, i3[d], &amp;nf(f, 0)) - lambda(0, n) * nf(f, d)) / fs(f);
<a name="l00141"></a>00141         <span class="keywordflow">for</span> (n = 0; n &lt; oN; n++) <span class="keywordflow">for</span> (lambda(1, n) = zone.<a class="code" href="classZone__CoviMAC.html#adb355629a4e62710130ee231b2e5866f">nu_dot</a>(&amp;o_nu, o_e, n, &amp;nf(f, 0), &amp;nf(f, 0)) / (fs(f) * fs(f)), d = 0; d &lt; D; d++)
<a name="l00142"></a>00142             lambda_t(1, n, d) = (zone.<a class="code" href="classZone__CoviMAC.html#adb355629a4e62710130ee231b2e5866f">nu_dot</a>(&amp;o_nu, o_e, n, i3[d], &amp;nf(f, 0)) - lambda(1, n) * nf(f, d)) / fs(f);
<a name="l00143"></a>00143 
<a name="l00144"></a>00144         <span class="keywordflow">if</span> (invh_paroi_ || oN != N) <span class="comment">/* paroi fine ou nb de composantes differents -&gt; couplage par le flux total */</span>
<a name="l00145"></a>00145           {
<a name="l00146"></a>00146 <span class="comment">// xh_c / wh_c : point harmonique commun, correspondant a la temperature de paroi du cote du pb courant</span>
<a name="l00147"></a>00147             den = 0, xh_c = 0, wh_c = 0; <span class="comment">//denominateur des expressions, position, poids des temperatures amont/aval</span>
<a name="l00148"></a>00148             <span class="keywordflow">for</span> (n = 0; n &lt;  N; n++) <span class="keywordflow">for</span> (den += (wh_c(0, n) = lambda(0, n) / (def(0) + invh(fb, n) * lambda(0, n))), d = 0; d &lt; D; d++)
<a name="l00149"></a>00149                 xh_c(d) += (lambda(0, n) * xef(0, d) + def(0) * lambda_t(0, n, d)) / (def(0) + invh(fb, n) * lambda(0, n));
<a name="l00150"></a>00150             <span class="keywordflow">for</span> (n = 0; n &lt; oN; n++) <span class="keywordflow">for</span> (den += (wh_c(1, n) = lambda(1, n) / (def(1) + (o_invh(o_fb, n) + invh_paroi_) * lambda(1, n))), d = 0; d &lt; D; d++)
<a name="l00151"></a>00151                 xh_c(d) += (lambda(1, n) * xef(1, d) - def(1) * lambda_t(1, n, d)) / (def(1) + (o_invh(o_fb, n) + invh_paroi_) * lambda(1, n));
<a name="l00152"></a>00152             xh_c /= den, wh_c /= den; <span class="comment">//normalisation</span>
<a name="l00153"></a>00153 
<a name="l00154"></a>00154             <span class="keywordflow">for</span> (n = 0; n &lt; N; n++) <span class="keywordflow">for</span> (d = 0; d &lt; D; d++) <span class="comment">//position du point pour chaque composante -&gt; dans xh (tableau sur toutes les faces)</span>
<a name="l00155"></a>00155                 xh(f, n, d) = (def(0) * xh_c(d) + invh(fb, n) * (lambda(0, n) * xef(0, d) + def(0) * lambda_t(0, n, d))) / (def(0) + invh(fb, n) * lambda(0, n));
<a name="l00156"></a>00156             <span class="keywordflow">for</span> (n = 0; n &lt; N; n++) <span class="comment">//poids de chaque cote -&gt; dans whm</span>
<a name="l00157"></a>00157               {
<a name="l00158"></a>00158                 <span class="keywordflow">for</span> (m = 0; m &lt;  N; m++) whm(i_mono, n, m, 0) = (def(0) * wh_c(0, m) + (m == n) * invh(fb, n) * lambda(0, n)) / (def(0) + invh(fb, n) * lambda(0, n));
<a name="l00159"></a>00159                 <span class="keywordflow">for</span> (m = 0; m &lt; oN; m++) whm(i_mono, n, m, 1) = def(0) * wh_c(1, m) / (def(0) + invh(fb, n) * lambda(0, n));
<a name="l00160"></a>00160               }
<a name="l00161"></a>00161           }
<a name="l00162"></a>00162         <span class="keywordflow">else</span> <span class="keywordflow">for</span> (n = 0; n &lt; N; n++) <span class="comment">/* sinon -&gt; couplage composante par composante */</span>
<a name="l00163"></a>00163             {
<a name="l00164"></a>00164               <span class="keywordflow">for</span> (d = 0; d &lt; D; d++) <span class="comment">/* position du &quot;harmonic average point &quot;*/</span>
<a name="l00165"></a>00165                 xh(f, n, d) = (lambda(1, n) * def(0) * xef(1, d) + lambda(0, n) * def(1) * xef(0, d) + def(0) * def(1) * (lambda_t(1, n, d) - lambda_t(0, n, d)))
<a name="l00166"></a>00166                               / (lambda(1, n) * def(0) + lambda(0, n) * def(1));
<a name="l00167"></a>00167               <span class="keywordflow">for</span> (n = 0; n &lt; N; n++) <span class="keywordflow">for</span> (m = 0; m &lt; M; m++) <span class="comment">/* poids de l&#39;amont dans la valeur a ce point */</span>
<a name="l00168"></a>00168                   whm(i_mono, n, m, 0) = (m == n) * lambda(0, n) * def(1) / (lambda(1, n) * def(0) + lambda(0, n) * def(1)), whm(i_mono, n, m, 1) = (m == n) - whm(i_mono, m, n, 0);
<a name="l00169"></a>00169             }
<a name="l00170"></a>00170         <span class="keywordflow">for</span> (n = 0; n &lt; N; n++) wh(f, n) = 0; <span class="comment">//pour indiquer que la face a ete traitee</span>
<a name="l00171"></a>00171       }
<a name="l00172"></a>00172 }
<a name="l00173"></a>00173 
<a name="l00174"></a><a class="code" href="classEchange__contact__CoviMAC.html#a775c099b1736f76cbf9d15d2785fb3f9">00174</a> <span class="keywordtype">void</span> <a class="code" href="classEchange__contact__CoviMAC.html#a775c099b1736f76cbf9d15d2785fb3f9">Echange_contact_CoviMAC::fgrad</a>(<span class="keywordtype">int</span> full_stencil, <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; phif_w, <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; phif_d, <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; phif_e, <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; phif_c, <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; phif_pe, <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; phif_pc)<span class="keyword"> const</span>
<a name="l00175"></a>00175 <span class="keyword"></span>{
<a name="l00176"></a>00176   <span class="keyword">const</span> <a class="code" href="classZone__CoviMAC.html" title="class Zone_CoviMAC Classe instanciable qui derive de Zone_VF. Cette classe contient les informations ...">Zone_CoviMAC</a>&amp; zone = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classZone__CoviMAC.html" title="class Zone_CoviMAC Classe instanciable qui derive de Zone_VF. Cette classe contient les informations ...">Zone_CoviMAC</a>, fvf-&gt;zone_dis()), &amp;o_zone = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classZone__CoviMAC.html" title="class Zone_CoviMAC Classe instanciable qui derive de Zone_VF. Cette classe contient les informations ...">Zone_CoviMAC</a>, o_fvf-&gt;zone_dis());
<a name="l00177"></a>00177   o_zone.init_stencils();
<a name="l00178"></a>00178   <span class="keywordtype">int</span> i_f, i, il, ic, j, k, l, f, o_f, fb, o_fb, e, o_e, e_s, f_s, f_sb, m, m_s, n, n_max, on_max, nw, infoo = 0;
<a name="l00179"></a>00179   <span class="keywordtype">int</span> d, D = <a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>, ne_tot = zone.<a class="code" href="classZone__dis__base.html#a4d6aa445f152aa6dc54d66ea7a071147">nb_elem_tot</a>(), o_ne_tot = o_zone.nb_elem_tot();
<a name="l00180"></a>00180   <span class="keywordtype">int</span> N = phif_w.<a class="code" href="classDoubleTab.html#ac3805e2637a3b880ba2d3e650c69dac4" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(1), oN = o_diff-&gt;equation().inconnue().valeurs().line_size(), M = <a class="code" href="Double_8h.html#a1c45761573e6cbc97cfacac78d905016">max</a>(N, oN);
<a name="l00181"></a>00181   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; f_e = zone.<a class="code" href="classZone__VF.html#a49d4322f5585a8fa95748ca785b70702" title="renvoie l&#39;element voisin de numface dans la direction i. i=0 : dans le sens oppose de l&#39;axe orthogona...">face_voisins</a>(), &amp;o_f_e = o_zone.face_voisins(), &amp;fe_d = fe_dist(), &amp;pe_ext = diff-&gt;pe_ext, &amp;o_pe_ext = o_diff-&gt;pe_ext;
<a name="l00182"></a>00182   <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; xv = zone.<a class="code" href="classZone__VF.html#a918c0885a9b67317fcce3a0535306542">xv</a>(), &amp;xp = zone.<a class="code" href="classZone__VF.html#a87a29f0223c71256a25ee343c9277599">xp</a>(), &amp;o_xp = o_zone.xp(), &amp;nf = zone.<a class="code" href="classZone__CoviMAC.html#a079b965aaef7bfcbb3dcd49981ba2c8d">face_normales</a>(), &amp;o_nf = o_zone.face_normales(),
<a name="l00183"></a>00183                    &amp;nu = diff-&gt;nu(), &amp;invh = diff-&gt;invh(), &amp;o_nu = o_diff-&gt;nu(), &amp;o_invh = o_diff-&gt;invh(), &amp;xh = diff-&gt;xh(), &amp;o_xh = o_diff-&gt;xh(),
<a name="l00184"></a>00184                     &amp;wh = diff-&gt;wh(), &amp;o_wh = o_diff-&gt;wh(), &amp;whm = diff-&gt;whm(), &amp;o_whm = o_diff-&gt;whm();
<a name="l00185"></a>00185   <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; fs = zone.<a class="code" href="classZone__VF.html#a40c3382b189a4fc508cf1c3e37b04b21">face_surfaces</a>(), &amp;o_fs = o_zone.face_surfaces();
<a name="l00186"></a>00186   <span class="keywordtype">double</span> i3[3][3] = { { 1, 0, 0 }, { 0, 1, 0 }, { 0, 0, 1 }}, tphi;
<a name="l00187"></a>00187   <span class="keywordtype">char</span> trans = <span class="charliteral">&#39;N&#39;</span>;
<a name="l00188"></a>00188 
<a name="l00189"></a>00189 <span class="comment">// traduction des indices de probleme dans o_diff en indices de problemes dans diff (avec extension de op_ext si necessaire)</span>
<a name="l00190"></a>00190   std::vector&lt;int&gt; trad;
<a name="l00191"></a>00191   <span class="keywordflow">for</span> (<span class="keyword">auto</span> op : o_diff-&gt;op_ext)
<a name="l00192"></a>00192     {
<a name="l00193"></a>00193       trad.push_back(std::find(diff-&gt;op_ext.begin(), diff-&gt;op_ext.end(), op) - diff-&gt;op_ext.begin());
<a name="l00194"></a>00194       <span class="keywordflow">if</span> (trad.back() == (int) diff-&gt;op_ext.size()) diff-&gt;op_ext.push_back(op);
<a name="l00195"></a>00195     }
<a name="l00196"></a>00196 
<a name="l00197"></a>00197 <span class="comment">// verification : phif_d doit etre rempli jusqu&#39;a la premiere face de la CL, on ne doit pas demander les faces virtuelles</span>
<a name="l00198"></a>00198   assert(phif_d.<a class="code" href="classIntTab.html#abc3b32c94925a82f69d5b153a356e359" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(0) == fvf-&gt;num_face(0) + 1 &amp;&amp; phif_w.<a class="code" href="classDoubleTab.html#ac3805e2637a3b880ba2d3e650c69dac4" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(0) == zone.<a class="code" href="classZone__VF.html#aede27992d9f2eedd52c24d4a80ff7ffb" title="renvoie le nombre global de faces.">nb_faces</a>());
<a name="l00199"></a>00199 
<a name="l00200"></a>00200   std::vector&lt;std::pair&lt;int, int&gt;&gt; p_e; <span class="comment">//stencil aux elemens : { { pb, elem/bord }, ... }</span>
<a name="l00201"></a>00201   <a class="code" href="classDoubleTrav.html" title="Tableau de travail a n entrees pour n&lt;= 4 C&#39;est un DoubleTab avec allocation dans un pool de memoire g...">DoubleTrav</a> base, A , B, lambda(2, M), r_int(2, M), h(2, M), xef(2, M, D), interp,  phi, W(1); <span class="comment">//base de champs possibles, systeme A.x = B,</span>
<a name="l00202"></a>00202   base.<a class="code" href="classArrOfDouble.html#ab49f6cae96be9d3f597468d8a53b67b6" title="Change le mode l&#39;allocation memoire: reallocation d&#39;un tableau a chaque changement de taille (flag = ...">set_smart_resize</a>(1), A.<a class="code" href="classArrOfDouble.html#ab49f6cae96be9d3f597468d8a53b67b6" title="Change le mode l&#39;allocation memoire: reallocation d&#39;un tableau a chaque changement de taille (flag = ...">set_smart_resize</a>(1), B.<a class="code" href="classArrOfDouble.html#ab49f6cae96be9d3f597468d8a53b67b6" title="Change le mode l&#39;allocation memoire: reallocation d&#39;un tableau a chaque changement de taille (flag = ...">set_smart_resize</a>(1), interp.<a class="code" href="classArrOfDouble.html#ab49f6cae96be9d3f597468d8a53b67b6" title="Change le mode l&#39;allocation memoire: reallocation d&#39;un tableau a chaque changement de taille (flag = ...">set_smart_resize</a>(1), phi.<a class="code" href="classArrOfDouble.html#ab49f6cae96be9d3f597468d8a53b67b6" title="Change le mode l&#39;allocation memoire: reallocation d&#39;un tableau a chaque changement de taille (flag = ...">set_smart_resize</a>(1), W.<a class="code" href="classArrOfDouble.html#ab49f6cae96be9d3f597468d8a53b67b6" title="Change le mode l&#39;allocation memoire: reallocation d&#39;un tableau a chaque changement de taille (flag = ...">set_smart_resize</a>(1);
<a name="l00203"></a>00203   <span class="keywordflow">for</span> (i_f = 0; i_f &lt; fvf-&gt;nb_faces(); i_f++, phif_d.<a class="code" href="classIntTab.html#ac0af4eac42ca46facc05f985c3ef05c6" title="Adds 1 to dimension_tot(0) and puts a in the added line.">append_line</a>(phif_e.<a class="code" href="classIntTab.html#abc3b32c94925a82f69d5b153a356e359" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(0), phif_pe.<a class="code" href="classIntTab.html#abc3b32c94925a82f69d5b153a356e359" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(0)))
<a name="l00204"></a>00204     {
<a name="l00205"></a>00205       f = fvf-&gt;num_face(i_f), e = f_e(f, 0), o_f = fe_d(i_f, 0), o_e = fe_d(i_f, 1), fb = zone.<a class="code" href="classZone__VF.html#a9cfb439ce3b58852ba3beec40b2b8c4e">fbord</a>(f), o_fb = o_zone.fbord(o_f);
<a name="l00206"></a>00206 
<a name="l00207"></a>00207       <span class="keyword">const</span> <span class="keywordtype">int</span> *fa = &amp;zone.<a class="code" href="classZone__CoviMAC.html#ab2149ba390821ecd54c8730a4d98da6f">fsten_f</a>(zone.<a class="code" href="classZone__CoviMAC.html#af569b2bf358ef869bc39da3ef5772144">fsten_d</a>(f)), *o_fa = &amp;o_zone.fsten_f(o_zone.fsten_d(o_f)); <span class="comment">//debuts des stencils de chaque cote</span>
<a name="l00208"></a>00208       <span class="keywordtype">int</span> n_f = zone.<a class="code" href="classZone__CoviMAC.html#af569b2bf358ef869bc39da3ef5772144">fsten_d</a>(f + 1) - zone.<a class="code" href="classZone__CoviMAC.html#af569b2bf358ef869bc39da3ef5772144">fsten_d</a>(f), o_n_f = o_zone.fsten_d(o_f + 1) - o_zone.fsten_d(o_f), n_tf = n_f + o_n_f + 2, nnz, hdiag, ok = 1;
<a name="l00209"></a>00209       <span class="comment">/* verification qu&#39;on dispose de tous les points harmoniques dont on a besoin */</span>
<a name="l00210"></a>00210       <span class="keywordflow">for</span> (i = 0; i &lt;   n_f; i++) ok &amp;= (  wh(  fa[i], 0) &gt;= 0);
<a name="l00211"></a>00211       <span class="keywordflow">for</span> (i = 0; i &lt; o_n_f; i++) ok &amp;= (o_wh(o_fa[i], 0) &gt;= 0);
<a name="l00212"></a>00212       <span class="keywordflow">if</span> (!ok) <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">Process::exit</a>(<a class="code" href="classNom.html" title="class Nom Une chaine de caractere pour nommer les objets de TRUST">Nom</a>(<span class="stringliteral">&quot;Echange_contact_CoviMAC: missing face neighborhood detected between &quot;</span>) + fvf-&gt;<a class="code" href="classNom.html#a4fcffbaa80271df0d9674f2a2751efb9" title="Renvoie *this;.">le_nom</a>() + <span class="stringliteral">&quot; and &quot;</span> + o_fvf-&gt;<a class="code" href="classNom.html#a4fcffbaa80271df0d9674f2a2751efb9" title="Renvoie *this;.">le_nom</a>()
<a name="l00213"></a>00213                                + <span class="stringliteral">&quot; ! Have you used Decouper_multi?&quot;</span>);
<a name="l00214"></a>00214 
<a name="l00215"></a>00215       <span class="keywordtype">double</span> h_max[2] = { 0, }, h_tot[2] = { 0, }, dist[2] = { zone.<a class="code" href="classZone__CoviMAC.html#af95d2084d566bad62b845d8e0fe76eef">dist_norm_bord</a>(f), o_zone.dist_norm_bord(o_f) }; <span class="comment">//coeff d&#39;echange max de chaque cote, distances</span>
<a name="l00216"></a>00216 
<a name="l00217"></a>00217       <span class="comment">/* nf.lambda.nf de chaque cote + identification des phases dominantes (-&gt; diffusant le plus) */</span>
<a name="l00218"></a>00218       <span class="keyword">const</span> <span class="keywordtype">double</span> *xe; <span class="comment">//coordonnees de l&#39;amont/aval</span>
<a name="l00219"></a>00219       <span class="keywordflow">for</span> (i = 0; i &lt; 2; i++) <span class="keywordflow">for</span> (xe = i ? &amp;o_xp(o_e, 0) : &amp;xp(e, 0), n = 0; n &lt; (i ? oN : N); n++)
<a name="l00220"></a>00220           {
<a name="l00221"></a>00221             lambda(i, n) = zone.<a class="code" href="classZone__CoviMAC.html#adb355629a4e62710130ee231b2e5866f">nu_dot</a>(i ? &amp;o_nu : &amp;nu, i ? o_e : e, n, &amp;nf(f, 0), &amp;nf(f, 0)) / (fs(f) * fs(f));
<a name="l00222"></a>00222             r_int(i, n) = dist[i] / lambda(i, n);
<a name="l00223"></a>00223             <span class="keywordflow">for</span> (d = 0; d &lt; D; d++) xef(i, n, d) = xe[d] + (i ? -1 : 1) * r_int(i, n) * zone.<a class="code" href="classZone__CoviMAC.html#adb355629a4e62710130ee231b2e5866f">nu_dot</a>(i ? &amp;o_nu : &amp;nu, i ? o_e : e, n, &amp;nf(f, 0), i3[d]) / fs(f);
<a name="l00224"></a>00224             h(i, n) = 1. / (r_int(i, n) + (i ? o_invh(o_fb, n): invh(fb, n)) + invh_paroi_ / 2), h_tot[i] += h(i, n);
<a name="l00225"></a>00225             <span class="keywordflow">if</span> (h(i, n) &gt; h_max[i]) h_max[i] = h(i, n), *(i ? &amp;on_max : &amp;n_max) = n;
<a name="l00226"></a>00226           }
<a name="l00227"></a>00227 
<a name="l00228"></a>00228       <span class="comment">/* interpolation des points projetes de chaque cote */</span>
<a name="l00229"></a>00229       interp.<a class="code" href="classDoubleTab.html#ae83b4d31205c53d9c8d2b43da178ce75" title="Change la taille du vecteur (identique a resize_array() pour le traitement des anciennes valeurs et d...">resize</a>(2, M, n_tf, M); <span class="comment">//ordre des colonnes : faces de zone.fsten_f -&gt; xh local -&gt; faces de o_zone.fsten_f -&gt; xh distant</span>
<a name="l00230"></a>00230       <span class="keywordflow">for</span> (interp = 0, i = 0; i &lt; 2; i++) <span class="keywordflow">for</span> (n = 0; n &lt; (i ? oN : N); n++) interp(i, n, i ? n_tf - 1 : n_f, n) = 1;
<a name="l00231"></a>00231       <span class="keywordflow">if</span> (invh_paroi_ &gt; 0 || oN != N) <span class="comment">/* paroi fine ou nombre de composantes differents -&gt; partition du flux total */</span>
<a name="l00232"></a>00232         {
<a name="l00233"></a>00233           <span class="keywordtype">int</span> nrhs = N + oN, ng = D + N + oN - 2, nl = ng + 1, nc = N * (n_f + 1) + oN * (o_n_f + 1);
<a name="l00234"></a>00234           B.<a class="code" href="classDoubleTab.html#ae83b4d31205c53d9c8d2b43da178ce75" title="Change la taille du vecteur (identique a resize_array() pour le traitement des anciennes valeurs et d...">resize</a>(nrhs, nc), A.<a class="code" href="classDoubleTab.html#ae83b4d31205c53d9c8d2b43da178ce75" title="Change la taille du vecteur (identique a resize_array() pour le traitement des anciennes valeurs et d...">resize</a>(nc, nl), base.<a class="code" href="classDoubleTab.html#ae83b4d31205c53d9c8d2b43da178ce75" title="Change la taille du vecteur (identique a resize_array() pour le traitement des anciennes valeurs et d...">resize</a>(ng, 2, M, D), base = 0;
<a name="l00235"></a>00235           <span class="comment">/* base de gradients amont/aval */</span>
<a name="l00236"></a>00236 <span class="comment">// D premiers : diffusion dans les phases dominantes</span>
<a name="l00237"></a>00237           <span class="keywordflow">for</span> (i = 0; i &lt; D; i++) <span class="keywordflow">for</span> (j = 0; j &lt; 2; j++) <span class="keywordflow">for</span> (d = 0; d &lt; D; d++)
<a name="l00238"></a>00238                 base(i, j, j ? on_max : n_max, d) = i3[i][d] + (j ? -1 : 1) * (zone.<a class="code" href="classZone__CoviMAC.html#adb355629a4e62710130ee231b2e5866f">nu_dot</a>(&amp;o_nu, o_e, on_max, &amp;nf(f, 0), i3[i]) - zone.<a class="code" href="classZone__CoviMAC.html#adb355629a4e62710130ee231b2e5866f">nu_dot</a>(&amp;nu, e, n_max, &amp;nf(f, 0), i3[i]))
<a name="l00239"></a>00239                                                     * nf(f, d) / (2 * fs(f) * fs(f) * lambda(j, j ? on_max : n_max));
<a name="l00240"></a>00240 <span class="comment">// N + oN - 2 suivants : gradient normal dans la phase n (non dominante) d&#39;un cote, compense par la phase dominante de l&#39;autre</span>
<a name="l00241"></a>00241           <span class="keywordflow">for</span> (i--, n = 0; n &lt;  N; n++) <span class="keywordflow">if</span> (n != n_max) <span class="keywordflow">for</span> (i++, j = 0; j &lt; 2; j++) <span class="keywordflow">for</span> (d = 0; d &lt; D; d++)
<a name="l00242"></a>00242                   base(i, j, j ? on_max : n, d) = nf(f, d) / fs(f) * (j ? lambda(0, n) / lambda(1, on_max) : 1);
<a name="l00243"></a>00243           <span class="keywordflow">for</span> (n = 0; n &lt; oN; n++) <span class="keywordflow">if</span> (n != on_max) <span class="keywordflow">for</span> (i++, j = 0; j &lt; 2; j++) <span class="keywordflow">for</span> (d = 0; d &lt; D; d++)
<a name="l00244"></a>00244                   base(i, j, j ? n : n_max, d)  = nf(f, d) / fs(f) * (j ? 1 : lambda(1, n) / lambda(0, n_max));
<a name="l00245"></a>00245 
<a name="l00246"></a>00246           <span class="comment">/* seconds membres : pour les N + oN interpolations a calculer, une equation par gradient possible + une pour la constante */</span>
<a name="l00247"></a>00247           <span class="keywordflow">for</span> (B = 0, i = 0, j = 0; i &lt; 2; i++) <span class="keywordflow">for</span> (n = 0; n &lt; (i ? oN : N); n++, j++) <span class="keywordflow">for</span> (k = 0; k &lt; nl; k++)
<a name="l00248"></a>00248                 B(j, k) = k &lt; ng ? zone.<a class="code" href="classZone__CoviMAC.html#a7a5ffb545c8b97f0ed2cd0026707350f">dot</a>(&amp;xef(i, n, 0), &amp;base(k, i, n, 0), i ? &amp;o_xh(o_f, n, 0) : &amp;xh(f, n, 0)) : 0;
<a name="l00249"></a>00249 
<a name="l00250"></a>00250           <span class="comment">/* poids par defaut : pt harmonique du bon cote */</span>
<a name="l00251"></a>00251           <span class="keywordflow">if</span> (std::pow(1e6 * <a class="code" href="DoubleVect_8cpp.html#aad339141fa6027fa3b627825a2407c12">local_max_abs_vect</a>(B), D - 1) &gt; fs(f)) <span class="comment">//pts projetes distants des pts harmoniques -&gt; recherche d&#39;interpolation</span>
<a name="l00252"></a>00252             {
<a name="l00253"></a>00253               <span class="comment">/* matrice */</span>
<a name="l00254"></a>00254               <span class="keywordflow">for</span> (i = 0, ic = 0; i &lt;= n_f; i++) <span class="keywordflow">for</span> (n = 0; n &lt; N; n++, ic++) <span class="keywordflow">for</span> (il = 0; il &lt;= ng; il++) <span class="comment">//cote interne</span>
<a name="l00255"></a>00255                     A(ic, il) = il &lt; ng ? zone.<a class="code" href="classZone__CoviMAC.html#a7a5ffb545c8b97f0ed2cd0026707350f">dot</a>(&amp;xh(i &lt; n_f ? fa[i] : f, n, 0), &amp;base(il, 0, n, 0), &amp;xv(f, 0))
<a name="l00256"></a>00256                                 + (invh(fb, n) + invh_paroi_ / 2) * zone.<a class="code" href="classZone__CoviMAC.html#adb355629a4e62710130ee231b2e5866f">nu_dot</a>(&amp;nu, e, n, &amp;nf(f, 0), &amp;base(il, 0, n, 0)) / fs(f) : 1;
<a name="l00257"></a>00257               <span class="keywordflow">for</span> (i = 0; i &lt;= o_n_f; i++) <span class="keywordflow">for</span> (n = 0; n &lt; oN; n++, ic++) <span class="keywordflow">for</span> (il = 0; il &lt;= ng; il++) <span class="comment">//cote externe</span>
<a name="l00258"></a>00258                     A(ic, il) = il &lt; ng ? zone.<a class="code" href="classZone__CoviMAC.html#a7a5ffb545c8b97f0ed2cd0026707350f">dot</a>(&amp;o_xh(i &lt; o_n_f ? o_fa[i] : o_f, n, 0), &amp;base(il, 1, n, 0), &amp;xv(f, 0))
<a name="l00259"></a>00259                                 - (o_invh(o_fb, n) + invh_paroi_ / 2) * zone.<a class="code" href="classZone__CoviMAC.html#adb355629a4e62710130ee231b2e5866f">nu_dot</a>(&amp;o_nu, o_e, n, &amp;nf(f, 0), &amp;base(il, 1, n, 0)) / fs(f) : 1;
<a name="l00260"></a>00260 
<a name="l00261"></a>00261               <span class="comment">/* resolution */</span>
<a name="l00262"></a>00262               nw = -1, <a class="code" href="arch_8h.html#a9b91c72ded7de2f0b393ea75de53929b">F77NAME</a>(dgels)(&amp;trans, &amp;nl, &amp;nc, &amp;nrhs, &amp;A(0, 0), &amp;nl, &amp;B(0, 0), &amp;nc, &amp;W(0), &amp;nw, &amp;infoo);
<a name="l00263"></a>00263               W.<a class="code" href="classDoubleTab.html#ae83b4d31205c53d9c8d2b43da178ce75" title="Change la taille du vecteur (identique a resize_array() pour le traitement des anciennes valeurs et d...">resize</a>(nw = W(0)), <a class="code" href="arch_8h.html#a9b91c72ded7de2f0b393ea75de53929b">F77NAME</a>(dgels)(&amp;trans, &amp;nl, &amp;nc, &amp;nrhs, &amp;A(0, 0), &amp;nl, &amp;B(0, 0), &amp;nc, &amp;W(0), &amp;nw, &amp;infoo);
<a name="l00264"></a>00264 
<a name="l00265"></a>00265               <span class="comment">/* correction de interp (avec ecretage) */</span>
<a name="l00266"></a>00266               <span class="keywordflow">for</span> (i = 0, j = 0; i &lt; 2; i++) <span class="keywordflow">for</span> (n = 0; n &lt; (i ? oN : N); n++, j++) <span class="keywordflow">for</span> (k = 0, il = 0; k &lt; n_tf; k++)
<a name="l00267"></a>00267                     <span class="keywordflow">for</span> (m = 0; m &lt; (k &gt; n_f ? oN : N); m++, il++) interp(i, n, k, m) += <a class="code" href="Double_8h.html#aaecd4ca8a2fe69cc6568af2938b94d2e">dabs</a>(B(j, il)) &gt; 1e-8 ? B(j, il) : 0;
<a name="l00268"></a>00268             }
<a name="l00269"></a>00269         }
<a name="l00270"></a>00270       <span class="keywordflow">else</span> <span class="keywordflow">for</span> (n = 0; n &lt; N; n++) <span class="comment">/* sinon -&gt; composante par composante */</span>
<a name="l00271"></a>00271           {
<a name="l00272"></a>00272             <span class="keywordtype">int</span> nrhs = 2, nl = D + 1, nc = n_tf;
<a name="l00273"></a>00273             B.<a class="code" href="classDoubleTab.html#ae83b4d31205c53d9c8d2b43da178ce75" title="Change la taille du vecteur (identique a resize_array() pour le traitement des anciennes valeurs et d...">resize</a>(nrhs, nc), A.<a class="code" href="classDoubleTab.html#ae83b4d31205c53d9c8d2b43da178ce75" title="Change la taille du vecteur (identique a resize_array() pour le traitement des anciennes valeurs et d...">resize</a>(nc, nl), base.<a class="code" href="classDoubleTab.html#ae83b4d31205c53d9c8d2b43da178ce75" title="Change la taille du vecteur (identique a resize_array() pour le traitement des anciennes valeurs et d...">resize</a>(2, D, D);
<a name="l00274"></a>00274             <span class="comment">/* base : base de &quot;vecteurs tests&quot; amont/aval d&#39;un gradient verifiant nf.nu_am.vec_am = nf.nu_av.vec_av */</span>
<a name="l00275"></a>00275             <span class="keywordflow">for</span> (i = 0; i &lt; 2; i++) <span class="keywordflow">for</span> (j = 0; j &lt; D; j++) <span class="keywordflow">for</span> (d = 0; d &lt; D; d++)
<a name="l00276"></a>00276                   base(i, j, d) = i3[j][d] + (i ? -1 : 1) * (zone.<a class="code" href="classZone__CoviMAC.html#adb355629a4e62710130ee231b2e5866f">nu_dot</a>(&amp;o_nu, o_e, n, &amp;nf(f, 0), i3[j]) - zone.<a class="code" href="classZone__CoviMAC.html#adb355629a4e62710130ee231b2e5866f">nu_dot</a>(&amp;nu, e, n, &amp;nf(f, 0), i3[j])) * nf(f, d) / (2 * lambda(i, n) * fs(f) * fs(f));
<a name="l00277"></a>00277 
<a name="l00278"></a>00278             <span class="comment">/* seconds membres : au passage, on calcule la resistance interne r = d / lambda */</span>
<a name="l00279"></a>00279             <span class="keywordflow">for</span> (B = 0, i = 0; i &lt; 2; i++) <span class="keywordflow">for</span> (d = 0; d &lt; D; d++)
<a name="l00280"></a>00280                 B(i, d) = (i ? o_xp(o_e, d) : xp(e, d)) + (i ? -1 : 1) * r_int(i, n) * zone.<a class="code" href="classZone__CoviMAC.html#adb355629a4e62710130ee231b2e5866f">nu_dot</a>(i ? &amp;o_nu : &amp;nu, i ? o_e : e, n, &amp;nf(f, 0), i3[d]) / fs(f) - xh(f, n, d);
<a name="l00281"></a>00281 
<a name="l00282"></a>00282             <span class="comment">/* interpolation des points projetes amont / aval */</span>
<a name="l00283"></a>00283             <span class="keywordflow">if</span> (std::pow(1e6 * <a class="code" href="DoubleVect_8cpp.html#aad339141fa6027fa3b627825a2407c12">local_max_abs_vect</a>(B), D - 1) &gt; fs(f)) <span class="comment">//si les pts projetes ne sont pas dessus -&gt; corrections</span>
<a name="l00284"></a>00284               {
<a name="l00285"></a>00285                 <span class="comment">/* matrice */</span>
<a name="l00286"></a>00286                 <span class="keywordflow">for</span> (i = 0, ic = 0; i &lt;= n_f; i++, ic++) <span class="keywordflow">for</span> (il = 0; il &lt;= D; il++) <span class="comment">//cote interne</span>
<a name="l00287"></a>00287                     A(ic, il) = il &lt; D ? zone.<a class="code" href="classZone__CoviMAC.html#a7a5ffb545c8b97f0ed2cd0026707350f">dot</a>(&amp;xh(i &lt; n_f ? fa[i] : f, n, 0), &amp;base(0, il, 0), &amp;xv(f, 0))
<a name="l00288"></a>00288                                 + (invh(fb, n) + invh_paroi_ / 2) * zone.<a class="code" href="classZone__CoviMAC.html#adb355629a4e62710130ee231b2e5866f">nu_dot</a>(&amp;nu, e, n, &amp;nf(f, 0), &amp;base(0, il, 0)) / fs(f) : 1;
<a name="l00289"></a>00289                 <span class="keywordflow">for</span> (i = 0; i &lt;= o_n_f; i++, ic++) <span class="keywordflow">for</span> (il = 0; il &lt;= D; il++) <span class="comment">//cote externe</span>
<a name="l00290"></a>00290                     A(ic, il) = il &lt; D ? zone.<a class="code" href="classZone__CoviMAC.html#a7a5ffb545c8b97f0ed2cd0026707350f">dot</a>(&amp;o_xh(i &lt; o_n_f ? o_fa[i] : o_f, n, 0), &amp;base(1, il, 0), &amp;xv(f, 0))
<a name="l00291"></a>00291                                 - (o_invh(o_fb, n) + invh_paroi_ / 2) * zone.<a class="code" href="classZone__CoviMAC.html#adb355629a4e62710130ee231b2e5866f">nu_dot</a>(&amp;o_nu, o_e, n, &amp;nf(f, 0), &amp;base(1, il, 0)) / fs(f) : 1;
<a name="l00292"></a>00292 
<a name="l00293"></a>00293                 <span class="comment">/* resolution */</span>
<a name="l00294"></a>00294                 nw = -1, <a class="code" href="arch_8h.html#a9b91c72ded7de2f0b393ea75de53929b">F77NAME</a>(dgels)(&amp;trans, &amp;nl, &amp;nc, &amp;nrhs, &amp;A(0, 0), &amp;nl, &amp;B(0, 0), &amp;nc, &amp;W(0), &amp;nw, &amp;infoo);
<a name="l00295"></a>00295                 W.<a class="code" href="classDoubleTab.html#ae83b4d31205c53d9c8d2b43da178ce75" title="Change la taille du vecteur (identique a resize_array() pour le traitement des anciennes valeurs et d...">resize</a>(nw = W(0)), <a class="code" href="arch_8h.html#a9b91c72ded7de2f0b393ea75de53929b">F77NAME</a>(dgels)(&amp;trans, &amp;nl, &amp;nc, &amp;nrhs, &amp;A(0, 0), &amp;nl, &amp;B(0, 0), &amp;nc, &amp;W(0), &amp;nw, &amp;infoo);
<a name="l00296"></a>00296                 <span class="comment">/* correction de interp (avec ecretage) */</span>
<a name="l00297"></a>00297                 <span class="keywordflow">for</span> (i = 0; i &lt; 2; i++) for (j = 0; j &lt; nc; j++) interp(i, n, j, n) += dabs(B(i, j)) &gt; 1e-8 ? B(i, j) : 0;
<a name="l00298"></a>00298               }
<a name="l00299"></a>00299 
<a name="l00300"></a>00300           }
<a name="l00301"></a>00301 
<a name="l00302"></a>00302       <span class="comment">/* stencil aux elements */</span>
<a name="l00303"></a>00303       <span class="keywordflow">for</span> (p_e.clear(), i = 0; i &lt; n_f; i++) <span class="keywordflow">for</span> (f_s = fa[i], f_sb = zone.<a class="code" href="classZone__VF.html#a9cfb439ce3b58852ba3beec40b2b8c4e">fbord</a>(f_s), j = 0; j &lt; 2; j++) <span class="comment">//cote interne</span>
<a name="l00304"></a>00304           <span class="keywordflow">if</span> ((e_s = f_e(f_s, j)) &gt;= 0) p_e.push_back({ 0, e_s }); <span class="comment">//element normal</span>
<a name="l00305"></a>00305           <span class="keywordflow">else</span> <span class="keywordflow">if</span> (f_sb &gt;= 0 &amp;&amp; (e_s = pe_ext(f_sb, 1)) &gt;= 0) p_e.push_back({ pe_ext(f_sb, 0), e_s }); <span class="comment">//de l&#39;autre cote d&#39;un Echange_contact</span>
<a name="l00306"></a>00306           <span class="keywordflow">else</span> <span class="keywordflow">if</span> (f_sb &gt;= 0) p_e.push_back({ 0, ne_tot + f_s }); <span class="comment">//CL non Echange_contact -&gt; dependance en les valeurs aux bords</span>
<a name="l00307"></a>00307       <span class="keywordflow">for</span> (i = 0; i &lt; o_n_f; i++) <span class="keywordflow">for</span> (f_s = o_fa[i], f_sb = o_zone.fbord(f_s), j = 0; j &lt; 2; j++) <span class="comment">//cote externe</span>
<a name="l00308"></a>00308           <span class="keywordflow">if</span> ((e_s = o_f_e(f_s, j)) &gt;= 0) p_e.push_back({ trad[0], e_s }); <span class="comment">//element normal</span>
<a name="l00309"></a>00309           <span class="keywordflow">else</span> <span class="keywordflow">if</span> (f_sb &gt;= 0 &amp;&amp; (e_s = o_pe_ext(f_sb, 1)) &gt;= 0) p_e.push_back({ trad[o_pe_ext(f_sb, 0)], e_s }); <span class="comment">//de l&#39;autre cote d&#39;un Echange_contact</span>
<a name="l00310"></a>00310           <span class="keywordflow">else</span> <span class="keywordflow">if</span> (f_sb &gt;= 0) p_e.push_back({ trad[0], o_ne_tot + f_s }); <span class="comment">//CL non Echange_contact -&gt; dependance en les valeurs aux bords</span>
<a name="l00311"></a>00311       <a class="code" href="AssembleurPP1BUtil_8cpp.html#acff816d35f8d4ce978f860e0cd958b8a">std::sort</a>(p_e.begin(), p_e.end()), p_e.erase(std::unique(p_e.begin(), p_e.end()), p_e.end()); <span class="comment">//classement + deduplication</span>
<a name="l00312"></a>00312 
<a name="l00313"></a>00313       <span class="comment">/* flux par composante */</span>
<a name="l00314"></a>00314       phi.resize(p_e.size(), M, M, 2), phi = 0;
<a name="l00315"></a>00315 <span class="comment">// dependances points amont/aval</span>
<a name="l00316"></a>00316       <span class="keywordflow">for</span> (i = 0; i &lt; 2; i++) <span class="keywordflow">for</span> (k = std::lower_bound(p_e.begin(), p_e.end(), std::make_pair(i ? trad[0] : 0, i ? o_e : e)) - p_e.begin(), n = 0; n &lt; (i ? oN : N); n++)
<a name="l00317"></a>00317           phi(k, n, n, i) += (i ? 1 : -1) / r_int(i, n);
<a name="l00318"></a>00318 
<a name="l00319"></a>00319 <span class="comment">// dependances cote local</span>
<a name="l00320"></a>00320       <span class="keywordflow">for</span> (i = 0; i &lt;= n_f; i++) <span class="keywordflow">for</span> (f_s = i &lt; n_f ? fa[i] : f, f_sb = zone.fbord(f_s), j = 0; j &lt; 2; j++)
<a name="l00321"></a>00321           <span class="keywordflow">if</span> ((e_s = f_e(f_s, j) &gt;= 0 ? f_e(f_s, j) : f_sb &gt;= 0 &amp;&amp; pe_ext(f_sb, 0) &gt;= 0 ? pe_ext(f_sb, 1) : -1) &gt;= 0) <span class="comment">//il existe un element source</span>
<a name="l00322"></a>00322             {
<a name="l00323"></a>00323               k = std::lower_bound(p_e.begin(), p_e.end(), std::make_pair(f_e(f_s, j) &gt;= 0 ? 0 : pe_ext(f_sb, 0), e_s)) - p_e.begin();
<a name="l00324"></a>00324               <span class="keywordflow">if</span> (f_sb &lt; 0 || pe_ext(f_sb, 0) &lt; 0) <span class="keywordflow">for</span> (l = 0; l &lt; 2; l++) <span class="keywordflow">for</span> (n = 0; n &lt; (l ? oN : N); n++) <span class="keywordflow">for</span> (m = 0; m &lt; wh.dimension(1); m++) <span class="comment">//pt harmonique normal : dependance diagonale</span>
<a name="l00325"></a>00325                       phi(k, n, m, l) += (l ? -1 : 1) / r_int(l, n) * interp(l, n, i, m) * (j ? 1 - wh(f_s, m) : wh(f_s, m));
<a name="l00326"></a>00326               <span class="keywordflow">else</span> <span class="keywordflow">for</span> (l = 0; l &lt; 2; l++) <span class="keywordflow">for</span> (n = 0; n &lt; (l ? oN : N); n++) <span class="keywordflow">for</span> (m = 0; m &lt; whm.dimension(1); m++) <span class="keywordflow">for</span> (m_s = 0; m_s &lt; whm.dimension(2); m_s++) <span class="comment">//pt harmonique d&#39;Echange_contact : melange...</span>
<a name="l00327"></a>00327                         phi(k, n, m_s, l) += (l ? -1 : 1) / r_int(l, n) * interp(l, n, i, m) * whm(pe_ext(f_sb, 2), m, m_s, j);
<a name="l00328"></a>00328             }
<a name="l00329"></a>00329           <span class="keywordflow">else</span> <span class="keywordflow">for</span> (k = std::find(p_e.begin(), p_e.end(), std::make_pair((<span class="keywordtype">int</span>)0, ne_tot + f_s)) - p_e.begin(), l = 0; l &lt; 2; l++) <span class="comment">//pas d&#39;elem source -&gt; dependance en la CL</span>
<a name="l00330"></a>00330               <span class="keywordflow">for</span> (n = 0; n &lt; (l ? oN : N); n++) <span class="keywordflow">for</span> (m = 0; m &lt; wh.dimension(1); m++)
<a name="l00331"></a>00331                   phi(k, n, m, l) += (l ? -1 : 1) / r_int(l, n) * interp(l, n, i, m)
<a name="l00332"></a>00332                                      * (wh(f_s, m) &lt; 1 ? 1 - wh(f_s, m) : - zone.dist_norm_bord(f_s) * fs(f_s) * fs(f_s) / zone.nu_dot(&amp;nu, f_e(f_s, 0), m, &amp;nf(f_s, 0), &amp;nf(f_s, 0)));
<a name="l00333"></a>00333 
<a name="l00334"></a>00334 <span class="comment">// dependances cote distant</span>
<a name="l00335"></a>00335       <span class="keywordflow">for</span> (i = n_f + 1; i &lt; n_tf; i++) <span class="keywordflow">for</span> (f_s = i &lt; n_tf - 1 ? o_fa[i - (n_f + 1)] : o_f, f_sb = o_zone.fbord(f_s), j = 0; j &lt; 2; j++)
<a name="l00336"></a>00336           <span class="keywordflow">if</span> ((e_s = o_f_e(f_s, j) &gt;= 0 ? o_f_e(f_s, j) : f_sb &gt;= 0 &amp;&amp; o_pe_ext(f_sb, 0) &gt;= 0 ? o_pe_ext(f_sb, 1) : -1) &gt;= 0) <span class="comment">//il existe un element source</span>
<a name="l00337"></a>00337             {
<a name="l00338"></a>00338               k = std::lower_bound(p_e.begin(), p_e.end(), std::make_pair(trad[o_f_e(f_s, j) &gt;= 0 ? 0 : o_pe_ext(f_sb, 0)], e_s)) - p_e.begin();
<a name="l00339"></a>00339               <span class="keywordflow">if</span> (f_sb &lt; 0 || o_pe_ext(f_sb, 0) &lt; 0) <span class="keywordflow">for</span> (l = 0; l &lt; 2; l++) <span class="keywordflow">for</span> (n = 0; n &lt; (l ? oN : N); n++) <span class="keywordflow">for</span> (m = 0; m &lt; o_wh.dimension(1); m++) <span class="comment">//pt harmonique normal : dependance diagonale</span>
<a name="l00340"></a>00340                       phi(k, n, m, l) += (l ? -1 : 1) / r_int(l, n) * interp(l, n, i, m) * (j ? 1 - o_wh(f_s, m) : o_wh(f_s, m));
<a name="l00341"></a>00341               <span class="keywordflow">else</span> <span class="keywordflow">for</span> (l = 0; l &lt; 2; l++) <span class="keywordflow">for</span> (n = 0; n &lt; (l ? oN : N); n++) <span class="keywordflow">for</span> (m = 0; m &lt; o_whm.dimension(1); m++) <span class="keywordflow">for</span> (m_s = 0; m_s &lt; o_whm.dimension(2); m_s++) <span class="comment">//pt harmonique d&#39;Echange_contact : melange...</span>
<a name="l00342"></a>00342                         phi(k, n, m_s, l) += (l ? -1 : 1) / r_int(l, n) * interp(l, n, i, m) * o_whm(o_pe_ext(f_sb, 2), m, m_s, j);
<a name="l00343"></a>00343             }
<a name="l00344"></a>00344           <span class="keywordflow">else</span> <span class="keywordflow">for</span> (k = std::find(p_e.begin(), p_e.end(), std::make_pair(trad[0], o_ne_tot + f_s)) - p_e.begin(), l = 0; l &lt; 2; l++) <span class="comment">//pas d&#39;elem source -&gt; dependance en la CL</span>
<a name="l00345"></a>00345               <span class="keywordflow">for</span> (n = 0; n &lt; (l ? oN : N); n++) <span class="keywordflow">for</span> (m = 0; m &lt; o_wh.dimension(1); m++)
<a name="l00346"></a>00346                   phi(k, n, m, l) += (l ? -1 : 1) / r_int(l, n) * interp(l, n, i, m)
<a name="l00347"></a>00347                                      * (o_wh(f_s, m) &lt; 1 ? 1 - o_wh(f_s, m) : - o_zone.dist_norm_bord(f_s) * o_fs(f_s) * o_fs(f_s) / o_zone.nu_dot(&amp;o_nu, o_f_e(f_s, 0), m, &amp;o_nf(f_s, 0), &amp;o_nf(f_s, 0)));
<a name="l00348"></a>00348 
<a name="l00349"></a>00349       <span class="keywordflow">if</span> (invh_paroi_ &gt; 0 || oN != N) <span class="comment">/* paroi fine ou nombre de composantes differents -&gt; calcul du flux total, puis partition entre composantes */</span>
<a name="l00350"></a>00350         {
<a name="l00351"></a>00351           <span class="keywordflow">for</span> (n = 0; n &lt; N; n++) phif_w(f, n) = h_tot[1] / (h_tot[0] + h_tot[1]); <span class="comment">//poids amont/aval : par le flux total</span>
<a name="l00352"></a>00352           <span class="keywordflow">for</span> (i = 0; i &lt; (int) p_e.size(); i++) <span class="keywordflow">for</span> (m = 0; m &lt; M; m++) <span class="keywordflow">for</span> (j = 0; j &lt; 2; j++)
<a name="l00353"></a>00353                 {
<a name="l00354"></a>00354                   <span class="keywordflow">for</span> (tphi = 0, n = 0; n &lt; (j ? oN : N); n++) tphi += phi(i, n, m, j); <span class="comment">//contrib de l&#39;item i au flux total</span>
<a name="l00355"></a>00355                   <span class="keywordflow">for</span> (n = 0; n &lt; (j ? oN : N); n++) phi(i, n, m, j) = h(0, n) / h_tot[0] * tphi; <span class="comment">//re-repartition</span>
<a name="l00356"></a>00356                 }
<a name="l00357"></a>00357         }
<a name="l00358"></a>00358       <span class="keywordflow">else</span> <span class="keywordflow">for</span> (n = 0; n &lt; N; n++) phif_w(f, n) = h(1, n) / (h(0, n) + h(1, n)); <span class="comment">//poids amont/aval : par composante</span>
<a name="l00359"></a>00359 
<a name="l00360"></a>00360       <span class="comment">/* remplissage */</span>
<a name="l00361"></a>00361       <span class="keywordflow">for</span> (i = 0; i &lt; (int) p_e.size(); i++)
<a name="l00362"></a>00362         {
<a name="l00363"></a>00363           <span class="keywordflow">for</span> (nnz = 0, hdiag = 0, n = 0; n &lt; N; n++) <span class="keywordflow">for</span> (m = 0; m &lt; M; m++) <span class="keywordflow">for</span> (j = 0; j &lt; 2; j++) <span class="keywordflow">if</span> (phi(i, n, m, j) != 0) nnz++, hdiag += (n != m);
<a name="l00364"></a>00364           <span class="keywordflow">if</span> (!nnz &amp;&amp; !full_stencil) <span class="keywordflow">continue</span>; <span class="comment">//on peut sauter cette dependance</span>
<a name="l00365"></a>00365           <span class="keywordflow">if</span> (p_e[i].first == 0 &amp;&amp; hdiag == 0) <span class="comment">//coeffs diagonaux et probleme local -&gt; phif_e / phif_c</span>
<a name="l00366"></a>00366             <span class="keywordflow">for</span> (phif_e.append_line(p_e[i].second), phif_c.resize((k = phif_c.dimension(0)) + 1, N, 2), n = 0; n &lt; N; n++) <span class="keywordflow">for</span> (j = 0; j &lt; 2; j++)
<a name="l00367"></a>00367                 phif_c(k, n, j) = phi(i, n, n, j);
<a name="l00368"></a>00368           <span class="keywordflow">else</span> <span class="keywordflow">for</span> (phif_pe.append_line(p_e[i].first, p_e[i].second), phif_pc.resize((k = phif_pc.dimension(0)) + 1, N, M, 2), n = 0; n &lt; N; n++) <span class="keywordflow">for</span> (m = 0; m &lt; M; m++) <span class="keywordflow">for</span> (j = 0; j &lt; 2; j++)
<a name="l00369"></a>00369                   phif_pc(k, n, m, j) = phi(i, n, m, j); <span class="comment">//sinon -&gt; phif_pe / phif_pc</span>
<a name="l00370"></a>00370         }
<a name="l00371"></a>00371     }
<a name="l00372"></a>00372 }
<a name="l00373"></a>00373 
</pre></div></div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Tue Dec 14 2021 19:35:09 for TRUST by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
