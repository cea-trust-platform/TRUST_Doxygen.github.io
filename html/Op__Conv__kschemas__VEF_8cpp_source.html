<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>TRUST: src/VEF/Operateurs/Op_Conv_kschemas_VEF.cpp Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">TRUST&#160;<span id="projectnumber">1.8.4</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
<div class="header">
  <div class="headertitle">
<div class="title">src/VEF/Operateurs/Op_Conv_kschemas_VEF.cpp</div>  </div>
</div>
<div class="contents">
<a href="Op__Conv__kschemas__VEF_8cpp.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/****************************************************************************</span>
<a name="l00002"></a>00002 <span class="comment">* Copyright (c) 2021, CEA</span>
<a name="l00003"></a>00003 <span class="comment">* All rights reserved.</span>
<a name="l00004"></a>00004 <span class="comment">*</span>
<a name="l00005"></a>00005 <span class="comment">* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</span>
<a name="l00006"></a>00006 <span class="comment">* 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.</span>
<a name="l00007"></a>00007 <span class="comment">* 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.</span>
<a name="l00008"></a>00008 <span class="comment">* 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.</span>
<a name="l00009"></a>00009 <span class="comment">*</span>
<a name="l00010"></a>00010 <span class="comment">* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.</span>
<a name="l00011"></a>00011 <span class="comment">* IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;</span>
<a name="l00012"></a>00012 <span class="comment">* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>
<a name="l00013"></a>00013 <span class="comment">*</span>
<a name="l00014"></a>00014 <span class="comment">*****************************************************************************/</span>
<a name="l00015"></a>00015 <span class="comment">//</span>
<a name="l00016"></a>00016 <span class="comment">// </span>
<a name="l00017"></a>00017 <span class="comment">// File:        Op_Conv_kschemas_VEF.cpp</span>
<a name="l00018"></a>00018 <span class="comment">// Directory:   $TRUST_ROOT/src/VEF/Operateurs</span>
<a name="l00019"></a>00019 <span class="comment">// Version:     /main/26</span>
<a name="l00020"></a>00020 <span class="comment">// </span>
<a name="l00021"></a>00021 <span class="comment">//</span>
<a name="l00022"></a>00022 
<a name="l00023"></a>00023 <span class="preprocessor">#include &lt;<a class="code" href="Op__Conv__kschemas__VEF_8h.html">Op_Conv_kschemas_VEF.h</a>&gt;</span>
<a name="l00024"></a>00024 
<a name="l00025"></a><a class="code" href="Op__Conv__kschemas__VEF_8cpp.html#afd8453167353b84f7a6b8263e45571b3">00025</a> <a class="code" href="Declare__Base_8h.html#ad0be56e3a9cdd8f6dafc3864627fea86">Implemente_base</a>(<a class="code" href="classOp__Conv__kschemas__VEF.html" title="class Op_Conv_kschemas_VEF Cette classe represente l&#39;operateur de convection associe a une equation d...">Op_Conv_kschemas_VEF</a>,<span class="stringliteral">&quot;Op_Conv_kschemas_VEF_P1NC&quot;</span>,<a class="code" href="classOp__Conv__VEF__base.html" title="class Op_Conv_VEF_base Classe de base des operateurs de convection VEF">Op_Conv_VEF_base</a>);
<a name="l00026"></a>00026 
<a name="l00027"></a>00027 <span class="comment"></span>
<a name="l00028"></a>00028 <span class="comment">////!&lt; printOn </span>
<a name="l00029"></a>00029 <span class="comment"></span><span class="comment">//</span>
<a name="l00030"></a>00030 
<a name="l00031"></a><a class="code" href="classOp__Conv__kschemas__VEF.html#af3b5c4e682a8bb339b6a8b6bc5dfeaae">00031</a> <a class="code" href="classSortie.html" title="Classe de base des flux de sortie. Elle sait ecrire des types simples&lt;br&gt;(entiers, flottants) et des Ob...">Sortie</a>&amp; <a class="code" href="classOp__Conv__kschemas__VEF.html#af3b5c4e682a8bb339b6a8b6bc5dfeaae" title="NE FAIT RIEN A surcharger dans les classes derivees.">Op_Conv_kschemas_VEF::printOn</a>(<a class="code" href="classSortie.html" title="Classe de base des flux de sortie. Elle sait ecrire des types simples&lt;br&gt;(entiers, flottants) et des Ob...">Sortie</a>&amp; s )<span class="keyword"> const</span>
<a name="l00032"></a>00032 <span class="keyword"></span>{
<a name="l00033"></a>00033   <span class="keywordflow">return</span> s &lt;&lt; <a class="code" href="classObjet__U.html#aa58e9a81c0ddc2c1149053b8f96698ac" title="renvoie la chaine identifiant la classe.">que_suis_je</a>() ;
<a name="l00034"></a>00034 }
<a name="l00035"></a>00035 <span class="comment"></span>
<a name="l00036"></a>00036 <span class="comment">////!&lt; readOn </span>
<a name="l00037"></a>00037 <span class="comment"></span><span class="comment">//</span>
<a name="l00038"></a>00038 
<a name="l00039"></a><a class="code" href="classOp__Conv__kschemas__VEF.html#ab8fbf8e5a86111b9bd4d131264a5ec88">00039</a> <a class="code" href="classEntree.html" title="Classe de definition des operateurs et methodes pour toute lecture dans un flot d&#39;entree (fichier...">Entree</a>&amp; <a class="code" href="classOp__Conv__kschemas__VEF.html#ab8fbf8e5a86111b9bd4d131264a5ec88" title="NE FAIT RIEN A surcharger dans les classes derivees.">Op_Conv_kschemas_VEF::readOn</a>(<a class="code" href="classEntree.html" title="Classe de definition des operateurs et methodes pour toute lecture dans un flot d&#39;entree (fichier...">Entree</a>&amp; s )
<a name="l00040"></a>00040 {
<a name="l00041"></a>00041   <span class="keywordflow">return</span> s ;
<a name="l00042"></a>00042 }
<a name="l00043"></a>00043 
<a name="l00044"></a>00044 <span class="comment">// </span>
<a name="l00045"></a>00045 <span class="comment">// Fonctions de la classe Op_Conv_kschemas_VEF</span>
<a name="l00046"></a>00046 <span class="comment">// </span>
<a name="l00047"></a><a class="code" href="classOp__Conv__kschemas__VEF.html#aedbfc8f0119e2c205de2dfe0edc98432">00047</a> <span class="keywordtype">void</span> <a class="code" href="classOp__Conv__kschemas__VEF.html#aedbfc8f0119e2c205de2dfe0edc98432">Op_Conv_kschemas_VEF::associer</a>(<span class="keyword">const</span> <a class="code" href="classZone__dis.html" title="classe Zone_dis Classe generique de la hierarchie des zones discretisees. Un objet de type Zone_dis p...">Zone_dis</a>&amp; zone_dis,
<a name="l00048"></a>00048                                     <span class="keyword">const</span> <a class="code" href="classZone__Cl__dis.html" title="classe Zone_Cl_dis Classe generique de la hierarchie des conditions aux limites discretisees. Un objet Zone_Cl_dis peut referencer n&#39;importe quel derivant de Zone_Cl_dis_base. La plupart des methodes appellent les methodes de l&#39;objet Probleme sous-jacent via la methode valeur() declaree grace a la macro Declare_deriv().;">Zone_Cl_dis</a>&amp; zone_cl_dis,
<a name="l00049"></a>00049                                     <span class="keyword">const</span> <a class="code" href="classChamp__Inc.html">Champ_Inc</a>&amp; ch )
<a name="l00050"></a>00050 {
<a name="l00051"></a>00051 <span class="comment">// CCa le 28/05/99 Le schema Kquick ne marche pas en paralle !!</span>
<a name="l00052"></a>00052   <span class="keywordflow">if</span>(<a class="code" href="classProcess.html#a6bf692ce58d9578aa62ac3c07b8caaa1" title="renvoie le nombre de processeurs dans le groupe courant Voir Comm_Group::nproc() et PE_Groups::curren...">Process::nproc</a>()&gt;1)
<a name="l00053"></a>00053     {
<a name="l00054"></a>00054       <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a>&lt;&lt;<span class="stringliteral">&quot;ATTENTION le kquick ne marche pas en parallele !!!&quot;</span>&lt;&lt;<a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
<a name="l00055"></a>00055       <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">exit</a>();
<a name="l00056"></a>00056     }
<a name="l00057"></a>00057 
<a name="l00058"></a>00058   <a class="code" href="classOp__Conv__kschemas__VEF.html#aedbfc8f0119e2c205de2dfe0edc98432">Op_Conv_VEF_base::associer</a>(zone_dis,zone_cl_dis,ch);
<a name="l00059"></a>00059 }
<a name="l00060"></a>00060 
<a name="l00061"></a>00061 
<a name="l00062"></a>00062 <span class="comment">//</span>
<a name="l00063"></a>00063 <span class="comment">// Fonctions pour les kschemas.</span>
<a name="l00064"></a>00064 <span class="comment">//</span>
<a name="l00065"></a>00065 
<a name="l00066"></a>00066 <span class="comment">// convkschemas : fonction utilitaire pour la convection</span>
<a name="l00067"></a>00067 
<a name="l00068"></a><a class="code" href="Op__Conv__kschemas__VEF_8cpp.html#a8b19f29166e833578e5f3d160894dac7">00068</a> <span class="keywordtype">void</span> <a class="code" href="Op__Conv__kschemas__VEF_8cpp.html#a8b19f29166e833578e5f3d160894dac7">convkschemas</a>(<span class="keyword">const</span> <span class="keywordtype">double</span> K, <span class="keyword">const</span> <span class="keywordtype">int</span> ncomp, <span class="keywordtype">int</span> dimension, <span class="keyword">const</span> <span class="keywordtype">int</span> poly ,
<a name="l00069"></a>00069                   <span class="keyword">const</span> <span class="keywordtype">int</span> poly1, <span class="keyword">const</span> <span class="keywordtype">int</span> poly2,<span class="keyword">const</span> <span class="keywordtype">int</span> jel0,
<a name="l00070"></a>00070                   <span class="keyword">const</span> <span class="keywordtype">int</span> jel1,<span class="keyword">const</span> <span class="keywordtype">double</span>&amp; psc ,<span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; tab1 ,
<a name="l00071"></a>00071                   <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; fluent, <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; flux,
<a name="l00072"></a>00072                   <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; rx0, <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; gradient_elem )
<a name="l00073"></a>00073 {
<a name="l00074"></a>00074 
<a name="l00075"></a>00075   <span class="keywordtype">int</span> comp,amont,i,elem1,elem2;
<a name="l00076"></a>00076   <span class="keywordtype">double</span> CF,UTC,deltat0,deltat1,deltat;
<a name="l00077"></a>00077   <a class="code" href="classDoubleVect.html">DoubleVect</a> rx(dimension);
<a name="l00078"></a>00078   deltat0 = 0.;
<a name="l00079"></a>00079   deltat1 = 0.;
<a name="l00080"></a>00080 
<a name="l00081"></a>00081 <span class="comment">//</span>
<a name="l00082"></a>00082 <span class="comment">// Test sur les bords</span>
<a name="l00083"></a>00083 <span class="comment">//</span>
<a name="l00084"></a>00084   <span class="keywordflow">if</span> ((poly1==-1) || (poly2==-1))
<a name="l00085"></a>00085     {
<a name="l00086"></a>00086       <span class="keywordflow">if</span> (psc &gt;= 0)
<a name="l00087"></a>00087         {
<a name="l00088"></a>00088           amont = jel0;
<a name="l00089"></a>00089           fluent[jel1] += psc;
<a name="l00090"></a>00090         }
<a name="l00091"></a>00091       <span class="keywordflow">else</span>
<a name="l00092"></a>00092         {
<a name="l00093"></a>00093           amont = jel1;
<a name="l00094"></a>00094           fluent[jel0] -= psc;
<a name="l00095"></a>00095         }
<a name="l00096"></a>00096 
<a name="l00097"></a>00097       <span class="keywordflow">for</span> (comp=0; comp&lt;ncomp; comp++)
<a name="l00098"></a>00098         flux(comp) = tab1(amont,comp);
<a name="l00099"></a>00099 
<a name="l00100"></a>00100     }
<a name="l00101"></a>00101   <span class="keywordflow">else</span>
<a name="l00102"></a>00102     {
<a name="l00103"></a>00103       <span class="keywordflow">if</span> (psc &gt;= 0)
<a name="l00104"></a>00104         {
<a name="l00105"></a>00105           amont = jel0;
<a name="l00106"></a>00106           rx = rx0;
<a name="l00107"></a>00107           elem1 = poly;
<a name="l00108"></a>00108           elem2 = poly1;
<a name="l00109"></a>00109           fluent(jel1)  += psc;
<a name="l00110"></a>00110         }
<a name="l00111"></a>00111       <span class="keywordflow">else</span>
<a name="l00112"></a>00112         {
<a name="l00113"></a>00113           amont = jel1;
<a name="l00114"></a>00114           rx = rx0;
<a name="l00115"></a>00115           rx *= -1.;
<a name="l00116"></a>00116           elem1 = poly;
<a name="l00117"></a>00117           elem2 = poly2;
<a name="l00118"></a>00118           fluent(jel0)  -= psc;
<a name="l00119"></a>00119         }
<a name="l00120"></a>00120 
<a name="l00121"></a>00121       <span class="keywordflow">for</span> (comp=0; comp&lt;ncomp; comp++)
<a name="l00122"></a>00122         {
<a name="l00123"></a>00123           deltat0 = deltat1 = 0.0;
<a name="l00124"></a>00124           flux(comp) = tab1(amont,comp);
<a name="l00125"></a>00125 <span class="comment">// Cerr &lt;&lt; &quot; flux(&quot; &lt;&lt; comp &lt;&lt; &quot;) ie phiamont= &quot; &lt;&lt;  flux(comp) &lt;&lt; finl;</span>
<a name="l00126"></a>00126 
<a name="l00127"></a>00127           <span class="keywordflow">for</span> (i=0; i&lt;dimension; i++)
<a name="l00128"></a>00128             {
<a name="l00129"></a>00129               deltat0 += gradient_elem(elem1,comp,i)*rx(i);
<a name="l00130"></a>00130               deltat1 += gradient_elem(elem2,comp,i)*rx(i);
<a name="l00131"></a>00131             }
<a name="l00132"></a>00132 
<a name="l00133"></a>00133           <span class="keywordflow">if</span> (K == 0.5)
<a name="l00134"></a>00134             {
<a name="l00135"></a>00135               deltat = deltat0 + deltat1;
<a name="l00136"></a>00136 
<a name="l00137"></a>00137               <span class="keywordflow">if</span>  (<a class="code" href="Double_8h.html#aaecd4ca8a2fe69cc6568af2938b94d2e">dabs</a>(deltat) &lt;= 1.e-5)
<a name="l00138"></a>00138                 {
<a name="l00139"></a>00139                   CF = 0.125;
<a name="l00140"></a>00140                 }
<a name="l00141"></a>00141               <span class="keywordflow">else</span>
<a name="l00142"></a>00142                 {
<a name="l00143"></a>00143                   UTC = deltat1 / deltat;
<a name="l00144"></a>00144 
<a name="l00145"></a>00145                   <span class="keywordflow">if</span> ( (UTC &lt;= -1.) || (UTC &gt;= 1.5) )      CF = 0.125;
<a name="l00146"></a>00146                   <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((UTC &gt; -1.) &amp;&amp; (UTC &lt;= 0.))     CF = 0.5 + 0.375*UTC;
<a name="l00147"></a>00147                   <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((UTC &gt; 0.) &amp;&amp; (UTC &lt;= 0.25))    CF = 0.5 - 0.625*sqrt(UTC);
<a name="l00148"></a>00148                   <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((UTC &gt; 0.25) &amp;&amp; (UTC &lt; 1.5 ))   CF = 0.25* <a class="code" href="Double_8h.html#aaecd4ca8a2fe69cc6568af2938b94d2e">dabs</a>(UTC - 1.);
<a name="l00149"></a>00149                   <span class="keywordflow">else</span>
<a name="l00150"></a>00150                     {
<a name="l00151"></a>00151                       CF=0.;
<a name="l00152"></a>00152                       <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">Process::exit</a>();
<a name="l00153"></a>00153                     }
<a name="l00154"></a>00154                 }
<a name="l00155"></a>00155 <span class="comment">// Calcul du flux</span>
<a name="l00156"></a>00156               flux(comp) += (0.5 - CF)*deltat0 + CF*deltat1 ;
<a name="l00157"></a>00157 <span class="comment">// Cerr &lt;&lt; &quot; flux(&quot; &lt;&lt; comp &lt;&lt; &quot;)= &quot; &lt;&lt;  flux(comp) &lt;&lt; finl;</span>
<a name="l00158"></a>00158             }
<a name="l00159"></a>00159           <span class="keywordflow">else</span>
<a name="l00160"></a>00160             {
<a name="l00161"></a>00161 <span class="comment">// Calcul du flux</span>
<a name="l00162"></a>00162               flux(comp) += 0.25*((1.+K)*deltat0 + (1.-K)*deltat1) ;
<a name="l00163"></a>00163             }
<a name="l00164"></a>00164         }
<a name="l00165"></a>00165 
<a name="l00166"></a>00166     }
<a name="l00167"></a>00167 }
<a name="l00168"></a>00168 
<a name="l00169"></a>00169 <span class="comment">//</span>
<a name="l00170"></a>00170 <span class="comment">// Procedure AJOUTER</span>
<a name="l00171"></a>00171 <span class="comment">//</span>
<a name="l00172"></a>00172 
<a name="l00173"></a><a class="code" href="classOp__Conv__kschemas__VEF.html#a5e31481a700610f5b4fd6bbce8b760f5">00173</a> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; <a class="code" href="classOp__Conv__kschemas__VEF.html#a5e31481a700610f5b4fd6bbce8b760f5">Op_Conv_kschemas_VEF::ajouter</a>(<span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; transporte,
<a name="l00174"></a>00174                                          <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; resu)<span class="keyword"> const</span>
<a name="l00175"></a>00175 <span class="keyword"></span>{
<a name="l00176"></a>00176   <span class="keyword">const</span> <a class="code" href="classZone__Cl__VEF.html">Zone_Cl_VEF</a>&amp; zone_Cl_VEF = <a class="code" href="classOp__Conv__VEF__base.html#a03f677ee7911706a4f85cd37e0ca4535">la_zcl_vef</a>.<a class="code" href="classRef__Zone__Cl__VEF.html#a0970d7253def65ad4f0c5ce1830fd243">valeur</a>();
<a name="l00177"></a>00177   <span class="keyword">const</span> <a class="code" href="classZone__VEF.html" title="class Zone_VEF Classe instanciable qui derive de Zone_VF. Cette classe contient les informations geom...">Zone_VEF</a>&amp; zone_VEF = <a class="code" href="classOp__Conv__VEF__base.html#a6c29a488a6805ba4a9f2f059cdba77ae">la_zone_vef</a>.<a class="code" href="classRef__Zone__VEF.html#aafd9a5ee1a76f290c9c6b5447b0c8d30">valeur</a>();
<a name="l00178"></a>00178   <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; porosite_face = zone_VEF.<a class="code" href="classZone__VF.html#ad9d74d1d9da9f50ab26768dbbca7711b">porosite_face</a>();
<a name="l00179"></a>00179   <span class="keyword">const</span> <a class="code" href="classChamp__Inc__base.html" title="Classe Champ_Inc_base Classe de base des champs inconnues qui sont les champs calcules par une equati...">Champ_Inc_base</a>&amp; la_vitesse=<a class="code" href="classOp__Conv__VEF__base.html#a5547875832fb45e09b1115372fb76ffd">vitesse_</a>.<a class="code" href="classRef__Champ__Inc__base.html#a17553641a4c06730e1562125e07b3490">valeur</a>();
<a name="l00180"></a>00180   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; elem_faces = zone_VEF.<a class="code" href="classZone__VF.html#a067e462dcd3ab92b0f6d945b19e4eb37" title="renvoie le numero de le ieme face de la maille num_elem la facon dont ces faces sont numerotees est l...">elem_faces</a>();
<a name="l00181"></a>00181   <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; face_normales = zone_VEF.<a class="code" href="classZone__VEF.html#a5742d75972e4846bf9fbb6ed5715053e">face_normales</a>();
<a name="l00182"></a>00182   <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; facette_normales = zone_VEF.<a class="code" href="classZone__VEF.html#a581b1ca0e62c668c92f104351d19fda6">facette_normales</a>();
<a name="l00183"></a>00183   <span class="keyword">const</span> <a class="code" href="classZone.html" title="classe Zone Une Zone est un maillage compose d&#39;un ensemble d&#39;elements geometriques de meme type...">Zone</a>&amp; zone = zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>();
<a name="l00184"></a>00184   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_faces = zone_VEF.<a class="code" href="classZone__VF.html#aede27992d9f2eedd52c24d4a80ff7ffb" title="renvoie le nombre global de faces.">nb_faces</a>();
<a name="l00185"></a>00185   <span class="keyword">const</span> <span class="keywordtype">int</span> nfa7 = zone_VEF.<a class="code" href="classZone__VEF.html#a46693c060b8096fb2595ca72192eea2a">type_elem</a>().<a class="code" href="classElem__VEF.html#a4a34777c0083b38dd34c8a400d5b4e90">nb_facette</a>();
<a name="l00186"></a>00186   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_elem = zone_VEF.<a class="code" href="classZone__dis__base.html#a790cb2f6bc2928518799e748313d0eb3">nb_elem</a>();
<a name="l00187"></a>00187   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_elem_tot = zone_VEF.<a class="code" href="classZone__dis__base.html#a4d6aa445f152aa6dc54d66ea7a071147">nb_elem_tot</a>();
<a name="l00188"></a>00188   <span class="keyword">const</span> <a class="code" href="classIntVect.html">IntVect</a>&amp; rang_elem_non_std = zone_VEF.<a class="code" href="classZone__VEF.html#a4b2171a85e5fc33663a3366acb713584">rang_elem_non_std</a>();
<a name="l00189"></a>00189   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; face_voisins = zone_VEF.<a class="code" href="classZone__VF.html#a49d4322f5585a8fa95748ca785b70702" title="renvoie l&#39;element voisin de numface dans la direction i. i=0 : dans le sens oppose de l&#39;axe orthogona...">face_voisins</a>();
<a name="l00190"></a>00190   <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; volumes = zone_VEF.<a class="code" href="classZone__VF.html#aea771c835e561469d2d21dbca5fac1cf" title="renvoie le volume de la maille i.">volumes</a>();
<a name="l00191"></a>00191   <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; xv = zone_VEF.<a class="code" href="classZone__VF.html#a918c0885a9b67317fcce3a0535306542">xv</a>();
<a name="l00192"></a>00192   <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; xg = zone_VEF.<a class="code" href="classZone__VF.html#a87a29f0223c71256a25ee343c9277599">xp</a>();
<a name="l00193"></a>00193   <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; coord = zone.<a class="code" href="classZone.html#a379ad2206b5a13a4f4f3df6d44c7546a" title="Renvoie le domaine dont la zone fait partie. (version const)">domaine</a>().<a class="code" href="classDomaine.html#aecd32c3eecc15cce7d1a0e468dadbf96" title="Renvoie le tableau des coordonnees des noeuds (sommets). (acces en lecture)">coord_sommets</a>();
<a name="l00194"></a>00194   <span class="keywordtype">int</span> premiere_face_int = zone_VEF.<a class="code" href="classZone__VF.html#a12869806fa4834aca8f2964e16509dfd" title="une face est interne ssi elle separe deux elements. renvoie le numero de la premiere face interne...">premiere_face_int</a>();
<a name="l00195"></a>00195   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; les_Polys = zone.<a class="code" href="classZone.html#ac115e8342be89afb882b7b61cc343267" title="Renvoie le tableau des sommets des elements.">les_elems</a>();
<a name="l00196"></a>00196 
<a name="l00197"></a>00197   <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; normales_facettes_Cl = zone_Cl_VEF.<a class="code" href="classZone__Cl__VEF.html#a83c05e82370553470ed05f10932e0f3f">normales_facettes_Cl</a>();
<a name="l00198"></a>00198 
<a name="l00199"></a>00199   <span class="keywordtype">int</span> nfac = zone.<a class="code" href="classZone.html#a548fbc7518be2f122b1a5c9589a443c2" title="Renvoie le nombre de face de type i des elements geometriques constituants la zone. Ex: les objets de la classe Prisme ont 2 types de faces: triangle ou quadrangle.">nb_faces_elem</a>();
<a name="l00200"></a>00200   <span class="keywordtype">int</span> nsom = zone.<a class="code" href="classZone.html#ae0b34a93b9ae8146df2d1884157afe9f" title="Renvoie le nombre de sommets des elements geometriques constituants la zone. Tous les elements de la ...">nb_som_elem</a>();
<a name="l00201"></a>00201   <span class="keywordtype">int</span> nb_som_facette = zone.<a class="code" href="classZone.html#a18cf83cd0f9c368dcfa32fb802a0ac94" title="Renvoie un element geometrique du type de ceux qui constituent la zone. (version const)">type_elem</a>().<a class="code" href="classElem__geom.html#ab55aa8b4ec6aa60cfde5d5fc134c5333" title="Appel a l&#39;objet sous-jacent Renvoie le nombre de sommets des faces du type specifie.">nb_som_face</a>();
<a name="l00202"></a>00202   <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; fluent_ = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classDoubleVect.html">DoubleVect</a>, <a class="code" href="classOp__Conv__VEF__base.html#a32b54e8fd5340e238cf4f28ff6e743ec" title="tableau qui sert pour le calcul du pas de temps de stabilite">fluent</a>);
<a name="l00203"></a>00203 
<a name="l00204"></a>00204 <span class="comment">// Pour le traitement de la convection on distingue les polyedres</span>
<a name="l00205"></a>00205 <span class="comment">// standard qui ne &quot;voient&quot; pas les conditions aux limites et les</span>
<a name="l00206"></a>00206 <span class="comment">// polyedres non standard qui ont au moins une face sur le bord.</span>
<a name="l00207"></a>00207 <span class="comment">// Un polyedre standard a n facettes sur lesquelles on applique le</span>
<a name="l00208"></a>00208 <span class="comment">// schema de convection.</span>
<a name="l00209"></a>00209 <span class="comment">// Pour un polyedre non standard qui porte des conditions aux limites</span>
<a name="l00210"></a>00210 <span class="comment">// de Dirichlet, une partie des facettes sont portees par les faces.</span>
<a name="l00211"></a>00211 <span class="comment">// En bref pour un polyedre le traitement de la convection depend</span>
<a name="l00212"></a>00212 <span class="comment">// du type (triangle, tetraedre ...) et du nombre de faces de Dirichlet.</span>
<a name="l00213"></a>00213 
<a name="l00214"></a>00214   <span class="keywordtype">double</span> psc;
<a name="l00215"></a>00215   <span class="keywordtype">int</span> poly,poly1,poly2,face_adj,fa7,i,j,n_bord;
<a name="l00216"></a>00216   <span class="keywordtype">int</span> num_face, rang ,itypcl;
<a name="l00217"></a>00217   <span class="keywordtype">int</span> num10,num20,num3,num_som;
<a name="l00218"></a>00218 
<a name="l00219"></a>00219 <span class="comment">// MODIF SB su 10/09/03</span>
<a name="l00220"></a>00220 <span class="comment">// Pour les 3 elements suivants, il y a autant de sommets que de face</span>
<a name="l00221"></a>00221 <span class="comment">// constituant l&#39;element geometrique</span>
<a name="l00222"></a>00222 <span class="comment">// PB avec les hexa, 8 sommets et 6 faces, donc l&#39;utilisation du tableau</span>
<a name="l00223"></a>00223 <span class="comment">// face[i] ne fonctionne plus</span>
<a name="l00224"></a>00224 <span class="comment">// la methode retenue pour eviter de calculer la vitesse aux sommets sans</span>
<a name="l00225"></a>00225 <span class="comment">// les fonctions de forme n&#39;est donc pas utilisable,</span>
<a name="l00226"></a>00226 <span class="comment">// pour l&#39;hexa on n&#39;a pas acces a la face.</span>
<a name="l00227"></a>00227 <span class="comment">// il existe le tableau Face=&gt;sommets mais pas l&#39;inverse.</span>
<a name="l00228"></a>00228 <span class="comment">// trop couteux et pour le moment on n&#39;etend pas les porosites aux hexa</span>
<a name="l00229"></a>00229 
<a name="l00230"></a>00230   <span class="keywordtype">int</span> istetra=0;
<a name="l00231"></a>00231   <span class="keyword">const</span> <a class="code" href="classElem__VEF__base.html">Elem_VEF_base</a>&amp; type_elemvef= zone_VEF.<a class="code" href="classZone__VEF.html#a46693c060b8096fb2595ca72192eea2a">type_elem</a>().<a class="code" href="classDeriv__Elem__VEF__base.html#a2886905d5071be902c77248b69ca0b7b">valeur</a>();
<a name="l00232"></a>00232   <a class="code" href="classNom.html" title="class Nom Une chaine de caractere pour nommer les objets de TRUST">Nom</a> nom_elem=type_elemvef.<a class="code" href="classObjet__U.html#aa58e9a81c0ddc2c1149053b8f96698ac" title="renvoie la chaine identifiant la classe.">que_suis_je</a>();
<a name="l00233"></a>00233   <span class="keywordflow">if</span> ((nom_elem==<span class="stringliteral">&quot;Tetra_VEF&quot;</span>)||(nom_elem==<span class="stringliteral">&quot;Tri_VEF&quot;</span>)) istetra=1;
<a name="l00234"></a>00234 
<a name="l00235"></a>00235   <span class="keyword">const</span> <span class="keywordtype">int</span> ncomp_ch_transporte= transporte.<a class="code" href="classDoubleVect.html#ab02d01cd1bdab66fbd66f9a47cc29e10">line_size</a>();
<a name="l00236"></a>00236   <span class="keywordtype">int</span> fac,elem1,elem2,comp0;
<a name="l00237"></a>00237   <span class="keywordtype">int</span> nb_faces_ = zone_VEF.<a class="code" href="classZone__VF.html#aede27992d9f2eedd52c24d4a80ff7ffb" title="renvoie le nombre global de faces.">nb_faces</a>();
<a name="l00238"></a>00238   <a class="code" href="classIntVect.html">IntVect</a> face(nfac);
<a name="l00239"></a>00239 
<a name="l00240"></a>00240   <a class="code" href="classDoubleVect.html">DoubleVect</a> flux(ncomp_ch_transporte);
<a name="l00241"></a>00241   <a class="code" href="classDoubleVect.html">DoubleVect</a> fluxsom(ncomp_ch_transporte);
<a name="l00242"></a>00242   <a class="code" href="classDoubleVect.html">DoubleVect</a> fluxg(ncomp_ch_transporte);
<a name="l00243"></a>00243 
<a name="l00244"></a>00244 <span class="comment">// Traitement particulier pour les faces de periodicite</span>
<a name="l00245"></a>00245   <span class="keywordtype">int</span> nb_faces_perio = 0;
<a name="l00246"></a>00246   <span class="keywordflow">for</span> (n_bord=0; n_bord&lt;zone_VEF.<a class="code" href="classZone__dis__base.html#af22167d614644f55591a29c77eb1c009">nb_front_Cl</a>(); n_bord++)
<a name="l00247"></a>00247     {
<a name="l00248"></a>00248       <span class="keyword">const</span> <a class="code" href="classCond__lim.html" title="classe Cond_lim Classe generique servant a representer n&#39;importe quelle classe derivee de la classe C...">Cond_lim</a>&amp; la_cl = zone_Cl_VEF.<a class="code" href="classZone__Cl__dis__base.html#af75e0ed7786863e4d333bfb29d67c323" title="Renvoie la i-ieme condition aux limites. (version const)">les_conditions_limites</a>(n_bord);
<a name="l00249"></a>00249       <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>()))
<a name="l00250"></a>00250         {
<a name="l00251"></a>00251           <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp; le_bord = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>,la_cl.<a class="code" href="classCond__lim.html#a5b2d24809cee07727006a891d4ce8d22" title="Appel a l&#39;objet sous-jacent Renvoie la frontiere discretisee associee a la condition aux limites...">frontiere_dis</a>());
<a name="l00252"></a>00252           <span class="keywordtype">int</span> num1 = le_bord.<a class="code" href="classFront__VF.html#a4986f0c65653fe9eb40bbbff5a97bf16" title="Numero de la premiere face du bord dans la liste des faces.">num_premiere_face</a>();
<a name="l00253"></a>00253           <span class="keywordtype">int</span> num2 = num1 + le_bord.<a class="code" href="classFront__VF.html#a341e2fcb5117b96e745fd7078ba86bab" title="Nombre de faces reelles du bord.">nb_faces</a>();
<a name="l00254"></a>00254           <span class="keywordflow">for</span> (num_face=num1; num_face&lt;num2; num_face++)
<a name="l00255"></a>00255             nb_faces_perio++;
<a name="l00256"></a>00256         }
<a name="l00257"></a>00257     }
<a name="l00258"></a>00258 
<a name="l00259"></a>00259   <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a> tab(nb_faces_perio,ncomp_ch_transporte);
<a name="l00260"></a>00260 
<a name="l00261"></a>00261   nb_faces_perio=0;
<a name="l00262"></a>00262   <span class="keywordflow">for</span> (n_bord=0; n_bord&lt;zone_VEF.<a class="code" href="classZone__dis__base.html#af22167d614644f55591a29c77eb1c009">nb_front_Cl</a>(); n_bord++)
<a name="l00263"></a>00263     {
<a name="l00264"></a>00264       <span class="keyword">const</span> <a class="code" href="classCond__lim.html" title="classe Cond_lim Classe generique servant a representer n&#39;importe quelle classe derivee de la classe C...">Cond_lim</a>&amp; la_cl = zone_Cl_VEF.<a class="code" href="classZone__Cl__dis__base.html#af75e0ed7786863e4d333bfb29d67c323" title="Renvoie la i-ieme condition aux limites. (version const)">les_conditions_limites</a>(n_bord);
<a name="l00265"></a>00265       <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>()))
<a name="l00266"></a>00266         {
<a name="l00267"></a>00267           <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp; le_bord = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>,la_cl.<a class="code" href="classCond__lim.html#a5b2d24809cee07727006a891d4ce8d22" title="Appel a l&#39;objet sous-jacent Renvoie la frontiere discretisee associee a la condition aux limites...">frontiere_dis</a>());
<a name="l00268"></a>00268           <span class="keywordtype">int</span> num1 = le_bord.<a class="code" href="classFront__VF.html#a4986f0c65653fe9eb40bbbff5a97bf16" title="Numero de la premiere face du bord dans la liste des faces.">num_premiere_face</a>();
<a name="l00269"></a>00269           <span class="keywordtype">int</span> num2 = num1 + le_bord.<a class="code" href="classFront__VF.html#a341e2fcb5117b96e745fd7078ba86bab" title="Nombre de faces reelles du bord.">nb_faces</a>();
<a name="l00270"></a>00270           <span class="keywordflow">for</span> (num_face=num1; num_face&lt;num2; num_face++)
<a name="l00271"></a>00271             {
<a name="l00272"></a>00272               <span class="keywordflow">for</span> (<span class="keywordtype">int</span> comp=0; comp&lt;ncomp_ch_transporte; comp++)
<a name="l00273"></a>00273                 tab(nb_faces_perio,comp) = resu(num_face,comp);
<a name="l00274"></a>00274               nb_faces_perio++;
<a name="l00275"></a>00275             }
<a name="l00276"></a>00276         }
<a name="l00277"></a>00277     }
<a name="l00278"></a>00278 
<a name="l00279"></a>00279 
<a name="l00280"></a>00280 <span class="comment">//</span>
<a name="l00281"></a>00281 <span class="comment">// &lt;</span>
<a name="l00282"></a>00282 <span class="comment">// calcul des gradients;  &lt; [ Ujp*np/vol(j) ]</span>
<a name="l00283"></a>00283 <span class="comment">// j</span>
<a name="l00284"></a>00284 <span class="comment">//</span>
<a name="l00285"></a>00285   <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a> gradient_elem(0, ncomp_ch_transporte, <a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>);
<a name="l00286"></a>00286   zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#a600fa15a19c7e1384564dffd83ecab4d" title="creation d&#39;un tableau parallele de valeurs aux elements. Voir MD_Vector_tools::creer_tableau_distribu...">creer_tableau_elements</a>(gradient_elem);
<a name="l00287"></a>00287 <span class="comment">// Boucle sur les faces</span>
<a name="l00288"></a>00288 
<a name="l00289"></a>00289 
<a name="l00290"></a>00290   <span class="keywordflow">for</span> (fac=0; fac&lt; premiere_face_int; fac++)
<a name="l00291"></a>00291     {
<a name="l00292"></a>00292       elem1=face_voisins(fac,0);
<a name="l00293"></a>00293       <span class="keywordflow">if</span>(ncomp_ch_transporte==1)
<a name="l00294"></a>00294         <span class="keywordflow">for</span> (i=0; i&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; i++)
<a name="l00295"></a>00295           {
<a name="l00296"></a>00296             gradient_elem(elem1, 0, i) +=
<a name="l00297"></a>00297               face_normales(fac,i)*transporte(fac);
<a name="l00298"></a>00298           }
<a name="l00299"></a>00299       <span class="keywordflow">else</span>
<a name="l00300"></a>00300         <span class="keywordflow">for</span> (comp0=0; comp0&lt;ncomp_ch_transporte; comp0++)
<a name="l00301"></a>00301           <span class="keywordflow">for</span> (i=0; i&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; i++)
<a name="l00302"></a>00302             gradient_elem(elem1, comp0, i) +=
<a name="l00303"></a>00303               face_normales(fac,i)*transporte(fac,comp0);
<a name="l00304"></a>00304 <span class="comment">// dUcomp/dXi</span>
<a name="l00305"></a>00305     } <span class="comment">//!&lt; fin du for faces</span>
<a name="l00306"></a>00306 <span class="comment"></span>
<a name="l00307"></a>00307   <span class="keywordflow">for</span> (; fac&lt;nb_faces_; fac++)
<a name="l00308"></a>00308     {
<a name="l00309"></a>00309       elem1=face_voisins(fac,0);
<a name="l00310"></a>00310       elem2=face_voisins(fac,1);
<a name="l00311"></a>00311       <span class="keywordflow">if</span>(ncomp_ch_transporte==1)
<a name="l00312"></a>00312         <span class="keywordflow">for</span> (i=0; i&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; i++)
<a name="l00313"></a>00313           {
<a name="l00314"></a>00314             gradient_elem(elem1, 0, i) +=
<a name="l00315"></a>00315               face_normales(fac,i)*transporte(fac);
<a name="l00316"></a>00316             gradient_elem(elem2, 0, i) -=
<a name="l00317"></a>00317               face_normales(fac,i)*transporte(fac);
<a name="l00318"></a>00318           }
<a name="l00319"></a>00319       <span class="keywordflow">else</span>
<a name="l00320"></a>00320         <span class="keywordflow">for</span> (comp0=0; comp0&lt;ncomp_ch_transporte; comp0++)
<a name="l00321"></a>00321           <span class="keywordflow">for</span> (i=0; i&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; i++)
<a name="l00322"></a>00322             {
<a name="l00323"></a>00323               gradient_elem(elem1, comp0, i) +=
<a name="l00324"></a>00324                 face_normales(fac,i)*transporte(fac,comp0);
<a name="l00325"></a>00325               gradient_elem(elem2, comp0, i) -=
<a name="l00326"></a>00326                 face_normales(fac,i)*transporte(fac,comp0);
<a name="l00327"></a>00327             }
<a name="l00328"></a>00328 <span class="comment">// dUcomp/dXi</span>
<a name="l00329"></a>00329     } <span class="comment">//!&lt; fin du for faces</span>
<a name="l00330"></a>00330 <span class="comment"></span>
<a name="l00331"></a>00331   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> elem=0; elem&lt;nb_elem; elem++)
<a name="l00332"></a>00332     <span class="keywordflow">for</span> (comp0=0; comp0&lt;ncomp_ch_transporte; comp0++)
<a name="l00333"></a>00333       <span class="keywordflow">for</span> (i=0; i&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; i++)
<a name="l00334"></a>00334         gradient_elem(elem,comp0,i) /= volumes(elem);
<a name="l00335"></a>00335 
<a name="l00336"></a>00336   gradient_elem.<a class="code" href="classDoubleVect.html#abfebbc2f685ce7bc4b80c720d7da9bf3">echange_espace_virtuel</a>();
<a name="l00337"></a>00337 
<a name="l00338"></a>00338 <span class="comment">//</span>
<a name="l00339"></a>00339 <span class="comment">// On a les gradient_elem par elements</span>
<a name="l00340"></a>00340 <span class="comment">//</span>
<a name="l00341"></a>00341 
<a name="l00342"></a>00342   <a class="code" href="classDoubleVect.html">DoubleVect</a> vs(dimension);
<a name="l00343"></a>00343   <a class="code" href="classDoubleVect.html">DoubleVect</a> vc(dimension);
<a name="l00344"></a>00344   <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a> vsom(nsom,dimension);
<a name="l00345"></a>00345   <a class="code" href="classDoubleVect.html">DoubleVect</a> cc(dimension);
<a name="l00346"></a>00346   <span class="keywordtype">double</span> xm;
<a name="l00347"></a>00347 
<a name="l00348"></a>00348 <span class="comment">// On remet a zero le tableau qui sert pour</span>
<a name="l00349"></a>00349 <span class="comment">// le calcul du pas de temps de stabilite</span>
<a name="l00350"></a>00350   fluent_ = 0;
<a name="l00351"></a>00351 
<a name="l00352"></a>00352 <span class="comment">// Les polyedres non standard sont ranges en 2 groupes dans la Zone_VEF:</span>
<a name="l00353"></a>00353 <span class="comment">// - polyedres bords et joints</span>
<a name="l00354"></a>00354 <span class="comment">// - polyedres bords et non joints</span>
<a name="l00355"></a>00355 <span class="comment">// On traite les polyedres en suivant l&#39;ordre dans lequel ils figurent</span>
<a name="l00356"></a>00356 <span class="comment">// dans la zone</span>
<a name="l00357"></a>00357 
<a name="l00358"></a>00358 <span class="comment">//</span>
<a name="l00359"></a>00359 <span class="comment">// boucle sur les polys</span>
<a name="l00360"></a>00360 <span class="comment">//</span>
<a name="l00361"></a>00361   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; KEL=zone_VEF.<a class="code" href="classZone__VEF.html#a46693c060b8096fb2595ca72192eea2a">type_elem</a>().<a class="code" href="classDeriv__Elem__VEF__base.html#a2886905d5071be902c77248b69ca0b7b">valeur</a>().<a class="code" href="classElem__VEF__base.html#ab129610ef702aa8c9c98dcb4c7551172">KEL</a>();
<a name="l00362"></a>00362   <span class="keywordflow">for</span> (poly=0; poly&lt;nb_elem; poly++)
<a name="l00363"></a>00363     {
<a name="l00364"></a>00364       rang = rang_elem_non_std(poly);
<a name="l00365"></a>00365       <span class="keywordflow">if</span> (rang==-1)
<a name="l00366"></a>00366         itypcl=0;
<a name="l00367"></a>00367       <span class="keywordflow">else</span>
<a name="l00368"></a>00368         itypcl=zone_Cl_VEF.<a class="code" href="classZone__Cl__VEF.html#a483bdab7690f844ed04e3defe04ec70a">type_elem_Cl</a>(rang);
<a name="l00369"></a>00369 
<a name="l00370"></a>00370 <span class="comment">// calcul des numeros des faces du polyedre</span>
<a name="l00371"></a>00371       <span class="keywordflow">for</span> (face_adj=0; face_adj&lt;nfac; face_adj++)
<a name="l00372"></a>00372         face(face_adj)= elem_faces(poly,face_adj);
<a name="l00373"></a>00373 
<a name="l00374"></a>00374       <span class="keywordtype">int</span> scom;
<a name="l00375"></a>00375       <a class="code" href="classDoubleVect.html">DoubleVect</a> rx0(dimension);
<a name="l00376"></a>00376 
<a name="l00377"></a>00377 <span class="comment">// calcul de la vitesse aux sommets des polyedres</span>
<a name="l00378"></a>00378       <span class="keywordflow">for</span> (j=0; j&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; j++)
<a name="l00379"></a>00379         {
<a name="l00380"></a>00380           vs(j) = la_vitesse(face(0),j)*porosite_face(face(0));
<a name="l00381"></a>00381           <span class="keywordflow">for</span> (i=1; i&lt;nfac; i++)
<a name="l00382"></a>00382             vs(j)+= la_vitesse(face(i),j)*porosite_face(face(i));
<a name="l00383"></a>00383         }
<a name="l00384"></a>00384 
<a name="l00385"></a>00385 <span class="comment">// int ncomp;</span>
<a name="l00386"></a>00386       <span class="keywordflow">if</span> (istetra==1)
<a name="l00387"></a>00387         {
<a name="l00388"></a>00388           <span class="keywordflow">for</span> (j=0; j&lt;nsom; j++)
<a name="l00389"></a>00389             {
<a name="l00390"></a>00390               <span class="keywordflow">for</span> (<span class="keywordtype">int</span> ncomp=0; ncomp&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>; ncomp++)
<a name="l00391"></a>00391                 vsom(j,ncomp) =vs[ncomp] - Objet_U::dimension*la_vitesse(face[j],ncomp)*porosite_face(face[j]);
<a name="l00392"></a>00392             }
<a name="l00393"></a>00393         }
<a name="l00394"></a>00394       <span class="keywordflow">else</span>
<a name="l00395"></a>00395         {
<a name="l00396"></a>00396 <span class="comment">// pour que cela soit valide avec les hexa</span>
<a name="l00397"></a>00397 <span class="comment">// On va utliser les fonctions de forme implementees dans la classe Champs_P1_impl ou Champs_Q1_impl</span>
<a name="l00398"></a>00398 <span class="comment">// int ncomp;</span>
<a name="l00399"></a>00399           <span class="keywordflow">for</span> (j=0; j&lt;nsom; j++)
<a name="l00400"></a>00400             {
<a name="l00401"></a>00401               num_som = zone.<a class="code" href="classZone.html#aa164c00997bc77a365a6da57bbec29ce" title="Renvoie le numero (global) j-ieme sommet du i-ieme element.">sommet_elem</a>(poly,j);
<a name="l00402"></a>00402               <span class="keywordflow">for</span> (<span class="keywordtype">int</span> ncomp=0; ncomp&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; ncomp++)
<a name="l00403"></a>00403                 {
<a name="l00404"></a>00404                   vsom(j,ncomp) = la_vitesse.<a class="code" href="classChamp__base.html#ad78f84c898b6fca623a30a9ae665c269" title="renvoi la compo eme corrdonne des valeurs a l&#39;element le_poly au sommet sommet">valeur_a_sommet_compo</a>(num_som,poly,ncomp);
<a name="l00405"></a>00405                 }
<a name="l00406"></a>00406             }
<a name="l00407"></a>00407         }
<a name="l00408"></a>00408 <span class="comment">// calcul de la vitesse au centre de gravite</span>
<a name="l00409"></a>00409       zone_VEF.<a class="code" href="classZone__VEF.html#a46693c060b8096fb2595ca72192eea2a">type_elem</a>().<a class="code" href="classElem__VEF.html#ab0be052b1bfa6135cb9b8288086f098e">calcul_vc</a>(face,vc,vs,vsom,<a class="code" href="classOp__Conv__VEF__base.html#a4872ffd7c638ecc415191d92d7f5f507">vitesse</a>(),itypcl,porosite_face);
<a name="l00410"></a>00410 
<a name="l00411"></a>00411 <span class="comment">// Boucle sur les facettes du polyedre non standard:</span>
<a name="l00412"></a>00412       <span class="keywordflow">for</span> (fa7=0; fa7&lt;nfa7; fa7++)
<a name="l00413"></a>00413         {
<a name="l00414"></a>00414 <span class="comment">// Cerr &lt;&lt; &quot;la facette etudiee est &quot; &lt;&lt; fa7 &lt;&lt; finl;</span>
<a name="l00415"></a>00415 <span class="comment">// fa7 separe num1 et num2. num3 est la troisieme face (2D).</span>
<a name="l00416"></a>00416 
<a name="l00417"></a>00417           num10 = face(KEL(0,fa7));
<a name="l00418"></a>00418           num20 = face(KEL(1,fa7));
<a name="l00419"></a>00419           num3 = face(KEL(2,fa7));
<a name="l00420"></a>00420 
<a name="l00421"></a>00421 <span class="comment">// Determination des elements voisins aux faces num1 et num2</span>
<a name="l00422"></a>00422 
<a name="l00423"></a>00423           poly1 = face_voisins(num10,0);
<a name="l00424"></a>00424           <span class="keywordflow">if</span> (poly1==poly)
<a name="l00425"></a>00425             poly1 = face_voisins(num10,1);
<a name="l00426"></a>00426 
<a name="l00427"></a>00427           poly2 = face_voisins(num20,0);
<a name="l00428"></a>00428           <span class="keywordflow">if</span> (poly2==poly)
<a name="l00429"></a>00429             poly2 = face_voisins(num20,1);
<a name="l00430"></a>00430 
<a name="l00431"></a>00431           scom = les_Polys(poly,KEL(2,fa7));
<a name="l00432"></a>00432 
<a name="l00433"></a>00433 <span class="comment">// calcul des rx0, distance entre les milieux des &#39;num i&#39;</span>
<a name="l00434"></a>00434 
<a name="l00435"></a>00435           <span class="keywordflow">for</span> (i=0; i&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; i++)
<a name="l00436"></a>00436             rx0(i) = xv(num20,i)-xv(num10,i);
<a name="l00437"></a>00437 
<a name="l00438"></a>00438 <span class="comment">// normales aux facettes</span>
<a name="l00439"></a>00439 
<a name="l00440"></a>00440           <span class="keywordflow">if</span> (rang==-1)
<a name="l00441"></a>00441             <span class="keywordflow">for</span> (i=0; i&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; i++)
<a name="l00442"></a>00442               cc[i] = facette_normales(poly, fa7, i);
<a name="l00443"></a>00443           <span class="keywordflow">else</span>
<a name="l00444"></a>00444             <span class="keywordflow">for</span> (i=0; i&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; i++)
<a name="l00445"></a>00445               cc[i] = normales_facettes_Cl(rang,fa7,i);
<a name="l00446"></a>00446 
<a name="l00447"></a>00447 <span class="comment">//</span>
<a name="l00448"></a>00448 <span class="comment">// On traite le point pour lequel vitesse = 0.5(vitsommet + vitmilieu)</span>
<a name="l00449"></a>00449 <span class="comment">//</span>
<a name="l00450"></a>00450 
<a name="l00451"></a>00451           <span class="keywordflow">for</span> (i=0; i&lt;nb_som_facette-1; i++)
<a name="l00452"></a>00452             {
<a name="l00453"></a>00453 <span class="comment">//</span>
<a name="l00454"></a>00454 <span class="comment">// Determination de PhiIJ au milieu entre le sommet et le milieu de num3</span>
<a name="l00455"></a>00455 <span class="comment">//</span>
<a name="l00456"></a>00456 
<a name="l00457"></a>00457               psc = 0;
<a name="l00458"></a>00458               <span class="keywordflow">for</span> (j=0; j&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; j++)
<a name="l00459"></a>00459                 psc+=((vsom(KEL(i+2,fa7),j) + la_vitesse(num3,j) * porosite_face(num3)))*cc[j];
<a name="l00460"></a>00460               psc *=0.5;
<a name="l00461"></a>00461               <a class="code" href="Op__Conv__kschemas__VEF_8cpp.html#a8b19f29166e833578e5f3d160894dac7">convkschemas</a>(<a class="code" href="classOp__Conv__kschemas__VEF.html#acefc930970ff28b3f623fbb3c867610a" title="int caracterisant les differents schemas">K</a>,ncomp_ch_transporte,dimension,poly,poly1,poly2,num10,num20,psc,transporte,
<a name="l00462"></a>00462                            fluent_,flux,rx0,gradient_elem);
<a name="l00463"></a>00463 
<a name="l00464"></a>00464 <span class="comment">//</span>
<a name="l00465"></a>00465 <span class="comment">// Limiteur pour le gradient. Calcul effectue en meme temps que le calcul du flux.</span>
<a name="l00466"></a>00466 <span class="comment">// gradient(K0) = teta*gradient(K0)+ (1-teta)gradient(K1ou K2)</span>
<a name="l00467"></a>00467 <span class="comment">//</span>
<a name="l00468"></a>00468 
<a name="l00469"></a>00469               <span class="keywordtype">double</span> teta = 0.5;
<a name="l00470"></a>00470 
<a name="l00471"></a>00471 <span class="comment">//</span>
<a name="l00472"></a>00472 <span class="comment">// On traite les sommets qui sont aussi des sommets du polyedre</span>
<a name="l00473"></a>00473 <span class="comment">//</span>
<a name="l00474"></a>00474 
<a name="l00475"></a>00475 <span class="comment">// XXX XXX XXX : Attention : we can not factorize more... the code is not the same</span>
<a name="l00476"></a>00476               <span class="keywordflow">if</span> (ncomp_ch_transporte == 1)
<a name="l00477"></a>00477                 {
<a name="l00478"></a>00478                   <span class="keywordflow">for</span> (j=0; j&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; j++)
<a name="l00479"></a>00479                     {
<a name="l00480"></a>00480                       xm = 0.5 *(coord(scom,j)+xv(num3,j));
<a name="l00481"></a>00481                       <span class="keywordflow">if</span> (psc &gt;= 0)
<a name="l00482"></a>00482                         {
<a name="l00483"></a>00483                           <span class="keywordflow">if</span> (poly1==-1)
<a name="l00484"></a>00484                             fluxsom(0) += gradient_elem(poly,0,j)*(coord(scom,j)-xm);
<a name="l00485"></a>00485                           <span class="keywordflow">else</span>
<a name="l00486"></a>00486                             fluxsom(0) += (teta*gradient_elem(poly,0,j) + (1.- teta)*gradient_elem(poly1,0,j))*(coord(scom,j)-xm);
<a name="l00487"></a>00487                         }
<a name="l00488"></a>00488                       <span class="keywordflow">else</span>
<a name="l00489"></a>00489                         {
<a name="l00490"></a>00490                           <span class="keywordflow">if</span> (poly2==-1)
<a name="l00491"></a>00491                             fluxsom(0) += gradient_elem(poly,0,j)*(coord(scom,j)-xm);
<a name="l00492"></a>00492                           <span class="keywordflow">else</span>
<a name="l00493"></a>00493                             fluxsom(0) += (teta*gradient_elem(poly,0,j) + (1.- teta)*gradient_elem(poly2,0,j))*(coord(scom,j)-xm);
<a name="l00494"></a>00494                         }
<a name="l00495"></a>00495                     }
<a name="l00496"></a>00496                   fluxsom(0) += flux(0);
<a name="l00497"></a>00497                   fluxsom(0) *= psc;
<a name="l00498"></a>00498                 }
<a name="l00499"></a>00499               <span class="keywordflow">else</span>
<a name="l00500"></a>00500                 {
<a name="l00501"></a>00501                   <span class="keywordflow">for</span> (comp0=0; comp0&lt;ncomp_ch_transporte; comp0++)
<a name="l00502"></a>00502                     {
<a name="l00503"></a>00503                       fluxsom(comp0) = flux(comp0);
<a name="l00504"></a>00504                       <span class="keywordflow">for</span> (j=0; j&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; j++)
<a name="l00505"></a>00505                         {
<a name="l00506"></a>00506                           xm = 0.5 *(coord(scom,j)+xv(num3,j));
<a name="l00507"></a>00507                           <span class="keywordflow">if</span> (psc &gt;= 0)
<a name="l00508"></a>00508                             {
<a name="l00509"></a>00509                               <span class="keywordflow">if</span> (poly1==-1)
<a name="l00510"></a>00510                                 fluxsom(comp0) += gradient_elem(poly,comp0,j)*(coord(scom,j)-xm);
<a name="l00511"></a>00511                               <span class="keywordflow">else</span>
<a name="l00512"></a>00512                                 fluxsom(comp0) += (teta*gradient_elem(poly,comp0,j) + (1.-teta)*gradient_elem(poly1,comp0,j))*(coord(scom,j)-xm);
<a name="l00513"></a>00513                             }
<a name="l00514"></a>00514                           <span class="keywordflow">else</span>
<a name="l00515"></a>00515                             {
<a name="l00516"></a>00516                               <span class="keywordflow">if</span> (poly2==-1)
<a name="l00517"></a>00517                                 fluxsom(comp0) += gradient_elem(poly,comp0,j)*(coord(scom,j)-xm);
<a name="l00518"></a>00518                               <span class="keywordflow">else</span>
<a name="l00519"></a>00519                                 fluxsom(comp0) += (teta*gradient_elem(poly,comp0,j) + (1.-teta)*gradient_elem(poly2,comp0,j))*(coord(scom,j)-xm);
<a name="l00520"></a>00520                             }
<a name="l00521"></a>00521                         }
<a name="l00522"></a>00522                       fluxsom(comp0) *= psc;
<a name="l00523"></a>00523                     }
<a name="l00524"></a>00524                 }
<a name="l00525"></a>00525 
<a name="l00526"></a>00526 <span class="comment">//</span>
<a name="l00527"></a>00527 <span class="comment">// on traite le centre de gravite</span>
<a name="l00528"></a>00528 <span class="comment">//</span>
<a name="l00529"></a>00529 
<a name="l00530"></a>00530 <span class="comment">// XXX XXX XXX : Attention : we can not factorize more... the code is not the same</span>
<a name="l00531"></a>00531               <span class="keywordflow">if</span> (ncomp_ch_transporte == 1)
<a name="l00532"></a>00532                 {
<a name="l00533"></a>00533                   <span class="keywordflow">for</span> (j=0; j&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; j++)
<a name="l00534"></a>00534                     {
<a name="l00535"></a>00535                       xm = 0.5 *(coord(scom,j)+xv(num3,j));
<a name="l00536"></a>00536                       <span class="keywordflow">if</span> (psc &gt;= 0)
<a name="l00537"></a>00537                         {
<a name="l00538"></a>00538                           <span class="keywordflow">if</span> (poly1==-1)
<a name="l00539"></a>00539                             fluxg(0) += gradient_elem(poly,0,j)*(xg(poly,j)-xm);
<a name="l00540"></a>00540                           <span class="keywordflow">else</span>
<a name="l00541"></a>00541                             fluxg(0) += (teta*gradient_elem(poly,0,j) + (1.- teta)*gradient_elem(poly1,0,j))*(xg(poly,j)-xm);
<a name="l00542"></a>00542                         }
<a name="l00543"></a>00543 
<a name="l00544"></a>00544                       <span class="keywordflow">else</span>
<a name="l00545"></a>00545                         {
<a name="l00546"></a>00546                           <span class="keywordflow">if</span> (poly2==-1)
<a name="l00547"></a>00547                             fluxg(0) += gradient_elem(poly,0,j)*(xg(poly,j)-xm);
<a name="l00548"></a>00548                           <span class="keywordflow">else</span>
<a name="l00549"></a>00549                             fluxg(0) += (teta*gradient_elem(poly,0,j) + (1.- teta)*gradient_elem(poly2,0,j))*(xg(poly,j)-xm);
<a name="l00550"></a>00550                         }
<a name="l00551"></a>00551                     }
<a name="l00552"></a>00552 
<a name="l00553"></a>00553                   fluxg(0) += flux(0);
<a name="l00554"></a>00554                   fluxg(0) *= psc;
<a name="l00555"></a>00555                 }
<a name="l00556"></a>00556               <span class="keywordflow">else</span>
<a name="l00557"></a>00557                 {
<a name="l00558"></a>00558                   <span class="keywordflow">for</span> (comp0=0; comp0&lt;ncomp_ch_transporte; comp0++)
<a name="l00559"></a>00559                     {
<a name="l00560"></a>00560                       fluxg(comp0) = flux(comp0);
<a name="l00561"></a>00561                       <span class="keywordflow">for</span> (j=0; j&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; j++)
<a name="l00562"></a>00562                         {
<a name="l00563"></a>00563                           xm = 0.5 *(coord(scom,j)+xv(num3,j));
<a name="l00564"></a>00564                           <span class="keywordflow">if</span> (psc &gt;= 0)
<a name="l00565"></a>00565                             {
<a name="l00566"></a>00566                               <span class="keywordflow">if</span> (poly1==-1)
<a name="l00567"></a>00567                                 fluxg(comp0) += gradient_elem(poly,comp0,j)*(xg(poly,j)-xm);
<a name="l00568"></a>00568                               <span class="keywordflow">else</span>
<a name="l00569"></a>00569                                 fluxg(comp0) += (teta*gradient_elem(poly,comp0,j) + (1.-teta)*gradient_elem(poly1,comp0,j))*(xg(poly,j)-xm);
<a name="l00570"></a>00570                             }
<a name="l00571"></a>00571 
<a name="l00572"></a>00572                           <span class="keywordflow">else</span>
<a name="l00573"></a>00573                             {
<a name="l00574"></a>00574                               <span class="keywordflow">if</span> (poly2==-1)
<a name="l00575"></a>00575                                 fluxg(comp0) += gradient_elem(poly,comp0,j)*(xg(poly,j)-xm);
<a name="l00576"></a>00576                               <span class="keywordflow">else</span>
<a name="l00577"></a>00577                                 fluxg(comp0) += (teta*gradient_elem(poly,comp0,j) + (1.-teta)*gradient_elem(poly2,comp0,j))*(xg(poly,j)-xm);
<a name="l00578"></a>00578                             }
<a name="l00579"></a>00579                         }
<a name="l00580"></a>00580                       fluxg(comp0) *= psc;
<a name="l00581"></a>00581                     }
<a name="l00582"></a>00582                 }
<a name="l00583"></a>00583 <span class="comment">//</span>
<a name="l00584"></a>00584 <span class="comment">// Integration de u.n.flux</span>
<a name="l00585"></a>00585 <span class="comment">//</span>
<a name="l00586"></a>00586               <span class="keywordflow">for</span> (comp0=0; comp0&lt;ncomp_ch_transporte; comp0++)
<a name="l00587"></a>00587                 {
<a name="l00588"></a>00588                   resu(num10,comp0) -= ( 0.5*(fluxsom(comp0)+fluxg(comp0)) );
<a name="l00589"></a>00589                   resu(num20,comp0) += ( 0.5*(fluxsom(comp0)+fluxg(comp0)) );
<a name="l00590"></a>00590                 }
<a name="l00591"></a>00591             }
<a name="l00592"></a>00592         }
<a name="l00593"></a>00593     } <span class="comment">//!&lt; fin de la boucle</span>
<a name="l00594"></a>00594 <span class="comment"></span>
<a name="l00595"></a>00595 <span class="comment">// Traitement des elements joints d&#39;epaisseur 1</span>
<a name="l00596"></a>00596   <span class="keywordflow">for</span> (poly=0; poly&lt;nb_elem_tot; poly++)
<a name="l00597"></a>00597     {
<a name="l00598"></a>00598 <span class="comment">// On regarde si une face du polyedre est une face joint</span>
<a name="l00599"></a>00599       <span class="keywordflow">for</span> (face_adj=0; face_adj&lt;nfac; face_adj++)
<a name="l00600"></a>00600         <span class="keywordflow">if</span>(face_adj&lt;nb_faces) <span class="keywordflow">break</span>;
<a name="l00601"></a>00601       <span class="keywordflow">if</span>(face_adj&lt;nfac)
<a name="l00602"></a>00602         {
<a name="l00603"></a>00603           rang = rang_elem_non_std(poly);
<a name="l00604"></a>00604           <span class="keywordflow">if</span> (rang==-1)
<a name="l00605"></a>00605             itypcl=0;
<a name="l00606"></a>00606           <span class="keywordflow">else</span>
<a name="l00607"></a>00607             itypcl=zone_Cl_VEF.<a class="code" href="classZone__Cl__VEF.html#a483bdab7690f844ed04e3defe04ec70a">type_elem_Cl</a>(rang);
<a name="l00608"></a>00608 
<a name="l00609"></a>00609 <span class="comment">// calcul des numeros des faces du polyedre</span>
<a name="l00610"></a>00610           <span class="keywordflow">for</span> (face_adj=0; face_adj&lt;nfac; face_adj++)
<a name="l00611"></a>00611             {
<a name="l00612"></a>00612               face(face_adj)= elem_faces(poly,face_adj);
<a name="l00613"></a>00613 <span class="comment">// Cerr &lt;&lt; &quot;les faces de l&#39;elements sont : &quot; &lt;&lt; face(face_adj) &lt;&lt; finl;</span>
<a name="l00614"></a>00614             }
<a name="l00615"></a>00615 
<a name="l00616"></a>00616           <span class="keywordtype">int</span> scom;
<a name="l00617"></a>00617           <a class="code" href="classDoubleVect.html">DoubleVect</a> rx0(dimension);
<a name="l00618"></a>00618 
<a name="l00619"></a>00619 <span class="comment">// calcul de la vitesse aux sommets des polyedres</span>
<a name="l00620"></a>00620           <span class="keywordflow">for</span> (j=0; j&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; j++)
<a name="l00621"></a>00621             {
<a name="l00622"></a>00622               vs(j) = la_vitesse(face(0),j)*porosite_face(face(0));
<a name="l00623"></a>00623               <span class="keywordflow">for</span> (i=1; i&lt;nfac; i++)
<a name="l00624"></a>00624                 vs(j)+= la_vitesse(face(i),j)*porosite_face(face(j));
<a name="l00625"></a>00625             }
<a name="l00626"></a>00626           <span class="keywordtype">int</span> ncomp;
<a name="l00627"></a>00627           <span class="keywordflow">for</span> (j=0; j&lt;nsom; j++)
<a name="l00628"></a>00628             {
<a name="l00629"></a>00629               num_som = zone.<a class="code" href="classZone.html#aa164c00997bc77a365a6da57bbec29ce" title="Renvoie le numero (global) j-ieme sommet du i-ieme element.">sommet_elem</a>(poly,j);
<a name="l00630"></a>00630               <span class="keywordflow">for</span> (ncomp=0; ncomp&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; ncomp++)
<a name="l00631"></a>00631                 vsom(j,ncomp) = la_vitesse.<a class="code" href="classChamp__base.html#ad78f84c898b6fca623a30a9ae665c269" title="renvoi la compo eme corrdonne des valeurs a l&#39;element le_poly au sommet sommet">valeur_a_sommet_compo</a>(num_som,poly,ncomp);
<a name="l00632"></a>00632             }
<a name="l00633"></a>00633 <span class="comment">// calcul de la vitesse au centre de gravite</span>
<a name="l00634"></a>00634 
<a name="l00635"></a>00635           zone_VEF.<a class="code" href="classZone__VEF.html#a46693c060b8096fb2595ca72192eea2a">type_elem</a>().<a class="code" href="classElem__VEF.html#ab0be052b1bfa6135cb9b8288086f098e">calcul_vc</a>(face,vc,vs,vsom,<a class="code" href="classOp__Conv__VEF__base.html#a4872ffd7c638ecc415191d92d7f5f507">vitesse</a>(),itypcl,porosite_face);
<a name="l00636"></a>00636 
<a name="l00637"></a>00637 
<a name="l00638"></a>00638 <span class="comment">// Boucle sur les facettes du polyedre non standard:</span>
<a name="l00639"></a>00639 
<a name="l00640"></a>00640           <span class="keywordflow">for</span> (fa7=0; fa7&lt;nfa7; fa7++)
<a name="l00641"></a>00641             {
<a name="l00642"></a>00642 <span class="comment">// Cerr &lt;&lt; &quot;la facette etudiee est &quot; &lt;&lt; fa7 &lt;&lt; finl;</span>
<a name="l00643"></a>00643 <span class="comment">// fa7 separe num1 et num2. num3 est la troisieme face (2D).</span>
<a name="l00644"></a>00644 
<a name="l00645"></a>00645               num10 = face(KEL(0,fa7));
<a name="l00646"></a>00646               num20 = face(KEL(1,fa7));
<a name="l00647"></a>00647               num3 = face(KEL(2,fa7));
<a name="l00648"></a>00648 
<a name="l00649"></a>00649 <span class="comment">// Determination des elements voisins aux faces num1 et num2</span>
<a name="l00650"></a>00650 
<a name="l00651"></a>00651               poly1 = face_voisins(num10,0);
<a name="l00652"></a>00652               <span class="keywordflow">if</span> (poly1==poly)
<a name="l00653"></a>00653                 {
<a name="l00654"></a>00654                   poly1 = face_voisins(num10,1);
<a name="l00655"></a>00655                 }
<a name="l00656"></a>00656 
<a name="l00657"></a>00657               poly2 = face_voisins(num20,0);
<a name="l00658"></a>00658               <span class="keywordflow">if</span> (poly2==poly)
<a name="l00659"></a>00659                 {
<a name="l00660"></a>00660                   poly2 = face_voisins(num20,1);
<a name="l00661"></a>00661                 }
<a name="l00662"></a>00662 
<a name="l00663"></a>00663               scom = les_Polys(poly,KEL(2,fa7));
<a name="l00664"></a>00664 
<a name="l00665"></a>00665 <span class="comment">// calcul des rx0, distance entre les milieux des &#39;num i&#39;</span>
<a name="l00666"></a>00666 
<a name="l00667"></a>00667               <span class="keywordflow">for</span> (i=0; i&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; i++)
<a name="l00668"></a>00668                 rx0(i) = xv(num20,i)-xv(num10,i);
<a name="l00669"></a>00669 
<a name="l00670"></a>00670 <span class="comment">// normales aux facettes</span>
<a name="l00671"></a>00671 
<a name="l00672"></a>00672               <span class="keywordflow">if</span> (rang==-1)
<a name="l00673"></a>00673                 <span class="keywordflow">for</span> (i=0; i&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; i++)
<a name="l00674"></a>00674                   cc[i] = facette_normales(poly, fa7, i);
<a name="l00675"></a>00675               <span class="keywordflow">else</span>
<a name="l00676"></a>00676                 <span class="keywordflow">for</span> (i=0; i&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; i++)
<a name="l00677"></a>00677                   cc[i] = normales_facettes_Cl(rang,fa7,i);
<a name="l00678"></a>00678 
<a name="l00679"></a>00679 <span class="comment">//</span>
<a name="l00680"></a>00680 <span class="comment">// On traite le point pour lequel vitesse = 0.5(vitsommet + vitmilieu)</span>
<a name="l00681"></a>00681 <span class="comment">//</span>
<a name="l00682"></a>00682 
<a name="l00683"></a>00683               <span class="keywordflow">for</span> (i=0; i&lt;nb_som_facette-1; i++)
<a name="l00684"></a>00684                 {
<a name="l00685"></a>00685 <span class="comment">//</span>
<a name="l00686"></a>00686 <span class="comment">// Determination de PhiIJ au milieu entre le sommet et le milieu de num3</span>
<a name="l00687"></a>00687 <span class="comment">//</span>
<a name="l00688"></a>00688 
<a name="l00689"></a>00689                   psc = 0;
<a name="l00690"></a>00690                   <span class="keywordflow">for</span> (j=0; j&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; j++)
<a name="l00691"></a>00691                     psc+=((vsom(KEL(i+2,fa7),j) + la_vitesse(num3,j) * porosite_face(num3)))*cc[j];
<a name="l00692"></a>00692                   psc *=0.5;
<a name="l00693"></a>00693                   <a class="code" href="Op__Conv__kschemas__VEF_8cpp.html#a8b19f29166e833578e5f3d160894dac7">convkschemas</a>(<a class="code" href="classOp__Conv__kschemas__VEF.html#acefc930970ff28b3f623fbb3c867610a" title="int caracterisant les differents schemas">K</a>,ncomp_ch_transporte,dimension,poly,poly1,poly2,num10,num20,psc,transporte,
<a name="l00694"></a>00694                                fluent_,flux,rx0,gradient_elem);
<a name="l00695"></a>00695 
<a name="l00696"></a>00696 
<a name="l00697"></a>00697 <span class="comment">//</span>
<a name="l00698"></a>00698 <span class="comment">// Limiteur pour le gradient. Calcul effectue en meme temps que le calcul du flux.</span>
<a name="l00699"></a>00699 <span class="comment">// gradient(K0) = teta*gradient(K0)+ (1-teta)gradient(K1ou K2)</span>
<a name="l00700"></a>00700 <span class="comment">//</span>
<a name="l00701"></a>00701 
<a name="l00702"></a>00702                   <span class="keywordtype">double</span> teta = 0.5;
<a name="l00703"></a>00703 
<a name="l00704"></a>00704 <span class="comment">//</span>
<a name="l00705"></a>00705 <span class="comment">// On traite les sommets qui sont aussi des sommets du polyedre</span>
<a name="l00706"></a>00706 <span class="comment">//</span>
<a name="l00707"></a>00707 
<a name="l00708"></a>00708 <span class="comment">// XXX XXX XXX : Attention : we can not factorize more... the code is not the same</span>
<a name="l00709"></a>00709                   <span class="keywordflow">if</span> (ncomp_ch_transporte == 1)
<a name="l00710"></a>00710                     {
<a name="l00711"></a>00711                       <span class="keywordflow">for</span> (j=0; j&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; j++)
<a name="l00712"></a>00712                         {
<a name="l00713"></a>00713                           xm = 0.5 *(coord(scom,j)+xv(num3,j));
<a name="l00714"></a>00714                           <span class="keywordflow">if</span> (psc &gt;= 0)
<a name="l00715"></a>00715                             {
<a name="l00716"></a>00716                               <span class="keywordflow">if</span> (poly1==-1)
<a name="l00717"></a>00717                                 fluxsom(0) += gradient_elem(poly,0,j)*(coord(scom,j)-xm);
<a name="l00718"></a>00718                               <span class="keywordflow">else</span>
<a name="l00719"></a>00719                                 fluxsom(0) += (teta*gradient_elem(poly,0,j) + (1.- teta)*gradient_elem(poly1,0,j))*(coord(scom,j)-xm);
<a name="l00720"></a>00720                             }
<a name="l00721"></a>00721                           <span class="keywordflow">else</span>
<a name="l00722"></a>00722                             {
<a name="l00723"></a>00723                               <span class="keywordflow">if</span> (poly2==-1)
<a name="l00724"></a>00724                                 fluxsom(0) += gradient_elem(poly,0,j)*(coord(scom,j)-xm);
<a name="l00725"></a>00725                               <span class="keywordflow">else</span>
<a name="l00726"></a>00726                                 fluxsom(0) += (teta*gradient_elem(poly,0,j) + (1.- teta)*gradient_elem(poly2,0,j))*(coord(scom,j)-xm);
<a name="l00727"></a>00727                             }
<a name="l00728"></a>00728                         }
<a name="l00729"></a>00729                       fluxsom(0) += flux(0);
<a name="l00730"></a>00730                       fluxsom(0) *= psc;
<a name="l00731"></a>00731                     }
<a name="l00732"></a>00732                   <span class="keywordflow">else</span>
<a name="l00733"></a>00733                     {
<a name="l00734"></a>00734                       <span class="keywordflow">for</span> (comp0=0; comp0&lt;ncomp_ch_transporte; comp0++)
<a name="l00735"></a>00735                         {
<a name="l00736"></a>00736                           fluxsom(comp0) = flux(comp0);
<a name="l00737"></a>00737                           <span class="keywordflow">for</span> (j=0; j&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; j++)
<a name="l00738"></a>00738                             {
<a name="l00739"></a>00739                               xm = 0.5 *(coord(scom,j)+xv(num3,j));
<a name="l00740"></a>00740                               <span class="keywordflow">if</span> (psc &gt;= 0)
<a name="l00741"></a>00741                                 {
<a name="l00742"></a>00742                                   <span class="keywordflow">if</span> (poly1==-1)
<a name="l00743"></a>00743                                     fluxsom(comp0) += gradient_elem(poly,comp0,j)*(coord(scom,j)-xm);
<a name="l00744"></a>00744                                   <span class="keywordflow">else</span>
<a name="l00745"></a>00745                                     fluxsom(comp0) += (teta*gradient_elem(poly,comp0,j) + (1.-teta)*gradient_elem(poly1,comp0,j))*(coord(scom,j)-xm);
<a name="l00746"></a>00746                                 }
<a name="l00747"></a>00747                               <span class="keywordflow">else</span>
<a name="l00748"></a>00748                                 {
<a name="l00749"></a>00749                                   <span class="keywordflow">if</span> (poly2==-1)
<a name="l00750"></a>00750                                     fluxsom(comp0) += gradient_elem(poly,comp0,j)*(coord(scom,j)-xm);
<a name="l00751"></a>00751                                   <span class="keywordflow">else</span>
<a name="l00752"></a>00752                                     fluxsom(comp0) += (teta*gradient_elem(poly,comp0,j) + (1.-teta)*gradient_elem(poly2,comp0,j))*(coord(scom,j)-xm);
<a name="l00753"></a>00753                                 }
<a name="l00754"></a>00754                             }
<a name="l00755"></a>00755                           fluxsom(comp0) *= psc;
<a name="l00756"></a>00756                         }
<a name="l00757"></a>00757                     }
<a name="l00758"></a>00758 
<a name="l00759"></a>00759 <span class="comment">//</span>
<a name="l00760"></a>00760 <span class="comment">// on traite le centre de gravite</span>
<a name="l00761"></a>00761 <span class="comment">//</span>
<a name="l00762"></a>00762 
<a name="l00763"></a>00763 <span class="comment">// XXX XXX XXX : Attention : we can not factorize more... the code is not the same</span>
<a name="l00764"></a>00764                   <span class="keywordflow">if</span> (ncomp_ch_transporte == 1)
<a name="l00765"></a>00765                     {
<a name="l00766"></a>00766                       <span class="keywordflow">for</span> (j=0; j&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; j++)
<a name="l00767"></a>00767                         {
<a name="l00768"></a>00768                           xm = 0.5 *(coord(scom,j)+xv(num3,j));
<a name="l00769"></a>00769                           <span class="keywordflow">if</span> (psc &gt;= 0)
<a name="l00770"></a>00770                             {
<a name="l00771"></a>00771                               <span class="keywordflow">if</span> (poly1==-1)
<a name="l00772"></a>00772                                 fluxg(0) += gradient_elem(poly,0,j)*(xg(poly,j)-xm);
<a name="l00773"></a>00773                               <span class="keywordflow">else</span>
<a name="l00774"></a>00774                                 fluxg(0) += (teta*gradient_elem(poly,0,j) + (1.- teta)*gradient_elem(poly1,0,j))*(xg(poly,j)-xm);
<a name="l00775"></a>00775                             }
<a name="l00776"></a>00776                           <span class="keywordflow">else</span>
<a name="l00777"></a>00777                             {
<a name="l00778"></a>00778                               <span class="keywordflow">if</span> (poly2==-1)
<a name="l00779"></a>00779                                 fluxg(0) += gradient_elem(poly,0,j)*(xg(poly,j)-xm);
<a name="l00780"></a>00780                               <span class="keywordflow">else</span>
<a name="l00781"></a>00781                                 fluxg(0) += (teta*gradient_elem(poly,0,j) + (1.- teta)*gradient_elem(poly2,0,j))*(xg(poly,j)-xm);
<a name="l00782"></a>00782                             }
<a name="l00783"></a>00783                         }
<a name="l00784"></a>00784                       fluxg(0) += flux(0);
<a name="l00785"></a>00785                       fluxg(0) *= psc;
<a name="l00786"></a>00786                     }
<a name="l00787"></a>00787                   <span class="keywordflow">else</span>
<a name="l00788"></a>00788                     {
<a name="l00789"></a>00789                       <span class="keywordflow">for</span> (comp0=0; comp0&lt;ncomp_ch_transporte; comp0++)
<a name="l00790"></a>00790                         {
<a name="l00791"></a>00791                           fluxg(comp0) = flux(comp0);
<a name="l00792"></a>00792                           <span class="keywordflow">for</span> (j=0; j&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; j++)
<a name="l00793"></a>00793                             {
<a name="l00794"></a>00794                               xm = 0.5 *(coord(scom,j)+xv(num3,j));
<a name="l00795"></a>00795                               <span class="keywordflow">if</span> (psc &gt;= 0)
<a name="l00796"></a>00796                                 {
<a name="l00797"></a>00797                                   <span class="keywordflow">if</span> (poly1==-1)
<a name="l00798"></a>00798                                     fluxg(comp0) += gradient_elem(poly,comp0,j)*(xg(poly,j)-xm);
<a name="l00799"></a>00799                                   <span class="keywordflow">else</span>
<a name="l00800"></a>00800                                     fluxg(comp0) += (teta*gradient_elem(poly,comp0,j) + (1.-teta)*gradient_elem(poly1,comp0,j))*(xg(poly,j)-xm);
<a name="l00801"></a>00801                                 }
<a name="l00802"></a>00802                               <span class="keywordflow">else</span>
<a name="l00803"></a>00803                                 {
<a name="l00804"></a>00804                                   <span class="keywordflow">if</span> (poly2==-1)
<a name="l00805"></a>00805                                     fluxg(comp0) += gradient_elem(poly,comp0,j)*(xg(poly,j)-xm);
<a name="l00806"></a>00806                                   <span class="keywordflow">else</span>
<a name="l00807"></a>00807                                     fluxg(comp0) += (teta*gradient_elem(poly,comp0,j) + (1.-teta)*gradient_elem(poly2,comp0,j))*(xg(poly,j)-xm);
<a name="l00808"></a>00808                                 }
<a name="l00809"></a>00809                             }
<a name="l00810"></a>00810                           fluxg(comp0) *= psc;
<a name="l00811"></a>00811                         }
<a name="l00812"></a>00812                     }
<a name="l00813"></a>00813 
<a name="l00814"></a>00814 <span class="comment">//</span>
<a name="l00815"></a>00815 <span class="comment">// Integration de u.n.flux</span>
<a name="l00816"></a>00816 <span class="comment">//</span>
<a name="l00817"></a>00817                   <span class="keywordflow">for</span> (comp0=0; comp0&lt;ncomp_ch_transporte; comp0++)
<a name="l00818"></a>00818                     {
<a name="l00819"></a>00819                       resu(num10,comp0) -= ( 0.5*(fluxsom(comp0)+fluxg(comp0)) );
<a name="l00820"></a>00820                       resu(num20,comp0) += ( 0.5*(fluxsom(comp0)+fluxg(comp0)) );
<a name="l00821"></a>00821                     }
<a name="l00822"></a>00822                 }
<a name="l00823"></a>00823             }
<a name="l00824"></a>00824         }
<a name="l00825"></a>00825     } <span class="comment">//!&lt; fin de la boucle</span>
<a name="l00826"></a>00826 <span class="comment"></span>  <span class="keywordtype">int</span> voisine;
<a name="l00827"></a>00827   nb_faces_perio = 0;
<a name="l00828"></a>00828   <span class="keywordtype">double</span> diff1,diff2;
<a name="l00829"></a>00829 
<a name="l00830"></a>00830 <span class="comment">// Dimensionnement du tableau des flux convectifs au bord du domaine</span>
<a name="l00831"></a>00831 <span class="comment">// de calcul</span>
<a name="l00832"></a>00832   <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; flux_b = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>,<a class="code" href="classOperateur__base.html#a451f51b41518ddbc0d3f586a8177d319" title="Tableau contenant les flux sur les bords de l&#39;operateur.">flux_bords_</a>);
<a name="l00833"></a>00833   flux_b.<a class="code" href="classDoubleTab.html#ae83b4d31205c53d9c8d2b43da178ce75" title="Change la taille du vecteur (identique a resize_array() pour le traitement des anciennes valeurs et d...">resize</a>(zone_VEF.<a class="code" href="classZone__VF.html#a8815e2276637c0db23868f043dc43e58" title="renvoie le nombre de faces sur lesquelles sont appliquees les conditions limites : bords...">nb_faces_bord</a>(),ncomp_ch_transporte);
<a name="l00834"></a>00834   flux_b = 0.;
<a name="l00835"></a>00835 
<a name="l00836"></a>00836 <span class="comment">// Boucle sur les bords pour traiter les conditions aux limites</span>
<a name="l00837"></a>00837 <span class="comment">// il y a prise en compte d&#39;un terme de convection pour les</span>
<a name="l00838"></a>00838 <span class="comment">// conditions aux limites de Neumann_sortie_libre seulement</span>
<a name="l00839"></a>00839 
<a name="l00840"></a>00840   <span class="keywordflow">for</span> (n_bord=0; n_bord&lt;zone_VEF.<a class="code" href="classZone__dis__base.html#af22167d614644f55591a29c77eb1c009">nb_front_Cl</a>(); n_bord++)
<a name="l00841"></a>00841     {
<a name="l00842"></a>00842       <span class="keyword">const</span> <a class="code" href="classCond__lim.html" title="classe Cond_lim Classe generique servant a representer n&#39;importe quelle classe derivee de la classe C...">Cond_lim</a>&amp; la_cl = zone_Cl_VEF.<a class="code" href="classZone__Cl__dis__base.html#af75e0ed7786863e4d333bfb29d67c323" title="Renvoie la i-ieme condition aux limites. (version const)">les_conditions_limites</a>(n_bord);
<a name="l00843"></a>00843 
<a name="l00844"></a>00844       <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classNeumann__sortie__libre.html" title="classe Neumann_sortie_libre Cette classe represente une frontiere ouverte sans vitesse imposee Pour l...">Neumann_sortie_libre</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>()))
<a name="l00845"></a>00845         {
<a name="l00846"></a>00846           <span class="keyword">const</span> <a class="code" href="classNeumann__sortie__libre.html" title="classe Neumann_sortie_libre Cette classe represente une frontiere ouverte sans vitesse imposee Pour l...">Neumann_sortie_libre</a>&amp; la_sortie_libre = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classNeumann__sortie__libre.html" title="classe Neumann_sortie_libre Cette classe represente une frontiere ouverte sans vitesse imposee Pour l...">Neumann_sortie_libre</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>());
<a name="l00847"></a>00847           <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp; le_bord = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>,la_cl.<a class="code" href="classCond__lim.html#a5b2d24809cee07727006a891d4ce8d22" title="Appel a l&#39;objet sous-jacent Renvoie la frontiere discretisee associee a la condition aux limites...">frontiere_dis</a>());
<a name="l00848"></a>00848           <span class="keywordtype">int</span> num1 = le_bord.num_premiere_face();
<a name="l00849"></a>00849           <span class="keywordtype">int</span> num2 = num1 + le_bord.nb_faces();
<a name="l00850"></a>00850           <span class="keywordflow">for</span> (num_face=num1; num_face&lt;num2; num_face++)
<a name="l00851"></a>00851             {
<a name="l00852"></a>00852               psc =0;
<a name="l00853"></a>00853               <span class="keywordflow">for</span> (i=0; i&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; i++)
<a name="l00854"></a>00854                 psc += la_vitesse(num_face,i)*face_normales(num_face,i)*porosite_face(num_face);
<a name="l00855"></a>00855               <span class="keywordflow">if</span> (psc&gt;0)
<a name="l00856"></a>00856                 <span class="keywordflow">for</span> (i=0; i&lt;ncomp_ch_transporte; i++)
<a name="l00857"></a>00857                   {
<a name="l00858"></a>00858                     resu(num_face,i) -= psc*transporte(num_face,i);
<a name="l00859"></a>00859                     flux_b(num_face,i) -= psc*transporte(num_face,i);
<a name="l00860"></a>00860                   }
<a name="l00861"></a>00861               <span class="keywordflow">else</span>
<a name="l00862"></a>00862                 {
<a name="l00863"></a>00863                   <span class="keywordflow">for</span> (i=0; i&lt;ncomp_ch_transporte; i++)
<a name="l00864"></a>00864                     {
<a name="l00865"></a>00865                       resu(num_face,i) -= psc*la_sortie_libre.<a class="code" href="classNeumann__sortie__libre.html#a886f1804fa2a9028fc56a0778a72a75d" title="Renvoie la valeur de la i-eme composante du champ impose a l&#39;exterieur de la frontiere.">val_ext</a>(num_face-num1,i);
<a name="l00866"></a>00866                       flux_b(num_face,i) -= psc*la_sortie_libre.<a class="code" href="classNeumann__sortie__libre.html#a886f1804fa2a9028fc56a0778a72a75d" title="Renvoie la valeur de la i-eme composante du champ impose a l&#39;exterieur de la frontiere.">val_ext</a>(num_face-num1,i);
<a name="l00867"></a>00867                     }
<a name="l00868"></a>00868                   fluent_(num_face) -= psc;
<a name="l00869"></a>00869                 }
<a name="l00870"></a>00870             }
<a name="l00871"></a>00871         }
<a name="l00872"></a>00872       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>()))
<a name="l00873"></a>00873         {
<a name="l00874"></a>00874           <span class="keyword">const</span> <a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>&amp; la_cl_perio = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>());
<a name="l00875"></a>00875           <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp; le_bord = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>,la_cl.<a class="code" href="classCond__lim.html#a5b2d24809cee07727006a891d4ce8d22" title="Appel a l&#39;objet sous-jacent Renvoie la frontiere discretisee associee a la condition aux limites...">frontiere_dis</a>());
<a name="l00876"></a>00876           <span class="keywordtype">int</span> num1 = le_bord.num_premiere_face();
<a name="l00877"></a>00877           <span class="keywordtype">int</span> num2 = num1 + le_bord.nb_faces();
<a name="l00878"></a>00878           <a class="code" href="classIntVect.html">IntVect</a> fait(le_bord.nb_faces());
<a name="l00879"></a>00879           fait = 0;
<a name="l00880"></a>00880           <span class="keywordflow">for</span> (num_face=num1; num_face&lt;num2; num_face++)
<a name="l00881"></a>00881             {
<a name="l00882"></a>00882               <span class="keywordflow">if</span> (fait[num_face-num1] == 0)
<a name="l00883"></a>00883                 {
<a name="l00884"></a>00884                   voisine = la_cl_perio.<a class="code" href="classPeriodique.html#a207b86556f199a63ea059b841851ca6a">face_associee</a>(num_face-num1) + num1;
<a name="l00885"></a>00885                   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> comp=0; comp&lt;ncomp_ch_transporte; comp++)
<a name="l00886"></a>00886                     {
<a name="l00887"></a>00887                       diff1 = resu(num_face,comp)-tab(nb_faces_perio,comp);
<a name="l00888"></a>00888                       diff2 = resu(voisine,comp)-tab(nb_faces_perio+voisine-num_face,comp);
<a name="l00889"></a>00889                       resu(voisine,comp)  += diff1;
<a name="l00890"></a>00890                       resu(num_face,comp) += diff2;
<a name="l00891"></a>00891                       flux_b(voisine,comp) += diff1;
<a name="l00892"></a>00892                       flux_b(num_face,comp) += diff2;
<a name="l00893"></a>00893                     }
<a name="l00894"></a>00894                   fait[num_face-num1]= 1;
<a name="l00895"></a>00895                   fait[voisine-num1] = 1;
<a name="l00896"></a>00896                 }
<a name="l00897"></a>00897               nb_faces_perio++;
<a name="l00898"></a>00898             }
<a name="l00899"></a>00899         }
<a name="l00900"></a>00900     }
<a name="l00901"></a>00901   <a class="code" href="classOp__VEF__Face.html#a6c8ce571769b4f2e20b07cbb7a6944f2">modifier_flux</a>(*<span class="keyword">this</span>);
<a name="l00902"></a>00902   <span class="keywordflow">return</span> resu;
<a name="l00903"></a>00903 }
<a name="l00904"></a>00904 
</pre></div></div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Tue Dec 14 2021 19:35:42 for TRUST by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
