<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>TRUST: Sortie_Nulle Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">TRUST&#160;<span id="projectnumber">1.8.4</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">Sortie_Nulle Class Reference</div>  </div>
</div>
<div class="contents">
<!-- doxytag: class="Sortie_Nulle" --><!-- doxytag: inherits="Sortie" -->
<p>Classe derivee de <a class="el" href="classSortie.html" title="Classe de base des flux de sortie. Elle sait ecrire des types simples&lt;br&gt;(entiers, flottants) et des Ob...">Sortie</a> qui ne sort les donnees nulle part (c'est une poubelle)<br/>
Classe utilisee dans le Journal() si celui-ci est desactive.<br/>
Le pointeur ostream_ est nul.  
 <a href="classSortie__Nulle.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="Sortie__Nulle_8h_source.html">Sortie_Nulle.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Sortie_Nulle:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classSortie__Nulle.png" usemap="#Sortie_Nulle_map" alt=""/>
  <map id="Sortie_Nulle_map" name="Sortie_Nulle_map">
<area href="classSortie.html" title="Classe de base des flux de sortie. Elle sait ecrire des types simples&lt;br&gt;(entiers, flottants) et des Ob..." alt="Sortie" shape="rect" coords="0,0,81,24"/>
</map>
 </div></div>

<p><a href="classSortie__Nulle-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSortie__Nulle.html#a9d51d71ae3fed1f9dafb97ac6876b838">Sortie_Nulle</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructeur par defaut (le pointeur ostream_ est nul).  <a href="#a9d51d71ae3fed1f9dafb97ac6876b838"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSortie__Nulle.html#a48dbe70eb8301aab58da87ce8bc356c5">~Sortie_Nulle</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSortie.html">Sortie</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSortie__Nulle.html#a62325d23842d30ad8b590ba468e81488">flush</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSortie__Nulle.html#a9217c458c8dd332fdc3fcd8a38e16b6b">setf</a> (std::_Ios_Fmtflags)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSortie__Nulle.html#a76d40d58e47cbe9d0addbb29df554f69">precision</a> (int)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSortie.html">Sortie</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSortie__Nulle.html#a16d83539fa13b631f59fd3f5f92e669c">operator&lt;&lt;</a> (const <a class="el" href="classSeparateur.html">Separateur</a> &amp;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSortie.html">Sortie</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSortie__Nulle.html#a7d579f4825cd0a4d37171257a1bb57b1">operator&lt;&lt;</a> (const <a class="el" href="classObjet__U.html">Objet_U</a> &amp;ob)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Ecriture d'un objet ou d'une variable.<br/>
Dans cette implementation (et dans la plupart des classes derivees)<br/>
on appelle simplement ob.printOn (a l'exception de <a class="el" href="classSortie__Nulle.html" title="Classe derivee de Sortie qui ne sort les donnees nulle part (c&#39;est une poubelle) Classe utilisee dans...">Sortie_Nulle</a>)<br/>
Attention, si on veut que le flux puisse etre indifferemment ASCII ou BINAIRE,<br/>
il faut inserer "\&lt;\&lt; space \&lt;\&lt;" ou "\&lt;\&lt; finl \&lt;\&lt;" pour separer les objets.  <a href="#a7d579f4825cd0a4d37171257a1bb57b1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSortie.html">Sortie</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSortie__Nulle.html#a9d2a4c4fe49117792c5db9fcf6e25bf0">operator&lt;&lt;</a> (const int &amp;ob)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Methode de bas niveau pour ecrire un int ou flottant dans le stream.<br/>
Dans l'implementation de la classe de base, on ecrit dans ostream_.<br/>
En binaire on utilise ostream::write(), en ascii ostream::operato&lt;&lt;()  <a href="#a9d2a4c4fe49117792c5db9fcf6e25bf0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSortie.html">Sortie</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSortie__Nulle.html#a97fcd96fa14bab25399767d94b2bd4f3">operator&lt;&lt;</a> (const unsigned &amp;ob)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Methode de bas niveau pour ecrire un int ou flottant dans le stream.<br/>
Dans l'implementation de la classe de base, on ecrit dans ostream_.<br/>
En binaire on utilise ostream::write(), en ascii ostream::operato&lt;&lt;()  <a href="#a97fcd96fa14bab25399767d94b2bd4f3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSortie.html">Sortie</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSortie__Nulle.html#adc1eae2f18adbaba3177f1e7aa156cb4">operator&lt;&lt;</a> (const long &amp;ob)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Methode de bas niveau pour ecrire un int ou flottant dans le stream.<br/>
Dans l'implementation de la classe de base, on ecrit dans ostream_.<br/>
En binaire on utilise ostream::write(), en ascii ostream::operato&lt;&lt;()  <a href="#adc1eae2f18adbaba3177f1e7aa156cb4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSortie.html">Sortie</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSortie__Nulle.html#adf3cce9389d272e314a30abfd5d0a163">operator&lt;&lt;</a> (const float &amp;ob)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Methode de bas niveau pour ecrire un int ou flottant dans le stream.<br/>
Dans l'implementation de la classe de base, on ecrit dans ostream_.<br/>
En binaire on utilise ostream::write(), en ascii ostream::operato&lt;&lt;()  <a href="#adf3cce9389d272e314a30abfd5d0a163"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSortie.html">Sortie</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSortie__Nulle.html#a32751a2263c8b42fb87001dd5db0925a">operator&lt;&lt;</a> (const double &amp;ob)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Methode de bas niveau pour ecrire un int ou flottant dans le stream.<br/>
Dans l'implementation de la classe de base, on ecrit dans ostream_.<br/>
En binaire on utilise ostream::write(), en ascii ostream::operato&lt;&lt;()  <a href="#a32751a2263c8b42fb87001dd5db0925a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSortie.html">Sortie</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSortie__Nulle.html#adacf99dd516b5a5e9ada32e58012a731">operator&lt;&lt;</a> (const char *ob)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Ecriture d'une chaine de caracteres. Attention, pour pouvoir<br/>
relire correctement la chaine en mode ascii, celle-ci ne doit<br/>
pas contenir de separateur (ni espace, ni retour a la ligne, ...)  <a href="#adacf99dd516b5a5e9ada32e58012a731"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSortie__Nulle.html#a530b2e93a94713df77af77ecf5b8fc57">put</a> (const unsigned *ob, int n, int pas=1)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Methode de bas niveau pour ecrire un tableau d'ints ou reels dans le stream.<br/>
Dans l'implementation de la classe de base, on ecrit dans ostream_.<br/>
En binaire on utilise ostream::write(), en ascii ostream::operato&lt;&lt;()<br/>
En ascii, on revient a la ligne chaque fois qu'on a ecrit "nb_col" valeurs et a la<br/>
fin du tableau.<br/>
Valeur de retour : ostream_-&gt;good()  <a href="#a530b2e93a94713df77af77ecf5b8fc57"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSortie__Nulle.html#aba04d345fa57605634ea89027b849da6">put</a> (const int *ob, int n, int pas=1)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Methode de bas niveau pour ecrire un tableau d'ints ou reels dans le stream.<br/>
Dans l'implementation de la classe de base, on ecrit dans ostream_.<br/>
En binaire on utilise ostream::write(), en ascii ostream::operato&lt;&lt;()<br/>
En ascii, on revient a la ligne chaque fois qu'on a ecrit "nb_col" valeurs et a la<br/>
fin du tableau.<br/>
Valeur de retour : ostream_-&gt;good()  <a href="#aba04d345fa57605634ea89027b849da6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSortie__Nulle.html#ae11686de240fce6d2b175ab9b2123646">put</a> (const long *ob, int n, int pas=1)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Methode de bas niveau pour ecrire un tableau d'ints ou reels dans le stream.<br/>
Dans l'implementation de la classe de base, on ecrit dans ostream_.<br/>
En binaire on utilise ostream::write(), en ascii ostream::operato&lt;&lt;()<br/>
En ascii, on revient a la ligne chaque fois qu'on a ecrit "nb_col" valeurs et a la<br/>
fin du tableau.<br/>
Valeur de retour : ostream_-&gt;good()  <a href="#ae11686de240fce6d2b175ab9b2123646"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSortie__Nulle.html#a0e440f5f3d82599959f83f6d5482510c">put</a> (const float *ob, int n, int pas=1)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Methode de bas niveau pour ecrire un tableau d'ints ou reels dans le stream.<br/>
Dans l'implementation de la classe de base, on ecrit dans ostream_.<br/>
En binaire on utilise ostream::write(), en ascii ostream::operato&lt;&lt;()<br/>
En ascii, on revient a la ligne chaque fois qu'on a ecrit "nb_col" valeurs et a la<br/>
fin du tableau.<br/>
Valeur de retour : ostream_-&gt;good()  <a href="#a0e440f5f3d82599959f83f6d5482510c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSortie__Nulle.html#a1f8a33f73945698574f1699703066f40">put</a> (const double *ob, int n, int pas=1)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Methode de bas niveau pour ecrire un tableau d'ints ou reels dans le stream.<br/>
Dans l'implementation de la classe de base, on ecrit dans ostream_.<br/>
En binaire on utilise ostream::write(), en ascii ostream::operato&lt;&lt;()<br/>
En ascii, on revient a la ligne chaque fois qu'on a ecrit "nb_col" valeurs et a la<br/>
fin du tableau.<br/>
Valeur de retour : ostream_-&gt;good()  <a href="#a1f8a33f73945698574f1699703066f40"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Classe derivee de <a class="el" href="classSortie.html" title="Classe de base des flux de sortie. Elle sait ecrire des types simples&lt;br&gt;(entiers, flottants) et des Ob...">Sortie</a> qui ne sort les donnees nulle part (c'est une poubelle)<br/>
Classe utilisee dans le Journal() si celui-ci est desactive.<br/>
Le pointeur ostream_ est nul. </p>

<p>Definition at line <a class="el" href="Sortie__Nulle_8h_source.html#l00036">36</a> of file <a class="el" href="Sortie__Nulle_8h_source.html">Sortie_Nulle.h</a>.</p>
</div><hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a9d51d71ae3fed1f9dafb97ac6876b838"></a><!-- doxytag: member="Sortie_Nulle::Sortie_Nulle" ref="a9d51d71ae3fed1f9dafb97ac6876b838" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Sortie_Nulle::Sortie_Nulle </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructeur par defaut (le pointeur ostream_ est nul). </p>

<p>Definition at line <a class="el" href="Sortie__Nulle_8cpp_source.html#l00026">26</a> of file <a class="el" href="Sortie__Nulle_8cpp_source.html">Sortie_Nulle.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{
}
</pre></div>
</div>
</div>
<a class="anchor" id="a48dbe70eb8301aab58da87ce8bc356c5"></a><!-- doxytag: member="Sortie_Nulle::~Sortie_Nulle" ref="a48dbe70eb8301aab58da87ce8bc356c5" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Sortie_Nulle::~Sortie_Nulle </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Sortie__Nulle_8cpp_source.html#l00030">30</a> of file <a class="el" href="Sortie__Nulle_8cpp_source.html">Sortie_Nulle.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{
}
</pre></div>
</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a62325d23842d30ad8b590ba468e81488"></a><!-- doxytag: member="Sortie_Nulle::flush" ref="a62325d23842d30ad8b590ba468e81488" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSortie.html">Sortie</a> &amp; Sortie_Nulle::flush </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="classSortie.html#a2456baf1997d9a7a6310349929bccf30">Sortie</a>.</p>

<p>Definition at line <a class="el" href="Sortie__Nulle_8cpp_source.html#l00034">34</a> of file <a class="el" href="Sortie__Nulle_8cpp_source.html">Sortie_Nulle.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">return</span> *<span class="keyword">this</span>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a16d83539fa13b631f59fd3f5f92e669c"></a><!-- doxytag: member="Sortie_Nulle::operator&lt;&lt;" ref="a16d83539fa13b631f59fd3f5f92e669c" args="(const Separateur &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSortie.html">Sortie</a> &amp; Sortie_Nulle::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSeparateur.html">Separateur</a> &amp;&#160;</td>
          <td class="paramname"><em>ob</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="classSortie.html#a36ef2c9f55625cb7652c74d81f2d76de">Sortie</a>.</p>

<p>Definition at line <a class="el" href="Sortie__Nulle_8cpp_source.html#l00041">41</a> of file <a class="el" href="Sortie__Nulle_8cpp_source.html">Sortie_Nulle.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">return</span> *<span class="keyword">this</span>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="adc1eae2f18adbaba3177f1e7aa156cb4"></a><!-- doxytag: member="Sortie_Nulle::operator&lt;&lt;" ref="adc1eae2f18adbaba3177f1e7aa156cb4" args="(const long &amp;ob)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSortie.html">Sortie</a> &amp; Sortie_Nulle::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">const long &amp;&#160;</td>
          <td class="paramname"><em>ob</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Methode de bas niveau pour ecrire un int ou flottant dans le stream.<br/>
Dans l'implementation de la classe de base, on ecrit dans ostream_.<br/>
En binaire on utilise ostream::write(), en ascii ostream::operato&lt;&lt;() </p>

<p>Reimplemented from <a class="el" href="classSortie.html#a496d561284b31eafddf17d209ab89ebb">Sortie</a>.</p>

<p>Definition at line <a class="el" href="Sortie__Nulle_8cpp_source.html#l00058">58</a> of file <a class="el" href="Sortie__Nulle_8cpp_source.html">Sortie_Nulle.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">return</span> *<span class="keyword">this</span>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="adf3cce9389d272e314a30abfd5d0a163"></a><!-- doxytag: member="Sortie_Nulle::operator&lt;&lt;" ref="adf3cce9389d272e314a30abfd5d0a163" args="(const float &amp;ob)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSortie.html">Sortie</a> &amp; Sortie_Nulle::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">const float &amp;&#160;</td>
          <td class="paramname"><em>ob</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Methode de bas niveau pour ecrire un int ou flottant dans le stream.<br/>
Dans l'implementation de la classe de base, on ecrit dans ostream_.<br/>
En binaire on utilise ostream::write(), en ascii ostream::operato&lt;&lt;() </p>

<p>Reimplemented from <a class="el" href="classSortie.html#ae86c4be35ac9aea5bd8e8115fb0feae5">Sortie</a>.</p>

<p>Definition at line <a class="el" href="Sortie__Nulle_8cpp_source.html#l00063">63</a> of file <a class="el" href="Sortie__Nulle_8cpp_source.html">Sortie_Nulle.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">return</span> *<span class="keyword">this</span>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a7d579f4825cd0a4d37171257a1bb57b1"></a><!-- doxytag: member="Sortie_Nulle::operator&lt;&lt;" ref="a7d579f4825cd0a4d37171257a1bb57b1" args="(const Objet_U &amp;ob)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSortie.html">Sortie</a> &amp; Sortie_Nulle::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classObjet__U.html">Objet_U</a> &amp;&#160;</td>
          <td class="paramname"><em>ob</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Ecriture d'un objet ou d'une variable.<br/>
Dans cette implementation (et dans la plupart des classes derivees)<br/>
on appelle simplement ob.printOn (a l'exception de <a class="el" href="classSortie__Nulle.html" title="Classe derivee de Sortie qui ne sort les donnees nulle part (c&#39;est une poubelle) Classe utilisee dans...">Sortie_Nulle</a>)<br/>
Attention, si on veut que le flux puisse etre indifferemment ASCII ou BINAIRE,<br/>
il faut inserer "\&lt;\&lt; space \&lt;\&lt;" ou "\&lt;\&lt; finl \&lt;\&lt;" pour separer les objets. </p>

<p>Reimplemented from <a class="el" href="classSortie.html#a7f429425dc28cee3daa801dbcb976b1c">Sortie</a>.</p>

<p>Definition at line <a class="el" href="Sortie__Nulle_8cpp_source.html#l00045">45</a> of file <a class="el" href="Sortie__Nulle_8cpp_source.html">Sortie_Nulle.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">return</span> *<span class="keyword">this</span>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a32751a2263c8b42fb87001dd5db0925a"></a><!-- doxytag: member="Sortie_Nulle::operator&lt;&lt;" ref="a32751a2263c8b42fb87001dd5db0925a" args="(const double &amp;ob)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSortie.html">Sortie</a> &amp; Sortie_Nulle::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>ob</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Methode de bas niveau pour ecrire un int ou flottant dans le stream.<br/>
Dans l'implementation de la classe de base, on ecrit dans ostream_.<br/>
En binaire on utilise ostream::write(), en ascii ostream::operato&lt;&lt;() </p>

<p>Reimplemented from <a class="el" href="classSortie.html#a549c4d26ca7d420bad336c0edf13492d">Sortie</a>.</p>

<p>Definition at line <a class="el" href="Sortie__Nulle_8cpp_source.html#l00067">67</a> of file <a class="el" href="Sortie__Nulle_8cpp_source.html">Sortie_Nulle.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">return</span> *<span class="keyword">this</span>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="adacf99dd516b5a5e9ada32e58012a731"></a><!-- doxytag: member="Sortie_Nulle::operator&lt;&lt;" ref="adacf99dd516b5a5e9ada32e58012a731" args="(const char *ob)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSortie.html">Sortie</a> &amp; Sortie_Nulle::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>ob</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Ecriture d'une chaine de caracteres. Attention, pour pouvoir<br/>
relire correctement la chaine en mode ascii, celle-ci ne doit<br/>
pas contenir de separateur (ni espace, ni retour a la ligne, ...) </p>

<p>Reimplemented from <a class="el" href="classSortie.html#a42d6162d4c64ce999be1bcb4509912d0">Sortie</a>.</p>

<p>Definition at line <a class="el" href="Sortie__Nulle_8cpp_source.html#l00071">71</a> of file <a class="el" href="Sortie__Nulle_8cpp_source.html">Sortie_Nulle.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">return</span> *<span class="keyword">this</span>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a9d2a4c4fe49117792c5db9fcf6e25bf0"></a><!-- doxytag: member="Sortie_Nulle::operator&lt;&lt;" ref="a9d2a4c4fe49117792c5db9fcf6e25bf0" args="(const int &amp;ob)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSortie.html">Sortie</a> &amp; Sortie_Nulle::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>ob</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Methode de bas niveau pour ecrire un int ou flottant dans le stream.<br/>
Dans l'implementation de la classe de base, on ecrit dans ostream_.<br/>
En binaire on utilise ostream::write(), en ascii ostream::operato&lt;&lt;() </p>

<p>Reimplemented from <a class="el" href="classSortie.html#a1c0e2f2fe5f2c09566033dc2a3e861b9">Sortie</a>.</p>

<p>Definition at line <a class="el" href="Sortie__Nulle_8cpp_source.html#l00049">49</a> of file <a class="el" href="Sortie__Nulle_8cpp_source.html">Sortie_Nulle.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">return</span> *<span class="keyword">this</span>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a97fcd96fa14bab25399767d94b2bd4f3"></a><!-- doxytag: member="Sortie_Nulle::operator&lt;&lt;" ref="a97fcd96fa14bab25399767d94b2bd4f3" args="(const unsigned &amp;ob)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSortie.html">Sortie</a> &amp; Sortie_Nulle::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">const unsigned &amp;&#160;</td>
          <td class="paramname"><em>ob</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Methode de bas niveau pour ecrire un int ou flottant dans le stream.<br/>
Dans l'implementation de la classe de base, on ecrit dans ostream_.<br/>
En binaire on utilise ostream::write(), en ascii ostream::operato&lt;&lt;() </p>

<p>Reimplemented from <a class="el" href="classSortie.html#adcd343c7639877812a5822bb3b8cb49c">Sortie</a>.</p>

<p>Definition at line <a class="el" href="Sortie__Nulle_8cpp_source.html#l00053">53</a> of file <a class="el" href="Sortie__Nulle_8cpp_source.html">Sortie_Nulle.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">return</span> *<span class="keyword">this</span>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a76d40d58e47cbe9d0addbb29df554f69"></a><!-- doxytag: member="Sortie_Nulle::precision" ref="a76d40d58e47cbe9d0addbb29df554f69" args="(int)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Sortie_Nulle::precision </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pre</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="classSortie.html#a846ea173fd5e5b18fa2a0764f39724e3">Sortie</a>.</p>

<p>Definition at line <a class="el" href="Sortie__Nulle_8cpp_source.html#l00039">39</a> of file <a class="el" href="Sortie__Nulle_8cpp_source.html">Sortie_Nulle.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{}
</pre></div>
</div>
</div>
<a class="anchor" id="ae11686de240fce6d2b175ab9b2123646"></a><!-- doxytag: member="Sortie_Nulle::put" ref="ae11686de240fce6d2b175ab9b2123646" args="(const long *ob, int n, int pas=1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Sortie_Nulle::put </td>
          <td>(</td>
          <td class="paramtype">const long *&#160;</td>
          <td class="paramname"><em>ob</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nb_colonnes</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Methode de bas niveau pour ecrire un tableau d'ints ou reels dans le stream.<br/>
Dans l'implementation de la classe de base, on ecrit dans ostream_.<br/>
En binaire on utilise ostream::write(), en ascii ostream::operato&lt;&lt;()<br/>
En ascii, on revient a la ligne chaque fois qu'on a ecrit "nb_col" valeurs et a la<br/>
fin du tableau.<br/>
Valeur de retour : ostream_-&gt;good() </p>

<p>Reimplemented from <a class="el" href="classSortie.html#a2cfe3a4ebb18061eb88d1375b43aa839">Sortie</a>.</p>

<p>Definition at line <a class="el" href="Sortie__Nulle_8cpp_source.html#l00086">86</a> of file <a class="el" href="Sortie__Nulle_8cpp_source.html">Sortie_Nulle.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">return</span> 1;
}
</pre></div>
</div>
</div>
<a class="anchor" id="aba04d345fa57605634ea89027b849da6"></a><!-- doxytag: member="Sortie_Nulle::put" ref="aba04d345fa57605634ea89027b849da6" args="(const int *ob, int n, int pas=1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Sortie_Nulle::put </td>
          <td>(</td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>ob</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nb_colonnes</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Methode de bas niveau pour ecrire un tableau d'ints ou reels dans le stream.<br/>
Dans l'implementation de la classe de base, on ecrit dans ostream_.<br/>
En binaire on utilise ostream::write(), en ascii ostream::operato&lt;&lt;()<br/>
En ascii, on revient a la ligne chaque fois qu'on a ecrit "nb_col" valeurs et a la<br/>
fin du tableau.<br/>
Valeur de retour : ostream_-&gt;good() </p>

<p>Reimplemented from <a class="el" href="classSortie.html#accee158a4354a9f13a3e21f7d73d4b3d">Sortie</a>.</p>

<p>Definition at line <a class="el" href="Sortie__Nulle_8cpp_source.html#l00081">81</a> of file <a class="el" href="Sortie__Nulle_8cpp_source.html">Sortie_Nulle.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">return</span> 1;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a530b2e93a94713df77af77ecf5b8fc57"></a><!-- doxytag: member="Sortie_Nulle::put" ref="a530b2e93a94713df77af77ecf5b8fc57" args="(const unsigned *ob, int n, int pas=1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Sortie_Nulle::put </td>
          <td>(</td>
          <td class="paramtype">const unsigned *&#160;</td>
          <td class="paramname"><em>ob</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nb_colonnes</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Methode de bas niveau pour ecrire un tableau d'ints ou reels dans le stream.<br/>
Dans l'implementation de la classe de base, on ecrit dans ostream_.<br/>
En binaire on utilise ostream::write(), en ascii ostream::operato&lt;&lt;()<br/>
En ascii, on revient a la ligne chaque fois qu'on a ecrit "nb_col" valeurs et a la<br/>
fin du tableau.<br/>
Valeur de retour : ostream_-&gt;good() </p>

<p>Reimplemented from <a class="el" href="classSortie.html#aa3f46aaccaff0f83c018784b50d8ea24">Sortie</a>.</p>

<p>Definition at line <a class="el" href="Sortie__Nulle_8cpp_source.html#l00076">76</a> of file <a class="el" href="Sortie__Nulle_8cpp_source.html">Sortie_Nulle.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">return</span> 1;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a0e440f5f3d82599959f83f6d5482510c"></a><!-- doxytag: member="Sortie_Nulle::put" ref="a0e440f5f3d82599959f83f6d5482510c" args="(const float *ob, int n, int pas=1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Sortie_Nulle::put </td>
          <td>(</td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>ob</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nb_colonnes</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Methode de bas niveau pour ecrire un tableau d'ints ou reels dans le stream.<br/>
Dans l'implementation de la classe de base, on ecrit dans ostream_.<br/>
En binaire on utilise ostream::write(), en ascii ostream::operato&lt;&lt;()<br/>
En ascii, on revient a la ligne chaque fois qu'on a ecrit "nb_col" valeurs et a la<br/>
fin du tableau.<br/>
Valeur de retour : ostream_-&gt;good() </p>

<p>Reimplemented from <a class="el" href="classSortie.html#a0dc36cb9e13f5be19a28b5e763e67e60">Sortie</a>.</p>

<p>Definition at line <a class="el" href="Sortie__Nulle_8cpp_source.html#l00090">90</a> of file <a class="el" href="Sortie__Nulle_8cpp_source.html">Sortie_Nulle.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">return</span> 1;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a1f8a33f73945698574f1699703066f40"></a><!-- doxytag: member="Sortie_Nulle::put" ref="a1f8a33f73945698574f1699703066f40" args="(const double *ob, int n, int pas=1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Sortie_Nulle::put </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>ob</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nb_colonnes</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Methode de bas niveau pour ecrire un tableau d'ints ou reels dans le stream.<br/>
Dans l'implementation de la classe de base, on ecrit dans ostream_.<br/>
En binaire on utilise ostream::write(), en ascii ostream::operato&lt;&lt;()<br/>
En ascii, on revient a la ligne chaque fois qu'on a ecrit "nb_col" valeurs et a la<br/>
fin du tableau.<br/>
Valeur de retour : ostream_-&gt;good() </p>

<p>Reimplemented from <a class="el" href="classSortie.html#a3ccfdd7f9f0e258d5193758d25b28b1d">Sortie</a>.</p>

<p>Definition at line <a class="el" href="Sortie__Nulle_8cpp_source.html#l00094">94</a> of file <a class="el" href="Sortie__Nulle_8cpp_source.html">Sortie_Nulle.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">return</span> 1;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a9217c458c8dd332fdc3fcd8a38e16b6b"></a><!-- doxytag: member="Sortie_Nulle::setf" ref="a9217c458c8dd332fdc3fcd8a38e16b6b" args="(std::_Ios_Fmtflags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Sortie_Nulle::setf </td>
          <td>(</td>
          <td class="paramtype">std::_Ios_Fmtflags&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="classSortie.html#a05322f1a56de2325a18095d3eea2e0a3">Sortie</a>.</p>

<p>Definition at line <a class="el" href="Sortie__Nulle_8cpp_source.html#l00038">38</a> of file <a class="el" href="Sortie__Nulle_8cpp_source.html">Sortie_Nulle.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{}
</pre></div>
</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/Kernel/Utilitaires/<a class="el" href="Sortie__Nulle_8h_source.html">Sortie_Nulle.h</a></li>
<li>src/Kernel/Utilitaires/<a class="el" href="Sortie__Nulle_8cpp_source.html">Sortie_Nulle.cpp</a></li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Tue Dec 14 2021 19:37:54 for TRUST by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
