<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>TRUST: src/Kernel/Math/SolvSys/SSOR.cpp Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">TRUST&#160;<span id="projectnumber">1.8.4</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
<div class="header">
  <div class="headertitle">
<div class="title">src/Kernel/Math/SolvSys/SSOR.cpp</div>  </div>
</div>
<div class="contents">
<a href="SSOR_8cpp.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/****************************************************************************</span>
<a name="l00002"></a>00002 <span class="comment">* Copyright (c) 2015 - 2016, CEA</span>
<a name="l00003"></a>00003 <span class="comment">* All rights reserved.</span>
<a name="l00004"></a>00004 <span class="comment">*</span>
<a name="l00005"></a>00005 <span class="comment">* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</span>
<a name="l00006"></a>00006 <span class="comment">* 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.</span>
<a name="l00007"></a>00007 <span class="comment">* 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.</span>
<a name="l00008"></a>00008 <span class="comment">* 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.</span>
<a name="l00009"></a>00009 <span class="comment">*</span>
<a name="l00010"></a>00010 <span class="comment">* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.</span>
<a name="l00011"></a>00011 <span class="comment">* IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;</span>
<a name="l00012"></a>00012 <span class="comment">* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>
<a name="l00013"></a>00013 <span class="comment">*</span>
<a name="l00014"></a>00014 <span class="comment">*****************************************************************************/</span>
<a name="l00015"></a>00015 <span class="comment">//</span>
<a name="l00016"></a>00016 <span class="comment">// </span>
<a name="l00017"></a>00017 <span class="comment">// File:        SSOR.cpp</span>
<a name="l00018"></a>00018 <span class="comment">// Directory:   $TRUST_ROOT/src/Kernel/Math/SolvSys</span>
<a name="l00019"></a>00019 <span class="comment">// Version:     /main/integration_fauchet_164/1</span>
<a name="l00020"></a>00020 <span class="comment">// </span>
<a name="l00021"></a>00021 <span class="comment">//</span>
<a name="l00022"></a>00022 <span class="comment">// </span>
<a name="l00023"></a>00023 <span class="comment">// WARNING: DO NOT EDIT THIS FILE! Only edit the template file SSOR.cpp.P</span>
<a name="l00024"></a>00024 <span class="comment">// </span>
<a name="l00025"></a>00025 
<a name="l00026"></a>00026 <span class="preprocessor">#include &lt;<a class="code" href="SSOR_8h.html">SSOR.h</a>&gt;</span>
<a name="l00027"></a>00027 <span class="preprocessor">#include &lt;<a class="code" href="Motcle_8h.html">Motcle.h</a>&gt;</span>
<a name="l00028"></a>00028 <span class="preprocessor">#include &lt;<a class="code" href="Matrice__Morse__Sym_8h.html">Matrice_Morse_Sym.h</a>&gt;</span>
<a name="l00029"></a>00029 <span class="preprocessor">#include &lt;<a class="code" href="Matrice__Bloc__Sym_8h.html">Matrice_Bloc_Sym.h</a>&gt;</span>
<a name="l00030"></a>00030 <span class="preprocessor">#include &lt;<a class="code" href="MD__Vector__tools_8h.html">MD_Vector_tools.h</a>&gt;</span>
<a name="l00031"></a>00031 <span class="preprocessor">#include &lt;<a class="code" href="MD__Vector__base_8h.html">MD_Vector_base.h</a>&gt;</span>
<a name="l00032"></a>00032 <span class="preprocessor">#include &lt;<a class="code" href="Param_8h.html">Param.h</a>&gt;</span>
<a name="l00033"></a>00033 <span class="preprocessor">#include &lt;<a class="code" href="ConstDoubleTab__parts_8h.html">ConstDoubleTab_parts.h</a>&gt;</span>
<a name="l00034"></a>00034 
<a name="l00035"></a>00035 
<a name="l00036"></a><a class="code" href="SSOR_8cpp.html#a15de6481f99a47c9ed659ff5adf54e64">00036</a> <a class="code" href="Declare__Inst_8h.html#afcab3f7633508e92f2077d767e19bc60">Implemente_instanciable_sans_constructeur</a>(<a class="code" href="classSSOR.html">SSOR</a>,<span class="stringliteral">&quot;SSOR&quot;</span>,<a class="code" href="classPrecond__base.html">Precond_base</a>);
<a name="l00037"></a>00037 <span class="comment">// </span>
<a name="l00038"></a>00038 <span class="comment">// printOn et readOn ddddd</span>
<a name="l00039"></a>00039 
<a name="l00040"></a><a class="code" href="classSSOR.html#a990400a8b59d63fb6895243b7712ebb5">00040</a> <a class="code" href="classSortie.html" title="Classe de base des flux de sortie. Elle sait ecrire des types simples&lt;br&gt;(entiers, flottants) et des Ob...">Sortie</a>&amp; <a class="code" href="classSSOR.html#a990400a8b59d63fb6895243b7712ebb5" title="Ecriture de l&#39;objet sur un flot de sortie Methode a surcharger.">SSOR::printOn</a>(<a class="code" href="classSortie.html" title="Classe de base des flux de sortie. Elle sait ecrire des types simples&lt;br&gt;(entiers, flottants) et des Ob...">Sortie</a>&amp; s )<span class="keyword"> const</span>
<a name="l00041"></a>00041 <span class="keyword"></span>{
<a name="l00042"></a>00042   s &lt;&lt; <span class="stringliteral">&quot; { omega  &quot;</span>&lt;&lt;<a class="code" href="classSSOR.html#abcfe9ade190627842b923d8bb78eec38">omega_</a> &lt;&lt; <span class="stringliteral">&quot; } &quot;</span>;
<a name="l00043"></a>00043   <span class="keywordflow">return</span> s;
<a name="l00044"></a>00044 }
<a name="l00045"></a>00045 
<a name="l00046"></a><a class="code" href="classSSOR.html#ababb2d794d89dadfa73b927cd81e88c7">00046</a> <a class="code" href="classEntree.html" title="Classe de definition des operateurs et methodes pour toute lecture dans un flot d&#39;entree (fichier...">Entree</a>&amp; <a class="code" href="classSSOR.html#ababb2d794d89dadfa73b927cd81e88c7" title="Lecture d&#39;un Objet_U sur un flot d&#39;entree Methode a surcharger.">SSOR::readOn</a>(<a class="code" href="classEntree.html" title="Classe de definition des operateurs et methodes pour toute lecture dans un flot d&#39;entree (fichier...">Entree</a>&amp; is )
<a name="l00047"></a>00047 {
<a name="l00048"></a>00048   <a class="code" href="classParam.html" title="Defined below in this file.">Param</a> param(<a class="code" href="classObjet__U.html#aa58e9a81c0ddc2c1149053b8f96698ac" title="renvoie la chaine identifiant la classe.">que_suis_je</a>());
<a name="l00049"></a>00049   param.<a class="code" href="classParam.html#affb8a0102361201ba896bac7ca8bc21c">ajouter</a>(<span class="stringliteral">&quot;omega&quot;</span>, &amp;<a class="code" href="classSSOR.html#abcfe9ade190627842b923d8bb78eec38">omega_</a>);
<a name="l00050"></a>00050   param.<a class="code" href="classParam.html#aea52f16d3b74c59c48cb5708ff48f14a">lire_avec_accolades</a>(is);
<a name="l00051"></a>00051 
<a name="l00052"></a>00052   <span class="keywordflow">if</span> (omega_ &lt;= 0. || omega_ &gt;= 2.)
<a name="l00053"></a>00053     {
<a name="l00054"></a>00054       <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;SSOR::readOn, omega is not within [0, 2]: SSOR not activated (you should use precond nul instead) &quot;</span>  &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
<a name="l00055"></a>00055     }
<a name="l00056"></a>00056   <span class="keywordflow">return</span> is;
<a name="l00057"></a>00057 }
<a name="l00058"></a>00058 
<a name="l00059"></a>00059 
<a name="l00060"></a><a class="code" href="classSSOR.html#a432953b87634ff31525376884aa096fc">00060</a> <a class="code" href="classSSOR.html#a432953b87634ff31525376884aa096fc">SSOR::SSOR</a>()
<a name="l00061"></a>00061 {
<a name="l00062"></a>00062   <a class="code" href="classSSOR.html#abcfe9ade190627842b923d8bb78eec38">omega_</a> = 1.6;
<a name="l00063"></a>00063   <a class="code" href="classSSOR.html#a60510dc39661fe9e59c4abf218702cf0">algo_items_communs_</a> = -1;
<a name="l00064"></a>00064   <a class="code" href="classSSOR.html#a725cf5261b6866015aba87d80228fd99">line_size_</a> = 0;
<a name="l00065"></a>00065 }
<a name="l00066"></a>00066 <span class="comment"></span>
<a name="l00067"></a>00067 <span class="comment">//! See Precond_base::prepare_()</span>
<a name="l00068"></a><a class="code" href="classSSOR.html#a972f1918ee74fa6fcc93be03e12fed3d">00068</a> <span class="comment"></span><span class="keywordtype">void</span> <a class="code" href="classSSOR.html#a972f1918ee74fa6fcc93be03e12fed3d" title="See Precond_base::prepare_()">SSOR::prepare_</a>(<span class="keyword">const</span> <a class="code" href="classMatrice__Base.html">Matrice_Base</a>&amp; la_matrice, <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; secmem)
<a name="l00069"></a>00069 {
<a name="l00070"></a>00070   <span class="keywordflow">if</span> (<a class="code" href="classPrecond__base.html#aa800d84d0dcc4ac5b199a3fe06c86e50">get_status</a>() &gt;= <a class="code" href="classPrecond__base.html#a1c72f8083998114548f759cd941d36caa68664bb0807d39c1ebf0e700ac33c6de">REINIT_ALL</a>)
<a name="l00071"></a>00071     {
<a name="l00072"></a>00072       <a class="code" href="classSSOR.html#ab7a055596252ee784e6aa1abe801e37c">md_secmem_</a> = secmem.<a class="code" href="classDoubleVect.html#a0d16d30580c90526e4895388fb44be5d">get_md_vector</a>();
<a name="l00073"></a>00073       <a class="code" href="classSSOR.html#a725cf5261b6866015aba87d80228fd99">line_size_</a> = secmem.<a class="code" href="classDoubleVect.html#ab02d01cd1bdab66fbd66f9a47cc29e10">line_size</a>();
<a name="l00074"></a>00074 <span class="comment">// Pour le prochain preconditionnement, verifier la matrice</span>
<a name="l00075"></a>00075       <a class="code" href="classSSOR.html#aa3cf956c10714ac36505c46e59d1b9dd">avec_assert_</a> = 1;
<a name="l00076"></a>00076 
<a name="l00077"></a>00077       <span class="keywordflow">if</span> (<a class="code" href="classProcess.html#a6bf692ce58d9578aa62ac3c07b8caaa1" title="renvoie le nombre de processeurs dans le groupe courant Voir Comm_Group::nproc() et PE_Groups::curren...">nproc</a>() == 1 || !(<a class="code" href="classSSOR.html#ab7a055596252ee784e6aa1abe801e37c">md_secmem_</a>.<a class="code" href="classMD__Vector.html#a4165c00904b7096274e38fdc7ca340f4">non_nul</a>()))
<a name="l00078"></a>00078         {
<a name="l00079"></a>00079           <a class="code" href="classSSOR.html#a60510dc39661fe9e59c4abf218702cf0">algo_items_communs_</a> = 0;
<a name="l00080"></a>00080         }
<a name="l00081"></a>00081       <span class="keywordflow">else</span>
<a name="l00082"></a>00082         {
<a name="l00083"></a>00083 <span class="comment">// Nombre d&#39;items sequentiels sur ce proc</span>
<a name="l00084"></a>00084           <span class="keyword">const</span> <span class="keywordtype">int</span> sz_tot = secmem.<a class="code" href="classDoubleVect.html#ad2d21b364e1c6559771970596a25c006" title="Identique a size_array()">size_totale</a>();
<a name="l00085"></a>00085           <a class="code" href="classSSOR.html#af396301be15d933e2cf1b55cf65a2420">items_a_traiter_</a>.<a class="code" href="classIntTab.html#ac66710ddde96fe2745f341a0166b3b34" title="met le tableau dans l&#39;etat obtenu par le constructeur par defaut voir IntVect::reset()">reset</a>();
<a name="l00086"></a>00086           <a class="code" href="classSSOR.html#af396301be15d933e2cf1b55cf65a2420">items_a_traiter_</a>.<a class="code" href="classIntTab.html#a22e6bed6826b3688d4d0181cbf3b7a38" title="Change la taille du vecteur (identique a resize_array() pour le traitement des anciennes valeurs et d...">resize</a>(sz_tot / <a class="code" href="classSSOR.html#a725cf5261b6866015aba87d80228fd99">line_size_</a>, <a class="code" href="classSSOR.html#a725cf5261b6866015aba87d80228fd99">line_size_</a>, <a class="code" href="classArray__base.html#abee342aa9ac59623c4c782dc9d7877ffaf6ae9ba7eb51c5f298ce693345b3ec68">Array_base::NOCOPY_NOINIT</a>);
<a name="l00087"></a>00087           <a class="code" href="classSSOR.html#af396301be15d933e2cf1b55cf65a2420">items_a_traiter_</a>.<a class="code" href="classIntTab.html#a02470d5d5921700f4daee05a5b3d2601" title="associe le md_vector au vecteur (voir IntVect::set_md_vector()) dimension(0) sera initialise a md_vec...">set_md_vector</a>(<a class="code" href="classSSOR.html#ab7a055596252ee784e6aa1abe801e37c">md_secmem_</a>);
<a name="l00088"></a>00088           <span class="keywordtype">int</span> n = <a class="code" href="classMD__Vector__tools.html#ad099d2407b0016920bd8c667a56fddd8">MD_Vector_tools::get_sequential_items_flags</a>(<a class="code" href="classSSOR.html#ab7a055596252ee784e6aa1abe801e37c">md_secmem_</a>, <a class="code" href="classSSOR.html#af396301be15d933e2cf1b55cf65a2420">items_a_traiter_</a>, <a class="code" href="classSSOR.html#a725cf5261b6866015aba87d80228fd99">line_size_</a>);
<a name="l00089"></a>00089           <span class="keywordtype">int</span> <a class="code" href="Nom_8cpp.html#a0e1ea19fb9fa7881d15d84eff4c090e1">sz</a> = <a class="code" href="classSSOR.html#ab7a055596252ee784e6aa1abe801e37c">md_secmem_</a>.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#ade0ef13d456f8aa11d02f51fd7912145">get_nb_items_reels</a>();
<a name="l00090"></a>00090 
<a name="l00091"></a>00091           <span class="keywordflow">if</span> (sz &lt; 0) <span class="comment">//!&lt; size() est invalide, les items reels ne sont pas groupes a debut !</span>
<a name="l00092"></a>00092 <span class="comment"></span>            <a class="code" href="classSSOR.html#a60510dc39661fe9e59c4abf218702cf0">algo_items_communs_</a> = 1;
<a name="l00093"></a>00093           <span class="keywordflow">else</span>
<a name="l00094"></a>00094             {
<a name="l00095"></a>00095               assert(sz &gt;= n);
<a name="l00096"></a>00096               <span class="keywordflow">if</span> (<a class="code" href="classProcess.html#a7d23bc1ef94b3f0623fbc79d034c27fd" title="Calcule la somme de x sur tous les processeurs du groupe courant. Voir aussi mp_max()">mp_sum</a>(sz) &gt; <a class="code" href="classProcess.html#a7d23bc1ef94b3f0623fbc79d034c27fd" title="Calcule la somme de x sur tous les processeurs du groupe courant. Voir aussi mp_max()">mp_sum</a>(n))
<a name="l00097"></a>00097                 <a class="code" href="classSSOR.html#a60510dc39661fe9e59c4abf218702cf0">algo_items_communs_</a> = 1; <span class="comment">//!&lt; Il y a des items partages parmi les items reels</span>
<a name="l00098"></a>00098 <span class="comment"></span>              <span class="keywordflow">else</span>
<a name="l00099"></a>00099                 {
<a name="l00100"></a>00100                   <a class="code" href="classSSOR.html#a60510dc39661fe9e59c4abf218702cf0">algo_items_communs_</a> = 0;
<a name="l00101"></a>00101                   <a class="code" href="classSSOR.html#af396301be15d933e2cf1b55cf65a2420">items_a_traiter_</a>.<a class="code" href="classIntTab.html#ac66710ddde96fe2745f341a0166b3b34" title="met le tableau dans l&#39;etat obtenu par le constructeur par defaut voir IntVect::reset()">reset</a>();
<a name="l00102"></a>00102                 }
<a name="l00103"></a>00103             }
<a name="l00104"></a>00104         }
<a name="l00105"></a>00105     }
<a name="l00106"></a>00106 
<a name="l00107"></a>00107   <span class="keywordflow">if</span> (<a class="code" href="classPrecond__base.html#aa800d84d0dcc4ac5b199a3fe06c86e50">get_status</a>() &gt;= <a class="code" href="classPrecond__base.html#a1c72f8083998114548f759cd941d36caae5c7bd9d36f3b6a71b1d1b3497567581">REINIT_COEFF</a>)
<a name="l00108"></a>00108     {
<a name="l00109"></a>00109     }
<a name="l00110"></a>00110   <a class="code" href="classSSOR.html#a972f1918ee74fa6fcc93be03e12fed3d" title="See Precond_base::prepare_()">Precond_base::prepare_</a>(la_matrice, secmem);
<a name="l00111"></a>00111 }
<a name="l00112"></a>00112 
<a name="l00113"></a>00113 <span class="comment">//</span>
<a name="l00114"></a>00114 <span class="comment">//</span><span class="comment"></span>
<a name="l00115"></a>00115 <span class="comment">//! Calcule la solution du systeme lineaire: A * solution = b&lt;br&gt;avec la methode de relaxation SSOR.</span>
<a name="l00116"></a><a class="code" href="classSSOR.html#a04448488b0aca9fd6fc91b794ad40941">00116</a> <span class="comment"></span><span class="keywordtype">int</span> <a class="code" href="classSSOR.html#a04448488b0aca9fd6fc91b794ad40941" title="Calcule la solution du systeme lineaire: A * solution = b avec la methode de relaxation SSOR...">SSOR::preconditionner_</a>(<span class="keyword">const</span> <a class="code" href="classMatrice__Base.html">Matrice_Base</a>&amp; la_matrice,
<a name="l00117"></a>00117                            <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; b,
<a name="l00118"></a>00118                            <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; solution)
<a name="l00119"></a>00119 {
<a name="l00120"></a>00120 <span class="comment">// pour compatibilite historique:</span>
<a name="l00121"></a>00121   <span class="keywordflow">if</span> (omega_ &lt;= 0. || omega_ &gt;= 2)
<a name="l00122"></a>00122     {
<a name="l00123"></a>00123       <a class="code" href="DoubleVect_8cpp.html#ad0e13908fed9f476adc797982dce010a">operator_egal</a>(solution, b);
<a name="l00124"></a>00124       <span class="keywordflow">return</span> 1;
<a name="l00125"></a>00125     }
<a name="l00126"></a>00126 
<a name="l00127"></a>00127   <a class="code" href="DoubleVect_8cpp.html#ad0e13908fed9f476adc797982dce010a">operator_egal</a>(solution, b);
<a name="l00128"></a>00128 
<a name="l00129"></a>00129   <span class="keywordflow">if</span>(<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classMatrice__Morse__Sym.html" title="Classe Matrice_Morse_Sym Represente une matrice M (creuse) symetrique stockee au format Morse Symetri...">Matrice_Morse_Sym</a>,la_matrice))
<a name="l00130"></a>00130     {
<a name="l00131"></a>00131       <span class="keyword">const</span> <a class="code" href="classMatrice__Morse__Sym.html" title="Classe Matrice_Morse_Sym Represente une matrice M (creuse) symetrique stockee au format Morse Symetri...">Matrice_Morse_Sym</a>&amp; matrice = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Morse__Sym.html" title="Classe Matrice_Morse_Sym Represente une matrice M (creuse) symetrique stockee au format Morse Symetri...">Matrice_Morse_Sym</a>, la_matrice);
<a name="l00132"></a>00132       <a class="code" href="classSSOR.html#a92a21f1643fbe5ee8fcb25096f59722c">ssor</a>(matrice, solution);
<a name="l00133"></a>00133     }
<a name="l00134"></a>00134   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classMatrice__Bloc__Sym.html">Matrice_Bloc_Sym</a>, la_matrice))
<a name="l00135"></a>00135     {
<a name="l00136"></a>00136 <span class="comment">// Matrice correspondant a un vecteur multi-localisation (MD_Vector_composite)</span>
<a name="l00137"></a>00137       <span class="keyword">const</span> <a class="code" href="classMatrice__Bloc__Sym.html">Matrice_Bloc_Sym</a>&amp; matrice = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Bloc__Sym.html">Matrice_Bloc_Sym</a>, la_matrice);
<a name="l00138"></a>00138       <a class="code" href="classSSOR.html#a92a21f1643fbe5ee8fcb25096f59722c">ssor</a>(matrice, solution);
<a name="l00139"></a>00139     }
<a name="l00140"></a>00140   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classMatrice__Bloc.html">Matrice_Bloc</a>, la_matrice))
<a name="l00141"></a>00141     {
<a name="l00142"></a>00142 <span class="comment">// On suppose une matrice reelle-reelle et une matrice reelle-virtuelle</span>
<a name="l00143"></a>00143       <span class="keyword">const</span> <a class="code" href="classMatrice__Bloc.html">Matrice_Bloc</a>&amp; mat = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Bloc.html">Matrice_Bloc</a>, la_matrice);
<a name="l00144"></a>00144       <span class="keyword">const</span> <a class="code" href="classMatrice__Morse__Sym.html" title="Classe Matrice_Morse_Sym Represente une matrice M (creuse) symetrique stockee au format Morse Symetri...">Matrice_Morse_Sym</a>&amp; matrice = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Morse__Sym.html" title="Classe Matrice_Morse_Sym Represente une matrice M (creuse) symetrique stockee au format Morse Symetri...">Matrice_Morse_Sym</a>, mat.<a class="code" href="classMatrice__Bloc.html#a7ffa38f7b93454432b2df7c616ed0a4e">get_bloc</a>(0,0).<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>());
<a name="l00145"></a>00145       <a class="code" href="classSSOR.html#a92a21f1643fbe5ee8fcb25096f59722c">ssor</a>(matrice, solution);
<a name="l00146"></a>00146     }
<a name="l00147"></a>00147   <span class="keywordflow">else</span>
<a name="l00148"></a>00148     {
<a name="l00149"></a>00149       <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;SSOR::preconditionner not coded for type &quot;</span> &lt;&lt; la_matrice.<a class="code" href="classObjet__U.html#aa58e9a81c0ddc2c1149053b8f96698ac" title="renvoie la chaine identifiant la classe.">que_suis_je</a>() &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
<a name="l00150"></a>00150       <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">exit</a>();
<a name="l00151"></a>00151     }
<a name="l00152"></a>00152   <span class="keywordflow">if</span> (<a class="code" href="classPrecond__base.html#a848534097f89d1f25993059450e7b0d2">echange_ev_solution_</a>)
<a name="l00153"></a>00153     solution.<a class="code" href="classDoubleVect.html#abfebbc2f685ce7bc4b80c720d7da9bf3">echange_espace_virtuel</a>();
<a name="l00154"></a>00154   <span class="keywordflow">return</span> 1;
<a name="l00155"></a>00155 }
<a name="l00156"></a>00156 
<a name="l00157"></a>00157 
<a name="l00158"></a>00158 
<a name="l00159"></a>00159 
<a name="l00160"></a>00160 
<a name="l00161"></a><a class="code" href="SSOR_8cpp.html#a83a12abf0d3d0650563cba68e988b4fd">00161</a> <span class="keywordtype">void</span> <a class="code" href="SSOR_8cpp.html#a83a12abf0d3d0650563cba68e988b4fd">traite_diagonale</a>(<span class="keyword">const</span> <span class="keywordtype">double</span> omega, <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; tab1, <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; tab2, <span class="keyword">const</span> <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a>&amp; <a class="code" href="Champ__P1iP1B__implementation_8cpp.html#aa8c8f49390c3cf7c702d71a71bc977e3">coeff</a>,
<a name="l00162"></a>00162                       <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; vecteur)
<a name="l00163"></a>00163 {
<a name="l00164"></a>00164   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_lignes_a_traiter = vecteur.<a class="code" href="classDoubleVect.html#aafef4b3a96cdc428d62c5cedc9af6112">size_reelle_ok</a>() ? vecteur.<a class="code" href="classDoubleVect.html#a4a6987db458541cdcd10495955f25263" title="Taille de l&#39;espace &quot;reel&quot; du vecteur. (si md_vector_ est nul, cette valeur est identique a size_arr...">size_reelle</a>() : vecteur.<a class="code" href="classDoubleVect.html#ad2d21b364e1c6559771970596a25c006" title="Identique a size_array()">size_totale</a>();
<a name="l00165"></a>00165 
<a name="l00166"></a>00166   <span class="keyword">const</span> <span class="keywordtype">double</span> psi = (2. - omega) / omega;
<a name="l00167"></a>00167   <span class="keyword">const</span> <span class="keywordtype">double</span> *coeff_fortran = coeff.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() - 1; <span class="comment">//!&lt; indexable par index fortran</span>
<a name="l00168"></a>00168 <span class="comment"></span>  <span class="keyword">const</span> <span class="keywordtype">int</span> *tab1_ptr = tab1.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
<a name="l00169"></a>00169   <span class="keywordtype">double</span> *vect_ptr = vecteur.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
<a name="l00170"></a>00170   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = nb_lignes_a_traiter; i; i--, tab1_ptr++, vect_ptr++)
<a name="l00171"></a>00171     {
<a name="l00172"></a>00172       <span class="keyword">const</span> <span class="keywordtype">int</span> j = *tab1_ptr;
<a name="l00173"></a>00173 <span class="comment">// Coefficient diagonale de la ligne i:</span>
<a name="l00174"></a>00174       <span class="keyword">const</span> <span class="keywordtype">double</span> coeff_i_i = coeff_fortran[j];
<a name="l00175"></a>00175       (*vect_ptr) *= psi * coeff_i_i;
<a name="l00176"></a>00176     }
<a name="l00177"></a>00177 }
<a name="l00178"></a>00178 
<a name="l00179"></a><a class="code" href="SSOR_8cpp.html#a48c1a6c6f0d5c6cf939af4ddab0a7ba1">00179</a> <span class="keywordtype">void</span> <a class="code" href="SSOR_8cpp.html#a48c1a6c6f0d5c6cf939af4ddab0a7ba1">descente</a>(<span class="keyword">const</span> <span class="keywordtype">double</span> omega, <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; tab1, <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; tab2, <span class="keyword">const</span> <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a>&amp; <a class="code" href="Champ__P1iP1B__implementation_8cpp.html#aa8c8f49390c3cf7c702d71a71bc977e3">coeff</a>,
<a name="l00180"></a>00180               <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; vecteur
<a name="l00181"></a>00181              )
<a name="l00182"></a>00182 {
<a name="l00183"></a>00183   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_lignes_a_traiter = vecteur.<a class="code" href="classDoubleVect.html#aafef4b3a96cdc428d62c5cedc9af6112">size_reelle_ok</a>() ? vecteur.<a class="code" href="classDoubleVect.html#a4a6987db458541cdcd10495955f25263" title="Taille de l&#39;espace &quot;reel&quot; du vecteur. (si md_vector_ est nul, cette valeur est identique a size_arr...">size_reelle</a>() : vecteur.<a class="code" href="classDoubleVect.html#ad2d21b364e1c6559771970596a25c006" title="Identique a size_array()">size_totale</a>();
<a name="l00184"></a>00184 <span class="comment">// pointeur &quot;fortran&quot; vers le tableau solution (indexable avec index fortran)</span>
<a name="l00185"></a>00185 <span class="comment">// le pointeur est constant, pas le tableau pointe.</span>
<a name="l00186"></a>00186   <span class="keywordtype">double</span> * <span class="keyword">const</span> sol_fortran = vecteur.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() - 1;
<a name="l00187"></a>00187   <span class="keyword">const</span> <span class="keywordtype">int</span> *tab1_ptr = tab1.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
<a name="l00188"></a>00188   assert(nb_lignes_a_traiter &lt;= tab1.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() + 1);
<a name="l00189"></a>00189   assert(*tab1_ptr == 1); <span class="comment">//!&lt; sinon 2 lignes ci-dessous fausses.</span>
<a name="l00190"></a>00190 <span class="comment"></span>  <span class="keyword">const</span> <span class="keywordtype">int</span> *tab2_ptr = tab2.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
<a name="l00191"></a>00191   <span class="keyword">const</span> <span class="keywordtype">double</span> *coeff_ptr = coeff.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
<a name="l00192"></a>00192   <span class="keywordtype">int</span> last_tab1_de_i = *tab1_ptr;
<a name="l00193"></a>00193   tab1_ptr++;
<a name="l00194"></a>00194   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 1; i &lt;= nb_lignes_a_traiter; i++, tab1_ptr++)
<a name="l00195"></a>00195     {
<a name="l00196"></a>00196       <span class="keyword">const</span> <span class="keywordtype">int</span> tab1_de_i = *tab1_ptr; <span class="comment">//!&lt; = tab1[i]</span>
<a name="l00197"></a>00197 <span class="comment"></span>      <span class="keyword">const</span> <span class="keywordtype">int</span> nvois = tab1_de_i - last_tab1_de_i;
<a name="l00198"></a>00198       <span class="keyword">static_cast&lt;</span><span class="keywordtype">void</span><span class="keyword">&gt;</span> (0);
<a name="l00199"></a>00199       last_tab1_de_i = tab1_de_i;
<a name="l00200"></a>00200 <span class="comment">// Ce test doit rester, sinon on pollue les autres lignes du vecteur sol</span>
<a name="l00201"></a>00201 <span class="comment">// avec des valeurs dependant des items communs et virtuels</span>
<a name="l00202"></a>00202       {
<a name="l00203"></a>00203 <span class="comment">// Le premier coeff doit etre le coef diagonal et doit etre strictement positif</span>
<a name="l00204"></a>00204         <span class="keyword">static_cast&lt;</span><span class="keywordtype">void</span><span class="keyword">&gt;</span> (0);
<a name="l00205"></a>00205         <span class="keyword">const</span> <span class="keywordtype">double</span> omega_coeff_i_i = omega / (*coeff_ptr);
<a name="l00206"></a>00206         <span class="keyword">const</span> <span class="keywordtype">double</span> v_i = sol_fortran[i] *= omega_coeff_i_i;
<a name="l00207"></a>00207         tab2_ptr++;
<a name="l00208"></a>00208         coeff_ptr++;
<a name="l00209"></a>00209         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = nvois-1; j; j--, tab2_ptr++, coeff_ptr++)
<a name="l00210"></a>00210           {
<a name="l00211"></a>00211             <span class="keyword">const</span> <span class="keywordtype">int</span> i2 = *tab2_ptr; <span class="comment">//!&lt; indice de colonne pour le prochain coefficient</span>
<a name="l00212"></a>00212 <span class="comment"></span>            <span class="keyword">const</span> <span class="keywordtype">double</span> coeff_i_i2 = *coeff_ptr;
<a name="l00213"></a>00213 <span class="comment">// la matrice n&#39;a que des coeffs diagonaux superieurs et on a deja traite</span>
<a name="l00214"></a>00214 <span class="comment">// la diagonale, donc i2 &gt; i.</span>
<a name="l00215"></a>00215 <span class="comment">// Pas d&#39;items virtuels autorises !</span>
<a name="l00216"></a>00216             <span class="keyword">static_cast&lt;</span><span class="keywordtype">void</span><span class="keyword">&gt;</span> (0);
<a name="l00217"></a>00217 <span class="comment">// B.M.: ... en revanche, le test sur les items communs est superflu ici car</span>
<a name="l00218"></a>00218 <span class="comment">// la valeur sera annulee (voir **Annulation items communs**),</span>
<a name="l00219"></a>00219 <span class="comment">// gain de perfs si on ne fait pas le test</span>
<a name="l00220"></a>00220             sol_fortran[i2] -= coeff_i_i2 * v_i;
<a name="l00221"></a>00221           }
<a name="l00222"></a>00222       }
<a name="l00223"></a>00223     }
<a name="l00224"></a>00224 }
<a name="l00225"></a>00225 
<a name="l00226"></a>00226 
<a name="l00227"></a><a class="code" href="SSOR_8cpp.html#aa3e5b9c2942469b29c8e8f874897bbe1">00227</a> <span class="keywordtype">void</span> <a class="code" href="SSOR_8cpp.html#aa3e5b9c2942469b29c8e8f874897bbe1">remontee</a>(<span class="keyword">const</span> <span class="keywordtype">double</span> omega, <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; tab1, <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; tab2, <span class="keyword">const</span> <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a>&amp; <a class="code" href="Champ__P1iP1B__implementation_8cpp.html#aa8c8f49390c3cf7c702d71a71bc977e3">coeff</a>,
<a name="l00228"></a>00228               <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; vecteur
<a name="l00229"></a>00229              )
<a name="l00230"></a>00230 {
<a name="l00231"></a>00231   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_lignes_a_traiter = vecteur.<a class="code" href="classDoubleVect.html#aafef4b3a96cdc428d62c5cedc9af6112">size_reelle_ok</a>() ? vecteur.<a class="code" href="classDoubleVect.html#a4a6987db458541cdcd10495955f25263" title="Taille de l&#39;espace &quot;reel&quot; du vecteur. (si md_vector_ est nul, cette valeur est identique a size_arr...">size_reelle</a>() : vecteur.<a class="code" href="classDoubleVect.html#ad2d21b364e1c6559771970596a25c006" title="Identique a size_array()">size_totale</a>();
<a name="l00232"></a>00232   <span class="keyword">const</span> <span class="keywordtype">double</span> psi = (2. - omega) / omega;
<a name="l00233"></a>00233 
<a name="l00234"></a>00234 <span class="comment">// pointeur &quot;fortran&quot; vers le tableau solution (indexable avec index fortran)</span>
<a name="l00235"></a>00235   <span class="keyword">const</span> <span class="keywordtype">double</span> * <span class="keyword">const</span> sol_fortran = vecteur.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() - 1;
<a name="l00236"></a>00236   <span class="keyword">const</span> <span class="keywordtype">int</span> *tab1_ptr = tab1.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() + nb_lignes_a_traiter;
<a name="l00237"></a>00237   <span class="keywordtype">int</span> last_tab1_de_i = *tab1_ptr;
<a name="l00238"></a>00238   tab1_ptr--;
<a name="l00239"></a>00239 <span class="comment">// On ne va pas a la fin de tab2 car on n&#39;est pas sur que nb_lignes_a_traiter = tab1.size_array() :</span>
<a name="l00240"></a>00240 <span class="comment">// -2 car last_tab1_de_i est l&#39;indice du premier coefficient de la ligne suivante en fortran</span>
<a name="l00241"></a>00241 <span class="comment">// (dont -1 pour fortran-&gt;c et -1 pour passer au dernier coeff de la ligne precedente)</span>
<a name="l00242"></a>00242   <span class="keyword">const</span> <span class="keywordtype">int</span> *tab2_ptr = tab2.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() + last_tab1_de_i - 2;
<a name="l00243"></a>00243   <span class="keyword">const</span> <span class="keywordtype">double</span> *coeff_ptr = coeff.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() + last_tab1_de_i - 2;
<a name="l00244"></a>00244   <span class="keywordtype">double</span> * soli_ptr = vecteur.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() + nb_lignes_a_traiter - 1;
<a name="l00245"></a>00245   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = nb_lignes_a_traiter; i; i--, tab1_ptr--, soli_ptr--)
<a name="l00246"></a>00246     {
<a name="l00247"></a>00247       <span class="keyword">const</span> <span class="keywordtype">int</span> tab1_de_i = *tab1_ptr; <span class="comment">//!&lt; = tab1[i]</span>
<a name="l00248"></a>00248 <span class="comment"></span>      <span class="keyword">const</span> <span class="keywordtype">int</span> nvois = last_tab1_de_i - tab1_de_i;
<a name="l00249"></a>00249       <span class="keyword">static_cast&lt;</span><span class="keywordtype">void</span><span class="keyword">&gt;</span> (0);
<a name="l00250"></a>00250       last_tab1_de_i = tab1_de_i;
<a name="l00251"></a>00251 <span class="comment">// Ce test doit rester car il ne faut pas modifier sol[i] pour les items communs</span>
<a name="l00252"></a>00252 <span class="comment">// et virtuels (ils sont nuls et doivent le rester pour ne pas polluer les autres lignes):</span>
<a name="l00253"></a>00253       <span class="keywordflow">if</span> (1)
<a name="l00254"></a>00254         {
<a name="l00255"></a>00255 <span class="comment">// Operation &quot;diagonale&quot;:</span>
<a name="l00256"></a>00256           <span class="keywordtype">double</span> x = 0.;
<a name="l00257"></a>00257           <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = nvois-1; j; j--, tab2_ptr--, coeff_ptr--)
<a name="l00258"></a>00258             {
<a name="l00259"></a>00259               <span class="keyword">const</span> <span class="keywordtype">int</span> i2 = *tab2_ptr;
<a name="l00260"></a>00260               <span class="keyword">const</span> <span class="keywordtype">double</span> coeff_i_i2 = *coeff_ptr;
<a name="l00261"></a>00261 <span class="comment">// Operation nulle pour les items communs et virtuels</span>
<a name="l00262"></a>00262 <span class="comment">// (on a annule le second membre lors de la descente)</span>
<a name="l00263"></a>00263               x += coeff_i_i2 * sol_fortran[i2];
<a name="l00264"></a>00264             }
<a name="l00265"></a>00265 <span class="comment">// ici coeff_ptr est le coeff diagonal</span>
<a name="l00266"></a>00266           <span class="keyword">static_cast&lt;</span><span class="keywordtype">void</span><span class="keyword">&gt;</span> (0);
<a name="l00267"></a>00267           <span class="keyword">const</span> <span class="keywordtype">double</span> coeff_i_i = *coeff_ptr;
<a name="l00268"></a>00268           <span class="keyword">const</span> <span class="keywordtype">double</span> omega_coeff_i_i = omega / coeff_i_i;
<a name="l00269"></a>00269           *soli_ptr = (*soli_ptr) * psi * omega - x * omega_coeff_i_i;
<a name="l00270"></a>00270           coeff_ptr--;
<a name="l00271"></a>00271           tab2_ptr--;
<a name="l00272"></a>00272         }
<a name="l00273"></a>00273       <span class="keywordflow">else</span>
<a name="l00274"></a>00274         {
<a name="l00275"></a>00275           assert((*soli_ptr) == 0.);
<a name="l00276"></a>00276           coeff_ptr -= nvois;
<a name="l00277"></a>00277           tab2_ptr -= nvois;
<a name="l00278"></a>00278         }
<a name="l00279"></a>00279     }
<a name="l00280"></a>00280 }
<a name="l00281"></a>00281 
<a name="l00282"></a><a class="code" href="SSOR_8cpp.html#a906876e35c5c5c892130214cc4f9e66c">00282</a> <span class="keywordtype">void</span> <a class="code" href="SSOR_8cpp.html#a48c1a6c6f0d5c6cf939af4ddab0a7ba1">descente</a>(<span class="keyword">const</span> <span class="keywordtype">double</span> omega, <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; tab1, <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; tab2, <span class="keyword">const</span> <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a>&amp; <a class="code" href="Champ__P1iP1B__implementation_8cpp.html#aa8c8f49390c3cf7c702d71a71bc977e3">coeff</a>,
<a name="l00283"></a>00283               <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; vecteur
<a name="l00284"></a>00284               , <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; items_a_traiter
<a name="l00285"></a>00285              )
<a name="l00286"></a>00286 {
<a name="l00287"></a>00287   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_lignes_a_traiter = vecteur.<a class="code" href="classDoubleVect.html#aafef4b3a96cdc428d62c5cedc9af6112">size_reelle_ok</a>() ? vecteur.<a class="code" href="classDoubleVect.html#a4a6987db458541cdcd10495955f25263" title="Taille de l&#39;espace &quot;reel&quot; du vecteur. (si md_vector_ est nul, cette valeur est identique a size_arr...">size_reelle</a>() : vecteur.<a class="code" href="classDoubleVect.html#ad2d21b364e1c6559771970596a25c006" title="Identique a size_array()">size_totale</a>();
<a name="l00288"></a>00288 <span class="comment">// pointeur &quot;fortran&quot; vers le tableau solution (indexable avec index fortran)</span>
<a name="l00289"></a>00289 <span class="comment">// le pointeur est constant, pas le tableau pointe.</span>
<a name="l00290"></a>00290   <span class="keywordtype">double</span> * <span class="keyword">const</span> sol_fortran = vecteur.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() - 1;
<a name="l00291"></a>00291   <span class="keyword">const</span> <span class="keywordtype">int</span> *flags_ptr = items_a_traiter.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
<a name="l00292"></a>00292   assert(nb_lignes_a_traiter &lt;= items_a_traiter.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>());
<a name="l00293"></a>00293   <span class="keyword">const</span> <span class="keywordtype">int</span> *tab1_ptr = tab1.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
<a name="l00294"></a>00294   assert(nb_lignes_a_traiter &lt;= tab1.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() + 1);
<a name="l00295"></a>00295   assert(*tab1_ptr == 1); <span class="comment">//!&lt; sinon 2 lignes ci-dessous fausses.</span>
<a name="l00296"></a>00296 <span class="comment"></span>  <span class="keyword">const</span> <span class="keywordtype">int</span> *tab2_ptr = tab2.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
<a name="l00297"></a>00297   <span class="keyword">const</span> <span class="keywordtype">double</span> *coeff_ptr = coeff.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
<a name="l00298"></a>00298   <span class="keywordtype">int</span> last_tab1_de_i = *tab1_ptr;
<a name="l00299"></a>00299   tab1_ptr++;
<a name="l00300"></a>00300   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 1; i &lt;= nb_lignes_a_traiter; i++, tab1_ptr++)
<a name="l00301"></a>00301     {
<a name="l00302"></a>00302       <span class="keyword">const</span> <span class="keywordtype">int</span> tab1_de_i = *tab1_ptr; <span class="comment">//!&lt; = tab1[i]</span>
<a name="l00303"></a>00303 <span class="comment"></span>      <span class="keyword">const</span> <span class="keywordtype">int</span> nvois = tab1_de_i - last_tab1_de_i;
<a name="l00304"></a>00304       <span class="keyword">static_cast&lt;</span><span class="keywordtype">void</span><span class="keyword">&gt;</span> (0);
<a name="l00305"></a>00305       last_tab1_de_i = tab1_de_i;
<a name="l00306"></a>00306 <span class="comment">// Ce test doit rester, sinon on pollue les autres lignes du vecteur sol</span>
<a name="l00307"></a>00307 <span class="comment">// avec des valeurs dependant des items communs et virtuels</span>
<a name="l00308"></a>00308       <span class="keyword">static_cast&lt;</span><span class="keywordtype">void</span><span class="keyword">&gt;</span> (0);
<a name="l00309"></a>00309       <span class="keyword">const</span> <span class="keywordtype">int</span> item_a_traiter = *(flags_ptr++);
<a name="l00310"></a>00310       <span class="keywordflow">if</span> (item_a_traiter)
<a name="l00311"></a>00311         {
<a name="l00312"></a>00312 <span class="comment">// Le premier coeff doit etre le coef diagonal et doit etre strictement positif</span>
<a name="l00313"></a>00313           <span class="keyword">static_cast&lt;</span><span class="keywordtype">void</span><span class="keyword">&gt;</span> (0);
<a name="l00314"></a>00314           <span class="keyword">const</span> <span class="keywordtype">double</span> omega_coeff_i_i = omega / (*coeff_ptr);
<a name="l00315"></a>00315           <span class="keyword">const</span> <span class="keywordtype">double</span> v_i = sol_fortran[i] *= omega_coeff_i_i;
<a name="l00316"></a>00316           tab2_ptr++;
<a name="l00317"></a>00317           coeff_ptr++;
<a name="l00318"></a>00318           <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = nvois-1; j; j--, tab2_ptr++, coeff_ptr++)
<a name="l00319"></a>00319             {
<a name="l00320"></a>00320               <span class="keyword">const</span> <span class="keywordtype">int</span> i2 = *tab2_ptr; <span class="comment">//!&lt; indice de colonne pour le prochain coefficient</span>
<a name="l00321"></a>00321 <span class="comment"></span>              <span class="keyword">const</span> <span class="keywordtype">double</span> coeff_i_i2 = *coeff_ptr;
<a name="l00322"></a>00322 <span class="comment">// la matrice n&#39;a que des coeffs diagonaux superieurs et on a deja traite</span>
<a name="l00323"></a>00323 <span class="comment">// la diagonale, donc i2 &gt; i.</span>
<a name="l00324"></a>00324               <span class="keyword">static_cast&lt;</span><span class="keywordtype">void</span><span class="keyword">&gt;</span> (0);
<a name="l00325"></a>00325 <span class="comment">// B.M.: ... en revanche, le test sur les items communs est superflu ici car</span>
<a name="l00326"></a>00326 <span class="comment">// la valeur sera annulee (voir **Annulation items communs**),</span>
<a name="l00327"></a>00327 <span class="comment">// gain de perfs si on ne fait pas le test</span>
<a name="l00328"></a>00328               sol_fortran[i2] -= coeff_i_i2 * v_i;
<a name="l00329"></a>00329             }
<a name="l00330"></a>00330         }
<a name="l00331"></a>00331       <span class="keywordflow">else</span>
<a name="l00332"></a>00332         {
<a name="l00333"></a>00333 <span class="comment">// **Annulation items communs**</span>
<a name="l00334"></a>00334 <span class="comment">// c&#39;est la derniere fois qu&#39;on ecrit dans sol_fortran[i] car la</span>
<a name="l00335"></a>00335 <span class="comment">// matrice est diagonale superieure. Pour eviter le test sur items_a_traiter_</span>
<a name="l00336"></a>00336 <span class="comment">// dans la remontee, on annule la solution pour les items communs et virtuels</span>
<a name="l00337"></a>00337 <span class="comment">// (sol_fortran[i] ne sera plus modifie ensuite dans la descente)</span>
<a name="l00338"></a>00338           sol_fortran[i] = 0.;
<a name="l00339"></a>00339           coeff_ptr += nvois;
<a name="l00340"></a>00340           tab2_ptr += nvois;
<a name="l00341"></a>00341         }
<a name="l00342"></a>00342     }
<a name="l00343"></a>00343 <span class="comment">// **Annulation items communs**</span>
<a name="l00344"></a>00344 <span class="comment">// Pour la remontee il faut annuler les valeurs dans les cases virtuelles</span>
<a name="l00345"></a>00345   {
<a name="l00346"></a>00346     <span class="keyword">const</span> <span class="keywordtype">int</span> fin = vecteur.<a class="code" href="classDoubleVect.html#ad2d21b364e1c6559771970596a25c006" title="Identique a size_array()">size_totale</a>();
<a name="l00347"></a>00347     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = nb_lignes_a_traiter+1; i &lt;= fin; i++)
<a name="l00348"></a>00348       sol_fortran[i] = 0.;
<a name="l00349"></a>00349   }
<a name="l00350"></a>00350 }
<a name="l00351"></a>00351 
<a name="l00352"></a>00352 
<a name="l00353"></a><a class="code" href="SSOR_8cpp.html#a63ed19f4f2d49705c4a2c909bcd796be">00353</a> <span class="keywordtype">void</span> <a class="code" href="SSOR_8cpp.html#aa3e5b9c2942469b29c8e8f874897bbe1">remontee</a>(<span class="keyword">const</span> <span class="keywordtype">double</span> omega, <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; tab1, <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; tab2, <span class="keyword">const</span> <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a>&amp; <a class="code" href="Champ__P1iP1B__implementation_8cpp.html#aa8c8f49390c3cf7c702d71a71bc977e3">coeff</a>,
<a name="l00354"></a>00354               <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; vecteur
<a name="l00355"></a>00355               , <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; items_a_traiter
<a name="l00356"></a>00356              )
<a name="l00357"></a>00357 {
<a name="l00358"></a>00358   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_lignes_a_traiter = vecteur.<a class="code" href="classDoubleVect.html#aafef4b3a96cdc428d62c5cedc9af6112">size_reelle_ok</a>() ? vecteur.<a class="code" href="classDoubleVect.html#a4a6987db458541cdcd10495955f25263" title="Taille de l&#39;espace &quot;reel&quot; du vecteur. (si md_vector_ est nul, cette valeur est identique a size_arr...">size_reelle</a>() : vecteur.<a class="code" href="classDoubleVect.html#ad2d21b364e1c6559771970596a25c006" title="Identique a size_array()">size_totale</a>();
<a name="l00359"></a>00359   <span class="keyword">const</span> <span class="keywordtype">int</span> *flags_ptr = items_a_traiter.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() + nb_lignes_a_traiter - 1;
<a name="l00360"></a>00360   assert(nb_lignes_a_traiter &lt;= items_a_traiter.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>());
<a name="l00361"></a>00361   <span class="keyword">const</span> <span class="keywordtype">double</span> psi = (2. - omega) / omega;
<a name="l00362"></a>00362 
<a name="l00363"></a>00363 <span class="comment">// pointeur &quot;fortran&quot; vers le tableau solution (indexable avec index fortran)</span>
<a name="l00364"></a>00364   <span class="keyword">const</span> <span class="keywordtype">double</span> * <span class="keyword">const</span> sol_fortran = vecteur.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() - 1;
<a name="l00365"></a>00365   <span class="keyword">const</span> <span class="keywordtype">int</span> *tab1_ptr = tab1.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() + nb_lignes_a_traiter;
<a name="l00366"></a>00366   <span class="keywordtype">int</span> last_tab1_de_i = *tab1_ptr;
<a name="l00367"></a>00367   tab1_ptr--;
<a name="l00368"></a>00368 <span class="comment">// On ne va pas a la fin de tab2 car on n&#39;est pas sur que nb_lignes_a_traiter = tab1.size_array() :</span>
<a name="l00369"></a>00369 <span class="comment">// -2 car last_tab1_de_i est l&#39;indice du premier coefficient de la ligne suivante en fortran</span>
<a name="l00370"></a>00370 <span class="comment">// (dont -1 pour fortran-&gt;c et -1 pour passer au dernier coeff de la ligne precedente)</span>
<a name="l00371"></a>00371   <span class="keyword">const</span> <span class="keywordtype">int</span> *tab2_ptr = tab2.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() + last_tab1_de_i - 2;
<a name="l00372"></a>00372   <span class="keyword">const</span> <span class="keywordtype">double</span> *coeff_ptr = coeff.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() + last_tab1_de_i - 2;
<a name="l00373"></a>00373   <span class="keywordtype">double</span> * soli_ptr = vecteur.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() + nb_lignes_a_traiter - 1;
<a name="l00374"></a>00374   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = nb_lignes_a_traiter; i; i--, tab1_ptr--, soli_ptr--)
<a name="l00375"></a>00375     {
<a name="l00376"></a>00376       <span class="keyword">const</span> <span class="keywordtype">int</span> tab1_de_i = *tab1_ptr; <span class="comment">//!&lt; = tab1[i]</span>
<a name="l00377"></a>00377 <span class="comment"></span>      <span class="keyword">const</span> <span class="keywordtype">int</span> nvois = last_tab1_de_i - tab1_de_i;
<a name="l00378"></a>00378       <span class="keyword">static_cast&lt;</span><span class="keywordtype">void</span><span class="keyword">&gt;</span> (0);
<a name="l00379"></a>00379       last_tab1_de_i = tab1_de_i;
<a name="l00380"></a>00380 <span class="comment">// Ce test doit rester car il ne faut pas modifier sol[i] pour les items communs</span>
<a name="l00381"></a>00381 <span class="comment">// et virtuels (ils sont nuls et doivent le rester pour ne pas polluer les autres lignes):</span>
<a name="l00382"></a>00382       <span class="keywordflow">if</span> (*(flags_ptr--))
<a name="l00383"></a>00383         {
<a name="l00384"></a>00384 <span class="comment">// Operation &quot;diagonale&quot;:</span>
<a name="l00385"></a>00385           <span class="keywordtype">double</span> x = 0.;
<a name="l00386"></a>00386           <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = nvois-1; j; j--, tab2_ptr--, coeff_ptr--)
<a name="l00387"></a>00387             {
<a name="l00388"></a>00388               <span class="keyword">const</span> <span class="keywordtype">int</span> i2 = *tab2_ptr;
<a name="l00389"></a>00389               <span class="keyword">const</span> <span class="keywordtype">double</span> coeff_i_i2 = *coeff_ptr;
<a name="l00390"></a>00390 <span class="comment">// Operation nulle pour les items communs et virtuels</span>
<a name="l00391"></a>00391 <span class="comment">// (on a annule le second membre lors de la descente)</span>
<a name="l00392"></a>00392               x += coeff_i_i2 * sol_fortran[i2];
<a name="l00393"></a>00393             }
<a name="l00394"></a>00394 <span class="comment">// ici coeff_ptr est le coeff diagonal</span>
<a name="l00395"></a>00395           <span class="keyword">static_cast&lt;</span><span class="keywordtype">void</span><span class="keyword">&gt;</span> (0);
<a name="l00396"></a>00396           <span class="keyword">const</span> <span class="keywordtype">double</span> coeff_i_i = *coeff_ptr;
<a name="l00397"></a>00397           <span class="keyword">const</span> <span class="keywordtype">double</span> omega_coeff_i_i = omega / coeff_i_i;
<a name="l00398"></a>00398           *soli_ptr = (*soli_ptr) * psi * omega - x * omega_coeff_i_i;
<a name="l00399"></a>00399           coeff_ptr--;
<a name="l00400"></a>00400           tab2_ptr--;
<a name="l00401"></a>00401         }
<a name="l00402"></a>00402       <span class="keywordflow">else</span>
<a name="l00403"></a>00403         {
<a name="l00404"></a>00404           assert((*soli_ptr) == 0.);
<a name="l00405"></a>00405           coeff_ptr -= nvois;
<a name="l00406"></a>00406           tab2_ptr -= nvois;
<a name="l00407"></a>00407         }
<a name="l00408"></a>00408     }
<a name="l00409"></a>00409 }
<a name="l00410"></a>00410 
<a name="l00411"></a><a class="code" href="SSOR_8cpp.html#a678783cb16d22aa5fdf95ee27a476764">00411</a> <span class="keywordtype">void</span> <a class="code" href="SSOR_8cpp.html#a678783cb16d22aa5fdf95ee27a476764">descente_assert</a>(<span class="keyword">const</span> <span class="keywordtype">double</span> omega, <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; tab1, <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; tab2, <span class="keyword">const</span> <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a>&amp; <a class="code" href="Champ__P1iP1B__implementation_8cpp.html#aa8c8f49390c3cf7c702d71a71bc977e3">coeff</a>,
<a name="l00412"></a>00412                      <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; vecteur
<a name="l00413"></a>00413                     )
<a name="l00414"></a>00414 {
<a name="l00415"></a>00415   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_lignes_a_traiter = vecteur.<a class="code" href="classDoubleVect.html#aafef4b3a96cdc428d62c5cedc9af6112">size_reelle_ok</a>() ? vecteur.<a class="code" href="classDoubleVect.html#a4a6987db458541cdcd10495955f25263" title="Taille de l&#39;espace &quot;reel&quot; du vecteur. (si md_vector_ est nul, cette valeur est identique a size_arr...">size_reelle</a>() : vecteur.<a class="code" href="classDoubleVect.html#ad2d21b364e1c6559771970596a25c006" title="Identique a size_array()">size_totale</a>();
<a name="l00416"></a>00416 <span class="comment">// pointeur &quot;fortran&quot; vers le tableau solution (indexable avec index fortran)</span>
<a name="l00417"></a>00417 <span class="comment">// le pointeur est constant, pas le tableau pointe.</span>
<a name="l00418"></a>00418   <span class="keywordtype">double</span> * <span class="keyword">const</span> sol_fortran = vecteur.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() - 1;
<a name="l00419"></a>00419   <span class="keyword">const</span> <span class="keywordtype">int</span> *tab1_ptr = tab1.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
<a name="l00420"></a>00420   assert(nb_lignes_a_traiter &lt;= tab1.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() + 1);
<a name="l00421"></a>00421   assert(*tab1_ptr == 1); <span class="comment">//!&lt; sinon 2 lignes ci-dessous fausses.</span>
<a name="l00422"></a>00422 <span class="comment"></span>  <span class="keyword">const</span> <span class="keywordtype">int</span> *tab2_ptr = tab2.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
<a name="l00423"></a>00423   <span class="keyword">const</span> <span class="keywordtype">double</span> *coeff_ptr = coeff.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
<a name="l00424"></a>00424   <span class="keywordtype">int</span> last_tab1_de_i = *tab1_ptr;
<a name="l00425"></a>00425   tab1_ptr++;
<a name="l00426"></a>00426   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 1; i &lt;= nb_lignes_a_traiter; i++, tab1_ptr++)
<a name="l00427"></a>00427     {
<a name="l00428"></a>00428       <span class="keyword">const</span> <span class="keywordtype">int</span> tab1_de_i = *tab1_ptr; <span class="comment">//!&lt; = tab1[i]</span>
<a name="l00429"></a>00429 <span class="comment"></span>      <span class="keyword">const</span> <span class="keywordtype">int</span> nvois = tab1_de_i - last_tab1_de_i;
<a name="l00430"></a>00430       assert(nvois &gt;= 0 &amp;&amp; (tab1_de_i - 1) &lt;= tab2.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>());
<a name="l00431"></a>00431       last_tab1_de_i = tab1_de_i;
<a name="l00432"></a>00432 <span class="comment">// Ce test doit rester, sinon on pollue les autres lignes du vecteur sol</span>
<a name="l00433"></a>00433 <span class="comment">// avec des valeurs dependant des items communs et virtuels</span>
<a name="l00434"></a>00434       {
<a name="l00435"></a>00435 <span class="comment">// Le premier coeff doit etre le coef diagonal et doit etre strictement positif</span>
<a name="l00436"></a>00436         assert(nvois &gt;= 1 &amp;&amp; (*tab2_ptr) == i &amp;&amp; (*coeff_ptr) &gt; 0.);
<a name="l00437"></a>00437         <span class="keyword">const</span> <span class="keywordtype">double</span> omega_coeff_i_i = omega / (*coeff_ptr);
<a name="l00438"></a>00438         <span class="keyword">const</span> <span class="keywordtype">double</span> v_i = sol_fortran[i] *= omega_coeff_i_i;
<a name="l00439"></a>00439         tab2_ptr++;
<a name="l00440"></a>00440         coeff_ptr++;
<a name="l00441"></a>00441         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = nvois-1; j; j--, tab2_ptr++, coeff_ptr++)
<a name="l00442"></a>00442           {
<a name="l00443"></a>00443             <span class="keyword">const</span> <span class="keywordtype">int</span> i2 = *tab2_ptr; <span class="comment">//!&lt; indice de colonne pour le prochain coefficient</span>
<a name="l00444"></a>00444 <span class="comment"></span>            <span class="keyword">const</span> <span class="keywordtype">double</span> coeff_i_i2 = *coeff_ptr;
<a name="l00445"></a>00445 <span class="comment">// la matrice n&#39;a que des coeffs diagonaux superieurs et on a deja traite</span>
<a name="l00446"></a>00446 <span class="comment">// la diagonale, donc i2 &gt; i.</span>
<a name="l00447"></a>00447 <span class="comment">// Pas d&#39;items virtuels autorises !</span>
<a name="l00448"></a>00448             assert(i2 &gt; i &amp;&amp; i2 &lt;= nb_lignes_a_traiter);
<a name="l00449"></a>00449 <span class="comment">// B.M.: ... en revanche, le test sur les items communs est superflu ici car</span>
<a name="l00450"></a>00450 <span class="comment">// la valeur sera annulee (voir **Annulation items communs**),</span>
<a name="l00451"></a>00451 <span class="comment">// gain de perfs si on ne fait pas le test</span>
<a name="l00452"></a>00452             sol_fortran[i2] -= coeff_i_i2 * v_i;
<a name="l00453"></a>00453           }
<a name="l00454"></a>00454       }
<a name="l00455"></a>00455     }
<a name="l00456"></a>00456 }
<a name="l00457"></a>00457 
<a name="l00458"></a>00458 <span class="comment">// Descente sur un bloc extradiagonal. Methode appelee par SSOR(const Matrice_bloc &amp; ...)</span>
<a name="l00459"></a>00459 <span class="comment">// vecteur: de taille &quot;nombre de lignes de la matrice&quot;</span>
<a name="l00460"></a>00460 <span class="comment">// vecteur2: &quot;nombre de colonnes&quot;</span>
<a name="l00461"></a><a class="code" href="SSOR_8cpp.html#abe7caa2af06f2228eeb87613b49fa72e">00461</a> <span class="keywordtype">void</span> <a class="code" href="SSOR_8cpp.html#abe7caa2af06f2228eeb87613b49fa72e">descente_bloc_extradiag_assert</a>(<span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; tab1, <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; tab2, <span class="keyword">const</span> <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a>&amp; <a class="code" href="Champ__P1iP1B__implementation_8cpp.html#aa8c8f49390c3cf7c702d71a71bc977e3">coeff</a>,
<a name="l00462"></a>00462                                     <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; vecteur,
<a name="l00463"></a>00463                                     <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; vecteur2
<a name="l00464"></a>00464                                    )
<a name="l00465"></a>00465 {
<a name="l00466"></a>00466   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_lignes = vecteur.<a class="code" href="classDoubleVect.html#aafef4b3a96cdc428d62c5cedc9af6112">size_reelle_ok</a>() ? vecteur.<a class="code" href="classDoubleVect.html#a4a6987db458541cdcd10495955f25263" title="Taille de l&#39;espace &quot;reel&quot; du vecteur. (si md_vector_ est nul, cette valeur est identique a size_arr...">size_reelle</a>() : vecteur.<a class="code" href="classDoubleVect.html#ad2d21b364e1c6559771970596a25c006" title="Identique a size_array()">size_totale</a>();
<a name="l00467"></a>00467   <span class="keyword">const</span> <span class="keywordtype">double</span> *vecteur_ptr = vecteur.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
<a name="l00468"></a>00468   <span class="keywordtype">double</span>       *vecteur2_fortran_ptr = vecteur2.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() - 1;
<a name="l00469"></a>00469   <span class="keyword">const</span> <span class="keywordtype">int</span> *tab2_fortran_ptr = tab2.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() - 1;
<a name="l00470"></a>00470   <span class="keyword">const</span> <span class="keywordtype">double</span> *coeff_fortran_ptr = coeff.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() - 1;
<a name="l00471"></a>00471   assert(coeff.<a class="code" href="classArrOfDouble.html#a3c3b33bea0e88b87315c21ee94bee05f" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() == tab2.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>());
<a name="l00472"></a>00472   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i_ligne = 0; i_ligne &lt; nb_lignes; i_ligne++, vecteur_ptr++)
<a name="l00473"></a>00473     {
<a name="l00474"></a>00474       {
<a name="l00475"></a>00475         <span class="keyword">const</span> <span class="keywordtype">double</span> v_i = *vecteur_ptr;
<a name="l00476"></a>00476         <span class="keywordtype">int</span> index = tab1[i_ligne];
<a name="l00477"></a>00477         <span class="keyword">const</span> <span class="keywordtype">int</span> index_fin = tab1[i_ligne+1];
<a name="l00478"></a>00478 <span class="comment">// Il peut n&#39;y avoir aucun coefficient sur la ligne =&gt; index_fin == index</span>
<a name="l00479"></a>00479         assert(index &gt; 0 &amp;&amp; index_fin &gt;= index &amp;&amp; index_fin &lt;= tab2.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>()+1);
<a name="l00480"></a>00480         <span class="keyword">const</span> <span class="keywordtype">int</span> *tab2_ptr = tab2_fortran_ptr + index;
<a name="l00481"></a>00481         <span class="keyword">const</span> <span class="keywordtype">double</span> *coeff_ptr = coeff_fortran_ptr + index;
<a name="l00482"></a>00482         <span class="keywordflow">for</span> (; index &lt; index_fin; index++, tab2_ptr++, coeff_ptr++)
<a name="l00483"></a>00483           {
<a name="l00484"></a>00484             <span class="keyword">const</span> <span class="keywordtype">int</span> i_colonne = *tab2_ptr;
<a name="l00485"></a>00485             assert(i_colonne &gt;= 1 &amp;&amp; i_colonne &lt;= vecteur2.<a class="code" href="classArrOfDouble.html#a3c3b33bea0e88b87315c21ee94bee05f" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>());
<a name="l00486"></a>00486             <span class="keyword">const</span> <span class="keywordtype">double</span> c = *coeff_ptr;
<a name="l00487"></a>00487 <span class="comment">// pas de test item commun sur les colonnes, voir **Annulation items communs**</span>
<a name="l00488"></a>00488             vecteur2_fortran_ptr[i_colonne] -= c * v_i;
<a name="l00489"></a>00489           }
<a name="l00490"></a>00490       }
<a name="l00491"></a>00491     }
<a name="l00492"></a>00492 }
<a name="l00493"></a>00493 
<a name="l00494"></a><a class="code" href="SSOR_8cpp.html#adfde91562afac839dcf9442dcfd3d507">00494</a> <span class="keywordtype">void</span> <a class="code" href="SSOR_8cpp.html#adfde91562afac839dcf9442dcfd3d507">remontee_assert</a>(<span class="keyword">const</span> <span class="keywordtype">double</span> omega, <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; tab1, <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; tab2, <span class="keyword">const</span> <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a>&amp; <a class="code" href="Champ__P1iP1B__implementation_8cpp.html#aa8c8f49390c3cf7c702d71a71bc977e3">coeff</a>,
<a name="l00495"></a>00495                      <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; vecteur
<a name="l00496"></a>00496                     )
<a name="l00497"></a>00497 {
<a name="l00498"></a>00498   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_lignes_a_traiter = vecteur.<a class="code" href="classDoubleVect.html#aafef4b3a96cdc428d62c5cedc9af6112">size_reelle_ok</a>() ? vecteur.<a class="code" href="classDoubleVect.html#a4a6987db458541cdcd10495955f25263" title="Taille de l&#39;espace &quot;reel&quot; du vecteur. (si md_vector_ est nul, cette valeur est identique a size_arr...">size_reelle</a>() : vecteur.<a class="code" href="classDoubleVect.html#ad2d21b364e1c6559771970596a25c006" title="Identique a size_array()">size_totale</a>();
<a name="l00499"></a>00499   <span class="keyword">const</span> <span class="keywordtype">double</span> psi = (2. - omega) / omega;
<a name="l00500"></a>00500 
<a name="l00501"></a>00501 <span class="comment">// pointeur &quot;fortran&quot; vers le tableau solution (indexable avec index fortran)</span>
<a name="l00502"></a>00502   <span class="keyword">const</span> <span class="keywordtype">double</span> * <span class="keyword">const</span> sol_fortran = vecteur.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() - 1;
<a name="l00503"></a>00503   <span class="keyword">const</span> <span class="keywordtype">int</span> *tab1_ptr = tab1.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() + nb_lignes_a_traiter;
<a name="l00504"></a>00504   <span class="keywordtype">int</span> last_tab1_de_i = *tab1_ptr;
<a name="l00505"></a>00505   tab1_ptr--;
<a name="l00506"></a>00506 <span class="comment">// On ne va pas a la fin de tab2 car on n&#39;est pas sur que nb_lignes_a_traiter = tab1.size_array() :</span>
<a name="l00507"></a>00507 <span class="comment">// -2 car last_tab1_de_i est l&#39;indice du premier coefficient de la ligne suivante en fortran</span>
<a name="l00508"></a>00508 <span class="comment">// (dont -1 pour fortran-&gt;c et -1 pour passer au dernier coeff de la ligne precedente)</span>
<a name="l00509"></a>00509   <span class="keyword">const</span> <span class="keywordtype">int</span> *tab2_ptr = tab2.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() + last_tab1_de_i - 2;
<a name="l00510"></a>00510   <span class="keyword">const</span> <span class="keywordtype">double</span> *coeff_ptr = coeff.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() + last_tab1_de_i - 2;
<a name="l00511"></a>00511   <span class="keywordtype">double</span> * soli_ptr = vecteur.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() + nb_lignes_a_traiter - 1;
<a name="l00512"></a>00512   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = nb_lignes_a_traiter; i; i--, tab1_ptr--, soli_ptr--)
<a name="l00513"></a>00513     {
<a name="l00514"></a>00514       <span class="keyword">const</span> <span class="keywordtype">int</span> tab1_de_i = *tab1_ptr; <span class="comment">//!&lt; = tab1[i]</span>
<a name="l00515"></a>00515 <span class="comment"></span>      <span class="keyword">const</span> <span class="keywordtype">int</span> nvois = last_tab1_de_i - tab1_de_i;
<a name="l00516"></a>00516       assert(nvois &gt;= 0 &amp;&amp; tab1_de_i &gt; 0);
<a name="l00517"></a>00517       last_tab1_de_i = tab1_de_i;
<a name="l00518"></a>00518 <span class="comment">// Ce test doit rester car il ne faut pas modifier sol[i] pour les items communs</span>
<a name="l00519"></a>00519 <span class="comment">// et virtuels (ils sont nuls et doivent le rester pour ne pas polluer les autres lignes):</span>
<a name="l00520"></a>00520       <span class="keywordflow">if</span> (1)
<a name="l00521"></a>00521         {
<a name="l00522"></a>00522 <span class="comment">// Operation &quot;diagonale&quot;:</span>
<a name="l00523"></a>00523           <span class="keywordtype">double</span> x = 0.;
<a name="l00524"></a>00524           <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = nvois-1; j; j--, tab2_ptr--, coeff_ptr--)
<a name="l00525"></a>00525             {
<a name="l00526"></a>00526               <span class="keyword">const</span> <span class="keywordtype">int</span> i2 = *tab2_ptr;
<a name="l00527"></a>00527               <span class="keyword">const</span> <span class="keywordtype">double</span> coeff_i_i2 = *coeff_ptr;
<a name="l00528"></a>00528 <span class="comment">// Operation nulle pour les items communs et virtuels</span>
<a name="l00529"></a>00529 <span class="comment">// (on a annule le second membre lors de la descente)</span>
<a name="l00530"></a>00530               x += coeff_i_i2 * sol_fortran[i2];
<a name="l00531"></a>00531             }
<a name="l00532"></a>00532 <span class="comment">// ici coeff_ptr est le coeff diagonal</span>
<a name="l00533"></a>00533           assert((*tab2_ptr) == i);
<a name="l00534"></a>00534           <span class="keyword">const</span> <span class="keywordtype">double</span> coeff_i_i = *coeff_ptr;
<a name="l00535"></a>00535           <span class="keyword">const</span> <span class="keywordtype">double</span> omega_coeff_i_i = omega / coeff_i_i;
<a name="l00536"></a>00536           *soli_ptr = (*soli_ptr) * psi * omega - x * omega_coeff_i_i;
<a name="l00537"></a>00537           coeff_ptr--;
<a name="l00538"></a>00538           tab2_ptr--;
<a name="l00539"></a>00539         }
<a name="l00540"></a>00540       <span class="keywordflow">else</span>
<a name="l00541"></a>00541         {
<a name="l00542"></a>00542           assert((*soli_ptr) == 0.);
<a name="l00543"></a>00543           coeff_ptr -= nvois;
<a name="l00544"></a>00544           tab2_ptr -= nvois;
<a name="l00545"></a>00545         }
<a name="l00546"></a>00546     }
<a name="l00547"></a>00547 }
<a name="l00548"></a>00548 
<a name="l00549"></a>00549 <span class="comment">// Remontee sur un bloc extradiagonal. Methode appelee par SSOR(const Matrice_bloc &amp; ...)</span>
<a name="l00550"></a>00550 <span class="comment">// vecteur: de taille &quot;nombre de lignes de la matrice&quot;</span>
<a name="l00551"></a>00551 <span class="comment">// vecteur2: &quot;nombre de colonnes&quot;</span>
<a name="l00552"></a><a class="code" href="SSOR_8cpp.html#a5600e796c5a19cf31272da290b9933d6">00552</a> <span class="keywordtype">void</span> <a class="code" href="SSOR_8cpp.html#a5600e796c5a19cf31272da290b9933d6">remontee_bloc_extradiag_assert</a>(<span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; tab1, <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; tab2, <span class="keyword">const</span> <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a>&amp; <a class="code" href="Champ__P1iP1B__implementation_8cpp.html#aa8c8f49390c3cf7c702d71a71bc977e3">coeff</a>,
<a name="l00553"></a>00553                                     <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; vecteur,
<a name="l00554"></a>00554                                     <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; vecteur2
<a name="l00555"></a>00555                                    )
<a name="l00556"></a>00556 {
<a name="l00557"></a>00557   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_lignes = vecteur.<a class="code" href="classDoubleVect.html#aafef4b3a96cdc428d62c5cedc9af6112">size_reelle_ok</a>() ? vecteur.<a class="code" href="classDoubleVect.html#a4a6987db458541cdcd10495955f25263" title="Taille de l&#39;espace &quot;reel&quot; du vecteur. (si md_vector_ est nul, cette valeur est identique a size_arr...">size_reelle</a>() : vecteur.<a class="code" href="classDoubleVect.html#ad2d21b364e1c6559771970596a25c006" title="Identique a size_array()">size_totale</a>();
<a name="l00558"></a>00558   <span class="keywordtype">double</span> *vecteur_ptr = vecteur.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
<a name="l00559"></a>00559   <span class="keyword">const</span> <span class="keywordtype">double</span> *vecteur2_fortran_ptr = vecteur2.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() - 1;
<a name="l00560"></a>00560   <span class="keyword">const</span> <span class="keywordtype">int</span> *tab2_fortran_ptr = tab2.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() - 1;
<a name="l00561"></a>00561   <span class="keyword">const</span> <span class="keywordtype">double</span> *coeff_fortran_ptr = coeff.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() - 1;
<a name="l00562"></a>00562   assert(coeff.<a class="code" href="classArrOfDouble.html#a3c3b33bea0e88b87315c21ee94bee05f" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() == tab2.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>());
<a name="l00563"></a>00563   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i_ligne = 0; i_ligne &lt; nb_lignes; i_ligne++, vecteur_ptr++)
<a name="l00564"></a>00564     {
<a name="l00565"></a>00565       {
<a name="l00566"></a>00566         <span class="keywordtype">double</span> x = *vecteur_ptr;
<a name="l00567"></a>00567         <span class="keywordtype">int</span> index = tab1[i_ligne];
<a name="l00568"></a>00568         <span class="keyword">const</span> <span class="keywordtype">int</span> index_fin = tab1[i_ligne+1];
<a name="l00569"></a>00569 <span class="comment">// Il peut n&#39;y avoir aucun coefficient sur la ligne =&gt; index_fin == index</span>
<a name="l00570"></a>00570         assert(index &gt; 0 &amp;&amp; index_fin &gt;= index &amp;&amp; index_fin &lt;= tab2.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>()+1);
<a name="l00571"></a>00571         <span class="keyword">const</span> <span class="keywordtype">int</span> *tab2_ptr = tab2_fortran_ptr + index;
<a name="l00572"></a>00572         <span class="keyword">const</span> <span class="keywordtype">double</span> *coeff_ptr = coeff_fortran_ptr + index;
<a name="l00573"></a>00573         <span class="keywordflow">for</span> (; index &lt; index_fin; index++, tab2_ptr++, coeff_ptr++)
<a name="l00574"></a>00574           {
<a name="l00575"></a>00575             <span class="keyword">const</span> <span class="keywordtype">int</span> i_colonne = *tab2_ptr;
<a name="l00576"></a>00576             assert(i_colonne &gt;= 1 &amp;&amp; i_colonne &lt;= vecteur2.<a class="code" href="classArrOfDouble.html#a3c3b33bea0e88b87315c21ee94bee05f" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>());
<a name="l00577"></a>00577             <span class="keyword">const</span> <span class="keywordtype">double</span> c = *coeff_ptr;
<a name="l00578"></a>00578             <span class="keyword">const</span> <span class="keywordtype">double</span> x2 = vecteur2_fortran_ptr[i_colonne];
<a name="l00579"></a>00579 <span class="comment">// pas de test item commun sur les colonnes, voir **Annulation items communs**</span>
<a name="l00580"></a>00580             x -= c * x2;
<a name="l00581"></a>00581           }
<a name="l00582"></a>00582         *vecteur_ptr = x;
<a name="l00583"></a>00583       }
<a name="l00584"></a>00584     }
<a name="l00585"></a>00585 }
<a name="l00586"></a><a class="code" href="SSOR_8cpp.html#a7e9cf5b8854791ed17d82f27a325c16e">00586</a> <span class="keywordtype">void</span> <a class="code" href="SSOR_8cpp.html#a678783cb16d22aa5fdf95ee27a476764">descente_assert</a>(<span class="keyword">const</span> <span class="keywordtype">double</span> omega, <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; tab1, <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; tab2, <span class="keyword">const</span> <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a>&amp; <a class="code" href="Champ__P1iP1B__implementation_8cpp.html#aa8c8f49390c3cf7c702d71a71bc977e3">coeff</a>,
<a name="l00587"></a>00587                      <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; vecteur
<a name="l00588"></a>00588                      , <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; items_a_traiter
<a name="l00589"></a>00589                     )
<a name="l00590"></a>00590 {
<a name="l00591"></a>00591   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_lignes_a_traiter = vecteur.<a class="code" href="classDoubleVect.html#aafef4b3a96cdc428d62c5cedc9af6112">size_reelle_ok</a>() ? vecteur.<a class="code" href="classDoubleVect.html#a4a6987db458541cdcd10495955f25263" title="Taille de l&#39;espace &quot;reel&quot; du vecteur. (si md_vector_ est nul, cette valeur est identique a size_arr...">size_reelle</a>() : vecteur.<a class="code" href="classDoubleVect.html#ad2d21b364e1c6559771970596a25c006" title="Identique a size_array()">size_totale</a>();
<a name="l00592"></a>00592 <span class="comment">// pointeur &quot;fortran&quot; vers le tableau solution (indexable avec index fortran)</span>
<a name="l00593"></a>00593 <span class="comment">// le pointeur est constant, pas le tableau pointe.</span>
<a name="l00594"></a>00594   <span class="keywordtype">double</span> * <span class="keyword">const</span> sol_fortran = vecteur.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() - 1;
<a name="l00595"></a>00595   <span class="keyword">const</span> <span class="keywordtype">int</span> *flags_ptr = items_a_traiter.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
<a name="l00596"></a>00596   assert(nb_lignes_a_traiter &lt;= items_a_traiter.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>());
<a name="l00597"></a>00597   <span class="keyword">const</span> <span class="keywordtype">int</span> *tab1_ptr = tab1.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
<a name="l00598"></a>00598   assert(nb_lignes_a_traiter &lt;= tab1.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() + 1);
<a name="l00599"></a>00599   assert(*tab1_ptr == 1); <span class="comment">//!&lt; sinon 2 lignes ci-dessous fausses.</span>
<a name="l00600"></a>00600 <span class="comment"></span>  <span class="keyword">const</span> <span class="keywordtype">int</span> *tab2_ptr = tab2.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
<a name="l00601"></a>00601   <span class="keyword">const</span> <span class="keywordtype">double</span> *coeff_ptr = coeff.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
<a name="l00602"></a>00602   <span class="keywordtype">int</span> last_tab1_de_i = *tab1_ptr;
<a name="l00603"></a>00603   tab1_ptr++;
<a name="l00604"></a>00604   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 1; i &lt;= nb_lignes_a_traiter; i++, tab1_ptr++)
<a name="l00605"></a>00605     {
<a name="l00606"></a>00606       <span class="keyword">const</span> <span class="keywordtype">int</span> tab1_de_i = *tab1_ptr; <span class="comment">//!&lt; = tab1[i]</span>
<a name="l00607"></a>00607 <span class="comment"></span>      <span class="keyword">const</span> <span class="keywordtype">int</span> nvois = tab1_de_i - last_tab1_de_i;
<a name="l00608"></a>00608       assert(nvois &gt;= 0 &amp;&amp; (tab1_de_i - 1) &lt;= tab2.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>());
<a name="l00609"></a>00609       last_tab1_de_i = tab1_de_i;
<a name="l00610"></a>00610 <span class="comment">// Ce test doit rester, sinon on pollue les autres lignes du vecteur sol</span>
<a name="l00611"></a>00611 <span class="comment">// avec des valeurs dependant des items communs et virtuels</span>
<a name="l00612"></a>00612       assert((flags_ptr - items_a_traiter.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>()) == (i-1));
<a name="l00613"></a>00613       <span class="keyword">const</span> <span class="keywordtype">int</span> item_a_traiter = *(flags_ptr++);
<a name="l00614"></a>00614       <span class="keywordflow">if</span> (item_a_traiter)
<a name="l00615"></a>00615         {
<a name="l00616"></a>00616 <span class="comment">// Le premier coeff doit etre le coef diagonal et doit etre strictement positif</span>
<a name="l00617"></a>00617           assert(nvois &gt;= 1 &amp;&amp; (*tab2_ptr) == i &amp;&amp; (*coeff_ptr) &gt; 0.);
<a name="l00618"></a>00618           <span class="keyword">const</span> <span class="keywordtype">double</span> omega_coeff_i_i = omega / (*coeff_ptr);
<a name="l00619"></a>00619           <span class="keyword">const</span> <span class="keywordtype">double</span> v_i = sol_fortran[i] *= omega_coeff_i_i;
<a name="l00620"></a>00620           tab2_ptr++;
<a name="l00621"></a>00621           coeff_ptr++;
<a name="l00622"></a>00622           <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = nvois-1; j; j--, tab2_ptr++, coeff_ptr++)
<a name="l00623"></a>00623             {
<a name="l00624"></a>00624               <span class="keyword">const</span> <span class="keywordtype">int</span> i2 = *tab2_ptr; <span class="comment">//!&lt; indice de colonne pour le prochain coefficient</span>
<a name="l00625"></a>00625 <span class="comment"></span>              <span class="keyword">const</span> <span class="keywordtype">double</span> coeff_i_i2 = *coeff_ptr;
<a name="l00626"></a>00626 <span class="comment">// la matrice n&#39;a que des coeffs diagonaux superieurs et on a deja traite</span>
<a name="l00627"></a>00627 <span class="comment">// la diagonale, donc i2 &gt; i.</span>
<a name="l00628"></a>00628               assert(i2 &gt; i &amp;&amp; i2 &lt;= vecteur.<a class="code" href="classDoubleVect.html#ad2d21b364e1c6559771970596a25c006" title="Identique a size_array()">size_totale</a>());
<a name="l00629"></a>00629 <span class="comment">// B.M.: ... en revanche, le test sur les items communs est superflu ici car</span>
<a name="l00630"></a>00630 <span class="comment">// la valeur sera annulee (voir **Annulation items communs**),</span>
<a name="l00631"></a>00631 <span class="comment">// gain de perfs si on ne fait pas le test</span>
<a name="l00632"></a>00632               sol_fortran[i2] -= coeff_i_i2 * v_i;
<a name="l00633"></a>00633             }
<a name="l00634"></a>00634         }
<a name="l00635"></a>00635       <span class="keywordflow">else</span>
<a name="l00636"></a>00636         {
<a name="l00637"></a>00637 <span class="comment">// **Annulation items communs**</span>
<a name="l00638"></a>00638 <span class="comment">// c&#39;est la derniere fois qu&#39;on ecrit dans sol_fortran[i] car la</span>
<a name="l00639"></a>00639 <span class="comment">// matrice est diagonale superieure. Pour eviter le test sur items_a_traiter_</span>
<a name="l00640"></a>00640 <span class="comment">// dans la remontee, on annule la solution pour les items communs et virtuels</span>
<a name="l00641"></a>00641 <span class="comment">// (sol_fortran[i] ne sera plus modifie ensuite dans la descente)</span>
<a name="l00642"></a>00642           sol_fortran[i] = 0.;
<a name="l00643"></a>00643           coeff_ptr += nvois;
<a name="l00644"></a>00644           tab2_ptr += nvois;
<a name="l00645"></a>00645         }
<a name="l00646"></a>00646     }
<a name="l00647"></a>00647 <span class="comment">// **Annulation items communs**</span>
<a name="l00648"></a>00648 <span class="comment">// Pour la remontee il faut annuler les valeurs dans les cases virtuelles</span>
<a name="l00649"></a>00649   {
<a name="l00650"></a>00650     <span class="keyword">const</span> <span class="keywordtype">int</span> fin = vecteur.<a class="code" href="classDoubleVect.html#ad2d21b364e1c6559771970596a25c006" title="Identique a size_array()">size_totale</a>();
<a name="l00651"></a>00651     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = nb_lignes_a_traiter+1; i &lt;= fin; i++)
<a name="l00652"></a>00652       sol_fortran[i] = 0.;
<a name="l00653"></a>00653   }
<a name="l00654"></a>00654 }
<a name="l00655"></a>00655 
<a name="l00656"></a>00656 <span class="comment">// Descente sur un bloc extradiagonal. Methode appelee par SSOR(const Matrice_bloc &amp; ...)</span>
<a name="l00657"></a>00657 <span class="comment">// vecteur: de taille &quot;nombre de lignes de la matrice&quot;</span>
<a name="l00658"></a>00658 <span class="comment">// vecteur2: &quot;nombre de colonnes&quot;</span>
<a name="l00659"></a><a class="code" href="SSOR_8cpp.html#a65eba611ca3cc3a3bfaa8d5afc59d99d">00659</a> <span class="keywordtype">void</span> <a class="code" href="SSOR_8cpp.html#abe7caa2af06f2228eeb87613b49fa72e">descente_bloc_extradiag_assert</a>(<span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; tab1, <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; tab2, <span class="keyword">const</span> <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a>&amp; <a class="code" href="Champ__P1iP1B__implementation_8cpp.html#aa8c8f49390c3cf7c702d71a71bc977e3">coeff</a>,
<a name="l00660"></a>00660                                     <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; vecteur,
<a name="l00661"></a>00661                                     <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; vecteur2
<a name="l00662"></a>00662                                     , <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; items_a_traiter
<a name="l00663"></a>00663                                    )
<a name="l00664"></a>00664 {
<a name="l00665"></a>00665   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_lignes = vecteur.<a class="code" href="classDoubleVect.html#aafef4b3a96cdc428d62c5cedc9af6112">size_reelle_ok</a>() ? vecteur.<a class="code" href="classDoubleVect.html#a4a6987db458541cdcd10495955f25263" title="Taille de l&#39;espace &quot;reel&quot; du vecteur. (si md_vector_ est nul, cette valeur est identique a size_arr...">size_reelle</a>() : vecteur.<a class="code" href="classDoubleVect.html#ad2d21b364e1c6559771970596a25c006" title="Identique a size_array()">size_totale</a>();
<a name="l00666"></a>00666   <span class="keyword">const</span> <span class="keywordtype">int</span> *flags_ptr = items_a_traiter.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
<a name="l00667"></a>00667   <span class="keyword">const</span> <span class="keywordtype">double</span> *vecteur_ptr = vecteur.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
<a name="l00668"></a>00668   <span class="keywordtype">double</span>       *vecteur2_fortran_ptr = vecteur2.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() - 1;
<a name="l00669"></a>00669   <span class="keyword">const</span> <span class="keywordtype">int</span> *tab2_fortran_ptr = tab2.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() - 1;
<a name="l00670"></a>00670   <span class="keyword">const</span> <span class="keywordtype">double</span> *coeff_fortran_ptr = coeff.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() - 1;
<a name="l00671"></a>00671   assert(coeff.<a class="code" href="classArrOfDouble.html#a3c3b33bea0e88b87315c21ee94bee05f" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() == tab2.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>());
<a name="l00672"></a>00672   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i_ligne = 0; i_ligne &lt; nb_lignes; i_ligne++, vecteur_ptr++)
<a name="l00673"></a>00673     {
<a name="l00674"></a>00674       <span class="keywordflow">if</span> (*(flags_ptr++))
<a name="l00675"></a>00675         {
<a name="l00676"></a>00676           <span class="keyword">const</span> <span class="keywordtype">double</span> v_i = *vecteur_ptr;
<a name="l00677"></a>00677           <span class="keywordtype">int</span> index = tab1[i_ligne];
<a name="l00678"></a>00678           <span class="keyword">const</span> <span class="keywordtype">int</span> index_fin = tab1[i_ligne+1];
<a name="l00679"></a>00679 <span class="comment">// Il peut n&#39;y avoir aucun coefficient sur la ligne =&gt; index_fin == index</span>
<a name="l00680"></a>00680           assert(index &gt; 0 &amp;&amp; index_fin &gt;= index &amp;&amp; index_fin &lt;= tab2.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>()+1);
<a name="l00681"></a>00681           <span class="keyword">const</span> <span class="keywordtype">int</span> *tab2_ptr = tab2_fortran_ptr + index;
<a name="l00682"></a>00682           <span class="keyword">const</span> <span class="keywordtype">double</span> *coeff_ptr = coeff_fortran_ptr + index;
<a name="l00683"></a>00683           <span class="keywordflow">for</span> (; index &lt; index_fin; index++, tab2_ptr++, coeff_ptr++)
<a name="l00684"></a>00684             {
<a name="l00685"></a>00685               <span class="keyword">const</span> <span class="keywordtype">int</span> i_colonne = *tab2_ptr;
<a name="l00686"></a>00686               assert(i_colonne &gt;= 1 &amp;&amp; i_colonne &lt;= vecteur2.<a class="code" href="classArrOfDouble.html#a3c3b33bea0e88b87315c21ee94bee05f" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>());
<a name="l00687"></a>00687               <span class="keyword">const</span> <span class="keywordtype">double</span> c = *coeff_ptr;
<a name="l00688"></a>00688 <span class="comment">// pas de test item commun sur les colonnes, voir **Annulation items communs**</span>
<a name="l00689"></a>00689               vecteur2_fortran_ptr[i_colonne] -= c * v_i;
<a name="l00690"></a>00690             }
<a name="l00691"></a>00691         }
<a name="l00692"></a>00692     }
<a name="l00693"></a>00693 }
<a name="l00694"></a>00694 
<a name="l00695"></a><a class="code" href="SSOR_8cpp.html#a3f7bb4887ce88e726a9512342521f07c">00695</a> <span class="keywordtype">void</span> <a class="code" href="SSOR_8cpp.html#adfde91562afac839dcf9442dcfd3d507">remontee_assert</a>(<span class="keyword">const</span> <span class="keywordtype">double</span> omega, <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; tab1, <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; tab2, <span class="keyword">const</span> <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a>&amp; <a class="code" href="Champ__P1iP1B__implementation_8cpp.html#aa8c8f49390c3cf7c702d71a71bc977e3">coeff</a>,
<a name="l00696"></a>00696                      <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; vecteur
<a name="l00697"></a>00697                      , <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; items_a_traiter
<a name="l00698"></a>00698                     )
<a name="l00699"></a>00699 {
<a name="l00700"></a>00700   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_lignes_a_traiter = vecteur.<a class="code" href="classDoubleVect.html#aafef4b3a96cdc428d62c5cedc9af6112">size_reelle_ok</a>() ? vecteur.<a class="code" href="classDoubleVect.html#a4a6987db458541cdcd10495955f25263" title="Taille de l&#39;espace &quot;reel&quot; du vecteur. (si md_vector_ est nul, cette valeur est identique a size_arr...">size_reelle</a>() : vecteur.<a class="code" href="classDoubleVect.html#ad2d21b364e1c6559771970596a25c006" title="Identique a size_array()">size_totale</a>();
<a name="l00701"></a>00701   <span class="keyword">const</span> <span class="keywordtype">int</span> *flags_ptr = items_a_traiter.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() + nb_lignes_a_traiter - 1;
<a name="l00702"></a>00702   assert(nb_lignes_a_traiter &lt;= items_a_traiter.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>());
<a name="l00703"></a>00703   <span class="keyword">const</span> <span class="keywordtype">double</span> psi = (2. - omega) / omega;
<a name="l00704"></a>00704 
<a name="l00705"></a>00705 <span class="comment">// pointeur &quot;fortran&quot; vers le tableau solution (indexable avec index fortran)</span>
<a name="l00706"></a>00706   <span class="keyword">const</span> <span class="keywordtype">double</span> * <span class="keyword">const</span> sol_fortran = vecteur.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() - 1;
<a name="l00707"></a>00707   <span class="keyword">const</span> <span class="keywordtype">int</span> *tab1_ptr = tab1.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() + nb_lignes_a_traiter;
<a name="l00708"></a>00708   <span class="keywordtype">int</span> last_tab1_de_i = *tab1_ptr;
<a name="l00709"></a>00709   tab1_ptr--;
<a name="l00710"></a>00710 <span class="comment">// On ne va pas a la fin de tab2 car on n&#39;est pas sur que nb_lignes_a_traiter = tab1.size_array() :</span>
<a name="l00711"></a>00711 <span class="comment">// -2 car last_tab1_de_i est l&#39;indice du premier coefficient de la ligne suivante en fortran</span>
<a name="l00712"></a>00712 <span class="comment">// (dont -1 pour fortran-&gt;c et -1 pour passer au dernier coeff de la ligne precedente)</span>
<a name="l00713"></a>00713   <span class="keyword">const</span> <span class="keywordtype">int</span> *tab2_ptr = tab2.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() + last_tab1_de_i - 2;
<a name="l00714"></a>00714   <span class="keyword">const</span> <span class="keywordtype">double</span> *coeff_ptr = coeff.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() + last_tab1_de_i - 2;
<a name="l00715"></a>00715   <span class="keywordtype">double</span> * soli_ptr = vecteur.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() + nb_lignes_a_traiter - 1;
<a name="l00716"></a>00716   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = nb_lignes_a_traiter; i; i--, tab1_ptr--, soli_ptr--)
<a name="l00717"></a>00717     {
<a name="l00718"></a>00718       <span class="keyword">const</span> <span class="keywordtype">int</span> tab1_de_i = *tab1_ptr; <span class="comment">//!&lt; = tab1[i]</span>
<a name="l00719"></a>00719 <span class="comment"></span>      <span class="keyword">const</span> <span class="keywordtype">int</span> nvois = last_tab1_de_i - tab1_de_i;
<a name="l00720"></a>00720       assert(nvois &gt;= 0 &amp;&amp; tab1_de_i &gt; 0);
<a name="l00721"></a>00721       last_tab1_de_i = tab1_de_i;
<a name="l00722"></a>00722 <span class="comment">// Ce test doit rester car il ne faut pas modifier sol[i] pour les items communs</span>
<a name="l00723"></a>00723 <span class="comment">// et virtuels (ils sont nuls et doivent le rester pour ne pas polluer les autres lignes):</span>
<a name="l00724"></a>00724       <span class="keywordflow">if</span> (*(flags_ptr--))
<a name="l00725"></a>00725         {
<a name="l00726"></a>00726 <span class="comment">// Operation &quot;diagonale&quot;:</span>
<a name="l00727"></a>00727           <span class="keywordtype">double</span> x = 0.;
<a name="l00728"></a>00728           <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = nvois-1; j; j--, tab2_ptr--, coeff_ptr--)
<a name="l00729"></a>00729             {
<a name="l00730"></a>00730               <span class="keyword">const</span> <span class="keywordtype">int</span> i2 = *tab2_ptr;
<a name="l00731"></a>00731               <span class="keyword">const</span> <span class="keywordtype">double</span> coeff_i_i2 = *coeff_ptr;
<a name="l00732"></a>00732 <span class="comment">// Operation nulle pour les items communs et virtuels</span>
<a name="l00733"></a>00733 <span class="comment">// (on a annule le second membre lors de la descente)</span>
<a name="l00734"></a>00734               x += coeff_i_i2 * sol_fortran[i2];
<a name="l00735"></a>00735             }
<a name="l00736"></a>00736 <span class="comment">// ici coeff_ptr est le coeff diagonal</span>
<a name="l00737"></a>00737           assert((*tab2_ptr) == i);
<a name="l00738"></a>00738           <span class="keyword">const</span> <span class="keywordtype">double</span> coeff_i_i = *coeff_ptr;
<a name="l00739"></a>00739           <span class="keyword">const</span> <span class="keywordtype">double</span> omega_coeff_i_i = omega / coeff_i_i;
<a name="l00740"></a>00740           *soli_ptr = (*soli_ptr) * psi * omega - x * omega_coeff_i_i;
<a name="l00741"></a>00741           coeff_ptr--;
<a name="l00742"></a>00742           tab2_ptr--;
<a name="l00743"></a>00743         }
<a name="l00744"></a>00744       <span class="keywordflow">else</span>
<a name="l00745"></a>00745         {
<a name="l00746"></a>00746           assert((*soli_ptr) == 0.);
<a name="l00747"></a>00747           coeff_ptr -= nvois;
<a name="l00748"></a>00748           tab2_ptr -= nvois;
<a name="l00749"></a>00749         }
<a name="l00750"></a>00750     }
<a name="l00751"></a>00751 }
<a name="l00752"></a>00752 
<a name="l00753"></a>00753 <span class="comment">// Remontee sur un bloc extradiagonal. Methode appelee par SSOR(const Matrice_bloc &amp; ...)</span>
<a name="l00754"></a>00754 <span class="comment">// vecteur: de taille &quot;nombre de lignes de la matrice&quot;</span>
<a name="l00755"></a>00755 <span class="comment">// vecteur2: &quot;nombre de colonnes&quot;</span>
<a name="l00756"></a><a class="code" href="SSOR_8cpp.html#ada55b3da28d7d5625ba464159920f977">00756</a> <span class="keywordtype">void</span> <a class="code" href="SSOR_8cpp.html#a5600e796c5a19cf31272da290b9933d6">remontee_bloc_extradiag_assert</a>(<span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; tab1, <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; tab2, <span class="keyword">const</span> <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a>&amp; <a class="code" href="Champ__P1iP1B__implementation_8cpp.html#aa8c8f49390c3cf7c702d71a71bc977e3">coeff</a>,
<a name="l00757"></a>00757                                     <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; vecteur,
<a name="l00758"></a>00758                                     <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; vecteur2
<a name="l00759"></a>00759                                     , <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; items_a_traiter
<a name="l00760"></a>00760                                    )
<a name="l00761"></a>00761 {
<a name="l00762"></a>00762   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_lignes = vecteur.<a class="code" href="classDoubleVect.html#aafef4b3a96cdc428d62c5cedc9af6112">size_reelle_ok</a>() ? vecteur.<a class="code" href="classDoubleVect.html#a4a6987db458541cdcd10495955f25263" title="Taille de l&#39;espace &quot;reel&quot; du vecteur. (si md_vector_ est nul, cette valeur est identique a size_arr...">size_reelle</a>() : vecteur.<a class="code" href="classDoubleVect.html#ad2d21b364e1c6559771970596a25c006" title="Identique a size_array()">size_totale</a>();
<a name="l00763"></a>00763   <span class="keyword">const</span> <span class="keywordtype">int</span> *flags_ptr = items_a_traiter.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
<a name="l00764"></a>00764   <span class="keywordtype">double</span> *vecteur_ptr = vecteur.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
<a name="l00765"></a>00765   <span class="keyword">const</span> <span class="keywordtype">double</span> *vecteur2_fortran_ptr = vecteur2.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() - 1;
<a name="l00766"></a>00766   <span class="keyword">const</span> <span class="keywordtype">int</span> *tab2_fortran_ptr = tab2.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() - 1;
<a name="l00767"></a>00767   <span class="keyword">const</span> <span class="keywordtype">double</span> *coeff_fortran_ptr = coeff.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() - 1;
<a name="l00768"></a>00768   assert(coeff.<a class="code" href="classArrOfDouble.html#a3c3b33bea0e88b87315c21ee94bee05f" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() == tab2.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>());
<a name="l00769"></a>00769   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i_ligne = 0; i_ligne &lt; nb_lignes; i_ligne++, vecteur_ptr++)
<a name="l00770"></a>00770     {
<a name="l00771"></a>00771       <span class="keywordflow">if</span> (*(flags_ptr++))
<a name="l00772"></a>00772         {
<a name="l00773"></a>00773           <span class="keywordtype">double</span> x = *vecteur_ptr;
<a name="l00774"></a>00774           <span class="keywordtype">int</span> index = tab1[i_ligne];
<a name="l00775"></a>00775           <span class="keyword">const</span> <span class="keywordtype">int</span> index_fin = tab1[i_ligne+1];
<a name="l00776"></a>00776 <span class="comment">// Il peut n&#39;y avoir aucun coefficient sur la ligne =&gt; index_fin == index</span>
<a name="l00777"></a>00777           assert(index &gt; 0 &amp;&amp; index_fin &gt;= index &amp;&amp; index_fin &lt;= tab2.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>()+1);
<a name="l00778"></a>00778           <span class="keyword">const</span> <span class="keywordtype">int</span> *tab2_ptr = tab2_fortran_ptr + index;
<a name="l00779"></a>00779           <span class="keyword">const</span> <span class="keywordtype">double</span> *coeff_ptr = coeff_fortran_ptr + index;
<a name="l00780"></a>00780           <span class="keywordflow">for</span> (; index &lt; index_fin; index++, tab2_ptr++, coeff_ptr++)
<a name="l00781"></a>00781             {
<a name="l00782"></a>00782               <span class="keyword">const</span> <span class="keywordtype">int</span> i_colonne = *tab2_ptr;
<a name="l00783"></a>00783               assert(i_colonne &gt;= 1 &amp;&amp; i_colonne &lt;= vecteur2.<a class="code" href="classArrOfDouble.html#a3c3b33bea0e88b87315c21ee94bee05f" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>());
<a name="l00784"></a>00784               <span class="keyword">const</span> <span class="keywordtype">double</span> c = *coeff_ptr;
<a name="l00785"></a>00785               <span class="keyword">const</span> <span class="keywordtype">double</span> x2 = vecteur2_fortran_ptr[i_colonne];
<a name="l00786"></a>00786 <span class="comment">// pas de test item commun sur les colonnes, voir **Annulation items communs**</span>
<a name="l00787"></a>00787               x -= c * x2;
<a name="l00788"></a>00788             }
<a name="l00789"></a>00789           *vecteur_ptr = x;
<a name="l00790"></a>00790         }
<a name="l00791"></a>00791     }
<a name="l00792"></a>00792 }
<a name="l00793"></a><a class="code" href="SSOR_8cpp.html#aed227e1ac9fa7cd2e15bcc6187422067">00793</a> <span class="keywordtype">void</span> <a class="code" href="SSOR_8cpp.html#aed227e1ac9fa7cd2e15bcc6187422067">descente_diag_ok_assert</a>(<span class="keyword">const</span> <span class="keywordtype">double</span> omega, <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; tab1, <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; tab2, <span class="keyword">const</span> <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a>&amp; <a class="code" href="Champ__P1iP1B__implementation_8cpp.html#aa8c8f49390c3cf7c702d71a71bc977e3">coeff</a>,
<a name="l00794"></a>00794                              <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; vecteur
<a name="l00795"></a>00795                             )
<a name="l00796"></a>00796 {
<a name="l00797"></a>00797   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_lignes_a_traiter = vecteur.<a class="code" href="classDoubleVect.html#aafef4b3a96cdc428d62c5cedc9af6112">size_reelle_ok</a>() ? vecteur.<a class="code" href="classDoubleVect.html#a4a6987db458541cdcd10495955f25263" title="Taille de l&#39;espace &quot;reel&quot; du vecteur. (si md_vector_ est nul, cette valeur est identique a size_arr...">size_reelle</a>() : vecteur.<a class="code" href="classDoubleVect.html#ad2d21b364e1c6559771970596a25c006" title="Identique a size_array()">size_totale</a>();
<a name="l00798"></a>00798 <span class="comment">// pointeur &quot;fortran&quot; vers le tableau solution (indexable avec index fortran)</span>
<a name="l00799"></a>00799 <span class="comment">// le pointeur est constant, pas le tableau pointe.</span>
<a name="l00800"></a>00800   <span class="keywordtype">double</span> * <span class="keyword">const</span> sol_fortran = vecteur.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() - 1;
<a name="l00801"></a>00801   <span class="keyword">const</span> <span class="keywordtype">int</span> *tab1_ptr = tab1.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
<a name="l00802"></a>00802   assert(nb_lignes_a_traiter &lt;= tab1.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() + 1);
<a name="l00803"></a>00803   assert(*tab1_ptr == 1); <span class="comment">//!&lt; sinon 2 lignes ci-dessous fausses.</span>
<a name="l00804"></a>00804 <span class="comment"></span>  <span class="keyword">const</span> <span class="keywordtype">int</span> *tab2_ptr = tab2.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
<a name="l00805"></a>00805   <span class="keyword">const</span> <span class="keywordtype">double</span> *coeff_ptr = coeff.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
<a name="l00806"></a>00806   <span class="keywordtype">int</span> last_tab1_de_i = *tab1_ptr;
<a name="l00807"></a>00807   tab1_ptr++;
<a name="l00808"></a>00808   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 1; i &lt;= nb_lignes_a_traiter; i++, tab1_ptr++)
<a name="l00809"></a>00809     {
<a name="l00810"></a>00810       <span class="keyword">const</span> <span class="keywordtype">int</span> tab1_de_i = *tab1_ptr; <span class="comment">//!&lt; = tab1[i]</span>
<a name="l00811"></a>00811 <span class="comment"></span>      <span class="keyword">const</span> <span class="keywordtype">int</span> nvois = tab1_de_i - last_tab1_de_i;
<a name="l00812"></a>00812       assert(nvois &gt;= 0 &amp;&amp; (tab1_de_i - 1) &lt;= tab2.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>());
<a name="l00813"></a>00813       last_tab1_de_i = tab1_de_i;
<a name="l00814"></a>00814 <span class="comment">// Ce test doit rester, sinon on pollue les autres lignes du vecteur sol</span>
<a name="l00815"></a>00815 <span class="comment">// avec des valeurs dependant des items communs et virtuels</span>
<a name="l00816"></a>00816       {
<a name="l00817"></a>00817 <span class="comment">// Le premier coeff doit etre le coef diagonal et doit etre strictement positif</span>
<a name="l00818"></a>00818         assert(nvois &gt;= 1 &amp;&amp; (*tab2_ptr) == i &amp;&amp; (*coeff_ptr) &gt; 0.);
<a name="l00819"></a>00819         <span class="keyword">const</span> <span class="keywordtype">double</span> omega_coeff_i_i = omega / (*coeff_ptr);
<a name="l00820"></a>00820         <span class="keyword">const</span> <span class="keywordtype">double</span> v_i = sol_fortran[i] *= omega_coeff_i_i;
<a name="l00821"></a>00821         tab2_ptr++;
<a name="l00822"></a>00822         coeff_ptr++;
<a name="l00823"></a>00823         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = nvois-1; j; j--, tab2_ptr++, coeff_ptr++)
<a name="l00824"></a>00824           {
<a name="l00825"></a>00825             <span class="keyword">const</span> <span class="keywordtype">int</span> i2 = *tab2_ptr; <span class="comment">//!&lt; indice de colonne pour le prochain coefficient</span>
<a name="l00826"></a>00826 <span class="comment"></span>            <span class="keyword">const</span> <span class="keywordtype">double</span> coeff_i_i2 = *coeff_ptr;
<a name="l00827"></a>00827 <span class="comment">// la matrice n&#39;a que des coeffs diagonaux superieurs et on a deja traite</span>
<a name="l00828"></a>00828 <span class="comment">// la diagonale, donc i2 &gt; i.</span>
<a name="l00829"></a>00829 <span class="comment">// Pas d&#39;items virtuels autorises !</span>
<a name="l00830"></a>00830             assert(i2 &gt; i &amp;&amp; i2 &lt;= nb_lignes_a_traiter);
<a name="l00831"></a>00831 <span class="comment">// B.M.: ... en revanche, le test sur les items communs est superflu ici car</span>
<a name="l00832"></a>00832 <span class="comment">// la valeur sera annulee (voir **Annulation items communs**),</span>
<a name="l00833"></a>00833 <span class="comment">// gain de perfs si on ne fait pas le test</span>
<a name="l00834"></a>00834             sol_fortran[i2] -= coeff_i_i2 * v_i;
<a name="l00835"></a>00835           }
<a name="l00836"></a>00836       }
<a name="l00837"></a>00837     }
<a name="l00838"></a>00838 }
<a name="l00839"></a>00839 
<a name="l00840"></a>00840 
<a name="l00841"></a><a class="code" href="SSOR_8cpp.html#a3d6a3eb26f76575031f1283cd7a0daa6">00841</a> <span class="keywordtype">void</span> <a class="code" href="SSOR_8cpp.html#a3d6a3eb26f76575031f1283cd7a0daa6">remontee_diag_ok_assert</a>(<span class="keyword">const</span> <span class="keywordtype">double</span> omega, <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; tab1, <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; tab2, <span class="keyword">const</span> <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a>&amp; <a class="code" href="Champ__P1iP1B__implementation_8cpp.html#aa8c8f49390c3cf7c702d71a71bc977e3">coeff</a>,
<a name="l00842"></a>00842                              <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; vecteur
<a name="l00843"></a>00843                             )
<a name="l00844"></a>00844 {
<a name="l00845"></a>00845   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_lignes_a_traiter = vecteur.<a class="code" href="classDoubleVect.html#aafef4b3a96cdc428d62c5cedc9af6112">size_reelle_ok</a>() ? vecteur.<a class="code" href="classDoubleVect.html#a4a6987db458541cdcd10495955f25263" title="Taille de l&#39;espace &quot;reel&quot; du vecteur. (si md_vector_ est nul, cette valeur est identique a size_arr...">size_reelle</a>() : vecteur.<a class="code" href="classDoubleVect.html#ad2d21b364e1c6559771970596a25c006" title="Identique a size_array()">size_totale</a>();
<a name="l00846"></a>00846 
<a name="l00847"></a>00847 <span class="comment">// pointeur &quot;fortran&quot; vers le tableau solution (indexable avec index fortran)</span>
<a name="l00848"></a>00848   <span class="keyword">const</span> <span class="keywordtype">double</span> * <span class="keyword">const</span> sol_fortran = vecteur.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() - 1;
<a name="l00849"></a>00849   <span class="keyword">const</span> <span class="keywordtype">int</span> *tab1_ptr = tab1.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() + nb_lignes_a_traiter;
<a name="l00850"></a>00850   <span class="keywordtype">int</span> last_tab1_de_i = *tab1_ptr;
<a name="l00851"></a>00851   tab1_ptr--;
<a name="l00852"></a>00852 <span class="comment">// On ne va pas a la fin de tab2 car on n&#39;est pas sur que nb_lignes_a_traiter = tab1.size_array() :</span>
<a name="l00853"></a>00853 <span class="comment">// -2 car last_tab1_de_i est l&#39;indice du premier coefficient de la ligne suivante en fortran</span>
<a name="l00854"></a>00854 <span class="comment">// (dont -1 pour fortran-&gt;c et -1 pour passer au dernier coeff de la ligne precedente)</span>
<a name="l00855"></a>00855   <span class="keyword">const</span> <span class="keywordtype">int</span> *tab2_ptr = tab2.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() + last_tab1_de_i - 2;
<a name="l00856"></a>00856   <span class="keyword">const</span> <span class="keywordtype">double</span> *coeff_ptr = coeff.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() + last_tab1_de_i - 2;
<a name="l00857"></a>00857   <span class="keywordtype">double</span> * soli_ptr = vecteur.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() + nb_lignes_a_traiter - 1;
<a name="l00858"></a>00858   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = nb_lignes_a_traiter; i; i--, tab1_ptr--, soli_ptr--)
<a name="l00859"></a>00859     {
<a name="l00860"></a>00860       <span class="keyword">const</span> <span class="keywordtype">int</span> tab1_de_i = *tab1_ptr; <span class="comment">//!&lt; = tab1[i]</span>
<a name="l00861"></a>00861 <span class="comment"></span>      <span class="keyword">const</span> <span class="keywordtype">int</span> nvois = last_tab1_de_i - tab1_de_i;
<a name="l00862"></a>00862       assert(nvois &gt;= 0 &amp;&amp; tab1_de_i &gt; 0);
<a name="l00863"></a>00863       last_tab1_de_i = tab1_de_i;
<a name="l00864"></a>00864 <span class="comment">// Ce test doit rester car il ne faut pas modifier sol[i] pour les items communs</span>
<a name="l00865"></a>00865 <span class="comment">// et virtuels (ils sont nuls et doivent le rester pour ne pas polluer les autres lignes):</span>
<a name="l00866"></a>00866       <span class="keywordflow">if</span> (1)
<a name="l00867"></a>00867         {
<a name="l00868"></a>00868 <span class="comment">// Operation &quot;diagonale&quot;:</span>
<a name="l00869"></a>00869           <span class="keywordtype">double</span> x = 0.;
<a name="l00870"></a>00870           <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = nvois-1; j; j--, tab2_ptr--, coeff_ptr--)
<a name="l00871"></a>00871             {
<a name="l00872"></a>00872               <span class="keyword">const</span> <span class="keywordtype">int</span> i2 = *tab2_ptr;
<a name="l00873"></a>00873               <span class="keyword">const</span> <span class="keywordtype">double</span> coeff_i_i2 = *coeff_ptr;
<a name="l00874"></a>00874 <span class="comment">// Operation nulle pour les items communs et virtuels</span>
<a name="l00875"></a>00875 <span class="comment">// (on a annule le second membre lors de la descente)</span>
<a name="l00876"></a>00876               x += coeff_i_i2 * sol_fortran[i2];
<a name="l00877"></a>00877             }
<a name="l00878"></a>00878 <span class="comment">// ici coeff_ptr est le coeff diagonal</span>
<a name="l00879"></a>00879           assert((*tab2_ptr) == i);
<a name="l00880"></a>00880           <span class="keyword">const</span> <span class="keywordtype">double</span> coeff_i_i = *coeff_ptr;
<a name="l00881"></a>00881           <span class="keyword">const</span> <span class="keywordtype">double</span> omega_coeff_i_i = omega / coeff_i_i;
<a name="l00882"></a>00882 <span class="comment">// La diagonale a deja ete multipliee par psi * coeff_i_i</span>
<a name="l00883"></a>00883           *soli_ptr = ((*soli_ptr) - x) * omega_coeff_i_i;
<a name="l00884"></a>00884           coeff_ptr--;
<a name="l00885"></a>00885           tab2_ptr--;
<a name="l00886"></a>00886         }
<a name="l00887"></a>00887       <span class="keywordflow">else</span>
<a name="l00888"></a>00888         {
<a name="l00889"></a>00889           assert((*soli_ptr) == 0.);
<a name="l00890"></a>00890           coeff_ptr -= nvois;
<a name="l00891"></a>00891           tab2_ptr -= nvois;
<a name="l00892"></a>00892         }
<a name="l00893"></a>00893     }
<a name="l00894"></a>00894 }
<a name="l00895"></a>00895 
<a name="l00896"></a><a class="code" href="SSOR_8cpp.html#af50d87729d0431f156ef36e568081cee">00896</a> <span class="keywordtype">void</span> <a class="code" href="SSOR_8cpp.html#aed227e1ac9fa7cd2e15bcc6187422067">descente_diag_ok_assert</a>(<span class="keyword">const</span> <span class="keywordtype">double</span> omega, <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; tab1, <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; tab2, <span class="keyword">const</span> <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a>&amp; <a class="code" href="Champ__P1iP1B__implementation_8cpp.html#aa8c8f49390c3cf7c702d71a71bc977e3">coeff</a>,
<a name="l00897"></a>00897                              <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; vecteur
<a name="l00898"></a>00898                              , <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; items_a_traiter
<a name="l00899"></a>00899                             )
<a name="l00900"></a>00900 {
<a name="l00901"></a>00901   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_lignes_a_traiter = vecteur.<a class="code" href="classDoubleVect.html#aafef4b3a96cdc428d62c5cedc9af6112">size_reelle_ok</a>() ? vecteur.<a class="code" href="classDoubleVect.html#a4a6987db458541cdcd10495955f25263" title="Taille de l&#39;espace &quot;reel&quot; du vecteur. (si md_vector_ est nul, cette valeur est identique a size_arr...">size_reelle</a>() : vecteur.<a class="code" href="classDoubleVect.html#ad2d21b364e1c6559771970596a25c006" title="Identique a size_array()">size_totale</a>();
<a name="l00902"></a>00902 <span class="comment">// pointeur &quot;fortran&quot; vers le tableau solution (indexable avec index fortran)</span>
<a name="l00903"></a>00903 <span class="comment">// le pointeur est constant, pas le tableau pointe.</span>
<a name="l00904"></a>00904   <span class="keywordtype">double</span> * <span class="keyword">const</span> sol_fortran = vecteur.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() - 1;
<a name="l00905"></a>00905   <span class="keyword">const</span> <span class="keywordtype">int</span> *flags_ptr = items_a_traiter.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
<a name="l00906"></a>00906   assert(nb_lignes_a_traiter &lt;= items_a_traiter.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>());
<a name="l00907"></a>00907   <span class="keyword">const</span> <span class="keywordtype">int</span> *tab1_ptr = tab1.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
<a name="l00908"></a>00908   assert(nb_lignes_a_traiter &lt;= tab1.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() + 1);
<a name="l00909"></a>00909   assert(*tab1_ptr == 1); <span class="comment">//!&lt; sinon 2 lignes ci-dessous fausses.</span>
<a name="l00910"></a>00910 <span class="comment"></span>  <span class="keyword">const</span> <span class="keywordtype">int</span> *tab2_ptr = tab2.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
<a name="l00911"></a>00911   <span class="keyword">const</span> <span class="keywordtype">double</span> *coeff_ptr = coeff.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
<a name="l00912"></a>00912   <span class="keywordtype">int</span> last_tab1_de_i = *tab1_ptr;
<a name="l00913"></a>00913   tab1_ptr++;
<a name="l00914"></a>00914   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 1; i &lt;= nb_lignes_a_traiter; i++, tab1_ptr++)
<a name="l00915"></a>00915     {
<a name="l00916"></a>00916       <span class="keyword">const</span> <span class="keywordtype">int</span> tab1_de_i = *tab1_ptr; <span class="comment">//!&lt; = tab1[i]</span>
<a name="l00917"></a>00917 <span class="comment"></span>      <span class="keyword">const</span> <span class="keywordtype">int</span> nvois = tab1_de_i - last_tab1_de_i;
<a name="l00918"></a>00918       assert(nvois &gt;= 0 &amp;&amp; (tab1_de_i - 1) &lt;= tab2.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>());
<a name="l00919"></a>00919       last_tab1_de_i = tab1_de_i;
<a name="l00920"></a>00920 <span class="comment">// Ce test doit rester, sinon on pollue les autres lignes du vecteur sol</span>
<a name="l00921"></a>00921 <span class="comment">// avec des valeurs dependant des items communs et virtuels</span>
<a name="l00922"></a>00922       assert((flags_ptr - items_a_traiter.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>()) == (i-1));
<a name="l00923"></a>00923       <span class="keyword">const</span> <span class="keywordtype">int</span> item_a_traiter = *(flags_ptr++);
<a name="l00924"></a>00924       <span class="keywordflow">if</span> (item_a_traiter)
<a name="l00925"></a>00925         {
<a name="l00926"></a>00926 <span class="comment">// Le premier coeff doit etre le coef diagonal et doit etre strictement positif</span>
<a name="l00927"></a>00927           assert(nvois &gt;= 1 &amp;&amp; (*tab2_ptr) == i &amp;&amp; (*coeff_ptr) &gt; 0.);
<a name="l00928"></a>00928           <span class="keyword">const</span> <span class="keywordtype">double</span> omega_coeff_i_i = omega / (*coeff_ptr);
<a name="l00929"></a>00929           <span class="keyword">const</span> <span class="keywordtype">double</span> v_i = sol_fortran[i] *= omega_coeff_i_i;
<a name="l00930"></a>00930           tab2_ptr++;
<a name="l00931"></a>00931           coeff_ptr++;
<a name="l00932"></a>00932           <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = nvois-1; j; j--, tab2_ptr++, coeff_ptr++)
<a name="l00933"></a>00933             {
<a name="l00934"></a>00934               <span class="keyword">const</span> <span class="keywordtype">int</span> i2 = *tab2_ptr; <span class="comment">//!&lt; indice de colonne pour le prochain coefficient</span>
<a name="l00935"></a>00935 <span class="comment"></span>              <span class="keyword">const</span> <span class="keywordtype">double</span> coeff_i_i2 = *coeff_ptr;
<a name="l00936"></a>00936 <span class="comment">// la matrice n&#39;a que des coeffs diagonaux superieurs et on a deja traite</span>
<a name="l00937"></a>00937 <span class="comment">// la diagonale, donc i2 &gt; i.</span>
<a name="l00938"></a>00938               assert(i2 &gt; i &amp;&amp; i2 &lt;= vecteur.<a class="code" href="classDoubleVect.html#ad2d21b364e1c6559771970596a25c006" title="Identique a size_array()">size_totale</a>());
<a name="l00939"></a>00939 <span class="comment">// B.M.: ... en revanche, le test sur les items communs est superflu ici car</span>
<a name="l00940"></a>00940 <span class="comment">// la valeur sera annulee (voir **Annulation items communs**),</span>
<a name="l00941"></a>00941 <span class="comment">// gain de perfs si on ne fait pas le test</span>
<a name="l00942"></a>00942               sol_fortran[i2] -= coeff_i_i2 * v_i;
<a name="l00943"></a>00943             }
<a name="l00944"></a>00944         }
<a name="l00945"></a>00945       <span class="keywordflow">else</span>
<a name="l00946"></a>00946         {
<a name="l00947"></a>00947 <span class="comment">// **Annulation items communs**</span>
<a name="l00948"></a>00948 <span class="comment">// c&#39;est la derniere fois qu&#39;on ecrit dans sol_fortran[i] car la</span>
<a name="l00949"></a>00949 <span class="comment">// matrice est diagonale superieure. Pour eviter le test sur items_a_traiter_</span>
<a name="l00950"></a>00950 <span class="comment">// dans la remontee, on annule la solution pour les items communs et virtuels</span>
<a name="l00951"></a>00951 <span class="comment">// (sol_fortran[i] ne sera plus modifie ensuite dans la descente)</span>
<a name="l00952"></a>00952           sol_fortran[i] = 0.;
<a name="l00953"></a>00953           coeff_ptr += nvois;
<a name="l00954"></a>00954           tab2_ptr += nvois;
<a name="l00955"></a>00955         }
<a name="l00956"></a>00956     }
<a name="l00957"></a>00957 <span class="comment">// **Annulation items communs**</span>
<a name="l00958"></a>00958 <span class="comment">// Pour la remontee il faut annuler les valeurs dans les cases virtuelles</span>
<a name="l00959"></a>00959   {
<a name="l00960"></a>00960     <span class="keyword">const</span> <span class="keywordtype">int</span> fin = vecteur.<a class="code" href="classDoubleVect.html#ad2d21b364e1c6559771970596a25c006" title="Identique a size_array()">size_totale</a>();
<a name="l00961"></a>00961     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = nb_lignes_a_traiter+1; i &lt;= fin; i++)
<a name="l00962"></a>00962       sol_fortran[i] = 0.;
<a name="l00963"></a>00963   }
<a name="l00964"></a>00964 }
<a name="l00965"></a>00965 
<a name="l00966"></a>00966 
<a name="l00967"></a><a class="code" href="SSOR_8cpp.html#a7f70981e2add623f46c0078c9b96bfb0">00967</a> <span class="keywordtype">void</span> <a class="code" href="SSOR_8cpp.html#a3d6a3eb26f76575031f1283cd7a0daa6">remontee_diag_ok_assert</a>(<span class="keyword">const</span> <span class="keywordtype">double</span> omega, <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; tab1, <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; tab2, <span class="keyword">const</span> <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a>&amp; <a class="code" href="Champ__P1iP1B__implementation_8cpp.html#aa8c8f49390c3cf7c702d71a71bc977e3">coeff</a>,
<a name="l00968"></a>00968                              <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; vecteur
<a name="l00969"></a>00969                              , <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; items_a_traiter
<a name="l00970"></a>00970                             )
<a name="l00971"></a>00971 {
<a name="l00972"></a>00972   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_lignes_a_traiter = vecteur.<a class="code" href="classDoubleVect.html#aafef4b3a96cdc428d62c5cedc9af6112">size_reelle_ok</a>() ? vecteur.<a class="code" href="classDoubleVect.html#a4a6987db458541cdcd10495955f25263" title="Taille de l&#39;espace &quot;reel&quot; du vecteur. (si md_vector_ est nul, cette valeur est identique a size_arr...">size_reelle</a>() : vecteur.<a class="code" href="classDoubleVect.html#ad2d21b364e1c6559771970596a25c006" title="Identique a size_array()">size_totale</a>();
<a name="l00973"></a>00973   <span class="keyword">const</span> <span class="keywordtype">int</span> *flags_ptr = items_a_traiter.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() + nb_lignes_a_traiter - 1;
<a name="l00974"></a>00974   assert(nb_lignes_a_traiter &lt;= items_a_traiter.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>());
<a name="l00975"></a>00975 
<a name="l00976"></a>00976 <span class="comment">// pointeur &quot;fortran&quot; vers le tableau solution (indexable avec index fortran)</span>
<a name="l00977"></a>00977   <span class="keyword">const</span> <span class="keywordtype">double</span> * <span class="keyword">const</span> sol_fortran = vecteur.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() - 1;
<a name="l00978"></a>00978   <span class="keyword">const</span> <span class="keywordtype">int</span> *tab1_ptr = tab1.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() + nb_lignes_a_traiter;
<a name="l00979"></a>00979   <span class="keywordtype">int</span> last_tab1_de_i = *tab1_ptr;
<a name="l00980"></a>00980   tab1_ptr--;
<a name="l00981"></a>00981 <span class="comment">// On ne va pas a la fin de tab2 car on n&#39;est pas sur que nb_lignes_a_traiter = tab1.size_array() :</span>
<a name="l00982"></a>00982 <span class="comment">// -2 car last_tab1_de_i est l&#39;indice du premier coefficient de la ligne suivante en fortran</span>
<a name="l00983"></a>00983 <span class="comment">// (dont -1 pour fortran-&gt;c et -1 pour passer au dernier coeff de la ligne precedente)</span>
<a name="l00984"></a>00984   <span class="keyword">const</span> <span class="keywordtype">int</span> *tab2_ptr = tab2.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() + last_tab1_de_i - 2;
<a name="l00985"></a>00985   <span class="keyword">const</span> <span class="keywordtype">double</span> *coeff_ptr = coeff.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() + last_tab1_de_i - 2;
<a name="l00986"></a>00986   <span class="keywordtype">double</span> * soli_ptr = vecteur.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() + nb_lignes_a_traiter - 1;
<a name="l00987"></a>00987   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = nb_lignes_a_traiter; i; i--, tab1_ptr--, soli_ptr--)
<a name="l00988"></a>00988     {
<a name="l00989"></a>00989       <span class="keyword">const</span> <span class="keywordtype">int</span> tab1_de_i = *tab1_ptr; <span class="comment">//!&lt; = tab1[i]</span>
<a name="l00990"></a>00990 <span class="comment"></span>      <span class="keyword">const</span> <span class="keywordtype">int</span> nvois = last_tab1_de_i - tab1_de_i;
<a name="l00991"></a>00991       assert(nvois &gt;= 0 &amp;&amp; tab1_de_i &gt; 0);
<a name="l00992"></a>00992       last_tab1_de_i = tab1_de_i;
<a name="l00993"></a>00993 <span class="comment">// Ce test doit rester car il ne faut pas modifier sol[i] pour les items communs</span>
<a name="l00994"></a>00994 <span class="comment">// et virtuels (ils sont nuls et doivent le rester pour ne pas polluer les autres lignes):</span>
<a name="l00995"></a>00995       <span class="keywordflow">if</span> (*(flags_ptr--))
<a name="l00996"></a>00996         {
<a name="l00997"></a>00997 <span class="comment">// Operation &quot;diagonale&quot;:</span>
<a name="l00998"></a>00998           <span class="keywordtype">double</span> x = 0.;
<a name="l00999"></a>00999           <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = nvois-1; j; j--, tab2_ptr--, coeff_ptr--)
<a name="l01000"></a>01000             {
<a name="l01001"></a>01001               <span class="keyword">const</span> <span class="keywordtype">int</span> i2 = *tab2_ptr;
<a name="l01002"></a>01002               <span class="keyword">const</span> <span class="keywordtype">double</span> coeff_i_i2 = *coeff_ptr;
<a name="l01003"></a>01003 <span class="comment">// Operation nulle pour les items communs et virtuels</span>
<a name="l01004"></a>01004 <span class="comment">// (on a annule le second membre lors de la descente)</span>
<a name="l01005"></a>01005               x += coeff_i_i2 * sol_fortran[i2];
<a name="l01006"></a>01006             }
<a name="l01007"></a>01007 <span class="comment">// ici coeff_ptr est le coeff diagonal</span>
<a name="l01008"></a>01008           assert((*tab2_ptr) == i);
<a name="l01009"></a>01009           <span class="keyword">const</span> <span class="keywordtype">double</span> coeff_i_i = *coeff_ptr;
<a name="l01010"></a>01010           <span class="keyword">const</span> <span class="keywordtype">double</span> omega_coeff_i_i = omega / coeff_i_i;
<a name="l01011"></a>01011 <span class="comment">// La diagonale a deja ete multipliee par psi * coeff_i_i</span>
<a name="l01012"></a>01012           *soli_ptr = ((*soli_ptr) - x) * omega_coeff_i_i;
<a name="l01013"></a>01013           coeff_ptr--;
<a name="l01014"></a>01014           tab2_ptr--;
<a name="l01015"></a>01015         }
<a name="l01016"></a>01016       <span class="keywordflow">else</span>
<a name="l01017"></a>01017         {
<a name="l01018"></a>01018           assert((*soli_ptr) == 0.);
<a name="l01019"></a>01019           coeff_ptr -= nvois;
<a name="l01020"></a>01020           tab2_ptr -= nvois;
<a name="l01021"></a>01021         }
<a name="l01022"></a>01022     }
<a name="l01023"></a>01023 }
<a name="l01024"></a>01024 
<a name="l01025"></a><a class="code" href="SSOR_8cpp.html#ac6165a9a7d7601cae69f7b343d02499d">01025</a> <span class="keywordtype">void</span> <a class="code" href="SSOR_8cpp.html#ac6165a9a7d7601cae69f7b343d02499d">descente_precond_diag</a>(<span class="keyword">const</span> <span class="keywordtype">double</span> omega, <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; tab1, <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; tab2, <span class="keyword">const</span> <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a>&amp; <a class="code" href="Champ__P1iP1B__implementation_8cpp.html#aa8c8f49390c3cf7c702d71a71bc977e3">coeff</a>,
<a name="l01026"></a>01026                            <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; vecteur
<a name="l01027"></a>01027                           )
<a name="l01028"></a>01028 {
<a name="l01029"></a>01029   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_lignes_a_traiter = vecteur.<a class="code" href="classDoubleVect.html#aafef4b3a96cdc428d62c5cedc9af6112">size_reelle_ok</a>() ? vecteur.<a class="code" href="classDoubleVect.html#a4a6987db458541cdcd10495955f25263" title="Taille de l&#39;espace &quot;reel&quot; du vecteur. (si md_vector_ est nul, cette valeur est identique a size_arr...">size_reelle</a>() : vecteur.<a class="code" href="classDoubleVect.html#ad2d21b364e1c6559771970596a25c006" title="Identique a size_array()">size_totale</a>();
<a name="l01030"></a>01030 <span class="comment">// pointeur &quot;fortran&quot; vers le tableau solution (indexable avec index fortran)</span>
<a name="l01031"></a>01031 <span class="comment">// le pointeur est constant, pas le tableau pointe.</span>
<a name="l01032"></a>01032   <span class="keywordtype">double</span> * <span class="keyword">const</span> sol_fortran = vecteur.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() - 1;
<a name="l01033"></a>01033   <span class="keyword">const</span> <span class="keywordtype">int</span> *tab1_ptr = tab1.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
<a name="l01034"></a>01034   assert(nb_lignes_a_traiter &lt;= tab1.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() + 1);
<a name="l01035"></a>01035   assert(*tab1_ptr == 1); <span class="comment">//!&lt; sinon 2 lignes ci-dessous fausses.</span>
<a name="l01036"></a>01036 <span class="comment"></span>  <span class="keyword">const</span> <span class="keywordtype">int</span> *tab2_ptr = tab2.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
<a name="l01037"></a>01037   <span class="keyword">const</span> <span class="keywordtype">double</span> *coeff_ptr = coeff.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
<a name="l01038"></a>01038   <span class="keywordtype">int</span> last_tab1_de_i = *tab1_ptr;
<a name="l01039"></a>01039   tab1_ptr++;
<a name="l01040"></a>01040   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 1; i &lt;= nb_lignes_a_traiter; i++, tab1_ptr++)
<a name="l01041"></a>01041     {
<a name="l01042"></a>01042       <span class="keyword">const</span> <span class="keywordtype">int</span> tab1_de_i = *tab1_ptr; <span class="comment">//!&lt; = tab1[i]</span>
<a name="l01043"></a>01043 <span class="comment"></span>      <span class="keyword">const</span> <span class="keywordtype">int</span> nvois = tab1_de_i - last_tab1_de_i;
<a name="l01044"></a>01044       <span class="keyword">static_cast&lt;</span><span class="keywordtype">void</span><span class="keyword">&gt;</span> (0);
<a name="l01045"></a>01045       last_tab1_de_i = tab1_de_i;
<a name="l01046"></a>01046 <span class="comment">// Ce test doit rester, sinon on pollue les autres lignes du vecteur sol</span>
<a name="l01047"></a>01047 <span class="comment">// avec des valeurs dependant des items communs et virtuels</span>
<a name="l01048"></a>01048       {
<a name="l01049"></a>01049 <span class="comment">// Pas de coefficient diagonal stocke (ni dans tab2 ni dans coeff), la diagonale vaut 1:</span>
<a name="l01050"></a>01050         <span class="keyword">const</span> <span class="keywordtype">double</span> v_i = sol_fortran[i] *= omega;
<a name="l01051"></a>01051         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = nvois-1; j; j--, tab2_ptr++, coeff_ptr++)
<a name="l01052"></a>01052           {
<a name="l01053"></a>01053             <span class="keyword">const</span> <span class="keywordtype">int</span> i2 = *tab2_ptr; <span class="comment">//!&lt; indice de colonne pour le prochain coefficient</span>
<a name="l01054"></a>01054 <span class="comment"></span>            <span class="keyword">const</span> <span class="keywordtype">double</span> coeff_i_i2 = *coeff_ptr;
<a name="l01055"></a>01055 <span class="comment">// la matrice n&#39;a que des coeffs diagonaux superieurs et on a deja traite</span>
<a name="l01056"></a>01056 <span class="comment">// la diagonale, donc i2 &gt; i.</span>
<a name="l01057"></a>01057 <span class="comment">// Pas d&#39;items virtuels autorises !</span>
<a name="l01058"></a>01058             <span class="keyword">static_cast&lt;</span><span class="keywordtype">void</span><span class="keyword">&gt;</span> (0);
<a name="l01059"></a>01059 <span class="comment">// B.M.: ... en revanche, le test sur les items communs est superflu ici car</span>
<a name="l01060"></a>01060 <span class="comment">// la valeur sera annulee (voir **Annulation items communs**),</span>
<a name="l01061"></a>01061 <span class="comment">// gain de perfs si on ne fait pas le test</span>
<a name="l01062"></a>01062             sol_fortran[i2] -= coeff_i_i2 * v_i;
<a name="l01063"></a>01063           }
<a name="l01064"></a>01064       }
<a name="l01065"></a>01065     }
<a name="l01066"></a>01066 }
<a name="l01067"></a>01067 
<a name="l01068"></a>01068 
<a name="l01069"></a><a class="code" href="SSOR_8cpp.html#aa011041d08feeec86cfb569445fd565d">01069</a> <span class="keywordtype">void</span> <a class="code" href="SSOR_8cpp.html#aa011041d08feeec86cfb569445fd565d">remontee_precond_diag</a>(<span class="keyword">const</span> <span class="keywordtype">double</span> omega, <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; tab1, <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; tab2, <span class="keyword">const</span> <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a>&amp; <a class="code" href="Champ__P1iP1B__implementation_8cpp.html#aa8c8f49390c3cf7c702d71a71bc977e3">coeff</a>,
<a name="l01070"></a>01070                            <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; vecteur
<a name="l01071"></a>01071                           )
<a name="l01072"></a>01072 {
<a name="l01073"></a>01073   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_lignes_a_traiter = vecteur.<a class="code" href="classDoubleVect.html#aafef4b3a96cdc428d62c5cedc9af6112">size_reelle_ok</a>() ? vecteur.<a class="code" href="classDoubleVect.html#a4a6987db458541cdcd10495955f25263" title="Taille de l&#39;espace &quot;reel&quot; du vecteur. (si md_vector_ est nul, cette valeur est identique a size_arr...">size_reelle</a>() : vecteur.<a class="code" href="classDoubleVect.html#ad2d21b364e1c6559771970596a25c006" title="Identique a size_array()">size_totale</a>();
<a name="l01074"></a>01074   <span class="keyword">const</span> <span class="keywordtype">double</span> psi = (2. - omega) / omega;
<a name="l01075"></a>01075 
<a name="l01076"></a>01076 <span class="comment">// pointeur &quot;fortran&quot; vers le tableau solution (indexable avec index fortran)</span>
<a name="l01077"></a>01077   <span class="keyword">const</span> <span class="keywordtype">double</span> * <span class="keyword">const</span> sol_fortran = vecteur.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() - 1;
<a name="l01078"></a>01078   <span class="keyword">const</span> <span class="keywordtype">int</span> *tab1_ptr = tab1.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() + nb_lignes_a_traiter;
<a name="l01079"></a>01079   <span class="keywordtype">int</span> last_tab1_de_i = *tab1_ptr;
<a name="l01080"></a>01080   tab1_ptr--;
<a name="l01081"></a>01081 <span class="comment">// On ne va pas a la fin de tab2 car on n&#39;est pas sur que nb_lignes_a_traiter = tab1.size_array() :</span>
<a name="l01082"></a>01082 <span class="comment">// -2 car last_tab1_de_i est l&#39;indice du premier coefficient de la ligne suivante en fortran</span>
<a name="l01083"></a>01083 <span class="comment">// (dont -1 pour fortran-&gt;c et -1 pour passer au dernier coeff de la ligne precedente)</span>
<a name="l01084"></a>01084   <span class="keyword">const</span> <span class="keywordtype">int</span> *tab2_ptr = tab2.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() + last_tab1_de_i - 2;
<a name="l01085"></a>01085   <span class="keyword">const</span> <span class="keywordtype">double</span> *coeff_ptr = coeff.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() + last_tab1_de_i - 2;
<a name="l01086"></a>01086   <span class="keywordtype">double</span> * soli_ptr = vecteur.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() + nb_lignes_a_traiter - 1;
<a name="l01087"></a>01087   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = nb_lignes_a_traiter; i; i--, tab1_ptr--, soli_ptr--)
<a name="l01088"></a>01088     {
<a name="l01089"></a>01089       <span class="keyword">const</span> <span class="keywordtype">int</span> tab1_de_i = *tab1_ptr; <span class="comment">//!&lt; = tab1[i]</span>
<a name="l01090"></a>01090 <span class="comment"></span>      <span class="keyword">const</span> <span class="keywordtype">int</span> nvois = last_tab1_de_i - tab1_de_i;
<a name="l01091"></a>01091       <span class="keyword">static_cast&lt;</span><span class="keywordtype">void</span><span class="keyword">&gt;</span> (0);
<a name="l01092"></a>01092       last_tab1_de_i = tab1_de_i;
<a name="l01093"></a>01093 <span class="comment">// Ce test doit rester car il ne faut pas modifier sol[i] pour les items communs</span>
<a name="l01094"></a>01094 <span class="comment">// et virtuels (ils sont nuls et doivent le rester pour ne pas polluer les autres lignes):</span>
<a name="l01095"></a>01095       <span class="keywordflow">if</span> (1)
<a name="l01096"></a>01096         {
<a name="l01097"></a>01097 <span class="comment">// Operation &quot;diagonale&quot;:</span>
<a name="l01098"></a>01098           <span class="keywordtype">double</span> x = 0.;
<a name="l01099"></a>01099           <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = nvois-1; j; j--, tab2_ptr--, coeff_ptr--)
<a name="l01100"></a>01100             {
<a name="l01101"></a>01101               <span class="keyword">const</span> <span class="keywordtype">int</span> i2 = *tab2_ptr;
<a name="l01102"></a>01102               <span class="keyword">const</span> <span class="keywordtype">double</span> coeff_i_i2 = *coeff_ptr;
<a name="l01103"></a>01103 <span class="comment">// Operation nulle pour les items communs et virtuels</span>
<a name="l01104"></a>01104 <span class="comment">// (on a annule le second membre lors de la descente)</span>
<a name="l01105"></a>01105               x += coeff_i_i2 * sol_fortran[i2];
<a name="l01106"></a>01106             }
<a name="l01107"></a>01107 <span class="comment">// Preconditionnement diagonal, pas de coefficient diagonal stocke:</span>
<a name="l01108"></a>01108           *soli_ptr = ((*soli_ptr) * psi - x) * omega;
<a name="l01109"></a>01109         }
<a name="l01110"></a>01110       <span class="keywordflow">else</span>
<a name="l01111"></a>01111         {
<a name="l01112"></a>01112           assert((*soli_ptr) == 0.);
<a name="l01113"></a>01113           coeff_ptr -= nvois;
<a name="l01114"></a>01114           tab2_ptr -= nvois;
<a name="l01115"></a>01115         }
<a name="l01116"></a>01116     }
<a name="l01117"></a>01117 }
<a name="l01118"></a>01118 
<a name="l01119"></a><a class="code" href="SSOR_8cpp.html#a92f28012f2a840b61326fc5a649b8735">01119</a> <span class="keywordtype">void</span> <a class="code" href="SSOR_8cpp.html#ac6165a9a7d7601cae69f7b343d02499d">descente_precond_diag</a>(<span class="keyword">const</span> <span class="keywordtype">double</span> omega, <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; tab1, <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; tab2, <span class="keyword">const</span> <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a>&amp; <a class="code" href="Champ__P1iP1B__implementation_8cpp.html#aa8c8f49390c3cf7c702d71a71bc977e3">coeff</a>,
<a name="l01120"></a>01120                            <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; vecteur
<a name="l01121"></a>01121                            , <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; items_a_traiter
<a name="l01122"></a>01122                           )
<a name="l01123"></a>01123 {
<a name="l01124"></a>01124   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_lignes_a_traiter = vecteur.<a class="code" href="classDoubleVect.html#aafef4b3a96cdc428d62c5cedc9af6112">size_reelle_ok</a>() ? vecteur.<a class="code" href="classDoubleVect.html#a4a6987db458541cdcd10495955f25263" title="Taille de l&#39;espace &quot;reel&quot; du vecteur. (si md_vector_ est nul, cette valeur est identique a size_arr...">size_reelle</a>() : vecteur.<a class="code" href="classDoubleVect.html#ad2d21b364e1c6559771970596a25c006" title="Identique a size_array()">size_totale</a>();
<a name="l01125"></a>01125 <span class="comment">// pointeur &quot;fortran&quot; vers le tableau solution (indexable avec index fortran)</span>
<a name="l01126"></a>01126 <span class="comment">// le pointeur est constant, pas le tableau pointe.</span>
<a name="l01127"></a>01127   <span class="keywordtype">double</span> * <span class="keyword">const</span> sol_fortran = vecteur.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() - 1;
<a name="l01128"></a>01128   <span class="keyword">const</span> <span class="keywordtype">int</span> *flags_ptr = items_a_traiter.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
<a name="l01129"></a>01129   assert(nb_lignes_a_traiter &lt;= items_a_traiter.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>());
<a name="l01130"></a>01130   <span class="keyword">const</span> <span class="keywordtype">int</span> *tab1_ptr = tab1.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
<a name="l01131"></a>01131   assert(nb_lignes_a_traiter &lt;= tab1.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() + 1);
<a name="l01132"></a>01132   assert(*tab1_ptr == 1); <span class="comment">//!&lt; sinon 2 lignes ci-dessous fausses.</span>
<a name="l01133"></a>01133 <span class="comment"></span>  <span class="keyword">const</span> <span class="keywordtype">int</span> *tab2_ptr = tab2.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
<a name="l01134"></a>01134   <span class="keyword">const</span> <span class="keywordtype">double</span> *coeff_ptr = coeff.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
<a name="l01135"></a>01135   <span class="keywordtype">int</span> last_tab1_de_i = *tab1_ptr;
<a name="l01136"></a>01136   tab1_ptr++;
<a name="l01137"></a>01137   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 1; i &lt;= nb_lignes_a_traiter; i++, tab1_ptr++)
<a name="l01138"></a>01138     {
<a name="l01139"></a>01139       <span class="keyword">const</span> <span class="keywordtype">int</span> tab1_de_i = *tab1_ptr; <span class="comment">//!&lt; = tab1[i]</span>
<a name="l01140"></a>01140 <span class="comment"></span>      <span class="keyword">const</span> <span class="keywordtype">int</span> nvois = tab1_de_i - last_tab1_de_i;
<a name="l01141"></a>01141       <span class="keyword">static_cast&lt;</span><span class="keywordtype">void</span><span class="keyword">&gt;</span> (0);
<a name="l01142"></a>01142       last_tab1_de_i = tab1_de_i;
<a name="l01143"></a>01143 <span class="comment">// Ce test doit rester, sinon on pollue les autres lignes du vecteur sol</span>
<a name="l01144"></a>01144 <span class="comment">// avec des valeurs dependant des items communs et virtuels</span>
<a name="l01145"></a>01145       <span class="keyword">static_cast&lt;</span><span class="keywordtype">void</span><span class="keyword">&gt;</span> (0);
<a name="l01146"></a>01146       <span class="keyword">const</span> <span class="keywordtype">int</span> item_a_traiter = *(flags_ptr++);
<a name="l01147"></a>01147       <span class="keywordflow">if</span> (item_a_traiter)
<a name="l01148"></a>01148         {
<a name="l01149"></a>01149 <span class="comment">// Pas de coefficient diagonal stocke (ni dans tab2 ni dans coeff), la diagonale vaut 1:</span>
<a name="l01150"></a>01150           <span class="keyword">const</span> <span class="keywordtype">double</span> v_i = sol_fortran[i] *= omega;
<a name="l01151"></a>01151           <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = nvois-1; j; j--, tab2_ptr++, coeff_ptr++)
<a name="l01152"></a>01152             {
<a name="l01153"></a>01153               <span class="keyword">const</span> <span class="keywordtype">int</span> i2 = *tab2_ptr; <span class="comment">//!&lt; indice de colonne pour le prochain coefficient</span>
<a name="l01154"></a>01154 <span class="comment"></span>              <span class="keyword">const</span> <span class="keywordtype">double</span> coeff_i_i2 = *coeff_ptr;
<a name="l01155"></a>01155 <span class="comment">// la matrice n&#39;a que des coeffs diagonaux superieurs et on a deja traite</span>
<a name="l01156"></a>01156 <span class="comment">// la diagonale, donc i2 &gt; i.</span>
<a name="l01157"></a>01157               <span class="keyword">static_cast&lt;</span><span class="keywordtype">void</span><span class="keyword">&gt;</span> (0);
<a name="l01158"></a>01158 <span class="comment">// B.M.: ... en revanche, le test sur les items communs est superflu ici car</span>
<a name="l01159"></a>01159 <span class="comment">// la valeur sera annulee (voir **Annulation items communs**),</span>
<a name="l01160"></a>01160 <span class="comment">// gain de perfs si on ne fait pas le test</span>
<a name="l01161"></a>01161               sol_fortran[i2] -= coeff_i_i2 * v_i;
<a name="l01162"></a>01162             }
<a name="l01163"></a>01163         }
<a name="l01164"></a>01164       <span class="keywordflow">else</span>
<a name="l01165"></a>01165         {
<a name="l01166"></a>01166 <span class="comment">// **Annulation items communs**</span>
<a name="l01167"></a>01167 <span class="comment">// c&#39;est la derniere fois qu&#39;on ecrit dans sol_fortran[i] car la</span>
<a name="l01168"></a>01168 <span class="comment">// matrice est diagonale superieure. Pour eviter le test sur items_a_traiter_</span>
<a name="l01169"></a>01169 <span class="comment">// dans la remontee, on annule la solution pour les items communs et virtuels</span>
<a name="l01170"></a>01170 <span class="comment">// (sol_fortran[i] ne sera plus modifie ensuite dans la descente)</span>
<a name="l01171"></a>01171           sol_fortran[i] = 0.;
<a name="l01172"></a>01172           coeff_ptr += nvois;
<a name="l01173"></a>01173           tab2_ptr += nvois;
<a name="l01174"></a>01174         }
<a name="l01175"></a>01175     }
<a name="l01176"></a>01176 <span class="comment">// **Annulation items communs**</span>
<a name="l01177"></a>01177 <span class="comment">// Pour la remontee il faut annuler les valeurs dans les cases virtuelles</span>
<a name="l01178"></a>01178   {
<a name="l01179"></a>01179     <span class="keyword">const</span> <span class="keywordtype">int</span> fin = vecteur.<a class="code" href="classDoubleVect.html#ad2d21b364e1c6559771970596a25c006" title="Identique a size_array()">size_totale</a>();
<a name="l01180"></a>01180     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = nb_lignes_a_traiter+1; i &lt;= fin; i++)
<a name="l01181"></a>01181       sol_fortran[i] = 0.;
<a name="l01182"></a>01182   }
<a name="l01183"></a>01183 }
<a name="l01184"></a>01184 
<a name="l01185"></a>01185 
<a name="l01186"></a><a class="code" href="SSOR_8cpp.html#a902ef62d765177f316b5b8460d0f1a8a">01186</a> <span class="keywordtype">void</span> <a class="code" href="SSOR_8cpp.html#aa011041d08feeec86cfb569445fd565d">remontee_precond_diag</a>(<span class="keyword">const</span> <span class="keywordtype">double</span> omega, <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; tab1, <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; tab2, <span class="keyword">const</span> <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a>&amp; <a class="code" href="Champ__P1iP1B__implementation_8cpp.html#aa8c8f49390c3cf7c702d71a71bc977e3">coeff</a>,
<a name="l01187"></a>01187                            <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; vecteur
<a name="l01188"></a>01188                            , <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; items_a_traiter
<a name="l01189"></a>01189                           )
<a name="l01190"></a>01190 {
<a name="l01191"></a>01191   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_lignes_a_traiter = vecteur.<a class="code" href="classDoubleVect.html#aafef4b3a96cdc428d62c5cedc9af6112">size_reelle_ok</a>() ? vecteur.<a class="code" href="classDoubleVect.html#a4a6987db458541cdcd10495955f25263" title="Taille de l&#39;espace &quot;reel&quot; du vecteur. (si md_vector_ est nul, cette valeur est identique a size_arr...">size_reelle</a>() : vecteur.<a class="code" href="classDoubleVect.html#ad2d21b364e1c6559771970596a25c006" title="Identique a size_array()">size_totale</a>();
<a name="l01192"></a>01192   <span class="keyword">const</span> <span class="keywordtype">int</span> *flags_ptr = items_a_traiter.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() + nb_lignes_a_traiter - 1;
<a name="l01193"></a>01193   assert(nb_lignes_a_traiter &lt;= items_a_traiter.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>());
<a name="l01194"></a>01194   <span class="keyword">const</span> <span class="keywordtype">double</span> psi = (2. - omega) / omega;
<a name="l01195"></a>01195 
<a name="l01196"></a>01196 <span class="comment">// pointeur &quot;fortran&quot; vers le tableau solution (indexable avec index fortran)</span>
<a name="l01197"></a>01197   <span class="keyword">const</span> <span class="keywordtype">double</span> * <span class="keyword">const</span> sol_fortran = vecteur.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() - 1;
<a name="l01198"></a>01198   <span class="keyword">const</span> <span class="keywordtype">int</span> *tab1_ptr = tab1.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() + nb_lignes_a_traiter;
<a name="l01199"></a>01199   <span class="keywordtype">int</span> last_tab1_de_i = *tab1_ptr;
<a name="l01200"></a>01200   tab1_ptr--;
<a name="l01201"></a>01201 <span class="comment">// On ne va pas a la fin de tab2 car on n&#39;est pas sur que nb_lignes_a_traiter = tab1.size_array() :</span>
<a name="l01202"></a>01202 <span class="comment">// -2 car last_tab1_de_i est l&#39;indice du premier coefficient de la ligne suivante en fortran</span>
<a name="l01203"></a>01203 <span class="comment">// (dont -1 pour fortran-&gt;c et -1 pour passer au dernier coeff de la ligne precedente)</span>
<a name="l01204"></a>01204   <span class="keyword">const</span> <span class="keywordtype">int</span> *tab2_ptr = tab2.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() + last_tab1_de_i - 2;
<a name="l01205"></a>01205   <span class="keyword">const</span> <span class="keywordtype">double</span> *coeff_ptr = coeff.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() + last_tab1_de_i - 2;
<a name="l01206"></a>01206   <span class="keywordtype">double</span> * soli_ptr = vecteur.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() + nb_lignes_a_traiter - 1;
<a name="l01207"></a>01207   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = nb_lignes_a_traiter; i; i--, tab1_ptr--, soli_ptr--)
<a name="l01208"></a>01208     {
<a name="l01209"></a>01209       <span class="keyword">const</span> <span class="keywordtype">int</span> tab1_de_i = *tab1_ptr; <span class="comment">//!&lt; = tab1[i]</span>
<a name="l01210"></a>01210 <span class="comment"></span>      <span class="keyword">const</span> <span class="keywordtype">int</span> nvois = last_tab1_de_i - tab1_de_i;
<a name="l01211"></a>01211       <span class="keyword">static_cast&lt;</span><span class="keywordtype">void</span><span class="keyword">&gt;</span> (0);
<a name="l01212"></a>01212       last_tab1_de_i = tab1_de_i;
<a name="l01213"></a>01213 <span class="comment">// Ce test doit rester car il ne faut pas modifier sol[i] pour les items communs</span>
<a name="l01214"></a>01214 <span class="comment">// et virtuels (ils sont nuls et doivent le rester pour ne pas polluer les autres lignes):</span>
<a name="l01215"></a>01215       <span class="keywordflow">if</span> (*(flags_ptr--))
<a name="l01216"></a>01216         {
<a name="l01217"></a>01217 <span class="comment">// Operation &quot;diagonale&quot;:</span>
<a name="l01218"></a>01218           <span class="keywordtype">double</span> x = 0.;
<a name="l01219"></a>01219           <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = nvois-1; j; j--, tab2_ptr--, coeff_ptr--)
<a name="l01220"></a>01220             {
<a name="l01221"></a>01221               <span class="keyword">const</span> <span class="keywordtype">int</span> i2 = *tab2_ptr;
<a name="l01222"></a>01222               <span class="keyword">const</span> <span class="keywordtype">double</span> coeff_i_i2 = *coeff_ptr;
<a name="l01223"></a>01223 <span class="comment">// Operation nulle pour les items communs et virtuels</span>
<a name="l01224"></a>01224 <span class="comment">// (on a annule le second membre lors de la descente)</span>
<a name="l01225"></a>01225               x += coeff_i_i2 * sol_fortran[i2];
<a name="l01226"></a>01226             }
<a name="l01227"></a>01227 <span class="comment">// Preconditionnement diagonal, pas de coefficient diagonal stocke:</span>
<a name="l01228"></a>01228           *soli_ptr = ((*soli_ptr) * psi - x) * omega;
<a name="l01229"></a>01229         }
<a name="l01230"></a>01230       <span class="keywordflow">else</span>
<a name="l01231"></a>01231         {
<a name="l01232"></a>01232           assert((*soli_ptr) == 0.);
<a name="l01233"></a>01233           coeff_ptr -= nvois;
<a name="l01234"></a>01234           tab2_ptr -= nvois;
<a name="l01235"></a>01235         }
<a name="l01236"></a>01236     }
<a name="l01237"></a>01237 }
<a name="l01238"></a>01238 
<a name="l01239"></a><a class="code" href="SSOR_8cpp.html#a341f4b46910ca2435d75af01fbe161bc">01239</a> <span class="keywordtype">void</span> <a class="code" href="SSOR_8cpp.html#a341f4b46910ca2435d75af01fbe161bc">descente_assert_precond_diag</a>(<span class="keyword">const</span> <span class="keywordtype">double</span> omega, <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; tab1, <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; tab2, <span class="keyword">const</span> <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a>&amp; <a class="code" href="Champ__P1iP1B__implementation_8cpp.html#aa8c8f49390c3cf7c702d71a71bc977e3">coeff</a>,
<a name="l01240"></a>01240                                   <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; vecteur
<a name="l01241"></a>01241                                  )
<a name="l01242"></a>01242 {
<a name="l01243"></a>01243   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_lignes_a_traiter = vecteur.<a class="code" href="classDoubleVect.html#aafef4b3a96cdc428d62c5cedc9af6112">size_reelle_ok</a>() ? vecteur.<a class="code" href="classDoubleVect.html#a4a6987db458541cdcd10495955f25263" title="Taille de l&#39;espace &quot;reel&quot; du vecteur. (si md_vector_ est nul, cette valeur est identique a size_arr...">size_reelle</a>() : vecteur.<a class="code" href="classDoubleVect.html#ad2d21b364e1c6559771970596a25c006" title="Identique a size_array()">size_totale</a>();
<a name="l01244"></a>01244 <span class="comment">// pointeur &quot;fortran&quot; vers le tableau solution (indexable avec index fortran)</span>
<a name="l01245"></a>01245 <span class="comment">// le pointeur est constant, pas le tableau pointe.</span>
<a name="l01246"></a>01246   <span class="keywordtype">double</span> * <span class="keyword">const</span> sol_fortran = vecteur.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() - 1;
<a name="l01247"></a>01247   <span class="keyword">const</span> <span class="keywordtype">int</span> *tab1_ptr = tab1.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
<a name="l01248"></a>01248   assert(nb_lignes_a_traiter &lt;= tab1.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() + 1);
<a name="l01249"></a>01249   assert(*tab1_ptr == 1); <span class="comment">//!&lt; sinon 2 lignes ci-dessous fausses.</span>
<a name="l01250"></a>01250 <span class="comment"></span>  <span class="keyword">const</span> <span class="keywordtype">int</span> *tab2_ptr = tab2.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
<a name="l01251"></a>01251   <span class="keyword">const</span> <span class="keywordtype">double</span> *coeff_ptr = coeff.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
<a name="l01252"></a>01252   <span class="keywordtype">int</span> last_tab1_de_i = *tab1_ptr;
<a name="l01253"></a>01253   tab1_ptr++;
<a name="l01254"></a>01254   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 1; i &lt;= nb_lignes_a_traiter; i++, tab1_ptr++)
<a name="l01255"></a>01255     {
<a name="l01256"></a>01256       <span class="keyword">const</span> <span class="keywordtype">int</span> tab1_de_i = *tab1_ptr; <span class="comment">//!&lt; = tab1[i]</span>
<a name="l01257"></a>01257 <span class="comment"></span>      <span class="keyword">const</span> <span class="keywordtype">int</span> nvois = tab1_de_i - last_tab1_de_i;
<a name="l01258"></a>01258       assert(nvois &gt;= 0 &amp;&amp; (tab1_de_i - 1) &lt;= tab2.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>());
<a name="l01259"></a>01259       last_tab1_de_i = tab1_de_i;
<a name="l01260"></a>01260 <span class="comment">// Ce test doit rester, sinon on pollue les autres lignes du vecteur sol</span>
<a name="l01261"></a>01261 <span class="comment">// avec des valeurs dependant des items communs et virtuels</span>
<a name="l01262"></a>01262       {
<a name="l01263"></a>01263 <span class="comment">// Pas de coefficient diagonal stocke (ni dans tab2 ni dans coeff), la diagonale vaut 1:</span>
<a name="l01264"></a>01264         <span class="keyword">const</span> <span class="keywordtype">double</span> v_i = sol_fortran[i] *= omega;
<a name="l01265"></a>01265         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = nvois-1; j; j--, tab2_ptr++, coeff_ptr++)
<a name="l01266"></a>01266           {
<a name="l01267"></a>01267             <span class="keyword">const</span> <span class="keywordtype">int</span> i2 = *tab2_ptr; <span class="comment">//!&lt; indice de colonne pour le prochain coefficient</span>
<a name="l01268"></a>01268 <span class="comment"></span>            <span class="keyword">const</span> <span class="keywordtype">double</span> coeff_i_i2 = *coeff_ptr;
<a name="l01269"></a>01269 <span class="comment">// la matrice n&#39;a que des coeffs diagonaux superieurs et on a deja traite</span>
<a name="l01270"></a>01270 <span class="comment">// la diagonale, donc i2 &gt; i.</span>
<a name="l01271"></a>01271 <span class="comment">// Pas d&#39;items virtuels autorises !</span>
<a name="l01272"></a>01272             assert(i2 &gt; i &amp;&amp; i2 &lt;= nb_lignes_a_traiter);
<a name="l01273"></a>01273 <span class="comment">// B.M.: ... en revanche, le test sur les items communs est superflu ici car</span>
<a name="l01274"></a>01274 <span class="comment">// la valeur sera annulee (voir **Annulation items communs**),</span>
<a name="l01275"></a>01275 <span class="comment">// gain de perfs si on ne fait pas le test</span>
<a name="l01276"></a>01276             sol_fortran[i2] -= coeff_i_i2 * v_i;
<a name="l01277"></a>01277           }
<a name="l01278"></a>01278       }
<a name="l01279"></a>01279     }
<a name="l01280"></a>01280 }
<a name="l01281"></a>01281 
<a name="l01282"></a>01282 
<a name="l01283"></a><a class="code" href="SSOR_8cpp.html#a38be26171881a415291350c94e94c644">01283</a> <span class="keywordtype">void</span> <a class="code" href="SSOR_8cpp.html#a38be26171881a415291350c94e94c644">remontee_assert_precond_diag</a>(<span class="keyword">const</span> <span class="keywordtype">double</span> omega, <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; tab1, <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; tab2, <span class="keyword">const</span> <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a>&amp; <a class="code" href="Champ__P1iP1B__implementation_8cpp.html#aa8c8f49390c3cf7c702d71a71bc977e3">coeff</a>,
<a name="l01284"></a>01284                                   <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; vecteur
<a name="l01285"></a>01285                                  )
<a name="l01286"></a>01286 {
<a name="l01287"></a>01287   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_lignes_a_traiter = vecteur.<a class="code" href="classDoubleVect.html#aafef4b3a96cdc428d62c5cedc9af6112">size_reelle_ok</a>() ? vecteur.<a class="code" href="classDoubleVect.html#a4a6987db458541cdcd10495955f25263" title="Taille de l&#39;espace &quot;reel&quot; du vecteur. (si md_vector_ est nul, cette valeur est identique a size_arr...">size_reelle</a>() : vecteur.<a class="code" href="classDoubleVect.html#ad2d21b364e1c6559771970596a25c006" title="Identique a size_array()">size_totale</a>();
<a name="l01288"></a>01288   <span class="keyword">const</span> <span class="keywordtype">double</span> psi = (2. - omega) / omega;
<a name="l01289"></a>01289 
<a name="l01290"></a>01290 <span class="comment">// pointeur &quot;fortran&quot; vers le tableau solution (indexable avec index fortran)</span>
<a name="l01291"></a>01291   <span class="keyword">const</span> <span class="keywordtype">double</span> * <span class="keyword">const</span> sol_fortran = vecteur.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() - 1;
<a name="l01292"></a>01292   <span class="keyword">const</span> <span class="keywordtype">int</span> *tab1_ptr = tab1.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() + nb_lignes_a_traiter;
<a name="l01293"></a>01293   <span class="keywordtype">int</span> last_tab1_de_i = *tab1_ptr;
<a name="l01294"></a>01294   tab1_ptr--;
<a name="l01295"></a>01295 <span class="comment">// On ne va pas a la fin de tab2 car on n&#39;est pas sur que nb_lignes_a_traiter = tab1.size_array() :</span>
<a name="l01296"></a>01296 <span class="comment">// -2 car last_tab1_de_i est l&#39;indice du premier coefficient de la ligne suivante en fortran</span>
<a name="l01297"></a>01297 <span class="comment">// (dont -1 pour fortran-&gt;c et -1 pour passer au dernier coeff de la ligne precedente)</span>
<a name="l01298"></a>01298   <span class="keyword">const</span> <span class="keywordtype">int</span> *tab2_ptr = tab2.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() + last_tab1_de_i - 2;
<a name="l01299"></a>01299   <span class="keyword">const</span> <span class="keywordtype">double</span> *coeff_ptr = coeff.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() + last_tab1_de_i - 2;
<a name="l01300"></a>01300   <span class="keywordtype">double</span> * soli_ptr = vecteur.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() + nb_lignes_a_traiter - 1;
<a name="l01301"></a>01301   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = nb_lignes_a_traiter; i; i--, tab1_ptr--, soli_ptr--)
<a name="l01302"></a>01302     {
<a name="l01303"></a>01303       <span class="keyword">const</span> <span class="keywordtype">int</span> tab1_de_i = *tab1_ptr; <span class="comment">//!&lt; = tab1[i]</span>
<a name="l01304"></a>01304 <span class="comment"></span>      <span class="keyword">const</span> <span class="keywordtype">int</span> nvois = last_tab1_de_i - tab1_de_i;
<a name="l01305"></a>01305       assert(nvois &gt;= 0 &amp;&amp; tab1_de_i &gt; 0);
<a name="l01306"></a>01306       last_tab1_de_i = tab1_de_i;
<a name="l01307"></a>01307 <span class="comment">// Ce test doit rester car il ne faut pas modifier sol[i] pour les items communs</span>
<a name="l01308"></a>01308 <span class="comment">// et virtuels (ils sont nuls et doivent le rester pour ne pas polluer les autres lignes):</span>
<a name="l01309"></a>01309       <span class="keywordflow">if</span> (1)
<a name="l01310"></a>01310         {
<a name="l01311"></a>01311 <span class="comment">// Operation &quot;diagonale&quot;:</span>
<a name="l01312"></a>01312           <span class="keywordtype">double</span> x = 0.;
<a name="l01313"></a>01313           <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = nvois-1; j; j--, tab2_ptr--, coeff_ptr--)
<a name="l01314"></a>01314             {
<a name="l01315"></a>01315               <span class="keyword">const</span> <span class="keywordtype">int</span> i2 = *tab2_ptr;
<a name="l01316"></a>01316               <span class="keyword">const</span> <span class="keywordtype">double</span> coeff_i_i2 = *coeff_ptr;
<a name="l01317"></a>01317 <span class="comment">// Operation nulle pour les items communs et virtuels</span>
<a name="l01318"></a>01318 <span class="comment">// (on a annule le second membre lors de la descente)</span>
<a name="l01319"></a>01319               x += coeff_i_i2 * sol_fortran[i2];
<a name="l01320"></a>01320             }
<a name="l01321"></a>01321 <span class="comment">// Preconditionnement diagonal, pas de coefficient diagonal stocke:</span>
<a name="l01322"></a>01322           *soli_ptr = ((*soli_ptr) * psi - x) * omega;
<a name="l01323"></a>01323         }
<a name="l01324"></a>01324       <span class="keywordflow">else</span>
<a name="l01325"></a>01325         {
<a name="l01326"></a>01326           assert((*soli_ptr) == 0.);
<a name="l01327"></a>01327           coeff_ptr -= nvois;
<a name="l01328"></a>01328           tab2_ptr -= nvois;
<a name="l01329"></a>01329         }
<a name="l01330"></a>01330     }
<a name="l01331"></a>01331 }
<a name="l01332"></a>01332 
<a name="l01333"></a><a class="code" href="SSOR_8cpp.html#ac6db7a57565b08f88196e93da2bcd53e">01333</a> <span class="keywordtype">void</span> <a class="code" href="SSOR_8cpp.html#a341f4b46910ca2435d75af01fbe161bc">descente_assert_precond_diag</a>(<span class="keyword">const</span> <span class="keywordtype">double</span> omega, <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; tab1, <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; tab2, <span class="keyword">const</span> <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a>&amp; <a class="code" href="Champ__P1iP1B__implementation_8cpp.html#aa8c8f49390c3cf7c702d71a71bc977e3">coeff</a>,
<a name="l01334"></a>01334                                   <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; vecteur
<a name="l01335"></a>01335                                   , <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; items_a_traiter
<a name="l01336"></a>01336                                  )
<a name="l01337"></a>01337 {
<a name="l01338"></a>01338   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_lignes_a_traiter = vecteur.<a class="code" href="classDoubleVect.html#aafef4b3a96cdc428d62c5cedc9af6112">size_reelle_ok</a>() ? vecteur.<a class="code" href="classDoubleVect.html#a4a6987db458541cdcd10495955f25263" title="Taille de l&#39;espace &quot;reel&quot; du vecteur. (si md_vector_ est nul, cette valeur est identique a size_arr...">size_reelle</a>() : vecteur.<a class="code" href="classDoubleVect.html#ad2d21b364e1c6559771970596a25c006" title="Identique a size_array()">size_totale</a>();
<a name="l01339"></a>01339 <span class="comment">// pointeur &quot;fortran&quot; vers le tableau solution (indexable avec index fortran)</span>
<a name="l01340"></a>01340 <span class="comment">// le pointeur est constant, pas le tableau pointe.</span>
<a name="l01341"></a>01341   <span class="keywordtype">double</span> * <span class="keyword">const</span> sol_fortran = vecteur.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() - 1;
<a name="l01342"></a>01342   <span class="keyword">const</span> <span class="keywordtype">int</span> *flags_ptr = items_a_traiter.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
<a name="l01343"></a>01343   assert(nb_lignes_a_traiter &lt;= items_a_traiter.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>());
<a name="l01344"></a>01344   <span class="keyword">const</span> <span class="keywordtype">int</span> *tab1_ptr = tab1.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
<a name="l01345"></a>01345   assert(nb_lignes_a_traiter &lt;= tab1.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() + 1);
<a name="l01346"></a>01346   assert(*tab1_ptr == 1); <span class="comment">//!&lt; sinon 2 lignes ci-dessous fausses.</span>
<a name="l01347"></a>01347 <span class="comment"></span>  <span class="keyword">const</span> <span class="keywordtype">int</span> *tab2_ptr = tab2.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
<a name="l01348"></a>01348   <span class="keyword">const</span> <span class="keywordtype">double</span> *coeff_ptr = coeff.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
<a name="l01349"></a>01349   <span class="keywordtype">int</span> last_tab1_de_i = *tab1_ptr;
<a name="l01350"></a>01350   tab1_ptr++;
<a name="l01351"></a>01351   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 1; i &lt;= nb_lignes_a_traiter; i++, tab1_ptr++)
<a name="l01352"></a>01352     {
<a name="l01353"></a>01353       <span class="keyword">const</span> <span class="keywordtype">int</span> tab1_de_i = *tab1_ptr; <span class="comment">//!&lt; = tab1[i]</span>
<a name="l01354"></a>01354 <span class="comment"></span>      <span class="keyword">const</span> <span class="keywordtype">int</span> nvois = tab1_de_i - last_tab1_de_i;
<a name="l01355"></a>01355       assert(nvois &gt;= 0 &amp;&amp; (tab1_de_i - 1) &lt;= tab2.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>());
<a name="l01356"></a>01356       last_tab1_de_i = tab1_de_i;
<a name="l01357"></a>01357 <span class="comment">// Ce test doit rester, sinon on pollue les autres lignes du vecteur sol</span>
<a name="l01358"></a>01358 <span class="comment">// avec des valeurs dependant des items communs et virtuels</span>
<a name="l01359"></a>01359       assert((flags_ptr - items_a_traiter.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>()) == (i-1));
<a name="l01360"></a>01360       <span class="keyword">const</span> <span class="keywordtype">int</span> item_a_traiter = *(flags_ptr++);
<a name="l01361"></a>01361       <span class="keywordflow">if</span> (item_a_traiter)
<a name="l01362"></a>01362         {
<a name="l01363"></a>01363 <span class="comment">// Pas de coefficient diagonal stocke (ni dans tab2 ni dans coeff), la diagonale vaut 1:</span>
<a name="l01364"></a>01364           <span class="keyword">const</span> <span class="keywordtype">double</span> v_i = sol_fortran[i] *= omega;
<a name="l01365"></a>01365           <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = nvois-1; j; j--, tab2_ptr++, coeff_ptr++)
<a name="l01366"></a>01366             {
<a name="l01367"></a>01367               <span class="keyword">const</span> <span class="keywordtype">int</span> i2 = *tab2_ptr; <span class="comment">//!&lt; indice de colonne pour le prochain coefficient</span>
<a name="l01368"></a>01368 <span class="comment"></span>              <span class="keyword">const</span> <span class="keywordtype">double</span> coeff_i_i2 = *coeff_ptr;
<a name="l01369"></a>01369 <span class="comment">// la matrice n&#39;a que des coeffs diagonaux superieurs et on a deja traite</span>
<a name="l01370"></a>01370 <span class="comment">// la diagonale, donc i2 &gt; i.</span>
<a name="l01371"></a>01371               assert(i2 &gt; i &amp;&amp; i2 &lt;= vecteur.<a class="code" href="classDoubleVect.html#ad2d21b364e1c6559771970596a25c006" title="Identique a size_array()">size_totale</a>());
<a name="l01372"></a>01372 <span class="comment">// B.M.: ... en revanche, le test sur les items communs est superflu ici car</span>
<a name="l01373"></a>01373 <span class="comment">// la valeur sera annulee (voir **Annulation items communs**),</span>
<a name="l01374"></a>01374 <span class="comment">// gain de perfs si on ne fait pas le test</span>
<a name="l01375"></a>01375               sol_fortran[i2] -= coeff_i_i2 * v_i;
<a name="l01376"></a>01376             }
<a name="l01377"></a>01377         }
<a name="l01378"></a>01378       <span class="keywordflow">else</span>
<a name="l01379"></a>01379         {
<a name="l01380"></a>01380 <span class="comment">// **Annulation items communs**</span>
<a name="l01381"></a>01381 <span class="comment">// c&#39;est la derniere fois qu&#39;on ecrit dans sol_fortran[i] car la</span>
<a name="l01382"></a>01382 <span class="comment">// matrice est diagonale superieure. Pour eviter le test sur items_a_traiter_</span>
<a name="l01383"></a>01383 <span class="comment">// dans la remontee, on annule la solution pour les items communs et virtuels</span>
<a name="l01384"></a>01384 <span class="comment">// (sol_fortran[i] ne sera plus modifie ensuite dans la descente)</span>
<a name="l01385"></a>01385           sol_fortran[i] = 0.;
<a name="l01386"></a>01386           coeff_ptr += nvois;
<a name="l01387"></a>01387           tab2_ptr += nvois;
<a name="l01388"></a>01388         }
<a name="l01389"></a>01389     }
<a name="l01390"></a>01390 <span class="comment">// **Annulation items communs**</span>
<a name="l01391"></a>01391 <span class="comment">// Pour la remontee il faut annuler les valeurs dans les cases virtuelles</span>
<a name="l01392"></a>01392   {
<a name="l01393"></a>01393     <span class="keyword">const</span> <span class="keywordtype">int</span> fin = vecteur.<a class="code" href="classDoubleVect.html#ad2d21b364e1c6559771970596a25c006" title="Identique a size_array()">size_totale</a>();
<a name="l01394"></a>01394     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = nb_lignes_a_traiter+1; i &lt;= fin; i++)
<a name="l01395"></a>01395       sol_fortran[i] = 0.;
<a name="l01396"></a>01396   }
<a name="l01397"></a>01397 }
<a name="l01398"></a>01398 
<a name="l01399"></a>01399 
<a name="l01400"></a><a class="code" href="SSOR_8cpp.html#ac9677ce4fb57e5aa0e3bc8452650b815">01400</a> <span class="keywordtype">void</span> <a class="code" href="SSOR_8cpp.html#a38be26171881a415291350c94e94c644">remontee_assert_precond_diag</a>(<span class="keyword">const</span> <span class="keywordtype">double</span> omega, <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; tab1, <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; tab2, <span class="keyword">const</span> <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a>&amp; <a class="code" href="Champ__P1iP1B__implementation_8cpp.html#aa8c8f49390c3cf7c702d71a71bc977e3">coeff</a>,
<a name="l01401"></a>01401                                   <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; vecteur
<a name="l01402"></a>01402                                   , <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; items_a_traiter
<a name="l01403"></a>01403                                  )
<a name="l01404"></a>01404 {
<a name="l01405"></a>01405   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_lignes_a_traiter = vecteur.<a class="code" href="classDoubleVect.html#aafef4b3a96cdc428d62c5cedc9af6112">size_reelle_ok</a>() ? vecteur.<a class="code" href="classDoubleVect.html#a4a6987db458541cdcd10495955f25263" title="Taille de l&#39;espace &quot;reel&quot; du vecteur. (si md_vector_ est nul, cette valeur est identique a size_arr...">size_reelle</a>() : vecteur.<a class="code" href="classDoubleVect.html#ad2d21b364e1c6559771970596a25c006" title="Identique a size_array()">size_totale</a>();
<a name="l01406"></a>01406   <span class="keyword">const</span> <span class="keywordtype">int</span> *flags_ptr = items_a_traiter.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() + nb_lignes_a_traiter - 1;
<a name="l01407"></a>01407   assert(nb_lignes_a_traiter &lt;= items_a_traiter.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>());
<a name="l01408"></a>01408   <span class="keyword">const</span> <span class="keywordtype">double</span> psi = (2. - omega) / omega;
<a name="l01409"></a>01409 
<a name="l01410"></a>01410 <span class="comment">// pointeur &quot;fortran&quot; vers le tableau solution (indexable avec index fortran)</span>
<a name="l01411"></a>01411   <span class="keyword">const</span> <span class="keywordtype">double</span> * <span class="keyword">const</span> sol_fortran = vecteur.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() - 1;
<a name="l01412"></a>01412   <span class="keyword">const</span> <span class="keywordtype">int</span> *tab1_ptr = tab1.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() + nb_lignes_a_traiter;
<a name="l01413"></a>01413   <span class="keywordtype">int</span> last_tab1_de_i = *tab1_ptr;
<a name="l01414"></a>01414   tab1_ptr--;
<a name="l01415"></a>01415 <span class="comment">// On ne va pas a la fin de tab2 car on n&#39;est pas sur que nb_lignes_a_traiter = tab1.size_array() :</span>
<a name="l01416"></a>01416 <span class="comment">// -2 car last_tab1_de_i est l&#39;indice du premier coefficient de la ligne suivante en fortran</span>
<a name="l01417"></a>01417 <span class="comment">// (dont -1 pour fortran-&gt;c et -1 pour passer au dernier coeff de la ligne precedente)</span>
<a name="l01418"></a>01418   <span class="keyword">const</span> <span class="keywordtype">int</span> *tab2_ptr = tab2.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() + last_tab1_de_i - 2;
<a name="l01419"></a>01419   <span class="keyword">const</span> <span class="keywordtype">double</span> *coeff_ptr = coeff.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() + last_tab1_de_i - 2;
<a name="l01420"></a>01420   <span class="keywordtype">double</span> * soli_ptr = vecteur.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() + nb_lignes_a_traiter - 1;
<a name="l01421"></a>01421   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = nb_lignes_a_traiter; i; i--, tab1_ptr--, soli_ptr--)
<a name="l01422"></a>01422     {
<a name="l01423"></a>01423       <span class="keyword">const</span> <span class="keywordtype">int</span> tab1_de_i = *tab1_ptr; <span class="comment">//!&lt; = tab1[i]</span>
<a name="l01424"></a>01424 <span class="comment"></span>      <span class="keyword">const</span> <span class="keywordtype">int</span> nvois = last_tab1_de_i - tab1_de_i;
<a name="l01425"></a>01425       assert(nvois &gt;= 0 &amp;&amp; tab1_de_i &gt; 0);
<a name="l01426"></a>01426       last_tab1_de_i = tab1_de_i;
<a name="l01427"></a>01427 <span class="comment">// Ce test doit rester car il ne faut pas modifier sol[i] pour les items communs</span>
<a name="l01428"></a>01428 <span class="comment">// et virtuels (ils sont nuls et doivent le rester pour ne pas polluer les autres lignes):</span>
<a name="l01429"></a>01429       <span class="keywordflow">if</span> (*(flags_ptr--))
<a name="l01430"></a>01430         {
<a name="l01431"></a>01431 <span class="comment">// Operation &quot;diagonale&quot;:</span>
<a name="l01432"></a>01432           <span class="keywordtype">double</span> x = 0.;
<a name="l01433"></a>01433           <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = nvois-1; j; j--, tab2_ptr--, coeff_ptr--)
<a name="l01434"></a>01434             {
<a name="l01435"></a>01435               <span class="keyword">const</span> <span class="keywordtype">int</span> i2 = *tab2_ptr;
<a name="l01436"></a>01436               <span class="keyword">const</span> <span class="keywordtype">double</span> coeff_i_i2 = *coeff_ptr;
<a name="l01437"></a>01437 <span class="comment">// Operation nulle pour les items communs et virtuels</span>
<a name="l01438"></a>01438 <span class="comment">// (on a annule le second membre lors de la descente)</span>
<a name="l01439"></a>01439               x += coeff_i_i2 * sol_fortran[i2];
<a name="l01440"></a>01440             }
<a name="l01441"></a>01441 <span class="comment">// Preconditionnement diagonal, pas de coefficient diagonal stocke:</span>
<a name="l01442"></a>01442           *soli_ptr = ((*soli_ptr) * psi - x) * omega;
<a name="l01443"></a>01443         }
<a name="l01444"></a>01444       <span class="keywordflow">else</span>
<a name="l01445"></a>01445         {
<a name="l01446"></a>01446           assert((*soli_ptr) == 0.);
<a name="l01447"></a>01447           coeff_ptr -= nvois;
<a name="l01448"></a>01448           tab2_ptr -= nvois;
<a name="l01449"></a>01449         }
<a name="l01450"></a>01450     }
<a name="l01451"></a>01451 }
<a name="l01452"></a>01452 
<a name="l01453"></a>01453 
<a name="l01454"></a>01454 
<a name="l01455"></a>01455 <span class="comment">// On calcule solution = inverse(C)*b avec:</span>
<a name="l01456"></a>01456 <span class="comment">// inverse(C) = inverse((1/w D - E)) * (2-w/w D) * inverse((1/wD -E)t)</span>
<a name="l01457"></a>01457 <span class="comment">// D :partie diagonale de la matrice</span>
<a name="l01458"></a>01458 <span class="comment">// E :partie triangulaire inferieure de la matrice</span>
<a name="l01459"></a><a class="code" href="classSSOR.html#a92a21f1643fbe5ee8fcb25096f59722c">01459</a> <span class="keywordtype">void</span> <a class="code" href="classSSOR.html#a92a21f1643fbe5ee8fcb25096f59722c">SSOR::ssor</a>(<span class="keyword">const</span> <a class="code" href="classMatrice__Morse__Sym.html" title="Classe Matrice_Morse_Sym Represente une matrice M (creuse) symetrique stockee au format Morse Symetri...">Matrice_Morse_Sym</a>&amp; matrice, <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; solution)
<a name="l01460"></a>01460 {
<a name="l01461"></a>01461   <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; tab1 = matrice.<a class="code" href="classMatrice__Morse.html#a79b4e334152850bd36e53478debf3061">get_tab1</a>();
<a name="l01462"></a>01462   <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; tab2 = matrice.<a class="code" href="classMatrice__Morse.html#a787b5a63f27063f9c891243d8f188cda">get_tab2</a>();
<a name="l01463"></a>01463   <span class="keyword">const</span> <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a>&amp; <a class="code" href="Champ__P1iP1B__implementation_8cpp.html#aa8c8f49390c3cf7c702d71a71bc977e3">coeff</a> = matrice.<a class="code" href="classMatrice__Morse.html#aacb80dd518dcc0812e3b34edac6ab67e">get_coeff</a>();
<a name="l01464"></a>01464 
<a name="l01465"></a>01465   <span class="keywordflow">if</span> (tab2.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() &gt; 0 &amp;&amp; tab2[0] == 1)
<a name="l01466"></a>01466     {
<a name="l01467"></a>01467 <span class="comment">// La diagonale est presente dans la matrice</span>
<a name="l01468"></a>01468       <span class="keywordflow">if</span> (<a class="code" href="classSSOR.html#aa3cf956c10714ac36505c46e59d1b9dd">avec_assert_</a>)
<a name="l01469"></a>01469         {
<a name="l01470"></a>01470           <span class="keywordflow">if</span> (<a class="code" href="classSSOR.html#a60510dc39661fe9e59c4abf218702cf0">algo_items_communs_</a>)
<a name="l01471"></a>01471             {
<a name="l01472"></a>01472               <a class="code" href="SSOR_8cpp.html#a678783cb16d22aa5fdf95ee27a476764">descente_assert</a>(<a class="code" href="classSSOR.html#abcfe9ade190627842b923d8bb78eec38">omega_</a>, tab1, tab2, coeff, solution, <a class="code" href="classSSOR.html#af396301be15d933e2cf1b55cf65a2420">items_a_traiter_</a>);
<a name="l01473"></a>01473               <a class="code" href="SSOR_8cpp.html#adfde91562afac839dcf9442dcfd3d507">remontee_assert</a>(<a class="code" href="classSSOR.html#abcfe9ade190627842b923d8bb78eec38">omega_</a>, tab1, tab2, coeff, solution, <a class="code" href="classSSOR.html#af396301be15d933e2cf1b55cf65a2420">items_a_traiter_</a>);
<a name="l01474"></a>01474             }
<a name="l01475"></a>01475           <span class="keywordflow">else</span>
<a name="l01476"></a>01476             {
<a name="l01477"></a>01477               <a class="code" href="SSOR_8cpp.html#a678783cb16d22aa5fdf95ee27a476764">descente_assert</a>(<a class="code" href="classSSOR.html#abcfe9ade190627842b923d8bb78eec38">omega_</a>, tab1, tab2, coeff, solution);
<a name="l01478"></a>01478               <a class="code" href="SSOR_8cpp.html#adfde91562afac839dcf9442dcfd3d507">remontee_assert</a>(<a class="code" href="classSSOR.html#abcfe9ade190627842b923d8bb78eec38">omega_</a>, tab1, tab2, coeff, solution);
<a name="l01479"></a>01479             }
<a name="l01480"></a>01480         }
<a name="l01481"></a>01481       <span class="keywordflow">else</span>
<a name="l01482"></a>01482         {
<a name="l01483"></a>01483           <span class="keywordflow">if</span> (<a class="code" href="classSSOR.html#a60510dc39661fe9e59c4abf218702cf0">algo_items_communs_</a>)
<a name="l01484"></a>01484             {
<a name="l01485"></a>01485               <a class="code" href="SSOR_8cpp.html#a48c1a6c6f0d5c6cf939af4ddab0a7ba1">descente</a>(<a class="code" href="classSSOR.html#abcfe9ade190627842b923d8bb78eec38">omega_</a>, tab1, tab2, coeff, solution, <a class="code" href="classSSOR.html#af396301be15d933e2cf1b55cf65a2420">items_a_traiter_</a>);
<a name="l01486"></a>01486               <a class="code" href="SSOR_8cpp.html#aa3e5b9c2942469b29c8e8f874897bbe1">remontee</a>(<a class="code" href="classSSOR.html#abcfe9ade190627842b923d8bb78eec38">omega_</a>, tab1, tab2, coeff, solution, <a class="code" href="classSSOR.html#af396301be15d933e2cf1b55cf65a2420">items_a_traiter_</a>);
<a name="l01487"></a>01487             }
<a name="l01488"></a>01488           <span class="keywordflow">else</span>
<a name="l01489"></a>01489             {
<a name="l01490"></a>01490               <a class="code" href="SSOR_8cpp.html#a48c1a6c6f0d5c6cf939af4ddab0a7ba1">descente</a>(<a class="code" href="classSSOR.html#abcfe9ade190627842b923d8bb78eec38">omega_</a>, tab1, tab2, coeff, solution);
<a name="l01491"></a>01491               <a class="code" href="SSOR_8cpp.html#aa3e5b9c2942469b29c8e8f874897bbe1">remontee</a>(<a class="code" href="classSSOR.html#abcfe9ade190627842b923d8bb78eec38">omega_</a>, tab1, tab2, coeff, solution);
<a name="l01492"></a>01492             }
<a name="l01493"></a>01493         }
<a name="l01494"></a>01494     }
<a name="l01495"></a>01495   <span class="keywordflow">else</span>
<a name="l01496"></a>01496     {
<a name="l01497"></a>01497 <span class="comment">// Pas de diagonale stockee, on suppose qu&#39;on a que des 1 sur la diagonale</span>
<a name="l01498"></a>01498 <span class="comment">// (preconditionnement diagonal)</span>
<a name="l01499"></a>01499       <span class="keywordflow">if</span> (<a class="code" href="classSSOR.html#aa3cf956c10714ac36505c46e59d1b9dd">avec_assert_</a>)
<a name="l01500"></a>01500         {
<a name="l01501"></a>01501           <span class="keywordflow">if</span> (<a class="code" href="classSSOR.html#a60510dc39661fe9e59c4abf218702cf0">algo_items_communs_</a>)
<a name="l01502"></a>01502             {
<a name="l01503"></a>01503               <a class="code" href="SSOR_8cpp.html#a341f4b46910ca2435d75af01fbe161bc">descente_assert_precond_diag</a>(<a class="code" href="classSSOR.html#abcfe9ade190627842b923d8bb78eec38">omega_</a>, tab1, tab2, coeff, solution, <a class="code" href="classSSOR.html#af396301be15d933e2cf1b55cf65a2420">items_a_traiter_</a>);
<a name="l01504"></a>01504               <a class="code" href="SSOR_8cpp.html#a38be26171881a415291350c94e94c644">remontee_assert_precond_diag</a>(<a class="code" href="classSSOR.html#abcfe9ade190627842b923d8bb78eec38">omega_</a>, tab1, tab2, coeff, solution, <a class="code" href="classSSOR.html#af396301be15d933e2cf1b55cf65a2420">items_a_traiter_</a>);
<a name="l01505"></a>01505             }
<a name="l01506"></a>01506           <span class="keywordflow">else</span>
<a name="l01507"></a>01507             {
<a name="l01508"></a>01508               <a class="code" href="SSOR_8cpp.html#a341f4b46910ca2435d75af01fbe161bc">descente_assert_precond_diag</a>(<a class="code" href="classSSOR.html#abcfe9ade190627842b923d8bb78eec38">omega_</a>, tab1, tab2, coeff, solution);
<a name="l01509"></a>01509               <a class="code" href="SSOR_8cpp.html#a38be26171881a415291350c94e94c644">remontee_assert_precond_diag</a>(<a class="code" href="classSSOR.html#abcfe9ade190627842b923d8bb78eec38">omega_</a>, tab1, tab2, coeff, solution);
<a name="l01510"></a>01510             }
<a name="l01511"></a>01511         }
<a name="l01512"></a>01512       <span class="keywordflow">else</span>
<a name="l01513"></a>01513         {
<a name="l01514"></a>01514           <span class="keywordflow">if</span> (<a class="code" href="classSSOR.html#a60510dc39661fe9e59c4abf218702cf0">algo_items_communs_</a>)
<a name="l01515"></a>01515             {
<a name="l01516"></a>01516               <a class="code" href="SSOR_8cpp.html#ac6165a9a7d7601cae69f7b343d02499d">descente_precond_diag</a>(<a class="code" href="classSSOR.html#abcfe9ade190627842b923d8bb78eec38">omega_</a>, tab1, tab2, coeff, solution, <a class="code" href="classSSOR.html#af396301be15d933e2cf1b55cf65a2420">items_a_traiter_</a>);
<a name="l01517"></a>01517               <a class="code" href="SSOR_8cpp.html#aa011041d08feeec86cfb569445fd565d">remontee_precond_diag</a>(<a class="code" href="classSSOR.html#abcfe9ade190627842b923d8bb78eec38">omega_</a>, tab1, tab2, coeff, solution, <a class="code" href="classSSOR.html#af396301be15d933e2cf1b55cf65a2420">items_a_traiter_</a>);
<a name="l01518"></a>01518             }
<a name="l01519"></a>01519           <span class="keywordflow">else</span>
<a name="l01520"></a>01520             {
<a name="l01521"></a>01521               <a class="code" href="SSOR_8cpp.html#ac6165a9a7d7601cae69f7b343d02499d">descente_precond_diag</a>(<a class="code" href="classSSOR.html#abcfe9ade190627842b923d8bb78eec38">omega_</a>, tab1, tab2, coeff, solution);
<a name="l01522"></a>01522               <a class="code" href="SSOR_8cpp.html#aa011041d08feeec86cfb569445fd565d">remontee_precond_diag</a>(<a class="code" href="classSSOR.html#abcfe9ade190627842b923d8bb78eec38">omega_</a>, tab1, tab2, coeff, solution);
<a name="l01523"></a>01523             }
<a name="l01524"></a>01524         }
<a name="l01525"></a>01525     }
<a name="l01526"></a>01526 <span class="comment">// Ne pas reverifier au prochain preconditionnement...</span>
<a name="l01527"></a>01527   <a class="code" href="classSSOR.html#aa3cf956c10714ac36505c46e59d1b9dd">avec_assert_</a> = 0;
<a name="l01528"></a>01528 }
<a name="l01529"></a>01529 
<a name="l01530"></a><a class="code" href="classSSOR.html#a47b7e45b8539a69595e212d3f68d021e">01530</a> <span class="keywordtype">void</span> <a class="code" href="classSSOR.html#a92a21f1643fbe5ee8fcb25096f59722c">SSOR::ssor</a>(<span class="keyword">const</span> <a class="code" href="classMatrice__Bloc__Sym.html">Matrice_Bloc_Sym</a>&amp; matrice, <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; solution)
<a name="l01531"></a>01531 {
<a name="l01532"></a>01532   <a class="code" href="classDoubleTab__parts.html">DoubleTab_parts</a> s_parts(solution);
<a name="l01533"></a>01533   <a class="code" href="classConstIntTab__parts.html">ConstIntTab_parts</a> items_parts;
<a name="l01534"></a>01534   <span class="keywordflow">if</span> (<a class="code" href="classSSOR.html#a60510dc39661fe9e59c4abf218702cf0">algo_items_communs_</a>)
<a name="l01535"></a>01535     items_parts.<a class="code" href="classConstIntTab__parts.html#a51f3b8c6db831ceb2c838f1dbfc2266d">initialize</a>(<a class="code" href="classSSOR.html#af396301be15d933e2cf1b55cf65a2420">items_a_traiter_</a>);
<a name="l01536"></a>01536   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_parts = s_parts.<a class="code" href="classDoubleTab__parts.html#a7c4973f30f4557048ef5b80aaec4fb2f">size</a>();
<a name="l01537"></a>01537   assert(s_parts.<a class="code" href="classDoubleTab__parts.html#a7c4973f30f4557048ef5b80aaec4fb2f">size</a>() == nb_parts);
<a name="l01538"></a>01538   assert(matrice.<a class="code" href="classMatrice__Bloc.html#a02193255787b0ecae7988ca4eada3b4b" title="retourne N_">nb_bloc_lignes</a>() == nb_parts);
<a name="l01539"></a>01539 
<a name="l01540"></a>01540 <span class="comment">// Descente</span>
<a name="l01541"></a>01541   <span class="keywordtype">int</span> i_part;
<a name="l01542"></a>01542   <span class="keywordflow">for</span> (i_part = 0; i_part &lt; nb_parts; i_part++)
<a name="l01543"></a>01543     {
<a name="l01544"></a>01544       <span class="keyword">const</span> <a class="code" href="classMatrice__Bloc.html">Matrice_Bloc</a>&amp; matrice0 = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Bloc.html">Matrice_Bloc</a>, matrice.<a class="code" href="classMatrice__Bloc__Sym.html#a1002ce880ea2b2fb48dae444097c9f7a" title="(0&lt;=i&lt;N , i&lt;=j&lt;M)">get_bloc</a>(i_part, i_part).<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>());
<a name="l01545"></a>01545       <span class="keyword">const</span> <a class="code" href="classMatrice__Morse__Sym.html" title="Classe Matrice_Morse_Sym Represente une matrice M (creuse) symetrique stockee au format Morse Symetri...">Matrice_Morse_Sym</a>&amp; MB00 = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Morse__Sym.html" title="Classe Matrice_Morse_Sym Represente une matrice M (creuse) symetrique stockee au format Morse Symetri...">Matrice_Morse_Sym</a>, matrice0.<a class="code" href="classMatrice__Bloc.html#a7ffa38f7b93454432b2df7c616ed0a4e">get_bloc</a>(0,0).<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>());
<a name="l01546"></a>01546       <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; partie = s_parts[i_part];
<a name="l01547"></a>01547       <span class="keywordflow">if</span> (<a class="code" href="classSSOR.html#a60510dc39661fe9e59c4abf218702cf0">algo_items_communs_</a>)
<a name="l01548"></a>01548         <a class="code" href="SSOR_8cpp.html#aed227e1ac9fa7cd2e15bcc6187422067">descente_diag_ok_assert</a>(<a class="code" href="classSSOR.html#abcfe9ade190627842b923d8bb78eec38">omega_</a>, MB00.get_tab1(), MB00.get_tab2(), MB00.get_coeff(), partie, items_parts[i_part]);
<a name="l01549"></a>01549       <span class="keywordflow">else</span>
<a name="l01550"></a>01550         <a class="code" href="SSOR_8cpp.html#aed227e1ac9fa7cd2e15bcc6187422067">descente_diag_ok_assert</a>(<a class="code" href="classSSOR.html#abcfe9ade190627842b923d8bb78eec38">omega_</a>, MB00.get_tab1(), MB00.get_tab2(), MB00.get_coeff(), partie);
<a name="l01551"></a>01551 
<a name="l01552"></a>01552 <span class="comment">// blocs extra-diagonaux</span>
<a name="l01553"></a>01553       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j_part = i_part+1; j_part &lt; nb_parts; j_part++)
<a name="l01554"></a>01554         {
<a name="l01555"></a>01555           <span class="keyword">const</span> <a class="code" href="classMatrice__Bloc.html">Matrice_Bloc</a>&amp; Aij = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Bloc.html">Matrice_Bloc</a>, matrice.<a class="code" href="classMatrice__Bloc__Sym.html#a1002ce880ea2b2fb48dae444097c9f7a" title="(0&lt;=i&lt;N , i&lt;=j&lt;M)">get_bloc</a>(i_part,j_part).<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>());
<a name="l01556"></a>01556           <span class="keyword">const</span> <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; MB00bis = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>, Aij.<a class="code" href="classMatrice__Bloc.html#a7ffa38f7b93454432b2df7c616ed0a4e">get_bloc</a>(0,0).<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>());
<a name="l01557"></a>01557           <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; partie_j = s_parts[j_part];
<a name="l01558"></a>01558 <span class="comment">// Attention: le test sur les items communs concerne les lignes de la matrice, pas</span>
<a name="l01559"></a>01559 <span class="comment">// les colonnes (on passe items_parts[i_part], pas j_part)</span>
<a name="l01560"></a>01560 <span class="comment">// (note BM: je crois que la version precedente etait buggee mais ca ne s&#39;est pas vu</span>
<a name="l01561"></a>01561 <span class="comment">// parce que la matrice elem-elem arrive en premier et qu&#39;il n&#39;y a pas d&#39;items communs sur les elements)</span>
<a name="l01562"></a>01562           <span class="keywordflow">if</span> (<a class="code" href="classSSOR.html#a60510dc39661fe9e59c4abf218702cf0">algo_items_communs_</a>)
<a name="l01563"></a>01563             <a class="code" href="SSOR_8cpp.html#abe7caa2af06f2228eeb87613b49fa72e">descente_bloc_extradiag_assert</a>(MB00bis.get_tab1(), MB00bis.get_tab2(), MB00bis.get_coeff(), partie, partie_j, items_parts[i_part]);
<a name="l01564"></a>01564           <span class="keywordflow">else</span>
<a name="l01565"></a>01565             <a class="code" href="SSOR_8cpp.html#abe7caa2af06f2228eeb87613b49fa72e">descente_bloc_extradiag_assert</a>(MB00bis.get_tab1(), MB00bis.get_tab2(), MB00bis.get_coeff(), partie, partie_j);
<a name="l01566"></a>01566         }
<a name="l01567"></a>01567     }
<a name="l01568"></a>01568 <span class="comment">// Traitement de la diagonale</span>
<a name="l01569"></a>01569   <span class="keywordflow">for</span> (i_part = 0; i_part &lt; nb_parts; i_part++)
<a name="l01570"></a>01570     {
<a name="l01571"></a>01571       <span class="keyword">const</span> <a class="code" href="classMatrice__Bloc.html">Matrice_Bloc</a>&amp; matrice0 = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Bloc.html">Matrice_Bloc</a>, matrice.<a class="code" href="classMatrice__Bloc__Sym.html#a1002ce880ea2b2fb48dae444097c9f7a" title="(0&lt;=i&lt;N , i&lt;=j&lt;M)">get_bloc</a>(i_part, i_part).<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>());
<a name="l01572"></a>01572       <span class="keyword">const</span> <a class="code" href="classMatrice__Morse__Sym.html" title="Classe Matrice_Morse_Sym Represente une matrice M (creuse) symetrique stockee au format Morse Symetri...">Matrice_Morse_Sym</a>&amp; MB00 = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Morse__Sym.html" title="Classe Matrice_Morse_Sym Represente une matrice M (creuse) symetrique stockee au format Morse Symetri...">Matrice_Morse_Sym</a>, matrice0.<a class="code" href="classMatrice__Bloc.html#a7ffa38f7b93454432b2df7c616ed0a4e">get_bloc</a>(0,0).<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>());
<a name="l01573"></a>01573       <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; partie = s_parts[i_part];
<a name="l01574"></a>01574       <a class="code" href="SSOR_8cpp.html#a83a12abf0d3d0650563cba68e988b4fd">traite_diagonale</a>(<a class="code" href="classSSOR.html#abcfe9ade190627842b923d8bb78eec38">omega_</a>, MB00.get_tab1(), MB00.get_tab2(), MB00.get_coeff(), partie);
<a name="l01575"></a>01575     }
<a name="l01576"></a>01576 
<a name="l01577"></a>01577 <span class="comment">// Remontee</span>
<a name="l01578"></a>01578   <span class="keywordflow">for</span> (i_part = nb_parts - 1; i_part &gt;= 0; i_part--)
<a name="l01579"></a>01579     {
<a name="l01580"></a>01580       <span class="keyword">const</span> <a class="code" href="classMatrice__Bloc.html">Matrice_Bloc</a>&amp; matrice0 = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Bloc.html">Matrice_Bloc</a>, matrice.<a class="code" href="classMatrice__Bloc__Sym.html#a1002ce880ea2b2fb48dae444097c9f7a" title="(0&lt;=i&lt;N , i&lt;=j&lt;M)">get_bloc</a>(i_part, i_part).<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>());
<a name="l01581"></a>01581       <span class="keyword">const</span> <a class="code" href="classMatrice__Morse__Sym.html" title="Classe Matrice_Morse_Sym Represente une matrice M (creuse) symetrique stockee au format Morse Symetri...">Matrice_Morse_Sym</a>&amp; MB00bis = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Morse__Sym.html" title="Classe Matrice_Morse_Sym Represente une matrice M (creuse) symetrique stockee au format Morse Symetri...">Matrice_Morse_Sym</a>, matrice0.<a class="code" href="classMatrice__Bloc.html#a7ffa38f7b93454432b2df7c616ed0a4e">get_bloc</a>(0,0).<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>());
<a name="l01582"></a>01582       <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; partie = s_parts[i_part];
<a name="l01583"></a>01583       <span class="keywordflow">if</span> (<a class="code" href="classSSOR.html#a60510dc39661fe9e59c4abf218702cf0">algo_items_communs_</a>)
<a name="l01584"></a>01584         <a class="code" href="SSOR_8cpp.html#a3d6a3eb26f76575031f1283cd7a0daa6">remontee_diag_ok_assert</a>(<a class="code" href="classSSOR.html#abcfe9ade190627842b923d8bb78eec38">omega_</a>, MB00bis.get_tab1(), MB00bis.get_tab2(), MB00bis.get_coeff(), partie, items_parts[i_part]);
<a name="l01585"></a>01585       <span class="keywordflow">else</span>
<a name="l01586"></a>01586         <a class="code" href="SSOR_8cpp.html#a3d6a3eb26f76575031f1283cd7a0daa6">remontee_diag_ok_assert</a>(<a class="code" href="classSSOR.html#abcfe9ade190627842b923d8bb78eec38">omega_</a>, MB00bis.get_tab1(), MB00bis.get_tab2(), MB00bis.get_coeff(), partie);
<a name="l01587"></a>01587 <span class="comment">// Blocs extra-diagonaux (parcours horizontal au lieu de vertical)</span>
<a name="l01588"></a>01588       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j_part = 0; j_part &lt; i_part; j_part++)
<a name="l01589"></a>01589         {
<a name="l01590"></a>01590           <span class="keyword">const</span> <a class="code" href="classMatrice__Bloc.html">Matrice_Bloc</a>&amp; Aij = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Bloc.html">Matrice_Bloc</a>, matrice.<a class="code" href="classMatrice__Bloc__Sym.html#a1002ce880ea2b2fb48dae444097c9f7a" title="(0&lt;=i&lt;N , i&lt;=j&lt;M)">get_bloc</a>(j_part,i_part).<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>());
<a name="l01591"></a>01591           <span class="keyword">const</span> <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; MB00 = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>, Aij.<a class="code" href="classMatrice__Bloc.html#a7ffa38f7b93454432b2df7c616ed0a4e">get_bloc</a>(0,0).<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>());
<a name="l01592"></a>01592           <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; partie_j = s_parts[j_part];
<a name="l01593"></a>01593 <span class="comment">// Attention: le test sur les items communs concerne les lignes de la matrice, pas</span>
<a name="l01594"></a>01594 <span class="comment">// les colonnes (on passe items_parts[i_part], pas j_part)</span>
<a name="l01595"></a>01595           <span class="keywordflow">if</span> (<a class="code" href="classSSOR.html#a60510dc39661fe9e59c4abf218702cf0">algo_items_communs_</a>)
<a name="l01596"></a>01596             <a class="code" href="SSOR_8cpp.html#a5600e796c5a19cf31272da290b9933d6">remontee_bloc_extradiag_assert</a>(MB00.get_tab1(), MB00.get_tab2(), MB00.get_coeff(), partie_j, partie, items_parts[j_part]);
<a name="l01597"></a>01597           <span class="keywordflow">else</span>
<a name="l01598"></a>01598             <a class="code" href="SSOR_8cpp.html#a5600e796c5a19cf31272da290b9933d6">remontee_bloc_extradiag_assert</a>(MB00.get_tab1(), MB00.get_tab2(), MB00.get_coeff(), partie_j, partie);
<a name="l01599"></a>01599         }
<a name="l01600"></a>01600     }
<a name="l01601"></a>01601 
<a name="l01602"></a>01602 }
<a name="l01603"></a>01603 
<a name="l01604"></a>01604 
<a name="l01605"></a>01605 
</pre></div></div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Tue Dec 14 2021 19:35:24 for TRUST by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
