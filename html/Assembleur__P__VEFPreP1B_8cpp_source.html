<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>TRUST: src/P1NCP1B/Solveurs/Assembleur_P_VEFPreP1B.cpp Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">TRUST&#160;<span id="projectnumber">1.8.4</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
<div class="header">
  <div class="headertitle">
<div class="title">src/P1NCP1B/Solveurs/Assembleur_P_VEFPreP1B.cpp</div>  </div>
</div>
<div class="contents">
<a href="Assembleur__P__VEFPreP1B_8cpp.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/****************************************************************************</span>
<a name="l00002"></a>00002 <span class="comment">* Copyright (c) 2020, CEA</span>
<a name="l00003"></a>00003 <span class="comment">* All rights reserved.</span>
<a name="l00004"></a>00004 <span class="comment">*</span>
<a name="l00005"></a>00005 <span class="comment">* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</span>
<a name="l00006"></a>00006 <span class="comment">* 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.</span>
<a name="l00007"></a>00007 <span class="comment">* 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.</span>
<a name="l00008"></a>00008 <span class="comment">* 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.</span>
<a name="l00009"></a>00009 <span class="comment">*</span>
<a name="l00010"></a>00010 <span class="comment">* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.</span>
<a name="l00011"></a>00011 <span class="comment">* IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;</span>
<a name="l00012"></a>00012 <span class="comment">* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>
<a name="l00013"></a>00013 <span class="comment">*</span>
<a name="l00014"></a>00014 <span class="comment">*****************************************************************************/</span>
<a name="l00015"></a>00015 <span class="comment">//</span>
<a name="l00016"></a>00016 <span class="comment">// </span>
<a name="l00017"></a>00017 <span class="comment">// File:        Assembleur_P_VEFPreP1B.cpp</span>
<a name="l00018"></a>00018 <span class="comment">// Directory:   $TRUST_ROOT/src/P1NCP1B/Solveurs</span>
<a name="l00019"></a>00019 <span class="comment">// Version:     /main/66</span>
<a name="l00020"></a>00020 <span class="comment">// </span>
<a name="l00021"></a>00021 <span class="comment">//</span>
<a name="l00022"></a>00022 
<a name="l00023"></a>00023 <span class="preprocessor">#include &lt;<a class="code" href="Assembleur__P__VEFPreP1B_8h.html">Assembleur_P_VEFPreP1B.h</a>&gt;</span>
<a name="l00024"></a>00024 <span class="preprocessor">#include &lt;<a class="code" href="Matrice__Bloc__Sym_8h.html">Matrice_Bloc_Sym.h</a>&gt;</span>
<a name="l00025"></a>00025 <span class="preprocessor">#include &lt;<a class="code" href="Domaine_8h.html">Domaine.h</a>&gt;</span>
<a name="l00026"></a>00026 <span class="preprocessor">#include &lt;<a class="code" href="Dirichlet_8h.html">Dirichlet.h</a>&gt;</span>
<a name="l00027"></a>00027 <span class="preprocessor">#include &lt;<a class="code" href="Dirichlet__homogene_8h.html">Dirichlet_homogene.h</a>&gt;</span>
<a name="l00028"></a>00028 <span class="preprocessor">#include &lt;<a class="code" href="Entree__fluide__vitesse__imposee_8h.html">Entree_fluide_vitesse_imposee.h</a>&gt;</span>
<a name="l00029"></a>00029 <span class="preprocessor">#include &lt;<a class="code" href="Neumann__sortie__libre_8h.html">Neumann_sortie_libre.h</a>&gt;</span>
<a name="l00030"></a>00030 <span class="preprocessor">#include &lt;<a class="code" href="LecFicDistribueBin_8h.html">LecFicDistribueBin.h</a>&gt;</span>
<a name="l00031"></a>00031 <span class="preprocessor">#include &lt;<a class="code" href="Champ__front__instationnaire__base_8h.html">Champ_front_instationnaire_base.h</a>&gt;</span>
<a name="l00032"></a>00032 <span class="preprocessor">#include &lt;<a class="code" href="Champ__front__var_8h.html">Champ_front_var.h</a>&gt;</span>
<a name="l00033"></a>00033 <span class="preprocessor">#include &lt;<a class="code" href="EcrFicCollecteBin_8h.html">EcrFicCollecteBin.h</a>&gt;</span>
<a name="l00034"></a>00034 <span class="preprocessor">#include &lt;<a class="code" href="Milieu__base_8h.html">Milieu_base.h</a>&gt;</span>
<a name="l00035"></a>00035 <span class="preprocessor">#include &lt;<a class="code" href="Navier__Stokes__std_8h.html">Navier_Stokes_std.h</a>&gt;</span>
<a name="l00036"></a>00036 <span class="preprocessor">#include &lt;<a class="code" href="Debog_8h.html">Debog.h</a>&gt;</span>
<a name="l00037"></a>00037 <span class="preprocessor">#include &lt;<a class="code" href="IntLists_8h.html">IntLists.h</a>&gt;</span>
<a name="l00038"></a>00038 <span class="preprocessor">#include &lt;<a class="code" href="Op__Grad__VEF__P1B__Face_8h.html">Op_Grad_VEF_P1B_Face.h</a>&gt;</span>
<a name="l00039"></a>00039 <span class="preprocessor">#include &lt;<a class="code" href="Op__Div__VEFP1B__Elem_8h.html">Op_Div_VEFP1B_Elem.h</a>&gt;</span>
<a name="l00040"></a>00040 <span class="preprocessor">#include &lt;<a class="code" href="SFichier_8h.html">SFichier.h</a>&gt;</span>
<a name="l00041"></a>00041 <span class="preprocessor">#include &lt;<a class="code" href="Champ__Fonc__P1NC_8h.html">Champ_Fonc_P1NC.h</a>&gt;</span>
<a name="l00042"></a>00042 <span class="preprocessor">#include &lt;<a class="code" href="SolveurPP1B_8h.html">SolveurPP1B.h</a>&gt;</span>
<a name="l00043"></a>00043 <span class="preprocessor">#include &lt;<a class="code" href="Scatter_8h.html">Scatter.h</a>&gt;</span>
<a name="l00044"></a>00044 <span class="preprocessor">#include &lt;<a class="code" href="Check__espace__virtuel_8h.html">Check_espace_virtuel.h</a>&gt;</span>
<a name="l00045"></a>00045 <span class="preprocessor">#include &lt;<a class="code" href="Champ__front__var__instationnaire_8h.html">Champ_front_var_instationnaire.h</a>&gt;</span>
<a name="l00046"></a>00046 <span class="preprocessor">#include &lt;<a class="code" href="Solv__Petsc_8h.html">Solv_Petsc.h</a>&gt;</span>
<a name="l00047"></a>00047 <span class="preprocessor">#include &lt;<a class="code" href="Matrice__Petsc_8h.html">Matrice_Petsc.h</a>&gt;</span>
<a name="l00048"></a>00048 
<a name="l00049"></a><a class="code" href="Assembleur__P__VEFPreP1B_8cpp.html#aae09693578a6a3e0fde3f6d35fe36da0">00049</a> <a class="code" href="Op__Diff__CoviMAC__Face_8cpp.html#aa86ec8ba612a969d9b4370b775037144">Implemente_instanciable</a>(<a class="code" href="classAssembleur__P__VEFPreP1B.html">Assembleur_P_VEFPreP1B</a>,<span class="stringliteral">&quot;Assembleur_P_VEFPreP1B&quot;</span>,<a class="code" href="classAssembleur__P__VEF.html">Assembleur_P_VEF</a>);
<a name="l00050"></a>00050 
<a name="l00051"></a>00051 <span class="comment">// printOn et readOn</span>
<a name="l00052"></a>00052 
<a name="l00053"></a><a class="code" href="classAssembleur__P__VEFPreP1B.html#abc6e9cb293d2b22bf8cc58714062aac2">00053</a> <a class="code" href="classSortie.html" title="Classe de base des flux de sortie. Elle sait ecrire des types simples&lt;br&gt;(entiers, flottants) et des Ob...">Sortie</a>&amp; <a class="code" href="classAssembleur__P__VEFPreP1B.html#abc6e9cb293d2b22bf8cc58714062aac2" title="Ecriture de l&#39;objet sur un flot de sortie Methode a surcharger.">Assembleur_P_VEFPreP1B::printOn</a>(<a class="code" href="classSortie.html" title="Classe de base des flux de sortie. Elle sait ecrire des types simples&lt;br&gt;(entiers, flottants) et des Ob...">Sortie</a>&amp; s )<span class="keyword"> const</span>
<a name="l00054"></a>00054 <span class="keyword"></span>{
<a name="l00055"></a>00055   <span class="keywordflow">return</span> <a class="code" href="classAssembleur__P__VEFPreP1B.html#abc6e9cb293d2b22bf8cc58714062aac2" title="Ecriture de l&#39;objet sur un flot de sortie Methode a surcharger.">Assembleur_base::printOn</a>(s);
<a name="l00056"></a>00056 }
<a name="l00057"></a>00057 
<a name="l00058"></a><a class="code" href="classAssembleur__P__VEFPreP1B.html#afbf05fd27ad04d93fc5396a8a9dd0bd7">00058</a> <a class="code" href="classEntree.html" title="Classe de definition des operateurs et methodes pour toute lecture dans un flot d&#39;entree (fichier...">Entree</a>&amp; <a class="code" href="classAssembleur__P__VEFPreP1B.html#afbf05fd27ad04d93fc5396a8a9dd0bd7" title="Lecture d&#39;un Objet_U sur un flot d&#39;entree Methode a surcharger.">Assembleur_P_VEFPreP1B::readOn</a>(<a class="code" href="classEntree.html" title="Classe de definition des operateurs et methodes pour toute lecture dans un flot d&#39;entree (fichier...">Entree</a>&amp; is )
<a name="l00059"></a>00059 {
<a name="l00060"></a>00060   <span class="keywordflow">return</span> <a class="code" href="classAssembleur__P__VEFPreP1B.html#afbf05fd27ad04d93fc5396a8a9dd0bd7" title="Lecture d&#39;un Objet_U sur un flot d&#39;entree Methode a surcharger.">Assembleur_base::readOn</a>(is);
<a name="l00061"></a>00061 }
<a name="l00062"></a>00062 
<a name="l00063"></a><a class="code" href="Assembleur__P__VEFPreP1B_8cpp.html#ad6ea924b20e311b70fc786906b53805b">00063</a> <span class="keyword">static</span> <span class="keywordtype">double</span> <a class="code" href="Assembleur__P__VEFPreP1B_8cpp.html#ad6ea924b20e311b70fc786906b53805b">estim_cond</a>(<a class="code" href="classMatrice.html">Matrice</a>&amp; A)
<a name="l00064"></a>00064 {
<a name="l00065"></a>00065   <span class="keywordtype">int</span> i=A.<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>( ).<a class="code" href="classMatrice__Base.html#a78420d19112a02c5808daa50151bbb09">nb_lignes</a>();
<a name="l00066"></a>00066 <span class="comment">// Cout &lt;&lt; &quot;rang &quot; &lt;&lt; i &lt;&lt; finl;</span>
<a name="l00067"></a>00067   <a class="code" href="classDoubleVect.html">DoubleVect</a> p(A.<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>( ).<a class="code" href="classMatrice__Base.html#a78420d19112a02c5808daa50151bbb09">nb_lignes</a>());
<a name="l00068"></a>00068   <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j=0; j&lt;i; j++)
<a name="l00069"></a>00069     p(j)=drand48();
<a name="l00070"></a>00070   <span class="keywordtype">double</span> normep=sqrt(<a class="code" href="DoubleVect_8cpp.html#a07d13cbdadca6b60d5e128653f52a4bb">mp_prodscal</a>(p,p));
<a name="l00071"></a>00071   p/=normep;
<a name="l00072"></a>00072   <a class="code" href="classDoubleVect.html">DoubleVect</a> r(A.<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>( ).<a class="code" href="classMatrice__Base.html#a78420d19112a02c5808daa50151bbb09">nb_lignes</a>());
<a name="l00073"></a>00073   <span class="keywordtype">double</span> lmax=1.e-36, lmin=1.e24;
<a name="l00074"></a>00074 <span class="comment">// double cond=-1;</span>
<a name="l00075"></a>00075   i=10000;
<a name="l00076"></a>00076   <span class="keywordflow">while</span>(i-- )
<a name="l00077"></a>00077     {
<a name="l00078"></a>00078 <span class="comment">// cond=lmax/lmin;</span>
<a name="l00079"></a>00079       A.<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>( ).<a class="code" href="classMatrice__Base.html#a05caa487a25a6d5e7fbd38d4b2f4ee1e" title="Multiplication d&#39;un vecteur par la matrice. Operation: r = A*x.">multvect</a>(p,r);
<a name="l00080"></a>00080       <span class="keywordtype">double</span> pscpr=<a class="code" href="DoubleVect_8cpp.html#a07d13cbdadca6b60d5e128653f52a4bb">mp_prodscal</a>(p,r);
<a name="l00081"></a>00081 <span class="comment">// Cout &lt;&lt; &quot;lambda &quot; &lt;&lt; i &lt;&lt; &quot; : &quot; &lt;&lt; pscpr &lt;&lt; &quot; , &quot; &lt;&lt; lmax/lmin &lt;&lt; finl;</span>
<a name="l00082"></a>00082       <span class="keywordtype">double</span> pscrr=<a class="code" href="DoubleVect_8cpp.html#a07d13cbdadca6b60d5e128653f52a4bb">mp_prodscal</a>(r,r);
<a name="l00083"></a>00083       <span class="keywordtype">double</span> epsilon=-pscpr/pscrr;
<a name="l00084"></a>00084       p.ajoute(epsilon,r);
<a name="l00085"></a>00085       <span class="keywordtype">double</span> normepbis=sqrt(<a class="code" href="DoubleVect_8cpp.html#a07d13cbdadca6b60d5e128653f52a4bb">mp_prodscal</a>(p,p));
<a name="l00086"></a>00086 <span class="comment">// Cout &lt;&lt; &quot;normep : &quot; &lt;&lt; normep &lt;&lt; finl;</span>
<a name="l00087"></a>00087       p/=normepbis;
<a name="l00088"></a>00088       <span class="keywordflow">if</span>(pscpr&gt;lmax)
<a name="l00089"></a>00089         lmax=pscpr;
<a name="l00090"></a>00090       <span class="keywordflow">else</span> <span class="keywordflow">if</span>(pscpr&lt;lmin)
<a name="l00091"></a>00091         lmin=pscpr;
<a name="l00092"></a>00092     }
<a name="l00093"></a>00093 <span class="comment">// Cout &lt;&lt; &quot;lmax &quot; &lt;&lt; lmax &lt;&lt; &quot; lmin = &quot; &lt;&lt; lmin &lt;&lt; finl;</span>
<a name="l00094"></a>00094 <span class="comment">// Cout &lt;&lt; p &lt;&lt; finl;</span>
<a name="l00095"></a>00095   <span class="keywordflow">if</span> (A.<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>( ).<a class="code" href="classMatrice__Base.html#a78420d19112a02c5808daa50151bbb09">nb_lignes</a>()&lt;30) A.<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>( ).<a class="code" href="classMatrice__Base.html#a2167f10f0e4efb71013a18aa44403f4e">imprimer_formatte</a>(<a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a>);
<a name="l00096"></a>00096 
<a name="l00097"></a>00097   <span class="keywordflow">return</span>(lmax/lmin);
<a name="l00098"></a>00098 }
<a name="l00099"></a>00099 
<a name="l00100"></a><a class="code" href="classAssembleur__P__VEFPreP1B.html#aeecf2e110cf38f394e6fb78fefb51f31">00100</a> <span class="keywordtype">void</span> <a class="code" href="classAssembleur__P__VEFPreP1B.html#aeecf2e110cf38f394e6fb78fefb51f31">Assembleur_P_VEFPreP1B::completer</a>(<span class="keyword">const</span> <a class="code" href="classEquation__base.html">Equation_base</a>&amp; eqn)
<a name="l00101"></a>00101 {
<a name="l00102"></a>00102   <a class="code" href="classAssembleur__P__VEFPreP1B.html#a75f504c4171787bdeb487a8dd98e2a00">mon_equation</a>=eqn;
<a name="l00103"></a>00103   <a class="code" href="classAssembleur__P__VEFPreP1B.html#aeecf2e110cf38f394e6fb78fefb51f31">Assembleur_P_VEF::completer</a>(eqn);
<a name="l00104"></a>00104 <span class="comment">// Initialisation de alpha, beta</span>
<a name="l00105"></a>00105   <a class="code" href="classAssembleur__P__VEFPreP1B.html#ae3dad2978525b28edcb08db30d0ce641">alpha</a>=0.;
<a name="l00106"></a>00106   <a class="code" href="classAssembleur__P__VEFPreP1B.html#a411ad82b856d17a1c8d942728a48f9a0" title="Coefficients du changement de base P0+P1&lt;-&gt;P1Bulle.">beta</a>=0.;
<a name="l00107"></a>00107   <span class="keywordflow">if</span> (<a class="code" href="classAssembleur__P__VEFPreP1B.html#a3b4a812a062b850be5966f8c6e201cee">zone_Vef</a>().get_P1Bulle())
<a name="l00108"></a>00108     {
<a name="l00109"></a>00109 <span class="comment">// Pour changer de base et retrouver le P1Bulle</span>
<a name="l00110"></a>00110       <a class="code" href="classAssembleur__P__VEFPreP1B.html#ae3dad2978525b28edcb08db30d0ce641">alpha</a>=1./<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>;
<a name="l00111"></a>00111       <a class="code" href="classAssembleur__P__VEFPreP1B.html#a411ad82b856d17a1c8d942728a48f9a0" title="Coefficients du changement de base P0+P1&lt;-&gt;P1Bulle.">beta</a>=1./(<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>*(<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>+1));
<a name="l00112"></a>00112     }
<a name="l00113"></a>00113   <a class="code" href="classAssembleur__P__VEFPreP1B.html#a5d22f81d5f579074de9324230e3ff45f" title="Matrice de travail.">la_matrice_de_travail_</a>.<a class="code" href="classDeriv__.html#ad1d33400ed15b6ff96579ed82d9e2719" title="Essaie de creer une instance du type &quot;type&quot;. si type n&#39;est pas un type ou type n&#39;est pas instanciab...">typer</a>(<span class="stringliteral">&quot;Matrice_Bloc_Sym&quot;</span>);
<a name="l00114"></a>00114 }
<a name="l00115"></a>00115 
<a name="l00116"></a><a class="code" href="classAssembleur__P__VEFPreP1B.html#a3b4a812a062b850be5966f8c6e201cee">00116</a> <span class="keyword">const</span> <a class="code" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a>&amp; <a class="code" href="classAssembleur__P__VEFPreP1B.html#a3b4a812a062b850be5966f8c6e201cee">Assembleur_P_VEFPreP1B::zone_Vef</a>()<span class="keyword"> const</span>
<a name="l00117"></a>00117 <span class="keyword"></span>{
<a name="l00118"></a>00118   <span class="keywordflow">return</span> <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a>, <a class="code" href="classAssembleur__P__VEF.html#ae16d976e530b6785006bf62384354ea7">la_zone_VEF</a>.<a class="code" href="classRef__Zone__VEF.html#aafd9a5ee1a76f290c9c6b5447b0c8d30">valeur</a>());
<a name="l00119"></a>00119 }
<a name="l00120"></a>00120 
<a name="l00121"></a>00121 <span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="Assembleur__P__VEFPreP1B_8cpp.html#a31e2d4bc38d5bc0bbf9e2c36d15b589b">assemblerP0P0</a>(<span class="keyword">const</span> <a class="code" href="classZone__dis__base.html" title="classe Zone_dis_base Cette classe est la base de la hierarchie des zones discretisees. Un objet Zone est associe a la zone discretise. A chaque methode numerique de Trio U correspond une classe derivant de Zone_dis_base implementant les outils necessaires a la methode.">Zone_dis_base</a>&amp; z,
<a name="l00122"></a>00122                           <span class="keyword">const</span> <a class="code" href="classZone__Cl__dis__base.html" title="classe Zone_Cl_dis_base Les objets Zone_Cl_dis_base representent les conditions aux limites discretis...">Zone_Cl_dis_base</a>&amp; zcl,
<a name="l00123"></a>00123                           <a class="code" href="classMatrice.html">Matrice</a>&amp; matrice,
<a name="l00124"></a>00124                           <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; inverse_quantitee_entrelacee);
<a name="l00125"></a>00125 
<a name="l00126"></a>00126 <span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="Assembleur__P__VEFPreP1B_8cpp.html#a31f132f3fda04d8428de212c63fd902f">assemblerP1P1</a>(<span class="keyword">const</span> <a class="code" href="classZone__dis__base.html" title="classe Zone_dis_base Cette classe est la base de la hierarchie des zones discretisees. Un objet Zone est associe a la zone discretise. A chaque methode numerique de Trio U correspond une classe derivant de Zone_dis_base implementant les outils necessaires a la methode.">Zone_dis_base</a>&amp; z,
<a name="l00127"></a>00127                           <span class="keyword">const</span> <a class="code" href="classZone__Cl__dis__base.html" title="classe Zone_Cl_dis_base Les objets Zone_Cl_dis_base representent les conditions aux limites discretis...">Zone_Cl_dis_base</a>&amp; zcl,
<a name="l00128"></a>00128                           <a class="code" href="classMatrice.html">Matrice</a>&amp; matrice,
<a name="l00129"></a>00129                           <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; inverse_quantitee_entrelacee, <span class="keyword">const</span> <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a>&amp; coef_som);
<a name="l00130"></a>00130 
<a name="l00131"></a>00131 <span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="Assembleur__P__VEFPreP1B_8cpp.html#a7840f924363ed7d3fbd50a59d9d990c0">assemblerPaPa</a>(<span class="keyword">const</span> <a class="code" href="classZone__dis__base.html" title="classe Zone_dis_base Cette classe est la base de la hierarchie des zones discretisees. Un objet Zone est associe a la zone discretise. A chaque methode numerique de Trio U correspond une classe derivant de Zone_dis_base implementant les outils necessaires a la methode.">Zone_dis_base</a>&amp; z,
<a name="l00132"></a>00132                           <span class="keyword">const</span> <a class="code" href="classZone__Cl__dis__base.html" title="classe Zone_Cl_dis_base Les objets Zone_Cl_dis_base representent les conditions aux limites discretis...">Zone_Cl_dis_base</a>&amp; zcl,
<a name="l00133"></a>00133                           <a class="code" href="classMatrice.html">Matrice</a>&amp; matrice, <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; inverse_quantitee_entrelacee);
<a name="l00134"></a>00134 
<a name="l00135"></a>00135 <span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="Assembleur__P__VEFPreP1B_8cpp.html#a3774b1608aeee56152e7e1e5f385bfe1">assemblerP0P1</a>(<span class="keyword">const</span> <a class="code" href="classZone__dis__base.html" title="classe Zone_dis_base Cette classe est la base de la hierarchie des zones discretisees. Un objet Zone est associe a la zone discretise. A chaque methode numerique de Trio U correspond une classe derivant de Zone_dis_base implementant les outils necessaires a la methode.">Zone_dis_base</a>&amp; z,
<a name="l00136"></a>00136                           <span class="keyword">const</span> <a class="code" href="classZone__Cl__dis__base.html" title="classe Zone_Cl_dis_base Les objets Zone_Cl_dis_base representent les conditions aux limites discretis...">Zone_Cl_dis_base</a>&amp; zcl,
<a name="l00137"></a>00137                           <a class="code" href="classMatrice.html">Matrice</a>&amp; matrice, <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; inverse_quantitee_entrelacee, <span class="keyword">const</span> <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a>&amp; coef_som);
<a name="l00138"></a>00138 
<a name="l00139"></a>00139 <span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="Assembleur__P__VEFPreP1B_8cpp.html#a30b5e404b46e2a239584ee19835c88bf">assemblerP0Pa</a>(<span class="keyword">const</span> <a class="code" href="classZone__dis__base.html" title="classe Zone_dis_base Cette classe est la base de la hierarchie des zones discretisees. Un objet Zone est associe a la zone discretise. A chaque methode numerique de Trio U correspond une classe derivant de Zone_dis_base implementant les outils necessaires a la methode.">Zone_dis_base</a>&amp; z,
<a name="l00140"></a>00140                           <span class="keyword">const</span> <a class="code" href="classZone__Cl__dis__base.html" title="classe Zone_Cl_dis_base Les objets Zone_Cl_dis_base representent les conditions aux limites discretis...">Zone_Cl_dis_base</a>&amp; zcl,
<a name="l00141"></a>00141                           <a class="code" href="classMatrice.html">Matrice</a>&amp; matrice,
<a name="l00142"></a>00142                           <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; inverse_quantitee_entrelacee);
<a name="l00143"></a>00143 
<a name="l00144"></a>00144 <span class="keyword">extern</span>  <span class="keywordtype">void</span> <a class="code" href="Assembleur__P__VEFPreP1B_8cpp.html#a5dcfee4400f896bcbb100259f53a5de1">assemblerP1Pa</a>(<span class="keyword">const</span> <a class="code" href="classZone__dis__base.html" title="classe Zone_dis_base Cette classe est la base de la hierarchie des zones discretisees. Un objet Zone est associe a la zone discretise. A chaque methode numerique de Trio U correspond une classe derivant de Zone_dis_base implementant les outils necessaires a la methode.">Zone_dis_base</a>&amp; z,
<a name="l00145"></a>00145                            <span class="keyword">const</span> <a class="code" href="classZone__Cl__dis__base.html" title="classe Zone_Cl_dis_base Les objets Zone_Cl_dis_base representent les conditions aux limites discretis...">Zone_Cl_dis_base</a>&amp; zcl,
<a name="l00146"></a>00146                            <a class="code" href="classMatrice.html">Matrice</a>&amp; matrice,
<a name="l00147"></a>00147                            <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; inverse_quantitee_entrelacee, <span class="keyword">const</span> <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a>&amp; coef_som);
<a name="l00148"></a>00148 
<a name="l00149"></a>00149 <span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="Assembleur__P__VEFPreP1B_8cpp.html#a48eaaecaa31bdde228ea5e3995db4771">updateP0P0</a>(<span class="keyword">const</span> <a class="code" href="classZone__dis__base.html" title="classe Zone_dis_base Cette classe est la base de la hierarchie des zones discretisees. Un objet Zone est associe a la zone discretise. A chaque methode numerique de Trio U correspond une classe derivant de Zone_dis_base implementant les outils necessaires a la methode.">Zone_dis_base</a>&amp; z,
<a name="l00150"></a>00150                        <span class="keyword">const</span> <a class="code" href="classZone__Cl__dis__base.html" title="classe Zone_Cl_dis_base Les objets Zone_Cl_dis_base representent les conditions aux limites discretis...">Zone_Cl_dis_base</a>&amp; zcl,
<a name="l00151"></a>00151                        <a class="code" href="classMatrice.html">Matrice</a>&amp; matrice,
<a name="l00152"></a>00152                        <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; inverse_quantitee_entrelacee);
<a name="l00153"></a>00153 
<a name="l00154"></a>00154 <span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="Assembleur__P__VEFPreP1B_8cpp.html#ab3c25c4172223f48fd2f9d433b005e0c">updateP1P1</a>(<span class="keyword">const</span> <a class="code" href="classZone__dis__base.html" title="classe Zone_dis_base Cette classe est la base de la hierarchie des zones discretisees. Un objet Zone est associe a la zone discretise. A chaque methode numerique de Trio U correspond une classe derivant de Zone_dis_base implementant les outils necessaires a la methode.">Zone_dis_base</a>&amp; z,
<a name="l00155"></a>00155                        <span class="keyword">const</span> <a class="code" href="classZone__Cl__dis__base.html" title="classe Zone_Cl_dis_base Les objets Zone_Cl_dis_base representent les conditions aux limites discretis...">Zone_Cl_dis_base</a>&amp; zcl,
<a name="l00156"></a>00156                        <a class="code" href="classMatrice.html">Matrice</a>&amp; matrice,
<a name="l00157"></a>00157                        <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; inverse_quantitee_entrelacee, <span class="keyword">const</span> <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a>&amp; coef_som);
<a name="l00158"></a>00158 <span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="Assembleur__P__VEFPreP1B_8cpp.html#a1ce15acad922bef2d305d970c13c68c8">modifieP1P1neumann</a>(<span class="keyword">const</span> <a class="code" href="classZone__dis__base.html" title="classe Zone_dis_base Cette classe est la base de la hierarchie des zones discretisees. Un objet Zone est associe a la zone discretise. A chaque methode numerique de Trio U correspond une classe derivant de Zone_dis_base implementant les outils necessaires a la methode.">Zone_dis_base</a>&amp; z,
<a name="l00159"></a>00159                                <span class="keyword">const</span> <a class="code" href="classZone__Cl__dis__base.html" title="classe Zone_Cl_dis_base Les objets Zone_Cl_dis_base representent les conditions aux limites discretis...">Zone_Cl_dis_base</a>&amp; zcl,
<a name="l00160"></a>00160                                <a class="code" href="classMatrice.html">Matrice</a>&amp; matrice,
<a name="l00161"></a>00161                                <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; inverse_quantitee_entrelacee, <span class="keyword">const</span> <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a>&amp; coef_som);
<a name="l00162"></a>00162 <span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="Assembleur__P__VEFPreP1B_8cpp.html#a4e0c0752e80915fd8b0143b70f08e718">updatePaPa</a>(<span class="keyword">const</span> <a class="code" href="classZone__dis__base.html" title="classe Zone_dis_base Cette classe est la base de la hierarchie des zones discretisees. Un objet Zone est associe a la zone discretise. A chaque methode numerique de Trio U correspond une classe derivant de Zone_dis_base implementant les outils necessaires a la methode.">Zone_dis_base</a>&amp; z,
<a name="l00163"></a>00163                        <span class="keyword">const</span> <a class="code" href="classZone__Cl__dis__base.html" title="classe Zone_Cl_dis_base Les objets Zone_Cl_dis_base representent les conditions aux limites discretis...">Zone_Cl_dis_base</a>&amp; zcl,
<a name="l00164"></a>00164                        <a class="code" href="classMatrice.html">Matrice</a>&amp; matrice,
<a name="l00165"></a>00165                        <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; inverse_quantitee_entrelacee);
<a name="l00166"></a>00166 
<a name="l00167"></a>00167 <span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="Assembleur__P__VEFPreP1B_8cpp.html#af30661e8e1b45bf522a5595f65ecc741">updateP0P1</a>(<span class="keyword">const</span> <a class="code" href="classZone__dis__base.html" title="classe Zone_dis_base Cette classe est la base de la hierarchie des zones discretisees. Un objet Zone est associe a la zone discretise. A chaque methode numerique de Trio U correspond une classe derivant de Zone_dis_base implementant les outils necessaires a la methode.">Zone_dis_base</a>&amp; z,
<a name="l00168"></a>00168                        <span class="keyword">const</span> <a class="code" href="classZone__Cl__dis__base.html" title="classe Zone_Cl_dis_base Les objets Zone_Cl_dis_base representent les conditions aux limites discretis...">Zone_Cl_dis_base</a>&amp; zcl,
<a name="l00169"></a>00169                        <a class="code" href="classMatrice.html">Matrice</a>&amp; matrice,
<a name="l00170"></a>00170                        <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; inverse_quantitee_entrelacee, <span class="keyword">const</span> <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a>&amp; coef_som);
<a name="l00171"></a>00171 
<a name="l00172"></a>00172 <span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="Assembleur__P__VEFPreP1B_8cpp.html#aacede92ea2595a5546e6357fbd1e1498">updateP0Pa</a>(<span class="keyword">const</span> <a class="code" href="classZone__dis__base.html" title="classe Zone_dis_base Cette classe est la base de la hierarchie des zones discretisees. Un objet Zone est associe a la zone discretise. A chaque methode numerique de Trio U correspond une classe derivant de Zone_dis_base implementant les outils necessaires a la methode.">Zone_dis_base</a>&amp; z,
<a name="l00173"></a>00173                        <span class="keyword">const</span> <a class="code" href="classZone__Cl__dis__base.html" title="classe Zone_Cl_dis_base Les objets Zone_Cl_dis_base representent les conditions aux limites discretis...">Zone_Cl_dis_base</a>&amp; zcl,
<a name="l00174"></a>00174                        <a class="code" href="classMatrice.html">Matrice</a>&amp; matrice,
<a name="l00175"></a>00175                        <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; inverse_quantitee_entrelacee);
<a name="l00176"></a>00176 
<a name="l00177"></a>00177 <span class="keyword">extern</span>  <span class="keywordtype">void</span> <a class="code" href="Assembleur__P__VEFPreP1B_8cpp.html#a8d9349eb29399f4ac72dc10543a4005a">updateP1Pa</a>(<span class="keyword">const</span> <a class="code" href="classZone__dis__base.html" title="classe Zone_dis_base Cette classe est la base de la hierarchie des zones discretisees. Un objet Zone est associe a la zone discretise. A chaque methode numerique de Trio U correspond une classe derivant de Zone_dis_base implementant les outils necessaires a la methode.">Zone_dis_base</a>&amp; z,
<a name="l00178"></a>00178                         <span class="keyword">const</span> <a class="code" href="classZone__Cl__dis__base.html" title="classe Zone_Cl_dis_base Les objets Zone_Cl_dis_base representent les conditions aux limites discretis...">Zone_Cl_dis_base</a>&amp; zcl,
<a name="l00179"></a>00179                         <a class="code" href="classMatrice.html">Matrice</a>&amp; matrice,
<a name="l00180"></a>00180                         <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; inverse_quantitee_entrelacee, <span class="keyword">const</span> <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a>&amp; coef_som);
<a name="l00181"></a>00181 
<a name="l00182"></a>00182 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="Op__Div__VEFP1B__Elem_8cpp.html#a45261662b3b88d5db461b3fc99246e5a">verifier</a>( <span class="keyword">const</span> <a class="code" href="classAssembleur__P__VEFPreP1B.html">Assembleur_P_VEFPreP1B</a>&amp; ass,
<a name="l00183"></a>00183                      <span class="keyword">const</span> <a class="code" href="classMatrice__Bloc__Sym.html">Matrice_Bloc_Sym</a>&amp; matrice,
<a name="l00184"></a>00184                      <span class="keyword">const</span> <a class="code" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a>&amp; zone_VEF,
<a name="l00185"></a>00185                      <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; inverse_quantitee_entrelacee);
<a name="l00186"></a>00186 
<a name="l00187"></a><a class="code" href="classAssembleur__P__VEFPreP1B.html#a67c7c35807840ac7243b7bf56666d46c">00187</a> <span class="keywordtype">int</span> <a class="code" href="classAssembleur__P__VEFPreP1B.html#a67c7c35807840ac7243b7bf56666d46c">Assembleur_P_VEFPreP1B::assembler</a>(<a class="code" href="classMatrice.html">Matrice</a>&amp; la_matrice)
<a name="l00188"></a>00188 {
<a name="l00189"></a>00189   <span class="keywordflow">return</span> <a class="code" href="classAssembleur__P__VEFPreP1B.html#a67c7c35807840ac7243b7bf56666d46c">Assembleur_P_VEF::assembler</a>(la_matrice);
<a name="l00190"></a>00190 }
<a name="l00191"></a>00191 
<a name="l00192"></a><a class="code" href="classAssembleur__P__VEFPreP1B.html#a051253f0b99e1c73b27eb007dcd1e117">00192</a> <span class="keywordtype">int</span> <a class="code" href="classAssembleur__P__VEFPreP1B.html#a051253f0b99e1c73b27eb007dcd1e117" title="Assemblage de la matrice div( porosite/rho * grad P ) Le type du champ &quot;rho&quot; a fournir depend de la d...">Assembleur_P_VEFPreP1B::assembler_rho_variable</a>(<a class="code" href="classMatrice.html">Matrice</a>&amp; la_matrice, <span class="keyword">const</span> <a class="code" href="classChamp__Don__base.html" title="classe Champ_Don_base classe de base des Champs donnes (non calcules) les proprietes physiques sont d...">Champ_Don_base</a>&amp; rho)
<a name="l00193"></a>00193 {
<a name="l00194"></a>00194 <span class="comment">// On multiplie par la masse volumique aux faces</span>
<a name="l00195"></a>00195   <span class="keywordflow">if</span> (!<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classChamp__Fonc__P1NC.html" title="classe Champ_Fonc_P1NC">Champ_Fonc_P1NC</a>, rho))
<a name="l00196"></a>00196     {
<a name="l00197"></a>00197       <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;La masse volumique n&#39;est pas aux faces dans Assembleur_P_VEFPreP1B::assembler_rho_variable.&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
<a name="l00198"></a>00198       <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">Process::exit</a>();
<a name="l00199"></a>00199     }
<a name="l00200"></a>00200   <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; volumes_entrelaces=<a class="code" href="classAssembleur__P__VEFPreP1B.html#a3b4a812a062b850be5966f8c6e201cee">zone_Vef</a>().<a class="code" href="classZone__VF.html#a64f0b549e5aea1656855113e3510f418">volumes_entrelaces</a>();
<a name="l00201"></a>00201   <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; masse_volumique=rho.<a class="code" href="classChamp__Don__base.html#ac0ac51817e03e27c28d2b96bb15db9a0" title="Surcharge Champ_base::valeurs() Renvoie le tableau des valeurs.">valeurs</a>();
<a name="l00202"></a>00202   <a class="code" href="classDoubleVect.html">DoubleVect</a> quantitee_entrelacee(volumes_entrelaces);
<a name="l00203"></a>00203   <span class="keywordtype">int</span> size=quantitee_entrelacee.<a class="code" href="classArrOfDouble.html#a3c3b33bea0e88b87315c21ee94bee05f" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>();
<a name="l00204"></a>00204   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;size; i++)
<a name="l00205"></a>00205     quantitee_entrelacee(i)=(volumes_entrelaces(i)*masse_volumique(i));
<a name="l00206"></a>00206 
<a name="l00207"></a>00207 <span class="comment">// On assemble la matrice</span>
<a name="l00208"></a>00208   <span class="keywordflow">return</span> <a class="code" href="classAssembleur__P__VEFPreP1B.html#a0cf6d0a6eeb99619a2c40e5a4a573c0d">assembler_mat</a>(la_matrice,quantitee_entrelacee,1,1);
<a name="l00209"></a>00209 }
<a name="l00210"></a>00210 
<a name="l00211"></a><a class="code" href="Assembleur__P__VEFPreP1B_8cpp.html#a6e2318de58fc55873393f2dccdbd9d6c">00211</a> <span class="keywordtype">void</span> <a class="code" href="Assembleur__P__VEFPreP1B_8cpp.html#a6e2318de58fc55873393f2dccdbd9d6c">zero</a>(<a class="code" href="classMatrice__Bloc__Sym.html">Matrice_Bloc_Sym</a>&amp; matrice)
<a name="l00212"></a>00212 {
<a name="l00213"></a>00213   <span class="keywordtype">int</span> nombre_supports = matrice.<a class="code" href="classMatrice__Bloc.html#aa0ef2e295d67f7d325914bdcff9409d4">ordre</a>();
<a name="l00214"></a>00214   <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;nombre_supports; i++)
<a name="l00215"></a>00215     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j=i; j&lt;nombre_supports; j++)
<a name="l00216"></a>00216       {
<a name="l00217"></a>00217         <a class="code" href="classMatrice__Bloc.html">Matrice_Bloc</a>&amp; bloc_ij=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Bloc.html">Matrice_Bloc</a>, matrice.<a class="code" href="classMatrice__Bloc__Sym.html#a1002ce880ea2b2fb48dae444097c9f7a" title="(0&lt;=i&lt;N , i&lt;=j&lt;M)">get_bloc</a>(i,j).<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>());
<a name="l00218"></a>00218         <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>, bloc_ij.<a class="code" href="classMatrice__Bloc.html#a7ffa38f7b93454432b2df7c616ed0a4e">get_bloc</a>(0,0).<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>()).clean();
<a name="l00219"></a>00219         <span class="keywordflow">if</span>(<a class="code" href="classProcess.html#a6bf692ce58d9578aa62ac3c07b8caaa1" title="renvoie le nombre de processeurs dans le groupe courant Voir Comm_Group::nproc() et PE_Groups::curren...">Process::nproc</a>()&gt;1)
<a name="l00220"></a>00220           {
<a name="l00221"></a>00221             <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>, bloc_ij.<a class="code" href="classMatrice__Bloc.html#a7ffa38f7b93454432b2df7c616ed0a4e">get_bloc</a>(0,1).<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>()).clean();
<a name="l00222"></a>00222             <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>, bloc_ij.<a class="code" href="classMatrice__Bloc.html#a7ffa38f7b93454432b2df7c616ed0a4e">get_bloc</a>(1,0).<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>()).clean();
<a name="l00223"></a>00223             <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>, bloc_ij.<a class="code" href="classMatrice__Bloc.html#a7ffa38f7b93454432b2df7c616ed0a4e">get_bloc</a>(1,1).<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>()).clean();
<a name="l00224"></a>00224           }
<a name="l00225"></a>00225       }
<a name="l00226"></a>00226 }
<a name="l00227"></a>00227 
<a name="l00228"></a>00228 
<a name="l00229"></a>00229 
<a name="l00230"></a><a class="code" href="classAssembleur__P__VEFPreP1B.html#a0cf6d0a6eeb99619a2c40e5a4a573c0d">00230</a> <span class="keywordtype">int</span> <a class="code" href="classAssembleur__P__VEFPreP1B.html#a0cf6d0a6eeb99619a2c40e5a4a573c0d">Assembleur_P_VEFPreP1B::assembler_mat</a>(<a class="code" href="classMatrice.html">Matrice</a>&amp; la_matrice,<span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; quantitee_entrelacee, <span class="keywordtype">int</span> incr_pression, <span class="keywordtype">int</span> resoudre_en_u)
<a name="l00231"></a>00231 {
<a name="l00232"></a>00232 <span class="comment">// On fixe les drapeaux de Assembleur_base</span>
<a name="l00233"></a>00233   <a class="code" href="classAssembleur__base.html#ad134c3371f3ced3768a1704be52e0fe8" title="Definit la valeur du drapeau resoudre_increment_pression_. Ce drapeau determine si le solveur en pres...">set_resoudre_increment_pression</a>(incr_pression);
<a name="l00234"></a>00234   <a class="code" href="classAssembleur__base.html#a9cdaa49e5340da74de179c2f22f08605" title="Definit la valeur du drapeau resoudre_en_u__. Ce drapeau determine si le solveur en pression resou en...">set_resoudre_en_u</a>(resoudre_en_u);
<a name="l00235"></a>00235 
<a name="l00236"></a>00236   <a class="code" href="classSolveurSys.html">SolveurSys</a>&amp; solveur_pression = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classNavier__Stokes__std.html" title="classe Navier_Stokes_std Cette classe porte les termes de l&#39;equation de la dynamique pour un fluide s...">Navier_Stokes_std</a>, <a class="code" href="classAssembleur__P__VEFPreP1B.html#a75f504c4171787bdeb487a8dd98e2a00">mon_equation</a>.<a class="code" href="classRef__Equation__base.html#a7bb6fb60cb55bef0eef1b0e8718300a4">valeur</a>()).solveur_pression();
<a name="l00237"></a>00237   <span class="keywordtype">bool</span> read_matrix = <span class="keyword">false</span>;
<a name="l00238"></a>00238   <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classSolv__Petsc.html">Solv_Petsc</a>, solveur_pression.<a class="code" href="classDeriv__SolveurSys__base.html#aa1f67fc10fc25960d05d484a67d1bb54">valeur</a>()))
<a name="l00239"></a>00239     read_matrix = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classSolv__Petsc.html">Solv_Petsc</a>, solveur_pression.<a class="code" href="classDeriv__SolveurSys__base.html#aa1f67fc10fc25960d05d484a67d1bb54">valeur</a>()).read_matrix();
<a name="l00240"></a>00240   <span class="keywordflow">if</span> (read_matrix) <span class="comment">//!&lt; Lecture de la matrice dans un fichier</span>
<a name="l00241"></a>00241 <span class="comment"></span>    {
<a name="l00242"></a>00242       la_matrice.<a class="code" href="classDeriv__.html#ad1d33400ed15b6ff96579ed82d9e2719" title="Essaie de creer une instance du type &quot;type&quot;. si type n&#39;est pas un type ou type n&#39;est pas instanciab...">typer</a>(<span class="stringliteral">&quot;Matrice_Petsc&quot;</span>);
<a name="l00243"></a>00243 <span class="comment">// ref_cast(Matrice_Petsc, la_matrice.valeur()).RestoreMatrixFromFile();</span>
<a name="l00244"></a>00244     }
<a name="l00245"></a>00245   <span class="keywordflow">else</span> <span class="comment">//!&lt; Assemblage de la matrice</span>
<a name="l00246"></a>00246 <span class="comment"></span>    {
<a name="l00247"></a>00247       <span class="keyword">const</span> <a class="code" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a>&amp; zone_vef = <a class="code" href="classAssembleur__P__VEFPreP1B.html#a3b4a812a062b850be5966f8c6e201cee">zone_Vef</a>();
<a name="l00248"></a>00248       <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Assemblage de la matrice de pression&quot;</span> &lt;&lt; (zone_vef.<a class="code" href="classZone__VEF__PreP1b.html#aee2def53aa92584d7945e7c3d0d98963">get_alphaE</a>() ? <span class="stringliteral">&quot; P0&quot;</span> : <span class="stringliteral">&quot;&quot;</span>)
<a name="l00249"></a>00249            &lt;&lt; (zone_vef.<a class="code" href="classZone__VEF__PreP1b.html#ad7fbcb5567dcc2e6f0a0ed85ce90a4fa">get_alphaS</a>() ? <span class="stringliteral">&quot; P1&quot;</span> : <span class="stringliteral">&quot;&quot;</span>) &lt;&lt; (zone_vef.<a class="code" href="classZone__VEF__PreP1b.html#a9d02e2431efb6e75c3d733ff06f89549">get_alphaA</a>() ? <span class="stringliteral">&quot; Pa&quot;</span> : <span class="stringliteral">&quot;&quot;</span>) &lt;&lt; <span class="stringliteral">&quot; en cours...&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
<a name="l00250"></a>00250 
<a name="l00251"></a>00251 <span class="comment">// Les decoupages doivent etre de largeur de joint de 2</span>
<a name="l00252"></a>00252 <span class="comment">// si le support P1 ou Pa est utilise...</span>
<a name="l00253"></a>00253       <span class="keywordflow">if</span> (<a class="code" href="classProcess.html#a6bf692ce58d9578aa62ac3c07b8caaa1" title="renvoie le nombre de processeurs dans le groupe courant Voir Comm_Group::nproc() et PE_Groups::curren...">Process::nproc</a>() &gt; 1 &amp;&amp;
<a name="l00254"></a>00254           zone_vef.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#ab096afb61e89705709a4ae6d3576a644" title="Renvoie le nombre de joints de la zone.">nb_joints</a>() &amp;&amp;
<a name="l00255"></a>00255           zone_vef.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#acec4c61032df8b55a95f9e7197ef6e3c" title="Renvoie le i-ieme joint de la zone&lt;br&gt;(version const)">joint</a>(0).<a class="code" href="classJoint.html#a67445a0294ff0e77d2d990ba0f493a17" title="Renvoie l&#39;epaisseur du joint.">epaisseur</a>() &lt; 2 &amp;&amp;
<a name="l00256"></a>00256           (zone_vef.<a class="code" href="classZone__VEF__PreP1b.html#ad7fbcb5567dcc2e6f0a0ed85ce90a4fa">get_alphaS</a>() || zone_vef.<a class="code" href="classZone__VEF__PreP1b.html#a9d02e2431efb6e75c3d733ff06f89549">get_alphaA</a>()))
<a name="l00257"></a>00257         {
<a name="l00258"></a>00258           <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Ghost cells width of &quot;</span> &lt;&lt; zone_vef.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#acec4c61032df8b55a95f9e7197ef6e3c" title="Renvoie le i-ieme joint de la zone&lt;br&gt;(version const)">joint</a>(0).<a class="code" href="classJoint.html#a67445a0294ff0e77d2d990ba0f493a17" title="Renvoie l&#39;epaisseur du joint.">epaisseur</a>()
<a name="l00259"></a>00259                &lt;&lt; <span class="stringliteral">&quot; is not enough for assembling VEFPreP1B pressure matrix&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
<a name="l00260"></a>00260           <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;for parallel calculation. Partition your mesh with larg_joint option set to 2.&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
<a name="l00261"></a>00261           <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">Process::exit</a>();
<a name="l00262"></a>00262         }
<a name="l00263"></a>00263 
<a name="l00264"></a>00264       <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a> inverse_quantitee_entrelacee;
<a name="l00265"></a>00265       <span class="keyword">const</span> <a class="code" href="classZone__Cl__VEF.html">Zone_Cl_VEF</a>&amp; zone_Cl_VEF = <a class="code" href="classAssembleur__P__VEF.html#af06d2fedcae0282000a96ddd444ec7a2">la_zone_Cl_VEF</a>.<a class="code" href="classRef__Zone__Cl__VEF.html#a0970d7253def65ad4f0c5ce1830fd243">valeur</a>();
<a name="l00266"></a>00266       <a class="code" href="classAssembleur__P__VEF.html#a7260acd8453511a0aaffe9c685df5bb7">calculer_inv_volume</a>(inverse_quantitee_entrelacee, zone_Cl_VEF, quantitee_entrelacee);
<a name="l00267"></a>00267       <span class="keywordtype">int</span> P0 = 0;
<a name="l00268"></a>00268       <span class="keywordtype">int</span> P1 = P0 + zone_vef.<a class="code" href="classZone__VEF__PreP1b.html#aee2def53aa92584d7945e7c3d0d98963">get_alphaE</a>();
<a name="l00269"></a>00269       <span class="keywordtype">int</span> Pa = P1 + zone_vef.<a class="code" href="classZone__VEF__PreP1b.html#ad7fbcb5567dcc2e6f0a0ed85ce90a4fa">get_alphaS</a>();
<a name="l00270"></a>00270       <span class="keywordtype">int</span> nombre_supports = Pa + zone_vef.<a class="code" href="classZone__VEF__PreP1b.html#a9d02e2431efb6e75c3d733ff06f89549">get_alphaA</a>();
<a name="l00271"></a>00271       <a class="code" href="classDoubleVect.html">DoubleVect</a> coef_som;
<a name="l00272"></a>00272       <span class="keywordflow">if</span> (zone_vef.<a class="code" href="classZone__VEF__PreP1b.html#ad7fbcb5567dcc2e6f0a0ed85ce90a4fa">get_alphaS</a>())
<a name="l00273"></a>00273         {
<a name="l00274"></a>00274           zone_vef.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#a600fa15a19c7e1384564dffd83ecab4d" title="creation d&#39;un tableau parallele de valeurs aux elements. Voir MD_Vector_tools::creer_tableau_distribu...">creer_tableau_elements</a>(coef_som);
<a name="l00275"></a>00275           <span class="keywordflow">for</span> (<span class="keywordtype">int</span> elem = 0; elem &lt; coef_som.<a class="code" href="classDoubleVect.html#ad2d21b364e1c6559771970596a25c006" title="Identique a size_array()">size_totale</a>(); elem++)
<a name="l00276"></a>00276             coef_som[elem] = <a class="code" href="classOp__Grad__VEF__P1B__Face.html#aa1b669139e643d29cff74806e14d3e3e">Op_Grad_VEF_P1B_Face::calculer_coef_som</a>(elem, zone_Cl_VEF, zone_vef);
<a name="l00277"></a>00277           coef_som.<a class="code" href="classDoubleVect.html#abfebbc2f685ce7bc4b80c720d7da9bf3">echange_espace_virtuel</a>();
<a name="l00278"></a>00278         }
<a name="l00279"></a>00279 
<a name="l00280"></a>00280 <span class="comment">// Assemblage de la matrice complete selon les supports choisis</span>
<a name="l00281"></a>00281       <a class="code" href="classMatrice__Bloc__Sym.html">Matrice_Bloc_Sym</a>&amp; la_matrice_bloc_sym_de_travail = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Bloc__Sym.html">Matrice_Bloc_Sym</a>, <a class="code" href="classAssembleur__P__VEFPreP1B.html#a5d22f81d5f579074de9324230e3ff45f" title="Matrice de travail.">la_matrice_de_travail_</a>.<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>());
<a name="l00282"></a>00282       <span class="keywordflow">if</span> (la_matrice_bloc_sym_de_travail.<a class="code" href="classMatrice__Bloc.html#a02193255787b0ecae7988ca4eada3b4b" title="retourne N_">nb_bloc_lignes</a>()==0)
<a name="l00283"></a>00283         {
<a name="l00284"></a>00284           la_matrice_bloc_sym_de_travail.<a class="code" href="classMatrice__Bloc__Sym.html#a1afda96c64b026b5e26ff31572c0234a" title="dimensionnement de blocs_">dimensionner</a>(nombre_supports, nombre_supports);
<a name="l00285"></a>00285           <span class="keywordflow">if</span> (zone_vef.<a class="code" href="classZone__VEF__PreP1b.html#aee2def53aa92584d7945e7c3d0d98963">get_alphaE</a>())
<a name="l00286"></a>00286             <a class="code" href="Assembleur__P__VEFPreP1B_8cpp.html#a31e2d4bc38d5bc0bbf9e2c36d15b589b">assemblerP0P0</a>(zone_vef, zone_Cl_VEF, la_matrice_bloc_sym_de_travail.<a class="code" href="classMatrice__Bloc__Sym.html#a1002ce880ea2b2fb48dae444097c9f7a" title="(0&lt;=i&lt;N , i&lt;=j&lt;M)">get_bloc</a>(P0, P0),
<a name="l00287"></a>00287                           inverse_quantitee_entrelacee);
<a name="l00288"></a>00288 
<a name="l00289"></a>00289           <span class="keywordflow">if</span> (zone_vef.<a class="code" href="classZone__VEF__PreP1b.html#ad7fbcb5567dcc2e6f0a0ed85ce90a4fa">get_alphaS</a>())
<a name="l00290"></a>00290             <a class="code" href="Assembleur__P__VEFPreP1B_8cpp.html#a31f132f3fda04d8428de212c63fd902f">assemblerP1P1</a>(zone_vef, zone_Cl_VEF, la_matrice_bloc_sym_de_travail.<a class="code" href="classMatrice__Bloc__Sym.html#a1002ce880ea2b2fb48dae444097c9f7a" title="(0&lt;=i&lt;N , i&lt;=j&lt;M)">get_bloc</a>(P1, P1),
<a name="l00291"></a>00291                           inverse_quantitee_entrelacee, coef_som);
<a name="l00292"></a>00292 
<a name="l00293"></a>00293           <span class="keywordflow">if</span> (zone_vef.<a class="code" href="classZone__VEF__PreP1b.html#aee2def53aa92584d7945e7c3d0d98963">get_alphaE</a>() &amp;&amp; zone_vef.<a class="code" href="classZone__VEF__PreP1b.html#ad7fbcb5567dcc2e6f0a0ed85ce90a4fa">get_alphaS</a>())
<a name="l00294"></a>00294             <a class="code" href="Assembleur__P__VEFPreP1B_8cpp.html#a3774b1608aeee56152e7e1e5f385bfe1">assemblerP0P1</a>(zone_vef, zone_Cl_VEF, la_matrice_bloc_sym_de_travail.<a class="code" href="classMatrice__Bloc__Sym.html#a1002ce880ea2b2fb48dae444097c9f7a" title="(0&lt;=i&lt;N , i&lt;=j&lt;M)">get_bloc</a>(P0, P1),
<a name="l00295"></a>00295                           inverse_quantitee_entrelacee, coef_som);
<a name="l00296"></a>00296 
<a name="l00297"></a>00297           <span class="keywordflow">if</span> (zone_vef.<a class="code" href="classZone__VEF__PreP1b.html#a9d02e2431efb6e75c3d733ff06f89549">get_alphaA</a>())
<a name="l00298"></a>00298             <a class="code" href="Assembleur__P__VEFPreP1B_8cpp.html#a7840f924363ed7d3fbd50a59d9d990c0">assemblerPaPa</a>(zone_vef, zone_Cl_VEF, la_matrice_bloc_sym_de_travail.<a class="code" href="classMatrice__Bloc__Sym.html#a1002ce880ea2b2fb48dae444097c9f7a" title="(0&lt;=i&lt;N , i&lt;=j&lt;M)">get_bloc</a>(Pa, Pa),
<a name="l00299"></a>00299                           inverse_quantitee_entrelacee);
<a name="l00300"></a>00300 
<a name="l00301"></a>00301           <span class="keywordflow">if</span> (zone_vef.<a class="code" href="classZone__VEF__PreP1b.html#ad7fbcb5567dcc2e6f0a0ed85ce90a4fa">get_alphaS</a>() &amp;&amp; zone_vef.<a class="code" href="classZone__VEF__PreP1b.html#a9d02e2431efb6e75c3d733ff06f89549">get_alphaA</a>())
<a name="l00302"></a>00302             <a class="code" href="Assembleur__P__VEFPreP1B_8cpp.html#a5dcfee4400f896bcbb100259f53a5de1">assemblerP1Pa</a>(zone_vef, zone_Cl_VEF, la_matrice_bloc_sym_de_travail.<a class="code" href="classMatrice__Bloc__Sym.html#a1002ce880ea2b2fb48dae444097c9f7a" title="(0&lt;=i&lt;N , i&lt;=j&lt;M)">get_bloc</a>(P1, Pa),
<a name="l00303"></a>00303                           inverse_quantitee_entrelacee, coef_som);
<a name="l00304"></a>00304 
<a name="l00305"></a>00305           <span class="keywordflow">if</span> (zone_vef.<a class="code" href="classZone__VEF__PreP1b.html#aee2def53aa92584d7945e7c3d0d98963">get_alphaE</a>() &amp;&amp; zone_vef.<a class="code" href="classZone__VEF__PreP1b.html#a9d02e2431efb6e75c3d733ff06f89549">get_alphaA</a>())
<a name="l00306"></a>00306             <a class="code" href="Assembleur__P__VEFPreP1B_8cpp.html#a30b5e404b46e2a239584ee19835c88bf">assemblerP0Pa</a>(zone_vef, zone_Cl_VEF, la_matrice_bloc_sym_de_travail.<a class="code" href="classMatrice__Bloc__Sym.html#a1002ce880ea2b2fb48dae444097c9f7a" title="(0&lt;=i&lt;N , i&lt;=j&lt;M)">get_bloc</a>(P0, Pa),
<a name="l00307"></a>00307                           inverse_quantitee_entrelacee);
<a name="l00308"></a>00308         }
<a name="l00309"></a>00309 <span class="comment">// On met a zero la matrice meme si elle a ete correctement construite et remplie dans les methodes</span>
<a name="l00310"></a>00310 <span class="comment">// assemblerPiPi et on la remplit a nouveau. Pourquoi? Pour avoir une couverture de tests</span>
<a name="l00311"></a>00311 <span class="comment">// suffisante des methodes updatePiPi en attendant de factoriser correctement les</span>
<a name="l00312"></a>00312 <span class="comment">// methodes assemblerPiPi et updatePiPi</span>
<a name="l00313"></a>00313       <a class="code" href="Assembleur__P__VEFPreP1B_8cpp.html#a6e2318de58fc55873393f2dccdbd9d6c">zero</a>(la_matrice_bloc_sym_de_travail);
<a name="l00314"></a>00314       {
<a name="l00315"></a>00315         <span class="keywordflow">if</span> (zone_vef.<a class="code" href="classZone__VEF__PreP1b.html#aee2def53aa92584d7945e7c3d0d98963">get_alphaE</a>())
<a name="l00316"></a>00316           <a class="code" href="Assembleur__P__VEFPreP1B_8cpp.html#a48eaaecaa31bdde228ea5e3995db4771">updateP0P0</a>(zone_vef, zone_Cl_VEF, la_matrice_bloc_sym_de_travail.<a class="code" href="classMatrice__Bloc__Sym.html#a1002ce880ea2b2fb48dae444097c9f7a" title="(0&lt;=i&lt;N , i&lt;=j&lt;M)">get_bloc</a>(P0, P0),
<a name="l00317"></a>00317                      inverse_quantitee_entrelacee);
<a name="l00318"></a>00318 
<a name="l00319"></a>00319         <span class="keywordflow">if</span> (zone_vef.<a class="code" href="classZone__VEF__PreP1b.html#ad7fbcb5567dcc2e6f0a0ed85ce90a4fa">get_alphaS</a>())
<a name="l00320"></a>00320           {
<a name="l00321"></a>00321             <a class="code" href="Assembleur__P__VEFPreP1B_8cpp.html#ab3c25c4172223f48fd2f9d433b005e0c">updateP1P1</a>(zone_vef, zone_Cl_VEF, la_matrice_bloc_sym_de_travail.<a class="code" href="classMatrice__Bloc__Sym.html#a1002ce880ea2b2fb48dae444097c9f7a" title="(0&lt;=i&lt;N , i&lt;=j&lt;M)">get_bloc</a>(P1, P1),
<a name="l00322"></a>00322                        inverse_quantitee_entrelacee, coef_som);
<a name="l00323"></a>00323             <span class="keywordflow">if</span> (zone_vef.<a class="code" href="classZone__VEF__PreP1b.html#aed6f98596f13c0c4df7a7d9f57235b56">get_cl_pression_sommet_faible</a>() == 0)
<a name="l00324"></a>00324               <a class="code" href="Assembleur__P__VEFPreP1B_8cpp.html#a1ce15acad922bef2d305d970c13c68c8">modifieP1P1neumann</a>(zone_vef, zone_Cl_VEF, la_matrice_bloc_sym_de_travail.<a class="code" href="classMatrice__Bloc__Sym.html#a1002ce880ea2b2fb48dae444097c9f7a" title="(0&lt;=i&lt;N , i&lt;=j&lt;M)">get_bloc</a>(P1, P1),
<a name="l00325"></a>00325                                  inverse_quantitee_entrelacee, coef_som);
<a name="l00326"></a>00326           }
<a name="l00327"></a>00327         <span class="keywordflow">if</span> (zone_vef.<a class="code" href="classZone__VEF__PreP1b.html#aee2def53aa92584d7945e7c3d0d98963">get_alphaE</a>() &amp;&amp; zone_vef.<a class="code" href="classZone__VEF__PreP1b.html#ad7fbcb5567dcc2e6f0a0ed85ce90a4fa">get_alphaS</a>())
<a name="l00328"></a>00328           <a class="code" href="Assembleur__P__VEFPreP1B_8cpp.html#af30661e8e1b45bf522a5595f65ecc741">updateP0P1</a>(zone_vef, zone_Cl_VEF, la_matrice_bloc_sym_de_travail.<a class="code" href="classMatrice__Bloc__Sym.html#a1002ce880ea2b2fb48dae444097c9f7a" title="(0&lt;=i&lt;N , i&lt;=j&lt;M)">get_bloc</a>(P0, P1),
<a name="l00329"></a>00329                      inverse_quantitee_entrelacee, coef_som);
<a name="l00330"></a>00330 
<a name="l00331"></a>00331         <span class="keywordflow">if</span> (zone_vef.<a class="code" href="classZone__VEF__PreP1b.html#a9d02e2431efb6e75c3d733ff06f89549">get_alphaA</a>())
<a name="l00332"></a>00332           <a class="code" href="Assembleur__P__VEFPreP1B_8cpp.html#a4e0c0752e80915fd8b0143b70f08e718">updatePaPa</a>(zone_vef, zone_Cl_VEF, la_matrice_bloc_sym_de_travail.<a class="code" href="classMatrice__Bloc__Sym.html#a1002ce880ea2b2fb48dae444097c9f7a" title="(0&lt;=i&lt;N , i&lt;=j&lt;M)">get_bloc</a>(Pa, Pa),
<a name="l00333"></a>00333                      inverse_quantitee_entrelacee);
<a name="l00334"></a>00334 
<a name="l00335"></a>00335         <span class="keywordflow">if</span> (zone_vef.<a class="code" href="classZone__VEF__PreP1b.html#ad7fbcb5567dcc2e6f0a0ed85ce90a4fa">get_alphaS</a>() &amp;&amp; zone_vef.<a class="code" href="classZone__VEF__PreP1b.html#a9d02e2431efb6e75c3d733ff06f89549">get_alphaA</a>())
<a name="l00336"></a>00336           <a class="code" href="Assembleur__P__VEFPreP1B_8cpp.html#a8d9349eb29399f4ac72dc10543a4005a">updateP1Pa</a>(zone_vef, zone_Cl_VEF, la_matrice_bloc_sym_de_travail.<a class="code" href="classMatrice__Bloc__Sym.html#a1002ce880ea2b2fb48dae444097c9f7a" title="(0&lt;=i&lt;N , i&lt;=j&lt;M)">get_bloc</a>(P1, Pa),
<a name="l00337"></a>00337                      inverse_quantitee_entrelacee, coef_som);
<a name="l00338"></a>00338 
<a name="l00339"></a>00339         <span class="keywordflow">if</span> (zone_vef.<a class="code" href="classZone__VEF__PreP1b.html#aee2def53aa92584d7945e7c3d0d98963">get_alphaE</a>() &amp;&amp; zone_vef.<a class="code" href="classZone__VEF__PreP1b.html#a9d02e2431efb6e75c3d733ff06f89549">get_alphaA</a>())
<a name="l00340"></a>00340           <a class="code" href="Assembleur__P__VEFPreP1B_8cpp.html#aacede92ea2595a5546e6357fbd1e1498">updateP0Pa</a>(zone_vef, zone_Cl_VEF, la_matrice_bloc_sym_de_travail.<a class="code" href="classMatrice__Bloc__Sym.html#a1002ce880ea2b2fb48dae444097c9f7a" title="(0&lt;=i&lt;N , i&lt;=j&lt;M)">get_bloc</a>(P0, Pa),
<a name="l00341"></a>00341                      inverse_quantitee_entrelacee);
<a name="l00342"></a>00342       }
<a name="l00343"></a>00343       <span class="keywordtype">int</span> ordre_matrice = <a class="code" href="classProcess.html#a7d23bc1ef94b3f0623fbc79d034c27fd" title="Calcule la somme de x sur tous les processeurs du groupe courant. Voir aussi mp_max()">mp_sum</a>(la_matrice_bloc_sym_de_travail.<a class="code" href="classMatrice__Bloc.html#aa282a8298b08603722d97704cf98c8cc">nb_lignes</a>());
<a name="l00344"></a>00344       <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Order of the matrix = &quot;</span> &lt;&lt; ordre_matrice &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
<a name="l00345"></a>00345 
<a name="l00346"></a>00346 <span class="comment">// Methode verifier</span>
<a name="l00347"></a>00347       <span class="keywordtype">char</span> *theValue = getenv(<span class="stringliteral">&quot;TRUST_VERIFIE_MATRICE_VEF&quot;</span>);
<a name="l00348"></a>00348       <span class="keywordflow">if</span> (theValue != NULL) <a class="code" href="Op__Div__VEFP1B__Elem_8cpp.html#a45261662b3b88d5db461b3fc99246e5a">verifier</a>(*<span class="keyword">this</span>, la_matrice_bloc_sym_de_travail, zone_vef, inverse_quantitee_entrelacee);
<a name="l00349"></a>00349 
<a name="l00350"></a>00350 <span class="comment">//</span>
<a name="l00351"></a>00351 <span class="comment">// Changement de base eventuel P0P1-&gt;P1Bulle</span>
<a name="l00352"></a>00352 <span class="comment">//</span>
<a name="l00353"></a>00353       <span class="keywordflow">if</span> (<a class="code" href="classAssembleur__P__VEFPreP1B.html#aa0ae226ce031b9410e951a4e95a393d8">changement_base</a>())
<a name="l00354"></a>00354         <a class="code" href="classAssembleur__P__VEFPreP1B.html#a1aebbbfd89e1ef2e187eca8c32a976f2" title="A-&gt;A~ (P0+P1-&gt;P1Bulle)">changer_base_matrice</a>(<a class="code" href="classAssembleur__P__VEFPreP1B.html#a5d22f81d5f579074de9324230e3ff45f" title="Matrice de travail.">la_matrice_de_travail_</a>); <span class="comment">//!&lt; A-&gt;A~</span>
<a name="l00355"></a>00355 <span class="comment"></span>
<a name="l00356"></a>00356 <span class="comment">//</span>
<a name="l00357"></a>00357 <span class="comment">// Modification de la matrice si pas de pression de reference</span>
<a name="l00358"></a>00358 <span class="comment">//</span>
<a name="l00359"></a>00359       <a class="code" href="classAssembleur__P__VEFPreP1B.html#a4f5ed51e7785455c9ddeb94d1978799a" title="Modifier eventuellement la matrice pour la rendre definie si elle ne l&#39;est pas Valeurs par defaut: Co...">modifier_matrice</a>(<a class="code" href="classAssembleur__P__VEFPreP1B.html#a5d22f81d5f579074de9324230e3ff45f" title="Matrice de travail.">la_matrice_de_travail_</a>);
<a name="l00360"></a>00360 
<a name="l00361"></a>00361 <span class="comment">// Conversion eventuelle en Matrice_Morse_Sym</span>
<a name="l00362"></a>00362       <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classNavier__Stokes__std.html" title="classe Navier_Stokes_std Cette classe porte les termes de l&#39;equation de la dynamique pour un fluide s...">Navier_Stokes_std</a>, <a class="code" href="classAssembleur__P__VEFPreP1B.html#a75f504c4171787bdeb487a8dd98e2a00">mon_equation</a>.<a class="code" href="classRef__Equation__base.html#a7bb6fb60cb55bef0eef1b0e8718300a4">valeur</a>()).solveur_pression().<a class="code" href="classSolveurSys.html#a90e3df61815652dccd9c8bf240d46ddc">supporte_matrice_morse_sym</a>() &amp;&amp;
<a name="l00363"></a>00363           zone_vef.<a class="code" href="classZone__VEF__PreP1b.html#aee2def53aa92584d7945e7c3d0d98963">get_alphaE</a>() != nombre_supports) <span class="comment">//!&lt; On n&#39;est pas en P0</span>
<a name="l00364"></a>00364 <span class="comment"></span>        {
<a name="l00365"></a>00365 <span class="comment">//</span>
<a name="l00366"></a>00366 <span class="comment">// La matrice retournee est une Matrice_Morse_Sym nettoyee</span>
<a name="l00367"></a>00367 <span class="comment">// si le solveur utilisee supporte ce type de matrice</span>
<a name="l00368"></a>00368 <span class="comment">// et si on n&#39;est pas en P0 seulement (dans ce cas la, la</span>
<a name="l00369"></a>00369 <span class="comment">// conversion en Mat_Morse_Sym n&#39;apporte rien, et plante le SSOR</span>
<a name="l00370"></a>00370 <span class="comment">// car la matrice morse contient alors des parties virtuelles</span>
<a name="l00371"></a>00371 <span class="comment">// alors qu&#39;il n&#39;y a pas d&#39;items communs et on tombe sur</span>
<a name="l00372"></a>00372 <span class="comment">// l&#39;assert assert(*tab2_ptr&lt;=n); Deux autres solutions:</span>
<a name="l00373"></a>00373 <span class="comment">// -Modifier le SSOR pour ne resoudre que la partie reelle</span>
<a name="l00374"></a>00374 <span class="comment">// -Dans le cas de P0 seul, il faudrait vider VV et RV dans la Mat_Bloc_Sym</span>
<a name="l00375"></a>00375 <span class="comment">//</span>
<a name="l00376"></a>00376           la_matrice.<a class="code" href="classDeriv__.html#ad1d33400ed15b6ff96579ed82d9e2719" title="Essaie de creer une instance du type &quot;type&quot;. si type n&#39;est pas un type ou type n&#39;est pas instanciab...">typer</a>(<span class="stringliteral">&quot;Matrice_Morse_Sym&quot;</span>);
<a name="l00377"></a>00377           <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Bloc__Sym.html">Matrice_Bloc_Sym</a>, <a class="code" href="classAssembleur__P__VEFPreP1B.html#a5d22f81d5f579074de9324230e3ff45f" title="Matrice de travail.">la_matrice_de_travail_</a>.<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>()).BlocSymToMatMorseSym(
<a name="l00378"></a>00378             <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Morse__Sym.html" title="Classe Matrice_Morse_Sym Represente une matrice M (creuse) symetrique stockee au format Morse Symetri...">Matrice_Morse_Sym</a>, la_matrice.<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>()));
<a name="l00379"></a>00379           <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Morse__Sym.html" title="Classe Matrice_Morse_Sym Represente une matrice M (creuse) symetrique stockee au format Morse Symetri...">Matrice_Morse_Sym</a>, la_matrice.<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>()).compacte(
<a name="l00380"></a>00380             2);<span class="comment">//!&lt; Suppression des coefficients nuls et quasi non nuls</span>
<a name="l00381"></a>00381 <span class="comment"></span>        }
<a name="l00382"></a>00382       <span class="keywordflow">else</span>
<a name="l00383"></a>00383         {
<a name="l00384"></a>00384 <span class="comment">//</span>
<a name="l00385"></a>00385 <span class="comment">// La matrice retournee est une Matrice_Bloc_Sym nettoyee</span>
<a name="l00386"></a>00386 <span class="comment">//</span>
<a name="l00387"></a>00387           la_matrice = <a class="code" href="classAssembleur__P__VEFPreP1B.html#a5d22f81d5f579074de9324230e3ff45f" title="Matrice de travail.">la_matrice_de_travail_</a>;
<a name="l00388"></a>00388           <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; nombre_supports; i++)
<a name="l00389"></a>00389             <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = i; j &lt; nombre_supports; j++)
<a name="l00390"></a>00390               {
<a name="l00391"></a>00391                 <a class="code" href="classMatrice__Bloc__Sym.html">Matrice_Bloc_Sym</a>&amp; mat_bloc_sym = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Bloc__Sym.html">Matrice_Bloc_Sym</a>, la_matrice.<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>());
<a name="l00392"></a>00392                 <a class="code" href="classMatrice__Bloc.html">Matrice_Bloc</a>&amp; bloc_ij = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Bloc.html">Matrice_Bloc</a>, mat_bloc_sym.<a class="code" href="classMatrice__Bloc__Sym.html#a1002ce880ea2b2fb48dae444097c9f7a" title="(0&lt;=i&lt;N , i&lt;=j&lt;M)">get_bloc</a>(i, j).<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>());
<a name="l00393"></a>00393                 <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>, bloc_ij.get_bloc(0, 0).valeur()).compacte(
<a name="l00394"></a>00394                   2); <span class="comment">//!&lt; Suppression des coefficients nuls et quasi non nuls</span>
<a name="l00395"></a>00395 <span class="comment"></span>              }
<a name="l00396"></a>00396         }
<a name="l00397"></a>00397     }
<a name="l00398"></a>00398 
<a name="l00399"></a>00399 <span class="comment">// Si pas deja fait, on prends un solveur (SolveurPP1B) qui fera les changements de base pour la solution et le second membre</span>
<a name="l00400"></a>00400   <span class="keywordflow">if</span> (<a class="code" href="classAssembleur__P__VEFPreP1B.html#aa0ae226ce031b9410e951a4e95a393d8">changement_base</a>() &amp;&amp; solveur_pression.<a class="code" href="classDeriv__SolveurSys__base.html#aa1f67fc10fc25960d05d484a67d1bb54">valeur</a>().<a class="code" href="classObjet__U.html#aa58e9a81c0ddc2c1149053b8f96698ac" title="renvoie la chaine identifiant la classe.">que_suis_je</a>() != <span class="stringliteral">&quot;SolveurPP1B&quot;</span>)
<a name="l00401"></a>00401     {
<a name="l00402"></a>00402       <a class="code" href="classSolveurSys.html">SolveurSys</a> solveur_pression_lu = solveur_pression;
<a name="l00403"></a>00403       solveur_pression.<a class="code" href="classDeriv__.html#ad1d33400ed15b6ff96579ed82d9e2719" title="Essaie de creer une instance du type &quot;type&quot;. si type n&#39;est pas un type ou type n&#39;est pas instanciab...">typer</a>(<span class="stringliteral">&quot;SolveurPP1B&quot;</span>);
<a name="l00404"></a>00404       <a class="code" href="classSolveurPP1B.html">SolveurPP1B</a>&amp; solveur_pression_PP1B = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classSolveurPP1B.html">SolveurPP1B</a>, solveur_pression.<a class="code" href="classDeriv__SolveurSys__base.html#aa1f67fc10fc25960d05d484a67d1bb54">valeur</a>());
<a name="l00405"></a>00405       solveur_pression_PP1B.<a class="code" href="classSolveurPP1B.html#a33ff8b6f192454d73472aebadb506a98">associer</a>(*<span class="keyword">this</span>, solveur_pression_lu);
<a name="l00406"></a>00406     }
<a name="l00407"></a>00407 
<a name="l00408"></a>00408 <span class="comment">//</span>
<a name="l00409"></a>00409 <span class="comment">// Affichage eventuel du conditionnement de la matrice</span>
<a name="l00410"></a>00410 <span class="comment">//</span>
<a name="l00411"></a>00411   <span class="keywordtype">char</span>* theValue2 = getenv(<span class="stringliteral">&quot;TRUST_CONDITIONNEMENT_MATRICE&quot;</span>);
<a name="l00412"></a>00412   <span class="keywordflow">if</span>(theValue2 != NULL)
<a name="l00413"></a>00413     <a class="code" href="EntreeSortie_8h.html#a1007c2f57f1c8fc7334a3f62aab08414">Cout</a> &lt;&lt; <span class="stringliteral">&quot;Estimation du conditionnement de la matrice: &quot;</span> &lt;&lt; <a class="code" href="Assembleur__P__VEFPreP1B_8cpp.html#ad6ea924b20e311b70fc786906b53805b">estim_cond</a>(la_matrice)&lt;&lt;<a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
<a name="l00414"></a>00414 
<a name="l00415"></a>00415   <span class="keywordflow">return</span> 1;
<a name="l00416"></a>00416 }
<a name="l00417"></a>00417 
<a name="l00418"></a><a class="code" href="classAssembleur__P__VEFPreP1B.html#a492bdeef134441bb3358ea66c771c783">00418</a> <span class="keywordtype">int</span> <a class="code" href="classAssembleur__P__VEFPreP1B.html#a492bdeef134441bb3358ea66c771c783">Assembleur_P_VEFPreP1B::modifier_secmem</a>(<a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; b)
<a name="l00419"></a>00419 {
<a name="l00420"></a>00420   <span class="keyword">const</span> <a class="code" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a>&amp; la_zone = <a class="code" href="classAssembleur__P__VEFPreP1B.html#a3b4a812a062b850be5966f8c6e201cee">zone_Vef</a>();
<a name="l00421"></a>00421 
<a name="l00422"></a>00422 <span class="comment">// Verification sur le support Pa</span>
<a name="l00423"></a>00423   <span class="keywordflow">if</span> (la_zone.<a class="code" href="classZone__VEF__PreP1b.html#a9d02e2431efb6e75c3d733ff06f89549">get_alphaA</a>())
<a name="l00424"></a>00424     {
<a name="l00425"></a>00425 <span class="comment">// Verification sur les aretes que:</span>
<a name="l00426"></a>00426       <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; renum_arete_perio=la_zone.<a class="code" href="classZone__VEF__PreP1b.html#a43767f8684512d1ee950dc07eea76c5b">get_renum_arete_perio</a>();
<a name="l00427"></a>00427       <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; ok_arete=la_zone.<a class="code" href="classZone__VEF__PreP1b.html#a83771f784d487e346b2ef22a389472a2">get_ok_arete</a>();
<a name="l00428"></a>00428       <span class="keywordtype">int</span> npa=la_zone.<a class="code" href="classZone__VEF__PreP1b.html#aa0033e533851a80e958050a0b892e9a8">numero_premiere_arete</a>();
<a name="l00429"></a>00429 <span class="comment">// b n&#39;a pas forcement son espace virtuel a jour</span>
<a name="l00430"></a>00430       <span class="keywordtype">int</span> nb_aretes=la_zone.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#a3e3b48691911fd85574c7bc10a1a4fb8" title="renvoie le nombre d&#39;aretes reelles.">nb_aretes</a>();
<a name="l00431"></a>00431       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;nb_aretes; i++)
<a name="l00432"></a>00432         <span class="keywordflow">if</span>(!ok_arete(i) &amp;&amp; b(npa+i)!=0.) <span class="comment">//!&lt; Les aretes superflues ont une valeur nulle</span>
<a name="l00433"></a>00433 <span class="comment"></span>          {
<a name="l00434"></a>00434             <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Pb div Aretes, la pression sur l&#39;arete &quot;</span> &lt;&lt; i &lt;&lt; <span class="stringliteral">&quot; (qui est superflue) n&#39;est pas nulle.&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
<a name="l00435"></a>00435             <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">Process::exit</a>();
<a name="l00436"></a>00436           }
<a name="l00437"></a>00437         <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( (renum_arete_perio(i)!=i) &amp;&amp; b(npa+i)!=0.) <span class="comment">//!&lt; Les aretes periodiques ont une valeur nulle</span>
<a name="l00438"></a>00438 <span class="comment"></span>          {
<a name="l00439"></a>00439             <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Pb div Aretes Perio, la pression sur l&#39;arete &quot;</span> &lt;&lt; i &lt;&lt; <span class="stringliteral">&quot; (qui est periodique) n&#39;est pas nulle.&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
<a name="l00440"></a>00440             <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">Process::exit</a>();
<a name="l00441"></a>00441           }
<a name="l00442"></a>00442     }
<a name="l00443"></a>00443 
<a name="l00444"></a>00444 <span class="comment">// Verification sur le support P1</span>
<a name="l00445"></a>00445   <span class="keywordflow">if</span> (la_zone.<a class="code" href="classZone__VEF__PreP1b.html#ad7fbcb5567dcc2e6f0a0ed85ce90a4fa">get_alphaS</a>())
<a name="l00446"></a>00446     {
<a name="l00447"></a>00447 <span class="comment">// Verification que la pression sur les sommets periodiques est nulle</span>
<a name="l00448"></a>00448       <span class="keyword">const</span> <a class="code" href="classDomaine.html" title="Classe Domaine Un Domaine represente le domaine (spatial) de resolution d&#39;un Probleme. Un Domaine a un Nom, il est constitue d&#39;une ou plusieurs Zone qui peuvent etre eventuellement decoupees en Sous_Zone. Un Domaine porte l&#39;ensemble des sommets utilises par ses Zones. On peut vouloir resoudre des problemes de type different sur plusieurs domaines, geometriquement les domaines sont alors couples par des surfaces qu&#39;on appelle Raccord.">Domaine</a>&amp; dom=la_zone.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#a379ad2206b5a13a4f4f3df6d44c7546a" title="Renvoie le domaine dont la zone fait partie. (version const)">domaine</a>();
<a name="l00449"></a>00449       <span class="keywordtype">int</span> nps=la_zone.<a class="code" href="classZone__VEF__PreP1b.html#ab469e7b0d67ddcc27e5cf16c3c85e8f4">numero_premier_sommet</a>();
<a name="l00450"></a>00450       <span class="keywordtype">int</span> ns=la_zone.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#ad340f571f81fa5c2e028b88c00b5c2ca" title="Renvoie le nombre de sommets de la zone.">nb_som</a>();
<a name="l00451"></a>00451       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;ns; i++)
<a name="l00452"></a>00452         {
<a name="l00453"></a>00453           <span class="keywordtype">int</span> k=dom.<a class="code" href="classDomaine.html#a37cc657f1907d53b0d5a573da862af80">get_renum_som_perio</a>(i);
<a name="l00454"></a>00454           <span class="keywordflow">if</span>((k!=i)&amp;&amp; b(nps+i)!=0.)
<a name="l00455"></a>00455             {
<a name="l00456"></a>00456               <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Pb div Som, la pression sur le sommet &quot;</span> &lt;&lt; i &lt;&lt; <span class="stringliteral">&quot; (qui est periodique) n&#39;est pas nulle.&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
<a name="l00457"></a>00457               <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;En terme clair, le second membre n&#39;est pas nul sur un sommet periodique.&quot;</span> &lt;&lt; finl;
<a name="l00458"></a>00458               <span class="keywordflow">if</span> (b(nps+i)!=b(nps+k))
<a name="l00459"></a>00459                 {
<a name="l00460"></a>00460                   <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;En outre, le second membre n&#39;a pas la meme valeur sur les 2 sommets periodiques.&quot;</span> &lt;&lt; finl;
<a name="l00461"></a>00461                   <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;b(nps+i)=&quot;</span> &lt;&lt; b(nps+i) &lt;&lt; <span class="stringliteral">&quot; &lt;&gt; b(nps+k)=&quot;</span> &lt;&lt; b(nps+k) &lt;&lt; finl;
<a name="l00462"></a>00462                 }
<a name="l00463"></a>00463               <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Il y&#39;a probabilite que le modele utilise soit mal implemente pour&quot;</span> &lt;&lt; finl;
<a name="l00464"></a>00464               <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;une condition de periodicite. Contacter le support TRUST.&quot;</span> &lt;&lt; finl;
<a name="l00465"></a>00465               <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">Process::exit</a>();
<a name="l00466"></a>00466             }
<a name="l00467"></a>00467         }
<a name="l00468"></a>00468     }
<a name="l00469"></a>00469 
<a name="l00470"></a>00470   <span class="keywordflow">if</span> (<a class="code" href="classAssembleur__base.html#a3744c3df3886e9fc65246c2eb1abb794" title="Renvoie la valeur du drapeau resoudre_en_u_ (0 ou 1) Renvoie -1 si le drapeau n&#39;a pas ete initialise...">get_resoudre_en_u</a>())
<a name="l00471"></a>00471     {
<a name="l00472"></a>00472       <span class="keyword">const</span> <a class="code" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a>&amp; zone_VEF =  <a class="code" href="classAssembleur__P__VEFPreP1B.html#a3b4a812a062b850be5966f8c6e201cee">zone_Vef</a>();
<a name="l00473"></a>00473       <span class="keyword">const</span> <a class="code" href="classZone__Cl__VEF.html">Zone_Cl_VEF</a>&amp; zone_Cl = <a class="code" href="classAssembleur__P__VEF.html#af06d2fedcae0282000a96ddd444ec7a2">la_zone_Cl_VEF</a>.<a class="code" href="classRef__Zone__Cl__VEF.html#a0970d7253def65ad4f0c5ce1830fd243">valeur</a>();
<a name="l00474"></a>00474 
<a name="l00475"></a>00475       <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; porosite_face = zone_VEF.<a class="code" href="classZone__VF.html#ad9d74d1d9da9f50ab26768dbbca7711b">porosite_face</a>();
<a name="l00476"></a>00476 
<a name="l00477"></a>00477       <span class="keyword">const</span> <span class="keywordtype">int</span> nb_cond_lim = zone_Cl.<a class="code" href="classZone__Cl__dis__base.html#aa6f1df56cfd6e2eae83cc991c7cc9b41" title="Renvoie le nombre de conditions aux limites.">nb_cond_lim</a>();
<a name="l00478"></a>00478 
<a name="l00479"></a>00479       <span class="comment">/**************************/</span>
<a name="l00480"></a>00480       <span class="comment">/* Recuperation de Gpoint */</span>
<a name="l00481"></a>00481       <span class="comment">/**************************/</span>
<a name="l00482"></a>00482       <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a> Gpoint(<a class="code" href="classAssembleur__P__VEFPreP1B.html#a9a85837c29e80d1bcbc3a7f740f93807">equation</a>().inconnue().valeurs());
<a name="l00483"></a>00483       Gpoint=0.;
<a name="l00484"></a>00484       <span class="keywordtype">int</span> Gpoint_nul = 1; <span class="comment">//!&lt; Drapeau pour economiser potentiellement un echange_espace_virtuel</span>
<a name="l00485"></a>00485 <span class="comment"></span>      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> cond_lim=0; cond_lim&lt;nb_cond_lim; cond_lim++)
<a name="l00486"></a>00486         {
<a name="l00487"></a>00487           <span class="keyword">const</span> <a class="code" href="classCond__lim__base.html" title="classe Cond_lim_base Classe de base pour la hierarchie des classes qui representent les differentes c...">Cond_lim_base</a>&amp; cl_base = zone_Cl.<a class="code" href="classZone__Cl__dis__base.html#af75e0ed7786863e4d333bfb29d67c323" title="Renvoie la i-ieme condition aux limites. (version const)">les_conditions_limites</a>(cond_lim).<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>();
<a name="l00488"></a>00488 
<a name="l00489"></a>00489           <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp; front_VF = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>,cl_base.<a class="code" href="classCond__lim__base.html#ad88b3b516351146c85e8fce1df0f691a" title="Renvoie la frontiere discretisee a laquelle les conditions aux limites s&#39;appliquent.">frontiere_dis</a>());
<a name="l00490"></a>00490           <span class="keyword">const</span> <a class="code" href="classChamp__front__base.html" title="classe Champ_front_base Classe de base pour la hierarchie des champs aux frontieres. Un objet Champ_front_base definit un champ sur la frontiere d&#39;un domaine. Un objet de type Champ_front_base sera associe a chaque condition aux limites. Champ_front_base derive de Champ_Proto, afin d&#39;avoir une interface conforme a tous les champs, et d&#39;heriter des operations courantes sur les Champs. Les deux methodes principales sont initialiser et mettre_a_jour. Ce sont les deux seules qui peuvent modifier les valeurs du champ. La methode initialiser est appelee une fois au debut du calcul. Elle ne doit pas dependre de donnees exterieures a l&#39;equation qui porte la CL (en effet, rien ne garantit que ces donnees sont initialisees). En revanche, les valeurs de l&#39;inconnue sur laquelle porte la CL peuvent etre utiles pour l&#39;initialisation =&gt; l&#39;inconnue est passee en parametre en lecture seule. La methode mettre_a_jour est appelee au debut de chaque pas de temps ou sous-pas-de-temps, elle peut utiliser des donnees exterieures a l&#39;equation. A charge a l&#39;algorithme de s&#39;assurer que ces donnees sont pertinentes... Dans le cas de champs stationnaires, la methode mettre_a_jour n&#39;a rien a faire et les valeurs sont remplies une fois pour toutes par la methode initialiser. Dans le cas de champs instationnaires, il y a plusieurs valeurs en temps et chacune peut etre mise a jour. Les Champ_front sont divises en : * Champ_front_uniforme, constant dans le temps et l&#39;espace * Champ_front_instationnaire_base, uniformes en espace mais variables en temps * Champ_front_var, variables en espace. Les Champ_front_var sont ensuite classes selon qu&#39;ils sont stationnaires ou instationnaires. Les valeurs sont stockees dans une roue de DoubleTab. Si le champ est uniforme en espace, les DoubleTab sont dimensionnes a 1. S&#39;il est stationnaire, la roue n&#39;a qu&#39;une valeur temporelle et le temps qui lui est assigne n&#39;a pas de sens. S&#39;il est instationnaire, les valeurs temporelles sont celles de l&#39;inconnue de l&#39;equation a laquelle se rapporte le champ.">Champ_front_base</a>&amp; champ_front = cl_base.<a class="code" href="classCond__lim__base.html#a8cddc02f544ee44bebd5bae0e6a9581c">champ_front</a>().<a class="code" href="classDeriv__Champ__front__base.html#a5405a20c106b868a23805a45c4436a53">valeur</a>();
<a name="l00491"></a>00491 
<a name="l00492"></a>00492           <span class="keyword">const</span> <span class="keywordtype">int</span> ndeb = front_VF.<a class="code" href="classFront__VF.html#a4986f0c65653fe9eb40bbbff5a97bf16" title="Numero de la premiere face du bord dans la liste des faces.">num_premiere_face</a>();
<a name="l00493"></a>00493           <span class="keyword">const</span> <span class="keywordtype">int</span> nfin = ndeb+front_VF.<a class="code" href="classFront__VF.html#a341e2fcb5117b96e745fd7078ba86bab" title="Nombre de faces reelles du bord.">nb_faces</a>();
<a name="l00494"></a>00494 
<a name="l00495"></a>00495           <span class="comment">/* Test sur la nature du champ au bord du domaine */</span>
<a name="l00496"></a>00496           <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classEntree__fluide__vitesse__imposee.html" title="classe Entree_fluide_vitesse_imposee Cas particulier de la classe Dirichlet_entree_fluide pour la vit...">Entree_fluide_vitesse_imposee</a>, cl_base))
<a name="l00497"></a>00497             {
<a name="l00498"></a>00498               <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classChamp__front__instationnaire__base.html" title="classe Champ_front_base Classe de base pour les Champs aux frontieres instationnaires, mais uniformes en espace. Les aspects temporels sont equivalents a ceux de Ch_front_var_instationnaire. En revanche, le tableau de valeurs est dimensionne a une seule valeur et n&#39;a pas d&#39;espace virtuel.">Champ_front_instationnaire_base</a>,champ_front))
<a name="l00499"></a>00499                 {
<a name="l00500"></a>00500                   Gpoint_nul = 0;
<a name="l00501"></a>00501                   <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; gpoint =
<a name="l00502"></a>00502                     <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classChamp__front__instationnaire__base.html" title="classe Champ_front_base Classe de base pour les Champs aux frontieres instationnaires, mais uniformes en espace. Les aspects temporels sont equivalents a ceux de Ch_front_var_instationnaire. En revanche, le tableau de valeurs est dimensionne a une seule valeur et n&#39;a pas d&#39;espace virtuel.">Champ_front_instationnaire_base</a>,champ_front).Gpoint();
<a name="l00503"></a>00503 
<a name="l00504"></a>00504                   assert(gpoint.<a class="code" href="classDoubleTab.html#ae6dda48778e7107e1beb723beef1f75b" title="Returns the number of dimensions of the array (&gt;= 1)">nb_dim</a>()==1);
<a name="l00505"></a>00505 
<a name="l00506"></a>00506                   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> num_face=ndeb; num_face&lt;nfin; num_face++)
<a name="l00507"></a>00507                     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> dim=0; dim&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>; dim++)
<a name="l00508"></a>00508                       Gpoint(num_face,dim)=porosite_face(num_face)*gpoint(dim);
<a name="l00509"></a>00509 
<a name="l00510"></a>00510                 }<span class="comment">//fin du if sur &quot;sub_type(Champ_front_instationnaire_base)&quot;</span>
<a name="l00511"></a>00511 
<a name="l00512"></a>00512               <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classChamp__front__var__instationnaire.html" title="classe Champ_front_var_instationnaire Classe derivee de Champ_front_var qui represente les champs aux...">Champ_front_var_instationnaire</a>,champ_front))
<a name="l00513"></a>00513                 {
<a name="l00514"></a>00514                   Gpoint_nul = 0;
<a name="l00515"></a>00515                   <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; gpoint =
<a name="l00516"></a>00516                     <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classChamp__front__var__instationnaire.html" title="classe Champ_front_var_instationnaire Classe derivee de Champ_front_var qui represente les champs aux...">Champ_front_var_instationnaire</a>,champ_front).Gpoint();
<a name="l00517"></a>00517 
<a name="l00518"></a>00518                   assert(gpoint.<a class="code" href="classDoubleTab.html#ae6dda48778e7107e1beb723beef1f75b" title="Returns the number of dimensions of the array (&gt;= 1)">nb_dim</a>()==2);
<a name="l00519"></a>00519 
<a name="l00520"></a>00520                   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> num_face=ndeb; num_face&lt;nfin; num_face++)
<a name="l00521"></a>00521                     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> dim=0; dim&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>; dim++)
<a name="l00522"></a>00522                       Gpoint(num_face,dim)=porosite_face(num_face)*gpoint(num_face-ndeb,dim);
<a name="l00523"></a>00523 
<a name="l00524"></a>00524                 }<span class="comment">//fin du if sur &quot;sub_type(Champ_front_var_instationnaire)&quot;</span>
<a name="l00525"></a>00525 
<a name="l00526"></a>00526             }<span class="comment">//fin du if sur &quot;sub_type(Entree_fluide_vitesse_imposee)&quot;</span>
<a name="l00527"></a>00527 
<a name="l00528"></a>00528         }<span class="comment">//fin du for sur &quot;cond_lim&quot;</span>
<a name="l00529"></a>00529 
<a name="l00530"></a>00530 <span class="comment">// Pour le parallele</span>
<a name="l00531"></a>00531       <span class="keywordflow">if</span> (!Gpoint_nul) Gpoint.<a class="code" href="classDoubleVect.html#abfebbc2f685ce7bc4b80c720d7da9bf3">echange_espace_virtuel</a>();
<a name="l00532"></a>00532 
<a name="l00533"></a>00533       <span class="comment">/******************************/</span>
<a name="l00534"></a>00534       <span class="comment">/* Fin recuperation de Gpoint */</span>
<a name="l00535"></a>00535       <span class="comment">/******************************/</span>
<a name="l00536"></a>00536 
<a name="l00537"></a>00537       <span class="comment">/*********************************/</span>
<a name="l00538"></a>00538       <span class="comment">/* Modification du second membre */</span>
<a name="l00539"></a>00539       <span class="comment">/*********************************/</span>
<a name="l00540"></a>00540 
<a name="l00541"></a>00541       <span class="keywordflow">if</span> (zone_VEF.<a class="code" href="classZone__VEF__PreP1b.html#aee2def53aa92584d7945e7c3d0d98963">get_alphaE</a>()) <a class="code" href="classAssembleur__P__VEFPreP1B.html#a68c56f1db1d79a34135f8f46c293dc83">modifier_secmem_elem</a>(Gpoint,b);
<a name="l00542"></a>00542       <span class="keywordflow">if</span> (zone_VEF.<a class="code" href="classZone__VEF__PreP1b.html#ad7fbcb5567dcc2e6f0a0ed85ce90a4fa">get_alphaS</a>()) <a class="code" href="classAssembleur__P__VEFPreP1B.html#a6e9aef242858ae25dde40c58c30791b8">modifier_secmem_som</a>(Gpoint,b);
<a name="l00543"></a>00543       <span class="keywordflow">if</span> (zone_VEF.<a class="code" href="classZone__VEF__PreP1b.html#a9d02e2431efb6e75c3d733ff06f89549">get_alphaA</a>()) <a class="code" href="classAssembleur__P__VEFPreP1B.html#a671dcfc1aa964152dbc04bc5c31d196c">modifier_secmem_aretes</a>(Gpoint,b);
<a name="l00544"></a>00544 
<a name="l00545"></a>00545       <span class="comment">/**********************************/</span>
<a name="l00546"></a>00546       <span class="comment">/* Fin modification second membre */</span>
<a name="l00547"></a>00547       <span class="comment">/**********************************/</span>
<a name="l00548"></a>00548 
<a name="l00549"></a>00549       b.<a class="code" href="classDoubleVect.html#abfebbc2f685ce7bc4b80c720d7da9bf3">echange_espace_virtuel</a>();
<a name="l00550"></a>00550     }
<a name="l00551"></a>00551 
<a name="l00552"></a>00552   <span class="keywordflow">return</span> 1;
<a name="l00553"></a>00553 }
<a name="l00554"></a>00554 
<a name="l00555"></a><a class="code" href="classAssembleur__P__VEFPreP1B.html#a68c56f1db1d79a34135f8f46c293dc83">00555</a> <span class="keywordtype">int</span> <a class="code" href="classAssembleur__P__VEFPreP1B.html#a68c56f1db1d79a34135f8f46c293dc83">Assembleur_P_VEFPreP1B::modifier_secmem_elem</a>(<span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; Gpoint, <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; b)
<a name="l00556"></a>00556 {
<a name="l00557"></a>00557   <span class="keyword">const</span> <a class="code" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a>&amp; zone_VEF =  <a class="code" href="classAssembleur__P__VEFPreP1B.html#a3b4a812a062b850be5966f8c6e201cee">zone_Vef</a>();
<a name="l00558"></a>00558   <span class="keyword">const</span> <a class="code" href="classZone__Cl__VEF.html">Zone_Cl_VEF</a>&amp; zone_Cl = <a class="code" href="classAssembleur__P__VEF.html#af06d2fedcae0282000a96ddd444ec7a2">la_zone_Cl_VEF</a>.<a class="code" href="classRef__Zone__Cl__VEF.html#a0970d7253def65ad4f0c5ce1830fd243">valeur</a>();
<a name="l00559"></a>00559 
<a name="l00560"></a>00560   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_cond_lim = zone_Cl.<a class="code" href="classZone__Cl__dis__base.html#aa6f1df56cfd6e2eae83cc991c7cc9b41" title="Renvoie le nombre de conditions aux limites.">nb_cond_lim</a>();
<a name="l00561"></a>00561 
<a name="l00562"></a>00562   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; face_voisins = zone_VEF.<a class="code" href="classZone__VF.html#a49d4322f5585a8fa95748ca785b70702" title="renvoie l&#39;element voisin de numface dans la direction i. i=0 : dans le sens oppose de l&#39;axe orthogona...">face_voisins</a>();
<a name="l00563"></a>00563   <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; face_normales = zone_VEF.<a class="code" href="classZone__VEF.html#a5742d75972e4846bf9fbb6ed5715053e">face_normales</a>();
<a name="l00564"></a>00564 
<a name="l00565"></a>00565   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> cond_lim=0; cond_lim&lt;nb_cond_lim; cond_lim++)
<a name="l00566"></a>00566     {
<a name="l00567"></a>00567       <span class="keyword">const</span> <a class="code" href="classCond__lim__base.html" title="classe Cond_lim_base Classe de base pour la hierarchie des classes qui representent les differentes c...">Cond_lim_base</a>&amp; cl_base = zone_Cl.<a class="code" href="classZone__Cl__dis__base.html#af75e0ed7786863e4d333bfb29d67c323" title="Renvoie la i-ieme condition aux limites. (version const)">les_conditions_limites</a>(cond_lim).<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>();
<a name="l00568"></a>00568 
<a name="l00569"></a>00569       <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp; front_VF = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>,cl_base.<a class="code" href="classCond__lim__base.html#ad88b3b516351146c85e8fce1df0f691a" title="Renvoie la frontiere discretisee a laquelle les conditions aux limites s&#39;appliquent.">frontiere_dis</a>());
<a name="l00570"></a>00570       <span class="keyword">const</span> <a class="code" href="classChamp__front__base.html" title="classe Champ_front_base Classe de base pour la hierarchie des champs aux frontieres. Un objet Champ_front_base definit un champ sur la frontiere d&#39;un domaine. Un objet de type Champ_front_base sera associe a chaque condition aux limites. Champ_front_base derive de Champ_Proto, afin d&#39;avoir une interface conforme a tous les champs, et d&#39;heriter des operations courantes sur les Champs. Les deux methodes principales sont initialiser et mettre_a_jour. Ce sont les deux seules qui peuvent modifier les valeurs du champ. La methode initialiser est appelee une fois au debut du calcul. Elle ne doit pas dependre de donnees exterieures a l&#39;equation qui porte la CL (en effet, rien ne garantit que ces donnees sont initialisees). En revanche, les valeurs de l&#39;inconnue sur laquelle porte la CL peuvent etre utiles pour l&#39;initialisation =&gt; l&#39;inconnue est passee en parametre en lecture seule. La methode mettre_a_jour est appelee au debut de chaque pas de temps ou sous-pas-de-temps, elle peut utiliser des donnees exterieures a l&#39;equation. A charge a l&#39;algorithme de s&#39;assurer que ces donnees sont pertinentes... Dans le cas de champs stationnaires, la methode mettre_a_jour n&#39;a rien a faire et les valeurs sont remplies une fois pour toutes par la methode initialiser. Dans le cas de champs instationnaires, il y a plusieurs valeurs en temps et chacune peut etre mise a jour. Les Champ_front sont divises en : * Champ_front_uniforme, constant dans le temps et l&#39;espace * Champ_front_instationnaire_base, uniformes en espace mais variables en temps * Champ_front_var, variables en espace. Les Champ_front_var sont ensuite classes selon qu&#39;ils sont stationnaires ou instationnaires. Les valeurs sont stockees dans une roue de DoubleTab. Si le champ est uniforme en espace, les DoubleTab sont dimensionnes a 1. S&#39;il est stationnaire, la roue n&#39;a qu&#39;une valeur temporelle et le temps qui lui est assigne n&#39;a pas de sens. S&#39;il est instationnaire, les valeurs temporelles sont celles de l&#39;inconnue de l&#39;equation a laquelle se rapporte le champ.">Champ_front_base</a>&amp; champ_front = cl_base.<a class="code" href="classCond__lim__base.html#a8cddc02f544ee44bebd5bae0e6a9581c">champ_front</a>().<a class="code" href="classDeriv__Champ__front__base.html#a5405a20c106b868a23805a45c4436a53">valeur</a>();
<a name="l00571"></a>00571 
<a name="l00572"></a>00572       <span class="comment">/* Test sur la nature du champ au bord du domaine */</span>
<a name="l00573"></a>00573       <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classEntree__fluide__vitesse__imposee.html" title="classe Entree_fluide_vitesse_imposee Cas particulier de la classe Dirichlet_entree_fluide pour la vit...">Entree_fluide_vitesse_imposee</a>, cl_base))
<a name="l00574"></a>00574         {
<a name="l00575"></a>00575           <span class="keywordflow">if</span> ( <a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classChamp__front__instationnaire__base.html" title="classe Champ_front_base Classe de base pour les Champs aux frontieres instationnaires, mais uniformes en espace. Les aspects temporels sont equivalents a ceux de Ch_front_var_instationnaire. En revanche, le tableau de valeurs est dimensionne a une seule valeur et n&#39;a pas d&#39;espace virtuel.">Champ_front_instationnaire_base</a>,champ_front) ||
<a name="l00576"></a>00576                <a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classChamp__front__var__instationnaire.html" title="classe Champ_front_var_instationnaire Classe derivee de Champ_front_var qui represente les champs aux...">Champ_front_var_instationnaire</a>,champ_front)
<a name="l00577"></a>00577              )
<a name="l00578"></a>00578 
<a name="l00579"></a>00579             {
<a name="l00580"></a>00580 <span class="comment">// Construction de la liste des faces a traiter (reelles + virtuelles)</span>
<a name="l00581"></a>00581               <span class="keyword">const</span> <span class="keywordtype">int</span> nb_faces_bord_tot = front_VF.<a class="code" href="classFront__VF.html#aed4006d91bf2ef3af2b9f7933d863a09" title="Nombre de faces reelles et virtuelles du bord.">nb_faces_tot</a>();
<a name="l00582"></a>00582 
<a name="l00583"></a>00583               <span class="keywordflow">for</span> (<span class="keywordtype">int</span> ind_face=0; ind_face&lt;nb_faces_bord_tot; ind_face++)
<a name="l00584"></a>00584                 {
<a name="l00585"></a>00585                   <span class="keyword">const</span> <span class="keywordtype">int</span> num_face =  front_VF.<a class="code" href="classFront__VF.html#a3402a19d7e54ed797d2b18e9a47ead1e" title="Renvoie le numero de face de la ieme face du bord.">num_face</a>(ind_face);
<a name="l00586"></a>00586                   <span class="keyword">const</span> <span class="keywordtype">int</span> elem = face_voisins(num_face,0);
<a name="l00587"></a>00587                   assert(elem!=-1);
<a name="l00588"></a>00588 
<a name="l00589"></a>00589                   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> dim=0; dim&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>; dim++)
<a name="l00590"></a>00590                     b(elem)-=Gpoint(num_face,dim)*face_normales(num_face,dim);
<a name="l00591"></a>00591                 }
<a name="l00592"></a>00592             }
<a name="l00593"></a>00593         }
<a name="l00594"></a>00594     }
<a name="l00595"></a>00595 
<a name="l00596"></a>00596   <span class="keywordflow">return</span> 1;
<a name="l00597"></a>00597 }
<a name="l00598"></a>00598 
<a name="l00599"></a><a class="code" href="classAssembleur__P__VEFPreP1B.html#a6e9aef242858ae25dde40c58c30791b8">00599</a> <span class="keywordtype">int</span> <a class="code" href="classAssembleur__P__VEFPreP1B.html#a6e9aef242858ae25dde40c58c30791b8">Assembleur_P_VEFPreP1B::modifier_secmem_som</a>(<span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; Gpoint, <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; b)
<a name="l00600"></a>00600 {
<a name="l00601"></a>00601   <span class="keyword">const</span> <a class="code" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a>&amp; zone_VEF =  <a class="code" href="classAssembleur__P__VEFPreP1B.html#a3b4a812a062b850be5966f8c6e201cee">zone_Vef</a>();
<a name="l00602"></a>00602   <span class="keyword">const</span> <a class="code" href="classZone__Cl__VEF.html">Zone_Cl_VEF</a>&amp; zone_Cl = <a class="code" href="classAssembleur__P__VEF.html#af06d2fedcae0282000a96ddd444ec7a2">la_zone_Cl_VEF</a>.<a class="code" href="classRef__Zone__Cl__VEF.html#a0970d7253def65ad4f0c5ce1830fd243">valeur</a>();
<a name="l00603"></a>00603   <span class="keyword">const</span> <a class="code" href="classZone.html" title="classe Zone Une Zone est un maillage compose d&#39;un ensemble d&#39;elements geometriques de meme type...">Zone</a>&amp; zone = zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>();
<a name="l00604"></a>00604   <span class="keyword">const</span> <a class="code" href="classDomaine.html" title="Classe Domaine Un Domaine represente le domaine (spatial) de resolution d&#39;un Probleme. Un Domaine a un Nom, il est constitue d&#39;une ou plusieurs Zone qui peuvent etre eventuellement decoupees en Sous_Zone. Un Domaine porte l&#39;ensemble des sommets utilises par ses Zones. On peut vouloir resoudre des problemes de type different sur plusieurs domaines, geometriquement les domaines sont alors couples par des surfaces qu&#39;on appelle Raccord.">Domaine</a>&amp; domaine = zone.<a class="code" href="classZone.html#a379ad2206b5a13a4f4f3df6d44c7546a" title="Renvoie le domaine dont la zone fait partie. (version const)">domaine</a>();
<a name="l00605"></a>00605 
<a name="l00606"></a>00606   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_cond_lim = zone_Cl.<a class="code" href="classZone__Cl__dis__base.html#aa6f1df56cfd6e2eae83cc991c7cc9b41" title="Renvoie le nombre de conditions aux limites.">nb_cond_lim</a>();
<a name="l00607"></a>00607   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_elem_tot = (zone_VEF.<a class="code" href="classZone__VEF__PreP1b.html#aee2def53aa92584d7945e7c3d0d98963">get_alphaE</a>()?zone.<a class="code" href="classZone.html#aa3a33e8b723618b9092460007153e42d" title="Renvoie le nombre total d&#39;elements de la zone.">nb_elem_tot</a>():0);
<a name="l00608"></a>00608   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_faces_elem = zone.<a class="code" href="classZone.html#a548fbc7518be2f122b1a5c9589a443c2" title="Renvoie le nombre de face de type i des elements geometriques constituants la zone. Ex: les objets de la classe Prisme ont 2 types de faces: triangle ou quadrangle.">nb_faces_elem</a>();
<a name="l00609"></a>00609 
<a name="l00610"></a>00610   <span class="keyword">const</span> <span class="keywordtype">double</span> coeff_dim = <a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>*(<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>+1);
<a name="l00611"></a>00611 
<a name="l00612"></a>00612   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; elem_faces = zone_VEF.<a class="code" href="classZone__VF.html#a067e462dcd3ab92b0f6d945b19e4eb37" title="renvoie le numero de le ieme face de la maille num_elem la facon dont ces faces sont numerotees est l...">elem_faces</a>();
<a name="l00613"></a>00613   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; face_sommets = zone_VEF.<a class="code" href="classZone__VF.html#a298e73b18e17da55f421b1fb0879bd46" title="renvoie le numero du ieme sommet de la face num_face.">face_sommets</a>();
<a name="l00614"></a>00614   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; face_voisins = zone_VEF.<a class="code" href="classZone__VF.html#a49d4322f5585a8fa95748ca785b70702" title="renvoie l&#39;element voisin de numface dans la direction i. i=0 : dans le sens oppose de l&#39;axe orthogona...">face_voisins</a>();
<a name="l00615"></a>00615   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; elem_sommets = zone.<a class="code" href="classZone.html#ac115e8342be89afb882b7b61cc343267" title="Renvoie le tableau des sommets des elements.">les_elems</a>();
<a name="l00616"></a>00616 
<a name="l00617"></a>00617   <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; face_normales = zone_VEF.<a class="code" href="classZone__VEF.html#a5742d75972e4846bf9fbb6ed5715053e">face_normales</a>();
<a name="l00618"></a>00618   <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a> sigma(<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>);
<a name="l00619"></a>00619 
<a name="l00620"></a>00620   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> cond_lim=0; cond_lim&lt;nb_cond_lim; cond_lim++)
<a name="l00621"></a>00621     {
<a name="l00622"></a>00622       <span class="keyword">const</span> <a class="code" href="classCond__lim__base.html" title="classe Cond_lim_base Classe de base pour la hierarchie des classes qui representent les differentes c...">Cond_lim_base</a>&amp; cl_base = zone_Cl.<a class="code" href="classZone__Cl__dis__base.html#af75e0ed7786863e4d333bfb29d67c323" title="Renvoie la i-ieme condition aux limites. (version const)">les_conditions_limites</a>(cond_lim).<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>();
<a name="l00623"></a>00623 
<a name="l00624"></a>00624       <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp; front_VF = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>,cl_base.<a class="code" href="classCond__lim__base.html#ad88b3b516351146c85e8fce1df0f691a" title="Renvoie la frontiere discretisee a laquelle les conditions aux limites s&#39;appliquent.">frontiere_dis</a>());
<a name="l00625"></a>00625       <span class="keyword">const</span> <a class="code" href="classChamp__front__base.html" title="classe Champ_front_base Classe de base pour la hierarchie des champs aux frontieres. Un objet Champ_front_base definit un champ sur la frontiere d&#39;un domaine. Un objet de type Champ_front_base sera associe a chaque condition aux limites. Champ_front_base derive de Champ_Proto, afin d&#39;avoir une interface conforme a tous les champs, et d&#39;heriter des operations courantes sur les Champs. Les deux methodes principales sont initialiser et mettre_a_jour. Ce sont les deux seules qui peuvent modifier les valeurs du champ. La methode initialiser est appelee une fois au debut du calcul. Elle ne doit pas dependre de donnees exterieures a l&#39;equation qui porte la CL (en effet, rien ne garantit que ces donnees sont initialisees). En revanche, les valeurs de l&#39;inconnue sur laquelle porte la CL peuvent etre utiles pour l&#39;initialisation =&gt; l&#39;inconnue est passee en parametre en lecture seule. La methode mettre_a_jour est appelee au debut de chaque pas de temps ou sous-pas-de-temps, elle peut utiliser des donnees exterieures a l&#39;equation. A charge a l&#39;algorithme de s&#39;assurer que ces donnees sont pertinentes... Dans le cas de champs stationnaires, la methode mettre_a_jour n&#39;a rien a faire et les valeurs sont remplies une fois pour toutes par la methode initialiser. Dans le cas de champs instationnaires, il y a plusieurs valeurs en temps et chacune peut etre mise a jour. Les Champ_front sont divises en : * Champ_front_uniforme, constant dans le temps et l&#39;espace * Champ_front_instationnaire_base, uniformes en espace mais variables en temps * Champ_front_var, variables en espace. Les Champ_front_var sont ensuite classes selon qu&#39;ils sont stationnaires ou instationnaires. Les valeurs sont stockees dans une roue de DoubleTab. Si le champ est uniforme en espace, les DoubleTab sont dimensionnes a 1. S&#39;il est stationnaire, la roue n&#39;a qu&#39;une valeur temporelle et le temps qui lui est assigne n&#39;a pas de sens. S&#39;il est instationnaire, les valeurs temporelles sont celles de l&#39;inconnue de l&#39;equation a laquelle se rapporte le champ.">Champ_front_base</a>&amp; champ_front = cl_base.<a class="code" href="classCond__lim__base.html#a8cddc02f544ee44bebd5bae0e6a9581c">champ_front</a>().<a class="code" href="classDeriv__Champ__front__base.html#a5405a20c106b868a23805a45c4436a53">valeur</a>();
<a name="l00626"></a>00626 
<a name="l00627"></a>00627       <span class="comment">/* Test sur la nature du champ au bord du domaine */</span>
<a name="l00628"></a>00628       <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classEntree__fluide__vitesse__imposee.html" title="classe Entree_fluide_vitesse_imposee Cas particulier de la classe Dirichlet_entree_fluide pour la vit...">Entree_fluide_vitesse_imposee</a>, cl_base))
<a name="l00629"></a>00629         {
<a name="l00630"></a>00630           <span class="keywordflow">if</span> ( <a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classChamp__front__instationnaire__base.html" title="classe Champ_front_base Classe de base pour les Champs aux frontieres instationnaires, mais uniformes en espace. Les aspects temporels sont equivalents a ceux de Ch_front_var_instationnaire. En revanche, le tableau de valeurs est dimensionne a une seule valeur et n&#39;a pas d&#39;espace virtuel.">Champ_front_instationnaire_base</a>,champ_front) ||
<a name="l00631"></a>00631                <a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classChamp__front__var__instationnaire.html" title="classe Champ_front_var_instationnaire Classe derivee de Champ_front_var qui represente les champs aux...">Champ_front_var_instationnaire</a>,champ_front)
<a name="l00632"></a>00632              )
<a name="l00633"></a>00633 
<a name="l00634"></a>00634             {
<a name="l00635"></a>00635 <span class="comment">// Construction de la liste des faces a traiter (reelles + virtuelles)</span>
<a name="l00636"></a>00636               <span class="keyword">const</span> <span class="keywordtype">int</span> nb_faces_bord_tot = front_VF.<a class="code" href="classFront__VF.html#aed4006d91bf2ef3af2b9f7933d863a09" title="Nombre de faces reelles et virtuelles du bord.">nb_faces_tot</a>();
<a name="l00637"></a>00637 
<a name="l00638"></a>00638               <span class="keywordflow">for</span> (<span class="keywordtype">int</span> ind_face=0; ind_face&lt;nb_faces_bord_tot; ind_face++)
<a name="l00639"></a>00639                 {
<a name="l00640"></a>00640                   <span class="keyword">const</span> <span class="keywordtype">int</span> num_face =  front_VF.<a class="code" href="classFront__VF.html#a3402a19d7e54ed797d2b18e9a47ead1e" title="Renvoie le numero de face de la ieme face du bord.">num_face</a>(ind_face);
<a name="l00641"></a>00641                   <span class="keyword">const</span> <span class="keywordtype">int</span> elem = face_voisins(num_face,0);
<a name="l00642"></a>00642                   assert(elem!=-1);
<a name="l00643"></a>00643 
<a name="l00644"></a>00644 <span class="comment">// Calcul de la vitesse au centre de l&#39;element</span>
<a name="l00645"></a>00645                   sigma=0.;
<a name="l00646"></a>00646                   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> face_loc=0; face_loc&lt;nb_faces_elem; face_loc++)
<a name="l00647"></a>00647                     {
<a name="l00648"></a>00648                       <span class="keyword">const</span> <span class="keywordtype">int</span> face = elem_faces(elem,face_loc);
<a name="l00649"></a>00649 
<a name="l00650"></a>00650                       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> comp=0; comp&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; comp++)
<a name="l00651"></a>00651                         sigma[comp]+=Gpoint(face,comp);
<a name="l00652"></a>00652                     }
<a name="l00653"></a>00653 
<a name="l00654"></a>00654 <span class="comment">// Calcul de la divergence de la vitesse</span>
<a name="l00655"></a>00655                   <span class="keywordflow">for</span>(<span class="keywordtype">int</span> face_loc=0; face_loc&lt;nb_faces_elem; face_loc++)
<a name="l00656"></a>00656                     {
<a name="l00657"></a>00657                       <span class="keyword">const</span> <span class="keywordtype">int</span> som = nb_elem_tot+domaine.<a class="code" href="classDomaine.html#a37cc657f1907d53b0d5a573da862af80">get_renum_som_perio</a>(elem_sommets(elem,face_loc));
<a name="l00658"></a>00658                       <span class="keyword">const</span> <span class="keywordtype">int</span> face = elem_faces(elem,face_loc);
<a name="l00659"></a>00659 
<a name="l00660"></a>00660                       <span class="keywordtype">double</span> psc=0;
<a name="l00661"></a>00661                       <span class="keywordtype">double</span> signe=1.;
<a name="l00662"></a>00662                       <span class="keywordflow">if</span>(elem!=face_voisins(face,0)) signe=-1.;
<a name="l00663"></a>00663 
<a name="l00664"></a>00664                       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> comp=0; comp&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; comp++)
<a name="l00665"></a>00665                         psc+=sigma[comp]*face_normales(face,comp);
<a name="l00666"></a>00666 
<a name="l00667"></a>00667                       b(som)-=signe*psc/coeff_dim;
<a name="l00668"></a>00668                     }
<a name="l00669"></a>00669 
<a name="l00670"></a>00670                   <span class="keywordtype">double</span> flux = 0. ;
<a name="l00671"></a>00671                   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> comp=0; comp&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; comp++)
<a name="l00672"></a>00672                     flux += Gpoint(num_face,comp) * face_normales(num_face,comp) ;
<a name="l00673"></a>00673 
<a name="l00674"></a>00674                   flux*=1./<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>;
<a name="l00675"></a>00675                   <span class="keywordflow">for</span>(<span class="keywordtype">int</span> som_loc=0; som_loc&lt;nb_faces_elem-1; som_loc++)
<a name="l00676"></a>00676                     {
<a name="l00677"></a>00677                       <span class="keyword">const</span> <span class="keywordtype">int</span> som=domaine.<a class="code" href="classDomaine.html#a37cc657f1907d53b0d5a573da862af80">get_renum_som_perio</a>(face_sommets(num_face,som_loc));
<a name="l00678"></a>00678                       b(nb_elem_tot+som)-=flux;
<a name="l00679"></a>00679                     }
<a name="l00680"></a>00680 <span class="comment">// Fin du calcul de la divergence de la vitesse</span>
<a name="l00681"></a>00681 
<a name="l00682"></a>00682                 }
<a name="l00683"></a>00683 
<a name="l00684"></a>00684             }
<a name="l00685"></a>00685         }
<a name="l00686"></a>00686     }
<a name="l00687"></a>00687 
<a name="l00688"></a>00688   <span class="keywordflow">return</span> 1;
<a name="l00689"></a>00689 }
<a name="l00690"></a>00690 
<a name="l00691"></a><a class="code" href="classAssembleur__P__VEFPreP1B.html#a671dcfc1aa964152dbc04bc5c31d196c">00691</a> <span class="keywordtype">int</span> <a class="code" href="classAssembleur__P__VEFPreP1B.html#a671dcfc1aa964152dbc04bc5c31d196c">Assembleur_P_VEFPreP1B::modifier_secmem_aretes</a>(<span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; Gpoint, <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; b)
<a name="l00692"></a>00692 {
<a name="l00693"></a>00693   <span class="keywordflow">return</span> 1;
<a name="l00694"></a>00694 }
<a name="l00695"></a>00695 
<a name="l00696"></a><a class="code" href="classAssembleur__P__VEFPreP1B.html#a2925a6f043f3422988739a550efb9a4d">00696</a> <span class="keywordtype">int</span> <a class="code" href="classAssembleur__P__VEFPreP1B.html#a2925a6f043f3422988739a550efb9a4d">Assembleur_P_VEFPreP1B::modifier_solution</a>(<a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; pression)
<a name="l00697"></a>00697 {
<a name="l00698"></a>00698 
<a name="l00699"></a>00699 <span class="comment">// if (!has_P_ref) exit();</span>
<a name="l00700"></a>00700   <span class="keyword">const</span> <a class="code" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a>&amp; la_zone = <a class="code" href="classAssembleur__P__VEFPreP1B.html#a3b4a812a062b850be5966f8c6e201cee">zone_Vef</a>();
<a name="l00701"></a>00701 
<a name="l00702"></a>00702 <span class="comment">// Verification sur les aretes</span>
<a name="l00703"></a>00703   <span class="keywordflow">if</span> (la_zone.<a class="code" href="classZone__VEF__PreP1b.html#a9d02e2431efb6e75c3d733ff06f89549">get_alphaA</a>())
<a name="l00704"></a>00704     {
<a name="l00705"></a>00705 <span class="comment">// On impose la pression a 0 sur les aretes superflues:</span>
<a name="l00706"></a>00706       <span class="keyword">const</span> <a class="code" href="classIntVect.html">IntVect</a>&amp; ok_arete=la_zone.<a class="code" href="classZone__VEF__PreP1b.html#a83771f784d487e346b2ef22a389472a2">get_ok_arete</a>();
<a name="l00707"></a>00707       <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; renum_arete_perio=la_zone.<a class="code" href="classZone__VEF__PreP1b.html#a43767f8684512d1ee950dc07eea76c5b">get_renum_arete_perio</a>();
<a name="l00708"></a>00708 <span class="comment">// Nombre d&#39;aretes reelles</span>
<a name="l00709"></a>00709       <span class="keywordtype">int</span> nb_aretes=ok_arete.<a class="code" href="classIntVect.html#ad90cfd411cbbd631ccf1935bb36f7c40" title="Identique a size_reelle()">size</a>();
<a name="l00710"></a>00710       <span class="keywordtype">int</span> npa=la_zone.<a class="code" href="classZone__VEF__PreP1b.html#aa0033e533851a80e958050a0b892e9a8">numero_premiere_arete</a>();
<a name="l00711"></a>00711       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;nb_aretes; i++)
<a name="l00712"></a>00712         {
<a name="l00713"></a>00713           <span class="keywordflow">if</span>(!ok_arete(i) &amp;&amp; pression(npa+i)!=0.)
<a name="l00714"></a>00714             {
<a name="l00715"></a>00715               <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Pb pression arete superflue, P(&quot;</span> &lt;&lt; npa+i &lt;&lt; <span class="stringliteral">&quot;)=&quot;</span> &lt;&lt; pression(npa+i) &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
<a name="l00716"></a>00716               pression(npa+i)=0;
<a name="l00717"></a>00717               <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">Process::exit</a>();
<a name="l00718"></a>00718             }
<a name="l00719"></a>00719           <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( (renum_arete_perio(i)!=i) &amp;&amp; pression(npa+i)!=0.)
<a name="l00720"></a>00720             {
<a name="l00721"></a>00721               <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Pb pression arete superflue periodique, P(&quot;</span> &lt;&lt; npa+i &lt;&lt; <span class="stringliteral">&quot;)=&quot;</span> &lt;&lt; pression(npa+i) &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
<a name="l00722"></a>00722               pression(npa+i)=0;
<a name="l00723"></a>00723               <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">Process::exit</a>();
<a name="l00724"></a>00724             }
<a name="l00725"></a>00725         }
<a name="l00726"></a>00726     }
<a name="l00727"></a>00727 
<a name="l00728"></a>00728 <span class="comment">// On applique la periodicite sur les sommets pour la pression:</span>
<a name="l00729"></a>00729   <span class="keywordflow">if</span> (la_zone.<a class="code" href="classZone__VEF__PreP1b.html#ad7fbcb5567dcc2e6f0a0ed85ce90a4fa">get_alphaS</a>())
<a name="l00730"></a>00730     {
<a name="l00731"></a>00731       <span class="keyword">const</span> <a class="code" href="classDomaine.html" title="Classe Domaine Un Domaine represente le domaine (spatial) de resolution d&#39;un Probleme. Un Domaine a un Nom, il est constitue d&#39;une ou plusieurs Zone qui peuvent etre eventuellement decoupees en Sous_Zone. Un Domaine porte l&#39;ensemble des sommets utilises par ses Zones. On peut vouloir resoudre des problemes de type different sur plusieurs domaines, geometriquement les domaines sont alors couples par des surfaces qu&#39;on appelle Raccord.">Domaine</a>&amp; dom=la_zone.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#a379ad2206b5a13a4f4f3df6d44c7546a" title="Renvoie le domaine dont la zone fait partie. (version const)">domaine</a>();
<a name="l00732"></a>00732       <span class="keywordtype">int</span> nps=la_zone.<a class="code" href="classZone__VEF__PreP1b.html#ab469e7b0d67ddcc27e5cf16c3c85e8f4">numero_premier_sommet</a>();
<a name="l00733"></a>00733       <span class="keywordtype">int</span> ns=la_zone.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#ad340f571f81fa5c2e028b88c00b5c2ca" title="Renvoie le nombre de sommets de la zone.">nb_som</a>();
<a name="l00734"></a>00734       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;ns; i++)
<a name="l00735"></a>00735         {
<a name="l00736"></a>00736           <span class="keywordtype">int</span> k=dom.<a class="code" href="classDomaine.html#a37cc657f1907d53b0d5a573da862af80">get_renum_som_perio</a>(i);
<a name="l00737"></a>00737           <span class="keywordflow">if</span> (k!=i) pression(nps+i)=pression(nps+k);
<a name="l00738"></a>00738         }
<a name="l00739"></a>00739     }
<a name="l00740"></a>00740 <span class="comment">// pression.echange_espace_virtuel();</span>
<a name="l00741"></a>00741 <span class="comment">// pour retirer le min de la pression si pas de Pref et si que PO sinon on filtre plus tard</span>
<a name="l00742"></a>00742   <span class="keywordflow">if</span> (la_zone.<a class="code" href="classZone__VEF__PreP1b.html#aee2def53aa92584d7945e7c3d0d98963">get_alphaE</a>() &amp;&amp; (la_zone.<a class="code" href="classZone__VEF__PreP1b.html#ad7fbcb5567dcc2e6f0a0ed85ce90a4fa">get_alphaS</a>()==0) &amp;&amp; (la_zone.<a class="code" href="classZone__VEF__PreP1b.html#a9d02e2431efb6e75c3d733ff06f89549">get_alphaA</a>()==0) )
<a name="l00743"></a>00743     <a class="code" href="classAssembleur__P__VEFPreP1B.html#a2925a6f043f3422988739a550efb9a4d">Assembleur_P_VEF::modifier_solution</a>( pression);
<a name="l00744"></a>00744 <span class="comment">// Verification possible par variable d&#39;environnement:</span>
<a name="l00745"></a>00745   <span class="keywordtype">char</span>* theValue = getenv(<span class="stringliteral">&quot;TRUST_VERIFIE_DIRICHLET&quot;</span>);
<a name="l00746"></a>00746   <span class="keywordflow">if</span>(theValue != NULL) <a class="code" href="classAssembleur__P__VEFPreP1B.html#acdeef94a4da9a426b6baf0042d9bf2b6">verifier_dirichlet</a>();
<a name="l00747"></a>00747 
<a name="l00748"></a>00748   <span class="keywordflow">return</span> 1;
<a name="l00749"></a>00749 }
<a name="l00750"></a>00750 
<a name="l00751"></a><a class="code" href="classAssembleur__P__VEFPreP1B.html#acdeef94a4da9a426b6baf0042d9bf2b6">00751</a> <span class="keywordtype">void</span> <a class="code" href="classAssembleur__P__VEFPreP1B.html#acdeef94a4da9a426b6baf0042d9bf2b6">Assembleur_P_VEFPreP1B::verifier_dirichlet</a>()
<a name="l00752"></a>00752 {
<a name="l00753"></a>00753   <span class="keywordflow">if</span> (<a class="code" href="classAssembleur__P__VEFPreP1B.html#a3b4a812a062b850be5966f8c6e201cee">zone_Vef</a>().get_alphaE()+<a class="code" href="classAssembleur__P__VEFPreP1B.html#a3b4a812a062b850be5966f8c6e201cee">zone_Vef</a>().get_alphaS()+<a class="code" href="classAssembleur__P__VEFPreP1B.html#a3b4a812a062b850be5966f8c6e201cee">zone_Vef</a>().get_alphaA()!=<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>)
<a name="l00754"></a>00754     {
<a name="l00755"></a>00755       <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Assembleur_P_VEFPreP1B::verifier_dirichlet ne fonctionne pas encore avec votre discretisation&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
<a name="l00756"></a>00756       <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">Process::exit</a>();
<a name="l00757"></a>00757     }
<a name="l00758"></a>00758 <span class="comment">// Verifications diverses des conditions limites</span>
<a name="l00759"></a>00759 <span class="comment">// en postraitant le resultat dans le champ Divergence_U</span>
<a name="l00760"></a>00760   <a class="code" href="classIntVect.html">IntVect</a> Faces_de_Dirichlet(<a class="code" href="classAssembleur__P__VEFPreP1B.html#a3b4a812a062b850be5966f8c6e201cee">zone_Vef</a>().nb_elem_tot());
<a name="l00761"></a>00761   <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a> faces(<a class="code" href="classAssembleur__P__VEFPreP1B.html#a3b4a812a062b850be5966f8c6e201cee">zone_Vef</a>().nb_elem_tot(),2);
<a name="l00762"></a>00762   faces=-1;
<a name="l00763"></a>00763   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; face_sommets=<a class="code" href="classAssembleur__P__VEFPreP1B.html#a3b4a812a062b850be5966f8c6e201cee">zone_Vef</a>().<a class="code" href="classZone__VF.html#a298e73b18e17da55f421b1fb0879bd46" title="renvoie le numero du ieme sommet de la face num_face.">face_sommets</a>();
<a name="l00764"></a>00764   Faces_de_Dirichlet=0;
<a name="l00765"></a>00765   <span class="keyword">const</span> <a class="code" href="classConds__lim.html">Conds_lim</a>&amp; les_cl = <a class="code" href="classAssembleur__P__VEF.html#af06d2fedcae0282000a96ddd444ec7a2">la_zone_Cl_VEF</a>.<a class="code" href="classRef__Zone__Cl__VEF.html#a0970d7253def65ad4f0c5ce1830fd243">valeur</a>().<a class="code" href="classZone__Cl__dis__base.html#af75e0ed7786863e4d333bfb29d67c323" title="Renvoie la i-ieme condition aux limites. (version const)">les_conditions_limites</a>();
<a name="l00766"></a>00766   <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;les_cl.<a class="code" href="classvect__impl.html#a78155bfbd6b61f4710b9830641ed1694">size</a>(); i++)
<a name="l00767"></a>00767     {
<a name="l00768"></a>00768       <span class="keyword">const</span> <a class="code" href="classCond__lim.html" title="classe Cond_lim Classe generique servant a representer n&#39;importe quelle classe derivee de la classe C...">Cond_lim</a>&amp; la_cl = les_cl[i];
<a name="l00769"></a>00769       <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp; le_bord = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>,la_cl.<a class="code" href="classCond__lim.html#a5b2d24809cee07727006a891d4ce8d22" title="Appel a l&#39;objet sous-jacent Renvoie la frontiere discretisee associee a la condition aux limites...">frontiere_dis</a>());
<a name="l00770"></a>00770       <span class="keywordtype">int</span> num1 = le_bord.<a class="code" href="classFront__VF.html#a4986f0c65653fe9eb40bbbff5a97bf16" title="Numero de la premiere face du bord dans la liste des faces.">num_premiere_face</a>();
<a name="l00771"></a>00771       <span class="keywordtype">int</span> num2 = num1 + le_bord.<a class="code" href="classFront__VF.html#a341e2fcb5117b96e745fd7078ba86bab" title="Nombre de faces reelles du bord.">nb_faces</a>();
<a name="l00772"></a>00772       <span class="keywordflow">if</span> ((<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classDirichlet.html" title="classe Dirichlet Cette classe est la classe de base de la hierarchie des conditions aux limites de ty...">Dirichlet</a>, la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>()))
<a name="l00773"></a>00773           || (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classDirichlet__homogene.html" title="Classe Dirichlet_homogene Cette classe est la classe de base de la hierarchie des conditions aux limi...">Dirichlet_homogene</a>, la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>())))
<a name="l00774"></a>00774         {
<a name="l00775"></a>00775           <span class="keywordflow">for</span> (<span class="keywordtype">int</span> face=num1; face&lt;num2; face++)
<a name="l00776"></a>00776             {
<a name="l00777"></a>00777               <span class="keywordtype">int</span> elem=<a class="code" href="classAssembleur__P__VEFPreP1B.html#a3b4a812a062b850be5966f8c6e201cee">zone_Vef</a>().<a class="code" href="classZone__VF.html#a49d4322f5585a8fa95748ca785b70702" title="renvoie l&#39;element voisin de numface dans la direction i. i=0 : dans le sens oppose de l&#39;axe orthogona...">face_voisins</a>(face,0);
<a name="l00778"></a>00778               <span class="keywordflow">if</span> (elem!=-1)
<a name="l00779"></a>00779                 {
<a name="l00780"></a>00780                   Faces_de_Dirichlet(elem)++;
<a name="l00781"></a>00781                   <span class="keywordflow">if</span> (faces(elem,0)==-1) faces(elem,0)=face;
<a name="l00782"></a>00782                   <span class="keywordflow">else</span> faces(elem,1)=face;
<a name="l00783"></a>00783 
<a name="l00784"></a>00784                 }
<a name="l00785"></a>00785               elem=<a class="code" href="classAssembleur__P__VEFPreP1B.html#a3b4a812a062b850be5966f8c6e201cee">zone_Vef</a>().<a class="code" href="classZone__VF.html#a49d4322f5585a8fa95748ca785b70702" title="renvoie l&#39;element voisin de numface dans la direction i. i=0 : dans le sens oppose de l&#39;axe orthogona...">face_voisins</a>(face,1);
<a name="l00786"></a>00786               <span class="keywordflow">if</span> (elem!=-1) Faces_de_Dirichlet(elem)++;
<a name="l00787"></a>00787             }
<a name="l00788"></a>00788         }
<a name="l00789"></a>00789     }
<a name="l00790"></a>00790   <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; post=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classNavier__Stokes__std.html" title="classe Navier_Stokes_std Cette classe porte les termes de l&#39;equation de la dynamique pour un fluide s...">Navier_Stokes_std</a>,<a class="code" href="classAssembleur__P__VEFPreP1B.html#a75f504c4171787bdeb487a8dd98e2a00">mon_equation</a>.<a class="code" href="classRef__Equation__base.html#a7bb6fb60cb55bef0eef1b0e8718300a4">valeur</a>()).div().valeurs();
<a name="l00791"></a>00791   post=0;
<a name="l00792"></a>00792   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> elem=0; elem&lt;Faces_de_Dirichlet.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>(); elem++)
<a name="l00793"></a>00793     {
<a name="l00794"></a>00794 <span class="comment">// post(elem)=Faces_de_Dirichlet(elem);</span>
<a name="l00795"></a>00795       <span class="keywordflow">if</span> (Faces_de_Dirichlet(elem)&gt;1)
<a name="l00796"></a>00796         {
<a name="l00797"></a>00797           <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;L&#39;element &quot;</span> &lt;&lt; elem &lt;&lt; <span class="stringliteral">&quot; a &quot;</span> &lt;&lt; Faces_de_Dirichlet(elem) &lt;&lt; <span class="stringliteral">&quot; faces de Dirichlet separees par une &quot;</span>;
<a name="l00798"></a>00798           <span class="keyword">const</span> <a class="code" href="classIntVect.html">IntVect</a>&amp; ok_arete=<a class="code" href="classAssembleur__P__VEFPreP1B.html#a3b4a812a062b850be5966f8c6e201cee">zone_Vef</a>().<a class="code" href="classZone__VEF__PreP1b.html#a83771f784d487e346b2ef22a389472a2">get_ok_arete</a>();
<a name="l00799"></a>00799           <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; aretes_som=<a class="code" href="classAssembleur__P__VEFPreP1B.html#a3b4a812a062b850be5966f8c6e201cee">zone_Vef</a>().<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#affa60690e1b372fa4c01d6088267dbe4" title="renvoie le tableau de connectivite aretes/sommets.">aretes_som</a>();
<a name="l00800"></a>00800 <span class="comment">// Parcours des aretes pour verifier les aretes de bord</span>
<a name="l00801"></a>00801           <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k=0; k&lt;6; k++)
<a name="l00802"></a>00802             {
<a name="l00803"></a>00803               <span class="keywordtype">int</span> arete=<a class="code" href="classAssembleur__P__VEFPreP1B.html#a3b4a812a062b850be5966f8c6e201cee">zone_Vef</a>().<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#a1e1e86ef5b088c4d33d42cd38a967b4a" title="renvoie le numero de la jeme arete du ieme element.">elem_aretes</a>(elem,k);
<a name="l00804"></a>00804 <span class="comment">// Les 2 sommets de l&#39;arete</span>
<a name="l00805"></a>00805               <span class="keywordtype">int</span> S0=aretes_som(arete,0);
<a name="l00806"></a>00806               <span class="keywordtype">int</span> S1=aretes_som(arete,1);
<a name="l00807"></a>00807 <span class="comment">// On verifie s&#39;ils sont 2 fois dans les sommets des faces</span>
<a name="l00808"></a>00808 <span class="comment">// auquels cas c&#39;est l&#39;arete qui partage 2 faces de Dirichlet</span>
<a name="l00809"></a>00809               <span class="keywordtype">int</span> ok=0;
<a name="l00810"></a>00810               <span class="keywordflow">for</span> (<span class="keywordtype">int</span> l=0; l&lt;2; l++)
<a name="l00811"></a>00811                 {
<a name="l00812"></a>00812                   <span class="keywordtype">int</span> face=faces(elem,l);
<a name="l00813"></a>00813                   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> s=0; s&lt;3; s++)
<a name="l00814"></a>00814                     {
<a name="l00815"></a>00815                       <span class="keywordflow">if</span> (face_sommets(face,s)==S0) ok++;
<a name="l00816"></a>00816                       <span class="keywordflow">if</span> (face_sommets(face,s)==S1) ok++;
<a name="l00817"></a>00817                     }
<a name="l00818"></a>00818                 }
<a name="l00819"></a>00819               <span class="keywordflow">if</span> (ok==4) <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;arete &quot;</span> &lt;&lt; (ok_arete(arete)==0?<span class="stringliteral">&quot;superflue&quot;</span>:<span class="stringliteral">&quot;&quot;</span>) &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
<a name="l00820"></a>00820 <span class="comment">// On compte les aretes superflues</span>
<a name="l00821"></a>00821               post(elem)+=(ok_arete(arete)==0);
<a name="l00822"></a>00822             }
<a name="l00823"></a>00823 <span class="comment">// Process::exit();</span>
<a name="l00824"></a>00824         }
<a name="l00825"></a>00825     }
<a name="l00826"></a>00826 }
<a name="l00827"></a>00827 
<a name="l00828"></a><a class="code" href="classAssembleur__P__VEFPreP1B.html#ad322061530a77e3541d562700b900641">00828</a> <span class="keywordtype">void</span> <a class="code" href="classAssembleur__P__VEFPreP1B.html#ad322061530a77e3541d562700b900641">Assembleur_P_VEFPreP1B::projete_L2</a>(<a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; pression)
<a name="l00829"></a>00829 {
<a name="l00830"></a>00830   <span class="keywordflow">if</span> (<a class="code" href="classAssembleur__P__VEFPreP1B.html#a3b4a812a062b850be5966f8c6e201cee">zone_Vef</a>().get_alphaE()+<a class="code" href="classAssembleur__P__VEFPreP1B.html#a3b4a812a062b850be5966f8c6e201cee">zone_Vef</a>().get_alphaS()+<a class="code" href="classAssembleur__P__VEFPreP1B.html#a3b4a812a062b850be5966f8c6e201cee">zone_Vef</a>().get_alphaA()!=3)
<a name="l00831"></a>00831     {
<a name="l00832"></a>00832       <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Assembleur_P_VEFPreP1B::projete_L2 ne fonctionne qu&#39;en P0+P1+Pa&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
<a name="l00833"></a>00833       <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">Process::exit</a>();
<a name="l00834"></a>00834     }
<a name="l00835"></a>00835 <span class="comment">// Cerr &lt;&lt; &quot;Projection L2&quot; &lt;&lt; finl;</span>
<a name="l00836"></a>00836   <span class="keyword">const</span> <a class="code" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a>&amp; zone_vef = <a class="code" href="classAssembleur__P__VEFPreP1B.html#a3b4a812a062b850be5966f8c6e201cee">zone_Vef</a>();
<a name="l00837"></a>00837   <span class="keyword">const</span> <a class="code" href="classZone.html" title="classe Zone Une Zone est un maillage compose d&#39;un ensemble d&#39;elements geometriques de meme type...">Zone</a>&amp; zone = zone_vef.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>();
<a name="l00838"></a>00838   <span class="keywordtype">int</span> nb_elem_tot=zone.<a class="code" href="classZone.html#aa3a33e8b723618b9092460007153e42d" title="Renvoie le nombre total d&#39;elements de la zone.">nb_elem_tot</a>();
<a name="l00839"></a>00839   <span class="keywordtype">int</span> ns=zone.<a class="code" href="classZone.html#a01ed67af826d6045ef4eacfb87a663e8" title="Renvoie le nombre total de sommets de la zone. i.e. le nombre de sommets reels et virtuels sur le pro...">nb_som_tot</a>();
<a name="l00840"></a>00840   <span class="keywordtype">int</span> nb_elem=zone.<a class="code" href="classZone.html#a7f249429803b27139a1c54436f6164a5" title="Renvoie le nombre d&#39;elements de la zone.">nb_elem</a>();
<a name="l00841"></a>00841   <span class="keywordtype">int</span> i,j;
<a name="l00842"></a>00842   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; som_elem=zone_vef.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#ac115e8342be89afb882b7b61cc343267" title="Renvoie le tableau des sommets des elements.">les_elems</a>();
<a name="l00843"></a>00843   <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; volumes=zone_vef.<a class="code" href="classZone__VF.html#aea771c835e561469d2d21dbca5fac1cf" title="renvoie le volume de la maille i.">volumes</a>();
<a name="l00844"></a>00844   <span class="keywordtype">double</span> volume_tot=0;
<a name="l00845"></a>00845   <span class="keywordtype">double</span> somme=0;
<a name="l00846"></a>00846   <span class="keywordtype">int</span> nsr=nb_elem_tot+ns;
<a name="l00847"></a>00847   <span class="keywordtype">int</span> nse=zone.<a class="code" href="classZone.html#ae0b34a93b9ae8146df2d1884157afe9f" title="Renvoie le nombre de sommets des elements geometriques constituants la zone. Tous les elements de la ...">nb_som_elem</a>();
<a name="l00848"></a>00848   <span class="keywordflow">for</span>(i=nb_elem_tot; i&lt;nsr; i++)
<a name="l00849"></a>00849     somme+=pression(i);
<a name="l00850"></a>00850   somme/=ns;
<a name="l00851"></a>00851   <span class="keywordflow">for</span>(i=nb_elem_tot; i&lt;nsr; i++)
<a name="l00852"></a>00852     pression(i)-=somme;
<a name="l00853"></a>00853   <span class="keyword">static</span> <span class="keywordtype">double</span> dalpha =(1./<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>*(<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>+1));
<a name="l00854"></a>00854   <span class="keywordtype">double</span> pmoy=0;
<a name="l00855"></a>00855   <span class="keywordflow">for</span>(i=0; i&lt;nb_elem; i++)
<a name="l00856"></a>00856     {
<a name="l00857"></a>00857       <span class="keywordtype">double</span> p=pression(i);
<a name="l00858"></a>00858       <span class="keywordtype">double</span> v=volumes(i);
<a name="l00859"></a>00859       <span class="keywordflow">for</span>(j=0; j&lt;nse; j++)
<a name="l00860"></a>00860         p+=pression(nb_elem_tot+som_elem(i,j))*dalpha;
<a name="l00861"></a>00861       pmoy+=p*v;
<a name="l00862"></a>00862       volume_tot+=v;
<a name="l00863"></a>00863     }
<a name="l00864"></a>00864   pmoy/=volume_tot;
<a name="l00865"></a>00865   <span class="keywordflow">for</span>(i=0; i&lt;nb_elem; i++)
<a name="l00866"></a>00866     pression(i)-=pmoy;
<a name="l00867"></a>00867 }
<a name="l00868"></a>00868 
<a name="l00869"></a>00869 <span class="comment">// Exception:</span>
<a name="l00870"></a>00870 <span class="comment">// Effets de bord:</span>
<a name="l00871"></a>00871 <span class="comment">// Postcondition:</span>
<a name="l00872"></a>00872 <span class="comment">//</span>
<a name="l00873"></a>00873 <span class="comment">//</span>
<a name="l00874"></a>00874 <span class="comment">//</span>
<a name="l00875"></a>00875 <span class="comment">//</span><span class="comment"></span>
<a name="l00876"></a>00876 <span class="comment">//! Modifier eventuellement la matrice pour la rendre definie si elle ne l&#39;est pas&lt;br&gt;Valeurs par defaut:&lt;br&gt;Contraintes:&lt;br&gt;Acces: lecture</span>
<a name="l00877"></a>00877 <span class="comment"></span><span class="comment">/** \return int&lt;br&gt;</span>
<a name="l00878"></a>00878 <span class="comment">Signification: renvoie 1 si la matrice est modifiee 0 sinon&lt;br&gt;</span>
<a name="l00879"></a>00879 <span class="comment">Contraintes: */</span>
<a name="l00880"></a><a class="code" href="classAssembleur__P__VEFPreP1B.html#a4f5ed51e7785455c9ddeb94d1978799a">00880</a> <span class="keywordtype">int</span> <a class="code" href="classAssembleur__P__VEFPreP1B.html#a4f5ed51e7785455c9ddeb94d1978799a" title="Modifier eventuellement la matrice pour la rendre definie si elle ne l&#39;est pas Valeurs par defaut: Co...">Assembleur_P_VEFPreP1B::modifier_matrice</a>(<a class="code" href="classMatrice.html">Matrice</a>&amp; la_matrice)
<a name="l00881"></a>00881 {
<a name="l00882"></a>00882   <span class="keywordtype">int</span> matrice_modifiee=0;
<a name="l00883"></a>00883   <a class="code" href="classAssembleur__P__VEF.html#a23daed7e2fca571504eabe445c920be1">has_P_ref</a>=0;
<a name="l00884"></a>00884   <span class="keyword">const</span> <a class="code" href="classConds__lim.html">Conds_lim</a>&amp; les_cl = <a class="code" href="classAssembleur__P__VEF.html#af06d2fedcae0282000a96ddd444ec7a2">la_zone_Cl_VEF</a>.<a class="code" href="classRef__Zone__Cl__VEF.html#a0970d7253def65ad4f0c5ce1830fd243">valeur</a>().<a class="code" href="classZone__Cl__dis__base.html#af75e0ed7786863e4d333bfb29d67c323" title="Renvoie la i-ieme condition aux limites. (version const)">les_conditions_limites</a>();
<a name="l00885"></a>00885   <span class="keyword">const</span> <a class="code" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a>&amp; zone_VEF = <a class="code" href="classAssembleur__P__VEFPreP1B.html#a3b4a812a062b850be5966f8c6e201cee">zone_Vef</a>();
<a name="l00886"></a>00886 <span class="comment">// Recherche s&#39;il y&#39;a une pression de reference, et si oui la matrice n&#39;est pas modifiee</span>
<a name="l00887"></a>00887   <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;les_cl.<a class="code" href="classvect__impl.html#a78155bfbd6b61f4710b9830641ed1694">size</a>(); i++)
<a name="l00888"></a>00888     <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classNeumann__sortie__libre.html" title="classe Neumann_sortie_libre Cette classe represente une frontiere ouverte sans vitesse imposee Pour l...">Neumann_sortie_libre</a>,les_cl[i].<a class="code" href="Source__Generique__Face__PolyMAC_8cpp.html#a7d7b5d77a3caa1af70f5e1c9108de5a1">valeur</a>()))
<a name="l00889"></a>00889       {
<a name="l00890"></a>00890         <a class="code" href="classAssembleur__P__VEF.html#a23daed7e2fca571504eabe445c920be1">has_P_ref</a>=1;
<a name="l00891"></a>00891         <span class="keywordflow">if</span> (zone_VEF.<a class="code" href="classZone__VEF__PreP1b.html#a9d02e2431efb6e75c3d733ff06f89549">get_alphaA</a>())
<a name="l00892"></a>00892           {
<a name="l00893"></a>00893 <span class="comment">// On en profite pour verifier si la pression est bien nulle si support Pa</span>
<a name="l00894"></a>00894             <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; val=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classNeumann__sortie__libre.html" title="classe Neumann_sortie_libre Cette classe represente une frontiere ouverte sans vitesse imposee Pour l...">Neumann_sortie_libre</a>,les_cl[i].<a class="code" href="Source__Generique__Face__PolyMAC_8cpp.html#a7d7b5d77a3caa1af70f5e1c9108de5a1">valeur</a>()).champ_front().valeurs();
<a name="l00895"></a>00895             <span class="keywordtype">int</span> nbval=val.<a class="code" href="classDoubleTab.html#ac3805e2637a3b880ba2d3e650c69dac4" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(0);
<a name="l00896"></a>00896             <span class="keywordflow">for</span> (<span class="keywordtype">int</span> n=0; n&lt;nbval; n++)
<a name="l00897"></a>00897               <span class="keywordflow">if</span> (val(n,0)!=0)
<a name="l00898"></a>00898                 {
<a name="l00899"></a>00899                   <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;La condition limite pression imposee non nulle n&#39;est pas encore&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
<a name="l00900"></a>00900                   <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;supportee en VEF avec support arete Pa.&quot;</span> &lt;&lt; finl;
<a name="l00901"></a>00901 <span class="comment">// Le travail est a faire dans Assembleur_P_VEFPreP1B::modifier_secmem_aretes</span>
<a name="l00902"></a>00902                   <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">Process::exit</a>();
<a name="l00903"></a>00903                 }
<a name="l00904"></a>00904           }
<a name="l00905"></a>00905       }
<a name="l00906"></a>00906 
<a name="l00907"></a>00907   <a class="code" href="classMatrice__Bloc__Sym.html">Matrice_Bloc_Sym</a>&amp; matrice=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Bloc__Sym.html">Matrice_Bloc_Sym</a>, la_matrice.<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>());
<a name="l00908"></a>00908   <span class="keywordtype">int</span> P0 = 0;
<a name="l00909"></a>00909   <span class="keywordtype">int</span> P1 = P0 + zone_VEF.<a class="code" href="classZone__VEF__PreP1b.html#aee2def53aa92584d7945e7c3d0d98963">get_alphaE</a>();
<a name="l00910"></a>00910   <span class="keywordtype">int</span> Pa = P1 + zone_VEF.<a class="code" href="classZone__VEF__PreP1b.html#ad7fbcb5567dcc2e6f0a0ed85ce90a4fa">get_alphaS</a>();
<a name="l00911"></a>00911 
<a name="l00912"></a>00912 
<a name="l00913"></a>00913 
<a name="l00914"></a>00914   <span class="keywordtype">int</span> CL_neumann=<a class="code" href="classAssembleur__P__VEF.html#a23daed7e2fca571504eabe445c920be1">has_P_ref</a>;
<a name="l00915"></a>00915 <span class="comment">//</span>
<a name="l00916"></a>00916 <span class="comment">// Partie P0</span>
<a name="l00917"></a>00917 <span class="comment">//</span>
<a name="l00918"></a>00918   <span class="keywordflow">if</span> (zone_VEF.<a class="code" href="classZone__VEF__PreP1b.html#aee2def53aa92584d7945e7c3d0d98963">get_alphaE</a>())
<a name="l00919"></a>00919     {
<a name="l00920"></a>00920 <span class="comment">// On impose une pression de reference sur un element si pas de CL de Neumann</span>
<a name="l00921"></a>00921       <span class="keywordflow">if</span> (<a class="code" href="classAssembleur__P__VEF.html#a23daed7e2fca571504eabe445c920be1">has_P_ref</a>)
<a name="l00922"></a>00922         {
<a name="l00923"></a>00923           <a class="code" href="classMatrice__Bloc.html">Matrice_Bloc</a>&amp; mat_bloc=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Bloc.html">Matrice_Bloc</a>,matrice.<a class="code" href="classMatrice__Bloc__Sym.html#a1002ce880ea2b2fb48dae444097c9f7a" title="(0&lt;=i&lt;N , i&lt;=j&lt;M)">get_bloc</a>(P0,P0).<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>());
<a name="l00924"></a>00924           <a class="code" href="classMatrice__Morse__Sym.html" title="Classe Matrice_Morse_Sym Represente une matrice M (creuse) symetrique stockee au format Morse Symetri...">Matrice_Morse_Sym</a>&amp; A00RR = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Morse__Sym.html" title="Classe Matrice_Morse_Sym Represente une matrice M (creuse) symetrique stockee au format Morse Symetri...">Matrice_Morse_Sym</a>,mat_bloc.<a class="code" href="classMatrice__Bloc.html#a7ffa38f7b93454432b2df7c616ed0a4e">get_bloc</a>(0,0).<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>());
<a name="l00925"></a>00925           A00RR.set_est_definie(1);
<a name="l00926"></a>00926         }
<a name="l00927"></a>00927       matrice_modifiee=<a class="code" href="classAssembleur__P__VEFPreP1B.html#a4f5ed51e7785455c9ddeb94d1978799a" title="Modifier eventuellement la matrice pour la rendre definie si elle ne l&#39;est pas Valeurs par defaut: Co...">Assembleur_P_VEF::modifier_matrice</a>(matrice.<a class="code" href="classMatrice__Bloc__Sym.html#a1002ce880ea2b2fb48dae444097c9f7a" title="(0&lt;=i&lt;N , i&lt;=j&lt;M)">get_bloc</a>(P0,P0));
<a name="l00928"></a>00928     }
<a name="l00929"></a>00929 
<a name="l00930"></a>00930 <span class="comment">//</span>
<a name="l00931"></a>00931 <span class="comment">// Partie P1</span>
<a name="l00932"></a>00932 <span class="comment">//</span>
<a name="l00933"></a>00933   <span class="keywordflow">if</span> (zone_VEF.<a class="code" href="classZone__VEF__PreP1b.html#ad7fbcb5567dcc2e6f0a0ed85ce90a4fa">get_alphaS</a>())
<a name="l00934"></a>00934     {
<a name="l00935"></a>00935       <a class="code" href="classMatrice__Bloc.html">Matrice_Bloc</a>&amp; mat_bloc_p1_p1 = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Bloc.html">Matrice_Bloc</a>, matrice.<a class="code" href="classMatrice__Bloc__Sym.html#a1002ce880ea2b2fb48dae444097c9f7a" title="(0&lt;=i&lt;N , i&lt;=j&lt;M)">get_bloc</a>(P1,P1).<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>());
<a name="l00936"></a>00936       <a class="code" href="classMatrice__Morse__Sym.html" title="Classe Matrice_Morse_Sym Represente une matrice M (creuse) symetrique stockee au format Morse Symetri...">Matrice_Morse_Sym</a>&amp; A11RR = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Morse__Sym.html" title="Classe Matrice_Morse_Sym Represente une matrice M (creuse) symetrique stockee au format Morse Symetri...">Matrice_Morse_Sym</a>,mat_bloc_p1_p1.<a class="code" href="classMatrice__Bloc.html#a7ffa38f7b93454432b2df7c616ed0a4e">get_bloc</a>(0,0).<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>());
<a name="l00937"></a>00937 <span class="comment">// On impose une pression de reference sur un sommet si support P0 ou si pas de CL de Neumann</span>
<a name="l00938"></a>00938       <span class="keywordflow">if</span> (((!(<a class="code" href="classProcess.html#a1e9d9f9899b71927cfafae14c7bd048d" title="Calcule le max de x sur tous les processeurs du groupe courant. Remarques : Cette methode doit etre a...">Process::mp_max</a>(CL_neumann))) || ((zone_VEF.<a class="code" href="classZone__VEF__PreP1b.html#aee2def53aa92584d7945e7c3d0d98963">get_alphaE</a>()) &amp;&amp; (zone_VEF.<a class="code" href="classZone__VEF__PreP1b.html#aed6f98596f13c0c4df7a7d9f57235b56">get_cl_pression_sommet_faible</a>()==1) ) ) &amp;&amp; <a class="code" href="classProcess.html#acd052b99706c577f8a5b6656217cf4c2" title="renvoie 1 si on est sur le processeur maitre du groupe courant (c&#39;est a dire me() == 0)...">Process::je_suis_maitre</a>())
<a name="l00939"></a>00939         {
<a name="l00940"></a>00940           <span class="keywordtype">int</span> sommet_referent=0;
<a name="l00941"></a>00941           <span class="keywordtype">double</span> distance=<a class="code" href="Double_8h.html#ae0ee0cebfad5968da0ad6cc7a49e16b6">DMAXFLOAT</a>;
<a name="l00942"></a>00942           <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; coord=zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#a379ad2206b5a13a4f4f3df6d44c7546a" title="Renvoie le domaine dont la zone fait partie. (version const)">domaine</a>().<a class="code" href="classDomaine.html#aecd32c3eecc15cce7d1a0e468dadbf96" title="Renvoie le tableau des coordonnees des noeuds (sommets). (acces en lecture)">coord_sommets</a>();
<a name="l00943"></a>00943           <span class="keywordtype">int</span> nb_som=zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#ad340f571f81fa5c2e028b88c00b5c2ca" title="Renvoie le nombre de sommets de la zone.">nb_som</a>();
<a name="l00944"></a>00944           <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;nb_som; i++)
<a name="l00945"></a>00945             {
<a name="l00946"></a>00946               <span class="keywordtype">double</span> tmp=0;
<a name="l00947"></a>00947               <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j=0; j&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; j++)
<a name="l00948"></a>00948                 tmp+=coord(i,j)*coord(i,j);
<a name="l00949"></a>00949               <span class="keywordflow">if</span> (<a class="code" href="Double_8h.html#ad7e27600604265379936210d7f9dfdd5">inf_strict</a>(tmp,distance) &amp;&amp; !<a class="code" href="Double_8h.html#ac86f5f350b0f95fd8c34b0ac8d720f6f">est_egal</a>(A11RR(i,i),0.))
<a name="l00950"></a>00950                 {
<a name="l00951"></a>00951                   distance=tmp;
<a name="l00952"></a>00952                   sommet_referent=i;
<a name="l00953"></a>00953                 }
<a name="l00954"></a>00954             }
<a name="l00955"></a>00955 <span class="comment">// Cerr &lt;&lt; &quot;On modifie la ligne (sommet) &quot; &lt;&lt; sommet_referent &lt;&lt; finl;</span>
<a name="l00956"></a>00956           A11RR(sommet_referent,sommet_referent)*=2;
<a name="l00957"></a>00957 <span class="comment">// has_P_ref=1;</span>
<a name="l00958"></a>00958           matrice_modifiee=1;
<a name="l00959"></a>00959         }
<a name="l00960"></a>00960       A11RR.set_est_definie(1);
<a name="l00961"></a>00961     }
<a name="l00962"></a>00962 
<a name="l00963"></a>00963 <span class="comment">//</span>
<a name="l00964"></a>00964 <span class="comment">// Partie Pa</span>
<a name="l00965"></a>00965 <span class="comment">//</span>
<a name="l00966"></a>00966   <span class="keywordflow">if</span> (zone_VEF.<a class="code" href="classZone__VEF__PreP1b.html#a9d02e2431efb6e75c3d733ff06f89549">get_alphaA</a>())
<a name="l00967"></a>00967     {
<a name="l00968"></a>00968       <a class="code" href="classMatrice__Bloc.html">Matrice_Bloc</a>&amp; mat_bloc_pa_pa = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Bloc.html">Matrice_Bloc</a>, matrice.<a class="code" href="classMatrice__Bloc__Sym.html#a1002ce880ea2b2fb48dae444097c9f7a" title="(0&lt;=i&lt;N , i&lt;=j&lt;M)">get_bloc</a>(Pa,Pa).<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>());
<a name="l00969"></a>00969       <a class="code" href="classMatrice__Morse__Sym.html" title="Classe Matrice_Morse_Sym Represente une matrice M (creuse) symetrique stockee au format Morse Symetri...">Matrice_Morse_Sym</a>&amp; A22RR = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Morse__Sym.html" title="Classe Matrice_Morse_Sym Represente une matrice M (creuse) symetrique stockee au format Morse Symetri...">Matrice_Morse_Sym</a>,mat_bloc_pa_pa.<a class="code" href="classMatrice__Bloc.html#a7ffa38f7b93454432b2df7c616ed0a4e">get_bloc</a>(0,0).<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>());
<a name="l00970"></a>00970 <span class="comment">// On impose une pression de reference sur une arete en P0+Pa uniquement</span>
<a name="l00971"></a>00971       <span class="keywordflow">if</span> ((zone_VEF.<a class="code" href="classZone__VEF__PreP1b.html#aee2def53aa92584d7945e7c3d0d98963">get_alphaE</a>() &amp;&amp; !zone_VEF.<a class="code" href="classZone__VEF__PreP1b.html#ad7fbcb5567dcc2e6f0a0ed85ce90a4fa">get_alphaS</a>()) &amp;&amp; <a class="code" href="classProcess.html#acd052b99706c577f8a5b6656217cf4c2" title="renvoie 1 si on est sur le processeur maitre du groupe courant (c&#39;est a dire me() == 0)...">Process::je_suis_maitre</a>())
<a name="l00972"></a>00972         {
<a name="l00973"></a>00973           <span class="keywordtype">int</span> arete_referente=0;
<a name="l00974"></a>00974           <span class="keywordtype">double</span> distance=<a class="code" href="Double_8h.html#ae0ee0cebfad5968da0ad6cc7a49e16b6">DMAXFLOAT</a>;
<a name="l00975"></a>00975           <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; coord=zone_VEF.<a class="code" href="classZone__VF.html#a6ad5a2a03fc2cba4247a6ebe662b1320">xa</a>();
<a name="l00976"></a>00976           <span class="keywordtype">int</span> nb_aretes=zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#a3e3b48691911fd85574c7bc10a1a4fb8" title="renvoie le nombre d&#39;aretes reelles.">nb_aretes</a>();
<a name="l00977"></a>00977           <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;nb_aretes; i++)
<a name="l00978"></a>00978             {
<a name="l00979"></a>00979               <span class="keywordtype">double</span> tmp=0;
<a name="l00980"></a>00980               <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j=0; j&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; j++)
<a name="l00981"></a>00981                 tmp+=coord(i,j)*coord(i,j);
<a name="l00982"></a>00982               <span class="keywordflow">if</span> (tmp&lt;distance &amp;&amp; A22RR(i,i)!=0)
<a name="l00983"></a>00983                 {
<a name="l00984"></a>00984                   distance=tmp;
<a name="l00985"></a>00985                   arete_referente=i;
<a name="l00986"></a>00986                 }
<a name="l00987"></a>00987             }
<a name="l00988"></a>00988 <span class="comment">// Cerr &lt;&lt; &quot;On modifie la ligne (arete) &quot; &lt;&lt; arete_referente &lt;&lt; finl;</span>
<a name="l00989"></a>00989           A22RR(arete_referente,arete_referente)*=2;
<a name="l00990"></a>00990 <span class="comment">// has_P_ref=1;</span>
<a name="l00991"></a>00991           matrice_modifiee=1;
<a name="l00992"></a>00992         }
<a name="l00993"></a>00993       A22RR.set_est_definie(1);
<a name="l00994"></a>00994     }
<a name="l00995"></a>00995 
<a name="l00996"></a>00996   {
<a name="l00997"></a>00997     <a class="code" href="classMatrice__Bloc.html">Matrice_Bloc</a>&amp; bloc_P0_P0 = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>( <a class="code" href="classMatrice__Bloc.html">Matrice_Bloc</a>,matrice.<a class="code" href="classMatrice__Bloc__Sym.html#a1002ce880ea2b2fb48dae444097c9f7a" title="(0&lt;=i&lt;N , i&lt;=j&lt;M)">get_bloc</a>(P0,P0).<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>( ) );
<a name="l00998"></a>00998     <a class="code" href="classMatrice__Morse__Sym.html" title="Classe Matrice_Morse_Sym Represente une matrice M (creuse) symetrique stockee au format Morse Symetri...">Matrice_Morse_Sym</a>&amp; A00RR = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>( <a class="code" href="classMatrice__Morse__Sym.html" title="Classe Matrice_Morse_Sym Represente une matrice M (creuse) symetrique stockee au format Morse Symetri...">Matrice_Morse_Sym</a>, bloc_P0_P0.<a class="code" href="classMatrice__Bloc.html#a7ffa38f7b93454432b2df7c616ed0a4e">get_bloc</a>(0,0).<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>() );
<a name="l00999"></a>00999     matrice.<a class="code" href="classMatrice__Sym.html#a532cf830aed3865010c9977b545927c0">set_est_definie</a>( A00RR.get_est_definie( ) );
<a name="l01000"></a>01000   }
<a name="l01001"></a>01001 
<a name="l01002"></a>01002   <span class="keywordflow">return</span> matrice_modifiee;
<a name="l01003"></a>01003 }
<a name="l01004"></a>01004 
<a name="l01005"></a><a class="code" href="Assembleur__P__VEFPreP1B_8cpp.html#a1ba6a21d7cd10f7974541a879696c5db">01005</a> <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="Assembleur__P__VEFPreP1B_8cpp.html#a1ba6a21d7cd10f7974541a879696c5db">range</a>(<span class="keywordtype">double</span>&amp; <a class="code" href="Zone__CoviMAC_8h.html#aa24d8c7ee8fd93e2360821d3636ec69d">prod</a>, <span class="keywordtype">int</span>&amp; i, <span class="keywordtype">int</span>&amp; n, <span class="keywordtype">int</span>&amp; j, <span class="keywordtype">int</span>&amp; m, <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; ARR, <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; ARV, <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; AVR, <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; AVV)
<a name="l01006"></a>01006 {
<a name="l01007"></a>01007   <span class="keywordflow">if</span> (i&lt;n)
<a name="l01008"></a>01008     <span class="keywordflow">if</span> (j&lt;m)
<a name="l01009"></a>01009       ARR(i,j)+=<a class="code" href="Zone__CoviMAC_8h.html#aa24d8c7ee8fd93e2360821d3636ec69d">prod</a>;
<a name="l01010"></a>01010     <span class="keywordflow">else</span>
<a name="l01011"></a>01011       ARV(i,j-m)+=<a class="code" href="Zone__CoviMAC_8h.html#aa24d8c7ee8fd93e2360821d3636ec69d">prod</a>;
<a name="l01012"></a>01012   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (j&lt;m)
<a name="l01013"></a>01013     AVR(i-n,j)+=<a class="code" href="Zone__CoviMAC_8h.html#aa24d8c7ee8fd93e2360821d3636ec69d">prod</a>;
<a name="l01014"></a>01014   <span class="keywordflow">else</span>
<a name="l01015"></a>01015     AVV(i-n,j-m)+=<a class="code" href="Zone__CoviMAC_8h.html#aa24d8c7ee8fd93e2360821d3636ec69d">prod</a>;
<a name="l01016"></a>01016 }
<a name="l01017"></a>01017 
<a name="l01018"></a><a class="code" href="Assembleur__P__VEFPreP1B_8cpp.html#ad34510dd4da2194051998525655e62f9">01018</a> <span class="keywordtype">void</span> <a class="code" href="Assembleur__P__VEFPreP1B_8cpp.html#ad34510dd4da2194051998525655e62f9">operation11</a>(<a class="code" href="classMatrice__Bloc.html">Matrice_Bloc</a>&amp; A00, <a class="code" href="classMatrice__Bloc.html">Matrice_Bloc</a>&amp; A01, <a class="code" href="classMatrice__Bloc.html">Matrice_Bloc</a>&amp; A11, <span class="keywordtype">double</span> beta, <span class="keyword">const</span> <a class="code" href="classZone.html" title="classe Zone Une Zone est un maillage compose d&#39;un ensemble d&#39;elements geometriques de meme type...">Zone</a>&amp; zone)
<a name="l01019"></a>01019 {
<a name="l01020"></a>01020 <span class="comment">// Cerr &lt;&lt; &quot;Operation11&quot; &lt;&lt; finl;</span>
<a name="l01021"></a>01021   <a class="code" href="classMatrice__Morse__Sym.html" title="Classe Matrice_Morse_Sym Represente une matrice M (creuse) symetrique stockee au format Morse Symetri...">Matrice_Morse_Sym</a>&amp; A11RR=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Morse__Sym.html" title="Classe Matrice_Morse_Sym Represente une matrice M (creuse) symetrique stockee au format Morse Symetri...">Matrice_Morse_Sym</a>, A11.<a class="code" href="classMatrice__Bloc.html#a7ffa38f7b93454432b2df7c616ed0a4e">get_bloc</a>(0,0).<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>());
<a name="l01022"></a>01022   <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; A11RV=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>, A11.<a class="code" href="classMatrice__Bloc.html#a7ffa38f7b93454432b2df7c616ed0a4e">get_bloc</a>(0,1).<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>());
<a name="l01023"></a>01023   <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; A11VR=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>, A11.<a class="code" href="classMatrice__Bloc.html#a7ffa38f7b93454432b2df7c616ed0a4e">get_bloc</a>(1,0).<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>());
<a name="l01024"></a>01024   <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; A11VV=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>, A11.<a class="code" href="classMatrice__Bloc.html#a7ffa38f7b93454432b2df7c616ed0a4e">get_bloc</a>(1,1).<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>());
<a name="l01025"></a>01025   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; les_elems=zone.<a class="code" href="classZone.html#ac115e8342be89afb882b7b61cc343267" title="Renvoie le tableau des sommets des elements.">les_elems</a>();
<a name="l01026"></a>01026   <span class="keyword">const</span> <a class="code" href="classDomaine.html" title="Classe Domaine Un Domaine represente le domaine (spatial) de resolution d&#39;un Probleme. Un Domaine a un Nom, il est constitue d&#39;une ou plusieurs Zone qui peuvent etre eventuellement decoupees en Sous_Zone. Un Domaine porte l&#39;ensemble des sommets utilises par ses Zones. On peut vouloir resoudre des problemes de type different sur plusieurs domaines, geometriquement les domaines sont alors couples par des surfaces qu&#39;on appelle Raccord.">Domaine</a>&amp; dom=zone.<a class="code" href="classZone.html#a379ad2206b5a13a4f4f3df6d44c7546a" title="Renvoie le domaine dont la zone fait partie. (version const)">domaine</a>();
<a name="l01027"></a>01027   <span class="keywordtype">int</span> nb_som=A11RR.<a class="code" href="classMatrice__Morse.html#a1f9bd6aedb226c86b7299689fa5b821a">nb_lignes</a>();
<a name="l01028"></a>01028   <span class="keywordtype">int</span> nb_som_elem=les_elems.dimension(1);
<a name="l01029"></a>01029 <span class="comment">// On parcours les elements de la matrice A00</span>
<a name="l01030"></a>01030 <span class="comment">// Cerr &lt;&lt; &quot;[&quot; &lt;&lt; Process::me() &lt;&lt; &quot;] Contribution de A00 dans A11~&quot; &lt;&lt; finl;</span>
<a name="l01031"></a>01031   <span class="keywordtype">int</span> ligne=0;
<a name="l01032"></a>01032   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i_bloc=0; i_bloc&lt;A00.<a class="code" href="classMatrice__Bloc.html#a02193255787b0ecae7988ca4eada3b4b" title="retourne N_">nb_bloc_lignes</a>(); i_bloc++)
<a name="l01033"></a>01033     {
<a name="l01034"></a>01034       <span class="keywordtype">int</span> colonne=0;
<a name="l01035"></a>01035       <span class="keywordtype">int</span> nb_lignes=0;
<a name="l01036"></a>01036       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j_bloc=0; j_bloc&lt;A00.<a class="code" href="classMatrice__Bloc.html#a2436d61e9c5d9e364d22fd106349cf9a" title="retourne M_">nb_bloc_colonnes</a>(); j_bloc++)
<a name="l01037"></a>01037         {
<a name="l01038"></a>01038           <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; A00ij=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>, A00.<a class="code" href="classMatrice__Bloc.html#a7ffa38f7b93454432b2df7c616ed0a4e">get_bloc</a>(i_bloc,j_bloc).<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>());
<a name="l01039"></a>01039           <span class="keyword">const</span> <span class="keywordtype">int</span>* tab1=A00ij.<a class="code" href="classMatrice__Morse.html#a79b4e334152850bd36e53478debf3061">get_tab1</a>().<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
<a name="l01040"></a>01040           <span class="keyword">const</span> <span class="keywordtype">int</span>* tab2=A00ij.<a class="code" href="classMatrice__Morse.html#a787b5a63f27063f9c891243d8f188cda">get_tab2</a>().<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
<a name="l01041"></a>01041           <span class="keyword">const</span> <span class="keywordtype">double</span>* <a class="code" href="Champ__P1iP1B__implementation_8cpp.html#aa8c8f49390c3cf7c702d71a71bc977e3">coeff</a>=A00ij.<a class="code" href="classMatrice__Morse.html#aacb80dd518dcc0812e3b34edac6ab67e">get_coeff</a>().<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
<a name="l01042"></a>01042           nb_lignes=A00ij.<a class="code" href="classMatrice__Morse.html#a1f9bd6aedb226c86b7299689fa5b821a">nb_lignes</a>();
<a name="l01043"></a>01043           <span class="keywordtype">int</span> nb_colonnes=A00ij.<a class="code" href="classMatrice__Morse.html#a94caf9937bc5a110a7179cb3e9eaa9d9">nb_colonnes</a>();
<a name="l01044"></a>01044           <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;nb_lignes; i++)
<a name="l01045"></a>01045             {
<a name="l01046"></a>01046               <span class="keywordtype">int</span> k1=ligne+i; <span class="comment">//!&lt; Element k1</span>
<a name="l01047"></a>01047 <span class="comment"></span>              <span class="keywordflow">for</span> (<span class="keywordtype">int</span> n=tab1[i]-1; n&lt;tab1[i+1]-1; n++)
<a name="l01048"></a>01048                 {
<a name="l01049"></a>01049                   <span class="keywordtype">int</span> k2=colonne+tab2[n]-1; <span class="comment">//!&lt; Element k2</span>
<a name="l01050"></a>01050 <span class="comment"></span>                  <span class="keywordflow">if</span> (k2&gt;=k1)
<a name="l01051"></a>01051                     {
<a name="l01052"></a>01052                       <span class="keywordtype">double</span> <a class="code" href="Zone__CoviMAC_8h.html#aa24d8c7ee8fd93e2360821d3636ec69d">prod</a> = beta * beta * coeff[n];        <span class="comment">//!&lt; Calcul de beta*beta*Ak1k2</span>
<a name="l01053"></a>01053 <span class="comment"></span>                      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> som1=0; som1&lt;nb_som_elem; som1++)
<a name="l01054"></a>01054                         {
<a name="l01055"></a>01055                           <span class="keywordtype">int</span> s1 = dom.<a class="code" href="classDomaine.html#a37cc657f1907d53b0d5a573da862af80">get_renum_som_perio</a>(les_elems(k1,som1));
<a name="l01056"></a>01056                           <span class="keywordflow">for</span> (<span class="keywordtype">int</span> som2=0; som2&lt;nb_som_elem; som2++)
<a name="l01057"></a>01057                             {
<a name="l01058"></a>01058                               <span class="keywordtype">int</span> s2 = dom.<a class="code" href="classDomaine.html#a37cc657f1907d53b0d5a573da862af80">get_renum_som_perio</a>(les_elems(k2,som2));
<a name="l01059"></a>01059                               <span class="keywordflow">if</span> (s2&gt;=s1) <a class="code" href="Assembleur__P__VEFPreP1B_8cpp.html#a1ba6a21d7cd10f7974541a879696c5db">range</a>(prod,s1,nb_som,s2,nb_som,A11RR,A11RV,A11VR,A11VV);
<a name="l01060"></a>01060                             }
<a name="l01061"></a>01061                         }
<a name="l01062"></a>01062                       <span class="keywordflow">if</span> (k1!=k2)
<a name="l01063"></a>01063                         {
<a name="l01064"></a>01064                           <span class="keywordflow">for</span> (<span class="keywordtype">int</span> som1=0; som1&lt;nb_som_elem; som1++)
<a name="l01065"></a>01065                             {
<a name="l01066"></a>01066                               <span class="keywordtype">int</span> s1 = dom.<a class="code" href="classDomaine.html#a37cc657f1907d53b0d5a573da862af80">get_renum_som_perio</a>(les_elems(k2,som1));
<a name="l01067"></a>01067                               <span class="keywordflow">for</span> (<span class="keywordtype">int</span> som2=0; som2&lt;nb_som_elem; som2++)
<a name="l01068"></a>01068                                 {
<a name="l01069"></a>01069                                   <span class="keywordtype">int</span> s2 = dom.<a class="code" href="classDomaine.html#a37cc657f1907d53b0d5a573da862af80">get_renum_som_perio</a>(les_elems(k1,som2));
<a name="l01070"></a>01070                                   <span class="keywordflow">if</span> (s2&gt;=s1) <a class="code" href="Assembleur__P__VEFPreP1B_8cpp.html#a1ba6a21d7cd10f7974541a879696c5db">range</a>(prod,s1,nb_som,s2,nb_som,A11RR,A11RV,A11VR,A11VV);
<a name="l01071"></a>01071                                 }
<a name="l01072"></a>01072                             }
<a name="l01073"></a>01073                         }
<a name="l01074"></a>01074                     }
<a name="l01075"></a>01075                 }
<a name="l01076"></a>01076             }
<a name="l01077"></a>01077           colonne+=nb_colonnes;
<a name="l01078"></a>01078         }
<a name="l01079"></a>01079       ligne+=nb_lignes;
<a name="l01080"></a>01080     }
<a name="l01081"></a>01081 <span class="comment">// On parcours les elements de la matrice A01</span>
<a name="l01082"></a>01082 <span class="comment">// Cerr &lt;&lt; &quot;[&quot; &lt;&lt; Process::me() &lt;&lt; &quot;] Contribution de A01 dans A11~&quot; &lt;&lt; finl;</span>
<a name="l01083"></a>01083   ligne=0;
<a name="l01084"></a>01084   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i_bloc=0; i_bloc&lt;A01.<a class="code" href="classMatrice__Bloc.html#a02193255787b0ecae7988ca4eada3b4b" title="retourne N_">nb_bloc_lignes</a>(); i_bloc++)
<a name="l01085"></a>01085     {
<a name="l01086"></a>01086       <span class="keywordtype">int</span> colonne=0;
<a name="l01087"></a>01087       <span class="keywordtype">int</span> nb_lignes=0;
<a name="l01088"></a>01088       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j_bloc=0; j_bloc&lt;A01.<a class="code" href="classMatrice__Bloc.html#a2436d61e9c5d9e364d22fd106349cf9a" title="retourne M_">nb_bloc_colonnes</a>(); j_bloc++)
<a name="l01089"></a>01089         {
<a name="l01090"></a>01090           <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; A01ij=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>, A01.<a class="code" href="classMatrice__Bloc.html#a7ffa38f7b93454432b2df7c616ed0a4e">get_bloc</a>(i_bloc,j_bloc).<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>());
<a name="l01091"></a>01091           <span class="keyword">const</span> <span class="keywordtype">int</span>* tab1=A01ij.<a class="code" href="classMatrice__Morse.html#a79b4e334152850bd36e53478debf3061">get_tab1</a>().<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
<a name="l01092"></a>01092           <span class="keyword">const</span> <span class="keywordtype">int</span>* tab2=A01ij.<a class="code" href="classMatrice__Morse.html#a787b5a63f27063f9c891243d8f188cda">get_tab2</a>().<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
<a name="l01093"></a>01093           <span class="keyword">const</span> <span class="keywordtype">double</span>* <a class="code" href="Champ__P1iP1B__implementation_8cpp.html#aa8c8f49390c3cf7c702d71a71bc977e3">coeff</a>=A01ij.<a class="code" href="classMatrice__Morse.html#aacb80dd518dcc0812e3b34edac6ab67e">get_coeff</a>().<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
<a name="l01094"></a>01094           nb_lignes=A01ij.<a class="code" href="classMatrice__Morse.html#a1f9bd6aedb226c86b7299689fa5b821a">nb_lignes</a>();
<a name="l01095"></a>01095           <span class="keywordtype">int</span> nb_colonnes=A01ij.<a class="code" href="classMatrice__Morse.html#a94caf9937bc5a110a7179cb3e9eaa9d9">nb_colonnes</a>();
<a name="l01096"></a>01096           <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;nb_lignes; i++)
<a name="l01097"></a>01097             {
<a name="l01098"></a>01098               <span class="keywordtype">int</span> k=ligne+i; <span class="comment">//!&lt; Element k</span>
<a name="l01099"></a>01099 <span class="comment"></span>              <span class="keywordflow">for</span> (<span class="keywordtype">int</span> n=tab1[i]-1; n&lt;tab1[i+1]-1; n++)
<a name="l01100"></a>01100                 {
<a name="l01101"></a>01101                   <span class="keywordtype">int</span> s1 = dom.<a class="code" href="classDomaine.html#a37cc657f1907d53b0d5a573da862af80">get_renum_som_perio</a>(colonne+tab2[n]-1); <span class="comment">//!&lt; Sommet s1</span>
<a name="l01102"></a>01102 <span class="comment"></span>                  <span class="keywordtype">double</span> <a class="code" href="Zone__CoviMAC_8h.html#aa24d8c7ee8fd93e2360821d3636ec69d">prod</a> = -beta * coeff[n];        <span class="comment">//!&lt; Calcul de -beta*Aks</span>
<a name="l01103"></a>01103 <span class="comment"></span>                  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> som=0; som&lt;nb_som_elem; som++)
<a name="l01104"></a>01104                     {
<a name="l01105"></a>01105                       <span class="keywordtype">int</span> s2 = dom.<a class="code" href="classDomaine.html#a37cc657f1907d53b0d5a573da862af80">get_renum_som_perio</a>(les_elems(k,som)); <span class="comment">//!&lt; Sommet s2</span>
<a name="l01106"></a>01106 <span class="comment"></span>                      <span class="keywordflow">if</span> (s2&gt;=s1) <a class="code" href="Assembleur__P__VEFPreP1B_8cpp.html#a1ba6a21d7cd10f7974541a879696c5db">range</a>(prod,s1,nb_som,s2,nb_som,A11RR,A11RV,A11VR,A11VV);
<a name="l01107"></a>01107                       <span class="keywordflow">if</span> (s1&gt;=s2) <a class="code" href="Assembleur__P__VEFPreP1B_8cpp.html#a1ba6a21d7cd10f7974541a879696c5db">range</a>(prod,s2,nb_som,s1,nb_som,A11RR,A11RV,A11VR,A11VV);
<a name="l01108"></a>01108                     }
<a name="l01109"></a>01109                 }
<a name="l01110"></a>01110             }
<a name="l01111"></a>01111           colonne+=nb_colonnes;
<a name="l01112"></a>01112         }
<a name="l01113"></a>01113       ligne+=nb_lignes;
<a name="l01114"></a>01114     }
<a name="l01115"></a>01115 }
<a name="l01116"></a>01116 
<a name="l01117"></a><a class="code" href="Assembleur__P__VEFPreP1B_8cpp.html#a092a07cbd42b28d79c8d8d04e835fd91">01117</a> <span class="keywordtype">void</span> <a class="code" href="Assembleur__P__VEFPreP1B_8cpp.html#a092a07cbd42b28d79c8d8d04e835fd91">operation01</a>(<a class="code" href="classMatrice__Bloc.html">Matrice_Bloc</a>&amp; A00, <a class="code" href="classMatrice__Bloc.html">Matrice_Bloc</a>&amp; A01, <span class="keywordtype">double</span> alpha, <span class="keywordtype">double</span> beta, <span class="keyword">const</span> <a class="code" href="classZone.html" title="classe Zone Une Zone est un maillage compose d&#39;un ensemble d&#39;elements geometriques de meme type...">Zone</a>&amp; zone)
<a name="l01118"></a>01118 {
<a name="l01119"></a>01119 <span class="comment">// Cerr &lt;&lt; &quot;[&quot; &lt;&lt; Process::me() &lt;&lt; &quot;] Operation01&quot; &lt;&lt; finl;</span>
<a name="l01120"></a>01120   <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; A01RR=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>, A01.<a class="code" href="classMatrice__Bloc.html#a7ffa38f7b93454432b2df7c616ed0a4e">get_bloc</a>(0,0).<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>());
<a name="l01121"></a>01121   <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; A01RV=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>, A01.<a class="code" href="classMatrice__Bloc.html#a7ffa38f7b93454432b2df7c616ed0a4e">get_bloc</a>(0,1).<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>());
<a name="l01122"></a>01122   <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; A01VR=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>, A01.<a class="code" href="classMatrice__Bloc.html#a7ffa38f7b93454432b2df7c616ed0a4e">get_bloc</a>(1,0).<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>());
<a name="l01123"></a>01123   <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; A01VV=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>, A01.<a class="code" href="classMatrice__Bloc.html#a7ffa38f7b93454432b2df7c616ed0a4e">get_bloc</a>(1,1).<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>());
<a name="l01124"></a>01124   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; les_elems=zone.<a class="code" href="classZone.html#ac115e8342be89afb882b7b61cc343267" title="Renvoie le tableau des sommets des elements.">les_elems</a>();
<a name="l01125"></a>01125   <span class="keyword">const</span> <a class="code" href="classDomaine.html" title="Classe Domaine Un Domaine represente le domaine (spatial) de resolution d&#39;un Probleme. Un Domaine a un Nom, il est constitue d&#39;une ou plusieurs Zone qui peuvent etre eventuellement decoupees en Sous_Zone. Un Domaine porte l&#39;ensemble des sommets utilises par ses Zones. On peut vouloir resoudre des problemes de type different sur plusieurs domaines, geometriquement les domaines sont alors couples par des surfaces qu&#39;on appelle Raccord.">Domaine</a>&amp; dom=zone.<a class="code" href="classZone.html#a379ad2206b5a13a4f4f3df6d44c7546a" title="Renvoie le domaine dont la zone fait partie. (version const)">domaine</a>();
<a name="l01126"></a>01126   <span class="keywordtype">int</span> nb_elem=A01RR.<a class="code" href="classMatrice__Morse.html#a1f9bd6aedb226c86b7299689fa5b821a">nb_lignes</a>();
<a name="l01127"></a>01127   <span class="keywordtype">int</span> nb_som=A01RR.<a class="code" href="classMatrice__Morse.html#a94caf9937bc5a110a7179cb3e9eaa9d9">nb_colonnes</a>();
<a name="l01128"></a>01128   <span class="keywordtype">int</span> nb_som_elem=les_elems.dimension(1);
<a name="l01129"></a>01129 <span class="comment">// On parcours les coefficients de A00</span>
<a name="l01130"></a>01130   <span class="keywordtype">int</span> ligne=0;
<a name="l01131"></a>01131   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i_bloc=0; i_bloc&lt;A00.<a class="code" href="classMatrice__Bloc.html#a02193255787b0ecae7988ca4eada3b4b" title="retourne N_">nb_bloc_lignes</a>(); i_bloc++)
<a name="l01132"></a>01132     {
<a name="l01133"></a>01133       <span class="keywordtype">int</span> colonne=0;
<a name="l01134"></a>01134       <span class="keywordtype">int</span> nb_lignes=0;
<a name="l01135"></a>01135       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j_bloc=0; j_bloc&lt;A00.<a class="code" href="classMatrice__Bloc.html#a2436d61e9c5d9e364d22fd106349cf9a" title="retourne M_">nb_bloc_colonnes</a>(); j_bloc++)
<a name="l01136"></a>01136         {
<a name="l01137"></a>01137           <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; A00ij=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>, A00.<a class="code" href="classMatrice__Bloc.html#a7ffa38f7b93454432b2df7c616ed0a4e">get_bloc</a>(i_bloc,j_bloc).<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>());
<a name="l01138"></a>01138           <span class="keyword">const</span> <span class="keywordtype">int</span>* tab1=A00ij.<a class="code" href="classMatrice__Morse.html#a79b4e334152850bd36e53478debf3061">get_tab1</a>().<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
<a name="l01139"></a>01139           <span class="keyword">const</span> <span class="keywordtype">int</span>* tab2=A00ij.<a class="code" href="classMatrice__Morse.html#a787b5a63f27063f9c891243d8f188cda">get_tab2</a>().<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
<a name="l01140"></a>01140           <span class="keyword">const</span> <span class="keywordtype">double</span>* <a class="code" href="Champ__P1iP1B__implementation_8cpp.html#aa8c8f49390c3cf7c702d71a71bc977e3">coeff</a>=A00ij.<a class="code" href="classMatrice__Morse.html#aacb80dd518dcc0812e3b34edac6ab67e">get_coeff</a>().<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
<a name="l01141"></a>01141           nb_lignes=A00ij.<a class="code" href="classMatrice__Morse.html#a1f9bd6aedb226c86b7299689fa5b821a">nb_lignes</a>();
<a name="l01142"></a>01142           <span class="keywordtype">int</span> nb_colonnes=A00ij.<a class="code" href="classMatrice__Morse.html#a94caf9937bc5a110a7179cb3e9eaa9d9">nb_colonnes</a>();
<a name="l01143"></a>01143           <span class="keywordtype">int</span> s;
<a name="l01144"></a>01144           <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;nb_lignes; i++)
<a name="l01145"></a>01145             {
<a name="l01146"></a>01146               <span class="keywordtype">int</span> k1=ligne+i; <span class="comment">//!&lt; Element k1</span>
<a name="l01147"></a>01147 <span class="comment"></span>              <span class="keywordflow">for</span> (<span class="keywordtype">int</span> n=tab1[i]-1; n&lt;tab1[i+1]-1; n++)
<a name="l01148"></a>01148                 {
<a name="l01149"></a>01149                   <span class="keywordtype">int</span> k2=colonne+tab2[n]-1; <span class="comment">//!&lt; Element k2</span>
<a name="l01150"></a>01150 <span class="comment"></span>                  <span class="keywordflow">if</span> (k2&gt;=k1)
<a name="l01151"></a>01151                     {
<a name="l01152"></a>01152                       <span class="keywordtype">double</span> <a class="code" href="Zone__CoviMAC_8h.html#aa24d8c7ee8fd93e2360821d3636ec69d">prod</a> = -alpha * beta * coeff[n];        <span class="comment">//!&lt; Calcul de -alpha*beta*Ak1k2</span>
<a name="l01153"></a>01153 <span class="comment"></span>                      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> som=0; som&lt;nb_som_elem; som++)
<a name="l01154"></a>01154                         {
<a name="l01155"></a>01155                           s = dom.<a class="code" href="classDomaine.html#a37cc657f1907d53b0d5a573da862af80">get_renum_som_perio</a>(les_elems(k2,som));
<a name="l01156"></a>01156                           <a class="code" href="Assembleur__P__VEFPreP1B_8cpp.html#a1ba6a21d7cd10f7974541a879696c5db">range</a>(prod,k1,nb_elem,s,nb_som,A01RR,A01RV,A01VR,A01VV);
<a name="l01157"></a>01157                           <span class="keywordflow">if</span> (k1!=k2)
<a name="l01158"></a>01158                             {
<a name="l01159"></a>01159                               s = dom.<a class="code" href="classDomaine.html#a37cc657f1907d53b0d5a573da862af80">get_renum_som_perio</a>(les_elems(k1,som));
<a name="l01160"></a>01160                               <a class="code" href="Assembleur__P__VEFPreP1B_8cpp.html#a1ba6a21d7cd10f7974541a879696c5db">range</a>(prod,k2,nb_elem,s,nb_som,A01RR,A01RV,A01VR,A01VV);
<a name="l01161"></a>01161                             }
<a name="l01162"></a>01162                         }
<a name="l01163"></a>01163                     }
<a name="l01164"></a>01164                 }
<a name="l01165"></a>01165             }
<a name="l01166"></a>01166           colonne+=nb_colonnes;
<a name="l01167"></a>01167         }
<a name="l01168"></a>01168       ligne+=nb_lignes;
<a name="l01169"></a>01169     }
<a name="l01170"></a>01170 }
<a name="l01171"></a>01171 
<a name="l01172"></a><a class="code" href="classAssembleur__P__VEFPreP1B.html#a1aebbbfd89e1ef2e187eca8c32a976f2">01172</a> <span class="keywordtype">void</span> <a class="code" href="classAssembleur__P__VEFPreP1B.html#a1aebbbfd89e1ef2e187eca8c32a976f2" title="A-&gt;A~ (P0+P1-&gt;P1Bulle)">Assembleur_P_VEFPreP1B::changer_base_matrice</a>(<a class="code" href="classMatrice.html">Matrice</a>&amp; la_matrice)
<a name="l01173"></a>01173 {
<a name="l01174"></a>01174   assert(<a class="code" href="classAssembleur__P__VEFPreP1B.html#a3b4a812a062b850be5966f8c6e201cee">zone_Vef</a>().get_alphaE() &amp;&amp; <a class="code" href="classAssembleur__P__VEFPreP1B.html#a3b4a812a062b850be5966f8c6e201cee">zone_Vef</a>().get_alphaS() &amp;&amp; !<a class="code" href="classAssembleur__P__VEFPreP1B.html#a3b4a812a062b850be5966f8c6e201cee">zone_Vef</a>().get_alphaA()); <span class="comment">//!&lt; P0+P1 uniquement</span>
<a name="l01175"></a>01175 <span class="comment"></span>  <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Changement de base pour la matrice: P0+P1-&gt;P1Bulle&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
<a name="l01176"></a>01176   <a class="code" href="classMatrice__Bloc__Sym.html">Matrice_Bloc_Sym</a>&amp; matrice=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Bloc__Sym.html">Matrice_Bloc_Sym</a>, la_matrice.<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>());
<a name="l01177"></a>01177   <a class="code" href="classMatrice__Bloc.html">Matrice_Bloc</a>&amp; A00=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Bloc.html">Matrice_Bloc</a>, matrice.<a class="code" href="classMatrice__Bloc__Sym.html#a1002ce880ea2b2fb48dae444097c9f7a" title="(0&lt;=i&lt;N , i&lt;=j&lt;M)">get_bloc</a>(0,0).<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>());
<a name="l01178"></a>01178   <a class="code" href="classMatrice__Bloc.html">Matrice_Bloc</a>&amp; A01=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Bloc.html">Matrice_Bloc</a>, matrice.<a class="code" href="classMatrice__Bloc__Sym.html#a1002ce880ea2b2fb48dae444097c9f7a" title="(0&lt;=i&lt;N , i&lt;=j&lt;M)">get_bloc</a>(0,1).<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>());
<a name="l01179"></a>01179   <a class="code" href="classMatrice__Bloc.html">Matrice_Bloc</a>&amp; A11=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Bloc.html">Matrice_Bloc</a>, matrice.<a class="code" href="classMatrice__Bloc__Sym.html#a1002ce880ea2b2fb48dae444097c9f7a" title="(0&lt;=i&lt;N , i&lt;=j&lt;M)">get_bloc</a>(1,1).<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>());
<a name="l01180"></a>01180 
<a name="l01181"></a>01181 <span class="comment">// Modification du bloc A11</span>
<a name="l01182"></a>01182 <span class="comment">// As1s2~=As1s2-beta*[somme(Ak1s2)(s1 appartient a k1)+somme(Ak1s1)(s2 appartenant a k1)]+beta*beta*somme(Ak1k2)(s1 appartenant a k1 et s2 appartenant a k2)</span>
<a name="l01183"></a>01183   <a class="code" href="Assembleur__P__VEFPreP1B_8cpp.html#ad34510dd4da2194051998525655e62f9">operation11</a>(A00,A01,A11,<a class="code" href="classAssembleur__P__VEFPreP1B.html#a411ad82b856d17a1c8d942728a48f9a0" title="Coefficients du changement de base P0+P1&lt;-&gt;P1Bulle.">beta</a>,<a class="code" href="classAssembleur__P__VEFPreP1B.html#a3b4a812a062b850be5966f8c6e201cee">zone_Vef</a>().zone());
<a name="l01184"></a>01184 
<a name="l01185"></a>01185 <span class="comment">// Modification du bloc A01</span>
<a name="l01186"></a>01186 <span class="comment">// Ak1s~=alpha*Ak1s - alpha*beta*somme(Ak1k2)(s appartenant a k2)</span>
<a name="l01187"></a>01187   A01*=<a class="code" href="classAssembleur__P__VEFPreP1B.html#ae3dad2978525b28edcb08db30d0ce641">alpha</a>;
<a name="l01188"></a>01188   <a class="code" href="Assembleur__P__VEFPreP1B_8cpp.html#a092a07cbd42b28d79c8d8d04e835fd91">operation01</a>(A00,A01,<a class="code" href="classAssembleur__P__VEFPreP1B.html#ae3dad2978525b28edcb08db30d0ce641">alpha</a>,<a class="code" href="classAssembleur__P__VEFPreP1B.html#a411ad82b856d17a1c8d942728a48f9a0" title="Coefficients du changement de base P0+P1&lt;-&gt;P1Bulle.">beta</a>,<a class="code" href="classAssembleur__P__VEFPreP1B.html#a3b4a812a062b850be5966f8c6e201cee">zone_Vef</a>().zone());
<a name="l01189"></a>01189 
<a name="l01190"></a>01190 <span class="comment">// Modification du bloc A00</span>
<a name="l01191"></a>01191 <span class="comment">// Ak1k2~ = alpha * alpha * Ak1k2</span>
<a name="l01192"></a>01192   A00*=<a class="code" href="classAssembleur__P__VEFPreP1B.html#ae3dad2978525b28edcb08db30d0ce641">alpha</a>*<a class="code" href="classAssembleur__P__VEFPreP1B.html#ae3dad2978525b28edcb08db30d0ce641">alpha</a>;
<a name="l01193"></a>01193 }
<a name="l01194"></a>01194 
<a name="l01195"></a>01195 
<a name="l01196"></a><a class="code" href="classAssembleur__P__VEFPreP1B.html#a163d9e93dac32382f803926e4cde4660">01196</a> <span class="keywordtype">void</span> <a class="code" href="classAssembleur__P__VEFPreP1B.html#a163d9e93dac32382f803926e4cde4660" title="y-&gt;y~ (P0+P1-&gt;P1Bulle)">Assembleur_P_VEFPreP1B::changer_base_second_membre</a>(<a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; y)
<a name="l01197"></a>01197 {
<a name="l01198"></a>01198   assert(<a class="code" href="classAssembleur__P__VEFPreP1B.html#a3b4a812a062b850be5966f8c6e201cee">zone_Vef</a>().get_alphaE() &amp;&amp; <a class="code" href="classAssembleur__P__VEFPreP1B.html#a3b4a812a062b850be5966f8c6e201cee">zone_Vef</a>().get_alphaS() &amp;&amp; !<a class="code" href="classAssembleur__P__VEFPreP1B.html#a3b4a812a062b850be5966f8c6e201cee">zone_Vef</a>().get_alphaA()); <span class="comment">//!&lt; P0+P1 uniquement ys~ = ys - beta * somme(yk)(s appartenant a k) yk~ = alpha * yk</span>
<a name="l01199"></a>01199 <span class="comment"></span><span class="comment">//</span>
<a name="l01200"></a>01200 <span class="comment">//</span>
<a name="l01201"></a>01201   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; les_elems=<a class="code" href="classAssembleur__P__VEFPreP1B.html#a3b4a812a062b850be5966f8c6e201cee">zone_Vef</a>().<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#ac115e8342be89afb882b7b61cc343267" title="Renvoie le tableau des sommets des elements.">les_elems</a>();
<a name="l01202"></a>01202   <span class="keyword">const</span> <a class="code" href="classDomaine.html" title="Classe Domaine Un Domaine represente le domaine (spatial) de resolution d&#39;un Probleme. Un Domaine a un Nom, il est constitue d&#39;une ou plusieurs Zone qui peuvent etre eventuellement decoupees en Sous_Zone. Un Domaine porte l&#39;ensemble des sommets utilises par ses Zones. On peut vouloir resoudre des problemes de type different sur plusieurs domaines, geometriquement les domaines sont alors couples par des surfaces qu&#39;on appelle Raccord.">Domaine</a>&amp; dom=<a class="code" href="classAssembleur__P__VEFPreP1B.html#a3b4a812a062b850be5966f8c6e201cee">zone_Vef</a>().<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#a379ad2206b5a13a4f4f3df6d44c7546a" title="Renvoie le domaine dont la zone fait partie. (version const)">domaine</a>();
<a name="l01203"></a>01203   <span class="keywordtype">int</span> nb_elem_tot=<a class="code" href="classAssembleur__P__VEFPreP1B.html#a3b4a812a062b850be5966f8c6e201cee">zone_Vef</a>().<a class="code" href="classZone__dis__base.html#a4d6aa445f152aa6dc54d66ea7a071147">nb_elem_tot</a>();
<a name="l01204"></a>01204   <span class="keywordtype">int</span> nb_som_elem=les_elems.<a class="code" href="classIntTab.html#abc3b32c94925a82f69d5b153a356e359" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(1);
<a name="l01205"></a>01205   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k=0; k&lt;nb_elem_tot; k++)
<a name="l01206"></a>01206     {
<a name="l01207"></a>01207       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> som=0; som&lt;nb_som_elem; som++)
<a name="l01208"></a>01208         {
<a name="l01209"></a>01209           <span class="keywordtype">int</span> s = nb_elem_tot+dom.<a class="code" href="classDomaine.html#a37cc657f1907d53b0d5a573da862af80">get_renum_som_perio</a>(les_elems(k,som));
<a name="l01210"></a>01210           y(s) -= <a class="code" href="classAssembleur__P__VEFPreP1B.html#a411ad82b856d17a1c8d942728a48f9a0" title="Coefficients du changement de base P0+P1&lt;-&gt;P1Bulle.">beta</a> * y(k);
<a name="l01211"></a>01211         }
<a name="l01212"></a>01212       y(k) *= <a class="code" href="classAssembleur__P__VEFPreP1B.html#ae3dad2978525b28edcb08db30d0ce641">alpha</a>;
<a name="l01213"></a>01213     }
<a name="l01214"></a>01214   y.<a class="code" href="classDoubleVect.html#abfebbc2f685ce7bc4b80c720d7da9bf3">echange_espace_virtuel</a>();
<a name="l01215"></a>01215 }
<a name="l01216"></a>01216 
<a name="l01217"></a><a class="code" href="classAssembleur__P__VEFPreP1B.html#a4e57094c4613e2cd895f9fb52d47a233">01217</a> <span class="keywordtype">void</span> <a class="code" href="classAssembleur__P__VEFPreP1B.html#a4e57094c4613e2cd895f9fb52d47a233" title="x~-&gt;x (P1Bulle-&gt;P0+P1)">Assembleur_P_VEFPreP1B::changer_base_pression_inverse</a>(<a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; x)<span class="keyword"> const</span>
<a name="l01218"></a>01218 <span class="keyword"></span>{
<a name="l01219"></a>01219   assert(<a class="code" href="classAssembleur__P__VEFPreP1B.html#a3b4a812a062b850be5966f8c6e201cee">zone_Vef</a>().get_alphaE() &amp;&amp; <a class="code" href="classAssembleur__P__VEFPreP1B.html#a3b4a812a062b850be5966f8c6e201cee">zone_Vef</a>().get_alphaS() &amp;&amp; !<a class="code" href="classAssembleur__P__VEFPreP1B.html#a3b4a812a062b850be5966f8c6e201cee">zone_Vef</a>().get_alphaA()); <span class="comment">//!&lt; P0+P1 uniquement xk = alpha * xk~ - beta * somme(xs~)(s appartenant a k) xs = xs~</span>
<a name="l01220"></a>01220 <span class="comment"></span><span class="comment">//</span>
<a name="l01221"></a>01221 <span class="comment">//</span>
<a name="l01222"></a>01222   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; les_elems=<a class="code" href="classAssembleur__P__VEFPreP1B.html#a3b4a812a062b850be5966f8c6e201cee">zone_Vef</a>().<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#ac115e8342be89afb882b7b61cc343267" title="Renvoie le tableau des sommets des elements.">les_elems</a>();
<a name="l01223"></a>01223   <span class="keyword">const</span> <a class="code" href="classDomaine.html" title="Classe Domaine Un Domaine represente le domaine (spatial) de resolution d&#39;un Probleme. Un Domaine a un Nom, il est constitue d&#39;une ou plusieurs Zone qui peuvent etre eventuellement decoupees en Sous_Zone. Un Domaine porte l&#39;ensemble des sommets utilises par ses Zones. On peut vouloir resoudre des problemes de type different sur plusieurs domaines, geometriquement les domaines sont alors couples par des surfaces qu&#39;on appelle Raccord.">Domaine</a>&amp; dom=<a class="code" href="classAssembleur__P__VEFPreP1B.html#a3b4a812a062b850be5966f8c6e201cee">zone_Vef</a>().<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#a379ad2206b5a13a4f4f3df6d44c7546a" title="Renvoie le domaine dont la zone fait partie. (version const)">domaine</a>();
<a name="l01224"></a>01224   <span class="keywordtype">int</span> nb_elem_tot=<a class="code" href="classAssembleur__P__VEFPreP1B.html#a3b4a812a062b850be5966f8c6e201cee">zone_Vef</a>().<a class="code" href="classZone__dis__base.html#a4d6aa445f152aa6dc54d66ea7a071147">nb_elem_tot</a>();
<a name="l01225"></a>01225   <span class="keywordtype">int</span> nb_som_elem=les_elems.<a class="code" href="classIntTab.html#abc3b32c94925a82f69d5b153a356e359" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(1);
<a name="l01226"></a>01226   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k=0; k&lt;nb_elem_tot; k++)
<a name="l01227"></a>01227     {
<a name="l01228"></a>01228       <span class="keywordtype">double</span> somme=0;
<a name="l01229"></a>01229       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> som=0; som&lt;nb_som_elem; som++)
<a name="l01230"></a>01230         {
<a name="l01231"></a>01231           <span class="keywordtype">int</span> s = nb_elem_tot+dom.<a class="code" href="classDomaine.html#a37cc657f1907d53b0d5a573da862af80">get_renum_som_perio</a>(les_elems(k,som));
<a name="l01232"></a>01232           somme += x(s);
<a name="l01233"></a>01233         }
<a name="l01234"></a>01234       x(k) = <a class="code" href="classAssembleur__P__VEFPreP1B.html#ae3dad2978525b28edcb08db30d0ce641">alpha</a> * x(k) - <a class="code" href="classAssembleur__P__VEFPreP1B.html#a411ad82b856d17a1c8d942728a48f9a0" title="Coefficients du changement de base P0+P1&lt;-&gt;P1Bulle.">beta</a> * somme;
<a name="l01235"></a>01235     }
<a name="l01236"></a>01236   assert(<a class="code" href="Check__espace__virtuel_8cpp.html#ab72bd6ba208050e04da28b8365e95b94" title="Verifie si le vecteur v a son espace virtuel a jour. Cette fonction doit etre appelee simultanement p...">check_espace_virtuel_vect</a>(x));
<a name="l01237"></a>01237 }
<a name="l01238"></a>01238 
<a name="l01239"></a><a class="code" href="classAssembleur__P__VEFPreP1B.html#a3f12c572633ef578d9a0f9d2d0f3506e">01239</a> <span class="keywordtype">void</span> <a class="code" href="classAssembleur__P__VEFPreP1B.html#a3f12c572633ef578d9a0f9d2d0f3506e" title="x-&gt;x~ (P0+P1-&gt;P1Bulle) Ne sert que pour les tests">Assembleur_P_VEFPreP1B::changer_base_pression</a>(<a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; x)
<a name="l01240"></a>01240 {
<a name="l01241"></a>01241   assert(<a class="code" href="classAssembleur__P__VEFPreP1B.html#a3b4a812a062b850be5966f8c6e201cee">zone_Vef</a>().get_alphaE() &amp;&amp; <a class="code" href="classAssembleur__P__VEFPreP1B.html#a3b4a812a062b850be5966f8c6e201cee">zone_Vef</a>().get_alphaS() &amp;&amp; !<a class="code" href="classAssembleur__P__VEFPreP1B.html#a3b4a812a062b850be5966f8c6e201cee">zone_Vef</a>().get_alphaA()); <span class="comment">//!&lt; P0+P1 uniquement xk~ = xk / alpha + beta / alpha * somme(xs)(s appartenant a k) xs~ = xs</span>
<a name="l01242"></a>01242 <span class="comment"></span><span class="comment">//</span>
<a name="l01243"></a>01243 <span class="comment">//</span>
<a name="l01244"></a>01244   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; les_elems=<a class="code" href="classAssembleur__P__VEFPreP1B.html#a3b4a812a062b850be5966f8c6e201cee">zone_Vef</a>().<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#ac115e8342be89afb882b7b61cc343267" title="Renvoie le tableau des sommets des elements.">les_elems</a>();
<a name="l01245"></a>01245   <span class="keyword">const</span> <a class="code" href="classDomaine.html" title="Classe Domaine Un Domaine represente le domaine (spatial) de resolution d&#39;un Probleme. Un Domaine a un Nom, il est constitue d&#39;une ou plusieurs Zone qui peuvent etre eventuellement decoupees en Sous_Zone. Un Domaine porte l&#39;ensemble des sommets utilises par ses Zones. On peut vouloir resoudre des problemes de type different sur plusieurs domaines, geometriquement les domaines sont alors couples par des surfaces qu&#39;on appelle Raccord.">Domaine</a>&amp; dom=<a class="code" href="classAssembleur__P__VEFPreP1B.html#a3b4a812a062b850be5966f8c6e201cee">zone_Vef</a>().<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#a379ad2206b5a13a4f4f3df6d44c7546a" title="Renvoie le domaine dont la zone fait partie. (version const)">domaine</a>();
<a name="l01246"></a>01246   <span class="keywordtype">int</span> nb_elem_tot=<a class="code" href="classAssembleur__P__VEFPreP1B.html#a3b4a812a062b850be5966f8c6e201cee">zone_Vef</a>().<a class="code" href="classZone__dis__base.html#a4d6aa445f152aa6dc54d66ea7a071147">nb_elem_tot</a>();
<a name="l01247"></a>01247   <span class="keywordtype">int</span> nb_som_elem=les_elems.<a class="code" href="classIntTab.html#abc3b32c94925a82f69d5b153a356e359" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(1);
<a name="l01248"></a>01248   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k=0; k&lt;nb_elem_tot; k++)
<a name="l01249"></a>01249     {
<a name="l01250"></a>01250       x(k) /= <a class="code" href="classAssembleur__P__VEFPreP1B.html#ae3dad2978525b28edcb08db30d0ce641">alpha</a>;
<a name="l01251"></a>01251       <span class="keywordtype">double</span> somme=0;
<a name="l01252"></a>01252       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> som=0; som&lt;nb_som_elem; som++)
<a name="l01253"></a>01253         {
<a name="l01254"></a>01254           <span class="keywordtype">int</span> s = nb_elem_tot+dom.<a class="code" href="classDomaine.html#a37cc657f1907d53b0d5a573da862af80">get_renum_som_perio</a>(les_elems(k,som));
<a name="l01255"></a>01255           somme += x(s);
<a name="l01256"></a>01256         }
<a name="l01257"></a>01257       x(k) += <a class="code" href="classAssembleur__P__VEFPreP1B.html#a411ad82b856d17a1c8d942728a48f9a0" title="Coefficients du changement de base P0+P1&lt;-&gt;P1Bulle.">beta</a> / <a class="code" href="classAssembleur__P__VEFPreP1B.html#ae3dad2978525b28edcb08db30d0ce641">alpha</a> * somme;
<a name="l01258"></a>01258     }
<a name="l01259"></a>01259   assert(<a class="code" href="Check__espace__virtuel_8cpp.html#ab72bd6ba208050e04da28b8365e95b94" title="Verifie si le vecteur v a son espace virtuel a jour. Cette fonction doit etre appelee simultanement p...">check_espace_virtuel_vect</a>(x));
<a name="l01260"></a>01260 }
<a name="l01261"></a>01261 
</pre></div></div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Tue Dec 14 2021 19:35:29 for TRUST by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
