<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>TRUST: src/VEF/Operateurs/Op_Conv_Muscl_New_VEF_Face.cpp Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">TRUST&#160;<span id="projectnumber">1.8.4</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
<div class="header">
  <div class="headertitle">
<div class="title">src/VEF/Operateurs/Op_Conv_Muscl_New_VEF_Face.cpp</div>  </div>
</div>
<div class="contents">
<a href="Op__Conv__Muscl__New__VEF__Face_8cpp.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/****************************************************************************</span>
<a name="l00002"></a>00002 <span class="comment">* Copyright (c) 2015 - 2016, CEA</span>
<a name="l00003"></a>00003 <span class="comment">* All rights reserved.</span>
<a name="l00004"></a>00004 <span class="comment">*</span>
<a name="l00005"></a>00005 <span class="comment">* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</span>
<a name="l00006"></a>00006 <span class="comment">* 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.</span>
<a name="l00007"></a>00007 <span class="comment">* 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.</span>
<a name="l00008"></a>00008 <span class="comment">* 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.</span>
<a name="l00009"></a>00009 <span class="comment">*</span>
<a name="l00010"></a>00010 <span class="comment">* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.</span>
<a name="l00011"></a>00011 <span class="comment">* IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;</span>
<a name="l00012"></a>00012 <span class="comment">* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>
<a name="l00013"></a>00013 <span class="comment">*</span>
<a name="l00014"></a>00014 <span class="comment">*****************************************************************************/</span>
<a name="l00015"></a>00015 <span class="comment">//</span>
<a name="l00016"></a>00016 <span class="comment">// </span>
<a name="l00017"></a>00017 <span class="comment">// File:        Op_Conv_Muscl_New_VEF_Face.cpp</span>
<a name="l00018"></a>00018 <span class="comment">// Directory:   $TRUST_ROOT/src/VEF/Operateurs</span>
<a name="l00019"></a>00019 <span class="comment">// Version:     /main/11</span>
<a name="l00020"></a>00020 <span class="comment">// </span>
<a name="l00021"></a>00021 <span class="comment">//</span>
<a name="l00022"></a>00022 
<a name="l00023"></a>00023 <span class="preprocessor">#include &lt;<a class="code" href="Op__Conv__Muscl__New__VEF__Face_8h.html">Op_Conv_Muscl_New_VEF_Face.h</a>&gt;</span>
<a name="l00024"></a>00024 <span class="preprocessor">#include &lt;<a class="code" href="Champ__P1NC_8h.html">Champ_P1NC.h</a>&gt;</span>
<a name="l00025"></a>00025 <span class="preprocessor">#include &lt;<a class="code" href="BilanQdmVEF_8h.html">BilanQdmVEF.h</a>&gt;</span>
<a name="l00026"></a>00026 <span class="preprocessor">#include &lt;<a class="code" href="Schema__Temps__base_8h.html">Schema_Temps_base.h</a>&gt;</span>
<a name="l00027"></a>00027 <span class="preprocessor">#include &lt;<a class="code" href="Debog_8h.html">Debog.h</a>&gt;</span>
<a name="l00028"></a>00028 <span class="preprocessor">#include &lt;<a class="code" href="Porosites__champ_8h.html">Porosites_champ.h</a>&gt;</span>
<a name="l00029"></a>00029 <span class="preprocessor">#include &lt;<a class="code" href="Sous__zone__VF_8h.html">Sous_zone_VF.h</a>&gt;</span>
<a name="l00030"></a>00030 <span class="preprocessor">#include &lt;<a class="code" href="Probleme__base_8h.html">Probleme_base.h</a>&gt;</span>
<a name="l00031"></a>00031 <span class="preprocessor">#include &lt;<a class="code" href="ArrOfBit_8h.html">ArrOfBit.h</a>&gt;</span>
<a name="l00032"></a>00032 <span class="preprocessor">#include &lt;<a class="code" href="IntVects_8h.html">IntVects.h</a>&gt;</span>
<a name="l00033"></a>00033 <span class="preprocessor">#include &lt;<a class="code" href="SFichier_8h.html">SFichier.h</a>&gt;</span>
<a name="l00034"></a>00034 <span class="preprocessor">#include &lt;<a class="code" href="IntList_8h.html">IntList.h</a>&gt;</span>
<a name="l00035"></a>00035 <span class="preprocessor">#include &lt;<a class="code" href="DoubleTabs_8h.html">DoubleTabs.h</a>&gt;</span>
<a name="l00036"></a>00036 <span class="preprocessor">#include &lt;<a class="code" href="stat__counters_8h.html">stat_counters.h</a>&gt;</span>
<a name="l00037"></a>00037 
<a name="l00038"></a>00038 <span class="comment">/*</span>
<a name="l00039"></a>00039 <span class="comment">  static inline double vanleer(double r)</span>
<a name="l00040"></a>00040 <span class="comment">{</span>
<a name="l00041"></a>00041 <span class="comment">  if(r&lt;=0.) return 0.;</span>
<a name="l00042"></a>00042 <span class="comment">  return 2.*r/(1.+r);//VanLeer</span>
<a name="l00043"></a>00043 <span class="comment">}</span>
<a name="l00044"></a>00044 <span class="comment">*/</span>
<a name="l00045"></a><a class="code" href="Op__Conv__Muscl__New__VEF__Face_8cpp.html#a3ad2393d9c8829a8cbde8e01c3fddd13">00045</a> <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">double</span> <a class="code" href="Convection__tools_8cpp.html#acd40757070ae472ea829cf1cb522d91a">minmod</a>(<span class="keywordtype">double</span> r)
<a name="l00046"></a>00046 {
<a name="l00047"></a>00047   <span class="keywordflow">if</span> (r&lt;=0.) <span class="keywordflow">return</span> 0.;
<a name="l00048"></a>00048   <span class="keywordflow">if</span> (r&lt;=1.) <span class="keywordflow">return</span> r;
<a name="l00049"></a>00049   <span class="keywordflow">else</span> <span class="keywordflow">return</span> 1.;
<a name="l00050"></a>00050 }
<a name="l00051"></a>00051 <span class="comment">/*</span>
<a name="l00052"></a>00052 <span class="comment">static inline double superbee(double r)</span>
<a name="l00053"></a>00053 <span class="comment">{</span>
<a name="l00054"></a>00054 <span class="comment">  if (r&lt;=0.) return 0.;</span>
<a name="l00055"></a>00055 <span class="comment">  if (r&lt;=.5) return 2.*r;</span>
<a name="l00056"></a>00056 <span class="comment">  if (r&lt;=1.) return 1;</span>
<a name="l00057"></a>00057 <span class="comment">  if (r&lt;=2) return r;</span>
<a name="l00058"></a>00058 <span class="comment">  else return 2.;</span>
<a name="l00059"></a>00059 <span class="comment">}</span>
<a name="l00060"></a>00060 <span class="comment">*/</span>
<a name="l00061"></a><a class="code" href="Op__Conv__Muscl__New__VEF__Face_8cpp.html#abd18971dfe4f2b2333aaf0203d859ca6">00061</a> <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">double</span> <a class="code" href="Op__Conv__Muscl__New__VEF__Face_8cpp.html#abd18971dfe4f2b2333aaf0203d859ca6">optimum</a>(<span class="keywordtype">double</span> a, <span class="keywordtype">double</span> b)
<a name="l00062"></a>00062 {
<a name="l00063"></a>00063   <span class="keywordflow">if</span> (a&gt;=0.)
<a name="l00064"></a>00064     <span class="keywordflow">if</span> (b&gt;=0.)
<a name="l00065"></a>00065       <span class="keywordflow">return</span> (a&lt;=b)?a:b;
<a name="l00066"></a>00066     <span class="keywordflow">else</span>
<a name="l00067"></a>00067       <span class="keywordflow">return</span> 0.;
<a name="l00068"></a>00068   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (b&gt;=0.)
<a name="l00069"></a>00069     <span class="keywordflow">return</span> 0.;
<a name="l00070"></a>00070   <span class="keywordflow">else</span>
<a name="l00071"></a>00071     <span class="keywordflow">return</span> (a&gt;=b)?a:b;
<a name="l00072"></a>00072 }
<a name="l00073"></a>00073 
<a name="l00074"></a><a class="code" href="Op__Conv__Muscl__New__VEF__Face_8cpp.html#afd33dcebc08fc02f1331b7fcd405bd59">00074</a> <a class="code" href="Op__Diff__CoviMAC__Face_8cpp.html#aa86ec8ba612a969d9b4370b775037144">Implemente_instanciable</a>(<a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html" title="class Op_Conv_Muscl_New_VEF_Face Cette classe represente l&#39;operateur de convection associe a une equa...">Op_Conv_Muscl_New_VEF_Face</a>,<span class="stringliteral">&quot;Op_Conv_Muscl_New_VEF_P1NC&quot;</span>,<a class="code" href="classOp__Conv__VEF__Face.html" title="class Op_Conv_VEF_Face Cette classe represente l&#39;operateur de convection associe a une equation de tr...">Op_Conv_VEF_Face</a>);
<a name="l00075"></a>00075 
<a name="l00076"></a>00076 <span class="comment"></span>
<a name="l00077"></a>00077 <span class="comment">////!&lt; printOn </span>
<a name="l00078"></a>00078 <span class="comment"></span><span class="comment">//</span>
<a name="l00079"></a>00079 
<a name="l00080"></a><a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#af69550ea7cba363dae2162d2ff994fe0">00080</a> <a class="code" href="classSortie.html" title="Classe de base des flux de sortie. Elle sait ecrire des types simples&lt;br&gt;(entiers, flottants) et des Ob...">Sortie</a>&amp; <a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#af69550ea7cba363dae2162d2ff994fe0" title="NE FAIT RIEN A surcharger dans les classes derivees.">Op_Conv_Muscl_New_VEF_Face::printOn</a>(<a class="code" href="classSortie.html" title="Classe de base des flux de sortie. Elle sait ecrire des types simples&lt;br&gt;(entiers, flottants) et des Ob...">Sortie</a>&amp; s )<span class="keyword"> const</span>
<a name="l00081"></a>00081 <span class="keyword"></span>{
<a name="l00082"></a>00082   <span class="keywordflow">return</span> s &lt;&lt; <a class="code" href="classObjet__U.html#aa58e9a81c0ddc2c1149053b8f96698ac" title="renvoie la chaine identifiant la classe.">que_suis_je</a>();
<a name="l00083"></a>00083 }
<a name="l00084"></a>00084 <span class="comment"></span>
<a name="l00085"></a>00085 <span class="comment">////!&lt; readOn </span>
<a name="l00086"></a>00086 <span class="comment"></span><span class="comment">//</span>
<a name="l00087"></a>00087 
<a name="l00088"></a><a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#a8bfb304871cfa825d460dd1bdc8f6594">00088</a> <a class="code" href="classEntree.html" title="Classe de definition des operateurs et methodes pour toute lecture dans un flot d&#39;entree (fichier...">Entree</a>&amp; <a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#a8bfb304871cfa825d460dd1bdc8f6594" title="NE FAIT RIEN A surcharger dans les classes derivees.">Op_Conv_Muscl_New_VEF_Face::readOn</a>(<a class="code" href="classEntree.html" title="Classe de definition des operateurs et methodes pour toute lecture dans un flot d&#39;entree (fichier...">Entree</a>&amp; s )
<a name="l00089"></a>00089 {
<a name="l00090"></a>00090 <span class="comment">// Les mots a reconnaitre</span>
<a name="l00091"></a>00091   <a class="code" href="classMotcle.html" title="Une chaine de caractere (Nom) en majuscules.">Motcle</a> motlu, accouverte = <span class="stringliteral">&quot;{&quot;</span> , accfermee = <span class="stringliteral">&quot;}&quot;</span> ;
<a name="l00092"></a>00092   <a class="code" href="classMotcle.html" title="Une chaine de caractere (Nom) en majuscules.">Motcle</a> <a class="code" href="Op__Conv__EF__VEF__P1NC__Stab_8cpp.html#a36b674f178bc8694c4bc14686f6f17bb">limiteur</a>;
<a name="l00093"></a>00093   <a class="code" href="classMotcles.html" title="Un tableau d&#39;objets de la classe Motcle.">Motcles</a> les_mots(8);
<a name="l00094"></a>00094   {
<a name="l00095"></a>00095     les_mots[0] = <span class="stringliteral">&quot;centre&quot;</span>;
<a name="l00096"></a>00096     les_mots[1] = <span class="stringliteral">&quot;amont&quot;</span>;
<a name="l00097"></a>00097     les_mots[2] = <span class="stringliteral">&quot;stab&quot;</span>;
<a name="l00098"></a>00098     les_mots[3] = <span class="stringliteral">&quot;alpha&quot;</span>;
<a name="l00099"></a>00099     les_mots[4] = <span class="stringliteral">&quot;centre_old&quot;</span>;
<a name="l00100"></a>00100     les_mots[5] = <span class="stringliteral">&quot;version&quot;</span>;
<a name="l00101"></a>00101     les_mots[6] = <span class="stringliteral">&quot;limiteur&quot;</span>;
<a name="l00102"></a>00102     les_mots[7] = <span class="stringliteral">&quot;facsec_auto&quot;</span>;
<a name="l00103"></a>00103   }
<a name="l00104"></a>00104   <a class="code" href="classMotcles.html" title="Un tableau d&#39;objets de la classe Motcle.">Motcles</a> les_mots2(3);
<a name="l00105"></a>00105   {
<a name="l00106"></a>00106     les_mots2[0] = <span class="stringliteral">&quot;vanleer&quot;</span>;
<a name="l00107"></a>00107     les_mots2[1] = <span class="stringliteral">&quot;minmod&quot;</span>;
<a name="l00108"></a>00108     les_mots2[2] = <span class="stringliteral">&quot;superbee&quot;</span>;
<a name="l00109"></a>00109   }
<a name="l00110"></a>00110 
<a name="l00111"></a>00111 <span class="comment">// Les variables a instancier</span>
<a name="l00112"></a>00112   <a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#aba93a9d2fdc68f373410c6439c95074c">alpha_</a>=1.;
<a name="l00113"></a>00113   <a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#af79e661742c516fb1f0945636d84f900">centered_</a>=1;
<a name="l00114"></a>00114   <a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#ad596610363f5610f9ab6517b977b3122">upwind_</a>=1;
<a name="l00115"></a>00115   <a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#a2b88ace4b5e403aacf90ce4a6787b76c">stabilized_</a>=1;
<a name="l00116"></a>00116   <a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#af27e616d4be292efae0dcd25ef29278c">old_centered_</a>=0;
<a name="l00117"></a>00117   <a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#a628f5f0e8616ec26b0541bdd128238c8">version_</a>=2;
<a name="l00118"></a>00118   <a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#a1265605bb264c308aa56d6ace2e187a3">limiteur_</a>=&amp;<a class="code" href="Convection__tools_8cpp.html#acd40757070ae472ea829cf1cb522d91a">minmod</a>;
<a name="l00119"></a>00119   <a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#a55d9e35f60df86eecbcc895f3cb72d3c">facsec_auto_</a>=0;
<a name="l00120"></a>00120   <a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#ae5e76d1a00689f96fe333745b2a6c2ef">max_limiteur_</a>=1.;
<a name="l00121"></a>00121 
<a name="l00122"></a>00122 <span class="comment">// Temporaire</span>
<a name="l00123"></a>00123 <span class="comment">// s &gt;&gt; motlu;</span>
<a name="l00124"></a>00124 <span class="comment">// if (motlu!=accouverte)</span>
<a name="l00125"></a>00125 <span class="comment">// {</span>
<a name="l00126"></a>00126 <span class="comment">// if (Process::je_suis_maitre())</span>
<a name="l00127"></a>00127 <span class="comment">// {</span>
<a name="l00128"></a>00128 <span class="comment">// Cerr &lt;&lt; &quot;Erreur Op_Conv_Muscl_New_VEF_Face::readOn()&quot; &lt;&lt; finl;</span>
<a name="l00129"></a>00129 <span class="comment">// Cerr &lt;&lt; &quot;Depuis la 1.6.1, la syntaxe du mot cle MUSCL a change.&quot; &lt;&lt; finl;</span>
<a name="l00130"></a>00130 <span class="comment">// Cerr &lt;&lt; &quot;Il faut commencer par une accolade ouvrante {&quot; &lt;&lt; finl;</span>
<a name="l00131"></a>00131 <span class="comment">// Cerr &lt;&lt; &quot;et les options eventuelles sont entre les accolades:&quot; &lt;&lt; finl;</span>
<a name="l00132"></a>00132 <span class="comment">// Cerr &lt;&lt; &quot;Convection { muscl } -&gt; Convection { muscl { } }&quot; &lt;&lt; finl;</span>
<a name="l00133"></a>00133 
<a name="l00134"></a>00134 <span class="comment">// }</span>
<a name="l00135"></a>00135 <span class="comment">// Process::exit();</span>
<a name="l00136"></a>00136 <span class="comment">// }</span>
<a name="l00137"></a>00137 <span class="comment">// s &gt;&gt; motlu;</span>
<a name="l00138"></a>00138 
<a name="l00139"></a>00139 <span class="comment">// while(motlu!=accfermee)</span>
<a name="l00140"></a>00140 <span class="comment">// {</span>
<a name="l00141"></a>00141 <span class="comment">// int rang=les_mots.search(motlu);</span>
<a name="l00142"></a>00142 
<a name="l00143"></a>00143 <span class="comment">// switch(rang)</span>
<a name="l00144"></a>00144 <span class="comment">// {</span>
<a name="l00145"></a>00145 <span class="comment">// case 0 :</span>
<a name="l00146"></a>00146 
<a name="l00147"></a>00147 <span class="comment">// centered_=1;</span>
<a name="l00148"></a>00148 <span class="comment">// upwind_=0;</span>
<a name="l00149"></a>00149 <span class="comment">// stabilized_=0;</span>
<a name="l00150"></a>00150 <span class="comment">// break;</span>
<a name="l00151"></a>00151 
<a name="l00152"></a>00152 <span class="comment">// case 1 :</span>
<a name="l00153"></a>00153 
<a name="l00154"></a>00154 <span class="comment">// centered_=1;</span>
<a name="l00155"></a>00155 <span class="comment">// upwind_=1;</span>
<a name="l00156"></a>00156 <span class="comment">// stabilized_=0;</span>
<a name="l00157"></a>00157 <span class="comment">// break;</span>
<a name="l00158"></a>00158 
<a name="l00159"></a>00159 <span class="comment">// case 2 :</span>
<a name="l00160"></a>00160 
<a name="l00161"></a>00161 <span class="comment">// centered_=1;</span>
<a name="l00162"></a>00162 <span class="comment">// upwind_=1;</span>
<a name="l00163"></a>00163 <span class="comment">// stabilized_=1;</span>
<a name="l00164"></a>00164 <span class="comment">// break;</span>
<a name="l00165"></a>00165 
<a name="l00166"></a>00166 <span class="comment">// case 3 :</span>
<a name="l00167"></a>00167 
<a name="l00168"></a>00168 <span class="comment">// s &gt;&gt; alpha_;</span>
<a name="l00169"></a>00169 <span class="comment">// break;</span>
<a name="l00170"></a>00170 
<a name="l00171"></a>00171 <span class="comment">// case 4 :</span>
<a name="l00172"></a>00172 
<a name="l00173"></a>00173 <span class="comment">// centered_=1;</span>
<a name="l00174"></a>00174 <span class="comment">// upwind_=0;</span>
<a name="l00175"></a>00175 <span class="comment">// stabilized_=0;</span>
<a name="l00176"></a>00176 <span class="comment">// old_centered_=1;</span>
<a name="l00177"></a>00177 <span class="comment">// break;</span>
<a name="l00178"></a>00178 
<a name="l00179"></a>00179 <span class="comment">// case 5 :</span>
<a name="l00180"></a>00180 
<a name="l00181"></a>00181 <span class="comment">// s&gt;&gt;version_;</span>
<a name="l00182"></a>00182 <span class="comment">// break;</span>
<a name="l00183"></a>00183 
<a name="l00184"></a>00184 <span class="comment">// case 6 :</span>
<a name="l00185"></a>00185 
<a name="l00186"></a>00186 <span class="comment">// s&gt;&gt;limiteur;</span>
<a name="l00187"></a>00187 
<a name="l00188"></a>00188 <span class="comment">// int rang2=les_mots2.search(limiteur);</span>
<a name="l00189"></a>00189 
<a name="l00190"></a>00190 <span class="comment">// switch(rang2)</span>
<a name="l00191"></a>00191 <span class="comment">// {</span>
<a name="l00192"></a>00192 <span class="comment">// case 0 :</span>
<a name="l00193"></a>00193 
<a name="l00194"></a>00194 <span class="comment">// limiteur_=&amp;vanleer;</span>
<a name="l00195"></a>00195 <span class="comment">// max_limiteur_=2.;</span>
<a name="l00196"></a>00196 <span class="comment">// break;</span>
<a name="l00197"></a>00197 
<a name="l00198"></a>00198 <span class="comment">// case 1 :</span>
<a name="l00199"></a>00199 
<a name="l00200"></a>00200 <span class="comment">// limiteur_=&amp;minmod;</span>
<a name="l00201"></a>00201 <span class="comment">// max_limiteur_=1.;</span>
<a name="l00202"></a>00202 <span class="comment">// break;</span>
<a name="l00203"></a>00203 
<a name="l00204"></a>00204 <span class="comment">// case 2 :</span>
<a name="l00205"></a>00205 
<a name="l00206"></a>00206 <span class="comment">// limiteur_=&amp;superbee;</span>
<a name="l00207"></a>00207 <span class="comment">// max_limiteur_=2.;</span>
<a name="l00208"></a>00208 <span class="comment">// break;</span>
<a name="l00209"></a>00209 
<a name="l00210"></a>00210 <span class="comment">// default :</span>
<a name="l00211"></a>00211 
<a name="l00212"></a>00212 <span class="comment">// if (Process::je_suis_maitre())</span>
<a name="l00213"></a>00213 <span class="comment">// {</span>
<a name="l00214"></a>00214 <span class="comment">// Cerr &lt;&lt; &quot;Erreur Op_Conv_Muscl_New_VEF_Face::readOn()&quot; &lt;&lt; finl;</span>
<a name="l00215"></a>00215 <span class="comment">// Cerr &lt;&lt; &quot;Limiteur &quot;&lt;&lt;limiteur&lt;&lt;&quot; non code&quot; &lt;&lt; finl;</span>
<a name="l00216"></a>00216 <span class="comment">// Cerr &lt;&lt; &quot;Sortie du programme&quot; &lt;&lt; finl;</span>
<a name="l00217"></a>00217 <span class="comment">// }</span>
<a name="l00218"></a>00218 <span class="comment">// Process::exit();</span>
<a name="l00219"></a>00219 <span class="comment">// break;</span>
<a name="l00220"></a>00220 <span class="comment">// }</span>
<a name="l00221"></a>00221 
<a name="l00222"></a>00222 <span class="comment">// break;</span>
<a name="l00223"></a>00223 
<a name="l00224"></a>00224 <span class="comment">// case 7 :</span>
<a name="l00225"></a>00225 
<a name="l00226"></a>00226 <span class="comment">// s&gt;&gt;facsec_auto_;</span>
<a name="l00227"></a>00227 <span class="comment">// break;</span>
<a name="l00228"></a>00228 
<a name="l00229"></a>00229 <span class="comment">// default :</span>
<a name="l00230"></a>00230 
<a name="l00231"></a>00231 <span class="comment">// if (Process::je_suis_maitre())</span>
<a name="l00232"></a>00232 <span class="comment">// {</span>
<a name="l00233"></a>00233 <span class="comment">// Cerr &lt;&lt; &quot;Erreur Op_Conv_Muscl_New_VEF_Face::readOn()&quot; &lt;&lt; finl;</span>
<a name="l00234"></a>00234 <span class="comment">// Cerr &lt;&lt; &quot;Mot clef &quot; &lt;&lt; motlu &lt;&lt; &quot; non connu.&quot; &lt;&lt; finl;</span>
<a name="l00235"></a>00235 <span class="comment">// Cerr &lt;&lt; &quot;Sortie du programme.&quot; &lt;&lt; finl;</span>
<a name="l00236"></a>00236 <span class="comment">// }</span>
<a name="l00237"></a>00237 <span class="comment">// Process::exit();</span>
<a name="l00238"></a>00238 <span class="comment">// break;</span>
<a name="l00239"></a>00239 
<a name="l00240"></a>00240 <span class="comment">// }//fin du switch</span>
<a name="l00241"></a>00241 
<a name="l00242"></a>00242 <span class="comment">// //Suite de la lecture</span>
<a name="l00243"></a>00243 <span class="comment">// s &gt;&gt; motlu;</span>
<a name="l00244"></a>00244 
<a name="l00245"></a>00245 <span class="comment">// }//fin du while</span>
<a name="l00246"></a>00246 <span class="comment">// Fin du temporaire</span>
<a name="l00247"></a>00247 
<a name="l00248"></a>00248 
<a name="l00249"></a>00249   <span class="keywordflow">return</span> s;
<a name="l00250"></a>00250 }
<a name="l00251"></a>00251 
<a name="l00252"></a>00252 <span class="comment">/*</span>
<a name="l00253"></a>00253 <span class="comment"> static inline int maximum(const int&amp; i, const int&amp; j)</span>
<a name="l00254"></a>00254 <span class="comment">{</span>
<a name="l00255"></a>00255 <span class="comment">  if (i&lt;j) return j;</span>
<a name="l00256"></a>00256 <span class="comment">  return i;</span>
<a name="l00257"></a>00257 <span class="comment">}</span>
<a name="l00258"></a>00258 <span class="comment">*/</span>
<a name="l00259"></a>00259 
<a name="l00260"></a>00260 <span class="comment">/*</span>
<a name="l00261"></a>00261 <span class="comment"> static inline double maximum(const double&amp; x,</span>
<a name="l00262"></a>00262 <span class="comment">                             const double&amp; y)</span>
<a name="l00263"></a>00263 <span class="comment">{</span>
<a name="l00264"></a>00264 <span class="comment">  if(x&lt;y)</span>
<a name="l00265"></a>00265 <span class="comment">    return y;</span>
<a name="l00266"></a>00266 <span class="comment">  return x;</span>
<a name="l00267"></a>00267 <span class="comment">}</span>
<a name="l00268"></a>00268 <span class="comment">*/</span>
<a name="l00269"></a>00269 <span class="comment">/*</span>
<a name="l00270"></a>00270 <span class="comment">static inline double maximum(const double&amp; x,</span>
<a name="l00271"></a>00271 <span class="comment">                             const double&amp; y,</span>
<a name="l00272"></a>00272 <span class="comment">                             const double&amp; z)</span>
<a name="l00273"></a>00273 <span class="comment">{</span>
<a name="l00274"></a>00274 <span class="comment">  return maximum(maximum(x,y),z);</span>
<a name="l00275"></a>00275 <span class="comment">}</span>
<a name="l00276"></a>00276 <span class="comment">*/</span>
<a name="l00277"></a>00277 <span class="comment">/*</span>
<a name="l00278"></a>00278 <span class="comment">static inline double minimum(const double&amp; x,</span>
<a name="l00279"></a>00279 <span class="comment">                             const double&amp; y)</span>
<a name="l00280"></a>00280 <span class="comment">{</span>
<a name="l00281"></a>00281 <span class="comment">  if(x&gt;y)</span>
<a name="l00282"></a>00282 <span class="comment">    return y;</span>
<a name="l00283"></a>00283 <span class="comment">  return x;</span>
<a name="l00284"></a>00284 <span class="comment">}</span>
<a name="l00285"></a>00285 <span class="comment">*/</span>
<a name="l00286"></a>00286 <span class="comment">/*</span>
<a name="l00287"></a>00287 <span class="comment">static inline double minimum(const double&amp; x,</span>
<a name="l00288"></a>00288 <span class="comment">                             const double&amp; y,</span>
<a name="l00289"></a>00289 <span class="comment">                             const double&amp; z)</span>
<a name="l00290"></a>00290 <span class="comment">{</span>
<a name="l00291"></a>00291 <span class="comment">  return minimum(minimum(x,y),z);</span>
<a name="l00292"></a>00292 <span class="comment">}</span>
<a name="l00293"></a>00293 <span class="comment">*/</span>
<a name="l00294"></a>00294 <span class="comment">/*</span>
<a name="l00295"></a>00295 <span class="comment">  static inline double Dij(int elem,</span>
<a name="l00296"></a>00296 <span class="comment">                         int face_loc_i,</span>
<a name="l00297"></a>00297 <span class="comment">                         int face_loc_j,</span>
<a name="l00298"></a>00298 <span class="comment">                         const DoubleTab&amp; Kij)</span>
<a name="l00299"></a>00299 <span class="comment">{</span>
<a name="l00300"></a>00300 <span class="comment">  const double&amp; kij=Kij(elem,face_loc_i,face_loc_j);</span>
<a name="l00301"></a>00301 <span class="comment">  const double&amp; kji=Kij(elem,face_loc_j,face_loc_i);</span>
<a name="l00302"></a>00302 <span class="comment">  return maximum(-kij,-kji,0);</span>
<a name="l00303"></a>00303 <span class="comment">}</span>
<a name="l00304"></a>00304 <span class="comment">*/</span>
<a name="l00305"></a>00305 
<a name="l00306"></a>00306 <span class="comment">//</span>
<a name="l00307"></a>00307 <span class="comment">// </span>
<a name="l00308"></a>00308 <span class="comment">// Implementation des fonctions</span>
<a name="l00309"></a>00309 <span class="comment">// </span>
<a name="l00310"></a>00310 <span class="comment">// de la classe Op_Conv_Muscl_New_VEF_Face</span>
<a name="l00311"></a>00311 <span class="comment">// </span>
<a name="l00312"></a>00312 <span class="comment">//</span>
<a name="l00313"></a>00313 
<a name="l00314"></a><a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#afde9a8f6daffddcc35a097fd68674797">00314</a> <span class="keywordtype">void</span> <a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#afde9a8f6daffddcc35a097fd68674797">Op_Conv_Muscl_New_VEF_Face::calculer_coefficients_operateur_centre</a>(<a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; Kij, <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; Cij, <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; Sij, <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; Sij2, <span class="keyword">const</span> <span class="keywordtype">int</span>&amp; nb_comp, <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; velocity)<span class="keyword"> const</span>
<a name="l00315"></a>00315 <span class="keyword"></span>{
<a name="l00316"></a>00316   <span class="keyword">const</span> <a class="code" href="classZone__VEF.html" title="class Zone_VEF Classe instanciable qui derive de Zone_VF. Cette classe contient les informations geom...">Zone_VEF</a>&amp; zone_VEF = <a class="code" href="classOp__Conv__VEF__base.html#a6c29a488a6805ba4a9f2f059cdba77ae">la_zone_vef</a>.<a class="code" href="classRef__Zone__VEF.html#aafd9a5ee1a76f290c9c6b5447b0c8d30">valeur</a>();
<a name="l00317"></a>00317   <span class="keyword">const</span> <a class="code" href="classZone__Cl__VEF.html">Zone_Cl_VEF</a>&amp; zone_Cl_VEF = <a class="code" href="classOp__Conv__VEF__base.html#a03f677ee7911706a4f85cd37e0ca4535">la_zcl_vef</a>.<a class="code" href="classRef__Zone__Cl__VEF.html#a0970d7253def65ad4f0c5ce1830fd243">valeur</a>();
<a name="l00318"></a>00318 
<a name="l00319"></a>00319   <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; facette_normales = zone_VEF.<a class="code" href="classZone__VEF.html#a581b1ca0e62c668c92f104351d19fda6">facette_normales</a>();
<a name="l00320"></a>00320   <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; facette_normales_Cl = zone_Cl_VEF.<a class="code" href="classZone__Cl__VEF.html#a83c05e82370553470ed05f10932e0f3f">normales_facettes_Cl</a>();
<a name="l00321"></a>00321   <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; porosite_elem = zone_VEF.<a class="code" href="classZone__VF.html#afd135a1b227731193b1a97b7ed525435">porosite_elem</a>();
<a name="l00322"></a>00322   <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; porosite_face = zone_VEF.<a class="code" href="classZone__VF.html#ad9d74d1d9da9f50ab26768dbbca7711b">porosite_face</a>();
<a name="l00323"></a>00323 
<a name="l00324"></a>00324   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; elem_faces = zone_VEF.<a class="code" href="classZone__VF.html#a067e462dcd3ab92b0f6d945b19e4eb37" title="renvoie le numero de le ieme face de la maille num_elem la facon dont ces faces sont numerotees est l...">elem_faces</a>();
<a name="l00325"></a>00325   <span class="keyword">const</span> <a class="code" href="classIntVect.html">IntVect</a>&amp; rang_elem_non_std = zone_VEF.<a class="code" href="classZone__VEF.html#a4b2171a85e5fc33663a3366acb713584">rang_elem_non_std</a>();
<a name="l00326"></a>00326   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; KEL=zone_VEF.<a class="code" href="classZone__VEF.html#a46693c060b8096fb2595ca72192eea2a">type_elem</a>().<a class="code" href="classDeriv__Elem__VEF__base.html#a2886905d5071be902c77248b69ca0b7b">valeur</a>().<a class="code" href="classElem__VEF__base.html#ab129610ef702aa8c9c98dcb4c7551172">KEL</a>();
<a name="l00327"></a>00327 
<a name="l00328"></a>00328   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_elem_tot = zone_VEF.<a class="code" href="classZone__dis__base.html#a4d6aa445f152aa6dc54d66ea7a071147">nb_elem_tot</a>();
<a name="l00329"></a>00329   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_faces_elem=elem_faces.<a class="code" href="classIntTab.html#abc3b32c94925a82f69d5b153a356e359" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(1);
<a name="l00330"></a>00330   <span class="keyword">const</span> <span class="keywordtype">int</span> nfa7 = zone_VEF.<a class="code" href="classZone__VEF.html#a46693c060b8096fb2595ca72192eea2a">type_elem</a>().<a class="code" href="classElem__VEF.html#a4a34777c0083b38dd34c8a400d5b4e90">nb_facette</a>();
<a name="l00331"></a>00331   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_som_elem = zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#ae0b34a93b9ae8146df2d1884157afe9f" title="Renvoie le nombre de sommets des elements geometriques constituants la zone. Tous les elements de la ...">nb_som_elem</a>();
<a name="l00332"></a>00332   <span class="keyword">const</span> <span class="keywordtype">int</span> marq = <a class="code" href="classOp__Conv__VEF__base.html#ad380b9b9ca1d70282b289838a604a4b0" title="definit si l&#39;on convecte psi avec phi*u ou avec u">phi_u_transportant</a>(<a class="code" href="classMorEqn.html#a615dd9abff96edcb625fa0424a489864" title="Renvoie la reference sur l&#39;equation pointe par MorEqn::mon_equation. (version const)">equation</a>());
<a name="l00333"></a>00333 
<a name="l00334"></a>00334   <span class="keywordtype">int</span> rang=-2;
<a name="l00335"></a>00335   <span class="keywordtype">int</span> fa7=0;
<a name="l00336"></a>00336   <span class="keywordtype">int</span> dim=-1;
<a name="l00337"></a>00337   <span class="keywordtype">int</span> itypcl=-2;
<a name="l00338"></a>00338   <span class="keywordtype">int</span> elem=0;
<a name="l00339"></a>00339   <span class="keywordtype">int</span> facei_loc=-1;
<a name="l00340"></a>00340   <span class="keywordtype">int</span> facej_loc=-1;
<a name="l00341"></a>00341 
<a name="l00342"></a>00342   <span class="keywordtype">double</span> psc=0.;
<a name="l00343"></a>00343   <span class="keywordtype">double</span> porosite=0.;
<a name="l00344"></a>00344 
<a name="l00345"></a>00345   <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a> vc(<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>);
<a name="l00346"></a>00346   <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a> vs(<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>);
<a name="l00347"></a>00347   <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a> vsom(nb_som_elem,<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>);
<a name="l00348"></a>00348 
<a name="l00349"></a>00349   <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> face(<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>+1);
<a name="l00350"></a>00350 
<a name="l00351"></a>00351   assert(Kij.<a class="code" href="classDoubleTab.html#ae6dda48778e7107e1beb723beef1f75b" title="Returns the number of dimensions of the array (&gt;= 1)">nb_dim</a>()==3);
<a name="l00352"></a>00352   assert(Kij.<a class="code" href="classDoubleTab.html#ac3805e2637a3b880ba2d3e650c69dac4" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(0)==nb_elem_tot);
<a name="l00353"></a>00353   assert(Kij.<a class="code" href="classDoubleTab.html#ac3805e2637a3b880ba2d3e650c69dac4" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(1)==Kij.<a class="code" href="classDoubleTab.html#ac3805e2637a3b880ba2d3e650c69dac4" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(2));
<a name="l00354"></a>00354   assert(Kij.<a class="code" href="classDoubleTab.html#ac3805e2637a3b880ba2d3e650c69dac4" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(1)==nb_faces_elem);
<a name="l00355"></a>00355 
<a name="l00356"></a>00356   assert(Cij.<a class="code" href="classDoubleTab.html#ae6dda48778e7107e1beb723beef1f75b" title="Returns the number of dimensions of the array (&gt;= 1)">nb_dim</a>()==2);
<a name="l00357"></a>00357   assert(Cij.<a class="code" href="classDoubleTab.html#ac3805e2637a3b880ba2d3e650c69dac4" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(0)==nb_elem_tot);
<a name="l00358"></a>00358   assert(Cij.<a class="code" href="classDoubleTab.html#ac3805e2637a3b880ba2d3e650c69dac4" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(1)==nfa7);
<a name="l00359"></a>00359 
<a name="l00360"></a>00360   assert(Sij.<a class="code" href="classDoubleTab.html#ae6dda48778e7107e1beb723beef1f75b" title="Returns the number of dimensions of the array (&gt;= 1)">nb_dim</a>()==2);
<a name="l00361"></a>00361   assert(Sij.<a class="code" href="classDoubleTab.html#ac3805e2637a3b880ba2d3e650c69dac4" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(0)==nb_elem_tot);
<a name="l00362"></a>00362   assert(Sij.<a class="code" href="classDoubleTab.html#ac3805e2637a3b880ba2d3e650c69dac4" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(1)==nfa7);
<a name="l00363"></a>00363 
<a name="l00364"></a>00364   <span class="keywordflow">if</span> (<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>==3)
<a name="l00365"></a>00365     {
<a name="l00366"></a>00366       assert(Sij2.<a class="code" href="classDoubleTab.html#ae6dda48778e7107e1beb723beef1f75b" title="Returns the number of dimensions of the array (&gt;= 1)">nb_dim</a>()==2);
<a name="l00367"></a>00367       assert(Sij2.<a class="code" href="classDoubleTab.html#ac3805e2637a3b880ba2d3e650c69dac4" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(0)==nb_elem_tot);
<a name="l00368"></a>00368       assert(Sij2.<a class="code" href="classDoubleTab.html#ac3805e2637a3b880ba2d3e650c69dac4" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(1)==nfa7);
<a name="l00369"></a>00369     }
<a name="l00370"></a>00370 
<a name="l00371"></a>00371 <span class="comment">// </span>
<a name="l00372"></a>00372 <span class="comment">// Calcul des coefficients de l&#39;operateur</span>
<a name="l00373"></a>00373 <span class="comment">// </span>
<a name="l00374"></a>00374   <span class="keywordflow">for</span>(elem=0; elem&lt;nb_elem_tot; elem++)
<a name="l00375"></a>00375     {
<a name="l00376"></a>00376       rang=rang_elem_non_std(elem);
<a name="l00377"></a>00377       itypcl=(rang==-1)?0:zone_Cl_VEF.<a class="code" href="classZone__Cl__VEF.html#a483bdab7690f844ed04e3defe04ec70a">type_elem_Cl</a>(rang);
<a name="l00378"></a>00378 
<a name="l00379"></a>00379       <span class="keywordflow">for</span> (facei_loc=0; facei_loc&lt;nb_faces_elem; facei_loc++)
<a name="l00380"></a>00380         face(facei_loc)=elem_faces(elem,facei_loc);
<a name="l00381"></a>00381 
<a name="l00382"></a>00382       vs=0.;
<a name="l00383"></a>00383       <span class="keywordflow">for</span> (dim=0; dim&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>; dim++)
<a name="l00384"></a>00384         <span class="keywordflow">for</span> (facei_loc=0; facei_loc&lt;nb_faces_elem; facei_loc++)
<a name="l00385"></a>00385           vs(dim)+=velocity(face(facei_loc),dim);
<a name="l00386"></a>00386 
<a name="l00387"></a>00387       vsom=0;
<a name="l00388"></a>00388       <span class="keywordflow">for</span> (dim=0; dim&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>; dim++)
<a name="l00389"></a>00389         <span class="keywordflow">for</span> (facei_loc=0; facei_loc&lt;nb_faces_elem; facei_loc++)
<a name="l00390"></a>00390           vsom(facei_loc,dim)=vs(dim)-Objet_U::dimension*velocity(face(facei_loc),dim);
<a name="l00391"></a>00391 
<a name="l00392"></a>00392       vc=0.;
<a name="l00393"></a>00393       zone_VEF.<a class="code" href="classZone__VEF.html#a46693c060b8096fb2595ca72192eea2a">type_elem</a>().<a class="code" href="classDeriv__Elem__VEF__base.html#a2886905d5071be902c77248b69ca0b7b">valeur</a>().<a class="code" href="classElem__VEF__base.html#a02b712675ec9d8bbb6571ddbbec33417">calcul_vc</a>(face,vc,vs,vsom,(*this).vitesse(),itypcl,porosite_face);
<a name="l00394"></a>00394       <span class="keywordflow">if</span> (marq==0)
<a name="l00395"></a>00395         {
<a name="l00396"></a>00396           porosite=1./porosite_elem(elem);
<a name="l00397"></a>00397 
<a name="l00398"></a>00398           vsom*=porosite;
<a name="l00399"></a>00399           vs*=porosite;
<a name="l00400"></a>00400           vc*=porosite;
<a name="l00401"></a>00401         }
<a name="l00402"></a>00402 
<a name="l00403"></a>00403       <span class="keywordflow">if</span> (Objet_U::dimension==2)
<a name="l00404"></a>00404         {
<a name="l00405"></a>00405           <span class="keywordflow">if</span> (rang==-1)
<a name="l00406"></a>00406             <span class="keywordflow">for</span> (fa7=0; fa7&lt;nfa7; fa7++)
<a name="l00407"></a>00407               {
<a name="l00408"></a>00408                 facei_loc=KEL(0,fa7);
<a name="l00409"></a>00409                 facej_loc=KEL(1,fa7);
<a name="l00410"></a>00410 
<a name="l00411"></a>00411                 Cij(elem,fa7)=0.;
<a name="l00412"></a>00412                 <span class="keywordflow">for</span> (dim=0; dim&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>; dim++)
<a name="l00413"></a>00413                   Cij(elem,fa7)+=vc(dim)*facette_normales(elem,fa7,dim);
<a name="l00414"></a>00414 
<a name="l00415"></a>00415                 Sij(elem,fa7)=0.;
<a name="l00416"></a>00416                 <span class="keywordflow">for</span> (dim=0; dim&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>; dim++)
<a name="l00417"></a>00417                   Sij(elem,fa7)+=vsom(KEL(2,fa7),dim)*facette_normales(elem,fa7,dim);
<a name="l00418"></a>00418 
<a name="l00419"></a>00419                 psc=Cij(elem,fa7)+Sij(elem,fa7);
<a name="l00420"></a>00420                 psc*=0.5;
<a name="l00421"></a>00421 
<a name="l00422"></a>00422                 Kij(elem,facei_loc,facej_loc)=psc;
<a name="l00423"></a>00423                 Kij(elem,facei_loc,facei_loc)-=psc;<span class="comment">//pour l&#39;aspect LED</span>
<a name="l00424"></a>00424                 Kij(elem,facej_loc,facei_loc)=-psc;
<a name="l00425"></a>00425                 Kij(elem,facej_loc,facej_loc)+=psc;<span class="comment">//pour l&#39;aspect LED</span>
<a name="l00426"></a>00426               }
<a name="l00427"></a>00427           <span class="keywordflow">else</span> <span class="comment">//rang!=-1</span>
<a name="l00428"></a>00428             <span class="keywordflow">for</span> (fa7=0; fa7&lt;nfa7; fa7++)
<a name="l00429"></a>00429               {
<a name="l00430"></a>00430                 facei_loc=KEL(0,fa7);
<a name="l00431"></a>00431                 facej_loc=KEL(1,fa7);
<a name="l00432"></a>00432 
<a name="l00433"></a>00433                 Cij(elem,fa7)=0.;
<a name="l00434"></a>00434                 <span class="keywordflow">for</span> (dim=0; dim&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>; dim++)
<a name="l00435"></a>00435                   Cij(elem,fa7)+=vc(dim)*facette_normales_Cl(rang,fa7,dim);
<a name="l00436"></a>00436 
<a name="l00437"></a>00437                 Sij(elem,fa7)=0.;
<a name="l00438"></a>00438                 <span class="keywordflow">for</span> (dim=0; dim&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>; dim++)
<a name="l00439"></a>00439                   Sij(elem,fa7)+=vsom(KEL(2,fa7),dim)*facette_normales_Cl(rang,fa7,dim);
<a name="l00440"></a>00440 
<a name="l00441"></a>00441                 psc=Cij(elem,fa7)+Sij(elem,fa7);
<a name="l00442"></a>00442                 psc*=0.5;
<a name="l00443"></a>00443 
<a name="l00444"></a>00444                 Kij(elem,facei_loc,facej_loc)=psc;
<a name="l00445"></a>00445                 Kij(elem,facei_loc,facei_loc)-=psc;<span class="comment">//pour l&#39;aspect LED</span>
<a name="l00446"></a>00446                 Kij(elem,facej_loc,facei_loc)=-psc;
<a name="l00447"></a>00447                 Kij(elem,facej_loc,facej_loc)+=psc;<span class="comment">//pour l&#39;aspect LED</span>
<a name="l00448"></a>00448               }
<a name="l00449"></a>00449         }<span class="comment">//fin Objet_U::dimension==2</span>
<a name="l00450"></a>00450       <span class="keywordflow">else</span> <span class="comment">//Objet_U::dimension==3</span>
<a name="l00451"></a>00451         {
<a name="l00452"></a>00452           <span class="keywordflow">if</span> (rang==-1)
<a name="l00453"></a>00453             <span class="keywordflow">for</span> (fa7=0; fa7&lt;nfa7; fa7++)
<a name="l00454"></a>00454               {
<a name="l00455"></a>00455                 facei_loc=KEL(0,fa7);
<a name="l00456"></a>00456                 facej_loc=KEL(1,fa7);
<a name="l00457"></a>00457 
<a name="l00458"></a>00458                 Cij(elem,fa7)=0.;
<a name="l00459"></a>00459                 <span class="keywordflow">for</span> (dim=0; dim&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>; dim++)
<a name="l00460"></a>00460                   Cij(elem,fa7)+=vc(dim)*facette_normales(elem,fa7,dim);
<a name="l00461"></a>00461 
<a name="l00462"></a>00462                 Sij(elem,fa7)=0.;
<a name="l00463"></a>00463                 <span class="keywordflow">for</span> (dim=0; dim&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>; dim++)
<a name="l00464"></a>00464                   Sij(elem,fa7)+=vsom(KEL(2,fa7),dim)*facette_normales(elem,fa7,dim);
<a name="l00465"></a>00465 
<a name="l00466"></a>00466                 Sij2(elem,fa7)=0.;
<a name="l00467"></a>00467                 <span class="keywordflow">for</span> (dim=0; dim&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>; dim++)
<a name="l00468"></a>00468                   Sij2(elem,fa7)+=vsom(KEL(3,fa7),dim)*facette_normales(elem,fa7,dim);
<a name="l00469"></a>00469 
<a name="l00470"></a>00470                 psc=Cij(elem,fa7)+Sij(elem,fa7)+Sij2(elem,fa7);
<a name="l00471"></a>00471                 psc/=3.;
<a name="l00472"></a>00472 
<a name="l00473"></a>00473                 Kij(elem,facei_loc,facej_loc)=psc;
<a name="l00474"></a>00474                 Kij(elem,facei_loc,facei_loc)-=psc;<span class="comment">//pour l&#39;aspect LED</span>
<a name="l00475"></a>00475                 Kij(elem,facej_loc,facei_loc)=-psc;
<a name="l00476"></a>00476                 Kij(elem,facej_loc,facej_loc)+=psc;<span class="comment">//pour l&#39;aspect LED</span>
<a name="l00477"></a>00477               }
<a name="l00478"></a>00478           <span class="keywordflow">else</span> <span class="comment">//rang!=-1</span>
<a name="l00479"></a>00479             <span class="keywordflow">for</span> (fa7=0; fa7&lt;nfa7; fa7++)
<a name="l00480"></a>00480               {
<a name="l00481"></a>00481                 facei_loc=KEL(0,fa7);
<a name="l00482"></a>00482                 facej_loc=KEL(1,fa7);
<a name="l00483"></a>00483 
<a name="l00484"></a>00484                 Cij(elem,fa7)=0.;
<a name="l00485"></a>00485                 <span class="keywordflow">for</span> (dim=0; dim&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>; dim++)
<a name="l00486"></a>00486                   Cij(elem,fa7)+=vc(dim)*facette_normales_Cl(rang,fa7,dim);
<a name="l00487"></a>00487 
<a name="l00488"></a>00488                 Sij(elem,fa7)=0.;
<a name="l00489"></a>00489                 <span class="keywordflow">for</span> (dim=0; dim&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>; dim++)
<a name="l00490"></a>00490                   Sij(elem,fa7)+=vsom(KEL(2,fa7),dim)*facette_normales_Cl(rang,fa7,dim);
<a name="l00491"></a>00491 
<a name="l00492"></a>00492                 Sij2(elem,fa7)=0.;
<a name="l00493"></a>00493                 <span class="keywordflow">for</span> (dim=0; dim&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>; dim++)
<a name="l00494"></a>00494                   Sij2(elem,fa7)+=vsom(KEL(3,fa7),dim)*facette_normales_Cl(rang,fa7,dim);
<a name="l00495"></a>00495 
<a name="l00496"></a>00496                 psc=Cij(elem,fa7)+Sij(elem,fa7)+Sij2(elem,fa7);
<a name="l00497"></a>00497                 psc/=3.;
<a name="l00498"></a>00498 
<a name="l00499"></a>00499                 Kij(elem,facei_loc,facej_loc)=psc;
<a name="l00500"></a>00500                 Kij(elem,facei_loc,facei_loc)-=psc;<span class="comment">//pour l&#39;aspect LED</span>
<a name="l00501"></a>00501                 Kij(elem,facej_loc,facei_loc)=-psc;
<a name="l00502"></a>00502                 Kij(elem,facej_loc,facej_loc)+=psc;<span class="comment">//pour l&#39;aspect LED</span>
<a name="l00503"></a>00503               }
<a name="l00504"></a>00504         }<span class="comment">//fin Objet_U::dimension==3</span>
<a name="l00505"></a>00505     }
<a name="l00506"></a>00506 
<a name="l00507"></a>00507 <span class="comment">// </span>
<a name="l00508"></a>00508 <span class="comment">// Correction des Kij pour Dirichlet !</span>
<a name="l00509"></a>00509 <span class="comment">// </span>
<a name="l00510"></a>00510   {
<a name="l00511"></a>00511     <span class="keywordtype">int</span> nb_bord=zone_Cl_VEF.<a class="code" href="classZone__Cl__dis__base.html#aa6f1df56cfd6e2eae83cc991c7cc9b41" title="Renvoie le nombre de conditions aux limites.">nb_cond_lim</a>();
<a name="l00512"></a>00512 
<a name="l00513"></a>00513     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> n_bord=0; n_bord&lt;nb_bord; n_bord++)
<a name="l00514"></a>00514       {
<a name="l00515"></a>00515         <span class="keyword">const</span> <a class="code" href="classCond__lim.html" title="classe Cond_lim Classe generique servant a representer n&#39;importe quelle classe derivee de la classe C...">Cond_lim</a>&amp; la_cl = zone_Cl_VEF.<a class="code" href="classZone__Cl__dis__base.html#af75e0ed7786863e4d333bfb29d67c323" title="Renvoie la i-ieme condition aux limites. (version const)">les_conditions_limites</a>(n_bord);
<a name="l00516"></a>00516 
<a name="l00517"></a>00517         <span class="keywordflow">if</span> ( (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classDirichlet.html" title="classe Dirichlet Cette classe est la classe de base de la hierarchie des conditions aux limites de ty...">Dirichlet</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>()))
<a name="l00518"></a>00518              || (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classDirichlet__homogene.html" title="Classe Dirichlet_homogene Cette classe est la classe de base de la hierarchie des conditions aux limi...">Dirichlet_homogene</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>()))
<a name="l00519"></a>00519            )
<a name="l00520"></a>00520           {
<a name="l00521"></a>00521 <span class="comment">// On ne fait rien</span>
<a name="l00522"></a>00522           }<span class="comment">//!&lt; sub_type Dirichlet</span>
<a name="l00523"></a>00523 <span class="comment"></span>
<a name="l00524"></a>00524 
<a name="l00525"></a>00525         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classNeumann.html" title="Classe Neumann Cette classe est la classe de base de la hierarchie des conditions aux limites de type...">Neumann</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>()) || <a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classNeumann__homogene.html" title="Classe Neumann_homogene Cette classe est la classe de base de la hierarchie des conditions aux limite...">Neumann_homogene</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>()))
<a name="l00526"></a>00526           {
<a name="l00527"></a>00527 <span class="comment">// On ne fait rien</span>
<a name="l00528"></a>00528           }<span class="comment">//fin du if sur Neumann</span>
<a name="l00529"></a>00529 
<a name="l00530"></a>00530         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classSymetrie.html" title="classe Symetrie Sur les faces de symetrie on a les proprietes suivantes: - composante normale de la v...">Symetrie</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>()))
<a name="l00531"></a>00531           {
<a name="l00532"></a>00532 <span class="comment">// On ne fait rien</span>
<a name="l00533"></a>00533           }<span class="comment">//fin du if sur Symetrie</span>
<a name="l00534"></a>00534 
<a name="l00535"></a>00535         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>()))
<a name="l00536"></a>00536           {
<a name="l00537"></a>00537 <span class="comment">// On ne fait rien</span>
<a name="l00538"></a>00538           }<span class="comment">//fin du if sur Periodique</span>
<a name="l00539"></a>00539 
<a name="l00540"></a>00540         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classEchange__impose__base.html" title="classe Echange_impose_base: Cette condition limite sert uniquement pour l&#39;equation d&#39;energie...">Echange_impose_base</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>()))
<a name="l00541"></a>00541           {
<a name="l00542"></a>00542 <span class="comment">// On ne fait rien</span>
<a name="l00543"></a>00543           }<span class="comment">//fin du if sur Echange_impose_base</span>
<a name="l00544"></a>00544 
<a name="l00545"></a>00545         <span class="keywordflow">else</span>
<a name="l00546"></a>00546           {
<a name="l00547"></a>00547             <span class="keywordflow">if</span> (<a class="code" href="classProcess.html#acd052b99706c577f8a5b6656217cf4c2" title="renvoie 1 si on est sur le processeur maitre du groupe courant (c&#39;est a dire me() == 0)...">Process::je_suis_maitre</a>())
<a name="l00548"></a>00548               {
<a name="l00549"></a>00549                 <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Erreur Op_Conv_Muscl_New_VEF_Face::calculer_coefficients_operateur_centre()&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
<a name="l00550"></a>00550                 <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Condition aux limites &quot;</span> &lt;&lt; la_cl.<a class="code" href="classObjet__U.html#aa58e9a81c0ddc2c1149053b8f96698ac" title="renvoie la chaine identifiant la classe.">que_suis_je</a>() &lt;&lt; <span class="stringliteral">&quot; non codee.&quot;</span>   &lt;&lt; finl;
<a name="l00551"></a>00551                 <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Sortie du programme.&quot;</span> &lt;&lt; finl;
<a name="l00552"></a>00552               }
<a name="l00553"></a>00553             <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">Process::exit</a>();
<a name="l00554"></a>00554           }<span class="comment">//fin du else sur les autres conditions aux limites</span>
<a name="l00555"></a>00555 
<a name="l00556"></a>00556       }<span class="comment">//fin des conditions aux limites</span>
<a name="l00557"></a>00557   }
<a name="l00558"></a>00558 
<a name="l00559"></a>00559 <span class="comment">// </span>
<a name="l00560"></a>00560 <span class="comment">// Fin de la correction des Kij</span>
<a name="l00561"></a>00561 <span class="comment">// </span>
<a name="l00562"></a>00562 }
<a name="l00563"></a>00563 
<a name="l00564"></a>00564 
<a name="l00565"></a>00565 <span class="keywordtype">void</span> <a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#aaf6d31030b81017b92df85d3377d6ae9">Op_Conv_Muscl_New_VEF_Face::</a>
<a name="l00566"></a><a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#aaf6d31030b81017b92df85d3377d6ae9">00566</a> <a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#aaf6d31030b81017b92df85d3377d6ae9">calculer_flux_operateur_centre</a>(<a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; Fij,<span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; Kij,<span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; Cij, <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; Sij, <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; Sij2, <span class="keyword">const</span> <span class="keywordtype">int</span>&amp; nb_comp, <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; velocity, <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; transporte)<span class="keyword"> const</span>
<a name="l00567"></a>00567 <span class="keyword"></span>{
<a name="l00568"></a>00568   <span class="keyword">const</span> <a class="code" href="classZone__VEF.html" title="class Zone_VEF Classe instanciable qui derive de Zone_VF. Cette classe contient les informations geom...">Zone_VEF</a>&amp; zone_VEF = <a class="code" href="classOp__Conv__VEF__base.html#a6c29a488a6805ba4a9f2f059cdba77ae">la_zone_vef</a>.<a class="code" href="classRef__Zone__VEF.html#aafd9a5ee1a76f290c9c6b5447b0c8d30">valeur</a>();
<a name="l00569"></a>00569   <span class="keyword">const</span> <a class="code" href="classZone__Cl__VEF.html">Zone_Cl_VEF</a>&amp; zone_Cl_VEF = <a class="code" href="classOp__Conv__VEF__base.html#a03f677ee7911706a4f85cd37e0ca4535">la_zcl_vef</a>.<a class="code" href="classRef__Zone__Cl__VEF.html#a0970d7253def65ad4f0c5ce1830fd243">valeur</a>();
<a name="l00570"></a>00570   <span class="keyword">const</span> <a class="code" href="classDomaine.html" title="Classe Domaine Un Domaine represente le domaine (spatial) de resolution d&#39;un Probleme. Un Domaine a un Nom, il est constitue d&#39;une ou plusieurs Zone qui peuvent etre eventuellement decoupees en Sous_Zone. Un Domaine porte l&#39;ensemble des sommets utilises par ses Zones. On peut vouloir resoudre des problemes de type different sur plusieurs domaines, geometriquement les domaines sont alors couples par des surfaces qu&#39;on appelle Raccord.">Domaine</a>&amp; domaine = zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#a379ad2206b5a13a4f4f3df6d44c7546a" title="Renvoie le domaine dont la zone fait partie. (version const)">domaine</a>();
<a name="l00571"></a>00571 
<a name="l00572"></a>00572   <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; vecteur_face_facette = <a class="code" href="Cast_8h.html#ad3836a067c92103af8df5ad8f35959a6">ref_cast_non_const</a>(<a class="code" href="classZone__VEF.html" title="class Zone_VEF Classe instanciable qui derive de Zone_VF. Cette classe contient les informations geom...">Zone_VEF</a>,zone_VEF).vecteur_face_facette();
<a name="l00573"></a>00573   <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; vecteur_face_facette_Cl = zone_Cl_VEF.<a class="code" href="classZone__Cl__VEF.html#aa7acf4bf79e075ba2488e2ee9051c6fe">vecteur_face_facette_Cl</a>();
<a name="l00574"></a>00574   <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; coord_sommets = domaine.<a class="code" href="classDomaine.html#aecd32c3eecc15cce7d1a0e468dadbf96" title="Renvoie le tableau des coordonnees des noeuds (sommets). (acces en lecture)">coord_sommets</a>();
<a name="l00575"></a>00575   <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; xv = zone_VEF.<a class="code" href="classZone__VF.html#a918c0885a9b67317fcce3a0535306542">xv</a>();
<a name="l00576"></a>00576 
<a name="l00577"></a>00577   <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; transporteVect=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classDoubleVect.html">DoubleVect</a>,transporte);
<a name="l00578"></a>00578 
<a name="l00579"></a>00579   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; elem_faces = zone_VEF.<a class="code" href="classZone__VF.html#a067e462dcd3ab92b0f6d945b19e4eb37" title="renvoie le numero de le ieme face de la maille num_elem la facon dont ces faces sont numerotees est l...">elem_faces</a>();
<a name="l00580"></a>00580 <span class="comment">// const IntTab&amp; face_voisins = zone_VEF.face_voisins();</span>
<a name="l00581"></a>00581   <span class="keyword">const</span> <a class="code" href="classIntVect.html">IntVect</a>&amp; rang_elem_non_std = zone_VEF.<a class="code" href="classZone__VEF.html#a4b2171a85e5fc33663a3366acb713584">rang_elem_non_std</a>();
<a name="l00582"></a>00582   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; KEL=zone_VEF.<a class="code" href="classZone__VEF.html#a46693c060b8096fb2595ca72192eea2a">type_elem</a>().<a class="code" href="classDeriv__Elem__VEF__base.html#a2886905d5071be902c77248b69ca0b7b">valeur</a>().<a class="code" href="classElem__VEF__base.html#ab129610ef702aa8c9c98dcb4c7551172">KEL</a>();
<a name="l00583"></a>00583 
<a name="l00584"></a>00584   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_elem_tot = zone_VEF.<a class="code" href="classZone__dis__base.html#a4d6aa445f152aa6dc54d66ea7a071147">nb_elem_tot</a>();
<a name="l00585"></a>00585   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_faces_elem=elem_faces.<a class="code" href="classIntTab.html#abc3b32c94925a82f69d5b153a356e359" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(1);
<a name="l00586"></a>00586   <span class="keyword">const</span> <span class="keywordtype">int</span> nfa7 = zone_VEF.<a class="code" href="classZone__VEF.html#a46693c060b8096fb2595ca72192eea2a">type_elem</a>().<a class="code" href="classElem__VEF.html#a4a34777c0083b38dd34c8a400d5b4e90">nb_facette</a>();
<a name="l00587"></a>00587 
<a name="l00588"></a>00588   <span class="keywordtype">int</span> rang=-2;
<a name="l00589"></a>00589   <span class="keywordtype">int</span> fa7=0;
<a name="l00590"></a>00590   <span class="keywordtype">int</span> dim=-1;
<a name="l00591"></a>00591   <span class="keywordtype">int</span> elem=0;
<a name="l00592"></a>00592   <span class="keywordtype">int</span> face_amont=-1;
<a name="l00593"></a>00593   <span class="keywordtype">int</span> dir=-1;
<a name="l00594"></a>00594   <span class="keywordtype">int</span> comp=-1;
<a name="l00595"></a>00595   <span class="keywordtype">int</span> s=-1;
<a name="l00596"></a>00596   <span class="keywordtype">int</span> s2=-1;
<a name="l00597"></a>00597   <span class="keywordtype">int</span> facei=-1;
<a name="l00598"></a>00598   <span class="keywordtype">int</span> facej=-1;
<a name="l00599"></a>00599   <span class="keywordtype">int</span> facei_loc=-1;
<a name="l00600"></a>00600   <span class="keywordtype">int</span> facej_loc=-1;
<a name="l00601"></a>00601 
<a name="l00602"></a>00602   <span class="keywordtype">double</span> inco_m=0.;
<a name="l00603"></a>00603   <span class="keywordtype">double</span> inco_s=0.;
<a name="l00604"></a>00604   <span class="keywordtype">double</span> inco_s2=0.;
<a name="l00605"></a>00605   <span class="keywordtype">double</span> inco_c=0.;
<a name="l00606"></a>00606   <span class="keywordtype">double</span> flux=0.;
<a name="l00607"></a>00607 
<a name="l00608"></a>00608   <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a> gradient_elem(nb_elem_tot,nb_comp,<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>);  <span class="comment">//!&lt; (du/dx du/dy dv/dx dv/dy) pour un poly  gradient_elem=0.;</span>
<a name="l00609"></a>00609 <span class="comment"></span>  <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a> face(<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>+1);
<a name="l00610"></a>00610 
<a name="l00611"></a>00611   assert(Fij.<a class="code" href="classDoubleTab.html#ae6dda48778e7107e1beb723beef1f75b" title="Returns the number of dimensions of the array (&gt;= 1)">nb_dim</a>()==4);
<a name="l00612"></a>00612   assert(Fij.<a class="code" href="classDoubleTab.html#ac3805e2637a3b880ba2d3e650c69dac4" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(0)==nb_elem_tot);
<a name="l00613"></a>00613   assert(Fij.<a class="code" href="classDoubleTab.html#ac3805e2637a3b880ba2d3e650c69dac4" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(1)==Fij.<a class="code" href="classDoubleTab.html#ac3805e2637a3b880ba2d3e650c69dac4" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(2));
<a name="l00614"></a>00614   assert(Fij.<a class="code" href="classDoubleTab.html#ac3805e2637a3b880ba2d3e650c69dac4" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(1)==nb_faces_elem);
<a name="l00615"></a>00615   assert(Fij.<a class="code" href="classDoubleTab.html#ac3805e2637a3b880ba2d3e650c69dac4" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(3)==nb_comp);
<a name="l00616"></a>00616 
<a name="l00617"></a>00617 <span class="comment">// </span>
<a name="l00618"></a>00618 <span class="comment">// Calcul des flux de l&#39;operateur</span>
<a name="l00619"></a>00619 <span class="comment">// </span>
<a name="l00620"></a>00620   <a class="code" href="classChamp__P1NC.html#a87d96c073d3c127684934610f9a1e407">Champ_P1NC::calcul_gradient</a>(transporte,gradient_elem,zone_Cl_VEF);
<a name="l00621"></a>00621 
<a name="l00622"></a>00622   <span class="keywordflow">for</span>(elem=0; elem&lt;nb_elem_tot; elem++)
<a name="l00623"></a>00623     {
<a name="l00624"></a>00624       rang=rang_elem_non_std(elem);
<a name="l00625"></a>00625 
<a name="l00626"></a>00626       <span class="keywordflow">for</span> (facei_loc=0; facei_loc&lt;nb_faces_elem; facei_loc++)
<a name="l00627"></a>00627         face(facei_loc)=elem_faces(elem,facei_loc);
<a name="l00628"></a>00628 
<a name="l00629"></a>00629       <span class="keywordflow">if</span> (<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>==2)
<a name="l00630"></a>00630         {
<a name="l00631"></a>00631           <span class="keywordflow">if</span> (rang==-1)
<a name="l00632"></a>00632             <span class="keywordflow">for</span> (fa7=0; fa7&lt;nfa7; fa7++)
<a name="l00633"></a>00633               {
<a name="l00634"></a>00634                 facei_loc=KEL(0,fa7);
<a name="l00635"></a>00635                 facej_loc=KEL(1,fa7);
<a name="l00636"></a>00636 
<a name="l00637"></a>00637                 facei=face(facei_loc);
<a name="l00638"></a>00638                 facej=face(facej_loc);
<a name="l00639"></a>00639 
<a name="l00640"></a>00640 <span class="comment">// REMARQUE : ON N&#39;OUBLIE PAS QUE LES NORMALES FA7 SONT ORIENTeES DE FACE_LOCI VERS FACE_LOCJ PAR DEFAUT</span>
<a name="l00641"></a>00641 <span class="comment">// LES PRODUITS SCALAIRES PSC_M, PSC_C, PSC_S SONT DONC CALCULeS POUR OBTENIR LE FLUX REcU PAR LA FACE FACE_LOCI</span>
<a name="l00642"></a>00642 <span class="comment">// ET EMIS PAR LA FACE_LOCJ</span>
<a name="l00643"></a>00643 <span class="comment">// SI L&#39;ON VEUT OBTENIR LE FLUX REcU PAR LA FACE FACE_LOCJ ET EMIS PAR LA FACE_LOCI, IL FAUT MULTIPLIER LES</span>
<a name="l00644"></a>00644 <span class="comment">// PRODUITS SCALAIRES PSC_M, PSC_C, PSC_S PAR -1 POUR IMPLICITEMENT ReORIENTER LES NORMALES FA7 DE FACE_LOCJ VERS</span>
<a name="l00645"></a>00645 <span class="comment">// FACE_LOCI</span>
<a name="l00646"></a>00646 <span class="comment">// MEME REMARQUE POUR LE SCALAIRE &quot;FLUX&quot;</span>
<a name="l00647"></a>00647                 <span class="keyword">const</span> <span class="keywordtype">double</span>&amp; psc_m = Kij(elem,facei_loc,facej_loc);
<a name="l00648"></a>00648                 <span class="keyword">const</span> <span class="keywordtype">double</span>&amp; psc_c = Cij(elem,fa7);
<a name="l00649"></a>00649                 <span class="keyword">const</span> <span class="keywordtype">double</span>&amp; psc_s = Sij(elem,fa7);
<a name="l00650"></a>00650 
<a name="l00651"></a>00651                 <span class="keywordflow">if</span> (psc_m&gt;=0.)
<a name="l00652"></a>00652                   face_amont=facei,dir=0;
<a name="l00653"></a>00653                 <span class="keywordflow">else</span>
<a name="l00654"></a>00654                   face_amont=facej,dir=1;
<a name="l00655"></a>00655 
<a name="l00656"></a>00656                 s=zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#aa164c00997bc77a365a6da57bbec29ce" title="Renvoie le numero (global) j-ieme sommet du i-ieme element.">sommet_elem</a>(elem,KEL(2,fa7));
<a name="l00657"></a>00657 
<a name="l00658"></a>00658                 <span class="keywordflow">for</span> (comp=0; comp&lt;nb_comp; comp++)
<a name="l00659"></a>00659                   {
<a name="l00660"></a>00660 <span class="comment">// Calcul de la valeur de l&#39;inconnue aux points d&#39;integration de la formule de Simspon</span>
<a name="l00661"></a>00661                     inco_m=transporteVect[face_amont*nb_comp+comp];
<a name="l00662"></a>00662                     <span class="keywordflow">for</span>(dim=0; dim&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>; dim++)
<a name="l00663"></a>00663                       inco_m+=gradient_elem(elem,comp,dim)*vecteur_face_facette(elem,fa7,dim,dir);
<a name="l00664"></a>00664 
<a name="l00665"></a>00665                     inco_s=transporteVect[face_amont*nb_comp+comp];
<a name="l00666"></a>00666                     <span class="keywordflow">for</span>(dim=0; dim&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>; dim++)
<a name="l00667"></a>00667                       inco_s+=gradient_elem(elem,comp,dim)*(coord_sommets(s,dim)-xv(face_amont,dim));
<a name="l00668"></a>00668 
<a name="l00669"></a>00669                     inco_c=2.*inco_m-inco_s;
<a name="l00670"></a>00670 
<a name="l00671"></a>00671 <span class="comment">// Calcul du flux final : formule d&#39;integration de Simpson</span>
<a name="l00672"></a>00672                     flux=inco_c*psc_c;
<a name="l00673"></a>00673                     flux+=4*inco_m*psc_m;
<a name="l00674"></a>00674                     flux+=inco_s*psc_s;
<a name="l00675"></a>00675                     flux/=6.;
<a name="l00676"></a>00676 
<a name="l00677"></a>00677 <span class="comment">// Fij(elem,facei_loc,facej_loc,comp) est le flux recu par la facei_loc dans elem</span>
<a name="l00678"></a>00678 <span class="comment">// envoye par la face facej_loc dans elem pour la composante comp de l&#39;inconnue</span>
<a name="l00679"></a>00679                     Fij(elem,facei_loc,facej_loc,comp)=flux-psc_m*transporteVect[facei*nb_comp+comp];
<a name="l00680"></a>00680                     Fij(elem,facej_loc,facei_loc,comp)=psc_m*transporteVect[facej*nb_comp+comp]-flux;
<a name="l00681"></a>00681                   }
<a name="l00682"></a>00682               }
<a name="l00683"></a>00683           <span class="keywordflow">else</span> <span class="comment">//rang!=-1</span>
<a name="l00684"></a>00684             <span class="keywordflow">for</span> (fa7=0; fa7&lt;nfa7; fa7++)
<a name="l00685"></a>00685               {
<a name="l00686"></a>00686                 facei_loc=KEL(0,fa7);
<a name="l00687"></a>00687                 facej_loc=KEL(1,fa7);
<a name="l00688"></a>00688 
<a name="l00689"></a>00689                 facei=face(facei_loc);
<a name="l00690"></a>00690                 facej=face(facej_loc);
<a name="l00691"></a>00691 
<a name="l00692"></a>00692 <span class="comment">// REMARQUE : ON N&#39;OUBLIE PAS QUE LES NORMALES FA7 SONT ORIENTeES DE FACE_LOCI VERS FACE_LOCJ PAR DEFAUT</span>
<a name="l00693"></a>00693 <span class="comment">// LES PRODUITS SCALAIRES PSC_M, PSC_C, PSC_S SONT DONC CALCULeS POUR OBTENIR LE FLUX REcU PAR LA FACE FACE_LOCI</span>
<a name="l00694"></a>00694 <span class="comment">// ET EMIS PAR LA FACE_LOCJ</span>
<a name="l00695"></a>00695 <span class="comment">// SI L&#39;ON VEUT OBTENIR LE FLUX REcU PAR LA FACE FACE_LOCJ ET EMIS PAR LA FACE_LOCI, IL FAUT MULTIPLIER LES</span>
<a name="l00696"></a>00696 <span class="comment">// PRODUITS SCALAIRES PSC_M, PSC_C, PSC_S PAR -1 POUR IMPLICITEMENT ReORIENTER LES NORMALES FA7 DE FACE_LOCJ VERS</span>
<a name="l00697"></a>00697 <span class="comment">// FACE_LOCI</span>
<a name="l00698"></a>00698 <span class="comment">// MEME REMARQUE POUR LE SCALAIRE &quot;FLUX&quot;</span>
<a name="l00699"></a>00699                 <span class="keyword">const</span> <span class="keywordtype">double</span>&amp; psc_m = Kij(elem,facei_loc,facej_loc);
<a name="l00700"></a>00700                 <span class="keyword">const</span> <span class="keywordtype">double</span>&amp; psc_c = Cij(elem,fa7);
<a name="l00701"></a>00701                 <span class="keyword">const</span> <span class="keywordtype">double</span>&amp; psc_s = Sij(elem,fa7);
<a name="l00702"></a>00702 
<a name="l00703"></a>00703                 <span class="keywordflow">if</span> (psc_m&gt;=0.)
<a name="l00704"></a>00704                   face_amont=facei,dir=0;
<a name="l00705"></a>00705                 <span class="keywordflow">else</span>
<a name="l00706"></a>00706                   face_amont=facej,dir=1;
<a name="l00707"></a>00707 
<a name="l00708"></a>00708                 s=zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#aa164c00997bc77a365a6da57bbec29ce" title="Renvoie le numero (global) j-ieme sommet du i-ieme element.">sommet_elem</a>(elem,KEL(2,fa7));
<a name="l00709"></a>00709 
<a name="l00710"></a>00710                 <span class="keywordflow">for</span> (comp=0; comp&lt;nb_comp; comp++)
<a name="l00711"></a>00711                   {
<a name="l00712"></a>00712 <span class="comment">// Calcul de la valeur de l&#39;inconnue aux points d&#39;integration de la formule de Simspon</span>
<a name="l00713"></a>00713                     inco_m=transporteVect[face_amont*nb_comp+comp];
<a name="l00714"></a>00714                     <span class="keywordflow">for</span>(dim=0; dim&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>; dim++)
<a name="l00715"></a>00715                       inco_m+=gradient_elem(elem,comp,dim)*vecteur_face_facette_Cl(rang,fa7,dim,dir);
<a name="l00716"></a>00716 
<a name="l00717"></a>00717                     inco_s=transporteVect[face_amont*nb_comp+comp];
<a name="l00718"></a>00718                     <span class="keywordflow">for</span>(dim=0; dim&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>; dim++)
<a name="l00719"></a>00719                       inco_s+=gradient_elem(elem,comp,dim)*(coord_sommets(s,dim)-xv(face_amont,dim));
<a name="l00720"></a>00720 
<a name="l00721"></a>00721                     inco_c=2.*inco_m-inco_s;
<a name="l00722"></a>00722 
<a name="l00723"></a>00723 <span class="comment">// Calcul du flux final : formule d&#39;integration de Simpson</span>
<a name="l00724"></a>00724                     flux=inco_c*psc_c;
<a name="l00725"></a>00725                     flux+=4*inco_m*psc_m;
<a name="l00726"></a>00726                     flux+=inco_s*psc_s;
<a name="l00727"></a>00727                     flux/=6.;
<a name="l00728"></a>00728 
<a name="l00729"></a>00729 <span class="comment">// Fij(elem,facei_loc,facej_loc,comp) est le flux recu par la facei_loc dans elem</span>
<a name="l00730"></a>00730 <span class="comment">// envoye par la face facej_loc dans elem pour la composante comp de l&#39;inconnue</span>
<a name="l00731"></a>00731                     Fij(elem,facei_loc,facej_loc,comp)=flux-psc_m*transporteVect[facei*nb_comp+comp];
<a name="l00732"></a>00732                     Fij(elem,facej_loc,facei_loc,comp)=psc_m*transporteVect[facej*nb_comp+comp]-flux;
<a name="l00733"></a>00733                   }
<a name="l00734"></a>00734               }
<a name="l00735"></a>00735         }<span class="comment">//fin Objet_U::dimension==2</span>
<a name="l00736"></a>00736       <span class="keywordflow">else</span> <span class="comment">//Objet_U::dimension==3</span>
<a name="l00737"></a>00737         {
<a name="l00738"></a>00738           <span class="keywordflow">if</span> (rang==-1)
<a name="l00739"></a>00739             <span class="keywordflow">for</span> (fa7=0; fa7&lt;nfa7; fa7++)
<a name="l00740"></a>00740               {
<a name="l00741"></a>00741                 facei_loc=KEL(0,fa7);
<a name="l00742"></a>00742                 facej_loc=KEL(1,fa7);
<a name="l00743"></a>00743 
<a name="l00744"></a>00744                 facei=face(facei_loc);
<a name="l00745"></a>00745                 facej=face(facej_loc);
<a name="l00746"></a>00746 
<a name="l00747"></a>00747 <span class="comment">// REMARQUE : ON N&#39;OUBLIE PAS QUE LES NORMALES FA7 SONT ORIENTeES DE FACE_LOCI VERS FACE_LOCJ PAR DEFAUT</span>
<a name="l00748"></a>00748 <span class="comment">// LES PRODUITS SCALAIRES PSC_M, PSC_C, PSC_S, PSC_S2 SONT DONC CALCULeS POUR OBTENIR LE FLUX REcU PAR LA FACE FACE_LOCI</span>
<a name="l00749"></a>00749 <span class="comment">// ET EMIS PAR LA FACE_LOCJ</span>
<a name="l00750"></a>00750 <span class="comment">// SI L&#39;ON VEUT OBTENIR LE FLUX REcU PAR LA FACE FACE_LOCJ ET EMIS PAR LA FACE_LOCI, IL FAUT MULTIPLIER LES</span>
<a name="l00751"></a>00751 <span class="comment">// PRODUITS SCALAIRES PSC_M, PSC_C, PSC_S, PSC_S2 PAR -1 POUR IMPLICITEMENT ReORIENTER LES NORMALES FA7 DE FACE_LOCJ VERS</span>
<a name="l00752"></a>00752 <span class="comment">// FACE_LOCI</span>
<a name="l00753"></a>00753 <span class="comment">// MEME REMARQUE POUR LE SCALAIRE &quot;FLUX&quot;</span>
<a name="l00754"></a>00754                 <span class="keyword">const</span> <span class="keywordtype">double</span>&amp; psc_c = Cij(elem,fa7);
<a name="l00755"></a>00755                 <span class="keyword">const</span> <span class="keywordtype">double</span>&amp; psc_s = Sij(elem,fa7);
<a name="l00756"></a>00756                 <span class="keyword">const</span> <span class="keywordtype">double</span>&amp; psc_s2 = Sij2(elem,fa7);
<a name="l00757"></a>00757                 <span class="keyword">const</span> <span class="keywordtype">double</span>&amp; psc_m = Kij(elem,facei_loc,facej_loc);
<a name="l00758"></a>00758 
<a name="l00759"></a>00759                 <span class="keywordflow">if</span> (psc_m&gt;=0.)
<a name="l00760"></a>00760                   face_amont=facei,dir=0;
<a name="l00761"></a>00761                 <span class="keywordflow">else</span>
<a name="l00762"></a>00762                   face_amont=facej,dir=1;
<a name="l00763"></a>00763 
<a name="l00764"></a>00764                 s=zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#aa164c00997bc77a365a6da57bbec29ce" title="Renvoie le numero (global) j-ieme sommet du i-ieme element.">sommet_elem</a>(elem,KEL(2,fa7));
<a name="l00765"></a>00765                 s2=zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#aa164c00997bc77a365a6da57bbec29ce" title="Renvoie le numero (global) j-ieme sommet du i-ieme element.">sommet_elem</a>(elem,KEL(3,fa7));
<a name="l00766"></a>00766 
<a name="l00767"></a>00767                 <span class="keywordflow">for</span> (comp=0; comp&lt;nb_comp; comp++)
<a name="l00768"></a>00768                   {
<a name="l00769"></a>00769 <span class="comment">// Calcul de la valeur de l&#39;inconnue aux points d&#39;integration de la formule 3D</span>
<a name="l00770"></a>00770                     inco_m=transporteVect[face_amont*nb_comp+comp];
<a name="l00771"></a>00771                     <span class="keywordflow">for</span>(dim=0; dim&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>; dim++)
<a name="l00772"></a>00772                       inco_m+=gradient_elem(elem,comp,dim)*vecteur_face_facette(elem,fa7,dim,dir);
<a name="l00773"></a>00773 
<a name="l00774"></a>00774                     inco_s=transporteVect[face_amont*nb_comp+comp];
<a name="l00775"></a>00775                     <span class="keywordflow">for</span>(dim=0; dim&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>; dim++)
<a name="l00776"></a>00776                       inco_s+=gradient_elem(elem,comp,dim)*(coord_sommets(s,dim)-xv(face_amont,dim));
<a name="l00777"></a>00777 
<a name="l00778"></a>00778                     inco_s2=transporteVect[face_amont*nb_comp+comp];
<a name="l00779"></a>00779                     <span class="keywordflow">for</span>(dim=0; dim&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>; dim++)
<a name="l00780"></a>00780                       inco_s2+=gradient_elem(elem,comp,dim)*(coord_sommets(s2,dim)-xv(face_amont,dim));
<a name="l00781"></a>00781 
<a name="l00782"></a>00782                     inco_c=3.*inco_m-inco_s-inco_s2;
<a name="l00783"></a>00783 
<a name="l00784"></a>00784 <span class="comment">// Calcul du flux final : formule d&#39;integration 3D exacte pour les polynomes de degre 2</span>
<a name="l00785"></a>00785                     flux=(inco_s+inco_s2)*(psc_s+psc_s2);
<a name="l00786"></a>00786                     flux+=(inco_s+inco_c)*(psc_s+psc_c);
<a name="l00787"></a>00787                     flux+=(inco_s2+inco_c)*(psc_s2+psc_c);
<a name="l00788"></a>00788                     flux/=12.;
<a name="l00789"></a>00789 
<a name="l00790"></a>00790 <span class="comment">// Fij(elem,facei_loc,facej_loc,comp) est le flux recu par la facei_loc dans elem</span>
<a name="l00791"></a>00791 <span class="comment">// envoye par la face facej_loc dans elem pour la composante comp de l&#39;inconnue</span>
<a name="l00792"></a>00792                     Fij(elem,facei_loc,facej_loc,comp)=flux-psc_m*transporteVect[facei*nb_comp+comp];
<a name="l00793"></a>00793                     Fij(elem,facej_loc,facei_loc,comp)=psc_m*transporteVect[facej*nb_comp+comp]-flux;
<a name="l00794"></a>00794                   }
<a name="l00795"></a>00795               }
<a name="l00796"></a>00796           <span class="keywordflow">else</span> <span class="comment">//rang!=-1</span>
<a name="l00797"></a>00797             <span class="keywordflow">for</span> (fa7=0; fa7&lt;nfa7; fa7++)
<a name="l00798"></a>00798               {
<a name="l00799"></a>00799                 facei_loc=KEL(0,fa7);
<a name="l00800"></a>00800                 facej_loc=KEL(1,fa7);
<a name="l00801"></a>00801 
<a name="l00802"></a>00802                 facei=face(facei_loc);
<a name="l00803"></a>00803                 facej=face(facej_loc);
<a name="l00804"></a>00804 
<a name="l00805"></a>00805 <span class="comment">// REMARQUE : ON N&#39;OUBLIE PAS QUE LES NORMALES FA7 SONT ORIENTeES DE FACE_LOCI VERS FACE_LOCJ PAR DEFAUT</span>
<a name="l00806"></a>00806 <span class="comment">// LES PRODUITS SCALAIRES PSC_M, PSC_C, PSC_S, PSC_S2 SONT DONC CALCULeS POUR OBTENIR LE FLUX REcU PAR LA FACE FACE_LOCI</span>
<a name="l00807"></a>00807 <span class="comment">// ET EMIS PAR LA FACE_LOCJ</span>
<a name="l00808"></a>00808 <span class="comment">// SI L&#39;ON VEUT OBTENIR LE FLUX REcU PAR LA FACE FACE_LOCJ ET EMIS PAR LA FACE_LOCI, IL FAUT MULTIPLIER LES</span>
<a name="l00809"></a>00809 <span class="comment">// PRODUITS SCALAIRES PSC_M, PSC_C, PSC_S, PSC_S2 PAR -1 POUR IMPLICITEMENT ReORIENTER LES NORMALES FA7 DE FACE_LOCJ VERS</span>
<a name="l00810"></a>00810 <span class="comment">// FACE_LOCI</span>
<a name="l00811"></a>00811 <span class="comment">// MEME REMARQUE POUR LE SCALAIRE &quot;FLUX&quot;</span>
<a name="l00812"></a>00812                 <span class="keyword">const</span> <span class="keywordtype">double</span>&amp; psc_c = Cij(elem,fa7);
<a name="l00813"></a>00813                 <span class="keyword">const</span> <span class="keywordtype">double</span>&amp; psc_s = Sij(elem,fa7);
<a name="l00814"></a>00814                 <span class="keyword">const</span> <span class="keywordtype">double</span>&amp; psc_s2 = Sij2(elem,fa7);
<a name="l00815"></a>00815                 <span class="keyword">const</span> <span class="keywordtype">double</span>&amp; psc_m = Kij(elem,facei_loc,facej_loc);
<a name="l00816"></a>00816 
<a name="l00817"></a>00817                 <span class="keywordflow">if</span> (psc_m&gt;=0.)
<a name="l00818"></a>00818                   face_amont=facei,dir=0;
<a name="l00819"></a>00819                 <span class="keywordflow">else</span>
<a name="l00820"></a>00820                   face_amont=facej,dir=1;
<a name="l00821"></a>00821 
<a name="l00822"></a>00822                 s=zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#aa164c00997bc77a365a6da57bbec29ce" title="Renvoie le numero (global) j-ieme sommet du i-ieme element.">sommet_elem</a>(elem,KEL(2,fa7));
<a name="l00823"></a>00823                 s2=zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#aa164c00997bc77a365a6da57bbec29ce" title="Renvoie le numero (global) j-ieme sommet du i-ieme element.">sommet_elem</a>(elem,KEL(3,fa7));
<a name="l00824"></a>00824 
<a name="l00825"></a>00825                 <span class="keywordflow">for</span> (comp=0; comp&lt;nb_comp; comp++)
<a name="l00826"></a>00826                   {
<a name="l00827"></a>00827 <span class="comment">// Calcul de la valeur de l&#39;inconnue aux points d&#39;integration de la formule 3D</span>
<a name="l00828"></a>00828                     inco_m=transporteVect[face_amont*nb_comp+comp];
<a name="l00829"></a>00829                     <span class="keywordflow">for</span>(dim=0; dim&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>; dim++)
<a name="l00830"></a>00830                       inco_m+=gradient_elem(elem,comp,dim)*vecteur_face_facette_Cl(rang,fa7,dim,dir);
<a name="l00831"></a>00831 
<a name="l00832"></a>00832                     inco_s=transporteVect[face_amont*nb_comp+comp];
<a name="l00833"></a>00833                     <span class="keywordflow">for</span>(dim=0; dim&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>; dim++)
<a name="l00834"></a>00834                       inco_s+=gradient_elem(elem,comp,dim)*(coord_sommets(s,dim)-xv(face_amont,dim));
<a name="l00835"></a>00835 
<a name="l00836"></a>00836                     inco_s2=transporteVect[face_amont*nb_comp+comp];
<a name="l00837"></a>00837                     <span class="keywordflow">for</span>(dim=0; dim&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>; dim++)
<a name="l00838"></a>00838                       inco_s2+=gradient_elem(elem,comp,dim)*(coord_sommets(s2,dim)-xv(face_amont,dim));
<a name="l00839"></a>00839 
<a name="l00840"></a>00840                     inco_c=3.*inco_m-inco_s-inco_s2;
<a name="l00841"></a>00841 
<a name="l00842"></a>00842 <span class="comment">// Calcul du flux final : formule d&#39;integration 3D exacte pour les polynomes de degre 2</span>
<a name="l00843"></a>00843                     flux=(inco_s+inco_s2)*(psc_s+psc_s2);
<a name="l00844"></a>00844                     flux+=(inco_s+inco_c)*(psc_s+psc_c);
<a name="l00845"></a>00845                     flux+=(inco_s2+inco_c)*(psc_s2+psc_c);
<a name="l00846"></a>00846                     flux/=12.;
<a name="l00847"></a>00847 
<a name="l00848"></a>00848 <span class="comment">// Fij(elem,facei_loc,facej_loc,comp) est le flux recu par la facei_loc dans elem</span>
<a name="l00849"></a>00849 <span class="comment">// envoye par la face facej_loc dans elem pour la composante comp de l&#39;inconnue</span>
<a name="l00850"></a>00850                     Fij(elem,facei_loc,facej_loc,comp)=flux-psc_m*transporteVect[facei*nb_comp+comp];
<a name="l00851"></a>00851                     Fij(elem,facej_loc,facei_loc,comp)=psc_m*transporteVect[facej*nb_comp+comp]-flux;
<a name="l00852"></a>00852                   }
<a name="l00853"></a>00853               }
<a name="l00854"></a>00854         }<span class="comment">//fin Objet_U::dimension==3</span>
<a name="l00855"></a>00855     }
<a name="l00856"></a>00856 }
<a name="l00857"></a>00857 
<a name="l00858"></a>00858 <span class="keywordtype">void</span> <a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#aea685b2416b3023598d337ab366512cb">Op_Conv_Muscl_New_VEF_Face::</a>
<a name="l00859"></a><a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#aea685b2416b3023598d337ab366512cb">00859</a> <a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#aea685b2416b3023598d337ab366512cb">modifier_flux_operateur_centre</a>(<a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; Fij,<span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; Kij,<span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; Cij, <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; Sij, <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; Sij2, <span class="keyword">const</span> <span class="keywordtype">int</span>&amp; nb_comp, <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; velocity, <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; transporte)<span class="keyword"> const</span>
<a name="l00860"></a>00860 <span class="keyword"></span>{
<a name="l00861"></a>00861   <span class="keyword">const</span> <a class="code" href="classZone__VEF.html" title="class Zone_VEF Classe instanciable qui derive de Zone_VF. Cette classe contient les informations geom...">Zone_VEF</a>&amp; zone_VEF = <a class="code" href="classOp__Conv__VEF__base.html#a6c29a488a6805ba4a9f2f059cdba77ae">la_zone_vef</a>.<a class="code" href="classRef__Zone__VEF.html#aafd9a5ee1a76f290c9c6b5447b0c8d30">valeur</a>();
<a name="l00862"></a>00862   <span class="keyword">const</span> <a class="code" href="classZone__Cl__VEF.html">Zone_Cl_VEF</a>&amp; zone_Cl_VEF = <a class="code" href="classOp__Conv__VEF__base.html#a03f677ee7911706a4f85cd37e0ca4535">la_zcl_vef</a>.<a class="code" href="classRef__Zone__Cl__VEF.html#a0970d7253def65ad4f0c5ce1830fd243">valeur</a>();
<a name="l00863"></a>00863 
<a name="l00864"></a>00864   <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; vecteur_face_facette = <a class="code" href="Cast_8h.html#ad3836a067c92103af8df5ad8f35959a6">ref_cast_non_const</a>(<a class="code" href="classZone__VEF.html" title="class Zone_VEF Classe instanciable qui derive de Zone_VF. Cette classe contient les informations geom...">Zone_VEF</a>,zone_VEF).vecteur_face_facette();
<a name="l00865"></a>00865   <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; vecteur_face_facette_Cl = zone_Cl_VEF.<a class="code" href="classZone__Cl__VEF.html#aa7acf4bf79e075ba2488e2ee9051c6fe">vecteur_face_facette_Cl</a>();
<a name="l00866"></a>00866 
<a name="l00867"></a>00867   <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; transporteVect=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classDoubleVect.html">DoubleVect</a>,transporte);
<a name="l00868"></a>00868 
<a name="l00869"></a>00869   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; elem_faces = zone_VEF.<a class="code" href="classZone__VF.html#a067e462dcd3ab92b0f6d945b19e4eb37" title="renvoie le numero de le ieme face de la maille num_elem la facon dont ces faces sont numerotees est l...">elem_faces</a>();
<a name="l00870"></a>00870   <span class="keyword">const</span> <a class="code" href="classIntVect.html">IntVect</a>&amp; rang_elem_non_std = zone_VEF.<a class="code" href="classZone__VEF.html#a4b2171a85e5fc33663a3366acb713584">rang_elem_non_std</a>();
<a name="l00871"></a>00871   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; KEL=zone_VEF.<a class="code" href="classZone__VEF.html#a46693c060b8096fb2595ca72192eea2a">type_elem</a>().<a class="code" href="classDeriv__Elem__VEF__base.html#a2886905d5071be902c77248b69ca0b7b">valeur</a>().<a class="code" href="classElem__VEF__base.html#ab129610ef702aa8c9c98dcb4c7551172">KEL</a>();
<a name="l00872"></a>00872 
<a name="l00873"></a>00873   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_elem_tot = zone_VEF.<a class="code" href="classZone__dis__base.html#a4d6aa445f152aa6dc54d66ea7a071147">nb_elem_tot</a>();
<a name="l00874"></a>00874   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_faces_elem=elem_faces.<a class="code" href="classIntTab.html#abc3b32c94925a82f69d5b153a356e359" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(1);
<a name="l00875"></a>00875   <span class="keyword">const</span> <span class="keywordtype">int</span> nfa7 = zone_VEF.<a class="code" href="classZone__VEF.html#a46693c060b8096fb2595ca72192eea2a">type_elem</a>().<a class="code" href="classElem__VEF.html#a4a34777c0083b38dd34c8a400d5b4e90">nb_facette</a>();
<a name="l00876"></a>00876 
<a name="l00877"></a>00877   <span class="keywordtype">int</span> rang=-2;
<a name="l00878"></a>00878   <span class="keywordtype">int</span> fa7=0;
<a name="l00879"></a>00879   <span class="keywordtype">int</span> dim=-1;
<a name="l00880"></a>00880   <span class="keywordtype">int</span> elem=0;
<a name="l00881"></a>00881   <span class="keywordtype">int</span> face_amont=-1;
<a name="l00882"></a>00882   <span class="keywordtype">int</span> dir=-1;
<a name="l00883"></a>00883   <span class="keywordtype">int</span> comp=-1;
<a name="l00884"></a>00884   <span class="keywordtype">int</span> facei=-1;
<a name="l00885"></a>00885   <span class="keywordtype">int</span> facej=-1;
<a name="l00886"></a>00886   <span class="keywordtype">int</span> facei_loc=-1;
<a name="l00887"></a>00887   <span class="keywordtype">int</span> facej_loc=-1;
<a name="l00888"></a>00888 
<a name="l00889"></a>00889   <span class="keywordtype">double</span> inco_m=0.;
<a name="l00890"></a>00890   <span class="keywordtype">double</span> flux=0.;
<a name="l00891"></a>00891 
<a name="l00892"></a>00892   <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a> gradient_elem(nb_elem_tot,nb_comp,<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>);  <span class="comment">//!&lt; (du/dx du/dy dv/dx dv/dy) pour un poly  gradient_elem=0.;</span>
<a name="l00893"></a>00893 <span class="comment"></span>  <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a> face(<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>+1);
<a name="l00894"></a>00894 
<a name="l00895"></a>00895   assert(Fij.<a class="code" href="classDoubleTab.html#ae6dda48778e7107e1beb723beef1f75b" title="Returns the number of dimensions of the array (&gt;= 1)">nb_dim</a>()==4);
<a name="l00896"></a>00896   assert(Fij.<a class="code" href="classDoubleTab.html#ac3805e2637a3b880ba2d3e650c69dac4" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(0)==nb_elem_tot);
<a name="l00897"></a>00897   assert(Fij.<a class="code" href="classDoubleTab.html#ac3805e2637a3b880ba2d3e650c69dac4" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(1)==Fij.<a class="code" href="classDoubleTab.html#ac3805e2637a3b880ba2d3e650c69dac4" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(2));
<a name="l00898"></a>00898   assert(Fij.<a class="code" href="classDoubleTab.html#ac3805e2637a3b880ba2d3e650c69dac4" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(1)==nb_faces_elem);
<a name="l00899"></a>00899   assert(Fij.<a class="code" href="classDoubleTab.html#ac3805e2637a3b880ba2d3e650c69dac4" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(3)==nb_comp);
<a name="l00900"></a>00900 
<a name="l00901"></a>00901 <span class="comment">// </span>
<a name="l00902"></a>00902 <span class="comment">// Calcul des flux de l&#39;operateur</span>
<a name="l00903"></a>00903 <span class="comment">// </span>
<a name="l00904"></a>00904   <a class="code" href="classChamp__P1NC.html#a87d96c073d3c127684934610f9a1e407">Champ_P1NC::calcul_gradient</a>(transporte,gradient_elem,zone_Cl_VEF);
<a name="l00905"></a>00905 
<a name="l00906"></a>00906   <span class="keywordflow">for</span>(elem=0; elem&lt;nb_elem_tot; elem++)
<a name="l00907"></a>00907     {
<a name="l00908"></a>00908       rang=rang_elem_non_std(elem);
<a name="l00909"></a>00909 
<a name="l00910"></a>00910       <span class="keywordflow">for</span> (facei_loc=0; facei_loc&lt;nb_faces_elem; facei_loc++)
<a name="l00911"></a>00911         face(facei_loc)=elem_faces(elem,facei_loc);
<a name="l00912"></a>00912 
<a name="l00913"></a>00913 <span class="comment">// RAZ des flux des elements a modifier</span>
<a name="l00914"></a>00914       <span class="keywordflow">if</span> (<a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#a93e226d752c2b31d4b63e08840aea2cb">is_element_for_upwinding_</a>(elem))
<a name="l00915"></a>00915         <span class="keywordflow">for</span> (facei_loc=0; facei_loc&lt;nb_faces_elem; facei_loc++)
<a name="l00916"></a>00916           <span class="keywordflow">for</span> (facej_loc=0; facej_loc&lt;nb_faces_elem; facej_loc++)
<a name="l00917"></a>00917             <span class="keywordflow">for</span> (comp=0; comp&lt;nb_comp; comp++)
<a name="l00918"></a>00918               Fij(elem,facei_loc,facej_loc,comp)=0.;
<a name="l00919"></a>00919 
<a name="l00920"></a>00920       <span class="keywordflow">if</span> (<a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#a93e226d752c2b31d4b63e08840aea2cb">is_element_for_upwinding_</a>(elem))
<a name="l00921"></a>00921         {
<a name="l00922"></a>00922           <span class="keywordflow">if</span> (rang==-1)
<a name="l00923"></a>00923             <span class="keywordflow">for</span> (fa7=0; fa7&lt;nfa7; fa7++)
<a name="l00924"></a>00924               {
<a name="l00925"></a>00925                 facei_loc=KEL(0,fa7);
<a name="l00926"></a>00926                 facej_loc=KEL(1,fa7);
<a name="l00927"></a>00927 
<a name="l00928"></a>00928                 facei=face(facei_loc);
<a name="l00929"></a>00929                 facej=face(facej_loc);
<a name="l00930"></a>00930 
<a name="l00931"></a>00931 <span class="comment">// REMARQUE : ON N&#39;OUBLIE PAS QUE LES NORMALES FA7 SONT ORIENTeES DE FACE_LOCI VERS FACE_LOCJ PAR DEFAUT</span>
<a name="l00932"></a>00932 <span class="comment">// LE PRODUIT SCALAIRE PSC_M EST DONC CALCULe POUR OBTENIR LE FLUX REcU PAR LA FACE FACE_LOCI</span>
<a name="l00933"></a>00933 <span class="comment">// ET EMIS PAR LA FACE_LOCJ</span>
<a name="l00934"></a>00934 <span class="comment">// SI L&#39;ON VEUT OBTENIR LE FLUX REcU PAR LA FACE FACE_LOCJ ET EMIS PAR LA FACE_LOCI, IL FAUT MULTIPLIER LE</span>
<a name="l00935"></a>00935 <span class="comment">// PRODUIT SCALAIRE PSC_M PAR -1 POUR IMPLICITEMENT ReORIENTER LES NORMALES FA7 DE FACE_LOCJ VERS</span>
<a name="l00936"></a>00936 <span class="comment">// FACE_LOCI</span>
<a name="l00937"></a>00937 <span class="comment">// MEME REMARQUE POUR LE SCALAIRE &quot;FLUX&quot;</span>
<a name="l00938"></a>00938                 <span class="keyword">const</span> <span class="keywordtype">double</span>&amp; psc_m = Kij(elem,facei_loc,facej_loc);
<a name="l00939"></a>00939 
<a name="l00940"></a>00940                 <span class="keywordflow">if</span> (psc_m&gt;=0.)
<a name="l00941"></a>00941                   face_amont=facei,dir=0;
<a name="l00942"></a>00942                 <span class="keywordflow">else</span>
<a name="l00943"></a>00943                   face_amont=facej,dir=1;
<a name="l00944"></a>00944 
<a name="l00945"></a>00945                 <span class="keywordflow">for</span> (comp=0; comp&lt;nb_comp; comp++)
<a name="l00946"></a>00946                   {
<a name="l00947"></a>00947 <span class="comment">// Calcul de la valeur de l&#39;inconnue aux points d&#39;integration de la formule du point milieu</span>
<a name="l00948"></a>00948                     inco_m=transporteVect[face_amont*nb_comp+comp];
<a name="l00949"></a>00949                     <span class="keywordflow">for</span>(dim=0; dim&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>; dim++)
<a name="l00950"></a>00950                       inco_m+=gradient_elem(elem,comp,dim)*vecteur_face_facette(elem,fa7,dim,dir);
<a name="l00951"></a>00951 
<a name="l00952"></a>00952 <span class="comment">// Calcul du flux final : formule du point milieu</span>
<a name="l00953"></a>00953                     flux=inco_m*psc_m;
<a name="l00954"></a>00954 
<a name="l00955"></a>00955 <span class="comment">// Fij(elem,facei_loc,facej_loc,comp) est le flux recu par la facei_loc dans elem</span>
<a name="l00956"></a>00956 <span class="comment">// envoye par la face facej_loc dans elem pour la composante comp de l&#39;inconnue</span>
<a name="l00957"></a>00957                     Fij(elem,facei_loc,facej_loc,comp)=flux-psc_m*transporteVect[facei*nb_comp+comp];
<a name="l00958"></a>00958                     Fij(elem,facej_loc,facei_loc,comp)=psc_m*transporteVect[facej*nb_comp+comp]-flux;
<a name="l00959"></a>00959                   }
<a name="l00960"></a>00960               }
<a name="l00961"></a>00961         }
<a name="l00962"></a>00962       <span class="keywordflow">else</span> <span class="comment">//rang!=-1</span>
<a name="l00963"></a>00963         {
<a name="l00964"></a>00964           <span class="keywordflow">for</span> (fa7=0; fa7&lt;nfa7; fa7++)
<a name="l00965"></a>00965             {
<a name="l00966"></a>00966               facei_loc=KEL(0,fa7);
<a name="l00967"></a>00967               facej_loc=KEL(1,fa7);
<a name="l00968"></a>00968 
<a name="l00969"></a>00969               facei=face(facei_loc);
<a name="l00970"></a>00970               facej=face(facej_loc);
<a name="l00971"></a>00971 
<a name="l00972"></a>00972 <span class="comment">// REMARQUE : ON N&#39;OUBLIE PAS QUE LES NORMALES FA7 SONT ORIENTeES DE FACE_LOCI VERS FACE_LOCJ PAR DEFAUT</span>
<a name="l00973"></a>00973 <span class="comment">// LE PRODUIT SCALAIRE PSC_M EST DONC CALCULe POUR OBTENIR LE FLUX REcU PAR LA FACE FACE_LOCI</span>
<a name="l00974"></a>00974 <span class="comment">// ET EMIS PAR LA FACE_LOCJ</span>
<a name="l00975"></a>00975 <span class="comment">// SI L&#39;ON VEUT OBTENIR LE FLUX REcU PAR LA FACE FACE_LOCJ ET EMIS PAR LA FACE_LOCI, IL FAUT MULTIPLIER LE</span>
<a name="l00976"></a>00976 <span class="comment">// PRODUIT SCALAIRE PSC_M PAR -1 POUR IMPLICITEMENT ReORIENTER LES NORMALES FA7 DE FACE_LOCJ VERS</span>
<a name="l00977"></a>00977 <span class="comment">// FACE_LOCI</span>
<a name="l00978"></a>00978 <span class="comment">// MEME REMARQUE POUR LE SCALAIRE &quot;FLUX&quot;</span>
<a name="l00979"></a>00979               <span class="keyword">const</span> <span class="keywordtype">double</span>&amp; psc_m = Kij(elem,facei_loc,facej_loc);
<a name="l00980"></a>00980 
<a name="l00981"></a>00981               <span class="keywordflow">if</span> (psc_m&gt;=0.)
<a name="l00982"></a>00982                 face_amont=facei,dir=0;
<a name="l00983"></a>00983               <span class="keywordflow">else</span>
<a name="l00984"></a>00984                 face_amont=facej,dir=1;
<a name="l00985"></a>00985 
<a name="l00986"></a>00986               <span class="keywordflow">for</span> (comp=0; comp&lt;nb_comp; comp++)
<a name="l00987"></a>00987                 {
<a name="l00988"></a>00988 <span class="comment">// Calcul de la valeur de l&#39;inconnue aux points d&#39;integration de la formule du point milieu</span>
<a name="l00989"></a>00989                   inco_m=transporteVect[face_amont*nb_comp+comp];
<a name="l00990"></a>00990                   <span class="keywordflow">for</span>(dim=0; dim&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>; dim++)
<a name="l00991"></a>00991                     inco_m+=gradient_elem(elem,comp,dim)*vecteur_face_facette_Cl(rang,fa7,dim,dir);
<a name="l00992"></a>00992 
<a name="l00993"></a>00993 <span class="comment">// Calcul du flux final : formule d&#39;integration du point milieu</span>
<a name="l00994"></a>00994                   flux=inco_m*psc_m;
<a name="l00995"></a>00995 
<a name="l00996"></a>00996 <span class="comment">// Fij(elem,facei_loc,facej_loc,comp) est le flux recu par la facei_loc dans elem</span>
<a name="l00997"></a>00997 <span class="comment">// envoye par la face facej_loc dans elem pour la composante comp de l&#39;inconnue</span>
<a name="l00998"></a>00998                   Fij(elem,facei_loc,facej_loc,comp)=flux-psc_m*transporteVect[facei*nb_comp+comp];
<a name="l00999"></a>00999                   Fij(elem,facej_loc,facei_loc,comp)=psc_m*transporteVect[facej*nb_comp+comp]-flux;
<a name="l01000"></a>01000                 }
<a name="l01001"></a>01001             }
<a name="l01002"></a>01002         }
<a name="l01003"></a>01003     }<span class="comment">//for sur elem</span>
<a name="l01004"></a>01004 }
<a name="l01005"></a>01005 
<a name="l01006"></a><a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#a3bd2f8fbc0e634221c7df74db0bca01d">01006</a> <span class="keywordtype">void</span> <a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#a3bd2f8fbc0e634221c7df74db0bca01d">Op_Conv_Muscl_New_VEF_Face::remplir_fluent</a>(<a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; fluent_)<span class="keyword"> const</span>
<a name="l01007"></a>01007 <span class="keyword"></span>{
<a name="l01008"></a>01008   <span class="keyword">const</span> <a class="code" href="classZone__VEF.html" title="class Zone_VEF Classe instanciable qui derive de Zone_VF. Cette classe contient les informations geom...">Zone_VEF</a>&amp; zone_VEF = <a class="code" href="classOp__Conv__VEF__base.html#a6c29a488a6805ba4a9f2f059cdba77ae">la_zone_vef</a>.<a class="code" href="classRef__Zone__VEF.html#aafd9a5ee1a76f290c9c6b5447b0c8d30">valeur</a>();
<a name="l01009"></a>01009   <span class="keyword">const</span> <a class="code" href="classChamp__Inc__base.html" title="Classe Champ_Inc_base Classe de base des champs inconnues qui sont les champs calcules par une equati...">Champ_Inc_base</a>&amp; la_vitesse=<a class="code" href="classOp__Conv__VEF__base.html#a5547875832fb45e09b1115372fb76ffd">vitesse_</a>.<a class="code" href="classRef__Champ__Inc__base.html#a17553641a4c06730e1562125e07b3490">valeur</a>();
<a name="l01010"></a>01010   <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; velocity=la_vitesse.<a class="code" href="classChamp__Inc__base.html#adb537f43f1649e103a8980314c7ed175" title="Renvoie le tableau des valeurs du champ au temps courant.">valeurs</a>();
<a name="l01011"></a>01011   <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; face_normales=zone_VEF.<a class="code" href="classZone__VEF.html#a5742d75972e4846bf9fbb6ed5715053e">face_normales</a>();
<a name="l01012"></a>01012   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_faces = zone_VEF.<a class="code" href="classZone__VF.html#aede27992d9f2eedd52c24d4a80ff7ffb" title="renvoie le nombre global de faces.">nb_faces</a>();
<a name="l01013"></a>01013 <span class="comment">// calcul de la CFL.</span>
<a name="l01014"></a>01014   <span class="keywordtype">double</span> psc;
<a name="l01015"></a>01015 <span class="comment">// On remet a zero le tableau qui sert pour</span>
<a name="l01016"></a>01016 <span class="comment">// le calcul du pas de temps de stabilite</span>
<a name="l01017"></a>01017   fluent_ = 0;
<a name="l01018"></a>01018 
<a name="l01019"></a>01019   <span class="keywordflow">for</span>(<span class="keywordtype">int</span> num_face=0; num_face&lt;nb_faces; num_face++)
<a name="l01020"></a>01020     {
<a name="l01021"></a>01021       psc=0.;
<a name="l01022"></a>01022       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; i++)
<a name="l01023"></a>01023         psc+=velocity(num_face,i)*face_normales(num_face,i);
<a name="l01024"></a>01024       fluent_(num_face)=<a class="code" href="Double_8h.html#aaecd4ca8a2fe69cc6568af2938b94d2e">dabs</a>(psc);
<a name="l01025"></a>01025     }
<a name="l01026"></a>01026 }
<a name="l01027"></a>01027 
<a name="l01028"></a>01028 
<a name="l01029"></a><a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#a51a3ed81dae9a408009dad9e3104f7de">01029</a> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; <a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#a51a3ed81dae9a408009dad9e3104f7de">Op_Conv_Muscl_New_VEF_Face::ajouter</a>(<span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; transporte_2,
<a name="l01030"></a>01030                                                <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; resu)<span class="keyword"> const</span>
<a name="l01031"></a>01031 <span class="keyword"></span>{
<a name="l01032"></a>01032   <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a> sauv(resu);
<a name="l01033"></a>01033   resu=0;
<a name="l01034"></a>01034 
<a name="l01035"></a>01035   <span class="keyword">const</span> <a class="code" href="classZone__VEF.html" title="class Zone_VEF Classe instanciable qui derive de Zone_VF. Cette classe contient les informations geom...">Zone_VEF</a>&amp; zone_VEF = <a class="code" href="classOp__Conv__VEF__base.html#a6c29a488a6805ba4a9f2f059cdba77ae">la_zone_vef</a>.<a class="code" href="classRef__Zone__VEF.html#aafd9a5ee1a76f290c9c6b5447b0c8d30">valeur</a>();
<a name="l01036"></a>01036   <span class="keyword">const</span> <a class="code" href="classChamp__P1NC.html">Champ_P1NC</a>&amp; la_vitesse=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>( <a class="code" href="classChamp__P1NC.html">Champ_P1NC</a>, <a class="code" href="classOp__Conv__VEF__base.html#a5547875832fb45e09b1115372fb76ffd">vitesse_</a>.<a class="code" href="classRef__Champ__Inc__base.html#a17553641a4c06730e1562125e07b3490">valeur</a>());
<a name="l01037"></a>01037   <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; vitesse_2=la_vitesse.<a class="code" href="classChamp__Inc__base.html#adb537f43f1649e103a8980314c7ed175" title="Renvoie le tableau des valeurs du champ au temps courant.">valeurs</a>();
<a name="l01038"></a>01038   <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; porosite_face = zone_VEF.<a class="code" href="classZone__VF.html#ad9d74d1d9da9f50ab26768dbbca7711b">porosite_face</a>();
<a name="l01039"></a>01039 
<a name="l01040"></a>01040   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; elem_faces = zone_VEF.<a class="code" href="classZone__VF.html#a067e462dcd3ab92b0f6d945b19e4eb37" title="renvoie le numero de le ieme face de la maille num_elem la facon dont ces faces sont numerotees est l...">elem_faces</a>();
<a name="l01041"></a>01041 
<a name="l01042"></a>01042   <span class="keyword">const</span> <span class="keywordtype">int</span> marq=<a class="code" href="classOp__Conv__VEF__base.html#ad380b9b9ca1d70282b289838a604a4b0" title="definit si l&#39;on convecte psi avec phi*u ou avec u">phi_u_transportant</a>(<a class="code" href="classMorEqn.html#a615dd9abff96edcb625fa0424a489864" title="Renvoie la reference sur l&#39;equation pointe par MorEqn::mon_equation. (version const)">equation</a>());
<a name="l01043"></a>01043   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_faces_elem=elem_faces.<a class="code" href="classIntTab.html#abc3b32c94925a82f69d5b153a356e359" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(1);
<a name="l01044"></a>01044   assert(nb_faces_elem==(<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>+1));
<a name="l01045"></a>01045   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_elem_tot = zone_VEF.<a class="code" href="classZone__dis__base.html#a4d6aa445f152aa6dc54d66ea7a071147">nb_elem_tot</a>();
<a name="l01046"></a>01046   <span class="keyword">const</span> <span class="keywordtype">int</span> nfa7 = zone_VEF.<a class="code" href="classZone__VEF.html#a46693c060b8096fb2595ca72192eea2a">type_elem</a>().<a class="code" href="classElem__VEF.html#a4a34777c0083b38dd34c8a400d5b4e90">nb_facette</a>();
<a name="l01047"></a>01047 
<a name="l01048"></a>01048   <span class="keywordtype">int</span> nb_comp=1;
<a name="l01049"></a>01049   <span class="keywordflow">if</span>(resu.<a class="code" href="classDoubleTab.html#ae6dda48778e7107e1beb723beef1f75b" title="Returns the number of dimensions of the array (&gt;= 1)">nb_dim</a>()!=1)
<a name="l01050"></a>01050     nb_comp=resu.<a class="code" href="classDoubleTab.html#ac3805e2637a3b880ba2d3e650c69dac4" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(1);
<a name="l01051"></a>01051 
<a name="l01052"></a>01052   <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a> <a class="code" href="Op__Conv__EF_8cpp.html#aec139ab06c54f3c620f1e9944627c994">transporte_</a>;
<a name="l01053"></a>01053   <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a> vitesse_face_;
<a name="l01054"></a>01054 <span class="comment">// soit on a transporte=phi*transporte_ et vitesse=vitesse_</span>
<a name="l01055"></a>01055 <span class="comment">// soit transporte=transporte_ et vitesse=phi*vitesse_</span>
<a name="l01056"></a>01056 <span class="comment">// cela depend si on transporte avec phi u ou avec u.</span>
<a name="l01057"></a>01057   <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; velocity=<a class="code" href="Porosites__champ_8cpp.html#a2340e7d73d0f9d34926d012fe1b1d884" title="renvoit le tableau res, res=org si flag=0, res= porosite*org sinon attention ne pas modifier res car ...">modif_par_porosite_si_flag</a>(vitesse_2,vitesse_face_,marq,porosite_face);
<a name="l01058"></a>01058 
<a name="l01059"></a>01059   <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a> Kij(nb_elem_tot,nb_faces_elem,nb_faces_elem);
<a name="l01060"></a>01060   <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a> Fij(nb_elem_tot,nb_faces_elem,nb_faces_elem,nb_comp);
<a name="l01061"></a>01061   <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a> Cij(nb_elem_tot,nfa7);
<a name="l01062"></a>01062   <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a> Sij(nb_elem_tot,nfa7);
<a name="l01063"></a>01063   <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a> Sij2;
<a name="l01064"></a>01064   <span class="keywordflow">if</span> (<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>==3)
<a name="l01065"></a>01065     {
<a name="l01066"></a>01066       Sij2.<a class="code" href="classDoubleTab.html#ae83b4d31205c53d9c8d2b43da178ce75" title="Change la taille du vecteur (identique a resize_array() pour le traitement des anciennes valeurs et d...">resize</a>(nb_elem_tot,nfa7);
<a name="l01067"></a>01067       Sij2=0.;
<a name="l01068"></a>01068     }
<a name="l01069"></a>01069 
<a name="l01070"></a>01070 <span class="comment">// Pour tenir compte des conditions de Neumann sortie libre</span>
<a name="l01071"></a>01071 
<a name="l01072"></a>01072 <span class="comment">// soit on a transporte=phi*transporte_ et vitesse=vitesse_</span>
<a name="l01073"></a>01073 <span class="comment">// soit transporte=transporte_ et vitesse=phi*vitesse_</span>
<a name="l01074"></a>01074 <span class="comment">// cela depend si on transporte avec phi u ou avec u.</span>
<a name="l01075"></a>01075   <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; transporte=<a class="code" href="Porosites__champ_8cpp.html#a2340e7d73d0f9d34926d012fe1b1d884" title="renvoit le tableau res, res=org si flag=0, res= porosite*org sinon attention ne pas modifier res car ...">modif_par_porosite_si_flag</a>(transporte_2,transporte_,!marq,porosite_face);
<a name="l01076"></a>01076 
<a name="l01077"></a>01077 <span class="comment">// Initialisation du tableau flux_bords_ pour le calcul des pertes de charge</span>
<a name="l01078"></a>01078   <a class="code" href="classOperateur__base.html#a451f51b41518ddbc0d3f586a8177d319" title="Tableau contenant les flux sur les bords de l&#39;operateur.">flux_bords_</a>.<a class="code" href="classDoubleTab.html#ae83b4d31205c53d9c8d2b43da178ce75" title="Change la taille du vecteur (identique a resize_array() pour le traitement des anciennes valeurs et d...">resize</a>(zone_VEF.<a class="code" href="classZone__VF.html#a8815e2276637c0db23868f043dc43e58" title="renvoie le nombre de faces sur lesquelles sont appliquees les conditions limites : bords...">nb_faces_bord</a>(),nb_comp);
<a name="l01079"></a>01079   <a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#ad9cd682b100057d3019ba30b61a9b469">calculer_flux_bords</a>(Kij,velocity,transporte);
<a name="l01080"></a>01080 
<a name="l01081"></a>01081 
<a name="l01082"></a>01082 <span class="comment">// statistiques().begin_count(m1);</span>
<a name="l01083"></a>01083   <a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#afde9a8f6daffddcc35a097fd68674797">calculer_coefficients_operateur_centre</a>(Kij,Cij,Sij,Sij2,nb_comp,velocity);
<a name="l01084"></a>01084   <a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#aaf6d31030b81017b92df85d3377d6ae9">calculer_flux_operateur_centre</a>(Fij,Kij,Cij,Sij,Sij2,nb_comp,velocity,transporte);
<a name="l01085"></a>01085   <span class="keywordflow">if</span> (<a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#af27e616d4be292efae0dcd25ef29278c">old_centered_</a>) <a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#aea685b2416b3023598d337ab366512cb">modifier_flux_operateur_centre</a>(Fij,Kij,Cij,Sij,Sij2,nb_comp,velocity,transporte);
<a name="l01086"></a>01086 <span class="comment">// statistiques().end_count(m1);</span>
<a name="l01087"></a>01087 <span class="comment">// statistiques().begin_count(m2);</span>
<a name="l01088"></a>01088 
<a name="l01089"></a>01089   <span class="keywordflow">if</span> (<a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#af79e661742c516fb1f0945636d84f900">centered_</a>) <a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#a0cd4001abc6587f38b6e3f23d251bc68">ajouter_operateur_centre</a>(Kij,Fij,transporte,resu);
<a name="l01090"></a>01090   <span class="keywordflow">if</span> (<a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#ad596610363f5610f9ab6517b977b3122">upwind_</a>) <a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#a7a5c2445abefb22846ad5eec13fde90d">ajouter_diffusion</a>(Kij,Fij,transporte,resu);
<a name="l01091"></a>01091 <span class="comment">// statistiques().end_count(m2);</span>
<a name="l01092"></a>01092 <span class="comment">// statistiques().begin_count(m3);</span>
<a name="l01093"></a>01093   <span class="keywordflow">if</span> (<a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#a2b88ace4b5e403aacf90ce4a6787b76c">stabilized_</a>) <a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#a0a4d5294bb89871b05c740fa867841b9">ajouter_antidiffusion</a>(Kij,Fij,transporte,resu);
<a name="l01094"></a>01094 
<a name="l01095"></a>01095 <span class="comment">// statistiques().end_count(m3);</span>
<a name="l01096"></a>01096   <a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#a98bafc0524994d1bba96aff4b28540b8">mettre_a_jour_pour_periodicite</a>(Kij,transporte,resu);
<a name="l01097"></a>01097 
<a name="l01098"></a>01098   resu*=-1.;<span class="comment">//car l&#39;operateur de convection est construit en tant que terme source</span>
<a name="l01099"></a>01099   resu+=sauv;
<a name="l01100"></a>01100 
<a name="l01101"></a>01101   <a class="code" href="classOp__VEF__Face.html#a6c8ce571769b4f2e20b07cbb7a6944f2">modifier_flux</a>(*<span class="keyword">this</span>);
<a name="l01102"></a>01102 
<a name="l01103"></a>01103   <span class="keywordflow">return</span> resu;
<a name="l01104"></a>01104 }
<a name="l01105"></a>01105 
<a name="l01106"></a>01106 <span class="comment">// ALGO TRES GROSSIER MAIS FONCTIONNE FACILEMENT</span>
<a name="l01107"></a><a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#a6c66104c0f7419cdf6a126d2266d4720">01107</a> <span class="keywordtype">double</span> <a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#a6c66104c0f7419cdf6a126d2266d4720" title="Calcul dt_stab.">Op_Conv_Muscl_New_VEF_Face::calculer_dt_stab</a>()<span class="keyword"> const</span>
<a name="l01108"></a>01108 <span class="keyword"></span>{
<a name="l01109"></a>01109   <span class="keywordflow">if</span> (!<a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#a55d9e35f60df86eecbcc895f3cb72d3c">facsec_auto_</a>)
<a name="l01110"></a>01110     <span class="keywordflow">return</span> <a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#a6c66104c0f7419cdf6a126d2266d4720" title="Calcul dt_stab.">Op_Conv_VEF_Face::calculer_dt_stab</a>();
<a name="l01111"></a>01111   <span class="keywordflow">else</span>
<a name="l01112"></a>01112     {
<a name="l01113"></a>01113       <span class="keyword">const</span> <a class="code" href="classZone__VEF.html" title="class Zone_VEF Classe instanciable qui derive de Zone_VF. Cette classe contient les informations geom...">Zone_VEF</a>&amp; zone_VEF = <a class="code" href="classOp__Conv__VEF__base.html#a6c29a488a6805ba4a9f2f059cdba77ae">la_zone_vef</a>.<a class="code" href="classRef__Zone__VEF.html#aafd9a5ee1a76f290c9c6b5447b0c8d30">valeur</a>();
<a name="l01114"></a>01114       <span class="keyword">const</span> <a class="code" href="classZone__Cl__VEF.html">Zone_Cl_VEF</a>&amp; zone_Cl_VEF = <a class="code" href="classOp__Conv__VEF__base.html#a03f677ee7911706a4f85cd37e0ca4535">la_zcl_vef</a>.<a class="code" href="classRef__Zone__Cl__VEF.html#a0970d7253def65ad4f0c5ce1830fd243">valeur</a>();
<a name="l01115"></a>01115       <span class="keyword">const</span> <a class="code" href="classChamp__P1NC.html">Champ_P1NC</a>&amp; la_vitesse=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>( <a class="code" href="classChamp__P1NC.html">Champ_P1NC</a>, <a class="code" href="classOp__Conv__VEF__base.html#a5547875832fb45e09b1115372fb76ffd">vitesse_</a>.<a class="code" href="classRef__Champ__Inc__base.html#a17553641a4c06730e1562125e07b3490">valeur</a>());
<a name="l01116"></a>01116       <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; vitesse_2=la_vitesse.<a class="code" href="classChamp__Inc__base.html#adb537f43f1649e103a8980314c7ed175" title="Renvoie le tableau des valeurs du champ au temps courant.">valeurs</a>();
<a name="l01117"></a>01117       <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; porosite_face = zone_VEF.<a class="code" href="classZone__VF.html#ad9d74d1d9da9f50ab26768dbbca7711b">porosite_face</a>();
<a name="l01118"></a>01118 
<a name="l01119"></a>01119       <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; elem_faces = zone_VEF.<a class="code" href="classZone__VF.html#a067e462dcd3ab92b0f6d945b19e4eb37" title="renvoie le numero de le ieme face de la maille num_elem la facon dont ces faces sont numerotees est l...">elem_faces</a>();
<a name="l01120"></a>01120 
<a name="l01121"></a>01121       <span class="keyword">const</span> <span class="keywordtype">int</span> marq=<a class="code" href="classOp__Conv__VEF__base.html#ad380b9b9ca1d70282b289838a604a4b0" title="definit si l&#39;on convecte psi avec phi*u ou avec u">phi_u_transportant</a>(<a class="code" href="classMorEqn.html#a615dd9abff96edcb625fa0424a489864" title="Renvoie la reference sur l&#39;equation pointe par MorEqn::mon_equation. (version const)">equation</a>());
<a name="l01122"></a>01122       <span class="keyword">const</span> <span class="keywordtype">int</span> nb_faces_elem=elem_faces.<a class="code" href="classIntTab.html#abc3b32c94925a82f69d5b153a356e359" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(1);
<a name="l01123"></a>01123       <span class="keyword">const</span> <span class="keywordtype">int</span> nb_elem_tot = zone_VEF.<a class="code" href="classZone__dis__base.html#a4d6aa445f152aa6dc54d66ea7a071147">nb_elem_tot</a>();
<a name="l01124"></a>01124       <span class="keyword">const</span> <span class="keywordtype">int</span> nfa7 = zone_VEF.<a class="code" href="classZone__VEF.html#a46693c060b8096fb2595ca72192eea2a">type_elem</a>().<a class="code" href="classElem__VEF.html#a4a34777c0083b38dd34c8a400d5b4e90">nb_facette</a>();
<a name="l01125"></a>01125       <span class="keyword">const</span> <span class="keywordtype">int</span> nb_faces_tot = zone_VEF.<a class="code" href="classZone__VF.html#a50fd21c9535680489015a3c8b88c685a" title="renvoie le nombre total de faces. C&#39;est-a-dire faces reelles + faces virtuelles">nb_faces_tot</a>();
<a name="l01126"></a>01126       <span class="keyword">const</span> <span class="keywordtype">int</span> nb_bord = zone_Cl_VEF.<a class="code" href="classZone__Cl__dis__base.html#aa6f1df56cfd6e2eae83cc991c7cc9b41" title="Renvoie le nombre de conditions aux limites.">nb_cond_lim</a>();
<a name="l01127"></a>01127 
<a name="l01128"></a>01128       <span class="keywordtype">int</span> nb_comp=1;
<a name="l01129"></a>01129       <span class="keywordflow">if</span>(<a class="code" href="classMorEqn.html#a615dd9abff96edcb625fa0424a489864" title="Renvoie la reference sur l&#39;equation pointe par MorEqn::mon_equation. (version const)">equation</a>().inconnue().valeurs().nb_dim()!=1)
<a name="l01130"></a>01130         nb_comp=<a class="code" href="classMorEqn.html#a615dd9abff96edcb625fa0424a489864" title="Renvoie la reference sur l&#39;equation pointe par MorEqn::mon_equation. (version const)">equation</a>().<a class="code" href="classEquation__base.html#a5a1fce9487b9a8dd17020914100c2c89">inconnue</a>().<a class="code" href="classChamp__Inc.html#a28ef3d411d12cb5684ac5e799efb7d24" title="Appel a l&#39;objet sous-jacent Renvoie le tableau des valeurs au temps courant.">valeurs</a>().<a class="code" href="classDoubleTab.html#ac3805e2637a3b880ba2d3e650c69dac4" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(1);
<a name="l01131"></a>01131 
<a name="l01132"></a>01132       <span class="keywordtype">int</span> elem=-1;
<a name="l01133"></a>01133       <span class="keywordtype">int</span> facei_loc=-1;
<a name="l01134"></a>01134       <span class="keywordtype">int</span> facei=-1;
<a name="l01135"></a>01135       <span class="keywordtype">int</span> faceiAss=-1;
<a name="l01136"></a>01136       <span class="keywordtype">int</span> facej_loc=-1;
<a name="l01137"></a>01137       <span class="keywordtype">int</span> facej=-1;
<a name="l01138"></a>01138       <span class="keywordtype">int</span> n_bord=-1;
<a name="l01139"></a>01139       <span class="keywordtype">int</span> num1=-1,num2=-1;
<a name="l01140"></a>01140       <span class="keywordtype">int</span> ind_face=-1;
<a name="l01141"></a>01141       <span class="keywordtype">int</span> ind_face_associee=-1;
<a name="l01142"></a>01142       <span class="keywordtype">int</span> max_int=-1;
<a name="l01143"></a>01143 
<a name="l01144"></a>01144       <span class="keywordtype">double</span> dt_stab = <a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#a6c66104c0f7419cdf6a126d2266d4720" title="Calcul dt_stab.">Op_Conv_VEF_Face::calculer_dt_stab</a>();
<a name="l01145"></a>01145       <span class="keywordtype">double</span> security_coeff=0.95;
<a name="l01146"></a>01146       <span class="keywordtype">double</span> dt_corrector=-1.;
<a name="l01147"></a>01147       <span class="keywordtype">double</span> kij=0.;
<a name="l01148"></a>01148 
<a name="l01149"></a>01149 <span class="comment">// soit on a transporte=phi*transporte_ et vitesse=vitesse_</span>
<a name="l01150"></a>01150 <span class="comment">// soit transporte=transporte_ et vitesse=phi*vitesse_</span>
<a name="l01151"></a>01151 <span class="comment">// cela depend si on transporte avec phi u ou avec u.</span>
<a name="l01152"></a>01152       <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a> vitesse_face_;
<a name="l01153"></a>01153       <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; velocity=<a class="code" href="Porosites__champ_8cpp.html#a2340e7d73d0f9d34926d012fe1b1d884" title="renvoit le tableau res, res=org si flag=0, res= porosite*org sinon attention ne pas modifier res car ...">modif_par_porosite_si_flag</a>(vitesse_2,vitesse_face_,marq,porosite_face);
<a name="l01154"></a>01154 
<a name="l01155"></a>01155 <span class="comment">// statistiques().begin_count(m1);</span>
<a name="l01156"></a>01156       <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a> Kij(nb_elem_tot,nb_faces_elem,nb_faces_elem);
<a name="l01157"></a>01157       <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a> Cij(nb_elem_tot,nfa7);
<a name="l01158"></a>01158       <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a> Sij(nb_elem_tot,nfa7);
<a name="l01159"></a>01159       <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a> Sij2;
<a name="l01160"></a>01160       <span class="keywordflow">if</span> (<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>==3)
<a name="l01161"></a>01161         {
<a name="l01162"></a>01162           Sij2.<a class="code" href="classDoubleTab.html#ae83b4d31205c53d9c8d2b43da178ce75" title="Change la taille du vecteur (identique a resize_array() pour le traitement des anciennes valeurs et d...">resize</a>(nb_elem_tot,nfa7);
<a name="l01163"></a>01163           Sij2=0.;
<a name="l01164"></a>01164         }
<a name="l01165"></a>01165       <a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#afde9a8f6daffddcc35a097fd68674797">calculer_coefficients_operateur_centre</a>(Kij,Cij,Sij,Sij2,nb_comp,velocity);
<a name="l01166"></a>01166 
<a name="l01167"></a>01167 <span class="comment">// Debut du calcul</span>
<a name="l01168"></a>01168       <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a> plus_tab(nb_faces_tot);
<a name="l01169"></a>01169       <span class="keywordflow">for</span> (elem=0; elem&lt;nb_elem_tot; elem++)
<a name="l01170"></a>01170         <span class="keywordflow">for</span> (facei_loc=0; facei_loc&lt;nb_faces_elem; facei_loc++)
<a name="l01171"></a>01171           {
<a name="l01172"></a>01172             facei=elem_faces(elem,facei_loc);
<a name="l01173"></a>01173             <span class="keywordflow">for</span> (facej_loc=facei_loc+1; facej_loc&lt;nb_faces_elem; facej_loc++)
<a name="l01174"></a>01174               {
<a name="l01175"></a>01175                 kij=Kij(elem,facei_loc,facej_loc);
<a name="l01176"></a>01176                 facej=elem_faces(elem,facej_loc);
<a name="l01177"></a>01177 
<a name="l01178"></a>01178                 <span class="keywordflow">if</span> (kij&gt;=0.)
<a name="l01179"></a>01179                   plus_tab(facei)+=1;
<a name="l01180"></a>01180                 <span class="keywordflow">else</span>
<a name="l01181"></a>01181                   plus_tab(facej)+=1;
<a name="l01182"></a>01182               }
<a name="l01183"></a>01183           }
<a name="l01184"></a>01184       <span class="keywordflow">for</span> (n_bord=0; n_bord&lt;nb_bord; n_bord++)
<a name="l01185"></a>01185         {
<a name="l01186"></a>01186           <span class="keyword">const</span> <a class="code" href="classCond__lim.html" title="classe Cond_lim Classe generique servant a representer n&#39;importe quelle classe derivee de la classe C...">Cond_lim</a>&amp; la_cl = zone_Cl_VEF.<a class="code" href="classZone__Cl__dis__base.html#af75e0ed7786863e4d333bfb29d67c323" title="Renvoie la i-ieme condition aux limites. (version const)">les_conditions_limites</a>(n_bord);
<a name="l01187"></a>01187           <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp; le_bord = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>,la_cl.<a class="code" href="classCond__lim.html#a5b2d24809cee07727006a891d4ce8d22" title="Appel a l&#39;objet sous-jacent Renvoie la frontiere discretisee associee a la condition aux limites...">frontiere_dis</a>());
<a name="l01188"></a>01188           num1=0;
<a name="l01189"></a>01189           num2=le_bord.<a class="code" href="classFront__VF.html#aed4006d91bf2ef3af2b9f7933d863a09" title="Nombre de faces reelles et virtuelles du bord.">nb_faces_tot</a>();
<a name="l01190"></a>01190 
<a name="l01191"></a>01191           <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>()))
<a name="l01192"></a>01192             {
<a name="l01193"></a>01193               <span class="keyword">const</span> <a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>&amp; la_cl_perio = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>());
<a name="l01194"></a>01194 
<a name="l01195"></a>01195               <span class="keywordflow">for</span> (ind_face=num1; ind_face&lt;num2; ind_face++)
<a name="l01196"></a>01196                 {
<a name="l01197"></a>01197                   facei=le_bord.<a class="code" href="classFront__VF.html#a3402a19d7e54ed797d2b18e9a47ead1e" title="Renvoie le numero de face de la ieme face du bord.">num_face</a>(ind_face);
<a name="l01198"></a>01198                   ind_face_associee=la_cl_perio.<a class="code" href="classPeriodique.html#a207b86556f199a63ea059b841851ca6a">face_associee</a>(ind_face);
<a name="l01199"></a>01199                   faceiAss=le_bord.<a class="code" href="classFront__VF.html#a3402a19d7e54ed797d2b18e9a47ead1e" title="Renvoie le numero de face de la ieme face du bord.">num_face</a>(ind_face_associee);
<a name="l01200"></a>01200 
<a name="l01201"></a>01201                   <span class="keywordflow">if</span> (facei&lt;faceiAss)
<a name="l01202"></a>01202                     {
<a name="l01203"></a>01203                       plus_tab[faceiAss]+=plus_tab[facei];
<a name="l01204"></a>01204                       plus_tab[facei]=plus_tab[faceiAss];
<a name="l01205"></a>01205                     }
<a name="l01206"></a>01206 
<a name="l01207"></a>01207                 }<span class="comment">//fin du for sur &quot;ind_face&quot;</span>
<a name="l01208"></a>01208 
<a name="l01209"></a>01209             }<span class="comment">//fin du if sur &quot;Periodique&quot;</span>
<a name="l01210"></a>01210 
<a name="l01211"></a>01211         }<span class="comment">//fin du for sur &quot;n_bord&quot;</span>
<a name="l01212"></a>01212       max_int=plus_tab.<a class="code" href="classIntVect.html#a8b11017f6dcfd2456d5c70bdc0c67013">mp_max_vect</a>();
<a name="l01213"></a>01213       max_int=(int)<a class="code" href="classProcess.html#a1e9d9f9899b71927cfafae14c7bd048d" title="Calcule le max de x sur tous les processeurs du groupe courant. Remarques : Cette methode doit etre a...">Process::mp_max</a>(max_int);
<a name="l01214"></a>01214 
<a name="l01215"></a>01215       dt_corrector=1./(1+<a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#ae5e76d1a00689f96fe333745b2a6c2ef">max_limiteur_</a>*max_int);
<a name="l01216"></a>01216       dt_corrector*=security_coeff;
<a name="l01217"></a>01217       dt_stab*=dt_corrector;
<a name="l01218"></a>01218 
<a name="l01219"></a>01219       <a class="code" href="classOp__Conv__VEF__base.html" title="class Op_Conv_VEF_base Classe de base des operateurs de convection VEF">Op_Conv_VEF_base</a>&amp; op = <a class="code" href="Cast_8h.html#ad3836a067c92103af8df5ad8f35959a6">ref_cast_non_const</a>(<a class="code" href="classOp__Conv__VEF__base.html" title="class Op_Conv_VEF_base Classe de base des operateurs de convection VEF">Op_Conv_VEF_base</a>,*<span class="keyword">this</span>);
<a name="l01220"></a>01220       op.<a class="code" href="classOperateur__Conv__base.html#a868dd39f29b4f613ec620fe5ada95977">fixer_dt_stab_conv</a>(dt_stab);
<a name="l01221"></a>01221 
<a name="l01222"></a>01222       <span class="keywordflow">return</span> dt_stab;
<a name="l01223"></a>01223     }
<a name="l01224"></a>01224 }
<a name="l01225"></a>01225 
<a name="l01226"></a>01226 <span class="comment">// Correction pour le poreux : on rajoute la partie en  T div(u)</span>
<a name="l01227"></a>01227 <span class="comment">// Variable transportee : T</span>
<a name="l01228"></a>01228 <span class="comment">// Variable transportante : u</span>
<a name="l01229"></a>01229 <span class="comment">// REMARQUE : il ne FAUT SURTOUT PAS utiliser le tableau Kij car par</span>
<a name="l01230"></a>01230 <span class="comment">// construction celui-ci est telle que sum_{j} Kij =0 ce qui revient a</span>
<a name="l01231"></a>01231 <span class="comment">// imposer une vitesse a divergence nulle par element. Ce qui est</span>
<a name="l01232"></a>01232 <span class="comment">// problematique quand on est en compressible</span>
<a name="l01233"></a><a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#a141336115c6ef5ebfb3b4bc9d2a0863a">01233</a> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; <a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#a141336115c6ef5ebfb3b4bc9d2a0863a">Op_Conv_Muscl_New_VEF_Face::ajouter_partie_compressible</a>(<span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; transporte,
<a name="l01234"></a>01234                                                                    <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; resu, <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; vitesse_2)<span class="keyword"> const</span>
<a name="l01235"></a>01235 <span class="keyword"></span>{
<a name="l01236"></a>01236 <span class="comment">// const Zone_VEF&amp; zone_VEF=la_zone_vef.valeur();</span>
<a name="l01237"></a>01237 
<a name="l01238"></a>01238 <span class="comment">// const IntTab&amp; elem_faces=zone_VEF.elem_faces();</span>
<a name="l01239"></a>01239 <span class="comment">// const IntTab&amp; face_voisins = zone_VEF.face_voisins();</span>
<a name="l01240"></a>01240 
<a name="l01241"></a>01241 <span class="comment">// const DoubleTab&amp; face_normales=zone_VEF.face_normales();</span>
<a name="l01242"></a>01242 
<a name="l01243"></a>01243 <span class="comment">// const int nb_elem_tot=zone_VEF.nb_elem_tot();</span>
<a name="l01244"></a>01244 <span class="comment">// const int nb_faces_elem=elem_faces.dimension(1);</span>
<a name="l01245"></a>01245 
<a name="l01246"></a>01246 <span class="comment">// //Pour tenir compte de la porosite</span>
<a name="l01247"></a>01247 <span class="comment">// const int marq = phi_u_transportant(equation());</span>
<a name="l01248"></a>01248 
<a name="l01249"></a>01249 <span class="comment">// const DoubleVect&amp; porosite_elem = zone_VEF.porosite_elem();</span>
<a name="l01250"></a>01250 <span class="comment">// const DoubleVect&amp; porosite_face = zone_VEF.porosite_face();</span>
<a name="l01251"></a>01251 
<a name="l01252"></a>01252 <span class="comment">// DoubleTab vitesse(vitesse_.valeur().valeurs());</span>
<a name="l01253"></a>01253 <span class="comment">// for (int i=0; i&lt;vitesse.dimension(0); i++)</span>
<a name="l01254"></a>01254 <span class="comment">// for (int j=0; j&lt;vitesse.dimension(1); j++)</span>
<a name="l01255"></a>01255 <span class="comment">// vitesse(i,j)*=porosite_face(i);</span>
<a name="l01256"></a>01256 
<a name="l01257"></a>01257 <span class="comment">// int nb_comp=1;</span>
<a name="l01258"></a>01258 <span class="comment">// if (transporte.nb_dim()!=1) nb_comp=transporte.dimension(1);</span>
<a name="l01259"></a>01259 
<a name="l01260"></a>01260 <span class="comment">// int elem=0,type_elem=0;</span>
<a name="l01261"></a>01261 <span class="comment">// int facei=0,facei_loc=0;</span>
<a name="l01262"></a>01262 <span class="comment">// int ligne=0;</span>
<a name="l01263"></a>01263 <span class="comment">// int dim=0;</span>
<a name="l01264"></a>01264 
<a name="l01265"></a>01265 <span class="comment">// double coeff=0.;</span>
<a name="l01266"></a>01266 <span class="comment">// double signe=0.;</span>
<a name="l01267"></a>01267 <span class="comment">// double div=0.;</span>
<a name="l01268"></a>01268 
<a name="l01269"></a>01269 <span class="comment">// const DoubleVect&amp; transporteV=ref_cast(DoubleVect,transporte);</span>
<a name="l01270"></a>01270 <span class="comment">// DoubleVect&amp; resuV=ref_cast(DoubleVect,resu);</span>
<a name="l01271"></a>01271 
<a name="l01272"></a>01272 <span class="comment">// double (*formule)(int);</span>
<a name="l01273"></a>01273 <span class="comment">// if (!volumes_etendus_)</span>
<a name="l01274"></a>01274 <span class="comment">// if (dimension==2) formule=&amp;formule_Id_2D;</span>
<a name="l01275"></a>01275 <span class="comment">// else formule=&amp;formule_Id_3D;</span>
<a name="l01276"></a>01276 <span class="comment">// else</span>
<a name="l01277"></a>01277 <span class="comment">// if (dimension==2) formule=&amp;formule_2D;</span>
<a name="l01278"></a>01278 <span class="comment">// else formule=&amp;formule_3D;</span>
<a name="l01279"></a>01279 
<a name="l01280"></a>01280 <span class="comment">// for (elem=0; elem&lt;nb_elem_tot; elem++)</span>
<a name="l01281"></a>01281 <span class="comment">// {</span>
<a name="l01282"></a>01282 <span class="comment">// //Type de l&#39;element : le nombre de faces de Dirichlet</span>
<a name="l01283"></a>01283 <span class="comment">// //qu&#39;il contient</span>
<a name="l01284"></a>01284 <span class="comment">// type_elem=elem_nb_faces_dirichlet_(elem);</span>
<a name="l01285"></a>01285 <span class="comment">// coeff=formule(type_elem);</span>
<a name="l01286"></a>01286 
<a name="l01287"></a>01287 <span class="comment">// //Calcul de la divergence par element</span>
<a name="l01288"></a>01288 <span class="comment">// div=0.;</span>
<a name="l01289"></a>01289 <span class="comment">// for (facei_loc=0; facei_loc&lt;nb_faces_elem; facei_loc++)</span>
<a name="l01290"></a>01290 <span class="comment">// {</span>
<a name="l01291"></a>01291 <span class="comment">// facei=elem_faces(elem,facei_loc);</span>
<a name="l01292"></a>01292 <span class="comment">// signe=(face_voisins(facei,0)==elem)? 1.:-1.;</span>
<a name="l01293"></a>01293 
<a name="l01294"></a>01294 <span class="comment">// for (dim=0; dim&lt;dimension; dim++)</span>
<a name="l01295"></a>01295 <span class="comment">// div+=signe*face_normales(facei,dim)*vitesse(facei,dim);</span>
<a name="l01296"></a>01296 <span class="comment">// }</span>
<a name="l01297"></a>01297 <span class="comment">// div*=coeff;</span>
<a name="l01298"></a>01298 <span class="comment">// if (!marq) div/=porosite_elem(elem);</span>
<a name="l01299"></a>01299 
<a name="l01300"></a>01300 <span class="comment">// //Calcul de la partie compressible</span>
<a name="l01301"></a>01301 <span class="comment">// for (facei_loc=0; facei_loc&lt;nb_faces_elem; facei_loc++)</span>
<a name="l01302"></a>01302 <span class="comment">// {</span>
<a name="l01303"></a>01303 <span class="comment">// facei=elem_faces(elem,facei_loc);</span>
<a name="l01304"></a>01304 
<a name="l01305"></a>01305 <span class="comment">// for (dim=0; dim&lt;nb_comp; dim++)</span>
<a name="l01306"></a>01306 <span class="comment">// {</span>
<a name="l01307"></a>01307 <span class="comment">// ligne=facei*nb_comp+dim;</span>
<a name="l01308"></a>01308 <span class="comment">// resuV[ligne]-=div*transporteV[ligne];</span>
<a name="l01309"></a>01309 <span class="comment">// }</span>
<a name="l01310"></a>01310 <span class="comment">// }</span>
<a name="l01311"></a>01311 <span class="comment">// }</span>
<a name="l01312"></a>01312 
<a name="l01313"></a>01313   <span class="keywordflow">return</span> resu;
<a name="l01314"></a>01314 }
<a name="l01315"></a>01315 
<a name="l01316"></a><a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#ad9cd682b100057d3019ba30b61a9b469">01316</a> <span class="keywordtype">void</span> <a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#ad9cd682b100057d3019ba30b61a9b469">Op_Conv_Muscl_New_VEF_Face::calculer_flux_bords</a>(<span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; Kij, <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; velocity, <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; transporte)<span class="keyword"> const</span>
<a name="l01317"></a>01317 <span class="keyword"></span>{
<a name="l01318"></a>01318 
<a name="l01319"></a>01319   <span class="keyword">const</span> <a class="code" href="classZone__VEF.html" title="class Zone_VEF Classe instanciable qui derive de Zone_VF. Cette classe contient les informations geom...">Zone_VEF</a>&amp; zone_VEF=<a class="code" href="classOp__Conv__VEF__base.html#a6c29a488a6805ba4a9f2f059cdba77ae">la_zone_vef</a>.<a class="code" href="classRef__Zone__VEF.html#aafd9a5ee1a76f290c9c6b5447b0c8d30">valeur</a>();
<a name="l01320"></a>01320   <span class="keyword">const</span> <a class="code" href="classZone__Cl__VEF.html">Zone_Cl_VEF</a>&amp; zone_Cl_VEF = <a class="code" href="classOp__Conv__VEF__base.html#a03f677ee7911706a4f85cd37e0ca4535">la_zcl_vef</a>.<a class="code" href="classRef__Zone__Cl__VEF.html#a0970d7253def65ad4f0c5ce1830fd243">valeur</a>();
<a name="l01321"></a>01321 
<a name="l01322"></a>01322 
<a name="l01323"></a>01323   <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; transporteV=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classDoubleVect.html">DoubleVect</a>,transporte);
<a name="l01324"></a>01324   <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; face_normales=zone_VEF.<a class="code" href="classZone__VEF.html#a5742d75972e4846bf9fbb6ed5715053e">face_normales</a>();
<a name="l01325"></a>01325 
<a name="l01326"></a>01326   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_bord = zone_Cl_VEF.<a class="code" href="classZone__Cl__dis__base.html#aa6f1df56cfd6e2eae83cc991c7cc9b41" title="Renvoie le nombre de conditions aux limites.">nb_cond_lim</a>();
<a name="l01327"></a>01327 
<a name="l01328"></a>01328   <span class="keywordtype">int</span> nb_comp=1;
<a name="l01329"></a>01329   <span class="keywordflow">if</span> (transporte.<a class="code" href="classDoubleTab.html#ae6dda48778e7107e1beb723beef1f75b" title="Returns the number of dimensions of the array (&gt;= 1)">nb_dim</a>()!=1) nb_comp=transporte.<a class="code" href="classDoubleTab.html#ac3805e2637a3b880ba2d3e650c69dac4" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(1);
<a name="l01330"></a>01330 
<a name="l01331"></a>01331   <span class="keywordtype">int</span> facei=0;
<a name="l01332"></a>01332   <span class="keywordtype">int</span> dim=0;
<a name="l01333"></a>01333   <span class="keywordtype">int</span> n_bord=0;
<a name="l01334"></a>01334   <span class="keywordtype">int</span> num1=0,num2=0;
<a name="l01335"></a>01335   <span class="keywordtype">int</span> ind_face=0;
<a name="l01336"></a>01336 
<a name="l01337"></a>01337   <span class="keywordtype">double</span> psc=0.;
<a name="l01338"></a>01338 
<a name="l01339"></a>01339   <span class="keywordflow">for</span> (n_bord=0; n_bord&lt;nb_bord; n_bord++)
<a name="l01340"></a>01340     {
<a name="l01341"></a>01341       <span class="keyword">const</span> <a class="code" href="classCond__lim.html" title="classe Cond_lim Classe generique servant a representer n&#39;importe quelle classe derivee de la classe C...">Cond_lim</a>&amp; la_cl = zone_Cl_VEF.<a class="code" href="classZone__Cl__dis__base.html#af75e0ed7786863e4d333bfb29d67c323" title="Renvoie la i-ieme condition aux limites. (version const)">les_conditions_limites</a>(n_bord);
<a name="l01342"></a>01342       <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp; le_bord = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>,la_cl.<a class="code" href="classCond__lim.html#a5b2d24809cee07727006a891d4ce8d22" title="Appel a l&#39;objet sous-jacent Renvoie la frontiere discretisee associee a la condition aux limites...">frontiere_dis</a>());
<a name="l01343"></a>01343       num1 = 0;
<a name="l01344"></a>01344       num2 = le_bord.<a class="code" href="classFront__VF.html#a341e2fcb5117b96e745fd7078ba86bab" title="Nombre de faces reelles du bord.">nb_faces</a>();<span class="comment">//il ne faut boucler que sur les faces reelles ici</span>
<a name="l01345"></a>01345 
<a name="l01346"></a>01346       <span class="keywordflow">if</span> ( <a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classDirichlet__homogene.html" title="Classe Dirichlet_homogene Cette classe est la classe de base de la hierarchie des conditions aux limi...">Dirichlet_homogene</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>()) )
<a name="l01347"></a>01347         {
<a name="l01348"></a>01348 <span class="comment">// On ne calcule pas le flux aux bords de Dirichlet_homogene</span>
<a name="l01349"></a>01349         }<span class="comment">//fin du if sur &quot;Dirichlet&quot;</span>
<a name="l01350"></a>01350       <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( <a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classDirichlet.html" title="classe Dirichlet Cette classe est la classe de base de la hierarchie des conditions aux limites de ty...">Dirichlet</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>() ))
<a name="l01351"></a>01351         {
<a name="l01352"></a>01352           <span class="keywordflow">for</span> (ind_face=num1; ind_face&lt;num2; ind_face++)
<a name="l01353"></a>01353             {
<a name="l01354"></a>01354               facei = le_bord.<a class="code" href="classFront__VF.html#a3402a19d7e54ed797d2b18e9a47ead1e" title="Renvoie le numero de face de la ieme face du bord.">num_face</a>(ind_face);
<a name="l01355"></a>01355 
<a name="l01356"></a>01356               psc=0.;
<a name="l01357"></a>01357               <span class="keywordflow">for</span> (dim=0; dim&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; dim++)
<a name="l01358"></a>01358                 psc-=velocity(facei,dim)*face_normales(facei,dim);
<a name="l01359"></a>01359 
<a name="l01360"></a>01360               <span class="keywordflow">for</span> (dim=0; dim&lt;nb_comp; dim++)
<a name="l01361"></a>01361                 <a class="code" href="classOperateur__base.html#a451f51b41518ddbc0d3f586a8177d319" title="Tableau contenant les flux sur les bords de l&#39;operateur.">flux_bords_</a>(facei,dim)=psc*transporteV[facei*nb_comp+dim];
<a name="l01362"></a>01362             }
<a name="l01363"></a>01363         }
<a name="l01364"></a>01364       <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( ( <a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classNeumann.html" title="Classe Neumann Cette classe est la classe de base de la hierarchie des conditions aux limites de type...">Neumann</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>()) &amp;&amp;
<a name="l01365"></a>01365                   !( <a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classNeumann__sortie__libre.html" title="classe Neumann_sortie_libre Cette classe represente une frontiere ouverte sans vitesse imposee Pour l...">Neumann_sortie_libre</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>())) )
<a name="l01366"></a>01366                 || <a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classNeumann__homogene.html" title="Classe Neumann_homogene Cette classe est la classe de base de la hierarchie des conditions aux limite...">Neumann_homogene</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>())
<a name="l01367"></a>01367                 || <a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classSymetrie.html" title="classe Symetrie Sur les faces de symetrie on a les proprietes suivantes: - composante normale de la v...">Symetrie</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>())
<a name="l01368"></a>01368                 || <a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classEchange__impose__base.html" title="classe Echange_impose_base: Cette condition limite sert uniquement pour l&#39;equation d&#39;energie...">Echange_impose_base</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>())
<a name="l01369"></a>01369               )
<a name="l01370"></a>01370         {
<a name="l01371"></a>01371           <span class="keywordflow">for</span> (ind_face=num1; ind_face&lt;num2; ind_face++)
<a name="l01372"></a>01372             {
<a name="l01373"></a>01373               facei = le_bord.<a class="code" href="classFront__VF.html#a3402a19d7e54ed797d2b18e9a47ead1e" title="Renvoie le numero de face de la ieme face du bord.">num_face</a>(ind_face);
<a name="l01374"></a>01374 
<a name="l01375"></a>01375               psc=0.;
<a name="l01376"></a>01376               <span class="keywordflow">for</span> (dim=0; dim&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; dim++)
<a name="l01377"></a>01377                 psc-=velocity(facei,dim)*face_normales(facei,dim);
<a name="l01378"></a>01378 
<a name="l01379"></a>01379               <span class="keywordflow">for</span> (dim=0; dim&lt;nb_comp; dim++)
<a name="l01380"></a>01380                 <a class="code" href="classOperateur__base.html#a451f51b41518ddbc0d3f586a8177d319" title="Tableau contenant les flux sur les bords de l&#39;operateur.">flux_bords_</a>(facei,dim)=psc*transporteV[facei*nb_comp+dim];
<a name="l01381"></a>01381             }
<a name="l01382"></a>01382 
<a name="l01383"></a>01383         }<span class="comment">//fin du if sur &quot;Neumann&quot;, &quot;Neumann_homogene&quot;, &quot;Symetrie&quot;, &quot;Echange_impose_base&quot;</span>
<a name="l01384"></a>01384       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classNeumann__sortie__libre.html" title="classe Neumann_sortie_libre Cette classe represente une frontiere ouverte sans vitesse imposee Pour l...">Neumann_sortie_libre</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>()))
<a name="l01385"></a>01385         {
<a name="l01386"></a>01386           <span class="keyword">const</span> <a class="code" href="classNeumann__sortie__libre.html" title="classe Neumann_sortie_libre Cette classe represente une frontiere ouverte sans vitesse imposee Pour l...">Neumann_sortie_libre</a>&amp; la_sortie_libre = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classNeumann__sortie__libre.html" title="classe Neumann_sortie_libre Cette classe represente une frontiere ouverte sans vitesse imposee Pour l...">Neumann_sortie_libre</a>, la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>());
<a name="l01387"></a>01387 
<a name="l01388"></a>01388           <span class="keywordflow">for</span> (ind_face=num1; ind_face&lt;num2; ind_face++)
<a name="l01389"></a>01389             {
<a name="l01390"></a>01390               facei = le_bord.<a class="code" href="classFront__VF.html#a3402a19d7e54ed797d2b18e9a47ead1e" title="Renvoie le numero de face de la ieme face du bord.">num_face</a>(ind_face);
<a name="l01391"></a>01391 
<a name="l01392"></a>01392               psc=0.;
<a name="l01393"></a>01393               <span class="keywordflow">for</span> (dim=0; dim&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; dim++)
<a name="l01394"></a>01394                 psc-=velocity(facei,dim)*face_normales(facei,dim);
<a name="l01395"></a>01395 
<a name="l01396"></a>01396               <span class="keywordflow">if</span> (psc&lt;0.)
<a name="l01397"></a>01397                 {
<a name="l01398"></a>01398                   <span class="keywordflow">for</span> (dim=0; dim&lt;nb_comp; dim++)
<a name="l01399"></a>01399                     {
<a name="l01400"></a>01400                       <a class="code" href="classOperateur__base.html#a451f51b41518ddbc0d3f586a8177d319" title="Tableau contenant les flux sur les bords de l&#39;operateur.">flux_bords_</a>(facei,dim) = psc*transporteV[facei*nb_comp+dim];
<a name="l01401"></a>01401                     }
<a name="l01402"></a>01402                 }
<a name="l01403"></a>01403               <span class="keywordflow">else</span>
<a name="l01404"></a>01404                 {
<a name="l01405"></a>01405                   <span class="keywordflow">if</span> (nb_comp == 1)
<a name="l01406"></a>01406                     {
<a name="l01407"></a>01407                       <a class="code" href="classOperateur__base.html#a451f51b41518ddbc0d3f586a8177d319" title="Tableau contenant les flux sur les bords de l&#39;operateur.">flux_bords_</a>(facei,0) = psc*la_sortie_libre.<a class="code" href="classNeumann__sortie__libre.html#a886f1804fa2a9028fc56a0778a72a75d" title="Renvoie la valeur de la i-eme composante du champ impose a l&#39;exterieur de la frontiere.">val_ext</a>(ind_face);
<a name="l01408"></a>01408                     }
<a name="l01409"></a>01409                   <span class="keywordflow">else</span>
<a name="l01410"></a>01410                     {
<a name="l01411"></a>01411                       <span class="keywordflow">for</span> (dim=0; dim&lt;nb_comp; dim++)
<a name="l01412"></a>01412                         {
<a name="l01413"></a>01413                           <a class="code" href="classOperateur__base.html#a451f51b41518ddbc0d3f586a8177d319" title="Tableau contenant les flux sur les bords de l&#39;operateur.">flux_bords_</a>(facei,dim) = psc*la_sortie_libre.<a class="code" href="classNeumann__sortie__libre.html#a886f1804fa2a9028fc56a0778a72a75d" title="Renvoie la valeur de la i-eme composante du champ impose a l&#39;exterieur de la frontiere.">val_ext</a>(ind_face,dim);
<a name="l01414"></a>01414                         }
<a name="l01415"></a>01415                     }
<a name="l01416"></a>01416                 }
<a name="l01417"></a>01417             }
<a name="l01418"></a>01418         }
<a name="l01419"></a>01419       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>()))
<a name="l01420"></a>01420         {
<a name="l01421"></a>01421           <span class="keyword">const</span> <a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>&amp; la_cl_perio = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>, la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>());
<a name="l01422"></a>01422 
<a name="l01423"></a>01423           <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> fait(num2);
<a name="l01424"></a>01424           fait = 0;
<a name="l01425"></a>01425 
<a name="l01426"></a>01426           <span class="keywordtype">int</span> ind_face_voisine = -1;
<a name="l01427"></a>01427           <span class="keywordtype">int</span> facei_voisine    = -1;
<a name="l01428"></a>01428           <span class="keywordtype">double</span> flux             = 0.;
<a name="l01429"></a>01429 
<a name="l01430"></a>01430           <span class="keywordflow">for</span> (ind_face=num1; ind_face&lt;num2; ind_face++)
<a name="l01431"></a>01431             {
<a name="l01432"></a>01432               <span class="keywordflow">if</span> (fait[ind_face] == 0)
<a name="l01433"></a>01433                 {
<a name="l01434"></a>01434                   facei            = le_bord.<a class="code" href="classFront__VF.html#a3402a19d7e54ed797d2b18e9a47ead1e" title="Renvoie le numero de face de la ieme face du bord.">num_face</a>(ind_face);
<a name="l01435"></a>01435                   ind_face_voisine = la_cl_perio.<a class="code" href="classPeriodique.html#a207b86556f199a63ea059b841851ca6a">face_associee</a>(ind_face);
<a name="l01436"></a>01436                   facei_voisine    = le_bord.<a class="code" href="classFront__VF.html#a3402a19d7e54ed797d2b18e9a47ead1e" title="Renvoie le numero de face de la ieme face du bord.">num_face</a>(ind_face_voisine);
<a name="l01437"></a>01437 
<a name="l01438"></a>01438                   psc=0.;
<a name="l01439"></a>01439                   <span class="keywordflow">for</span> (dim=0; dim&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; dim++)
<a name="l01440"></a>01440                     psc-=velocity(facei,dim)*face_normales(facei,dim);
<a name="l01441"></a>01441 
<a name="l01442"></a>01442                   <span class="keywordflow">for</span> (dim=0; dim&lt;nb_comp; dim++)
<a name="l01443"></a>01443                     {
<a name="l01444"></a>01444                       flux                           = psc*transporteV[facei*nb_comp+dim];
<a name="l01445"></a>01445                       <a class="code" href="classOperateur__base.html#a451f51b41518ddbc0d3f586a8177d319" title="Tableau contenant les flux sur les bords de l&#39;operateur.">flux_bords_</a>(facei,dim)         =  flux;
<a name="l01446"></a>01446                       <a class="code" href="classOperateur__base.html#a451f51b41518ddbc0d3f586a8177d319" title="Tableau contenant les flux sur les bords de l&#39;operateur.">flux_bords_</a>(facei_voisine,dim) = -flux;
<a name="l01447"></a>01447                     }
<a name="l01448"></a>01448 
<a name="l01449"></a>01449                   fait[ind_face]         = 1;
<a name="l01450"></a>01450                   fait[ind_face_voisine] = 1;
<a name="l01451"></a>01451                 }
<a name="l01452"></a>01452             }
<a name="l01453"></a>01453         }
<a name="l01454"></a>01454       <span class="keywordflow">else</span>
<a name="l01455"></a>01455         {
<a name="l01456"></a>01456           <span class="keywordflow">if</span> (<a class="code" href="classProcess.html#acd052b99706c577f8a5b6656217cf4c2" title="renvoie 1 si on est sur le processeur maitre du groupe courant (c&#39;est a dire me() == 0)...">Process::je_suis_maitre</a>())
<a name="l01457"></a>01457             {
<a name="l01458"></a>01458               <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Erreur Op_Conv_Muscl_New_VEF_Face::calculer_flux_bords()&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
<a name="l01459"></a>01459               <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Condition aux limites &quot;</span> &lt;&lt; la_cl.<a class="code" href="classObjet__U.html#aa58e9a81c0ddc2c1149053b8f96698ac" title="renvoie la chaine identifiant la classe.">que_suis_je</a>() &lt;&lt; <span class="stringliteral">&quot; non codee.&quot;</span>   &lt;&lt; finl;
<a name="l01460"></a>01460               <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Sortie du programme.&quot;</span> &lt;&lt; finl;
<a name="l01461"></a>01461             }
<a name="l01462"></a>01462           <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">Process::exit</a>();
<a name="l01463"></a>01463         }<span class="comment">//fin du else sur les autres conditions aux limites</span>
<a name="l01464"></a>01464     }
<a name="l01465"></a>01465 }
<a name="l01466"></a>01466 
<a name="l01467"></a>01467 <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp;
<a name="l01468"></a><a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#a0cd4001abc6587f38b6e3f23d251bc68">01468</a> <a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#a0cd4001abc6587f38b6e3f23d251bc68">Op_Conv_Muscl_New_VEF_Face::ajouter_operateur_centre</a>(<span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; Kij, <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; Fij, <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; transporte, <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; resu)<span class="keyword"> const</span>
<a name="l01469"></a>01469 <span class="keyword"></span>{
<a name="l01470"></a>01470   <span class="keyword">const</span> <a class="code" href="classZone__VEF.html" title="class Zone_VEF Classe instanciable qui derive de Zone_VF. Cette classe contient les informations geom...">Zone_VEF</a>&amp; zone_VEF=<a class="code" href="classOp__Conv__VEF__base.html#a6c29a488a6805ba4a9f2f059cdba77ae">la_zone_vef</a>.<a class="code" href="classRef__Zone__VEF.html#aafd9a5ee1a76f290c9c6b5447b0c8d30">valeur</a>();
<a name="l01471"></a>01471 
<a name="l01472"></a>01472   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; elem_faces=zone_VEF.<a class="code" href="classZone__VF.html#a067e462dcd3ab92b0f6d945b19e4eb37" title="renvoie le numero de le ieme face de la maille num_elem la facon dont ces faces sont numerotees est l...">elem_faces</a>();
<a name="l01473"></a>01473   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; KEL=zone_VEF.<a class="code" href="classZone__VEF.html#a46693c060b8096fb2595ca72192eea2a">type_elem</a>().<a class="code" href="classDeriv__Elem__VEF__base.html#a2886905d5071be902c77248b69ca0b7b">valeur</a>().<a class="code" href="classElem__VEF__base.html#ab129610ef702aa8c9c98dcb4c7551172">KEL</a>();
<a name="l01474"></a>01474   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; face_voisins=zone_VEF.<a class="code" href="classZone__VF.html#a49d4322f5585a8fa95748ca785b70702" title="renvoie l&#39;element voisin de numface dans la direction i. i=0 : dans le sens oppose de l&#39;axe orthogona...">face_voisins</a>();
<a name="l01475"></a>01475   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; num_fac_loc = zone_VEF.<a class="code" href="classZone__VF.html#a95113b10f16f37600ba81d3fb41102b2">get_num_fac_loc</a>();
<a name="l01476"></a>01476 
<a name="l01477"></a>01477   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_elem_tot=zone_VEF.<a class="code" href="classZone__dis__base.html#a4d6aa445f152aa6dc54d66ea7a071147">nb_elem_tot</a>();
<a name="l01478"></a>01478   <span class="keyword">const</span> <span class="keywordtype">int</span> nfa7 = zone_VEF.<a class="code" href="classZone__VEF.html#a46693c060b8096fb2595ca72192eea2a">type_elem</a>().<a class="code" href="classElem__VEF.html#a4a34777c0083b38dd34c8a400d5b4e90">nb_facette</a>();
<a name="l01479"></a>01479   <span class="keyword">const</span> <span class="keywordtype">int</span> premiere_face_int = zone_VEF.<a class="code" href="classZone__VF.html#a12869806fa4834aca8f2964e16509dfd" title="une face est interne ssi elle separe deux elements. renvoie le numero de la premiere face interne...">premiere_face_int</a>();
<a name="l01480"></a>01480   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_faces = zone_VEF.<a class="code" href="classZone__VF.html#aede27992d9f2eedd52c24d4a80ff7ffb" title="renvoie le nombre global de faces.">nb_faces</a>();
<a name="l01481"></a>01481 
<a name="l01482"></a>01482   <span class="keywordtype">int</span> nb_comp=1;
<a name="l01483"></a>01483   <span class="keywordflow">if</span> (transporte.<a class="code" href="classDoubleTab.html#ae6dda48778e7107e1beb723beef1f75b" title="Returns the number of dimensions of the array (&gt;= 1)">nb_dim</a>()!=1) nb_comp=transporte.<a class="code" href="classDoubleTab.html#ac3805e2637a3b880ba2d3e650c69dac4" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(1);
<a name="l01484"></a>01484 
<a name="l01485"></a>01485   <span class="keywordtype">int</span> elem=0;
<a name="l01486"></a>01486   <span class="keywordtype">int</span> facei=0,facei_loc=0;
<a name="l01487"></a>01487   <span class="keywordtype">int</span> facej=0,facej_loc=0;
<a name="l01488"></a>01488   <span class="keywordtype">int</span> ligne=0,colonne=0;
<a name="l01489"></a>01489   <span class="keywordtype">int</span> dim=0;
<a name="l01490"></a>01490   <span class="keywordtype">int</span> fa7=0;
<a name="l01491"></a>01491 
<a name="l01492"></a>01492   <span class="keywordtype">double</span> fij=0.;
<a name="l01493"></a>01493   <span class="keywordtype">double</span> fji=0.;
<a name="l01494"></a>01494 
<a name="l01495"></a>01495   <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; transporteV = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classDoubleVect.html">DoubleVect</a>,transporte);
<a name="l01496"></a>01496   <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; resuV=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classDoubleVect.html">DoubleVect</a>,resu);
<a name="l01497"></a>01497 
<a name="l01498"></a>01498 <span class="comment">// Faces internes</span>
<a name="l01499"></a>01499   <span class="keywordflow">for</span> (elem=0; elem&lt;nb_elem_tot; elem++)
<a name="l01500"></a>01500     <span class="keywordflow">for</span> (fa7=0; fa7&lt;nfa7; fa7++)
<a name="l01501"></a>01501       {
<a name="l01502"></a>01502         facei_loc=KEL(0,fa7);
<a name="l01503"></a>01503         facej_loc=KEL(1,fa7);
<a name="l01504"></a>01504 
<a name="l01505"></a>01505         facei=elem_faces(elem,facei_loc);
<a name="l01506"></a>01506         facej=elem_faces(elem,facej_loc);
<a name="l01507"></a>01507 
<a name="l01508"></a>01508         <span class="keywordflow">for</span> (dim=0; dim&lt;nb_comp; dim++)
<a name="l01509"></a>01509           {
<a name="l01510"></a>01510             fij=Fij(elem,facei_loc,facej_loc,dim);
<a name="l01511"></a>01511             fji=Fij(elem,facej_loc,facei_loc,dim);
<a name="l01512"></a>01512 
<a name="l01513"></a>01513             ligne=facei*nb_comp+dim;
<a name="l01514"></a>01514             colonne=facej*nb_comp+dim;
<a name="l01515"></a>01515 
<a name="l01516"></a>01516             resuV[ligne]+=fij;
<a name="l01517"></a>01517             resuV[colonne]+=fji;
<a name="l01518"></a>01518           }
<a name="l01519"></a>01519       }
<a name="l01520"></a>01520 
<a name="l01521"></a>01521   <span class="keywordflow">if</span> (<a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#af27e616d4be292efae0dcd25ef29278c">old_centered_</a>)
<a name="l01522"></a>01522     <span class="keywordflow">for</span> (facei=premiere_face_int; facei&lt;nb_faces; facei++)
<a name="l01523"></a>01523       {
<a name="l01524"></a>01524 <span class="comment">// Premier voisin</span>
<a name="l01525"></a>01525         elem=face_voisins(facei,0);
<a name="l01526"></a>01526         facei_loc=num_fac_loc(facei,0);
<a name="l01527"></a>01527         assert(elem_faces(elem,facei_loc)==facei);
<a name="l01528"></a>01528 
<a name="l01529"></a>01529         fij=Kij(elem,facei_loc,facei_loc);
<a name="l01530"></a>01530 
<a name="l01531"></a>01531 <span class="comment">// Deuxieme voisin</span>
<a name="l01532"></a>01532         elem=face_voisins(facei,1);
<a name="l01533"></a>01533         facei_loc=num_fac_loc(facei,1);
<a name="l01534"></a>01534         assert(elem_faces(elem,facei_loc)==facei);
<a name="l01535"></a>01535 
<a name="l01536"></a>01536         fij+=Kij(elem,facei_loc,facei_loc);
<a name="l01537"></a>01537 
<a name="l01538"></a>01538         <span class="keywordflow">for</span> (dim=0; dim&lt;nb_comp; dim++)
<a name="l01539"></a>01539           {
<a name="l01540"></a>01540             ligne=facei*nb_comp+dim;
<a name="l01541"></a>01541             resuV[ligne]-=fij*transporteV[ligne];
<a name="l01542"></a>01542           }
<a name="l01543"></a>01543       }
<a name="l01544"></a>01544 
<a name="l01545"></a>01545 
<a name="l01546"></a>01546 <span class="comment">// Faces de bord</span>
<a name="l01547"></a>01547   <span class="keyword">const</span> <a class="code" href="classZone__Cl__VEF.html">Zone_Cl_VEF</a>&amp; zone_Cl_VEF = <a class="code" href="classOp__Conv__VEF__base.html#a03f677ee7911706a4f85cd37e0ca4535">la_zcl_vef</a>.<a class="code" href="classRef__Zone__Cl__VEF.html#a0970d7253def65ad4f0c5ce1830fd243">valeur</a>();
<a name="l01548"></a>01548 
<a name="l01549"></a>01549   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_bord = zone_Cl_VEF.<a class="code" href="classZone__Cl__dis__base.html#aa6f1df56cfd6e2eae83cc991c7cc9b41" title="Renvoie le nombre de conditions aux limites.">nb_cond_lim</a>();
<a name="l01550"></a>01550 
<a name="l01551"></a>01551   <span class="keywordtype">int</span> n_bord=-1;
<a name="l01552"></a>01552   <span class="keywordtype">int</span> num1=0;
<a name="l01553"></a>01553   <span class="keywordtype">int</span> num2=0;
<a name="l01554"></a>01554   <span class="keywordtype">int</span> ind_face=-1;
<a name="l01555"></a>01555 
<a name="l01556"></a>01556   <span class="keywordtype">double</span> psc=0.;
<a name="l01557"></a>01557 
<a name="l01558"></a>01558   <span class="keywordflow">for</span> (n_bord=0; n_bord&lt;nb_bord; n_bord++)
<a name="l01559"></a>01559     {
<a name="l01560"></a>01560       <span class="keyword">const</span> <a class="code" href="classCond__lim.html" title="classe Cond_lim Classe generique servant a representer n&#39;importe quelle classe derivee de la classe C...">Cond_lim</a>&amp; la_cl = zone_Cl_VEF.<a class="code" href="classZone__Cl__dis__base.html#af75e0ed7786863e4d333bfb29d67c323" title="Renvoie la i-ieme condition aux limites. (version const)">les_conditions_limites</a>(n_bord);
<a name="l01561"></a>01561       <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp; le_bord = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>,la_cl.<a class="code" href="classCond__lim.html#a5b2d24809cee07727006a891d4ce8d22" title="Appel a l&#39;objet sous-jacent Renvoie la frontiere discretisee associee a la condition aux limites...">frontiere_dis</a>());
<a name="l01562"></a>01562       num1=0;
<a name="l01563"></a>01563       num2=le_bord.<a class="code" href="classFront__VF.html#a341e2fcb5117b96e745fd7078ba86bab" title="Nombre de faces reelles du bord.">nb_faces</a>();
<a name="l01564"></a>01564 
<a name="l01565"></a>01565       <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classNeumann__sortie__libre.html" title="classe Neumann_sortie_libre Cette classe represente une frontiere ouverte sans vitesse imposee Pour l...">Neumann_sortie_libre</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>()))
<a name="l01566"></a>01566         {
<a name="l01567"></a>01567           <span class="keyword">const</span> <a class="code" href="classNeumann__sortie__libre.html" title="classe Neumann_sortie_libre Cette classe represente une frontiere ouverte sans vitesse imposee Pour l...">Neumann_sortie_libre</a>&amp; la_sortie_libre = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classNeumann__sortie__libre.html" title="classe Neumann_sortie_libre Cette classe represente une frontiere ouverte sans vitesse imposee Pour l...">Neumann_sortie_libre</a>, la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>());
<a name="l01568"></a>01568 
<a name="l01569"></a>01569           <span class="keywordflow">for</span> (ind_face=num1; ind_face&lt;num2; ind_face++)
<a name="l01570"></a>01570             {
<a name="l01571"></a>01571               facei=le_bord.<a class="code" href="classFront__VF.html#a3402a19d7e54ed797d2b18e9a47ead1e" title="Renvoie le numero de face de la ieme face du bord.">num_face</a>(ind_face);
<a name="l01572"></a>01572               facei_loc=num_fac_loc(facei,0);
<a name="l01573"></a>01573               elem=face_voisins(facei,0);
<a name="l01574"></a>01574               assert(elem_faces(elem,facei_loc)==facei);
<a name="l01575"></a>01575 
<a name="l01576"></a>01576 
<a name="l01577"></a>01577               psc=Kij(elem,facei_loc,facei_loc);<span class="comment">//ATTENTION : SUPPOSE QU&#39;ON EST a DIVERGENCE NULLE</span>
<a name="l01578"></a>01578 
<a name="l01579"></a>01579               <span class="keywordflow">if</span> (psc&gt;=0.)
<a name="l01580"></a>01580                 {
<a name="l01581"></a>01581 <span class="comment">// On ne fait rien car on en a deja tenu compte dans l&#39;operateur centre</span>
<a name="l01582"></a>01582                 }
<a name="l01583"></a>01583               <span class="keywordflow">else</span>
<a name="l01584"></a>01584                 <span class="keywordflow">for</span> (dim=0; dim&lt;nb_comp; dim++)
<a name="l01585"></a>01585                   {
<a name="l01586"></a>01586 <span class="comment">// On modifie car on a tenu compte dans l&#39;operateur centre de psc*tansporteV[ligne]</span>
<a name="l01587"></a>01587                     ligne=facei*nb_comp+dim;
<a name="l01588"></a>01588                     resuV[ligne]+=psc*(la_sortie_libre.<a class="code" href="classNeumann__sortie__libre.html#a886f1804fa2a9028fc56a0778a72a75d" title="Renvoie la valeur de la i-eme composante du champ impose a l&#39;exterieur de la frontiere.">val_ext</a>(facei,dim)-transporteV[ligne]);
<a name="l01589"></a>01589                   }
<a name="l01590"></a>01590 
<a name="l01591"></a>01591             }<span class="comment">//fin du for sur &quot;face_i&quot;</span>
<a name="l01592"></a>01592 
<a name="l01593"></a>01593         }<span class="comment">//fin du if sur &quot;Neumann&quot;</span>
<a name="l01594"></a>01594 
<a name="l01595"></a>01595     }<span class="comment">//fin du for sur &quot;n_bord&quot;</span>
<a name="l01596"></a>01596 
<a name="l01597"></a>01597 
<a name="l01598"></a>01598 <span class="comment">// Retour du resultat</span>
<a name="l01599"></a>01599   <span class="keywordflow">return</span> resu;
<a name="l01600"></a>01600 }
<a name="l01601"></a>01601 
<a name="l01602"></a>01602 <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp;
<a name="l01603"></a><a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#a7a5c2445abefb22846ad5eec13fde90d">01603</a> <a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#a7a5c2445abefb22846ad5eec13fde90d">Op_Conv_Muscl_New_VEF_Face::ajouter_diffusion</a>(<span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; Kij,<span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; Fij, <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; transporte, <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; resu)<span class="keyword"> const</span>
<a name="l01604"></a>01604 <span class="keyword"></span>{
<a name="l01605"></a>01605   <span class="keyword">const</span> <a class="code" href="classZone__VEF.html" title="class Zone_VEF Classe instanciable qui derive de Zone_VF. Cette classe contient les informations geom...">Zone_VEF</a>&amp; zone_VEF=<a class="code" href="classOp__Conv__VEF__base.html#a6c29a488a6805ba4a9f2f059cdba77ae">la_zone_vef</a>.<a class="code" href="classRef__Zone__VEF.html#aafd9a5ee1a76f290c9c6b5447b0c8d30">valeur</a>();
<a name="l01606"></a>01606 
<a name="l01607"></a>01607   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; elem_faces=zone_VEF.<a class="code" href="classZone__VF.html#a067e462dcd3ab92b0f6d945b19e4eb37" title="renvoie le numero de le ieme face de la maille num_elem la facon dont ces faces sont numerotees est l...">elem_faces</a>();
<a name="l01608"></a>01608   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; KEL=zone_VEF.<a class="code" href="classZone__VEF.html#a46693c060b8096fb2595ca72192eea2a">type_elem</a>().<a class="code" href="classDeriv__Elem__VEF__base.html#a2886905d5071be902c77248b69ca0b7b">valeur</a>().<a class="code" href="classElem__VEF__base.html#ab129610ef702aa8c9c98dcb4c7551172">KEL</a>();
<a name="l01609"></a>01609 
<a name="l01610"></a>01610   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_elem_tot=zone_VEF.<a class="code" href="classZone__dis__base.html#a4d6aa445f152aa6dc54d66ea7a071147">nb_elem_tot</a>();
<a name="l01611"></a>01611   <span class="keyword">const</span> <span class="keywordtype">int</span> nfa7 = zone_VEF.<a class="code" href="classZone__VEF.html#a46693c060b8096fb2595ca72192eea2a">type_elem</a>().<a class="code" href="classElem__VEF.html#a4a34777c0083b38dd34c8a400d5b4e90">nb_facette</a>();
<a name="l01612"></a>01612 
<a name="l01613"></a>01613   <span class="keywordtype">int</span> nb_comp=1;
<a name="l01614"></a>01614   <span class="keywordflow">if</span> (transporte.<a class="code" href="classDoubleTab.html#ae6dda48778e7107e1beb723beef1f75b" title="Returns the number of dimensions of the array (&gt;= 1)">nb_dim</a>()!=1) nb_comp=transporte.<a class="code" href="classDoubleTab.html#ac3805e2637a3b880ba2d3e650c69dac4" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(1);
<a name="l01615"></a>01615 
<a name="l01616"></a>01616   <span class="keywordtype">int</span> elem=0;
<a name="l01617"></a>01617   <span class="keywordtype">int</span> facei=0,facei_loc=0;
<a name="l01618"></a>01618   <span class="keywordtype">int</span> facej=0,facej_loc=0;
<a name="l01619"></a>01619   <span class="keywordtype">int</span> ligne=0,colonne=0;
<a name="l01620"></a>01620   <span class="keywordtype">int</span> dim=0;
<a name="l01621"></a>01621   <span class="keywordtype">int</span> fa7=0;
<a name="l01622"></a>01622 
<a name="l01623"></a>01623 <span class="comment">// double coeffij=0.,coeffji=0.;</span>
<a name="l01624"></a>01624   <span class="keywordtype">double</span> fij=0.,fji=0.;
<a name="l01625"></a>01625   <span class="keywordtype">double</span> psc=0.;
<a name="l01626"></a>01626 
<a name="l01627"></a>01627   <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; resuV=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classDoubleVect.html">DoubleVect</a>,resu);
<a name="l01628"></a>01628 
<a name="l01629"></a>01629 <span class="comment">// Pour les faces internes</span>
<a name="l01630"></a>01630   <span class="keywordflow">for</span> (elem=0; elem&lt;nb_elem_tot; elem++)
<a name="l01631"></a>01631     <span class="keywordflow">for</span> (fa7=0; fa7&lt;nfa7; fa7++)
<a name="l01632"></a>01632       {
<a name="l01633"></a>01633         facei_loc=KEL(0,fa7);
<a name="l01634"></a>01634         facej_loc=KEL(1,fa7);
<a name="l01635"></a>01635 
<a name="l01636"></a>01636         facei=elem_faces(elem,facei_loc);
<a name="l01637"></a>01637         facej=elem_faces(elem,facej_loc);
<a name="l01638"></a>01638 
<a name="l01639"></a>01639         psc=Kij(elem,facei_loc,facej_loc);
<a name="l01640"></a>01640 
<a name="l01641"></a>01641         <span class="keywordflow">for</span> (dim=0; dim&lt;nb_comp; dim++)
<a name="l01642"></a>01642           {
<a name="l01643"></a>01643             fij=<a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#aba93a9d2fdc68f373410c6439c95074c">alpha_</a>*Fij(elem,facei_loc,facej_loc,dim);
<a name="l01644"></a>01644             fji=<a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#aba93a9d2fdc68f373410c6439c95074c">alpha_</a>*Fij(elem,facej_loc,facei_loc,dim);
<a name="l01645"></a>01645 
<a name="l01646"></a>01646             ligne=facei*nb_comp+dim;
<a name="l01647"></a>01647             colonne=facej*nb_comp+dim;
<a name="l01648"></a>01648 
<a name="l01649"></a>01649             <span class="keywordflow">if</span> (psc&gt;=0.)
<a name="l01650"></a>01650               {
<a name="l01651"></a>01651                 resuV[ligne]-=fij;
<a name="l01652"></a>01652                 resuV[colonne]+=fij;
<a name="l01653"></a>01653               }
<a name="l01654"></a>01654             <span class="keywordflow">else</span>
<a name="l01655"></a>01655               {
<a name="l01656"></a>01656                 resuV[ligne]+=fji;
<a name="l01657"></a>01657                 resuV[colonne]-=fji;
<a name="l01658"></a>01658               }
<a name="l01659"></a>01659           }
<a name="l01660"></a>01660       }
<a name="l01661"></a>01661 
<a name="l01662"></a>01662 <span class="comment">// Pour les faces de bord :</span>
<a name="l01663"></a>01663 <span class="comment">// ON N&#39;A RIEN a FAIRE</span>
<a name="l01664"></a>01664 
<a name="l01665"></a>01665 <span class="comment">// Retour du resultat</span>
<a name="l01666"></a>01666   <span class="keywordflow">return</span> resu;
<a name="l01667"></a>01667 }
<a name="l01668"></a>01668 
<a name="l01669"></a>01669 <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp;
<a name="l01670"></a><a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#a0a4d5294bb89871b05c740fa867841b9">01670</a> <a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#a0a4d5294bb89871b05c740fa867841b9">Op_Conv_Muscl_New_VEF_Face::ajouter_antidiffusion</a>(<span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; Kij, <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; Fij,<span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; transporte, <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; resu)<span class="keyword"> const</span>
<a name="l01671"></a>01671 <span class="keyword"></span>{
<a name="l01672"></a>01672   <span class="keywordflow">switch</span>(<a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#a628f5f0e8616ec26b0541bdd128238c8">version_</a>)
<a name="l01673"></a>01673     {
<a name="l01674"></a>01674     <span class="keywordflow">case</span> 1 :
<a name="l01675"></a>01675 
<a name="l01676"></a>01676       <span class="keywordflow">return</span> <a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#a97cd8ef9b333f725b08b769aa6bd846e">ajouter_antidiffusion_v1</a>(Kij,Fij,transporte,resu);
<a name="l01677"></a>01677       <span class="keywordflow">break</span>;
<a name="l01678"></a>01678 
<a name="l01679"></a>01679     <span class="keywordflow">case</span> 2 :
<a name="l01680"></a>01680 
<a name="l01681"></a>01681       <span class="keywordflow">return</span> <a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#a78488062b4b9cb57b6b63b1fdbd9895c">ajouter_antidiffusion_v2</a>(Kij,Fij,transporte,resu);
<a name="l01682"></a>01682       <span class="keywordflow">break</span>;
<a name="l01683"></a>01683 
<a name="l01684"></a>01684     <span class="keywordflow">default</span> :
<a name="l01685"></a>01685 
<a name="l01686"></a>01686       <span class="keywordflow">if</span> (<a class="code" href="classProcess.html#acd052b99706c577f8a5b6656217cf4c2" title="renvoie 1 si on est sur le processeur maitre du groupe courant (c&#39;est a dire me() == 0)...">Process::je_suis_maitre</a>())
<a name="l01687"></a>01687         {
<a name="l01688"></a>01688           <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a>&lt;&lt;<span class="stringliteral">&quot;Error in Op_Conv_Muscl_New_VEF_Face::ajouter_antidiffusion()&quot;</span>&lt;&lt;<a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
<a name="l01689"></a>01689           <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a>&lt;&lt;<span class="stringliteral">&quot;Version number &quot;</span>&lt;&lt;<a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#a628f5f0e8616ec26b0541bdd128238c8">version_</a>&lt;&lt;<span class="stringliteral">&quot; of antidiffusive operator does not exist&quot;</span>&lt;&lt;finl;
<a name="l01690"></a>01690         }
<a name="l01691"></a>01691       <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">Process::exit</a>();
<a name="l01692"></a>01692       <span class="keywordflow">break</span>;
<a name="l01693"></a>01693     }
<a name="l01694"></a>01694 
<a name="l01695"></a>01695   <span class="keywordflow">return</span> resu;
<a name="l01696"></a>01696 }
<a name="l01697"></a>01697 
<a name="l01698"></a>01698 <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp;
<a name="l01699"></a><a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#a78488062b4b9cb57b6b63b1fdbd9895c">01699</a> <a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#a78488062b4b9cb57b6b63b1fdbd9895c">Op_Conv_Muscl_New_VEF_Face::ajouter_antidiffusion_v2</a>(<span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; Kij, <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; Fij,<span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; transporte, <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; resu)<span class="keyword"> const</span>
<a name="l01700"></a>01700 <span class="keyword"></span>{
<a name="l01701"></a>01701   <span class="keyword">const</span> <a class="code" href="classZone__VEF.html" title="class Zone_VEF Classe instanciable qui derive de Zone_VF. Cette classe contient les informations geom...">Zone_VEF</a>&amp; zone_VEF=<a class="code" href="classOp__Conv__VEF__base.html#a6c29a488a6805ba4a9f2f059cdba77ae">la_zone_vef</a>.<a class="code" href="classRef__Zone__VEF.html#aafd9a5ee1a76f290c9c6b5447b0c8d30">valeur</a>();
<a name="l01702"></a>01702 
<a name="l01703"></a>01703   <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; transporteV=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classDoubleVect.html">DoubleVect</a>,transporte);
<a name="l01704"></a>01704 
<a name="l01705"></a>01705   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; elem_faces=zone_VEF.<a class="code" href="classZone__VF.html#a067e462dcd3ab92b0f6d945b19e4eb37" title="renvoie le numero de le ieme face de la maille num_elem la facon dont ces faces sont numerotees est l...">elem_faces</a>();
<a name="l01706"></a>01706   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; KEL=zone_VEF.<a class="code" href="classZone__VEF.html#a46693c060b8096fb2595ca72192eea2a">type_elem</a>().<a class="code" href="classDeriv__Elem__VEF__base.html#a2886905d5071be902c77248b69ca0b7b">valeur</a>().<a class="code" href="classElem__VEF__base.html#ab129610ef702aa8c9c98dcb4c7551172">KEL</a>();
<a name="l01707"></a>01707   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; face_voisins=zone_VEF.<a class="code" href="classZone__VF.html#a49d4322f5585a8fa95748ca785b70702" title="renvoie l&#39;element voisin de numface dans la direction i. i=0 : dans le sens oppose de l&#39;axe orthogona...">face_voisins</a>();
<a name="l01708"></a>01708   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; num_fac_loc = zone_VEF.<a class="code" href="classZone__VF.html#a95113b10f16f37600ba81d3fb41102b2">get_num_fac_loc</a>();
<a name="l01709"></a>01709 
<a name="l01710"></a>01710   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_elem_tot=zone_VEF.<a class="code" href="classZone__dis__base.html#a4d6aa445f152aa6dc54d66ea7a071147">nb_elem_tot</a>();
<a name="l01711"></a>01711   <span class="keyword">const</span> <span class="keywordtype">int</span> nfa7 = zone_VEF.<a class="code" href="classZone__VEF.html#a46693c060b8096fb2595ca72192eea2a">type_elem</a>().<a class="code" href="classElem__VEF.html#a4a34777c0083b38dd34c8a400d5b4e90">nb_facette</a>();
<a name="l01712"></a>01712 
<a name="l01713"></a>01713   <span class="keywordtype">int</span> nb_comp=1;
<a name="l01714"></a>01714   <span class="keywordflow">if</span> (transporte.<a class="code" href="classDoubleTab.html#ae6dda48778e7107e1beb723beef1f75b" title="Returns the number of dimensions of the array (&gt;= 1)">nb_dim</a>()!=1) nb_comp=transporte.<a class="code" href="classDoubleTab.html#ac3805e2637a3b880ba2d3e650c69dac4" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(1);
<a name="l01715"></a>01715 
<a name="l01716"></a>01716   <span class="keywordtype">int</span> elem=0;
<a name="l01717"></a>01717   <span class="keywordtype">int</span> facei=0,facei_loc=0;
<a name="l01718"></a>01718   <span class="keywordtype">int</span> facej=0,facej_loc=0;
<a name="l01719"></a>01719   <span class="keywordtype">int</span> ligne=0,colonne=0;
<a name="l01720"></a>01720   <span class="keywordtype">int</span> dim=0;
<a name="l01721"></a>01721   <span class="keywordtype">int</span> fa7=0;
<a name="l01722"></a>01722 
<a name="l01723"></a>01723 <span class="comment">// Pour le limiteur</span>
<a name="l01724"></a>01724   <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a> P_plus(nb_comp),P_moins(nb_comp);
<a name="l01725"></a>01725   <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a> Q_plus(nb_comp),Q_moins(nb_comp);
<a name="l01726"></a>01726   P_plus=0., P_moins=0.;
<a name="l01727"></a>01727   Q_plus=0., Q_moins=0.;
<a name="l01728"></a>01728 
<a name="l01729"></a>01729 <span class="comment">// double coeffij=0.,coeffji=0.;</span>
<a name="l01730"></a>01730   <span class="keywordtype">double</span> fij=0.,fji=0.;
<a name="l01731"></a>01731   <span class="keywordtype">double</span> kij=0.;
<a name="l01732"></a>01732   <span class="keywordtype">double</span> R=0.;
<a name="l01733"></a>01733   <span class="keywordtype">double</span> tmp=0.;
<a name="l01734"></a>01734   <span class="keywordtype">double</span> fij_low=0.,fji_low=0.;
<a name="l01735"></a>01735 
<a name="l01736"></a>01736   <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; resuV=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classDoubleVect.html">DoubleVect</a>,resu);
<a name="l01737"></a>01737 
<a name="l01738"></a>01738 <span class="comment">// Pour les faces internes</span>
<a name="l01739"></a>01739   <span class="keywordflow">for</span> (elem=0; elem&lt;nb_elem_tot; elem++)
<a name="l01740"></a>01740     <span class="keywordflow">for</span> (fa7=0; fa7&lt;nfa7; fa7++)
<a name="l01741"></a>01741       {
<a name="l01742"></a>01742         facei_loc=KEL(0,fa7);
<a name="l01743"></a>01743         facej_loc=KEL(1,fa7);
<a name="l01744"></a>01744 
<a name="l01745"></a>01745         facei=elem_faces(elem,facei_loc);
<a name="l01746"></a>01746         facej=elem_faces(elem,facej_loc);
<a name="l01747"></a>01747 
<a name="l01748"></a>01748         kij=Kij(elem,facei_loc,facej_loc);
<a name="l01749"></a>01749 
<a name="l01750"></a>01750         P_plus=0., P_moins=0.;
<a name="l01751"></a>01751         Q_plus=0., Q_moins=0.;
<a name="l01752"></a>01752         <span class="keywordflow">if</span> (kij&gt;=0.) <span class="comment">//facei amont</span>
<a name="l01753"></a>01753           <a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#a2032486fe36dd90a3ae2bffcc16569c0">calculer_senseur_v2</a>(Kij,Fij,transporteV,nb_comp,facei,elem_faces,face_voisins,num_fac_loc,P_plus,P_moins,Q_plus,Q_moins);<span class="comment">//La face i est amont</span>
<a name="l01754"></a>01754         <span class="keywordflow">else</span> <span class="comment">//facej amont</span>
<a name="l01755"></a>01755           <a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#a2032486fe36dd90a3ae2bffcc16569c0">calculer_senseur_v2</a>(Kij,Fij,transporteV,nb_comp,facej,elem_faces,face_voisins,num_fac_loc,P_plus,P_moins,Q_plus,Q_moins);<span class="comment">//La face j est amont</span>
<a name="l01756"></a>01756 
<a name="l01757"></a>01757         <span class="keywordflow">for</span> (dim=0; dim&lt;nb_comp; dim++)
<a name="l01758"></a>01758           {
<a name="l01759"></a>01759             fij=<a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#aba93a9d2fdc68f373410c6439c95074c">alpha_</a>*Fij(elem,facei_loc,facej_loc,dim);
<a name="l01760"></a>01760             fji=<a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#aba93a9d2fdc68f373410c6439c95074c">alpha_</a>*Fij(elem,facej_loc,facei_loc,dim);
<a name="l01761"></a>01761 
<a name="l01762"></a>01762             ligne=facei*nb_comp+dim;
<a name="l01763"></a>01763             colonne=facej*nb_comp+dim;
<a name="l01764"></a>01764 
<a name="l01765"></a>01765             fij_low=transporteV[colonne]-transporteV[ligne];
<a name="l01766"></a>01766             fij_low*=kij;
<a name="l01767"></a>01767             fji_low=fij_low;
<a name="l01768"></a>01768 
<a name="l01769"></a>01769             <span class="keywordflow">if</span> (kij&gt;=0.) <span class="comment">//facei amont</span>
<a name="l01770"></a>01770               {
<a name="l01771"></a>01771 <span class="comment">// if (fij&gt;=0.) R=(P_plus(dim)==0.)?0.:Q_plus(dim)/P_plus(dim);</span>
<a name="l01772"></a>01772 <span class="comment">// else R=(P_moins(dim)==0.)?0.:Q_moins(dim)/P_moins(dim);</span>
<a name="l01773"></a>01773 
<a name="l01774"></a>01774 <span class="comment">// if (fij&gt;=0.) R=(P_plus(dim)==0.)?0.:Q_plus(dim)/(P_plus(dim)+DMINFLOAT);</span>
<a name="l01775"></a>01775 <span class="comment">// else R=(P_moins(dim)==0.)?0.:Q_moins(dim)/(P_moins(dim)+DMINFLOAT);</span>
<a name="l01776"></a>01776 
<a name="l01777"></a>01777                 <span class="keywordflow">if</span> (fij&gt;=0.) R=(<a class="code" href="Double_8h.html#aaecd4ca8a2fe69cc6568af2938b94d2e">dabs</a>(P_plus(dim))&lt;<a class="code" href="Double_8h.html#a0a3fffa6d17ad8f7de4bb337c6266561">DMINFLOAT</a>)?0.:Q_plus(dim)/P_plus(dim);
<a name="l01778"></a>01778                 <span class="keywordflow">else</span> R=(<a class="code" href="Double_8h.html#aaecd4ca8a2fe69cc6568af2938b94d2e">dabs</a>(P_moins(dim))&lt;<a class="code" href="Double_8h.html#a0a3fffa6d17ad8f7de4bb337c6266561">DMINFLOAT</a>)?0.:Q_moins(dim)/P_moins(dim);
<a name="l01779"></a>01779 
<a name="l01780"></a>01780 
<a name="l01781"></a>01781                 R=(*limiteur_)(R);
<a name="l01782"></a>01782                 R*=fij;
<a name="l01783"></a>01783 
<a name="l01784"></a>01784                 <span class="keywordflow">if</span> (!<a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#a1e7b0db2325d8e59bbaa9460ed6f3826">is_dirichlet_faces_</a>(facej))
<a name="l01785"></a>01785                   tmp=<a class="code" href="Op__Conv__Muscl__New__VEF__Face_8cpp.html#abd18971dfe4f2b2333aaf0203d859ca6">optimum</a>(R,fji_low);
<a name="l01786"></a>01786                 <span class="keywordflow">else</span>
<a name="l01787"></a>01787                   tmp=R;
<a name="l01788"></a>01788 
<a name="l01789"></a>01789                 resuV[ligne]+=tmp;
<a name="l01790"></a>01790                 resuV[colonne]-=tmp;
<a name="l01791"></a>01791               }
<a name="l01792"></a>01792             <span class="keywordflow">else</span> <span class="comment">//facej amont</span>
<a name="l01793"></a>01793               {
<a name="l01794"></a>01794 <span class="comment">// if (fji&lt;=0.) R=(P_moins(dim)==0.)?0.:Q_moins(dim)/P_moins(dim);</span>
<a name="l01795"></a>01795 <span class="comment">// else R=(P_plus(dim)==0.)?0.:Q_plus(dim)/P_plus(dim);</span>
<a name="l01796"></a>01796 
<a name="l01797"></a>01797 <span class="comment">// if (fji&lt;=0.) R=(P_moins(dim)==0.)?0.:Q_moins(dim)/(P_moins(dim)+DMINFLOAT);</span>
<a name="l01798"></a>01798 <span class="comment">// else R=(P_plus(dim)==0.)?0.:Q_plus(dim)/(P_plus(dim)+DMINFLOAT);</span>
<a name="l01799"></a>01799 
<a name="l01800"></a>01800                 <span class="keywordflow">if</span> (fji&lt;=0.) R=(<a class="code" href="Double_8h.html#aaecd4ca8a2fe69cc6568af2938b94d2e">dabs</a>(P_moins(dim))&lt;<a class="code" href="Double_8h.html#a0a3fffa6d17ad8f7de4bb337c6266561">DMINFLOAT</a>)?0.:Q_moins(dim)/P_moins(dim);
<a name="l01801"></a>01801                 <span class="keywordflow">else</span> R=(<a class="code" href="Double_8h.html#aaecd4ca8a2fe69cc6568af2938b94d2e">dabs</a>(P_plus(dim))&lt;<a class="code" href="Double_8h.html#a0a3fffa6d17ad8f7de4bb337c6266561">DMINFLOAT</a>)?0.:Q_plus(dim)/P_plus(dim);
<a name="l01802"></a>01802 
<a name="l01803"></a>01803 
<a name="l01804"></a>01804                 R=(*limiteur_)(R);
<a name="l01805"></a>01805                 R*=fji;
<a name="l01806"></a>01806 
<a name="l01807"></a>01807                 <span class="keywordflow">if</span> (!<a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#a1e7b0db2325d8e59bbaa9460ed6f3826">is_dirichlet_faces_</a>(facei))
<a name="l01808"></a>01808                   tmp=<a class="code" href="Op__Conv__Muscl__New__VEF__Face_8cpp.html#abd18971dfe4f2b2333aaf0203d859ca6">optimum</a>(R,fij_low);
<a name="l01809"></a>01809                 <span class="keywordflow">else</span>
<a name="l01810"></a>01810                   tmp=R;
<a name="l01811"></a>01811 
<a name="l01812"></a>01812                 resuV[ligne]-=tmp;
<a name="l01813"></a>01813                 resuV[colonne]+=tmp;
<a name="l01814"></a>01814               }
<a name="l01815"></a>01815           }
<a name="l01816"></a>01816       }
<a name="l01817"></a>01817 
<a name="l01818"></a>01818 
<a name="l01819"></a>01819 <span class="comment">// Pour les faces de bord</span>
<a name="l01820"></a>01820 <span class="comment">// IL N&#39;Y A RIEN a FAIRE TOUT EST FAIT DANS LA FONCTION AJOUTER_DIFFUSION</span>
<a name="l01821"></a>01821 <span class="comment">// QUI EST PARFAITEMENT COMPLeTER PAR LA FONCTION AJOUTER_ANTIDIFFUSION</span>
<a name="l01822"></a>01822 
<a name="l01823"></a>01823 <span class="comment">// Retour du resultat</span>
<a name="l01824"></a>01824   <span class="keywordflow">return</span> resu;
<a name="l01825"></a>01825 }
<a name="l01826"></a>01826 
<a name="l01827"></a>01827 <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp;
<a name="l01828"></a><a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#a97cd8ef9b333f725b08b769aa6bd846e">01828</a> <a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#a97cd8ef9b333f725b08b769aa6bd846e">Op_Conv_Muscl_New_VEF_Face::ajouter_antidiffusion_v1</a>(<span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; Kij, <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; Fij,<span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; transporte, <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; resu)<span class="keyword"> const</span>
<a name="l01829"></a>01829 <span class="keyword"></span>{
<a name="l01830"></a>01830   <span class="keyword">const</span> <a class="code" href="classZone__VEF.html" title="class Zone_VEF Classe instanciable qui derive de Zone_VF. Cette classe contient les informations geom...">Zone_VEF</a>&amp; zone_VEF=<a class="code" href="classOp__Conv__VEF__base.html#a6c29a488a6805ba4a9f2f059cdba77ae">la_zone_vef</a>.<a class="code" href="classRef__Zone__VEF.html#aafd9a5ee1a76f290c9c6b5447b0c8d30">valeur</a>();
<a name="l01831"></a>01831 
<a name="l01832"></a>01832   <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; transporteV=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classDoubleVect.html">DoubleVect</a>,transporte);
<a name="l01833"></a>01833 
<a name="l01834"></a>01834   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; elem_faces=zone_VEF.<a class="code" href="classZone__VF.html#a067e462dcd3ab92b0f6d945b19e4eb37" title="renvoie le numero de le ieme face de la maille num_elem la facon dont ces faces sont numerotees est l...">elem_faces</a>();
<a name="l01835"></a>01835   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; KEL=zone_VEF.<a class="code" href="classZone__VEF.html#a46693c060b8096fb2595ca72192eea2a">type_elem</a>().<a class="code" href="classDeriv__Elem__VEF__base.html#a2886905d5071be902c77248b69ca0b7b">valeur</a>().<a class="code" href="classElem__VEF__base.html#ab129610ef702aa8c9c98dcb4c7551172">KEL</a>();
<a name="l01836"></a>01836   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; face_voisins=zone_VEF.<a class="code" href="classZone__VF.html#a49d4322f5585a8fa95748ca785b70702" title="renvoie l&#39;element voisin de numface dans la direction i. i=0 : dans le sens oppose de l&#39;axe orthogona...">face_voisins</a>();
<a name="l01837"></a>01837   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; num_fac_loc = zone_VEF.<a class="code" href="classZone__VF.html#a95113b10f16f37600ba81d3fb41102b2">get_num_fac_loc</a>();
<a name="l01838"></a>01838 
<a name="l01839"></a>01839   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_elem_tot=zone_VEF.<a class="code" href="classZone__dis__base.html#a4d6aa445f152aa6dc54d66ea7a071147">nb_elem_tot</a>();
<a name="l01840"></a>01840   <span class="keyword">const</span> <span class="keywordtype">int</span> nfa7 = zone_VEF.<a class="code" href="classZone__VEF.html#a46693c060b8096fb2595ca72192eea2a">type_elem</a>().<a class="code" href="classElem__VEF.html#a4a34777c0083b38dd34c8a400d5b4e90">nb_facette</a>();
<a name="l01841"></a>01841 
<a name="l01842"></a>01842   <span class="keywordtype">int</span> nb_comp=1;
<a name="l01843"></a>01843   <span class="keywordflow">if</span> (transporte.<a class="code" href="classDoubleTab.html#ae6dda48778e7107e1beb723beef1f75b" title="Returns the number of dimensions of the array (&gt;= 1)">nb_dim</a>()!=1) nb_comp=transporte.<a class="code" href="classDoubleTab.html#ac3805e2637a3b880ba2d3e650c69dac4" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(1);
<a name="l01844"></a>01844 
<a name="l01845"></a>01845   <span class="keywordtype">int</span> elem=0;
<a name="l01846"></a>01846   <span class="keywordtype">int</span> facei=0,facei_loc=0;
<a name="l01847"></a>01847   <span class="keywordtype">int</span> facej=0,facej_loc=0;
<a name="l01848"></a>01848   <span class="keywordtype">int</span> ligne=0,colonne=0;
<a name="l01849"></a>01849   <span class="keywordtype">int</span> dim=0;
<a name="l01850"></a>01850   <span class="keywordtype">int</span> fa7=0;
<a name="l01851"></a>01851 
<a name="l01852"></a>01852 <span class="comment">// Pour le limiteur</span>
<a name="l01853"></a>01853   <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a> Pi_plus(nb_comp),Pi_moins(nb_comp);
<a name="l01854"></a>01854   <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a> Qi_plus(nb_comp),Qi_moins(nb_comp);
<a name="l01855"></a>01855   Pi_plus=0., Pi_moins=0.;
<a name="l01856"></a>01856   Qi_plus=0., Qi_moins=0.;
<a name="l01857"></a>01857 
<a name="l01858"></a>01858 <span class="comment">// Pour le limiteur</span>
<a name="l01859"></a>01859   <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a> Pj_plus(nb_comp),Pj_moins(nb_comp);
<a name="l01860"></a>01860   <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a> Qj_plus(nb_comp),Qj_moins(nb_comp);
<a name="l01861"></a>01861   Pj_plus=0., Pj_moins=0.;
<a name="l01862"></a>01862   Qj_plus=0., Qj_moins=0.;
<a name="l01863"></a>01863 
<a name="l01864"></a>01864 <span class="comment">// double coeffij=0.,coeffji=0.;</span>
<a name="l01865"></a>01865   <span class="keywordtype">double</span> fij=0.,fji=0.;
<a name="l01866"></a>01866   <span class="keywordtype">double</span> kij=0.;
<a name="l01867"></a>01867   <span class="keywordtype">double</span> R=0.;
<a name="l01868"></a>01868   <span class="keywordtype">double</span> Ri=0.;
<a name="l01869"></a>01869   <span class="keywordtype">double</span> Rj=0.;
<a name="l01870"></a>01870   <span class="keywordtype">double</span> tmp=0.;
<a name="l01871"></a>01871 
<a name="l01872"></a>01872   <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; resuV=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classDoubleVect.html">DoubleVect</a>,resu);
<a name="l01873"></a>01873 
<a name="l01874"></a>01874 <span class="comment">// Pour les faces internes</span>
<a name="l01875"></a>01875   <span class="keywordflow">for</span> (elem=0; elem&lt;nb_elem_tot; elem++)
<a name="l01876"></a>01876     <span class="keywordflow">for</span> (fa7=0; fa7&lt;nfa7; fa7++)
<a name="l01877"></a>01877       {
<a name="l01878"></a>01878         facei_loc=KEL(0,fa7);
<a name="l01879"></a>01879         facej_loc=KEL(1,fa7);
<a name="l01880"></a>01880 
<a name="l01881"></a>01881         facei=elem_faces(elem,facei_loc);
<a name="l01882"></a>01882         facej=elem_faces(elem,facej_loc);
<a name="l01883"></a>01883 
<a name="l01884"></a>01884         kij=Kij(elem,facei_loc,facej_loc);
<a name="l01885"></a>01885 
<a name="l01886"></a>01886         Pi_plus=0., Pi_moins=0.;
<a name="l01887"></a>01887         Qi_plus=0., Qi_moins=0.;
<a name="l01888"></a>01888         <a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#a62e58f1cd47b3865342a3b37fb1a06df">calculer_senseur_v1</a>(Kij,Fij,transporteV,nb_comp,facei,elem_faces,face_voisins,num_fac_loc,Pi_plus,Pi_moins,Qi_plus,Qi_moins);
<a name="l01889"></a>01889 
<a name="l01890"></a>01890         Pj_plus=0., Pj_moins=0.;
<a name="l01891"></a>01891         Qj_plus=0., Qj_moins=0.;
<a name="l01892"></a>01892         <a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#a62e58f1cd47b3865342a3b37fb1a06df">calculer_senseur_v1</a>(Kij,Fij,transporteV,nb_comp,facej,elem_faces,face_voisins,num_fac_loc,Pj_plus,Pj_moins,Qj_plus,Qj_moins);
<a name="l01893"></a>01893 
<a name="l01894"></a>01894         <span class="keywordflow">for</span> (dim=0; dim&lt;nb_comp; dim++)
<a name="l01895"></a>01895           {
<a name="l01896"></a>01896             fij=<a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#aba93a9d2fdc68f373410c6439c95074c">alpha_</a>*Fij(elem,facei_loc,facej_loc,dim);
<a name="l01897"></a>01897             fji=<a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#aba93a9d2fdc68f373410c6439c95074c">alpha_</a>*Fij(elem,facej_loc,facei_loc,dim);
<a name="l01898"></a>01898 
<a name="l01899"></a>01899             ligne=facei*nb_comp+dim;
<a name="l01900"></a>01900             colonne=facej*nb_comp+dim;
<a name="l01901"></a>01901 
<a name="l01902"></a>01902             <span class="keywordflow">if</span> (kij&gt;=0.)
<a name="l01903"></a>01903               {
<a name="l01904"></a>01904 <span class="comment">// Face amont : facei</span>
<a name="l01905"></a>01905                 <span class="keywordflow">if</span> (fij&gt;=0.)
<a name="l01906"></a>01906                   {
<a name="l01907"></a>01907 <span class="comment">// Ri=(Pi_plus(dim)==0.)?0.:Qi_plus(dim)/Pi_plus(dim);</span>
<a name="l01908"></a>01908 <span class="comment">// Rj=(Pj_moins(dim)==0.)?0.:Qj_moins(dim)/Pj_moins(dim);//car fji=-fij</span>
<a name="l01909"></a>01909 
<a name="l01910"></a>01910 <span class="comment">// Ri=(Pi_plus(dim)==0.)?0.:Qi_plus(dim)/(Pi_plus(dim)+DMINFLOAT);</span>
<a name="l01911"></a>01911 <span class="comment">// Rj=(Pj_moins(dim)==0.)?0.:Qj_moins(dim)/(Pj_moins(dim)+DMINFLOAT);//car fji=-fij</span>
<a name="l01912"></a>01912 
<a name="l01913"></a>01913                     Ri=(<a class="code" href="Double_8h.html#aaecd4ca8a2fe69cc6568af2938b94d2e">dabs</a>(Pi_plus(dim))&lt;<a class="code" href="Double_8h.html#a0a3fffa6d17ad8f7de4bb337c6266561">DMINFLOAT</a>)?0.:Qi_plus(dim)/Pi_plus(dim);
<a name="l01914"></a>01914                     Rj=(<a class="code" href="Double_8h.html#aaecd4ca8a2fe69cc6568af2938b94d2e">dabs</a>(Pj_moins(dim))&lt;<a class="code" href="Double_8h.html#a0a3fffa6d17ad8f7de4bb337c6266561">DMINFLOAT</a>)?0.:Qj_moins(dim)/Pj_moins(dim);<span class="comment">//car fji=-fij</span>
<a name="l01915"></a>01915                   }
<a name="l01916"></a>01916                 <span class="keywordflow">else</span>
<a name="l01917"></a>01917                   {
<a name="l01918"></a>01918 <span class="comment">// Ri=(Pi_moins(dim)==0.)?0.:Qi_moins(dim)/Pi_moins(dim);</span>
<a name="l01919"></a>01919 <span class="comment">// Rj=(Pj_plus(dim)==0.)?0.:Qj_plus(dim)/Pj_plus(dim);//car fji=-fij</span>
<a name="l01920"></a>01920 
<a name="l01921"></a>01921 <span class="comment">// Ri=(Pi_moins(dim)==0.)?0.:Qi_moins(dim)/(Pi_moins(dim)+DMINFLOAT);</span>
<a name="l01922"></a>01922 <span class="comment">// Rj=(Pj_plus(dim)==0.)?0.:Qj_plus(dim)/(Pj_plus(dim)+DMINFLOAT);//car fji=-fij</span>
<a name="l01923"></a>01923 
<a name="l01924"></a>01924                     Ri=(<a class="code" href="Double_8h.html#aaecd4ca8a2fe69cc6568af2938b94d2e">dabs</a>(Pi_moins(dim))&lt;<a class="code" href="Double_8h.html#a0a3fffa6d17ad8f7de4bb337c6266561">DMINFLOAT</a>)?0.:Qi_moins(dim)/Pi_moins(dim);
<a name="l01925"></a>01925                     Rj=(<a class="code" href="Double_8h.html#aaecd4ca8a2fe69cc6568af2938b94d2e">dabs</a>(Pj_plus(dim))&lt;<a class="code" href="Double_8h.html#a0a3fffa6d17ad8f7de4bb337c6266561">DMINFLOAT</a>)?0.:Qj_plus(dim)/Pj_plus(dim);<span class="comment">//car fji=-fij</span>
<a name="l01926"></a>01926                   }
<a name="l01927"></a>01927 
<a name="l01928"></a>01928                 <span class="keywordflow">if</span> (<a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#a1e7b0db2325d8e59bbaa9460ed6f3826">is_dirichlet_faces_</a>(facej)) Rj=<a class="code" href="Double_8h.html#ae0ee0cebfad5968da0ad6cc7a49e16b6">DMAXFLOAT</a>;<span class="comment">//on n&#39;a pas besoin de prendre le min quand il y a une face de Dirichlet</span>
<a name="l01929"></a>01929                 R=(Ri&lt;=Rj)?Ri:Rj;
<a name="l01930"></a>01930                 R=(*limiteur_)(R);
<a name="l01931"></a>01931 
<a name="l01932"></a>01932                 tmp=R*fij;
<a name="l01933"></a>01933                 resuV[ligne]+=tmp;
<a name="l01934"></a>01934                 resuV[colonne]-=tmp;
<a name="l01935"></a>01935               }
<a name="l01936"></a>01936             <span class="keywordflow">else</span>
<a name="l01937"></a>01937               {
<a name="l01938"></a>01938 <span class="comment">// Face amont : facej</span>
<a name="l01939"></a>01939                 <span class="keywordflow">if</span> (fji&lt;=0.)
<a name="l01940"></a>01940                   {
<a name="l01941"></a>01941 <span class="comment">// Rj=(Pj_moins(dim)==0.)?0.:Qj_moins(dim)/Pj_moins(dim);</span>
<a name="l01942"></a>01942 <span class="comment">// Ri=(Pi_plus(dim)==0.)?0.:Qi_plus(dim)/Pi_plus(dim);</span>
<a name="l01943"></a>01943 
<a name="l01944"></a>01944 <span class="comment">// Rj=(Pj_moins(dim)==0.)?0.:Qj_moins(dim)/(Pj_moins(dim)+DMINFLOAT);</span>
<a name="l01945"></a>01945 <span class="comment">// Ri=(Pi_plus(dim)==0.)?0.:Qi_plus(dim)/(Pi_plus(dim)+DMINFLOAT);</span>
<a name="l01946"></a>01946 
<a name="l01947"></a>01947                     Rj=(<a class="code" href="Double_8h.html#aaecd4ca8a2fe69cc6568af2938b94d2e">dabs</a>(Pj_moins(dim))&lt;<a class="code" href="Double_8h.html#a0a3fffa6d17ad8f7de4bb337c6266561">DMINFLOAT</a>)?0.:Qj_moins(dim)/Pj_moins(dim);
<a name="l01948"></a>01948                     Ri=(<a class="code" href="Double_8h.html#aaecd4ca8a2fe69cc6568af2938b94d2e">dabs</a>(Pi_plus(dim))&lt;<a class="code" href="Double_8h.html#a0a3fffa6d17ad8f7de4bb337c6266561">DMINFLOAT</a>)?0.:Qi_plus(dim)/Pi_plus(dim);
<a name="l01949"></a>01949                   }
<a name="l01950"></a>01950                 <span class="keywordflow">else</span>
<a name="l01951"></a>01951                   {
<a name="l01952"></a>01952 <span class="comment">// Rj=(Pj_plus(dim)==0.)?0.:Qj_plus(dim)/Pj_plus(dim);</span>
<a name="l01953"></a>01953 <span class="comment">// Ri=(Pi_moins(dim)==0.)?0.:Qi_moins(dim)/Pi_moins(dim);</span>
<a name="l01954"></a>01954 
<a name="l01955"></a>01955 <span class="comment">// Rj=(Pj_plus(dim)==0.)?0.:Qj_plus(dim)/(Pj_plus(dim)+DMINFLOAT);</span>
<a name="l01956"></a>01956 <span class="comment">// Ri=(Pi_moins(dim)==0.)?0.:Qi_moins(dim)/(Pi_moins(dim)+DMINFLOAT);</span>
<a name="l01957"></a>01957 
<a name="l01958"></a>01958                     Rj=(<a class="code" href="Double_8h.html#aaecd4ca8a2fe69cc6568af2938b94d2e">dabs</a>(Pj_plus(dim))&lt;<a class="code" href="Double_8h.html#a0a3fffa6d17ad8f7de4bb337c6266561">DMINFLOAT</a>)?0.:Qj_plus(dim)/Pj_plus(dim);
<a name="l01959"></a>01959                     Ri=(<a class="code" href="Double_8h.html#aaecd4ca8a2fe69cc6568af2938b94d2e">dabs</a>(Pi_moins(dim))&lt;<a class="code" href="Double_8h.html#a0a3fffa6d17ad8f7de4bb337c6266561">DMINFLOAT</a>)?0.:Qi_moins(dim)/Pi_moins(dim);
<a name="l01960"></a>01960                   }
<a name="l01961"></a>01961 
<a name="l01962"></a>01962                 <span class="keywordflow">if</span> (<a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#a1e7b0db2325d8e59bbaa9460ed6f3826">is_dirichlet_faces_</a>(facei)) Ri=<a class="code" href="Double_8h.html#ae0ee0cebfad5968da0ad6cc7a49e16b6">DMAXFLOAT</a>;<span class="comment">//on n&#39;a pas besoin de prendre le min quand il y a une face de Dirichlet</span>
<a name="l01963"></a>01963                 R=(Ri&lt;=Rj)?Ri:Rj;
<a name="l01964"></a>01964                 R=(*limiteur_)(R);
<a name="l01965"></a>01965 
<a name="l01966"></a>01966                 tmp=R*fji;
<a name="l01967"></a>01967                 resuV[ligne]-=tmp;
<a name="l01968"></a>01968                 resuV[colonne]+=tmp;
<a name="l01969"></a>01969               }
<a name="l01970"></a>01970           }
<a name="l01971"></a>01971       }
<a name="l01972"></a>01972 
<a name="l01973"></a>01973 <span class="comment">// Pour les faces de bord</span>
<a name="l01974"></a>01974 <span class="comment">// IL N&#39;Y A RIEN a FAIRE TOUT EST FAIT DANS LA FONCTION AJOUTER_DIFFUSION</span>
<a name="l01975"></a>01975 <span class="comment">// QUI EST PARFAITEMENT COMPLeTER PAR LA FONCTION AJOUTER_ANTIDIFFUSION</span>
<a name="l01976"></a>01976 
<a name="l01977"></a>01977 <span class="comment">// Retour du resultat</span>
<a name="l01978"></a>01978 <span class="comment">// resuV+=antidiff;</span>
<a name="l01979"></a>01979   <span class="keywordflow">return</span> resu;
<a name="l01980"></a>01980 }
<a name="l01981"></a>01981 
<a name="l01982"></a>01982 <span class="comment">// ATTENTION : suppose les parametres P_plus, P_moins, Q_plus, Q_moins nuls en entree</span>
<a name="l01983"></a>01983 <span class="keyword">inline</span> <span class="keywordtype">void</span>
<a name="l01984"></a><a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#a2032486fe36dd90a3ae2bffcc16569c0">01984</a> <a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#a2032486fe36dd90a3ae2bffcc16569c0">Op_Conv_Muscl_New_VEF_Face::calculer_senseur_v2</a>(<span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; Kij, <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; Fij, <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; transporteV,
<a name="l01985"></a>01985                                                 <span class="keyword">const</span> <span class="keywordtype">int</span>&amp; nb_comp, <span class="keyword">const</span> <span class="keywordtype">int</span>&amp; face_i,
<a name="l01986"></a>01986                                                 <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; elem_faces, <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; face_voisins, <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; num_fac_loc,
<a name="l01987"></a>01987                                                 <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a>&amp; P_plus, <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a>&amp; P_moins,
<a name="l01988"></a>01988                                                 <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a>&amp; Q_plus, <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a>&amp; Q_moins)<span class="keyword"> const</span>
<a name="l01989"></a>01989 <span class="keyword"></span>{
<a name="l01990"></a>01990   <a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#a62e58f1cd47b3865342a3b37fb1a06df">calculer_senseur_v1</a>(Kij,Fij,transporteV,nb_comp,face_i,elem_faces,face_voisins,num_fac_loc,P_plus,P_moins,Q_plus,Q_moins);
<a name="l01991"></a>01991 
<a name="l01992"></a>01992 <span class="comment">// assert(P_plus.size_array()==nb_comp);</span>
<a name="l01993"></a>01993 <span class="comment">// assert(Q_plus.size_array()==nb_comp);</span>
<a name="l01994"></a>01994 <span class="comment">// assert(P_moins.size_array()==nb_comp);</span>
<a name="l01995"></a>01995 <span class="comment">// assert(Q_moins.size_array()==nb_comp);</span>
<a name="l01996"></a>01996 
<a name="l01997"></a>01997 <span class="comment">// const int nb_faces_elem=elem_faces.dimension(1);</span>
<a name="l01998"></a>01998 <span class="comment">// for (int elem_voisin=0; elem_voisin&lt;2; elem_voisin++)</span>
<a name="l01999"></a>01999 <span class="comment">// {</span>
<a name="l02000"></a>02000 <span class="comment">// int elem = face_voisins(face_i,elem_voisin);</span>
<a name="l02001"></a>02001 <span class="comment">// if (elem!=-1)</span>
<a name="l02002"></a>02002 <span class="comment">// {</span>
<a name="l02003"></a>02003 <span class="comment">// int face_i_loc = num_fac_loc(face_i,elem_voisin);</span>
<a name="l02004"></a>02004 <span class="comment">// assert(face_i_loc&gt;=0);</span>
<a name="l02005"></a>02005 <span class="comment">// assert(face_i_loc&lt;nb_faces_elem);</span>
<a name="l02006"></a>02006 <span class="comment">// //On travaille sur les faces de &quot;elem&quot;</span>
<a name="l02007"></a>02007 <span class="comment">// for (int face_k_loc=0; face_k_loc&lt;nb_faces_elem; face_k_loc++)</span>
<a name="l02008"></a>02008 <span class="comment">// {</span>
<a name="l02009"></a>02009 <span class="comment">// double kik=Kij(elem,face_i_loc,face_k_loc);</span>
<a name="l02010"></a>02010 <span class="comment">// //</span>
<a name="l02011"></a>02011 <span class="comment">// //Calcul des variables intermediaires</span>
<a name="l02012"></a>02012 <span class="comment">// //</span>
<a name="l02013"></a>02013 <span class="comment">// for (int dim=0; dim&lt;nb_comp; dim++)</span>
<a name="l02014"></a>02014 <span class="comment">// {</span>
<a name="l02015"></a>02015 <span class="comment">// double fik=Fij(elem,face_i_loc,face_k_loc,dim);</span>
<a name="l02016"></a>02016 
<a name="l02017"></a>02017 <span class="comment">// // Codage optimise:</span>
<a name="l02018"></a>02018 <span class="comment">// if (kik&lt;0)</span>
<a name="l02019"></a>02019 <span class="comment">// {</span>
<a name="l02020"></a>02020 <span class="comment">// if (fik&gt;0) Q_plus(dim)+=fik;</span>
<a name="l02021"></a>02021 <span class="comment">// else       Q_moins(dim)+=fik;</span>
<a name="l02022"></a>02022 <span class="comment">// }</span>
<a name="l02023"></a>02023 <span class="comment">// else</span>
<a name="l02024"></a>02024 <span class="comment">// {</span>
<a name="l02025"></a>02025 <span class="comment">// if (fik&gt;0) P_plus(dim)+=fik;</span>
<a name="l02026"></a>02026 <span class="comment">// else       P_moins(dim)+=fik;</span>
<a name="l02027"></a>02027 <span class="comment">// }</span>
<a name="l02028"></a>02028 <span class="comment">// assert(P_plus(dim)&gt;=0);</span>
<a name="l02029"></a>02029 <span class="comment">// assert(Q_plus(dim)&gt;=0);</span>
<a name="l02030"></a>02030 <span class="comment">// assert(P_moins(dim)&lt;=0);</span>
<a name="l02031"></a>02031 <span class="comment">// assert(Q_moins(dim)&lt;=0);</span>
<a name="l02032"></a>02032 <span class="comment">// }//fin du for sur &quot;dim&quot;</span>
<a name="l02033"></a>02033 <span class="comment">// //</span>
<a name="l02034"></a>02034 <span class="comment">// //Fin du calcul des variables intermediaires</span>
<a name="l02035"></a>02035 <span class="comment">// //</span>
<a name="l02036"></a>02036 <span class="comment">// }//fin du for sur &quot;face_k_loc&quot;</span>
<a name="l02037"></a>02037 <span class="comment">// }//fin du if sur &quot;elem!=-1&quot;</span>
<a name="l02038"></a>02038 <span class="comment">// }//fin du for sur &quot;elem_voisin&quot;</span>
<a name="l02039"></a>02039 }
<a name="l02040"></a>02040 
<a name="l02041"></a>02041 <span class="comment">// ATTENTION : suppose les parametres P_plus, P_moins, Q_plus, Q_moins nuls en entree</span>
<a name="l02042"></a>02042 <span class="keyword">inline</span> <span class="keywordtype">void</span>
<a name="l02043"></a><a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#a62e58f1cd47b3865342a3b37fb1a06df">02043</a> <a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#a62e58f1cd47b3865342a3b37fb1a06df">Op_Conv_Muscl_New_VEF_Face::calculer_senseur_v1</a>(<span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; Kij, <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; Fij, <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; transporteV,
<a name="l02044"></a>02044                                                 <span class="keyword">const</span> <span class="keywordtype">int</span>&amp; nb_comp, <span class="keyword">const</span> <span class="keywordtype">int</span>&amp; face_i,
<a name="l02045"></a>02045                                                 <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; elem_faces, <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; face_voisins, <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; num_fac_loc,
<a name="l02046"></a>02046                                                 <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a>&amp; P_plus, <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a>&amp; P_moins,
<a name="l02047"></a>02047                                                 <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a>&amp; Q_plus, <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a>&amp; Q_moins)<span class="keyword"> const</span>
<a name="l02048"></a>02048 <span class="keyword"></span>{
<a name="l02049"></a>02049   assert(P_plus.<a class="code" href="classArrOfDouble.html#a3c3b33bea0e88b87315c21ee94bee05f" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>()==nb_comp);
<a name="l02050"></a>02050   assert(Q_plus.<a class="code" href="classArrOfDouble.html#a3c3b33bea0e88b87315c21ee94bee05f" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>()==nb_comp);
<a name="l02051"></a>02051   assert(P_moins.<a class="code" href="classArrOfDouble.html#a3c3b33bea0e88b87315c21ee94bee05f" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>()==nb_comp);
<a name="l02052"></a>02052   assert(Q_moins.<a class="code" href="classArrOfDouble.html#a3c3b33bea0e88b87315c21ee94bee05f" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>()==nb_comp);
<a name="l02053"></a>02053 
<a name="l02054"></a>02054   <span class="keywordtype">double</span> inci=0.;
<a name="l02055"></a>02055   <span class="keywordtype">double</span> inck=0.;
<a name="l02056"></a>02056 
<a name="l02057"></a>02057   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_faces_elem=elem_faces.<a class="code" href="classIntTab.html#abc3b32c94925a82f69d5b153a356e359" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(1);
<a name="l02058"></a>02058   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> elem_voisin=0; elem_voisin&lt;2; elem_voisin++)
<a name="l02059"></a>02059     {
<a name="l02060"></a>02060       <span class="keywordtype">int</span> elem = face_voisins(face_i,elem_voisin);
<a name="l02061"></a>02061       <span class="keywordflow">if</span> (elem!=-1)
<a name="l02062"></a>02062         {
<a name="l02063"></a>02063           <span class="keywordtype">int</span> face_i_loc = num_fac_loc(face_i,elem_voisin);
<a name="l02064"></a>02064           assert(face_i_loc&gt;=0);
<a name="l02065"></a>02065           assert(face_i_loc&lt;nb_faces_elem);
<a name="l02066"></a>02066 
<a name="l02067"></a>02067 <span class="comment">// On travaille sur les faces de &quot;elem&quot;</span>
<a name="l02068"></a>02068           <span class="keywordflow">for</span> (<span class="keywordtype">int</span> face_k_loc=0; face_k_loc&lt;nb_faces_elem; face_k_loc++)
<a name="l02069"></a>02069             {
<a name="l02070"></a>02070               <span class="keywordtype">int</span> face_k=elem_faces(elem,face_k_loc);
<a name="l02071"></a>02071               <span class="keywordtype">double</span> kik=Kij(elem,face_i_loc,face_k_loc);
<a name="l02072"></a>02072 <span class="comment">// </span>
<a name="l02073"></a>02073 <span class="comment">// Calcul des variables intermediaires</span>
<a name="l02074"></a>02074 <span class="comment">// </span>
<a name="l02075"></a>02075               <span class="keywordflow">for</span> (<span class="keywordtype">int</span> dim=0; dim&lt;nb_comp; dim++)
<a name="l02076"></a>02076                 {
<a name="l02077"></a>02077                   inci=transporteV[face_i*nb_comp+dim];
<a name="l02078"></a>02078                   inck=transporteV[face_k*nb_comp+dim];
<a name="l02079"></a>02079 
<a name="l02080"></a>02080                   <span class="keywordtype">double</span> fik_low=kik*(inck-inci);
<a name="l02081"></a>02081                   <span class="keywordtype">double</span> fik_high=Fij(elem,face_i_loc,face_k_loc,dim);
<a name="l02082"></a>02082 
<a name="l02083"></a>02083 <span class="comment">// Codage optimise:</span>
<a name="l02084"></a>02084                   <span class="keywordflow">if</span> (kik&lt;0)
<a name="l02085"></a>02085                     {
<a name="l02086"></a>02086                       <span class="keywordflow">if</span> (fik_low&gt;0) Q_plus(dim)+=fik_low;
<a name="l02087"></a>02087                       <span class="keywordflow">else</span>       Q_moins(dim)+=fik_low;
<a name="l02088"></a>02088                     }
<a name="l02089"></a>02089                   <span class="keywordflow">else</span>
<a name="l02090"></a>02090                     {
<a name="l02091"></a>02091                       <span class="keywordflow">if</span> (fik_high&gt;0) P_plus(dim)+=fik_high;
<a name="l02092"></a>02092                       <span class="keywordflow">else</span>       P_moins(dim)+=fik_high;
<a name="l02093"></a>02093                     }
<a name="l02094"></a>02094                   assert(P_plus(dim)&gt;=0);
<a name="l02095"></a>02095                   assert(Q_plus(dim)&gt;=0);
<a name="l02096"></a>02096                   assert(P_moins(dim)&lt;=0);
<a name="l02097"></a>02097                   assert(Q_moins(dim)&lt;=0);
<a name="l02098"></a>02098                 }<span class="comment">//fin du for sur &quot;dim&quot;</span>
<a name="l02099"></a>02099 <span class="comment">// </span>
<a name="l02100"></a>02100 <span class="comment">// Fin du calcul des variables intermediaires</span>
<a name="l02101"></a>02101 <span class="comment">// </span>
<a name="l02102"></a>02102             }<span class="comment">//fin du for sur &quot;face_k_loc&quot;</span>
<a name="l02103"></a>02103         }<span class="comment">//fin du if sur &quot;elem!=-1&quot;</span>
<a name="l02104"></a>02104     }<span class="comment">//fin du for sur &quot;elem_voisin&quot;</span>
<a name="l02105"></a>02105 }
<a name="l02106"></a>02106 
<a name="l02107"></a><a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#a6709414bd989ff2c3e4a377bb7efe084">02107</a> <span class="keywordtype">void</span> <a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#a6709414bd989ff2c3e4a377bb7efe084">Op_Conv_Muscl_New_VEF_Face::test</a>(<span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; transporte, <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; resu, <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; velocity)<span class="keyword"> const</span>
<a name="l02108"></a>02108 <span class="keyword"></span>{
<a name="l02109"></a>02109 }
<a name="l02110"></a>02110 
<a name="l02111"></a><a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#a1acd183f7ead04c1c937df139024bea4">02111</a> <span class="keywordtype">void</span> <a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#a1acd183f7ead04c1c937df139024bea4">Op_Conv_Muscl_New_VEF_Face::test_difference_Kij</a>(<span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; transporte, <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; Kij, <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; Kij_ancien, <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; velocity )<span class="keyword"> const</span>
<a name="l02112"></a>02112 <span class="keyword"></span>{
<a name="l02113"></a>02113 }
<a name="l02114"></a>02114 
<a name="l02115"></a><a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#afc6c7aed9be880d6426a3a1be6d87d38">02115</a> <span class="keywordtype">void</span> <a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#afc6c7aed9be880d6426a3a1be6d87d38">Op_Conv_Muscl_New_VEF_Face::test_difference_resu</a>(<span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; Kij, <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; Kij_ancien,
<a name="l02116"></a>02116                                                       <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; transporte,<span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; resu, <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; velocity)<span class="keyword"> const</span>
<a name="l02117"></a>02117 <span class="keyword"></span>{
<a name="l02118"></a>02118 <span class="comment">// DoubleTab resu1(resu);</span>
<a name="l02119"></a>02119 <span class="comment">// resu1=0;</span>
<a name="l02120"></a>02120 
<a name="l02121"></a>02121 <span class="comment">// if (is_compressible_) ajouter_partie_compressible(transporte,resu1,velocity);</span>
<a name="l02122"></a>02122 <span class="comment">// ajouter_operateur_centre(Kij,transporte,resu1);</span>
<a name="l02123"></a>02123 <span class="comment">// ajouter_diffusion(Kij,transporte,resu1);</span>
<a name="l02124"></a>02124 <span class="comment">// ajouter_antidiffusion(Kij,transporte,resu1);</span>
<a name="l02125"></a>02125 <span class="comment">// mettre_a_jour_pour_periodicite(resu1);</span>
<a name="l02126"></a>02126 }
<a name="l02127"></a>02127 
<a name="l02128"></a><a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#a98bafc0524994d1bba96aff4b28540b8">02128</a> <span class="keywordtype">void</span> <a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#a98bafc0524994d1bba96aff4b28540b8">Op_Conv_Muscl_New_VEF_Face::mettre_a_jour_pour_periodicite</a>(<span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; Kij, <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; transporte, <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; resu)<span class="keyword"> const</span>
<a name="l02129"></a>02129 <span class="keyword"></span>{
<a name="l02130"></a>02130   <span class="keyword">const</span> <a class="code" href="classZone__VEF.html" title="class Zone_VEF Classe instanciable qui derive de Zone_VF. Cette classe contient les informations geom...">Zone_VEF</a>&amp; zone_VEF=<a class="code" href="classOp__Conv__VEF__base.html#a6c29a488a6805ba4a9f2f059cdba77ae">la_zone_vef</a>.<a class="code" href="classRef__Zone__VEF.html#aafd9a5ee1a76f290c9c6b5447b0c8d30">valeur</a>();
<a name="l02131"></a>02131   <span class="keyword">const</span> <a class="code" href="classZone__Cl__VEF.html">Zone_Cl_VEF</a>&amp; zone_Cl_VEF = <a class="code" href="classOp__Conv__VEF__base.html#a03f677ee7911706a4f85cd37e0ca4535">la_zcl_vef</a>.<a class="code" href="classRef__Zone__Cl__VEF.html#a0970d7253def65ad4f0c5ce1830fd243">valeur</a>();
<a name="l02132"></a>02132 
<a name="l02133"></a>02133   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_bord = zone_Cl_VEF.<a class="code" href="classZone__Cl__dis__base.html#aa6f1df56cfd6e2eae83cc991c7cc9b41" title="Renvoie le nombre de conditions aux limites.">nb_cond_lim</a>();
<a name="l02134"></a>02134   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_comp = (resu.<a class="code" href="classDoubleTab.html#ae6dda48778e7107e1beb723beef1f75b" title="Returns the number of dimensions of the array (&gt;= 1)">nb_dim</a>()==1) ? 1 : resu.<a class="code" href="classDoubleTab.html#ac3805e2637a3b880ba2d3e650c69dac4" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(1);
<a name="l02135"></a>02135 
<a name="l02136"></a>02136   <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; transporteV=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classDoubleVect.html">DoubleVect</a>,transporte);
<a name="l02137"></a>02137   <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; resuV=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classDoubleVect.html">DoubleVect</a>,resu);
<a name="l02138"></a>02138 
<a name="l02139"></a>02139   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; face_voisins=zone_VEF.<a class="code" href="classZone__VF.html#a49d4322f5585a8fa95748ca785b70702" title="renvoie l&#39;element voisin de numface dans la direction i. i=0 : dans le sens oppose de l&#39;axe orthogona...">face_voisins</a>();
<a name="l02140"></a>02140   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; num_fac_loc = zone_VEF.<a class="code" href="classZone__VF.html#a95113b10f16f37600ba81d3fb41102b2">get_num_fac_loc</a>();
<a name="l02141"></a>02141 
<a name="l02142"></a>02142   <span class="keywordtype">int</span> ligne=0,ligneAss=0;
<a name="l02143"></a>02143   <span class="keywordtype">int</span> facei=0,faceiAss=0;
<a name="l02144"></a>02144   <span class="keywordtype">int</span> ind_face=0;
<a name="l02145"></a>02145   <span class="keywordtype">int</span> num1=0,num2=0;
<a name="l02146"></a>02146   <span class="keywordtype">int</span> ind_face_associee=0;
<a name="l02147"></a>02147   <span class="keywordtype">int</span> dim=0;
<a name="l02148"></a>02148   <span class="keywordtype">int</span> elem=-1;
<a name="l02149"></a>02149   <span class="keywordtype">int</span> facei_loc=-1;
<a name="l02150"></a>02150 
<a name="l02151"></a>02151   <span class="keywordtype">double</span> kii=0.;
<a name="l02152"></a>02152   <span class="keywordtype">double</span> tmp=0.;
<a name="l02153"></a>02153 
<a name="l02154"></a>02154 <span class="comment">// Faces de bord</span>
<a name="l02155"></a>02155   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> n_bord=0; n_bord&lt;nb_bord; n_bord++)
<a name="l02156"></a>02156     {
<a name="l02157"></a>02157       <span class="keyword">const</span> <a class="code" href="classCond__lim.html" title="classe Cond_lim Classe generique servant a representer n&#39;importe quelle classe derivee de la classe C...">Cond_lim</a>&amp; la_cl = zone_Cl_VEF.<a class="code" href="classZone__Cl__dis__base.html#af75e0ed7786863e4d333bfb29d67c323" title="Renvoie la i-ieme condition aux limites. (version const)">les_conditions_limites</a>(n_bord);
<a name="l02158"></a>02158       <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp; le_bord = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>,la_cl.<a class="code" href="classCond__lim.html#a5b2d24809cee07727006a891d4ce8d22" title="Appel a l&#39;objet sous-jacent Renvoie la frontiere discretisee associee a la condition aux limites...">frontiere_dis</a>());
<a name="l02159"></a>02159       num1=0;
<a name="l02160"></a>02160       num2=le_bord.<a class="code" href="classFront__VF.html#a341e2fcb5117b96e745fd7078ba86bab" title="Nombre de faces reelles du bord.">nb_faces</a>();
<a name="l02161"></a>02161 
<a name="l02162"></a>02162       <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>()))
<a name="l02163"></a>02163         {
<a name="l02164"></a>02164           <span class="keyword">const</span> <a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>&amp; la_cl_perio = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>());
<a name="l02165"></a>02165 
<a name="l02166"></a>02166           <span class="keywordflow">for</span> (ind_face=num1; ind_face&lt;num2; ind_face++)
<a name="l02167"></a>02167             {
<a name="l02168"></a>02168               facei=le_bord.<a class="code" href="classFront__VF.html#a3402a19d7e54ed797d2b18e9a47ead1e" title="Renvoie le numero de face de la ieme face du bord.">num_face</a>(ind_face);
<a name="l02169"></a>02169               ind_face_associee=la_cl_perio.<a class="code" href="classPeriodique.html#a207b86556f199a63ea059b841851ca6a">face_associee</a>(ind_face);
<a name="l02170"></a>02170               faceiAss=le_bord.<a class="code" href="classFront__VF.html#a3402a19d7e54ed797d2b18e9a47ead1e" title="Renvoie le numero de face de la ieme face du bord.">num_face</a>(ind_face_associee);
<a name="l02171"></a>02171 
<a name="l02172"></a>02172               <span class="keywordflow">if</span> (facei&lt;faceiAss)
<a name="l02173"></a>02173                 <span class="keywordflow">for</span> (dim=0; dim&lt;nb_comp; dim++)
<a name="l02174"></a>02174                   {
<a name="l02175"></a>02175                     ligne=facei*nb_comp+dim;
<a name="l02176"></a>02176                     ligneAss=faceiAss*nb_comp+dim;
<a name="l02177"></a>02177 
<a name="l02178"></a>02178                     resuV[ligneAss]+=resuV[ligne];
<a name="l02179"></a>02179                     resuV[ligne]=resuV[ligneAss];
<a name="l02180"></a>02180                   }
<a name="l02181"></a>02181 
<a name="l02182"></a>02182               <span class="keywordflow">if</span> (<a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#af27e616d4be292efae0dcd25ef29278c">old_centered_</a>)
<a name="l02183"></a>02183                 {
<a name="l02184"></a>02184 <span class="comment">// Pour le 1er element voisin</span>
<a name="l02185"></a>02185                   elem=face_voisins(facei,0);
<a name="l02186"></a>02186                   facei_loc=-1;
<a name="l02187"></a>02187                   facei_loc=num_fac_loc(facei,0);
<a name="l02188"></a>02188                   assert(facei_loc!=-1);
<a name="l02189"></a>02189                   kii=Kij(elem,facei_loc,facei_loc);
<a name="l02190"></a>02190 
<a name="l02191"></a>02191 <span class="comment">// Pour le 2eme element voisin</span>
<a name="l02192"></a>02192                   elem=face_voisins(facei,1);
<a name="l02193"></a>02193                   facei_loc=-1;
<a name="l02194"></a>02194                   facei_loc=num_fac_loc(facei,1);
<a name="l02195"></a>02195                   assert(facei_loc!=-1);
<a name="l02196"></a>02196                   kii+=Kij(elem,facei_loc,facei_loc);
<a name="l02197"></a>02197 
<a name="l02198"></a>02198                   <span class="keywordflow">for</span> (dim=0; dim&lt;nb_comp; dim++)
<a name="l02199"></a>02199                     {
<a name="l02200"></a>02200                       ligne=facei*nb_comp+dim;
<a name="l02201"></a>02201                       ligneAss=faceiAss*nb_comp+dim;
<a name="l02202"></a>02202 
<a name="l02203"></a>02203                       tmp=kii*transporteV[ligneAss];
<a name="l02204"></a>02204                       resuV[ligneAss]-=tmp;
<a name="l02205"></a>02205                       resuV[ligne]-=tmp;
<a name="l02206"></a>02206                     }
<a name="l02207"></a>02207                 }
<a name="l02208"></a>02208 
<a name="l02209"></a>02209             }<span class="comment">//fin du for sur &quot;face_i&quot;</span>
<a name="l02210"></a>02210 
<a name="l02211"></a>02211         }<span class="comment">//fin du if sur &quot;Periodique&quot;</span>
<a name="l02212"></a>02212 
<a name="l02213"></a>02213     }<span class="comment">//fin du for sur &quot;n_bord&quot;</span>
<a name="l02214"></a>02214 }
<a name="l02215"></a>02215 
<a name="l02216"></a><a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#af0ae6f8bcbe698e8ddc0b0a83f67604c">02216</a> <span class="keywordtype">void</span> <a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#af0ae6f8bcbe698e8ddc0b0a83f67604c">Op_Conv_Muscl_New_VEF_Face::ajouter_old</a>(<span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; transporte, <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; resu, <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; velocity )<span class="keyword"> const</span>
<a name="l02217"></a>02217 <span class="keyword"></span>{
<a name="l02218"></a>02218 }
<a name="l02219"></a>02219 
<a name="l02220"></a>02220 <span class="comment">// Fonction qui initialise les attributs &quot;elem_nb_faces_dirichlet_&quot;</span>
<a name="l02221"></a>02221 <span class="comment">// et &quot;elem_faces_dirichlet_&quot;</span>
<a name="l02222"></a>02222 <span class="comment">// REMARQUE : &quot;elem_nb_faces_dirichlet_&quot; contient le nombre de faces de Dirichlet</span>
<a name="l02223"></a>02223 <span class="comment">// pour chaque element du maillage</span>
<a name="l02224"></a>02224 <span class="comment">// REMARQUE : &quot;elem_faces_dirichlet_&quot; le numero global des faces de Dirichlet</span>
<a name="l02225"></a>02225 <span class="comment">// contenu dans un element quelconque du maillage</span>
<a name="l02226"></a><a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#a4ff4bc26b4f14df5174c4682f2ec580b">02226</a> <span class="keywordtype">void</span> <a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#a4ff4bc26b4f14df5174c4682f2ec580b">Op_Conv_Muscl_New_VEF_Face::calculer_data_pour_dirichlet</a>()
<a name="l02227"></a>02227 {
<a name="l02228"></a>02228   <span class="keyword">const</span> <a class="code" href="classZone__VEF.html" title="class Zone_VEF Classe instanciable qui derive de Zone_VF. Cette classe contient les informations geom...">Zone_VEF</a>&amp; zone_VEF = <a class="code" href="classOp__Conv__VEF__base.html#a6c29a488a6805ba4a9f2f059cdba77ae">la_zone_vef</a>.<a class="code" href="classRef__Zone__VEF.html#aafd9a5ee1a76f290c9c6b5447b0c8d30">valeur</a>();
<a name="l02229"></a>02229   <span class="keyword">const</span> <a class="code" href="classZone__Cl__VEF.html">Zone_Cl_VEF</a>&amp; zone_Cl_VEF = <a class="code" href="classOp__Conv__VEF__base.html#a03f677ee7911706a4f85cd37e0ca4535">la_zcl_vef</a>.<a class="code" href="classRef__Zone__Cl__VEF.html#a0970d7253def65ad4f0c5ce1830fd243">valeur</a>();
<a name="l02230"></a>02230 
<a name="l02231"></a>02231   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; face_sommets = zone_VEF.<a class="code" href="classZone__VF.html#a298e73b18e17da55f421b1fb0879bd46" title="renvoie le numero du ieme sommet de la face num_face.">face_sommets</a>();
<a name="l02232"></a>02232   <span class="keyword">const</span> <a class="code" href="classIntVect.html">IntVect</a>&amp; rang_elem_non_std = zone_VEF.<a class="code" href="classZone__VEF.html#a4b2171a85e5fc33663a3366acb713584">rang_elem_non_std</a>();
<a name="l02233"></a>02233   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; elem_sommets = zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#ac115e8342be89afb882b7b61cc343267" title="Renvoie le tableau des sommets des elements.">les_elems</a>();
<a name="l02234"></a>02234 
<a name="l02235"></a>02235   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_elem_tot = zone_VEF.<a class="code" href="classZone__dis__base.html#a4d6aa445f152aa6dc54d66ea7a071147">nb_elem_tot</a>();
<a name="l02236"></a>02236   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_bord = zone_Cl_VEF.<a class="code" href="classZone__Cl__dis__base.html#aa6f1df56cfd6e2eae83cc991c7cc9b41" title="Renvoie le nombre de conditions aux limites.">nb_cond_lim</a>();
<a name="l02237"></a>02237   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_som_faces = zone_VEF.<a class="code" href="classZone__VF.html#a990808f967f351edbb83ff11d60b7445" title="renvoie le nombre de sommets par face. Rque : on a suppose que toutes les faces avait le meme nombre ...">nb_som_face</a>();
<a name="l02238"></a>02238   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_som_elem = zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#ae0b34a93b9ae8146df2d1884157afe9f" title="Renvoie le nombre de sommets des elements geometriques constituants la zone. Tous les elements de la ...">nb_som_elem</a>();
<a name="l02239"></a>02239 
<a name="l02240"></a>02240   <span class="keywordtype">int</span> som_loc=-1;
<a name="l02241"></a>02241   <span class="keywordtype">int</span> som=-1;
<a name="l02242"></a>02242   <span class="keywordtype">int</span> ind_face=-1;
<a name="l02243"></a>02243   <span class="keywordtype">int</span> elem=-1;
<a name="l02244"></a>02244   <span class="keywordtype">int</span> rang=-2;
<a name="l02245"></a>02245 
<a name="l02246"></a>02246 <span class="comment">// On rajoute un flag aux elements qui ont au moins un sommet qui appartient</span>
<a name="l02247"></a>02247 <span class="comment">// une face de Dirichlet ou Dirichlet_homogene</span>
<a name="l02248"></a>02248   <span class="keywordflow">if</span> (<a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#af27e616d4be292efae0dcd25ef29278c">old_centered_</a>)
<a name="l02249"></a>02249     {
<a name="l02250"></a>02250       <a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#a93e226d752c2b31d4b63e08840aea2cb">is_element_for_upwinding_</a>.<a class="code" href="classIntTab.html#a22e6bed6826b3688d4d0181cbf3b7a38" title="Change la taille du vecteur (identique a resize_array() pour le traitement des anciennes valeurs et d...">resize</a>(nb_elem_tot);
<a name="l02251"></a>02251       <a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#a93e226d752c2b31d4b63e08840aea2cb">is_element_for_upwinding_</a>=0;
<a name="l02252"></a>02252 
<a name="l02253"></a>02253       <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a> est_un_sommet_de_bord(zone_VEF.<a class="code" href="classZone__dis__base.html#a8f793341b7a41d67561ba563ae0f69a0">nb_som_tot</a>());
<a name="l02254"></a>02254       est_un_sommet_de_bord=0;
<a name="l02255"></a>02255 
<a name="l02256"></a>02256       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> n_bord=0; n_bord&lt;nb_bord; n_bord++)
<a name="l02257"></a>02257         {
<a name="l02258"></a>02258           <span class="keyword">const</span> <a class="code" href="classCond__lim.html" title="classe Cond_lim Classe generique servant a representer n&#39;importe quelle classe derivee de la classe C...">Cond_lim</a>&amp; la_cl = zone_Cl_VEF.<a class="code" href="classZone__Cl__dis__base.html#af75e0ed7786863e4d333bfb29d67c323" title="Renvoie la i-ieme condition aux limites. (version const)">les_conditions_limites</a>(n_bord);
<a name="l02259"></a>02259           <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp; le_bord = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>,la_cl.<a class="code" href="classCond__lim.html#a5b2d24809cee07727006a891d4ce8d22" title="Appel a l&#39;objet sous-jacent Renvoie la frontiere discretisee associee a la condition aux limites...">frontiere_dis</a>());
<a name="l02260"></a>02260           <span class="keywordtype">int</span> nb_faces_tot=le_bord.<a class="code" href="classFront__VF.html#aed4006d91bf2ef3af2b9f7933d863a09" title="Nombre de faces reelles et virtuelles du bord.">nb_faces_tot</a>();
<a name="l02261"></a>02261           <span class="keywordtype">int</span> face=-1;
<a name="l02262"></a>02262 
<a name="l02263"></a>02263           <span class="keywordflow">if</span> ( (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classDirichlet.html" title="classe Dirichlet Cette classe est la classe de base de la hierarchie des conditions aux limites de ty...">Dirichlet</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>()))
<a name="l02264"></a>02264                || (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classDirichlet__homogene.html" title="Classe Dirichlet_homogene Cette classe est la classe de base de la hierarchie des conditions aux limi...">Dirichlet_homogene</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>()))
<a name="l02265"></a>02265              )
<a name="l02266"></a>02266             <span class="keywordflow">for</span> (ind_face=0; ind_face&lt;nb_faces_tot; ind_face++)
<a name="l02267"></a>02267               {
<a name="l02268"></a>02268                 face = le_bord.<a class="code" href="classFront__VF.html#a3402a19d7e54ed797d2b18e9a47ead1e" title="Renvoie le numero de face de la ieme face du bord.">num_face</a>(ind_face);
<a name="l02269"></a>02269                 <span class="keywordflow">for</span> (som_loc=0; som_loc&lt;nb_som_faces; som_loc++)
<a name="l02270"></a>02270                   {
<a name="l02271"></a>02271                     som=face_sommets(face,som_loc);
<a name="l02272"></a>02272                     est_un_sommet_de_bord(som)=1;
<a name="l02273"></a>02273                   }
<a name="l02274"></a>02274               }
<a name="l02275"></a>02275         }
<a name="l02276"></a>02276 
<a name="l02277"></a>02277       <span class="keywordflow">for</span> (elem=0; elem&lt;nb_elem_tot; elem++)
<a name="l02278"></a>02278         {
<a name="l02279"></a>02279           rang=rang_elem_non_std(elem);
<a name="l02280"></a>02280           <span class="keywordflow">if</span> (rang!=-1) <a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#a93e226d752c2b31d4b63e08840aea2cb">is_element_for_upwinding_</a>(elem)=1;
<a name="l02281"></a>02281           <span class="keywordflow">else</span>
<a name="l02282"></a>02282             <span class="keywordflow">for</span> (som_loc=0; som_loc&lt;nb_som_elem; som_loc++)
<a name="l02283"></a>02283               {
<a name="l02284"></a>02284                 som=elem_sommets(elem,som_loc);
<a name="l02285"></a>02285                 <span class="keywordflow">if</span> (est_un_sommet_de_bord(som))
<a name="l02286"></a>02286                   <a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#a93e226d752c2b31d4b63e08840aea2cb">is_element_for_upwinding_</a>(elem)=1;
<a name="l02287"></a>02287               }
<a name="l02288"></a>02288         }
<a name="l02289"></a>02289     }
<a name="l02290"></a>02290   <a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#a1e7b0db2325d8e59bbaa9460ed6f3826">is_dirichlet_faces_</a>.<a class="code" href="classIntTab.html#a22e6bed6826b3688d4d0181cbf3b7a38" title="Change la taille du vecteur (identique a resize_array() pour le traitement des anciennes valeurs et d...">resize</a>(zone_VEF.<a class="code" href="classZone__VF.html#a50fd21c9535680489015a3c8b88c685a" title="renvoie le nombre total de faces. C&#39;est-a-dire faces reelles + faces virtuelles">nb_faces_tot</a>());
<a name="l02291"></a>02291   <a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#a1e7b0db2325d8e59bbaa9460ed6f3826">is_dirichlet_faces_</a>=0;
<a name="l02292"></a>02292 
<a name="l02293"></a>02293   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> n_bord=0; n_bord&lt;nb_bord; n_bord++)
<a name="l02294"></a>02294     {
<a name="l02295"></a>02295       <span class="keyword">const</span> <a class="code" href="classCond__lim.html" title="classe Cond_lim Classe generique servant a representer n&#39;importe quelle classe derivee de la classe C...">Cond_lim</a>&amp; la_cl = zone_Cl_VEF.<a class="code" href="classZone__Cl__dis__base.html#af75e0ed7786863e4d333bfb29d67c323" title="Renvoie la i-ieme condition aux limites. (version const)">les_conditions_limites</a>(n_bord);
<a name="l02296"></a>02296       <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp; le_bord = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>,la_cl.<a class="code" href="classCond__lim.html#a5b2d24809cee07727006a891d4ce8d22" title="Appel a l&#39;objet sous-jacent Renvoie la frontiere discretisee associee a la condition aux limites...">frontiere_dis</a>());
<a name="l02297"></a>02297       <span class="keywordtype">int</span> nb_faces_tot=le_bord.<a class="code" href="classFront__VF.html#aed4006d91bf2ef3af2b9f7933d863a09" title="Nombre de faces reelles et virtuelles du bord.">nb_faces_tot</a>();
<a name="l02298"></a>02298       <span class="keywordtype">int</span> face=-1;
<a name="l02299"></a>02299 
<a name="l02300"></a>02300       <span class="keywordflow">if</span> ( (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classDirichlet.html" title="classe Dirichlet Cette classe est la classe de base de la hierarchie des conditions aux limites de ty...">Dirichlet</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>()))
<a name="l02301"></a>02301            || (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classDirichlet__homogene.html" title="Classe Dirichlet_homogene Cette classe est la classe de base de la hierarchie des conditions aux limi...">Dirichlet_homogene</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>()))
<a name="l02302"></a>02302          )
<a name="l02303"></a>02303         <span class="keywordflow">for</span> (ind_face=0; ind_face&lt;nb_faces_tot; ind_face++)
<a name="l02304"></a>02304           {
<a name="l02305"></a>02305             face = le_bord.<a class="code" href="classFront__VF.html#a3402a19d7e54ed797d2b18e9a47ead1e" title="Renvoie le numero de face de la ieme face du bord.">num_face</a>(ind_face);
<a name="l02306"></a>02306             <a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#a1e7b0db2325d8e59bbaa9460ed6f3826">is_dirichlet_faces_</a>(face)=1;
<a name="l02307"></a>02307           }
<a name="l02308"></a>02308     }
<a name="l02309"></a>02309 }
<a name="l02310"></a>02310 
<a name="l02311"></a><a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#aa314b43d428161f096acbd9dfb8b6634">02311</a> <span class="keywordtype">void</span> <a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#aa314b43d428161f096acbd9dfb8b6634" title="Associe l&#39;operateur a la zone_dis, la zone_Cl_dis, et a l&#39;inconnue de son equation.">Op_Conv_Muscl_New_VEF_Face::completer</a>()
<a name="l02312"></a>02312 {
<a name="l02313"></a>02313   <a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#aa314b43d428161f096acbd9dfb8b6634" title="Associe l&#39;operateur a la zone_dis, la zone_Cl_dis, et a l&#39;inconnue de son equation.">Op_Conv_VEF_Face::completer</a>();
<a name="l02314"></a>02314   <a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#a4ff4bc26b4f14df5174c4682f2ec580b">calculer_data_pour_dirichlet</a>();
<a name="l02315"></a>02315 
<a name="l02316"></a>02316 <span class="comment">// int nb_comp=1;</span>
<a name="l02317"></a>02317 <span class="comment">// if (equation().inconnue().valeurs().nb_dim()&gt;1)</span>
<a name="l02318"></a>02318 <span class="comment">// nb_comp=equation().inconnue().valeurs().dimension(1);</span>
<a name="l02319"></a>02319 
<a name="l02320"></a>02320 <span class="comment">// limiteurs_.resize(la_zone_vef-&gt;nb_faces_tot(),nb_comp);</span>
<a name="l02321"></a>02321 <span class="comment">// limiteurs_=0.;</span>
<a name="l02322"></a>02322 
<a name="l02323"></a>02323   <a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#a5477f9154396fb7e43a71d40c0689e78">alpha_tab</a>.<a class="code" href="classArrOfDouble.html#a610464f4b3dccac6f814915b526783ed">resize_array</a>(<a class="code" href="classOp__Conv__VEF__base.html#a6c29a488a6805ba4a9f2f059cdba77ae">la_zone_vef</a>-&gt;nb_faces_tot());
<a name="l02324"></a>02324   <a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#a5477f9154396fb7e43a71d40c0689e78">alpha_tab</a> = <a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#aba93a9d2fdc68f373410c6439c95074c">alpha_</a>;
<a name="l02325"></a>02325 
<a name="l02326"></a>02326   <a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#a809512967978e8fbb8cb99a54cd17594" title="vaut zero pour les faces ou l&#39;on souhaite degenerer en Amont. mutable DoubleTab limiteurs_;//tableau ...">beta</a>.<a class="code" href="classArrOfDouble.html#a610464f4b3dccac6f814915b526783ed">resize_array</a>(<a class="code" href="classOp__Conv__VEF__base.html#a6c29a488a6805ba4a9f2f059cdba77ae">la_zone_vef</a>-&gt;nb_faces_tot());
<a name="l02327"></a>02327   <a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#a809512967978e8fbb8cb99a54cd17594" title="vaut zero pour les faces ou l&#39;on souhaite degenerer en Amont. mutable DoubleTab limiteurs_;//tableau ...">beta</a>=1.;
<a name="l02328"></a>02328 
<a name="l02329"></a>02329 <span class="comment">// if (sous_zone) {</span>
<a name="l02330"></a>02330 <span class="comment">// sous_zone=false;</span>
<a name="l02331"></a>02331 <span class="comment">// const Sous_Zone&amp; la_sous_zone=equation().probleme().domaine().ss_zone(nom_sous_zone);</span>
<a name="l02332"></a>02332 <span class="comment">// const Domaine_dis&amp; le_domaine_dis=la_zone_vef-&gt;domaine_dis();</span>
<a name="l02333"></a>02333 <span class="comment">// for (int ssz=0;ssz&lt;le_domaine_dis.nombre_de_sous_zones_dis();ssz++) {</span>
<a name="l02334"></a>02334 <span class="comment">// if (le_domaine_dis.sous_zone_dis(ssz)-&gt;sous_zone().est_egal_a(la_sous_zone)) {</span>
<a name="l02335"></a>02335 <span class="comment">// sous_zone=true;</span>
<a name="l02336"></a>02336 <span class="comment">// la_sous_zone_dis=ref_cast(Sous_zone_VF,le_domaine_dis.sous_zone_dis(ssz).valeur());</span>
<a name="l02337"></a>02337 <span class="comment">// }</span>
<a name="l02338"></a>02338 <span class="comment">// }</span>
<a name="l02339"></a>02339 
<a name="l02340"></a>02340 <span class="comment">// if(!sous_zone) {</span>
<a name="l02341"></a>02341 <span class="comment">// Cerr &lt;&lt; &quot;On ne trouve pas la sous_zone discretisee associee a &quot; &lt;&lt; nom_sous_zone &lt;&lt; finl;</span>
<a name="l02342"></a>02342 <span class="comment">// Process::exit();</span>
<a name="l02343"></a>02343 <span class="comment">// }</span>
<a name="l02344"></a>02344 
<a name="l02345"></a>02345 <span class="comment">// const Sous_zone_VF&amp; ssz=la_sous_zone_dis.valeur();</span>
<a name="l02346"></a>02346 <span class="comment">// int nb_faces = ssz.les_faces().size();</span>
<a name="l02347"></a>02347 
<a name="l02348"></a>02348 <span class="comment">// for (int face=0;face&lt;nb_faces;face++) {</span>
<a name="l02349"></a>02349 <span class="comment">// int la_face=ssz.les_faces()[face];</span>
<a name="l02350"></a>02350 <span class="comment">// beta(la_face) = 0.;</span>
<a name="l02351"></a>02351 <span class="comment">// alpha_tab(la_face) = 1.;</span>
<a name="l02352"></a>02352 <span class="comment">// }</span>
<a name="l02353"></a>02353 <span class="comment">// }</span>
<a name="l02354"></a>02354 
<a name="l02355"></a>02355 }
<a name="l02356"></a>02356 
<a name="l02357"></a><a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#abac773d46607384fdecf846d33a9c3c5">02357</a> <span class="keywordtype">void</span> <a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#abac773d46607384fdecf846d33a9c3c5">Op_Conv_Muscl_New_VEF_Face::ajouter_contribution</a>(<span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; transporte_2, <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; matrice)<span class="keyword"> const</span>
<a name="l02358"></a>02358 <span class="keyword"></span>{
<a name="l02359"></a>02359 }
<a name="l02360"></a>02360 
<a name="l02361"></a><a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#a9aa7c75c67bd0c800683b833d35eab0f">02361</a> <span class="keywordtype">void</span> <a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#a9aa7c75c67bd0c800683b833d35eab0f" title="On modifie le second membre et la matrice dans le cas des conditions de dirichlet.">Op_Conv_Muscl_New_VEF_Face::modifier_pour_Cl</a> (<a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; matrice, <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; secmem)<span class="keyword"> const</span>
<a name="l02362"></a>02362 <span class="keyword"></span>{
<a name="l02363"></a>02363   <a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#a9aa7c75c67bd0c800683b833d35eab0f" title="On modifie le second membre et la matrice dans le cas des conditions de dirichlet.">Op_Conv_VEF_Face::modifier_pour_Cl</a>(matrice,secmem);
<a name="l02364"></a>02364 }
<a name="l02365"></a>02365 
<a name="l02366"></a><a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#af94ae9e4b02bc730600d17589ecb74f0">02366</a> <span class="keywordtype">void</span> <a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#af94ae9e4b02bc730600d17589ecb74f0">Op_Conv_Muscl_New_VEF_Face::ajouter_contribution_operateur_centre</a>(<span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; Kij, <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; transporte, <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; matrice)<span class="keyword"> const</span>
<a name="l02367"></a>02367 <span class="keyword"></span>{
<a name="l02368"></a>02368 <span class="comment">// const Zone_VEF&amp; zone_VEF=la_zone_vef.valeur();</span>
<a name="l02369"></a>02369 <span class="comment">// const Zone_Cl_VEF&amp; zone_Cl_VEF = la_zcl_vef.valeur();</span>
<a name="l02370"></a>02370 
<a name="l02371"></a>02371 <span class="comment">// const IntTab&amp; elem_faces=zone_VEF.elem_faces();</span>
<a name="l02372"></a>02372 <span class="comment">// const IntTab&amp; face_voisins = zone_VEF.face_voisins();</span>
<a name="l02373"></a>02373 
<a name="l02374"></a>02374 <span class="comment">// const int nb_elem_tot=zone_VEF.nb_elem_tot();</span>
<a name="l02375"></a>02375 <span class="comment">// const int nb_faces_elem=elem_faces.dimension(1);</span>
<a name="l02376"></a>02376 <span class="comment">// const int nb_bord=zone_Cl_VEF.nb_cond_lim();</span>
<a name="l02377"></a>02377 
<a name="l02378"></a>02378 <span class="comment">// int nb_comp=1;</span>
<a name="l02379"></a>02379 <span class="comment">// if (transporte.nb_dim()!=1) nb_comp=transporte.dimension(1);</span>
<a name="l02380"></a>02380 
<a name="l02381"></a>02381 <span class="comment">// int elem=0;</span>
<a name="l02382"></a>02382 <span class="comment">// int facei=0,facei_loc=0;</span>
<a name="l02383"></a>02383 <span class="comment">// int facej=0,facej_loc=0;</span>
<a name="l02384"></a>02384 <span class="comment">// int ligne=0,colonne=0;</span>
<a name="l02385"></a>02385 <span class="comment">// int dim=0;</span>
<a name="l02386"></a>02386 <span class="comment">// int ind_face=0;</span>
<a name="l02387"></a>02387 <span class="comment">// int num1=0,num2=0;</span>
<a name="l02388"></a>02388 <span class="comment">// int faceToComplete=0;</span>
<a name="l02389"></a>02389 <span class="comment">// int elem_loc=0;</span>
<a name="l02390"></a>02390 
<a name="l02391"></a>02391 <span class="comment">// double kij=0.,kji=0.;</span>
<a name="l02392"></a>02392 
<a name="l02393"></a>02393 <span class="comment">// for (elem=0; elem&lt;nb_elem_tot; elem++)</span>
<a name="l02394"></a>02394 <span class="comment">// for (facei_loc=0; facei_loc&lt;nb_faces_elem; facei_loc++)</span>
<a name="l02395"></a>02395 <span class="comment">// {</span>
<a name="l02396"></a>02396 <span class="comment">// facei=elem_faces(elem,facei_loc);</span>
<a name="l02397"></a>02397 
<a name="l02398"></a>02398 <span class="comment">// for (facej_loc=facei_loc+1; facej_loc&lt;nb_faces_elem; facej_loc++)</span>
<a name="l02399"></a>02399 <span class="comment">// {</span>
<a name="l02400"></a>02400 <span class="comment">// facej=elem_faces(elem,facej_loc);</span>
<a name="l02401"></a>02401 <span class="comment">// assert(facej!=facei);</span>
<a name="l02402"></a>02402 
<a name="l02403"></a>02403 <span class="comment">// kij=Kij(elem,facei_loc,facej_loc);</span>
<a name="l02404"></a>02404 <span class="comment">// kji=Kij(elem,facej_loc,facei_loc);</span>
<a name="l02405"></a>02405 
<a name="l02406"></a>02406 <span class="comment">// for (dim=0; dim&lt;nb_comp; dim++)</span>
<a name="l02407"></a>02407 <span class="comment">// {</span>
<a name="l02408"></a>02408 <span class="comment">// ligne=facei*nb_comp+dim;</span>
<a name="l02409"></a>02409 <span class="comment">// colonne=facej*nb_comp+dim;</span>
<a name="l02410"></a>02410 
<a name="l02411"></a>02411 <span class="comment">// //ATTENTION AU SIGNE : ici on code +div(uT)</span>
<a name="l02412"></a>02412 <span class="comment">// matrice(ligne,ligne)+=kij;</span>
<a name="l02413"></a>02413 <span class="comment">// matrice(ligne,colonne)-=kij;</span>
<a name="l02414"></a>02414 <span class="comment">// matrice(colonne,colonne)+=kji;</span>
<a name="l02415"></a>02415 <span class="comment">// matrice(colonne,ligne)-=kji;</span>
<a name="l02416"></a>02416 <span class="comment">// }</span>
<a name="l02417"></a>02417 <span class="comment">// }</span>
<a name="l02418"></a>02418 <span class="comment">// }</span>
<a name="l02419"></a>02419 
<a name="l02420"></a>02420 <span class="comment">// //</span>
<a name="l02421"></a>02421 <span class="comment">// //Pour la periodicite</span>
<a name="l02422"></a>02422 <span class="comment">// //</span>
<a name="l02423"></a>02423 <span class="comment">// const IntTab&amp; num_fac_loc = zone_VEF.get_num_fac_loc();</span>
<a name="l02424"></a>02424 <span class="comment">// for (int n_bord=0; n_bord&lt;nb_bord; n_bord++)</span>
<a name="l02425"></a>02425 <span class="comment">// {</span>
<a name="l02426"></a>02426 <span class="comment">// const Cond_lim&amp; la_cl = zone_Cl_VEF.les_conditions_limites(n_bord);</span>
<a name="l02427"></a>02427 <span class="comment">// const Front_VF&amp; le_bord = ref_cast(Front_VF,la_cl.frontiere_dis());</span>
<a name="l02428"></a>02428 <span class="comment">// num1 = 0;</span>
<a name="l02429"></a>02429 <span class="comment">// num2=le_bord.nb_faces_tot();//et surtout pas nb_faces sinon on oublie certains coefficients</span>
<a name="l02430"></a>02430 
<a name="l02431"></a>02431 <span class="comment">// if (sub_type(Periodique,la_cl.valeur()))</span>
<a name="l02432"></a>02432 <span class="comment">// {</span>
<a name="l02433"></a>02433 <span class="comment">// const Periodique&amp; la_cl_perio = ref_cast(Periodique,la_cl.valeur());</span>
<a name="l02434"></a>02434 <span class="comment">// int faceiAss=0,ind_faceiAss=0;</span>
<a name="l02435"></a>02435 
<a name="l02436"></a>02436 <span class="comment">// for (ind_face=num1; ind_face&lt;num2; ind_face++)</span>
<a name="l02437"></a>02437 <span class="comment">// {</span>
<a name="l02438"></a>02438 <span class="comment">// ind_faceiAss=la_cl_perio.face_associee(ind_face);</span>
<a name="l02439"></a>02439 
<a name="l02440"></a>02440 <span class="comment">// facei=le_bord.num_face(ind_face);</span>
<a name="l02441"></a>02441 <span class="comment">// faceiAss=le_bord.num_face(ind_faceiAss);</span>
<a name="l02442"></a>02442 
<a name="l02443"></a>02443 <span class="comment">// //Pour ne parcourir qu&#39;une seule fois les faces perio</span>
<a name="l02444"></a>02444 <span class="comment">// if (facei&lt;faceiAss)</span>
<a name="l02445"></a>02445 <span class="comment">// for (elem_loc=0;elem_loc&lt;2;elem_loc++)</span>
<a name="l02446"></a>02446 <span class="comment">// {</span>
<a name="l02447"></a>02447 <span class="comment">// elem=face_voisins(facei,elem_loc);</span>
<a name="l02448"></a>02448 <span class="comment">// assert(elem!=-1);</span>
<a name="l02449"></a>02449 
<a name="l02450"></a>02450 <span class="comment">// //Calcul du numero local de la face dans &quot;elem&quot;</span>
<a name="l02451"></a>02451 <span class="comment">// facei_loc=num_fac_loc(facei,elem_loc);</span>
<a name="l02452"></a>02452 <span class="comment">// if (facei_loc!=-1)</span>
<a name="l02453"></a>02453 <span class="comment">// faceToComplete=faceiAss;</span>
<a name="l02454"></a>02454 <span class="comment">// else</span>
<a name="l02455"></a>02455 <span class="comment">// {</span>
<a name="l02456"></a>02456 <span class="comment">// faceToComplete=facei;</span>
<a name="l02457"></a>02457 <span class="comment">// facei_loc=num_fac_loc(faceiAss,elem_loc);</span>
<a name="l02458"></a>02458 <span class="comment">// assert(facei_loc!=-1);</span>
<a name="l02459"></a>02459 <span class="comment">// }</span>
<a name="l02460"></a>02460 
<a name="l02461"></a>02461 <span class="comment">// //Calcul des coefficients de la matrice dus a &quot;elem&quot;</span>
<a name="l02462"></a>02462 <span class="comment">// for (facej_loc=0; facej_loc&lt;nb_faces_elem; facej_loc++)</span>
<a name="l02463"></a>02463 <span class="comment">// {</span>
<a name="l02464"></a>02464 <span class="comment">// facej=elem_faces(elem,facej_loc);</span>
<a name="l02465"></a>02465 
<a name="l02466"></a>02466 <span class="comment">// if (facej_loc!=facei_loc)</span>
<a name="l02467"></a>02467 <span class="comment">// {</span>
<a name="l02468"></a>02468 <span class="comment">// kij=Kij(elem,facei_loc,facej_loc);</span>
<a name="l02469"></a>02469 <span class="comment">// kji=Kij(elem,facej_loc,facei_loc);</span>
<a name="l02470"></a>02470 
<a name="l02471"></a>02471 <span class="comment">// for (dim=0; dim&lt;nb_comp; dim++)</span>
<a name="l02472"></a>02472 <span class="comment">// {</span>
<a name="l02473"></a>02473 <span class="comment">// ligne=faceToComplete*nb_comp+dim;</span>
<a name="l02474"></a>02474 <span class="comment">// colonne=facej*nb_comp+dim;</span>
<a name="l02475"></a>02475 
<a name="l02476"></a>02476 <span class="comment">// //ATTENTION AU SIGNE : ici on code +div(uT)</span>
<a name="l02477"></a>02477 <span class="comment">// matrice(ligne,ligne)+=kij;</span>
<a name="l02478"></a>02478 <span class="comment">// matrice(ligne,colonne)-=kij;</span>
<a name="l02479"></a>02479 <span class="comment">// }</span>
<a name="l02480"></a>02480 <span class="comment">// }</span>
<a name="l02481"></a>02481 <span class="comment">// }</span>
<a name="l02482"></a>02482 <span class="comment">// }</span>
<a name="l02483"></a>02483 <span class="comment">// }</span>
<a name="l02484"></a>02484 <span class="comment">// }</span>
<a name="l02485"></a>02485 <span class="comment">// }</span>
<a name="l02486"></a>02486 }
<a name="l02487"></a>02487 
<a name="l02488"></a><a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#a6410a4c4150029025579edfe38a37d75">02488</a> <span class="keywordtype">void</span> <a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#a6410a4c4150029025579edfe38a37d75">Op_Conv_Muscl_New_VEF_Face::ajouter_contribution_diffusion</a>(<span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; Kij, <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; transporte, <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; matrice)<span class="keyword"> const</span>
<a name="l02489"></a>02489 <span class="keyword"></span>{
<a name="l02490"></a>02490 <span class="comment">// const Zone_VEF&amp; zone_VEF=la_zone_vef.valeur();</span>
<a name="l02491"></a>02491 <span class="comment">// const Zone_Cl_VEF&amp; zone_Cl_VEF = la_zcl_vef.valeur();</span>
<a name="l02492"></a>02492 
<a name="l02493"></a>02493 <span class="comment">// const IntTab&amp; elem_faces=zone_VEF.elem_faces();</span>
<a name="l02494"></a>02494 <span class="comment">// const IntTab&amp; face_voisins = zone_VEF.face_voisins();</span>
<a name="l02495"></a>02495 
<a name="l02496"></a>02496 <span class="comment">// const int nb_elem_tot=zone_VEF.nb_elem_tot();</span>
<a name="l02497"></a>02497 <span class="comment">// const int nb_faces_elem=elem_faces.dimension(1);</span>
<a name="l02498"></a>02498 <span class="comment">// const int nb_bord=zone_Cl_VEF.nb_cond_lim();</span>
<a name="l02499"></a>02499 
<a name="l02500"></a>02500 <span class="comment">// int nb_comp=1;</span>
<a name="l02501"></a>02501 <span class="comment">// if (transporte.nb_dim()!=1) nb_comp=transporte.dimension(1);</span>
<a name="l02502"></a>02502 
<a name="l02503"></a>02503 <span class="comment">// int elem=0;</span>
<a name="l02504"></a>02504 <span class="comment">// int facei=0,facei_loc=0;</span>
<a name="l02505"></a>02505 <span class="comment">// int facej=0,facej_loc=0;</span>
<a name="l02506"></a>02506 <span class="comment">// int ligne=0,colonne=0;</span>
<a name="l02507"></a>02507 <span class="comment">// int dim=0;</span>
<a name="l02508"></a>02508 <span class="comment">// int ind_face=0;</span>
<a name="l02509"></a>02509 <span class="comment">// int num1=0,num2=0;</span>
<a name="l02510"></a>02510 <span class="comment">// int faceToComplete=0;</span>
<a name="l02511"></a>02511 <span class="comment">// int elem_loc=0;</span>
<a name="l02512"></a>02512 
<a name="l02513"></a>02513 <span class="comment">// double dij=0.;</span>
<a name="l02514"></a>02514 <span class="comment">// double coeffij=0.,coeffji=0.;</span>
<a name="l02515"></a>02515 
<a name="l02516"></a>02516 <span class="comment">// for (elem=0; elem&lt;nb_elem_tot; elem++)</span>
<a name="l02517"></a>02517 <span class="comment">// for (facei_loc=0; facei_loc&lt;nb_faces_elem; facei_loc++)</span>
<a name="l02518"></a>02518 <span class="comment">// {</span>
<a name="l02519"></a>02519 <span class="comment">// facei=elem_faces(elem,facei_loc);</span>
<a name="l02520"></a>02520 
<a name="l02521"></a>02521 <span class="comment">// for (facej_loc=facei_loc+1; facej_loc&lt;nb_faces_elem; facej_loc++)</span>
<a name="l02522"></a>02522 <span class="comment">// {</span>
<a name="l02523"></a>02523 <span class="comment">// facej=elem_faces(elem,facej_loc);</span>
<a name="l02524"></a>02524 <span class="comment">// assert(facej!=facei);</span>
<a name="l02525"></a>02525 
<a name="l02526"></a>02526 <span class="comment">// dij=Dij(elem,facei_loc,facej_loc,Kij);</span>
<a name="l02527"></a>02527 <span class="comment">// assert(dij&gt;=0);</span>
<a name="l02528"></a>02528 
<a name="l02529"></a>02529 <span class="comment">// coeffij=alpha_tab(facei)*dij;</span>
<a name="l02530"></a>02530 <span class="comment">// coeffji=alpha_tab(facej)*dij;</span>
<a name="l02531"></a>02531 
<a name="l02532"></a>02532 <span class="comment">// for (dim=0; dim&lt;nb_comp; dim++)</span>
<a name="l02533"></a>02533 <span class="comment">// {</span>
<a name="l02534"></a>02534 <span class="comment">// ligne=facei*nb_comp+dim;</span>
<a name="l02535"></a>02535 <span class="comment">// colonne=facej*nb_comp+dim;</span>
<a name="l02536"></a>02536 
<a name="l02537"></a>02537 <span class="comment">// //ATTENTION AU SIGNE : ici on code +div(uT)</span>
<a name="l02538"></a>02538 <span class="comment">// //REMARQUE : on utilise la symetrie de l&#39;operateur</span>
<a name="l02539"></a>02539 <span class="comment">// matrice(ligne,ligne)+=coeffij;</span>
<a name="l02540"></a>02540 <span class="comment">// matrice(ligne,colonne)-=coeffij;</span>
<a name="l02541"></a>02541 <span class="comment">// matrice(colonne,colonne)+=coeffji;</span>
<a name="l02542"></a>02542 <span class="comment">// matrice(colonne,ligne)-=coeffji;</span>
<a name="l02543"></a>02543 <span class="comment">// }</span>
<a name="l02544"></a>02544 <span class="comment">// }</span>
<a name="l02545"></a>02545 <span class="comment">// }</span>
<a name="l02546"></a>02546 
<a name="l02547"></a>02547 <span class="comment">// //</span>
<a name="l02548"></a>02548 <span class="comment">// //Pour la periodicite</span>
<a name="l02549"></a>02549 <span class="comment">// //</span>
<a name="l02550"></a>02550 <span class="comment">// const IntTab&amp; num_fac_loc = zone_VEF.get_num_fac_loc();</span>
<a name="l02551"></a>02551 <span class="comment">// for (int n_bord=0; n_bord&lt;nb_bord; n_bord++)</span>
<a name="l02552"></a>02552 <span class="comment">// {</span>
<a name="l02553"></a>02553 <span class="comment">// const Cond_lim&amp; la_cl = zone_Cl_VEF.les_conditions_limites(n_bord);</span>
<a name="l02554"></a>02554 <span class="comment">// const Front_VF&amp; le_bord = ref_cast(Front_VF,la_cl.frontiere_dis());</span>
<a name="l02555"></a>02555 <span class="comment">// num1 = 0;</span>
<a name="l02556"></a>02556 <span class="comment">// num2=le_bord.nb_faces_tot();//et surtout pas nb_faces() sinon on oublie certains coefficiens</span>
<a name="l02557"></a>02557 
<a name="l02558"></a>02558 <span class="comment">// if (sub_type(Periodique,la_cl.valeur()))</span>
<a name="l02559"></a>02559 <span class="comment">// {</span>
<a name="l02560"></a>02560 <span class="comment">// const Periodique&amp; la_cl_perio = ref_cast(Periodique,la_cl.valeur());</span>
<a name="l02561"></a>02561 <span class="comment">// int faceiAss=0,ind_faceiAss=0;</span>
<a name="l02562"></a>02562 
<a name="l02563"></a>02563 <span class="comment">// for (ind_face=num1; ind_face&lt;num2; ind_face++)</span>
<a name="l02564"></a>02564 <span class="comment">// {</span>
<a name="l02565"></a>02565 <span class="comment">// facei=le_bord.num_face(ind_face);</span>
<a name="l02566"></a>02566 <span class="comment">// ind_faceiAss=la_cl_perio.face_associee(ind_face);</span>
<a name="l02567"></a>02567 <span class="comment">// faceiAss=le_bord.num_face(ind_faceiAss);</span>
<a name="l02568"></a>02568 
<a name="l02569"></a>02569 <span class="comment">// //Pour ne parcourir qu&#39;une seule fois les faces perio</span>
<a name="l02570"></a>02570 <span class="comment">// if (facei&lt;faceiAss)</span>
<a name="l02571"></a>02571 <span class="comment">// for (elem_loc=0;elem_loc&lt;2;elem_loc++)</span>
<a name="l02572"></a>02572 <span class="comment">// {</span>
<a name="l02573"></a>02573 <span class="comment">// elem=face_voisins(facei,elem_loc);</span>
<a name="l02574"></a>02574 <span class="comment">// assert(elem!=-1);</span>
<a name="l02575"></a>02575 
<a name="l02576"></a>02576 <span class="comment">// //Calcul du numero local de la face dans &quot;elem&quot;</span>
<a name="l02577"></a>02577 <span class="comment">// facei_loc=num_fac_loc(facei,elem_loc);</span>
<a name="l02578"></a>02578 <span class="comment">// if (facei_loc!=-1)</span>
<a name="l02579"></a>02579 <span class="comment">// faceToComplete=faceiAss;</span>
<a name="l02580"></a>02580 <span class="comment">// else</span>
<a name="l02581"></a>02581 <span class="comment">// {</span>
<a name="l02582"></a>02582 <span class="comment">// faceToComplete=facei;</span>
<a name="l02583"></a>02583 <span class="comment">// facei_loc=num_fac_loc(faceiAss,elem_loc);</span>
<a name="l02584"></a>02584 <span class="comment">// assert(facei_loc!=-1);</span>
<a name="l02585"></a>02585 <span class="comment">// }</span>
<a name="l02586"></a>02586 
<a name="l02587"></a>02587 <span class="comment">// //Calcul des coefficients de la matrice dus a &quot;elem&quot;</span>
<a name="l02588"></a>02588 <span class="comment">// for (facej_loc=0; facej_loc&lt;nb_faces_elem; facej_loc++)</span>
<a name="l02589"></a>02589 <span class="comment">// {</span>
<a name="l02590"></a>02590 <span class="comment">// facej=elem_faces(elem,facej_loc);</span>
<a name="l02591"></a>02591 
<a name="l02592"></a>02592 <span class="comment">// if (facej_loc!=facei_loc)</span>
<a name="l02593"></a>02593 <span class="comment">// {</span>
<a name="l02594"></a>02594 <span class="comment">// dij=Dij(elem,facei_loc,facej_loc,Kij);</span>
<a name="l02595"></a>02595 <span class="comment">// assert(dij&gt;=0);</span>
<a name="l02596"></a>02596 
<a name="l02597"></a>02597 <span class="comment">// coeffij=alpha_tab(faceToComplete)*dij;</span>
<a name="l02598"></a>02598 <span class="comment">// coeffji=alpha_tab(facej)*dij;</span>
<a name="l02599"></a>02599 
<a name="l02600"></a>02600 <span class="comment">// for (dim=0; dim&lt;nb_comp; dim++)</span>
<a name="l02601"></a>02601 <span class="comment">// {</span>
<a name="l02602"></a>02602 <span class="comment">// ligne=faceToComplete*nb_comp+dim;</span>
<a name="l02603"></a>02603 <span class="comment">// colonne=facej*nb_comp+dim;</span>
<a name="l02604"></a>02604 
<a name="l02605"></a>02605 <span class="comment">// //ATTENTION AU SIGNE : ici on code +div(uT)</span>
<a name="l02606"></a>02606 <span class="comment">// matrice(ligne,ligne)+=coeffij;</span>
<a name="l02607"></a>02607 <span class="comment">// matrice(ligne,colonne)-=coeffij;</span>
<a name="l02608"></a>02608 <span class="comment">// }</span>
<a name="l02609"></a>02609 <span class="comment">// }</span>
<a name="l02610"></a>02610 <span class="comment">// }</span>
<a name="l02611"></a>02611 <span class="comment">// }</span>
<a name="l02612"></a>02612 <span class="comment">// }</span>
<a name="l02613"></a>02613 <span class="comment">// }</span>
<a name="l02614"></a>02614 <span class="comment">// }</span>
<a name="l02615"></a>02615 }
<a name="l02616"></a>02616 
<a name="l02617"></a>02617 <span class="comment">// Correction pour le poreux : on rajoute la partie en  T div(u)</span>
<a name="l02618"></a>02618 <span class="comment">// Variable transportee : T</span>
<a name="l02619"></a>02619 <span class="comment">// Variable transportante : u</span>
<a name="l02620"></a>02620 <span class="comment">// REMARQUE : il ne FAUT SURTOUT PAS utiliser le tableau Kij car par</span>
<a name="l02621"></a>02621 <span class="comment">// construction celui-ci est telle que sum_{j} Kij =0 ce qui revient a</span>
<a name="l02622"></a>02622 <span class="comment">// imposer une vitesse a divergence nulle par element. Ce qui est</span>
<a name="l02623"></a>02623 <span class="comment">// problematique quand on est en compressible</span>
<a name="l02624"></a><a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#a026e368e5d3d1af6bbb0f1be6d802fac">02624</a> <span class="keywordtype">void</span> <a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#a026e368e5d3d1af6bbb0f1be6d802fac">Op_Conv_Muscl_New_VEF_Face::ajouter_contribution_partie_compressible</a>(<span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; transporte, <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; vitesse_2,
<a name="l02625"></a>02625                                                                           <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; matrice)<span class="keyword"> const</span>
<a name="l02626"></a>02626 <span class="keyword"></span>{
<a name="l02627"></a>02627 <span class="comment">// const Zone_VEF&amp; zone_VEF=la_zone_vef.valeur();</span>
<a name="l02628"></a>02628 <span class="comment">// const Zone_Cl_VEF&amp; zone_Cl_VEF = la_zcl_vef.valeur();</span>
<a name="l02629"></a>02629 
<a name="l02630"></a>02630 <span class="comment">// const IntTab&amp; elem_faces=zone_VEF.elem_faces();</span>
<a name="l02631"></a>02631 <span class="comment">// const IntTab&amp; face_voisins = zone_VEF.face_voisins();</span>
<a name="l02632"></a>02632 
<a name="l02633"></a>02633 <span class="comment">// const DoubleTab&amp; face_normales=zone_VEF.face_normales();</span>
<a name="l02634"></a>02634 
<a name="l02635"></a>02635 <span class="comment">// const int nb_elem_tot=zone_VEF.nb_elem_tot();</span>
<a name="l02636"></a>02636 <span class="comment">// const int nb_faces_elem=elem_faces.dimension(1);</span>
<a name="l02637"></a>02637 <span class="comment">// const int nb_bord=zone_Cl_VEF.nb_cond_lim();</span>
<a name="l02638"></a>02638 
<a name="l02639"></a>02639 <span class="comment">// //Pour tenir compte de la porosite</span>
<a name="l02640"></a>02640 <span class="comment">// const int marq = phi_u_transportant(equation());</span>
<a name="l02641"></a>02641 
<a name="l02642"></a>02642 <span class="comment">// const DoubleVect&amp; porosite_elem = zone_VEF.porosite_elem();</span>
<a name="l02643"></a>02643 <span class="comment">// const DoubleVect&amp; porosite_face = zone_VEF.porosite_face();</span>
<a name="l02644"></a>02644 
<a name="l02645"></a>02645 <span class="comment">// DoubleTab vitesse(vitesse_.valeur().valeurs());</span>
<a name="l02646"></a>02646 <span class="comment">// for (int i=0; i&lt;vitesse.dimension(0); i++)</span>
<a name="l02647"></a>02647 <span class="comment">// for (int j=0; j&lt;vitesse.dimension(1); j++)</span>
<a name="l02648"></a>02648 <span class="comment">// vitesse(i,j)*=porosite_face(i);</span>
<a name="l02649"></a>02649 
<a name="l02650"></a>02650 <span class="comment">// int nb_comp=1;</span>
<a name="l02651"></a>02651 <span class="comment">// if (transporte.nb_dim()!=1) nb_comp=transporte.dimension(1);</span>
<a name="l02652"></a>02652 
<a name="l02653"></a>02653 <span class="comment">// int elem=0,type_elem=0;</span>
<a name="l02654"></a>02654 <span class="comment">// int facei=0,facei_loc=0;</span>
<a name="l02655"></a>02655 <span class="comment">// int faceiAss=0,ind_faceiAss=0;</span>
<a name="l02656"></a>02656 <span class="comment">// int ligne=0;</span>
<a name="l02657"></a>02657 <span class="comment">// int dim=0;</span>
<a name="l02658"></a>02658 <span class="comment">// int ind_face=0;</span>
<a name="l02659"></a>02659 <span class="comment">// int num1=0,num2=0;</span>
<a name="l02660"></a>02660 <span class="comment">// int faceToComplete=0;</span>
<a name="l02661"></a>02661 <span class="comment">// int elem_loc=0;</span>
<a name="l02662"></a>02662 <span class="comment">// int n_bord=0;</span>
<a name="l02663"></a>02663 
<a name="l02664"></a>02664 <span class="comment">// double coeff=0.;</span>
<a name="l02665"></a>02665 <span class="comment">// double signe=0.;</span>
<a name="l02666"></a>02666 <span class="comment">// double div=0.;</span>
<a name="l02667"></a>02667 
<a name="l02668"></a>02668 <span class="comment">// double (*formule)(int);</span>
<a name="l02669"></a>02669 <span class="comment">// if (!volumes_etendus_)</span>
<a name="l02670"></a>02670 <span class="comment">// if (dimension==2) formule=&amp;formule_Id_2D;</span>
<a name="l02671"></a>02671 <span class="comment">// else formule=&amp;formule_Id_3D;</span>
<a name="l02672"></a>02672 <span class="comment">// else</span>
<a name="l02673"></a>02673 <span class="comment">// if (dimension==2) formule=&amp;formule_2D;</span>
<a name="l02674"></a>02674 <span class="comment">// else formule=&amp;formule_3D;</span>
<a name="l02675"></a>02675 
<a name="l02676"></a>02676 <span class="comment">// for (elem=0; elem&lt;nb_elem_tot; elem++)</span>
<a name="l02677"></a>02677 <span class="comment">// {</span>
<a name="l02678"></a>02678 <span class="comment">// //Type de l&#39;element : le nombre de faces de Dirichlet</span>
<a name="l02679"></a>02679 <span class="comment">// //qu&#39;il contient</span>
<a name="l02680"></a>02680 <span class="comment">// type_elem=elem_nb_faces_dirichlet_(elem);</span>
<a name="l02681"></a>02681 <span class="comment">// coeff=formule(type_elem);</span>
<a name="l02682"></a>02682 
<a name="l02683"></a>02683 <span class="comment">// //Calcul de la divergence par element</span>
<a name="l02684"></a>02684 <span class="comment">// div=0.;</span>
<a name="l02685"></a>02685 <span class="comment">// for (facei_loc=0; facei_loc&lt;nb_faces_elem; facei_loc++)</span>
<a name="l02686"></a>02686 <span class="comment">// {</span>
<a name="l02687"></a>02687 <span class="comment">// facei=elem_faces(elem,facei_loc);</span>
<a name="l02688"></a>02688 <span class="comment">// signe=(face_voisins(facei,0)==elem)? 1.:-1.;</span>
<a name="l02689"></a>02689 
<a name="l02690"></a>02690 <span class="comment">// for (dim=0; dim&lt;dimension; dim++)</span>
<a name="l02691"></a>02691 <span class="comment">// div+=signe*face_normales(facei,dim)*vitesse(facei,dim);</span>
<a name="l02692"></a>02692 <span class="comment">// }</span>
<a name="l02693"></a>02693 <span class="comment">// div*=coeff;</span>
<a name="l02694"></a>02694 <span class="comment">// if (!marq) div/=porosite_elem(elem);</span>
<a name="l02695"></a>02695 
<a name="l02696"></a>02696 <span class="comment">// //Calcul de la partie compressible</span>
<a name="l02697"></a>02697 <span class="comment">// for (facei_loc=0; facei_loc&lt;nb_faces_elem; facei_loc++)</span>
<a name="l02698"></a>02698 <span class="comment">// {</span>
<a name="l02699"></a>02699 <span class="comment">// facei=elem_faces(elem,facei_loc);</span>
<a name="l02700"></a>02700 
<a name="l02701"></a>02701 <span class="comment">// for (dim=0; dim&lt;nb_comp; dim++)</span>
<a name="l02702"></a>02702 <span class="comment">// {</span>
<a name="l02703"></a>02703 <span class="comment">// ligne=facei*nb_comp+dim;</span>
<a name="l02704"></a>02704 <span class="comment">// matrice(ligne,ligne)+=div;</span>
<a name="l02705"></a>02705 <span class="comment">// }</span>
<a name="l02706"></a>02706 <span class="comment">// }</span>
<a name="l02707"></a>02707 <span class="comment">// }</span>
<a name="l02708"></a>02708 
<a name="l02709"></a>02709 <span class="comment">// //</span>
<a name="l02710"></a>02710 <span class="comment">// //Pour la periodicite</span>
<a name="l02711"></a>02711 <span class="comment">// //</span>
<a name="l02712"></a>02712 <span class="comment">// const IntTab&amp; num_fac_loc = zone_VEF.get_num_fac_loc();</span>
<a name="l02713"></a>02713 <span class="comment">// for (n_bord=0; n_bord&lt;nb_bord; n_bord++)</span>
<a name="l02714"></a>02714 <span class="comment">// {</span>
<a name="l02715"></a>02715 <span class="comment">// const Cond_lim&amp; la_cl = zone_Cl_VEF.les_conditions_limites(n_bord);</span>
<a name="l02716"></a>02716 <span class="comment">// const Front_VF&amp; le_bord = ref_cast(Front_VF,la_cl.frontiere_dis());</span>
<a name="l02717"></a>02717 <span class="comment">// num1 = 0;</span>
<a name="l02718"></a>02718 <span class="comment">// num2=le_bord.nb_faces();//pour ne parcourir que les faces reelles</span>
<a name="l02719"></a>02719 
<a name="l02720"></a>02720 <span class="comment">// if (sub_type(Periodique,la_cl.valeur()))</span>
<a name="l02721"></a>02721 <span class="comment">// {</span>
<a name="l02722"></a>02722 <span class="comment">// const Periodique&amp; la_cl_perio = ref_cast(Periodique,la_cl.valeur());</span>
<a name="l02723"></a>02723 
<a name="l02724"></a>02724 <span class="comment">// for (ind_face=num1; ind_face&lt;num2; ind_face++)</span>
<a name="l02725"></a>02725 <span class="comment">// {</span>
<a name="l02726"></a>02726 <span class="comment">// facei=le_bord.num_face(ind_face);</span>
<a name="l02727"></a>02727 <span class="comment">// ind_faceiAss=la_cl_perio.face_associee(ind_face);</span>
<a name="l02728"></a>02728 <span class="comment">// faceiAss=le_bord.num_face(ind_faceiAss);</span>
<a name="l02729"></a>02729 
<a name="l02730"></a>02730 <span class="comment">// //Pour ne parcourir qu&#39;une seule fois les faces perio</span>
<a name="l02731"></a>02731 <span class="comment">// if (facei&lt;faceiAss)</span>
<a name="l02732"></a>02732 <span class="comment">// for (elem_loc=0;elem_loc&lt;2;elem_loc++)</span>
<a name="l02733"></a>02733 <span class="comment">// {</span>
<a name="l02734"></a>02734 <span class="comment">// elem=face_voisins(facei,elem_loc);</span>
<a name="l02735"></a>02735 <span class="comment">// assert(elem!=-1);</span>
<a name="l02736"></a>02736 
<a name="l02737"></a>02737 <span class="comment">// //Calcul du numero local de la face dans &quot;elem&quot;</span>
<a name="l02738"></a>02738 <span class="comment">// facei_loc=num_fac_loc(facei,elem_loc);</span>
<a name="l02739"></a>02739 <span class="comment">// if (facei_loc!=-1)</span>
<a name="l02740"></a>02740 <span class="comment">// faceToComplete=faceiAss;</span>
<a name="l02741"></a>02741 <span class="comment">// else</span>
<a name="l02742"></a>02742 <span class="comment">// {</span>
<a name="l02743"></a>02743 <span class="comment">// faceToComplete=facei;</span>
<a name="l02744"></a>02744 <span class="comment">// facei_loc=num_fac_loc(faceiAss,elem_loc);</span>
<a name="l02745"></a>02745 <span class="comment">// assert(facei_loc!=-1);</span>
<a name="l02746"></a>02746 <span class="comment">// }</span>
<a name="l02747"></a>02747 
<a name="l02748"></a>02748 <span class="comment">// //Type de l&#39;element : le nombre de faces de Dirichlet</span>
<a name="l02749"></a>02749 <span class="comment">// //qu&#39;il contient</span>
<a name="l02750"></a>02750 <span class="comment">// type_elem=elem_nb_faces_dirichlet_(elem);</span>
<a name="l02751"></a>02751 <span class="comment">// coeff=formule(type_elem);</span>
<a name="l02752"></a>02752 
<a name="l02753"></a>02753 <span class="comment">// //Calcul de la divergence par element</span>
<a name="l02754"></a>02754 <span class="comment">// div=0.;</span>
<a name="l02755"></a>02755 <span class="comment">// for (facei_loc=0; facei_loc&lt;nb_faces_elem; facei_loc++)</span>
<a name="l02756"></a>02756 <span class="comment">// {</span>
<a name="l02757"></a>02757 <span class="comment">// facei=elem_faces(elem,facei_loc);</span>
<a name="l02758"></a>02758 <span class="comment">// signe=(face_voisins(facei,0)==elem)? 1.:-1.;</span>
<a name="l02759"></a>02759 
<a name="l02760"></a>02760 <span class="comment">// for (dim=0; dim&lt;dimension; dim++)</span>
<a name="l02761"></a>02761 <span class="comment">// div+=signe*face_normales(facei,dim)*vitesse(facei,dim);</span>
<a name="l02762"></a>02762 <span class="comment">// }</span>
<a name="l02763"></a>02763 <span class="comment">// div*=coeff;</span>
<a name="l02764"></a>02764 <span class="comment">// if (!marq) div/=porosite_elem(elem);</span>
<a name="l02765"></a>02765 
<a name="l02766"></a>02766 <span class="comment">// //Calcul de la partie compressible</span>
<a name="l02767"></a>02767 <span class="comment">// for (dim=0; dim&lt;nb_comp; dim++)</span>
<a name="l02768"></a>02768 <span class="comment">// {</span>
<a name="l02769"></a>02769 <span class="comment">// ligne=faceToComplete*nb_comp+dim;</span>
<a name="l02770"></a>02770 <span class="comment">// matrice(ligne,ligne)+=div;</span>
<a name="l02771"></a>02771 <span class="comment">// }</span>
<a name="l02772"></a>02772 <span class="comment">// }</span>
<a name="l02773"></a>02773 <span class="comment">// }</span>
<a name="l02774"></a>02774 <span class="comment">// }</span>
<a name="l02775"></a>02775 <span class="comment">// }</span>
<a name="l02776"></a>02776 }
<a name="l02777"></a>02777 
<a name="l02778"></a><a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#ae8449f75326ce9bb64f44c8a67906916">02778</a> <span class="keywordtype">void</span> <a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#ae8449f75326ce9bb64f44c8a67906916">Op_Conv_Muscl_New_VEF_Face::ajouter_contribution_antidiffusion</a>(<span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; Kij, <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; transporte,
<a name="l02779"></a>02779                                                                     <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; matrice)<span class="keyword"> const</span>
<a name="l02780"></a>02780 <span class="keyword"></span>{
<a name="l02781"></a>02781 <span class="comment">// const Zone_VEF&amp; zone_VEF=la_zone_vef.valeur();</span>
<a name="l02782"></a>02782 <span class="comment">// const Zone_Cl_VEF&amp; zone_Cl_VEF = la_zcl_vef.valeur();</span>
<a name="l02783"></a>02783 
<a name="l02784"></a>02784 <span class="comment">// const IntTab&amp; elem_faces=zone_VEF.elem_faces();</span>
<a name="l02785"></a>02785 <span class="comment">// const IntTab&amp; face_voisins = zone_VEF.face_voisins();</span>
<a name="l02786"></a>02786 
<a name="l02787"></a>02787 <span class="comment">// const int nb_elem_tot=zone_VEF.nb_elem_tot();</span>
<a name="l02788"></a>02788 <span class="comment">// const int nb_faces_elem=elem_faces.dimension(1);</span>
<a name="l02789"></a>02789 <span class="comment">// const int nb_bord=zone_Cl_VEF.nb_cond_lim();</span>
<a name="l02790"></a>02790 
<a name="l02791"></a>02791 <span class="comment">// int nb_comp=1;</span>
<a name="l02792"></a>02792 <span class="comment">// if (transporte.nb_dim()!=1) nb_comp=transporte.dimension(1);</span>
<a name="l02793"></a>02793 
<a name="l02794"></a>02794 <span class="comment">// int elem=0;</span>
<a name="l02795"></a>02795 <span class="comment">// int elem_loc=0;</span>
<a name="l02796"></a>02796 <span class="comment">// int facei=0,facei_loc=0;</span>
<a name="l02797"></a>02797 <span class="comment">// int faceiAss=0;</span>
<a name="l02798"></a>02798 <span class="comment">// int ind_face=0,ind_faceiAss=0;</span>
<a name="l02799"></a>02799 <span class="comment">// int facej=0,facej_loc=0;</span>
<a name="l02800"></a>02800 <span class="comment">// int ligne=0,colonne=0;</span>
<a name="l02801"></a>02801 <span class="comment">// int dim=0;</span>
<a name="l02802"></a>02802 <span class="comment">// int face_amont=0,face_aval=0;</span>
<a name="l02803"></a>02803 <span class="comment">// int faceToComplete=0;</span>
<a name="l02804"></a>02804 <span class="comment">// int num1=0,num2=0;</span>
<a name="l02805"></a>02805 <span class="comment">// int n_bord=0;</span>
<a name="l02806"></a>02806 
<a name="l02807"></a>02807 <span class="comment">// double kij=0.,kji=0.,dij=0.;</span>
<a name="l02808"></a>02808 <span class="comment">// double lij=0.,lji=0.;</span>
<a name="l02809"></a>02809 <span class="comment">// double daij=0.;</span>
<a name="l02810"></a>02810 <span class="comment">// double delta=0.;</span>
<a name="l02811"></a>02811 <span class="comment">// double coeffij=0.,coeffji=0.;</span>
<a name="l02812"></a>02812 <span class="comment">// double coeff=0.;</span>
<a name="l02813"></a>02813 <span class="comment">// double R=0.;</span>
<a name="l02814"></a>02814 
<a name="l02815"></a>02815 <span class="comment">// //Pour le limiteur</span>
<a name="l02816"></a>02816 <span class="comment">// ArrOfDouble P_plus(nb_comp),P_moins(nb_comp);</span>
<a name="l02817"></a>02817 <span class="comment">// ArrOfDouble Q_plus(nb_comp),Q_moins(nb_comp);</span>
<a name="l02818"></a>02818 <span class="comment">// P_plus=0., P_moins=0.;</span>
<a name="l02819"></a>02819 <span class="comment">// Q_plus=0., Q_moins=0.;</span>
<a name="l02820"></a>02820 
<a name="l02821"></a>02821 <span class="comment">// const DoubleVect&amp; transporteV=ref_cast(DoubleVect,transporte);</span>
<a name="l02822"></a>02822 <span class="comment">// const IntTab&amp; num_fac_loc = zone_VEF.get_num_fac_loc();</span>
<a name="l02823"></a>02823 <span class="comment">// for (elem=0; elem&lt;nb_elem_tot; elem++)</span>
<a name="l02824"></a>02824 <span class="comment">// for (facei_loc=0; facei_loc&lt;nb_faces_elem; facei_loc++)</span>
<a name="l02825"></a>02825 <span class="comment">// {</span>
<a name="l02826"></a>02826 <span class="comment">// facei=elem_faces(elem,facei_loc);</span>
<a name="l02827"></a>02827 
<a name="l02828"></a>02828 <span class="comment">// P_plus=0., P_moins=0.;</span>
<a name="l02829"></a>02829 <span class="comment">// Q_plus=0., Q_moins=0.;</span>
<a name="l02830"></a>02830 <span class="comment">// calculer_senseur(Kij,transporteV,nb_comp,facei,elem_faces,face_voisins,num_fac_loc,P_plus,P_moins,Q_plus,Q_moins);</span>
<a name="l02831"></a>02831 <span class="comment">// for (facej_loc=0; facej_loc&lt;nb_faces_elem; facej_loc++)</span>
<a name="l02832"></a>02832 <span class="comment">// if (facej_loc!=facei_loc)</span>
<a name="l02833"></a>02833 <span class="comment">// {</span>
<a name="l02834"></a>02834 <span class="comment">// facej=elem_faces(elem,facej_loc);</span>
<a name="l02835"></a>02835 
<a name="l02836"></a>02836 <span class="comment">// kij = Kij(elem,facei_loc,facej_loc);</span>
<a name="l02837"></a>02837 <span class="comment">// kji = Kij(elem,facej_loc,facei_loc);</span>
<a name="l02838"></a>02838 <span class="comment">// dij = Dij(elem,facei_loc,facej_loc,Kij);</span>
<a name="l02839"></a>02839 <span class="comment">// lij = kij+dij;</span>
<a name="l02840"></a>02840 <span class="comment">// lji = kji+dij;</span>
<a name="l02841"></a>02841 <span class="comment">// assert(lij&gt;=0);</span>
<a name="l02842"></a>02842 <span class="comment">// assert(lji&gt;=0);</span>
<a name="l02843"></a>02843 
<a name="l02844"></a>02844 <span class="comment">// if (lij&lt;=lji) //facei est amont</span>
<a name="l02845"></a>02845 <span class="comment">// {</span>
<a name="l02846"></a>02846 <span class="comment">// face_amont = facei;</span>
<a name="l02847"></a>02847 <span class="comment">// face_aval = facej;</span>
<a name="l02848"></a>02848 
<a name="l02849"></a>02849 <span class="comment">// //Si lij==lji, on passe deux foix dans la boucle</span>
<a name="l02850"></a>02850 <span class="comment">// //d&#39;ou la presence du coefficient 1/2</span>
<a name="l02851"></a>02851 <span class="comment">// coeff = 1.*(lij&lt;lji)+0.5*(lij==lji);</span>
<a name="l02852"></a>02852 <span class="comment">// assert(coeff==1. || coeff==0.5);</span>
<a name="l02853"></a>02853 
<a name="l02854"></a>02854 <span class="comment">// for (dim=0; dim&lt;nb_comp; dim++)</span>
<a name="l02855"></a>02855 <span class="comment">// {</span>
<a name="l02856"></a>02856 <span class="comment">// ligne=face_amont*nb_comp+dim;</span>
<a name="l02857"></a>02857 <span class="comment">// colonne=face_aval*nb_comp+dim;</span>
<a name="l02858"></a>02858 
<a name="l02859"></a>02859 <span class="comment">// delta=transporteV[ligne]-transporteV[colonne];</span>
<a name="l02860"></a>02860 
<a name="l02861"></a>02861 <span class="comment">// //Limiteur de pente</span>
<a name="l02862"></a>02862 <span class="comment">// if (delta&gt;=0.) R=(P_plus(dim)==0.) ? 0. : Q_plus(dim)/P_plus(dim);</span>
<a name="l02863"></a>02863 <span class="comment">// else  R=(P_moins(dim)==0.) ? 0. : Q_moins(dim)/P_moins(dim);</span>
<a name="l02864"></a>02864 
<a name="l02865"></a>02865 <span class="comment">// daij=minimum(limiteur(R)*dij,lji);</span>
<a name="l02866"></a>02866 <span class="comment">// assert(daij&gt;=0);</span>
<a name="l02867"></a>02867 <span class="comment">// assert(daij&lt;=lji);</span>
<a name="l02868"></a>02868 <span class="comment">// coeffij=alpha_tab(face_amont)*beta(face_amont)*daij;</span>
<a name="l02869"></a>02869 <span class="comment">// coeffji=alpha_tab(face_aval)*beta(face_aval)*daij;</span>
<a name="l02870"></a>02870 
<a name="l02871"></a>02871 <span class="comment">// //Calcul de la matrice</span>
<a name="l02872"></a>02872 <span class="comment">// matrice(ligne,ligne)-=coeffij*coeff;</span>
<a name="l02873"></a>02873 <span class="comment">// matrice(ligne,colonne)+=coeffij*coeff;</span>
<a name="l02874"></a>02874 <span class="comment">// matrice(colonne,colonne)-=coeffji*coeff;</span>
<a name="l02875"></a>02875 <span class="comment">// matrice(colonne,ligne)+=coeffji*coeff;</span>
<a name="l02876"></a>02876 <span class="comment">// }</span>
<a name="l02877"></a>02877 <span class="comment">// }</span>
<a name="l02878"></a>02878 <span class="comment">// }</span>
<a name="l02879"></a>02879 <span class="comment">// }</span>
<a name="l02880"></a>02880 
<a name="l02881"></a>02881 <span class="comment">// //</span>
<a name="l02882"></a>02882 <span class="comment">// //Pour la periodicite</span>
<a name="l02883"></a>02883 <span class="comment">// //</span>
<a name="l02884"></a>02884 <span class="comment">// for (n_bord=0; n_bord&lt;nb_bord; n_bord++)</span>
<a name="l02885"></a>02885 <span class="comment">// {</span>
<a name="l02886"></a>02886 <span class="comment">// const Cond_lim&amp; la_cl = zone_Cl_VEF.les_conditions_limites(n_bord);</span>
<a name="l02887"></a>02887 <span class="comment">// const Front_VF&amp; le_bord = ref_cast(Front_VF,la_cl.frontiere_dis());</span>
<a name="l02888"></a>02888 <span class="comment">// num1 = 0;</span>
<a name="l02889"></a>02889 <span class="comment">// num2=le_bord.nb_faces();//pour ne parcourir que les faces reelles</span>
<a name="l02890"></a>02890 
<a name="l02891"></a>02891 <span class="comment">// if (sub_type(Periodique,la_cl.valeur()))</span>
<a name="l02892"></a>02892 <span class="comment">// {</span>
<a name="l02893"></a>02893 <span class="comment">// const Periodique&amp; la_cl_perio = ref_cast(Periodique,la_cl.valeur());</span>
<a name="l02894"></a>02894 
<a name="l02895"></a>02895 <span class="comment">// //Pour le limiteur</span>
<a name="l02896"></a>02896 <span class="comment">// ArrOfDouble Pj_plus(nb_comp),Pj_moins(nb_comp);</span>
<a name="l02897"></a>02897 <span class="comment">// ArrOfDouble Qj_plus(nb_comp),Qj_moins(nb_comp);</span>
<a name="l02898"></a>02898 <span class="comment">// Pj_plus=0., Pj_moins=0.;</span>
<a name="l02899"></a>02899 <span class="comment">// Qj_plus=0., Qj_moins=0.;</span>
<a name="l02900"></a>02900 
<a name="l02901"></a>02901 <span class="comment">// for (ind_face=num1; ind_face&lt;num2; ind_face++)</span>
<a name="l02902"></a>02902 <span class="comment">// {</span>
<a name="l02903"></a>02903 <span class="comment">// facei=le_bord.num_face(ind_face);</span>
<a name="l02904"></a>02904 <span class="comment">// ind_faceiAss=la_cl_perio.face_associee(ind_face);</span>
<a name="l02905"></a>02905 <span class="comment">// faceiAss=le_bord.num_face(ind_faceiAss);</span>
<a name="l02906"></a>02906 
<a name="l02907"></a>02907 <span class="comment">// //Pour ne parcourir qu&#39;une seule fois les faces perio</span>
<a name="l02908"></a>02908 <span class="comment">// if (facei&lt;faceiAss)</span>
<a name="l02909"></a>02909 <span class="comment">// for (elem_loc=0;elem_loc&lt;2;elem_loc++)</span>
<a name="l02910"></a>02910 <span class="comment">// {</span>
<a name="l02911"></a>02911 <span class="comment">// elem=face_voisins(facei,elem_loc);</span>
<a name="l02912"></a>02912 <span class="comment">// assert(elem!=-1);</span>
<a name="l02913"></a>02913 
<a name="l02914"></a>02914 <span class="comment">// //Calcul du numero local de la face dans &quot;elem&quot;</span>
<a name="l02915"></a>02915 <span class="comment">// facei_loc=num_fac_loc(facei,elem_loc);</span>
<a name="l02916"></a>02916 <span class="comment">// if (facei_loc!=-1)</span>
<a name="l02917"></a>02917 <span class="comment">// faceToComplete=faceiAss;</span>
<a name="l02918"></a>02918 <span class="comment">// else</span>
<a name="l02919"></a>02919 <span class="comment">// {</span>
<a name="l02920"></a>02920 <span class="comment">// faceToComplete=facei;</span>
<a name="l02921"></a>02921 <span class="comment">// facei_loc=num_fac_loc(faceiAss,elem_loc);</span>
<a name="l02922"></a>02922 <span class="comment">// assert(facei_loc!=-1);</span>
<a name="l02923"></a>02923 <span class="comment">// }</span>
<a name="l02924"></a>02924 
<a name="l02925"></a>02925 <span class="comment">// //Calcul du coefficient a rajouter dans la matrice</span>
<a name="l02926"></a>02926 <span class="comment">// P_plus=0., P_moins=0.;</span>
<a name="l02927"></a>02927 <span class="comment">// Q_plus=0., Q_moins=0.;</span>
<a name="l02928"></a>02928 <span class="comment">// calculer_senseur(Kij,transporteV,nb_comp,faceToComplete,elem_faces,face_voisins,num_fac_loc,P_plus,P_moins,Q_plus,Q_moins);</span>
<a name="l02929"></a>02929 
<a name="l02930"></a>02930 <span class="comment">// for (facej_loc=0; facej_loc&lt;nb_faces_elem; facej_loc++)</span>
<a name="l02931"></a>02931 <span class="comment">// if (facej_loc!=facei_loc)</span>
<a name="l02932"></a>02932 <span class="comment">// {</span>
<a name="l02933"></a>02933 <span class="comment">// facej=elem_faces(elem,facej_loc);</span>
<a name="l02934"></a>02934 
<a name="l02935"></a>02935 <span class="comment">// kij = Kij(elem,facei_loc,facej_loc);</span>
<a name="l02936"></a>02936 <span class="comment">// kji = Kij(elem,facej_loc,facei_loc);</span>
<a name="l02937"></a>02937 <span class="comment">// dij = Dij(elem,facei_loc,facej_loc,Kij);</span>
<a name="l02938"></a>02938 <span class="comment">// lij = kij+dij;</span>
<a name="l02939"></a>02939 <span class="comment">// lji = kji+dij;</span>
<a name="l02940"></a>02940 <span class="comment">// assert(lij&gt;=0);</span>
<a name="l02941"></a>02941 <span class="comment">// assert(lji&gt;=0);</span>
<a name="l02942"></a>02942 
<a name="l02943"></a>02943 <span class="comment">// if (lij&lt;=lji) //faceToComplete est amont</span>
<a name="l02944"></a>02944 <span class="comment">// {</span>
<a name="l02945"></a>02945 <span class="comment">// face_amont=faceToComplete;</span>
<a name="l02946"></a>02946 <span class="comment">// face_aval=facej;</span>
<a name="l02947"></a>02947 
<a name="l02948"></a>02948 <span class="comment">// //Si lij==lji, on passe deux foix dans la boucle</span>
<a name="l02949"></a>02949 <span class="comment">// //d&#39;ou la presence du coefficient 1/2</span>
<a name="l02950"></a>02950 <span class="comment">// coeff = 1.*(lij&lt;lji)+0.5*(lij==lji);</span>
<a name="l02951"></a>02951 <span class="comment">// assert(coeff==1. || coeff==0.5);</span>
<a name="l02952"></a>02952 
<a name="l02953"></a>02953 <span class="comment">// for (dim=0; dim&lt;nb_comp; dim++)</span>
<a name="l02954"></a>02954 <span class="comment">// {</span>
<a name="l02955"></a>02955 <span class="comment">// ligne=face_amont*nb_comp+dim;</span>
<a name="l02956"></a>02956 <span class="comment">// colonne=face_aval*nb_comp+dim;</span>
<a name="l02957"></a>02957 
<a name="l02958"></a>02958 <span class="comment">// delta=transporteV[ligne]-transporteV[colonne];</span>
<a name="l02959"></a>02959 
<a name="l02960"></a>02960 <span class="comment">// //Limiteur de pente</span>
<a name="l02961"></a>02961 <span class="comment">// if (delta&gt;=0.) R=(P_plus(dim)==0.) ? 0. : Q_plus(dim)/P_plus(dim);</span>
<a name="l02962"></a>02962 <span class="comment">// else  R=(P_moins(dim)==0.) ? 0. : Q_moins(dim)/P_moins(dim);</span>
<a name="l02963"></a>02963 
<a name="l02964"></a>02964 <span class="comment">// daij=minimum(limiteur(R)*dij,lji);</span>
<a name="l02965"></a>02965 <span class="comment">// assert(daij&gt;=0);</span>
<a name="l02966"></a>02966 <span class="comment">// assert(daij&lt;=lji);</span>
<a name="l02967"></a>02967 <span class="comment">// coeffij=alpha_tab(face_amont)*beta(face_amont)*daij;</span>
<a name="l02968"></a>02968 
<a name="l02969"></a>02969 <span class="comment">// //Calcul de la matrice</span>
<a name="l02970"></a>02970 <span class="comment">// matrice(ligne,ligne)-=coeffij*coeff;</span>
<a name="l02971"></a>02971 <span class="comment">// matrice(ligne,colonne)+=coeffij*coeff;</span>
<a name="l02972"></a>02972 <span class="comment">// }</span>
<a name="l02973"></a>02973 <span class="comment">// }</span>
<a name="l02974"></a>02974 <span class="comment">// else  //faceToComplete est aval</span>
<a name="l02975"></a>02975 <span class="comment">// {</span>
<a name="l02976"></a>02976 <span class="comment">// face_aval=faceToComplete;</span>
<a name="l02977"></a>02977 <span class="comment">// face_amont=facej;</span>
<a name="l02978"></a>02978 
<a name="l02979"></a>02979 <span class="comment">// coeff=1.;</span>
<a name="l02980"></a>02980 
<a name="l02981"></a>02981 <span class="comment">// Pj_plus=0., Pj_moins=0.;</span>
<a name="l02982"></a>02982 <span class="comment">// Qj_plus=0., Qj_moins=0.;</span>
<a name="l02983"></a>02983 <span class="comment">// calculer_senseur(Kij,transporteV,nb_comp,facej,elem_faces,face_voisins,num_fac_loc,Pj_plus,Pj_moins,Qj_plus,Qj_moins);</span>
<a name="l02984"></a>02984 
<a name="l02985"></a>02985 <span class="comment">// for (dim=0; dim&lt;nb_comp; dim++)</span>
<a name="l02986"></a>02986 <span class="comment">// {</span>
<a name="l02987"></a>02987 <span class="comment">// ligne=face_amont*nb_comp+dim;</span>
<a name="l02988"></a>02988 <span class="comment">// colonne=face_aval*nb_comp+dim;</span>
<a name="l02989"></a>02989 
<a name="l02990"></a>02990 <span class="comment">// delta=transporteV[ligne]-transporteV[colonne];</span>
<a name="l02991"></a>02991 
<a name="l02992"></a>02992 <span class="comment">// //Limiteur de pente</span>
<a name="l02993"></a>02993 <span class="comment">// if (delta&gt;=0.) R=(Pj_plus(dim)==0.) ? 0. : Qj_plus(dim)/Pj_plus(dim);</span>
<a name="l02994"></a>02994 <span class="comment">// else  R=(Pj_moins(dim)==0.) ? 0. : Qj_moins(dim)/Pj_moins(dim);</span>
<a name="l02995"></a>02995 
<a name="l02996"></a>02996 <span class="comment">// daij=minimum(limiteur(R)*dij,lij);</span>
<a name="l02997"></a>02997 <span class="comment">// assert(daij&gt;=0);</span>
<a name="l02998"></a>02998 <span class="comment">// assert(daij&lt;=lij);</span>
<a name="l02999"></a>02999 <span class="comment">// coeffij=alpha_tab(face_aval)*beta(face_aval)*daij;</span>
<a name="l03000"></a>03000 
<a name="l03001"></a>03001 <span class="comment">// //Calcul de la matrice</span>
<a name="l03002"></a>03002 <span class="comment">// matrice(colonne,colonne)-=coeffij*coeff;</span>
<a name="l03003"></a>03003 <span class="comment">// matrice(colonne,ligne)+=coeffij*coeff;</span>
<a name="l03004"></a>03004 <span class="comment">// }</span>
<a name="l03005"></a>03005 <span class="comment">// }</span>
<a name="l03006"></a>03006 <span class="comment">// }</span>
<a name="l03007"></a>03007 <span class="comment">// }</span>
<a name="l03008"></a>03008 <span class="comment">// }</span>
<a name="l03009"></a>03009 <span class="comment">// }</span>
<a name="l03010"></a>03010 <span class="comment">// }</span>
<a name="l03011"></a>03011 }
<a name="l03012"></a>03012 
<a name="l03013"></a><a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#ab68a8db5c6dc0e66de1ca5c9ab610364">03013</a> <span class="keywordtype">void</span> <a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#ab68a8db5c6dc0e66de1ca5c9ab610364">Op_Conv_Muscl_New_VEF_Face::test_implicite</a>()<span class="keyword"> const</span>
<a name="l03014"></a>03014 <span class="keyword"></span>{
<a name="l03015"></a>03015 }
<a name="l03016"></a>03016 
<a name="l03017"></a>03017 
</pre></div></div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Tue Dec 14 2021 19:35:43 for TRUST by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
