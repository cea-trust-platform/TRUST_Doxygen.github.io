<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>TRUST: src/VDF/Operateurs/Iterateurs/T_It_VDF_Elem.h Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">TRUST&#160;<span id="projectnumber">1.8.4</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
<div class="header">
  <div class="headertitle">
<div class="title">src/VDF/Operateurs/Iterateurs/T_It_VDF_Elem.h</div>  </div>
</div>
<div class="contents">
<a href="T__It__VDF__Elem_8h.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/****************************************************************************</span>
<a name="l00002"></a>00002 <span class="comment">* Copyright (c) 2021, CEA</span>
<a name="l00003"></a>00003 <span class="comment">* All rights reserved.</span>
<a name="l00004"></a>00004 <span class="comment">*</span>
<a name="l00005"></a>00005 <span class="comment">* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</span>
<a name="l00006"></a>00006 <span class="comment">* 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.</span>
<a name="l00007"></a>00007 <span class="comment">* 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.</span>
<a name="l00008"></a>00008 <span class="comment">* 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.</span>
<a name="l00009"></a>00009 <span class="comment">*</span>
<a name="l00010"></a>00010 <span class="comment">* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.</span>
<a name="l00011"></a>00011 <span class="comment">* IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;</span>
<a name="l00012"></a>00012 <span class="comment">* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>
<a name="l00013"></a>00013 <span class="comment">*</span>
<a name="l00014"></a>00014 <span class="comment">*****************************************************************************/</span>
<a name="l00015"></a>00015 <span class="comment">//</span>
<a name="l00016"></a>00016 <span class="comment">// </span>
<a name="l00017"></a>00017 <span class="comment">// File:        T_It_VDF_Elem.h</span>
<a name="l00018"></a>00018 <span class="comment">// Directory:   $TRUST_ROOT/src/VDF/Operateurs/Iterateurs</span>
<a name="l00019"></a>00019 <span class="comment">// Version:     /main/43</span>
<a name="l00020"></a>00020 <span class="comment">// </span>
<a name="l00021"></a>00021 <span class="comment">//</span>
<a name="l00022"></a>00022 
<a name="l00023"></a>00023 
<a name="l00024"></a>00024 
<a name="l00025"></a>00025 <span class="preprocessor">#ifndef T_It_VDF_Elem_included</span>
<a name="l00026"></a>00026 <span class="preprocessor"></span><span class="preprocessor">#define T_It_VDF_Elem_included</span>
<a name="l00027"></a>00027 <span class="preprocessor"></span>
<a name="l00028"></a>00028 <span class="preprocessor">#include &lt;<a class="code" href="Equation__base_8h.html">Equation_base.h</a>&gt;</span>
<a name="l00029"></a>00029 <span class="preprocessor">#include &lt;<a class="code" href="Milieu__base_8h.html">Milieu_base.h</a>&gt;</span>
<a name="l00030"></a>00030 <span class="preprocessor">#include &lt;<a class="code" href="Champ__Uniforme_8h.html">Champ_Uniforme.h</a>&gt;</span>
<a name="l00031"></a>00031 <span class="preprocessor">#include &lt;<a class="code" href="Debog_8h.html">Debog.h</a>&gt;</span>
<a name="l00032"></a>00032 <span class="preprocessor">#include &lt;<a class="code" href="Probleme__base_8h.html">Probleme_base.h</a>&gt;</span>
<a name="l00033"></a>00033 <span class="preprocessor">#include &lt;<a class="code" href="Schema__Temps__base_8h.html">Schema_Temps_base.h</a>&gt;</span>
<a name="l00034"></a>00034 <span class="preprocessor">#include &lt;<a class="code" href="Operateur__base_8h.html">Operateur_base.h</a>&gt;</span>
<a name="l00035"></a>00035 <span class="preprocessor">#include &lt;<a class="code" href="Operateur__Diff__base_8h.html">Operateur_Diff_base.h</a>&gt;</span>
<a name="l00036"></a>00036 <span class="preprocessor">#include &lt;<a class="code" href="Op__Conv__VDF__base_8h.html">Op_Conv_VDF_base.h</a>&gt;</span>
<a name="l00037"></a>00037 <span class="preprocessor">#include &lt;<a class="code" href="EcrFicPartage_8h.html">EcrFicPartage.h</a>&gt;</span>
<a name="l00038"></a>00038 <span class="preprocessor">#include &lt;<a class="code" href="communications_8h.html">communications.h</a>&gt;</span>
<a name="l00039"></a>00039 <span class="preprocessor">#include &lt;<a class="code" href="DoubleTrav_8h.html">DoubleTrav.h</a>&gt;</span>
<a name="l00040"></a>00040 
<a name="l00041"></a>00041 <span class="comment">//</span>
<a name="l00042"></a>00042 <span class="comment">// </span>
<a name="l00043"></a>00043 <span class="comment">// CLASS Iterateur_VDF_Elem</span>
<a name="l00044"></a>00044 <span class="comment">// </span>
<a name="l00045"></a>00045 <span class="comment">//</span>
<a name="l00046"></a>00046 
<a name="l00047"></a>00047 <span class="keyword">template</span> &lt;<span class="keyword">class</span> _TYPE_&gt;
<a name="l00048"></a>00048 
<a name="l00049"></a><a class="code" href="classT__It__VDF__Elem.html">00049</a> <span class="keyword">class </span><a class="code" href="classT__It__VDF__Elem.html">T_It_VDF_Elem</a> : <span class="keyword">public</span> <a class="code" href="classIterateur__VDF__base.html">Iterateur_VDF_base</a>
<a name="l00050"></a>00050 {
<a name="l00051"></a>00051 <span class="comment">// Declare_instanciable(T_It_VDF_Elem(_TYPE_));</span>
<a name="l00052"></a><a class="code" href="classT__It__VDF__Elem.html#a99f48d16ca0cd64b2bbe6a1e92f299ee">00052</a>   <span class="keyword">inline</span> <span class="keywordtype">int</span> <a class="code" href="classT__It__VDF__Elem.html#a99f48d16ca0cd64b2bbe6a1e92f299ee">duplique</a>()<span class="keyword"> const</span>
<a name="l00053"></a>00053 <span class="keyword">  </span>{
<a name="l00054"></a>00054     <a class="code" href="classT__It__VDF__Elem.html">T_It_VDF_Elem</a>* xxx = <span class="keyword">new</span>  <a class="code" href="classT__It__VDF__Elem.html#a0f6e7990b43d9aa236c8883058b327dc">T_It_VDF_Elem</a>(*<span class="keyword">this</span>);
<a name="l00055"></a>00055     <span class="keywordflow">if</span>(!xxx)
<a name="l00056"></a>00056       {
<a name="l00057"></a>00057         <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Not enough memory &quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
<a name="l00058"></a>00058         <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">exit</a>();
<a name="l00059"></a>00059       }
<a name="l00060"></a>00060     <span class="keywordflow">return</span> xxx-&gt;<a class="code" href="classObjet__U.html#a299d10d1be93af1c2b9f2f43f50141f5" title="Renvoie l&#39;indice de l&#39;objet dans Memoire::data.">numero</a>();
<a name="l00061"></a>00061   };
<a name="l00062"></a><a class="code" href="classT__It__VDF__Elem.html#a0b4d2acc1a454dd05c99abc596f3ca2c">00062</a>   <span class="keyword">inline</span> <span class="keywordtype">unsigned</span> <a class="code" href="classT__It__VDF__Elem.html#a0b4d2acc1a454dd05c99abc596f3ca2c">taille_memoire</a>()<span class="keyword"> const</span>
<a name="l00063"></a>00063 <span class="keyword">  </span>{
<a name="l00064"></a>00064     <span class="keywordflow">throw</span>;
<a name="l00065"></a>00065   };
<a name="l00066"></a>00066 <span class="keyword">public</span>:
<a name="l00067"></a><a class="code" href="classT__It__VDF__Elem.html#a0f6e7990b43d9aa236c8883058b327dc">00067</a>   <span class="keyword">inline</span> <a class="code" href="classT__It__VDF__Elem.html#a0f6e7990b43d9aa236c8883058b327dc">T_It_VDF_Elem</a>() { } ;
<a name="l00068"></a>00068   <span class="keyword">inline</span> <a class="code" href="classT__It__VDF__Elem.html#a0f6e7990b43d9aa236c8883058b327dc">T_It_VDF_Elem</a>(<span class="keyword">const</span> <a class="code" href="classT__It__VDF__Elem.html">T_It_VDF_Elem&lt;_TYPE_&gt;</a>&amp; );
<a name="l00069"></a>00069   <span class="keyword">inline</span> <a class="code" href="classEvaluateur__VDF.html" title="class Evaluateur_VDF Classe de base des evaluateurs VDF. Cette classe n&#39;appartient pas a la hierarchi...">Evaluateur_VDF</a>&amp; <a class="code" href="classT__It__VDF__Elem.html#a4937ea2745a85911d44f0d8a0c0b0dcb">evaluateur</a>();
<a name="l00070"></a>00070   <span class="keyword">inline</span> <span class="keyword">const</span> <a class="code" href="classEvaluateur__VDF.html" title="class Evaluateur_VDF Classe de base des evaluateurs VDF. Cette classe n&#39;appartient pas a la hierarchi...">Evaluateur_VDF</a>&amp; <a class="code" href="classT__It__VDF__Elem.html#a4937ea2745a85911d44f0d8a0c0b0dcb">evaluateur</a>() <span class="keyword">const</span>;
<a name="l00071"></a>00071   <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; <a class="code" href="classT__It__VDF__Elem.html#aebb1435185a41a57d65bbc647c2cd864">calculer</a>(<span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; , <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; ) <span class="keyword">const</span>;
<a name="l00072"></a>00072   <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; <a class="code" href="classT__It__VDF__Elem.html#ac8cf5ddb45fc2de559e28ef15e304a07">ajouter</a>(<span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp;, <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; ) <span class="keyword">const</span>;
<a name="l00073"></a>00073   <span class="keywordtype">void</span> <a class="code" href="classT__It__VDF__Elem.html#a854af77a4cce0e2deeff69f4bce88c21">calculer_flux_bord</a>(<span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp;) <span class="keyword">const</span>;
<a name="l00074"></a>00074   <span class="keywordtype">void</span> <a class="code" href="classT__It__VDF__Elem.html#ae6c075c1c484a6fb44bc0451c79f6b29">contribuer_au_second_membre</a>(<a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; ) <span class="keyword">const</span>;
<a name="l00075"></a>00075   <span class="keywordtype">void</span> <a class="code" href="classT__It__VDF__Elem.html#a81a6d79a10b9317cfa92b93dccd41b0f">ajouter_contribution</a>(<span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp;, <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; ) <span class="keyword">const</span>;
<a name="l00076"></a>00076   <span class="keywordtype">void</span> <a class="code" href="classT__It__VDF__Elem.html#ad4071d7d498524ba686fdf3a3fe2fd0d">ajouter_contribution_vitesse</a>(<span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp;, <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; ) <span class="keyword">const</span>;
<a name="l00077"></a>00077   <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="classT__It__VDF__Elem.html#a1d0df1533727ebd0e9f455f466c82b01">completer_</a>();
<a name="l00078"></a>00078   <span class="keywordtype">int</span> <a class="code" href="classT__It__VDF__Elem.html#a7eda6d967c50c9843d43e1cbe72a1afd">impr</a>(<a class="code" href="classSortie.html" title="Classe de base des flux de sortie. Elle sait ecrire des types simples&lt;br&gt;(entiers, flottants) et des Ob...">Sortie</a>&amp; os) <span class="keyword">const</span>;
<a name="l00079"></a>00079   <span class="keywordtype">void</span> <a class="code" href="classT__It__VDF__Elem.html#ab3efc8b1a81fa3eb613f850dc2498edf">modifier_flux</a>() <span class="keyword">const</span>;
<a name="l00080"></a>00080 <span class="keyword">protected</span>:
<a name="l00081"></a><a class="code" href="classT__It__VDF__Elem.html#ae1fc0535bed05926b790dd398811b036">00081</a>   _TYPE_ <a class="code" href="classT__It__VDF__Elem.html#ae1fc0535bed05926b790dd398811b036">flux_evaluateur</a>;
<a name="l00082"></a>00082   <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; <a class="code" href="classT__It__VDF__Elem.html#a5648f59099343727831e87ae671e3d8e">ajouter_bords</a>(<span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; , <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; ) <span class="keyword">const</span>;
<a name="l00083"></a>00083   <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; <a class="code" href="classT__It__VDF__Elem.html#a8fc65edb5f401e6e9fac46666467b82d">ajouter_interne</a>(<span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; , <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; ) <span class="keyword">const</span>;
<a name="l00084"></a>00084   <span class="keywordtype">void</span> <a class="code" href="classT__It__VDF__Elem.html#a6d0871f9825679d4ce6382ba88d7d8e6">contribuer_au_second_membre_bords</a>(<a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; ) <span class="keyword">const</span>;
<a name="l00085"></a>00085   <span class="keywordtype">void</span> <a class="code" href="classT__It__VDF__Elem.html#a67c535d1963fe3f0b19a9e42d515fb10">contribuer_au_second_membre_interne</a>(<a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; ) <span class="keyword">const</span>;
<a name="l00086"></a>00086   <span class="keywordtype">void</span> <a class="code" href="classT__It__VDF__Elem.html#a5a4f3009b36687e4dd7fa1f33ab541ce">ajouter_contribution_bords</a>(<span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp;, <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; ) <span class="keyword">const</span>;
<a name="l00087"></a>00087   <span class="keywordtype">void</span> <a class="code" href="classT__It__VDF__Elem.html#a5ab524280db69182287cbe3f25666f9b">ajouter_contribution_interne</a>(<span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp;, <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; ) <span class="keyword">const</span>;
<a name="l00088"></a>00088   <span class="keywordtype">void</span> <a class="code" href="classT__It__VDF__Elem.html#a961776f7de2967cf58f1cc8e51ef0463">ajouter_contribution_interne_vitesse</a>(<span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp;, <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; ) <span class="keyword">const</span>;
<a name="l00089"></a>00089   <span class="keywordtype">void</span> <a class="code" href="classT__It__VDF__Elem.html#ae7a38e26b2d63f9d0df4561c73289011">ajouter_contribution_bords_vitesse</a>(<span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp;, <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; ) <span class="keyword">const</span>;
<a name="l00090"></a>00090   <span class="keywordtype">void</span> <a class="code" href="classT__It__VDF__Elem.html#a4e06ea2303d06f5d88619dfde55e280c">ajouter_contribution_autre_pb</a>(<span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; inco, <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; matrice, <span class="keyword">const</span> <a class="code" href="classCond__lim.html" title="classe Cond_lim Classe generique servant a representer n&#39;importe quelle classe derivee de la classe C...">Cond_lim</a>&amp; la_cl, std::map&lt;<span class="keywordtype">int</span>, std::pair&lt;int, int&gt;&gt;&amp;) <span class="keyword">const</span>;
<a name="l00091"></a>00091   <span class="keyword">const</span> <a class="code" href="classMilieu__base.html" title="classe Milieu_base Cette classe est la base de la hierarchie des milieux (physiques) Elle regroupe le...">Milieu_base</a>&amp; <a class="code" href="classT__It__VDF__Elem.html#add22ff724d5064affef48e034eb26cc6">milieu</a>() <span class="keyword">const</span>;
<a name="l00092"></a><a class="code" href="classT__It__VDF__Elem.html#a1c6facf0ffcf4a16a8d81d090a7fc1e8">00092</a>   <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a> <a class="code" href="classT__It__VDF__Elem.html#a1c6facf0ffcf4a16a8d81d090a7fc1e8">elem</a>;
<a name="l00093"></a><a class="code" href="classT__It__VDF__Elem.html#af07213914efa02ff865b0d3e01020be5">00093</a>   <span class="keyword">mutable</span> <a class="code" href="classSFichier.html" title="Cette classe est a la classe C++ ofstream ce que la classe Sortie est a la classe C++ ostream Elle re...">SFichier</a> <a class="code" href="classT__It__VDF__Elem.html#aa9e60b7897f03897d207b0e976dacb59">Flux</a>, <a class="code" href="classT__It__VDF__Elem.html#a2bdd758add883f6ad6e9029cb1664a32">Flux_moment</a>, <a class="code" href="classT__It__VDF__Elem.html#af07213914efa02ff865b0d3e01020be5">Flux_sum</a>;
<a name="l00094"></a>00094 };
<a name="l00095"></a><a class="code" href="classT__It__VDF__Elem.html#a16a428a0049524394b77439a046b6347">00095</a> <span class="keyword">template</span> &lt;<span class="keyword">class</span> _TYPE_&gt; <span class="keyword">inline</span> <a class="code" href="classT__It__VDF__Elem.html#a0f6e7990b43d9aa236c8883058b327dc">T_It_VDF_Elem&lt;_TYPE_&gt;::T_It_VDF_Elem</a>(<span class="keyword">const</span> <a class="code" href="classT__It__VDF__Elem.html">T_It_VDF_Elem&lt;_TYPE_&gt;</a>&amp; iter)
<a name="l00096"></a>00096   :<a class="code" href="classIterateur__VDF__base.html">Iterateur_VDF_base</a>(iter),
<a name="l00097"></a>00097    flux_evaluateur(iter.flux_evaluateur)
<a name="l00098"></a>00098 {
<a name="l00099"></a>00099   <a class="code" href="classT__It__VDF__Elem.html#a1c6facf0ffcf4a16a8d81d090a7fc1e8">elem</a>.<a class="code" href="classIntTab.html#ae9ae8fefb1fda4a5c035229ab420a96d" title="fait pointer le tableau sur le vecteur v et en associant la meme structure parallele. Attention, si line_size du vecteur v est different de 1, on cree un tableau bidimensionnel (on peut avoir un vecteur de ce type si on copie un Tab dans un Vect puis on prend une ref sur ce Vect).">ref</a>(iter.<a class="code" href="classT__It__VDF__Elem.html#a1c6facf0ffcf4a16a8d81d090a7fc1e8">elem</a>);
<a name="l00100"></a>00100 }
<a name="l00101"></a><a class="code" href="classT__It__VDF__Elem.html#a4937ea2745a85911d44f0d8a0c0b0dcb">00101</a> <span class="keyword">template</span> &lt;<span class="keyword">class</span> _TYPE_&gt; <span class="keyword">inline</span> <a class="code" href="classEvaluateur__VDF.html" title="class Evaluateur_VDF Classe de base des evaluateurs VDF. Cette classe n&#39;appartient pas a la hierarchi...">Evaluateur_VDF</a>&amp; <a class="code" href="classT__It__VDF__Elem.html#a4937ea2745a85911d44f0d8a0c0b0dcb">T_It_VDF_Elem&lt;_TYPE_&gt;::evaluateur</a>()
<a name="l00102"></a>00102 {
<a name="l00103"></a>00103   <a class="code" href="classEvaluateur__VDF.html" title="class Evaluateur_VDF Classe de base des evaluateurs VDF. Cette classe n&#39;appartient pas a la hierarchi...">Evaluateur_VDF</a>&amp; eval = (<a class="code" href="classEvaluateur__VDF.html" title="class Evaluateur_VDF Classe de base des evaluateurs VDF. Cette classe n&#39;appartient pas a la hierarchi...">Evaluateur_VDF</a>&amp;) flux_evaluateur;
<a name="l00104"></a>00104   <span class="keywordflow">return</span> eval;
<a name="l00105"></a>00105 }
<a name="l00106"></a><a class="code" href="classT__It__VDF__Elem.html#a1bc39b8215edd7886446c930aeb9c2e7">00106</a> <span class="keyword">template</span> &lt;<span class="keyword">class</span> _TYPE_&gt; <span class="keyword">inline</span> <span class="keyword">const</span> <a class="code" href="classEvaluateur__VDF.html" title="class Evaluateur_VDF Classe de base des evaluateurs VDF. Cette classe n&#39;appartient pas a la hierarchi...">Evaluateur_VDF</a>&amp; <a class="code" href="classT__It__VDF__Elem.html#a4937ea2745a85911d44f0d8a0c0b0dcb">T_It_VDF_Elem&lt;_TYPE_&gt;::evaluateur</a>()<span class="keyword"> const</span>
<a name="l00107"></a>00107 <span class="keyword"></span>{
<a name="l00108"></a>00108   <a class="code" href="classEvaluateur__VDF.html" title="class Evaluateur_VDF Classe de base des evaluateurs VDF. Cette classe n&#39;appartient pas a la hierarchi...">Evaluateur_VDF</a>&amp; eval = (<a class="code" href="classEvaluateur__VDF.html" title="class Evaluateur_VDF Classe de base des evaluateurs VDF. Cette classe n&#39;appartient pas a la hierarchi...">Evaluateur_VDF</a>&amp;) flux_evaluateur;
<a name="l00109"></a>00109   <span class="keywordflow">return</span> eval;
<a name="l00110"></a>00110 }
<a name="l00111"></a>00111 
<a name="l00112"></a>00112 <span class="comment">/*Sortie&amp; T_It_VDF_Elem&lt;_TYPE_&gt;::printOn(Sortie&amp; s ) const {</span>
<a name="l00113"></a>00113 <span class="comment">    return s &lt;&lt; que_suis_je() ;</span>
<a name="l00114"></a>00114 <span class="comment">  }</span>
<a name="l00115"></a>00115 <span class="comment">  Entree&amp; T_It_VDF_Elem&lt;_TYPE_&gt;::readOn(Entree&amp; s ) {</span>
<a name="l00116"></a>00116 <span class="comment">    return s ;</span>
<a name="l00117"></a>00117 <span class="comment">  }</span>
<a name="l00118"></a>00118 <span class="comment">// Implemente_instanciable(T_It_VDF_Elem&lt;_TYPE_&gt;,&quot;Iterateur_VDF_Elem&quot;,Iterateur_VDF_base);</span>
<a name="l00119"></a>00119 <span class="comment">*/</span>
<a name="l00120"></a><a class="code" href="classT__It__VDF__Elem.html#a1d0df1533727ebd0e9f455f466c82b01">00120</a> <span class="keyword">template</span> &lt;<span class="keyword">class</span> _TYPE_&gt; <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="classT__It__VDF__Elem.html#a1d0df1533727ebd0e9f455f466c82b01">T_It_VDF_Elem&lt;_TYPE_&gt;::completer_</a>()
<a name="l00121"></a>00121 {
<a name="l00122"></a>00122   elem.ref(la_zone-&gt;face_voisins());
<a name="l00123"></a>00123 }
<a name="l00124"></a>00124 <span class="keyword">template</span> &lt;<span class="keyword">class</span> _TYPE_&gt;
<a name="l00125"></a><a class="code" href="classT__It__VDF__Elem.html#add22ff724d5064affef48e034eb26cc6">00125</a> <span class="keyword">const</span> <a class="code" href="classMilieu__base.html" title="classe Milieu_base Cette classe est la base de la hierarchie des milieux (physiques) Elle regroupe le...">Milieu_base</a>&amp; <a class="code" href="classT__It__VDF__Elem.html#add22ff724d5064affef48e034eb26cc6">T_It_VDF_Elem&lt;_TYPE_&gt;::milieu</a>()<span class="keyword"> const</span>
<a name="l00126"></a>00126 <span class="keyword"></span>{
<a name="l00127"></a>00127   <span class="keywordflow">return</span> (la_zcl-&gt;equation()).milieu();
<a name="l00128"></a>00128 }
<a name="l00129"></a>00129 <span class="keyword">template</span> &lt;<span class="keyword">class</span> _TYPE_&gt;
<a name="l00130"></a><a class="code" href="classT__It__VDF__Elem.html#ac8cf5ddb45fc2de559e28ef15e304a07">00130</a> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; <a class="code" href="classT__It__VDF__Elem.html#ac8cf5ddb45fc2de559e28ef15e304a07">T_It_VDF_Elem&lt;_TYPE_&gt;::ajouter</a>(<span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; donne,
<a name="l00131"></a>00131                                           <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; resu)<span class="keyword"> const</span>
<a name="l00132"></a>00132 <span class="keyword"></span>{
<a name="l00133"></a>00133   ((_TYPE_&amp;) flux_evaluateur).mettre_a_jour();
<a name="l00134"></a>00134   assert(donne.<a class="code" href="classDoubleTab.html#ae6dda48778e7107e1beb723beef1f75b" title="Returns the number of dimensions of the array (&gt;= 1)">nb_dim</a>() &lt; 3);
<a name="l00135"></a>00135   assert(la_zcl.non_nul());
<a name="l00136"></a>00136   assert(la_zone.non_nul());
<a name="l00137"></a>00137   <span class="keyword">const</span> <span class="keywordtype">int</span> ncomp = donne.<a class="code" href="classDoubleVect.html#ab02d01cd1bdab66fbd66f9a47cc29e10">line_size</a>();
<a name="l00138"></a>00138   <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; flux_bords=op_base-&gt;flux_bords();
<a name="l00139"></a>00139   flux_bords.<a class="code" href="classDoubleTab.html#ae83b4d31205c53d9c8d2b43da178ce75" title="Change la taille du vecteur (identique a resize_array() pour le traitement des anciennes valeurs et d...">resize</a>(la_zone-&gt;nb_faces_bord(),ncomp);
<a name="l00140"></a>00140   flux_bords=0;
<a name="l00141"></a>00141   <span class="comment">/* modif b.m.: on va faire += sur des items virtuels, initialiser les cases */</span>
<a name="l00142"></a>00142   <span class="comment">/* sinon risque que les cases soient invalides ou non initialisees */</span>
<a name="l00143"></a>00143   {
<a name="l00144"></a>00144     <span class="keywordtype">int</span> n = resu.<a class="code" href="classArrOfDouble.html#a3c3b33bea0e88b87315c21ee94bee05f" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() - resu.<a class="code" href="classDoubleVect.html#a392c1f20b462563365389d28e0853867" title="Identique a size_reelle()">size</a>();
<a name="l00145"></a>00145     <span class="keywordtype">double</span> *data = resu.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() + resu.<a class="code" href="classDoubleVect.html#a392c1f20b462563365389d28e0853867" title="Identique a size_reelle()">size</a>();
<a name="l00146"></a>00146     <span class="keywordflow">for</span> (; n; n--, data++)
<a name="l00147"></a>00147       *data = 0.;
<a name="l00148"></a>00148   }
<a name="l00149"></a>00149   ajouter_bords(donne, resu) ;
<a name="l00150"></a>00150   ajouter_interne(donne, resu) ;
<a name="l00151"></a>00151   modifier_flux() ;
<a name="l00152"></a>00152   <span class="keywordflow">return</span> resu;
<a name="l00153"></a>00153 }
<a name="l00154"></a>00154 
<a name="l00155"></a><a class="code" href="classT__It__VDF__Elem.html#a5648f59099343727831e87ae671e3d8e">00155</a> <span class="keyword">template</span> &lt;<span class="keyword">class</span> _TYPE_&gt;  <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; <a class="code" href="classT__It__VDF__Elem.html#a5648f59099343727831e87ae671e3d8e">T_It_VDF_Elem&lt;_TYPE_&gt;::ajouter_bords</a>(<span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; donnee,
<a name="l00156"></a>00156                                                                          <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; resu)<span class="keyword"> const</span>
<a name="l00157"></a>00157 <span class="keyword"></span>{
<a name="l00158"></a>00158   <span class="keyword">const</span> <span class="keywordtype">int</span> ncomp = resu.<a class="code" href="classDoubleVect.html#ab02d01cd1bdab66fbd66f9a47cc29e10">line_size</a>();
<a name="l00159"></a>00159   <span class="keywordtype">int</span> elem1, elem2;
<a name="l00160"></a>00160   <span class="keywordtype">int</span> ndeb, nfin;
<a name="l00161"></a>00161   <span class="keywordtype">int</span> face,k;
<a name="l00162"></a>00162   <a class="code" href="classDoubleVect.html">DoubleVect</a> flux(ncomp);
<a name="l00163"></a>00163   <span class="keywordtype">int</span> num_cl=0;
<a name="l00164"></a>00164   <span class="keywordtype">int</span> nb_front_Cl=la_zone-&gt;nb_front_Cl();
<a name="l00165"></a>00165   <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; flux_bords=op_base-&gt;flux_bords();
<a name="l00166"></a>00166   <span class="keywordflow">for</span> (; num_cl&lt;nb_front_Cl; num_cl++)
<a name="l00167"></a>00167     {
<a name="l00168"></a>00168       <span class="keyword">const</span> <a class="code" href="classCond__lim.html" title="classe Cond_lim Classe generique servant a representer n&#39;importe quelle classe derivee de la classe C...">Cond_lim</a>&amp; la_cl = la_zcl-&gt;les_conditions_limites(num_cl);
<a name="l00169"></a>00169       <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp; frontiere_dis = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>,la_cl.<a class="code" href="classCond__lim.html#a5b2d24809cee07727006a891d4ce8d22" title="Appel a l&#39;objet sous-jacent Renvoie la frontiere discretisee associee a la condition aux limites...">frontiere_dis</a>());
<a name="l00170"></a>00170       ndeb = frontiere_dis.<a class="code" href="classFront__VF.html#a4986f0c65653fe9eb40bbbff5a97bf16" title="Numero de la premiere face du bord dans la liste des faces.">num_premiere_face</a>();
<a name="l00171"></a>00171       nfin = ndeb + frontiere_dis.<a class="code" href="classFront__VF.html#a341e2fcb5117b96e745fd7078ba86bab" title="Nombre de faces reelles du bord.">nb_faces</a>();
<a name="l00172"></a>00172       <span class="comment">/* Test en bidim axi */</span>
<a name="l00173"></a>00173       <span class="keywordflow">if</span> (bidim_axi &amp;&amp; !<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classSymetrie.html" title="classe Symetrie Sur les faces de symetrie on a les proprietes suivantes: - composante normale de la v...">Symetrie</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>()))
<a name="l00174"></a>00174         {
<a name="l00175"></a>00175           <span class="keywordflow">if</span> (nfin&gt;ndeb &amp;&amp; <a class="code" href="Double_8h.html#ac86f5f350b0f95fd8c34b0ac8d720f6f">est_egal</a>(la_zone.valeur().face_surfaces()[ndeb],0))
<a name="l00176"></a>00176             {
<a name="l00177"></a>00177               <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Error in the definition of the boundary conditions.&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
<a name="l00178"></a>00178               <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;The axis of revolution for this 2D calculation is along Y.&quot;</span> &lt;&lt; finl;
<a name="l00179"></a>00179               <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;So you must specify symmetry boundary condition (symetrie keyword) for the boundary &quot;</span> &lt;&lt; frontiere_dis.<a class="code" href="classFrontiere__dis__base.html#a5a7eb46dc3af8a7d4225adc1814845d8" title="Renvoie le nom de la frontiere geometrique.">le_nom</a>() &lt;&lt; finl;
<a name="l00180"></a>00180               exit();
<a name="l00181"></a>00181             }
<a name="l00182"></a>00182         }
<a name="l00183"></a>00183       <span class="keywordflow">switch</span>(type_cl(la_cl))
<a name="l00184"></a>00184         {
<a name="l00185"></a>00185         <span class="keywordflow">case</span> <a class="code" href="Iterateur__PolyMAC__base_8h.html#adda1d69a86f9e3be7366c5f4c6ace649ac938491055e13993f3eed68c989f90b0" title="Symetrie.">symetrie</a> :
<a name="l00186"></a>00186           <span class="keywordflow">if</span> (flux_evaluateur.calculer_flux_faces_symetrie())
<a name="l00187"></a>00187             {
<a name="l00188"></a>00188               <span class="keyword">const</span> <a class="code" href="classSymetrie.html" title="classe Symetrie Sur les faces de symetrie on a les proprietes suivantes: - composante normale de la v...">Symetrie</a>&amp; cl =(<span class="keyword">const</span> <a class="code" href="classSymetrie.html" title="classe Symetrie Sur les faces de symetrie on a les proprietes suivantes: - composante normale de la v...">Symetrie</a>&amp;) (la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>());
<a name="l00189"></a>00189               <span class="keywordflow">for</span> (face=ndeb; face&lt;nfin; face++)
<a name="l00190"></a>00190                 {
<a name="l00191"></a>00191                   flux_evaluateur.flux_face(donnee, face, cl, ndeb, flux);
<a name="l00192"></a>00192                   <span class="keywordflow">if</span> ( (elem1=elem(face,0)) &gt; -1)
<a name="l00193"></a>00193                     <span class="keywordflow">for</span> (k=0; k&lt;ncomp; k++)
<a name="l00194"></a>00194                       {
<a name="l00195"></a>00195                         resu(elem1,k) +=flux(k);
<a name="l00196"></a>00196                         flux_bords(face,k)+=flux(k);
<a name="l00197"></a>00197                       }
<a name="l00198"></a>00198                   <span class="keywordflow">if</span> ( (elem2=elem(face,1)) &gt; -1)
<a name="l00199"></a>00199                     <span class="keywordflow">for</span> (k=0; k&lt;ncomp; k++)
<a name="l00200"></a>00200                       {
<a name="l00201"></a>00201                         resu(elem2,k) -=flux(k);
<a name="l00202"></a>00202                         flux_bords(face,k)-=flux(k);
<a name="l00203"></a>00203                       }
<a name="l00204"></a>00204                 }
<a name="l00205"></a>00205             }
<a name="l00206"></a>00206           <span class="keywordflow">break</span>;
<a name="l00207"></a>00207         <span class="keywordflow">case</span> <a class="code" href="Iterateur__PolyMAC__base_8h.html#adda1d69a86f9e3be7366c5f4c6ace649ac4317ef27513bbab3cd0ccfd0d9ed199" title="Neumann_sortie_libre ou derivees.">sortie_libre</a> :
<a name="l00208"></a>00208           <span class="keywordflow">if</span> (flux_evaluateur.calculer_flux_faces_sortie_libre())
<a name="l00209"></a>00209             {
<a name="l00210"></a>00210               <span class="keyword">const</span> <a class="code" href="classNeumann__sortie__libre.html" title="classe Neumann_sortie_libre Cette classe represente une frontiere ouverte sans vitesse imposee Pour l...">Neumann_sortie_libre</a>&amp; cl =(<span class="keyword">const</span> <a class="code" href="classNeumann__sortie__libre.html" title="classe Neumann_sortie_libre Cette classe represente une frontiere ouverte sans vitesse imposee Pour l...">Neumann_sortie_libre</a>&amp;) (la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>());
<a name="l00211"></a>00211               <span class="keywordflow">for</span> (face=ndeb; face&lt;nfin; face++)
<a name="l00212"></a>00212                 {
<a name="l00213"></a>00213                   flux_evaluateur.flux_face(donnee, face, cl, ndeb, flux);
<a name="l00214"></a>00214                   <span class="keywordflow">if</span> ( (elem1=elem(face,0)) &gt; -1)
<a name="l00215"></a>00215                     <span class="keywordflow">for</span> (k=0; k&lt;ncomp; k++)
<a name="l00216"></a>00216                       {
<a name="l00217"></a>00217                         resu(elem1,k) +=flux(k);
<a name="l00218"></a>00218                         flux_bords(face,k)+=flux(k);
<a name="l00219"></a>00219                       }
<a name="l00220"></a>00220                   <span class="keywordflow">if</span> ( (elem2=elem(face,1)) &gt; -1)
<a name="l00221"></a>00221                     <span class="keywordflow">for</span> (k=0; k&lt;ncomp; k++)
<a name="l00222"></a>00222                       {
<a name="l00223"></a>00223                         resu(elem2,k) -=flux(k);
<a name="l00224"></a>00224                         flux_bords(face,k)-=flux(k);
<a name="l00225"></a>00225                       }
<a name="l00226"></a>00226                 }
<a name="l00227"></a>00227             }
<a name="l00228"></a>00228           <span class="keywordflow">break</span>;
<a name="l00229"></a>00229         <span class="keywordflow">case</span> <a class="code" href="Iterateur__PolyMAC__base_8h.html#adda1d69a86f9e3be7366c5f4c6ace649a594fd60a4576f47654eed7df53dee9be" title="Dirichlet_entree_fluide.">entree_fluide</a> :
<a name="l00230"></a>00230           <span class="keywordflow">if</span> (flux_evaluateur.calculer_flux_faces_entree_fluide())
<a name="l00231"></a>00231             {
<a name="l00232"></a>00232               <span class="keyword">const</span> <a class="code" href="classDirichlet__entree__fluide.html" title="classe Dirichlet_entree_fluide Cette classe represente une condition aux limite imposant une grandeur...">Dirichlet_entree_fluide</a>&amp; cl =(<span class="keyword">const</span> <a class="code" href="classDirichlet__entree__fluide.html" title="classe Dirichlet_entree_fluide Cette classe represente une condition aux limite imposant une grandeur...">Dirichlet_entree_fluide</a>&amp;) (la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>());
<a name="l00233"></a>00233               <span class="keywordflow">for</span> (face=ndeb; face&lt;nfin; face++)
<a name="l00234"></a>00234                 {
<a name="l00235"></a>00235                   flux_evaluateur.flux_face(donnee, face, cl, ndeb, flux);
<a name="l00236"></a>00236                   <span class="keywordflow">if</span> ( (elem1=elem(face,0)) &gt; -1)
<a name="l00237"></a>00237                     <span class="keywordflow">for</span> (k=0; k&lt;ncomp; k++)
<a name="l00238"></a>00238                       {
<a name="l00239"></a>00239                         resu(elem1,k) +=flux(k);
<a name="l00240"></a>00240                         flux_bords(face,k)+=flux(k);
<a name="l00241"></a>00241                       }
<a name="l00242"></a>00242                   <span class="keywordflow">if</span> ( (elem2=elem(face,1)) &gt; -1)
<a name="l00243"></a>00243                     <span class="keywordflow">for</span> (k=0; k&lt;ncomp; k++)
<a name="l00244"></a>00244                       {
<a name="l00245"></a>00245                         resu(elem2,k) -=flux(k);
<a name="l00246"></a>00246                         flux_bords(face,k)-=flux(k);
<a name="l00247"></a>00247                       }
<a name="l00248"></a>00248                 }
<a name="l00249"></a>00249             }
<a name="l00250"></a>00250           <span class="keywordflow">break</span>;
<a name="l00251"></a>00251         <span class="keywordflow">case</span> <a class="code" href="Iterateur__PolyMAC__base_8h.html#adda1d69a86f9e3be7366c5f4c6ace649a497d92e00f36c1c7ec874c0a318db91e" title="Dirichlet_paroi_fixe.">paroi_fixe</a> :
<a name="l00252"></a>00252           <span class="keywordflow">if</span> (flux_evaluateur.calculer_flux_faces_paroi_fixe())
<a name="l00253"></a>00253             {
<a name="l00254"></a>00254               <span class="keyword">const</span> <a class="code" href="classDirichlet__paroi__fixe.html" title="classe Dirichlet_paroi_fixe Represente une paroi immobile dans une equation de type Navier_Stokes...">Dirichlet_paroi_fixe</a>&amp; cl =(<span class="keyword">const</span> <a class="code" href="classDirichlet__paroi__fixe.html" title="classe Dirichlet_paroi_fixe Represente une paroi immobile dans une equation de type Navier_Stokes...">Dirichlet_paroi_fixe</a>&amp;) (la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>());
<a name="l00255"></a>00255               <span class="keywordflow">for</span> (face=ndeb; face&lt;nfin; face++)
<a name="l00256"></a>00256                 {
<a name="l00257"></a>00257                   flux_evaluateur.flux_face(donnee, face, cl, ndeb, flux);
<a name="l00258"></a>00258                   <span class="keywordflow">if</span> ( (elem1=elem(face,0)) &gt; -1)
<a name="l00259"></a>00259                     <span class="keywordflow">for</span> (k=0; k&lt;ncomp; k++)
<a name="l00260"></a>00260                       {
<a name="l00261"></a>00261                         resu(elem1,k) +=flux(k);
<a name="l00262"></a>00262                         flux_bords(face,k)+=flux(k);
<a name="l00263"></a>00263                       }
<a name="l00264"></a>00264                   <span class="keywordflow">if</span> ( (elem2=elem(face,1)) &gt; -1)
<a name="l00265"></a>00265                     <span class="keywordflow">for</span> (k=0; k&lt;ncomp; k++)
<a name="l00266"></a>00266                       {
<a name="l00267"></a>00267                         resu(elem2,k) -=flux(k);
<a name="l00268"></a>00268                         flux_bords(face,k)-=flux(k);
<a name="l00269"></a>00269                       }
<a name="l00270"></a>00270                 }
<a name="l00271"></a>00271             }
<a name="l00272"></a>00272           <span class="keywordflow">break</span>;
<a name="l00273"></a>00273         <span class="keywordflow">case</span> <a class="code" href="Iterateur__PolyMAC__base_8h.html#adda1d69a86f9e3be7366c5f4c6ace649acdd1bf461cb105b93d5a9b003ce33141" title="Dirichlet_paroi_defilante.">paroi_defilante</a> :
<a name="l00274"></a>00274           <span class="keywordflow">if</span> (flux_evaluateur.calculer_flux_faces_paroi_defilante())
<a name="l00275"></a>00275             {
<a name="l00276"></a>00276               <span class="keyword">const</span> <a class="code" href="classDirichlet__paroi__defilante.html" title="classe Dirichlet_paroi_defilante Impose la vitesse de paroi dnas une equation de type Navier_Stokes...">Dirichlet_paroi_defilante</a>&amp; cl =(<span class="keyword">const</span> <a class="code" href="classDirichlet__paroi__defilante.html" title="classe Dirichlet_paroi_defilante Impose la vitesse de paroi dnas une equation de type Navier_Stokes...">Dirichlet_paroi_defilante</a>&amp;) (la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>());
<a name="l00277"></a>00277               <span class="keywordflow">for</span> (face=ndeb; face&lt;nfin; face++)
<a name="l00278"></a>00278                 {
<a name="l00279"></a>00279                   flux_evaluateur.flux_face(donnee, face, cl, ndeb, flux);
<a name="l00280"></a>00280                   <span class="keywordflow">if</span> ( (elem1=elem(face,0)) &gt; -1)
<a name="l00281"></a>00281                     <span class="keywordflow">for</span> (k=0; k&lt;ncomp; k++)
<a name="l00282"></a>00282                       {
<a name="l00283"></a>00283                         resu(elem1,k) +=flux(k);
<a name="l00284"></a>00284                         flux_bords(face,k)+=flux(k);
<a name="l00285"></a>00285                       }
<a name="l00286"></a>00286                   <span class="keywordflow">if</span> ( (elem2=elem(face,1)) &gt; -1)
<a name="l00287"></a>00287                     <span class="keywordflow">for</span> (k=0; k&lt;ncomp; k++)
<a name="l00288"></a>00288                       {
<a name="l00289"></a>00289                         resu(elem2,k) -=flux(k);
<a name="l00290"></a>00290                         flux_bords(face,k)-=flux(k);
<a name="l00291"></a>00291                       }
<a name="l00292"></a>00292                 }
<a name="l00293"></a>00293             }
<a name="l00294"></a>00294           <span class="keywordflow">break</span>;
<a name="l00295"></a>00295         <span class="keywordflow">case</span> <a class="code" href="classparoi__adiabatique.html">paroi_adiabatique</a> :
<a name="l00296"></a>00296           <span class="keywordflow">if</span> (flux_evaluateur.calculer_flux_faces_paroi_adiabatique())
<a name="l00297"></a>00297             {
<a name="l00298"></a>00298               <span class="keyword">const</span> <a class="code" href="classNeumann__paroi__adiabatique.html" title="Classe Neumann_paroi_adiabatique Cette condition limite correspond a une paroi adiabatique dans une e...">Neumann_paroi_adiabatique</a>&amp; cl =(<span class="keyword">const</span> <a class="code" href="classNeumann__paroi__adiabatique.html" title="Classe Neumann_paroi_adiabatique Cette condition limite correspond a une paroi adiabatique dans une e...">Neumann_paroi_adiabatique</a>&amp;) (la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>());
<a name="l00299"></a>00299               <span class="keywordflow">for</span> (face=ndeb; face&lt;nfin; face++)
<a name="l00300"></a>00300                 {
<a name="l00301"></a>00301                   <span class="comment">/* on initialise elem1 elem2 et on fait planter */</span>
<a name="l00302"></a>00302                   elem1=-1;
<a name="l00303"></a>00303                   elem2=-1;
<a name="l00304"></a>00304                   assert(0);
<a name="l00305"></a>00305                   exit();
<a name="l00306"></a>00306                   flux_evaluateur.flux_face(donnee, face, cl, ndeb, flux);
<a name="l00307"></a>00307                   <span class="keywordflow">if</span> ( (elem1=elem(face,0)) &gt; -1)
<a name="l00308"></a>00308                     <span class="keywordflow">for</span> (k=0; k&lt;ncomp; k++)
<a name="l00309"></a>00309                       {
<a name="l00310"></a>00310                         resu(elem1,k) +=flux(k);
<a name="l00311"></a>00311                         flux_bords(face,k)+=flux(k);
<a name="l00312"></a>00312                       }
<a name="l00313"></a>00313                   <span class="keywordflow">if</span> ( (elem2=elem(face,1)) &gt; -1)
<a name="l00314"></a>00314                     <span class="keywordflow">for</span> (k=0; k&lt;ncomp; k++)
<a name="l00315"></a>00315                       {
<a name="l00316"></a>00316                         resu(elem2,k) -=flux(k);
<a name="l00317"></a>00317                         flux_bords(face,k)-=flux(k);
<a name="l00318"></a>00318                       }
<a name="l00319"></a>00319                 }
<a name="l00320"></a>00320             }
<a name="l00321"></a>00321           <span class="keywordflow">break</span>;
<a name="l00322"></a>00322         <span class="keywordflow">case</span> <a class="code" href="Iterateur__PolyMAC__base_8h.html#adda1d69a86f9e3be7366c5f4c6ace649af695f3ba17490e07dc3259c85875d8d6" title="Neumann_paroi.">paroi</a> :
<a name="l00323"></a>00323           <span class="keywordflow">if</span> (flux_evaluateur.calculer_flux_faces_paroi())
<a name="l00324"></a>00324             {
<a name="l00325"></a>00325               <span class="keyword">const</span> <a class="code" href="classNeumann__paroi.html" title="Classe Neumann_paroi Cette condition limite correspond a un flux impose pour l&#39;equation de transport ...">Neumann_paroi</a>&amp; cl =(<span class="keyword">const</span> <a class="code" href="classNeumann__paroi.html" title="Classe Neumann_paroi Cette condition limite correspond a un flux impose pour l&#39;equation de transport ...">Neumann_paroi</a>&amp;) (la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>());
<a name="l00326"></a>00326               <span class="keywordflow">for</span> (face=ndeb; face&lt;nfin; face++)
<a name="l00327"></a>00327                 {
<a name="l00328"></a>00328                   flux_evaluateur.flux_face(donnee, face, cl, ndeb, flux);
<a name="l00329"></a>00329                   <span class="keywordflow">if</span> ( (elem1=elem(face,0)) &gt; -1)
<a name="l00330"></a>00330                     <span class="keywordflow">for</span> (k=0; k&lt;ncomp; k++)
<a name="l00331"></a>00331                       {
<a name="l00332"></a>00332                         resu(elem1, k)+=flux(k);
<a name="l00333"></a>00333                         flux_bords(face, k)+=flux(k);
<a name="l00334"></a>00334                       }
<a name="l00335"></a>00335                   <span class="keywordflow">if</span> ( (elem2=elem(face,1)) &gt; -1)
<a name="l00336"></a>00336                     <span class="keywordflow">for</span> (k=0; k&lt;ncomp; k++)
<a name="l00337"></a>00337                       {
<a name="l00338"></a>00338                         resu(elem2, k)-=flux(k);
<a name="l00339"></a>00339                         flux_bords(face,k)-=flux(k);
<a name="l00340"></a>00340                       }
<a name="l00341"></a>00341                 }
<a name="l00342"></a>00342             }
<a name="l00343"></a>00343           <span class="keywordflow">break</span>;
<a name="l00344"></a>00344         <span class="keywordflow">case</span> <a class="code" href="Iterateur__PolyMAC__base_8h.html#adda1d69a86f9e3be7366c5f4c6ace649a38f997f881a13a46f2d06012162cf833" title="Echange_externe_impose.">echange_externe_impose</a> :
<a name="l00345"></a>00345           <span class="keywordflow">if</span> (flux_evaluateur.calculer_flux_faces_echange_externe_impose())
<a name="l00346"></a>00346             {
<a name="l00347"></a>00347               <span class="keyword">const</span> <a class="code" href="classEchange__externe__impose.html" title="Classe Echange_externe_impose: Cette classe represente le cas particulier de la classe Echange_impose...">Echange_externe_impose</a>&amp; cl =(<span class="keyword">const</span> <a class="code" href="classEchange__externe__impose.html" title="Classe Echange_externe_impose: Cette classe represente le cas particulier de la classe Echange_impose...">Echange_externe_impose</a>&amp;) (la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>());
<a name="l00348"></a>00348 
<a name="l00349"></a>00349               <span class="keywordtype">int</span> boundary_index=-1;
<a name="l00350"></a>00350               <span class="keywordflow">if</span> (la_zone.valeur().front_VF(num_cl).le_nom() == frontiere_dis.<a class="code" href="classFrontiere__dis__base.html#a5a7eb46dc3af8a7d4225adc1814845d8" title="Renvoie le nom de la frontiere geometrique.">le_nom</a>())
<a name="l00351"></a>00351                 boundary_index=num_cl;
<a name="l00352"></a>00352 
<a name="l00353"></a>00353               <span class="keywordflow">for</span> (face=ndeb; face&lt;nfin; face++)
<a name="l00354"></a>00354                 {
<a name="l00355"></a>00355                   <span class="keywordtype">int</span> local_face=la_zone.valeur().front_VF(boundary_index).num_local_face(face);
<a name="l00356"></a>00356                   flux_evaluateur.flux_face(donnee, boundary_index, face, local_face, cl, ndeb, flux);
<a name="l00357"></a>00357                   <span class="keywordflow">if</span> ( (elem1=elem(face,0)) &gt; -1)
<a name="l00358"></a>00358                     <span class="keywordflow">for</span> (k=0; k&lt;ncomp; k++)
<a name="l00359"></a>00359                       {
<a name="l00360"></a>00360                         resu(elem1,k) +=flux(k);
<a name="l00361"></a>00361                         flux_bords(face,k)+=flux(k);
<a name="l00362"></a>00362                       }
<a name="l00363"></a>00363                   <span class="keywordflow">if</span> ( (elem2=elem(face,1)) &gt; -1)
<a name="l00364"></a>00364                     <span class="keywordflow">for</span> (k=0; k&lt;ncomp; k++)
<a name="l00365"></a>00365                       {
<a name="l00366"></a>00366                         resu(elem2,k) -=flux(k);
<a name="l00367"></a>00367                         flux_bords(face,k)-=flux(k);
<a name="l00368"></a>00368                       }
<a name="l00369"></a>00369                 }
<a name="l00370"></a>00370             }
<a name="l00371"></a>00371           <span class="keywordflow">break</span>;
<a name="l00372"></a>00372         <span class="keywordflow">case</span> <a class="code" href="Iterateur__PolyMAC__base_8h.html#adda1d69a86f9e3be7366c5f4c6ace649a9201b83c6fe44d3928abbe5f73364323" title="Echange_global_impose.">echange_global_impose</a> :
<a name="l00373"></a>00373           <span class="keywordflow">if</span> (flux_evaluateur.calculer_flux_faces_echange_global_impose())
<a name="l00374"></a>00374             {
<a name="l00375"></a>00375               <span class="keyword">const</span> <a class="code" href="classEchange__global__impose.html" title="Classe Echange_global_impose Cette classe represente le cas particulier de la classe Echange_impose_b...">Echange_global_impose</a>&amp; cl =(<span class="keyword">const</span> <a class="code" href="classEchange__global__impose.html" title="Classe Echange_global_impose Cette classe represente le cas particulier de la classe Echange_impose_b...">Echange_global_impose</a>&amp;) (la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>());
<a name="l00376"></a>00376               <span class="keywordflow">for</span> (face=ndeb; face&lt;nfin; face++)
<a name="l00377"></a>00377                 {
<a name="l00378"></a>00378                   flux_evaluateur.flux_face(donnee, face, cl, ndeb, flux);
<a name="l00379"></a>00379                   <span class="keywordflow">if</span> ( (elem1=elem(face,0)) &gt; -1)
<a name="l00380"></a>00380                     <span class="keywordflow">for</span> (k=0; k&lt;ncomp; k++)
<a name="l00381"></a>00381                       {
<a name="l00382"></a>00382                         resu(elem1,k) +=flux(k);
<a name="l00383"></a>00383                         flux_bords(face,k)+=flux(k);
<a name="l00384"></a>00384                       }
<a name="l00385"></a>00385                   <span class="keywordflow">if</span> ( (elem2=elem(face,1)) &gt; -1)
<a name="l00386"></a>00386                     <span class="keywordflow">for</span> (k=0; k&lt;ncomp; k++)
<a name="l00387"></a>00387                       {
<a name="l00388"></a>00388                         resu(elem2,k) -=flux(k);
<a name="l00389"></a>00389                         flux_bords(face,k)-=flux(k);
<a name="l00390"></a>00390                       }
<a name="l00391"></a>00391                 }
<a name="l00392"></a>00392             }
<a name="l00393"></a>00393           <span class="keywordflow">break</span>;
<a name="l00394"></a>00394         <span class="keywordflow">case</span> <a class="code" href="Iterateur__PolyMAC__base_8h.html#adda1d69a86f9e3be7366c5f4c6ace649adbce3cca9532937c741ae3ac77dc2d54" title="NSCBC.">nscbc</a> :
<a name="l00395"></a>00395           <span class="keywordflow">if</span> (flux_evaluateur.calculer_flux_faces_NSCBC())
<a name="l00396"></a>00396             {
<a name="l00397"></a>00397               <span class="keyword">const</span> <a class="code" href="classNSCBC.html" title="classe">NSCBC</a>&amp; cl =(<span class="keyword">const</span> <a class="code" href="classNSCBC.html" title="classe">NSCBC</a>&amp;) (la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>());
<a name="l00398"></a>00398               <span class="keywordflow">for</span> (face=ndeb; face&lt;nfin; face++)
<a name="l00399"></a>00399                 {
<a name="l00400"></a>00400                   assert(ncomp == 1); <span class="comment">//!&lt; codage avec flux en DoubleVect auquel on assigne la valeur de la fonction scalaire (pas de codage vectoriel de nscbc)</span>
<a name="l00401"></a>00401 <span class="comment"></span>                  flux = flux_evaluateur.flux_face(donnee, face, cl, ndeb);
<a name="l00402"></a>00402 <span class="comment">// flux_evaluateur.flux_face(donnee, face, cl, ndeb, flux);</span>
<a name="l00403"></a>00403                   <span class="keywordflow">if</span> ( (elem1=elem(face,0)) &gt; -1)
<a name="l00404"></a>00404                     <span class="keywordflow">for</span> (k=0; k&lt;ncomp; k++)
<a name="l00405"></a>00405                       {
<a name="l00406"></a>00406                         resu(elem1,k) +=flux(k);
<a name="l00407"></a>00407                         flux_bords(face,k)+=flux(k);
<a name="l00408"></a>00408                       }
<a name="l00409"></a>00409                   <span class="keywordflow">if</span> ( (elem2=elem(face,1)) &gt; -1)
<a name="l00410"></a>00410                     <span class="keywordflow">for</span> (k=0; k&lt;ncomp; k++)
<a name="l00411"></a>00411                       {
<a name="l00412"></a>00412                         resu(elem2,k) -=flux(k);
<a name="l00413"></a>00413                         flux_bords(face,k)-=flux(k);
<a name="l00414"></a>00414                       }
<a name="l00415"></a>00415                 }
<a name="l00416"></a>00416             }
<a name="l00417"></a>00417           <span class="keywordflow">break</span>;
<a name="l00418"></a>00418         <span class="keywordflow">case</span> <a class="code" href="Iterateur__PolyMAC__base_8h.html#adda1d69a86f9e3be7366c5f4c6ace649ab83c671c148d8664c5c87f343d2ab9fd" title="periodique">periodique</a> :
<a name="l00419"></a>00419           <span class="keywordflow">if</span> (flux_evaluateur.calculer_flux_faces_periodique())
<a name="l00420"></a>00420             {
<a name="l00421"></a>00421               <span class="keyword">const</span> <a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>&amp; cl =(<span class="keyword">const</span> <a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>&amp;) (la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>());
<a name="l00422"></a>00422               <span class="keywordflow">for</span> (face=ndeb; face&lt;nfin; face++)
<a name="l00423"></a>00423                 {
<a name="l00424"></a>00424                   flux_evaluateur.flux_face(donnee, face, cl, ndeb, flux);
<a name="l00425"></a>00425                   <span class="keywordflow">if</span> ( (elem1=elem(face,0)) &gt; -1)
<a name="l00426"></a>00426                     <span class="keywordflow">for</span> (k=0; k&lt;ncomp; k++)
<a name="l00427"></a>00427                       {
<a name="l00428"></a>00428                         resu(elem1,k) +=0.5*flux(k);
<a name="l00429"></a>00429                         <span class="keywordflow">if</span> ( face &lt; (ndeb+frontiere_dis.<a class="code" href="classFront__VF.html#a341e2fcb5117b96e745fd7078ba86bab" title="Nombre de faces reelles du bord.">nb_faces</a>()/2) )
<a name="l00430"></a>00430                           flux_bords(face,k)+=flux(k);
<a name="l00431"></a>00431                       }
<a name="l00432"></a>00432                   <span class="keywordflow">if</span> ( (elem2=elem(face,1)) &gt; -1)
<a name="l00433"></a>00433                     <span class="keywordflow">for</span> (k=0; k&lt;ncomp; k++)
<a name="l00434"></a>00434                       {
<a name="l00435"></a>00435                         resu(elem2,k) -=0.5*flux(k);
<a name="l00436"></a>00436                         <span class="keywordflow">if</span> ( (ndeb+frontiere_dis.<a class="code" href="classFront__VF.html#a341e2fcb5117b96e745fd7078ba86bab" title="Nombre de faces reelles du bord.">nb_faces</a>()/2) &lt;= face )
<a name="l00437"></a>00437                           flux_bords(face,k)-=flux(k);
<a name="l00438"></a>00438                       }
<a name="l00439"></a>00439                 }
<a name="l00440"></a>00440             }
<a name="l00441"></a>00441           <span class="keywordflow">break</span>;
<a name="l00442"></a>00442           <span class="comment">/*</span>
<a name="l00443"></a>00443 <span class="comment">                                                                            case nouvelle_Cl_VDF :</span>
<a name="l00444"></a>00444 <span class="comment">                                                                            if (flux_evaluateur.calculer_flux_faces_echange_global_impose()){</span>
<a name="l00445"></a>00445 <span class="comment">                                                                            const Nouvelle_Cl_VDF&amp; cl =(const Nouvelle_Cl_VDF&amp;) (la_cl.valeur());</span>
<a name="l00446"></a>00446 <span class="comment">                                                                            for (face=ndeb; face&lt;nfin; face++) {</span>
<a name="l00447"></a>00447 <span class="comment">                                                                            flux_evaluateur.flux_face(donnee, face, cl, ndeb, flux);</span>
<a name="l00448"></a>00448 <span class="comment">                                                                            if ( (elem1=elem(face,0)) &gt; -1)</span>
<a name="l00449"></a>00449 <span class="comment">                                                                            for (k=0; k&lt;ncomp; k++)</span>
<a name="l00450"></a>00450 <span class="comment">                                                                            resu(elem1,k) +=flux(k);</span>
<a name="l00451"></a>00451 <span class="comment">                                                                            if ( (elem2=elem(face,1)) &gt; -1)</span>
<a name="l00452"></a>00452 <span class="comment">                                                                            for (k=0; k&lt;ncomp; k++)</span>
<a name="l00453"></a>00453 <span class="comment">                                                                            resu(elem2,k) -=flux(k);</span>
<a name="l00454"></a>00454 <span class="comment">                                                                            }</span>
<a name="l00455"></a>00455 <span class="comment">                                                                            }</span>
<a name="l00456"></a>00456 <span class="comment">                                                                            break;</span>
<a name="l00457"></a>00457 <span class="comment">          */</span>
<a name="l00458"></a>00458         <span class="keywordflow">default</span> :
<a name="l00459"></a>00459           <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;On ne reconnait pas la condition limite : &quot;</span> &lt;&lt; la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>();
<a name="l00460"></a>00460           exit();
<a name="l00461"></a>00461           <span class="keywordflow">break</span>;
<a name="l00462"></a>00462         }
<a name="l00463"></a>00463     }
<a name="l00464"></a>00464   <span class="keywordflow">return</span> resu;
<a name="l00465"></a>00465 }
<a name="l00466"></a>00466 
<a name="l00467"></a><a class="code" href="classT__It__VDF__Elem.html#a854af77a4cce0e2deeff69f4bce88c21">00467</a> <span class="keyword">template</span> &lt;<span class="keyword">class</span> _TYPE_&gt;  <span class="keywordtype">void</span> <a class="code" href="classT__It__VDF__Elem.html#a854af77a4cce0e2deeff69f4bce88c21">T_It_VDF_Elem&lt;_TYPE_&gt;::calculer_flux_bord</a>(<span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; donnee)<span class="keyword"> const</span>
<a name="l00468"></a>00468 <span class="keyword"></span>{
<a name="l00469"></a>00469   ((_TYPE_&amp;) flux_evaluateur).mettre_a_jour();
<a name="l00470"></a>00470   assert(donnee.<a class="code" href="classDoubleTab.html#ae6dda48778e7107e1beb723beef1f75b" title="Returns the number of dimensions of the array (&gt;= 1)">nb_dim</a>() &lt; 3);
<a name="l00471"></a>00471   assert(la_zcl.non_nul());
<a name="l00472"></a>00472   assert(la_zone.non_nul());
<a name="l00473"></a>00473   <span class="keyword">const</span> <span class="keywordtype">int</span> ncomp = donnee.<a class="code" href="classDoubleVect.html#ab02d01cd1bdab66fbd66f9a47cc29e10">line_size</a>();
<a name="l00474"></a>00474   <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; flux_bords=op_base-&gt;flux_bords();
<a name="l00475"></a>00475   flux_bords.<a class="code" href="classDoubleTab.html#ae83b4d31205c53d9c8d2b43da178ce75" title="Change la taille du vecteur (identique a resize_array() pour le traitement des anciennes valeurs et d...">resize</a>(la_zone-&gt;nb_faces_bord(),ncomp);
<a name="l00476"></a>00476   flux_bords=0;
<a name="l00477"></a>00477 
<a name="l00478"></a>00478   <span class="keywordflow">if</span>( ncomp != 1) <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">Process ::exit</a>();<span class="comment">/* cas scalaire */</span>
<a name="l00479"></a>00479 
<a name="l00480"></a>00480 
<a name="l00481"></a>00481   <span class="keywordtype">int</span> ndeb, nfin;
<a name="l00482"></a>00482   <span class="keywordtype">int</span> face;
<a name="l00483"></a>00483   <span class="keywordtype">int</span> num_cl=0;
<a name="l00484"></a>00484   <span class="keywordtype">double</span> flux;
<a name="l00485"></a>00485   <span class="keywordtype">int</span> nb_front_Cl=la_zone-&gt;nb_front_Cl();
<a name="l00486"></a>00486   <span class="keywordflow">for</span> (; num_cl&lt;nb_front_Cl; num_cl++)
<a name="l00487"></a>00487     {
<a name="l00488"></a>00488       <span class="comment">/* pour chaque Condition Limite on regarde son type */</span>
<a name="l00489"></a>00489       <span class="keyword">const</span> <a class="code" href="classCond__lim.html" title="classe Cond_lim Classe generique servant a representer n&#39;importe quelle classe derivee de la classe C...">Cond_lim</a>&amp; la_cl = la_zcl-&gt;les_conditions_limites(num_cl);
<a name="l00490"></a>00490       <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp; frontiere_dis = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>,la_cl.<a class="code" href="classCond__lim.html#a5b2d24809cee07727006a891d4ce8d22" title="Appel a l&#39;objet sous-jacent Renvoie la frontiere discretisee associee a la condition aux limites...">frontiere_dis</a>());
<a name="l00491"></a>00491       ndeb = frontiere_dis.<a class="code" href="classFront__VF.html#a4986f0c65653fe9eb40bbbff5a97bf16" title="Numero de la premiere face du bord dans la liste des faces.">num_premiere_face</a>();
<a name="l00492"></a>00492       nfin = ndeb + frontiere_dis.<a class="code" href="classFront__VF.html#a341e2fcb5117b96e745fd7078ba86bab" title="Nombre de faces reelles du bord.">nb_faces</a>();
<a name="l00493"></a>00493       <span class="comment">/* Test en bidim axi */</span>
<a name="l00494"></a>00494       <span class="keywordflow">if</span> (bidim_axi &amp;&amp; !<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classSymetrie.html" title="classe Symetrie Sur les faces de symetrie on a les proprietes suivantes: - composante normale de la v...">Symetrie</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>()))
<a name="l00495"></a>00495         {
<a name="l00496"></a>00496           <span class="keywordflow">if</span> (nfin&gt;ndeb &amp;&amp; <a class="code" href="Double_8h.html#ac86f5f350b0f95fd8c34b0ac8d720f6f">est_egal</a>(la_zone.valeur().face_surfaces()[ndeb],0))
<a name="l00497"></a>00497             {
<a name="l00498"></a>00498               <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Error in the definition of the boundary conditions.&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
<a name="l00499"></a>00499               <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;The axis of revolution for this 2D calculation is along Y.&quot;</span> &lt;&lt; finl;
<a name="l00500"></a>00500               <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;So you must specify symmetry boundary condition (symetrie keyword) for the boundary &quot;</span> &lt;&lt; frontiere_dis.<a class="code" href="classFrontiere__dis__base.html#a5a7eb46dc3af8a7d4225adc1814845d8" title="Renvoie le nom de la frontiere geometrique.">le_nom</a>() &lt;&lt; finl;
<a name="l00501"></a>00501               exit();
<a name="l00502"></a>00502             }
<a name="l00503"></a>00503         }
<a name="l00504"></a>00504       <span class="keywordflow">switch</span>(type_cl(la_cl))
<a name="l00505"></a>00505         {
<a name="l00506"></a>00506         <span class="keywordflow">case</span> <a class="code" href="Iterateur__PolyMAC__base_8h.html#adda1d69a86f9e3be7366c5f4c6ace649ac938491055e13993f3eed68c989f90b0" title="Symetrie.">symetrie</a> :
<a name="l00507"></a>00507           <span class="keywordflow">if</span> (flux_evaluateur.calculer_flux_faces_symetrie())
<a name="l00508"></a>00508             {
<a name="l00509"></a>00509               <span class="keyword">const</span> <a class="code" href="classSymetrie.html" title="classe Symetrie Sur les faces de symetrie on a les proprietes suivantes: - composante normale de la v...">Symetrie</a>&amp; cl =(<span class="keyword">const</span> <a class="code" href="classSymetrie.html" title="classe Symetrie Sur les faces de symetrie on a les proprietes suivantes: - composante normale de la v...">Symetrie</a>&amp;) (la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>());
<a name="l00510"></a>00510               <span class="keywordflow">for</span> (face=ndeb; face&lt;nfin; face++)
<a name="l00511"></a>00511                 {
<a name="l00512"></a>00512                   flux = flux_evaluateur.flux_face(donnee, face, cl, ndeb);
<a name="l00513"></a>00513                   <span class="keywordflow">if</span> ( (elem(face,0)) &gt; -1)
<a name="l00514"></a>00514                     {
<a name="l00515"></a>00515                       flux_bords(face,0)+=flux;
<a name="l00516"></a>00516                     }
<a name="l00517"></a>00517                   <span class="keywordflow">if</span> ( (elem(face,1)) &gt; -1)
<a name="l00518"></a>00518                     {
<a name="l00519"></a>00519                       flux_bords(face,0)-=flux;
<a name="l00520"></a>00520                     }
<a name="l00521"></a>00521                 }
<a name="l00522"></a>00522             }
<a name="l00523"></a>00523           <span class="keywordflow">break</span>;
<a name="l00524"></a>00524         <span class="keywordflow">case</span> <a class="code" href="Iterateur__PolyMAC__base_8h.html#adda1d69a86f9e3be7366c5f4c6ace649ac4317ef27513bbab3cd0ccfd0d9ed199" title="Neumann_sortie_libre ou derivees.">sortie_libre</a> :
<a name="l00525"></a>00525           <span class="keywordflow">if</span> (flux_evaluateur.calculer_flux_faces_sortie_libre())
<a name="l00526"></a>00526             {
<a name="l00527"></a>00527               <span class="keyword">const</span> <a class="code" href="classNeumann__sortie__libre.html" title="classe Neumann_sortie_libre Cette classe represente une frontiere ouverte sans vitesse imposee Pour l...">Neumann_sortie_libre</a>&amp; cl =(<span class="keyword">const</span> <a class="code" href="classNeumann__sortie__libre.html" title="classe Neumann_sortie_libre Cette classe represente une frontiere ouverte sans vitesse imposee Pour l...">Neumann_sortie_libre</a>&amp;) (la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>());
<a name="l00528"></a>00528               <span class="keywordflow">for</span> (face=ndeb; face&lt;nfin; face++)
<a name="l00529"></a>00529                 {
<a name="l00530"></a>00530                   flux = flux_evaluateur.flux_face(donnee, face, cl, ndeb);
<a name="l00531"></a>00531                   <span class="keywordflow">if</span> ( (elem(face,0)) &gt; -1)
<a name="l00532"></a>00532                     {
<a name="l00533"></a>00533                       flux_bords(face,0)+=flux;
<a name="l00534"></a>00534                     }
<a name="l00535"></a>00535                   <span class="keywordflow">if</span> ( (elem(face,1)) &gt; -1)
<a name="l00536"></a>00536                     {
<a name="l00537"></a>00537                       flux_bords(face,0)-=flux;
<a name="l00538"></a>00538                     }
<a name="l00539"></a>00539                 }
<a name="l00540"></a>00540             }
<a name="l00541"></a>00541           <span class="keywordflow">break</span>;
<a name="l00542"></a>00542         <span class="keywordflow">case</span> <a class="code" href="Iterateur__PolyMAC__base_8h.html#adda1d69a86f9e3be7366c5f4c6ace649a594fd60a4576f47654eed7df53dee9be" title="Dirichlet_entree_fluide.">entree_fluide</a> :
<a name="l00543"></a>00543           <span class="keywordflow">if</span> (flux_evaluateur.calculer_flux_faces_entree_fluide())
<a name="l00544"></a>00544             {
<a name="l00545"></a>00545               <span class="keyword">const</span> <a class="code" href="classDirichlet__entree__fluide.html" title="classe Dirichlet_entree_fluide Cette classe represente une condition aux limite imposant une grandeur...">Dirichlet_entree_fluide</a>&amp; cl =(<span class="keyword">const</span> <a class="code" href="classDirichlet__entree__fluide.html" title="classe Dirichlet_entree_fluide Cette classe represente une condition aux limite imposant une grandeur...">Dirichlet_entree_fluide</a>&amp;) (la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>());
<a name="l00546"></a>00546               <span class="keywordflow">for</span> (face=ndeb; face&lt;nfin; face++)
<a name="l00547"></a>00547                 {
<a name="l00548"></a>00548                   flux = flux_evaluateur.flux_face(donnee, face, cl, ndeb);
<a name="l00549"></a>00549                   <span class="keywordflow">if</span> ( (elem(face,0)) &gt; -1)
<a name="l00550"></a>00550                     {
<a name="l00551"></a>00551                       flux_bords(face,0)+=flux;
<a name="l00552"></a>00552                     }
<a name="l00553"></a>00553                   <span class="keywordflow">if</span> ( (elem(face,1)) &gt; -1)
<a name="l00554"></a>00554                     {
<a name="l00555"></a>00555                       flux_bords(face,0)-=flux;
<a name="l00556"></a>00556                     }
<a name="l00557"></a>00557                 }
<a name="l00558"></a>00558             }
<a name="l00559"></a>00559           <span class="keywordflow">break</span>;
<a name="l00560"></a>00560         <span class="keywordflow">case</span> <a class="code" href="Iterateur__PolyMAC__base_8h.html#adda1d69a86f9e3be7366c5f4c6ace649a497d92e00f36c1c7ec874c0a318db91e" title="Dirichlet_paroi_fixe.">paroi_fixe</a> :
<a name="l00561"></a>00561           <span class="keywordflow">if</span> (flux_evaluateur.calculer_flux_faces_paroi_fixe())
<a name="l00562"></a>00562             {
<a name="l00563"></a>00563               <span class="keyword">const</span> <a class="code" href="classDirichlet__paroi__fixe.html" title="classe Dirichlet_paroi_fixe Represente une paroi immobile dans une equation de type Navier_Stokes...">Dirichlet_paroi_fixe</a>&amp; cl =(<span class="keyword">const</span> <a class="code" href="classDirichlet__paroi__fixe.html" title="classe Dirichlet_paroi_fixe Represente une paroi immobile dans une equation de type Navier_Stokes...">Dirichlet_paroi_fixe</a>&amp;) (la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>());
<a name="l00564"></a>00564               <span class="keywordflow">for</span> (face=ndeb; face&lt;nfin; face++)
<a name="l00565"></a>00565                 {
<a name="l00566"></a>00566                   flux = flux_evaluateur.flux_face(donnee, face, cl, ndeb);
<a name="l00567"></a>00567                   <span class="keywordflow">if</span> ( (elem(face,0)) &gt; -1)
<a name="l00568"></a>00568                     {
<a name="l00569"></a>00569                       flux_bords(face,0)+=flux;
<a name="l00570"></a>00570                     }
<a name="l00571"></a>00571                   <span class="keywordflow">if</span> ( (elem(face,1)) &gt; -1)
<a name="l00572"></a>00572                     {
<a name="l00573"></a>00573                       flux_bords(face,0)-=flux;
<a name="l00574"></a>00574                     }
<a name="l00575"></a>00575                 }
<a name="l00576"></a>00576             }
<a name="l00577"></a>00577           <span class="keywordflow">break</span>;
<a name="l00578"></a>00578         <span class="keywordflow">case</span> <a class="code" href="Iterateur__PolyMAC__base_8h.html#adda1d69a86f9e3be7366c5f4c6ace649acdd1bf461cb105b93d5a9b003ce33141" title="Dirichlet_paroi_defilante.">paroi_defilante</a> :
<a name="l00579"></a>00579           <span class="keywordflow">if</span> (flux_evaluateur.calculer_flux_faces_paroi_defilante())
<a name="l00580"></a>00580             {
<a name="l00581"></a>00581               <span class="keyword">const</span> <a class="code" href="classDirichlet__paroi__defilante.html" title="classe Dirichlet_paroi_defilante Impose la vitesse de paroi dnas une equation de type Navier_Stokes...">Dirichlet_paroi_defilante</a>&amp; cl =(<span class="keyword">const</span> <a class="code" href="classDirichlet__paroi__defilante.html" title="classe Dirichlet_paroi_defilante Impose la vitesse de paroi dnas une equation de type Navier_Stokes...">Dirichlet_paroi_defilante</a>&amp;) (la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>());
<a name="l00582"></a>00582               <span class="keywordflow">for</span> (face=ndeb; face&lt;nfin; face++)
<a name="l00583"></a>00583                 {
<a name="l00584"></a>00584                   flux = flux_evaluateur.flux_face(donnee, face, cl, ndeb);
<a name="l00585"></a>00585                   <span class="keywordflow">if</span> ( (elem(face,0)) &gt; -1)
<a name="l00586"></a>00586                     {
<a name="l00587"></a>00587                       flux_bords(face,0)+=flux;
<a name="l00588"></a>00588                     }
<a name="l00589"></a>00589                   <span class="keywordflow">if</span> ( (elem(face,1)) &gt; -1)
<a name="l00590"></a>00590                     {
<a name="l00591"></a>00591                       flux_bords(face,0)-=flux;
<a name="l00592"></a>00592                     }
<a name="l00593"></a>00593                 }
<a name="l00594"></a>00594             }
<a name="l00595"></a>00595           <span class="keywordflow">break</span>;
<a name="l00596"></a>00596         <span class="keywordflow">case</span> <a class="code" href="classparoi__adiabatique.html">paroi_adiabatique</a> :
<a name="l00597"></a>00597           <span class="keywordflow">if</span> (flux_evaluateur.calculer_flux_faces_paroi_adiabatique())
<a name="l00598"></a>00598             {
<a name="l00599"></a>00599               <span class="keyword">const</span> <a class="code" href="classNeumann__paroi__adiabatique.html" title="Classe Neumann_paroi_adiabatique Cette condition limite correspond a une paroi adiabatique dans une e...">Neumann_paroi_adiabatique</a>&amp; cl =(<span class="keyword">const</span> <a class="code" href="classNeumann__paroi__adiabatique.html" title="Classe Neumann_paroi_adiabatique Cette condition limite correspond a une paroi adiabatique dans une e...">Neumann_paroi_adiabatique</a>&amp;) (la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>());
<a name="l00600"></a>00600               <span class="keywordflow">for</span> (face=ndeb; face&lt;nfin; face++)
<a name="l00601"></a>00601                 {
<a name="l00602"></a>00602                   assert(0);
<a name="l00603"></a>00603                   exit();
<a name="l00604"></a>00604                   flux = flux_evaluateur.flux_face(donnee, face, cl, ndeb);
<a name="l00605"></a>00605                   flux_bords(face,0)+=flux;
<a name="l00606"></a>00606                   flux_bords(face,0)-=flux;
<a name="l00607"></a>00607                 }
<a name="l00608"></a>00608             }
<a name="l00609"></a>00609           <span class="keywordflow">break</span>;
<a name="l00610"></a>00610         <span class="keywordflow">case</span> <a class="code" href="Iterateur__PolyMAC__base_8h.html#adda1d69a86f9e3be7366c5f4c6ace649af695f3ba17490e07dc3259c85875d8d6" title="Neumann_paroi.">paroi</a> :
<a name="l00611"></a>00611           <span class="keywordflow">if</span> (flux_evaluateur.calculer_flux_faces_paroi())
<a name="l00612"></a>00612             {
<a name="l00613"></a>00613               <span class="keyword">const</span> <a class="code" href="classNeumann__paroi.html" title="Classe Neumann_paroi Cette condition limite correspond a un flux impose pour l&#39;equation de transport ...">Neumann_paroi</a>&amp; cl =(<span class="keyword">const</span> <a class="code" href="classNeumann__paroi.html" title="Classe Neumann_paroi Cette condition limite correspond a un flux impose pour l&#39;equation de transport ...">Neumann_paroi</a>&amp;) (la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>());
<a name="l00614"></a>00614               <span class="keywordflow">for</span> (face=ndeb; face&lt;nfin; face++)
<a name="l00615"></a>00615                 {
<a name="l00616"></a>00616                   flux = flux_evaluateur.flux_face(donnee, face, cl, ndeb);
<a name="l00617"></a>00617                   <span class="keywordflow">if</span> ( (elem(face,0)) &gt; -1)
<a name="l00618"></a>00618                     {
<a name="l00619"></a>00619                       flux_bords(face,0)+=flux;
<a name="l00620"></a>00620                     }
<a name="l00621"></a>00621                   <span class="keywordflow">if</span> ( (elem(face,1)) &gt; -1)
<a name="l00622"></a>00622                     {
<a name="l00623"></a>00623                       flux_bords(face,0)-=flux;
<a name="l00624"></a>00624                     }
<a name="l00625"></a>00625                 }
<a name="l00626"></a>00626             }
<a name="l00627"></a>00627           <span class="keywordflow">break</span>;
<a name="l00628"></a>00628         <span class="keywordflow">case</span> <a class="code" href="Iterateur__PolyMAC__base_8h.html#adda1d69a86f9e3be7366c5f4c6ace649a38f997f881a13a46f2d06012162cf833" title="Echange_externe_impose.">echange_externe_impose</a> :
<a name="l00629"></a>00629           <span class="keywordflow">if</span> (flux_evaluateur.calculer_flux_faces_echange_externe_impose())
<a name="l00630"></a>00630             {
<a name="l00631"></a>00631               <span class="keyword">const</span> <a class="code" href="classEchange__externe__impose.html" title="Classe Echange_externe_impose: Cette classe represente le cas particulier de la classe Echange_impose...">Echange_externe_impose</a>&amp; cl =(<span class="keyword">const</span> <a class="code" href="classEchange__externe__impose.html" title="Classe Echange_externe_impose: Cette classe represente le cas particulier de la classe Echange_impose...">Echange_externe_impose</a>&amp;) (la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>());
<a name="l00632"></a>00632 
<a name="l00633"></a>00633               <span class="keywordtype">int</span> boundary_index=-1;
<a name="l00634"></a>00634               <span class="keywordflow">if</span> (la_zone.valeur().front_VF(num_cl).le_nom() == frontiere_dis.<a class="code" href="classFrontiere__dis__base.html#a5a7eb46dc3af8a7d4225adc1814845d8" title="Renvoie le nom de la frontiere geometrique.">le_nom</a>())
<a name="l00635"></a>00635                 boundary_index=num_cl;
<a name="l00636"></a>00636 
<a name="l00637"></a>00637               <span class="keywordflow">for</span> (face=ndeb; face&lt;nfin; face++)
<a name="l00638"></a>00638                 {
<a name="l00639"></a>00639                   <span class="keywordtype">int</span> local_face=la_zone.valeur().front_VF(boundary_index).num_local_face(face);
<a name="l00640"></a>00640                   flux = flux_evaluateur.flux_face(donnee, boundary_index,face,local_face, cl, ndeb);
<a name="l00641"></a>00641                   <span class="keywordflow">if</span> ( (elem(face,0)) &gt; -1)
<a name="l00642"></a>00642                     {
<a name="l00643"></a>00643                       flux_bords(face,0)+=flux;
<a name="l00644"></a>00644                     }
<a name="l00645"></a>00645                   <span class="keywordflow">if</span> ( (elem(face,1)) &gt; -1)
<a name="l00646"></a>00646                     {
<a name="l00647"></a>00647                       flux_bords(face,0)-=flux;
<a name="l00648"></a>00648                     }
<a name="l00649"></a>00649                 }
<a name="l00650"></a>00650             }
<a name="l00651"></a>00651           <span class="keywordflow">break</span>;
<a name="l00652"></a>00652         <span class="keywordflow">case</span> <a class="code" href="Iterateur__PolyMAC__base_8h.html#adda1d69a86f9e3be7366c5f4c6ace649a9201b83c6fe44d3928abbe5f73364323" title="Echange_global_impose.">echange_global_impose</a> :
<a name="l00653"></a>00653           <span class="keywordflow">if</span> (flux_evaluateur.calculer_flux_faces_echange_global_impose())
<a name="l00654"></a>00654             {
<a name="l00655"></a>00655               <span class="keyword">const</span> <a class="code" href="classEchange__global__impose.html" title="Classe Echange_global_impose Cette classe represente le cas particulier de la classe Echange_impose_b...">Echange_global_impose</a>&amp; cl =(<span class="keyword">const</span> <a class="code" href="classEchange__global__impose.html" title="Classe Echange_global_impose Cette classe represente le cas particulier de la classe Echange_impose_b...">Echange_global_impose</a>&amp;) (la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>());
<a name="l00656"></a>00656               <span class="keywordflow">for</span> (face=ndeb; face&lt;nfin; face++)
<a name="l00657"></a>00657                 {
<a name="l00658"></a>00658                   flux = flux_evaluateur.flux_face(donnee, face, cl, ndeb);
<a name="l00659"></a>00659                   <span class="keywordflow">if</span> ( (elem(face,0)) &gt; -1)
<a name="l00660"></a>00660                     {
<a name="l00661"></a>00661                       flux_bords(face,0)+=flux;
<a name="l00662"></a>00662                     }
<a name="l00663"></a>00663                   <span class="keywordflow">if</span> ( (elem(face,1)) &gt; -1)
<a name="l00664"></a>00664                     {
<a name="l00665"></a>00665                       flux_bords(face,0)-=flux;
<a name="l00666"></a>00666                     }
<a name="l00667"></a>00667                 }
<a name="l00668"></a>00668             }
<a name="l00669"></a>00669           <span class="keywordflow">break</span>;
<a name="l00670"></a>00670         <span class="keywordflow">case</span> <a class="code" href="Iterateur__PolyMAC__base_8h.html#adda1d69a86f9e3be7366c5f4c6ace649adbce3cca9532937c741ae3ac77dc2d54" title="NSCBC.">nscbc</a> :
<a name="l00671"></a>00671           <span class="keywordflow">if</span> (flux_evaluateur.calculer_flux_faces_NSCBC())
<a name="l00672"></a>00672             {
<a name="l00673"></a>00673               <span class="keyword">const</span> <a class="code" href="classNSCBC.html" title="classe">NSCBC</a>&amp; cl =(<span class="keyword">const</span> <a class="code" href="classNSCBC.html" title="classe">NSCBC</a>&amp;) (la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>());
<a name="l00674"></a>00674               <span class="keywordflow">for</span> (face=ndeb; face&lt;nfin; face++)
<a name="l00675"></a>00675                 {
<a name="l00676"></a>00676                   flux = flux_evaluateur.flux_face(donnee, face, cl, ndeb);
<a name="l00677"></a>00677                   <span class="keywordflow">if</span> ( (elem(face,0)) &gt; -1)
<a name="l00678"></a>00678                     {
<a name="l00679"></a>00679                       flux_bords(face,0)+=flux;
<a name="l00680"></a>00680                     }
<a name="l00681"></a>00681                   <span class="keywordflow">if</span> ( (elem(face,1)) &gt; -1)
<a name="l00682"></a>00682                     {
<a name="l00683"></a>00683                       flux_bords(face,0)-=flux;
<a name="l00684"></a>00684                     }
<a name="l00685"></a>00685                 }
<a name="l00686"></a>00686             }
<a name="l00687"></a>00687           <span class="keywordflow">break</span>;
<a name="l00688"></a>00688         <span class="keywordflow">case</span> <a class="code" href="Iterateur__PolyMAC__base_8h.html#adda1d69a86f9e3be7366c5f4c6ace649ab83c671c148d8664c5c87f343d2ab9fd" title="periodique">periodique</a> :
<a name="l00689"></a>00689           <span class="keywordflow">if</span> (flux_evaluateur.calculer_flux_faces_periodique())
<a name="l00690"></a>00690             {
<a name="l00691"></a>00691               <span class="keyword">const</span> <a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>&amp; cl =(<span class="keyword">const</span> <a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>&amp;) (la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>());
<a name="l00692"></a>00692               <span class="keywordflow">for</span> (face=ndeb; face&lt;nfin; face++)
<a name="l00693"></a>00693                 {
<a name="l00694"></a>00694                   flux = flux_evaluateur.flux_face(donnee, face, cl, ndeb);
<a name="l00695"></a>00695                   <span class="keywordflow">if</span> ( (elem(face,0)) &gt; -1)
<a name="l00696"></a>00696                     {
<a name="l00697"></a>00697                       <span class="keywordflow">if</span> ( face &lt; (ndeb+frontiere_dis.<a class="code" href="classFront__VF.html#a341e2fcb5117b96e745fd7078ba86bab" title="Nombre de faces reelles du bord.">nb_faces</a>()/2) )
<a name="l00698"></a>00698                         flux_bords(face,0)+=flux;
<a name="l00699"></a>00699                     }
<a name="l00700"></a>00700                   <span class="keywordflow">if</span> ( (elem(face,1)) &gt; -1)
<a name="l00701"></a>00701                     {
<a name="l00702"></a>00702                       <span class="keywordflow">if</span> ( (ndeb+frontiere_dis.<a class="code" href="classFront__VF.html#a341e2fcb5117b96e745fd7078ba86bab" title="Nombre de faces reelles du bord.">nb_faces</a>()/2) &lt;= face )
<a name="l00703"></a>00703                         flux_bords(face,0)-=flux;
<a name="l00704"></a>00704                     }
<a name="l00705"></a>00705                 }
<a name="l00706"></a>00706             }
<a name="l00707"></a>00707           <span class="keywordflow">break</span>;
<a name="l00708"></a>00708           <span class="comment">/*</span>
<a name="l00709"></a>00709 <span class="comment">                                                                            case nouvelle_Cl_VDF :</span>
<a name="l00710"></a>00710 <span class="comment">                                                                            if (flux_evaluateur.calculer_flux_faces_echange_global_impose()){</span>
<a name="l00711"></a>00711 <span class="comment">                                                                            const Nouvelle_Cl_VDF&amp; cl =(const Nouvelle_Cl_VDF&amp;) (la_cl.valeur());</span>
<a name="l00712"></a>00712 <span class="comment">                                                                            for (face=ndeb; face&lt;nfin; face++) {</span>
<a name="l00713"></a>00713 <span class="comment">                                                                            if ( (int elem1=elem(face,0)) &gt; -1)</span>
<a name="l00714"></a>00714 <span class="comment">                                                                            resu[elem1]+=flux_evaluateur.flux_face(donnee, face, cl, ndeb);</span>
<a name="l00715"></a>00715 <span class="comment">                                                                            if ( (int elem2=elem(face,1)) &gt; -1)</span>
<a name="l00716"></a>00716 <span class="comment">                                                                            resu[elem2]-=flux_evaluateur.flux_face(donnee, face, cl, ndeb);</span>
<a name="l00717"></a>00717 <span class="comment">                                                                            }</span>
<a name="l00718"></a>00718 <span class="comment">                                                                            }</span>
<a name="l00719"></a>00719 <span class="comment">                                                                            break;</span>
<a name="l00720"></a>00720 <span class="comment">          */</span>
<a name="l00721"></a>00721         <span class="keywordflow">default</span> :
<a name="l00722"></a>00722           <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;On ne reconnait pas la condition limite : &quot;</span> &lt;&lt; la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>();
<a name="l00723"></a>00723           <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Dans T_It_VDF_Elem&lt;_TYPE_&gt;::ajouter_bords&quot;</span>&lt;&lt;<a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
<a name="l00724"></a>00724           exit();
<a name="l00725"></a>00725           <span class="keywordflow">break</span>;
<a name="l00726"></a>00726         }
<a name="l00727"></a>00727     }
<a name="l00728"></a>00728   modifier_flux() ;
<a name="l00729"></a>00729 }
<a name="l00730"></a>00730 
<a name="l00731"></a><a class="code" href="classT__It__VDF__Elem.html#a8fc65edb5f401e6e9fac46666467b82d">00731</a> <span class="keyword">template</span> &lt;<span class="keyword">class</span> _TYPE_&gt;  <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; <a class="code" href="classT__It__VDF__Elem.html#a8fc65edb5f401e6e9fac46666467b82d">T_It_VDF_Elem&lt;_TYPE_&gt;::ajouter_interne</a>(<span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; donnee,
<a name="l00732"></a>00732                                                                            <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; resu)<span class="keyword"> const</span>
<a name="l00733"></a>00733 <span class="keyword"></span>{
<a name="l00734"></a>00734   <span class="keyword">const</span> <span class="keywordtype">int</span> ncomp = resu.<a class="code" href="classDoubleVect.html#ab02d01cd1bdab66fbd66f9a47cc29e10">line_size</a>();
<a name="l00735"></a>00735   <span class="keyword">const</span> <a class="code" href="classZone__VDF.html" title="class Zone_VDF Classe instanciable qui derive de Zone_VF. Cette classe contient les informations geom...">Zone_VDF</a>&amp; zone_VDF = la_zone.valeur();
<a name="l00736"></a>00736   <a class="code" href="classDoubleVect.html">DoubleVect</a> flux(ncomp);
<a name="l00737"></a>00737   <span class="keywordtype">int</span> face,k;
<a name="l00738"></a>00738   <span class="keywordtype">int</span> elem0,elem1;
<a name="l00739"></a>00739   <span class="keywordtype">int</span> ndeb = zone_VDF.<a class="code" href="classZone__VF.html#a12869806fa4834aca8f2964e16509dfd" title="une face est interne ssi elle separe deux elements. renvoie le numero de la premiere face interne...">premiere_face_int</a>();
<a name="l00740"></a>00740   <span class="keywordtype">int</span> nfin = zone_VDF.<a class="code" href="classZone__VF.html#aede27992d9f2eedd52c24d4a80ff7ffb" title="renvoie le nombre global de faces.">nb_faces</a>();
<a name="l00741"></a>00741   <span class="keywordflow">for</span> (face=ndeb; face&lt;nfin; face++)
<a name="l00742"></a>00742     {
<a name="l00743"></a>00743       flux_evaluateur.flux_faces_interne(donnee, face, flux);
<a name="l00744"></a>00744       elem0 = elem(face,0);
<a name="l00745"></a>00745       elem1 = elem(face,1);
<a name="l00746"></a>00746       <span class="keywordflow">for</span> (k=0; k&lt;ncomp; k++)
<a name="l00747"></a>00747         {
<a name="l00748"></a>00748           resu(elem0,k)+=flux(k);
<a name="l00749"></a>00749           resu(elem1,k)-=flux(k);
<a name="l00750"></a>00750         }
<a name="l00751"></a>00751     }
<a name="l00752"></a>00752   <span class="keywordflow">return</span> resu;
<a name="l00753"></a>00753 }
<a name="l00754"></a><a class="code" href="classT__It__VDF__Elem.html#aebb1435185a41a57d65bbc647c2cd864">00754</a> <span class="keyword">template</span> &lt;<span class="keyword">class</span> _TYPE_&gt;  <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; <a class="code" href="classT__It__VDF__Elem.html#aebb1435185a41a57d65bbc647c2cd864">T_It_VDF_Elem&lt;_TYPE_&gt;::calculer</a>(<span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; inco, <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; resu)<span class="keyword"> const</span>
<a name="l00755"></a>00755 <span class="keyword"></span>{
<a name="l00756"></a>00756   <a class="code" href="DoubleVect_8cpp.html#ad0e13908fed9f476adc797982dce010a">operator_egal</a>(resu, 0., <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caab47906d8d2e6c20f8ba32e4acb6edbe0">VECT_REAL_ITEMS</a>);
<a name="l00757"></a>00757   <span class="keywordflow">return</span> <a class="code" href="Faces2_8cpp.html#a5763a31981073cc0c97bf903b1f120d9" title="Fonction hors classe.">ajouter</a>(inco,resu);
<a name="l00758"></a>00758 }
<a name="l00759"></a><a class="code" href="classT__It__VDF__Elem.html#ab3efc8b1a81fa3eb613f850dc2498edf">00759</a> <span class="keyword">template</span> &lt;<span class="keyword">class</span> _TYPE_&gt;  <span class="keywordtype">void</span>  <a class="code" href="classT__It__VDF__Elem.html#ab3efc8b1a81fa3eb613f850dc2498edf">T_It_VDF_Elem&lt;_TYPE_&gt;::modifier_flux</a>()<span class="keyword"> const</span>
<a name="l00760"></a>00760 <span class="keyword"></span>{
<a name="l00761"></a>00761   <span class="keywordflow">if</span> (op_base-&gt;equation().inconnue().le_nom().debute_par(<span class="stringliteral">&quot;temperature&quot;</span>)
<a name="l00762"></a>00762       &amp;&amp; !( <a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classOperateur__Diff__base.html" title="classe Operateur_Diff_base Cette classe est la base de la hierarchie des operateurs representant un t...">Operateur_Diff_base</a>,op_base.valeur()) &amp;&amp; <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classOperateur__Diff__base.html" title="classe Operateur_Diff_base Cette classe est la base de la hierarchie des operateurs representant un t...">Operateur_Diff_base</a>,op_base.valeur()).diffusivite().le_nom() == <span class="stringliteral">&quot;conductivite&quot;</span> ) )
<a name="l00763"></a>00763     {
<a name="l00764"></a>00764       <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; flux_bords=op_base-&gt;flux_bords();
<a name="l00765"></a>00765       <span class="keyword">const</span> <a class="code" href="classZone__VDF.html" title="class Zone_VDF Classe instanciable qui derive de Zone_VF. Cette classe contient les informations geom...">Zone_VDF</a>&amp; la_zone_vdf=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classZone__VDF.html" title="class Zone_VDF Classe instanciable qui derive de Zone_VF. Cette classe contient les informations geom...">Zone_VDF</a>,op_base-&gt;equation().zone_dis().valeur());
<a name="l00766"></a>00766       <span class="keyword">const</span> <a class="code" href="classChamp__base.html" title="classe Champ_base Cette classe est la base de la hierarchie des champs. Ses membres sont les attribut...">Champ_base</a>&amp; rho = (op_base-&gt;equation()).milieu().masse_volumique();
<a name="l00767"></a>00767       <span class="keyword">const</span> <a class="code" href="classChamp__Don.html" title="classe Champ_Don Classe generique de la hierarchie des champs donnes, un objet Champ_Don peut referen...">Champ_Don</a>&amp; Cp = (op_base-&gt;equation()).milieu().capacite_calorifique();
<a name="l00768"></a>00768       <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; face_voisins=la_zone_vdf.<a class="code" href="classZone__VF.html#a49d4322f5585a8fa95748ca785b70702" title="renvoie l&#39;element voisin de numface dans la direction i. i=0 : dans le sens oppose de l&#39;axe orthogona...">face_voisins</a>();
<a name="l00769"></a>00769       <span class="keywordtype">int</span> rho_uniforme=(<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classChamp__Uniforme.html" title="classe Champ_Uniforme Represente un champ constant dans l&#39;espace et dans le temps.">Champ_Uniforme</a>,rho) ? 1:0);
<a name="l00770"></a>00770       <span class="keywordtype">int</span> cp_uniforme=(<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classChamp__Uniforme.html" title="classe Champ_Uniforme Represente un champ constant dans l&#39;espace et dans le temps.">Champ_Uniforme</a>,Cp.<a class="code" href="classDeriv__Champ__Don__base.html#ae16e7e2a7a706352781c5ecc7764703d">valeur</a>()) ? 1:0);
<a name="l00771"></a>00771       <span class="keywordtype">int</span> is_rho_u=op_base-&gt;equation().probleme().is_dilatable();
<a name="l00772"></a>00772       <span class="keywordflow">if</span> (is_rho_u)
<a name="l00773"></a>00773         {
<a name="l00774"></a>00774           <span class="keyword">const</span> <a class="code" href="classOperateur__base.html" title="classe Operateur_base Classe est la base de la hierarchie des objets representant un operateur utilis...">Operateur_base</a>&amp; op=op_base.valeur();
<a name="l00775"></a>00775           is_rho_u=0;
<a name="l00776"></a>00776           <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classOp__Conv__VDF__base.html" title="class Op_Conv_VDF_base Classe de base des operateurs de convection VDF">Op_Conv_VDF_base</a>,op))
<a name="l00777"></a>00777             <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classOp__Conv__VDF__base.html" title="class Op_Conv_VDF_base Classe de base des operateurs de convection VDF">Op_Conv_VDF_base</a>,op).vitesse().le_nom()==<span class="stringliteral">&quot;rho_u&quot;</span>)
<a name="l00778"></a>00778               is_rho_u=1;
<a name="l00779"></a>00779         }
<a name="l00780"></a>00780       <span class="keywordtype">double</span> Cp_=0,rho_=0;
<a name="l00781"></a>00781       <span class="keyword">const</span> <span class="keywordtype">int</span>&amp; nb_faces_bords=la_zone_vdf.<a class="code" href="classZone__VF.html#a8815e2276637c0db23868f043dc43e58" title="renvoie le nombre de faces sur lesquelles sont appliquees les conditions limites : bords...">nb_faces_bord</a>();
<a name="l00782"></a>00782       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> face=0; face&lt;nb_faces_bords; face++)
<a name="l00783"></a>00783         {
<a name="l00784"></a>00784           <span class="keywordtype">int</span> num_elem=face_voisins(face,0);
<a name="l00785"></a>00785           <span class="keywordflow">if</span> (num_elem == -1) num_elem = face_voisins(face,1);
<a name="l00786"></a>00786           <span class="keywordflow">if</span> (cp_uniforme) Cp_=Cp(0,0);
<a name="l00787"></a>00787           <span class="keywordflow">else</span> <span class="keywordflow">if</span> (Cp.<a class="code" href="classChamp__Don.html#aa0b82f09287c5934333d540ef77e0059" title="Appel a l&#39;objet sous-jacent Renvoie le nombre de composantes du champ.">nb_comp</a>()==1) Cp_=Cp(num_elem);
<a name="l00788"></a>00788           <span class="keywordflow">else</span> Cp_=Cp(num_elem,0);
<a name="l00789"></a>00789           <span class="keywordflow">if</span> (rho_uniforme) rho_=rho(0,0);
<a name="l00790"></a>00790           <span class="keywordflow">else</span> <span class="keywordflow">if</span> (rho.nb_comp()==1) rho_=rho(num_elem);
<a name="l00791"></a>00791           <span class="keywordflow">else</span> rho_=rho(num_elem,0);
<a name="l00792"></a>00792           <span class="comment">/* si on est en QC temperature on a calcule div(rhou * T) */</span>
<a name="l00793"></a>00793           <span class="comment">/* il ne faut pas remultiplier par rho */</span>
<a name="l00794"></a>00794           <span class="keywordflow">if</span> (is_rho_u) rho_=1;
<a name="l00795"></a>00795           flux_bords(face,0) *= (rho_*Cp_);
<a name="l00796"></a>00796         }
<a name="l00797"></a>00797     }
<a name="l00798"></a>00798 }
<a name="l00799"></a>00799 
<a name="l00800"></a><a class="code" href="classT__It__VDF__Elem.html#a7eda6d967c50c9843d43e1cbe72a1afd">00800</a> <span class="keyword">template</span> &lt;<span class="keyword">class</span> _TYPE_&gt;  <span class="keywordtype">int</span> <a class="code" href="classT__It__VDF__Elem.html#a7eda6d967c50c9843d43e1cbe72a1afd">T_It_VDF_Elem&lt;_TYPE_&gt;::impr</a>(<a class="code" href="classSortie.html" title="Classe de base des flux de sortie. Elle sait ecrire des types simples&lt;br&gt;(entiers, flottants) et des Ob...">Sortie</a>&amp; os)<span class="keyword"> const</span>
<a name="l00801"></a>00801 <span class="keyword"></span>{
<a name="l00802"></a>00802   <span class="keyword">const</span> <a class="code" href="classZone__VDF.html" title="class Zone_VDF Classe instanciable qui derive de Zone_VF. Cette classe contient les informations geom...">Zone_VDF</a>&amp; la_zone_vdf=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classZone__VDF.html" title="class Zone_VDF Classe instanciable qui derive de Zone_VF. Cette classe contient les informations geom...">Zone_VDF</a>,op_base.valeur().equation().zone_dis().valeur());
<a name="l00803"></a>00803   <span class="keyword">const</span> <a class="code" href="classZone.html" title="classe Zone Une Zone est un maillage compose d&#39;un ensemble d&#39;elements geometriques de meme type...">Zone</a>&amp; mazone=la_zone-&gt;zone();
<a name="l00804"></a>00804   <span class="keyword">const</span> <span class="keywordtype">int</span> impr_bord=(mazone.Bords_a_imprimer().est_vide() ? 0:1);
<a name="l00805"></a>00805   <span class="keyword">const</span> <a class="code" href="classSchema__Temps__base.html" title="classe Schema_Temps_base">Schema_Temps_base</a>&amp; sch = la_zcl-&gt;equation().probleme().schema_temps();
<a name="l00806"></a>00806   <span class="keywordtype">double</span> temps = sch.<a class="code" href="classSchema__Temps__base.html#a5054df01edb6d4f7baec7e612d423834" title="Renvoie le temps courant.">temps_courant</a>();
<a name="l00807"></a>00807   <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; flux_bords=op_base-&gt;flux_bords();
<a name="l00808"></a>00808   <a class="code" href="classDoubleVect.html">DoubleVect</a> bilan(flux_bords.<a class="code" href="classDoubleTab.html#ac3805e2637a3b880ba2d3e650c69dac4" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(1));
<a name="l00809"></a>00809   <span class="keywordtype">int</span> k,face;
<a name="l00810"></a>00810   <span class="keywordtype">int</span> nb_front_Cl=la_zone-&gt;nb_front_Cl();
<a name="l00811"></a>00811   <a class="code" href="classDoubleTrav.html" title="Tableau de travail a n entrees pour n&lt;= 4 C&#39;est un DoubleTab avec allocation dans un pool de memoire g...">DoubleTrav</a> flux_bords2( 3, nb_front_Cl , flux_bords.<a class="code" href="classDoubleTab.html#ac3805e2637a3b880ba2d3e650c69dac4" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(1)) ;
<a name="l00812"></a>00812   flux_bords2=0;
<a name="l00813"></a>00813   <span class="comment">/*flux_bord(k)          -&gt;   flux_bords2(0,num_cl,k) */</span>
<a name="l00814"></a>00814   <span class="comment">/*flux_bord_perio1(k)   -&gt;   flux_bords2(1,num_cl,k) */</span>
<a name="l00815"></a>00815   <span class="comment">/*flux_bord_perio2(k)   -&gt;   flux_bords2(2,num_cl,k) */</span>
<a name="l00816"></a>00816   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> num_cl=0; num_cl&lt;nb_front_Cl; num_cl++)
<a name="l00817"></a>00817     {
<a name="l00818"></a>00818       <span class="keyword">const</span> <a class="code" href="classCond__lim.html" title="classe Cond_lim Classe generique servant a representer n&#39;importe quelle classe derivee de la classe C...">Cond_lim</a>&amp; la_cl = la_zcl-&gt;les_conditions_limites(num_cl);
<a name="l00819"></a>00819       <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp; frontiere_dis = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>,la_cl.<a class="code" href="classCond__lim.html#a5b2d24809cee07727006a891d4ce8d22" title="Appel a l&#39;objet sous-jacent Renvoie la frontiere discretisee associee a la condition aux limites...">frontiere_dis</a>());
<a name="l00820"></a>00820       <span class="keywordtype">int</span> ndeb = frontiere_dis.<a class="code" href="classFront__VF.html#a4986f0c65653fe9eb40bbbff5a97bf16" title="Numero de la premiere face du bord dans la liste des faces.">num_premiere_face</a>();
<a name="l00821"></a>00821       <span class="keywordtype">int</span> nfin = ndeb + frontiere_dis.<a class="code" href="classFront__VF.html#a341e2fcb5117b96e745fd7078ba86bab" title="Nombre de faces reelles du bord.">nb_faces</a>();
<a name="l00822"></a>00822       <span class="keywordtype">int</span> periodicite = (type_cl(la_cl)==<a class="code" href="Iterateur__PolyMAC__base_8h.html#adda1d69a86f9e3be7366c5f4c6ace649ab83c671c148d8664c5c87f343d2ab9fd" title="periodique">periodique</a>?1:0);
<a name="l00823"></a>00823       <span class="keywordflow">for</span> (face=ndeb; face&lt;nfin; face++)
<a name="l00824"></a>00824         <span class="keywordflow">for</span>(k=0; k&lt;flux_bords.<a class="code" href="classDoubleTab.html#ac3805e2637a3b880ba2d3e650c69dac4" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(1); k++)
<a name="l00825"></a>00825           {
<a name="l00826"></a>00826             flux_bords2(0,num_cl,k)+=flux_bords(face, k);
<a name="l00827"></a>00827             <span class="keywordflow">if</span>(periodicite)
<a name="l00828"></a>00828               {
<a name="l00829"></a>00829                 <span class="keywordflow">if</span>( face &lt; (ndeb+frontiere_dis.<a class="code" href="classFront__VF.html#a341e2fcb5117b96e745fd7078ba86bab" title="Nombre de faces reelles du bord.">nb_faces</a>()/2) )
<a name="l00830"></a>00830                   flux_bords2(1,num_cl,k)+=flux_bords(face, k);
<a name="l00831"></a>00831                 <span class="keywordflow">else</span>
<a name="l00832"></a>00832                   flux_bords2(2,num_cl,k)+=flux_bords(face, k);
<a name="l00833"></a>00833               }
<a name="l00834"></a>00834           }
<a name="l00835"></a>00835     } <span class="comment">/* fin for num_cl */</span>
<a name="l00836"></a>00836   <a class="code" href="communications_8cpp.html#a5f15b8a5c15449d3277ff3cde06fa68a">mp_sum_for_each_item</a>(flux_bords2);
<a name="l00837"></a>00837   <span class="keywordflow">if</span> (je_suis_maitre())
<a name="l00838"></a>00838     {
<a name="l00839"></a>00839       op_base-&gt;ouvrir_fichier(Flux,<span class="stringliteral">&quot;&quot;</span>,1);
<a name="l00840"></a>00840       Flux.add_col(temps);
<a name="l00841"></a>00841       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> num_cl=0; num_cl&lt;nb_front_Cl; num_cl++)
<a name="l00842"></a>00842         {
<a name="l00843"></a>00843           <span class="keyword">const</span> <a class="code" href="classCond__lim.html" title="classe Cond_lim Classe generique servant a representer n&#39;importe quelle classe derivee de la classe C...">Cond_lim</a>&amp; la_cl = la_zcl-&gt;les_conditions_limites(num_cl);
<a name="l00844"></a>00844           <span class="keywordtype">int</span> periodicite = (type_cl(la_cl)==<a class="code" href="Iterateur__PolyMAC__base_8h.html#adda1d69a86f9e3be7366c5f4c6ace649ab83c671c148d8664c5c87f343d2ab9fd" title="periodique">periodique</a>?1:0);
<a name="l00845"></a>00845           <span class="keywordflow">for</span>(k=0; k&lt;flux_bords.<a class="code" href="classDoubleTab.html#ac3805e2637a3b880ba2d3e650c69dac4" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(1); k++)
<a name="l00846"></a>00846             {
<a name="l00847"></a>00847               bilan(k)+=flux_bords2(0,num_cl,k);
<a name="l00848"></a>00848               <span class="keywordflow">if</span>(periodicite)
<a name="l00849"></a>00849                 {
<a name="l00850"></a>00850                   Flux.add_col(flux_bords2(1,num_cl,k));
<a name="l00851"></a>00851                   Flux.add_col(flux_bords2(2,num_cl,k));
<a name="l00852"></a>00852                 }
<a name="l00853"></a>00853               <span class="keywordflow">else</span>
<a name="l00854"></a>00854                 Flux.add_col(flux_bords2(0,num_cl,k));
<a name="l00855"></a>00855             }
<a name="l00856"></a>00856         }
<a name="l00857"></a>00857       <span class="keywordflow">for</span>(k=0; k&lt;flux_bords.<a class="code" href="classDoubleTab.html#ac3805e2637a3b880ba2d3e650c69dac4" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(1); k++)
<a name="l00858"></a>00858         Flux.add_col(bilan(k));
<a name="l00859"></a>00859       Flux &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
<a name="l00860"></a>00860     }
<a name="l00861"></a>00861   <span class="keyword">const</span> <a class="code" href="List_8h.html#a3149526fb499ddb08728c87daa32c5ad">LIST</a>(<a class="code" href="classNom.html" title="class Nom Une chaine de caractere pour nommer les objets de TRUST">Nom</a>)&amp; Liste_Bords_a_imprimer = la_zone-&gt;zone().Bords_a_imprimer();
<a name="l00862"></a>00862   <span class="keywordflow">if</span> (!Liste_Bords_a_imprimer.est_vide())
<a name="l00863"></a>00863     {
<a name="l00864"></a>00864       <a class="code" href="classEcrFicPartage.html">EcrFicPartage</a> Flux_face;
<a name="l00865"></a>00865       op_base-&gt;ouvrir_fichier_partage(Flux_face,<span class="stringliteral">&quot;&quot;</span>,impr_bord);
<a name="l00866"></a>00866       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> num_cl=0; num_cl&lt;nb_front_Cl; num_cl++)
<a name="l00867"></a>00867         {
<a name="l00868"></a>00868           <span class="keyword">const</span> <a class="code" href="classFrontiere__dis__base.html" title="classe Frontiere_dis_base Classe representant une frontiere discretisee. Les objets Frontiere_dis_bas...">Frontiere_dis_base</a>&amp; la_fr = la_zcl-&gt;les_conditions_limites(num_cl).frontiere_dis();
<a name="l00869"></a>00869           <span class="keyword">const</span> <a class="code" href="classCond__lim.html" title="classe Cond_lim Classe generique servant a representer n&#39;importe quelle classe derivee de la classe C...">Cond_lim</a>&amp; la_cl = la_zcl-&gt;les_conditions_limites(num_cl);
<a name="l00870"></a>00870           <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp; frontiere_dis = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>,la_cl.<a class="code" href="classCond__lim.html#a5b2d24809cee07727006a891d4ce8d22" title="Appel a l&#39;objet sous-jacent Renvoie la frontiere discretisee associee a la condition aux limites...">frontiere_dis</a>());
<a name="l00871"></a>00871           <span class="keywordtype">int</span> ndeb = frontiere_dis.<a class="code" href="classFront__VF.html#a4986f0c65653fe9eb40bbbff5a97bf16" title="Numero de la premiere face du bord dans la liste des faces.">num_premiere_face</a>();
<a name="l00872"></a>00872           <span class="keywordtype">int</span> nfin = ndeb + frontiere_dis.<a class="code" href="classFront__VF.html#a341e2fcb5117b96e745fd7078ba86bab" title="Nombre de faces reelles du bord.">nb_faces</a>();
<a name="l00873"></a>00873           <span class="keywordflow">if</span> (mazone.Bords_a_imprimer().contient(la_fr.<a class="code" href="classFrontiere__dis__base.html#a5a7eb46dc3af8a7d4225adc1814845d8" title="Renvoie le nom de la frontiere geometrique.">le_nom</a>()))
<a name="l00874"></a>00874             {
<a name="l00875"></a>00875               Flux_face &lt;&lt; <span class="stringliteral">&quot;# Flux par face sur &quot;</span> &lt;&lt; la_fr.<a class="code" href="classFrontiere__dis__base.html#a5a7eb46dc3af8a7d4225adc1814845d8" title="Renvoie le nom de la frontiere geometrique.">le_nom</a>() &lt;&lt; <span class="stringliteral">&quot; au temps &quot;</span> &lt;&lt; temps &lt;&lt; <span class="stringliteral">&quot; : &quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
<a name="l00876"></a>00876               <span class="keywordflow">for</span> (face=ndeb; face&lt;nfin; face++)
<a name="l00877"></a>00877                 {
<a name="l00878"></a>00878                   <span class="keywordflow">if</span> (dimension == 2)
<a name="l00879"></a>00879                     Flux_face &lt;&lt; <span class="stringliteral">&quot;# Face a x= &quot;</span> &lt;&lt; la_zone-&gt;xv(face,0) &lt;&lt; <span class="stringliteral">&quot; y= &quot;</span> &lt;&lt; la_zone-&gt;xv(face,1);
<a name="l00880"></a>00880                   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (dimension == 3)
<a name="l00881"></a>00881                     Flux_face &lt;&lt; <span class="stringliteral">&quot;# Face a x= &quot;</span> &lt;&lt; la_zone-&gt;xv(face,0) &lt;&lt; <span class="stringliteral">&quot; y= &quot;</span> &lt;&lt; la_zone-&gt;xv(face,1) &lt;&lt; <span class="stringliteral">&quot; z= &quot;</span> &lt;&lt; la_zone-&gt;xv(face,2);
<a name="l00882"></a>00882                   <span class="keywordflow">for</span>(k=0; k&lt;flux_bords.<a class="code" href="classDoubleTab.html#ac3805e2637a3b880ba2d3e650c69dac4" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(1); k++)
<a name="l00883"></a>00883                     {
<a name="l00884"></a>00884                       <span class="keywordflow">if</span> (!<a class="code" href="Double_8h.html#ac86f5f350b0f95fd8c34b0ac8d720f6f">est_egal</a>(la_zone_vdf.<a class="code" href="classZone__VF.html#a40c3382b189a4fc508cf1c3e37b04b21">face_surfaces</a>(face),0., 1.e-20))
<a name="l00885"></a>00885                         {
<a name="l00886"></a>00886                           Flux_face &lt;&lt; <span class="stringliteral">&quot; surface_face(m2)= &quot;</span> &lt;&lt; la_zone_vdf.<a class="code" href="classZone__VF.html#a40c3382b189a4fc508cf1c3e37b04b21">face_surfaces</a>(face) ;
<a name="l00887"></a>00887                           Flux_face &lt;&lt; <span class="stringliteral">&quot; flux_par_surface(W/m2)= &quot;</span>  &lt;&lt; flux_bords(face, k)/la_zone_vdf.<a class="code" href="classZone__VF.html#a40c3382b189a4fc508cf1c3e37b04b21">face_surfaces</a>(face) ;
<a name="l00888"></a>00888                         }
<a name="l00889"></a>00889                       Flux_face &lt;&lt; <span class="stringliteral">&quot; flux(W)= &quot;</span> &lt;&lt; flux_bords(face, k) ;
<a name="l00890"></a>00890                     }
<a name="l00891"></a>00891                   Flux_face &lt;&lt; finl;
<a name="l00892"></a>00892                 }
<a name="l00893"></a>00893               Flux_face.<a class="code" href="classEcrFicPartage.html#a76131150f8293c86eb36f4b45125183d" title="Provoque l&#39;ecriture sur disque des donnees accumulees sur les differents processeurs depuis le dernie...">syncfile</a>();
<a name="l00894"></a>00894             }
<a name="l00895"></a>00895         }
<a name="l00896"></a>00896     }
<a name="l00897"></a>00897   <span class="keywordflow">return</span> 1;
<a name="l00898"></a>00898 }
<a name="l00899"></a>00899 
<a name="l00900"></a><a class="code" href="classT__It__VDF__Elem.html#ae6c075c1c484a6fb44bc0451c79f6b29">00900</a> <span class="keyword">template</span> &lt;<span class="keyword">class</span> _TYPE_&gt;  <span class="keywordtype">void</span> <a class="code" href="classT__It__VDF__Elem.html#ae6c075c1c484a6fb44bc0451c79f6b29">T_It_VDF_Elem&lt;_TYPE_&gt;::contribuer_au_second_membre</a>(<a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; resu)<span class="keyword"> const</span>
<a name="l00901"></a>00901 <span class="keyword"></span>{
<a name="l00902"></a>00902   ((_TYPE_&amp;) flux_evaluateur).mettre_a_jour();
<a name="l00903"></a>00903   assert(resu.<a class="code" href="classDoubleTab.html#ae6dda48778e7107e1beb723beef1f75b" title="Returns the number of dimensions of the array (&gt;= 1)">nb_dim</a>() &lt; 3);
<a name="l00904"></a>00904   assert(la_zcl.non_nul());
<a name="l00905"></a>00905   assert(la_zone.non_nul());
<a name="l00906"></a>00906   assert(op_base-&gt;flux_bords().dimension(0)==la_zone-&gt;nb_faces_bord()); <span class="comment">/* resize deja fait */</span>
<a name="l00907"></a>00907   contribuer_au_second_membre_bords(resu) ;
<a name="l00908"></a>00908   contribuer_au_second_membre_interne(resu) ;
<a name="l00909"></a>00909 }
<a name="l00910"></a><a class="code" href="classT__It__VDF__Elem.html#a6d0871f9825679d4ce6382ba88d7d8e6">00910</a> <span class="keyword">template</span> &lt;<span class="keyword">class</span> _TYPE_&gt;  <span class="keywordtype">void</span> <a class="code" href="classT__It__VDF__Elem.html#a6d0871f9825679d4ce6382ba88d7d8e6">T_It_VDF_Elem&lt;_TYPE_&gt;::contribuer_au_second_membre_bords</a>(<a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; resu)<span class="keyword"> const</span>
<a name="l00911"></a>00911 <span class="keyword"></span>{
<a name="l00912"></a>00912   <span class="keyword">const</span> <span class="keywordtype">int</span> ncomp = resu.<a class="code" href="classDoubleVect.html#ab02d01cd1bdab66fbd66f9a47cc29e10">line_size</a>();
<a name="l00913"></a>00913   <span class="keywordtype">int</span> elem1, elem2;
<a name="l00914"></a>00914   <span class="keywordtype">int</span> ndeb, nfin;
<a name="l00915"></a>00915   <span class="keywordtype">int</span> face,k;
<a name="l00916"></a>00916   <a class="code" href="classDoubleVect.html">DoubleVect</a> flux(ncomp);
<a name="l00917"></a>00917   <span class="keywordtype">int</span> num_cl=0;
<a name="l00918"></a>00918   <span class="keywordtype">int</span> nb_front_Cl=la_zone-&gt;nb_front_Cl();
<a name="l00919"></a>00919   <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; flux_bords=op_base-&gt;flux_bords();
<a name="l00920"></a>00920   <span class="keywordflow">for</span> (; num_cl&lt;nb_front_Cl; num_cl++)
<a name="l00921"></a>00921     {
<a name="l00922"></a>00922       <span class="keyword">const</span> <a class="code" href="classCond__lim.html" title="classe Cond_lim Classe generique servant a representer n&#39;importe quelle classe derivee de la classe C...">Cond_lim</a>&amp; la_cl = la_zcl-&gt;les_conditions_limites(num_cl);
<a name="l00923"></a>00923       <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp; frontiere_dis = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>,la_cl.<a class="code" href="classCond__lim.html#a5b2d24809cee07727006a891d4ce8d22" title="Appel a l&#39;objet sous-jacent Renvoie la frontiere discretisee associee a la condition aux limites...">frontiere_dis</a>());
<a name="l00924"></a>00924       ndeb = frontiere_dis.<a class="code" href="classFront__VF.html#a4986f0c65653fe9eb40bbbff5a97bf16" title="Numero de la premiere face du bord dans la liste des faces.">num_premiere_face</a>();
<a name="l00925"></a>00925       nfin = ndeb + frontiere_dis.<a class="code" href="classFront__VF.html#a341e2fcb5117b96e745fd7078ba86bab" title="Nombre de faces reelles du bord.">nb_faces</a>();
<a name="l00926"></a>00926       <span class="keywordflow">switch</span>(type_cl(la_cl))
<a name="l00927"></a>00927         {
<a name="l00928"></a>00928         <span class="keywordflow">case</span> <a class="code" href="Iterateur__PolyMAC__base_8h.html#adda1d69a86f9e3be7366c5f4c6ace649ac938491055e13993f3eed68c989f90b0" title="Symetrie.">symetrie</a> :
<a name="l00929"></a>00929           <span class="keywordflow">if</span> (flux_evaluateur.calculer_flux_faces_symetrie())
<a name="l00930"></a>00930             {
<a name="l00931"></a>00931               <span class="keyword">const</span> <a class="code" href="classSymetrie.html" title="classe Symetrie Sur les faces de symetrie on a les proprietes suivantes: - composante normale de la v...">Symetrie</a>&amp; cl =(<span class="keyword">const</span> <a class="code" href="classSymetrie.html" title="classe Symetrie Sur les faces de symetrie on a les proprietes suivantes: - composante normale de la v...">Symetrie</a>&amp;) (la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>());
<a name="l00932"></a>00932               <span class="keywordflow">for</span> (face=ndeb; face&lt;nfin; face++)
<a name="l00933"></a>00933                 {
<a name="l00934"></a>00934                   flux_evaluateur.secmem_face(face, cl, ndeb, flux);
<a name="l00935"></a>00935                   <span class="keywordflow">if</span> ( (elem1=elem(face,0)) &gt; -1)
<a name="l00936"></a>00936                     <span class="keywordflow">for</span> (k=0; k&lt;ncomp; k++)
<a name="l00937"></a>00937                       {
<a name="l00938"></a>00938                         resu(elem1,k) +=flux(k);
<a name="l00939"></a>00939                         flux_bords(face,k)+=flux(k);
<a name="l00940"></a>00940                       }
<a name="l00941"></a>00941                   <span class="keywordflow">if</span> ( (elem2=elem(face,1)) &gt; -1)
<a name="l00942"></a>00942                     <span class="keywordflow">for</span> (k=0; k&lt;ncomp; k++)
<a name="l00943"></a>00943                       {
<a name="l00944"></a>00944                         resu(elem2,k) -=flux(k);
<a name="l00945"></a>00945                         flux_bords(face,k)-=flux(k);
<a name="l00946"></a>00946                       }
<a name="l00947"></a>00947                 }
<a name="l00948"></a>00948             }
<a name="l00949"></a>00949           <span class="keywordflow">break</span>;
<a name="l00950"></a>00950         <span class="keywordflow">case</span> <a class="code" href="Iterateur__PolyMAC__base_8h.html#adda1d69a86f9e3be7366c5f4c6ace649ac4317ef27513bbab3cd0ccfd0d9ed199" title="Neumann_sortie_libre ou derivees.">sortie_libre</a> :
<a name="l00951"></a>00951           <span class="keywordflow">if</span> (flux_evaluateur.calculer_flux_faces_sortie_libre())
<a name="l00952"></a>00952             {
<a name="l00953"></a>00953               <span class="keyword">const</span> <a class="code" href="classNeumann__sortie__libre.html" title="classe Neumann_sortie_libre Cette classe represente une frontiere ouverte sans vitesse imposee Pour l...">Neumann_sortie_libre</a>&amp; cl =(<span class="keyword">const</span> <a class="code" href="classNeumann__sortie__libre.html" title="classe Neumann_sortie_libre Cette classe represente une frontiere ouverte sans vitesse imposee Pour l...">Neumann_sortie_libre</a>&amp;) (la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>());
<a name="l00954"></a>00954               <span class="keywordflow">for</span> (face=ndeb; face&lt;nfin; face++)
<a name="l00955"></a>00955                 {
<a name="l00956"></a>00956                   flux_evaluateur.secmem_face(face, cl, ndeb, flux);
<a name="l00957"></a>00957                   <span class="keywordflow">if</span> ( (elem1=elem(face,0)) &gt; -1)
<a name="l00958"></a>00958                     <span class="keywordflow">for</span> (k=0; k&lt;ncomp; k++)
<a name="l00959"></a>00959                       {
<a name="l00960"></a>00960                         resu(elem1,k) +=flux(k);
<a name="l00961"></a>00961                         flux_bords(face,k)+=flux(k);
<a name="l00962"></a>00962                       }
<a name="l00963"></a>00963                   <span class="keywordflow">if</span> ( (elem2=elem(face,1)) &gt; -1)
<a name="l00964"></a>00964                     <span class="keywordflow">for</span> (k=0; k&lt;ncomp; k++)
<a name="l00965"></a>00965                       {
<a name="l00966"></a>00966                         resu(elem2,k) -=flux(k);
<a name="l00967"></a>00967                         flux_bords(face,k)-=flux(k);
<a name="l00968"></a>00968                       }
<a name="l00969"></a>00969                 }
<a name="l00970"></a>00970             }
<a name="l00971"></a>00971           <span class="keywordflow">break</span>;
<a name="l00972"></a>00972         <span class="keywordflow">case</span> <a class="code" href="Iterateur__PolyMAC__base_8h.html#adda1d69a86f9e3be7366c5f4c6ace649a594fd60a4576f47654eed7df53dee9be" title="Dirichlet_entree_fluide.">entree_fluide</a> :
<a name="l00973"></a>00973           <span class="keywordflow">if</span> (flux_evaluateur.calculer_flux_faces_entree_fluide())
<a name="l00974"></a>00974             {
<a name="l00975"></a>00975               <span class="keyword">const</span> <a class="code" href="classDirichlet__entree__fluide.html" title="classe Dirichlet_entree_fluide Cette classe represente une condition aux limite imposant une grandeur...">Dirichlet_entree_fluide</a>&amp; cl =(<span class="keyword">const</span> <a class="code" href="classDirichlet__entree__fluide.html" title="classe Dirichlet_entree_fluide Cette classe represente une condition aux limite imposant une grandeur...">Dirichlet_entree_fluide</a>&amp;) (la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>());
<a name="l00976"></a>00976               <span class="keywordflow">for</span> (face=ndeb; face&lt;nfin; face++)
<a name="l00977"></a>00977                 {
<a name="l00978"></a>00978                   flux_evaluateur.secmem_face(face, cl, ndeb, flux);
<a name="l00979"></a>00979                   <span class="keywordflow">if</span> ( (elem1=elem(face,0)) &gt; -1)
<a name="l00980"></a>00980                     <span class="keywordflow">for</span> (k=0; k&lt;ncomp; k++)
<a name="l00981"></a>00981                       {
<a name="l00982"></a>00982                         resu(elem1,k) +=flux(k);
<a name="l00983"></a>00983                         flux_bords(face,k)+=flux(k);
<a name="l00984"></a>00984                       }
<a name="l00985"></a>00985                   <span class="keywordflow">if</span> ( (elem2=elem(face,1)) &gt; -1)
<a name="l00986"></a>00986                     <span class="keywordflow">for</span> (k=0; k&lt;ncomp; k++)
<a name="l00987"></a>00987                       {
<a name="l00988"></a>00988                         resu(elem2,k) -=flux(k);
<a name="l00989"></a>00989                         flux_bords(face,k)-=flux(k);
<a name="l00990"></a>00990                       }
<a name="l00991"></a>00991                 }
<a name="l00992"></a>00992             }
<a name="l00993"></a>00993           <span class="keywordflow">break</span>;
<a name="l00994"></a>00994         <span class="keywordflow">case</span> <a class="code" href="Iterateur__PolyMAC__base_8h.html#adda1d69a86f9e3be7366c5f4c6ace649a497d92e00f36c1c7ec874c0a318db91e" title="Dirichlet_paroi_fixe.">paroi_fixe</a> :
<a name="l00995"></a>00995           <span class="keywordflow">if</span> (flux_evaluateur.calculer_flux_faces_paroi_fixe())
<a name="l00996"></a>00996             {
<a name="l00997"></a>00997               <span class="keyword">const</span> <a class="code" href="classDirichlet__paroi__fixe.html" title="classe Dirichlet_paroi_fixe Represente une paroi immobile dans une equation de type Navier_Stokes...">Dirichlet_paroi_fixe</a>&amp; cl =(<span class="keyword">const</span> <a class="code" href="classDirichlet__paroi__fixe.html" title="classe Dirichlet_paroi_fixe Represente une paroi immobile dans une equation de type Navier_Stokes...">Dirichlet_paroi_fixe</a>&amp;) (la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>());
<a name="l00998"></a>00998               <span class="keywordflow">for</span> (face=ndeb; face&lt;nfin; face++)
<a name="l00999"></a>00999                 {
<a name="l01000"></a>01000                   flux_evaluateur.secmem_face(face, cl, ndeb, flux);
<a name="l01001"></a>01001                   <span class="keywordflow">if</span> ( (elem1=elem(face,0)) &gt; -1)
<a name="l01002"></a>01002                     <span class="keywordflow">for</span> (k=0; k&lt;ncomp; k++)
<a name="l01003"></a>01003                       {
<a name="l01004"></a>01004                         resu(elem1,k) +=flux(k);
<a name="l01005"></a>01005                         flux_bords(face,k)+=flux(k);
<a name="l01006"></a>01006                       }
<a name="l01007"></a>01007                   <span class="keywordflow">if</span> ( (elem2=elem(face,1)) &gt; -1)
<a name="l01008"></a>01008                     <span class="keywordflow">for</span> (k=0; k&lt;ncomp; k++)
<a name="l01009"></a>01009                       {
<a name="l01010"></a>01010                         resu(elem2,k) -=flux(k);
<a name="l01011"></a>01011                         flux_bords(face,k)-=flux(k);
<a name="l01012"></a>01012                       }
<a name="l01013"></a>01013                 }
<a name="l01014"></a>01014             }
<a name="l01015"></a>01015           <span class="keywordflow">break</span>;
<a name="l01016"></a>01016         <span class="keywordflow">case</span> <a class="code" href="Iterateur__PolyMAC__base_8h.html#adda1d69a86f9e3be7366c5f4c6ace649acdd1bf461cb105b93d5a9b003ce33141" title="Dirichlet_paroi_defilante.">paroi_defilante</a> :
<a name="l01017"></a>01017           <span class="keywordflow">if</span> (flux_evaluateur.calculer_flux_faces_paroi_defilante())
<a name="l01018"></a>01018             {
<a name="l01019"></a>01019               <span class="keyword">const</span> <a class="code" href="classDirichlet__paroi__defilante.html" title="classe Dirichlet_paroi_defilante Impose la vitesse de paroi dnas une equation de type Navier_Stokes...">Dirichlet_paroi_defilante</a>&amp; cl =(<span class="keyword">const</span> <a class="code" href="classDirichlet__paroi__defilante.html" title="classe Dirichlet_paroi_defilante Impose la vitesse de paroi dnas une equation de type Navier_Stokes...">Dirichlet_paroi_defilante</a>&amp;) (la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>());
<a name="l01020"></a>01020               <span class="keywordflow">for</span> (face=ndeb; face&lt;nfin; face++)
<a name="l01021"></a>01021                 {
<a name="l01022"></a>01022                   flux_evaluateur.secmem_face(face, cl, ndeb, flux);
<a name="l01023"></a>01023                   <span class="keywordflow">if</span> ( (elem1=elem(face,0)) &gt; -1)
<a name="l01024"></a>01024                     <span class="keywordflow">for</span> (k=0; k&lt;ncomp; k++)
<a name="l01025"></a>01025                       {
<a name="l01026"></a>01026                         resu(elem1,k) +=flux(k);
<a name="l01027"></a>01027                         flux_bords(face,k)+=flux(k);
<a name="l01028"></a>01028                       }
<a name="l01029"></a>01029                   <span class="keywordflow">if</span> ( (elem2=elem(face,1)) &gt; -1)
<a name="l01030"></a>01030                     <span class="keywordflow">for</span> (k=0; k&lt;ncomp; k++)
<a name="l01031"></a>01031                       {
<a name="l01032"></a>01032                         resu(elem2,k) -=flux(k);
<a name="l01033"></a>01033                         flux_bords(face,k)-=flux(k);
<a name="l01034"></a>01034                       }
<a name="l01035"></a>01035                 }
<a name="l01036"></a>01036             }
<a name="l01037"></a>01037           <span class="keywordflow">break</span>;
<a name="l01038"></a>01038         <span class="keywordflow">case</span> <a class="code" href="classparoi__adiabatique.html">paroi_adiabatique</a> :
<a name="l01039"></a>01039           <span class="keywordflow">if</span> (flux_evaluateur.calculer_flux_faces_paroi_adiabatique())
<a name="l01040"></a>01040             {
<a name="l01041"></a>01041               <span class="keyword">const</span> <a class="code" href="classNeumann__paroi__adiabatique.html" title="Classe Neumann_paroi_adiabatique Cette condition limite correspond a une paroi adiabatique dans une e...">Neumann_paroi_adiabatique</a>&amp; cl =(<span class="keyword">const</span> <a class="code" href="classNeumann__paroi__adiabatique.html" title="Classe Neumann_paroi_adiabatique Cette condition limite correspond a une paroi adiabatique dans une e...">Neumann_paroi_adiabatique</a>&amp;) (la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>());
<a name="l01042"></a>01042               <span class="keywordflow">for</span> (face=ndeb; face&lt;nfin; face++)
<a name="l01043"></a>01043                 {
<a name="l01044"></a>01044                   flux_evaluateur.secmem_face(face, cl, ndeb, flux);
<a name="l01045"></a>01045                   <span class="keywordflow">if</span> ( (elem1=elem(face,0)) &gt; -1)
<a name="l01046"></a>01046                     <span class="keywordflow">for</span> (k=0; k&lt;ncomp; k++)
<a name="l01047"></a>01047                       {
<a name="l01048"></a>01048                         resu(elem1,k) +=flux(k);
<a name="l01049"></a>01049                         flux_bords(face,k)+=flux(k);
<a name="l01050"></a>01050                       }
<a name="l01051"></a>01051                   <span class="keywordflow">if</span> ( (elem2=elem(face,1)) &gt; -1)
<a name="l01052"></a>01052                     <span class="keywordflow">for</span> (k=0; k&lt;ncomp; k++)
<a name="l01053"></a>01053                       {
<a name="l01054"></a>01054                         resu(elem2,k) -=flux(k);
<a name="l01055"></a>01055                         flux_bords(face,k)-=flux(k);
<a name="l01056"></a>01056                       }
<a name="l01057"></a>01057                 }
<a name="l01058"></a>01058             }
<a name="l01059"></a>01059           <span class="keywordflow">break</span>;
<a name="l01060"></a>01060         <span class="keywordflow">case</span> <a class="code" href="Iterateur__PolyMAC__base_8h.html#adda1d69a86f9e3be7366c5f4c6ace649af695f3ba17490e07dc3259c85875d8d6" title="Neumann_paroi.">paroi</a> :
<a name="l01061"></a>01061           <span class="keywordflow">if</span> (flux_evaluateur.calculer_flux_faces_paroi())
<a name="l01062"></a>01062             {
<a name="l01063"></a>01063               <span class="keyword">const</span> <a class="code" href="classNeumann__paroi.html" title="Classe Neumann_paroi Cette condition limite correspond a un flux impose pour l&#39;equation de transport ...">Neumann_paroi</a>&amp; cl =(<span class="keyword">const</span> <a class="code" href="classNeumann__paroi.html" title="Classe Neumann_paroi Cette condition limite correspond a un flux impose pour l&#39;equation de transport ...">Neumann_paroi</a>&amp;) (la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>());
<a name="l01064"></a>01064               <span class="keywordflow">for</span> (face=ndeb; face&lt;nfin; face++)
<a name="l01065"></a>01065                 {
<a name="l01066"></a>01066                   flux_evaluateur.secmem_face(face, cl, ndeb, flux);
<a name="l01067"></a>01067                   <span class="keywordflow">if</span> ( (elem1=elem(face,0)) &gt; -1)
<a name="l01068"></a>01068                     <span class="keywordflow">for</span> (k=0; k&lt;ncomp; k++)
<a name="l01069"></a>01069                       {
<a name="l01070"></a>01070                         resu(elem1,k) +=flux(k);
<a name="l01071"></a>01071                         flux_bords(face,k)+=flux(k);
<a name="l01072"></a>01072                       }
<a name="l01073"></a>01073                   <span class="keywordflow">if</span> ( (elem2=elem(face,1)) &gt; -1)
<a name="l01074"></a>01074                     <span class="keywordflow">for</span> (k=0; k&lt;ncomp; k++)
<a name="l01075"></a>01075                       {
<a name="l01076"></a>01076                         resu(elem2,k) -=flux(k);
<a name="l01077"></a>01077                         flux_bords(face,k)-=flux(k);
<a name="l01078"></a>01078                       }
<a name="l01079"></a>01079                 }
<a name="l01080"></a>01080             }
<a name="l01081"></a>01081           <span class="keywordflow">break</span>;
<a name="l01082"></a>01082         <span class="keywordflow">case</span> <a class="code" href="Iterateur__PolyMAC__base_8h.html#adda1d69a86f9e3be7366c5f4c6ace649a38f997f881a13a46f2d06012162cf833" title="Echange_externe_impose.">echange_externe_impose</a> :
<a name="l01083"></a>01083           <span class="keywordflow">if</span> (flux_evaluateur.calculer_flux_faces_echange_externe_impose())
<a name="l01084"></a>01084             {
<a name="l01085"></a>01085               <span class="keyword">const</span> <a class="code" href="classEchange__externe__impose.html" title="Classe Echange_externe_impose: Cette classe represente le cas particulier de la classe Echange_impose...">Echange_externe_impose</a>&amp; cl =(<span class="keyword">const</span> <a class="code" href="classEchange__externe__impose.html" title="Classe Echange_externe_impose: Cette classe represente le cas particulier de la classe Echange_impose...">Echange_externe_impose</a>&amp;) (la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>());
<a name="l01086"></a>01086 
<a name="l01087"></a>01087               <span class="keywordtype">int</span> boundary_index=-1;
<a name="l01088"></a>01088               <span class="keywordflow">if</span> (la_zone.valeur().front_VF(num_cl).le_nom() == frontiere_dis.<a class="code" href="classFrontiere__dis__base.html#a5a7eb46dc3af8a7d4225adc1814845d8" title="Renvoie le nom de la frontiere geometrique.">le_nom</a>())
<a name="l01089"></a>01089                 boundary_index=num_cl;
<a name="l01090"></a>01090 
<a name="l01091"></a>01091               <span class="keywordflow">for</span> (face=ndeb; face&lt;nfin; face++)
<a name="l01092"></a>01092                 {
<a name="l01093"></a>01093                   <span class="keywordtype">int</span> local_face=la_zone.valeur().front_VF(boundary_index).num_local_face(face);
<a name="l01094"></a>01094                   flux_evaluateur.secmem_face(boundary_index,face,local_face, cl, ndeb, flux);
<a name="l01095"></a>01095                   <span class="keywordflow">if</span> ( (elem1=elem(face,0)) &gt; -1)
<a name="l01096"></a>01096                     <span class="keywordflow">for</span> (k=0; k&lt;ncomp; k++)
<a name="l01097"></a>01097                       {
<a name="l01098"></a>01098                         resu(elem1,k) +=flux(k);
<a name="l01099"></a>01099                         flux_bords(face,k)+=flux(k);
<a name="l01100"></a>01100                       }
<a name="l01101"></a>01101                   <span class="keywordflow">if</span> ( (elem2=elem(face,1)) &gt; -1)
<a name="l01102"></a>01102                     <span class="keywordflow">for</span> (k=0; k&lt;ncomp; k++)
<a name="l01103"></a>01103                       {
<a name="l01104"></a>01104                         resu(elem2,k) -=flux(k);
<a name="l01105"></a>01105                         flux_bords(face,k)-=flux(k);
<a name="l01106"></a>01106                       }
<a name="l01107"></a>01107                 }
<a name="l01108"></a>01108             }
<a name="l01109"></a>01109           <span class="keywordflow">break</span>;
<a name="l01110"></a>01110         <span class="keywordflow">case</span> <a class="code" href="Iterateur__PolyMAC__base_8h.html#adda1d69a86f9e3be7366c5f4c6ace649a9201b83c6fe44d3928abbe5f73364323" title="Echange_global_impose.">echange_global_impose</a> :
<a name="l01111"></a>01111           <span class="keywordflow">if</span> (flux_evaluateur.calculer_flux_faces_echange_global_impose())
<a name="l01112"></a>01112             {
<a name="l01113"></a>01113               <span class="keyword">const</span> <a class="code" href="classEchange__global__impose.html" title="Classe Echange_global_impose Cette classe represente le cas particulier de la classe Echange_impose_b...">Echange_global_impose</a>&amp; cl =(<span class="keyword">const</span> <a class="code" href="classEchange__global__impose.html" title="Classe Echange_global_impose Cette classe represente le cas particulier de la classe Echange_impose_b...">Echange_global_impose</a>&amp;) (la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>());
<a name="l01114"></a>01114               <span class="keywordflow">for</span> (face=ndeb; face&lt;nfin; face++)
<a name="l01115"></a>01115                 {
<a name="l01116"></a>01116                   flux_evaluateur.secmem_face(face, cl, ndeb, flux);
<a name="l01117"></a>01117                   <span class="keywordflow">if</span> ( (elem1=elem(face,0)) &gt; -1)
<a name="l01118"></a>01118                     <span class="keywordflow">for</span> (k=0; k&lt;ncomp; k++)
<a name="l01119"></a>01119                       {
<a name="l01120"></a>01120                         resu(elem1,k) +=flux(k);
<a name="l01121"></a>01121                         flux_bords(face,k)+=flux(k);
<a name="l01122"></a>01122                       }
<a name="l01123"></a>01123                   <span class="keywordflow">if</span> ( (elem2=elem(face,1)) &gt; -1)
<a name="l01124"></a>01124                     <span class="keywordflow">for</span> (k=0; k&lt;ncomp; k++)
<a name="l01125"></a>01125                       {
<a name="l01126"></a>01126                         resu(elem2,k) -=flux(k);
<a name="l01127"></a>01127                         flux_bords(face,k)-=flux(k);
<a name="l01128"></a>01128                       }
<a name="l01129"></a>01129                 }
<a name="l01130"></a>01130             }
<a name="l01131"></a>01131           <span class="keywordflow">break</span>;
<a name="l01132"></a>01132         <span class="keywordflow">case</span> <a class="code" href="Iterateur__PolyMAC__base_8h.html#adda1d69a86f9e3be7366c5f4c6ace649adbce3cca9532937c741ae3ac77dc2d54" title="NSCBC.">nscbc</a> :
<a name="l01133"></a>01133           <span class="keywordflow">if</span> (flux_evaluateur.calculer_flux_faces_NSCBC())
<a name="l01134"></a>01134             {
<a name="l01135"></a>01135               <span class="keyword">const</span> <a class="code" href="classNSCBC.html" title="classe">NSCBC</a>&amp; cl =(<span class="keyword">const</span> <a class="code" href="classNSCBC.html" title="classe">NSCBC</a>&amp;) (la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>());
<a name="l01136"></a>01136               <span class="keywordflow">for</span> (face=ndeb; face&lt;nfin; face++)
<a name="l01137"></a>01137                 {
<a name="l01138"></a>01138                   assert(ncomp == 1); <span class="comment">//!&lt; codage avec flux en DoubleVect auquel on assigne la valeur de la fonction scalaire (pas de codage vectoriel de nscbc)</span>
<a name="l01139"></a>01139 <span class="comment"></span>                  flux = flux_evaluateur.secmem_face(face, cl, ndeb);
<a name="l01140"></a>01140 <span class="comment">// flux_evaluateur.secmem_face(face, cl, ndeb, flux);</span>
<a name="l01141"></a>01141                   <span class="keywordflow">if</span> ( (elem1=elem(face,0)) &gt; -1)
<a name="l01142"></a>01142                     <span class="keywordflow">for</span> (k=0; k&lt;ncomp; k++)
<a name="l01143"></a>01143                       {
<a name="l01144"></a>01144                         resu(elem1,k) +=flux(k);
<a name="l01145"></a>01145                         flux_bords(face,k)+=flux(k);
<a name="l01146"></a>01146                       }
<a name="l01147"></a>01147                   <span class="keywordflow">if</span> ( (elem2=elem(face,1)) &gt; -1)
<a name="l01148"></a>01148                     <span class="keywordflow">for</span> (k=0; k&lt;ncomp; k++)
<a name="l01149"></a>01149                       {
<a name="l01150"></a>01150                         resu(elem2,k) -=flux(k);
<a name="l01151"></a>01151                         flux_bords(face,k)-=flux(k);
<a name="l01152"></a>01152                       }
<a name="l01153"></a>01153                 }
<a name="l01154"></a>01154             }
<a name="l01155"></a>01155           <span class="keywordflow">break</span>;
<a name="l01156"></a>01156         <span class="keywordflow">case</span> <a class="code" href="Iterateur__PolyMAC__base_8h.html#adda1d69a86f9e3be7366c5f4c6ace649ab83c671c148d8664c5c87f343d2ab9fd" title="periodique">periodique</a> :
<a name="l01157"></a>01157           <span class="keywordflow">if</span> (flux_evaluateur.calculer_flux_faces_periodique())
<a name="l01158"></a>01158             {
<a name="l01159"></a>01159               <span class="keyword">const</span> <a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>&amp; cl =(<span class="keyword">const</span> <a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>&amp;) (la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>());
<a name="l01160"></a>01160               <span class="keywordflow">for</span> (face=ndeb; face&lt;nfin; face++)
<a name="l01161"></a>01161                 {
<a name="l01162"></a>01162                   flux_evaluateur.secmem_face(face, cl, ndeb, flux);
<a name="l01163"></a>01163                   <span class="keywordflow">if</span> ( (elem1=elem(face,0)) &gt; -1)
<a name="l01164"></a>01164                     <span class="keywordflow">for</span> (k=0; k&lt;ncomp; k++)
<a name="l01165"></a>01165                       {
<a name="l01166"></a>01166                         resu(elem1,k) +=0.5*flux(k);
<a name="l01167"></a>01167                         flux_bords(face,k)+=0.5*flux(k);
<a name="l01168"></a>01168                       }
<a name="l01169"></a>01169                   <span class="keywordflow">if</span> ( (elem2=elem(face,1)) &gt; -1)
<a name="l01170"></a>01170                     <span class="keywordflow">for</span> (k=0; k&lt;ncomp; k++)
<a name="l01171"></a>01171                       {
<a name="l01172"></a>01172                         resu(elem2,k) -=0.5*flux(k);
<a name="l01173"></a>01173                         flux_bords(face,k)-=0.5*flux(k);
<a name="l01174"></a>01174                       }
<a name="l01175"></a>01175                 }
<a name="l01176"></a>01176             }
<a name="l01177"></a>01177           <span class="keywordflow">break</span>;
<a name="l01178"></a>01178           <span class="comment">/*</span>
<a name="l01179"></a>01179 <span class="comment">                                                                            case nouvelle_Cl_VDF :</span>
<a name="l01180"></a>01180 <span class="comment">                                                                            if (flux_evaluateur.calculer_flux_faces_echange_global_impose()){</span>
<a name="l01181"></a>01181 <span class="comment">                                                                            const Nouvelle_Cl_VDF&amp; cl =(const Nouvelle_Cl_VDF&amp;) (la_cl.valeur());</span>
<a name="l01182"></a>01182 <span class="comment">                                                                            for (face=ndeb; face&lt;nfin; face++) {</span>
<a name="l01183"></a>01183 <span class="comment">                                                                            flux_evaluateur.secmem_face(face, cl, ndeb, flux);</span>
<a name="l01184"></a>01184 <span class="comment">                                                                            if ( (elem1=elem(face,0)) &gt; -1)</span>
<a name="l01185"></a>01185 <span class="comment">                                                                            for (k=0; k&lt;ncomp; k++)</span>
<a name="l01186"></a>01186 <span class="comment">                                                                            resu(elem1,k) +=flux(k);</span>
<a name="l01187"></a>01187 <span class="comment">                                                                            if ( (elem2=elem(face,1)) &gt; -1)</span>
<a name="l01188"></a>01188 <span class="comment">                                                                            for (k=0; k&lt;ncomp; k++)</span>
<a name="l01189"></a>01189 <span class="comment">                                                                            resu(elem2,k) -=flux(k);</span>
<a name="l01190"></a>01190 <span class="comment">                                                                            }</span>
<a name="l01191"></a>01191 <span class="comment">                                                                            }</span>
<a name="l01192"></a>01192 <span class="comment">                                                                            break;</span>
<a name="l01193"></a>01193 <span class="comment">          */</span>
<a name="l01194"></a>01194         <span class="keywordflow">default</span> :
<a name="l01195"></a>01195           <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;On ne reconnait pas la condition limite : &quot;</span> &lt;&lt; la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>();
<a name="l01196"></a>01196           exit();
<a name="l01197"></a>01197           <span class="keywordflow">break</span>;
<a name="l01198"></a>01198         }
<a name="l01199"></a>01199     }
<a name="l01200"></a>01200 }
<a name="l01201"></a>01201 
<a name="l01202"></a><a class="code" href="classT__It__VDF__Elem.html#a67c535d1963fe3f0b19a9e42d515fb10">01202</a> <span class="keyword">template</span> &lt;<span class="keyword">class</span> _TYPE_&gt;  <span class="keywordtype">void</span> <a class="code" href="classT__It__VDF__Elem.html#a67c535d1963fe3f0b19a9e42d515fb10">T_It_VDF_Elem&lt;_TYPE_&gt;::contribuer_au_second_membre_interne</a>( <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; resu)<span class="keyword"> const</span>
<a name="l01203"></a>01203 <span class="keyword"></span>{
<a name="l01204"></a>01204   <span class="keyword">const</span> <span class="keywordtype">int</span> ncomp = resu.<a class="code" href="classDoubleVect.html#ab02d01cd1bdab66fbd66f9a47cc29e10">line_size</a>();
<a name="l01205"></a>01205   <span class="keyword">const</span> <a class="code" href="classZone__VDF.html" title="class Zone_VDF Classe instanciable qui derive de Zone_VF. Cette classe contient les informations geom...">Zone_VDF</a>&amp; zone_VDF = la_zone.valeur();
<a name="l01206"></a>01206   <a class="code" href="classDoubleVect.html">DoubleVect</a> flux(ncomp);
<a name="l01207"></a>01207   <span class="keywordtype">int</span> face,k;
<a name="l01208"></a>01208   <span class="keywordtype">int</span> elem0,elem1;
<a name="l01209"></a>01209   <span class="keywordtype">int</span> ndeb=zone_VDF.<a class="code" href="classZone__VF.html#a12869806fa4834aca8f2964e16509dfd" title="une face est interne ssi elle separe deux elements. renvoie le numero de la premiere face interne...">premiere_face_int</a>();
<a name="l01210"></a>01210   <span class="keywordtype">int</span> nfin=zone_VDF.<a class="code" href="classZone__VF.html#aede27992d9f2eedd52c24d4a80ff7ffb" title="renvoie le nombre global de faces.">nb_faces</a>();
<a name="l01211"></a>01211   <span class="keywordflow">for</span> (face=ndeb; face&lt;nfin; face++)
<a name="l01212"></a>01212     {
<a name="l01213"></a>01213       flux_evaluateur.secmem_faces_interne(face, flux);
<a name="l01214"></a>01214       elem0 = elem(face,0);
<a name="l01215"></a>01215       elem1 = elem(face,1);
<a name="l01216"></a>01216       <span class="keywordflow">for</span> (k=0; k&lt;ncomp; k++)
<a name="l01217"></a>01217         {
<a name="l01218"></a>01218           resu(elem0,k)+=flux(k);
<a name="l01219"></a>01219           resu(elem1,k)-=flux(k);
<a name="l01220"></a>01220         }
<a name="l01221"></a>01221     }
<a name="l01222"></a>01222 }
<a name="l01223"></a>01223 
<a name="l01224"></a>01224 
<a name="l01225"></a><a class="code" href="classT__It__VDF__Elem.html#a81a6d79a10b9317cfa92b93dccd41b0f">01225</a> <span class="keyword">template</span> &lt;<span class="keyword">class</span> _TYPE_&gt;  <span class="keywordtype">void</span> <a class="code" href="classT__It__VDF__Elem.html#a81a6d79a10b9317cfa92b93dccd41b0f">T_It_VDF_Elem&lt;_TYPE_&gt;::ajouter_contribution</a>(<span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; inco, <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; matrice)<span class="keyword"> const</span>
<a name="l01226"></a>01226 <span class="keyword"></span>{
<a name="l01227"></a>01227   ((_TYPE_&amp;) flux_evaluateur).mettre_a_jour();
<a name="l01228"></a>01228   assert(inco.<a class="code" href="classDoubleTab.html#ae6dda48778e7107e1beb723beef1f75b" title="Returns the number of dimensions of the array (&gt;= 1)">nb_dim</a>() &lt; 3);
<a name="l01229"></a>01229   assert(la_zcl.non_nul());
<a name="l01230"></a>01230   assert(la_zone.non_nul());
<a name="l01231"></a>01231   <span class="keyword">const</span> <span class="keywordtype">int</span> ncomp = inco.<a class="code" href="classDoubleVect.html#ab02d01cd1bdab66fbd66f9a47cc29e10">line_size</a>();
<a name="l01232"></a>01232   <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; flux_bords=op_base-&gt;flux_bords();
<a name="l01233"></a>01233   flux_bords.<a class="code" href="classDoubleTab.html#ae83b4d31205c53d9c8d2b43da178ce75" title="Change la taille du vecteur (identique a resize_array() pour le traitement des anciennes valeurs et d...">resize</a>(la_zone-&gt;nb_faces_bord(),ncomp);
<a name="l01234"></a>01234   flux_bords=0;
<a name="l01235"></a>01235   ajouter_contribution_bords(inco, matrice) ;
<a name="l01236"></a>01236   ajouter_contribution_interne(inco, matrice) ;
<a name="l01237"></a>01237 }
<a name="l01238"></a>01238 
<a name="l01239"></a><a class="code" href="classT__It__VDF__Elem.html#ad4071d7d498524ba686fdf3a3fe2fd0d">01239</a> <span class="keyword">template</span> &lt;<span class="keyword">class</span> _TYPE_&gt;  <span class="keywordtype">void</span> <a class="code" href="classT__It__VDF__Elem.html#ad4071d7d498524ba686fdf3a3fe2fd0d">T_It_VDF_Elem&lt;_TYPE_&gt;::ajouter_contribution_vitesse</a>(<span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; inco, <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; matrice)<span class="keyword"> const</span>
<a name="l01240"></a>01240 <span class="keyword"></span>{
<a name="l01241"></a>01241   ((_TYPE_&amp;) flux_evaluateur).mettre_a_jour();
<a name="l01242"></a>01242   assert(inco.<a class="code" href="classDoubleTab.html#ae6dda48778e7107e1beb723beef1f75b" title="Returns the number of dimensions of the array (&gt;= 1)">nb_dim</a>() &lt; 3);
<a name="l01243"></a>01243   assert(la_zcl.non_nul());
<a name="l01244"></a>01244   assert(la_zone.non_nul());
<a name="l01245"></a>01245   <span class="keywordtype">int</span> ncomp=1;
<a name="l01246"></a>01246   <span class="keywordflow">if</span> (inco.<a class="code" href="classDoubleTab.html#ae6dda48778e7107e1beb723beef1f75b" title="Returns the number of dimensions of the array (&gt;= 1)">nb_dim</a>() == 2)
<a name="l01247"></a>01247     ncomp=inco.<a class="code" href="classDoubleTab.html#ac3805e2637a3b880ba2d3e650c69dac4" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(1);
<a name="l01248"></a>01248 <span class="comment">// DoubleTab&amp; flux_bords=op_base-&gt;flux_bords();</span>
<a name="l01249"></a>01249 <span class="comment">// flux_bords.resize(la_zone-&gt;nb_faces_bord(),ncomp);</span>
<a name="l01250"></a>01250 <span class="comment">// flux_bords=0;</span>
<a name="l01251"></a>01251   <span class="keywordflow">if</span>( ncomp == 1) <span class="comment">/* cas scalaire */</span>
<a name="l01252"></a>01252     {
<a name="l01253"></a>01253       ajouter_contribution_bords_vitesse(inco, matrice);
<a name="l01254"></a>01254       ajouter_contribution_interne_vitesse(inco, matrice);
<a name="l01255"></a>01255     }
<a name="l01256"></a>01256   <span class="keywordflow">else</span> <span class="comment">/* cas vectoriel */</span>
<a name="l01257"></a>01257     {
<a name="l01258"></a>01258       abort();
<a name="l01259"></a>01259 <span class="comment">// ajouter_contribution_bords(inco, matrice, ncomp) ;</span>
<a name="l01260"></a>01260 <span class="comment">// ajouter_contribution_interne(inco, matrice, ncomp) ;</span>
<a name="l01261"></a>01261     }
<a name="l01262"></a>01262 }
<a name="l01263"></a>01263 
<a name="l01264"></a><a class="code" href="classT__It__VDF__Elem.html#a5a4f3009b36687e4dd7fa1f33ab541ce">01264</a> <span class="keyword">template</span> &lt;<span class="keyword">class</span> _TYPE_&gt;  <span class="keywordtype">void</span> <a class="code" href="classT__It__VDF__Elem.html#a5a4f3009b36687e4dd7fa1f33ab541ce">T_It_VDF_Elem&lt;_TYPE_&gt;::ajouter_contribution_bords</a>(<span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; inco, <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; matrice )<span class="keyword"> const</span>
<a name="l01265"></a>01265 <span class="keyword"></span>{
<a name="l01266"></a>01266   <span class="keyword">const</span> <span class="keywordtype">int</span> ncomp = inco.<a class="code" href="classDoubleVect.html#ab02d01cd1bdab66fbd66f9a47cc29e10">line_size</a>();
<a name="l01267"></a>01267   <span class="keywordtype">int</span> elem1, elem2;
<a name="l01268"></a>01268   <a class="code" href="classDoubleVect.html">DoubleVect</a> aii(ncomp), ajj(ncomp);
<a name="l01269"></a>01269   <span class="keywordtype">int</span> ndeb, nfin;
<a name="l01270"></a>01270   <span class="keywordtype">int</span> face;
<a name="l01271"></a>01271   <span class="keywordtype">int</span> num_cl=0;
<a name="l01272"></a>01272   <span class="keywordtype">int</span> nb_front_Cl=la_zone-&gt;nb_front_Cl();
<a name="l01273"></a>01273   <span class="keywordflow">for</span> (; num_cl&lt;nb_front_Cl; num_cl++)
<a name="l01274"></a>01274     {
<a name="l01275"></a>01275       <span class="keyword">const</span> <a class="code" href="classCond__lim.html" title="classe Cond_lim Classe generique servant a representer n&#39;importe quelle classe derivee de la classe C...">Cond_lim</a>&amp; la_cl = la_zcl-&gt;les_conditions_limites(num_cl);
<a name="l01276"></a>01276       <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp; frontiere_dis = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>,la_cl.<a class="code" href="classCond__lim.html#a5b2d24809cee07727006a891d4ce8d22" title="Appel a l&#39;objet sous-jacent Renvoie la frontiere discretisee associee a la condition aux limites...">frontiere_dis</a>());
<a name="l01277"></a>01277       ndeb = frontiere_dis.<a class="code" href="classFront__VF.html#a4986f0c65653fe9eb40bbbff5a97bf16" title="Numero de la premiere face du bord dans la liste des faces.">num_premiere_face</a>();
<a name="l01278"></a>01278       nfin = ndeb + frontiere_dis.<a class="code" href="classFront__VF.html#a341e2fcb5117b96e745fd7078ba86bab" title="Nombre de faces reelles du bord.">nb_faces</a>();
<a name="l01279"></a>01279       <span class="keywordflow">switch</span>(type_cl(la_cl))
<a name="l01280"></a>01280         {
<a name="l01281"></a>01281         <span class="keywordflow">case</span> <a class="code" href="Iterateur__PolyMAC__base_8h.html#adda1d69a86f9e3be7366c5f4c6ace649ac938491055e13993f3eed68c989f90b0" title="Symetrie.">symetrie</a> :
<a name="l01282"></a>01282           <span class="keywordflow">if</span> (flux_evaluateur.calculer_flux_faces_symetrie())
<a name="l01283"></a>01283             {
<a name="l01284"></a>01284               <span class="keyword">const</span> <a class="code" href="classSymetrie.html" title="classe Symetrie Sur les faces de symetrie on a les proprietes suivantes: - composante normale de la v...">Symetrie</a>&amp; cl =(<span class="keyword">const</span> <a class="code" href="classSymetrie.html" title="classe Symetrie Sur les faces de symetrie on a les proprietes suivantes: - composante normale de la v...">Symetrie</a>&amp;) (la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>());
<a name="l01285"></a>01285               <span class="keywordflow">for</span> (face=ndeb; face&lt;nfin; face++)
<a name="l01286"></a>01286                 {
<a name="l01287"></a>01287                   flux_evaluateur.coeffs_face(face,ndeb, cl, aii, ajj);
<a name="l01288"></a>01288                   <span class="keywordflow">if</span> ( (elem1=elem(face,0)) &gt; -1)
<a name="l01289"></a>01289                     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; ncomp; i++)
<a name="l01290"></a>01290                       matrice(elem1*ncomp+i,elem1*ncomp+i)+=aii(i);
<a name="l01291"></a>01291                   <span class="keywordflow">if</span> ( (elem2=elem(face,1)) &gt; -1)
<a name="l01292"></a>01292                     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; ncomp; i++)
<a name="l01293"></a>01293                       matrice(elem2*ncomp+i,elem2*ncomp+i)+=ajj(i);
<a name="l01294"></a>01294                 }
<a name="l01295"></a>01295             }
<a name="l01296"></a>01296           <span class="keywordflow">break</span>;
<a name="l01297"></a>01297         <span class="keywordflow">case</span> <a class="code" href="Iterateur__PolyMAC__base_8h.html#adda1d69a86f9e3be7366c5f4c6ace649ac4317ef27513bbab3cd0ccfd0d9ed199" title="Neumann_sortie_libre ou derivees.">sortie_libre</a> :
<a name="l01298"></a>01298           <span class="keywordflow">if</span> (flux_evaluateur.calculer_flux_faces_sortie_libre())
<a name="l01299"></a>01299             {
<a name="l01300"></a>01300               <span class="keyword">const</span> <a class="code" href="classNeumann__sortie__libre.html" title="classe Neumann_sortie_libre Cette classe represente une frontiere ouverte sans vitesse imposee Pour l...">Neumann_sortie_libre</a>&amp; cl =(<span class="keyword">const</span> <a class="code" href="classNeumann__sortie__libre.html" title="classe Neumann_sortie_libre Cette classe represente une frontiere ouverte sans vitesse imposee Pour l...">Neumann_sortie_libre</a>&amp;) (la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>());
<a name="l01301"></a>01301               <span class="keywordflow">for</span> (face=ndeb; face&lt;nfin; face++)
<a name="l01302"></a>01302                 {
<a name="l01303"></a>01303                   flux_evaluateur.coeffs_face(face,ndeb, cl, aii, ajj);
<a name="l01304"></a>01304                   <span class="keywordflow">if</span> ( (elem1=elem(face,0)) &gt; -1)
<a name="l01305"></a>01305                     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; ncomp; i++)
<a name="l01306"></a>01306                       matrice(elem1*ncomp+i,elem1*ncomp+i)+=aii(i);
<a name="l01307"></a>01307                   <span class="keywordflow">if</span> ( (elem2=elem(face,1)) &gt; -1)
<a name="l01308"></a>01308                     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; ncomp; i++)
<a name="l01309"></a>01309                       matrice(elem2*ncomp+i,elem2*ncomp+i)+=ajj(i);
<a name="l01310"></a>01310                 }
<a name="l01311"></a>01311             }
<a name="l01312"></a>01312           <span class="keywordflow">break</span>;
<a name="l01313"></a>01313         <span class="keywordflow">case</span> <a class="code" href="Iterateur__PolyMAC__base_8h.html#adda1d69a86f9e3be7366c5f4c6ace649a594fd60a4576f47654eed7df53dee9be" title="Dirichlet_entree_fluide.">entree_fluide</a> :
<a name="l01314"></a>01314           <span class="keywordflow">if</span> (flux_evaluateur.calculer_flux_faces_entree_fluide())
<a name="l01315"></a>01315             {
<a name="l01316"></a>01316               <span class="keyword">const</span> <a class="code" href="classDirichlet__entree__fluide.html" title="classe Dirichlet_entree_fluide Cette classe represente une condition aux limite imposant une grandeur...">Dirichlet_entree_fluide</a>&amp; cl =(<span class="keyword">const</span> <a class="code" href="classDirichlet__entree__fluide.html" title="classe Dirichlet_entree_fluide Cette classe represente une condition aux limite imposant une grandeur...">Dirichlet_entree_fluide</a>&amp;) (la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>());
<a name="l01317"></a>01317               <span class="keywordflow">for</span> (face=ndeb; face&lt;nfin; face++)
<a name="l01318"></a>01318                 {
<a name="l01319"></a>01319                   flux_evaluateur.coeffs_face(face,ndeb, cl, aii, ajj);
<a name="l01320"></a>01320                   <span class="keywordflow">if</span> ( (elem1=elem(face,0)) &gt; -1)
<a name="l01321"></a>01321                     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; ncomp; i++)
<a name="l01322"></a>01322                       matrice(elem1*ncomp+i,elem1*ncomp+i)+=aii(i);
<a name="l01323"></a>01323                   <span class="keywordflow">if</span> ( (elem2=elem(face,1)) &gt; -1)
<a name="l01324"></a>01324                     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; ncomp; i++)
<a name="l01325"></a>01325                       matrice(elem2*ncomp+i,elem2*ncomp+i)+=ajj(i);
<a name="l01326"></a>01326                 }
<a name="l01327"></a>01327             }
<a name="l01328"></a>01328           <span class="keywordflow">break</span>;
<a name="l01329"></a>01329         <span class="keywordflow">case</span> <a class="code" href="Iterateur__PolyMAC__base_8h.html#adda1d69a86f9e3be7366c5f4c6ace649a497d92e00f36c1c7ec874c0a318db91e" title="Dirichlet_paroi_fixe.">paroi_fixe</a> :
<a name="l01330"></a>01330           <span class="keywordflow">if</span> (flux_evaluateur.calculer_flux_faces_paroi_fixe())
<a name="l01331"></a>01331             {
<a name="l01332"></a>01332               <span class="keyword">const</span> <a class="code" href="classDirichlet__paroi__fixe.html" title="classe Dirichlet_paroi_fixe Represente une paroi immobile dans une equation de type Navier_Stokes...">Dirichlet_paroi_fixe</a>&amp; cl =(<span class="keyword">const</span> <a class="code" href="classDirichlet__paroi__fixe.html" title="classe Dirichlet_paroi_fixe Represente une paroi immobile dans une equation de type Navier_Stokes...">Dirichlet_paroi_fixe</a>&amp;) (la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>());
<a name="l01333"></a>01333               <span class="keywordflow">for</span> (face=ndeb; face&lt;nfin; face++)
<a name="l01334"></a>01334                 {
<a name="l01335"></a>01335                   flux_evaluateur.coeffs_face(face,ndeb, cl, aii, ajj);
<a name="l01336"></a>01336                   <span class="keywordflow">if</span> ( (elem1=elem(face,0)) &gt; -1)
<a name="l01337"></a>01337                     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; ncomp; i++)
<a name="l01338"></a>01338                       matrice(elem1*ncomp+i,elem1*ncomp+i)+=aii(i);
<a name="l01339"></a>01339                   <span class="keywordflow">if</span> ( (elem2=elem(face,1)) &gt; -1)
<a name="l01340"></a>01340                     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; ncomp; i++)
<a name="l01341"></a>01341                       matrice(elem2*ncomp+i,elem2*ncomp+i)+=ajj(i);
<a name="l01342"></a>01342                 }
<a name="l01343"></a>01343             }
<a name="l01344"></a>01344           <span class="keywordflow">break</span>;
<a name="l01345"></a>01345         <span class="keywordflow">case</span> <a class="code" href="Iterateur__PolyMAC__base_8h.html#adda1d69a86f9e3be7366c5f4c6ace649acdd1bf461cb105b93d5a9b003ce33141" title="Dirichlet_paroi_defilante.">paroi_defilante</a> :
<a name="l01346"></a>01346           <span class="keywordflow">if</span> (flux_evaluateur.calculer_flux_faces_paroi_defilante())
<a name="l01347"></a>01347             {
<a name="l01348"></a>01348               <span class="keyword">const</span> <a class="code" href="classDirichlet__paroi__defilante.html" title="classe Dirichlet_paroi_defilante Impose la vitesse de paroi dnas une equation de type Navier_Stokes...">Dirichlet_paroi_defilante</a>&amp; cl =(<span class="keyword">const</span> <a class="code" href="classDirichlet__paroi__defilante.html" title="classe Dirichlet_paroi_defilante Impose la vitesse de paroi dnas une equation de type Navier_Stokes...">Dirichlet_paroi_defilante</a>&amp;) (la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>());
<a name="l01349"></a>01349               <span class="keywordflow">for</span> (face=ndeb; face&lt;nfin; face++)
<a name="l01350"></a>01350                 {
<a name="l01351"></a>01351                   flux_evaluateur.coeffs_face(face,ndeb, cl, aii, ajj);
<a name="l01352"></a>01352                   <span class="keywordflow">if</span> ( (elem1=elem(face,0)) &gt; -1)
<a name="l01353"></a>01353                     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; ncomp; i++)
<a name="l01354"></a>01354                       matrice(elem1*ncomp+i,elem1*ncomp+i)+=aii(i);
<a name="l01355"></a>01355                   <span class="keywordflow">if</span> ( (elem2=elem(face,1)) &gt; -1)
<a name="l01356"></a>01356                     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; ncomp; i++)
<a name="l01357"></a>01357                       matrice(elem2*ncomp+i,elem2*ncomp+i)+=ajj(i);
<a name="l01358"></a>01358                 }
<a name="l01359"></a>01359             }
<a name="l01360"></a>01360           <span class="keywordflow">break</span>;
<a name="l01361"></a>01361         <span class="keywordflow">case</span> <a class="code" href="classparoi__adiabatique.html">paroi_adiabatique</a> :
<a name="l01362"></a>01362           <span class="keywordflow">if</span> (flux_evaluateur.calculer_flux_faces_paroi_adiabatique())
<a name="l01363"></a>01363             {
<a name="l01364"></a>01364               <span class="keyword">const</span> <a class="code" href="classNeumann__paroi__adiabatique.html" title="Classe Neumann_paroi_adiabatique Cette condition limite correspond a une paroi adiabatique dans une e...">Neumann_paroi_adiabatique</a>&amp; cl =(<span class="keyword">const</span> <a class="code" href="classNeumann__paroi__adiabatique.html" title="Classe Neumann_paroi_adiabatique Cette condition limite correspond a une paroi adiabatique dans une e...">Neumann_paroi_adiabatique</a>&amp;) (la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>());
<a name="l01365"></a>01365               <span class="keywordflow">for</span> (face=ndeb; face&lt;nfin; face++)
<a name="l01366"></a>01366                 {
<a name="l01367"></a>01367                   flux_evaluateur.coeffs_face(face,ndeb, cl, aii, ajj);
<a name="l01368"></a>01368                   <span class="keywordflow">if</span> ( (elem1=elem(face,0)) &gt; -1)
<a name="l01369"></a>01369                     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; ncomp; i++)
<a name="l01370"></a>01370                       matrice(elem1*ncomp+i,elem1*ncomp+i)+=aii(i);
<a name="l01371"></a>01371                   <span class="keywordflow">if</span> ( (elem2=elem(face,1)) &gt; -1)
<a name="l01372"></a>01372                     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; ncomp; i++)
<a name="l01373"></a>01373                       matrice(elem2*ncomp+i,elem2*ncomp+i)+=ajj(i);
<a name="l01374"></a>01374                 }
<a name="l01375"></a>01375             }
<a name="l01376"></a>01376           <span class="keywordflow">break</span>;
<a name="l01377"></a>01377         <span class="keywordflow">case</span> <a class="code" href="Iterateur__PolyMAC__base_8h.html#adda1d69a86f9e3be7366c5f4c6ace649af695f3ba17490e07dc3259c85875d8d6" title="Neumann_paroi.">paroi</a> :
<a name="l01378"></a>01378           <span class="keywordflow">if</span> (flux_evaluateur.calculer_flux_faces_paroi())
<a name="l01379"></a>01379             {
<a name="l01380"></a>01380               <span class="keyword">const</span> <a class="code" href="classNeumann__paroi.html" title="Classe Neumann_paroi Cette condition limite correspond a un flux impose pour l&#39;equation de transport ...">Neumann_paroi</a>&amp; cl =(<span class="keyword">const</span> <a class="code" href="classNeumann__paroi.html" title="Classe Neumann_paroi Cette condition limite correspond a un flux impose pour l&#39;equation de transport ...">Neumann_paroi</a>&amp;) (la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>());
<a name="l01381"></a>01381               <span class="keywordflow">for</span> (face=ndeb; face&lt;nfin; face++)
<a name="l01382"></a>01382                 {
<a name="l01383"></a>01383                   flux_evaluateur.coeffs_face(face,ndeb, cl, aii, ajj);
<a name="l01384"></a>01384                   <span class="keywordflow">if</span> ( (elem1=elem(face,0)) &gt; -1)
<a name="l01385"></a>01385                     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; ncomp; i++)
<a name="l01386"></a>01386                       matrice(elem1*ncomp+i,elem1*ncomp+i)+=aii(i);
<a name="l01387"></a>01387                   <span class="keywordflow">if</span> ( (elem2=elem(face,1)) &gt; -1)
<a name="l01388"></a>01388                     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; ncomp; i++)
<a name="l01389"></a>01389                       matrice(elem2*ncomp+i,elem2*ncomp+i)+=ajj(i);
<a name="l01390"></a>01390                 }
<a name="l01391"></a>01391             }
<a name="l01392"></a>01392           <span class="keywordflow">break</span>;
<a name="l01393"></a>01393         <span class="keywordflow">case</span> <a class="code" href="Iterateur__PolyMAC__base_8h.html#adda1d69a86f9e3be7366c5f4c6ace649a38f997f881a13a46f2d06012162cf833" title="Echange_externe_impose.">echange_externe_impose</a> :
<a name="l01394"></a>01394           <span class="keywordflow">if</span> (flux_evaluateur.calculer_flux_faces_echange_externe_impose())
<a name="l01395"></a>01395             {
<a name="l01396"></a>01396               <span class="keyword">const</span> <a class="code" href="classEchange__externe__impose.html" title="Classe Echange_externe_impose: Cette classe represente le cas particulier de la classe Echange_impose...">Echange_externe_impose</a>&amp; cl =(<span class="keyword">const</span> <a class="code" href="classEchange__externe__impose.html" title="Classe Echange_externe_impose: Cette classe represente le cas particulier de la classe Echange_impose...">Echange_externe_impose</a>&amp;) (la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>());
<a name="l01397"></a>01397 
<a name="l01398"></a>01398               <span class="keywordtype">int</span> boundary_index=-1;
<a name="l01399"></a>01399               <span class="keywordflow">if</span> (la_zone.valeur().front_VF(num_cl).le_nom() == frontiere_dis.<a class="code" href="classFrontiere__dis__base.html#a5a7eb46dc3af8a7d4225adc1814845d8" title="Renvoie le nom de la frontiere geometrique.">le_nom</a>())
<a name="l01400"></a>01400                 boundary_index=num_cl;
<a name="l01401"></a>01401 
<a name="l01402"></a>01402               <span class="keywordflow">for</span> (face=ndeb; face&lt;nfin; face++)
<a name="l01403"></a>01403                 {
<a name="l01404"></a>01404                   <span class="keywordtype">int</span> local_face=la_zone.valeur().front_VF(boundary_index).num_local_face(face);
<a name="l01405"></a>01405                   flux_evaluateur.coeffs_face(boundary_index,face,local_face,ndeb, cl, aii, ajj);
<a name="l01406"></a>01406                   <span class="keywordflow">if</span> ( (elem1=elem(face,0)) &gt; -1)
<a name="l01407"></a>01407                     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; ncomp; i++)
<a name="l01408"></a>01408                       matrice(elem1*ncomp+i,elem1*ncomp+i)+=aii(i);
<a name="l01409"></a>01409                   <span class="keywordflow">if</span> ( (elem2=elem(face,1)) &gt; -1)
<a name="l01410"></a>01410                     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; ncomp; i++)
<a name="l01411"></a>01411                       matrice(elem2*ncomp+i,elem2*ncomp+i)+=ajj(i);
<a name="l01412"></a>01412                 }
<a name="l01413"></a>01413             }
<a name="l01414"></a>01414           <span class="keywordflow">break</span>;
<a name="l01415"></a>01415         <span class="keywordflow">case</span> <a class="code" href="Iterateur__PolyMAC__base_8h.html#adda1d69a86f9e3be7366c5f4c6ace649a9201b83c6fe44d3928abbe5f73364323" title="Echange_global_impose.">echange_global_impose</a> :
<a name="l01416"></a>01416           <span class="keywordflow">if</span> (flux_evaluateur.calculer_flux_faces_echange_global_impose())
<a name="l01417"></a>01417             {
<a name="l01418"></a>01418               <span class="keyword">const</span> <a class="code" href="classEchange__global__impose.html" title="Classe Echange_global_impose Cette classe represente le cas particulier de la classe Echange_impose_b...">Echange_global_impose</a>&amp; cl =(<span class="keyword">const</span> <a class="code" href="classEchange__global__impose.html" title="Classe Echange_global_impose Cette classe represente le cas particulier de la classe Echange_impose_b...">Echange_global_impose</a>&amp;) (la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>());
<a name="l01419"></a>01419               <span class="keywordflow">for</span> (face=ndeb; face&lt;nfin; face++)
<a name="l01420"></a>01420                 {
<a name="l01421"></a>01421                   flux_evaluateur.coeffs_face(face,ndeb, cl, aii, ajj);
<a name="l01422"></a>01422                   <span class="keywordflow">if</span> ( (elem1=elem(face,0)) &gt; -1)
<a name="l01423"></a>01423                     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; ncomp; i++)
<a name="l01424"></a>01424                       matrice(elem1*ncomp+i,elem1*ncomp+i)+=aii(i);
<a name="l01425"></a>01425                   <span class="keywordflow">if</span> ( (elem2=elem(face,1)) &gt; -1)
<a name="l01426"></a>01426                     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; ncomp; i++)
<a name="l01427"></a>01427                       matrice(elem2*ncomp+i,elem2*ncomp+i)+=ajj(i);
<a name="l01428"></a>01428                 }
<a name="l01429"></a>01429             }
<a name="l01430"></a>01430           <span class="keywordflow">break</span>;
<a name="l01431"></a>01431         <span class="keywordflow">case</span> <a class="code" href="Iterateur__PolyMAC__base_8h.html#adda1d69a86f9e3be7366c5f4c6ace649adbce3cca9532937c741ae3ac77dc2d54" title="NSCBC.">nscbc</a> :
<a name="l01432"></a>01432           <span class="keywordflow">if</span> (flux_evaluateur.calculer_flux_faces_NSCBC())
<a name="l01433"></a>01433             {
<a name="l01434"></a>01434               <span class="keyword">const</span> <a class="code" href="classNSCBC.html" title="classe">NSCBC</a>&amp; cl =(<span class="keyword">const</span> <a class="code" href="classNSCBC.html" title="classe">NSCBC</a>&amp;) (la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>());
<a name="l01435"></a>01435               <span class="keywordflow">for</span> (face=ndeb; face&lt;nfin; face++)
<a name="l01436"></a>01436                 {
<a name="l01437"></a>01437 <span class="comment">// codage scalaire applique aux DoubleVect</span>
<a name="l01438"></a>01438                   assert(ncomp == 1);
<a name="l01439"></a>01439                   <span class="keywordtype">double</span> aii_ = 0., ajj_ = 0.;
<a name="l01440"></a>01440                   flux_evaluateur.coeffs_face(face,ndeb, cl, aii_, ajj_);
<a name="l01441"></a>01441                   aii = aii_, ajj = ajj_;
<a name="l01442"></a>01442                   <span class="keywordflow">if</span> ( (elem1=elem(face,0)) &gt; -1)
<a name="l01443"></a>01443                     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; ncomp; i++)
<a name="l01444"></a>01444                       matrice(elem1*ncomp+i,elem1*ncomp+i)+=aii(i);
<a name="l01445"></a>01445                   <span class="keywordflow">if</span> ( (elem2=elem(face,1)) &gt; -1)
<a name="l01446"></a>01446                     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; ncomp; i++)
<a name="l01447"></a>01447                       matrice(elem2*ncomp+i,elem2*ncomp+i)+=ajj(i);
<a name="l01448"></a>01448                 }
<a name="l01449"></a>01449             }
<a name="l01450"></a>01450           <span class="keywordflow">break</span>;
<a name="l01451"></a>01451         <span class="keywordflow">case</span> <a class="code" href="Iterateur__PolyMAC__base_8h.html#adda1d69a86f9e3be7366c5f4c6ace649ab83c671c148d8664c5c87f343d2ab9fd" title="periodique">periodique</a> :
<a name="l01452"></a>01452           <span class="keywordflow">if</span> (flux_evaluateur.calculer_flux_faces_periodique())
<a name="l01453"></a>01453             {
<a name="l01454"></a>01454               <span class="keyword">const</span> <a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>&amp; cl =(<span class="keyword">const</span> <a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>&amp;) (la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>());
<a name="l01455"></a>01455               <span class="keywordflow">for</span> (face=ndeb; face&lt;nfin; face++)
<a name="l01456"></a>01456                 {
<a name="l01457"></a>01457                   flux_evaluateur.coeffs_face(face,ndeb, cl, aii, ajj);
<a name="l01458"></a>01458                   elem1 = elem(face,0);
<a name="l01459"></a>01459                   elem2 = elem(face,1);
<a name="l01460"></a>01460                   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; ncomp; i++)
<a name="l01461"></a>01461                     {
<a name="l01462"></a>01462                       <span class="keywordtype">int</span> n1=elem1*ncomp+i;
<a name="l01463"></a>01463                       <span class="keywordtype">int</span> n2=elem2*ncomp+i;
<a name="l01464"></a>01464                       matrice(n1,n1)+=0.5*aii(i);
<a name="l01465"></a>01465                       matrice(n1,n2)-=0.5*ajj(i);
<a name="l01466"></a>01466                       matrice(n2,n2)+=0.5*ajj(i);
<a name="l01467"></a>01467                       matrice(n2,n1)-=0.5*aii(i);
<a name="l01468"></a>01468                     }
<a name="l01469"></a>01469                 }
<a name="l01470"></a>01470             }
<a name="l01471"></a>01471           <span class="keywordflow">break</span>;
<a name="l01472"></a>01472         <span class="keywordflow">default</span> :
<a name="l01473"></a>01473           <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;On ne reconnait pas la condition limite : &quot;</span> &lt;&lt; la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>();
<a name="l01474"></a>01474           exit();
<a name="l01475"></a>01475           <span class="keywordflow">break</span>;
<a name="l01476"></a>01476         }
<a name="l01477"></a>01477     }
<a name="l01478"></a>01478 }
<a name="l01479"></a>01479 
<a name="l01480"></a><a class="code" href="classT__It__VDF__Elem.html#a5ab524280db69182287cbe3f25666f9b">01480</a> <span class="keyword">template</span> &lt;<span class="keyword">class</span> _TYPE_&gt;  <span class="keywordtype">void</span> <a class="code" href="classT__It__VDF__Elem.html#a5ab524280db69182287cbe3f25666f9b">T_It_VDF_Elem&lt;_TYPE_&gt;::ajouter_contribution_interne</a>(<span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; inco, <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; matrice )<span class="keyword"> const</span>
<a name="l01481"></a>01481 <span class="keyword"></span>{
<a name="l01482"></a>01482   <span class="keyword">const</span> <span class="keywordtype">int</span> ncomp = inco.<a class="code" href="classDoubleVect.html#ab02d01cd1bdab66fbd66f9a47cc29e10">line_size</a>();
<a name="l01483"></a>01483   <span class="keyword">const</span> <a class="code" href="classZone__VDF.html" title="class Zone_VDF Classe instanciable qui derive de Zone_VF. Cette classe contient les informations geom...">Zone_VDF</a>&amp; zone_VDF = la_zone.valeur();
<a name="l01484"></a>01484   <span class="keywordtype">int</span> face,i;
<a name="l01485"></a>01485   <a class="code" href="classDoubleVect.html">DoubleVect</a> aii(ncomp), ajj(ncomp);
<a name="l01486"></a>01486   <span class="keywordtype">int</span> elem1,elem2;
<a name="l01487"></a>01487   <span class="keywordtype">int</span> ndeb=zone_VDF.<a class="code" href="classZone__VF.html#a12869806fa4834aca8f2964e16509dfd" title="une face est interne ssi elle separe deux elements. renvoie le numero de la premiere face interne...">premiere_face_int</a>();
<a name="l01488"></a>01488   <span class="keywordtype">int</span> nfin=zone_VDF.<a class="code" href="classZone__VF.html#aede27992d9f2eedd52c24d4a80ff7ffb" title="renvoie le nombre global de faces.">nb_faces</a>();
<a name="l01489"></a>01489   <span class="keywordflow">for</span> (face=ndeb; face&lt;nfin; face++)
<a name="l01490"></a>01490     {
<a name="l01491"></a>01491       elem1 = elem(face,0);
<a name="l01492"></a>01492       elem2 = elem(face,1);
<a name="l01493"></a>01493       flux_evaluateur.coeffs_faces_interne(face, aii, ajj);
<a name="l01494"></a>01494       <span class="keywordflow">for</span> (i=0; i&lt;ncomp; i++)
<a name="l01495"></a>01495         {
<a name="l01496"></a>01496           <span class="keywordtype">int</span> i0=elem1*ncomp+i,j0=elem2*ncomp+i;
<a name="l01497"></a>01497           matrice(i0,i0)+=aii(i) ;
<a name="l01498"></a>01498           matrice(i0,j0)-=ajj(i) ;
<a name="l01499"></a>01499           matrice(j0,j0)+=ajj(i) ;
<a name="l01500"></a>01500           matrice(j0,i0)-=aii(i) ;
<a name="l01501"></a>01501         }
<a name="l01502"></a>01502     }
<a name="l01503"></a>01503 }
<a name="l01504"></a>01504 
<a name="l01505"></a><a class="code" href="classT__It__VDF__Elem.html#a961776f7de2967cf58f1cc8e51ef0463">01505</a> <span class="keyword">template</span> &lt;<span class="keyword">class</span> _TYPE_&gt;  <span class="keywordtype">void</span> <a class="code" href="classT__It__VDF__Elem.html#a961776f7de2967cf58f1cc8e51ef0463">T_It_VDF_Elem&lt;_TYPE_&gt;::ajouter_contribution_interne_vitesse</a>(<span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; inco, <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; matrice)<span class="keyword"> const</span>
<a name="l01506"></a>01506 <span class="keyword"></span>{
<a name="l01507"></a>01507   <span class="keyword">const</span> <a class="code" href="classZone__VDF.html" title="class Zone_VDF Classe instanciable qui derive de Zone_VF. Cette classe contient les informations geom...">Zone_VDF</a>&amp; zone_VDF = la_zone.valeur();
<a name="l01508"></a>01508   <span class="keywordtype">double</span> aef = 0;
<a name="l01509"></a>01509   <span class="keyword">const</span> <span class="keywordtype">int</span> ndeb = zone_VDF.<a class="code" href="classZone__VF.html#a12869806fa4834aca8f2964e16509dfd" title="une face est interne ssi elle separe deux elements. renvoie le numero de la premiere face interne...">premiere_face_int</a>();
<a name="l01510"></a>01510   <span class="keyword">const</span> <span class="keywordtype">int</span> nfin = zone_VDF.<a class="code" href="classZone__VF.html#aede27992d9f2eedd52c24d4a80ff7ffb" title="renvoie le nombre global de faces.">nb_faces</a>();
<a name="l01511"></a>01511   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> f = ndeb; f &lt; nfin; f++)
<a name="l01512"></a>01512     {
<a name="l01513"></a>01513       <span class="keyword">const</span> <span class="keywordtype">int</span> e1 = elem(f, 0);
<a name="l01514"></a>01514       <span class="keyword">const</span> <span class="keywordtype">int</span> e2 = elem(f, 1);
<a name="l01515"></a>01515       aef = flux_evaluateur.coeffs_faces_interne_bloc_vitesse(inco, f);
<a name="l01516"></a>01516       matrice(e1, f) += aef;
<a name="l01517"></a>01517       matrice(e2, f) -= aef;
<a name="l01518"></a>01518     }
<a name="l01519"></a>01519 }
<a name="l01520"></a>01520 
<a name="l01521"></a><a class="code" href="classT__It__VDF__Elem.html#ae7a38e26b2d63f9d0df4561c73289011">01521</a> <span class="keyword">template</span> &lt;<span class="keyword">class</span> _TYPE_&gt;  <span class="keywordtype">void</span> <a class="code" href="classT__It__VDF__Elem.html#ae7a38e26b2d63f9d0df4561c73289011">T_It_VDF_Elem&lt;_TYPE_&gt;::ajouter_contribution_bords_vitesse</a>(<span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; inco, <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; matrice )<span class="keyword"> const</span>
<a name="l01522"></a>01522 <span class="keyword"></span>{
<a name="l01523"></a>01523   <span class="keywordtype">int</span> e1, e2;
<a name="l01524"></a>01524   <span class="keywordtype">double</span> aef=0;
<a name="l01525"></a>01525   <span class="keywordtype">int</span> ndeb, nfin;
<a name="l01526"></a>01526   <span class="keywordtype">int</span> nb_front_Cl=la_zone-&gt;nb_front_Cl();
<a name="l01527"></a>01527   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> num_cl = 0; num_cl&lt;nb_front_Cl; num_cl++)
<a name="l01528"></a>01528     {
<a name="l01529"></a>01529       <span class="comment">/* pour chaque Condition Limite on regarde son type */</span>
<a name="l01530"></a>01530       <span class="keyword">const</span> <a class="code" href="classCond__lim.html" title="classe Cond_lim Classe generique servant a representer n&#39;importe quelle classe derivee de la classe C...">Cond_lim</a>&amp; la_cl = la_zcl-&gt;les_conditions_limites(num_cl);
<a name="l01531"></a>01531       <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp; frontiere_dis = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>,la_cl.<a class="code" href="classCond__lim.html#a5b2d24809cee07727006a891d4ce8d22" title="Appel a l&#39;objet sous-jacent Renvoie la frontiere discretisee associee a la condition aux limites...">frontiere_dis</a>());
<a name="l01532"></a>01532       ndeb = frontiere_dis.<a class="code" href="classFront__VF.html#a4986f0c65653fe9eb40bbbff5a97bf16" title="Numero de la premiere face du bord dans la liste des faces.">num_premiere_face</a>();
<a name="l01533"></a>01533       nfin = ndeb + frontiere_dis.<a class="code" href="classFront__VF.html#a341e2fcb5117b96e745fd7078ba86bab" title="Nombre de faces reelles du bord.">nb_faces</a>();
<a name="l01534"></a>01534       <span class="keywordflow">switch</span>(type_cl(la_cl))
<a name="l01535"></a>01535         {
<a name="l01536"></a>01536         <span class="keywordflow">case</span> <a class="code" href="Iterateur__PolyMAC__base_8h.html#adda1d69a86f9e3be7366c5f4c6ace649ac938491055e13993f3eed68c989f90b0" title="Symetrie.">symetrie</a> :
<a name="l01537"></a>01537           <span class="keywordflow">if</span> (flux_evaluateur.calculer_flux_faces_symetrie())
<a name="l01538"></a>01538             {
<a name="l01539"></a>01539               <span class="keyword">const</span> <a class="code" href="classSymetrie.html" title="classe Symetrie Sur les faces de symetrie on a les proprietes suivantes: - composante normale de la v...">Symetrie</a>&amp; cl =(<span class="keyword">const</span> <a class="code" href="classSymetrie.html" title="classe Symetrie Sur les faces de symetrie on a les proprietes suivantes: - composante normale de la v...">Symetrie</a>&amp;) (la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>());
<a name="l01540"></a>01540               <span class="keywordflow">for</span> (<span class="keywordtype">int</span> f = ndeb; f &lt; nfin; f++)
<a name="l01541"></a>01541                 {
<a name="l01542"></a>01542                   aef = flux_evaluateur.coeffs_face_bloc_vitesse(inco, f, cl, ndeb);
<a name="l01543"></a>01543                   <span class="keywordflow">if</span> ( (e1 = elem(f, 0)) &gt; -1) matrice(e1, f) += aef;
<a name="l01544"></a>01544                   <span class="keywordflow">if</span> ( (e2 = elem(f, 1)) &gt; -1) matrice(e2, f) -= aef;
<a name="l01545"></a>01545                 }
<a name="l01546"></a>01546             }
<a name="l01547"></a>01547           <span class="keywordflow">break</span>;
<a name="l01548"></a>01548         <span class="keywordflow">case</span> <a class="code" href="Iterateur__PolyMAC__base_8h.html#adda1d69a86f9e3be7366c5f4c6ace649ac4317ef27513bbab3cd0ccfd0d9ed199" title="Neumann_sortie_libre ou derivees.">sortie_libre</a> :
<a name="l01549"></a>01549           <span class="keywordflow">if</span> (flux_evaluateur.calculer_flux_faces_sortie_libre())
<a name="l01550"></a>01550             {
<a name="l01551"></a>01551               <span class="keyword">const</span> <a class="code" href="classNeumann__sortie__libre.html" title="classe Neumann_sortie_libre Cette classe represente une frontiere ouverte sans vitesse imposee Pour l...">Neumann_sortie_libre</a>&amp; cl =(<span class="keyword">const</span> <a class="code" href="classNeumann__sortie__libre.html" title="classe Neumann_sortie_libre Cette classe represente une frontiere ouverte sans vitesse imposee Pour l...">Neumann_sortie_libre</a>&amp;) (la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>());
<a name="l01552"></a>01552               <span class="keywordflow">for</span> (<span class="keywordtype">int</span> f = ndeb; f &lt; nfin; f++)
<a name="l01553"></a>01553                 {
<a name="l01554"></a>01554                   aef = flux_evaluateur.coeffs_face_bloc_vitesse(inco, f, cl, ndeb);
<a name="l01555"></a>01555                   <span class="keywordflow">if</span> ( (e1 = elem(f, 0)) &gt; -1) matrice(e1, f) += aef;
<a name="l01556"></a>01556                   <span class="keywordflow">if</span> ( (e2 = elem(f, 1)) &gt; -1) matrice(e2, f) -= aef;
<a name="l01557"></a>01557                 }
<a name="l01558"></a>01558             }
<a name="l01559"></a>01559           <span class="keywordflow">break</span>;
<a name="l01560"></a>01560         <span class="keywordflow">case</span> <a class="code" href="Iterateur__PolyMAC__base_8h.html#adda1d69a86f9e3be7366c5f4c6ace649a594fd60a4576f47654eed7df53dee9be" title="Dirichlet_entree_fluide.">entree_fluide</a> :
<a name="l01561"></a>01561           <span class="keywordflow">if</span> (flux_evaluateur.calculer_flux_faces_entree_fluide())
<a name="l01562"></a>01562             {
<a name="l01563"></a>01563               <span class="keyword">const</span> <a class="code" href="classDirichlet__entree__fluide.html" title="classe Dirichlet_entree_fluide Cette classe represente une condition aux limite imposant une grandeur...">Dirichlet_entree_fluide</a>&amp; cl =(<span class="keyword">const</span> <a class="code" href="classDirichlet__entree__fluide.html" title="classe Dirichlet_entree_fluide Cette classe represente une condition aux limite imposant une grandeur...">Dirichlet_entree_fluide</a>&amp;) (la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>());
<a name="l01564"></a>01564               <span class="keywordflow">for</span> (<span class="keywordtype">int</span> f = ndeb; f &lt; nfin; f++)
<a name="l01565"></a>01565                 {
<a name="l01566"></a>01566                   aef = flux_evaluateur.coeffs_face_bloc_vitesse(inco, f, cl, ndeb);
<a name="l01567"></a>01567                   <span class="keywordflow">if</span> ( (e1 = elem(f, 0)) &gt; -1) matrice(e1, f) += aef;
<a name="l01568"></a>01568                   <span class="keywordflow">if</span> ( (e2 = elem(f, 1)) &gt; -1) matrice(e2, f) -= aef;
<a name="l01569"></a>01569                 }
<a name="l01570"></a>01570             }
<a name="l01571"></a>01571           <span class="keywordflow">break</span>;
<a name="l01572"></a>01572         <span class="keywordflow">case</span> <a class="code" href="Iterateur__PolyMAC__base_8h.html#adda1d69a86f9e3be7366c5f4c6ace649a497d92e00f36c1c7ec874c0a318db91e" title="Dirichlet_paroi_fixe.">paroi_fixe</a> :
<a name="l01573"></a>01573           <span class="keywordflow">if</span> (flux_evaluateur.calculer_flux_faces_paroi_fixe())
<a name="l01574"></a>01574             {
<a name="l01575"></a>01575               <span class="keyword">const</span> <a class="code" href="classDirichlet__paroi__fixe.html" title="classe Dirichlet_paroi_fixe Represente une paroi immobile dans une equation de type Navier_Stokes...">Dirichlet_paroi_fixe</a>&amp; cl =(<span class="keyword">const</span> <a class="code" href="classDirichlet__paroi__fixe.html" title="classe Dirichlet_paroi_fixe Represente une paroi immobile dans une equation de type Navier_Stokes...">Dirichlet_paroi_fixe</a>&amp;) (la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>());
<a name="l01576"></a>01576               <span class="keywordflow">for</span> (<span class="keywordtype">int</span> f = ndeb; f &lt; nfin; f++)
<a name="l01577"></a>01577                 {
<a name="l01578"></a>01578                   aef = flux_evaluateur.coeffs_face_bloc_vitesse(inco, f, cl, ndeb);
<a name="l01579"></a>01579                   <span class="keywordflow">if</span> ( (e1 = elem(f, 0)) &gt; -1) matrice(e1, f) += aef;
<a name="l01580"></a>01580                   <span class="keywordflow">if</span> ( (e2 = elem(f, 1)) &gt; -1) matrice(e2, f) -= aef;
<a name="l01581"></a>01581                 }
<a name="l01582"></a>01582             }
<a name="l01583"></a>01583           <span class="keywordflow">break</span>;
<a name="l01584"></a>01584         <span class="keywordflow">case</span> <a class="code" href="Iterateur__PolyMAC__base_8h.html#adda1d69a86f9e3be7366c5f4c6ace649acdd1bf461cb105b93d5a9b003ce33141" title="Dirichlet_paroi_defilante.">paroi_defilante</a> :
<a name="l01585"></a>01585           <span class="keywordflow">if</span> (flux_evaluateur.calculer_flux_faces_paroi_defilante())
<a name="l01586"></a>01586             {
<a name="l01587"></a>01587               <span class="keyword">const</span> <a class="code" href="classDirichlet__paroi__defilante.html" title="classe Dirichlet_paroi_defilante Impose la vitesse de paroi dnas une equation de type Navier_Stokes...">Dirichlet_paroi_defilante</a>&amp; cl =(<span class="keyword">const</span> <a class="code" href="classDirichlet__paroi__defilante.html" title="classe Dirichlet_paroi_defilante Impose la vitesse de paroi dnas une equation de type Navier_Stokes...">Dirichlet_paroi_defilante</a>&amp;) (la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>());
<a name="l01588"></a>01588               <span class="keywordflow">for</span> (<span class="keywordtype">int</span> f = ndeb; f &lt; nfin; f++)
<a name="l01589"></a>01589                 {
<a name="l01590"></a>01590                   aef = flux_evaluateur.coeffs_face_bloc_vitesse(inco, f, cl, ndeb);
<a name="l01591"></a>01591                   <span class="keywordflow">if</span> ( (e1 = elem(f, 0)) &gt; -1) matrice(e1, f) += aef;
<a name="l01592"></a>01592                   <span class="keywordflow">if</span> ( (e2 = elem(f, 1)) &gt; -1) matrice(e2, f) -= aef;
<a name="l01593"></a>01593                 }
<a name="l01594"></a>01594             }
<a name="l01595"></a>01595           <span class="keywordflow">break</span>;
<a name="l01596"></a>01596         <span class="keywordflow">case</span> <a class="code" href="classparoi__adiabatique.html">paroi_adiabatique</a> :
<a name="l01597"></a>01597           <span class="keywordflow">if</span> (flux_evaluateur.calculer_flux_faces_paroi_adiabatique())
<a name="l01598"></a>01598             {
<a name="l01599"></a>01599               <span class="keyword">const</span> <a class="code" href="classNeumann__paroi__adiabatique.html" title="Classe Neumann_paroi_adiabatique Cette condition limite correspond a une paroi adiabatique dans une e...">Neumann_paroi_adiabatique</a>&amp; cl =(<span class="keyword">const</span> <a class="code" href="classNeumann__paroi__adiabatique.html" title="Classe Neumann_paroi_adiabatique Cette condition limite correspond a une paroi adiabatique dans une e...">Neumann_paroi_adiabatique</a>&amp;) (la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>());
<a name="l01600"></a>01600               <span class="keywordflow">for</span> (<span class="keywordtype">int</span> f = ndeb; f &lt; nfin; f++)
<a name="l01601"></a>01601                 {
<a name="l01602"></a>01602                   aef = flux_evaluateur.coeffs_face_bloc_vitesse(inco, f, cl, ndeb);
<a name="l01603"></a>01603                   <span class="keywordflow">if</span> ( (e1 = elem(f, 0)) &gt; -1) matrice(e1, f) += aef;
<a name="l01604"></a>01604                   <span class="keywordflow">if</span> ( (e2 = elem(f, 1)) &gt; -1) matrice(e2, f) -= aef;
<a name="l01605"></a>01605                 }
<a name="l01606"></a>01606             }
<a name="l01607"></a>01607           <span class="keywordflow">break</span>;
<a name="l01608"></a>01608         <span class="keywordflow">case</span> <a class="code" href="Iterateur__PolyMAC__base_8h.html#adda1d69a86f9e3be7366c5f4c6ace649af695f3ba17490e07dc3259c85875d8d6" title="Neumann_paroi.">paroi</a> :
<a name="l01609"></a>01609           <span class="keywordflow">if</span> (flux_evaluateur.calculer_flux_faces_paroi())
<a name="l01610"></a>01610             {
<a name="l01611"></a>01611               <span class="keyword">const</span> <a class="code" href="classNeumann__paroi.html" title="Classe Neumann_paroi Cette condition limite correspond a un flux impose pour l&#39;equation de transport ...">Neumann_paroi</a>&amp; cl =(<span class="keyword">const</span> <a class="code" href="classNeumann__paroi.html" title="Classe Neumann_paroi Cette condition limite correspond a un flux impose pour l&#39;equation de transport ...">Neumann_paroi</a>&amp;) (la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>());
<a name="l01612"></a>01612               <span class="keywordflow">for</span> (<span class="keywordtype">int</span> f = ndeb; f &lt; nfin; f++)
<a name="l01613"></a>01613                 {
<a name="l01614"></a>01614                   aef = flux_evaluateur.coeffs_face_bloc_vitesse(inco, f, cl, ndeb);
<a name="l01615"></a>01615                   <span class="keywordflow">if</span> ( (e1 = elem(f, 0)) &gt; -1) matrice(e1, f) += aef;
<a name="l01616"></a>01616                   <span class="keywordflow">if</span> ( (e2 = elem(f, 1)) &gt; -1) matrice(e2, f) -= aef;
<a name="l01617"></a>01617                 }
<a name="l01618"></a>01618             }
<a name="l01619"></a>01619           <span class="keywordflow">break</span>;
<a name="l01620"></a>01620         <span class="keywordflow">case</span> <a class="code" href="Iterateur__PolyMAC__base_8h.html#adda1d69a86f9e3be7366c5f4c6ace649a38f997f881a13a46f2d06012162cf833" title="Echange_externe_impose.">echange_externe_impose</a> :
<a name="l01621"></a>01621           <span class="keywordflow">if</span> (flux_evaluateur.calculer_flux_faces_echange_externe_impose())
<a name="l01622"></a>01622             {
<a name="l01623"></a>01623               <span class="keyword">const</span> <a class="code" href="classEchange__externe__impose.html" title="Classe Echange_externe_impose: Cette classe represente le cas particulier de la classe Echange_impose...">Echange_externe_impose</a>&amp; cl =(<span class="keyword">const</span> <a class="code" href="classEchange__externe__impose.html" title="Classe Echange_externe_impose: Cette classe represente le cas particulier de la classe Echange_impose...">Echange_externe_impose</a>&amp;) (la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>());
<a name="l01624"></a>01624               <span class="keywordtype">int</span> boundary_index=-1;
<a name="l01625"></a>01625               <span class="keywordflow">if</span> (la_zone.valeur().front_VF(num_cl).le_nom() == frontiere_dis.<a class="code" href="classFrontiere__dis__base.html#a5a7eb46dc3af8a7d4225adc1814845d8" title="Renvoie le nom de la frontiere geometrique.">le_nom</a>())
<a name="l01626"></a>01626                 boundary_index=num_cl;
<a name="l01627"></a>01627 
<a name="l01628"></a>01628               <span class="keywordflow">for</span> (<span class="keywordtype">int</span> f = ndeb; f &lt; nfin; f++)
<a name="l01629"></a>01629                 {
<a name="l01630"></a>01630                   <span class="keywordtype">int</span> local_face=la_zone.valeur().front_VF(boundary_index).num_local_face(f);
<a name="l01631"></a>01631                   aef = flux_evaluateur.coeffs_face_bloc_vitesse(inco, boundary_index, f, local_face, cl, ndeb);
<a name="l01632"></a>01632                   <span class="keywordflow">if</span> ( (e1 = elem(f, 0)) &gt; -1) matrice(e1, f) += aef;
<a name="l01633"></a>01633                   <span class="keywordflow">if</span> ( (e2 = elem(f, 1)) &gt; -1) matrice(e1, f) -= aef;
<a name="l01634"></a>01634                 }
<a name="l01635"></a>01635             }
<a name="l01636"></a>01636           <span class="keywordflow">break</span>;
<a name="l01637"></a>01637         <span class="keywordflow">case</span> <a class="code" href="Iterateur__PolyMAC__base_8h.html#adda1d69a86f9e3be7366c5f4c6ace649a9201b83c6fe44d3928abbe5f73364323" title="Echange_global_impose.">echange_global_impose</a> :
<a name="l01638"></a>01638           <span class="keywordflow">if</span> (flux_evaluateur.calculer_flux_faces_echange_global_impose())
<a name="l01639"></a>01639             {
<a name="l01640"></a>01640               <span class="keyword">const</span> <a class="code" href="classEchange__global__impose.html" title="Classe Echange_global_impose Cette classe represente le cas particulier de la classe Echange_impose_b...">Echange_global_impose</a>&amp; cl =(<span class="keyword">const</span> <a class="code" href="classEchange__global__impose.html" title="Classe Echange_global_impose Cette classe represente le cas particulier de la classe Echange_impose_b...">Echange_global_impose</a>&amp;) (la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>());
<a name="l01641"></a>01641               <span class="keywordflow">for</span> (<span class="keywordtype">int</span> f = ndeb; f &lt; nfin; f++)
<a name="l01642"></a>01642                 {
<a name="l01643"></a>01643                   aef = flux_evaluateur.coeffs_face_bloc_vitesse(inco, f, cl, ndeb);
<a name="l01644"></a>01644                   <span class="keywordflow">if</span> ( (e1 = elem(f, 0)) &gt; -1) matrice(e1, f) += aef;
<a name="l01645"></a>01645                   <span class="keywordflow">if</span> ( (e2 = elem(f, 1)) &gt; -1) matrice(e2, f) -= aef;
<a name="l01646"></a>01646                 }
<a name="l01647"></a>01647             }
<a name="l01648"></a>01648           <span class="keywordflow">break</span>;
<a name="l01649"></a>01649         <span class="keywordflow">case</span> <a class="code" href="Iterateur__PolyMAC__base_8h.html#adda1d69a86f9e3be7366c5f4c6ace649adbce3cca9532937c741ae3ac77dc2d54" title="NSCBC.">nscbc</a> :
<a name="l01650"></a>01650           <span class="keywordflow">if</span> (flux_evaluateur.calculer_flux_faces_NSCBC())
<a name="l01651"></a>01651             {
<a name="l01652"></a>01652               <span class="keyword">const</span> <a class="code" href="classNSCBC.html" title="classe">NSCBC</a>&amp; cl =(<span class="keyword">const</span> <a class="code" href="classNSCBC.html" title="classe">NSCBC</a>&amp;) (la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>());
<a name="l01653"></a>01653               <span class="keywordflow">for</span> (<span class="keywordtype">int</span> f = ndeb; f &lt; nfin; f++)
<a name="l01654"></a>01654                 {
<a name="l01655"></a>01655                   aef = flux_evaluateur.coeffs_face_bloc_vitesse(inco, f, cl, ndeb);
<a name="l01656"></a>01656                   <span class="keywordflow">if</span> ( (e1 = elem(f, 0)) &gt; -1) matrice(e1, f) += aef;
<a name="l01657"></a>01657                   <span class="keywordflow">if</span> ( (e2 = elem(f, 1)) &gt; -1) matrice(e2, f) -= aef;
<a name="l01658"></a>01658                 }
<a name="l01659"></a>01659             }
<a name="l01660"></a>01660           <span class="keywordflow">break</span>;
<a name="l01661"></a>01661         <span class="keywordflow">case</span> <a class="code" href="Iterateur__PolyMAC__base_8h.html#adda1d69a86f9e3be7366c5f4c6ace649ab83c671c148d8664c5c87f343d2ab9fd" title="periodique">periodique</a> :
<a name="l01662"></a>01662           <span class="keywordflow">if</span> (flux_evaluateur.calculer_flux_faces_periodique())
<a name="l01663"></a>01663             {
<a name="l01664"></a>01664               <span class="keyword">const</span> <a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>&amp; cl =(<span class="keyword">const</span> <a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>&amp;) (la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>());
<a name="l01665"></a>01665               <span class="keywordflow">for</span> (<span class="keywordtype">int</span> f = ndeb; f &lt; nfin; f++)
<a name="l01666"></a>01666                 {
<a name="l01667"></a>01667                   aef = flux_evaluateur.coeffs_face_bloc_vitesse(inco, f, cl, ndeb);
<a name="l01668"></a>01668                   <span class="keywordflow">if</span> ( (e1 = elem(f, 0)) &gt; -1)
<a name="l01669"></a>01669                     {
<a name="l01670"></a>01670                       <span class="keywordflow">if</span> ( f &lt; (ndeb+frontiere_dis.<a class="code" href="classFront__VF.html#a341e2fcb5117b96e745fd7078ba86bab" title="Nombre de faces reelles du bord.">nb_faces</a>()/2) )
<a name="l01671"></a>01671                         matrice(e1, f) += aef;
<a name="l01672"></a>01672                     }
<a name="l01673"></a>01673                   <span class="keywordflow">if</span> ( (e2 = elem(f, 1)) &gt; -1)
<a name="l01674"></a>01674                     {
<a name="l01675"></a>01675                       <span class="keywordflow">if</span> ( (ndeb+frontiere_dis.<a class="code" href="classFront__VF.html#a341e2fcb5117b96e745fd7078ba86bab" title="Nombre de faces reelles du bord.">nb_faces</a>()/2) &lt;= f )
<a name="l01676"></a>01676                         matrice(e2, f) -= aef;
<a name="l01677"></a>01677                     }
<a name="l01678"></a>01678                 }
<a name="l01679"></a>01679             }
<a name="l01680"></a>01680           <span class="keywordflow">break</span>;
<a name="l01681"></a>01681         <span class="keywordflow">default</span> :
<a name="l01682"></a>01682           <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;On ne reconnait pas la condition limite : &quot;</span> &lt;&lt; la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>();
<a name="l01683"></a>01683           exit();
<a name="l01684"></a>01684           <span class="keywordflow">break</span>;
<a name="l01685"></a>01685         }
<a name="l01686"></a>01686 
<a name="l01687"></a>01687     }
<a name="l01688"></a>01688 }
<a name="l01689"></a>01689 
<a name="l01690"></a><a class="code" href="classT__It__VDF__Elem.html#a4e06ea2303d06f5d88619dfde55e280c">01690</a> <span class="keyword">template</span> &lt;<span class="keyword">class</span> _TYPE_&gt;  <span class="keywordtype">void</span> <a class="code" href="classT__It__VDF__Elem.html#a4e06ea2303d06f5d88619dfde55e280c">T_It_VDF_Elem&lt;_TYPE_&gt;::ajouter_contribution_autre_pb</a>(<span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; inco, <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; matrice, <span class="keyword">const</span> <a class="code" href="classCond__lim.html" title="classe Cond_lim Classe generique servant a representer n&#39;importe quelle classe derivee de la classe C...">Cond_lim</a>&amp; la_cl, std::map&lt;<span class="keywordtype">int</span>, std::pair&lt;int, int&gt;&gt;&amp; f2e)<span class="keyword"> const</span>
<a name="l01691"></a>01691 <span class="keyword"></span>{
<a name="l01692"></a>01692   <span class="keywordtype">double</span> aii=0, ajj=0;
<a name="l01693"></a>01693   <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp; frontiere_dis = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>, la_cl.<a class="code" href="classCond__lim.html#a5b2d24809cee07727006a891d4ce8d22" title="Appel a l&#39;objet sous-jacent Renvoie la frontiere discretisee associee a la condition aux limites...">frontiere_dis</a>());
<a name="l01694"></a>01694   <span class="keyword">const</span> <span class="keywordtype">int</span> ndeb = frontiere_dis.<a class="code" href="classFront__VF.html#a4986f0c65653fe9eb40bbbff5a97bf16" title="Numero de la premiere face du bord dans la liste des faces.">num_premiere_face</a>();
<a name="l01695"></a>01695   <span class="keyword">const</span> <span class="keywordtype">int</span> nfin = ndeb + frontiere_dis.<a class="code" href="classFront__VF.html#a341e2fcb5117b96e745fd7078ba86bab" title="Nombre de faces reelles du bord.">nb_faces</a>();
<a name="l01696"></a>01696 <span class="comment">// assert(cl est bien paroi contact)</span>
<a name="l01697"></a>01697   <span class="keywordflow">if</span> (flux_evaluateur.calculer_flux_faces_echange_global_impose())
<a name="l01698"></a>01698     {
<a name="l01699"></a>01699       <span class="keyword">const</span> <a class="code" href="classEchange__global__impose.html" title="Classe Echange_global_impose Cette classe represente le cas particulier de la classe Echange_impose_b...">Echange_global_impose</a>&amp; cl =(<span class="keyword">const</span> <a class="code" href="classEchange__global__impose.html" title="Classe Echange_global_impose Cette classe represente le cas particulier de la classe Echange_impose_b...">Echange_global_impose</a>&amp;) (la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>());
<a name="l01700"></a>01700       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> f = ndeb; f &lt; nfin; f++)
<a name="l01701"></a>01701         {
<a name="l01702"></a>01702           flux_evaluateur.coeffs_face(f, ndeb, cl, aii, ajj);
<a name="l01703"></a>01703           <span class="keyword">const</span> <span class="keywordtype">int</span> e1 = f2e[f].first, e2 = f2e[f].second;
<a name="l01704"></a>01704           matrice(e1, e2) = -(elem(f, 0) &gt; -1 ? aii : ajj);
<a name="l01705"></a>01705         }
<a name="l01706"></a>01706     }
<a name="l01707"></a>01707 }
<a name="l01708"></a>01708 <span class="preprocessor">#endif</span>
<a name="l01709"></a>01709 <span class="preprocessor"></span>
</pre></div></div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Tue Dec 14 2021 19:35:39 for TRUST by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
