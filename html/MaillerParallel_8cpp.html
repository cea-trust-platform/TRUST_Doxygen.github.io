<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>TRUST: src/Kernel/Geometrie/MaillerParallel.cpp File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">TRUST&#160;<span id="projectnumber">1.8.4</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">src/Kernel/Geometrie/MaillerParallel.cpp File Reference</div>  </div>
</div>
<div class="contents">
<div class="textblock"><code>#include &lt;<a class="el" href="MaillerParallel_8h_source.html">MaillerParallel.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="Domaine_8h_source.html">Domaine.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="Motcle_8h_source.html">Motcle.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="Scatter_8h_source.html">Scatter.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="Statistiques_8h_source.html">Statistiques.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="Param_8h_source.html">Param.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="Vect__ArrOfDouble_8h_source.html">Vect_ArrOfDouble.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="Parser__U_8h_source.html">Parser_U.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="Reordonner__faces__periodiques_8h_source.html">Reordonner_faces_periodiques.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="EFichier_8h_source.html">EFichier.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="Schema__Comm_8h_source.html">Schema_Comm.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="Octree__Double_8h_source.html">Octree_Double.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="Faces__builder_8h_source.html">Faces_builder.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="Connectivite__som__elem_8h_source.html">Connectivite_som_elem.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="Static__Int__Lists_8h_source.html">Static_Int_Lists.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="communications_8h_source.html">communications.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="ArrOfBit_8h_source.html">ArrOfBit.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="Array__tools_8h_source.html">Array_tools.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="Ref__Joint_8h_source.html">Ref_Joint.h</a>&gt;</code><br/>
</div>
<p><a href="MaillerParallel_8cpp_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBlocData.html">BlocData</a></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="MaillerParallel_8cpp.html#a6ba3b4bcfd66200d20aad91d85653444">bbox_intersection</a> (const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;bboxes, int i, int j, double epsilon)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="MaillerParallel_8cpp.html#a84d7b23bed74996cd415586161aa92fd">find_matching_coordinates</a> (const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;coords, <a class="el" href="classVect__ArrOfInt.html">Vect_ArrOfInt</a> &amp;match, double epsilon)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">for a given set of local coordinates, finds which other processors<br/>
share the same nodes.<br/>
match must be sized to <a class="el" href="classProcess.html#a6bf692ce58d9578aa62ac3c07b8caaa1" title="renvoie le nombre de processeurs dans le groupe courant Voir Comm_Group::nproc() et PE_Groups::curren...">Process::nproc()</a> and will be filled with, for each processor,<br/>
the indexes of coordinates that the corresponding processor shares with me.<br/>
Nodes are listed in the same order on couples of processors sharing a list of nodes<br/>
match[<a class="el" href="classProcess.html#ab55ba07167ec807ed3a145cac0f5dca4" title="renvoie mon rang dans le groupe de communication courant. Voir Comm_Group::rank() et PE_Groups::curre...">Process::me()</a>] will be left empty.  <a href="#a84d7b23bed74996cd415586161aa92fd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="MaillerParallel_8cpp.html#aaffcc9b5476334db05eb75b524a20d5d">find_joint_faces</a> (const <a class="el" href="classZone.html">Zone</a> &amp;zone, <a class="el" href="classIntTab.html">IntTab</a> &amp;faces)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">finds all faces of all elements that<br/>
- have only one neighbour elements<br/>
- and do not belong to a boundary&lt;br&gt;(these are joint faces)<br/>
Fills "faces" with the local node numbers of the faces that have been found.  <a href="#aaffcc9b5476334db05eb75b524a20d5d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="MaillerParallel_8cpp.html#a36b86a59ab5c59e71d833df1b70903ab">auto_build_joints</a> (<a class="el" href="classZone.html">Zone</a> &amp;zone, const int epaisseur_joint)</td></tr>
<tr><td colspan="2"><h2><a name="var-members"></a>
Variables</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classType__info.html">Type_info</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="MaillerParallel_8cpp.html#a0be7bff9e7d678a6d4793cb7dde80076">MaillerParallelbases</a> [1] = { &amp;( <a class="el" href="classInterprete.html">Interprete</a> ::info_obj)}</td></tr>
</table>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a36b86a59ab5c59e71d833df1b70903ab"></a><!-- doxytag: member="MaillerParallel.cpp::auto_build_joints" ref="a36b86a59ab5c59e71d833df1b70903ab" args="(Zone &amp;zone, const int epaisseur_joint)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void auto_build_joints </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classZone.html">Zone</a> &amp;&#160;</td>
          <td class="paramname"><em>zone</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>epaisseur_joint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>&lt; copie du tableau</p>
<p>&lt; init with 0. </p>
</p>

<p>Definition at line <a class="el" href="MaillerParallel_8cpp_source.html#l00421">421</a> of file <a class="el" href="MaillerParallel_8cpp_source.html">MaillerParallel.cpp</a>.</p>

<p>References <a class="el" href="Joints_8h_source.html#l00028">List_Joint::add()</a>, <a class="el" href="Joint_8cpp_source.html#l00092">Joint::affecte_epaisseur()</a>, <a class="el" href="Joint_8cpp_source.html#l00085">Joint::affecte_PEvoisin()</a>, <a class="el" href="Scatter_8cpp_source.html#l00778">array_trier_retirer_doublons()</a>, <a class="el" href="Frontiere_8cpp_source.html#l00093">Frontiere::associer_zone()</a>, <a class="el" href="IntTab_8h_source.html#l00233">IntTab::dimension()</a>, <a class="el" href="DoubleTab_8h_source.html#l00243">DoubleTab::dimension()</a>, <a class="el" href="Faces_8cpp_source.html#l00386">Faces::dimensionner()</a>, <a class="el" href="Zone_8cpp_source.html#l00262">Zone::domaine()</a>, <a class="el" href="Frontiere_8h_source.html#l00175">Frontiere::faces()</a>, <a class="el" href="Zone_8h_source.html#l01098">Zone::faces_joint()</a>, <a class="el" href="MaillerParallel_8cpp_source.html#l00355">find_joint_faces()</a>, <a class="el" href="MaillerParallel_8cpp_source.html#l00232">find_matching_coordinates()</a>, <a class="el" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>, <a class="el" href="Process_8cpp_source.html#l00345">Process::Journal()</a>, <a class="el" href="Faces_8h_source.html#l00268">Faces::les_sommets()</a>, <a class="el" href="Domaine_8h_source.html#l00577">Domaine::les_sommets()</a>, <a class="el" href="Array__base_8h_source.html#l00038">Array_base::NOCOPY_NOINIT</a>, <a class="el" href="Frontiere_8cpp_source.html#l00113">Frontiere::nommer()</a>, <a class="el" href="Process_8cpp_source.html#l00109">Process::nproc()</a>, <a class="el" href="ArrOfInt_8cpp_source.html#l00897">ArrOfInt::ordonne_array()</a>, <a class="el" href="Joint_8cpp_source.html#l00099">Joint::PEvoisin()</a>, <a class="el" href="Ref_8h_source.html#l00026">REF</a>, <a class="el" href="DoubleTab_8cpp_source.html#l00335">DoubleTab::resize()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00240">ArrOfInt::resize_array()</a>, <a class="el" href="Joint__Items_8cpp_source.html#l00056">Joint_Items::set_items_communs()</a>, <a class="el" href="Joint_8cpp_source.html#l00159">Joint::set_joint_item()</a>, <a class="el" href="liste_8cpp_source.html#l00175">liste::size()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00342">ArrOfInt::size_array()</a>, <a class="el" href="Joint_8h_source.html#l00066">Joint::SOMMET</a>, <a class="el" href="Scatter_8cpp_source.html#l00752">Scatter::trier_les_joints()</a>, <a class="el" href="Zone_8h_source.html#l00491">Zone::type_elem()</a>, <a class="el" href="classElem__geom__base.html#af781819b042bc5d8fec8b2255e32b498">Elem_geom_base::type_face()</a>, <a class="el" href="Faces_8cpp_source.html#l00461">Faces::typer()</a>, <a class="el" href="Elem__geom_8h_source.html#l00044">Deriv_Elem_geom_base::valeur()</a>, and <a class="el" href="Vect_8h_source.html#l00026">VECT</a>.</p>

<p>Referenced by <a class="el" href="MaillerParallel_8cpp_source.html#l00534">MaillerParallel::interpreter()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">const</span> <span class="keywordtype">double</span> epsilon = 1e-10;
  <span class="keywordtype">int</span> i, j;
<span class="comment">// Find joint faces (faces with 1 neighbour element not registered in boundary faces)</span>
  <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a> faces;
  <a class="code" href="MaillerParallel_8cpp.html#aaffcc9b5476334db05eb75b524a20d5d" title="finds all faces of all elements that - have only one neighbour elements - and do not belong to a boun...">find_joint_faces</a>(zone, faces);

  <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; sommets = zone.<a class="code" href="classZone.html#a379ad2206b5a13a4f4f3df6d44c7546a" title="Renvoie le domaine dont la zone fait partie. (version const)">domaine</a>().<a class="code" href="classDomaine.html#a0846ac03a10b65c4df911fe35a19c02f" title="Renvoie le nombre total de sommets.">les_sommets</a>();
<span class="comment">// List of unique local boundary node numbers</span>
  <span class="keyword">const</span> <span class="keywordtype">int</span> dim = sommets.<a class="code" href="classDoubleTab.html#ac3805e2637a3b880ba2d3e650c69dac4" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(1);

  {
    <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> boundary_nodes_index;
    boundary_nodes_index = faces; <span class="comment">//!&lt; copie du tableau</span>
<span class="comment"></span>    <a class="code" href="Scatter_8cpp.html#a23c4d19dc90caae2323f04de90621709" title="Methode outil pour retirer les doublons dans un tableau.">array_trier_retirer_doublons</a>(boundary_nodes_index);
    <span class="keyword">const</span> <span class="keywordtype">int</span> ncoord = boundary_nodes_index.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>();
<span class="comment">// Fill nodes coordinates and bounding boxes</span>
    <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a> coord;
    coord.<a class="code" href="classDoubleTab.html#ae83b4d31205c53d9c8d2b43da178ce75" title="Change la taille du vecteur (identique a resize_array() pour le traitement des anciennes valeurs et d...">resize</a>(ncoord, dim, <a class="code" href="classArray__base.html#abee342aa9ac59623c4c782dc9d7877ffaf6ae9ba7eb51c5f298ce693345b3ec68">Array_base::NOCOPY_NOINIT</a>);
    <span class="keywordflow">for</span> (i = 0; i &lt; ncoord; i++)
      {
        <span class="keyword">const</span> <span class="keywordtype">int</span> som = boundary_nodes_index[i];
        <span class="keywordflow">for</span> (j = 0; j &lt; dim; j++)
          coord(i, j) = sommets(som, j);
      }
    <a class="code" href="Vect_8h.html#adc7c7b04809c9aec2cb897cd2ef06378">VECT</a>(<a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>) match(<a class="code" href="classProcess.html" title="Classe de base de TRUST (notamment Objet_U). Elle fournit quelques services de base accessibles de pa...">Process</a>::nproc());
    <a class="code" href="MaillerParallel_8cpp.html#a84d7b23bed74996cd415586161aa92fd" title="for a given set of local coordinates, finds which other processors share the same nodes...">find_matching_coordinates</a>(coord, match, epsilon);

    for (<span class="keywordtype">int</span> pe = 0; pe &lt; match.size(); pe++)
      {
        <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; list = match[pe];
        <span class="keyword">const</span> <span class="keywordtype">int</span> n = list.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>();
        <span class="keywordflow">if</span> (n &gt; 0)
          {
            <a class="code" href="classJoint.html" title="La classe Joint est une Frontiere qui contient les faces et les sommets de joint avec la zone PEvoisi...">Joint</a>&amp; joint = zone.<a class="code" href="classZone.html#a16f273a76321d31435995cdad664285a" title="Renvoie la liste des joints de la zone. (version const)">faces_joint</a>().<a class="code" href="classList__Joint.html#af5bca88a907fbe4086842805696cfe2f">add</a>(<a class="code" href="classJoint.html" title="La classe Joint est une Frontiere qui contient les faces et les sommets de joint avec la zone PEvoisi...">Joint</a>());
            joint.<a class="code" href="classFrontiere.html#a714e3cc26d7e59f3a65d80de23ea21ac" title="Donne un nom a la frontiere.">nommer</a>(<span class="stringliteral">&quot;Joint_i&quot;</span>);
            joint.<a class="code" href="classFrontiere.html#af927b5d4fc1fd086ba91e916f61badee" title="Associe la frontiere a la zone dont elle depend.">associer_zone</a>(zone);
            joint.<a class="code" href="classJoint.html#a130c206de5fddabf173bb3e4604cefa3" title="Fixe l&#39;epaisseur du joint.">affecte_epaisseur</a>(epaisseur_joint);
            joint.<a class="code" href="classJoint.html#a3c4ef6a648dd0b5d4aa072a1f4e3c64e" title="Fixe le numero du PE voisin.">affecte_PEvoisin</a>(pe);
            joint.<a class="code" href="classFrontiere.html#ac64479069f0c43a17cb5766a39ce5ba8" title="Renvoie les faces de la frontiere&lt;br&gt;(version const)">faces</a>().<a class="code" href="classFaces.html#a503fe687811445373b75dd8ac0991ec2" title="Type les faces.">typer</a>(zone.<a class="code" href="classZone.html#a18cf83cd0f9c368dcfa32fb802a0ac94" title="Renvoie un element geometrique du type de ceux qui constituent la zone. (version const)">type_elem</a>().<a class="code" href="classDeriv__Elem__geom__base.html#a384b487459a33f9f521fb16539ec81de">valeur</a>().<a class="code" href="classElem__geom__base.html#af781819b042bc5d8fec8b2255e32b498">type_face</a>());
            <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; sommets_joint = joint.<a class="code" href="classJoint.html#aa1c4d729a3017082d26907d82ad1d7de" title="Renvoie les informations de joint pour un type d&#39;item geometrique donne, pour remplissage des structu...">set_joint_item</a>(<a class="code" href="classJoint.html#a1e2d15d088c27c9b7b11c02bf4d2c926a050aa4faf237e25faef6fff15ffc20f8">Joint::SOMMET</a>).<a class="code" href="classJoint__Items.html#aa01c4601d506c658f4f1d45e66951ce0" title="Renvoie le tableau items_communs_ pour le remplir. (BM: ce tableau n&#39;est pas encore rempli)...">set_items_communs</a>();
            sommets_joint.<a class="code" href="classArrOfInt.html#a9b3afbb46b16870dbd36236c8935b535">resize_array</a>(n, <a class="code" href="classArray__base.html#abee342aa9ac59623c4c782dc9d7877ffaf6ae9ba7eb51c5f298ce693345b3ec68">Array_base::NOCOPY_NOINIT</a>);
            <span class="keywordflow">for</span> (i = 0; i &lt; n; i++)
              sommets_joint[i] = boundary_nodes_index[list[i]];
            sommets_joint.<a class="code" href="classArrOfInt.html#abb0f48cf5a4be4b70edcc90baaebd521" title="Tri des valeurs du tableau dans l&#39;ordre croissant. La fonction utilisee est qsort de stdlib (elle est...">ordonne_array</a>();
            <a class="code" href="classProcess.html#a57e0f54b11e6eaadbea224fa904b18dd" title="Renvoie un objet statique de type Sortie qui sert de journal d&#39;evenements. Si message_level &lt;= verbose...">Process::Journal</a>() &lt;&lt; <span class="stringliteral">&quot;Joint sommets with pe &quot;</span> &lt;&lt; pe &lt;&lt; <span class="stringliteral">&quot; has &quot;</span> &lt;&lt; n &lt;&lt; <span class="stringliteral">&quot; nodes&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
          }
      }
  }

  {
<span class="comment">// Find matching faces (match the coordinates of the centers)</span>
    <span class="keyword">const</span> <span class="keywordtype">int</span> nfaces = faces.<a class="code" href="classIntTab.html#abc3b32c94925a82f69d5b153a356e359" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(0);
    <span class="keyword">const</span> <span class="keywordtype">int</span> nb_som_faces = faces.<a class="code" href="classIntTab.html#abc3b32c94925a82f69d5b153a356e359" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(1);
    <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a> coord(nfaces, dim); <span class="comment">//!&lt; init with 0.</span>
<span class="comment"></span>    <span class="keyword">const</span> <span class="keywordtype">double</span> facteur = 1. / (double)nb_som_faces;
    <span class="keywordflow">for</span> (i = 0; i &lt; nfaces; i++)
      {
        <span class="keywordflow">for</span> (j = 0; j &lt; nb_som_faces; j++)
          {
            <span class="keyword">const</span> <span class="keywordtype">int</span> som = faces(i,j);
            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k = 0; k &lt; dim; k++)
              coord(i, k) += sommets(som, k) * facteur;
          }
      }
    <a class="code" href="Vect_8h.html#adc7c7b04809c9aec2cb897cd2ef06378">VECT</a>(<a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>) match(<a class="code" href="classProcess.html" title="Classe de base de TRUST (notamment Objet_U). Elle fournit quelques services de base accessibles de pa...">Process</a>::nproc());
    <a class="code" href="MaillerParallel_8cpp.html#a84d7b23bed74996cd415586161aa92fd" title="for a given set of local coordinates, finds which other processors share the same nodes...">find_matching_coordinates</a>(coord, match, epsilon);

    for (<span class="keywordtype">int</span> pe = 0; pe &lt; match.size(); pe++)
      {
        <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; list = match[pe];
        <span class="keyword">const</span> <span class="keywordtype">int</span> n = list.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>();
        <span class="keywordflow">if</span> (n &gt; 0)
          {
            <a class="code" href="Ref_8h.html#aab5720a5c34da14028d0745e386aaa01">REF</a>(<a class="code" href="classJoint.html" title="La classe Joint est une Frontiere qui contient les faces et les sommets de joint avec la zone PEvoisi...">Joint</a>) ref_joint;
            <span class="keywordtype">int</span> ii;
            for (ii = 0; ii &lt; zone.faces_joint().size(); ii++)
              {
                <a class="code" href="classJoint.html" title="La classe Joint est une Frontiere qui contient les faces et les sommets de joint avec la zone PEvoisi...">Joint</a>&amp; joint = zone.<a class="code" href="classZone.html#a16f273a76321d31435995cdad664285a" title="Renvoie la liste des joints de la zone. (version const)">faces_joint</a>()[ii];
                <span class="keywordflow">if</span> (joint.<a class="code" href="classJoint.html#a0952bc5c7805434ccd8cd5c9b01e3747" title="Renvoie PEvoisin (numero de la zone voisine)">PEvoisin</a>() == pe)
                  {
                    ref_joint = joint;
                    <span class="keywordflow">break</span>;
                  }
              }
            <span class="keywordflow">if</span> (!ref_joint.non_nul())
              {
                <a class="code" href="classJoint.html" title="La classe Joint est une Frontiere qui contient les faces et les sommets de joint avec la zone PEvoisi...">Joint</a>&amp; joint = zone.<a class="code" href="classZone.html#a16f273a76321d31435995cdad664285a" title="Renvoie la liste des joints de la zone. (version const)">faces_joint</a>().<a class="code" href="classList__Joint.html#af5bca88a907fbe4086842805696cfe2f">add</a>(<a class="code" href="classJoint.html" title="La classe Joint est une Frontiere qui contient les faces et les sommets de joint avec la zone PEvoisi...">Joint</a>());
                joint.<a class="code" href="classFrontiere.html#a714e3cc26d7e59f3a65d80de23ea21ac" title="Donne un nom a la frontiere.">nommer</a>(<span class="stringliteral">&quot;Joint_i&quot;</span>);
                joint.<a class="code" href="classFrontiere.html#af927b5d4fc1fd086ba91e916f61badee" title="Associe la frontiere a la zone dont elle depend.">associer_zone</a>(zone);
                joint.<a class="code" href="classJoint.html#a130c206de5fddabf173bb3e4604cefa3" title="Fixe l&#39;epaisseur du joint.">affecte_epaisseur</a>(epaisseur_joint);
                joint.<a class="code" href="classJoint.html#a3c4ef6a648dd0b5d4aa072a1f4e3c64e" title="Fixe le numero du PE voisin.">affecte_PEvoisin</a>(pe);
                joint.<a class="code" href="classFrontiere.html#ac64479069f0c43a17cb5766a39ce5ba8" title="Renvoie les faces de la frontiere&lt;br&gt;(version const)">faces</a>().<a class="code" href="classFaces.html#a503fe687811445373b75dd8ac0991ec2" title="Type les faces.">typer</a>(zone.<a class="code" href="classZone.html#a18cf83cd0f9c368dcfa32fb802a0ac94" title="Renvoie un element geometrique du type de ceux qui constituent la zone. (version const)">type_elem</a>().<a class="code" href="classDeriv__Elem__geom__base.html#a384b487459a33f9f521fb16539ec81de">valeur</a>().<a class="code" href="classElem__geom__base.html#af781819b042bc5d8fec8b2255e32b498">type_face</a>());
                ref_joint = joint;
              }
            <a class="code" href="classFaces.html" title="enum Type_Face Les differents types geometriques de faces.">Faces</a>&amp; les_faces = ref_joint.valeur().<a class="code" href="classFrontiere.html#ac64479069f0c43a17cb5766a39ce5ba8" title="Renvoie les faces de la frontiere&lt;br&gt;(version const)">faces</a>();
            les_faces.<a class="code" href="classFaces.html#aa3112928fe6cd95eb6c3394fd53c3cb1" title="(Re-)dimensionne les faces On redimensionne les voisins en consequence. Les sommets implicitement ajo...">dimensionner</a>(n);
            <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; faces_sommets = les_faces.<a class="code" href="classFaces.html#a07b8d8db9e3d656b93a21a49c063430c">les_sommets</a>();
            <span class="keywordflow">for</span> (ii = 0; ii &lt; n; ii++)
              {
                <span class="keyword">const</span> <span class="keywordtype">int</span> num_face = list[ii];
                <span class="keywordflow">for</span> (j = 0; j &lt; nb_som_faces; j++)
                  faces_sommets(ii, j) = faces(num_face, j);
              }
            <a class="code" href="classProcess.html#a57e0f54b11e6eaadbea224fa904b18dd" title="Renvoie un objet statique de type Sortie qui sert de journal d&#39;evenements. Si message_level &lt;= verbose...">Process::Journal</a>() &lt;&lt; <span class="stringliteral">&quot;Joint faces with pe &quot;</span> &lt;&lt; pe &lt;&lt; <span class="stringliteral">&quot; has &quot;</span> &lt;&lt; n &lt;&lt; <span class="stringliteral">&quot; faces&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
          }
      }
  }
<span class="comment">// Tri des joints dans l&#39;ordre croissant des processeurs</span>
  <a class="code" href="classScatter.html#ac5dd6d7661490708649976cde509f480" title="Tri des joints dans l&#39;ordre croissant des processeurs.">Scatter::trier_les_joints</a>(zone.<a class="code" href="classZone.html#a16f273a76321d31435995cdad664285a" title="Renvoie la liste des joints de la zone. (version const)">faces_joint</a>());
}
</pre></div>
</div>
</div>
<a class="anchor" id="a6ba3b4bcfd66200d20aad91d85653444"></a><!-- doxytag: member="MaillerParallel.cpp::bbox_intersection" ref="a6ba3b4bcfd66200d20aad91d85653444" args="(const DoubleTab &amp;bboxes, int i, int j, double epsilon)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int bbox_intersection </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>bboxes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>epsilon</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="MaillerParallel_8cpp_source.html#l00211">211</a> of file <a class="el" href="MaillerParallel_8cpp_source.html">MaillerParallel.cpp</a>.</p>

<p>References <a class="el" href="DoubleTab_8h_source.html#l00243">DoubleTab::dimension()</a>.</p>

<p>Referenced by <a class="el" href="MaillerParallel_8cpp_source.html#l00232">find_matching_coordinates()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">const</span> <span class="keywordtype">int</span> dim = bboxes.<a class="code" href="classDoubleTab.html#ac3805e2637a3b880ba2d3e650c69dac4" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(1) / 2;
  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k = 0; k &lt; dim; k++)
    {
      <span class="keywordtype">double</span> min1 = bboxes(i, k) - epsilon;
      <span class="keywordtype">double</span> max1 = bboxes(i, dim+k) + epsilon;
      <span class="keywordtype">double</span> min2 = bboxes(j, k);
      <span class="keywordtype">double</span> max2 = bboxes(j, dim+k);
      <span class="keywordflow">if</span> (min1 &gt; max2 || max1 &lt; min2)
        <span class="keywordflow">return</span> 0;
    }
  <span class="keywordflow">return</span> 1;
}
</pre></div>
</div>
</div>
<a class="anchor" id="aaffcc9b5476334db05eb75b524a20d5d"></a><!-- doxytag: member="MaillerParallel.cpp::find_joint_faces" ref="aaffcc9b5476334db05eb75b524a20d5d" args="(const Zone &amp;zone, IntTab &amp;faces)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void find_joint_faces </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classZone.html">Zone</a> &amp;&#160;</td>
          <td class="paramname"><em>zone</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classIntTab.html">IntTab</a> &amp;&#160;</td>
          <td class="paramname"><em>faces</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>finds all faces of all elements that<br/>
- have only one neighbour elements<br/>
- and do not belong to a boundary&lt;br&gt;(these are joint faces)<br/>
Fills "faces" with the local node numbers of the faces that have been found. </p>

<p>Definition at line <a class="el" href="MaillerParallel_8cpp_source.html#l00355">355</a> of file <a class="el" href="MaillerParallel_8cpp_source.html">MaillerParallel.cpp</a>.</p>

<p>References <a class="el" href="EntreeSortie_8h_source.html#l00032">Cerr</a>, <a class="el" href="Faces__builder_8cpp_source.html#l00325">Faces_builder::chercher_face_element()</a>, <a class="el" href="Connectivite__som__elem_8cpp_source.html#l00042">construire_connectivite_som_elem()</a>, <a class="el" href="IntTab_8h_source.html#l00233">IntTab::dimension()</a>, <a class="el" href="Zone_8cpp_source.html#l00262">Zone::domaine()</a>, <a class="el" href="Process_8cpp_source.html#l00223">Process::exit()</a>, <a class="el" href="Frontiere_8h_source.html#l00175">Frontiere::faces()</a>, <a class="el" href="Connectivite__som__elem_8cpp_source.html#l00108">find_adjacent_elements()</a>, <a class="el" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>, <a class="el" href="Zone_8h_source.html#l00840">Zone::frontiere()</a>, <a class="el" href="Elem__geom__base_8cpp_source.html#l00265">Elem_geom_base::get_tab_faces_sommets_locaux()</a>, <a class="el" href="Process_8cpp_source.html#l00345">Process::Journal()</a>, <a class="el" href="Domaine_8h_source.html#l00204">Domaine::le_nom()</a>, <a class="el" href="Zone_8h_source.html#l00402">Zone::les_elems()</a>, <a class="el" href="Faces_8h_source.html#l00268">Faces::les_sommets()</a>, <a class="el" href="Zone_8h_source.html#l00618">Zone::nb_front_Cl()</a>, <a class="el" href="Domaine_8cpp_source.html#l00184">Domaine::nb_som()</a>, <a class="el" href="classElem__geom__base.html#ad6c1fe053cf842b50bc1c0870f4d21f5">Elem_geom_base::nb_som_face()</a>, <a class="el" href="IntTab_8cpp_source.html#l00353">IntTab::resize()</a>, <a class="el" href="IntTab_8cpp_source.html#l00344">IntTab::resize_dim0()</a>, <a class="el" href="ArrOfInt_8cpp_source.html#l00443">ArrOfInt::set_smart_resize()</a>, <a class="el" href="ArrOfBit_8h_source.html#l00064">ArrOfBit::setbit()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00342">ArrOfInt::size_array()</a>, <a class="el" href="Zone_8h_source.html#l00491">Zone::type_elem()</a>, and <a class="el" href="Elem__geom_8h_source.html#l00044">Deriv_Elem_geom_base::valeur()</a>.</p>

<p>Referenced by <a class="el" href="MaillerParallel_8cpp_source.html#l00421">auto_build_joints()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <a class="code" href="classStatic__Int__Lists.html" title="Cette classe permet de stocker des listes d&#39;entiers accessibles en temps constant. La taille des listes ne peut pas changer sans perdre le contenu (ce sont des listes statiques). Exemple: Static_Int_List l; ArrOfInt tailles(3); tailles[0] = 2; tailles[1] = 3; tailles[2] = 0; // On reserve la memoire pour trois listes de taille 2, 3 et 0: l.set_list_sizes(tailles); // On affecte une valeur au deuxieme element de la premiere liste: l.set_value(0,1,765); // Affiche la valeur Cout &lt;&lt; l(0,1);.">Static_Int_Lists</a> som_elem;
  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; elements = zone.<a class="code" href="classZone.html#ac115e8342be89afb882b7b61cc343267" title="Renvoie le tableau des sommets des elements.">les_elems</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_som = zone.<a class="code" href="classZone.html#a379ad2206b5a13a4f4f3df6d44c7546a" title="Renvoie le domaine dont la zone fait partie. (version const)">domaine</a>().<a class="code" href="classDomaine.html#abc4abc8b8db5bebeb161fae4162a89ce" title="Renvoie le nombre de sommets.">nb_som</a>();
  <a class="code" href="Connectivite__som__elem_8cpp.html#a82161461a228e43ae236c31101ff3ce6" title="construction de la structure som_elem pour la zone donnee On cree pour chaque sommet i la liste des e...">construire_connectivite_som_elem</a>(nb_som, elements, som_elem, 0 <span class="comment">/* do not include virtual elements */</span>);
  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_som_faces = zone.<a class="code" href="classZone.html#a18cf83cd0f9c368dcfa32fb802a0ac94" title="Renvoie un element geometrique du type de ceux qui constituent la zone. (version const)">type_elem</a>().<a class="code" href="classDeriv__Elem__geom__base.html#a384b487459a33f9f521fb16539ec81de">valeur</a>().<a class="code" href="classElem__geom__base.html#ad6c1fe053cf842b50bc1c0870f4d21f5">nb_som_face</a>();
  faces.<a class="code" href="classIntTab.html#a22e6bed6826b3688d4d0181cbf3b7a38" title="Change la taille du vecteur (identique a resize_array() pour le traitement des anciennes valeurs et d...">resize</a>(0, nb_som_faces);
  faces.<a class="code" href="classArrOfInt.html#a22d744bcd452d039580d1d9186f02b4e" title="Change le mode l&#39;allocation memoire: reallocation d&#39;un tableau a chaque changement de taille (flag = ...">set_smart_resize</a>(1);
  <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a> faces_element_reference;
  zone.<a class="code" href="classZone.html#a18cf83cd0f9c368dcfa32fb802a0ac94" title="Renvoie un element geometrique du type de ceux qui constituent la zone. (version const)">type_elem</a>().<a class="code" href="classDeriv__Elem__geom__base.html#a384b487459a33f9f521fb16539ec81de">valeur</a>().<a class="code" href="classElem__geom__base.html#a9993267e98ef97472d3a5ef9c3c67882" title="remplit le tableau faces_som_local(i,j) qui donne pour 0 &lt;= i &lt; nb_faces() et 0 &lt;= j &lt; nb_som_face(i) le ...">get_tab_faces_sommets_locaux</a>(faces_element_reference);
  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_faces_elem = faces_element_reference.<a class="code" href="classIntTab.html#abc3b32c94925a82f69d5b153a356e359" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(0);
<span class="comment">// Mark faces of elements that are on a boundary</span>
  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_elem = elements.<a class="code" href="classIntTab.html#abc3b32c94925a82f69d5b153a356e359" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(0);
  <a class="code" href="classArrOfBit.html">ArrOfBit</a> boundary_faces(nb_elem * nb_faces_elem);
  boundary_faces = 0;
  <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> une_face(nb_som_faces);
  <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> liste_elements;
  liste_elements.<a class="code" href="classArrOfInt.html#a22d744bcd452d039580d1d9186f02b4e" title="Change le mode l&#39;allocation memoire: reallocation d&#39;un tableau a chaque changement de taille (flag = ...">set_smart_resize</a>(1);
  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_boundaries = zone.<a class="code" href="classZone.html#a9bf185c52ad1809d954bba670d9aed8a" title="Renvoie le nombre de bords + le nombre de raccords + le nombre de faces frontieres internes...">nb_front_Cl</a>();
  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i_boundary = 0; i_boundary &lt; nb_boundaries; i_boundary++)
    {
      <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; faces_front = zone.<a class="code" href="classZone.html#ac338b119d4b0bc4f510a223b9086fe5e">frontiere</a>(i_boundary).<a class="code" href="classFrontiere.html#ac64479069f0c43a17cb5766a39ce5ba8" title="Renvoie les faces de la frontiere&lt;br&gt;(version const)">faces</a>().<a class="code" href="classFaces.html#a07b8d8db9e3d656b93a21a49c063430c">les_sommets</a>();
      <span class="keyword">const</span> <span class="keywordtype">int</span> nb_faces_bord = faces_front.<a class="code" href="classIntTab.html#abc3b32c94925a82f69d5b153a356e359" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(0);
      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; nb_faces_bord; j++)
        {
          <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k = 0; k &lt; nb_som_faces; k++)
            une_face[k] = faces_front(j, k);
          <a class="code" href="Connectivite__som__elem_8cpp.html#afccbadf5344a16154a56b33dbddf88c1" title="Cherche les elements qui contiennent tous les sommets du tableau sommets_to_find (permet de trouver l...">find_adjacent_elements</a>(som_elem, une_face, liste_elements);
          <span class="keywordflow">if</span> (liste_elements.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() != 1)
            {
              <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Error in MaillerParallel::find_joint_faces: boundary face ArrOfInt=&quot;</span> &lt;&lt; une_face
                   &lt;&lt; <span class="stringliteral">&quot; does not have exactly 1 neighbour element: &quot;</span> &lt;&lt; liste_elements;
              <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">Process::exit</a>();
            }
          <span class="keyword">const</span> <span class="keywordtype">int</span> elem = liste_elements[0];
          <span class="keyword">const</span> <span class="keywordtype">int</span> face_locale = <a class="code" href="classFaces__builder.html#a17469d1ff2feae7d358abcccd2d67831">Faces_builder::chercher_face_element</a>(elements, faces_element_reference, une_face, elem);
          boundary_faces.setbit(elem * nb_faces_elem + face_locale);
        }
    }
<span class="comment">// Browse all faces of all elements, find faces with only one neighbour</span>
  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> elem = 0; elem &lt; nb_elem; elem++)
    {
      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> face_locale = 0; face_locale &lt; nb_faces_elem; face_locale++)
        {
          <span class="keywordflow">if</span> (boundary_faces[elem * nb_faces_elem + face_locale])
            <span class="keywordflow">continue</span>;
          <span class="keywordtype">int</span> i;
          <span class="keywordflow">for</span> (i = 0; i &lt; nb_som_faces; i++)
            {
              <span class="keyword">const</span> <span class="keywordtype">int</span> sommet_local = faces_element_reference(face_locale, i);
              une_face[i] = elements(elem, sommet_local);
            }
          <a class="code" href="Connectivite__som__elem_8cpp.html#afccbadf5344a16154a56b33dbddf88c1" title="Cherche les elements qui contiennent tous les sommets du tableau sommets_to_find (permet de trouver l...">find_adjacent_elements</a>(som_elem, une_face, liste_elements);
          <span class="keywordflow">if</span> (liste_elements.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() == 1)
            {
              <span class="keyword">const</span> <span class="keywordtype">int</span> n = faces.<a class="code" href="classIntTab.html#abc3b32c94925a82f69d5b153a356e359" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(0);
              faces.<a class="code" href="classIntTab.html#a425c14e929dedb4760f303ff42a20ee2" title="change la dimension[0] du tableau en conservant les autres.">resize_dim0</a>(n+1);
              <span class="keywordflow">for</span> (i = 0; i &lt; nb_som_faces; i++)
                faces(n, i) = une_face[i];
            }
        }
    }
  <a class="code" href="classProcess.html#a57e0f54b11e6eaadbea224fa904b18dd" title="Renvoie un objet statique de type Sortie qui sert de journal d&#39;evenements. Si message_level &lt;= verbose...">Process::Journal</a>() &lt;&lt; <span class="stringliteral">&quot;Domain &quot;</span> &lt;&lt; zone.<a class="code" href="classZone.html#a379ad2206b5a13a4f4f3df6d44c7546a" title="Renvoie le domaine dont la zone fait partie. (version const)">domaine</a>().<a class="code" href="classDomaine.html#a87e2cdc035a26565e6fe481446aa4cd3" title="Renvoie le nom du domaine.">le_nom</a>() &lt;&lt; <span class="stringliteral">&quot; has &quot;</span> &lt;&lt; faces.<a class="code" href="classIntTab.html#abc3b32c94925a82f69d5b153a356e359" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(0) &lt;&lt; <span class="stringliteral">&quot; undeclared boundary faces candidates for joint faces&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a84d7b23bed74996cd415586161aa92fd"></a><!-- doxytag: member="MaillerParallel.cpp::find_matching_coordinates" ref="a84d7b23bed74996cd415586161aa92fd" args="(const DoubleTab &amp;coords, Vect_ArrOfInt &amp;match, double epsilon)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void find_matching_coordinates </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>coords</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVect__ArrOfInt.html">Vect_ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>match</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>epsilon</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>for a given set of local coordinates, finds which other processors<br/>
share the same nodes.<br/>
match must be sized to <a class="el" href="classProcess.html#a6bf692ce58d9578aa62ac3c07b8caaa1" title="renvoie le nombre de processeurs dans le groupe courant Voir Comm_Group::nproc() et PE_Groups::curren...">Process::nproc()</a> and will be filled with, for each processor,<br/>
the indexes of coordinates that the corresponding processor shares with me.<br/>
Nodes are listed in the same order on couples of processors sharing a list of nodes<br/>
match[<a class="el" href="classProcess.html#ab55ba07167ec807ed3a145cac0f5dca4" title="renvoie mon rang dans le groupe de communication courant. Voir Comm_Group::rank() et PE_Groups::curre...">Process::me()</a>] will be left empty. </p>

<p><p>&lt; processor number</p>
<p>&lt; processor number </p>
</p>

<p>Definition at line <a class="el" href="MaillerParallel_8cpp_source.html#l00232">232</a> of file <a class="el" href="MaillerParallel_8cpp_source.html">MaillerParallel.cpp</a>.</p>

<p>References <a class="el" href="ArrOfInt_8h_source.html#l00355">ArrOfInt::append_array()</a>, <a class="el" href="MaillerParallel_8cpp_source.html#l00211">bbox_intersection()</a>, <a class="el" href="Schema__Comm_8cpp_source.html#l00166">Schema_Comm::begin_comm()</a>, <a class="el" href="Octree__Double_8cpp_source.html#l00154">Octree_Double::build_nodes()</a>, <a class="el" href="EntreeSortie_8h_source.html#l00032">Cerr</a>, <a class="el" href="DoubleTab_8h_source.html#l00243">DoubleTab::dimension()</a>, <a class="el" href="Schema__Comm_8cpp_source.html#l00380">Schema_Comm::echange_taille_et_messages()</a>, <a class="el" href="Schema__Comm_8cpp_source.html#l00430">Schema_Comm::end_comm()</a>, <a class="el" href="communications_8cpp_source.html#l00452">envoyer_all_to_all()</a>, <a class="el" href="Entree_8cpp_source.html#l00549">Entree::eof()</a>, <a class="el" href="Process_8cpp_source.html#l00223">Process::exit()</a>, <a class="el" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>, <a class="el" href="Process_8cpp_source.html#l00117">Process::me()</a>, <a class="el" href="Process_8cpp_source.html#l00109">Process::nproc()</a>, <a class="el" href="Schema__Comm_8cpp_source.html#l00494">Schema_Comm::recv_buffer()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00240">ArrOfInt::resize_array()</a>, <a class="el" href="Octree__Double_8cpp_source.html#l00244">Octree_Double::search_elements_box()</a>, <a class="el" href="Octree__Double_8cpp_source.html#l00289">Octree_Double::search_nodes_close_to()</a>, <a class="el" href="Schema__Comm_8cpp_source.html#l00477">Schema_Comm::send_buffer()</a>, <a class="el" href="Schema__Comm_8cpp_source.html#l00146">Schema_Comm::set_send_recv_pe_list()</a>, <a class="el" href="ArrOfInt_8cpp_source.html#l00443">ArrOfInt::set_smart_resize()</a>, and <a class="el" href="ArrOfInt_8h_source.html#l00342">ArrOfInt::size_array()</a>.</p>

<p>Referenced by <a class="el" href="MaillerParallel_8cpp_source.html#l00421">auto_build_joints()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">int</span> i, j;
  <span class="keyword">const</span> <span class="keywordtype">int</span> dim = coords.<a class="code" href="classDoubleTab.html#ac3805e2637a3b880ba2d3e650c69dac4" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(1);
  <span class="keyword">const</span> <span class="keywordtype">int</span> ncoord = coords.<a class="code" href="classDoubleTab.html#ac3805e2637a3b880ba2d3e650c69dac4" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(0);
  <span class="keyword">const</span> <span class="keywordtype">int</span> nproc = <a class="code" href="classProcess.html#a6bf692ce58d9578aa62ac3c07b8caaa1" title="renvoie le nombre de processeurs dans le groupe courant Voir Comm_Group::nproc() et PE_Groups::curren...">Process::nproc</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> moi = <a class="code" href="classProcess.html#ab55ba07167ec807ed3a145cac0f5dca4" title="renvoie mon rang dans le groupe de communication courant. Voir Comm_Group::rank() et PE_Groups::curre...">Process::me</a>();
<span class="comment">// Fill nodes coordinates and bounding boxes</span>
  <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a> bounding_boxes(nproc, dim*2);
  {
    <span class="keyword">const</span> <span class="keywordtype">double</span> big_val = 1.e36;
    <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a> min_coord(dim);
    min_coord= big_val;
    <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a> max_coord(dim);
    max_coord= -big_val;

    <span class="keywordflow">for</span> (i = 0; i &lt; ncoord; i++)
      {
        <span class="keywordflow">for</span> (j = 0; j &lt; dim; j++)
          {
            <span class="keyword">const</span> <span class="keywordtype">double</span> x = coords(i, j);
            <span class="keywordflow">if</span> (x &gt; max_coord[j])
              max_coord[j] = x;
            <span class="keywordflow">if</span> (x &lt; min_coord[j])
              min_coord[j] = x;
          }
      }
<span class="comment">// broadcast a tous les processeurs</span>
    <span class="keywordflow">for</span> (i = 0; i &lt; nproc; i++)
      {
        <span class="keywordflow">for</span> (j = 0; j &lt; dim; j++)
          {
            bounding_boxes(i, j) = min_coord[j];
            bounding_boxes(i, j+dim) = max_coord[j];
          }
      }
    <a class="code" href="communications_8cpp.html#a5ceda011ec527d63b691f62cd2fb61c8">envoyer_all_to_all</a>(bounding_boxes, bounding_boxes);
  }
<span class="comment">// Exchange boundary nodes coordinates with other processors</span>
  <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> all_pe;
  all_pe.<a class="code" href="classArrOfInt.html#a22d744bcd452d039580d1d9186f02b4e" title="Change le mode l&#39;allocation memoire: reallocation d&#39;un tableau a chaque changement de taille (flag = ...">set_smart_resize</a>(1);
  <span class="keywordflow">for</span> (i = 0; i &lt; nproc; i++)
    <span class="keywordflow">if</span> (i != moi &amp;&amp; <a class="code" href="MaillerParallel_8cpp.html#a6ba3b4bcfd66200d20aad91d85653444">bbox_intersection</a>(bounding_boxes, moi, i, epsilon))
      all_pe.<a class="code" href="classArrOfInt.html#a3f39d0966599416e7b1f7cd8159d8d01" title="Ajoute une case en fin de tableau et y stocke la &quot;valeur&quot;.">append_array</a>(i);

  <a class="code" href="classSchema__Comm.html">Schema_Comm</a> schema;
  schema.<a class="code" href="classSchema__Comm.html#ad11c9b47999c294c26ae4df8d2bbd57b" title="Definit la liste des processeurs a qui on va envoyer et de qui on va recevoir des donnees...">set_send_recv_pe_list</a>(all_pe, all_pe);
  schema.<a class="code" href="classSchema__Comm.html#ac617b53de22748cdd9fa30a0cfd0f4a8" title="Statut passe a WRITING Autorise si status_ == WRITING:">begin_comm</a>();
  <a class="code" href="classOctree__Double.html" title=": Un octree permettant de chercher dans l&#39;espace des elements ou des points decrits par des coordonne...">Octree_Double</a> octree;
  octree.<a class="code" href="classOctree__Double.html#a0b66bd315e7f45a024695b6a2764e7d4" title="construit un octree contenant les points de coordonnees coords. Si include_virtual=1, on stocke coords.dimension_tot(0) elements, sinon on en stocke coords.dimension(0) Si epsilon = 0, on construit un octree de points de taille nulle (chaque point se trouve dans un seul octree_floor) Sinon, on construit un octree d&#39;elements cubiques centres sur les coords, de demie-largeur epsilon. Un point peut alors se trouver dans plusieurs octree_floor.">build_nodes</a>(coords, 0 <span class="comment">/* do not include virtual nodes */</span>);

<span class="comment">// Send nodes coordinates to processors with non empty intersection</span>
<span class="comment">// temporary array for octree functions:</span>
  <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> nodes_list;
  nodes_list.<a class="code" href="classArrOfInt.html#a22d744bcd452d039580d1d9186f02b4e" title="Change le mode l&#39;allocation memoire: reallocation d&#39;un tableau a chaque changement de taille (flag = ...">set_smart_resize</a>(1);
  <span class="keywordtype">int</span> ipe;
  <span class="keywordflow">for</span> (ipe = 0; ipe &lt; all_pe.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>(); ipe++)
    {
<span class="comment">// Search nodes within the bounding box of the other processor:</span>
      <span class="keyword">const</span> <span class="keywordtype">int</span> pe = all_pe[ipe]; <span class="comment">//!&lt; processor number</span>
<span class="comment"></span>      <span class="keyword">const</span> <span class="keywordtype">double</span> xmin = bounding_boxes(pe, 0) - epsilon;
      <span class="keyword">const</span> <span class="keywordtype">double</span> ymin = bounding_boxes(pe, 1) - epsilon;
      <span class="keyword">const</span> <span class="keywordtype">double</span> zmin = (dim == 3) ? bounding_boxes(pe, 2) - epsilon : -epsilon;
      <span class="keyword">const</span> <span class="keywordtype">double</span> xmax = bounding_boxes(pe, dim) + epsilon;
      <span class="keyword">const</span> <span class="keywordtype">double</span> ymax = bounding_boxes(pe, dim+1) + epsilon;
      <span class="keyword">const</span> <span class="keywordtype">double</span> zmax = (dim == 3) ? bounding_boxes(pe, dim+2) + epsilon : epsilon;
      octree.<a class="code" href="classOctree__Double.html#a1dffcace51ca06cb52ff6e2330ab4b2e" title="cherche tous les elements ou points ayant potentiellement une intersection non vide avec la boite don...">search_elements_box</a>(xmin, ymin, zmin, xmax, ymax, zmax, nodes_list);

      <a class="code" href="classSortie.html" title="Classe de base des flux de sortie. Elle sait ecrire des types simples&lt;br&gt;(entiers, flottants) et des Ob...">Sortie</a>&amp; buffer = schema.<a class="code" href="classSchema__Comm.html#a6c771eae3b46250ae0d2f0126a7d8065" title="renvoie le buffer correspondant au processeur num_PE pour y entasser des donnees a envoyer...">send_buffer</a>(pe);
      <span class="keyword">const</span> <span class="keywordtype">int</span> n = nodes_list.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>();
      <span class="keywordflow">for</span> (i = 0; i &lt; n; i++)
        {
          <span class="keyword">const</span> <span class="keywordtype">int</span> som = nodes_list[i];
          <span class="keyword">const</span> <span class="keywordtype">double</span> x = coords(som, 0);
          <span class="keyword">const</span> <span class="keywordtype">double</span> y = coords(som, 1);
          <span class="keyword">const</span> <span class="keywordtype">double</span> z = (dim==3) ? coords(som, 2) : 0;
<span class="comment">// test again if inside bounding box (octree test gives more nodes)</span>
          <span class="keywordflow">if</span> (x&gt;=xmin &amp;&amp; x&lt;=xmax &amp;&amp; y&gt;=ymin &amp;&amp; y&lt;=ymax &amp;&amp; z&gt;=zmin &amp;&amp; z&lt;=zmax)
            {
              buffer &lt;&lt; x &lt;&lt; y &lt;&lt; z;
            }
        }
    }
  schema.<a class="code" href="classSchema__Comm.html#abca0e8ac6c2b742d26f3cfaee0690c72" title="Statut passe a EXCHANGED.">echange_taille_et_messages</a>();
  <span class="keywordflow">for</span> (ipe = 0; ipe &lt; all_pe.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>(); ipe++)
    {
      <span class="keyword">const</span> <span class="keywordtype">int</span> pe = all_pe[ipe]; <span class="comment">//!&lt; processor number</span>
<span class="comment"></span>      <a class="code" href="classEntree.html" title="Classe de definition des operateurs et methodes pour toute lecture dans un flot d&#39;entree (fichier...">Entree</a>&amp; buffer = schema.<a class="code" href="classSchema__Comm.html#a0c056eb81ab8fd513912b336b4d13a1a" title="renvoie le buffer correspondant au processeur num_PE pour y lire les donnees recues. Le schema doit etre dans l&#39;etat EXCHANGED.">recv_buffer</a>(pe);
      <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; resu = match[pe];
      resu.<a class="code" href="classArrOfInt.html#a22d744bcd452d039580d1d9186f02b4e" title="Change le mode l&#39;allocation memoire: reallocation d&#39;un tableau a chaque changement de taille (flag = ...">set_smart_resize</a>(1);
      resu.<a class="code" href="classArrOfInt.html#a9b3afbb46b16870dbd36236c8935b535">resize_array</a>(0);
      <span class="keywordflow">while</span>(1)
        {
          <span class="keywordtype">double</span> x, y, z;
          buffer &gt;&gt; x &gt;&gt; y &gt;&gt; z;
          <span class="keywordflow">if</span> (buffer.<a class="code" href="classEntree.html#abcd397cb0b99fbe7c6f01047d8cec89c">eof</a>())
            <span class="keywordflow">break</span>;
<span class="comment">// Seach for this node in my list</span>
          octree.<a class="code" href="classOctree__Double.html#a1dffcace51ca06cb52ff6e2330ab4b2e" title="cherche tous les elements ou points ayant potentiellement une intersection non vide avec la boite don...">search_elements_box</a>(x-epsilon, y-epsilon, z-epsilon,
                                     x+epsilon, y+epsilon, z+epsilon, nodes_list);
<span class="comment">// Refine search to keep only matching nodes:</span>
          octree.<a class="code" href="classOctree__Double.html#a8ba1f6ceba5dae2af587d2f9a766aac2" title="Methode hors classe Cherche parmi les sommets de la liste node_list ceux qui sont a une distance infe...">search_nodes_close_to</a>(x, y, z, coords, nodes_list, epsilon);
          <span class="keyword">const</span> <span class="keywordtype">int</span> n = nodes_list.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>();
          <span class="keywordflow">if</span> (n &gt; 1)
            {
              <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Error in automatic joint builder: more than one node within epsilon tolerance\n&quot;</span>
                   &lt;&lt; <span class="stringliteral">&quot; node coord = &quot;</span> &lt;&lt; x &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; y &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; z &lt;&lt; <span class="stringliteral">&quot; tolerance= &quot;</span> &lt;&lt; epsilon &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
              <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">Process::exit</a>();
            }
          <span class="keywordflow">if</span> (n == 1)
            resu.<a class="code" href="classArrOfInt.html#a3f39d0966599416e7b1f7cd8159d8d01" title="Ajoute une case en fin de tableau et y stocke la &quot;valeur&quot;.">append_array</a>(nodes_list[0]);
        }
    }
  schema.<a class="code" href="classSchema__Comm.html#a73a981f88b6ffebc150fb46c5cce75d9" title="Statut passe a RESET Accesseurs:">end_comm</a>();
}
</pre></div>
</div>
</div>
<hr/><h2>Variable Documentation</h2>
<a class="anchor" id="a0be7bff9e7d678a6d4793cb7dde80076"></a><!-- doxytag: member="MaillerParallel.cpp::MaillerParallelbases" ref="a0be7bff9e7d678a6d4793cb7dde80076" args="[1]" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classType__info.html">Type_info</a>* <a class="el" href="MaillerParallel_8cpp.html#a0be7bff9e7d678a6d4793cb7dde80076">MaillerParallelbases</a>[1] = { &amp;( <a class="el" href="classInterprete.html">Interprete</a> ::info_obj)}</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="MaillerParallel_8cpp_source.html#l00043">43</a> of file <a class="el" href="MaillerParallel_8cpp_source.html">MaillerParallel.cpp</a>.</p>

</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Tue Dec 14 2021 19:35:50 for TRUST by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
