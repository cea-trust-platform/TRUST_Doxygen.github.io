<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>TRUST: src/Kernel/Math/MD_Vector_std.cpp Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">TRUST&#160;<span id="projectnumber">1.8.4</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
<div class="header">
  <div class="headertitle">
<div class="title">src/Kernel/Math/MD_Vector_std.cpp</div>  </div>
</div>
<div class="contents">
<a href="MD__Vector__std_8cpp.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/****************************************************************************</span>
<a name="l00002"></a>00002 <span class="comment">* Copyright (c) 2015 - 2016, CEA</span>
<a name="l00003"></a>00003 <span class="comment">* All rights reserved.</span>
<a name="l00004"></a>00004 <span class="comment">*</span>
<a name="l00005"></a>00005 <span class="comment">* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</span>
<a name="l00006"></a>00006 <span class="comment">* 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.</span>
<a name="l00007"></a>00007 <span class="comment">* 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.</span>
<a name="l00008"></a>00008 <span class="comment">* 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.</span>
<a name="l00009"></a>00009 <span class="comment">*</span>
<a name="l00010"></a>00010 <span class="comment">* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.</span>
<a name="l00011"></a>00011 <span class="comment">* IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;</span>
<a name="l00012"></a>00012 <span class="comment">* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>
<a name="l00013"></a>00013 <span class="comment">*</span>
<a name="l00014"></a>00014 <span class="comment">*****************************************************************************/</span>
<a name="l00015"></a>00015 <span class="comment">//</span>
<a name="l00016"></a>00016 <span class="comment">// </span>
<a name="l00017"></a>00017 <span class="comment">// File:        MD_Vector_std.cpp</span>
<a name="l00018"></a>00018 <span class="comment">// Directory:   $TRUST_ROOT/src/Kernel/Math</span>
<a name="l00019"></a>00019 <span class="comment">// Version:     /main/fauchet_160/2</span>
<a name="l00020"></a>00020 <span class="comment">// </span>
<a name="l00021"></a>00021 <span class="comment">//</span>
<a name="l00022"></a>00022 <span class="comment">// </span>
<a name="l00023"></a>00023 <span class="comment">// WARNING: DO NOT EDIT THIS FILE! Only edit the template file MD_Vector_std.cpp.P</span>
<a name="l00024"></a>00024 <span class="comment">// </span>
<a name="l00025"></a>00025 <span class="preprocessor">#include &lt;<a class="code" href="MD__Vector__std_8h.html">MD_Vector_std.h</a>&gt;</span>
<a name="l00026"></a>00026 <span class="preprocessor">#include &lt;<a class="code" href="DoubleVect_8h.html">DoubleVect.h</a>&gt;</span>
<a name="l00027"></a>00027 <span class="preprocessor">#include &lt;<a class="code" href="IntVect_8h.html">IntVect.h</a>&gt;</span>
<a name="l00028"></a>00028 <span class="preprocessor">#include &lt;<a class="code" href="Schema__Comm__Vecteurs_8h.html">Schema_Comm_Vecteurs.h</a>&gt;</span>
<a name="l00029"></a>00029 <span class="preprocessor">#include &lt;<a class="code" href="Echange__EV__Options_8h.html">Echange_EV_Options.h</a>&gt;</span>
<a name="l00030"></a>00030 <span class="preprocessor">#include &lt;<a class="code" href="communications_8h.html">communications.h</a>&gt;</span>
<a name="l00031"></a>00031 <span class="preprocessor">#include &lt;<a class="code" href="Param_8h.html">Param.h</a>&gt;</span>
<a name="l00032"></a>00032 
<a name="l00033"></a><a class="code" href="MD__Vector__std_8cpp.html#aec9fc09b4c731c425fedebfbda0c7589">00033</a> <a class="code" href="Declare__Inst_8h.html#afcab3f7633508e92f2077d767e19bc60">Implemente_instanciable_sans_constructeur</a>(<a class="code" href="classMD__Vector__std.html" title="C&#39;est le plus simple des descripteurs, utilise pour les tableaux de valeurs aux sommets, elements, faces, aretes, faces de bord, etc... Il supporte la notion d&#39;items &quot;communs&quot; (sommets du maillage partages entre plusieurs processeurs) et d&#39;items &quot;distants&quot; et &quot;virtuels&quot; (sommets, elements dans l&#39;epaisseur de joint). Voir aussi MD_Vector_composite (descripteur compose d&#39;une reunion de plusieurs descripteurs, pour le P1Bulle par exemple)">MD_Vector_std</a>,<span class="stringliteral">&quot;MD_Vector_std&quot;</span>,<a class="code" href="classMD__Vector__base2.html">MD_Vector_base2</a>);
<a name="l00034"></a>00034 
<a name="l00035"></a><a class="code" href="classMD__Vector__std.html#a9993fd685468915f744b7fee7f072954">00035</a> <a class="code" href="classMD__Vector__std.html#a9993fd685468915f744b7fee7f072954">MD_Vector_std::MD_Vector_std</a>()
<a name="l00036"></a>00036 {
<a name="l00037"></a>00037   <a class="code" href="classMD__Vector__base2.html#a7cf9dbd94db6c0ba49e87681d207aef0">nb_items_seq_tot_</a> = -1;
<a name="l00038"></a>00038   <a class="code" href="classMD__Vector__base2.html#a2bb5e578b35a03544342e963d2adec35">nb_items_seq_local_</a> = -1;
<a name="l00039"></a>00039   <a class="code" href="classMD__Vector__base2.html#ae222cd70f0be4da64d0aa7fcd89df0f4">nb_items_tot_</a> = -1;
<a name="l00040"></a>00040   <a class="code" href="classMD__Vector__base2.html#a87c423fabd116249cb1dab31887193c9">nb_items_reels_</a> = -1;
<a name="l00041"></a>00041 }
<a name="l00042"></a>00042 
<a name="l00043"></a>00043 <span class="comment">//</span>
<a name="l00044"></a>00044 <span class="comment">//</span>
<a name="l00045"></a>00045 <span class="comment">//</span>
<a name="l00046"></a>00046 <span class="comment">//</span>
<a name="l00047"></a>00047 <span class="comment">//</span>
<a name="l00048"></a>00048 <span class="comment">//</span>
<a name="l00049"></a>00049 <span class="comment">//</span>
<a name="l00050"></a>00050 <span class="comment">//</span>
<a name="l00051"></a>00051 <span class="comment">//</span>
<a name="l00052"></a>00052 <span class="comment">//</span>
<a name="l00053"></a>00053 <span class="comment">//</span>
<a name="l00054"></a>00054 <span class="comment">//</span>
<a name="l00055"></a>00055 <span class="comment">//</span>
<a name="l00056"></a>00056 <span class="comment">//</span>
<a name="l00057"></a>00057 <span class="comment">//</span>
<a name="l00058"></a>00058 <span class="comment">//</span>
<a name="l00059"></a>00059 <span class="comment">//</span>
<a name="l00060"></a>00060 <span class="comment">//</span>
<a name="l00061"></a>00061 <span class="comment">//</span>
<a name="l00062"></a>00062 <span class="comment">//</span>
<a name="l00063"></a>00063 <span class="comment">//</span><span class="comment"></span>
<a name="l00064"></a>00064 <span class="comment">//! Constructeur.&lt;br&gt;Si nb_items_reels &gt;= 0, items_to_compute contiendra un bloc avec les items reels,&lt;br&gt;sinon, items_to_compute prendra tous les items (jusqu&#39;a nb_items_tot).&lt;br&gt;Parametre: nb_items_tot&lt;br&gt;Signification: valeur que prendra nb_items_tot_ (doit etre &gt;= 0)&lt;br&gt;Parametre: nb_items_reels&lt;br&gt;Signification: valeur que prendra nb_items_reels_ (doit etre &gt;= -1,&lt;br&gt;-1 signifie qu&#39;il n&#39;y a pas d&#39;items &quot;reels&quot; groupes au debut du tableau&lt;br&gt;Parametre: pe_voisins&lt;br&gt;Signification: liste des processeurs voisins, classes dans l&#39;ordre croissant&lt;br&gt;(les tableaux VECT(ArrOfInt) doivent avoir la meme taille).&lt;br&gt;Cette liste n&#39;est pas reprise integralement: on retire les processeurs&lt;br&gt;pour lesquels toutes les trois listes d&#39;items sont vides.&lt;br&gt;Parametre: items_to_send&lt;br&gt;Signification: pour chaque pe_voisin, liste des items a envoyer (communs et virtuels).&lt;br&gt;count_items_to_send_to_items_ est calcule par une communication a partir de items_to_recv.&lt;br&gt;Parametre: items_to_recv&lt;br&gt;Signification: liste d&#39;items individuels a recevoir des differents procs&lt;br&gt;(souvent des items communs mais ce n&#39;est pas obligatoire, ex front-tracking)&lt;br&gt;Parametre: blocs_to_recv&lt;br&gt;Signification: liste de blocs d&#39;items a recevoir (voir MD_Vector_std::blocs_to_recv_)&lt;br&gt;(souvent les items virtuels...)</span>
<a name="l00065"></a><a class="code" href="classMD__Vector__std.html#a596e2f992e0e1c8a6fa6f307d4ede491">00065</a> <span class="comment"></span><a class="code" href="classMD__Vector__std.html#a9993fd685468915f744b7fee7f072954">MD_Vector_std::MD_Vector_std</a>(<span class="keywordtype">int</span> nb_items_tot,
<a name="l00066"></a>00066                              <span class="keywordtype">int</span> nb_items_reels,
<a name="l00067"></a>00067                              <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; pe_voisins,
<a name="l00068"></a>00068                              <span class="keyword">const</span> <a class="code" href="Vect_8h.html#adc7c7b04809c9aec2cb897cd2ef06378">VECT</a>(<a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>) &amp; items_to_send,
<a name="l00069"></a>00069                              <span class="keyword">const</span> <a class="code" href="Vect_8h.html#adc7c7b04809c9aec2cb897cd2ef06378">VECT</a>(<a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>) &amp; items_to_recv,
<a name="l00070"></a>00070                              <span class="keyword">const</span> <a class="code" href="Vect_8h.html#adc7c7b04809c9aec2cb897cd2ef06378">VECT</a>(<a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>) &amp; blocs_to_recv)
<a name="l00071"></a>00071 {
<a name="l00072"></a>00072   assert(nb_items_tot &gt;= 0);
<a name="l00073"></a>00073   assert(nb_items_reels &gt;= -1 &amp;&amp; nb_items_reels &lt;= nb_items_tot);
<a name="l00074"></a>00074   <a class="code" href="classMD__Vector__base2.html#ae222cd70f0be4da64d0aa7fcd89df0f4">nb_items_tot_</a> = nb_items_tot;
<a name="l00075"></a>00075   <a class="code" href="classMD__Vector__base2.html#a87c423fabd116249cb1dab31887193c9">nb_items_reels_</a> = nb_items_reels;
<a name="l00076"></a>00076   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_voisins = pe_voisins.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>();
<a name="l00077"></a>00077   assert(items_to_send.size() == nb_voisins);
<a name="l00078"></a>00078   assert(items_to_recv.size() == nb_voisins);
<a name="l00079"></a>00079   assert(blocs_to_recv.size() == nb_voisins);
<a name="l00080"></a>00080 
<a name="l00081"></a>00081 <span class="comment">// selection: liste des indices des pe a conserver dans pe_voisins</span>
<a name="l00082"></a>00082 <span class="comment">// (procs avec qui on echange effectivement des donnees)</span>
<a name="l00083"></a>00083   <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> tmp, selection;
<a name="l00084"></a>00084   tmp.<a class="code" href="classArrOfInt.html#a22d744bcd452d039580d1d9186f02b4e" title="Change le mode l&#39;allocation memoire: reallocation d&#39;un tableau a chaque changement de taille (flag = ...">set_smart_resize</a>(1);
<a name="l00085"></a>00085   selection.set_smart_resize(1);
<a name="l00086"></a>00086   <span class="keywordtype">int</span> i;
<a name="l00087"></a>00087   <span class="keywordflow">for</span> (i = 0; i &lt; nb_voisins; i++)
<a name="l00088"></a>00088     <span class="keywordflow">if</span> (items_to_send[i].size_array() &gt; 0
<a name="l00089"></a>00089         || items_to_recv[i].size_array() &gt; 0
<a name="l00090"></a>00090         || blocs_to_recv[i].size_array() &gt; 0)
<a name="l00091"></a>00091       {
<a name="l00092"></a>00092         tmp.append_array(pe_voisins[i]);
<a name="l00093"></a>00093         selection.append_array(i);
<a name="l00094"></a>00094       }
<a name="l00095"></a>00095   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_voisins2 = tmp.size_array();
<a name="l00096"></a>00096 <span class="comment">// ** pe_voisins_ **</span>
<a name="l00097"></a>00097   <a class="code" href="classMD__Vector__std.html#a68854e710075fdc8c2f2ce28fbbb9ecc">pe_voisins_</a> = tmp;
<a name="l00098"></a>00098 
<a name="l00099"></a>00099   {
<a name="l00100"></a>00100     <a class="code" href="Vect_8h.html#adc7c7b04809c9aec2cb897cd2ef06378">VECT</a>(<a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>) tmpbis(nb_voisins2);
<a name="l00101"></a>00101 
<a name="l00102"></a>00102     <span class="keywordflow">for</span> (i = 0; i &lt; nb_voisins2; i++)
<a name="l00103"></a>00103       tmpbis[i] = items_to_send[selection[i]];
<a name="l00104"></a>00104     <a class="code" href="classMD__Vector__std.html#a3ee9294b8d36492e8bdabbc9a97db451">items_to_send_</a>.<a class="code" href="classStatic__Int__Lists.html#ae1c143a65ae04163efa337624b8bd079">set</a>(tmpbis);
<a name="l00105"></a>00105 
<a name="l00106"></a>00106     <span class="keywordflow">for</span> (i = 0; i &lt; nb_voisins2; i++)
<a name="l00107"></a>00107       tmpbis[i] = items_to_recv[selection[i]];
<a name="l00108"></a>00108     <a class="code" href="classMD__Vector__std.html#a8d6c4c5d6da6fe56e8330253137d412f">items_to_recv_</a>.<a class="code" href="classStatic__Int__Lists.html#ae1c143a65ae04163efa337624b8bd079">set</a>(tmpbis);
<a name="l00109"></a>00109 
<a name="l00110"></a>00110     <span class="keywordflow">for</span> (i = 0; i &lt; nb_voisins2; i++)
<a name="l00111"></a>00111       tmpbis[i] = blocs_to_recv[selection[i]];
<a name="l00112"></a>00112     <a class="code" href="classMD__Vector__std.html#ae266bd552dcb9f817c791a1c7342a6b0">blocs_to_recv_</a>.<a class="code" href="classStatic__Int__Lists.html#ae1c143a65ae04163efa337624b8bd079">set</a>(tmpbis);
<a name="l00113"></a>00113   }
<a name="l00114"></a>00114 
<a name="l00115"></a>00115 <span class="comment">// Calcul de nb_items_to_items_</span>
<a name="l00116"></a>00116   {
<a name="l00117"></a>00117     <a class="code" href="classMD__Vector__std.html#afd0c291718e3bc9846c8a06420efeb69">nb_items_to_items_</a>.<a class="code" href="classArrOfInt.html#a9b3afbb46b16870dbd36236c8935b535">resize_array</a>(nb_voisins2, <a class="code" href="classArray__base.html#abee342aa9ac59623c4c782dc9d7877ffaf6ae9ba7eb51c5f298ce693345b3ec68">Array_base::NOCOPY_NOINIT</a>);
<a name="l00118"></a>00118     tmp.resize_array(<a class="code" href="classProcess.html#a6bf692ce58d9578aa62ac3c07b8caaa1" title="renvoie le nombre de processeurs dans le groupe courant Voir Comm_Group::nproc() et PE_Groups::curren...">nproc</a>(), <a class="code" href="classArray__base.html#abee342aa9ac59623c4c782dc9d7877ffaf6ae9ba7eb51c5f298ce693345b3ec68">Array_base::NOCOPY_NOINIT</a>);
<a name="l00119"></a>00119     tmp = 0;
<a name="l00120"></a>00120     <span class="keywordflow">for</span> (i = 0; i &lt; nb_voisins2; i++)
<a name="l00121"></a>00121       tmp[<a class="code" href="classMD__Vector__std.html#a68854e710075fdc8c2f2ce28fbbb9ecc">pe_voisins_</a>[i]] = items_to_recv[selection[i]].size_array();;
<a name="l00122"></a>00122     <a class="code" href="communications_8cpp.html#a5ceda011ec527d63b691f62cd2fb61c8">envoyer_all_to_all</a>(tmp, tmp);
<a name="l00123"></a>00123     <span class="keywordflow">for</span> (i = 0; i &lt; nb_voisins2; i++)
<a name="l00124"></a>00124       {
<a name="l00125"></a>00125         <span class="keywordtype">int</span> n = tmp[<a class="code" href="classMD__Vector__std.html#a68854e710075fdc8c2f2ce28fbbb9ecc">pe_voisins_</a>[i]];
<a name="l00126"></a>00126         assert(n &lt;= <a class="code" href="classMD__Vector__std.html#a3ee9294b8d36492e8bdabbc9a97db451">items_to_send_</a>.<a class="code" href="classStatic__Int__Lists.html#adbf6903737c3c30bf87e05b29f5a5b56" title="renvoie le nombre d&#39;elements de la liste i">get_list_size</a>(i));
<a name="l00127"></a>00127         <a class="code" href="classMD__Vector__std.html#afd0c291718e3bc9846c8a06420efeb69">nb_items_to_items_</a>[i] = n;
<a name="l00128"></a>00128       }
<a name="l00129"></a>00129   }
<a name="l00130"></a>00130 <span class="comment">// Calcul de blocs_items_count_</span>
<a name="l00131"></a>00131   {
<a name="l00132"></a>00132     <a class="code" href="classMD__Vector__std.html#a4aa5e80e0b975026cc201fbdee72956c">blocs_items_count_</a>.<a class="code" href="classArrOfInt.html#a9b3afbb46b16870dbd36236c8935b535">resize_array</a>(nb_voisins2, <a class="code" href="classArray__base.html#abee342aa9ac59623c4c782dc9d7877ffaf6ae9ba7eb51c5f298ce693345b3ec68">Array_base::NOCOPY_NOINIT</a>);
<a name="l00133"></a>00133     <span class="keywordflow">for</span> (i = 0; i &lt; nb_voisins2; i++)
<a name="l00134"></a>00134       {
<a name="l00135"></a>00135         <span class="keyword">const</span> <span class="keywordtype">int</span> nblocs = <a class="code" href="classMD__Vector__std.html#ae266bd552dcb9f817c791a1c7342a6b0">blocs_to_recv_</a>.<a class="code" href="classStatic__Int__Lists.html#adbf6903737c3c30bf87e05b29f5a5b56" title="renvoie le nombre d&#39;elements de la liste i">get_list_size</a>(i) / 2;
<a name="l00136"></a>00136         <span class="keywordtype">int</span> count = 0;
<a name="l00137"></a>00137         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; nblocs; j++)
<a name="l00138"></a>00138           {
<a name="l00139"></a>00139             <span class="keywordtype">int</span> deb = <a class="code" href="classMD__Vector__std.html#ae266bd552dcb9f817c791a1c7342a6b0">blocs_to_recv_</a>(i, j*2);
<a name="l00140"></a>00140             <span class="keywordtype">int</span> fin = <a class="code" href="classMD__Vector__std.html#ae266bd552dcb9f817c791a1c7342a6b0">blocs_to_recv_</a>(i, j*2+1);
<a name="l00141"></a>00141             assert(deb &gt;= 0 &amp;&amp; fin &gt; deb &amp;&amp; fin &lt;= <a class="code" href="classMD__Vector__base2.html#ae222cd70f0be4da64d0aa7fcd89df0f4">nb_items_tot_</a>);
<a name="l00142"></a>00142             count += fin - deb;
<a name="l00143"></a>00143           }
<a name="l00144"></a>00144         <a class="code" href="classMD__Vector__std.html#a4aa5e80e0b975026cc201fbdee72956c">blocs_items_count_</a>[i] = count;
<a name="l00145"></a>00145       }
<a name="l00146"></a>00146   }
<a name="l00147"></a>00147 <span class="comment">// Calcul des blocs d&#39;items sequentiels (items non recus d&#39;un autre proc)</span>
<a name="l00148"></a>00148   tmp.<a class="code" href="classArrOfInt.html#a9b3afbb46b16870dbd36236c8935b535">resize_array</a>(nb_items_tot, <a class="code" href="classArray__base.html#abee342aa9ac59623c4c782dc9d7877ffaf6ae9ba7eb51c5f298ce693345b3ec68">Array_base::NOCOPY_NOINIT</a>);
<a name="l00149"></a>00149   {
<a name="l00150"></a>00150 <span class="comment">// Marquage des items recus a zero</span>
<a name="l00151"></a>00151     tmp = 1;
<a name="l00152"></a>00152     <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; items = <a class="code" href="classMD__Vector__std.html#a8d6c4c5d6da6fe56e8330253137d412f">items_to_recv_</a>.<a class="code" href="classStatic__Int__Lists.html#ac72c923acdf74ba0d8fed055c494fc5b">get_data</a>();
<a name="l00153"></a>00153     <span class="keywordtype">int</span> n = items.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>();
<a name="l00154"></a>00154     <span class="keywordflow">for</span> (i = 0; i &lt; n; i++)
<a name="l00155"></a>00155       {
<a name="l00156"></a>00156         assert(tmp[items[i]] == 1); <span class="comment">//!&lt; sinon, c&#39;est qu&#39;on recoit deux fois le meme items</span>
<a name="l00157"></a>00157 <span class="comment"></span>        tmp[items[i]] = 0;
<a name="l00158"></a>00158       }
<a name="l00159"></a>00159     <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; items2 = <a class="code" href="classMD__Vector__std.html#ae266bd552dcb9f817c791a1c7342a6b0">blocs_to_recv_</a>.<a class="code" href="classStatic__Int__Lists.html#ac72c923acdf74ba0d8fed055c494fc5b">get_data</a>();
<a name="l00160"></a>00160     assert(items2.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() % 2 == 0);
<a name="l00161"></a>00161     n = items2.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() / 2;
<a name="l00162"></a>00162     <span class="keywordflow">for</span> (i = 0; i &lt; n; i++)
<a name="l00163"></a>00163       {
<a name="l00164"></a>00164         <span class="keyword">const</span> <span class="keywordtype">int</span> start = items2[i*2];
<a name="l00165"></a>00165         <span class="keyword">const</span> <span class="keywordtype">int</span> end = items2[i*2+1];
<a name="l00166"></a>00166         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = start; j &lt; end; j++)
<a name="l00167"></a>00167           {
<a name="l00168"></a>00168             assert(tmp[j] == 1); <span class="comment">//!&lt; sinon, c&#39;est qu&#39;on recoit deux fois le meme items</span>
<a name="l00169"></a>00169 <span class="comment"></span>            tmp[j] = 0;
<a name="l00170"></a>00170           }
<a name="l00171"></a>00171       }
<a name="l00172"></a>00172 
<a name="l00173"></a>00173 <span class="comment">// Construction d&#39;une liste de blocs d&#39;items sequentiels (ceux qui sont restes a 1)</span>
<a name="l00174"></a>00174     <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> blocs;
<a name="l00175"></a>00175     blocs.<a class="code" href="classArrOfInt.html#a22d744bcd452d039580d1d9186f02b4e" title="Change le mode l&#39;allocation memoire: reallocation d&#39;un tableau a chaque changement de taille (flag = ...">set_smart_resize</a>(1);
<a name="l00176"></a>00176     <span class="keywordtype">int</span> nb_seq = 0;
<a name="l00177"></a>00177     <span class="keywordflow">for</span> (i = 0; i &lt; nb_items_tot; i++)
<a name="l00178"></a>00178       {
<a name="l00179"></a>00179         <span class="keywordflow">if</span> (tmp[i])
<a name="l00180"></a>00180           {
<a name="l00181"></a>00181             <span class="keywordflow">if</span> (nb_items_reels &gt;= 0 &amp;&amp; i &gt;= nb_items_reels)
<a name="l00182"></a>00182               {
<a name="l00183"></a>00183 <span class="comment">// On a un item non recu parmi les items virtuels !</span>
<a name="l00184"></a>00184                 <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Error in MD_Vector_std::MD_Vector_std(...) [pe &quot;</span> &lt;&lt; <a class="code" href="classProcess.html#ab55ba07167ec807ed3a145cac0f5dca4" title="renvoie mon rang dans le groupe de communication courant. Voir Comm_Group::rank() et PE_Groups::curre...">me</a>()
<a name="l00185"></a>00185                      &lt;&lt; <span class="stringliteral">&quot;]\n an item i(&quot;</span> &lt;&lt; i &lt;&lt; <span class="stringliteral">&quot;) &gt; nb_items_reels(&quot;</span> &lt;&lt; nb_items_reels
<a name="l00186"></a>00186                      &lt;&lt; <span class="stringliteral">&quot;) is not received from any other processor&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
<a name="l00187"></a>00187                 <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">exit</a>();
<a name="l00188"></a>00188               }
<a name="l00189"></a>00189             <a class="code" href="classMD__Vector__base2.html#af0e28390469007418371b633a7fad378" title="methode outil pour ajouter un item a un tableau du genre &quot;blocs&quot; contenant des series de blocs...">append_item_to_blocs</a>(blocs, i);
<a name="l00190"></a>00190             nb_seq++;
<a name="l00191"></a>00191           }
<a name="l00192"></a>00192       }
<a name="l00193"></a>00193     <a class="code" href="classMD__Vector__base2.html#afb3898aebe081ff8c87759822946ece7">blocs_items_to_sum_</a> = blocs;
<a name="l00194"></a>00194     <a class="code" href="classMD__Vector__base2.html#a2bb5e578b35a03544342e963d2adec35">nb_items_seq_local_</a> = nb_seq;
<a name="l00195"></a>00195     <a class="code" href="classMD__Vector__base2.html#a7cf9dbd94db6c0ba49e87681d207aef0">nb_items_seq_tot_</a> = <a class="code" href="classProcess.html#a7d23bc1ef94b3f0623fbc79d034c27fd" title="Calcule la somme de x sur tous les processeurs du groupe courant. Voir aussi mp_max()">mp_sum</a>(nb_seq);
<a name="l00196"></a>00196   }
<a name="l00197"></a>00197 
<a name="l00198"></a>00198 <span class="comment">// Bloc items to compute:</span>
<a name="l00199"></a>00199 <span class="comment">// Par defaut: un seul bloc</span>
<a name="l00200"></a>00200   <span class="keywordflow">if</span> (<a class="code" href="classMD__Vector__base2.html#a87c423fabd116249cb1dab31887193c9">nb_items_reels_</a> &gt;= 0)
<a name="l00201"></a>00201     {
<a name="l00202"></a>00202 <span class="comment">// Les operateurs sur les tableaux calculent tous les items reels</span>
<a name="l00203"></a>00203       <a class="code" href="classMD__Vector__base2.html#ac19dad1f73b786033a9911cbfe3ae440">blocs_items_to_compute_</a>.<a class="code" href="classArrOfInt.html#a15fc7e3958f02cb38d3106eeb919f6fc" title="appel a ArrOfInt::resize_array()">resize</a>(2, <a class="code" href="classArray__base.html#abee342aa9ac59623c4c782dc9d7877ffaf6ae9ba7eb51c5f298ce693345b3ec68">Array_base::NOCOPY_NOINIT</a>);
<a name="l00204"></a>00204       <a class="code" href="classMD__Vector__base2.html#ac19dad1f73b786033a9911cbfe3ae440">blocs_items_to_compute_</a>[0] = 0;
<a name="l00205"></a>00205       <a class="code" href="classMD__Vector__base2.html#ac19dad1f73b786033a9911cbfe3ae440">blocs_items_to_compute_</a>[1] = <a class="code" href="classMD__Vector__base2.html#a87c423fabd116249cb1dab31887193c9">nb_items_reels_</a>;
<a name="l00206"></a>00206     }
<a name="l00207"></a>00207   <span class="keywordflow">else</span>
<a name="l00208"></a>00208     {
<a name="l00209"></a>00209 <span class="comment">// Les operateurs sur les tableaux calculent tout</span>
<a name="l00210"></a>00210       <a class="code" href="classMD__Vector__base2.html#ac19dad1f73b786033a9911cbfe3ae440">blocs_items_to_compute_</a>.<a class="code" href="classArrOfInt.html#a15fc7e3958f02cb38d3106eeb919f6fc" title="appel a ArrOfInt::resize_array()">resize</a>(2, <a class="code" href="classArray__base.html#abee342aa9ac59623c4c782dc9d7877ffaf6ae9ba7eb51c5f298ce693345b3ec68">Array_base::NOCOPY_NOINIT</a>);
<a name="l00211"></a>00211       <a class="code" href="classMD__Vector__base2.html#ac19dad1f73b786033a9911cbfe3ae440">blocs_items_to_compute_</a>[0] = 0;
<a name="l00212"></a>00212       <a class="code" href="classMD__Vector__base2.html#ac19dad1f73b786033a9911cbfe3ae440">blocs_items_to_compute_</a>[1] = <a class="code" href="classMD__Vector__base2.html#ae222cd70f0be4da64d0aa7fcd89df0f4">nb_items_tot_</a>;
<a name="l00213"></a>00213     }
<a name="l00214"></a>00214 }
<a name="l00215"></a>00215 
<a name="l00216"></a>00216 
<a name="l00217"></a>00217 <span class="comment">//</span><span class="comment"></span>
<a name="l00218"></a>00218 <span class="comment">//! method used to dump/restore a descriptor in a file&lt;br&gt;Each process writes a different descriptor. See MD_Vector_tools::restore_vector_with_md()</span>
<a name="l00219"></a><a class="code" href="classMD__Vector__std.html#acb627ae134f2e6762ce514ec3e09ea81">00219</a> <span class="comment"></span><a class="code" href="classEntree.html" title="Classe de definition des operateurs et methodes pour toute lecture dans un flot d&#39;entree (fichier...">Entree</a>&amp; <a class="code" href="classMD__Vector__std.html#acb627ae134f2e6762ce514ec3e09ea81" title="method used to dump/restore a descriptor in a file Each process writes a different descriptor...">MD_Vector_std::readOn</a>(<a class="code" href="classEntree.html" title="Classe de definition des operateurs et methodes pour toute lecture dans un flot d&#39;entree (fichier...">Entree</a>&amp; is)
<a name="l00220"></a>00220 {
<a name="l00221"></a>00221   <a class="code" href="classMD__Vector__std.html#acb627ae134f2e6762ce514ec3e09ea81" title="method used to dump/restore a descriptor in a file Each process writes a different descriptor...">MD_Vector_base2::readOn</a>(is);
<a name="l00222"></a>00222   <a class="code" href="classParam.html" title="Defined below in this file.">Param</a> p(<a class="code" href="classObjet__U.html#aa58e9a81c0ddc2c1149053b8f96698ac" title="renvoie la chaine identifiant la classe.">que_suis_je</a>());
<a name="l00223"></a>00223   <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> items_send_index, items_send_data, items_index, items_data, blocs_index, blocs_data;
<a name="l00224"></a>00224   p.<a class="code" href="classParam.html#affb8a0102361201ba896bac7ca8bc21c">ajouter</a>(<span class="stringliteral">&quot;pe_voisins&quot;</span>, &amp;<a class="code" href="classMD__Vector__std.html#a68854e710075fdc8c2f2ce28fbbb9ecc">pe_voisins_</a>);
<a name="l00225"></a>00225   p.<a class="code" href="classParam.html#affb8a0102361201ba896bac7ca8bc21c">ajouter</a>(<span class="stringliteral">&quot;items_to_send_index&quot;</span>, &amp;items_send_index);
<a name="l00226"></a>00226   p.<a class="code" href="classParam.html#affb8a0102361201ba896bac7ca8bc21c">ajouter</a>(<span class="stringliteral">&quot;items_to_send_data&quot;</span>, &amp;items_send_data);
<a name="l00227"></a>00227   p.<a class="code" href="classParam.html#affb8a0102361201ba896bac7ca8bc21c">ajouter</a>(<span class="stringliteral">&quot;nb_items_to_items&quot;</span>, &amp;<a class="code" href="classMD__Vector__std.html#afd0c291718e3bc9846c8a06420efeb69">nb_items_to_items_</a>);
<a name="l00228"></a>00228   p.<a class="code" href="classParam.html#affb8a0102361201ba896bac7ca8bc21c">ajouter</a>(<span class="stringliteral">&quot;items_to_recv_index&quot;</span>, &amp;items_index);
<a name="l00229"></a>00229   p.<a class="code" href="classParam.html#affb8a0102361201ba896bac7ca8bc21c">ajouter</a>(<span class="stringliteral">&quot;items_to_recv_data&quot;</span>, &amp;items_data);
<a name="l00230"></a>00230   p.<a class="code" href="classParam.html#affb8a0102361201ba896bac7ca8bc21c">ajouter</a>(<span class="stringliteral">&quot;blocs_to_recv_index&quot;</span>, &amp;blocs_index);
<a name="l00231"></a>00231   p.<a class="code" href="classParam.html#affb8a0102361201ba896bac7ca8bc21c">ajouter</a>(<span class="stringliteral">&quot;blocs_to_recv_data&quot;</span>, &amp;blocs_data);
<a name="l00232"></a>00232   p.<a class="code" href="classParam.html#affb8a0102361201ba896bac7ca8bc21c">ajouter</a>(<span class="stringliteral">&quot;blocs_items_count&quot;</span>, &amp;<a class="code" href="classMD__Vector__std.html#a4aa5e80e0b975026cc201fbdee72956c">blocs_items_count_</a>);
<a name="l00233"></a>00233   p.<a class="code" href="classParam.html#aea52f16d3b74c59c48cb5708ff48f14a">lire_avec_accolades</a>(is);
<a name="l00234"></a>00234   <span class="keywordflow">if</span> (items_send_data.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>())
<a name="l00235"></a>00235     <a class="code" href="classMD__Vector__std.html#a3ee9294b8d36492e8bdabbc9a97db451">items_to_send_</a>.<a class="code" href="classStatic__Int__Lists.html#ac2bd1e46c2d090657b51aed314b4ab40" title="remplace index et data.">set_index_data</a>(items_send_index, items_send_data);
<a name="l00236"></a>00236   <span class="keywordflow">if</span> (items_data.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>())
<a name="l00237"></a>00237     <a class="code" href="classMD__Vector__std.html#a8d6c4c5d6da6fe56e8330253137d412f">items_to_recv_</a>.<a class="code" href="classStatic__Int__Lists.html#ac2bd1e46c2d090657b51aed314b4ab40" title="remplace index et data.">set_index_data</a>(items_index, items_data);
<a name="l00238"></a>00238   <span class="keywordflow">if</span> (blocs_data.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>())
<a name="l00239"></a>00239     <a class="code" href="classMD__Vector__std.html#ae266bd552dcb9f817c791a1c7342a6b0">blocs_to_recv_</a>.<a class="code" href="classStatic__Int__Lists.html#ac2bd1e46c2d090657b51aed314b4ab40" title="remplace index et data.">set_index_data</a>(blocs_index, blocs_data);
<a name="l00240"></a>00240   <span class="keywordflow">return</span> is;
<a name="l00241"></a>00241 }
<a name="l00242"></a>00242 
<a name="l00243"></a>00243 <span class="comment">//</span><span class="comment"></span>
<a name="l00244"></a>00244 <span class="comment">//! method used to dump/restore a descriptor in a file&lt;br&gt;Each process writes a different descriptor. See MD_Vector_tools::dump_vector_with_md()</span>
<a name="l00245"></a><a class="code" href="classMD__Vector__std.html#ae5e4df932ffbaa45cc5c95602d0d997f">00245</a> <span class="comment"></span><a class="code" href="classSortie.html" title="Classe de base des flux de sortie. Elle sait ecrire des types simples&lt;br&gt;(entiers, flottants) et des Ob...">Sortie</a>&amp; <a class="code" href="classMD__Vector__std.html#ae5e4df932ffbaa45cc5c95602d0d997f" title="method used to dump/restore a descriptor in a file Each process writes a different descriptor...">MD_Vector_std::printOn</a>(<a class="code" href="classSortie.html" title="Classe de base des flux de sortie. Elle sait ecrire des types simples&lt;br&gt;(entiers, flottants) et des Ob...">Sortie</a>&amp; os)<span class="keyword"> const</span>
<a name="l00246"></a>00246 <span class="keyword"></span>{
<a name="l00247"></a>00247   <a class="code" href="classMD__Vector__std.html#ae5e4df932ffbaa45cc5c95602d0d997f" title="method used to dump/restore a descriptor in a file Each process writes a different descriptor...">MD_Vector_base2::printOn</a>(os);
<a name="l00248"></a>00248   os &lt;&lt; <span class="stringliteral">&quot;{&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
<a name="l00249"></a>00249   os &lt;&lt; <span class="stringliteral">&quot;pe_voisins&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#ae67efc620265981e3385b5f75837d3ef">space</a> &lt;&lt; <a class="code" href="classMD__Vector__std.html#a68854e710075fdc8c2f2ce28fbbb9ecc">pe_voisins_</a> &lt;&lt; finl;
<a name="l00250"></a>00250   os &lt;&lt; <span class="stringliteral">&quot;items_to_send_index&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#ae67efc620265981e3385b5f75837d3ef">space</a> &lt;&lt; <a class="code" href="classMD__Vector__std.html#a3ee9294b8d36492e8bdabbc9a97db451">items_to_send_</a>.<a class="code" href="classStatic__Int__Lists.html#a51352f7203aa95a858fdf7d198630352">get_index</a>() &lt;&lt; finl;
<a name="l00251"></a>00251   os &lt;&lt; <span class="stringliteral">&quot;items_to_send_data&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#ae67efc620265981e3385b5f75837d3ef">space</a> &lt;&lt; <a class="code" href="classMD__Vector__std.html#a3ee9294b8d36492e8bdabbc9a97db451">items_to_send_</a>.<a class="code" href="classStatic__Int__Lists.html#ac72c923acdf74ba0d8fed055c494fc5b">get_data</a>() &lt;&lt; finl;
<a name="l00252"></a>00252   os &lt;&lt; <span class="stringliteral">&quot;nb_items_to_items&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#ae67efc620265981e3385b5f75837d3ef">space</a> &lt;&lt; <a class="code" href="classMD__Vector__std.html#afd0c291718e3bc9846c8a06420efeb69">nb_items_to_items_</a> &lt;&lt; finl;
<a name="l00253"></a>00253   os &lt;&lt; <span class="stringliteral">&quot;items_to_recv_index&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#ae67efc620265981e3385b5f75837d3ef">space</a> &lt;&lt; <a class="code" href="classMD__Vector__std.html#a8d6c4c5d6da6fe56e8330253137d412f">items_to_recv_</a>.<a class="code" href="classStatic__Int__Lists.html#a51352f7203aa95a858fdf7d198630352">get_index</a>();
<a name="l00254"></a>00254   os &lt;&lt; <span class="stringliteral">&quot;items_to_recv_data&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#ae67efc620265981e3385b5f75837d3ef">space</a> &lt;&lt; <a class="code" href="classMD__Vector__std.html#a8d6c4c5d6da6fe56e8330253137d412f">items_to_recv_</a>.<a class="code" href="classStatic__Int__Lists.html#ac72c923acdf74ba0d8fed055c494fc5b">get_data</a>();
<a name="l00255"></a>00255   os &lt;&lt; <span class="stringliteral">&quot;blocs_to_recv_index&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#ae67efc620265981e3385b5f75837d3ef">space</a> &lt;&lt; <a class="code" href="classMD__Vector__std.html#ae266bd552dcb9f817c791a1c7342a6b0">blocs_to_recv_</a>.<a class="code" href="classStatic__Int__Lists.html#a51352f7203aa95a858fdf7d198630352">get_index</a>() &lt;&lt; finl;
<a name="l00256"></a>00256   os &lt;&lt; <span class="stringliteral">&quot;blocs_to_recv_data&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#ae67efc620265981e3385b5f75837d3ef">space</a> &lt;&lt; <a class="code" href="classMD__Vector__std.html#ae266bd552dcb9f817c791a1c7342a6b0">blocs_to_recv_</a>.<a class="code" href="classStatic__Int__Lists.html#ac72c923acdf74ba0d8fed055c494fc5b">get_data</a>();
<a name="l00257"></a>00257   os &lt;&lt; <span class="stringliteral">&quot;blocs_items_count&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#ae67efc620265981e3385b5f75837d3ef">space</a> &lt;&lt; <a class="code" href="classMD__Vector__std.html#a4aa5e80e0b975026cc201fbdee72956c">blocs_items_count_</a> &lt;&lt; finl;
<a name="l00258"></a>00258   os &lt;&lt; <span class="stringliteral">&quot;}&quot;</span> &lt;&lt; finl;
<a name="l00259"></a>00259   <span class="keywordflow">return</span> os;
<a name="l00260"></a>00260 }
<a name="l00261"></a>00261 
<a name="l00262"></a>00262 
<a name="l00263"></a>00263 <span class="comment">// static inline void -&gt; inline void car sinon erreur sur AIX:</span>
<a name="l00264"></a>00264 <span class="comment">// Static declarations are not considered for a function call if the function is not qualified</span>
<a name="l00265"></a><a class="code" href="MD__Vector__std_8cpp.html#a274c0a8351b6c6028b67209f0e34024f">00265</a> <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="MD__Vector__std_8cpp.html#a274c0a8351b6c6028b67209f0e34024f">initialize_comm_</a>(<span class="keyword">const</span> <a class="code" href="classMD__Vector__std.html" title="C&#39;est le plus simple des descripteurs, utilise pour les tableaux de valeurs aux sommets, elements, faces, aretes, faces de bord, etc... Il supporte la notion d&#39;items &quot;communs&quot; (sommets du maillage partages entre plusieurs processeurs) et d&#39;items &quot;distants&quot; et &quot;virtuels&quot; (sommets, elements dans l&#39;epaisseur de joint). Voir aussi MD_Vector_composite (descripteur compose d&#39;une reunion de plusieurs descripteurs, pour le P1Bulle par exemple)">MD_Vector_std</a>&amp; md, <span class="keyword">const</span> <a class="code" href="classEchange__EV__Options.html">Echange_EV_Options</a>&amp; opt, <a class="code" href="classSchema__Comm__Vecteurs.html" title="Classe outil utilisee notamment par les methodes MD_Vector::echange_espace_virtuel() Permet d&#39;echange...">Schema_Comm_Vecteurs</a>&amp; <a class="code" href="MD__Vector__tools_8cpp.html#aff39c4429f5c1b24eb7ac0848f154ffc">comm</a>, <span class="keywordtype">int</span> line_size, <span class="keywordtype">int</span> is_double)
<a name="l00266"></a>00266 {
<a name="l00267"></a>00267   <span class="keyword">const</span> <span class="keywordtype">int</span> reverse = (opt.<a class="code" href="classEchange__EV__Options.html#aa3d975c4dc791256ebd217c6aa3f4b15">get_op</a>() != <a class="code" href="classEchange__EV__Options.html#ab91405f7667327d1f277b627ca1adc09a96cf69dc7e23b38d6f83854a4d881e9b">Echange_EV_Options::SYNC</a>);
<a name="l00268"></a>00268 
<a name="l00269"></a>00269   <span class="keyword">const</span> <span class="keywordtype">int</span> have_items_to_recv = (md.<a class="code" href="classMD__Vector__std.html#a8d6c4c5d6da6fe56e8330253137d412f">items_to_recv_</a>.<a class="code" href="classStatic__Int__Lists.html#ac72c923acdf74ba0d8fed055c494fc5b">get_data</a>().<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() &gt; 0);
<a name="l00270"></a>00270   <span class="keyword">const</span> <span class="keywordtype">int</span> have_blocs_to_recv = (md.<a class="code" href="classMD__Vector__std.html#ae266bd552dcb9f817c791a1c7342a6b0">blocs_to_recv_</a>.<a class="code" href="classStatic__Int__Lists.html#ac72c923acdf74ba0d8fed055c494fc5b">get_data</a>().<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() &gt; 0);
<a name="l00271"></a>00271   <span class="keyword">const</span> <span class="keywordtype">int</span> nprocs = md.<a class="code" href="classMD__Vector__std.html#a68854e710075fdc8c2f2ce28fbbb9ecc">pe_voisins_</a>.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>();
<a name="l00272"></a>00272   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; nprocs; i++)
<a name="l00273"></a>00273     {
<a name="l00274"></a>00274       <span class="keyword">const</span> <span class="keywordtype">int</span> pe = md.<a class="code" href="classMD__Vector__std.html#a68854e710075fdc8c2f2ce28fbbb9ecc">pe_voisins_</a>[i];
<a name="l00275"></a>00275       <span class="keywordtype">int</span> sz1 = md.<a class="code" href="classMD__Vector__std.html#a3ee9294b8d36492e8bdabbc9a97db451">items_to_send_</a>.<a class="code" href="classStatic__Int__Lists.html#adbf6903737c3c30bf87e05b29f5a5b56" title="renvoie le nombre d&#39;elements de la liste i">get_list_size</a>(i);
<a name="l00276"></a>00276       <span class="keywordtype">int</span> sz2 = 0;
<a name="l00277"></a>00277       <span class="keywordflow">if</span> (have_items_to_recv)
<a name="l00278"></a>00278         sz2 = md.<a class="code" href="classMD__Vector__std.html#a8d6c4c5d6da6fe56e8330253137d412f">items_to_recv_</a>.<a class="code" href="classStatic__Int__Lists.html#adbf6903737c3c30bf87e05b29f5a5b56" title="renvoie le nombre d&#39;elements de la liste i">get_list_size</a>(i);
<a name="l00279"></a>00279       <span class="keywordflow">if</span> (have_blocs_to_recv)
<a name="l00280"></a>00280         sz2 += md.<a class="code" href="classMD__Vector__std.html#a4aa5e80e0b975026cc201fbdee72956c">blocs_items_count_</a>[i];
<a name="l00281"></a>00281       <span class="keywordflow">if</span> (reverse)
<a name="l00282"></a>00282         {
<a name="l00283"></a>00283 <span class="comment">// Schema a l&#39;envers: lecture dans les items to recv,</span>
<a name="l00284"></a>00284 <span class="comment">// ecriture dans les items to send</span>
<a name="l00285"></a>00285           <span class="keywordtype">int</span> tmp = sz1;
<a name="l00286"></a>00286           sz1 = sz2;
<a name="l00287"></a>00287           sz2 = tmp;
<a name="l00288"></a>00288         }
<a name="l00289"></a>00289       <span class="keywordflow">if</span> (is_double)
<a name="l00290"></a>00290         {
<a name="l00291"></a>00291           comm.<a class="code" href="classSchema__Comm__Vecteurs.html#a64e4789eec21a8a401107adb1aaa65eb">add_send_area_double</a>(pe, sz1 * line_size);
<a name="l00292"></a>00292           comm.<a class="code" href="classSchema__Comm__Vecteurs.html#a1e886aafb0edbc524e3426786d268ff1">add_recv_area_double</a>(pe, sz2 * line_size);
<a name="l00293"></a>00293         }
<a name="l00294"></a>00294       <span class="keywordflow">else</span>
<a name="l00295"></a>00295         {
<a name="l00296"></a>00296           comm.<a class="code" href="classSchema__Comm__Vecteurs.html#a80428288ac46f964239cf75adff9e426">add_send_area_int</a>(pe, sz1 * line_size);
<a name="l00297"></a>00297           comm.<a class="code" href="classSchema__Comm__Vecteurs.html#a7e0bf8bf0137f69808fb319802b29782">add_recv_area_int</a>(pe, sz2 * line_size);
<a name="l00298"></a>00298         }
<a name="l00299"></a>00299     }
<a name="l00300"></a>00300 }
<a name="l00301"></a>00301 
<a name="l00302"></a><a class="code" href="classMD__Vector__std.html#a9de1051fcb6626d3578660d2c1ab503a">00302</a> <span class="keywordtype">void</span> <a class="code" href="classMD__Vector__std.html#a9de1051fcb6626d3578660d2c1ab503a">MD_Vector_std::initialize_comm</a>(<span class="keyword">const</span> <a class="code" href="classEchange__EV__Options.html">Echange_EV_Options</a>&amp; opt, <a class="code" href="classSchema__Comm__Vecteurs.html" title="Classe outil utilisee notamment par les methodes MD_Vector::echange_espace_virtuel() Permet d&#39;echange...">Schema_Comm_Vecteurs</a>&amp; <a class="code" href="MD__Vector__tools_8cpp.html#aff39c4429f5c1b24eb7ac0848f154ffc">comm</a>, <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; v)<span class="keyword"> const</span>
<a name="l00303"></a>00303 <span class="keyword"></span>{
<a name="l00304"></a>00304   <a class="code" href="MD__Vector__std_8cpp.html#a274c0a8351b6c6028b67209f0e34024f">initialize_comm_</a>(*<span class="keyword">this</span>, opt, comm, v.<a class="code" href="classDoubleVect.html#ab02d01cd1bdab66fbd66f9a47cc29e10">line_size</a>(), 1 <span class="comment">/* double */</span>);
<a name="l00305"></a>00305 }
<a name="l00306"></a>00306 
<a name="l00307"></a><a class="code" href="classMD__Vector__std.html#afaea8c54f55c19671ba8b9d18f6fbd30">00307</a> <span class="keywordtype">void</span> <a class="code" href="classMD__Vector__std.html#a9de1051fcb6626d3578660d2c1ab503a">MD_Vector_std::initialize_comm</a>(<span class="keyword">const</span> <a class="code" href="classEchange__EV__Options.html">Echange_EV_Options</a>&amp; opt, <a class="code" href="classSchema__Comm__Vecteurs.html" title="Classe outil utilisee notamment par les methodes MD_Vector::echange_espace_virtuel() Permet d&#39;echange...">Schema_Comm_Vecteurs</a>&amp; <a class="code" href="MD__Vector__tools_8cpp.html#aff39c4429f5c1b24eb7ac0848f154ffc">comm</a>, <a class="code" href="classIntVect.html">IntVect</a>&amp; v)<span class="keyword"> const</span>
<a name="l00308"></a>00308 <span class="keyword"></span>{
<a name="l00309"></a>00309   <a class="code" href="MD__Vector__std_8cpp.html#a274c0a8351b6c6028b67209f0e34024f">initialize_comm_</a>(*<span class="keyword">this</span>, opt, comm, v.<a class="code" href="classIntVect.html#a5ba680066169c8e057bb3e3b876e4a8c">line_size</a>(), 0 <span class="comment">/* int */</span>);
<a name="l00310"></a>00310 }
<a name="l00311"></a>00311 
<a name="l00312"></a>00312 
<a name="l00313"></a>00313 <span class="comment">// Mais pourquoi on fait ca ?</span>
<a name="l00314"></a>00314 <span class="comment">// Le cas line_size==1 est courant (echange d&#39;une inconnue scalaire)</span>
<a name="l00315"></a>00315 <span class="comment">// et peut etre bien optimise en inline (multiplications et boucles en moins).</span>
<a name="l00316"></a>00316 
<a name="l00317"></a>00317 
<a name="l00318"></a>00318 
<a name="l00319"></a>00319 
<a name="l00320"></a>00320 
<a name="l00321"></a>00321 <span class="comment">// Methode generique pour traiter une liste d&#39;items ou de blocs, d&#39;ints ou de double</span>
<a name="l00322"></a>00322 <span class="comment">// a envoyer,recevoir ou ajouter.</span>
<a name="l00323"></a>00323 <span class="comment">// static inline void -&gt; inline void car sinon erreur sur AIX:</span>
<a name="l00324"></a>00324 <span class="comment">// Static declarations are not considered for a function call if the function is not qualified</span>
<a name="l00325"></a><a class="code" href="MD__Vector__std_8cpp.html#a10b62793ecb01cb8437cffbc92d2dd89">00325</a> <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="MD__Vector__std_8cpp.html#a10b62793ecb01cb8437cffbc92d2dd89">read_from_vect_items</a>(<span class="keyword">const</span> <span class="keywordtype">int</span> line_size,
<a name="l00326"></a>00326                                  <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; voisins,
<a name="l00327"></a>00327                                  <span class="keyword">const</span> <a class="code" href="classStatic__Int__Lists.html" title="Cette classe permet de stocker des listes d&#39;entiers accessibles en temps constant. La taille des listes ne peut pas changer sans perdre le contenu (ce sont des listes statiques). Exemple: Static_Int_List l; ArrOfInt tailles(3); tailles[0] = 2; tailles[1] = 3; tailles[2] = 0; // On reserve la memoire pour trois listes de taille 2, 3 et 0: l.set_list_sizes(tailles); // On affecte une valeur au deuxieme element de la premiere liste: l.set_value(0,1,765); // Affiche la valeur Cout &lt;&lt; l(0,1);.">Static_Int_Lists</a>&amp; list,
<a name="l00328"></a>00328                                  <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a>&amp; vect,
<a name="l00329"></a>00329                                  <a class="code" href="classSchema__Comm__Vecteurs.html" title="Classe outil utilisee notamment par les methodes MD_Vector::echange_espace_virtuel() Permet d&#39;echange...">Schema_Comm_Vecteurs</a>&amp; buffers)
<a name="l00330"></a>00330 {
<a name="l00331"></a>00331   assert(line_size &gt; 0);
<a name="l00332"></a>00332   <span class="keywordtype">double</span> *data = vect.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
<a name="l00333"></a>00333   <span class="keyword">const</span> <span class="keywordtype">int</span> *items_to_process = list.<a class="code" href="classStatic__Int__Lists.html#ac72c923acdf74ba0d8fed055c494fc5b">get_data</a>().<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
<a name="l00334"></a>00334   <span class="keywordtype">int</span> idx = 0; <span class="comment">//!&lt; Index in list.get_data()</span>
<a name="l00335"></a>00335 <span class="comment"></span>  <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; index = list.<a class="code" href="classStatic__Int__Lists.html#a51352f7203aa95a858fdf7d198630352">get_index</a>();
<a name="l00336"></a>00336   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_voisins = list.<a class="code" href="classStatic__Int__Lists.html#a5872636466919b2cb8efe715c315d7ca" title="renvoie le nombre de listes stockees">get_nb_lists</a>();
<a name="l00337"></a>00337   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i_voisin = 0; i_voisin &lt; nb_voisins; i_voisin++)
<a name="l00338"></a>00338     {
<a name="l00339"></a>00339 <span class="comment">// Indice dans list.get_data() de la fin de la liste d&#39;items/blocs pour ce voisin:</span>
<a name="l00340"></a>00340       <span class="keyword">const</span> <span class="keywordtype">int</span> idx_end_of_list = index[i_voisin+1];
<a name="l00341"></a>00341 <span class="comment">// Nombre d&#39;elements de tableau a envoyer/recevoir de ce voisin</span>
<a name="l00342"></a>00342       <span class="keyword">const</span> <span class="keywordtype">int</span> nb_elems = (idx_end_of_list - idx) * line_size;
<a name="l00343"></a>00343       <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a>&amp; buffer = buffers.<a class="code" href="classSchema__Comm__Vecteurs.html#a22d534079143232b4a9db96c93288782">get_next_area_double</a>(voisins[i_voisin], nb_elems);
<a name="l00344"></a>00344       <span class="keywordtype">double</span> * bufptr = buffer.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
<a name="l00345"></a>00345       assert(idx_end_of_list &lt;= list.<a class="code" href="classStatic__Int__Lists.html#ac72c923acdf74ba0d8fed055c494fc5b">get_data</a>().<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>());
<a name="l00346"></a>00346       <span class="keywordflow">while</span> (idx &lt; idx_end_of_list)
<a name="l00347"></a>00347         {
<a name="l00348"></a>00348 <span class="comment">// Indice de l&#39;item geometrique a copier (ou du premier item du bloc)</span>
<a name="l00349"></a>00349           <span class="keywordtype">int</span> premier_item_bloc = items_to_process[idx++];
<a name="l00350"></a>00350           <span class="keyword">const</span> <span class="keywordtype">int</span> bloc_size = 1;
<a name="l00351"></a>00351 <span class="comment">// Adresse des elements a copier dans le vecteur</span>
<a name="l00352"></a>00352           assert(premier_item_bloc &gt;= 0 &amp;&amp; bloc_size &gt; 0 &amp;&amp; (premier_item_bloc+bloc_size) * line_size &lt;= vect.<a class="code" href="classArrOfDouble.html#a3c3b33bea0e88b87315c21ee94bee05f" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>());
<a name="l00353"></a>00353           <span class="keywordtype">double</span> *vectptr = data + premier_item_bloc * line_size;
<a name="l00354"></a>00354           <span class="keyword">const</span> <span class="keywordtype">int</span> n = line_size * bloc_size;
<a name="l00355"></a>00355           assert(bufptr + n - buffer.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() &lt;= buffer.<a class="code" href="classArrOfDouble.html#a3c3b33bea0e88b87315c21ee94bee05f" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>());
<a name="l00356"></a>00356           <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; n; j++)
<a name="l00357"></a>00357             {
<a name="l00358"></a>00358               *(bufptr++) = *(vectptr++);
<a name="l00359"></a>00359             }
<a name="l00360"></a>00360         }
<a name="l00361"></a>00361     }
<a name="l00362"></a>00362 }
<a name="l00363"></a>00363 
<a name="l00364"></a>00364 
<a name="l00365"></a>00365 <span class="comment">// Methode generique pour traiter une liste d&#39;items ou de blocs, d&#39;ints ou de double</span>
<a name="l00366"></a>00366 <span class="comment">// a envoyer,recevoir ou ajouter.</span>
<a name="l00367"></a>00367 <span class="comment">// static inline void -&gt; inline void car sinon erreur sur AIX:</span>
<a name="l00368"></a>00368 <span class="comment">// Static declarations are not considered for a function call if the function is not qualified</span>
<a name="l00369"></a><a class="code" href="MD__Vector__std_8cpp.html#af1a3457cd2fc6fc193441c0e6dd3be74">00369</a> <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="MD__Vector__std_8cpp.html#af1a3457cd2fc6fc193441c0e6dd3be74">write_to_vect_items</a>(<span class="keyword">const</span> <span class="keywordtype">int</span> line_size,
<a name="l00370"></a>00370                                 <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; voisins,
<a name="l00371"></a>00371                                 <span class="keyword">const</span> <a class="code" href="classStatic__Int__Lists.html" title="Cette classe permet de stocker des listes d&#39;entiers accessibles en temps constant. La taille des listes ne peut pas changer sans perdre le contenu (ce sont des listes statiques). Exemple: Static_Int_List l; ArrOfInt tailles(3); tailles[0] = 2; tailles[1] = 3; tailles[2] = 0; // On reserve la memoire pour trois listes de taille 2, 3 et 0: l.set_list_sizes(tailles); // On affecte une valeur au deuxieme element de la premiere liste: l.set_value(0,1,765); // Affiche la valeur Cout &lt;&lt; l(0,1);.">Static_Int_Lists</a>&amp; list,
<a name="l00372"></a>00372                                 <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a>&amp; vect,
<a name="l00373"></a>00373                                 <a class="code" href="classSchema__Comm__Vecteurs.html" title="Classe outil utilisee notamment par les methodes MD_Vector::echange_espace_virtuel() Permet d&#39;echange...">Schema_Comm_Vecteurs</a>&amp; buffers)
<a name="l00374"></a>00374 {
<a name="l00375"></a>00375   assert(line_size &gt; 0);
<a name="l00376"></a>00376   <span class="keywordtype">double</span> *data = vect.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
<a name="l00377"></a>00377   <span class="keyword">const</span> <span class="keywordtype">int</span> *items_to_process = list.<a class="code" href="classStatic__Int__Lists.html#ac72c923acdf74ba0d8fed055c494fc5b">get_data</a>().<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
<a name="l00378"></a>00378   <span class="keywordtype">int</span> idx = 0; <span class="comment">//!&lt; Index in list.get_data()</span>
<a name="l00379"></a>00379 <span class="comment"></span>  <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; index = list.<a class="code" href="classStatic__Int__Lists.html#a51352f7203aa95a858fdf7d198630352">get_index</a>();
<a name="l00380"></a>00380   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_voisins = list.<a class="code" href="classStatic__Int__Lists.html#a5872636466919b2cb8efe715c315d7ca" title="renvoie le nombre de listes stockees">get_nb_lists</a>();
<a name="l00381"></a>00381   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i_voisin = 0; i_voisin &lt; nb_voisins; i_voisin++)
<a name="l00382"></a>00382     {
<a name="l00383"></a>00383 <span class="comment">// Indice dans list.get_data() de la fin de la liste d&#39;items/blocs pour ce voisin:</span>
<a name="l00384"></a>00384       <span class="keyword">const</span> <span class="keywordtype">int</span> idx_end_of_list = index[i_voisin+1];
<a name="l00385"></a>00385 <span class="comment">// Nombre d&#39;elements de tableau a envoyer/recevoir de ce voisin</span>
<a name="l00386"></a>00386       <span class="keyword">const</span> <span class="keywordtype">int</span> nb_elems = (idx_end_of_list - idx) * line_size;
<a name="l00387"></a>00387       <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a>&amp; buffer = buffers.<a class="code" href="classSchema__Comm__Vecteurs.html#a22d534079143232b4a9db96c93288782">get_next_area_double</a>(voisins[i_voisin], nb_elems);
<a name="l00388"></a>00388       <span class="keywordtype">double</span> * bufptr = buffer.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
<a name="l00389"></a>00389       assert(idx_end_of_list &lt;= list.<a class="code" href="classStatic__Int__Lists.html#ac72c923acdf74ba0d8fed055c494fc5b">get_data</a>().<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>());
<a name="l00390"></a>00390       <span class="keywordflow">while</span> (idx &lt; idx_end_of_list)
<a name="l00391"></a>00391         {
<a name="l00392"></a>00392 <span class="comment">// Indice de l&#39;item geometrique a copier (ou du premier item du bloc)</span>
<a name="l00393"></a>00393           <span class="keywordtype">int</span> premier_item_bloc = items_to_process[idx++];
<a name="l00394"></a>00394           <span class="keyword">const</span> <span class="keywordtype">int</span> bloc_size = 1;
<a name="l00395"></a>00395 <span class="comment">// Adresse des elements a copier dans le vecteur</span>
<a name="l00396"></a>00396           assert(premier_item_bloc &gt;= 0 &amp;&amp; bloc_size &gt; 0 &amp;&amp; (premier_item_bloc+bloc_size) * line_size &lt;= vect.<a class="code" href="classArrOfDouble.html#a3c3b33bea0e88b87315c21ee94bee05f" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>());
<a name="l00397"></a>00397           <span class="keywordtype">double</span> *vectptr = data + premier_item_bloc * line_size;
<a name="l00398"></a>00398           <span class="keyword">const</span> <span class="keywordtype">int</span> n = line_size * bloc_size;
<a name="l00399"></a>00399           assert(bufptr + n - buffer.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() &lt;= buffer.<a class="code" href="classArrOfDouble.html#a3c3b33bea0e88b87315c21ee94bee05f" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>());
<a name="l00400"></a>00400           <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; n; j++)
<a name="l00401"></a>00401             {
<a name="l00402"></a>00402               *(vectptr++) = *(bufptr++);
<a name="l00403"></a>00403             }
<a name="l00404"></a>00404         }
<a name="l00405"></a>00405     }
<a name="l00406"></a>00406 }
<a name="l00407"></a>00407 
<a name="l00408"></a>00408 
<a name="l00409"></a>00409 <span class="comment">// Methode generique pour traiter une liste d&#39;items ou de blocs, d&#39;ints ou de double</span>
<a name="l00410"></a>00410 <span class="comment">// a envoyer,recevoir ou ajouter.</span>
<a name="l00411"></a>00411 <span class="comment">// static inline void -&gt; inline void car sinon erreur sur AIX:</span>
<a name="l00412"></a>00412 <span class="comment">// Static declarations are not considered for a function call if the function is not qualified</span>
<a name="l00413"></a><a class="code" href="MD__Vector__std_8cpp.html#a18734241182f029a4ac78fe0e7c5215c">00413</a> <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="MD__Vector__std_8cpp.html#a18734241182f029a4ac78fe0e7c5215c">add_to_vect_items</a>(<span class="keyword">const</span> <span class="keywordtype">int</span> line_size,
<a name="l00414"></a>00414                               <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; voisins,
<a name="l00415"></a>00415                               <span class="keyword">const</span> <a class="code" href="classStatic__Int__Lists.html" title="Cette classe permet de stocker des listes d&#39;entiers accessibles en temps constant. La taille des listes ne peut pas changer sans perdre le contenu (ce sont des listes statiques). Exemple: Static_Int_List l; ArrOfInt tailles(3); tailles[0] = 2; tailles[1] = 3; tailles[2] = 0; // On reserve la memoire pour trois listes de taille 2, 3 et 0: l.set_list_sizes(tailles); // On affecte une valeur au deuxieme element de la premiere liste: l.set_value(0,1,765); // Affiche la valeur Cout &lt;&lt; l(0,1);.">Static_Int_Lists</a>&amp; list,
<a name="l00416"></a>00416                               <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a>&amp; vect,
<a name="l00417"></a>00417                               <a class="code" href="classSchema__Comm__Vecteurs.html" title="Classe outil utilisee notamment par les methodes MD_Vector::echange_espace_virtuel() Permet d&#39;echange...">Schema_Comm_Vecteurs</a>&amp; buffers)
<a name="l00418"></a>00418 {
<a name="l00419"></a>00419   assert(line_size &gt; 0);
<a name="l00420"></a>00420   <span class="keywordtype">double</span> *data = vect.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
<a name="l00421"></a>00421   <span class="keyword">const</span> <span class="keywordtype">int</span> *items_to_process = list.<a class="code" href="classStatic__Int__Lists.html#ac72c923acdf74ba0d8fed055c494fc5b">get_data</a>().<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
<a name="l00422"></a>00422   <span class="keywordtype">int</span> idx = 0; <span class="comment">//!&lt; Index in list.get_data()</span>
<a name="l00423"></a>00423 <span class="comment"></span>  <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; index = list.<a class="code" href="classStatic__Int__Lists.html#a51352f7203aa95a858fdf7d198630352">get_index</a>();
<a name="l00424"></a>00424   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_voisins = list.<a class="code" href="classStatic__Int__Lists.html#a5872636466919b2cb8efe715c315d7ca" title="renvoie le nombre de listes stockees">get_nb_lists</a>();
<a name="l00425"></a>00425   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i_voisin = 0; i_voisin &lt; nb_voisins; i_voisin++)
<a name="l00426"></a>00426     {
<a name="l00427"></a>00427 <span class="comment">// Indice dans list.get_data() de la fin de la liste d&#39;items/blocs pour ce voisin:</span>
<a name="l00428"></a>00428       <span class="keyword">const</span> <span class="keywordtype">int</span> idx_end_of_list = index[i_voisin+1];
<a name="l00429"></a>00429 <span class="comment">// Nombre d&#39;elements de tableau a envoyer/recevoir de ce voisin</span>
<a name="l00430"></a>00430       <span class="keyword">const</span> <span class="keywordtype">int</span> nb_elems = (idx_end_of_list - idx) * line_size;
<a name="l00431"></a>00431       <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a>&amp; buffer = buffers.<a class="code" href="classSchema__Comm__Vecteurs.html#a22d534079143232b4a9db96c93288782">get_next_area_double</a>(voisins[i_voisin], nb_elems);
<a name="l00432"></a>00432       <span class="keywordtype">double</span> * bufptr = buffer.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
<a name="l00433"></a>00433       assert(idx_end_of_list &lt;= list.<a class="code" href="classStatic__Int__Lists.html#ac72c923acdf74ba0d8fed055c494fc5b">get_data</a>().<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>());
<a name="l00434"></a>00434       <span class="keywordflow">while</span> (idx &lt; idx_end_of_list)
<a name="l00435"></a>00435         {
<a name="l00436"></a>00436 <span class="comment">// Indice de l&#39;item geometrique a copier (ou du premier item du bloc)</span>
<a name="l00437"></a>00437           <span class="keywordtype">int</span> premier_item_bloc = items_to_process[idx++];
<a name="l00438"></a>00438           <span class="keyword">const</span> <span class="keywordtype">int</span> bloc_size = 1;
<a name="l00439"></a>00439 <span class="comment">// Adresse des elements a copier dans le vecteur</span>
<a name="l00440"></a>00440           assert(premier_item_bloc &gt;= 0 &amp;&amp; bloc_size &gt; 0 &amp;&amp; (premier_item_bloc+bloc_size) * line_size &lt;= vect.<a class="code" href="classArrOfDouble.html#a3c3b33bea0e88b87315c21ee94bee05f" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>());
<a name="l00441"></a>00441           <span class="keywordtype">double</span> *vectptr = data + premier_item_bloc * line_size;
<a name="l00442"></a>00442           <span class="keyword">const</span> <span class="keywordtype">int</span> n = line_size * bloc_size;
<a name="l00443"></a>00443           assert(bufptr + n - buffer.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() &lt;= buffer.<a class="code" href="classArrOfDouble.html#a3c3b33bea0e88b87315c21ee94bee05f" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>());
<a name="l00444"></a>00444           <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; n; j++)
<a name="l00445"></a>00445             {
<a name="l00446"></a>00446               *(vectptr++) += *(bufptr++);
<a name="l00447"></a>00447             }
<a name="l00448"></a>00448         }
<a name="l00449"></a>00449     }
<a name="l00450"></a>00450 }
<a name="l00451"></a>00451 
<a name="l00452"></a>00452 
<a name="l00453"></a>00453 <span class="comment">// Methode generique pour traiter une liste d&#39;items ou de blocs, d&#39;ints ou de double</span>
<a name="l00454"></a>00454 <span class="comment">// a envoyer,recevoir ou ajouter.</span>
<a name="l00455"></a>00455 <span class="comment">// static inline void -&gt; inline void car sinon erreur sur AIX:</span>
<a name="l00456"></a>00456 <span class="comment">// Static declarations are not considered for a function call if the function is not qualified</span>
<a name="l00457"></a><a class="code" href="MD__Vector__std_8cpp.html#a0288ab9d63ca627c55980a67dcf9a8da">00457</a> <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="MD__Vector__std_8cpp.html#a0288ab9d63ca627c55980a67dcf9a8da">max_to_vect_items</a>(<span class="keyword">const</span> <span class="keywordtype">int</span> line_size,
<a name="l00458"></a>00458                               <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; voisins,
<a name="l00459"></a>00459                               <span class="keyword">const</span> <a class="code" href="classStatic__Int__Lists.html" title="Cette classe permet de stocker des listes d&#39;entiers accessibles en temps constant. La taille des listes ne peut pas changer sans perdre le contenu (ce sont des listes statiques). Exemple: Static_Int_List l; ArrOfInt tailles(3); tailles[0] = 2; tailles[1] = 3; tailles[2] = 0; // On reserve la memoire pour trois listes de taille 2, 3 et 0: l.set_list_sizes(tailles); // On affecte une valeur au deuxieme element de la premiere liste: l.set_value(0,1,765); // Affiche la valeur Cout &lt;&lt; l(0,1);.">Static_Int_Lists</a>&amp; list,
<a name="l00460"></a>00460                               <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a>&amp; vect,
<a name="l00461"></a>00461                               <a class="code" href="classSchema__Comm__Vecteurs.html" title="Classe outil utilisee notamment par les methodes MD_Vector::echange_espace_virtuel() Permet d&#39;echange...">Schema_Comm_Vecteurs</a>&amp; buffers)
<a name="l00462"></a>00462 {
<a name="l00463"></a>00463   assert(line_size &gt; 0);
<a name="l00464"></a>00464   <span class="keywordtype">double</span> *data = vect.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
<a name="l00465"></a>00465   <span class="keyword">const</span> <span class="keywordtype">int</span> *items_to_process = list.<a class="code" href="classStatic__Int__Lists.html#ac72c923acdf74ba0d8fed055c494fc5b">get_data</a>().<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
<a name="l00466"></a>00466   <span class="keywordtype">int</span> idx = 0; <span class="comment">//!&lt; Index in list.get_data()</span>
<a name="l00467"></a>00467 <span class="comment"></span>  <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; index = list.<a class="code" href="classStatic__Int__Lists.html#a51352f7203aa95a858fdf7d198630352">get_index</a>();
<a name="l00468"></a>00468   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_voisins = list.<a class="code" href="classStatic__Int__Lists.html#a5872636466919b2cb8efe715c315d7ca" title="renvoie le nombre de listes stockees">get_nb_lists</a>();
<a name="l00469"></a>00469   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i_voisin = 0; i_voisin &lt; nb_voisins; i_voisin++)
<a name="l00470"></a>00470     {
<a name="l00471"></a>00471 <span class="comment">// Indice dans list.get_data() de la fin de la liste d&#39;items/blocs pour ce voisin:</span>
<a name="l00472"></a>00472       <span class="keyword">const</span> <span class="keywordtype">int</span> idx_end_of_list = index[i_voisin+1];
<a name="l00473"></a>00473 <span class="comment">// Nombre d&#39;elements de tableau a envoyer/recevoir de ce voisin</span>
<a name="l00474"></a>00474       <span class="keyword">const</span> <span class="keywordtype">int</span> nb_elems = (idx_end_of_list - idx) * line_size;
<a name="l00475"></a>00475       <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a>&amp; buffer = buffers.<a class="code" href="classSchema__Comm__Vecteurs.html#a22d534079143232b4a9db96c93288782">get_next_area_double</a>(voisins[i_voisin], nb_elems);
<a name="l00476"></a>00476       <span class="keywordtype">double</span> * bufptr = buffer.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
<a name="l00477"></a>00477       assert(idx_end_of_list &lt;= list.<a class="code" href="classStatic__Int__Lists.html#ac72c923acdf74ba0d8fed055c494fc5b">get_data</a>().<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>());
<a name="l00478"></a>00478       <span class="keywordflow">while</span> (idx &lt; idx_end_of_list)
<a name="l00479"></a>00479         {
<a name="l00480"></a>00480 <span class="comment">// Indice de l&#39;item geometrique a copier (ou du premier item du bloc)</span>
<a name="l00481"></a>00481           <span class="keywordtype">int</span> premier_item_bloc = items_to_process[idx++];
<a name="l00482"></a>00482           <span class="keyword">const</span> <span class="keywordtype">int</span> bloc_size = 1;
<a name="l00483"></a>00483 <span class="comment">// Adresse des elements a copier dans le vecteur</span>
<a name="l00484"></a>00484           assert(premier_item_bloc &gt;= 0 &amp;&amp; bloc_size &gt; 0 &amp;&amp; (premier_item_bloc+bloc_size) * line_size &lt;= vect.<a class="code" href="classArrOfDouble.html#a3c3b33bea0e88b87315c21ee94bee05f" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>());
<a name="l00485"></a>00485           <span class="keywordtype">double</span> *vectptr = data + premier_item_bloc * line_size;
<a name="l00486"></a>00486           <span class="keyword">const</span> <span class="keywordtype">int</span> n = line_size * bloc_size;
<a name="l00487"></a>00487           assert(bufptr + n - buffer.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() &lt;= buffer.<a class="code" href="classArrOfDouble.html#a3c3b33bea0e88b87315c21ee94bee05f" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>());
<a name="l00488"></a>00488           <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; n; j++)
<a name="l00489"></a>00489             {
<a name="l00490"></a>00490               <span class="keywordtype">double</span> dest = *vectptr;
<a name="l00491"></a>00491               <span class="keywordtype">double</span> src  = *(bufptr++);
<a name="l00492"></a>00492               *(vectptr++) = (dest &gt; src) ? dest : src;
<a name="l00493"></a>00493             }
<a name="l00494"></a>00494         }
<a name="l00495"></a>00495     }
<a name="l00496"></a>00496 }
<a name="l00497"></a>00497 
<a name="l00498"></a>00498 
<a name="l00499"></a>00499 <span class="comment">// Methode generique pour traiter une liste d&#39;items ou de blocs, d&#39;ints ou de double</span>
<a name="l00500"></a>00500 <span class="comment">// a envoyer,recevoir ou ajouter.</span>
<a name="l00501"></a>00501 <span class="comment">// static inline void -&gt; inline void car sinon erreur sur AIX:</span>
<a name="l00502"></a>00502 <span class="comment">// Static declarations are not considered for a function call if the function is not qualified</span>
<a name="l00503"></a><a class="code" href="MD__Vector__std_8cpp.html#acc05df4426870bc5165ab6e635c5312c">00503</a> <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="MD__Vector__std_8cpp.html#acc05df4426870bc5165ab6e635c5312c">mincol1_to_vect_items</a>(<span class="keyword">const</span> <span class="keywordtype">int</span> line_size,
<a name="l00504"></a>00504                                   <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; voisins,
<a name="l00505"></a>00505                                   <span class="keyword">const</span> <a class="code" href="classStatic__Int__Lists.html" title="Cette classe permet de stocker des listes d&#39;entiers accessibles en temps constant. La taille des listes ne peut pas changer sans perdre le contenu (ce sont des listes statiques). Exemple: Static_Int_List l; ArrOfInt tailles(3); tailles[0] = 2; tailles[1] = 3; tailles[2] = 0; // On reserve la memoire pour trois listes de taille 2, 3 et 0: l.set_list_sizes(tailles); // On affecte une valeur au deuxieme element de la premiere liste: l.set_value(0,1,765); // Affiche la valeur Cout &lt;&lt; l(0,1);.">Static_Int_Lists</a>&amp; list,
<a name="l00506"></a>00506                                   <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a>&amp; vect,
<a name="l00507"></a>00507                                   <a class="code" href="classSchema__Comm__Vecteurs.html" title="Classe outil utilisee notamment par les methodes MD_Vector::echange_espace_virtuel() Permet d&#39;echange...">Schema_Comm_Vecteurs</a>&amp; buffers)
<a name="l00508"></a>00508 {
<a name="l00509"></a>00509   assert(line_size &gt; 0);
<a name="l00510"></a>00510   <span class="keywordtype">double</span> *data = vect.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
<a name="l00511"></a>00511   <span class="keyword">const</span> <span class="keywordtype">int</span> *items_to_process = list.<a class="code" href="classStatic__Int__Lists.html#ac72c923acdf74ba0d8fed055c494fc5b">get_data</a>().<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
<a name="l00512"></a>00512   <span class="keywordtype">int</span> idx = 0; <span class="comment">//!&lt; Index in list.get_data()</span>
<a name="l00513"></a>00513 <span class="comment"></span>  <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; index = list.<a class="code" href="classStatic__Int__Lists.html#a51352f7203aa95a858fdf7d198630352">get_index</a>();
<a name="l00514"></a>00514   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_voisins = list.<a class="code" href="classStatic__Int__Lists.html#a5872636466919b2cb8efe715c315d7ca" title="renvoie le nombre de listes stockees">get_nb_lists</a>();
<a name="l00515"></a>00515   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i_voisin = 0; i_voisin &lt; nb_voisins; i_voisin++)
<a name="l00516"></a>00516     {
<a name="l00517"></a>00517 <span class="comment">// Indice dans list.get_data() de la fin de la liste d&#39;items/blocs pour ce voisin:</span>
<a name="l00518"></a>00518       <span class="keyword">const</span> <span class="keywordtype">int</span> idx_end_of_list = index[i_voisin+1];
<a name="l00519"></a>00519 <span class="comment">// Nombre d&#39;elements de tableau a envoyer/recevoir de ce voisin</span>
<a name="l00520"></a>00520       <span class="keyword">const</span> <span class="keywordtype">int</span> nb_elems = (idx_end_of_list - idx) * line_size;
<a name="l00521"></a>00521       <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a>&amp; buffer = buffers.<a class="code" href="classSchema__Comm__Vecteurs.html#a22d534079143232b4a9db96c93288782">get_next_area_double</a>(voisins[i_voisin], nb_elems);
<a name="l00522"></a>00522       <span class="keywordtype">double</span> * bufptr = buffer.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
<a name="l00523"></a>00523       assert(idx_end_of_list &lt;= list.<a class="code" href="classStatic__Int__Lists.html#ac72c923acdf74ba0d8fed055c494fc5b">get_data</a>().<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>());
<a name="l00524"></a>00524       <span class="keywordflow">while</span> (idx &lt; idx_end_of_list)
<a name="l00525"></a>00525         {
<a name="l00526"></a>00526 <span class="comment">// Indice de l&#39;item geometrique a copier (ou du premier item du bloc)</span>
<a name="l00527"></a>00527           <span class="keywordtype">int</span> premier_item_bloc = items_to_process[idx++];
<a name="l00528"></a>00528           <span class="keyword">const</span> <span class="keywordtype">int</span> bloc_size = 1;
<a name="l00529"></a>00529 <span class="comment">// Adresse des elements a copier dans le vecteur</span>
<a name="l00530"></a>00530           assert(premier_item_bloc &gt;= 0 &amp;&amp; bloc_size &gt; 0 &amp;&amp; (premier_item_bloc+bloc_size) * line_size &lt;= vect.<a class="code" href="classArrOfDouble.html#a3c3b33bea0e88b87315c21ee94bee05f" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>());
<a name="l00531"></a>00531           <span class="keywordtype">double</span> *vectptr = data + premier_item_bloc * line_size;
<a name="l00532"></a>00532 <span class="comment">// Copy whole line if first line is greater than destination</span>
<a name="l00533"></a>00533           assert(bufptr + line_size * bloc_size - buffer.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() &lt;= buffer.<a class="code" href="classArrOfDouble.html#a3c3b33bea0e88b87315c21ee94bee05f" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>());
<a name="l00534"></a>00534           <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; bloc_size; j++)
<a name="l00535"></a>00535             {
<a name="l00536"></a>00536               <span class="keywordtype">double</span> dest = *vectptr;
<a name="l00537"></a>00537               <span class="keywordtype">double</span> src  = *bufptr;
<a name="l00538"></a>00538               <span class="keywordflow">if</span> (src &lt; dest)
<a name="l00539"></a>00539                 {
<a name="l00540"></a>00540                   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k = line_size; k; k--)
<a name="l00541"></a>00541                     *(vectptr++) = *(bufptr++);
<a name="l00542"></a>00542                 }
<a name="l00543"></a>00543               <span class="keywordflow">else</span>
<a name="l00544"></a>00544                 {
<a name="l00545"></a>00545                   vectptr += line_size;
<a name="l00546"></a>00546                   bufptr += line_size;
<a name="l00547"></a>00547                 }
<a name="l00548"></a>00548             }
<a name="l00549"></a>00549         }
<a name="l00550"></a>00550     }
<a name="l00551"></a>00551 }
<a name="l00552"></a>00552 
<a name="l00553"></a>00553 
<a name="l00554"></a>00554 <span class="comment">// Methode generique pour traiter une liste d&#39;items ou de blocs, d&#39;ints ou de double</span>
<a name="l00555"></a>00555 <span class="comment">// a envoyer,recevoir ou ajouter.</span>
<a name="l00556"></a>00556 <span class="comment">// static inline void -&gt; inline void car sinon erreur sur AIX:</span>
<a name="l00557"></a>00557 <span class="comment">// Static declarations are not considered for a function call if the function is not qualified</span>
<a name="l00558"></a><a class="code" href="MD__Vector__std_8cpp.html#a5a29fa9c3f9067e3d09fd936dac0d2f0">00558</a> <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="MD__Vector__std_8cpp.html#a5a29fa9c3f9067e3d09fd936dac0d2f0">read_from_vect_blocs</a>(<span class="keyword">const</span> <span class="keywordtype">int</span> line_size,
<a name="l00559"></a>00559                                  <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; voisins,
<a name="l00560"></a>00560                                  <span class="keyword">const</span> <a class="code" href="classStatic__Int__Lists.html" title="Cette classe permet de stocker des listes d&#39;entiers accessibles en temps constant. La taille des listes ne peut pas changer sans perdre le contenu (ce sont des listes statiques). Exemple: Static_Int_List l; ArrOfInt tailles(3); tailles[0] = 2; tailles[1] = 3; tailles[2] = 0; // On reserve la memoire pour trois listes de taille 2, 3 et 0: l.set_list_sizes(tailles); // On affecte une valeur au deuxieme element de la premiere liste: l.set_value(0,1,765); // Affiche la valeur Cout &lt;&lt; l(0,1);.">Static_Int_Lists</a>&amp; list,
<a name="l00561"></a>00561                                  <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; nb_items_par_voisin,
<a name="l00562"></a>00562                                  <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a>&amp; vect,
<a name="l00563"></a>00563                                  <a class="code" href="classSchema__Comm__Vecteurs.html" title="Classe outil utilisee notamment par les methodes MD_Vector::echange_espace_virtuel() Permet d&#39;echange...">Schema_Comm_Vecteurs</a>&amp; buffers)
<a name="l00564"></a>00564 {
<a name="l00565"></a>00565   assert(line_size &gt; 0);
<a name="l00566"></a>00566   <span class="keywordtype">double</span> *data = vect.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
<a name="l00567"></a>00567   <span class="keyword">const</span> <span class="keywordtype">int</span> *items_to_process = list.<a class="code" href="classStatic__Int__Lists.html#ac72c923acdf74ba0d8fed055c494fc5b">get_data</a>().<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
<a name="l00568"></a>00568   <span class="keywordtype">int</span> idx = 0; <span class="comment">//!&lt; Index in list.get_data()</span>
<a name="l00569"></a>00569 <span class="comment"></span>  <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; index = list.<a class="code" href="classStatic__Int__Lists.html#a51352f7203aa95a858fdf7d198630352">get_index</a>();
<a name="l00570"></a>00570   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_voisins = list.<a class="code" href="classStatic__Int__Lists.html#a5872636466919b2cb8efe715c315d7ca" title="renvoie le nombre de listes stockees">get_nb_lists</a>();
<a name="l00571"></a>00571   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i_voisin = 0; i_voisin &lt; nb_voisins; i_voisin++)
<a name="l00572"></a>00572     {
<a name="l00573"></a>00573 <span class="comment">// Indice dans list.get_data() de la fin de la liste d&#39;items/blocs pour ce voisin:</span>
<a name="l00574"></a>00574       <span class="keyword">const</span> <span class="keywordtype">int</span> idx_end_of_list = index[i_voisin+1];
<a name="l00575"></a>00575 <span class="comment">// Nombre d&#39;elements de tableau a envoyer/recevoir de ce voisin</span>
<a name="l00576"></a>00576       <span class="keyword">const</span> <span class="keywordtype">int</span> nb_elems = nb_items_par_voisin[i_voisin] * line_size;
<a name="l00577"></a>00577       <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a>&amp; buffer = buffers.<a class="code" href="classSchema__Comm__Vecteurs.html#a22d534079143232b4a9db96c93288782">get_next_area_double</a>(voisins[i_voisin], nb_elems);
<a name="l00578"></a>00578       <span class="keywordtype">double</span> * bufptr = buffer.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
<a name="l00579"></a>00579       assert(idx_end_of_list &lt;= list.<a class="code" href="classStatic__Int__Lists.html#ac72c923acdf74ba0d8fed055c494fc5b">get_data</a>().<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>());
<a name="l00580"></a>00580       <span class="keywordflow">while</span> (idx &lt; idx_end_of_list)
<a name="l00581"></a>00581         {
<a name="l00582"></a>00582 <span class="comment">// Indice de l&#39;item geometrique a copier (ou du premier item du bloc)</span>
<a name="l00583"></a>00583           <span class="keywordtype">int</span> premier_item_bloc = items_to_process[idx++];
<a name="l00584"></a>00584 <span class="comment">// For blocs, the array contains begin_bloc, end_bloc, begin_bloc, end_bloc...</span>
<a name="l00585"></a>00585           <span class="keyword">const</span> <span class="keywordtype">int</span> dernier_item_bloc = items_to_process[idx++];
<a name="l00586"></a>00586           <span class="keyword">const</span> <span class="keywordtype">int</span> bloc_size = dernier_item_bloc - premier_item_bloc;
<a name="l00587"></a>00587 <span class="comment">// Adresse des elements a copier dans le vecteur</span>
<a name="l00588"></a>00588           assert(premier_item_bloc &gt;= 0 &amp;&amp; bloc_size &gt; 0 &amp;&amp; (premier_item_bloc+bloc_size) * line_size &lt;= vect.<a class="code" href="classArrOfDouble.html#a3c3b33bea0e88b87315c21ee94bee05f" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>());
<a name="l00589"></a>00589           <span class="keywordtype">double</span> *vectptr = data + premier_item_bloc * line_size;
<a name="l00590"></a>00590           <span class="keyword">const</span> <span class="keywordtype">int</span> n = line_size * bloc_size;
<a name="l00591"></a>00591           assert(bufptr + n - buffer.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() &lt;= buffer.<a class="code" href="classArrOfDouble.html#a3c3b33bea0e88b87315c21ee94bee05f" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>());
<a name="l00592"></a>00592           <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; n; j++)
<a name="l00593"></a>00593             {
<a name="l00594"></a>00594               *(bufptr++) = *(vectptr++);
<a name="l00595"></a>00595             }
<a name="l00596"></a>00596         }
<a name="l00597"></a>00597     }
<a name="l00598"></a>00598 }
<a name="l00599"></a>00599 
<a name="l00600"></a>00600 
<a name="l00601"></a>00601 <span class="comment">// Methode generique pour traiter une liste d&#39;items ou de blocs, d&#39;ints ou de double</span>
<a name="l00602"></a>00602 <span class="comment">// a envoyer,recevoir ou ajouter.</span>
<a name="l00603"></a>00603 <span class="comment">// static inline void -&gt; inline void car sinon erreur sur AIX:</span>
<a name="l00604"></a>00604 <span class="comment">// Static declarations are not considered for a function call if the function is not qualified</span>
<a name="l00605"></a><a class="code" href="MD__Vector__std_8cpp.html#acbe04bcc0dbf2780408e9348dd5a9833">00605</a> <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="MD__Vector__std_8cpp.html#acbe04bcc0dbf2780408e9348dd5a9833">write_to_vect_blocs</a>(<span class="keyword">const</span> <span class="keywordtype">int</span> line_size,
<a name="l00606"></a>00606                                 <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; voisins,
<a name="l00607"></a>00607                                 <span class="keyword">const</span> <a class="code" href="classStatic__Int__Lists.html" title="Cette classe permet de stocker des listes d&#39;entiers accessibles en temps constant. La taille des listes ne peut pas changer sans perdre le contenu (ce sont des listes statiques). Exemple: Static_Int_List l; ArrOfInt tailles(3); tailles[0] = 2; tailles[1] = 3; tailles[2] = 0; // On reserve la memoire pour trois listes de taille 2, 3 et 0: l.set_list_sizes(tailles); // On affecte une valeur au deuxieme element de la premiere liste: l.set_value(0,1,765); // Affiche la valeur Cout &lt;&lt; l(0,1);.">Static_Int_Lists</a>&amp; list,
<a name="l00608"></a>00608                                 <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; nb_items_par_voisin,
<a name="l00609"></a>00609                                 <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a>&amp; vect,
<a name="l00610"></a>00610                                 <a class="code" href="classSchema__Comm__Vecteurs.html" title="Classe outil utilisee notamment par les methodes MD_Vector::echange_espace_virtuel() Permet d&#39;echange...">Schema_Comm_Vecteurs</a>&amp; buffers)
<a name="l00611"></a>00611 {
<a name="l00612"></a>00612   assert(line_size &gt; 0);
<a name="l00613"></a>00613   <span class="keywordtype">double</span> *data = vect.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
<a name="l00614"></a>00614   <span class="keyword">const</span> <span class="keywordtype">int</span> *items_to_process = list.<a class="code" href="classStatic__Int__Lists.html#ac72c923acdf74ba0d8fed055c494fc5b">get_data</a>().<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
<a name="l00615"></a>00615   <span class="keywordtype">int</span> idx = 0; <span class="comment">//!&lt; Index in list.get_data()</span>
<a name="l00616"></a>00616 <span class="comment"></span>  <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; index = list.<a class="code" href="classStatic__Int__Lists.html#a51352f7203aa95a858fdf7d198630352">get_index</a>();
<a name="l00617"></a>00617   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_voisins = list.<a class="code" href="classStatic__Int__Lists.html#a5872636466919b2cb8efe715c315d7ca" title="renvoie le nombre de listes stockees">get_nb_lists</a>();
<a name="l00618"></a>00618   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i_voisin = 0; i_voisin &lt; nb_voisins; i_voisin++)
<a name="l00619"></a>00619     {
<a name="l00620"></a>00620 <span class="comment">// Indice dans list.get_data() de la fin de la liste d&#39;items/blocs pour ce voisin:</span>
<a name="l00621"></a>00621       <span class="keyword">const</span> <span class="keywordtype">int</span> idx_end_of_list = index[i_voisin+1];
<a name="l00622"></a>00622 <span class="comment">// Nombre d&#39;elements de tableau a envoyer/recevoir de ce voisin</span>
<a name="l00623"></a>00623       <span class="keyword">const</span> <span class="keywordtype">int</span> nb_elems = nb_items_par_voisin[i_voisin] * line_size;
<a name="l00624"></a>00624       <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a>&amp; buffer = buffers.<a class="code" href="classSchema__Comm__Vecteurs.html#a22d534079143232b4a9db96c93288782">get_next_area_double</a>(voisins[i_voisin], nb_elems);
<a name="l00625"></a>00625       <span class="keywordtype">double</span> * bufptr = buffer.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
<a name="l00626"></a>00626       assert(idx_end_of_list &lt;= list.<a class="code" href="classStatic__Int__Lists.html#ac72c923acdf74ba0d8fed055c494fc5b">get_data</a>().<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>());
<a name="l00627"></a>00627       <span class="keywordflow">while</span> (idx &lt; idx_end_of_list)
<a name="l00628"></a>00628         {
<a name="l00629"></a>00629 <span class="comment">// Indice de l&#39;item geometrique a copier (ou du premier item du bloc)</span>
<a name="l00630"></a>00630           <span class="keywordtype">int</span> premier_item_bloc = items_to_process[idx++];
<a name="l00631"></a>00631 <span class="comment">// For blocs, the array contains begin_bloc, end_bloc, begin_bloc, end_bloc...</span>
<a name="l00632"></a>00632           <span class="keyword">const</span> <span class="keywordtype">int</span> dernier_item_bloc = items_to_process[idx++];
<a name="l00633"></a>00633           <span class="keyword">const</span> <span class="keywordtype">int</span> bloc_size = dernier_item_bloc - premier_item_bloc;
<a name="l00634"></a>00634 <span class="comment">// Adresse des elements a copier dans le vecteur</span>
<a name="l00635"></a>00635           assert(premier_item_bloc &gt;= 0 &amp;&amp; bloc_size &gt; 0 &amp;&amp; (premier_item_bloc+bloc_size) * line_size &lt;= vect.<a class="code" href="classArrOfDouble.html#a3c3b33bea0e88b87315c21ee94bee05f" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>());
<a name="l00636"></a>00636           <span class="keywordtype">double</span> *vectptr = data + premier_item_bloc * line_size;
<a name="l00637"></a>00637           <span class="keyword">const</span> <span class="keywordtype">int</span> n = line_size * bloc_size;
<a name="l00638"></a>00638           assert(bufptr + n - buffer.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() &lt;= buffer.<a class="code" href="classArrOfDouble.html#a3c3b33bea0e88b87315c21ee94bee05f" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>());
<a name="l00639"></a>00639           <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; n; j++)
<a name="l00640"></a>00640             {
<a name="l00641"></a>00641               *(vectptr++) = *(bufptr++);
<a name="l00642"></a>00642             }
<a name="l00643"></a>00643         }
<a name="l00644"></a>00644     }
<a name="l00645"></a>00645 }
<a name="l00646"></a>00646 
<a name="l00647"></a>00647 
<a name="l00648"></a>00648 <span class="comment">// Methode generique pour traiter une liste d&#39;items ou de blocs, d&#39;ints ou de double</span>
<a name="l00649"></a>00649 <span class="comment">// a envoyer,recevoir ou ajouter.</span>
<a name="l00650"></a>00650 <span class="comment">// static inline void -&gt; inline void car sinon erreur sur AIX:</span>
<a name="l00651"></a>00651 <span class="comment">// Static declarations are not considered for a function call if the function is not qualified</span>
<a name="l00652"></a><a class="code" href="MD__Vector__std_8cpp.html#a6b3040ad0a784f5bca7eddafffa60fca">00652</a> <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="MD__Vector__std_8cpp.html#a6b3040ad0a784f5bca7eddafffa60fca">add_to_vect_blocs</a>(<span class="keyword">const</span> <span class="keywordtype">int</span> line_size,
<a name="l00653"></a>00653                               <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; voisins,
<a name="l00654"></a>00654                               <span class="keyword">const</span> <a class="code" href="classStatic__Int__Lists.html" title="Cette classe permet de stocker des listes d&#39;entiers accessibles en temps constant. La taille des listes ne peut pas changer sans perdre le contenu (ce sont des listes statiques). Exemple: Static_Int_List l; ArrOfInt tailles(3); tailles[0] = 2; tailles[1] = 3; tailles[2] = 0; // On reserve la memoire pour trois listes de taille 2, 3 et 0: l.set_list_sizes(tailles); // On affecte une valeur au deuxieme element de la premiere liste: l.set_value(0,1,765); // Affiche la valeur Cout &lt;&lt; l(0,1);.">Static_Int_Lists</a>&amp; list,
<a name="l00655"></a>00655                               <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; nb_items_par_voisin,
<a name="l00656"></a>00656                               <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a>&amp; vect,
<a name="l00657"></a>00657                               <a class="code" href="classSchema__Comm__Vecteurs.html" title="Classe outil utilisee notamment par les methodes MD_Vector::echange_espace_virtuel() Permet d&#39;echange...">Schema_Comm_Vecteurs</a>&amp; buffers)
<a name="l00658"></a>00658 {
<a name="l00659"></a>00659   assert(line_size &gt; 0);
<a name="l00660"></a>00660   <span class="keywordtype">double</span> *data = vect.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
<a name="l00661"></a>00661   <span class="keyword">const</span> <span class="keywordtype">int</span> *items_to_process = list.<a class="code" href="classStatic__Int__Lists.html#ac72c923acdf74ba0d8fed055c494fc5b">get_data</a>().<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
<a name="l00662"></a>00662   <span class="keywordtype">int</span> idx = 0; <span class="comment">//!&lt; Index in list.get_data()</span>
<a name="l00663"></a>00663 <span class="comment"></span>  <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; index = list.<a class="code" href="classStatic__Int__Lists.html#a51352f7203aa95a858fdf7d198630352">get_index</a>();
<a name="l00664"></a>00664   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_voisins = list.<a class="code" href="classStatic__Int__Lists.html#a5872636466919b2cb8efe715c315d7ca" title="renvoie le nombre de listes stockees">get_nb_lists</a>();
<a name="l00665"></a>00665   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i_voisin = 0; i_voisin &lt; nb_voisins; i_voisin++)
<a name="l00666"></a>00666     {
<a name="l00667"></a>00667 <span class="comment">// Indice dans list.get_data() de la fin de la liste d&#39;items/blocs pour ce voisin:</span>
<a name="l00668"></a>00668       <span class="keyword">const</span> <span class="keywordtype">int</span> idx_end_of_list = index[i_voisin+1];
<a name="l00669"></a>00669 <span class="comment">// Nombre d&#39;elements de tableau a envoyer/recevoir de ce voisin</span>
<a name="l00670"></a>00670       <span class="keyword">const</span> <span class="keywordtype">int</span> nb_elems = nb_items_par_voisin[i_voisin] * line_size;
<a name="l00671"></a>00671       <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a>&amp; buffer = buffers.<a class="code" href="classSchema__Comm__Vecteurs.html#a22d534079143232b4a9db96c93288782">get_next_area_double</a>(voisins[i_voisin], nb_elems);
<a name="l00672"></a>00672       <span class="keywordtype">double</span> * bufptr = buffer.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
<a name="l00673"></a>00673       assert(idx_end_of_list &lt;= list.<a class="code" href="classStatic__Int__Lists.html#ac72c923acdf74ba0d8fed055c494fc5b">get_data</a>().<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>());
<a name="l00674"></a>00674       <span class="keywordflow">while</span> (idx &lt; idx_end_of_list)
<a name="l00675"></a>00675         {
<a name="l00676"></a>00676 <span class="comment">// Indice de l&#39;item geometrique a copier (ou du premier item du bloc)</span>
<a name="l00677"></a>00677           <span class="keywordtype">int</span> premier_item_bloc = items_to_process[idx++];
<a name="l00678"></a>00678 <span class="comment">// For blocs, the array contains begin_bloc, end_bloc, begin_bloc, end_bloc...</span>
<a name="l00679"></a>00679           <span class="keyword">const</span> <span class="keywordtype">int</span> dernier_item_bloc = items_to_process[idx++];
<a name="l00680"></a>00680           <span class="keyword">const</span> <span class="keywordtype">int</span> bloc_size = dernier_item_bloc - premier_item_bloc;
<a name="l00681"></a>00681 <span class="comment">// Adresse des elements a copier dans le vecteur</span>
<a name="l00682"></a>00682           assert(premier_item_bloc &gt;= 0 &amp;&amp; bloc_size &gt; 0 &amp;&amp; (premier_item_bloc+bloc_size) * line_size &lt;= vect.<a class="code" href="classArrOfDouble.html#a3c3b33bea0e88b87315c21ee94bee05f" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>());
<a name="l00683"></a>00683           <span class="keywordtype">double</span> *vectptr = data + premier_item_bloc * line_size;
<a name="l00684"></a>00684           <span class="keyword">const</span> <span class="keywordtype">int</span> n = line_size * bloc_size;
<a name="l00685"></a>00685           assert(bufptr + n - buffer.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() &lt;= buffer.<a class="code" href="classArrOfDouble.html#a3c3b33bea0e88b87315c21ee94bee05f" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>());
<a name="l00686"></a>00686           <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; n; j++)
<a name="l00687"></a>00687             {
<a name="l00688"></a>00688               *(vectptr++) += *(bufptr++);
<a name="l00689"></a>00689             }
<a name="l00690"></a>00690         }
<a name="l00691"></a>00691     }
<a name="l00692"></a>00692 }
<a name="l00693"></a>00693 
<a name="l00694"></a>00694 <span class="comment">//</span>
<a name="l00695"></a>00695 <span class="comment">//</span>
<a name="l00696"></a>00696 <span class="comment">//</span>
<a name="l00697"></a>00697 <span class="comment">//</span><span class="comment"></span>
<a name="l00698"></a>00698 <span class="comment">//! This is the first part of the echange_espace_virtuel() process.&lt;br&gt;We take the data that has to be sent to other processors in &quot;vect&quot; and put&lt;br&gt;it in appropriate send buffers in &quot;buffers&quot;. The data taken depends on &quot;opt&quot;.&lt;br&gt;Preconditon: The buffers must have been initialized to the appropriate size&lt;br&gt;and neighbour processors.</span>
<a name="l00699"></a><a class="code" href="classMD__Vector__std.html#ada966d7ecd5433dd05d7d7d4c97ee298">00699</a> <span class="comment"></span><span class="keywordtype">void</span> <a class="code" href="classMD__Vector__std.html#ada966d7ecd5433dd05d7d7d4c97ee298" title="This is the first part of the echange_espace_virtuel() process. We take the data that has to be sent ...">MD_Vector_std::prepare_send_data</a>(<span class="keyword">const</span> <a class="code" href="classEchange__EV__Options.html">Echange_EV_Options</a>&amp; opt,
<a name="l00700"></a>00700                                       <a class="code" href="classSchema__Comm__Vecteurs.html" title="Classe outil utilisee notamment par les methodes MD_Vector::echange_espace_virtuel() Permet d&#39;echange...">Schema_Comm_Vecteurs</a>&amp; buffers,
<a name="l00701"></a>00701                                       <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; vect)<span class="keyword"> const</span>
<a name="l00702"></a>00702 <span class="keyword"></span>{
<a name="l00703"></a>00703   <span class="keyword">const</span> <span class="keywordtype">int</span> line_size = vect.<a class="code" href="classDoubleVect.html#ab02d01cd1bdab66fbd66f9a47cc29e10">line_size</a>();
<a name="l00704"></a>00704   <span class="keywordflow">switch</span>(opt.<a class="code" href="classEchange__EV__Options.html#aa3d975c4dc791256ebd217c6aa3f4b15">get_op</a>())
<a name="l00705"></a>00705     {
<a name="l00706"></a>00706     <span class="keywordflow">case</span> <a class="code" href="classEchange__EV__Options.html#ab91405f7667327d1f277b627ca1adc09a96cf69dc7e23b38d6f83854a4d881e9b">Echange_EV_Options::SYNC</a>:
<a name="l00707"></a>00707       <span class="keywordflow">if</span> ( line_size==1)
<a name="l00708"></a>00708         <a class="code" href="MD__Vector__std_8cpp.html#a10b62793ecb01cb8437cffbc92d2dd89">read_from_vect_items</a>(1, <a class="code" href="classMD__Vector__std.html#a68854e710075fdc8c2f2ce28fbbb9ecc">pe_voisins_</a>, <a class="code" href="classMD__Vector__std.html#a3ee9294b8d36492e8bdabbc9a97db451">items_to_send_</a>, vect, buffers);
<a name="l00709"></a>00709       <span class="keywordflow">else</span>
<a name="l00710"></a>00710         <a class="code" href="MD__Vector__std_8cpp.html#a10b62793ecb01cb8437cffbc92d2dd89">read_from_vect_items</a>( line_size, <a class="code" href="classMD__Vector__std.html#a68854e710075fdc8c2f2ce28fbbb9ecc">pe_voisins_</a>, <a class="code" href="classMD__Vector__std.html#a3ee9294b8d36492e8bdabbc9a97db451">items_to_send_</a>, vect, buffers);
<a name="l00711"></a>00711       <span class="keywordflow">break</span>;
<a name="l00712"></a>00712     <span class="keywordflow">case</span> <a class="code" href="classEchange__EV__Options.html#ab91405f7667327d1f277b627ca1adc09ac77c64f48af249bb37caf3ab34df6150">Echange_EV_Options::SUM</a>:
<a name="l00713"></a>00713     <span class="keywordflow">case</span> <a class="code" href="classEchange__EV__Options.html#ab91405f7667327d1f277b627ca1adc09a671e2b505a3a0afccaa8fa1d544d977e">Echange_EV_Options::MAX</a>:
<a name="l00714"></a>00714     <span class="keywordflow">case</span> <a class="code" href="classEchange__EV__Options.html#ab91405f7667327d1f277b627ca1adc09a2f06eeb16446aeefef2331a15aa91b67">Echange_EV_Options::MINCOL1</a>:
<a name="l00715"></a>00715       <span class="keywordflow">if</span> (<a class="code" href="classMD__Vector__std.html#a8d6c4c5d6da6fe56e8330253137d412f">items_to_recv_</a>.<a class="code" href="classStatic__Int__Lists.html#ac72c923acdf74ba0d8fed055c494fc5b">get_data</a>().<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() &gt; 0)
<a name="l00716"></a>00716         {
<a name="l00717"></a>00717           <span class="keywordflow">if</span> ( line_size==1)
<a name="l00718"></a>00718             <a class="code" href="MD__Vector__std_8cpp.html#a10b62793ecb01cb8437cffbc92d2dd89">read_from_vect_items</a>(1, <a class="code" href="classMD__Vector__std.html#a68854e710075fdc8c2f2ce28fbbb9ecc">pe_voisins_</a>, <a class="code" href="classMD__Vector__std.html#a8d6c4c5d6da6fe56e8330253137d412f">items_to_recv_</a>, vect, buffers);
<a name="l00719"></a>00719           <span class="keywordflow">else</span>
<a name="l00720"></a>00720             <a class="code" href="MD__Vector__std_8cpp.html#a10b62793ecb01cb8437cffbc92d2dd89">read_from_vect_items</a>( line_size, <a class="code" href="classMD__Vector__std.html#a68854e710075fdc8c2f2ce28fbbb9ecc">pe_voisins_</a>, <a class="code" href="classMD__Vector__std.html#a8d6c4c5d6da6fe56e8330253137d412f">items_to_recv_</a>, vect, buffers);
<a name="l00721"></a>00721         }
<a name="l00722"></a>00722       <span class="keywordflow">if</span> (<a class="code" href="classMD__Vector__std.html#ae266bd552dcb9f817c791a1c7342a6b0">blocs_to_recv_</a>.<a class="code" href="classStatic__Int__Lists.html#ac72c923acdf74ba0d8fed055c494fc5b">get_data</a>().<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() &gt; 0)
<a name="l00723"></a>00723         {
<a name="l00724"></a>00724           <span class="keywordflow">if</span> ( line_size==1)
<a name="l00725"></a>00725             <a class="code" href="MD__Vector__std_8cpp.html#a5a29fa9c3f9067e3d09fd936dac0d2f0">read_from_vect_blocs</a>(1, <a class="code" href="classMD__Vector__std.html#a68854e710075fdc8c2f2ce28fbbb9ecc">pe_voisins_</a>, <a class="code" href="classMD__Vector__std.html#ae266bd552dcb9f817c791a1c7342a6b0">blocs_to_recv_</a>, <a class="code" href="classMD__Vector__std.html#a4aa5e80e0b975026cc201fbdee72956c">blocs_items_count_</a>, vect, buffers);
<a name="l00726"></a>00726           <span class="keywordflow">else</span>
<a name="l00727"></a>00727             <a class="code" href="MD__Vector__std_8cpp.html#a5a29fa9c3f9067e3d09fd936dac0d2f0">read_from_vect_blocs</a>( line_size, <a class="code" href="classMD__Vector__std.html#a68854e710075fdc8c2f2ce28fbbb9ecc">pe_voisins_</a>, <a class="code" href="classMD__Vector__std.html#ae266bd552dcb9f817c791a1c7342a6b0">blocs_to_recv_</a>, <a class="code" href="classMD__Vector__std.html#a4aa5e80e0b975026cc201fbdee72956c">blocs_items_count_</a>, vect, buffers);
<a name="l00728"></a>00728         }
<a name="l00729"></a>00729       <span class="keywordflow">break</span>;
<a name="l00730"></a>00730     <span class="keywordflow">default</span>:
<a name="l00731"></a>00731       <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Error in MD_Vector_std.cpp prepare send data: operation not implemented&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
<a name="l00732"></a>00732       <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">Process::exit</a>();
<a name="l00733"></a>00733     }
<a name="l00734"></a>00734 }
<a name="l00735"></a>00735 
<a name="l00736"></a><a class="code" href="classMD__Vector__std.html#aac76e0b9c999dde47168e2a1060508d1">00736</a> <span class="keywordtype">void</span> <a class="code" href="classMD__Vector__std.html#aac76e0b9c999dde47168e2a1060508d1">MD_Vector_std::process_recv_data</a>(<span class="keyword">const</span> <a class="code" href="classEchange__EV__Options.html">Echange_EV_Options</a>&amp; opt,
<a name="l00737"></a>00737                                       <a class="code" href="classSchema__Comm__Vecteurs.html" title="Classe outil utilisee notamment par les methodes MD_Vector::echange_espace_virtuel() Permet d&#39;echange...">Schema_Comm_Vecteurs</a>&amp; buffers,
<a name="l00738"></a>00738                                       <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; vect)<span class="keyword"> const</span>
<a name="l00739"></a>00739 <span class="keyword"></span>{
<a name="l00740"></a>00740   <span class="keyword">const</span> <span class="keywordtype">int</span> line_size = vect.<a class="code" href="classDoubleVect.html#ab02d01cd1bdab66fbd66f9a47cc29e10">line_size</a>();
<a name="l00741"></a>00741   <span class="keywordflow">switch</span>(opt.<a class="code" href="classEchange__EV__Options.html#aa3d975c4dc791256ebd217c6aa3f4b15">get_op</a>())
<a name="l00742"></a>00742     {
<a name="l00743"></a>00743     <span class="keywordflow">case</span> <a class="code" href="classEchange__EV__Options.html#ab91405f7667327d1f277b627ca1adc09a96cf69dc7e23b38d6f83854a4d881e9b">Echange_EV_Options::SYNC</a>:
<a name="l00744"></a>00744       <span class="keywordflow">if</span> (<a class="code" href="classMD__Vector__std.html#a8d6c4c5d6da6fe56e8330253137d412f">items_to_recv_</a>.<a class="code" href="classStatic__Int__Lists.html#ac72c923acdf74ba0d8fed055c494fc5b">get_data</a>().<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() &gt; 0)
<a name="l00745"></a>00745         {
<a name="l00746"></a>00746           <span class="keywordflow">if</span> ( line_size==1)
<a name="l00747"></a>00747             <a class="code" href="MD__Vector__std_8cpp.html#af1a3457cd2fc6fc193441c0e6dd3be74">write_to_vect_items</a>(1, <a class="code" href="classMD__Vector__std.html#a68854e710075fdc8c2f2ce28fbbb9ecc">pe_voisins_</a>, <a class="code" href="classMD__Vector__std.html#a8d6c4c5d6da6fe56e8330253137d412f">items_to_recv_</a>, vect, buffers);
<a name="l00748"></a>00748           <span class="keywordflow">else</span>
<a name="l00749"></a>00749             <a class="code" href="MD__Vector__std_8cpp.html#af1a3457cd2fc6fc193441c0e6dd3be74">write_to_vect_items</a>( line_size, <a class="code" href="classMD__Vector__std.html#a68854e710075fdc8c2f2ce28fbbb9ecc">pe_voisins_</a>, <a class="code" href="classMD__Vector__std.html#a8d6c4c5d6da6fe56e8330253137d412f">items_to_recv_</a>, vect, buffers);
<a name="l00750"></a>00750         }
<a name="l00751"></a>00751       <span class="keywordflow">if</span> (<a class="code" href="classMD__Vector__std.html#ae266bd552dcb9f817c791a1c7342a6b0">blocs_to_recv_</a>.<a class="code" href="classStatic__Int__Lists.html#ac72c923acdf74ba0d8fed055c494fc5b">get_data</a>().<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() &gt; 0)
<a name="l00752"></a>00752         {
<a name="l00753"></a>00753           <span class="keywordflow">if</span> ( line_size==1)
<a name="l00754"></a>00754             <a class="code" href="MD__Vector__std_8cpp.html#acbe04bcc0dbf2780408e9348dd5a9833">write_to_vect_blocs</a>(1, <a class="code" href="classMD__Vector__std.html#a68854e710075fdc8c2f2ce28fbbb9ecc">pe_voisins_</a>, <a class="code" href="classMD__Vector__std.html#ae266bd552dcb9f817c791a1c7342a6b0">blocs_to_recv_</a>, <a class="code" href="classMD__Vector__std.html#a4aa5e80e0b975026cc201fbdee72956c">blocs_items_count_</a>, vect, buffers);
<a name="l00755"></a>00755           <span class="keywordflow">else</span>
<a name="l00756"></a>00756             <a class="code" href="MD__Vector__std_8cpp.html#acbe04bcc0dbf2780408e9348dd5a9833">write_to_vect_blocs</a>( line_size, <a class="code" href="classMD__Vector__std.html#a68854e710075fdc8c2f2ce28fbbb9ecc">pe_voisins_</a>, <a class="code" href="classMD__Vector__std.html#ae266bd552dcb9f817c791a1c7342a6b0">blocs_to_recv_</a>, <a class="code" href="classMD__Vector__std.html#a4aa5e80e0b975026cc201fbdee72956c">blocs_items_count_</a>, vect, buffers);
<a name="l00757"></a>00757         }
<a name="l00758"></a>00758       <span class="keywordflow">break</span>;
<a name="l00759"></a>00759     <span class="keywordflow">case</span> <a class="code" href="classEchange__EV__Options.html#ab91405f7667327d1f277b627ca1adc09ac77c64f48af249bb37caf3ab34df6150">Echange_EV_Options::SUM</a>:
<a name="l00760"></a>00760 <span class="comment">// Reverse operation: write data to &quot;real&quot; items</span>
<a name="l00761"></a>00761       <span class="keywordflow">if</span> ( line_size==1)
<a name="l00762"></a>00762         <a class="code" href="MD__Vector__std_8cpp.html#a18734241182f029a4ac78fe0e7c5215c">add_to_vect_items</a>(1, <a class="code" href="classMD__Vector__std.html#a68854e710075fdc8c2f2ce28fbbb9ecc">pe_voisins_</a>, <a class="code" href="classMD__Vector__std.html#a3ee9294b8d36492e8bdabbc9a97db451">items_to_send_</a>, vect, buffers);
<a name="l00763"></a>00763       <span class="keywordflow">else</span>
<a name="l00764"></a>00764         <a class="code" href="MD__Vector__std_8cpp.html#a18734241182f029a4ac78fe0e7c5215c">add_to_vect_items</a>( line_size, <a class="code" href="classMD__Vector__std.html#a68854e710075fdc8c2f2ce28fbbb9ecc">pe_voisins_</a>, <a class="code" href="classMD__Vector__std.html#a3ee9294b8d36492e8bdabbc9a97db451">items_to_send_</a>, vect, buffers);
<a name="l00765"></a>00765       <span class="keywordflow">break</span>;
<a name="l00766"></a>00766     <span class="keywordflow">case</span> <a class="code" href="classEchange__EV__Options.html#ab91405f7667327d1f277b627ca1adc09a671e2b505a3a0afccaa8fa1d544d977e">Echange_EV_Options::MAX</a>:
<a name="l00767"></a>00767       <span class="keywordflow">if</span> ( line_size==1)
<a name="l00768"></a>00768         <a class="code" href="MD__Vector__std_8cpp.html#a0288ab9d63ca627c55980a67dcf9a8da">max_to_vect_items</a>(1, <a class="code" href="classMD__Vector__std.html#a68854e710075fdc8c2f2ce28fbbb9ecc">pe_voisins_</a>, <a class="code" href="classMD__Vector__std.html#a3ee9294b8d36492e8bdabbc9a97db451">items_to_send_</a>, vect, buffers);
<a name="l00769"></a>00769       <span class="keywordflow">else</span>
<a name="l00770"></a>00770         <a class="code" href="MD__Vector__std_8cpp.html#a0288ab9d63ca627c55980a67dcf9a8da">max_to_vect_items</a>( line_size, <a class="code" href="classMD__Vector__std.html#a68854e710075fdc8c2f2ce28fbbb9ecc">pe_voisins_</a>, <a class="code" href="classMD__Vector__std.html#a3ee9294b8d36492e8bdabbc9a97db451">items_to_send_</a>, vect, buffers);
<a name="l00771"></a>00771       <span class="keywordflow">break</span>;
<a name="l00772"></a>00772     <span class="keywordflow">case</span> <a class="code" href="classEchange__EV__Options.html#ab91405f7667327d1f277b627ca1adc09a2f06eeb16446aeefef2331a15aa91b67">Echange_EV_Options::MINCOL1</a>:
<a name="l00773"></a>00773       <span class="keywordflow">if</span> ( line_size==1)
<a name="l00774"></a>00774         <a class="code" href="MD__Vector__std_8cpp.html#acc05df4426870bc5165ab6e635c5312c">mincol1_to_vect_items</a>(1, <a class="code" href="classMD__Vector__std.html#a68854e710075fdc8c2f2ce28fbbb9ecc">pe_voisins_</a>, <a class="code" href="classMD__Vector__std.html#a3ee9294b8d36492e8bdabbc9a97db451">items_to_send_</a>, vect, buffers);
<a name="l00775"></a>00775       <span class="keywordflow">else</span>
<a name="l00776"></a>00776         <a class="code" href="MD__Vector__std_8cpp.html#acc05df4426870bc5165ab6e635c5312c">mincol1_to_vect_items</a>( line_size, <a class="code" href="classMD__Vector__std.html#a68854e710075fdc8c2f2ce28fbbb9ecc">pe_voisins_</a>, <a class="code" href="classMD__Vector__std.html#a3ee9294b8d36492e8bdabbc9a97db451">items_to_send_</a>, vect, buffers);
<a name="l00777"></a>00777       <span class="keywordflow">break</span>;
<a name="l00778"></a>00778     <span class="keywordflow">default</span>:
<a name="l00779"></a>00779       <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Error in MD_Vector_std.cpp process recv data: operation not implemented&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
<a name="l00780"></a>00780       <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">Process::exit</a>();
<a name="l00781"></a>00781     }
<a name="l00782"></a>00782 }
<a name="l00783"></a>00783 
<a name="l00784"></a>00784 
<a name="l00785"></a>00785 <span class="comment">// Methode generique pour traiter une liste d&#39;items ou de blocs, d&#39;ints ou de double</span>
<a name="l00786"></a>00786 <span class="comment">// a envoyer,recevoir ou ajouter.</span>
<a name="l00787"></a>00787 <span class="comment">// static inline void -&gt; inline void car sinon erreur sur AIX:</span>
<a name="l00788"></a>00788 <span class="comment">// Static declarations are not considered for a function call if the function is not qualified</span>
<a name="l00789"></a><a class="code" href="MD__Vector__std_8cpp.html#aafd41fc64277c4557a45f15dfdea335f">00789</a> <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="MD__Vector__std_8cpp.html#a10b62793ecb01cb8437cffbc92d2dd89">read_from_vect_items</a>(<span class="keyword">const</span> <span class="keywordtype">int</span> line_size,
<a name="l00790"></a>00790                                  <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; voisins,
<a name="l00791"></a>00791                                  <span class="keyword">const</span> <a class="code" href="classStatic__Int__Lists.html" title="Cette classe permet de stocker des listes d&#39;entiers accessibles en temps constant. La taille des listes ne peut pas changer sans perdre le contenu (ce sont des listes statiques). Exemple: Static_Int_List l; ArrOfInt tailles(3); tailles[0] = 2; tailles[1] = 3; tailles[2] = 0; // On reserve la memoire pour trois listes de taille 2, 3 et 0: l.set_list_sizes(tailles); // On affecte une valeur au deuxieme element de la premiere liste: l.set_value(0,1,765); // Affiche la valeur Cout &lt;&lt; l(0,1);.">Static_Int_Lists</a>&amp; list,
<a name="l00792"></a>00792                                  <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; vect,
<a name="l00793"></a>00793                                  <a class="code" href="classSchema__Comm__Vecteurs.html" title="Classe outil utilisee notamment par les methodes MD_Vector::echange_espace_virtuel() Permet d&#39;echange...">Schema_Comm_Vecteurs</a>&amp; buffers)
<a name="l00794"></a>00794 {
<a name="l00795"></a>00795   assert(line_size &gt; 0);
<a name="l00796"></a>00796   <span class="keywordtype">int</span> *data = vect.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
<a name="l00797"></a>00797   <span class="keyword">const</span> <span class="keywordtype">int</span> *items_to_process = list.<a class="code" href="classStatic__Int__Lists.html#ac72c923acdf74ba0d8fed055c494fc5b">get_data</a>().<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
<a name="l00798"></a>00798   <span class="keywordtype">int</span> idx = 0; <span class="comment">//!&lt; Index in list.get_data()</span>
<a name="l00799"></a>00799 <span class="comment"></span>  <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; index = list.<a class="code" href="classStatic__Int__Lists.html#a51352f7203aa95a858fdf7d198630352">get_index</a>();
<a name="l00800"></a>00800   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_voisins = list.<a class="code" href="classStatic__Int__Lists.html#a5872636466919b2cb8efe715c315d7ca" title="renvoie le nombre de listes stockees">get_nb_lists</a>();
<a name="l00801"></a>00801   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i_voisin = 0; i_voisin &lt; nb_voisins; i_voisin++)
<a name="l00802"></a>00802     {
<a name="l00803"></a>00803 <span class="comment">// Indice dans list.get_data() de la fin de la liste d&#39;items/blocs pour ce voisin:</span>
<a name="l00804"></a>00804       <span class="keyword">const</span> <span class="keywordtype">int</span> idx_end_of_list = index[i_voisin+1];
<a name="l00805"></a>00805 <span class="comment">// Nombre d&#39;elements de tableau a envoyer/recevoir de ce voisin</span>
<a name="l00806"></a>00806       <span class="keyword">const</span> <span class="keywordtype">int</span> nb_elems = (idx_end_of_list - idx) * line_size;
<a name="l00807"></a>00807       <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; buffer = buffers.<a class="code" href="classSchema__Comm__Vecteurs.html#ae31bd8f65b3b9ff75f5e8f12f94f5ebf" title="renvoie un tableau contenant les &quot;size&quot; valeurs suivantes recues du processeur pe lors de la commun...">get_next_area_int</a>(voisins[i_voisin], nb_elems);
<a name="l00808"></a>00808       <span class="keywordtype">int</span> * bufptr = buffer.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
<a name="l00809"></a>00809       assert(idx_end_of_list &lt;= list.<a class="code" href="classStatic__Int__Lists.html#ac72c923acdf74ba0d8fed055c494fc5b">get_data</a>().<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>());
<a name="l00810"></a>00810       <span class="keywordflow">while</span> (idx &lt; idx_end_of_list)
<a name="l00811"></a>00811         {
<a name="l00812"></a>00812 <span class="comment">// Indice de l&#39;item geometrique a copier (ou du premier item du bloc)</span>
<a name="l00813"></a>00813           <span class="keywordtype">int</span> premier_item_bloc = items_to_process[idx++];
<a name="l00814"></a>00814           <span class="keyword">const</span> <span class="keywordtype">int</span> bloc_size = 1;
<a name="l00815"></a>00815 <span class="comment">// Adresse des elements a copier dans le vecteur</span>
<a name="l00816"></a>00816           assert(premier_item_bloc &gt;= 0 &amp;&amp; bloc_size &gt; 0 &amp;&amp; (premier_item_bloc+bloc_size) * line_size &lt;= vect.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>());
<a name="l00817"></a>00817           <span class="keywordtype">int</span> *vectptr = data + premier_item_bloc * line_size;
<a name="l00818"></a>00818           <span class="keyword">const</span> <span class="keywordtype">int</span> n = line_size * bloc_size;
<a name="l00819"></a>00819           assert(bufptr + n - buffer.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() &lt;= buffer.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>());
<a name="l00820"></a>00820           <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; n; j++)
<a name="l00821"></a>00821             {
<a name="l00822"></a>00822               *(bufptr++) = *(vectptr++);
<a name="l00823"></a>00823             }
<a name="l00824"></a>00824         }
<a name="l00825"></a>00825     }
<a name="l00826"></a>00826 }
<a name="l00827"></a>00827 
<a name="l00828"></a>00828 
<a name="l00829"></a>00829 <span class="comment">// Methode generique pour traiter une liste d&#39;items ou de blocs, d&#39;ints ou de double</span>
<a name="l00830"></a>00830 <span class="comment">// a envoyer,recevoir ou ajouter.</span>
<a name="l00831"></a>00831 <span class="comment">// static inline void -&gt; inline void car sinon erreur sur AIX:</span>
<a name="l00832"></a>00832 <span class="comment">// Static declarations are not considered for a function call if the function is not qualified</span>
<a name="l00833"></a><a class="code" href="MD__Vector__std_8cpp.html#a9f809601c51b1f7030e73731b9fd4684">00833</a> <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="MD__Vector__std_8cpp.html#af1a3457cd2fc6fc193441c0e6dd3be74">write_to_vect_items</a>(<span class="keyword">const</span> <span class="keywordtype">int</span> line_size,
<a name="l00834"></a>00834                                 <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; voisins,
<a name="l00835"></a>00835                                 <span class="keyword">const</span> <a class="code" href="classStatic__Int__Lists.html" title="Cette classe permet de stocker des listes d&#39;entiers accessibles en temps constant. La taille des listes ne peut pas changer sans perdre le contenu (ce sont des listes statiques). Exemple: Static_Int_List l; ArrOfInt tailles(3); tailles[0] = 2; tailles[1] = 3; tailles[2] = 0; // On reserve la memoire pour trois listes de taille 2, 3 et 0: l.set_list_sizes(tailles); // On affecte une valeur au deuxieme element de la premiere liste: l.set_value(0,1,765); // Affiche la valeur Cout &lt;&lt; l(0,1);.">Static_Int_Lists</a>&amp; list,
<a name="l00836"></a>00836                                 <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; vect,
<a name="l00837"></a>00837                                 <a class="code" href="classSchema__Comm__Vecteurs.html" title="Classe outil utilisee notamment par les methodes MD_Vector::echange_espace_virtuel() Permet d&#39;echange...">Schema_Comm_Vecteurs</a>&amp; buffers)
<a name="l00838"></a>00838 {
<a name="l00839"></a>00839   assert(line_size &gt; 0);
<a name="l00840"></a>00840   <span class="keywordtype">int</span> *data = vect.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
<a name="l00841"></a>00841   <span class="keyword">const</span> <span class="keywordtype">int</span> *items_to_process = list.<a class="code" href="classStatic__Int__Lists.html#ac72c923acdf74ba0d8fed055c494fc5b">get_data</a>().<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
<a name="l00842"></a>00842   <span class="keywordtype">int</span> idx = 0; <span class="comment">//!&lt; Index in list.get_data()</span>
<a name="l00843"></a>00843 <span class="comment"></span>  <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; index = list.<a class="code" href="classStatic__Int__Lists.html#a51352f7203aa95a858fdf7d198630352">get_index</a>();
<a name="l00844"></a>00844   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_voisins = list.<a class="code" href="classStatic__Int__Lists.html#a5872636466919b2cb8efe715c315d7ca" title="renvoie le nombre de listes stockees">get_nb_lists</a>();
<a name="l00845"></a>00845   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i_voisin = 0; i_voisin &lt; nb_voisins; i_voisin++)
<a name="l00846"></a>00846     {
<a name="l00847"></a>00847 <span class="comment">// Indice dans list.get_data() de la fin de la liste d&#39;items/blocs pour ce voisin:</span>
<a name="l00848"></a>00848       <span class="keyword">const</span> <span class="keywordtype">int</span> idx_end_of_list = index[i_voisin+1];
<a name="l00849"></a>00849 <span class="comment">// Nombre d&#39;elements de tableau a envoyer/recevoir de ce voisin</span>
<a name="l00850"></a>00850       <span class="keyword">const</span> <span class="keywordtype">int</span> nb_elems = (idx_end_of_list - idx) * line_size;
<a name="l00851"></a>00851       <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; buffer = buffers.<a class="code" href="classSchema__Comm__Vecteurs.html#ae31bd8f65b3b9ff75f5e8f12f94f5ebf" title="renvoie un tableau contenant les &quot;size&quot; valeurs suivantes recues du processeur pe lors de la commun...">get_next_area_int</a>(voisins[i_voisin], nb_elems);
<a name="l00852"></a>00852       <span class="keywordtype">int</span> * bufptr = buffer.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
<a name="l00853"></a>00853       assert(idx_end_of_list &lt;= list.<a class="code" href="classStatic__Int__Lists.html#ac72c923acdf74ba0d8fed055c494fc5b">get_data</a>().<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>());
<a name="l00854"></a>00854       <span class="keywordflow">while</span> (idx &lt; idx_end_of_list)
<a name="l00855"></a>00855         {
<a name="l00856"></a>00856 <span class="comment">// Indice de l&#39;item geometrique a copier (ou du premier item du bloc)</span>
<a name="l00857"></a>00857           <span class="keywordtype">int</span> premier_item_bloc = items_to_process[idx++];
<a name="l00858"></a>00858           <span class="keyword">const</span> <span class="keywordtype">int</span> bloc_size = 1;
<a name="l00859"></a>00859 <span class="comment">// Adresse des elements a copier dans le vecteur</span>
<a name="l00860"></a>00860           assert(premier_item_bloc &gt;= 0 &amp;&amp; bloc_size &gt; 0 &amp;&amp; (premier_item_bloc+bloc_size) * line_size &lt;= vect.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>());
<a name="l00861"></a>00861           <span class="keywordtype">int</span> *vectptr = data + premier_item_bloc * line_size;
<a name="l00862"></a>00862           <span class="keyword">const</span> <span class="keywordtype">int</span> n = line_size * bloc_size;
<a name="l00863"></a>00863           assert(bufptr + n - buffer.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() &lt;= buffer.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>());
<a name="l00864"></a>00864           <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; n; j++)
<a name="l00865"></a>00865             {
<a name="l00866"></a>00866               *(vectptr++) = *(bufptr++);
<a name="l00867"></a>00867             }
<a name="l00868"></a>00868         }
<a name="l00869"></a>00869     }
<a name="l00870"></a>00870 }
<a name="l00871"></a>00871 
<a name="l00872"></a>00872 
<a name="l00873"></a>00873 <span class="comment">// Methode generique pour traiter une liste d&#39;items ou de blocs, d&#39;ints ou de double</span>
<a name="l00874"></a>00874 <span class="comment">// a envoyer,recevoir ou ajouter.</span>
<a name="l00875"></a>00875 <span class="comment">// static inline void -&gt; inline void car sinon erreur sur AIX:</span>
<a name="l00876"></a>00876 <span class="comment">// Static declarations are not considered for a function call if the function is not qualified</span>
<a name="l00877"></a><a class="code" href="MD__Vector__std_8cpp.html#ab54618ac8d5e595356fd7ad038f6140e">00877</a> <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="MD__Vector__std_8cpp.html#a18734241182f029a4ac78fe0e7c5215c">add_to_vect_items</a>(<span class="keyword">const</span> <span class="keywordtype">int</span> line_size,
<a name="l00878"></a>00878                               <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; voisins,
<a name="l00879"></a>00879                               <span class="keyword">const</span> <a class="code" href="classStatic__Int__Lists.html" title="Cette classe permet de stocker des listes d&#39;entiers accessibles en temps constant. La taille des listes ne peut pas changer sans perdre le contenu (ce sont des listes statiques). Exemple: Static_Int_List l; ArrOfInt tailles(3); tailles[0] = 2; tailles[1] = 3; tailles[2] = 0; // On reserve la memoire pour trois listes de taille 2, 3 et 0: l.set_list_sizes(tailles); // On affecte une valeur au deuxieme element de la premiere liste: l.set_value(0,1,765); // Affiche la valeur Cout &lt;&lt; l(0,1);.">Static_Int_Lists</a>&amp; list,
<a name="l00880"></a>00880                               <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; vect,
<a name="l00881"></a>00881                               <a class="code" href="classSchema__Comm__Vecteurs.html" title="Classe outil utilisee notamment par les methodes MD_Vector::echange_espace_virtuel() Permet d&#39;echange...">Schema_Comm_Vecteurs</a>&amp; buffers)
<a name="l00882"></a>00882 {
<a name="l00883"></a>00883   assert(line_size &gt; 0);
<a name="l00884"></a>00884   <span class="keywordtype">int</span> *data = vect.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
<a name="l00885"></a>00885   <span class="keyword">const</span> <span class="keywordtype">int</span> *items_to_process = list.<a class="code" href="classStatic__Int__Lists.html#ac72c923acdf74ba0d8fed055c494fc5b">get_data</a>().<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
<a name="l00886"></a>00886   <span class="keywordtype">int</span> idx = 0; <span class="comment">//!&lt; Index in list.get_data()</span>
<a name="l00887"></a>00887 <span class="comment"></span>  <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; index = list.<a class="code" href="classStatic__Int__Lists.html#a51352f7203aa95a858fdf7d198630352">get_index</a>();
<a name="l00888"></a>00888   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_voisins = list.<a class="code" href="classStatic__Int__Lists.html#a5872636466919b2cb8efe715c315d7ca" title="renvoie le nombre de listes stockees">get_nb_lists</a>();
<a name="l00889"></a>00889   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i_voisin = 0; i_voisin &lt; nb_voisins; i_voisin++)
<a name="l00890"></a>00890     {
<a name="l00891"></a>00891 <span class="comment">// Indice dans list.get_data() de la fin de la liste d&#39;items/blocs pour ce voisin:</span>
<a name="l00892"></a>00892       <span class="keyword">const</span> <span class="keywordtype">int</span> idx_end_of_list = index[i_voisin+1];
<a name="l00893"></a>00893 <span class="comment">// Nombre d&#39;elements de tableau a envoyer/recevoir de ce voisin</span>
<a name="l00894"></a>00894       <span class="keyword">const</span> <span class="keywordtype">int</span> nb_elems = (idx_end_of_list - idx) * line_size;
<a name="l00895"></a>00895       <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; buffer = buffers.<a class="code" href="classSchema__Comm__Vecteurs.html#ae31bd8f65b3b9ff75f5e8f12f94f5ebf" title="renvoie un tableau contenant les &quot;size&quot; valeurs suivantes recues du processeur pe lors de la commun...">get_next_area_int</a>(voisins[i_voisin], nb_elems);
<a name="l00896"></a>00896       <span class="keywordtype">int</span> * bufptr = buffer.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
<a name="l00897"></a>00897       assert(idx_end_of_list &lt;= list.<a class="code" href="classStatic__Int__Lists.html#ac72c923acdf74ba0d8fed055c494fc5b">get_data</a>().<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>());
<a name="l00898"></a>00898       <span class="keywordflow">while</span> (idx &lt; idx_end_of_list)
<a name="l00899"></a>00899         {
<a name="l00900"></a>00900 <span class="comment">// Indice de l&#39;item geometrique a copier (ou du premier item du bloc)</span>
<a name="l00901"></a>00901           <span class="keywordtype">int</span> premier_item_bloc = items_to_process[idx++];
<a name="l00902"></a>00902           <span class="keyword">const</span> <span class="keywordtype">int</span> bloc_size = 1;
<a name="l00903"></a>00903 <span class="comment">// Adresse des elements a copier dans le vecteur</span>
<a name="l00904"></a>00904           assert(premier_item_bloc &gt;= 0 &amp;&amp; bloc_size &gt; 0 &amp;&amp; (premier_item_bloc+bloc_size) * line_size &lt;= vect.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>());
<a name="l00905"></a>00905           <span class="keywordtype">int</span> *vectptr = data + premier_item_bloc * line_size;
<a name="l00906"></a>00906           <span class="keyword">const</span> <span class="keywordtype">int</span> n = line_size * bloc_size;
<a name="l00907"></a>00907           assert(bufptr + n - buffer.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() &lt;= buffer.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>());
<a name="l00908"></a>00908           <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; n; j++)
<a name="l00909"></a>00909             {
<a name="l00910"></a>00910               *(vectptr++) += *(bufptr++);
<a name="l00911"></a>00911             }
<a name="l00912"></a>00912         }
<a name="l00913"></a>00913     }
<a name="l00914"></a>00914 }
<a name="l00915"></a>00915 
<a name="l00916"></a>00916 
<a name="l00917"></a>00917 <span class="comment">// Methode generique pour traiter une liste d&#39;items ou de blocs, d&#39;ints ou de double</span>
<a name="l00918"></a>00918 <span class="comment">// a envoyer,recevoir ou ajouter.</span>
<a name="l00919"></a>00919 <span class="comment">// static inline void -&gt; inline void car sinon erreur sur AIX:</span>
<a name="l00920"></a>00920 <span class="comment">// Static declarations are not considered for a function call if the function is not qualified</span>
<a name="l00921"></a><a class="code" href="MD__Vector__std_8cpp.html#aeb6e79d8e1e2abab309c3c58241bd164">00921</a> <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="MD__Vector__std_8cpp.html#a0288ab9d63ca627c55980a67dcf9a8da">max_to_vect_items</a>(<span class="keyword">const</span> <span class="keywordtype">int</span> line_size,
<a name="l00922"></a>00922                               <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; voisins,
<a name="l00923"></a>00923                               <span class="keyword">const</span> <a class="code" href="classStatic__Int__Lists.html" title="Cette classe permet de stocker des listes d&#39;entiers accessibles en temps constant. La taille des listes ne peut pas changer sans perdre le contenu (ce sont des listes statiques). Exemple: Static_Int_List l; ArrOfInt tailles(3); tailles[0] = 2; tailles[1] = 3; tailles[2] = 0; // On reserve la memoire pour trois listes de taille 2, 3 et 0: l.set_list_sizes(tailles); // On affecte une valeur au deuxieme element de la premiere liste: l.set_value(0,1,765); // Affiche la valeur Cout &lt;&lt; l(0,1);.">Static_Int_Lists</a>&amp; list,
<a name="l00924"></a>00924                               <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; vect,
<a name="l00925"></a>00925                               <a class="code" href="classSchema__Comm__Vecteurs.html" title="Classe outil utilisee notamment par les methodes MD_Vector::echange_espace_virtuel() Permet d&#39;echange...">Schema_Comm_Vecteurs</a>&amp; buffers)
<a name="l00926"></a>00926 {
<a name="l00927"></a>00927   assert(line_size &gt; 0);
<a name="l00928"></a>00928   <span class="keywordtype">int</span> *data = vect.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
<a name="l00929"></a>00929   <span class="keyword">const</span> <span class="keywordtype">int</span> *items_to_process = list.<a class="code" href="classStatic__Int__Lists.html#ac72c923acdf74ba0d8fed055c494fc5b">get_data</a>().<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
<a name="l00930"></a>00930   <span class="keywordtype">int</span> idx = 0; <span class="comment">//!&lt; Index in list.get_data()</span>
<a name="l00931"></a>00931 <span class="comment"></span>  <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; index = list.<a class="code" href="classStatic__Int__Lists.html#a51352f7203aa95a858fdf7d198630352">get_index</a>();
<a name="l00932"></a>00932   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_voisins = list.<a class="code" href="classStatic__Int__Lists.html#a5872636466919b2cb8efe715c315d7ca" title="renvoie le nombre de listes stockees">get_nb_lists</a>();
<a name="l00933"></a>00933   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i_voisin = 0; i_voisin &lt; nb_voisins; i_voisin++)
<a name="l00934"></a>00934     {
<a name="l00935"></a>00935 <span class="comment">// Indice dans list.get_data() de la fin de la liste d&#39;items/blocs pour ce voisin:</span>
<a name="l00936"></a>00936       <span class="keyword">const</span> <span class="keywordtype">int</span> idx_end_of_list = index[i_voisin+1];
<a name="l00937"></a>00937 <span class="comment">// Nombre d&#39;elements de tableau a envoyer/recevoir de ce voisin</span>
<a name="l00938"></a>00938       <span class="keyword">const</span> <span class="keywordtype">int</span> nb_elems = (idx_end_of_list - idx) * line_size;
<a name="l00939"></a>00939       <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; buffer = buffers.<a class="code" href="classSchema__Comm__Vecteurs.html#ae31bd8f65b3b9ff75f5e8f12f94f5ebf" title="renvoie un tableau contenant les &quot;size&quot; valeurs suivantes recues du processeur pe lors de la commun...">get_next_area_int</a>(voisins[i_voisin], nb_elems);
<a name="l00940"></a>00940       <span class="keywordtype">int</span> * bufptr = buffer.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
<a name="l00941"></a>00941       assert(idx_end_of_list &lt;= list.<a class="code" href="classStatic__Int__Lists.html#ac72c923acdf74ba0d8fed055c494fc5b">get_data</a>().<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>());
<a name="l00942"></a>00942       <span class="keywordflow">while</span> (idx &lt; idx_end_of_list)
<a name="l00943"></a>00943         {
<a name="l00944"></a>00944 <span class="comment">// Indice de l&#39;item geometrique a copier (ou du premier item du bloc)</span>
<a name="l00945"></a>00945           <span class="keywordtype">int</span> premier_item_bloc = items_to_process[idx++];
<a name="l00946"></a>00946           <span class="keyword">const</span> <span class="keywordtype">int</span> bloc_size = 1;
<a name="l00947"></a>00947 <span class="comment">// Adresse des elements a copier dans le vecteur</span>
<a name="l00948"></a>00948           assert(premier_item_bloc &gt;= 0 &amp;&amp; bloc_size &gt; 0 &amp;&amp; (premier_item_bloc+bloc_size) * line_size &lt;= vect.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>());
<a name="l00949"></a>00949           <span class="keywordtype">int</span> *vectptr = data + premier_item_bloc * line_size;
<a name="l00950"></a>00950           <span class="keyword">const</span> <span class="keywordtype">int</span> n = line_size * bloc_size;
<a name="l00951"></a>00951           assert(bufptr + n - buffer.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() &lt;= buffer.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>());
<a name="l00952"></a>00952           <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; n; j++)
<a name="l00953"></a>00953             {
<a name="l00954"></a>00954               <span class="keywordtype">int</span> dest = *vectptr;
<a name="l00955"></a>00955               <span class="keywordtype">int</span> src  = *(bufptr++);
<a name="l00956"></a>00956               *(vectptr++) = (dest &gt; src) ? dest : src;
<a name="l00957"></a>00957             }
<a name="l00958"></a>00958         }
<a name="l00959"></a>00959     }
<a name="l00960"></a>00960 }
<a name="l00961"></a>00961 
<a name="l00962"></a>00962 
<a name="l00963"></a>00963 <span class="comment">// Methode generique pour traiter une liste d&#39;items ou de blocs, d&#39;ints ou de double</span>
<a name="l00964"></a>00964 <span class="comment">// a envoyer,recevoir ou ajouter.</span>
<a name="l00965"></a>00965 <span class="comment">// static inline void -&gt; inline void car sinon erreur sur AIX:</span>
<a name="l00966"></a>00966 <span class="comment">// Static declarations are not considered for a function call if the function is not qualified</span>
<a name="l00967"></a><a class="code" href="MD__Vector__std_8cpp.html#a4c00e18db2e886d5456940fea1957cff">00967</a> <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="MD__Vector__std_8cpp.html#acc05df4426870bc5165ab6e635c5312c">mincol1_to_vect_items</a>(<span class="keyword">const</span> <span class="keywordtype">int</span> line_size,
<a name="l00968"></a>00968                                   <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; voisins,
<a name="l00969"></a>00969                                   <span class="keyword">const</span> <a class="code" href="classStatic__Int__Lists.html" title="Cette classe permet de stocker des listes d&#39;entiers accessibles en temps constant. La taille des listes ne peut pas changer sans perdre le contenu (ce sont des listes statiques). Exemple: Static_Int_List l; ArrOfInt tailles(3); tailles[0] = 2; tailles[1] = 3; tailles[2] = 0; // On reserve la memoire pour trois listes de taille 2, 3 et 0: l.set_list_sizes(tailles); // On affecte une valeur au deuxieme element de la premiere liste: l.set_value(0,1,765); // Affiche la valeur Cout &lt;&lt; l(0,1);.">Static_Int_Lists</a>&amp; list,
<a name="l00970"></a>00970                                   <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; vect,
<a name="l00971"></a>00971                                   <a class="code" href="classSchema__Comm__Vecteurs.html" title="Classe outil utilisee notamment par les methodes MD_Vector::echange_espace_virtuel() Permet d&#39;echange...">Schema_Comm_Vecteurs</a>&amp; buffers)
<a name="l00972"></a>00972 {
<a name="l00973"></a>00973   assert(line_size &gt; 0);
<a name="l00974"></a>00974   <span class="keywordtype">int</span> *data = vect.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
<a name="l00975"></a>00975   <span class="keyword">const</span> <span class="keywordtype">int</span> *items_to_process = list.<a class="code" href="classStatic__Int__Lists.html#ac72c923acdf74ba0d8fed055c494fc5b">get_data</a>().<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
<a name="l00976"></a>00976   <span class="keywordtype">int</span> idx = 0; <span class="comment">//!&lt; Index in list.get_data()</span>
<a name="l00977"></a>00977 <span class="comment"></span>  <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; index = list.<a class="code" href="classStatic__Int__Lists.html#a51352f7203aa95a858fdf7d198630352">get_index</a>();
<a name="l00978"></a>00978   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_voisins = list.<a class="code" href="classStatic__Int__Lists.html#a5872636466919b2cb8efe715c315d7ca" title="renvoie le nombre de listes stockees">get_nb_lists</a>();
<a name="l00979"></a>00979   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i_voisin = 0; i_voisin &lt; nb_voisins; i_voisin++)
<a name="l00980"></a>00980     {
<a name="l00981"></a>00981 <span class="comment">// Indice dans list.get_data() de la fin de la liste d&#39;items/blocs pour ce voisin:</span>
<a name="l00982"></a>00982       <span class="keyword">const</span> <span class="keywordtype">int</span> idx_end_of_list = index[i_voisin+1];
<a name="l00983"></a>00983 <span class="comment">// Nombre d&#39;elements de tableau a envoyer/recevoir de ce voisin</span>
<a name="l00984"></a>00984       <span class="keyword">const</span> <span class="keywordtype">int</span> nb_elems = (idx_end_of_list - idx) * line_size;
<a name="l00985"></a>00985       <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; buffer = buffers.<a class="code" href="classSchema__Comm__Vecteurs.html#ae31bd8f65b3b9ff75f5e8f12f94f5ebf" title="renvoie un tableau contenant les &quot;size&quot; valeurs suivantes recues du processeur pe lors de la commun...">get_next_area_int</a>(voisins[i_voisin], nb_elems);
<a name="l00986"></a>00986       <span class="keywordtype">int</span> * bufptr = buffer.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
<a name="l00987"></a>00987       assert(idx_end_of_list &lt;= list.<a class="code" href="classStatic__Int__Lists.html#ac72c923acdf74ba0d8fed055c494fc5b">get_data</a>().<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>());
<a name="l00988"></a>00988       <span class="keywordflow">while</span> (idx &lt; idx_end_of_list)
<a name="l00989"></a>00989         {
<a name="l00990"></a>00990 <span class="comment">// Indice de l&#39;item geometrique a copier (ou du premier item du bloc)</span>
<a name="l00991"></a>00991           <span class="keywordtype">int</span> premier_item_bloc = items_to_process[idx++];
<a name="l00992"></a>00992           <span class="keyword">const</span> <span class="keywordtype">int</span> bloc_size = 1;
<a name="l00993"></a>00993 <span class="comment">// Adresse des elements a copier dans le vecteur</span>
<a name="l00994"></a>00994           assert(premier_item_bloc &gt;= 0 &amp;&amp; bloc_size &gt; 0 &amp;&amp; (premier_item_bloc+bloc_size) * line_size &lt;= vect.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>());
<a name="l00995"></a>00995           <span class="keywordtype">int</span> *vectptr = data + premier_item_bloc * line_size;
<a name="l00996"></a>00996 <span class="comment">// Copy whole line if first line is greater than destination</span>
<a name="l00997"></a>00997           assert(bufptr + line_size * bloc_size - buffer.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() &lt;= buffer.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>());
<a name="l00998"></a>00998           <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; bloc_size; j++)
<a name="l00999"></a>00999             {
<a name="l01000"></a>01000               <span class="keywordtype">int</span> dest = *vectptr;
<a name="l01001"></a>01001               <span class="keywordtype">int</span> src  = *bufptr;
<a name="l01002"></a>01002               <span class="keywordflow">if</span> (src &lt; dest)
<a name="l01003"></a>01003                 {
<a name="l01004"></a>01004                   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k = line_size; k; k--)
<a name="l01005"></a>01005                     *(vectptr++) = *(bufptr++);
<a name="l01006"></a>01006                 }
<a name="l01007"></a>01007               <span class="keywordflow">else</span>
<a name="l01008"></a>01008                 {
<a name="l01009"></a>01009                   vectptr += line_size;
<a name="l01010"></a>01010                   bufptr += line_size;
<a name="l01011"></a>01011                 }
<a name="l01012"></a>01012             }
<a name="l01013"></a>01013         }
<a name="l01014"></a>01014     }
<a name="l01015"></a>01015 }
<a name="l01016"></a>01016 
<a name="l01017"></a>01017 
<a name="l01018"></a>01018 <span class="comment">// Methode generique pour traiter une liste d&#39;items ou de blocs, d&#39;ints ou de double</span>
<a name="l01019"></a>01019 <span class="comment">// a envoyer,recevoir ou ajouter.</span>
<a name="l01020"></a>01020 <span class="comment">// static inline void -&gt; inline void car sinon erreur sur AIX:</span>
<a name="l01021"></a>01021 <span class="comment">// Static declarations are not considered for a function call if the function is not qualified</span>
<a name="l01022"></a><a class="code" href="MD__Vector__std_8cpp.html#ab6fa83dd6ea808c3f9beda91a5c9a28e">01022</a> <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="MD__Vector__std_8cpp.html#a5a29fa9c3f9067e3d09fd936dac0d2f0">read_from_vect_blocs</a>(<span class="keyword">const</span> <span class="keywordtype">int</span> line_size,
<a name="l01023"></a>01023                                  <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; voisins,
<a name="l01024"></a>01024                                  <span class="keyword">const</span> <a class="code" href="classStatic__Int__Lists.html" title="Cette classe permet de stocker des listes d&#39;entiers accessibles en temps constant. La taille des listes ne peut pas changer sans perdre le contenu (ce sont des listes statiques). Exemple: Static_Int_List l; ArrOfInt tailles(3); tailles[0] = 2; tailles[1] = 3; tailles[2] = 0; // On reserve la memoire pour trois listes de taille 2, 3 et 0: l.set_list_sizes(tailles); // On affecte une valeur au deuxieme element de la premiere liste: l.set_value(0,1,765); // Affiche la valeur Cout &lt;&lt; l(0,1);.">Static_Int_Lists</a>&amp; list,
<a name="l01025"></a>01025                                  <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; nb_items_par_voisin,
<a name="l01026"></a>01026                                  <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; vect,
<a name="l01027"></a>01027                                  <a class="code" href="classSchema__Comm__Vecteurs.html" title="Classe outil utilisee notamment par les methodes MD_Vector::echange_espace_virtuel() Permet d&#39;echange...">Schema_Comm_Vecteurs</a>&amp; buffers)
<a name="l01028"></a>01028 {
<a name="l01029"></a>01029   assert(line_size &gt; 0);
<a name="l01030"></a>01030   <span class="keywordtype">int</span> *data = vect.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
<a name="l01031"></a>01031   <span class="keyword">const</span> <span class="keywordtype">int</span> *items_to_process = list.<a class="code" href="classStatic__Int__Lists.html#ac72c923acdf74ba0d8fed055c494fc5b">get_data</a>().<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
<a name="l01032"></a>01032   <span class="keywordtype">int</span> idx = 0; <span class="comment">//!&lt; Index in list.get_data()</span>
<a name="l01033"></a>01033 <span class="comment"></span>  <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; index = list.<a class="code" href="classStatic__Int__Lists.html#a51352f7203aa95a858fdf7d198630352">get_index</a>();
<a name="l01034"></a>01034   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_voisins = list.<a class="code" href="classStatic__Int__Lists.html#a5872636466919b2cb8efe715c315d7ca" title="renvoie le nombre de listes stockees">get_nb_lists</a>();
<a name="l01035"></a>01035   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i_voisin = 0; i_voisin &lt; nb_voisins; i_voisin++)
<a name="l01036"></a>01036     {
<a name="l01037"></a>01037 <span class="comment">// Indice dans list.get_data() de la fin de la liste d&#39;items/blocs pour ce voisin:</span>
<a name="l01038"></a>01038       <span class="keyword">const</span> <span class="keywordtype">int</span> idx_end_of_list = index[i_voisin+1];
<a name="l01039"></a>01039 <span class="comment">// Nombre d&#39;elements de tableau a envoyer/recevoir de ce voisin</span>
<a name="l01040"></a>01040       <span class="keyword">const</span> <span class="keywordtype">int</span> nb_elems = nb_items_par_voisin[i_voisin] * line_size;
<a name="l01041"></a>01041       <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; buffer = buffers.<a class="code" href="classSchema__Comm__Vecteurs.html#ae31bd8f65b3b9ff75f5e8f12f94f5ebf" title="renvoie un tableau contenant les &quot;size&quot; valeurs suivantes recues du processeur pe lors de la commun...">get_next_area_int</a>(voisins[i_voisin], nb_elems);
<a name="l01042"></a>01042       <span class="keywordtype">int</span> * bufptr = buffer.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
<a name="l01043"></a>01043       assert(idx_end_of_list &lt;= list.<a class="code" href="classStatic__Int__Lists.html#ac72c923acdf74ba0d8fed055c494fc5b">get_data</a>().<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>());
<a name="l01044"></a>01044       <span class="keywordflow">while</span> (idx &lt; idx_end_of_list)
<a name="l01045"></a>01045         {
<a name="l01046"></a>01046 <span class="comment">// Indice de l&#39;item geometrique a copier (ou du premier item du bloc)</span>
<a name="l01047"></a>01047           <span class="keywordtype">int</span> premier_item_bloc = items_to_process[idx++];
<a name="l01048"></a>01048 <span class="comment">// For blocs, the array contains begin_bloc, end_bloc, begin_bloc, end_bloc...</span>
<a name="l01049"></a>01049           <span class="keyword">const</span> <span class="keywordtype">int</span> dernier_item_bloc = items_to_process[idx++];
<a name="l01050"></a>01050           <span class="keyword">const</span> <span class="keywordtype">int</span> bloc_size = dernier_item_bloc - premier_item_bloc;
<a name="l01051"></a>01051 <span class="comment">// Adresse des elements a copier dans le vecteur</span>
<a name="l01052"></a>01052           assert(premier_item_bloc &gt;= 0 &amp;&amp; bloc_size &gt; 0 &amp;&amp; (premier_item_bloc+bloc_size) * line_size &lt;= vect.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>());
<a name="l01053"></a>01053           <span class="keywordtype">int</span> *vectptr = data + premier_item_bloc * line_size;
<a name="l01054"></a>01054           <span class="keyword">const</span> <span class="keywordtype">int</span> n = line_size * bloc_size;
<a name="l01055"></a>01055           assert(bufptr + n - buffer.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() &lt;= buffer.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>());
<a name="l01056"></a>01056           <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; n; j++)
<a name="l01057"></a>01057             {
<a name="l01058"></a>01058               *(bufptr++) = *(vectptr++);
<a name="l01059"></a>01059             }
<a name="l01060"></a>01060         }
<a name="l01061"></a>01061     }
<a name="l01062"></a>01062 }
<a name="l01063"></a>01063 
<a name="l01064"></a>01064 
<a name="l01065"></a>01065 <span class="comment">// Methode generique pour traiter une liste d&#39;items ou de blocs, d&#39;ints ou de double</span>
<a name="l01066"></a>01066 <span class="comment">// a envoyer,recevoir ou ajouter.</span>
<a name="l01067"></a>01067 <span class="comment">// static inline void -&gt; inline void car sinon erreur sur AIX:</span>
<a name="l01068"></a>01068 <span class="comment">// Static declarations are not considered for a function call if the function is not qualified</span>
<a name="l01069"></a><a class="code" href="MD__Vector__std_8cpp.html#ad696660c13588959c658f009754a9265">01069</a> <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="MD__Vector__std_8cpp.html#acbe04bcc0dbf2780408e9348dd5a9833">write_to_vect_blocs</a>(<span class="keyword">const</span> <span class="keywordtype">int</span> line_size,
<a name="l01070"></a>01070                                 <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; voisins,
<a name="l01071"></a>01071                                 <span class="keyword">const</span> <a class="code" href="classStatic__Int__Lists.html" title="Cette classe permet de stocker des listes d&#39;entiers accessibles en temps constant. La taille des listes ne peut pas changer sans perdre le contenu (ce sont des listes statiques). Exemple: Static_Int_List l; ArrOfInt tailles(3); tailles[0] = 2; tailles[1] = 3; tailles[2] = 0; // On reserve la memoire pour trois listes de taille 2, 3 et 0: l.set_list_sizes(tailles); // On affecte une valeur au deuxieme element de la premiere liste: l.set_value(0,1,765); // Affiche la valeur Cout &lt;&lt; l(0,1);.">Static_Int_Lists</a>&amp; list,
<a name="l01072"></a>01072                                 <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; nb_items_par_voisin,
<a name="l01073"></a>01073                                 <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; vect,
<a name="l01074"></a>01074                                 <a class="code" href="classSchema__Comm__Vecteurs.html" title="Classe outil utilisee notamment par les methodes MD_Vector::echange_espace_virtuel() Permet d&#39;echange...">Schema_Comm_Vecteurs</a>&amp; buffers)
<a name="l01075"></a>01075 {
<a name="l01076"></a>01076   assert(line_size &gt; 0);
<a name="l01077"></a>01077   <span class="keywordtype">int</span> *data = vect.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
<a name="l01078"></a>01078   <span class="keyword">const</span> <span class="keywordtype">int</span> *items_to_process = list.<a class="code" href="classStatic__Int__Lists.html#ac72c923acdf74ba0d8fed055c494fc5b">get_data</a>().<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
<a name="l01079"></a>01079   <span class="keywordtype">int</span> idx = 0; <span class="comment">//!&lt; Index in list.get_data()</span>
<a name="l01080"></a>01080 <span class="comment"></span>  <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; index = list.<a class="code" href="classStatic__Int__Lists.html#a51352f7203aa95a858fdf7d198630352">get_index</a>();
<a name="l01081"></a>01081   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_voisins = list.<a class="code" href="classStatic__Int__Lists.html#a5872636466919b2cb8efe715c315d7ca" title="renvoie le nombre de listes stockees">get_nb_lists</a>();
<a name="l01082"></a>01082   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i_voisin = 0; i_voisin &lt; nb_voisins; i_voisin++)
<a name="l01083"></a>01083     {
<a name="l01084"></a>01084 <span class="comment">// Indice dans list.get_data() de la fin de la liste d&#39;items/blocs pour ce voisin:</span>
<a name="l01085"></a>01085       <span class="keyword">const</span> <span class="keywordtype">int</span> idx_end_of_list = index[i_voisin+1];
<a name="l01086"></a>01086 <span class="comment">// Nombre d&#39;elements de tableau a envoyer/recevoir de ce voisin</span>
<a name="l01087"></a>01087       <span class="keyword">const</span> <span class="keywordtype">int</span> nb_elems = nb_items_par_voisin[i_voisin] * line_size;
<a name="l01088"></a>01088       <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; buffer = buffers.<a class="code" href="classSchema__Comm__Vecteurs.html#ae31bd8f65b3b9ff75f5e8f12f94f5ebf" title="renvoie un tableau contenant les &quot;size&quot; valeurs suivantes recues du processeur pe lors de la commun...">get_next_area_int</a>(voisins[i_voisin], nb_elems);
<a name="l01089"></a>01089       <span class="keywordtype">int</span> * bufptr = buffer.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
<a name="l01090"></a>01090       assert(idx_end_of_list &lt;= list.<a class="code" href="classStatic__Int__Lists.html#ac72c923acdf74ba0d8fed055c494fc5b">get_data</a>().<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>());
<a name="l01091"></a>01091       <span class="keywordflow">while</span> (idx &lt; idx_end_of_list)
<a name="l01092"></a>01092         {
<a name="l01093"></a>01093 <span class="comment">// Indice de l&#39;item geometrique a copier (ou du premier item du bloc)</span>
<a name="l01094"></a>01094           <span class="keywordtype">int</span> premier_item_bloc = items_to_process[idx++];
<a name="l01095"></a>01095 <span class="comment">// For blocs, the array contains begin_bloc, end_bloc, begin_bloc, end_bloc...</span>
<a name="l01096"></a>01096           <span class="keyword">const</span> <span class="keywordtype">int</span> dernier_item_bloc = items_to_process[idx++];
<a name="l01097"></a>01097           <span class="keyword">const</span> <span class="keywordtype">int</span> bloc_size = dernier_item_bloc - premier_item_bloc;
<a name="l01098"></a>01098 <span class="comment">// Adresse des elements a copier dans le vecteur</span>
<a name="l01099"></a>01099           assert(premier_item_bloc &gt;= 0 &amp;&amp; bloc_size &gt; 0 &amp;&amp; (premier_item_bloc+bloc_size) * line_size &lt;= vect.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>());
<a name="l01100"></a>01100           <span class="keywordtype">int</span> *vectptr = data + premier_item_bloc * line_size;
<a name="l01101"></a>01101           <span class="keyword">const</span> <span class="keywordtype">int</span> n = line_size * bloc_size;
<a name="l01102"></a>01102           assert(bufptr + n - buffer.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() &lt;= buffer.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>());
<a name="l01103"></a>01103           <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; n; j++)
<a name="l01104"></a>01104             {
<a name="l01105"></a>01105               *(vectptr++) = *(bufptr++);
<a name="l01106"></a>01106             }
<a name="l01107"></a>01107         }
<a name="l01108"></a>01108     }
<a name="l01109"></a>01109 }
<a name="l01110"></a>01110 
<a name="l01111"></a>01111 
<a name="l01112"></a>01112 <span class="comment">// Methode generique pour traiter une liste d&#39;items ou de blocs, d&#39;ints ou de double</span>
<a name="l01113"></a>01113 <span class="comment">// a envoyer,recevoir ou ajouter.</span>
<a name="l01114"></a>01114 <span class="comment">// static inline void -&gt; inline void car sinon erreur sur AIX:</span>
<a name="l01115"></a>01115 <span class="comment">// Static declarations are not considered for a function call if the function is not qualified</span>
<a name="l01116"></a><a class="code" href="MD__Vector__std_8cpp.html#a3351597c3ac95cf85801ae3917f33f52">01116</a> <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="MD__Vector__std_8cpp.html#a6b3040ad0a784f5bca7eddafffa60fca">add_to_vect_blocs</a>(<span class="keyword">const</span> <span class="keywordtype">int</span> line_size,
<a name="l01117"></a>01117                               <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; voisins,
<a name="l01118"></a>01118                               <span class="keyword">const</span> <a class="code" href="classStatic__Int__Lists.html" title="Cette classe permet de stocker des listes d&#39;entiers accessibles en temps constant. La taille des listes ne peut pas changer sans perdre le contenu (ce sont des listes statiques). Exemple: Static_Int_List l; ArrOfInt tailles(3); tailles[0] = 2; tailles[1] = 3; tailles[2] = 0; // On reserve la memoire pour trois listes de taille 2, 3 et 0: l.set_list_sizes(tailles); // On affecte une valeur au deuxieme element de la premiere liste: l.set_value(0,1,765); // Affiche la valeur Cout &lt;&lt; l(0,1);.">Static_Int_Lists</a>&amp; list,
<a name="l01119"></a>01119                               <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; nb_items_par_voisin,
<a name="l01120"></a>01120                               <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; vect,
<a name="l01121"></a>01121                               <a class="code" href="classSchema__Comm__Vecteurs.html" title="Classe outil utilisee notamment par les methodes MD_Vector::echange_espace_virtuel() Permet d&#39;echange...">Schema_Comm_Vecteurs</a>&amp; buffers)
<a name="l01122"></a>01122 {
<a name="l01123"></a>01123   assert(line_size &gt; 0);
<a name="l01124"></a>01124   <span class="keywordtype">int</span> *data = vect.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
<a name="l01125"></a>01125   <span class="keyword">const</span> <span class="keywordtype">int</span> *items_to_process = list.<a class="code" href="classStatic__Int__Lists.html#ac72c923acdf74ba0d8fed055c494fc5b">get_data</a>().<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
<a name="l01126"></a>01126   <span class="keywordtype">int</span> idx = 0; <span class="comment">//!&lt; Index in list.get_data()</span>
<a name="l01127"></a>01127 <span class="comment"></span>  <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; index = list.<a class="code" href="classStatic__Int__Lists.html#a51352f7203aa95a858fdf7d198630352">get_index</a>();
<a name="l01128"></a>01128   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_voisins = list.<a class="code" href="classStatic__Int__Lists.html#a5872636466919b2cb8efe715c315d7ca" title="renvoie le nombre de listes stockees">get_nb_lists</a>();
<a name="l01129"></a>01129   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i_voisin = 0; i_voisin &lt; nb_voisins; i_voisin++)
<a name="l01130"></a>01130     {
<a name="l01131"></a>01131 <span class="comment">// Indice dans list.get_data() de la fin de la liste d&#39;items/blocs pour ce voisin:</span>
<a name="l01132"></a>01132       <span class="keyword">const</span> <span class="keywordtype">int</span> idx_end_of_list = index[i_voisin+1];
<a name="l01133"></a>01133 <span class="comment">// Nombre d&#39;elements de tableau a envoyer/recevoir de ce voisin</span>
<a name="l01134"></a>01134       <span class="keyword">const</span> <span class="keywordtype">int</span> nb_elems = nb_items_par_voisin[i_voisin] * line_size;
<a name="l01135"></a>01135       <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; buffer = buffers.<a class="code" href="classSchema__Comm__Vecteurs.html#ae31bd8f65b3b9ff75f5e8f12f94f5ebf" title="renvoie un tableau contenant les &quot;size&quot; valeurs suivantes recues du processeur pe lors de la commun...">get_next_area_int</a>(voisins[i_voisin], nb_elems);
<a name="l01136"></a>01136       <span class="keywordtype">int</span> * bufptr = buffer.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
<a name="l01137"></a>01137       assert(idx_end_of_list &lt;= list.<a class="code" href="classStatic__Int__Lists.html#ac72c923acdf74ba0d8fed055c494fc5b">get_data</a>().<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>());
<a name="l01138"></a>01138       <span class="keywordflow">while</span> (idx &lt; idx_end_of_list)
<a name="l01139"></a>01139         {
<a name="l01140"></a>01140 <span class="comment">// Indice de l&#39;item geometrique a copier (ou du premier item du bloc)</span>
<a name="l01141"></a>01141           <span class="keywordtype">int</span> premier_item_bloc = items_to_process[idx++];
<a name="l01142"></a>01142 <span class="comment">// For blocs, the array contains begin_bloc, end_bloc, begin_bloc, end_bloc...</span>
<a name="l01143"></a>01143           <span class="keyword">const</span> <span class="keywordtype">int</span> dernier_item_bloc = items_to_process[idx++];
<a name="l01144"></a>01144           <span class="keyword">const</span> <span class="keywordtype">int</span> bloc_size = dernier_item_bloc - premier_item_bloc;
<a name="l01145"></a>01145 <span class="comment">// Adresse des elements a copier dans le vecteur</span>
<a name="l01146"></a>01146           assert(premier_item_bloc &gt;= 0 &amp;&amp; bloc_size &gt; 0 &amp;&amp; (premier_item_bloc+bloc_size) * line_size &lt;= vect.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>());
<a name="l01147"></a>01147           <span class="keywordtype">int</span> *vectptr = data + premier_item_bloc * line_size;
<a name="l01148"></a>01148           <span class="keyword">const</span> <span class="keywordtype">int</span> n = line_size * bloc_size;
<a name="l01149"></a>01149           assert(bufptr + n - buffer.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() &lt;= buffer.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>());
<a name="l01150"></a>01150           <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; n; j++)
<a name="l01151"></a>01151             {
<a name="l01152"></a>01152               *(vectptr++) += *(bufptr++);
<a name="l01153"></a>01153             }
<a name="l01154"></a>01154         }
<a name="l01155"></a>01155     }
<a name="l01156"></a>01156 }
<a name="l01157"></a>01157 
<a name="l01158"></a>01158 <span class="comment">//</span>
<a name="l01159"></a>01159 <span class="comment">//</span>
<a name="l01160"></a>01160 <span class="comment">//</span>
<a name="l01161"></a>01161 <span class="comment">//</span><span class="comment"></span>
<a name="l01162"></a>01162 <span class="comment">//! This is the first part of the echange_espace_virtuel() process.&lt;br&gt;We take the data that has to be sent to other processors in &quot;vect&quot; and put&lt;br&gt;it in appropriate send buffers in &quot;buffers&quot;. The data taken depends on &quot;opt&quot;.&lt;br&gt;Preconditon: The buffers must have been initialized to the appropriate size&lt;br&gt;and neighbour processors.</span>
<a name="l01163"></a><a class="code" href="classMD__Vector__std.html#a875d60acb01e81a220604b5e5d632536">01163</a> <span class="comment"></span><span class="keywordtype">void</span> <a class="code" href="classMD__Vector__std.html#ada966d7ecd5433dd05d7d7d4c97ee298" title="This is the first part of the echange_espace_virtuel() process. We take the data that has to be sent ...">MD_Vector_std::prepare_send_data</a>(<span class="keyword">const</span> <a class="code" href="classEchange__EV__Options.html">Echange_EV_Options</a>&amp; opt,
<a name="l01164"></a>01164                                       <a class="code" href="classSchema__Comm__Vecteurs.html" title="Classe outil utilisee notamment par les methodes MD_Vector::echange_espace_virtuel() Permet d&#39;echange...">Schema_Comm_Vecteurs</a>&amp; buffers,
<a name="l01165"></a>01165                                       <a class="code" href="classIntVect.html">IntVect</a>&amp; vect)<span class="keyword"> const</span>
<a name="l01166"></a>01166 <span class="keyword"></span>{
<a name="l01167"></a>01167   <span class="keyword">const</span> <span class="keywordtype">int</span> line_size = vect.<a class="code" href="classIntVect.html#a5ba680066169c8e057bb3e3b876e4a8c">line_size</a>();
<a name="l01168"></a>01168   <span class="keywordflow">switch</span>(opt.<a class="code" href="classEchange__EV__Options.html#aa3d975c4dc791256ebd217c6aa3f4b15">get_op</a>())
<a name="l01169"></a>01169     {
<a name="l01170"></a>01170     <span class="keywordflow">case</span> <a class="code" href="classEchange__EV__Options.html#ab91405f7667327d1f277b627ca1adc09a96cf69dc7e23b38d6f83854a4d881e9b">Echange_EV_Options::SYNC</a>:
<a name="l01171"></a>01171       <span class="keywordflow">if</span> ( line_size==1)
<a name="l01172"></a>01172         <a class="code" href="MD__Vector__std_8cpp.html#a10b62793ecb01cb8437cffbc92d2dd89">read_from_vect_items</a>(1, <a class="code" href="classMD__Vector__std.html#a68854e710075fdc8c2f2ce28fbbb9ecc">pe_voisins_</a>, <a class="code" href="classMD__Vector__std.html#a3ee9294b8d36492e8bdabbc9a97db451">items_to_send_</a>, vect, buffers);
<a name="l01173"></a>01173       <span class="keywordflow">else</span>
<a name="l01174"></a>01174         <a class="code" href="MD__Vector__std_8cpp.html#a10b62793ecb01cb8437cffbc92d2dd89">read_from_vect_items</a>( line_size, <a class="code" href="classMD__Vector__std.html#a68854e710075fdc8c2f2ce28fbbb9ecc">pe_voisins_</a>, <a class="code" href="classMD__Vector__std.html#a3ee9294b8d36492e8bdabbc9a97db451">items_to_send_</a>, vect, buffers);
<a name="l01175"></a>01175       <span class="keywordflow">break</span>;
<a name="l01176"></a>01176     <span class="keywordflow">case</span> <a class="code" href="classEchange__EV__Options.html#ab91405f7667327d1f277b627ca1adc09ac77c64f48af249bb37caf3ab34df6150">Echange_EV_Options::SUM</a>:
<a name="l01177"></a>01177     <span class="keywordflow">case</span> <a class="code" href="classEchange__EV__Options.html#ab91405f7667327d1f277b627ca1adc09a671e2b505a3a0afccaa8fa1d544d977e">Echange_EV_Options::MAX</a>:
<a name="l01178"></a>01178     <span class="keywordflow">case</span> <a class="code" href="classEchange__EV__Options.html#ab91405f7667327d1f277b627ca1adc09a2f06eeb16446aeefef2331a15aa91b67">Echange_EV_Options::MINCOL1</a>:
<a name="l01179"></a>01179       <span class="keywordflow">if</span> (<a class="code" href="classMD__Vector__std.html#a8d6c4c5d6da6fe56e8330253137d412f">items_to_recv_</a>.<a class="code" href="classStatic__Int__Lists.html#ac72c923acdf74ba0d8fed055c494fc5b">get_data</a>().<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() &gt; 0)
<a name="l01180"></a>01180         {
<a name="l01181"></a>01181           <span class="keywordflow">if</span> ( line_size==1)
<a name="l01182"></a>01182             <a class="code" href="MD__Vector__std_8cpp.html#a10b62793ecb01cb8437cffbc92d2dd89">read_from_vect_items</a>(1, <a class="code" href="classMD__Vector__std.html#a68854e710075fdc8c2f2ce28fbbb9ecc">pe_voisins_</a>, <a class="code" href="classMD__Vector__std.html#a8d6c4c5d6da6fe56e8330253137d412f">items_to_recv_</a>, vect, buffers);
<a name="l01183"></a>01183           <span class="keywordflow">else</span>
<a name="l01184"></a>01184             <a class="code" href="MD__Vector__std_8cpp.html#a10b62793ecb01cb8437cffbc92d2dd89">read_from_vect_items</a>( line_size, <a class="code" href="classMD__Vector__std.html#a68854e710075fdc8c2f2ce28fbbb9ecc">pe_voisins_</a>, <a class="code" href="classMD__Vector__std.html#a8d6c4c5d6da6fe56e8330253137d412f">items_to_recv_</a>, vect, buffers);
<a name="l01185"></a>01185         }
<a name="l01186"></a>01186       <span class="keywordflow">if</span> (<a class="code" href="classMD__Vector__std.html#ae266bd552dcb9f817c791a1c7342a6b0">blocs_to_recv_</a>.<a class="code" href="classStatic__Int__Lists.html#ac72c923acdf74ba0d8fed055c494fc5b">get_data</a>().<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() &gt; 0)
<a name="l01187"></a>01187         {
<a name="l01188"></a>01188           <span class="keywordflow">if</span> ( line_size==1)
<a name="l01189"></a>01189             <a class="code" href="MD__Vector__std_8cpp.html#a5a29fa9c3f9067e3d09fd936dac0d2f0">read_from_vect_blocs</a>(1, <a class="code" href="classMD__Vector__std.html#a68854e710075fdc8c2f2ce28fbbb9ecc">pe_voisins_</a>, <a class="code" href="classMD__Vector__std.html#ae266bd552dcb9f817c791a1c7342a6b0">blocs_to_recv_</a>, <a class="code" href="classMD__Vector__std.html#a4aa5e80e0b975026cc201fbdee72956c">blocs_items_count_</a>, vect, buffers);
<a name="l01190"></a>01190           <span class="keywordflow">else</span>
<a name="l01191"></a>01191             <a class="code" href="MD__Vector__std_8cpp.html#a5a29fa9c3f9067e3d09fd936dac0d2f0">read_from_vect_blocs</a>( line_size, <a class="code" href="classMD__Vector__std.html#a68854e710075fdc8c2f2ce28fbbb9ecc">pe_voisins_</a>, <a class="code" href="classMD__Vector__std.html#ae266bd552dcb9f817c791a1c7342a6b0">blocs_to_recv_</a>, <a class="code" href="classMD__Vector__std.html#a4aa5e80e0b975026cc201fbdee72956c">blocs_items_count_</a>, vect, buffers);
<a name="l01192"></a>01192         }
<a name="l01193"></a>01193       <span class="keywordflow">break</span>;
<a name="l01194"></a>01194     <span class="keywordflow">default</span>:
<a name="l01195"></a>01195       <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Error in MD_Vector_std.cpp prepare send data: operation not implemented&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
<a name="l01196"></a>01196       <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">Process::exit</a>();
<a name="l01197"></a>01197     }
<a name="l01198"></a>01198 }
<a name="l01199"></a>01199 
<a name="l01200"></a><a class="code" href="classMD__Vector__std.html#a819c9d9d8c17db8b3f073c0dcf2b1e96">01200</a> <span class="keywordtype">void</span> <a class="code" href="classMD__Vector__std.html#aac76e0b9c999dde47168e2a1060508d1">MD_Vector_std::process_recv_data</a>(<span class="keyword">const</span> <a class="code" href="classEchange__EV__Options.html">Echange_EV_Options</a>&amp; opt,
<a name="l01201"></a>01201                                       <a class="code" href="classSchema__Comm__Vecteurs.html" title="Classe outil utilisee notamment par les methodes MD_Vector::echange_espace_virtuel() Permet d&#39;echange...">Schema_Comm_Vecteurs</a>&amp; buffers,
<a name="l01202"></a>01202                                       <a class="code" href="classIntVect.html">IntVect</a>&amp; vect)<span class="keyword"> const</span>
<a name="l01203"></a>01203 <span class="keyword"></span>{
<a name="l01204"></a>01204   <span class="keyword">const</span> <span class="keywordtype">int</span> line_size = vect.<a class="code" href="classIntVect.html#a5ba680066169c8e057bb3e3b876e4a8c">line_size</a>();
<a name="l01205"></a>01205   <span class="keywordflow">switch</span>(opt.<a class="code" href="classEchange__EV__Options.html#aa3d975c4dc791256ebd217c6aa3f4b15">get_op</a>())
<a name="l01206"></a>01206     {
<a name="l01207"></a>01207     <span class="keywordflow">case</span> <a class="code" href="classEchange__EV__Options.html#ab91405f7667327d1f277b627ca1adc09a96cf69dc7e23b38d6f83854a4d881e9b">Echange_EV_Options::SYNC</a>:
<a name="l01208"></a>01208       <span class="keywordflow">if</span> (<a class="code" href="classMD__Vector__std.html#a8d6c4c5d6da6fe56e8330253137d412f">items_to_recv_</a>.<a class="code" href="classStatic__Int__Lists.html#ac72c923acdf74ba0d8fed055c494fc5b">get_data</a>().<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() &gt; 0)
<a name="l01209"></a>01209         {
<a name="l01210"></a>01210           <span class="keywordflow">if</span> ( line_size==1)
<a name="l01211"></a>01211             <a class="code" href="MD__Vector__std_8cpp.html#af1a3457cd2fc6fc193441c0e6dd3be74">write_to_vect_items</a>(1, <a class="code" href="classMD__Vector__std.html#a68854e710075fdc8c2f2ce28fbbb9ecc">pe_voisins_</a>, <a class="code" href="classMD__Vector__std.html#a8d6c4c5d6da6fe56e8330253137d412f">items_to_recv_</a>, vect, buffers);
<a name="l01212"></a>01212           <span class="keywordflow">else</span>
<a name="l01213"></a>01213             <a class="code" href="MD__Vector__std_8cpp.html#af1a3457cd2fc6fc193441c0e6dd3be74">write_to_vect_items</a>( line_size, <a class="code" href="classMD__Vector__std.html#a68854e710075fdc8c2f2ce28fbbb9ecc">pe_voisins_</a>, <a class="code" href="classMD__Vector__std.html#a8d6c4c5d6da6fe56e8330253137d412f">items_to_recv_</a>, vect, buffers);
<a name="l01214"></a>01214         }
<a name="l01215"></a>01215       <span class="keywordflow">if</span> (<a class="code" href="classMD__Vector__std.html#ae266bd552dcb9f817c791a1c7342a6b0">blocs_to_recv_</a>.<a class="code" href="classStatic__Int__Lists.html#ac72c923acdf74ba0d8fed055c494fc5b">get_data</a>().<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() &gt; 0)
<a name="l01216"></a>01216         {
<a name="l01217"></a>01217           <span class="keywordflow">if</span> ( line_size==1)
<a name="l01218"></a>01218             <a class="code" href="MD__Vector__std_8cpp.html#acbe04bcc0dbf2780408e9348dd5a9833">write_to_vect_blocs</a>(1, <a class="code" href="classMD__Vector__std.html#a68854e710075fdc8c2f2ce28fbbb9ecc">pe_voisins_</a>, <a class="code" href="classMD__Vector__std.html#ae266bd552dcb9f817c791a1c7342a6b0">blocs_to_recv_</a>, <a class="code" href="classMD__Vector__std.html#a4aa5e80e0b975026cc201fbdee72956c">blocs_items_count_</a>, vect, buffers);
<a name="l01219"></a>01219           <span class="keywordflow">else</span>
<a name="l01220"></a>01220             <a class="code" href="MD__Vector__std_8cpp.html#acbe04bcc0dbf2780408e9348dd5a9833">write_to_vect_blocs</a>( line_size, <a class="code" href="classMD__Vector__std.html#a68854e710075fdc8c2f2ce28fbbb9ecc">pe_voisins_</a>, <a class="code" href="classMD__Vector__std.html#ae266bd552dcb9f817c791a1c7342a6b0">blocs_to_recv_</a>, <a class="code" href="classMD__Vector__std.html#a4aa5e80e0b975026cc201fbdee72956c">blocs_items_count_</a>, vect, buffers);
<a name="l01221"></a>01221         }
<a name="l01222"></a>01222       <span class="keywordflow">break</span>;
<a name="l01223"></a>01223     <span class="keywordflow">case</span> <a class="code" href="classEchange__EV__Options.html#ab91405f7667327d1f277b627ca1adc09ac77c64f48af249bb37caf3ab34df6150">Echange_EV_Options::SUM</a>:
<a name="l01224"></a>01224 <span class="comment">// Reverse operation: write data to &quot;real&quot; items</span>
<a name="l01225"></a>01225       <span class="keywordflow">if</span> ( line_size==1)
<a name="l01226"></a>01226         <a class="code" href="MD__Vector__std_8cpp.html#a18734241182f029a4ac78fe0e7c5215c">add_to_vect_items</a>(1, <a class="code" href="classMD__Vector__std.html#a68854e710075fdc8c2f2ce28fbbb9ecc">pe_voisins_</a>, <a class="code" href="classMD__Vector__std.html#a3ee9294b8d36492e8bdabbc9a97db451">items_to_send_</a>, vect, buffers);
<a name="l01227"></a>01227       <span class="keywordflow">else</span>
<a name="l01228"></a>01228         <a class="code" href="MD__Vector__std_8cpp.html#a18734241182f029a4ac78fe0e7c5215c">add_to_vect_items</a>( line_size, <a class="code" href="classMD__Vector__std.html#a68854e710075fdc8c2f2ce28fbbb9ecc">pe_voisins_</a>, <a class="code" href="classMD__Vector__std.html#a3ee9294b8d36492e8bdabbc9a97db451">items_to_send_</a>, vect, buffers);
<a name="l01229"></a>01229       <span class="keywordflow">break</span>;
<a name="l01230"></a>01230     <span class="keywordflow">case</span> <a class="code" href="classEchange__EV__Options.html#ab91405f7667327d1f277b627ca1adc09a671e2b505a3a0afccaa8fa1d544d977e">Echange_EV_Options::MAX</a>:
<a name="l01231"></a>01231       <span class="keywordflow">if</span> ( line_size==1)
<a name="l01232"></a>01232         <a class="code" href="MD__Vector__std_8cpp.html#a0288ab9d63ca627c55980a67dcf9a8da">max_to_vect_items</a>(1, <a class="code" href="classMD__Vector__std.html#a68854e710075fdc8c2f2ce28fbbb9ecc">pe_voisins_</a>, <a class="code" href="classMD__Vector__std.html#a3ee9294b8d36492e8bdabbc9a97db451">items_to_send_</a>, vect, buffers);
<a name="l01233"></a>01233       <span class="keywordflow">else</span>
<a name="l01234"></a>01234         <a class="code" href="MD__Vector__std_8cpp.html#a0288ab9d63ca627c55980a67dcf9a8da">max_to_vect_items</a>( line_size, <a class="code" href="classMD__Vector__std.html#a68854e710075fdc8c2f2ce28fbbb9ecc">pe_voisins_</a>, <a class="code" href="classMD__Vector__std.html#a3ee9294b8d36492e8bdabbc9a97db451">items_to_send_</a>, vect, buffers);
<a name="l01235"></a>01235       <span class="keywordflow">break</span>;
<a name="l01236"></a>01236     <span class="keywordflow">case</span> <a class="code" href="classEchange__EV__Options.html#ab91405f7667327d1f277b627ca1adc09a2f06eeb16446aeefef2331a15aa91b67">Echange_EV_Options::MINCOL1</a>:
<a name="l01237"></a>01237       <span class="keywordflow">if</span> ( line_size==1)
<a name="l01238"></a>01238         <a class="code" href="MD__Vector__std_8cpp.html#acc05df4426870bc5165ab6e635c5312c">mincol1_to_vect_items</a>(1, <a class="code" href="classMD__Vector__std.html#a68854e710075fdc8c2f2ce28fbbb9ecc">pe_voisins_</a>, <a class="code" href="classMD__Vector__std.html#a3ee9294b8d36492e8bdabbc9a97db451">items_to_send_</a>, vect, buffers);
<a name="l01239"></a>01239       <span class="keywordflow">else</span>
<a name="l01240"></a>01240         <a class="code" href="MD__Vector__std_8cpp.html#acc05df4426870bc5165ab6e635c5312c">mincol1_to_vect_items</a>( line_size, <a class="code" href="classMD__Vector__std.html#a68854e710075fdc8c2f2ce28fbbb9ecc">pe_voisins_</a>, <a class="code" href="classMD__Vector__std.html#a3ee9294b8d36492e8bdabbc9a97db451">items_to_send_</a>, vect, buffers);
<a name="l01241"></a>01241       <span class="keywordflow">break</span>;
<a name="l01242"></a>01242     <span class="keywordflow">default</span>:
<a name="l01243"></a>01243       <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Error in MD_Vector_std.cpp process recv data: operation not implemented&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
<a name="l01244"></a>01244       <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">Process::exit</a>();
<a name="l01245"></a>01245     }
<a name="l01246"></a>01246 }
<a name="l01247"></a>01247 
<a name="l01248"></a>01248 
<a name="l01249"></a>01249 
<a name="l01250"></a>01250 
<a name="l01251"></a>01251 
</pre></div></div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Tue Dec 14 2021 19:35:23 for TRUST by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
