<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>TRUST: src/Kernel/Math/SolvSys/Solv_GCP.cpp Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">TRUST&#160;<span id="projectnumber">1.8.4</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
<div class="header">
  <div class="headertitle">
<div class="title">src/Kernel/Math/SolvSys/Solv_GCP.cpp</div>  </div>
</div>
<div class="contents">
<a href="Solv__GCP_8cpp.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/****************************************************************************</span>
<a name="l00002"></a>00002 <span class="comment">* Copyright (c) 2015 - 2016, CEA</span>
<a name="l00003"></a>00003 <span class="comment">* All rights reserved.</span>
<a name="l00004"></a>00004 <span class="comment">*</span>
<a name="l00005"></a>00005 <span class="comment">* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</span>
<a name="l00006"></a>00006 <span class="comment">* 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.</span>
<a name="l00007"></a>00007 <span class="comment">* 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.</span>
<a name="l00008"></a>00008 <span class="comment">* 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.</span>
<a name="l00009"></a>00009 <span class="comment">*</span>
<a name="l00010"></a>00010 <span class="comment">* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.</span>
<a name="l00011"></a>00011 <span class="comment">* IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;</span>
<a name="l00012"></a>00012 <span class="comment">* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>
<a name="l00013"></a>00013 <span class="comment">*</span>
<a name="l00014"></a>00014 <span class="comment">*****************************************************************************/</span>
<a name="l00015"></a>00015 <span class="comment">//</span>
<a name="l00016"></a>00016 <span class="comment">// </span>
<a name="l00017"></a>00017 <span class="comment">// File:        Solv_GCP.cpp</span>
<a name="l00018"></a>00018 <span class="comment">// Directory:   $TRUST_ROOT/src/Kernel/Math/SolvSys</span>
<a name="l00019"></a>00019 <span class="comment">// Version:     /main/54</span>
<a name="l00020"></a>00020 <span class="comment">// </span>
<a name="l00021"></a>00021 <span class="comment">//</span>
<a name="l00022"></a>00022 
<a name="l00023"></a>00023 <span class="preprocessor">#include &lt;<a class="code" href="Solv__GCP_8h.html">Solv_GCP.h</a>&gt;</span>
<a name="l00024"></a>00024 <span class="preprocessor">#include &lt;<a class="code" href="SSOR_8h.html">SSOR.h</a>&gt;</span>
<a name="l00025"></a>00025 <span class="preprocessor">#include &lt;<a class="code" href="Param_8h.html">Param.h</a>&gt;</span>
<a name="l00026"></a>00026 <span class="preprocessor">#include &lt;<a class="code" href="Matrice__Bloc__Sym_8h.html">Matrice_Bloc_Sym.h</a>&gt;</span>
<a name="l00027"></a>00027 <span class="preprocessor">#include &lt;<a class="code" href="Sparskit_8h.html">Sparskit.h</a>&gt;</span>
<a name="l00028"></a>00028 <span class="preprocessor">#include &lt;<a class="code" href="Check__espace__virtuel_8h.html">Check_espace_virtuel.h</a>&gt;</span>
<a name="l00029"></a>00029 <span class="preprocessor">#include &lt;<a class="code" href="MD__Vector__base_8h.html">MD_Vector_base.h</a>&gt;</span>
<a name="l00030"></a>00030 <span class="preprocessor">#include &lt;<a class="code" href="MD__Vector__tools_8h.html">MD_Vector_tools.h</a>&gt;</span>
<a name="l00031"></a>00031 <span class="preprocessor">#include &lt;<a class="code" href="communications_8h.html">communications.h</a>&gt;</span>
<a name="l00032"></a>00032 <span class="preprocessor">#include &lt;<a class="code" href="ConstDoubleTab__parts_8h.html">ConstDoubleTab_parts.h</a>&gt;</span>
<a name="l00033"></a>00033 
<a name="l00034"></a><a class="code" href="Solv__GCP_8cpp.html#a8db9005bd2d648fcd69b44411cda39ae">00034</a> <a class="code" href="Declare__Inst_8h.html#afcab3f7633508e92f2077d767e19bc60">Implemente_instanciable_sans_constructeur</a>(<a class="code" href="classSolv__GCP.html">Solv_GCP</a>,<span class="stringliteral">&quot;Solv_GCP&quot;</span>,<a class="code" href="classsolv__iteratif.html">solv_iteratif</a>);
<a name="l00035"></a>00035 <span class="comment">// </span>
<a name="l00036"></a>00036 <span class="comment">// printOn et readOn</span>
<a name="l00037"></a>00037 
<a name="l00038"></a><a class="code" href="classSolv__GCP.html#ac2abbec713f0320129df64a8fddc5826">00038</a> <a class="code" href="classSolv__GCP.html#ac2abbec713f0320129df64a8fddc5826">Solv_GCP::Solv_GCP</a>()
<a name="l00039"></a>00039 {
<a name="l00040"></a>00040   <a class="code" href="classsolv__iteratif.html#a726974e9a0579e0c242606430dc320d4">seuil_</a>=1.e-12;
<a name="l00041"></a>00041   <a class="code" href="classSolv__GCP.html#aba192c7ac366b8c30b0eecd8629af793" title="0=&gt; rien n&#39;est pret 1=&gt; memoire allouee, coeffs matrice a copier, 2=&gt; ok">reinit_</a> = 0;
<a name="l00042"></a>00042   <a class="code" href="classSolv__GCP.html#aebbaeaa67bf2f876d354938b76e7c36a">precond_diag_</a> = 0;
<a name="l00043"></a>00043   <a class="code" href="classSolv__GCP.html#a2de0798151556049240ddceaedcd2010">optimized_</a> = 0;
<a name="l00044"></a>00044   <a class="code" href="classSolv__GCP.html#a468e7aef13e89875aa96874a3cc3e0f7">nb_it_max_</a>=-1;
<a name="l00045"></a>00045 }
<a name="l00046"></a>00046 
<a name="l00047"></a><a class="code" href="classSolv__GCP.html#a07f4bbd4ed0ae392abf49e66b9dfcae6">00047</a> <a class="code" href="classSortie.html" title="Classe de base des flux de sortie. Elle sait ecrire des types simples&lt;br&gt;(entiers, flottants) et des Ob...">Sortie</a>&amp; <a class="code" href="classSolv__GCP.html#a07f4bbd4ed0ae392abf49e66b9dfcae6" title="Ecriture de l&#39;objet sur un flot de sortie Methode a surcharger.">Solv_GCP::printOn</a>(<a class="code" href="classSortie.html" title="Classe de base des flux de sortie. Elle sait ecrire des types simples&lt;br&gt;(entiers, flottants) et des Ob...">Sortie</a>&amp; s )<span class="keyword"> const</span>
<a name="l00048"></a>00048 <span class="keyword"></span>{
<a name="l00049"></a>00049   s&lt;&lt;<span class="stringliteral">&quot; { seuil &quot;</span> &lt;&lt; <a class="code" href="classsolv__iteratif.html#a726974e9a0579e0c242606430dc320d4">seuil_</a> ;
<a name="l00050"></a>00050   <span class="keywordflow">if</span> (<a class="code" href="classSolv__GCP.html#aa9aa7485970ae948b2561b89e141af13">le_precond_</a>.<a class="code" href="classO__U__Ptr.html#a16f216b2d169e885876419182658ddcc" title="Renvoie 1 si le pointeur est non_nul Renvoie 0 sinon.">non_nul</a>())
<a name="l00051"></a>00051     s&lt;&lt;<span class="stringliteral">&quot; precond &quot;</span> &lt;&lt;<a class="code" href="classSolv__GCP.html#aa9aa7485970ae948b2561b89e141af13">le_precond_</a>;
<a name="l00052"></a>00052   <span class="keywordflow">else</span>
<a name="l00053"></a>00053     s&lt;&lt;<span class="stringliteral">&quot; precond_nul &quot;</span>;
<a name="l00054"></a>00054   <span class="keywordflow">if</span> (<a class="code" href="classSolveurSys__base.html#ab3ef68bcf4e1b402c52905aa78728aef">limpr</a>()==1) s&lt;&lt;<span class="stringliteral">&quot; impr &quot;</span>;
<a name="l00055"></a>00055   <span class="keywordflow">if</span> (<a class="code" href="classSolveurSys__base.html#ab3ef68bcf4e1b402c52905aa78728aef">limpr</a>()==-1) s&lt;&lt;<span class="stringliteral">&quot; quiet &quot;</span>;
<a name="l00056"></a>00056   <span class="keywordflow">if</span> (<a class="code" href="classSolveurSys__base.html#a824322fe6a2c03aa986b8152aefcf14b" title="Drapeau pour savoir si un stockage disque est a refaire.">save_matrice_</a>) s&lt;&lt;<span class="stringliteral">&quot; save_matrice &quot;</span>;
<a name="l00057"></a>00057   <span class="keywordflow">if</span> (<a class="code" href="classSolv__GCP.html#a468e7aef13e89875aa96874a3cc3e0f7">nb_it_max_</a>!=-1) s&lt;&lt;<span class="stringliteral">&quot; nb_it_max &quot;</span>&lt;&lt;<a class="code" href="classSolv__GCP.html#a468e7aef13e89875aa96874a3cc3e0f7">nb_it_max_</a>;
<a name="l00058"></a>00058 
<a name="l00059"></a>00059   s&lt;&lt;<span class="stringliteral">&quot; } &quot;</span>;
<a name="l00060"></a>00060   <span class="keywordflow">return</span> s ;
<a name="l00061"></a>00061 }
<a name="l00062"></a>00062 
<a name="l00063"></a><a class="code" href="classSolv__GCP.html#a03d07e57b46d32e119e23b402d343454">00063</a> <a class="code" href="classEntree.html" title="Classe de definition des operateurs et methodes pour toute lecture dans un flot d&#39;entree (fichier...">Entree</a>&amp; <a class="code" href="classSolv__GCP.html#a03d07e57b46d32e119e23b402d343454" title="Lecture d&#39;un Objet_U sur un flot d&#39;entree Methode a surcharger.">Solv_GCP::readOn</a>(<a class="code" href="classEntree.html" title="Classe de definition des operateurs et methodes pour toute lecture dans un flot d&#39;entree (fichier...">Entree</a>&amp; is )
<a name="l00064"></a>00064 {
<a name="l00065"></a>00065   <span class="keywordtype">int</span> precond_nul;
<a name="l00066"></a>00066   <span class="keywordtype">int</span> impr,quiet;
<a name="l00067"></a>00067   <a class="code" href="classParam.html" title="Defined below in this file.">Param</a> param((*this).que_suis_je());
<a name="l00068"></a>00068   param.<a class="code" href="classParam.html#affb8a0102361201ba896bac7ca8bc21c">ajouter</a>(<span class="stringliteral">&quot;seuil&quot;</span>,&amp;<a class="code" href="classsolv__iteratif.html#a726974e9a0579e0c242606430dc320d4">seuil_</a>,<a class="code" href="classParam.html#aa4ad0ca1d49bc5f2ebc5fc83ee9df384aaf5b6dfac1c5970478525407cc6ac572">Param::REQUIRED</a>);
<a name="l00069"></a>00069   param.ajouter(<span class="stringliteral">&quot;nb_it_max&quot;</span>,&amp;<a class="code" href="classSolv__GCP.html#a468e7aef13e89875aa96874a3cc3e0f7">nb_it_max_</a>);
<a name="l00070"></a>00070   param.ajouter_flag(<span class="stringliteral">&quot;impr&quot;</span>,&amp;impr);
<a name="l00071"></a>00071   param.ajouter_flag(<span class="stringliteral">&quot;quiet&quot;</span>,&amp;quiet);
<a name="l00072"></a>00072   param.ajouter_flag(<span class="stringliteral">&quot;save_matrice|save_matrix&quot;</span>,&amp;<a class="code" href="classSolveurSys__base.html#a824322fe6a2c03aa986b8152aefcf14b" title="Drapeau pour savoir si un stockage disque est a refaire.">save_matrice_</a>);
<a name="l00073"></a>00073   param.ajouter(<span class="stringliteral">&quot;precond&quot;</span>,&amp;<a class="code" href="classSolv__GCP.html#aa9aa7485970ae948b2561b89e141af13">le_precond_</a>);
<a name="l00074"></a>00074   param.ajouter_flag(<span class="stringliteral">&quot;precond_nul&quot;</span>,&amp;precond_nul);
<a name="l00075"></a>00075   param.ajouter_flag(<span class="stringliteral">&quot;precond_diagonal&quot;</span>, &amp;<a class="code" href="classSolv__GCP.html#aebbaeaa67bf2f876d354938b76e7c36a">precond_diag_</a>);
<a name="l00076"></a>00076   param.ajouter_flag(<span class="stringliteral">&quot;optimized&quot;</span>, &amp;<a class="code" href="classSolv__GCP.html#a2de0798151556049240ddceaedcd2010">optimized_</a>);
<a name="l00077"></a>00077   param.lire_avec_accolades_depuis(is);
<a name="l00078"></a>00078 <span class="comment">// Obligation de definir un precond</span>
<a name="l00079"></a>00079   <span class="keywordflow">if</span> (!<a class="code" href="classSolv__GCP.html#aa9aa7485970ae948b2561b89e141af13">le_precond_</a>.<a class="code" href="classO__U__Ptr.html#a16f216b2d169e885876419182658ddcc" title="Renvoie 1 si le pointeur est non_nul Renvoie 0 sinon.">non_nul</a>() &amp;&amp; precond_nul==0 &amp;&amp; <a class="code" href="classSolv__GCP.html#aebbaeaa67bf2f876d354938b76e7c36a">precond_diag_</a>==0)
<a name="l00080"></a>00080     {
<a name="l00081"></a>00081       <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;You forgot to define a preconditionner with the keyword precond.&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
<a name="l00082"></a>00082       <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;If you don&#39;t want a preconditionner, add for the solver definition:&quot;</span> &lt;&lt; finl;
<a name="l00083"></a>00083       <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;precond_nul&quot;</span> &lt;&lt; finl;
<a name="l00084"></a>00084       <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">Process::exit</a>();
<a name="l00085"></a>00085     }
<a name="l00086"></a>00086   <span class="keywordflow">if</span> (precond_nul)
<a name="l00087"></a>00087     {
<a name="l00088"></a>00088       <a class="code" href="classSolv__GCP.html#aa9aa7485970ae948b2561b89e141af13">le_precond_</a>.<a class="code" href="classDeriv__.html#a1792f7b005c558e7412661aeee781bd2">detach</a>();
<a name="l00089"></a>00089     }
<a name="l00090"></a>00090   assert(<a class="code" href="classsolv__iteratif.html#a726974e9a0579e0c242606430dc320d4">seuil_</a>&gt;0);
<a name="l00091"></a>00091   <a class="code" href="classSolveurSys__base.html#a987e97740c779c1ab4192c3c1f1bbd5d">fixer_limpr</a>(impr);
<a name="l00092"></a>00092   <span class="keywordflow">if</span> (quiet)
<a name="l00093"></a>00093     <a class="code" href="classSolveurSys__base.html#a987e97740c779c1ab4192c3c1f1bbd5d">fixer_limpr</a>(-1);
<a name="l00094"></a>00094   <span class="keywordflow">return</span> is;
<a name="l00095"></a>00095 }
<a name="l00096"></a>00096 
<a name="l00097"></a><a class="code" href="classSolv__GCP.html#ac32faafc19ecfacd8d0e4dc749eb3e64">00097</a> <span class="keywordtype">int</span> <a class="code" href="classSolv__GCP.html#ac32faafc19ecfacd8d0e4dc749eb3e64">Solv_GCP::resoudre_systeme</a>(<span class="keyword">const</span> <a class="code" href="classMatrice__Base.html">Matrice_Base</a>&amp; matrice, <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; secmem, <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; solution)
<a name="l00098"></a>00098 {
<a name="l00099"></a>00099 
<a name="l00100"></a>00100 
<a name="l00101"></a>00101   <span class="keywordtype">int</span> n = <a class="code" href="classSolv__GCP.html#ab92ff464161604146fb820cdbf2079a1">resoudre_</a>(matrice, secmem, solution, 100);
<a name="l00102"></a>00102   <span class="keywordflow">return</span> n;
<a name="l00103"></a>00103 }
<a name="l00104"></a>00104 
<a name="l00105"></a><a class="code" href="classSolv__GCP.html#a2938854d2ea72586ef3e959412f31e14">00105</a> <span class="keywordtype">int</span> <a class="code" href="classSolv__GCP.html#ac32faafc19ecfacd8d0e4dc749eb3e64">Solv_GCP::resoudre_systeme</a>(<span class="keyword">const</span> <a class="code" href="classMatrice__Base.html">Matrice_Base</a>&amp; matrice, <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; secmem, <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; solution,
<a name="l00106"></a>00106                                <span class="keywordtype">int</span> nmax)
<a name="l00107"></a>00107 {
<a name="l00108"></a>00108 
<a name="l00109"></a>00109 
<a name="l00110"></a>00110   <span class="keywordtype">int</span> n = <a class="code" href="classSolv__GCP.html#ab92ff464161604146fb820cdbf2079a1">resoudre_</a>(matrice, secmem, solution, nmax);
<a name="l00111"></a>00111   <span class="keywordflow">return</span> n;
<a name="l00112"></a>00112 }
<a name="l00113"></a>00113 
<a name="l00114"></a>00114 
<a name="l00115"></a><a class="code" href="classSolv__GCP.html#a506c202030f5f801f0ae4779c24ba77b">00115</a> <span class="keywordtype">void</span> <a class="code" href="classSolv__GCP.html#a506c202030f5f801f0ae4779c24ba77b">Solv_GCP::reinit</a>()
<a name="l00116"></a>00116 {
<a name="l00117"></a>00117   <span class="keywordflow">if</span> (<a class="code" href="classSolv__GCP.html#aba192c7ac366b8c30b0eecd8629af793" title="0=&gt; rien n&#39;est pret 1=&gt; memoire allouee, coeffs matrice a copier, 2=&gt; ok">reinit_</a> &gt; 1) <span class="comment">//!&lt; Si reinit_ = 0, ne pas toucher.</span>
<a name="l00118"></a>00118 <span class="comment"></span>    <a class="code" href="classSolv__GCP.html#aba192c7ac366b8c30b0eecd8629af793" title="0=&gt; rien n&#39;est pret 1=&gt; memoire allouee, coeffs matrice a copier, 2=&gt; ok">reinit_</a> = 1;
<a name="l00119"></a>00119   <a class="code" href="classSolv__GCP.html#a506c202030f5f801f0ae4779c24ba77b">SolveurSys_base::reinit</a>();
<a name="l00120"></a>00120   <span class="keywordflow">if</span> (<a class="code" href="classSolv__GCP.html#aa9aa7485970ae948b2561b89e141af13">le_precond_</a>.<a class="code" href="classO__U__Ptr.html#a16f216b2d169e885876419182658ddcc" title="Renvoie 1 si le pointeur est non_nul Renvoie 0 sinon.">non_nul</a>())
<a name="l00121"></a>00121     <a class="code" href="classSolv__GCP.html#aa9aa7485970ae948b2561b89e141af13">le_precond_</a>.<a class="code" href="classDeriv__Precond__base.html#a407e470c17d054ca8d60fbc025e6b72b">valeur</a>().<a class="code" href="classPrecond__base.html#ab18d88451a29f28d526041302c811e83" title="this method must be called before preconditionner() whenever the matrix changes (coefficients only or...">reinit</a>();
<a name="l00122"></a>00122 }
<a name="l00123"></a>00123 
<a name="l00124"></a><a class="code" href="classSolv__GCP.html#aeb6006a337b824f7702dbd32084580a1">00124</a> <span class="keywordtype">void</span> <a class="code" href="classSolv__GCP.html#aeb6006a337b824f7702dbd32084580a1">Solv_GCP::prepare_data</a>(<span class="keyword">const</span> <a class="code" href="classMatrice__Base.html">Matrice_Base</a>&amp; matrice, <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; secmem, <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; solution)
<a name="l00125"></a>00125 {
<a name="l00126"></a>00126   <span class="keywordflow">if</span> (<a class="code" href="classSolv__GCP.html#aba192c7ac366b8c30b0eecd8629af793" title="0=&gt; rien n&#39;est pret 1=&gt; memoire allouee, coeffs matrice a copier, 2=&gt; ok">reinit_</a> == 0)
<a name="l00127"></a>00127     {
<a name="l00128"></a>00128 <span class="comment">// Reconstruction de toute la structure (tableaux d&#39;index et coefficients)</span>
<a name="l00129"></a>00129 
<a name="l00130"></a>00130       <span class="keywordflow">if</span> (secmem.<a class="code" href="classDoubleVect.html#ab02d01cd1bdab66fbd66f9a47cc29e10">line_size</a>() != 1)
<a name="l00131"></a>00131         {
<a name="l00132"></a>00132           <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Error line_size&gt;1 not coded (GCP)&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
<a name="l00133"></a>00133           <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">exit</a>();
<a name="l00134"></a>00134         }
<a name="l00135"></a>00135 
<a name="l00136"></a>00136       <span class="keyword">const</span> <a class="code" href="classMatrice__Bloc.html">Matrice_Bloc</a>&amp; mat_bloc = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Bloc.html">Matrice_Bloc</a>, matrice);
<a name="l00137"></a>00137       <span class="keyword">const</span> <a class="code" href="classMatrice__Morse__Sym.html" title="Classe Matrice_Morse_Sym Represente une matrice M (creuse) symetrique stockee au format Morse Symetri...">Matrice_Morse_Sym</a>&amp; mat = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Morse__Sym.html" title="Classe Matrice_Morse_Sym Represente une matrice M (creuse) symetrique stockee au format Morse Symetri...">Matrice_Morse_Sym</a>, mat_bloc.<a class="code" href="classMatrice__Bloc.html#a7ffa38f7b93454432b2df7c616ed0a4e">get_bloc</a>(0,0).<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>());
<a name="l00138"></a>00138       <span class="keyword">const</span> <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; mat_virt = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>, mat_bloc.<a class="code" href="classMatrice__Bloc.html#a7ffa38f7b93454432b2df7c616ed0a4e">get_bloc</a>(0,1).<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>());
<a name="l00139"></a>00139 
<a name="l00140"></a>00140 <span class="comment">// Determination du nombre d&#39;items reellement utilises:</span>
<a name="l00141"></a>00141       {
<a name="l00142"></a>00142         <span class="keyword">const</span> <span class="keywordtype">int</span> sztot_source = secmem.<a class="code" href="classArrOfDouble.html#a3c3b33bea0e88b87315c21ee94bee05f" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>();
<a name="l00143"></a>00143         <span class="keyword">const</span> <span class="keywordtype">int</span> <a class="code" href="Nom_8cpp.html#a0e1ea19fb9fa7881d15d84eff4c090e1">sz</a> = secmem.<a class="code" href="classDoubleVect.html#a392c1f20b462563365389d28e0853867" title="Identique a size_reelle()">size</a>();
<a name="l00144"></a>00144         <a class="code" href="classSolv__GCP.html#ab61b9443523fdea985d32989eee85ee7">renum_</a>.<a class="code" href="classIntVect.html#a273976ecf3d2d4fdbdc48ab446027e8e" title="met l&#39;objet dans l&#39;etat obtenu par le constructeur par defaut. (voir ArrOfInt::reset())">reset</a>();
<a name="l00145"></a>00145         <a class="code" href="classSolv__GCP.html#ab61b9443523fdea985d32989eee85ee7">renum_</a>.<a class="code" href="classIntVect.html#a5900779fd9a3f9a82c68007a42b87d98" title="Change la taille du vecteur (identique a resize_array() pour le traitement des anciennes valeurs et d...">resize</a>(sztot_source, <a class="code" href="classArray__base.html#abee342aa9ac59623c4c782dc9d7877ffaf6ae9ba7eb51c5f298ce693345b3ec68">Array_base::NOCOPY_NOINIT</a>);
<a name="l00146"></a>00146         <a class="code" href="classSolv__GCP.html#ab61b9443523fdea985d32989eee85ee7">renum_</a> = 0;
<a name="l00147"></a>00147 <span class="comment">// Retirer les items virtuels</span>
<a name="l00148"></a>00148         <span class="keywordtype">int</span> i;
<a name="l00149"></a>00149         <span class="keywordflow">for</span> (i = sz; i &lt; sztot_source; i++)
<a name="l00150"></a>00150           <a class="code" href="classSolv__GCP.html#ab61b9443523fdea985d32989eee85ee7">renum_</a>[i] = -1;
<a name="l00151"></a>00151         <a class="code" href="classSolv__GCP.html#ab61b9443523fdea985d32989eee85ee7">renum_</a>.<a class="code" href="classIntVect.html#aefca15627f9f7852150f4a769f00e3e2" title="associe le md_vector au vecteur et initialise l&#39;attribut size_reelle_ (voir methode size_reelle()) Si...">set_md_vector</a>(secmem.<a class="code" href="classDoubleVect.html#a0d16d30580c90526e4895388fb44be5d">get_md_vector</a>());
<a name="l00152"></a>00152         <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; tab2 = mat_virt.get_tab2();
<a name="l00153"></a>00153         <span class="keyword">const</span> <span class="keywordtype">int</span> n = tab2.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>();
<a name="l00154"></a>00154         <span class="keywordflow">for</span> (i = 0; i &lt; n; i++)
<a name="l00155"></a>00155           {
<a name="l00156"></a>00156 <span class="comment">// Attention: tab2 de la partie reele-virtuelle contient des indices</span>
<a name="l00157"></a>00157 <span class="comment">// relatifs au debut de la partie virtuelle (d&#39;ou &quot;+ sz&quot;)</span>
<a name="l00158"></a>00158             <span class="keyword">const</span> <span class="keywordtype">int</span> j = tab2[i]-1 + <a class="code" href="Nom_8cpp.html#a0e1ea19fb9fa7881d15d84eff4c090e1">sz</a>; <span class="comment">//!&lt; fortran -&gt; c</span>
<a name="l00159"></a>00159 <span class="comment"></span>            <a class="code" href="classSolv__GCP.html#ab61b9443523fdea985d32989eee85ee7">renum_</a>[j] = 0;
<a name="l00160"></a>00160           }
<a name="l00161"></a>00161       }
<a name="l00162"></a>00162 <span class="comment">// Determination du nombre de lignes non vides de mat_virt</span>
<a name="l00163"></a>00163       <span class="keywordtype">int</span> nb_lignes_mat_virt = 0;
<a name="l00164"></a>00164       {
<a name="l00165"></a>00165         <span class="keyword">const</span> <span class="keywordtype">int</span> n = mat_virt.get_tab1().<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() - 1;
<a name="l00166"></a>00166         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; n; i++)
<a name="l00167"></a>00167           <span class="keywordflow">if</span> (mat_virt.get_tab1()(i+1) - mat_virt.get_tab1()(i) &gt; 0)
<a name="l00168"></a>00168             nb_lignes_mat_virt++;
<a name="l00169"></a>00169       }
<a name="l00170"></a>00170 
<a name="l00171"></a>00171 <span class="comment">// Descripteur contenant uniquement les items utiles:</span>
<a name="l00172"></a>00172       <a class="code" href="classMD__Vector.html" title=": Cette classe est un DERIV mais l&#39;objet pointe est partage entre plusieurs instances de cette classe...">MD_Vector</a> md;
<a name="l00173"></a>00173       <a class="code" href="classMD__Vector__tools.html#a773ef21e5af6331de459189d19cc340b" title="Idem que creer_md_vect_renum() mais cree une numerotation par defaut. Le tableau flags_renum doit con...">MD_Vector_tools::creer_md_vect_renum_auto</a>(<a class="code" href="classSolv__GCP.html#ab61b9443523fdea985d32989eee85ee7">renum_</a>, md);
<a name="l00174"></a>00174       <span class="keyword">const</span> <span class="keywordtype">int</span> sz_tot = md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a27d5ace2aee5ecf1d78accb7b321108d">get_nb_items_tot</a>();
<a name="l00175"></a>00175       <span class="keyword">const</span> <span class="keywordtype">int</span> <a class="code" href="Nom_8cpp.html#a0e1ea19fb9fa7881d15d84eff4c090e1">sz</a> = md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#ade0ef13d456f8aa11d02f51fd7912145">get_nb_items_reels</a>();
<a name="l00176"></a>00176 
<a name="l00177"></a>00177 <span class="comment">// Calcul de la taille memoire requise:</span>
<a name="l00178"></a>00178       <span class="keywordtype">int</span> mem_size = 0;
<a name="l00179"></a>00179       mem_size += sz_tot * <span class="keyword">sizeof</span>(double); <span class="comment">//!&lt;  vecteurs avec espace virtuel (tmp_p_)</span>
<a name="l00180"></a>00180 <span class="comment"></span>      mem_size += sz * <span class="keyword">sizeof</span>(double) * 3; <span class="comment">//!&lt; vecteurs sans espace virtuel</span>
<a name="l00181"></a>00181 <span class="comment"></span>      <span class="keyword">const</span> <span class="keywordtype">int</span> nb_lignes_mat = <a class="code" href="Nom_8cpp.html#a0e1ea19fb9fa7881d15d84eff4c090e1">sz</a>;
<a name="l00182"></a>00182 <span class="comment">// matrice reel/reel</span>
<a name="l00183"></a>00183       mem_size += (sz + 1) * <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>); <span class="comment">//!&lt; pour tab1_</span>
<a name="l00184"></a>00184 <span class="comment"></span>      <span class="keywordtype">int</span> nnz_reel_reel = 0;
<a name="l00185"></a>00185       assert(mat.<a class="code" href="classMatrice__Morse.html#a79b4e334152850bd36e53478debf3061">get_tab1</a>().<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() == sz + 1);
<a name="l00186"></a>00186       assert(mat.<a class="code" href="classMatrice__Morse.html#a787b5a63f27063f9c891243d8f188cda">get_tab2</a>().<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() == mat.<a class="code" href="classMatrice__Morse.html#aacb80dd518dcc0812e3b34edac6ab67e">get_coeff</a>().<a class="code" href="classArrOfDouble.html#a3c3b33bea0e88b87315c21ee94bee05f" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>());
<a name="l00187"></a>00187       <span class="keywordflow">if</span> (! <a class="code" href="classSolv__GCP.html#aebbaeaa67bf2f876d354938b76e7c36a">precond_diag_</a>)
<a name="l00188"></a>00188         {
<a name="l00189"></a>00189           nnz_reel_reel = mat.<a class="code" href="classMatrice__Morse.html#aacb80dd518dcc0812e3b34edac6ab67e">get_coeff</a>().<a class="code" href="classArrOfDouble.html#a3c3b33bea0e88b87315c21ee94bee05f" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>();
<a name="l00190"></a>00190         }
<a name="l00191"></a>00191       <span class="keywordflow">else</span>
<a name="l00192"></a>00192         {
<a name="l00193"></a>00193 <span class="comment">// On ne stocke pas les coefficients diagonaux:</span>
<a name="l00194"></a>00194           nnz_reel_reel = mat.<a class="code" href="classMatrice__Morse.html#aacb80dd518dcc0812e3b34edac6ab67e">get_coeff</a>().<a class="code" href="classArrOfDouble.html#a3c3b33bea0e88b87315c21ee94bee05f" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() - <a class="code" href="Nom_8cpp.html#a0e1ea19fb9fa7881d15d84eff4c090e1">sz</a>;
<a name="l00195"></a>00195         }
<a name="l00196"></a>00196       mem_size += nnz_reel_reel * <span class="keyword">sizeof</span>(double); <span class="comment">//!&lt; pour les coefficients</span>
<a name="l00197"></a>00197 <span class="comment"></span>      mem_size += nnz_reel_reel * <span class="keyword">sizeof</span>(int); <span class="comment">//!&lt; pour les indices matrice reel/virtuel</span>
<a name="l00198"></a>00198 <span class="comment"></span><span class="comment">//</span>
<a name="l00199"></a>00199       mem_size += (nb_lignes_mat_virt+1) * <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>); <span class="comment">//!&lt; pour tab1_</span>
<a name="l00200"></a>00200 <span class="comment"></span>      <span class="keyword">const</span> <span class="keywordtype">int</span> nnz_reel_virtuel = mat_virt.get_coeff().size_array();
<a name="l00201"></a>00201       assert(mat_virt.get_tab2().size_array() == nnz_reel_virtuel);
<a name="l00202"></a>00202       mem_size += nnz_reel_virtuel * <span class="keyword">sizeof</span>(double); <span class="comment">//!&lt; pour les coefficients</span>
<a name="l00203"></a>00203 <span class="comment"></span>      mem_size += nnz_reel_virtuel * <span class="keyword">sizeof</span>(int); <span class="comment">//!&lt; pour les indices taille de tmp_mat_virt_.lignes_non_vides_</span>
<a name="l00204"></a>00204 <span class="comment"></span><span class="comment">//</span>
<a name="l00205"></a>00205       mem_size += nb_lignes_mat_virt * <span class="keyword">sizeof</span>(int);
<a name="l00206"></a>00206 <span class="comment">// aligner la taille sur un multiple de 8</span>
<a name="l00207"></a>00207       <span class="keywordflow">if</span> (mem_size % 8 != 0)
<a name="l00208"></a>00208         mem_size = (mem_size/8+1)*8;
<a name="l00209"></a>00209 
<a name="l00210"></a>00210 <span class="comment">// Allocation des tableaux:</span>
<a name="l00211"></a>00211 <span class="comment">// (on met d&#39;abord tous les tableaux de double, puis a la fin les tableaux d&#39;entiers</span>
<a name="l00212"></a>00212 <span class="comment">// sinon il faut ajouter du padding pour aligner si on remet des double apres de int)</span>
<a name="l00213"></a>00213 <span class="comment">// </span>
<a name="l00214"></a>00214       <a class="code" href="classProcess.html#a57e0f54b11e6eaadbea224fa904b18dd" title="Renvoie un objet statique de type Sortie qui sert de journal d&#39;evenements. Si message_level &lt;= verbose...">Journal</a>() &lt;&lt; <span class="stringliteral">&quot;Solv_GCP::prepare allocating data chunk : &quot;</span> &lt;&lt; mem_size &lt;&lt; <span class="stringliteral">&quot; bytes&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
<a name="l00215"></a>00215       <a class="code" href="classSolv__GCP.html#a63001a11b5ed3214789975e7633eac92">tmp_data_block_</a>.<a class="code" href="classArrOfDouble.html#a610464f4b3dccac6f814915b526783ed">resize_array</a>(mem_size/8, <a class="code" href="classArray__base.html#abee342aa9ac59623c4c782dc9d7877ffaf6ae9ba7eb51c5f298ce693345b3ec68">Array_base::NOCOPY_NOINIT</a>);
<a name="l00216"></a>00216 
<a name="l00217"></a>00217       <span class="keywordtype">double</span> *ptr = <a class="code" href="classSolv__GCP.html#a63001a11b5ed3214789975e7633eac92">tmp_data_block_</a>.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
<a name="l00218"></a>00218       <a class="code" href="classSolv__GCP.html#a2dde6b48ed50f795d0df442e25543f24">resu_</a>.<a class="code" href="classDoubleVect.html#a4cc7c18df3f14857336aee6ff41f4f49" title="voir ArrOfDouble::ref_data(). (cree un tableau sans structure parallele)">ref_data</a>(ptr, sz);
<a name="l00219"></a>00219       ptr += <a class="code" href="Nom_8cpp.html#a0e1ea19fb9fa7881d15d84eff4c090e1">sz</a>;
<a name="l00220"></a>00220       <a class="code" href="classSolv__GCP.html#a491a6795972aa58d19e222211b70bb73">residu_</a>.<a class="code" href="classDoubleVect.html#a4cc7c18df3f14857336aee6ff41f4f49" title="voir ArrOfDouble::ref_data(). (cree un tableau sans structure parallele)">ref_data</a>(ptr, sz);
<a name="l00221"></a>00221       ptr += <a class="code" href="Nom_8cpp.html#a0e1ea19fb9fa7881d15d84eff4c090e1">sz</a>;
<a name="l00222"></a>00222       <a class="code" href="classSolv__GCP.html#af10441b3afc51b4e2a967a2f9c2e813e">tmp_p_avec_items_virt_</a>.<a class="code" href="classDoubleVect.html#a4cc7c18df3f14857336aee6ff41f4f49" title="voir ArrOfDouble::ref_data(). (cree un tableau sans structure parallele)">ref_data</a>(ptr, sz_tot); <span class="comment">//!&lt; avec espace virtuel</span>
<a name="l00223"></a>00223 <span class="comment"></span>      <a class="code" href="classSolv__GCP.html#af10441b3afc51b4e2a967a2f9c2e813e">tmp_p_avec_items_virt_</a>.<a class="code" href="classDoubleVect.html#a63f1c9da5548085b7b2f7a9e54611a0d" title="associe le md_vector au vecteur et initialise l&#39;attribut size_reelle_ (voir methode size_reelle()) Si...">set_md_vector</a>(md);
<a name="l00224"></a>00224 <span class="comment">// tmp_p_ pointe sur la meme zone:</span>
<a name="l00225"></a>00225       <a class="code" href="classSolv__GCP.html#a73cac6d4f308333325a0430590ebceec">tmp_p_</a>.<a class="code" href="classDoubleVect.html#a4cc7c18df3f14857336aee6ff41f4f49" title="voir ArrOfDouble::ref_data(). (cree un tableau sans structure parallele)">ref_data</a>(ptr, sz); <span class="comment">//!&lt; sans l&#39;espace virtuel</span>
<a name="l00226"></a>00226 <span class="comment"></span>      ptr += sz_tot;
<a name="l00227"></a>00227       <a class="code" href="classSolv__GCP.html#a3ee6d07baa401b83335a06036b8c9d4e">tmp_solution_</a>.<a class="code" href="classDoubleVect.html#a4cc7c18df3f14857336aee6ff41f4f49" title="voir ArrOfDouble::ref_data(). (cree un tableau sans structure parallele)">ref_data</a>(ptr, sz);
<a name="l00228"></a>00228       ptr += <a class="code" href="Nom_8cpp.html#a0e1ea19fb9fa7881d15d84eff4c090e1">sz</a>;
<a name="l00229"></a>00229 <span class="comment">// Allocation des tableaux pour les matrices:</span>
<a name="l00230"></a>00230       <a class="code" href="classSolv__GCP.html#af90f523225473263ab3531630a418817">tmp_mat_</a>.<a class="code" href="classMatrice__Morse.html#acd067e8514e5741f52b18a1d99746d11">get_set_coeff</a>().<a class="code" href="classDoubleVect.html#a4cc7c18df3f14857336aee6ff41f4f49" title="voir ArrOfDouble::ref_data(). (cree un tableau sans structure parallele)">ref_data</a>(ptr, nnz_reel_reel);
<a name="l00231"></a>00231       ptr += nnz_reel_reel;
<a name="l00232"></a>00232       <a class="code" href="classSolv__GCP.html#ab0dde9b547a7afdbb13329529c24f995">tmp_mat_virt_</a>.<a class="code" href="classMatrice__SuperMorse.html#a98b6048dc2ccb53becccaff698e64e38">get_set_coeff</a>().<a class="code" href="classArrOfDouble.html#a8cc97dbe67c8001dad97008b10fa7690" title="Fait pointer le tableau vers la zone de memoire &quot;data_&quot;. On detache la zone de memoire existante...">ref_data</a>(ptr, nnz_reel_virtuel);
<a name="l00233"></a>00233       ptr += nnz_reel_virtuel;
<a name="l00234"></a>00234 <span class="comment">// On a fini les double, on passe aux tableaux d&#39;entiers:</span>
<a name="l00235"></a>00235       <span class="keywordtype">int</span> * iptr = (<span class="keywordtype">int</span>*)ptr;
<a name="l00236"></a>00236       <a class="code" href="classSolv__GCP.html#af90f523225473263ab3531630a418817">tmp_mat_</a>.<a class="code" href="classMatrice__Morse.html#a7a49c763706dcfaed900f9d2cbb68716">get_set_tab1</a>().<a class="code" href="classIntVect.html#aca0cf803f3b217131c25563773c9f043" title="voir ArrOfInt::ref_data(). (cree un tableau sans structure parallele)">ref_data</a>(iptr, nb_lignes_mat + 1);
<a name="l00237"></a>00237       iptr += nb_lignes_mat + 1;
<a name="l00238"></a>00238       <a class="code" href="classSolv__GCP.html#af90f523225473263ab3531630a418817">tmp_mat_</a>.<a class="code" href="classMatrice__Morse.html#af11c5853518e9e6db4c7e6e6acc8d7fd">get_set_tab2</a>().<a class="code" href="classIntVect.html#aca0cf803f3b217131c25563773c9f043" title="voir ArrOfInt::ref_data(). (cree un tableau sans structure parallele)">ref_data</a>(iptr, nnz_reel_reel);
<a name="l00239"></a>00239       iptr += nnz_reel_reel;
<a name="l00240"></a>00240       <a class="code" href="classSolv__GCP.html#ab0dde9b547a7afdbb13329529c24f995">tmp_mat_virt_</a>.<a class="code" href="classMatrice__SuperMorse.html#a9cde1b97e8a6d898fdc67bb995544361">lignes_non_vides_</a>.<a class="code" href="classArrOfInt.html#a95b02281f2d3f210e463389ff7288169" title="Fait pointer le tableau vers la zone de memoire &quot;data_&quot;. On detache la zone de memoire existante...">ref_data</a>(iptr, nb_lignes_mat_virt);
<a name="l00241"></a>00241       iptr += nb_lignes_mat_virt;
<a name="l00242"></a>00242       <a class="code" href="classSolv__GCP.html#ab0dde9b547a7afdbb13329529c24f995">tmp_mat_virt_</a>.<a class="code" href="classMatrice__SuperMorse.html#a0fa4af20a68806d12a4a8efdf4979825">get_set_tab1</a>().<a class="code" href="classArrOfInt.html#a95b02281f2d3f210e463389ff7288169" title="Fait pointer le tableau vers la zone de memoire &quot;data_&quot;. On detache la zone de memoire existante...">ref_data</a>(iptr, nb_lignes_mat_virt + 1);
<a name="l00243"></a>00243       iptr += nb_lignes_mat_virt + 1;
<a name="l00244"></a>00244       <a class="code" href="classSolv__GCP.html#ab0dde9b547a7afdbb13329529c24f995">tmp_mat_virt_</a>.<a class="code" href="classMatrice__SuperMorse.html#adf9277e7d1424888f34f54668a61a02f">get_set_tab2</a>().<a class="code" href="classArrOfInt.html#a95b02281f2d3f210e463389ff7288169" title="Fait pointer le tableau vers la zone de memoire &quot;data_&quot;. On detache la zone de memoire existante...">ref_data</a>(iptr, nnz_reel_virtuel);
<a name="l00245"></a>00245       iptr += nnz_reel_virtuel;
<a name="l00246"></a>00246 <span class="comment">// Allocation terminee.</span>
<a name="l00247"></a>00247       assert(((<span class="keywordtype">char</span>*)iptr) &lt;= ((<span class="keywordtype">char</span>*)<a class="code" href="classSolv__GCP.html#a63001a11b5ed3214789975e7633eac92">tmp_data_block_</a>.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() + mem_size));
<a name="l00248"></a>00248 
<a name="l00249"></a>00249 <span class="comment">// Remplissages des tableaux d&#39;index (tab1_, tab2_ et lignes_non_vides_)</span>
<a name="l00250"></a>00250       <span class="keywordflow">if</span> (! <a class="code" href="classSolv__GCP.html#aebbaeaa67bf2f876d354938b76e7c36a">precond_diag_</a>)
<a name="l00251"></a>00251         {
<a name="l00252"></a>00252           <a class="code" href="classSolv__GCP.html#af90f523225473263ab3531630a418817">tmp_mat_</a>.<a class="code" href="classMatrice__Morse.html#a7a49c763706dcfaed900f9d2cbb68716">get_set_tab1</a>().<a class="code" href="classArrOfInt.html#a195c644d98bf2da2fe4f8aede4e02262" title="Copie les elements source[first_element_source + i] dans les elements (*this)[first_element_dest + i]...">inject_array</a>(mat.<a class="code" href="classMatrice__Morse.html#a79b4e334152850bd36e53478debf3061">get_tab1</a>());
<a name="l00253"></a>00253           {
<a name="l00254"></a>00254 <span class="comment">// remplissage de tab2 (renumerotation eventuelle)</span>
<a name="l00255"></a>00255             <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; nnz_reel_reel; i++)
<a name="l00256"></a>00256               {
<a name="l00257"></a>00257                 <span class="keywordtype">int</span> j = mat.<a class="code" href="classMatrice__Morse.html#a787b5a63f27063f9c891243d8f188cda">get_tab2</a>()(i)-1; <span class="comment">//!&lt; fortran-&gt;c</span>
<a name="l00258"></a>00258 <span class="comment"></span>                <span class="keywordtype">int</span> rj = <a class="code" href="classSolv__GCP.html#ab61b9443523fdea985d32989eee85ee7">renum_</a>[j];
<a name="l00259"></a>00259                 assert(rj &lt; sz_tot);
<a name="l00260"></a>00260                 <a class="code" href="classSolv__GCP.html#af90f523225473263ab3531630a418817">tmp_mat_</a>.<a class="code" href="classMatrice__Morse.html#af11c5853518e9e6db4c7e6e6acc8d7fd">get_set_tab2</a>()(i) = rj+1; <span class="comment">//!&lt; c-&gt;fortran</span>
<a name="l00261"></a>00261 <span class="comment"></span>              }
<a name="l00262"></a>00262           }
<a name="l00263"></a>00263           <a class="code" href="classSolv__GCP.html#af90f523225473263ab3531630a418817">tmp_mat_</a>.<a class="code" href="classMatrice__Morse.html#ab2fb02a8aba88f717c2285960f375fba">set_nb_columns</a>( sz_tot );
<a name="l00264"></a>00264         }
<a name="l00265"></a>00265       <span class="keywordflow">else</span>
<a name="l00266"></a>00266         {
<a name="l00267"></a>00267 <span class="comment">// Construction de la matrice D^(-1/2) * A * D^(-1/2)</span>
<a name="l00268"></a>00268 <span class="comment">// on ne stocke pas les coeffs diagonaux</span>
<a name="l00269"></a>00269 <span class="comment">// Le remplissage de tab1_ n&#39;est pas trivial, du coup:</span>
<a name="l00270"></a>00270           {
<a name="l00271"></a>00271             <span class="keywordtype">int</span> src_index = 0; <span class="comment">//!&lt; index dans mat.tab2_ et coeff_</span>
<a name="l00272"></a>00272 <span class="comment"></span>            <span class="keywordtype">int</span> dest_index = 0; <span class="comment">//!&lt; index dans tmp_mat_.tab2_ et coeff_</span>
<a name="l00273"></a>00273 <span class="comment"></span>            <span class="keywordtype">int</span> i_ligne;
<a name="l00274"></a>00274             <span class="keywordflow">for</span> (i_ligne = 0; i_ligne &lt; nb_lignes_mat; i_ligne++)
<a name="l00275"></a>00275               {
<a name="l00276"></a>00276 <span class="comment">// A chaque ligne on a un coefficient de moins que dans la matrice d&#39;origine</span>
<a name="l00277"></a>00277 <span class="comment">// (on ne met pas le coeff diagonal)</span>
<a name="l00278"></a>00278                 <a class="code" href="classSolv__GCP.html#af90f523225473263ab3531630a418817">tmp_mat_</a>.<a class="code" href="classMatrice__Morse.html#a7a49c763706dcfaed900f9d2cbb68716">get_set_tab1</a>()(i_ligne) = dest_index + 1; <span class="comment">//!&lt; indice fortran du debut de ligne</span>
<a name="l00279"></a>00279 <span class="comment"></span>                <span class="keyword">const</span> <span class="keywordtype">int</span> ncoeff = mat.<a class="code" href="classMatrice__Morse.html#a79b4e334152850bd36e53478debf3061">get_tab1</a>()(i_ligne+1) - mat.<a class="code" href="classMatrice__Morse.html#a79b4e334152850bd36e53478debf3061">get_tab1</a>()(i_ligne) - 1;
<a name="l00280"></a>00280 <span class="comment">// Ne pas inserer le coeff diagonal</span>
<a name="l00281"></a>00281                 assert(mat.<a class="code" href="classMatrice__Morse.html#a787b5a63f27063f9c891243d8f188cda">get_tab2</a>()(src_index) == i_ligne + 1); <span class="comment">//!&lt; index fortran</span>
<a name="l00282"></a>00282 <span class="comment"></span>                src_index++;
<a name="l00283"></a>00283 <span class="comment">// Inserer les autres coeffs:</span>
<a name="l00284"></a>00284                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; ncoeff; i++, src_index++, dest_index++)
<a name="l00285"></a>00285                   <a class="code" href="classSolv__GCP.html#af90f523225473263ab3531630a418817">tmp_mat_</a>.<a class="code" href="classMatrice__Morse.html#af11c5853518e9e6db4c7e6e6acc8d7fd">get_set_tab2</a>()(dest_index) = mat.<a class="code" href="classMatrice__Morse.html#a787b5a63f27063f9c891243d8f188cda">get_tab2</a>()(src_index);
<a name="l00286"></a>00286 
<a name="l00287"></a>00287               }
<a name="l00288"></a>00288 <span class="comment">// Fin de la derniere ligne:</span>
<a name="l00289"></a>00289             <a class="code" href="classSolv__GCP.html#af90f523225473263ab3531630a418817">tmp_mat_</a>.<a class="code" href="classMatrice__Morse.html#a7a49c763706dcfaed900f9d2cbb68716">get_set_tab1</a>()(i_ligne) = dest_index + 1; <span class="comment">//!&lt; indice fortran du debut de ligne</span>
<a name="l00290"></a>00290 <span class="comment"></span>          }
<a name="l00291"></a>00291           <a class="code" href="classSolv__GCP.html#af90f523225473263ab3531630a418817">tmp_mat_</a>.<a class="code" href="classMatrice__Morse.html#ab2fb02a8aba88f717c2285960f375fba">set_nb_columns</a>( sz_tot );
<a name="l00292"></a>00292         }
<a name="l00293"></a>00293 <span class="comment">// remplissage de tmp_mat_virt_</span>
<a name="l00294"></a>00294       {
<a name="l00295"></a>00295         <a class="code" href="classSolv__GCP.html#ab0dde9b547a7afdbb13329529c24f995">tmp_mat_virt_</a>.<a class="code" href="classMatrice__SuperMorse.html#a0fa4af20a68806d12a4a8efdf4979825">get_set_tab1</a>()(0) = 1;
<a name="l00296"></a>00296         <span class="keywordtype">int</span> i_ligne_dest = 0;
<a name="l00297"></a>00297         <span class="keywordtype">int</span> dest_index = 0;
<a name="l00298"></a>00298         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i_ligne = 0; i_ligne &lt; nb_lignes_mat; i_ligne++)
<a name="l00299"></a>00299           {
<a name="l00300"></a>00300             <span class="keyword">const</span> <span class="keywordtype">int</span> count = mat_virt.get_tab1()(i_ligne+1) - mat_virt.get_tab1()(i_ligne);
<a name="l00301"></a>00301             <span class="keywordflow">if</span> (count &gt; 0)
<a name="l00302"></a>00302               {
<a name="l00303"></a>00303                 <a class="code" href="classSolv__GCP.html#ab0dde9b547a7afdbb13329529c24f995">tmp_mat_virt_</a>.<a class="code" href="classMatrice__SuperMorse.html#a9cde1b97e8a6d898fdc67bb995544361">lignes_non_vides_</a>[i_ligne_dest] = i_ligne + 1; <span class="comment">//!&lt; indice fortran</span>
<a name="l00304"></a>00304 <span class="comment"></span>                <a class="code" href="classSolv__GCP.html#ab0dde9b547a7afdbb13329529c24f995">tmp_mat_virt_</a>.<a class="code" href="classMatrice__SuperMorse.html#a0fa4af20a68806d12a4a8efdf4979825">get_set_tab1</a>()(i_ligne_dest) = dest_index + 1; <span class="comment">//!&lt; index fortran</span>
<a name="l00305"></a>00305 <span class="comment"></span>                i_ligne_dest++;
<a name="l00306"></a>00306                 <span class="keywordtype">int</span> src_index = mat_virt.get_tab1()(i_ligne) - 1; <span class="comment">//!&lt; fortran-&gt;c</span>
<a name="l00307"></a>00307 <span class="comment"></span>                <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; count; i++, src_index++, dest_index++)
<a name="l00308"></a>00308                   {
<a name="l00309"></a>00309 <span class="comment">// mat_virt contient des indices fortran relatifs au debut de la partie virtuelle,</span>
<a name="l00310"></a>00310 <span class="comment">// on transform en indice C, relatif au vecteur complet</span>
<a name="l00311"></a>00311                     <span class="keywordtype">int</span> j = mat_virt.get_tab2()(src_index) + sz - 1;
<a name="l00312"></a>00312                     <span class="keywordtype">int</span> rj = <a class="code" href="classSolv__GCP.html#ab61b9443523fdea985d32989eee85ee7">renum_</a>[j];
<a name="l00313"></a>00313 <span class="comment">// on stocke dans tmp_mat_virt des indices de colonnes relatifs au vecteur complet</span>
<a name="l00314"></a>00314 <span class="comment">// (pas seulement la partie virtuelle)</span>
<a name="l00315"></a>00315                     <a class="code" href="classSolv__GCP.html#ab0dde9b547a7afdbb13329529c24f995">tmp_mat_virt_</a>.<a class="code" href="classMatrice__SuperMorse.html#adf9277e7d1424888f34f54668a61a02f">get_set_tab2</a>()(dest_index) = rj + 1; <span class="comment">//!&lt; indice fortran</span>
<a name="l00316"></a>00316 <span class="comment"></span>                  }
<a name="l00317"></a>00317               }
<a name="l00318"></a>00318           }
<a name="l00319"></a>00319 <span class="comment">// Fin de la derniere ligne:</span>
<a name="l00320"></a>00320         <a class="code" href="classSolv__GCP.html#ab0dde9b547a7afdbb13329529c24f995">tmp_mat_virt_</a>.<a class="code" href="classMatrice__SuperMorse.html#a0fa4af20a68806d12a4a8efdf4979825">get_set_tab1</a>()(i_ligne_dest) = dest_index + 1; <span class="comment">//!&lt; index fortran</span>
<a name="l00321"></a>00321 <span class="comment"></span>      }
<a name="l00322"></a>00322       <a class="code" href="classSolv__GCP.html#aba192c7ac366b8c30b0eecd8629af793" title="0=&gt; rien n&#39;est pret 1=&gt; memoire allouee, coeffs matrice a copier, 2=&gt; ok">reinit_</a> = 1;
<a name="l00323"></a>00323     }
<a name="l00324"></a>00324 
<a name="l00325"></a>00325   <span class="keywordflow">if</span> (<a class="code" href="classSolv__GCP.html#aba192c7ac366b8c30b0eecd8629af793" title="0=&gt; rien n&#39;est pret 1=&gt; memoire allouee, coeffs matrice a copier, 2=&gt; ok">reinit_</a> &lt; 2)
<a name="l00326"></a>00326     {
<a name="l00327"></a>00327       <span class="keyword">const</span> <a class="code" href="classMatrice__Bloc.html">Matrice_Bloc</a>&amp; mat_bloc = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Bloc.html">Matrice_Bloc</a>, matrice);
<a name="l00328"></a>00328       <span class="keyword">const</span> <a class="code" href="classMatrice__Morse__Sym.html" title="Classe Matrice_Morse_Sym Represente une matrice M (creuse) symetrique stockee au format Morse Symetri...">Matrice_Morse_Sym</a>&amp; mat = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Morse__Sym.html" title="Classe Matrice_Morse_Sym Represente une matrice M (creuse) symetrique stockee au format Morse Symetri...">Matrice_Morse_Sym</a>, mat_bloc.<a class="code" href="classMatrice__Bloc.html#a7ffa38f7b93454432b2df7c616ed0a4e">get_bloc</a>(0,0).<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>());
<a name="l00329"></a>00329       <span class="keyword">const</span> <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; mat_virt = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>, mat_bloc.<a class="code" href="classMatrice__Bloc.html#a7ffa38f7b93454432b2df7c616ed0a4e">get_bloc</a>(0,1).<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>());
<a name="l00330"></a>00330       <span class="keywordflow">if</span> (!<a class="code" href="classSolv__GCP.html#aebbaeaa67bf2f876d354938b76e7c36a">precond_diag_</a>)
<a name="l00331"></a>00331         {
<a name="l00332"></a>00332           <a class="code" href="classSolv__GCP.html#af90f523225473263ab3531630a418817">tmp_mat_</a>.<a class="code" href="classMatrice__Morse.html#acd067e8514e5741f52b18a1d99746d11">get_set_coeff</a>().<a class="code" href="classArrOfDouble.html#a2fcb2a2d3b59425c6cb37526ea6af6a3" title="Copie les elements source[first_element_source + i] dans les elements (*this)[first_element_dest + i]...">inject_array</a>(mat.<a class="code" href="classMatrice__Morse.html#aacb80dd518dcc0812e3b34edac6ab67e">get_coeff</a>());
<a name="l00333"></a>00333           <a class="code" href="classSolv__GCP.html#ab0dde9b547a7afdbb13329529c24f995">tmp_mat_virt_</a>.<a class="code" href="classMatrice__SuperMorse.html#a98b6048dc2ccb53becccaff698e64e38">get_set_coeff</a>().<a class="code" href="classArrOfDouble.html#a2fcb2a2d3b59425c6cb37526ea6af6a3" title="Copie les elements source[first_element_source + i] dans les elements (*this)[first_element_dest + i]...">inject_array</a>(mat_virt.get_coeff());
<a name="l00334"></a>00334         }
<a name="l00335"></a>00335       <span class="keywordflow">else</span>
<a name="l00336"></a>00336         {
<a name="l00337"></a>00337 <span class="comment">// calcul de D^(-1/2)</span>
<a name="l00338"></a>00338           <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">exit</a>();
<a name="l00339"></a>00339 <span class="comment">// calcul du produit D^(-1/2) * A * D^(-1/2)</span>
<a name="l00340"></a>00340 
<a name="l00341"></a>00341         }
<a name="l00342"></a>00342       <a class="code" href="classSolv__GCP.html#aba192c7ac366b8c30b0eecd8629af793" title="0=&gt; rien n&#39;est pret 1=&gt; memoire allouee, coeffs matrice a copier, 2=&gt; ok">reinit_</a> = 2;
<a name="l00343"></a>00343     }
<a name="l00344"></a>00344 
<a name="l00345"></a>00345   <span class="keywordflow">if</span> (!<a class="code" href="classSolv__GCP.html#aebbaeaa67bf2f876d354938b76e7c36a">precond_diag_</a>)
<a name="l00346"></a>00346     {
<a name="l00347"></a>00347       <a class="code" href="classSolv__GCP.html#a3ee6d07baa401b83335a06036b8c9d4e">tmp_solution_</a>.<a class="code" href="classArrOfDouble.html#a2fcb2a2d3b59425c6cb37526ea6af6a3" title="Copie les elements source[first_element_source + i] dans les elements (*this)[first_element_dest + i]...">inject_array</a>(solution, <a class="code" href="classSolv__GCP.html#a3ee6d07baa401b83335a06036b8c9d4e">tmp_solution_</a>.<a class="code" href="classDoubleVect.html#a392c1f20b462563365389d28e0853867" title="Identique a size_reelle()">size</a>());
<a name="l00348"></a>00348       <a class="code" href="classSolv__GCP.html#a2dde6b48ed50f795d0df442e25543f24">resu_</a>.<a class="code" href="classArrOfDouble.html#a2fcb2a2d3b59425c6cb37526ea6af6a3" title="Copie les elements source[first_element_source + i] dans les elements (*this)[first_element_dest + i]...">inject_array</a>(secmem, <a class="code" href="classSolv__GCP.html#a2dde6b48ed50f795d0df442e25543f24">resu_</a>.<a class="code" href="classArrOfDouble.html#a3c3b33bea0e88b87315c21ee94bee05f" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>());
<a name="l00349"></a>00349     }
<a name="l00350"></a>00350   <span class="keywordflow">else</span>
<a name="l00351"></a>00351     {
<a name="l00352"></a>00352       <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">exit</a>();
<a name="l00353"></a>00353     }
<a name="l00354"></a>00354 }
<a name="l00355"></a>00355 
<a name="l00356"></a>00356 <span class="comment">// Calcul de vx = vx * alpha - vy</span>
<a name="l00357"></a><a class="code" href="Solv__GCP_8cpp.html#ab5770466cce112d525bb5d526fec71cd">00357</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="Solv__GCP_8cpp.html#ab5770466cce112d525bb5d526fec71cd">multiply_sub</a>(<a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; vx, <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; vy, <span class="keywordtype">double</span> alpha)
<a name="l00358"></a>00358 {
<a name="l00359"></a>00359   <span class="keywordtype">int</span> n = vx.<a class="code" href="classDoubleVect.html#aafef4b3a96cdc428d62c5cedc9af6112">size_reelle_ok</a>() ? vx.<a class="code" href="classDoubleVect.html#a392c1f20b462563365389d28e0853867" title="Identique a size_reelle()">size</a>() : vx.<a class="code" href="classDoubleVect.html#ad2d21b364e1c6559771970596a25c006" title="Identique a size_array()">size_totale</a>();
<a name="l00360"></a>00360   assert(vy.<a class="code" href="classDoubleVect.html#ad2d21b364e1c6559771970596a25c006" title="Identique a size_array()">size_totale</a>() &gt;= n);
<a name="l00361"></a>00361   <span class="keywordtype">double</span> *x_ptr = vx.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
<a name="l00362"></a>00362   <span class="keywordtype">double</span> *y_ptr = vy.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
<a name="l00363"></a>00363   <span class="keywordflow">for</span> (n = n - 1; n &gt; 0; n -= 2, x_ptr += 2, y_ptr += 2)
<a name="l00364"></a>00364     {
<a name="l00365"></a>00365       <span class="keywordtype">double</span> a = x_ptr[0] * alpha - y_ptr[0];
<a name="l00366"></a>00366       <span class="keywordtype">double</span> b = x_ptr[1] * alpha - y_ptr[1];
<a name="l00367"></a>00367       x_ptr[0] = a;
<a name="l00368"></a>00368       x_ptr[1] = b;
<a name="l00369"></a>00369     }
<a name="l00370"></a>00370 <span class="comment">// n etait-il impair au depart ?</span>
<a name="l00371"></a>00371   <span class="keywordflow">if</span> (n == 0)
<a name="l00372"></a>00372     x_ptr[0] = x_ptr[0] * alpha - y_ptr[0];
<a name="l00373"></a>00373 }
<a name="l00374"></a>00374 
<a name="l00375"></a>00375 <span class="comment">// Calcul de vx += alpha * vy</span>
<a name="l00376"></a>00376 <span class="comment">// Valeur de retour: somme locale sur ce processeur des vx[i]*vx[i] (apres ajout)</span>
<a name="l00377"></a>00377 <span class="comment">// Attention: pas code pour les items communs</span>
<a name="l00378"></a><a class="code" href="Solv__GCP_8cpp.html#a39937d853c6c6660fb5193a686ace132">00378</a> <span class="keyword">static</span> <span class="keywordtype">double</span> <a class="code" href="Solv__GCP_8cpp.html#a39937d853c6c6660fb5193a686ace132">ajoute_alpha_v_norme</a>(<a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; vx, <span class="keywordtype">double</span> alpha, <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; vy)
<a name="l00379"></a>00379 {
<a name="l00380"></a>00380   <span class="keywordtype">int</span> n = vx.<a class="code" href="classDoubleVect.html#a392c1f20b462563365389d28e0853867" title="Identique a size_reelle()">size</a>();
<a name="l00381"></a>00381   assert(vy.<a class="code" href="classDoubleVect.html#a392c1f20b462563365389d28e0853867" title="Identique a size_reelle()">size</a>() == n);
<a name="l00382"></a>00382   <span class="keywordtype">double</span> *x_ptr = vx.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
<a name="l00383"></a>00383   <span class="keywordtype">double</span> *y_ptr = vy.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
<a name="l00384"></a>00384   <span class="keywordtype">double</span> norme1 = 0., norme2 = 0.;
<a name="l00385"></a>00385   <span class="keywordflow">for</span> (n = n - 1; n &gt; 0; n -= 2, x_ptr += 2, y_ptr += 2)
<a name="l00386"></a>00386     {
<a name="l00387"></a>00387       <span class="keywordtype">double</span> a = x_ptr[0] + alpha * y_ptr[0];
<a name="l00388"></a>00388       <span class="keywordtype">double</span> b = x_ptr[1] + alpha * y_ptr[1];
<a name="l00389"></a>00389       x_ptr[0] = a;
<a name="l00390"></a>00390       x_ptr[1] = b;
<a name="l00391"></a>00391       norme1 += a * a;
<a name="l00392"></a>00392       norme2 += b * b;
<a name="l00393"></a>00393     }
<a name="l00394"></a>00394 <span class="comment">// n etait-il impair au depart ?</span>
<a name="l00395"></a>00395   <span class="keywordflow">if</span> (n == 0)
<a name="l00396"></a>00396     {
<a name="l00397"></a>00397       <span class="keywordtype">double</span> a = x_ptr[0] + alpha * y_ptr[0];
<a name="l00398"></a>00398       x_ptr[0] = a;
<a name="l00399"></a>00399       norme1 += a * a;
<a name="l00400"></a>00400     }
<a name="l00401"></a>00401   <span class="keywordflow">return</span> norme1 + norme2;
<a name="l00402"></a>00402 }
<a name="l00403"></a>00403 
<a name="l00404"></a><a class="code" href="classSolv__GCP.html#ab92ff464161604146fb820cdbf2079a1">00404</a> <span class="keywordtype">int</span> <a class="code" href="classSolv__GCP.html#ab92ff464161604146fb820cdbf2079a1">Solv_GCP::resoudre_</a>(<span class="keyword">const</span> <a class="code" href="classMatrice__Base.html">Matrice_Base</a>&amp; matrice,
<a name="l00405"></a>00405                         <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; secmem,
<a name="l00406"></a>00406                         <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; solution,
<a name="l00407"></a>00407                         <span class="keywordtype">int</span> nmax)
<a name="l00408"></a>00408 {
<a name="l00409"></a>00409   <span class="keyword">const</span> <span class="keywordtype">int</span> n_items_reels = solution.<a class="code" href="classDoubleVect.html#aafef4b3a96cdc428d62c5cedc9af6112">size_reelle_ok</a>() ? solution.<a class="code" href="classDoubleVect.html#a4a6987db458541cdcd10495955f25263" title="Taille de l&#39;espace &quot;reel&quot; du vecteur. (si md_vector_ est nul, cette valeur est identique a size_arr...">size_reelle</a>() : solution.<a class="code" href="classDoubleVect.html#ad2d21b364e1c6559771970596a25c006" title="Identique a size_array()">size_totale</a>();
<a name="l00410"></a>00410   {
<a name="l00411"></a>00411     <span class="keyword">const</span> <span class="keywordtype">int</span> nb_items_seq = solution.<a class="code" href="classDoubleVect.html#a0d16d30580c90526e4895388fb44be5d">get_md_vector</a>().<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a47d5867ac692b62645169eae6e2cafa0">nb_items_seq_tot</a>();
<a name="l00412"></a>00412     <span class="keyword">const</span> <span class="keywordtype">int</span> ls = secmem.<a class="code" href="classDoubleVect.html#ab02d01cd1bdab66fbd66f9a47cc29e10">line_size</a>();
<a name="l00413"></a>00413     <span class="keyword">const</span> <span class="keywordtype">int</span> nb_inco_tot = nb_items_seq * ls;
<a name="l00414"></a>00414     nmax = <a class="code" href="Double_8h.html#a1c45761573e6cbc97cfacac78d905016">max</a>(nb_inco_tot, nmax);
<a name="l00415"></a>00415   }
<a name="l00416"></a>00416 
<a name="l00417"></a>00417   <span class="keyword">const</span> <span class="keywordtype">int</span> avec_precond = <a class="code" href="classSolv__GCP.html#aa9aa7485970ae948b2561b89e141af13">le_precond_</a>.<a class="code" href="classO__U__Ptr.html#a16f216b2d169e885876419182658ddcc" title="Renvoie 1 si le pointeur est non_nul Renvoie 0 sinon.">non_nul</a>();
<a name="l00418"></a>00418   <span class="keyword">const</span> <span class="keywordtype">int</span> precond_requires_echange_espace_virtuel =
<a name="l00419"></a>00419     avec_precond &amp;&amp; (<a class="code" href="classSolv__GCP.html#aa9aa7485970ae948b2561b89e141af13">le_precond_</a>.<a class="code" href="classDeriv__Precond__base.html#a407e470c17d054ca8d60fbc025e6b72b">valeur</a>().<a class="code" href="classPrecond__base.html#a2f72ac102a2808186830135a6facc84b">get_flag_updated_input</a>());
<a name="l00420"></a>00420 
<a name="l00421"></a>00421   <span class="keyword">const</span> <span class="keywordtype">int</span> optimized = <a class="code" href="classSolv__GCP.html#a2de0798151556049240ddceaedcd2010">optimized_</a>;
<a name="l00422"></a>00422 
<a name="l00423"></a>00423   <span class="keywordflow">if</span> (optimized)
<a name="l00424"></a>00424     {
<a name="l00425"></a>00425       <a class="code" href="classSolv__GCP.html#aeb6006a337b824f7702dbd32084580a1">prepare_data</a>(matrice, secmem, solution);
<a name="l00426"></a>00426     }
<a name="l00427"></a>00427   <span class="keywordflow">else</span>
<a name="l00428"></a>00428     {
<a name="l00429"></a>00429       <a class="code" href="classSolv__GCP.html#a2dde6b48ed50f795d0df442e25543f24">resu_</a>.<a class="code" href="classDoubleVect.html#a990500e5bf63a8ca55fd833d111e135c" title="met l&#39;objet dans l&#39;etat obtenu par le constructeur par defaut. (voir ArrOfDouble::reset())">reset</a>();
<a name="l00430"></a>00430       <a class="code" href="classSolv__GCP.html#a491a6795972aa58d19e222211b70bb73">residu_</a>.<a class="code" href="classDoubleVect.html#a990500e5bf63a8ca55fd833d111e135c" title="met l&#39;objet dans l&#39;etat obtenu par le constructeur par defaut. (voir ArrOfDouble::reset())">reset</a>();
<a name="l00431"></a>00431       <a class="code" href="classSolv__GCP.html#af10441b3afc51b4e2a967a2f9c2e813e">tmp_p_avec_items_virt_</a>.<a class="code" href="classDoubleVect.html#a990500e5bf63a8ca55fd833d111e135c" title="met l&#39;objet dans l&#39;etat obtenu par le constructeur par defaut. (voir ArrOfDouble::reset())">reset</a>();
<a name="l00432"></a>00432       <a class="code" href="classSolv__GCP.html#a2dde6b48ed50f795d0df442e25543f24">resu_</a>.<a class="code" href="classDoubleVect.html#aaccfc72d49151e3105aba476fa9f414b" title="copie de la structure et des valeurs (si opt==COPY_INIT) du tableau v. Attention, v doit vraiment etr...">copy</a>(solution, <a class="code" href="classArray__base.html#abee342aa9ac59623c4c782dc9d7877ffaf6ae9ba7eb51c5f298ce693345b3ec68">Array_base::NOCOPY_NOINIT</a>);
<a name="l00433"></a>00433       <a class="code" href="classSolv__GCP.html#a491a6795972aa58d19e222211b70bb73">residu_</a>.<a class="code" href="classDoubleVect.html#aaccfc72d49151e3105aba476fa9f414b" title="copie de la structure et des valeurs (si opt==COPY_INIT) du tableau v. Attention, v doit vraiment etr...">copy</a>(solution, <a class="code" href="classArray__base.html#abee342aa9ac59623c4c782dc9d7877ffaf6ae9ba7eb51c5f298ce693345b3ec68">Array_base::NOCOPY_NOINIT</a>);
<a name="l00434"></a>00434       <a class="code" href="classSolv__GCP.html#af10441b3afc51b4e2a967a2f9c2e813e">tmp_p_avec_items_virt_</a>.<a class="code" href="classDoubleVect.html#aaccfc72d49151e3105aba476fa9f414b" title="copie de la structure et des valeurs (si opt==COPY_INIT) du tableau v. Attention, v doit vraiment etr...">copy</a>(solution, <a class="code" href="classArray__base.html#abee342aa9ac59623c4c782dc9d7877ffaf6ae9ba7eb51c5f298ce693345b3ec68">Array_base::NOCOPY_NOINIT</a>);
<a name="l00435"></a>00435       <a class="code" href="classSolv__GCP.html#a73cac6d4f308333325a0430590ebceec">tmp_p_</a>.<a class="code" href="classDoubleVect.html#a2b45ece955d7d57746fa32b5a6a89cc2" title="detache le tableau et l&#39;attache a v (sauf si v==*this, ne fait rien) Fait pointer le tableau sur la m...">ref</a>(<a class="code" href="classSolv__GCP.html#af10441b3afc51b4e2a967a2f9c2e813e">tmp_p_avec_items_virt_</a>);
<a name="l00436"></a>00436       <a class="code" href="classSolv__GCP.html#a3ee6d07baa401b83335a06036b8c9d4e">tmp_solution_</a>.<a class="code" href="classDoubleVect.html#a2b45ece955d7d57746fa32b5a6a89cc2" title="detache le tableau et l&#39;attache a v (sauf si v==*this, ne fait rien) Fait pointer le tableau sur la m...">ref</a>(solution);
<a name="l00437"></a>00437       <a class="code" href="classSolv__GCP.html#a2dde6b48ed50f795d0df442e25543f24">resu_</a>.<a class="code" href="classArrOfDouble.html#a2fcb2a2d3b59425c6cb37526ea6af6a3" title="Copie les elements source[first_element_source + i] dans les elements (*this)[first_element_dest + i]...">inject_array</a>(secmem);
<a name="l00438"></a>00438     }
<a name="l00439"></a>00439 
<a name="l00440"></a>00440   <a class="code" href="classSolv__GCP.html#af10441b3afc51b4e2a967a2f9c2e813e">tmp_p_avec_items_virt_</a>.<a class="code" href="classArrOfDouble.html#a2fcb2a2d3b59425c6cb37526ea6af6a3" title="Copie les elements source[first_element_source + i] dans les elements (*this)[first_element_dest + i]...">inject_array</a>(<a class="code" href="classSolv__GCP.html#a3ee6d07baa401b83335a06036b8c9d4e">tmp_solution_</a>, n_items_reels);
<a name="l00441"></a>00441   <a class="code" href="classSolv__GCP.html#af10441b3afc51b4e2a967a2f9c2e813e">tmp_p_avec_items_virt_</a>.<a class="code" href="classDoubleVect.html#abfebbc2f685ce7bc4b80c720d7da9bf3">echange_espace_virtuel</a>();
<a name="l00442"></a>00442 <span class="comment">// On n&#39;a pas besoin que residu ait son espace virtuel a jour</span>
<a name="l00443"></a>00443 <span class="comment">// En revanche, on a besoin de l&#39;espace virtuel de tmp_p_...</span>
<a name="l00444"></a>00444   <span class="keywordflow">if</span> (optimized)
<a name="l00445"></a>00445     {
<a name="l00446"></a>00446       <a class="code" href="classSolv__GCP.html#af90f523225473263ab3531630a418817">tmp_mat_</a>.<a class="code" href="classMatrice__Base.html#a8e710142a55d65a007a89e0ccc36ed62">multvect_</a>(<a class="code" href="classSolv__GCP.html#af10441b3afc51b4e2a967a2f9c2e813e">tmp_p_avec_items_virt_</a>, <a class="code" href="classSolv__GCP.html#a491a6795972aa58d19e222211b70bb73">residu_</a>);
<a name="l00447"></a>00447 <span class="comment">// calcul du produit, le produit scalaire n&#39;est pas utilise:</span>
<a name="l00448"></a>00448       <a class="code" href="classSolv__GCP.html#ab0dde9b547a7afdbb13329529c24f995">tmp_mat_virt_</a>.<a class="code" href="classMatrice__SuperMorse.html#ad818064b928adc13f9d986d11d4ff35a" title="Calcul de &quot;resu += MATRICE * x&quot; et d&#39;un produit scalaire (c&#39;est une brique de base pour le gradient...">ajouter_mult_vect_et_prodscal</a>(<a class="code" href="classSolv__GCP.html#af10441b3afc51b4e2a967a2f9c2e813e">tmp_p_avec_items_virt_</a>, <a class="code" href="classSolv__GCP.html#a491a6795972aa58d19e222211b70bb73">residu_</a>);
<a name="l00449"></a>00449     }
<a name="l00450"></a>00450   <span class="keywordflow">else</span>
<a name="l00451"></a>00451     {
<a name="l00452"></a>00452       matrice.<a class="code" href="classMatrice__Base.html#a05caa487a25a6d5e7fbd38d4b2f4ee1e" title="Multiplication d&#39;un vecteur par la matrice. Operation: r = A*x.">multvect</a>(<a class="code" href="classSolv__GCP.html#af10441b3afc51b4e2a967a2f9c2e813e">tmp_p_avec_items_virt_</a>, <a class="code" href="classSolv__GCP.html#a491a6795972aa58d19e222211b70bb73">residu_</a>);
<a name="l00453"></a>00453     }
<a name="l00454"></a>00454 <span class="comment">// ATTENTION: on suppose que secmem a ete copie dans resu_</span>
<a name="l00455"></a>00455   <a class="code" href="DoubleVect_8cpp.html#a813958fe17f5746cc80e1e21d0b10a6a">operator_sub</a>(<a class="code" href="classSolv__GCP.html#a491a6795972aa58d19e222211b70bb73">residu_</a>, <a class="code" href="classSolv__GCP.html#a2dde6b48ed50f795d0df442e25543f24">resu_</a>, <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caab47906d8d2e6c20f8ba32e4acb6edbe0">VECT_REAL_ITEMS</a>); <span class="comment">//!&lt; ne pas toucher a l&#39;espace virtuel</span>
<a name="l00456"></a>00456 <span class="comment"></span>
<a name="l00457"></a>00457   <span class="keywordflow">if</span> (avec_precond)
<a name="l00458"></a>00458     {
<a name="l00459"></a>00459       <span class="keywordflow">if</span> (precond_requires_echange_espace_virtuel)
<a name="l00460"></a>00460         <a class="code" href="classSolv__GCP.html#a491a6795972aa58d19e222211b70bb73">residu_</a>.<a class="code" href="classDoubleVect.html#abfebbc2f685ce7bc4b80c720d7da9bf3">echange_espace_virtuel</a>();
<a name="l00461"></a>00461 
<a name="l00462"></a>00462       <span class="keywordflow">if</span> (optimized)
<a name="l00463"></a>00463         <a class="code" href="classSolv__GCP.html#aa9aa7485970ae948b2561b89e141af13">le_precond_</a>.<a class="code" href="classDeriv__Precond__base.html#a407e470c17d054ca8d60fbc025e6b72b">valeur</a>().<a class="code" href="classPrecond__base.html#a20061d7ebbe45f61a6e2c65c723b3da3" title="Call to the prepare() method if reinit() has been called previously, then call to preconditionner_()...">preconditionner</a>(<a class="code" href="classSolv__GCP.html#af90f523225473263ab3531630a418817">tmp_mat_</a>, <a class="code" href="classSolv__GCP.html#a491a6795972aa58d19e222211b70bb73">residu_</a>, <a class="code" href="classSolv__GCP.html#a73cac6d4f308333325a0430590ebceec">tmp_p_</a>);
<a name="l00464"></a>00464       <span class="keywordflow">else</span>
<a name="l00465"></a>00465         <a class="code" href="classSolv__GCP.html#aa9aa7485970ae948b2561b89e141af13">le_precond_</a>.<a class="code" href="classDeriv__Precond__base.html#a407e470c17d054ca8d60fbc025e6b72b">valeur</a>().<a class="code" href="classPrecond__base.html#a20061d7ebbe45f61a6e2c65c723b3da3" title="Call to the prepare() method if reinit() has been called previously, then call to preconditionner_()...">preconditionner</a>(matrice, <a class="code" href="classSolv__GCP.html#a491a6795972aa58d19e222211b70bb73">residu_</a>, <a class="code" href="classSolv__GCP.html#a73cac6d4f308333325a0430590ebceec">tmp_p_</a>);
<a name="l00466"></a>00466 
<a name="l00467"></a>00467     }
<a name="l00468"></a>00468   <span class="keywordflow">else</span>
<a name="l00469"></a>00469     {
<a name="l00470"></a>00470       <a class="code" href="classSolv__GCP.html#a73cac6d4f308333325a0430590ebceec">tmp_p_</a>.<a class="code" href="classArrOfDouble.html#a2fcb2a2d3b59425c6cb37526ea6af6a3" title="Copie les elements source[first_element_source + i] dans les elements (*this)[first_element_dest + i]...">inject_array</a>(<a class="code" href="classSolv__GCP.html#a491a6795972aa58d19e222211b70bb73">residu_</a>, n_items_reels);
<a name="l00471"></a>00471     }
<a name="l00472"></a>00472   <span class="keywordtype">double</span> dold = <a class="code" href="DoubleVect_8cpp.html#a07d13cbdadca6b60d5e128653f52a4bb">mp_prodscal</a>(<a class="code" href="classSolv__GCP.html#a491a6795972aa58d19e222211b70bb73">residu_</a>, <a class="code" href="classSolv__GCP.html#a73cac6d4f308333325a0430590ebceec">tmp_p_</a>);
<a name="l00473"></a>00473 
<a name="l00474"></a>00474   <a class="code" href="DoubleVect_8cpp.html#a037eedbd9167441dbd379675d4b2fe55">operator_negate</a>(<a class="code" href="classSolv__GCP.html#a73cac6d4f308333325a0430590ebceec">tmp_p_</a>, <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caab47906d8d2e6c20f8ba32e4acb6edbe0">VECT_REAL_ITEMS</a>);
<a name="l00475"></a>00475 
<a name="l00476"></a>00476   <span class="keywordtype">double</span> <a class="code" href="Double_8h.html#ac842198e9490fae75825cab2a03eed2d">norme</a> = <a class="code" href="DoubleVect_8cpp.html#afaa33f0032aa927d8d54ff9fb002b749">mp_norme_vect</a>(<a class="code" href="classSolv__GCP.html#a491a6795972aa58d19e222211b70bb73">residu_</a>);
<a name="l00477"></a>00477   <span class="keywordtype">double</span> norme_b = <a class="code" href="DoubleVect_8cpp.html#afaa33f0032aa927d8d54ff9fb002b749">mp_norme_vect</a>(<a class="code" href="classSolv__GCP.html#a2dde6b48ed50f795d0df442e25543f24">resu_</a>);
<a name="l00478"></a>00478 
<a name="l00479"></a>00479   <span class="keywordflow">if</span> (<a class="code" href="classSolveurSys__base.html#ab3ef68bcf4e1b402c52905aa78728aef">limpr</a>()==1)
<a name="l00480"></a>00480     {
<a name="l00481"></a>00481       <span class="keywordtype">double</span> norme_relative=(norme_b&gt;<a class="code" href="Double_8h.html#a0a3fffa6d17ad8f7de4bb337c6266561">DMINFLOAT</a>?norme/(norme_b+<a class="code" href="Double_8h.html#a0a3fffa6d17ad8f7de4bb337c6266561">DMINFLOAT</a>):norme);
<a name="l00482"></a>00482       <a class="code" href="EntreeSortie_8h.html#a1007c2f57f1c8fc7334a3f62aab08414">Cout</a> &lt;&lt; <span class="stringliteral">&quot;Norm of the residue: &quot;</span> &lt;&lt; norme &lt;&lt; <span class="stringliteral">&quot; (&quot;</span> &lt;&lt; norme_relative &lt;&lt; <span class="stringliteral">&quot;)&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
<a name="l00483"></a>00483     }
<a name="l00484"></a>00484   <span class="keywordtype">int</span> niter = 0;
<a name="l00485"></a>00485   <span class="keywordtype">int</span> nb_it_max=nmax;
<a name="l00486"></a>00486   <span class="keywordflow">if</span> (<a class="code" href="classSolv__GCP.html#a468e7aef13e89875aa96874a3cc3e0f7">nb_it_max_</a>&gt;-1)
<a name="l00487"></a>00487     nb_it_max=<a class="code" href="classSolv__GCP.html#a468e7aef13e89875aa96874a3cc3e0f7">nb_it_max_</a>;
<a name="l00488"></a>00488   <span class="keywordflow">while</span> ( ( norme &gt; <a class="code" href="classsolv__iteratif.html#a726974e9a0579e0c242606430dc320d4">seuil_</a> ) &amp;&amp; (niter++ &lt; nmax) &amp;&amp;( niter&lt;nb_it_max))
<a name="l00489"></a>00489     {
<a name="l00490"></a>00490 <span class="comment">// Precondition pour multvect</span>
<a name="l00491"></a>00491 <span class="comment">// (le seul echange espace virtuel de l&#39;algo sauf si le precond en a besoin)</span>
<a name="l00492"></a>00492       <a class="code" href="classSolv__GCP.html#af10441b3afc51b4e2a967a2f9c2e813e">tmp_p_avec_items_virt_</a>.<a class="code" href="classDoubleVect.html#abfebbc2f685ce7bc4b80c720d7da9bf3">echange_espace_virtuel</a>();
<a name="l00493"></a>00493 <span class="comment">// En revanche, on n&#39;a pas besoin de l&#39;espace virtuel a jour de resu:</span>
<a name="l00494"></a>00494       <span class="keywordtype">double</span> resu_scalaire_p_local;
<a name="l00495"></a>00495       <span class="keywordflow">if</span> (optimized)
<a name="l00496"></a>00496         {
<a name="l00497"></a>00497           resu_scalaire_p_local = <a class="code" href="classSolv__GCP.html#af90f523225473263ab3531630a418817">tmp_mat_</a>.<a class="code" href="classMatrice__Morse__Sym.html#a32f04eb58027168900262c381afc7c89">multvect_et_prodscal</a>(<a class="code" href="classSolv__GCP.html#af10441b3afc51b4e2a967a2f9c2e813e">tmp_p_avec_items_virt_</a>, <a class="code" href="classSolv__GCP.html#a2dde6b48ed50f795d0df442e25543f24">resu_</a>);
<a name="l00498"></a>00498           resu_scalaire_p_local += <a class="code" href="classSolv__GCP.html#ab0dde9b547a7afdbb13329529c24f995">tmp_mat_virt_</a>.<a class="code" href="classMatrice__SuperMorse.html#ad818064b928adc13f9d986d11d4ff35a" title="Calcul de &quot;resu += MATRICE * x&quot; et d&#39;un produit scalaire (c&#39;est une brique de base pour le gradient...">ajouter_mult_vect_et_prodscal</a>(<a class="code" href="classSolv__GCP.html#af10441b3afc51b4e2a967a2f9c2e813e">tmp_p_avec_items_virt_</a>, <a class="code" href="classSolv__GCP.html#a2dde6b48ed50f795d0df442e25543f24">resu_</a>);
<a name="l00499"></a>00499         }
<a name="l00500"></a>00500       <span class="keywordflow">else</span>
<a name="l00501"></a>00501         {
<a name="l00502"></a>00502           matrice.<a class="code" href="classMatrice__Base.html#a05caa487a25a6d5e7fbd38d4b2f4ee1e" title="Multiplication d&#39;un vecteur par la matrice. Operation: r = A*x.">multvect</a>(<a class="code" href="classSolv__GCP.html#af10441b3afc51b4e2a967a2f9c2e813e">tmp_p_avec_items_virt_</a>, <a class="code" href="classSolv__GCP.html#a2dde6b48ed50f795d0df442e25543f24">resu_</a>);
<a name="l00503"></a>00503           resu_scalaire_p_local = <a class="code" href="DoubleVect_8cpp.html#acbe5711639fbfe2e85d5f87bf81f851a" title="Renvoie la somme des x[i]*y[i] pour les items sequentiels sur ce processeur. (tous les items si pas d...">local_prodscal</a>(<a class="code" href="classSolv__GCP.html#a2dde6b48ed50f795d0df442e25543f24">resu_</a>, <a class="code" href="classSolv__GCP.html#af10441b3afc51b4e2a967a2f9c2e813e">tmp_p_avec_items_virt_</a>);
<a name="l00504"></a>00504         }
<a name="l00505"></a>00505       <span class="keyword">const</span> <span class="keywordtype">double</span> resu_scalaire_p = <a class="code" href="classProcess.html#a7d23bc1ef94b3f0623fbc79d034c27fd" title="Calcule la somme de x sur tous les processeurs du groupe courant. Voir aussi mp_max()">mp_sum</a>(resu_scalaire_p_local);
<a name="l00506"></a>00506       <span class="keyword">const</span> <span class="keywordtype">double</span> alfa = dold / resu_scalaire_p;
<a name="l00507"></a>00507       <a class="code" href="DoubleVect_8cpp.html#a3cf7911dc14efcacd03f9915978b2b88">ajoute_alpha_v</a>(<a class="code" href="classSolv__GCP.html#a3ee6d07baa401b83335a06036b8c9d4e">tmp_solution_</a>, alfa, <a class="code" href="classSolv__GCP.html#a73cac6d4f308333325a0430590ebceec">tmp_p_</a>, <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caab47906d8d2e6c20f8ba32e4acb6edbe0">VECT_REAL_ITEMS</a>);
<a name="l00508"></a>00508 
<a name="l00509"></a>00509       <span class="keywordtype">double</span> norme_residu_locale;
<a name="l00510"></a>00510       <span class="keywordflow">if</span> (optimized)
<a name="l00511"></a>00511         {
<a name="l00512"></a>00512           norme_residu_locale = <a class="code" href="Solv__GCP_8cpp.html#a39937d853c6c6660fb5193a686ace132">ajoute_alpha_v_norme</a>(<a class="code" href="classSolv__GCP.html#a491a6795972aa58d19e222211b70bb73">residu_</a>, alfa, <a class="code" href="classSolv__GCP.html#a2dde6b48ed50f795d0df442e25543f24">resu_</a>);
<a name="l00513"></a>00513         }
<a name="l00514"></a>00514       <span class="keywordflow">else</span>
<a name="l00515"></a>00515         {
<a name="l00516"></a>00516           <a class="code" href="DoubleVect_8cpp.html#a3cf7911dc14efcacd03f9915978b2b88">ajoute_alpha_v</a>(<a class="code" href="classSolv__GCP.html#a491a6795972aa58d19e222211b70bb73">residu_</a>, alfa, <a class="code" href="classSolv__GCP.html#a2dde6b48ed50f795d0df442e25543f24">resu_</a>);
<a name="l00517"></a>00517           norme_residu_locale = <a class="code" href="DoubleVect_8cpp.html#aec1f3fbee9c49f94ac517feea6a8d6ed">local_carre_norme_vect</a>(<a class="code" href="classSolv__GCP.html#a491a6795972aa58d19e222211b70bb73">residu_</a>);
<a name="l00518"></a>00518         }
<a name="l00519"></a>00519 
<a name="l00520"></a>00520       <span class="keywordflow">if</span>(avec_precond)
<a name="l00521"></a>00521         {
<a name="l00522"></a>00522           <span class="keywordflow">if</span> (precond_requires_echange_espace_virtuel)
<a name="l00523"></a>00523             <a class="code" href="classSolv__GCP.html#a491a6795972aa58d19e222211b70bb73">residu_</a>.<a class="code" href="classDoubleVect.html#abfebbc2f685ce7bc4b80c720d7da9bf3">echange_espace_virtuel</a>();
<a name="l00524"></a>00524           <span class="keywordflow">if</span> (optimized)
<a name="l00525"></a>00525             <a class="code" href="classSolv__GCP.html#aa9aa7485970ae948b2561b89e141af13">le_precond_</a>.<a class="code" href="classDeriv__Precond__base.html#a407e470c17d054ca8d60fbc025e6b72b">valeur</a>().<a class="code" href="classPrecond__base.html#a20061d7ebbe45f61a6e2c65c723b3da3" title="Call to the prepare() method if reinit() has been called previously, then call to preconditionner_()...">preconditionner</a>(<a class="code" href="classSolv__GCP.html#af90f523225473263ab3531630a418817">tmp_mat_</a>, <a class="code" href="classSolv__GCP.html#a491a6795972aa58d19e222211b70bb73">residu_</a>, <a class="code" href="classSolv__GCP.html#a2dde6b48ed50f795d0df442e25543f24">resu_</a>);
<a name="l00526"></a>00526           <span class="keywordflow">else</span>
<a name="l00527"></a>00527             <a class="code" href="classSolv__GCP.html#aa9aa7485970ae948b2561b89e141af13">le_precond_</a>.<a class="code" href="classDeriv__Precond__base.html#a407e470c17d054ca8d60fbc025e6b72b">valeur</a>().<a class="code" href="classPrecond__base.html#a20061d7ebbe45f61a6e2c65c723b3da3" title="Call to the prepare() method if reinit() has been called previously, then call to preconditionner_()...">preconditionner</a>(matrice, <a class="code" href="classSolv__GCP.html#a491a6795972aa58d19e222211b70bb73">residu_</a>, <a class="code" href="classSolv__GCP.html#a2dde6b48ed50f795d0df442e25543f24">resu_</a>);
<a name="l00528"></a>00528 
<a name="l00529"></a>00529           <span class="keywordtype">double</span> residu_scalaire_resu = <a class="code" href="DoubleVect_8cpp.html#acbe5711639fbfe2e85d5f87bf81f851a" title="Renvoie la somme des x[i]*y[i] pour les items sequentiels sur ce processeur. (tous les items si pas d...">local_prodscal</a>(<a class="code" href="classSolv__GCP.html#a491a6795972aa58d19e222211b70bb73">residu_</a>, <a class="code" href="classSolv__GCP.html#a2dde6b48ed50f795d0df442e25543f24">resu_</a>);
<a name="l00530"></a>00530           norme = norme_residu_locale;
<a name="l00531"></a>00531 <span class="comment">// optimisation: on calcule en une seule fois les deux sommes</span>
<a name="l00532"></a>00532           <a class="code" href="communications_8cpp.html#af63556e6cd8ba837d64821d5e66a090e">mpsum_multiple</a>(residu_scalaire_resu, norme);
<a name="l00533"></a>00533           assert(residu_scalaire_resu &gt;= 0);
<a name="l00534"></a>00534           <a class="code" href="Solv__GCP_8cpp.html#ab5770466cce112d525bb5d526fec71cd">multiply_sub</a>(<a class="code" href="classSolv__GCP.html#a73cac6d4f308333325a0430590ebceec">tmp_p_</a>, <a class="code" href="classSolv__GCP.html#a2dde6b48ed50f795d0df442e25543f24">resu_</a>, residu_scalaire_resu / dold);
<a name="l00535"></a>00535           dold = residu_scalaire_resu;
<a name="l00536"></a>00536         }
<a name="l00537"></a>00537       <span class="keywordflow">else</span>
<a name="l00538"></a>00538         {
<a name="l00539"></a>00539           <span class="keyword">const</span> <span class="keywordtype">double</span> dnew = <a class="code" href="DoubleVect_8cpp.html#aab5110c88e5f7519eb6b7e603130b702">mp_carre_norme_vect</a>(<a class="code" href="classSolv__GCP.html#a491a6795972aa58d19e222211b70bb73">residu_</a>);
<a name="l00540"></a>00540           norme = <a class="code" href="classProcess.html#a7d23bc1ef94b3f0623fbc79d034c27fd" title="Calcule la somme de x sur tous les processeurs du groupe courant. Voir aussi mp_max()">mp_sum</a>(norme_residu_locale);
<a name="l00541"></a>00541           assert(dnew &gt;= 0);
<a name="l00542"></a>00542           <a class="code" href="Solv__GCP_8cpp.html#ab5770466cce112d525bb5d526fec71cd">multiply_sub</a>(<a class="code" href="classSolv__GCP.html#a73cac6d4f308333325a0430590ebceec">tmp_p_</a>, <a class="code" href="classSolv__GCP.html#a491a6795972aa58d19e222211b70bb73">residu_</a>, dnew / dold);
<a name="l00543"></a>00543           dold = dnew;
<a name="l00544"></a>00544         }
<a name="l00545"></a>00545       norme = sqrt(norme);
<a name="l00546"></a>00546 
<a name="l00547"></a>00547       <span class="keywordflow">if</span> (<a class="code" href="classSolveurSys__base.html#ab3ef68bcf4e1b402c52905aa78728aef">limpr</a>()==1)
<a name="l00548"></a>00548         {
<a name="l00549"></a>00549           <a class="code" href="EntreeSortie_8h.html#a1007c2f57f1c8fc7334a3f62aab08414">Cout</a> &lt;&lt; norme &lt;&lt; <span class="stringliteral">&quot; &quot;</span>;
<a name="l00550"></a>00550           <span class="keywordflow">if</span> ((niter % 15) == 0) <a class="code" href="EntreeSortie_8h.html#a1007c2f57f1c8fc7334a3f62aab08414">Cout</a> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a> ;
<a name="l00551"></a>00551         }
<a name="l00552"></a>00552     }
<a name="l00553"></a>00553   <span class="keywordflow">if</span> ((<a class="code" href="classSolv__GCP.html#a468e7aef13e89875aa96874a3cc3e0f7">nb_it_max_</a>&lt;0)&amp;&amp; (norme &gt; <a class="code" href="classsolv__iteratif.html#a726974e9a0579e0c242606430dc320d4">seuil_</a>))
<a name="l00554"></a>00554     {
<a name="l00555"></a>00555       <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;No convergence after : &quot;</span> &lt;&lt; niter &lt;&lt; <span class="stringliteral">&quot; iterations\n&quot;</span>;
<a name="l00556"></a>00556       <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot; Residue : &quot;</span>&lt;&lt; norme &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;
<a name="l00557"></a>00557       <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot; threshold : &quot;</span>&lt;&lt; <a class="code" href="classsolv__iteratif.html#a726974e9a0579e0c242606430dc320d4">seuil_</a> &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;
<a name="l00558"></a>00558       <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Change your data set.&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
<a name="l00559"></a>00559       <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">exit</a>();
<a name="l00560"></a>00560     }
<a name="l00561"></a>00561 
<a name="l00562"></a>00562   <span class="keywordflow">if</span> (optimized)
<a name="l00563"></a>00563     solution.<a class="code" href="classArrOfDouble.html#a2fcb2a2d3b59425c6cb37526ea6af6a3" title="Copie les elements source[first_element_source + i] dans les elements (*this)[first_element_dest + i]...">inject_array</a>(<a class="code" href="classSolv__GCP.html#a3ee6d07baa401b83335a06036b8c9d4e">tmp_solution_</a>, n_items_reels);
<a name="l00564"></a>00564 
<a name="l00565"></a>00565 <span class="comment">// The user wants a result with updated virtual space:</span>
<a name="l00566"></a>00566   <span class="keywordflow">if</span> (<a class="code" href="classSolveurSys__base.html#a338dcdf8a39dba544729c2ffd96ae37f">get_flag_updated_result</a>())
<a name="l00567"></a>00567     solution.<a class="code" href="classDoubleVect.html#abfebbc2f685ce7bc4b80c720d7da9bf3">echange_espace_virtuel</a>();
<a name="l00568"></a>00568 
<a name="l00569"></a>00569 <span class="comment">// On affiche quand meme le nombre d&#39;iterations</span>
<a name="l00570"></a>00570   <span class="keywordflow">if</span> (<a class="code" href="classSolveurSys__base.html#ab3ef68bcf4e1b402c52905aa78728aef">limpr</a>()&gt;-1)
<a name="l00571"></a>00571     {
<a name="l00572"></a>00572       <span class="keywordtype">double</span> norme_relative=(norme_b&gt;0?norme/(norme_b+<a class="code" href="Double_8h.html#a0a3fffa6d17ad8f7de4bb337c6266561">DMINFLOAT</a>):norme);
<a name="l00573"></a>00573       <a class="code" href="EntreeSortie_8h.html#a1007c2f57f1c8fc7334a3f62aab08414">Cout</a> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
<a name="l00574"></a>00574       <a class="code" href="EntreeSortie_8h.html#a1007c2f57f1c8fc7334a3f62aab08414">Cout</a> &lt;&lt; <span class="stringliteral">&quot;Final residue: &quot;</span> &lt;&lt; norme &lt;&lt; <span class="stringliteral">&quot; ( &quot;</span> &lt;&lt; norme_relative &lt;&lt; <span class="stringliteral">&quot; )&quot;</span>&lt;&lt;finl;
<a name="l00575"></a>00575     }
<a name="l00576"></a>00576   <span class="keywordflow">return</span>(niter);
<a name="l00577"></a>00577 
<a name="l00578"></a>00578 }
<a name="l00579"></a>00579 
<a name="l00580"></a>00580 
<a name="l00581"></a>00581 
<a name="l00582"></a>00582 
</pre></div></div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Tue Dec 14 2021 19:35:23 for TRUST by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
