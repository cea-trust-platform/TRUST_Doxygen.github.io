<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>TRUST: ArrOfInt Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">TRUST&#160;<span id="projectnumber">1.8.4</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a>  </div>
  <div class="headertitle">
<div class="title">ArrOfInt Class Reference</div>  </div>
</div>
<div class="contents">
<!-- doxytag: class="ArrOfInt" --><!-- doxytag: inherits="Array_base" -->
<p>Represente un tableau d'elements de type int.<br/>
L'etat du tableau est caracterise par la valeur de p_ et de data_ :<br/>
* detache : on a alors p_==0, data_==0, size_array_==0<br/>
(etat obtenu par le constructeur par defaut, <a class="el" href="classArrOfInt.html#adb53e0eaa4b61a4b5d68a620c8548543" title="Amene le tableau dans l&#39;etat &quot;detache&quot;. C&#39;est a dire: Si le tableau est &quot;detache&quot; : * ne rien faire...">detach_array()</a><br/>
et resize_array(0) dans certains cas)<br/>
* normal : alors p pointe vers une structure Vdbldata, data_==p-&gt;data_<br/>
et size_array_ &lt;= p-&gt;size_. A la destruction du tableau, si<br/>
p-&gt;ref_count_ est nul on libere la memoire.<br/>
data_ n'est pas nul.<br/>
L'espace memoire du tableau peut etre partage entre plusieurs<br/>
<a class="el" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> (le pointeur "p" pointe alors sur une meme structure).<br/>
Ce type de tableau est produit par <a class="el" href="classArrOfInt.html#acdd0214cc8f6c95882e5032b9e3121ea" title="Fait pointer le tableau vers les memes donnees qu&#39;un tableau existant. Le tableau sera du meme type q...">ref_array()</a>.<br/>
Le dernier <a class="el" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> a utiliser une zone de memoire<br/>
la detruit lorsqu'il a fini (voir <a class="el" href="classArrOfInt.html#adb53e0eaa4b61a4b5d68a620c8548543" title="Amene le tableau dans l&#39;etat &quot;detache&quot;. C&#39;est a dire: Si le tableau est &quot;detache&quot; : * ne rien faire...">detach_array()</a>)<br/>
Si smart_resize_==0, alors on a toujours size_array_==p-&gt;size_.<br/>
* ref_data : p_==0, data_ pointe vers un tableau existant, la memoire<br/>
n'est pas liberee a la destruction du <a class="el" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>.<br/>
Ces tableaux sont obtenus par appel a ref_data(...) et peuvent servir<br/>
pour importer un tableau fourni par une routine exterieure (C ou fortran)<br/>
Valeur initiale par defaut : voir "fill_default_value".<br/>
Priere de supposer desormais que les tableaux ne sont pas initialises<br/>
par defaut.  
 <a href="classArrOfInt.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="ArrOfInt_8h_source.html">ArrOfInt.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for ArrOfInt:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classArrOfInt.png" usemap="#ArrOfInt_map" alt=""/>
  <map id="ArrOfInt_map" name="ArrOfInt_map">
<area href="classArray__base.html" title=": classe vide servant de base a tous les tableaux. (permet de passer un type generique quel que soit ..." alt="Array_base" shape="rect" coords="44,112,123,136"/>
<area href="classObjet__U.html" title="classe Objet_U Cette classe est la classe de base des Objets de TRUST Dans les classes derivees de Ob..." alt="Objet_U" shape="rect" coords="44,56,123,80"/>
<area href="classProcess.html" title="Classe de base de TRUST (notamment Objet_U). Elle fournit quelques services de base accessibles de pa..." alt="Process" shape="rect" coords="44,0,123,24"/>
<area href="classEsp__Dist.html" title="Espace distant utilise pour la gestion des tableaux distribues Cette classe permet de decrire un espa..." alt="Esp_Dist" shape="rect" coords="0,224,79,248"/>
<area href="classIntVect.html" alt="IntVect" shape="rect" coords="89,224,168,248"/>
<area href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co..." alt="IntTab" shape="rect" coords="89,280,168,304"/>
<area href="classIntTrav.html" title="Tableau de travail a n entrees pour n&lt;= 4 C&#39;est un IntTab avec allocation dans un pool de memoire gere..." alt="IntTrav" shape="rect" coords="89,336,168,360"/>
</map>
 </div></div>

<p><a href="classArrOfInt-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArrOfInt.html#ae96e99b17332a05cd91a09a2b6bb3cc4">Storage</a> { <a class="el" href="classArrOfInt.html#ae96e99b17332a05cd91a09a2b6bb3cc4a9ec717f02c48a617afb247b79eb7a22b">STANDARD</a>, 
<a class="el" href="classArrOfInt.html#ae96e99b17332a05cd91a09a2b6bb3cc4ae7040d434081b185c65b1d0809121028">TEMP_STORAGE</a>
 }</td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArrOfInt.html#a52bfe11d364b9b9a9e9618f77856790f">taille_memoire</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArrOfInt.html#a4b418607bdfcf48c3bc8a5b554db7ee1">duplique</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classType__info.html">Type_info</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArrOfInt.html#a7dd6de7c430472331cf0d42d2c1dac9e">get_info</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Donne des informations sur le type de l'Objet_U.  <a href="#a7dd6de7c430472331cf0d42d2c1dac9e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArrOfInt.html#a47022c3b385b094563e5a38cfbf02434">~ArrOfInt</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructeur : appelle <a class="el" href="classArrOfInt.html#adb53e0eaa4b61a4b5d68a620c8548543" title="Amene le tableau dans l&#39;etat &quot;detache&quot;. C&#39;est a dire: Si le tableau est &quot;detache&quot; : * ne rien faire...">detach_array()</a>  <a href="#a47022c3b385b094563e5a38cfbf02434"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArrOfInt.html#ae1e83ae894ba984f578438b4b94fd52c">ArrOfInt</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructeur par defaut: cree un tableau "detache",<br/>
soit p_==0, data_==0, size_array_==0, smart_resize_==0.  <a href="#ae1e83ae894ba984f578438b4b94fd52c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArrOfInt.html#aa23f80b82702c98155cbf2121952b95c">ArrOfInt</a> (int size)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Cree un tableau de taille n avec allocation standard (voir set_mem_storage).<br/>
Le tableau est rempli avec zero par defaut. Pour creer un tableau non initialise, utiliser:<br/>
<a class="el" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> toto;<br/>
toto.resize_array(n, NOCOPY_NOINIT);<br/>
Parametre: int n<br/>
Signification: taille du tableau.  <a href="#aa23f80b82702c98155cbf2121952b95c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArrOfInt.html#a45db258aab6f8e2ee9b5c21967529dab">ArrOfInt</a> (const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructeur par copie. On alloue une nouvelle zone de memoire<br/>
et on copie le contenu du tableau (il s'agit d'un "deep copy").<br/>
L'attribut smart_resize_ est copie aussi.<br/>
Si le tableau A est de taille nulle, on cree un tableau "detache",<br/>
sinon on cree un tableau "normal".<br/>
Parametre: const <a class="el" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; A<br/>
Signification: le tableau a copier.  <a href="#a45db258aab6f8e2ee9b5c21967529dab"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArrOfInt.html#a9b3afbb46b16870dbd36236c8935b535">resize_array</a> (int new_size, <a class="el" href="classArray__base.html#abee342aa9ac59623c4c782dc9d7877ff">Array_base::Resize_Options</a> opt=COPY_INIT)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArrOfInt.html#a15fc7e3958f02cb38d3106eeb919f6fc">resize</a> (int new_size, <a class="el" href="classArray__base.html#abee342aa9ac59623c4c782dc9d7877ff">Array_base::Resize_Options</a> opt=COPY_INIT)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">appel a <a class="el" href="classArrOfInt.html#a9b3afbb46b16870dbd36236c8935b535">ArrOfInt::resize_array()</a>  <a href="#a15fc7e3958f02cb38d3106eeb919f6fc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArrOfInt.html#a2a8d5b9b592390c7d54d54742977d200">resize_tab</a> (int n, <a class="el" href="classArray__base.html#abee342aa9ac59623c4c782dc9d7877ff">Array_base::Resize_Options</a> opt=COPY_INIT)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">methode virtuelle identique a <a class="el" href="classArrOfInt.html#a9b3afbb46b16870dbd36236c8935b535">resize_array()</a>, permet de traiter<br/>
de facon generique les ArrOf, Vect et Tab.<br/>
Si l'objet est de type <a class="el" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>, appel a resize_array(n)<br/>
Prerequis: le tableau doit etre "resizable" (voir <a class="el" href="classArrOfInt.html#a9b3afbb46b16870dbd36236c8935b535">resize_array()</a>).<br/>
S'il est d'un type derive (Vect ou Tab), il ne doit pas avoir de descripteur<br/>
parallele si la taille est effectivement modifiee.  <a href="#a2a8d5b9b592390c7d54d54742977d200"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArrOfInt.html#a22d744bcd452d039580d1d9186f02b4e">set_smart_resize</a> (int flag)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Change le mode l'allocation memoire: reallocation d'un tableau<br/>
a chaque changement de taille (flag = 0) ou reallocation<br/>
uniquement si la taille augmente et par doublement de la taille<br/>
du tableau (flag = 1).  <a href="#a22d744bcd452d039580d1d9186f02b4e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArrOfInt.html#a95dce3e5a03c189d89146d9fd34e8d07">set_mem_storage</a> (const <a class="el" href="classArrOfInt.html#ae96e99b17332a05cd91a09a2b6bb3cc4">Storage</a> storage)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Change le mode d'allocation memoire lors des resize&lt;br&gt;(voir VIntdata et Int_ptr_trav)<br/>
Exemple pour creer un tableau avec allocation temporaire:<br/>
<a class="el" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a> tab; // Creation d'un tableau vide<br/>
tab.set_mem_storage(TEMP_STORAGE); // Changement de mode d'allocation<br/>
tab.resize(n); // Allocation memoire.  <a href="#a95dce3e5a03c189d89146d9fd34e8d07"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classArrOfInt.html#ae96e99b17332a05cd91a09a2b6bb3cc4">Storage</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArrOfInt.html#ae2d3c83cd7eedc971a21de3f9f8afa9b">get_mem_storage</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Renvoie le mode d'allocation du tableau (qui sera utilise<br/>
lors du prochain resize si changement de taille).<br/>
(voir <a class="el" href="classVIntdata.html" title="VIntdata alloue une zone de memoire de la taille specifiee au constructeur, et libere la zone de memo...">VIntdata</a> et <a class="el" href="classInt__ptr__trav.html" title="Une zone de travail de la Memoire TRUST composee d&#39;elements de type int.">Int_ptr_trav</a>)  <a href="#ae2d3c83cd7eedc971a21de3f9f8afa9b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArrOfInt.html#a95b02281f2d3f210e463389ff7288169">ref_data</a> (int *ptr, int size)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Fait pointer le tableau vers la zone de memoire "data_".<br/>
On detache la zone de memoire existante. Le tableau devient<br/>
de type "ref_data". Attention : ptr doit etre non nul.<br/>
La taille est initialisee avec size.<br/>
Attention: methode virtuelle: dans les classes derivee, cette methode<br/>
initialise les structures pour creer un tableau sequentiel.<br/>
Pour faire une ref sur un tableau parallele utiliser <a class="el" href="classIntVect.html#a165455689c6d27ac93c9cf8823e47a0f" title="detache le tableau et l&#39;attache a v (sauf si v==*this, ne fait rien) Fait pointer le tableau sur la m...">IntVect::ref()</a><br/>
Parametre: int*<br/>
Signification: le tableau a recuperer. Si pointeur nul alors size<br/>
doit etre nulle aussi et le tableau reste detache<br/>
Parametre: int size<br/>
Signification: le nombre d'elements du tableau.  <a href="#a95b02281f2d3f210e463389ff7288169"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArrOfInt.html#acdd0214cc8f6c95882e5032b9e3121ea">ref_array</a> (<a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;, int start=0, int <a class="el" href="Nom_8cpp.html#a0e1ea19fb9fa7881d15d84eff4c090e1">sz</a>=-1)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Fait pointer le tableau vers les memes donnees qu'un tableau<br/>
existant. Le tableau sera du meme type que le tableau m ("detache",<br/>
"normal"). Le tableau m ne doit pas etre de type "ref_data"<br/>
Attention, le tableau source et *this sont ensuite figes (<a class="el" href="classArrOfInt.html#a9b3afbb46b16870dbd36236c8935b535">resize_array()</a><br/>
interdit).<br/>
Attention: methode virtuelle: dans les classes derivee, cette methode<br/>
initialise les structures pour creer un tableau sequentiel.<br/>
Parametre: const <a class="el" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; m<br/>
Signification: le tableau a referencer (pas de type "ref_data"<br/>
et different de *this !!!)  <a href="#acdd0214cc8f6c95882e5032b9e3121ea"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArrOfInt.html#a1851289f5b18738eebb6f909c65920ee">operator=</a> (const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copie les donnees du tableau m.<br/>
Si "m" n'a pas la meme taille que "*this", on fait un resize_array.<br/>
Ensuite, on copie les valeurs de "m" dans "*this".<br/>
Le type de tableau (methode d'allocation) n'est pas copie.  <a href="#a1851289f5b18738eebb6f909c65920ee"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArrOfInt.html#afc932bc1df352ead26b844dcb090dacc">reset</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Remet le tableau dans l'etat obtenu avec le constructeur par defaut<br/>
(libere la memoire mais conserve le mode d'allocation memoire actuel)  <a href="#afc932bc1df352ead26b844dcb090dacc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArrOfInt.html#a8969ecd1d929dcc1c92d23dec55c8eb9">operator=</a> (int valeur)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">x est affecte a toutes les cases  <a href="#a8969ecd1d929dcc1c92d23dec55c8eb9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArrOfInt.html#ac3668f9c049886746539a3ed7bce7723">operator[]</a> (int i)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">operateur [] retourne le ieme element du tableau  <a href="#ac3668f9c049886746539a3ed7bce7723"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const int &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArrOfInt.html#a52b456caab2e93cacaa85d246021886d">operator[]</a> (int i) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">operateur [] retourne le ieme element du tableau  <a href="#a52b456caab2e93cacaa85d246021886d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArrOfInt.html#a2db9e4cf7c9096344df4ad90567c9041">operator()</a> (int i)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">idem operator[]  <a href="#a2db9e4cf7c9096344df4ad90567c9041"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const int &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArrOfInt.html#afb78c76aae98f9874e23ebcb96680c07">operator()</a> (int i) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d">addr</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Renvoie un pointeur sur le premier element du tableau.<br/>
Le pointeur est nul si le tableau est "detache".<br/>
Attention, l'adresse peut changer apres un appel<br/>
a <a class="el" href="classArrOfInt.html#a9b3afbb46b16870dbd36236c8935b535">resize_array()</a>, ref_data, ref_array, ...  <a href="#ad0b31250e60cd9040ea60be55db73c3d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArrOfInt.html#a5347acb0e39041c22584f498d9ae7271">addr</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Renvoie un pointeur sur le premier element du tableau.<br/>
Le pointeur est nul si le tableau est "detache".  <a href="#a5347acb0e39041c22584f498d9ae7271"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d">size_array</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Renvoie la taille du tableau (nombre d'elements declares<br/>
a la construction ou a <a class="el" href="classArrOfInt.html#a9b3afbb46b16870dbd36236c8935b535">resize_array()</a>).<br/>
C'est le nombre d'elements accessibles a operator[].  <a href="#a0f41611fce0a58c3ef3409dc1af8904d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArrOfInt.html#a2e8671e0e07855965bbff4c59582f224">ref_count</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne le nombre de references des donnees du tableau<br/>
si le tableau est "normal", -1 s'il est "detache" ou "ref_data".  <a href="#a2e8671e0e07855965bbff4c59582f224"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArrOfInt.html#a3f39d0966599416e7b1f7cd8159d8d01">append_array</a> (int valeur)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Ajoute une case en fin de tableau et y stocke la "valeur".  <a href="#a3f39d0966599416e7b1f7cd8159d8d01"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArrOfInt.html#a0fa5723f68c75dde90b9c6d1718d198c">operator+=</a> (const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition case a case sur toutes les cases du tableau.  <a href="#a0fa5723f68c75dde90b9c6d1718d198c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArrOfInt.html#a260e2d376a27555b1e8844ec6519b642">operator+=</a> (const int)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">ajoute la meme valeur a toutes les cases du tableau  <a href="#a260e2d376a27555b1e8844ec6519b642"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArrOfInt.html#a4fddff7058410064187290e6bec6c68e">operator-=</a> (const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Soustraction case a case sur toutes les cases du tableau<br/>
Parametre: const <a class="el" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; y<br/>
Signification: tableau de meme taille que *this.  <a href="#a4fddff7058410064187290e6bec6c68e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArrOfInt.html#a8fceeab1bf0ed0df9ca13b151a3f8eba">operator-=</a> (const int)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">soustrait la meme valeur a toutes les cases  <a href="#a8fceeab1bf0ed0df9ca13b151a3f8eba"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArrOfInt.html#a195c644d98bf2da2fe4f8aede4e02262">inject_array</a> (const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;source, int nb_elements=-1, int first_element_dest=0, int first_element_source=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copie les elements source[first_element_source + i]<br/>
dans les elements (*this)[first_element_dest + i] pour 0 &lt;= i &lt; nb_elements<br/>
Les autres elements de (*this) sont inchanges.  <a href="#a195c644d98bf2da2fe4f8aede4e02262"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArrOfInt.html#ac97734ef5e8a98fb4bdfe1985a3ce803">copy_array</a> (const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">appelle operator=(a)  <a href="#ac97734ef5e8a98fb4bdfe1985a3ce803"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArrOfInt.html#af501756161df3f9d3812154f888bd64f">operator=</a> (const FArrOfInt &amp;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArrOfInt.html#abb0f48cf5a4be4b70edcc90baaebd521">ordonne_array</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Tri des valeurs du tableau dans l'ordre croissant.<br/>
La fonction utilisee est qsort de stdlib (elle est en n*log(n)).  <a href="#abb0f48cf5a4be4b70edcc90baaebd521"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArrOfInt.html#a62f590c7e6998144131b7dbd8eb9a2a1">array_trier_retirer_doublons</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Tri des valeurs du tableau dans l'ordre croissant et suppresion des doublons<br/>
La fonction utilisee est qsort de stdlib (elle est en n*log(n)).  <a href="#a62f590c7e6998144131b7dbd8eb9a2a1"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classObjet__U.html">Objet_U</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArrOfInt.html#a6d1fd6c3c7fed35dc75028c40a875c93">cree_instance</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classType__info.html">Type_info</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArrOfInt.html#a32f629b94dc0867e56395ba5eb316a9a">info</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Donne des informations sur le type de l'Objet_U.  <a href="#a32f629b94dc0867e56395ba5eb316a9a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArrOfInt.html#acb778cd9e23f16950cd99e0faac8d0b6">self_cast</a> (<a class="el" href="classObjet__U.html">Objet_U</a> &amp;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArrOfInt.html#a90c131eb221769da60d9bc77fa432bcb">self_cast</a> (const <a class="el" href="classObjet__U.html">Objet_U</a> &amp;)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">methode ajoutee pour caster en python  <a href="#a90c131eb221769da60d9bc77fa432bcb"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classType__info.html">Type_info</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArrOfInt.html#a008742084e91090da12686a49537843c">info_obj</a></td></tr>
<tr><td colspan="2"><h2><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classSortie.html">Sortie</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArrOfInt.html#a4d80731bc6ae7f1494dce3109b961771">printOn</a> (<a class="el" href="classSortie.html">Sortie</a> &amp;x) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Ecriture du tableau sur "os" :<br/>
ecrit le nombre d'elements suivi des valeurs du tableau.  <a href="#a4d80731bc6ae7f1494dce3109b961771"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classEntree.html">Entree</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArrOfInt.html#a20d8ed6b33d5090632359a10c7ff671c">readOn</a> (<a class="el" href="classEntree.html">Entree</a> &amp;)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Lecture d'un tableau dans un flot d'entree<br/>
Lit le nombre d'elements suivi des elements eux-memes.  <a href="#a20d8ed6b33d5090632359a10c7ff671c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArrOfInt.html#aaf31134feae9b3a836eaea860ce952bf">attach_array</a> (const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;a, int start=0, int size=-1)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Amene le tableau dans l'etat "normal", "detache" ou "ref_array"<br/>
en associant une sous-zone de memoire du tableau m, definie par start et size<br/>
Si size &lt; 0, on prend le tableau m jusqu'a la fin.  <a href="#aaf31134feae9b3a836eaea860ce952bf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArrOfInt.html#adb53e0eaa4b61a4b5d68a620c8548543">detach_array</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Amene le tableau dans l'etat "detache". C'est a dire:<br/>
Si le tableau est "detache" :<br/>
* ne rien faire<br/>
Si le tableau est "normal" :<br/>
* decremente le nombre de references a *p<br/>
* detruit *p si p-&gt;ref_count==0<br/>
* annule p_, data_ et size_array_<br/>
Si le tableau est "ref_data" :<br/>
* annule data_ et size_array_.  <a href="#adb53e0eaa4b61a4b5d68a620c8548543"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArrOfInt.html#acdeb6ce266ee43155b998f80a0f249e2">fill_default_value</a> (<a class="el" href="classArray__base.html#abee342aa9ac59623c4c782dc9d7877ff">Array_base::Resize_Options</a> opt, int first, int nb)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Remplit "nb" cases consecutives du tableau a partir de la case "first"<br/>
avec une valeur par defaut.<br/>
Cette fonction est appelee lors d'un resize pour initialiser les<br/>
cases nouvellement creees.<br/>
Le comportement depend actuellement du type de tableau :<br/>
* Tableau de type "smart_resize":<br/>
* en mode debug (macro NDEBUG non definie) le tableau est initialise<br/>
avec une valeur invalide.<br/>
* en optimise, le tableau n'est pas initialise<br/>
* Tableau normal :<br/>
Le tableau est initialise avec la valeur 0. Ce comportement est choisi<br/>
pour des raisons de compatibilite avec l'implementation precedente.<br/>
Cette specification pourrait etre modifiee prochainement pour des raisons<br/>
de performances (pour ne pas avoir a initialiser inutilement les tableaux).<br/>
DONC: il faut supposer desormais que les nouvelles cases ne sont pas<br/>
initialisees lors d'un resize.<br/>
Parametre: first<br/>
Signification: premiere case a initialiser.<br/>
Contrainte: (nb==0) ou (0 &lt;= first &lt; memory_size_)<br/>
Parametre: nb<br/>
Signification: nombre de cases a initialiser.<br/>
Contrainte: (nb==0) ou (0 &lt; nb &lt;= memory_size_ - first)  <a href="#acdeb6ce266ee43155b998f80a0f249e2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArrOfInt.html#a17a4f4f68e28465b89ef84180bb04406">resize_array_</a> (int n, <a class="el" href="classArray__base.html#abee342aa9ac59623c4c782dc9d7877ff">Array_base::Resize_Options</a> opt=COPY_INIT)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">methode protegee de changement de taille, appelable par<br/>
les classes derivees (idem que <a class="el" href="classArrOfInt.html#a9b3afbb46b16870dbd36236c8935b535">resize_array()</a> mais sans condition sur le<br/>
type derive de l'objet)  <a href="#a17a4f4f68e28465b89ef84180bb04406"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArrOfInt.html#a1bdac0af7218a7a9d6abf1709feffc17">memory_resize</a> (int new_size, <a class="el" href="classArray__base.html#abee342aa9ac59623c4c782dc9d7877ff">Array_base::Resize_Options</a> opt=COPY_INIT)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Si besoin, alloue une nouvelle zone de memoire,<br/>
copie les donnees et efface l'ancienne zone de memoire.<br/>
Attention, on suppose que cette methode est appelee par<br/>
<a class="el" href="classArrOfInt.html#a9b3afbb46b16870dbd36236c8935b535">resize_array()</a>.<br/>
Attention: si ref_count_&gt;1, l'appel a <a class="el" href="classArrOfInt.html#a9b3afbb46b16870dbd36236c8935b535">resize_array()</a> est<br/>
autorise uniquement si la nouvelle taille est identique<br/>
a la precedente (auquel cas on ne fait rien)<br/>
Si ref_count_ == 1, l'appel est invalide si p_-&gt;data_ est<br/>
different de data_ (le tableau a ete construit avec <a class="el" href="classArrOfInt.html#acdd0214cc8f6c95882e5032b9e3121ea" title="Fait pointer le tableau vers les memes donnees qu&#39;un tableau existant. Le tableau sera du meme type q...">ref_array()</a><br/>
avec start &gt; 0)  <a href="#a1bdac0af7218a7a9d6abf1709feffc17"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVIntdata.html">VIntdata</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArrOfInt.html#a54afaafbf7fa8c80696da7a2c3d3f48b">p_</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArrOfInt.html#ab799099ee6d316bdaad7d7f3e99f0637">data_</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArrOfInt.html#a23d1b6526fd584ba8de321ee7d1f1c1b">size_array_</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArrOfInt.html#a9cda25dd5c640c8523243990b6c0b845">memory_size_</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArrOfInt.html#a9170b6699fa2b83ccc8c9a451e18bd44">smart_resize_</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classArrOfInt.html#ae96e99b17332a05cd91a09a2b6bb3cc4">Storage</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArrOfInt.html#a5a5cbc9e1c2d4ba877ca0bd697ea56bc">storage_type_</a></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Represente un tableau d'elements de type int.<br/>
L'etat du tableau est caracterise par la valeur de p_ et de data_ :<br/>
* detache : on a alors p_==0, data_==0, size_array_==0<br/>
(etat obtenu par le constructeur par defaut, <a class="el" href="classArrOfInt.html#adb53e0eaa4b61a4b5d68a620c8548543" title="Amene le tableau dans l&#39;etat &quot;detache&quot;. C&#39;est a dire: Si le tableau est &quot;detache&quot; : * ne rien faire...">detach_array()</a><br/>
et resize_array(0) dans certains cas)<br/>
* normal : alors p pointe vers une structure Vdbldata, data_==p-&gt;data_<br/>
et size_array_ &lt;= p-&gt;size_. A la destruction du tableau, si<br/>
p-&gt;ref_count_ est nul on libere la memoire.<br/>
data_ n'est pas nul.<br/>
L'espace memoire du tableau peut etre partage entre plusieurs<br/>
<a class="el" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> (le pointeur "p" pointe alors sur une meme structure).<br/>
Ce type de tableau est produit par <a class="el" href="classArrOfInt.html#acdd0214cc8f6c95882e5032b9e3121ea" title="Fait pointer le tableau vers les memes donnees qu&#39;un tableau existant. Le tableau sera du meme type q...">ref_array()</a>.<br/>
Le dernier <a class="el" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> a utiliser une zone de memoire<br/>
la detruit lorsqu'il a fini (voir <a class="el" href="classArrOfInt.html#adb53e0eaa4b61a4b5d68a620c8548543" title="Amene le tableau dans l&#39;etat &quot;detache&quot;. C&#39;est a dire: Si le tableau est &quot;detache&quot; : * ne rien faire...">detach_array()</a>)<br/>
Si smart_resize_==0, alors on a toujours size_array_==p-&gt;size_.<br/>
* ref_data : p_==0, data_ pointe vers un tableau existant, la memoire<br/>
n'est pas liberee a la destruction du <a class="el" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>.<br/>
Ces tableaux sont obtenus par appel a ref_data(...) et peuvent servir<br/>
pour importer un tableau fourni par une routine exterieure (C ou fortran)<br/>
Valeur initiale par defaut : voir "fill_default_value".<br/>
Priere de supposer desormais que les tableaux ne sont pas initialises<br/>
par defaut. </p>

<p>Definition at line <a class="el" href="ArrOfInt_8h_source.html#l00071">71</a> of file <a class="el" href="ArrOfInt_8h_source.html">ArrOfInt.h</a>.</p>
</div><hr/><h2>Member Enumeration Documentation</h2>
<a class="anchor" id="ae96e99b17332a05cd91a09a2b6bb3cc4"></a><!-- doxytag: member="ArrOfInt::Storage" ref="ae96e99b17332a05cd91a09a2b6bb3cc4" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classArrOfInt.html#ae96e99b17332a05cd91a09a2b6bb3cc4">ArrOfInt::Storage</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="ae96e99b17332a05cd91a09a2b6bb3cc4a9ec717f02c48a617afb247b79eb7a22b"></a><!-- doxytag: member="STANDARD" ref="ae96e99b17332a05cd91a09a2b6bb3cc4a9ec717f02c48a617afb247b79eb7a22b" args="" -->STANDARD</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ae96e99b17332a05cd91a09a2b6bb3cc4ae7040d434081b185c65b1d0809121028"></a><!-- doxytag: member="TEMP_STORAGE" ref="ae96e99b17332a05cd91a09a2b6bb3cc4ae7040d434081b185c65b1d0809121028" args="" -->TEMP_STORAGE</em>&nbsp;</td><td>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="ArrOfInt_8h_source.html#l00101">101</a> of file <a class="el" href="ArrOfInt_8h_source.html">ArrOfInt.h</a>.</p>
<div class="fragment"><pre class="fragment">{ <a class="code" href="classArrOfInt.html#ae96e99b17332a05cd91a09a2b6bb3cc4a9ec717f02c48a617afb247b79eb7a22b">STANDARD</a>, <a class="code" href="classArrOfInt.html#ae96e99b17332a05cd91a09a2b6bb3cc4ae7040d434081b185c65b1d0809121028">TEMP_STORAGE</a> };
</pre></div>
</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a47022c3b385b094563e5a38cfbf02434"></a><!-- doxytag: member="ArrOfInt::~ArrOfInt" ref="a47022c3b385b094563e5a38cfbf02434" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ArrOfInt::~ArrOfInt </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Destructeur : appelle <a class="el" href="classArrOfInt.html#adb53e0eaa4b61a4b5d68a620c8548543" title="Amene le tableau dans l&#39;etat &quot;detache&quot;. C&#39;est a dire: Si le tableau est &quot;detache&quot; : * ne rien faire...">detach_array()</a> </p>

<p><p>&lt; Paranoia: si size_array_==-1, c'est un zombie </p>
</p>

<p>Definition at line <a class="el" href="ArrOfInt_8cpp_source.html#l00317">317</a> of file <a class="el" href="ArrOfInt_8cpp_source.html">ArrOfInt.cpp</a>.</p>

<p>References <a class="el" href="ArrOfInt_8cpp_source.html#l01002">detach_array()</a>, and <a class="el" href="ArrOfInt_8h_source.html#l00180">size_array_</a>.</p>
<div class="fragment"><pre class="fragment">{
  <a class="code" href="classArrOfInt.html#adb53e0eaa4b61a4b5d68a620c8548543" title="Amene le tableau dans l&#39;etat &quot;detache&quot;. C&#39;est a dire: Si le tableau est &quot;detache&quot; : * ne rien faire...">detach_array</a>();
  <a class="code" href="classArrOfInt.html#a23d1b6526fd584ba8de321ee7d1f1c1b">size_array_</a> = -1; <span class="comment">//!&lt; Paranoia: si size_array_==-1, c&#39;est un zombie</span>
<span class="comment"></span>}
</pre></div>
</div>
</div>
<a class="anchor" id="ae1e83ae894ba984f578438b4b94fd52c"></a><!-- doxytag: member="ArrOfInt::ArrOfInt" ref="ae1e83ae894ba984f578438b4b94fd52c" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ArrOfInt::ArrOfInt </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructeur par defaut: cree un tableau "detache",<br/>
soit p_==0, data_==0, size_array_==0, smart_resize_==0. </p>

<p>Definition at line <a class="el" href="ArrOfInt_8cpp_source.html#l00326">326</a> of file <a class="el" href="ArrOfInt_8cpp_source.html">ArrOfInt.cpp</a>.</p>
<div class="fragment"><pre class="fragment">                   :
  <a class="code" href="classArrOfInt.html#a54afaafbf7fa8c80696da7a2c3d3f48b">p_</a>(0),
  <a class="code" href="classArrOfInt.html#ab799099ee6d316bdaad7d7f3e99f0637">data_</a>(0),
  <a class="code" href="classArrOfInt.html#a23d1b6526fd584ba8de321ee7d1f1c1b">size_array_</a>(0),
  <a class="code" href="classArrOfInt.html#a9cda25dd5c640c8523243990b6c0b845">memory_size_</a>(0),
  <a class="code" href="classArrOfInt.html#a9170b6699fa2b83ccc8c9a451e18bd44">smart_resize_</a>(0),
  <a class="code" href="classArrOfInt.html#a5a5cbc9e1c2d4ba877ca0bd697ea56bc">storage_type_</a>(<a class="code" href="classArrOfInt.html#ae96e99b17332a05cd91a09a2b6bb3cc4a9ec717f02c48a617afb247b79eb7a22b">STANDARD</a>)
{
}
</pre></div>
</div>
</div>
<a class="anchor" id="aa23f80b82702c98155cbf2121952b95c"></a><!-- doxytag: member="ArrOfInt::ArrOfInt" ref="aa23f80b82702c98155cbf2121952b95c" args="(int size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ArrOfInt::ArrOfInt </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Cree un tableau de taille n avec allocation standard (voir set_mem_storage).<br/>
Le tableau est rempli avec zero par defaut. Pour creer un tableau non initialise, utiliser:<br/>
<a class="el" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> toto;<br/>
toto.resize_array(n, NOCOPY_NOINIT);<br/>
Parametre: int n<br/>
Signification: taille du tableau. </p>

<p>Definition at line <a class="el" href="ArrOfInt_8cpp_source.html#l00343">343</a> of file <a class="el" href="ArrOfInt_8cpp_source.html">ArrOfInt.cpp</a>.</p>

<p>References <a class="el" href="Array__base_8h_source.html#l00038">Array_base::COPY_INIT</a>, <a class="el" href="ArrOfInt_8h_source.html#l00176">data_</a>, <a class="el" href="ArrOfInt_8cpp_source.html#l00651">fill_default_value()</a>, <a class="el" href="ArrOfInt_8cpp_source.html#l00224">VIntdata::get_data()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00168">p_</a>, and <a class="el" href="ArrOfInt_8h_source.html#l00101">STANDARD</a>.</p>
<div class="fragment"><pre class="fragment">                        :
  <a class="code" href="classArrOfInt.html#a54afaafbf7fa8c80696da7a2c3d3f48b">p_</a>(0),
  <a class="code" href="classArrOfInt.html#ab799099ee6d316bdaad7d7f3e99f0637">data_</a>(0),
  <a class="code" href="classArrOfInt.html#a23d1b6526fd584ba8de321ee7d1f1c1b">size_array_</a>(n),
  <a class="code" href="classArrOfInt.html#a9cda25dd5c640c8523243990b6c0b845">memory_size_</a>(n),
  <a class="code" href="classArrOfInt.html#a9170b6699fa2b83ccc8c9a451e18bd44">smart_resize_</a>(0),
  <a class="code" href="classArrOfInt.html#a5a5cbc9e1c2d4ba877ca0bd697ea56bc">storage_type_</a>(<a class="code" href="classArrOfInt.html#ae96e99b17332a05cd91a09a2b6bb3cc4a9ec717f02c48a617afb247b79eb7a22b">STANDARD</a>)
{
  <span class="keywordflow">if</span> (n)
    {
      <a class="code" href="classArrOfInt.html#a54afaafbf7fa8c80696da7a2c3d3f48b">p_</a> = <span class="keyword">new</span> <a class="code" href="classVIntdata.html" title="VIntdata alloue une zone de memoire de la taille specifiee au constructeur, et libere la zone de memo...">VIntdata</a>(n, <a class="code" href="classArrOfInt.html#ae96e99b17332a05cd91a09a2b6bb3cc4a9ec717f02c48a617afb247b79eb7a22b">STANDARD</a>);
      <a class="code" href="classArrOfInt.html#ab799099ee6d316bdaad7d7f3e99f0637">data_</a> = <a class="code" href="classArrOfInt.html#a54afaafbf7fa8c80696da7a2c3d3f48b">p_</a>-&gt;<a class="code" href="classVIntdata.html#ad4a8ad27e706b36dcdfc05b4209fa41f" title="renvoie data_">get_data</a>();
      <a class="code" href="classArrOfInt.html#acdeb6ce266ee43155b998f80a0f249e2" title="Remplit &quot;nb&quot; cases consecutives du tableau a partir de la case &quot;first&quot; avec une valeur par defaut...">fill_default_value</a>(<a class="code" href="classArray__base.html#abee342aa9ac59623c4c782dc9d7877ffa9a675e25b5b7accff8d861e05060547b">COPY_INIT</a>, 0, n);
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a45db258aab6f8e2ee9b5c21967529dab"></a><!-- doxytag: member="ArrOfInt::ArrOfInt" ref="a45db258aab6f8e2ee9b5c21967529dab" args="(const ArrOfInt &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ArrOfInt::ArrOfInt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructeur par copie. On alloue une nouvelle zone de memoire<br/>
et on copie le contenu du tableau (il s'agit d'un "deep copy").<br/>
L'attribut smart_resize_ est copie aussi.<br/>
Si le tableau A est de taille nulle, on cree un tableau "detache",<br/>
sinon on cree un tableau "normal".<br/>
Parametre: const <a class="el" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; A<br/>
Signification: le tableau a copier. </p>

<p>Definition at line <a class="el" href="ArrOfInt_8cpp_source.html#l00391">391</a> of file <a class="el" href="ArrOfInt_8cpp_source.html">ArrOfInt.cpp</a>.</p>

<p>References <a class="el" href="ArrOfInt_8h_source.html#l00176">data_</a>, <a class="el" href="ArrOfInt_8cpp_source.html#l00224">VIntdata::get_data()</a>, <a class="el" href="ArrOfInt_8cpp_source.html#l01098">inject_array()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00185">memory_size_</a>, <a class="el" href="ArrOfInt_8h_source.html#l00168">p_</a>, <a class="el" href="ArrOfInt_8h_source.html#l00342">size_array()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00180">size_array_</a>, <a class="el" href="ArrOfInt_8h_source.html#l00191">smart_resize_</a>, <a class="el" href="ArrOfInt_8h_source.html#l00101">STANDARD</a>, and <a class="el" href="ArrOfInt_8h_source.html#l00195">storage_type_</a>.</p>
<div class="fragment"><pre class="fragment">                                   : <a class="code" href="classArray__base.html" title=": classe vide servant de base a tous les tableaux. (permet de passer un type generique quel que soit ...">Array_base</a>()
{
  <span class="keyword">const</span> <span class="keywordtype">int</span> size = A.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>();
  <span class="keywordflow">if</span> (size &gt; 0)
    {
<span class="comment">// Creation d&#39;un tableau &quot;normal&quot;</span>
      <a class="code" href="classArrOfInt.html#a5a5cbc9e1c2d4ba877ca0bd697ea56bc">storage_type_</a> = <a class="code" href="classArrOfInt.html#ae96e99b17332a05cd91a09a2b6bb3cc4a9ec717f02c48a617afb247b79eb7a22b">STANDARD</a>;
      <a class="code" href="classArrOfInt.html#a54afaafbf7fa8c80696da7a2c3d3f48b">p_</a> = <span class="keyword">new</span> <a class="code" href="classVIntdata.html" title="VIntdata alloue une zone de memoire de la taille specifiee au constructeur, et libere la zone de memo...">VIntdata</a>(size, <a class="code" href="classArrOfInt.html#ae96e99b17332a05cd91a09a2b6bb3cc4a9ec717f02c48a617afb247b79eb7a22b">STANDARD</a>);
      <a class="code" href="classArrOfInt.html#ab799099ee6d316bdaad7d7f3e99f0637">data_</a> = <a class="code" href="classArrOfInt.html#a54afaafbf7fa8c80696da7a2c3d3f48b">p_</a>-&gt;<a class="code" href="classVIntdata.html#ad4a8ad27e706b36dcdfc05b4209fa41f" title="renvoie data_">get_data</a>();
      <a class="code" href="classArrOfInt.html#a23d1b6526fd584ba8de321ee7d1f1c1b">size_array_</a> = size;
      <a class="code" href="classArrOfInt.html#a9cda25dd5c640c8523243990b6c0b845">memory_size_</a> = size;
      <a class="code" href="classArrOfInt.html#a9170b6699fa2b83ccc8c9a451e18bd44">smart_resize_</a> = A.<a class="code" href="classArrOfInt.html#a9170b6699fa2b83ccc8c9a451e18bd44">smart_resize_</a>;
      <a class="code" href="classArrOfInt.html#a195c644d98bf2da2fe4f8aede4e02262" title="Copie les elements source[first_element_source + i] dans les elements (*this)[first_element_dest + i]...">inject_array</a>(A);
    }
  <span class="keywordflow">else</span>
    {
<span class="comment">// Creation d&#39;un tableau &quot;detache&quot;</span>
      <a class="code" href="classArrOfInt.html#a54afaafbf7fa8c80696da7a2c3d3f48b">p_</a> = 0;
      <a class="code" href="classArrOfInt.html#ab799099ee6d316bdaad7d7f3e99f0637">data_</a> = 0;
      <a class="code" href="classArrOfInt.html#a23d1b6526fd584ba8de321ee7d1f1c1b">size_array_</a> = 0;
      <a class="code" href="classArrOfInt.html#a9cda25dd5c640c8523243990b6c0b845">memory_size_</a> = 0;
      <a class="code" href="classArrOfInt.html#a9170b6699fa2b83ccc8c9a451e18bd44">smart_resize_</a> = 0;
      <a class="code" href="classArrOfInt.html#a5a5cbc9e1c2d4ba877ca0bd697ea56bc">storage_type_</a> = <a class="code" href="classArrOfInt.html#ae96e99b17332a05cd91a09a2b6bb3cc4a9ec717f02c48a617afb247b79eb7a22b">STANDARD</a>;
    }
}
</pre></div>
</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="ad0b31250e60cd9040ea60be55db73c3d"></a><!-- doxytag: member="ArrOfInt::addr" ref="ad0b31250e60cd9040ea60be55db73c3d" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int * ArrOfInt::addr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Renvoie un pointeur sur le premier element du tableau.<br/>
Le pointeur est nul si le tableau est "detache".<br/>
Attention, l'adresse peut changer apres un appel<br/>
a <a class="el" href="classArrOfInt.html#a9b3afbb46b16870dbd36236c8935b535">resize_array()</a>, ref_data, ref_array, ... </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>const int*<br/>
 Signification: pointeur sur le premier element du tableau </dd></dl>

<p>Definition at line <a class="el" href="ArrOfInt_8h_source.html#l00371">371</a> of file <a class="el" href="ArrOfInt_8h_source.html">ArrOfInt.h</a>.</p>

<p>References <a class="el" href="ArrOfInt_8h_source.html#l00176">data_</a>.</p>

<p>Referenced by <a class="el" href="MD__Vector__std_8cpp_source.html#l00652">add_to_vect_blocs()</a>, <a class="el" href="MD__Vector__std_8cpp_source.html#l00413">add_to_vect_items()</a>, <a class="el" href="Convert__ICoCoTrioField_8cpp_source.html#l00039">affecte_int_avec_inttab()</a>, <a class="el" href="DoubleVect_8cpp_source.html#l01531">ajoute_alpha_v()</a>, <a class="el" href="DoubleVect_8cpp_source.html#l01594">ajoute_carre()</a>, <a class="el" href="DoubleVect_8cpp_source.html#l01657">ajoute_produit_scalaire()</a>, <a class="el" href="DoubleTab_8cpp_source.html#l00668">DoubleTab::ajoute_produit_tensoriel()</a>, <a class="el" href="Matrice__SuperMorse_8cpp_source.html#l00032">Matrice_SuperMorse::ajouter_mult_vect_et_prodscal()</a>, <a class="el" href="Matrice__Morse__Sym_8cpp_source.html#l00335">Matrice_Morse_Sym::ajouter_multvect_()</a>, <a class="el" href="Matrice__Morse_8cpp_source.html#l00936">Matrice_Morse::ajouter_multvect_()</a>, <a class="el" href="IntTab_8h_source.html#l00261">IntTab::append_line()</a>, <a class="el" href="SETS_8cpp_source.html#l00496">SETS::assembler()</a>, <a class="el" href="Domaine_8cpp_source.html#l00574">Domaine::buildUFacesMesh()</a>, <a class="el" href="DoubleVect_8cpp_source.html#l01782">carre()</a>, <a class="el" href="Scatter_8cpp_source.html#l02512">Scatter::Chercher_Correspondance()</a>, <a class="el" href="Solv__Cholesky_8cpp_source.html#l00143">Solv_Cholesky::Cholesky()</a>, <a class="el" href="interface__CALCULBIJ_8cpp_source.html#l00065">interface_CALCULBIJ::Compute()</a>, <a class="el" href="Partitionneur__Tranche_8cpp_source.html#l00185">Partitionneur_Tranche::construire_partition()</a>, <a class="el" href="Partitionneur__Ptscotch_8cpp_source.html#l00085">Partitionneur_Ptscotch::construire_partition()</a>, <a class="el" href="Partitionneur__Parmetis_8cpp_source.html#l00085">Partitionneur_Parmetis::construire_partition()</a>, <a class="el" href="Partitionneur__Metis_8cpp_source.html#l00136">Partitionneur_Metis::construire_partition()</a>, <a class="el" href="SSOR_8cpp_source.html#l00179">descente()</a>, <a class="el" href="SSOR_8cpp_source.html#l00411">descente_assert()</a>, <a class="el" href="SSOR_8cpp_source.html#l01239">descente_assert_precond_diag()</a>, <a class="el" href="SSOR_8cpp_source.html#l00461">descente_bloc_extradiag_assert()</a>, <a class="el" href="SSOR_8cpp_source.html#l00793">descente_diag_ok_assert()</a>, <a class="el" href="SSOR_8cpp_source.html#l01025">descente_precond_diag()</a>, <a class="el" href="Matrice__Morse_8cpp_source.html#l00864">Matrice_Morse::diagmulmat()</a>, <a class="el" href="Zone__CoviMAC_8cpp_source.html#l00610">disp_ia()</a>, <a class="el" href="Zone__CoviMAC_8cpp_source.html#l00599">disp_it()</a>, <a class="el" href="Zone__CoviMAC_8cpp_source.html#l00618">disp_m()</a>, <a class="el" href="Debog_8cpp_source.html#l00956">Debog_Pb::ecrire_partie()</a>, <a class="el" href="DomaineCutter_8cpp_source.html#l01268">DomaineCutter::ecrire_zones()</a>, <a class="el" href="communications_8cpp_source.html#l00473">envoyer_all_to_all()</a>, <a class="el" href="Schema__Comm_8cpp_source.html#l00179">exchange_data()</a>, <a class="el" href="ILU_8cpp_source.html#l00126">ILU::factoriser()</a>, <a class="el" href="MD__Vector__tools_8cpp_source.html#l00240">get_seq_flags()</a>, <a class="el" href="ILU_8cpp_source.html#l00269">ILU::ilu()</a>, <a class="el" href="ILU_8cpp_source.html#l00275">ILU::ilut()</a>, <a class="el" href="Scatter_8cpp_source.html#l01561">Traduction_Indice_Global_Local::initialiser()</a>, <a class="el" href="ArrOfInt_8cpp_source.html#l01098">inject_array()</a>, <a class="el" href="Decouper__multi_8cpp_source.html#l00093">Decouper_multi::interpreter()</a>, <a class="el" href="Lire__Ideas_8cpp_source.html#l00042">Lire_Ideas::interpreter_()</a>, <a class="el" href="IntVect_8cpp_source.html#l00367">invalidate_data()</a>, <a class="el" href="Matrice__Morse_8cpp_source.html#l01184">Matrice_Morse::inverse()</a>, <a class="el" href="Matrice__Dense_8cpp_source.html#l00377">Matrice_Dense::inverse()</a>, <a class="el" href="SolvElem__Gmres_8h_source.html#l00044">SolvElem_Gmres::iteration()</a>, <a class="el" href="SolvElem__BiCGStab_8h_source.html#l00044">SolvElem_BiCGStab::iteration()</a>, <a class="el" href="Matrice__Morse_8cpp_source.html#l02281">Matrice_Morse::largeur_de_bande()</a>, <a class="el" href="Champ__Fonc__MED_8cpp_source.html#l00313">Champ_Fonc_MED::lire()</a>, <a class="el" href="IntVect_8cpp_source.html#l00297">IntVect::lit()</a>, <a class="el" href="DoubleVect_8cpp_source.html#l00481">local_carre_norme_vect()</a>, <a class="el" href="DoubleVect_8cpp_source.html#l00716">local_imax_vect()</a>, <a class="el" href="DoubleVect_8cpp_source.html#l00603">local_imin_vect()</a>, <a class="el" href="DoubleVect_8cpp_source.html#l00829">local_max_abs_vect()</a>, <a class="el" href="DoubleVect_8cpp_source.html#l00773">local_max_vect()</a>, <a class="el" href="DoubleVect_8cpp_source.html#l00886">local_min_abs_vect()</a>, <a class="el" href="DoubleVect_8cpp_source.html#l00660">local_min_vect()</a>, <a class="el" href="DoubleVect_8cpp_source.html#l00419">local_prodscal()</a>, <a class="el" href="DoubleVect_8cpp_source.html#l00541">local_somme_vect()</a>, <a class="el" href="MD__Vector__std_8cpp_source.html#l00457">max_to_vect_items()</a>, <a class="el" href="Chimie_8cpp_source.html#l00200">Chimie::mettre_a_jour()</a>, <a class="el" href="MD__Vector__std_8cpp_source.html#l00503">mincol1_to_vect_items()</a>, <a class="el" href="communications_8cpp_source.html#l00629">mp_collective_op()</a>, <a class="el" href="Matrice__Morse__Sym_8cpp_source.html#l00266">Matrice_Morse_Sym::multvect_et_prodscal()</a>, <a class="el" href="Assembleur__P__VEFPreP1B_8cpp_source.html#l01117">operation01()</a>, <a class="el" href="Assembleur__P__VEFPreP1B_8cpp_source.html#l01018">operation11()</a>, <a class="el" href="Matrice__Morse_8cpp_source.html#l01117">operator+()</a>, <a class="el" href="ArrOfInt_8cpp_source.html#l00686">operator==()</a>, <a class="el" href="DoubleVect_8cpp_source.html#l00943">operator_abs()</a>, <a class="el" href="DoubleVect_8cpp_source.html#l00999">operator_add()</a>, <a class="el" href="DoubleVect_8cpp_source.html#l01838">operator_divide()</a>, <a class="el" href="DoubleVect_8cpp_source.html#l01412">operator_egal()</a>, <a class="el" href="DoubleVect_8cpp_source.html#l01902">operator_inverse()</a>, <a class="el" href="DoubleVect_8cpp_source.html#l01237">operator_multiply()</a>, <a class="el" href="DoubleVect_8cpp_source.html#l01356">operator_negate()</a>, <a class="el" href="DoubleVect_8cpp_source.html#l01118">operator_sub()</a>, <a class="el" href="IntTab_8cpp_source.html#l00046">IntTab::printOn()</a>, <a class="el" href="DoubleVect_8cpp_source.html#l01726">racine_carree()</a>, <a class="el" href="MD__Vector__std_8cpp_source.html#l00558">read_from_vect_blocs()</a>, <a class="el" href="MD__Vector__std_8cpp_source.html#l00325">read_from_vect_items()</a>, <a class="el" href="SSOR_8cpp_source.html#l00227">remontee()</a>, <a class="el" href="SSOR_8cpp_source.html#l00494">remontee_assert()</a>, <a class="el" href="SSOR_8cpp_source.html#l01283">remontee_assert_precond_diag()</a>, <a class="el" href="SSOR_8cpp_source.html#l00552">remontee_bloc_extradiag_assert()</a>, <a class="el" href="SSOR_8cpp_source.html#l00841">remontee_diag_ok_assert()</a>, <a class="el" href="SSOR_8cpp_source.html#l01069">remontee_precond_diag()</a>, <a class="el" href="Matrice__Morse_8cpp_source.html#l02068">Matrice_Morse::remplir()</a>, <a class="el" href="Matrice__Bloc_8cpp_source.html#l00676">Matrice_Bloc::remplir()</a>, <a class="el" href="Matrice__Morse__Sym_8cpp_source.html#l00988">Matrice_Morse_Sym::renumerote()</a>, <a class="el" href="Solv__Petsc_8cpp_source.html#l01553">Solv_Petsc::resoudre_systeme()</a>, <a class="el" href="DoubleVect_8cpp_source.html#l02029">tab_divide_any_shape_()</a>, <a class="el" href="DoubleVect_8cpp_source.html#l01959">tab_multiply_any_shape_()</a>, <a class="el" href="SSOR_8cpp_source.html#l00161">traite_diagonale()</a>, <a class="el" href="Array__tools_8cpp_source.html#l00237">tri_lexicographique_tableau()</a>, <a class="el" href="Array__tools_8cpp_source.html#l00342">tri_lexicographique_tableau_indirect()</a>, <a class="el" href="Partitionneur__Tranche_8cpp_source.html#l00110">trier_index_colonne_i()</a>, <a class="el" href="Debog_8cpp_source.html#l01018">Debog_Pb::verifier_partie_std()</a>, <a class="el" href="Format__Post__Lata_8cpp_source.html#l00417">Format_Post_Lata::write_inttab()</a>, <a class="el" href="MD__Vector__std_8cpp_source.html#l00605">write_to_vect_blocs()</a>, and <a class="el" href="MD__Vector__std_8cpp_source.html#l00369">write_to_vect_items()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">return</span> <a class="code" href="classArrOfInt.html#ab799099ee6d316bdaad7d7f3e99f0637">data_</a>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a5347acb0e39041c22584f498d9ae7271"></a><!-- doxytag: member="ArrOfInt::addr" ref="a5347acb0e39041c22584f498d9ae7271" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int * ArrOfInt::addr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Renvoie un pointeur sur le premier element du tableau.<br/>
Le pointeur est nul si le tableau est "detache". </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>const int*<br/>
 Signification: la zone memoire du tableau </dd></dl>

<p>Definition at line <a class="el" href="ArrOfInt_8h_source.html#l00382">382</a> of file <a class="el" href="ArrOfInt_8h_source.html">ArrOfInt.h</a>.</p>

<p>References <a class="el" href="ArrOfInt_8h_source.html#l00176">data_</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">return</span> <a class="code" href="classArrOfInt.html#ab799099ee6d316bdaad7d7f3e99f0637">data_</a>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a3f39d0966599416e7b1f7cd8159d8d01"></a><!-- doxytag: member="ArrOfInt::append_array" ref="a3f39d0966599416e7b1f7cd8159d8d01" args="(int valeur)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ArrOfInt::append_array </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>valeur</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Ajoute une case en fin de tableau et y stocke la "valeur". </p>

<p>Definition at line <a class="el" href="ArrOfInt_8h_source.html#l00355">355</a> of file <a class="el" href="ArrOfInt_8h_source.html">ArrOfInt.h</a>.</p>

<p>References <a class="el" href="Array__base_8h_source.html#l00038">Array_base::COPY_NOINIT</a>, <a class="el" href="ArrOfInt_8h_source.html#l00176">data_</a>, <a class="el" href="ArrOfInt_8h_source.html#l00240">resize_array()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00180">size_array_</a>, <a class="el" href="ArrOfInt_8h_source.html#l00191">smart_resize_</a>, and <a class="el" href="Source__Generique__Face__PolyMAC_8cpp_source.html#l00045">valeur()</a>.</p>

<p>Referenced by <a class="el" href="Schema__Comm__Vecteurs_8h_source.html#l00128">Schema_Comm_Vecteurs::add()</a>, <a class="el" href="Objet__a__lire_8cpp_source.html#l00155">Objet_a_lire::add_dict()</a>, <a class="el" href="MD__Vector__composite_8cpp_source.html#l00307">MD_Vector_composite::add_part()</a>, <a class="el" href="Sonde_8cpp_source.html#l01493">Sonde::ajouter_bords()</a>, <a class="el" href="Scatter_8cpp_source.html#l01151">Scatter::ajouter_joints()</a>, <a class="el" href="MD__Vector__composite_8cpp_source.html#l00136">append_global_md()</a>, <a class="el" href="MD__Vector__base2_8h_source.html#l00092">MD_Vector_base2::append_item_to_blocs()</a>, <a class="el" href="Polygone_8cpp_source.html#l00092">Polygone::build_reduced()</a>, <a class="el" href="Polyedre_8cpp_source.html#l00649">Polyedre::build_reduced()</a>, <a class="el" href="Scatter_8cpp_source.html#l00937">Scatter::calculer_espace_distant()</a>, <a class="el" href="Scatter_8cpp_source.html#l02184">Scatter::calculer_espace_distant_elements()</a>, <a class="el" href="Scatter_8cpp_source.html#l01219">calculer_espace_distant_item()</a>, <a class="el" href="Scatter_8cpp_source.html#l01929">calculer_liste_complete_aretes_joint()</a>, <a class="el" href="Scatter_8cpp_source.html#l01899">calculer_liste_complete_sommets_joint()</a>, <a class="el" href="Scatter_8cpp_source.html#l00297">Scatter::check_consistancy_remote_items()</a>, <a class="el" href="Raccord__distant__homogene_8cpp_source.html#l00237">Raccord_distant_homogene::completer()</a>, <a class="el" href="DomaineCutter_8cpp_source.html#l00517">DomaineCutter::construire_elements_distants_ssdom()</a>, <a class="el" href="DomaineCutter_8cpp_source.html#l00736">DomaineCutter::construire_faces_joints_ssdom()</a>, <a class="el" href="DomaineCutter_8cpp_source.html#l00245">construire_liste_faces_sous_domaine()</a>, <a class="el" href="Scatter_8cpp_source.html#l01409">Scatter::construire_md_vector()</a>, <a class="el" href="Partitionneur__Tranche_8cpp_source.html#l00185">Partitionneur_Tranche::construire_partition()</a>, <a class="el" href="DomaineCutter_8cpp_source.html#l00643">DomaineCutter::construire_sommets_joints_ssdom()</a>, <a class="el" href="Scatter_8cpp_source.html#l02035">Scatter::corriger_espace_distant_elements_perio()</a>, <a class="el" href="Partitionneur__base_8cpp_source.html#l00260">Partitionneur_base::corriger_sommets_bord()</a>, <a class="el" href="Faces__builder_8cpp_source.html#l00940">Zone::creer_aretes()</a>, <a class="el" href="Faces__builder_8cpp_source.html#l00414">Faces_builder::creer_faces_frontiere()</a>, <a class="el" href="Faces__builder_8cpp_source.html#l00562">Faces_builder::creer_faces_internes()</a>, <a class="el" href="MD__Vector__tools_8cpp_source.html#l00341">creer_md_vect_renum()</a>, <a class="el" href="DomaineCutter_8cpp_source.html#l01268">DomaineCutter::ecrire_zones()</a>, <a class="el" href="MD__Vector__tools_8cpp_source.html#l00302">extract_blocs()</a>, <a class="el" href="Domaine__bord_8cpp_source.html#l00109">Domaine_bord::extraire_domaine_bord()</a>, <a class="el" href="Octree__Zone_8cpp_source.html#l00055">Octree_Zone::find_elements()</a>, <a class="el" href="MaillerParallel_8cpp_source.html#l00232">find_matching_coordinates()</a>, <a class="el" href="Raccord__distant__homogene_8cpp_source.html#l00267">Raccord_distant_homogene::initialise()</a>, <a class="el" href="Champ__front__recyclage_8cpp_source.html#l00472">Champ_front_recyclage::initialiser()</a>, <a class="el" href="Create__domain__from__sous__zone_8cpp_source.html#l00045">Create_domain_from_sous_zone::interpreter_()</a>, <a class="el" href="Scatter_8cpp_source.html#l00463">Scatter::mergeDomains()</a>, <a class="el" href="DomaineCutter_8cpp_source.html#l00432">parcourir_epaisseurs_elements()</a>, <a class="el" href="Champ__Fonc__MED_8cpp_source.html#l00077">Champ_Fonc_MED::readOn()</a>, <a class="el" href="Raffiner__Simplexes_8cpp_source.html#l00788">Raffiner_Simplexes::refine_domain()</a>, <a class="el" href="Scatter_8cpp_source.html#l01807">Scatter::reordonner_faces_de_joint()</a>, <a class="el" href="Connex__components_8cpp_source.html#l00048">search_connex_components_local()</a>, and <a class="el" href="Octree__Int_8cpp_source.html#l00209">Octree_Int::search_elements_box_floor()</a>.</p>
<div class="fragment"><pre class="fragment">{
  assert(<a class="code" href="classArrOfInt.html#a9170b6699fa2b83ccc8c9a451e18bd44">smart_resize_</a>);
  <span class="keyword">const</span> <span class="keywordtype">int</span> n = <a class="code" href="classArrOfInt.html#a23d1b6526fd584ba8de321ee7d1f1c1b">size_array_</a>;
  <a class="code" href="classArrOfInt.html#a9b3afbb46b16870dbd36236c8935b535">resize_array</a>(<a class="code" href="classArrOfInt.html#a23d1b6526fd584ba8de321ee7d1f1c1b">size_array_</a>+1, <a class="code" href="classArray__base.html#abee342aa9ac59623c4c782dc9d7877ffac85954f9768f1ed2b14e58cea8ddb7c5">COPY_NOINIT</a>);
  <a class="code" href="classArrOfInt.html#ab799099ee6d316bdaad7d7f3e99f0637">data_</a>[n] = <a class="code" href="Source__Generique__Face__PolyMAC_8cpp.html#a7d7b5d77a3caa1af70f5e1c9108de5a1">valeur</a>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a62f590c7e6998144131b7dbd8eb9a2a1"></a><!-- doxytag: member="ArrOfInt::array_trier_retirer_doublons" ref="a62f590c7e6998144131b7dbd8eb9a2a1" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ArrOfInt::array_trier_retirer_doublons </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Tri des valeurs du tableau dans l'ordre croissant et suppresion des doublons<br/>
La fonction utilisee est qsort de stdlib (elle est en n*log(n)). </p>

<p>Definition at line <a class="el" href="ArrOfInt_8cpp_source.html#l00911">911</a> of file <a class="el" href="ArrOfInt_8cpp_source.html">ArrOfInt.cpp</a>.</p>

<p>References <a class="el" href="ArrOfInt_8h_source.html#l00176">data_</a>, <a class="el" href="ArrOfInt_8cpp_source.html#l00897">ordonne_array()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00240">resize_array()</a>, and <a class="el" href="ArrOfInt_8h_source.html#l00180">size_array_</a>.</p>

<p>Referenced by <a class="el" href="Scatter_8cpp_source.html#l00463">Scatter::mergeDomains()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">const</span> <span class="keywordtype">int</span> size_ = <a class="code" href="classArrOfInt.html#a23d1b6526fd584ba8de321ee7d1f1c1b">size_array_</a>;
  <span class="keywordflow">if</span> (size_ &lt;= 0)
    <span class="keywordflow">return</span>;
<span class="comment">// Tri dans l&#39;ordre croissant</span>
  <a class="code" href="classArrOfInt.html#abb0f48cf5a4be4b70edcc90baaebd521" title="Tri des valeurs du tableau dans l&#39;ordre croissant. La fonction utilisee est qsort de stdlib (elle est...">ordonne_array</a>();
<span class="comment">// Retire les doublons (codage optimise en pointeurs)</span>
  <span class="keywordtype">int</span> last_value = *<a class="code" href="classArrOfInt.html#ab799099ee6d316bdaad7d7f3e99f0637">data_</a>;
  <span class="keywordtype">int</span> *src = <a class="code" href="classArrOfInt.html#ab799099ee6d316bdaad7d7f3e99f0637">data_</a> + 1;
  <span class="keywordtype">int</span> *dest = <a class="code" href="classArrOfInt.html#ab799099ee6d316bdaad7d7f3e99f0637">data_</a> + 1;
  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = size_ - 1; i != 0; i--)
    {
      <span class="keywordtype">int</span> x = *(src++);
      <span class="keywordflow">if</span> (x != last_value)
        {
          *(dest++) = x;
          last_value = x;
        }
    }
  <span class="keywordtype">int</span> new_size_ = dest - <a class="code" href="classArrOfInt.html#ab799099ee6d316bdaad7d7f3e99f0637">data_</a>;
  <a class="code" href="classArrOfInt.html#a9b3afbb46b16870dbd36236c8935b535">resize_array</a>(new_size_);
}
</pre></div>
</div>
</div>
<a class="anchor" id="aaf31134feae9b3a836eaea860ce952bf"></a><!-- doxytag: member="ArrOfInt::attach_array" ref="aaf31134feae9b3a836eaea860ce952bf" args="(const ArrOfInt &amp;a, int start=0, int size=&#45;1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ArrOfInt::attach_array </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>start</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Amene le tableau dans l'etat "normal", "detache" ou "ref_array"<br/>
en associant une sous-zone de memoire du tableau m, definie par start et size<br/>
Si size &lt; 0, on prend le tableau m jusqu'a la fin. </p>

<p>Definition at line <a class="el" href="ArrOfInt_8cpp_source.html#l01042">1042</a> of file <a class="el" href="ArrOfInt_8cpp_source.html">ArrOfInt.cpp</a>.</p>

<p>References <a class="el" href="ArrOfInt_8cpp_source.html#l00205">VIntdata::add_one_ref()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00176">data_</a>, <a class="el" href="ArrOfInt_8h_source.html#l00185">memory_size_</a>, <a class="el" href="ArrOfInt_8h_source.html#l00168">p_</a>, <a class="el" href="ArrOfInt_8h_source.html#l00342">size_array()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00180">size_array_</a>, and <a class="el" href="ArrOfInt_8h_source.html#l00191">smart_resize_</a>.</p>

<p>Referenced by <a class="el" href="IntVect_8cpp_source.html#l00132">IntVect::ref()</a>, and <a class="el" href="ArrOfInt_8cpp_source.html#l00952">ref_array()</a>.</p>
<div class="fragment"><pre class="fragment">{
<span class="comment">// Le tableau doit etre detache</span>
  assert(<a class="code" href="classArrOfInt.html#ab799099ee6d316bdaad7d7f3e99f0637">data_</a> == 0 &amp;&amp; <a class="code" href="classArrOfInt.html#a54afaafbf7fa8c80696da7a2c3d3f48b">p_</a> == 0);
<span class="comment">// Le tableau doit etre different de *this</span>
  assert(&amp;m != <span class="keyword">this</span>);
  <span class="keywordflow">if</span> (size &lt; 0)
    size = m.size_array_ - start;
  assert(start &gt;= 0 &amp;&amp; size &gt;=0 &amp;&amp; start + size &lt;= m.size_array_);
  <span class="keywordflow">if</span> (m.size_array() &gt; 0)
    {
      <a class="code" href="classArrOfInt.html#a54afaafbf7fa8c80696da7a2c3d3f48b">p_</a> = m.p_;
      <span class="keywordflow">if</span> (<a class="code" href="classArrOfInt.html#a54afaafbf7fa8c80696da7a2c3d3f48b">p_</a>)
        <a class="code" href="classArrOfInt.html#a54afaafbf7fa8c80696da7a2c3d3f48b">p_</a>-&gt;<a class="code" href="classVIntdata.html#adf37ea61dd0f50a112f7b0e4a41463cb" title="Un nouveau tableau utilise cette zone memoire : incremente ref_count.">add_one_ref</a>();
      <a class="code" href="classArrOfInt.html#ab799099ee6d316bdaad7d7f3e99f0637">data_</a> = m.data_ + start;
      <a class="code" href="classArrOfInt.html#a23d1b6526fd584ba8de321ee7d1f1c1b">size_array_</a> = size;
      <a class="code" href="classArrOfInt.html#a9cda25dd5c640c8523243990b6c0b845">memory_size_</a> = m.memory_size_ - start;
      <a class="code" href="classArrOfInt.html#a9170b6699fa2b83ccc8c9a451e18bd44">smart_resize_</a> = m.smart_resize_;
    }
  <span class="keywordflow">else</span>
    {
<span class="comment">// Cas particulier ou on attache un tableau de taille nulle:</span>
<span class="comment">// en theorie, c&#39;est pareil qu&#39;un tableau de taille non nulle, MAIS</span>
<span class="comment">// dans les operateurs (ex:Op_Dift_VDF_Face_Axi), une ref est construite</span>
<span class="comment">// avant que le tableau ne prenne sa taille definitive. Donc, pour ne pas</span>
<span class="comment">// empecher le resize, il ne faut pas attacher le tableau s&#39;il n&#39;a pas</span>
<span class="comment">// encore la bonne taille. Solution propre: reecrire les operateurs pour</span>
<span class="comment">// qu&#39;ils ne prennent pas une ref avant que le tableau ne soit valide</span>
<span class="comment">// et faire p_ = m.p_ dans tous les cas.</span>
<span class="comment">// Process::Journal() &lt;&lt; &quot;Warning ArrOfInt::attach_array(m), m.size_array()==0, on n attache pas le tableau&quot; &lt;&lt; finl;</span>
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="ac97734ef5e8a98fb4bdfe1985a3ce803"></a><!-- doxytag: member="ArrOfInt::copy_array" ref="ac97734ef5e8a98fb4bdfe1985a3ce803" args="(const ArrOfInt &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp; ArrOfInt::copy_array </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>appelle operator=(a) </p>

<p>Definition at line <a class="el" href="ArrOfInt_8cpp_source.html#l00501">501</a> of file <a class="el" href="ArrOfInt_8cpp_source.html">ArrOfInt.cpp</a>.</p>

<p>References <a class="el" href="ArrOfInt_8cpp_source.html#l00468">operator=()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <a class="code" href="classArrOfInt.html#a1851289f5b18738eebb6f909c65920ee" title="Copie les donnees du tableau m. Si &quot;m&quot; n&#39;a pas la meme taille que &quot;*this&quot;, on fait un resize_arra...">operator=</a>(a);
  <span class="keywordflow">return</span> *<span class="keyword">this</span>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a6d1fd6c3c7fed35dc75028c40a875c93"></a><!-- doxytag: member="ArrOfInt::cree_instance" ref="a6d1fd6c3c7fed35dc75028c40a875c93" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classObjet__U.html">Objet_U</a> * ArrOfInt::cree_instance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented in <a class="el" href="classEsp__Dist.html#a0a5fb7a64b0459360df918acbf8ebf71">Esp_Dist</a>, <a class="el" href="classIntTab.html#afca0cf0b52b00efdee90874b0d13546b">IntTab</a>, <a class="el" href="classIntTrav.html#a147ad3bcdadbfceb5588dfd8135fc492">IntTrav</a>, and <a class="el" href="classIntVect.html#a350ba40aca8ec99669423300fb2900ab">IntVect</a>.</p>

<p>Definition at line <a class="el" href="ArrOfInt_8cpp_source.html#l00038">38</a> of file <a class="el" href="ArrOfInt_8cpp_source.html">ArrOfInt.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{
</pre></div>
</div>
</div>
<a class="anchor" id="adb53e0eaa4b61a4b5d68a620c8548543"></a><!-- doxytag: member="ArrOfInt::detach_array" ref="adb53e0eaa4b61a4b5d68a620c8548543" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ArrOfInt::detach_array </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Amene le tableau dans l'etat "detache". C'est a dire:<br/>
Si le tableau est "detache" :<br/>
* ne rien faire<br/>
Si le tableau est "normal" :<br/>
* decremente le nombre de references a *p<br/>
* detruit *p si p-&gt;ref_count==0<br/>
* annule p_, data_ et size_array_<br/>
Si le tableau est "ref_data" :<br/>
* annule data_ et size_array_. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>int<br/>
 Signification: 1 si les donnees du tableau ont ete supprimees </dd></dl>

<p>Definition at line <a class="el" href="ArrOfInt_8cpp_source.html#l01002">1002</a> of file <a class="el" href="ArrOfInt_8cpp_source.html">ArrOfInt.cpp</a>.</p>

<p>References <a class="el" href="ArrOfInt_8h_source.html#l00176">data_</a>, <a class="el" href="ArrOfInt_8h_source.html#l00185">memory_size_</a>, <a class="el" href="ArrOfInt_8h_source.html#l00168">p_</a>, <a class="el" href="ArrOfInt_8h_source.html#l00180">size_array_</a>, and <a class="el" href="ArrOfInt_8cpp_source.html#l00217">VIntdata::suppr_one_ref()</a>.</p>

<p>Referenced by <a class="el" href="ArrOfInt_8cpp_source.html#l00542">memory_resize()</a>, <a class="el" href="IntVect_8cpp_source.html#l00132">IntVect::ref()</a>, <a class="el" href="ArrOfInt_8cpp_source.html#l00952">ref_array()</a>, <a class="el" href="ArrOfInt_8cpp_source.html#l00976">ref_data()</a>, <a class="el" href="ArrOfInt_8cpp_source.html#l00452">reset()</a>, and <a class="el" href="ArrOfInt_8cpp_source.html#l00317">~ArrOfInt()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">int</span> retour = 0;
  <span class="keywordflow">if</span> (<a class="code" href="classArrOfInt.html#a54afaafbf7fa8c80696da7a2c3d3f48b">p_</a>)
    {
<span class="comment">// Le tableau est de type &quot;normal&quot;</span>
<span class="comment">// Si la zone de memoire n&#39;est plus utilisee par personne,</span>
<span class="comment">// on la detruit.</span>
      <span class="keywordflow">if</span> ((<a class="code" href="classArrOfInt.html#a54afaafbf7fa8c80696da7a2c3d3f48b">p_</a>-&gt;<a class="code" href="classVIntdata.html#a67562d6d1fbc5d8bfe0717c25539223c" title="Un tableau de moins utilise cette zone memoire decremente ref_count.">suppr_one_ref</a>()) == 0)
        {
          <span class="keyword">delete</span> <a class="code" href="classArrOfInt.html#a54afaafbf7fa8c80696da7a2c3d3f48b">p_</a>;
          retour = 1;
        }
      <a class="code" href="classArrOfInt.html#a54afaafbf7fa8c80696da7a2c3d3f48b">p_</a> = 0;
    }
  <a class="code" href="classArrOfInt.html#ab799099ee6d316bdaad7d7f3e99f0637">data_</a> = 0;
  <a class="code" href="classArrOfInt.html#a23d1b6526fd584ba8de321ee7d1f1c1b">size_array_</a> = 0;
  <a class="code" href="classArrOfInt.html#a9cda25dd5c640c8523243990b6c0b845">memory_size_</a> = 0;
  <span class="keywordflow">return</span> retour;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a4b418607bdfcf48c3bc8a5b554db7ee1"></a><!-- doxytag: member="ArrOfInt::duplique" ref="a4b418607bdfcf48c3bc8a5b554db7ee1" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ArrOfInt::duplique </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implements <a class="el" href="classArray__base.html#a4116173313698f7f48ffe1765b474083">Array_base</a>.</p>

<p>Reimplemented in <a class="el" href="classEsp__Dist.html#addd5294bb96e0ecc5d47c0315af3dc38">Esp_Dist</a>, <a class="el" href="classIntTab.html#ae93484f56fee1c6b092c7344de7a7591">IntTab</a>, <a class="el" href="classIntTrav.html#a7c24e309e00805d0be6e542b08a19aad">IntTrav</a>, and <a class="el" href="classIntVect.html#a49e9ca0c56d89f59c72464ae1fc00fbb">IntVect</a>.</p>

<p>Definition at line <a class="el" href="ArrOfInt_8cpp_source.html#l00038">38</a> of file <a class="el" href="ArrOfInt_8cpp_source.html">ArrOfInt.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{
</pre></div>
</div>
</div>
<a class="anchor" id="acdeb6ce266ee43155b998f80a0f249e2"></a><!-- doxytag: member="ArrOfInt::fill_default_value" ref="acdeb6ce266ee43155b998f80a0f249e2" args="(Array_base::Resize_Options opt, int first, int nb)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ArrOfInt::fill_default_value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classArray__base.html#abee342aa9ac59623c4c782dc9d7877ff">Array_base::Resize_Options</a>&#160;</td>
          <td class="paramname"><em>opt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Remplit "nb" cases consecutives du tableau a partir de la case "first"<br/>
avec une valeur par defaut.<br/>
Cette fonction est appelee lors d'un resize pour initialiser les<br/>
cases nouvellement creees.<br/>
Le comportement depend actuellement du type de tableau :<br/>
* Tableau de type "smart_resize":<br/>
* en mode debug (macro NDEBUG non definie) le tableau est initialise<br/>
avec une valeur invalide.<br/>
* en optimise, le tableau n'est pas initialise<br/>
* Tableau normal :<br/>
Le tableau est initialise avec la valeur 0. Ce comportement est choisi<br/>
pour des raisons de compatibilite avec l'implementation precedente.<br/>
Cette specification pourrait etre modifiee prochainement pour des raisons<br/>
de performances (pour ne pas avoir a initialiser inutilement les tableaux).<br/>
DONC: il faut supposer desormais que les nouvelles cases ne sont pas<br/>
initialisees lors d'un resize.<br/>
Parametre: first<br/>
Signification: premiere case a initialiser.<br/>
Contrainte: (nb==0) ou (0 &lt;= first &lt; memory_size_)<br/>
Parametre: nb<br/>
Signification: nombre de cases a initialiser.<br/>
Contrainte: (nb==0) ou (0 &lt; nb &lt;= memory_size_ - first) </p>

<p>Definition at line <a class="el" href="ArrOfInt_8cpp_source.html#l00651">651</a> of file <a class="el" href="ArrOfInt_8cpp_source.html">ArrOfInt.cpp</a>.</p>

<p>References <a class="el" href="Array__base_8h_source.html#l00038">Array_base::COPY_INIT</a>, <a class="el" href="ArrOfInt_8h_source.html#l00176">data_</a>, and <a class="el" href="ArrOfInt_8h_source.html#l00185">memory_size_</a>.</p>

<p>Referenced by <a class="el" href="ArrOfInt_8cpp_source.html#l00343">ArrOfInt()</a>, and <a class="el" href="ArrOfInt_8cpp_source.html#l00542">memory_resize()</a>.</p>
<div class="fragment"><pre class="fragment">{
  assert((nb == 0) || (first &gt;= 0 &amp;&amp; first &lt; <a class="code" href="classArrOfInt.html#a9cda25dd5c640c8523243990b6c0b845">memory_size_</a>));
  assert((nb == 0) || (nb &gt; 0 &amp;&amp; nb &lt;= <a class="code" href="classArrOfInt.html#a9cda25dd5c640c8523243990b6c0b845">memory_size_</a> - first));
  <span class="keywordtype">int</span> * data = <a class="code" href="classArrOfInt.html#ab799099ee6d316bdaad7d7f3e99f0637">data_</a>;
  assert(data!=0 || nb==0);
  data += first;
  <span class="keywordflow">if</span> (opt != <a class="code" href="classArray__base.html#abee342aa9ac59623c4c782dc9d7877ffa9a675e25b5b7accff8d861e05060547b">COPY_INIT</a>)
    {
<span class="comment">// On initialise uniquement en mode debug</span>
<span class="preprocessor">#ifndef NDEBUG</span>
<span class="preprocessor"></span>      <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> INT_INVALIDE = INT_MIN;
      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; nb; i++)
        data[i] = INT_INVALIDE;
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>    }
  <span class="keywordflow">else</span>
    {
<span class="comment">// Comportement pour les tableaux normaux : compatibilite avec la</span>
<span class="comment">// version precedente : on initialise avec 0.</span>
      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; nb; i++)
        data[i] = (<span class="keywordtype">int</span>) 0;
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a7dd6de7c430472331cf0d42d2c1dac9e"></a><!-- doxytag: member="ArrOfInt::get_info" ref="a7dd6de7c430472331cf0d42d2c1dac9e" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classType__info.html">Type_info</a> * ArrOfInt::get_info </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Donne des informations sur le type de l'Objet_U. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>const Type_info*<br/>
 Signification: structure regroupant les informations sur le type de l'Objet_U<br/>
 Contraintes: </dd></dl>

<p>Reimplemented from <a class="el" href="classArray__base.html#a794e57ef060138d9ecbdb37d34d46634">Array_base</a>.</p>

<p>Reimplemented in <a class="el" href="classEsp__Dist.html#a75de1dc924d94cd486808a7c6baf6899">Esp_Dist</a>, <a class="el" href="classIntTab.html#aa5b3ac5d8f84a28cc13b6d6a1bef6283">IntTab</a>, <a class="el" href="classIntTrav.html#a930c51d4878f787f206e717768a52bd0">IntTrav</a>, and <a class="el" href="classIntVect.html#a7fb41e29109cda329b88ed5a6483bde8">IntVect</a>.</p>

<p>Definition at line <a class="el" href="ArrOfInt_8cpp_source.html#l00038">38</a> of file <a class="el" href="ArrOfInt_8cpp_source.html">ArrOfInt.cpp</a>.</p>

<p>Referenced by <a class="el" href="IntVect_8cpp_source.html#l00165">IntVect::copy()</a>, and <a class="el" href="ArrOfInt_8h_source.html#l00240">resize_array()</a>.</p>
<div class="fragment"><pre class="fragment">{
</pre></div>
</div>
</div>
<a class="anchor" id="ae2d3c83cd7eedc971a21de3f9f8afa9b"></a><!-- doxytag: member="ArrOfInt::get_mem_storage" ref="ae2d3c83cd7eedc971a21de3f9f8afa9b" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classArrOfInt.html#ae96e99b17332a05cd91a09a2b6bb3cc4">ArrOfInt::Storage</a> ArrOfInt::get_mem_storage </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Renvoie le mode d'allocation du tableau (qui sera utilise<br/>
lors du prochain resize si changement de taille).<br/>
(voir <a class="el" href="classVIntdata.html" title="VIntdata alloue une zone de memoire de la taille specifiee au constructeur, et libere la zone de memo...">VIntdata</a> et <a class="el" href="classInt__ptr__trav.html" title="Une zone de travail de la Memoire TRUST composee d&#39;elements de type int.">Int_ptr_trav</a>) </p>

<p>Definition at line <a class="el" href="ArrOfInt_8cpp_source.html#l00433">433</a> of file <a class="el" href="ArrOfInt_8cpp_source.html">ArrOfInt.cpp</a>.</p>

<p>References <a class="el" href="ArrOfInt_8h_source.html#l00195">storage_type_</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">return</span> <a class="code" href="classArrOfInt.html#a5a5cbc9e1c2d4ba877ca0bd697ea56bc">storage_type_</a>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a32f629b94dc0867e56395ba5eb316a9a"></a><!-- doxytag: member="ArrOfInt::info" ref="a32f629b94dc0867e56395ba5eb316a9a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classType__info.html">Type_info</a> * ArrOfInt::info </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Donne des informations sur le type de l'Objet_U. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>const Type_info*<br/>
 Signification: structure regroupant les informations sur le type de l'Objet_U<br/>
 Contraintes: </dd></dl>

<p>Reimplemented from <a class="el" href="classArray__base.html#a5214dee08ff85f62ec0aef0806eadeae">Array_base</a>.</p>

<p>Reimplemented in <a class="el" href="classEsp__Dist.html#a96dfd531abec920133d4f7257c807ecc">Esp_Dist</a>, <a class="el" href="classIntTab.html#ac67599f6de641e639fb9a7838df427d0">IntTab</a>, <a class="el" href="classIntTrav.html#ad742674427c162f01f31c62e7211440f">IntTrav</a>, and <a class="el" href="classIntVect.html#ab2d1ab93a0df6867e2e93aa8181c274b">IntVect</a>.</p>

<p>Definition at line <a class="el" href="ArrOfInt_8cpp_source.html#l00038">38</a> of file <a class="el" href="ArrOfInt_8cpp_source.html">ArrOfInt.cpp</a>.</p>

<p>Referenced by <a class="el" href="ArrOfInt_8h_source.html#l00240">resize_array()</a>.</p>
<div class="fragment"><pre class="fragment">{
</pre></div>
</div>
</div>
<a class="anchor" id="a195c644d98bf2da2fe4f8aede4e02262"></a><!-- doxytag: member="ArrOfInt::inject_array" ref="a195c644d98bf2da2fe4f8aede4e02262" args="(const ArrOfInt &amp;source, int nb_elements=&#45;1, int first_element_dest=0, int first_element_source=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp; ArrOfInt::inject_array </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nb_elements</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>first_element_dest</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>first_element_source</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copie les elements source[first_element_source + i]<br/>
dans les elements (*this)[first_element_dest + i] pour 0 &lt;= i &lt; nb_elements<br/>
Les autres elements de (*this) sont inchanges. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp;<br/>
 Signification: *this<br/>
 Contraintes: </dd></dl>

<p>Definition at line <a class="el" href="ArrOfInt_8cpp_source.html#l01098">1098</a> of file <a class="el" href="ArrOfInt_8cpp_source.html">ArrOfInt.cpp</a>.</p>

<p>References <a class="el" href="ArrOfInt_8h_source.html#l00371">addr()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00176">data_</a>, and <a class="el" href="ArrOfInt_8h_source.html#l00342">size_array()</a>.</p>

<p>Referenced by <a class="el" href="Array__tools_8cpp_source.html#l00515">append_array_to_array()</a>, <a class="el" href="ArrOfInt_8cpp_source.html#l00391">ArrOfInt()</a>, <a class="el" href="Zone__VF_8cpp_source.html#l00431">Zone_VF::construire_face_virt_pe_num()</a>, <a class="el" href="Scatter_8cpp_source.html#l01409">Scatter::construire_md_vector()</a>, <a class="el" href="Partitionneur__Tranche_8cpp_source.html#l00185">Partitionneur_Tranche::construire_partition()</a>, <a class="el" href="IntVect_8cpp_source.html#l00165">IntVect::copy()</a>, <a class="el" href="IntVect_8cpp_source.html#l00190">IntVect::copy_()</a>, <a class="el" href="Static__Int__Lists_8cpp_source.html#l00109">Static_Int_Lists::copy_list_to_array()</a>, <a class="el" href="communications_8cpp_source.html#l00473">envoyer_all_to_all()</a>, <a class="el" href="ExtrudeParoi_8cpp_source.html#l00159">ExtrudeParoi::extrude()</a>, <a class="el" href="Champ__front__recyclage_8cpp_source.html#l00721">Champ_front_recyclage::mettre_a_jour()</a>, <a class="el" href="ArrOfInt_8cpp_source.html#l00468">operator=()</a>, <a class="el" href="Solv__GCP_8cpp_source.html#l00124">Solv_GCP::prepare_data()</a>, <a class="el" href="Static__Int__Lists_8cpp_source.html#l00155">Static_Int_Lists::set()</a>, and <a class="el" href="Static__Int__Lists_8cpp_source.html#l00057">Static_Int_Lists::set_data()</a>.</p>
<div class="fragment"><pre class="fragment">{
  assert(&amp;source != <span class="keyword">this</span>);
  assert(nb_elements &gt;= -1);
  assert(first_element_dest &gt;= 0);
  assert(first_element_source &gt;= 0);

  <span class="keywordflow">if</span> (nb_elements &lt; 0)
    nb_elements = source.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>();

  assert(first_element_source + nb_elements &lt;= source.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>());
  assert(first_element_dest + nb_elements &lt;= <a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>());

  <span class="keywordflow">if</span> (nb_elements &gt; 0)
    {
      <span class="keywordtype">int</span> * addr_dest = <a class="code" href="classArrOfInt.html#ab799099ee6d316bdaad7d7f3e99f0637">data_</a> + first_element_dest;
      <span class="keyword">const</span> <span class="keywordtype">int</span> * addr_source = source.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() + first_element_source;
<span class="comment">// PL: On utilise le memcpy car c&#39;est VRAIMENT plus rapide (10% +vite sur RNR_G20)</span>
      memcpy(addr_dest , addr_source, nb_elements * <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>));
      <span class="comment">/*</span>
<span class="comment">        int i;</span>
<span class="comment">        for (i = 0; i &lt; nb_elements; i++) {</span>
<span class="comment">        addr_dest[i] = addr_source[i];</span>
<span class="comment">        } */</span>
    }
  <span class="keywordflow">return</span> *<span class="keyword">this</span>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a1bdac0af7218a7a9d6abf1709feffc17"></a><!-- doxytag: member="ArrOfInt::memory_resize" ref="a1bdac0af7218a7a9d6abf1709feffc17" args="(int new_size, Array_base::Resize_Options opt=COPY_INIT)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ArrOfInt::memory_resize </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>new_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArray__base.html#abee342aa9ac59623c4c782dc9d7877ff">Array_base::Resize_Options</a>&#160;</td>
          <td class="paramname"><em>opt</em> = <code>COPY_INIT</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Si besoin, alloue une nouvelle zone de memoire,<br/>
copie les donnees et efface l'ancienne zone de memoire.<br/>
Attention, on suppose que cette methode est appelee par<br/>
<a class="el" href="classArrOfInt.html#a9b3afbb46b16870dbd36236c8935b535">resize_array()</a>.<br/>
Attention: si ref_count_&gt;1, l'appel a <a class="el" href="classArrOfInt.html#a9b3afbb46b16870dbd36236c8935b535">resize_array()</a> est<br/>
autorise uniquement si la nouvelle taille est identique<br/>
a la precedente (auquel cas on ne fait rien)<br/>
Si ref_count_ == 1, l'appel est invalide si p_-&gt;data_ est<br/>
different de data_ (le tableau a ete construit avec <a class="el" href="classArrOfInt.html#acdd0214cc8f6c95882e5032b9e3121ea" title="Fait pointer le tableau vers les memes donnees qu&#39;un tableau existant. Le tableau sera du meme type q...">ref_array()</a><br/>
avec start &gt; 0) </p>

<p>Definition at line <a class="el" href="ArrOfInt_8cpp_source.html#l00542">542</a> of file <a class="el" href="ArrOfInt_8cpp_source.html">ArrOfInt.cpp</a>.</p>

<p>References <a class="el" href="Array__base_8h_source.html#l00038">Array_base::COPY_INIT</a>, <a class="el" href="ArrOfInt_8h_source.html#l00176">data_</a>, <a class="el" href="ArrOfInt_8cpp_source.html#l01002">detach_array()</a>, <a class="el" href="ArrOfInt_8cpp_source.html#l00651">fill_default_value()</a>, <a class="el" href="ArrOfInt_8cpp_source.html#l00224">VIntdata::get_data()</a>, <a class="el" href="ArrOfInt_8cpp_source.html#l00195">VIntdata::get_size()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00185">memory_size_</a>, <a class="el" href="Array__base_8h_source.html#l00038">Array_base::NOCOPY_NOINIT</a>, <a class="el" href="ArrOfInt_8h_source.html#l00168">p_</a>, <a class="el" href="ArrOfInt_8cpp_source.html#l01134">ref_count()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00180">size_array_</a>, <a class="el" href="ArrOfInt_8h_source.html#l00191">smart_resize_</a>, and <a class="el" href="ArrOfInt_8h_source.html#l00195">storage_type_</a>.</p>

<p>Referenced by <a class="el" href="ArrOfInt_8h_source.html#l00256">resize_array_()</a>.</p>
<div class="fragment"><pre class="fragment">{
  assert(new_size &gt;= 0);

<span class="comment">// Si new_size==size_array_, on ne fait rien, c&#39;est toujours autorise</span>
  <span class="keywordflow">if</span> (new_size == <a class="code" href="classArrOfInt.html#a23d1b6526fd584ba8de321ee7d1f1c1b">size_array_</a>)
    <span class="keywordflow">return</span>;

<span class="comment">// Sinon, il faut que le resize soit autorise, c&#39;est a dire</span>
<span class="comment">// - soit le tableau est detache</span>
<span class="comment">// - soit le tableau est normal et il n&#39;y a pas d&#39;autre reference au tableau</span>
  assert((<a class="code" href="classArrOfInt.html#ab799099ee6d316bdaad7d7f3e99f0637">data_</a> == 0) || ((<a class="code" href="classArrOfInt.html#a54afaafbf7fa8c80696da7a2c3d3f48b">p_</a> != 0) &amp;&amp; (<a class="code" href="classArrOfInt.html#a54afaafbf7fa8c80696da7a2c3d3f48b">p_</a>-&gt;<a class="code" href="classVIntdata.html#ad4a8ad27e706b36dcdfc05b4209fa41f" title="renvoie data_">get_data</a>() == <a class="code" href="classArrOfInt.html#ab799099ee6d316bdaad7d7f3e99f0637">data_</a>) &amp;&amp; (<a class="code" href="classArrOfInt.html#a2e8671e0e07855965bbff4c59582f224" title="Retourne le nombre de references des donnees du tableau si le tableau est &quot;normal&quot;, -1 s&#39;il est &quot;detache&quot; ou &quot;ref_data&quot;.">ref_count</a>() == 1)));

<span class="comment">// Occupation memoire de l&#39;ancien tableau:</span>
  <span class="keywordtype">int</span> old_mem_size = <a class="code" href="classArrOfInt.html#a9cda25dd5c640c8523243990b6c0b845">memory_size_</a>;
  assert((!<a class="code" href="classArrOfInt.html#a54afaafbf7fa8c80696da7a2c3d3f48b">p_</a>) || (<a class="code" href="classArrOfInt.html#a54afaafbf7fa8c80696da7a2c3d3f48b">p_</a>-&gt;<a class="code" href="classVIntdata.html#aae35f6e0237be8a8e71a47c304fe8a09" title="renvoie size_">get_size</a>() == <a class="code" href="classArrOfInt.html#a9cda25dd5c640c8523243990b6c0b845">memory_size_</a>));
  assert(<a class="code" href="classArrOfInt.html#a9cda25dd5c640c8523243990b6c0b845">memory_size_</a> &gt;= <a class="code" href="classArrOfInt.html#a23d1b6526fd584ba8de321ee7d1f1c1b">size_array_</a>);

<span class="comment">// Occupation memoire du nouveau tableau :</span>
<span class="comment">// Si smart_resize, on prend au moins deux fois la taille</span>
<span class="comment">// precedente, ou new_size</span>
  <span class="keywordtype">int</span> new_mem_size = new_size;
  <span class="keywordflow">if</span> (<a class="code" href="classArrOfInt.html#a9170b6699fa2b83ccc8c9a451e18bd44">smart_resize_</a>)
    {
      <span class="keywordflow">if</span> (new_size &lt;= old_mem_size)
        new_mem_size = old_mem_size;
      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (new_size &lt; old_mem_size * 2)
        new_mem_size = old_mem_size * 2;
      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (new_size &gt; old_mem_size &amp;&amp; old_mem_size &gt; INT_MAX / 2)
        new_mem_size = INT_MAX;
    }

  <span class="keywordflow">if</span> (new_mem_size != old_mem_size)
    {
<span class="comment">// detach_array() efface le contenu de size_array_. On le met de cote:</span>
      <span class="keyword">const</span> <span class="keywordtype">int</span> old_size_array = <a class="code" href="classArrOfInt.html#a23d1b6526fd584ba8de321ee7d1f1c1b">size_array_</a>;
      <span class="keywordflow">if</span> (new_mem_size == 0)
        {
<span class="comment">// La nouvelle taille est nulle, on cree un tableau &quot;detache&quot;</span>
          <a class="code" href="classArrOfInt.html#adb53e0eaa4b61a4b5d68a620c8548543" title="Amene le tableau dans l&#39;etat &quot;detache&quot;. C&#39;est a dire: Si le tableau est &quot;detache&quot; : * ne rien faire...">detach_array</a>();
        }
      <span class="keywordflow">else</span>
        {
<span class="comment">// Allocation d&#39;une nouvelle zone</span>
          <a class="code" href="classVIntdata.html" title="VIntdata alloue une zone de memoire de la taille specifiee au constructeur, et libere la zone de memo...">VIntdata</a> * new_p = <span class="keyword">new</span> <a class="code" href="classVIntdata.html" title="VIntdata alloue une zone de memoire de la taille specifiee au constructeur, et libere la zone de memo...">VIntdata</a>(new_mem_size, <a class="code" href="classArrOfInt.html#a5a5cbc9e1c2d4ba877ca0bd697ea56bc">storage_type_</a>);
          <span class="keywordtype">int</span> * new_data = new_p-&gt;<a class="code" href="classVIntdata.html#ad4a8ad27e706b36dcdfc05b4209fa41f" title="renvoie data_">get_data</a>();
<span class="comment">// Raccourci si le tableau etait &quot;detache&quot;, inutile de copier</span>
<span class="comment">// les anciennes donnees. On copie si COPY_OLD est demande</span>
          <span class="keywordtype">int</span> copy_size = 0;
          <span class="keywordflow">if</span> (<a class="code" href="classArrOfInt.html#ab799099ee6d316bdaad7d7f3e99f0637">data_</a> != 0)
            {
<span class="comment">// Calcul du nombre d&#39;elements a copier vers la nouvelle</span>
<span class="comment">// zone de memoire : c&#39;est le min de l&#39;ancienne et de</span>
<span class="comment">// la nouvelle taille.</span>
              <span class="keywordflow">if</span> (opt != <a class="code" href="classArray__base.html#abee342aa9ac59623c4c782dc9d7877ffaf6ae9ba7eb51c5f298ce693345b3ec68">NOCOPY_NOINIT</a>)
                {
                  copy_size = <a class="code" href="classArrOfInt.html#a23d1b6526fd584ba8de321ee7d1f1c1b">size_array_</a>;
                  <span class="keywordflow">if</span> (new_size &lt; copy_size)
                    copy_size = new_size;
<span class="comment">// Copie des valeurs dans le nouveau tableau</span>
                  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; copy_size; i++)
                    new_data[i] = <a class="code" href="classArrOfInt.html#ab799099ee6d316bdaad7d7f3e99f0637">data_</a>[i];
                }
<span class="comment">// Destruction de l&#39;ancienne zone (si plus aucune reference)</span>
              <a class="code" href="classArrOfInt.html#adb53e0eaa4b61a4b5d68a620c8548543" title="Amene le tableau dans l&#39;etat &quot;detache&quot;. C&#39;est a dire: Si le tableau est &quot;detache&quot; : * ne rien faire...">detach_array</a>();
            }
<span class="comment">// On attache la nouvelle zone de memoire</span>
          <a class="code" href="classArrOfInt.html#a54afaafbf7fa8c80696da7a2c3d3f48b">p_</a> = new_p;
          <a class="code" href="classArrOfInt.html#ab799099ee6d316bdaad7d7f3e99f0637">data_</a> = new_data;
          <a class="code" href="classArrOfInt.html#a9cda25dd5c640c8523243990b6c0b845">memory_size_</a> = new_mem_size;
<span class="comment">// Initialisation des cases supplementaires avec une valeur par defaut</span>
          <a class="code" href="classArrOfInt.html#acdeb6ce266ee43155b998f80a0f249e2" title="Remplit &quot;nb&quot; cases consecutives du tableau a partir de la case &quot;first&quot; avec une valeur par defaut...">fill_default_value</a>(opt, copy_size, new_mem_size - copy_size);
<span class="comment">// Restaure l&#39;ancienne valeur de size_array_</span>
          <a class="code" href="classArrOfInt.html#a23d1b6526fd584ba8de321ee7d1f1c1b">size_array_</a> = old_size_array;
        }
    }
  <span class="keywordflow">else</span>
    {
<span class="comment">// Pas de reallocation, initialisation si besoin</span>
      <span class="keywordflow">if</span> (opt == <a class="code" href="classArray__base.html#abee342aa9ac59623c4c782dc9d7877ffa9a675e25b5b7accff8d861e05060547b">COPY_INIT</a> &amp;&amp; new_size &gt; <a class="code" href="classArrOfInt.html#a23d1b6526fd584ba8de321ee7d1f1c1b">size_array_</a>)
        {
          <a class="code" href="classArrOfInt.html#acdeb6ce266ee43155b998f80a0f249e2" title="Remplit &quot;nb&quot; cases consecutives du tableau a partir de la case &quot;first&quot; avec une valeur par defaut...">fill_default_value</a>(opt, <a class="code" href="classArrOfInt.html#a23d1b6526fd584ba8de321ee7d1f1c1b">size_array_</a>, new_size - <a class="code" href="classArrOfInt.html#a23d1b6526fd584ba8de321ee7d1f1c1b">size_array_</a>);
        }
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a2db9e4cf7c9096344df4ad90567c9041"></a><!-- doxytag: member="ArrOfInt::operator()" ref="a2db9e4cf7c9096344df4ad90567c9041" args="(int i)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int &amp; ArrOfInt::operator() </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>idem operator[] </p>

<p>Reimplemented in <a class="el" href="classIntTab.html#a019ddfb358764467c90568045ce8c161">IntTab</a>.</p>

<p>Definition at line <a class="el" href="ArrOfInt_8h_source.html#l00327">327</a> of file <a class="el" href="ArrOfInt_8h_source.html">ArrOfInt.h</a>.</p>

<p>References <a class="el" href="ArrOfInt_8h_source.html#l00306">operator[]()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">return</span> <a class="code" href="classArrOfInt.html#ac3668f9c049886746539a3ed7bce7723" title="operateur [] retourne le ieme element du tableau">operator[]</a>(i);
}
</pre></div>
</div>
</div>
<a class="anchor" id="afb78c76aae98f9874e23ebcb96680c07"></a><!-- doxytag: member="ArrOfInt::operator()" ref="afb78c76aae98f9874e23ebcb96680c07" args="(int i) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int &amp; ArrOfInt::operator() </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented in <a class="el" href="classIntTab.html#aa1d8bf849235b67312acaa834bd4f616">IntTab</a>.</p>

<p>Definition at line <a class="el" href="ArrOfInt_8h_source.html#l00332">332</a> of file <a class="el" href="ArrOfInt_8h_source.html">ArrOfInt.h</a>.</p>

<p>References <a class="el" href="ArrOfInt_8h_source.html#l00306">operator[]()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">return</span> <a class="code" href="classArrOfInt.html#ac3668f9c049886746539a3ed7bce7723" title="operateur [] retourne le ieme element du tableau">operator[]</a>(i);
}
</pre></div>
</div>
</div>
<a class="anchor" id="a0fa5723f68c75dde90b9c6d1718d198c"></a><!-- doxytag: member="ArrOfInt::operator+=" ref="a0fa5723f68c75dde90b9c6d1718d198c" args="(const ArrOfInt &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp; ArrOfInt::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>y</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Addition case a case sur toutes les cases du tableau. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp;<br/>
 Signification: *this<br/>
 Contraintes: </dd></dl>

<p>Definition at line <a class="el" href="ArrOfInt_8cpp_source.html#l01157">1157</a> of file <a class="el" href="ArrOfInt_8cpp_source.html">ArrOfInt.cpp</a>.</p>

<p>References <a class="el" href="ArrOfInt_8h_source.html#l00176">data_</a>, and <a class="el" href="ArrOfInt_8h_source.html#l00342">size_array()</a>.</p>
<div class="fragment"><pre class="fragment">{
  assert(<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>()==y.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>());
  <span class="keywordtype">int</span>* dx = <a class="code" href="classArrOfInt.html#ab799099ee6d316bdaad7d7f3e99f0637">data_</a>;
  <span class="keyword">const</span> <span class="keywordtype">int</span>* dy = y.<a class="code" href="classArrOfInt.html#ab799099ee6d316bdaad7d7f3e99f0637">data_</a>;
  <span class="keyword">const</span> <span class="keywordtype">int</span> n = <a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>();
  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;n; i++)
    dx[i] += dy[i];
  <span class="keywordflow">return</span> *<span class="keyword">this</span>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a260e2d376a27555b1e8844ec6519b642"></a><!-- doxytag: member="ArrOfInt::operator+=" ref="a260e2d376a27555b1e8844ec6519b642" args="(const int)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp; ArrOfInt::operator+= </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>dy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>ajoute la meme valeur a toutes les cases du tableau </p>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a><br/>
 Signification: *this<br/>
 Contraintes: </dd></dl>

<p>Reimplemented in <a class="el" href="classIntVect.html#a78909e0f247b3b0d7a3a24e2c744cfd8">IntVect</a>.</p>

<p>Definition at line <a class="el" href="ArrOfInt_8cpp_source.html#l01182">1182</a> of file <a class="el" href="ArrOfInt_8cpp_source.html">ArrOfInt.cpp</a>.</p>

<p>References <a class="el" href="ArrOfInt_8h_source.html#l00176">data_</a>, and <a class="el" href="ArrOfInt_8h_source.html#l00342">size_array()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">int</span> * data = <a class="code" href="classArrOfInt.html#ab799099ee6d316bdaad7d7f3e99f0637">data_</a>;
  <span class="keyword">const</span> <span class="keywordtype">int</span> n = <a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>();
  <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i &lt; n; i++)
    data[i] += dy;
  <span class="keywordflow">return</span> *<span class="keyword">this</span>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a8fceeab1bf0ed0df9ca13b151a3f8eba"></a><!-- doxytag: member="ArrOfInt::operator&#45;=" ref="a8fceeab1bf0ed0df9ca13b151a3f8eba" args="(const int)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp; ArrOfInt::operator-= </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>dy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>soustrait la meme valeur a toutes les cases </p>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> &amp;<br/>
 Signification: *this </dd></dl>

<p>Reimplemented in <a class="el" href="classIntVect.html#ade9df0a07549e07f3fd8863647eaea48">IntVect</a>.</p>

<p>Definition at line <a class="el" href="ArrOfInt_8cpp_source.html#l01212">1212</a> of file <a class="el" href="ArrOfInt_8cpp_source.html">ArrOfInt.cpp</a>.</p>

<p>References <a class="el" href="ArrOfInt_8h_source.html#l00176">data_</a>, and <a class="el" href="ArrOfInt_8h_source.html#l00342">size_array()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">int</span> * data = <a class="code" href="classArrOfInt.html#ab799099ee6d316bdaad7d7f3e99f0637">data_</a>;
  <span class="keyword">const</span> <span class="keywordtype">int</span> n = <a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>();
  <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i &lt; n; i++)
    data[i] -= dy;
  <span class="keywordflow">return</span> *<span class="keyword">this</span>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a4fddff7058410064187290e6bec6c68e"></a><!-- doxytag: member="ArrOfInt::operator&#45;=" ref="a4fddff7058410064187290e6bec6c68e" args="(const ArrOfInt &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp; ArrOfInt::operator-= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>y</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Soustraction case a case sur toutes les cases du tableau<br/>
Parametre: const <a class="el" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; y<br/>
Signification: tableau de meme taille que *this. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp;<br/>
 Signification: *this </dd></dl>

<p>Definition at line <a class="el" href="ArrOfInt_8cpp_source.html#l01196">1196</a> of file <a class="el" href="ArrOfInt_8cpp_source.html">ArrOfInt.cpp</a>.</p>

<p>References <a class="el" href="ArrOfInt_8h_source.html#l00176">data_</a>, and <a class="el" href="ArrOfInt_8h_source.html#l00342">size_array()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">const</span> <span class="keywordtype">int</span> size = <a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>();
  assert(size == y.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>());
  <span class="keywordtype">int</span> * data = <a class="code" href="classArrOfInt.html#ab799099ee6d316bdaad7d7f3e99f0637">data_</a>;
  <span class="keyword">const</span> <span class="keywordtype">int</span> * data_y = y.<a class="code" href="classArrOfInt.html#ab799099ee6d316bdaad7d7f3e99f0637">data_</a>;
  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i &lt; size; i++)
    data[i] -= data_y[i];
  <span class="keywordflow">return</span> *<span class="keyword">this</span>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a1851289f5b18738eebb6f909c65920ee"></a><!-- doxytag: member="ArrOfInt::operator=" ref="a1851289f5b18738eebb6f909c65920ee" args="(const ArrOfInt &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp; ArrOfInt::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copie les donnees du tableau m.<br/>
Si "m" n'a pas la meme taille que "*this", on fait un resize_array.<br/>
Ensuite, on copie les valeurs de "m" dans "*this".<br/>
Le type de tableau (methode d'allocation) n'est pas copie. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp;<br/>
 Signification: *this </dd></dl>

<p>Definition at line <a class="el" href="ArrOfInt_8cpp_source.html#l00468">468</a> of file <a class="el" href="ArrOfInt_8cpp_source.html">ArrOfInt.cpp</a>.</p>

<p>References <a class="el" href="ArrOfInt_8cpp_source.html#l01098">inject_array()</a>, <a class="el" href="Array__base_8h_source.html#l00038">Array_base::NOCOPY_NOINIT</a>, <a class="el" href="ArrOfInt_8h_source.html#l00240">resize_array()</a>, and <a class="el" href="ArrOfInt_8h_source.html#l00342">size_array()</a>.</p>

<p>Referenced by <a class="el" href="ArrOfInt_8cpp_source.html#l00501">copy_array()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">if</span> (&amp;m != <span class="keyword">this</span>)
    {
      <span class="keyword">const</span> <span class="keywordtype">int</span> new_size = m.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>();
<span class="comment">// On utilise la methode resize_array() qui teste le type derive de l&#39;objet</span>
<span class="comment">// (resize interdit sur un type derive)</span>
      <a class="code" href="classArrOfInt.html#a9b3afbb46b16870dbd36236c8935b535">resize_array</a>(new_size, <a class="code" href="classArray__base.html#abee342aa9ac59623c4c782dc9d7877ffaf6ae9ba7eb51c5f298ce693345b3ec68">NOCOPY_NOINIT</a>);
      <a class="code" href="classArrOfInt.html#a195c644d98bf2da2fe4f8aede4e02262" title="Copie les elements source[first_element_source + i] dans les elements (*this)[first_element_dest + i]...">inject_array</a>(m);
    }
  <span class="keywordflow">return</span> *<span class="keyword">this</span>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a8969ecd1d929dcc1c92d23dec55c8eb9"></a><!-- doxytag: member="ArrOfInt::operator=" ref="a8969ecd1d929dcc1c92d23dec55c8eb9" args="(int valeur)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp; ArrOfInt::operator= </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>x est affecte a toutes les cases </p>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp;<br/>
 Signification: *this<br/>
 Contraintes: </dd></dl>

<p>Reimplemented in <a class="el" href="classIntTab.html#a1b74f2045e669b8f676b782bd2f97a9c">IntTab</a>, <a class="el" href="classIntTrav.html#a0c9b00a9631432a1aa4ef13570052398">IntTrav</a>, and <a class="el" href="classIntVect.html#ab22c8098b919f34e83cd773361b54dc8">IntVect</a>.</p>

<p>Definition at line <a class="el" href="ArrOfInt_8h_source.html#l00288">288</a> of file <a class="el" href="ArrOfInt_8h_source.html">ArrOfInt.h</a>.</p>

<p>References <a class="el" href="ArrOfInt_8h_source.html#l00176">data_</a>, and <a class="el" href="ArrOfInt_8h_source.html#l00180">size_array_</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">const</span> <span class="keywordtype">int</span> n = <a class="code" href="classArrOfInt.html#a23d1b6526fd584ba8de321ee7d1f1c1b">size_array_</a>;
  <span class="keywordtype">int</span> *data = <a class="code" href="classArrOfInt.html#ab799099ee6d316bdaad7d7f3e99f0637">data_</a>;
  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; n; i++)
    {
      data[i] = x;
    }
  <span class="keywordflow">return</span> *<span class="keyword">this</span>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="af501756161df3f9d3812154f888bd64f"></a><!-- doxytag: member="ArrOfInt::operator=" ref="af501756161df3f9d3812154f888bd64f" args="(const FArrOfInt &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classArrOfInt.html">ArrOfInt</a>&amp; ArrOfInt::operator= </td>
          <td>(</td>
          <td class="paramtype">const FArrOfInt &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a52b456caab2e93cacaa85d246021886d"></a><!-- doxytag: member="ArrOfInt::operator[]" ref="a52b456caab2e93cacaa85d246021886d" args="(int i) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int &amp; ArrOfInt::operator[] </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>operateur [] retourne le ieme element du tableau </p>

<p>Reimplemented in <a class="el" href="classIntTab.html#ad53f9bc1670e5346b10984506f9c23c7">IntTab</a>.</p>

<p>Definition at line <a class="el" href="ArrOfInt_8h_source.html#l00319">319</a> of file <a class="el" href="ArrOfInt_8h_source.html">ArrOfInt.h</a>.</p>

<p>References <a class="el" href="ArrOfInt_8h_source.html#l00176">data_</a>, and <a class="el" href="ArrOfInt_8h_source.html#l00180">size_array_</a>.</p>
<div class="fragment"><pre class="fragment">{
  assert(i &gt;= 0 &amp;&amp; i &lt; <a class="code" href="classArrOfInt.html#a23d1b6526fd584ba8de321ee7d1f1c1b">size_array_</a>);
  <span class="keywordflow">return</span> <a class="code" href="classArrOfInt.html#ab799099ee6d316bdaad7d7f3e99f0637">data_</a>[i];
}
</pre></div>
</div>
</div>
<a class="anchor" id="ac3668f9c049886746539a3ed7bce7723"></a><!-- doxytag: member="ArrOfInt::operator[]" ref="ac3668f9c049886746539a3ed7bce7723" args="(int i)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int &amp; ArrOfInt::operator[] </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>operateur [] retourne le ieme element du tableau </p>

<p>Reimplemented in <a class="el" href="classIntTab.html#af3df1702201b27dfd5aff77e6215166e">IntTab</a>.</p>

<p>Definition at line <a class="el" href="ArrOfInt_8h_source.html#l00306">306</a> of file <a class="el" href="ArrOfInt_8h_source.html">ArrOfInt.h</a>.</p>

<p>References <a class="el" href="ArrOfInt_8h_source.html#l00176">data_</a>, and <a class="el" href="ArrOfInt_8h_source.html#l00180">size_array_</a>.</p>

<p>Referenced by <a class="el" href="ArrOfInt_8h_source.html#l00327">operator()()</a>.</p>
<div class="fragment"><pre class="fragment">{
  assert(i &gt;= 0 &amp;&amp; i &lt; <a class="code" href="classArrOfInt.html#a23d1b6526fd584ba8de321ee7d1f1c1b">size_array_</a>);
  <span class="keywordflow">return</span> <a class="code" href="classArrOfInt.html#ab799099ee6d316bdaad7d7f3e99f0637">data_</a>[i];
}
</pre></div>
</div>
</div>
<a class="anchor" id="abb0f48cf5a4be4b70edcc90baaebd521"></a><!-- doxytag: member="ArrOfInt::ordonne_array" ref="abb0f48cf5a4be4b70edcc90baaebd521" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ArrOfInt::ordonne_array </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Tri des valeurs du tableau dans l'ordre croissant.<br/>
La fonction utilisee est qsort de stdlib (elle est en n*log(n)). </p>

<p>Definition at line <a class="el" href="ArrOfInt_8cpp_source.html#l00897">897</a> of file <a class="el" href="ArrOfInt_8cpp_source.html">ArrOfInt.cpp</a>.</p>

<p>References <a class="el" href="ArrOfInt_8h_source.html#l00176">data_</a>, <a class="el" href="ArrOfInt_8cpp_source.html#l00878">fonction_compare_arrofint_ordonner()</a>, and <a class="el" href="ArrOfInt_8h_source.html#l00180">size_array_</a>.</p>

<p>Referenced by <a class="el" href="ArrOfInt_8cpp_source.html#l00911">array_trier_retirer_doublons()</a>, <a class="el" href="Scatter_8cpp_source.html#l00778">array_trier_retirer_doublons()</a>, <a class="el" href="MaillerParallel_8cpp_source.html#l00421">auto_build_joints()</a>, <a class="el" href="Scatter_8cpp_source.html#l00937">Scatter::calculer_espace_distant()</a>, <a class="el" href="Schema__Comm_8cpp_source.html#l00549">Schema_Comm::check_send_recv_pe_list()</a>, <a class="el" href="Raccord__distant__homogene_8cpp_source.html#l00237">Raccord_distant_homogene::completer()</a>, <a class="el" href="Octree_8cpp_source.html#l01743">OctreeFloor::construire()</a>, <a class="el" href="DomaineCutter_8cpp_source.html#l00517">DomaineCutter::construire_elements_distants_ssdom()</a>, <a class="el" href="Scatter_8cpp_source.html#l02035">Scatter::corriger_espace_distant_elements_perio()</a>, <a class="el" href="Schema__Comm__Vecteurs_8cpp_source.html#l00110">Schema_Comm_Vecteurs::end_init()</a>, <a class="el" href="Matrice__Morse_8cpp_source.html#l01920">Matrice_Morse::get_stencil()</a>, <a class="el" href="Matrice__Morse__Sym_8cpp_source.html#l00693">Matrice_Morse_Sym::get_symmetric_stencil()</a>, <a class="el" href="Remove__elem_8cpp_source.html#l00096">Remove_elem::recreer_faces()</a>, <a class="el" href="Remove__elem_8cpp_source.html#l00184">Remove_elem::remplir_liste()</a>, <a class="el" href="Zone__VEF_8cpp_source.html#l00118">Zone_VEF::reordonner()</a>, <a class="el" href="Zone__PolyMAC_8cpp_source.html#l00156">Zone_PolyMAC::reordonner()</a>, <a class="el" href="Zone__EF_8cpp_source.html#l00231">Zone_EF::reordonner()</a>, <a class="el" href="Zone__CoviMAC_8cpp_source.html#l00153">Zone_CoviMAC::reordonner()</a>, <a class="el" href="Zone__VDF_8cpp_source.html#l00102">reordonner_vdf()</a>, <a class="el" href="Array__tools_8cpp_source.html#l00237">tri_lexicographique_tableau()</a>, <a class="el" href="Scatter_8cpp_source.html#l00752">Scatter::trier_les_joints()</a>, and <a class="el" href="Static__Int__Lists_8cpp_source.html#l00091">Static_Int_Lists::trier_liste()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">const</span> <span class="keywordtype">int</span> size = <a class="code" href="classArrOfInt.html#a23d1b6526fd584ba8de321ee7d1f1c1b">size_array_</a>;
  <span class="keywordflow">if</span> (size &gt; 1)
    {
      <span class="keywordtype">int</span> * data = <a class="code" href="classArrOfInt.html#ab799099ee6d316bdaad7d7f3e99f0637">data_</a>;
      qsort(data, size, <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>),
            <a class="code" href="ArrOfInt_8cpp.html#a9d5c9879b5af1e678b1b1f34bfd1828e" title="Fonction de comparaison utilisee pour trier le tableau dans ArrOfInt::trier(). Voir man qsort...">fonction_compare_arrofint_ordonner</a>);
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a4d80731bc6ae7f1494dce3109b961771"></a><!-- doxytag: member="ArrOfInt::printOn" ref="a4d80731bc6ae7f1494dce3109b961771" args="(Sortie &amp;x) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSortie.html">Sortie</a> &amp; ArrOfInt::printOn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSortie.html">Sortie</a> &amp;&#160;</td>
          <td class="paramname"><em>os</em></td><td>)</td>
          <td> const<code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Ecriture du tableau sur "os" :<br/>
ecrit le nombre d'elements suivi des valeurs du tableau. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="classSortie.html" title="Classe de base des flux de sortie. Elle sait ecrire des types simples&lt;br&gt;(entiers, flottants) et des Ob...">Sortie</a>&amp;<br/>
 Signification: le flot de sortie modifie </dd></dl>

<p>Reimplemented from <a class="el" href="classArray__base.html#af0712503fdbe484e22213d746b1b4c37">Array_base</a>.</p>

<p>Reimplemented in <a class="el" href="classEsp__Dist.html#acbb23ccb07774fb29e0fd9912a630e2c">Esp_Dist</a>, <a class="el" href="classIntTab.html#a32ab42cbc6be5b8f83e2133aacfbe282">IntTab</a>, <a class="el" href="classIntTrav.html#a2d6aa36aaf75a17dfe2b9ac5208ba885">IntTrav</a>, and <a class="el" href="classIntVect.html#a3e21190c2549bb9421f7ba2fd5c3487a">IntVect</a>.</p>

<p>Definition at line <a class="el" href="ArrOfInt_8cpp_source.html#l00264">264</a> of file <a class="el" href="ArrOfInt_8cpp_source.html">ArrOfInt.cpp</a>.</p>

<p>References <a class="el" href="ArrOfInt_8h_source.html#l00176">data_</a>, <a class="el" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>, <a class="el" href="Sortie_8cpp_source.html#l00176">Sortie::put()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00342">size_array()</a>, and <a class="el" href="Nom_8cpp_source.html#l00040">sz</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">int</span> <a class="code" href="Nom_8cpp.html#a0e1ea19fb9fa7881d15d84eff4c090e1">sz</a>=<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>();
  os &lt;&lt; sz &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
  <span class="keywordflow">if</span> (sz &gt; 0)
    {
      <span class="keyword">const</span> <span class="keywordtype">int</span>* v = <a class="code" href="classArrOfInt.html#ab799099ee6d316bdaad7d7f3e99f0637">data_</a>;
      os.<a class="code" href="classSortie.html#aa3f46aaccaff0f83c018784b50d8ea24" title="Methode de bas niveau pour ecrire un tableau d&#39;ints ou reels dans le stream. Dans l&#39;implementation de...">put</a>(v,sz,sz);
    }
  <span class="keywordflow">return</span> os;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a20d8ed6b33d5090632359a10c7ff671c"></a><!-- doxytag: member="ArrOfInt::readOn" ref="a20d8ed6b33d5090632359a10c7ff671c" args="(Entree &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEntree.html">Entree</a> &amp; ArrOfInt::readOn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEntree.html">Entree</a> &amp;&#160;</td>
          <td class="paramname"><em>is</em></td><td>)</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Lecture d'un tableau dans un flot d'entree<br/>
Lit le nombre d'elements suivi des elements eux-memes. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="classEntree.html" title="Classe de definition des operateurs et methodes pour toute lecture dans un flot d&#39;entree (fichier...">Entree</a>&amp;<br/>
 Signification: le flot d'entree modifie<br/>
 Contraintes: </dd></dl>

<p>Reimplemented from <a class="el" href="classArray__base.html#a568a333d18bc619ebfe4da6a38151248">Array_base</a>.</p>

<p>Reimplemented in <a class="el" href="classEsp__Dist.html#a2ab604fb89b3df93b6801744a80e04b5">Esp_Dist</a>, <a class="el" href="classIntTab.html#ac3d58e040e6c3cfb429f6d3a7206bf7e">IntTab</a>, <a class="el" href="classIntTrav.html#a49d453e10ea8566daac141583422c43f">IntTrav</a>, and <a class="el" href="classIntVect.html#a2afffe1eea3d2f91b85573a23ddb8f63">IntVect</a>.</p>

<p>Definition at line <a class="el" href="ArrOfInt_8cpp_source.html#l00291">291</a> of file <a class="el" href="ArrOfInt_8cpp_source.html">ArrOfInt.cpp</a>.</p>

<p>References <a class="el" href="EntreeSortie_8h_source.html#l00032">Cerr</a>, <a class="el" href="ArrOfInt_8h_source.html#l00176">data_</a>, <a class="el" href="Process_8cpp_source.html#l00223">Process::exit()</a>, <a class="el" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>, <a class="el" href="Entree_8cpp_source.html#l00302">Entree::get()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00256">resize_array_()</a>, and <a class="el" href="Nom_8cpp_source.html#l00040">sz</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">int</span> <a class="code" href="Nom_8cpp.html#a0e1ea19fb9fa7881d15d84eff4c090e1">sz</a>;
  is &gt;&gt; <a class="code" href="Nom_8cpp.html#a0e1ea19fb9fa7881d15d84eff4c090e1">sz</a>;
  <span class="keywordflow">if</span> (sz &gt;= 0)
    {
<span class="comment">// Appel a la methode sans precondition sur le type derive</span>
<span class="comment">// (car readOn est virtuelle, les autres proprietes seront initialisees correctement)</span>
      <a class="code" href="classArrOfInt.html#a17a4f4f68e28465b89ef84180bb04406" title="methode protegee de changement de taille, appelable par les classes derivees (idem que resize_array()...">resize_array_</a>(sz);
      <span class="keywordflow">if</span> (sz &gt; 0)
        {
          <span class="keywordtype">int</span>* v = <a class="code" href="classArrOfInt.html#ab799099ee6d316bdaad7d7f3e99f0637">data_</a>;
          is.<a class="code" href="classEntree.html#aa434f5ceb8169e469613d1f6cd1fd99f" title="methode virtuelle pour lire un tableau d&#39;ints ou reels&lt;br&gt;(le tableau doit avoir la bonne dimension: ...">get</a>(v,sz);
        }
    }
  <span class="keywordflow">else</span>
    {
      <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Error in ArrOfInt:readOn : size = &quot;</span> &lt;&lt; sz &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
      assert(0);
      <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">exit</a>();
    }
  <span class="keywordflow">return</span> is;
}
</pre></div>
</div>
</div>
<a class="anchor" id="acdd0214cc8f6c95882e5032b9e3121ea"></a><!-- doxytag: member="ArrOfInt::ref_array" ref="acdd0214cc8f6c95882e5032b9e3121ea" args="(ArrOfInt &amp;, int start=0, int sz=&#45;1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ArrOfInt::ref_array </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>start</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fait pointer le tableau vers les memes donnees qu'un tableau<br/>
existant. Le tableau sera du meme type que le tableau m ("detache",<br/>
"normal"). Le tableau m ne doit pas etre de type "ref_data"<br/>
Attention, le tableau source et *this sont ensuite figes (<a class="el" href="classArrOfInt.html#a9b3afbb46b16870dbd36236c8935b535">resize_array()</a><br/>
interdit).<br/>
Attention: methode virtuelle: dans les classes derivee, cette methode<br/>
initialise les structures pour creer un tableau sequentiel.<br/>
Parametre: const <a class="el" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; m<br/>
Signification: le tableau a referencer (pas de type "ref_data"<br/>
et different de *this !!!) </p>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp;<br/>
 Signification: *this<br/>
 Contraintes: </dd></dl>

<p>Reimplemented in <a class="el" href="classIntTab.html#a42dfa6b5dafbf88d38adae8872a0be0b">IntTab</a>, and <a class="el" href="classIntVect.html#aeba00ad5c640b47a1bc4825a4d8f6e91">IntVect</a>.</p>

<p>Definition at line <a class="el" href="ArrOfInt_8cpp_source.html#l00952">952</a> of file <a class="el" href="ArrOfInt_8cpp_source.html">ArrOfInt.cpp</a>.</p>

<p>References <a class="el" href="ArrOfInt_8cpp_source.html#l01042">attach_array()</a>, and <a class="el" href="ArrOfInt_8cpp_source.html#l01002">detach_array()</a>.</p>

<p>Referenced by <a class="el" href="Scatter_8cpp_source.html#l01725">Traduction_Indice_Global_Local::traduire_espace_virtuel()</a>, and <a class="el" href="Static__Int__Lists_8cpp_source.html#l00091">Static_Int_Lists::trier_liste()</a>.</p>
<div class="fragment"><pre class="fragment">{
  assert(&amp;m != <span class="keyword">this</span>);
<span class="comment">// La condition &#39;m n&#39;est pas de type &quot;ref_data&quot;&#39; est necessaire pour</span>
<span class="comment">// attach_array().</span>
  <a class="code" href="classArrOfInt.html#adb53e0eaa4b61a4b5d68a620c8548543" title="Amene le tableau dans l&#39;etat &quot;detache&quot;. C&#39;est a dire: Si le tableau est &quot;detache&quot; : * ne rien faire...">detach_array</a>();
  <a class="code" href="classArrOfInt.html#aaf31134feae9b3a836eaea860ce952bf" title="Amene le tableau dans l&#39;etat &quot;normal&quot;, &quot;detache&quot; ou &quot;ref_array&quot; en associant une sous-zone de m...">attach_array</a>(m, start, size);
}
</pre></div>
</div>
</div>
<a class="anchor" id="a2e8671e0e07855965bbff4c59582f224"></a><!-- doxytag: member="ArrOfInt::ref_count" ref="a2e8671e0e07855965bbff4c59582f224" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ArrOfInt::ref_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retourne le nombre de references des donnees du tableau<br/>
si le tableau est "normal", -1 s'il est "detache" ou "ref_data". </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>int<br/>
 Signification: ref_count_ </dd></dl>

<p>Definition at line <a class="el" href="ArrOfInt_8cpp_source.html#l01134">1134</a> of file <a class="el" href="ArrOfInt_8cpp_source.html">ArrOfInt.cpp</a>.</p>

<p>References <a class="el" href="ArrOfInt_8h_source.html#l00168">p_</a>, and <a class="el" href="ArrOfInt_8cpp_source.html#l00189">VIntdata::ref_count()</a>.</p>

<p>Referenced by <a class="el" href="ArrOfInt_8cpp_source.html#l00542">memory_resize()</a>, <a class="el" href="Memoire_8cpp_source.html#l00587">operator&lt;&lt;()</a>, and <a class="el" href="ArrOfInt_8h_source.html#l00256">resize_array_()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">if</span> (<a class="code" href="classArrOfInt.html#a54afaafbf7fa8c80696da7a2c3d3f48b">p_</a>)
    <span class="keywordflow">return</span> <a class="code" href="classArrOfInt.html#a54afaafbf7fa8c80696da7a2c3d3f48b">p_</a>-&gt;<a class="code" href="classVIntdata.html#af3c05d8376b864fd8695fe5ebaebe71c" title="renvoie ref_count_">ref_count</a>();
  <span class="keywordflow">else</span>
    <span class="keywordflow">return</span> -1;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a95b02281f2d3f210e463389ff7288169"></a><!-- doxytag: member="ArrOfInt::ref_data" ref="a95b02281f2d3f210e463389ff7288169" args="(int *ptr, int size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ArrOfInt::ref_data </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fait pointer le tableau vers la zone de memoire "data_".<br/>
On detache la zone de memoire existante. Le tableau devient<br/>
de type "ref_data". Attention : ptr doit etre non nul.<br/>
La taille est initialisee avec size.<br/>
Attention: methode virtuelle: dans les classes derivee, cette methode<br/>
initialise les structures pour creer un tableau sequentiel.<br/>
Pour faire une ref sur un tableau parallele utiliser <a class="el" href="classIntVect.html#a165455689c6d27ac93c9cf8823e47a0f" title="detache le tableau et l&#39;attache a v (sauf si v==*this, ne fait rien) Fait pointer le tableau sur la m...">IntVect::ref()</a><br/>
Parametre: int*<br/>
Signification: le tableau a recuperer. Si pointeur nul alors size<br/>
doit etre nulle aussi et le tableau reste detache<br/>
Parametre: int size<br/>
Signification: le nombre d'elements du tableau. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp;<br/>
 Signification: *this </dd></dl>

<p><p>&lt; Pour passer les tests si on resize a la meme taille </p>
</p>

<p>Reimplemented in <a class="el" href="classIntTab.html#a9fc9043361eded7804f208d8e1f87f45">IntTab</a>, and <a class="el" href="classIntVect.html#aca0cf803f3b217131c25563773c9f043">IntVect</a>.</p>

<p>Definition at line <a class="el" href="ArrOfInt_8cpp_source.html#l00976">976</a> of file <a class="el" href="ArrOfInt_8cpp_source.html">ArrOfInt.cpp</a>.</p>

<p>References <a class="el" href="ArrOfInt_8h_source.html#l00176">data_</a>, <a class="el" href="ArrOfInt_8cpp_source.html#l01002">detach_array()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00185">memory_size_</a>, and <a class="el" href="ArrOfInt_8h_source.html#l00180">size_array_</a>.</p>

<p>Referenced by <a class="el" href="Partitionneur__Tranche_8cpp_source.html#l00185">Partitionneur_Tranche::construire_partition()</a>, <a class="el" href="Schema__Comm__Vecteurs_8h_source.html#l00169">Schema_Comm_Vecteurs::get_next_area_int()</a>, and <a class="el" href="Solv__GCP_8cpp_source.html#l00124">Solv_GCP::prepare_data()</a>.</p>
<div class="fragment"><pre class="fragment">{
  assert(ptr != 0 || size == 0);
  assert(size &gt;= 0);
  <a class="code" href="classArrOfInt.html#adb53e0eaa4b61a4b5d68a620c8548543" title="Amene le tableau dans l&#39;etat &quot;detache&quot;. C&#39;est a dire: Si le tableau est &quot;detache&quot; : * ne rien faire...">detach_array</a>();
  <a class="code" href="classArrOfInt.html#ab799099ee6d316bdaad7d7f3e99f0637">data_</a> = ptr;
  <a class="code" href="classArrOfInt.html#a23d1b6526fd584ba8de321ee7d1f1c1b">size_array_</a> = size;
  <a class="code" href="classArrOfInt.html#a9cda25dd5c640c8523243990b6c0b845">memory_size_</a> = size; <span class="comment">//!&lt; Pour passer les tests si on resize a la meme taille</span>
<span class="comment"></span>}
</pre></div>
</div>
</div>
<a class="anchor" id="afc932bc1df352ead26b844dcb090dacc"></a><!-- doxytag: member="ArrOfInt::reset" ref="afc932bc1df352ead26b844dcb090dacc" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ArrOfInt::reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Remet le tableau dans l'etat obtenu avec le constructeur par defaut<br/>
(libere la memoire mais conserve le mode d'allocation memoire actuel) </p>

<p>Reimplemented in <a class="el" href="classIntTab.html#ac66710ddde96fe2745f341a0166b3b34">IntTab</a>, and <a class="el" href="classIntVect.html#a273976ecf3d2d4fdbdc48ab446027e8e">IntVect</a>.</p>

<p>Definition at line <a class="el" href="ArrOfInt_8cpp_source.html#l00452">452</a> of file <a class="el" href="ArrOfInt_8cpp_source.html">ArrOfInt.cpp</a>.</p>

<p>References <a class="el" href="ArrOfInt_8cpp_source.html#l01002">detach_array()</a>.</p>

<p>Referenced by <a class="el" href="Domaine__bord_8cpp_source.html#l00109">Domaine_bord::extraire_domaine_bord()</a>, <a class="el" href="Domaine_8cpp_source.html#l00132">Domaine::read_vertices()</a>, <a class="el" href="Domaine_8cpp_source.html#l00090">Domaine::readOn()</a>, <a class="el" href="Octree__Int_8cpp_source.html#l00290">Octree_Int::reset()</a>, <a class="el" href="Joint__Items_8cpp_source.html#l00038">Joint_Items::reset()</a>, and <a class="el" href="DomaineCutter__Correspondance_8cpp_source.html#l00031">DomaineCutter_Correspondance::reset()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <a class="code" href="classArrOfInt.html#adb53e0eaa4b61a4b5d68a620c8548543" title="Amene le tableau dans l&#39;etat &quot;detache&quot;. C&#39;est a dire: Si le tableau est &quot;detache&quot; : * ne rien faire...">detach_array</a>();
}
</pre></div>
</div>
</div>
<a class="anchor" id="a15fc7e3958f02cb38d3106eeb919f6fc"></a><!-- doxytag: member="ArrOfInt::resize" ref="a15fc7e3958f02cb38d3106eeb919f6fc" args="(int new_size, Array_base::Resize_Options opt=COPY_INIT)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ArrOfInt::resize </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>new_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArray__base.html#abee342aa9ac59623c4c782dc9d7877ff">Array_base::Resize_Options</a>&#160;</td>
          <td class="paramname"><em>opt</em> = <code>COPY_INIT</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>appel a <a class="el" href="classArrOfInt.html#a9b3afbb46b16870dbd36236c8935b535">ArrOfInt::resize_array()</a> </p>

<p>Reimplemented in <a class="el" href="classIntTab.html#a22e6bed6826b3688d4d0181cbf3b7a38">IntTab</a>, and <a class="el" href="classIntVect.html#a5900779fd9a3f9a82c68007a42b87d98">IntVect</a>.</p>

<p>Definition at line <a class="el" href="ArrOfInt_8h_source.html#l00248">248</a> of file <a class="el" href="ArrOfInt_8h_source.html">ArrOfInt.h</a>.</p>

<p>References <a class="el" href="ArrOfInt_8h_source.html#l00240">resize_array()</a>.</p>

<p>Referenced by <a class="el" href="Partitionneur__Tranche_8cpp_source.html#l00067">Partitionneur_Tranche::associer_domaine()</a>, <a class="el" href="Polyedre_8cpp_source.html#l00671">Polyedre::compute_virtual_index()</a>, <a class="el" href="DomaineCutter_8cpp_source.html#l00192">construire_elems_sous_domaine()</a>, <a class="el" href="ConstDoubleTab__parts_8cpp_source.html#l00028">init_parts()</a>, <a class="el" href="MD__Vector__std_8cpp_source.html#l00065">MD_Vector_std::MD_Vector_std()</a>, and <a class="el" href="Champ__Fonc__MED_8cpp_source.html#l00077">Champ_Fonc_MED::readOn()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <a class="code" href="classArrOfInt.html#a9b3afbb46b16870dbd36236c8935b535">resize_array</a>(new_size, opt);
}
</pre></div>
</div>
</div>
<a class="anchor" id="a9b3afbb46b16870dbd36236c8935b535"></a><!-- doxytag: member="ArrOfInt::resize_array" ref="a9b3afbb46b16870dbd36236c8935b535" args="(int new_size, Array_base::Resize_Options opt=COPY_INIT)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ArrOfInt::resize_array </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>new_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArray__base.html#abee342aa9ac59623c4c782dc9d7877ff">Array_base::Resize_Options</a>&#160;</td>
          <td class="paramname"><em>opt</em> = <code>COPY_INIT</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="ArrOfInt_8h_source.html#l00240">240</a> of file <a class="el" href="ArrOfInt_8h_source.html">ArrOfInt.h</a>.</p>

<p>References <a class="el" href="ArrOfInt_8cpp_source.html#l00038">get_info()</a>, <a class="el" href="ArrOfInt_8cpp_source.html#l00038">info()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00256">resize_array_()</a>, and <a class="el" href="ArrOfInt_8h_source.html#l00180">size_array_</a>.</p>

<p>Referenced by <a class="el" href="RTabInt_8cpp_source.html#l00084">RTabInt::add()</a>, <a class="el" href="CSR__Builder_8h_source.html#l00054">CSR_Builder::add_coeff()</a>, <a class="el" href="Op__Conv__VEF__Face_8cpp_source.html#l00121">Op_Conv_VEF_Face::ajouter()</a>, <a class="el" href="Polyedre_8cpp_source.html#l00585">Polyedre::ajouter_elements()</a>, <a class="el" href="Scatter_8cpp_source.html#l01151">Scatter::ajouter_joints()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00355">append_array()</a>, <a class="el" href="Array__tools_8cpp_source.html#l00515">append_array_to_array()</a>, <a class="el" href="MD__Vector__composite_8cpp_source.html#l00115">append_blocs()</a>, <a class="el" href="MD__Vector__composite_8cpp_source.html#l00136">append_global_md()</a>, <a class="el" href="MD__Vector__composite_8cpp_source.html#l00102">append_items()</a>, <a class="el" href="Array__tools_8cpp_source.html#l00078">array_calculer_intersection()</a>, <a class="el" href="Scatter_8cpp_source.html#l00806">array_retirer_elements()</a>, <a class="el" href="Array__tools_8cpp_source.html#l00497">array_smart_allocate()</a>, <a class="el" href="ArrOfInt_8cpp_source.html#l00911">array_trier_retirer_doublons()</a>, <a class="el" href="Scatter_8cpp_source.html#l00778">array_trier_retirer_doublons()</a>, <a class="el" href="MaillerParallel_8cpp_source.html#l00421">auto_build_joints()</a>, <a class="el" href="Schema__Comm__Vecteurs_8cpp_source.html#l00088">Schema_Comm_Vecteurs::begin_init()</a>, <a class="el" href="Octree__Int_8cpp_source.html#l00088">Octree_Int::build()</a>, <a class="el" href="Octree__Int_8cpp_source.html#l00300">Octree_Int::build_octree_floor()</a>, <a class="el" href="Octree__Int_8cpp_source.html#l00316">Octree_Int::build_octree_recursively()</a>, <a class="el" href="Scatter_8cpp_source.html#l02184">Scatter::calculer_espace_distant_elements()</a>, <a class="el" href="Scatter_8cpp_source.html#l01219">calculer_espace_distant_item()</a>, <a class="el" href="Array__tools_8cpp_source.html#l00456">calculer_renum_sans_doublons()</a>, <a class="el" href="Partitionneur__Tranche_8cpp_source.html#l00128">Partitionneur_Tranche::chercher_direction_perio()</a>, <a class="el" href="Partitionneur__base_8cpp_source.html#l00103">chercher_elems_voisins_faces()</a>, <a class="el" href="Terme__Source__Rappel__T__VEF__Face_8cpp_source.html#l00125">Terme_Source_Rappel_T_VEF_Face::completer()</a>, <a class="el" href="Periodique_8cpp_source.html#l00072">Periodique::completer()</a>, <a class="el" href="Connex__components_8cpp_source.html#l00215">compute_global_connex_components()</a>, <a class="el" href="Scatter_8cpp_source.html#l02653">Scatter::construire_correspondance_items_par_coordonnees()</a>, <a class="el" href="DomaineCutter_8cpp_source.html#l00517">DomaineCutter::construire_elements_distants_ssdom()</a>, <a class="el" href="Domain__Graph_8cpp_source.html#l00170">Domain_Graph::construire_graph_elem_elem()</a>, <a class="el" href="Domain__Graph_8cpp_source.html#l00102">Domain_Graph::construire_graph_from_segment()</a>, <a class="el" href="DomaineCutter_8cpp_source.html#l00091">construire_liste_sommets_sousdomaine()</a>, <a class="el" href="Scatter_8cpp_source.html#l01409">Scatter::construire_md_vector()</a>, <a class="el" href="Partitionneur__Tranche_8cpp_source.html#l00185">Partitionneur_Tranche::construire_partition()</a>, <a class="el" href="Partitionneur__Ptscotch_8cpp_source.html#l00085">Partitionneur_Ptscotch::construire_partition()</a>, <a class="el" href="Partitionneur__Parmetis_8cpp_source.html#l00085">Partitionneur_Parmetis::construire_partition()</a>, <a class="el" href="Zone__VEF__PreP1b_8cpp_source.html#l00504">Zone_VEF_PreP1b::construire_renum_arete_perio()</a>, <a class="el" href="DomaineCutter_8cpp_source.html#l00643">DomaineCutter::construire_sommets_joints_ssdom()</a>, <a class="el" href="Zone__Cl__EF_8cpp_source.html#l00117">construit_connectivite_sommet()</a>, <a class="el" href="Static__Int__Lists_8cpp_source.html#l00109">Static_Int_Lists::copy_list_to_array()</a>, <a class="el" href="Partitionneur__base_8cpp_source.html#l00260">Partitionneur_base::corriger_sommets_bord()</a>, <a class="el" href="Faces__builder_8cpp_source.html#l00940">Zone::creer_aretes()</a>, <a class="el" href="Faces__builder_8cpp_source.html#l00070">Faces_builder::creer_faces_reeles()</a>, <a class="el" href="Zone__VEF_8cpp_source.html#l00565">Zone_VEF::creer_faces_virtuelles_non_std()</a>, <a class="el" href="Zone__PolyMAC_8cpp_source.html#l00830">Zone_PolyMAC::creer_faces_virtuelles_non_std()</a>, <a class="el" href="Zone__EF_8cpp_source.html#l00908">Zone_EF::creer_faces_virtuelles_non_std()</a>, <a class="el" href="MD__Vector__tools_8cpp_source.html#l00341">creer_md_vect_renum()</a>, <a class="el" href="Schema__Comm_8cpp_source.html#l00261">Schema_Comm::echange_taille()</a>, <a class="el" href="Schema__Comm_8cpp_source.html#l00380">Schema_Comm::echange_taille_et_messages()</a>, <a class="el" href="DomaineCutter_8cpp_source.html#l01268">DomaineCutter::ecrire_zones()</a>, <a class="el" href="Schema__Comm__Vecteurs_8cpp_source.html#l00110">Schema_Comm_Vecteurs::end_init()</a>, <a class="el" href="communications_8cpp_source.html#l00473">envoyer_all_to_all()</a>, <a class="el" href="MD__Vector__tools_8cpp_source.html#l00302">extract_blocs()</a>, <a class="el" href="ILU_8cpp_source.html#l00126">ILU::factoriser()</a>, <a class="el" href="Connectivite__som__elem_8cpp_source.html#l00108">find_adjacent_elements()</a>, <a class="el" href="Octree__Zone_8cpp_source.html#l00055">Octree_Zone::find_elements()</a>, <a class="el" href="MaillerParallel_8cpp_source.html#l00232">find_matching_coordinates()</a>, <a class="el" href="Champ__Generique__Interpolation_8cpp_source.html#l00226">Champ_Generique_Interpolation::get_champ_with_calculer_champ_post()</a>, <a class="el" href="MD__Vector__tools_8cpp_source.html#l00286">MD_Vector_tools::get_sequential_items_flags()</a>, <a class="el" href="Matrice__Morse_8cpp_source.html#l01920">Matrice_Morse::get_stencil()</a>, <a class="el" href="Matrice__Morse_8cpp_source.html#l01968">Matrice_Morse::get_stencil_and_coefficients()</a>, <a class="el" href="Matrice__Morse__Sym_8cpp_source.html#l00693">Matrice_Morse_Sym::get_symmetric_stencil()</a>, <a class="el" href="Matrice__Morse__Sym_8cpp_source.html#l00748">Matrice_Morse_Sym::get_symmetric_stencil_and_coefficients()</a>, <a class="el" href="Faces__builder_8cpp_source.html#l00751">Zone::init_faces_virt_bord()</a>, <a class="el" href="Comm__Group_8cpp_source.html#l00089">Comm_Group::init_group()</a>, <a class="el" href="Comm__Group_8cpp_source.html#l00146">Comm_Group::init_group_trio()</a>, <a class="el" href="ConstDoubleTab__parts_8cpp_source.html#l00028">init_parts()</a>, <a class="el" href="Scatter_8cpp_source.html#l02845">init_simple_md_vector()</a>, <a class="el" href="Raccord__distant__homogene_8cpp_source.html#l00267">Raccord_distant_homogene::initialise()</a>, <a class="el" href="Ch__front__Vortex_8cpp_source.html#l00198">Ch_front_Vortex::initialiser()</a>, <a class="el" href="Execute__parallel_8cpp_source.html#l00059">Execute_parallel::interpreter()</a>, <a class="el" href="MaillerParallel_8cpp_source.html#l00534">MaillerParallel::interpreter()</a>, <a class="el" href="Remove__Invalid__Internal__Boundaries_8cpp_source.html#l00044">Remove_Invalid_Internal_Boundaries::interpreter_()</a>, <a class="el" href="Lire__Tgrid_8cpp_source.html#l00244">Lire_Tgrid::interpreter_()</a>, <a class="el" href="EcritureLectureSpecial_8cpp_source.html#l00328">lire_special()</a>, <a class="el" href="Assembleur__P__VDF_8cpp_source.html#l00065">Assembleur_P_VDF::liste_faces_periodiques()</a>, <a class="el" href="Op__EF__base_8cpp_source.html#l00475">Op_EF_base::marque_elem()</a>, <a class="el" href="Zone__VF_8cpp_source.html#l00508">Zone_VF::marquer_faces_double_contrib()</a>, <a class="el" href="MD__Vector__std_8cpp_source.html#l00065">MD_Vector_std::MD_Vector_std()</a>, <a class="el" href="Chimie_8cpp_source.html#l00200">Chimie::mettre_a_jour()</a>, <a class="el" href="Raffiner__isotrope__parallele_8cpp_source.html#l00055">mon_construire_correspondance_items_par_coordonnees()</a>, <a class="el" href="ArrOfInt_8cpp_source.html#l00468">operator=()</a>, <a class="el" href="DomaineCutter_8cpp_source.html#l00432">parcourir_epaisseurs_elements()</a>, <a class="el" href="Octree_8cpp_source.html#l01377">OctreeRoot::rang_arete()</a>, <a class="el" href="Octree_8cpp_source.html#l01426">OctreeRoot::rang_elem()</a>, <a class="el" href="Octree_8cpp_source.html#l01482">OctreeRoot::rang_elem_depuis()</a>, <a class="el" href="Octree_8cpp_source.html#l01543">OctreeRoot::rang_elems_sommet()</a>, <a class="el" href="Octree_8cpp_source.html#l01322">OctreeRoot::rang_sommet()</a>, <a class="el" href="Sous__Zone_8cpp_source.html#l00096">Sous_Zone::readOn()</a>, <a class="el" href="Probleme__Couple_8cpp_source.html#l00147">Probleme_Couple::readOn()</a>, <a class="el" href="Champ__front__contact__VEF_8cpp_source.html#l00608">Champ_front_contact_VEF::remplir_connect_bords()</a>, <a class="el" href="Op__Diff__EF_8cpp_source.html#l00091">remplir_marqueur_sommet_neumann()</a>, <a class="el" href="Zone__Cl__EF_8cpp_source.html#l00176">Zone_Cl_EF::remplir_type_elem_Cl()</a>, <a class="el" href="Matrice__Morse__Sym_8cpp_source.html#l00988">Matrice_Morse_Sym::renumerote()</a>, <a class="el" href="Static__Int__Lists_8cpp_source.html#l00026">Static_Int_Lists::reset()</a>, <a class="el" href="RTabInt_8h_source.html#l00082">RTabInt::resize()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00248">resize()</a>, <a class="el" href="ArrOfInt_8cpp_source.html#l00513">resize_tab()</a>, <a class="el" href="communications_8cpp_source.html#l00561">reverse_send_recv_pe_list()</a>, <a class="el" href="RTabInt_8cpp_source.html#l00058">RTabInt::RTabInt()</a>, <a class="el" href="Connex__components_8cpp_source.html#l00048">search_connex_components_local()</a>, <a class="el" href="Octree__Int_8cpp_source.html#l00173">Octree_Int::search_elements_box()</a>, <a class="el" href="Octree__Double_8cpp_source.html#l00244">Octree_Double::search_elements_box()</a>, <a class="el" href="Octree__Double_8cpp_source.html#l00289">Octree_Double::search_nodes_close_to()</a>, <a class="el" href="Static__Int__Lists_8cpp_source.html#l00155">Static_Int_Lists::set()</a>, <a class="el" href="Static__Int__Lists_8cpp_source.html#l00036">Static_Int_Lists::set_list_sizes()</a>, <a class="el" href="Array__tools_8cpp_source.html#l00342">tri_lexicographique_tableau_indirect()</a>, <a class="el" href="Trier_8cpp_source.html#l00072">trier()</a>, and <a class="el" href="Trier_8cpp_source.html#l00060">trier_abs()</a>.</p>
<div class="fragment"><pre class="fragment">{
<span class="comment">// Si le tableau change de taille, il doit etre du type ArrOfInt</span>
  assert(new_size == <a class="code" href="classArrOfInt.html#a23d1b6526fd584ba8de321ee7d1f1c1b">size_array_</a> || <a class="code" href="classArrOfInt.html#a7dd6de7c430472331cf0d42d2c1dac9e" title="Donne des informations sur le type de l&#39;Objet_U.">get_info</a>() == <a class="code" href="classArrOfInt.html#a32f629b94dc0867e56395ba5eb316a9a" title="Donne des informations sur le type de l&#39;Objet_U.">ArrOfInt::info</a>());
  <a class="code" href="classArrOfInt.html#a17a4f4f68e28465b89ef84180bb04406" title="methode protegee de changement de taille, appelable par les classes derivees (idem que resize_array()...">resize_array_</a>(new_size, opt);
}
</pre></div>
</div>
</div>
<a class="anchor" id="a17a4f4f68e28465b89ef84180bb04406"></a><!-- doxytag: member="ArrOfInt::resize_array_" ref="a17a4f4f68e28465b89ef84180bb04406" args="(int n, Array_base::Resize_Options opt=COPY_INIT)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ArrOfInt::resize_array_ </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArray__base.html#abee342aa9ac59623c4c782dc9d7877ff">Array_base::Resize_Options</a>&#160;</td>
          <td class="paramname"><em>opt</em> = <code>COPY_INIT</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>methode protegee de changement de taille, appelable par<br/>
les classes derivees (idem que <a class="el" href="classArrOfInt.html#a9b3afbb46b16870dbd36236c8935b535">resize_array()</a> mais sans condition sur le<br/>
type derive de l'objet) </p>

<p>Definition at line <a class="el" href="ArrOfInt_8h_source.html#l00256">256</a> of file <a class="el" href="ArrOfInt_8h_source.html">ArrOfInt.h</a>.</p>

<p>References <a class="el" href="Array__base_8h_source.html#l00038">Array_base::COPY_INIT</a>, <a class="el" href="ArrOfInt_8h_source.html#l00176">data_</a>, <a class="el" href="ArrOfInt_8cpp_source.html#l00542">memory_resize()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00185">memory_size_</a>, <a class="el" href="ArrOfInt_8h_source.html#l00168">p_</a>, <a class="el" href="ArrOfInt_8cpp_source.html#l01134">ref_count()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00180">size_array_</a>, and <a class="el" href="ArrOfInt_8h_source.html#l00191">smart_resize_</a>.</p>

<p>Referenced by <a class="el" href="IntVect_8cpp_source.html#l00190">IntVect::copy_()</a>, <a class="el" href="ArrOfInt_8cpp_source.html#l00291">readOn()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00240">resize_array()</a>, and <a class="el" href="IntVect_8h_source.html#l00191">IntVect::resize_vect_()</a>.</p>
<div class="fragment"><pre class="fragment">{
  assert(new_size &gt;= 0);
<span class="comment">// Soit le tableau est detache (data_==0), soit il est normal (p_!=0)</span>
<span class="comment">// S&#39;il est normal, il ne faut pas qu&#39;il y ait d&#39;autre reference au tableau,</span>
<span class="comment">// ou alors la taille ne doit pas changer.</span>
  assert(new_size == <a class="code" href="classArrOfInt.html#a23d1b6526fd584ba8de321ee7d1f1c1b">size_array_</a> || <a class="code" href="classArrOfInt.html#ab799099ee6d316bdaad7d7f3e99f0637">data_</a> == 0 || (<a class="code" href="classArrOfInt.html#a54afaafbf7fa8c80696da7a2c3d3f48b">p_</a> != 0 &amp;&amp; <a class="code" href="classArrOfInt.html#a2e8671e0e07855965bbff4c59582f224" title="Retourne le nombre de references des donnees du tableau si le tableau est &quot;normal&quot;, -1 s&#39;il est &quot;detache&quot; ou &quot;ref_data&quot;.">ref_count</a>() == 1));
<span class="comment">// Le seul cas ou on n&#39;appelle pas memory_resize est le suivant:</span>
<span class="comment">// le tableau est smart_resize</span>
<span class="comment">// ET la taille reste inferieure ou egale a la taille allouee</span>
<span class="comment">// ET on ne veut pas initialiser les nouvelles cases</span>
  <span class="keywordflow">if</span> ((opt == <a class="code" href="classArray__base.html#abee342aa9ac59623c4c782dc9d7877ffa9a675e25b5b7accff8d861e05060547b">COPY_INIT</a>) || (new_size &gt; <a class="code" href="classArrOfInt.html#a9cda25dd5c640c8523243990b6c0b845">memory_size_</a>) || (<a class="code" href="classArrOfInt.html#a9170b6699fa2b83ccc8c9a451e18bd44">smart_resize_</a> == 0))
<span class="comment">// attention, il existe un cas ou memory_resize realloue un buffer meme si size_array_==new_size:</span>
<span class="comment">// si on est passe de smart_resize=1 a smart_resize=0, on realloue juste ce qu&#39;il faut.</span>
    <a class="code" href="classArrOfInt.html#a1bdac0af7218a7a9d6abf1709feffc17" title="Si besoin, alloue une nouvelle zone de memoire, copie les donnees et efface l&#39;ancienne zone de memoir...">memory_resize</a>(new_size, opt);
  <a class="code" href="classArrOfInt.html#a23d1b6526fd584ba8de321ee7d1f1c1b">size_array_</a> = new_size;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a2a8d5b9b592390c7d54d54742977d200"></a><!-- doxytag: member="ArrOfInt::resize_tab" ref="a2a8d5b9b592390c7d54d54742977d200" args="(int n, Array_base::Resize_Options opt=COPY_INIT)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ArrOfInt::resize_tab </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArray__base.html#abee342aa9ac59623c4c782dc9d7877ff">Array_base::Resize_Options</a>&#160;</td>
          <td class="paramname"><em>opt</em> = <code>COPY_INIT</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>methode virtuelle identique a <a class="el" href="classArrOfInt.html#a9b3afbb46b16870dbd36236c8935b535">resize_array()</a>, permet de traiter<br/>
de facon generique les ArrOf, Vect et Tab.<br/>
Si l'objet est de type <a class="el" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>, appel a resize_array(n)<br/>
Prerequis: le tableau doit etre "resizable" (voir <a class="el" href="classArrOfInt.html#a9b3afbb46b16870dbd36236c8935b535">resize_array()</a>).<br/>
S'il est d'un type derive (Vect ou Tab), il ne doit pas avoir de descripteur<br/>
parallele si la taille est effectivement modifiee. </p>

<p>Reimplemented in <a class="el" href="classIntTab.html#aa8b19e31c33993156e0e3cd1f315c1b5">IntTab</a>, and <a class="el" href="classIntVect.html#a220fdf0488ad21f64f4c89891651841c">IntVect</a>.</p>

<p>Definition at line <a class="el" href="ArrOfInt_8cpp_source.html#l00513">513</a> of file <a class="el" href="ArrOfInt_8cpp_source.html">ArrOfInt.cpp</a>.</p>

<p>References <a class="el" href="ArrOfInt_8h_source.html#l00240">resize_array()</a>.</p>

<p>Referenced by <a class="el" href="Zone_8cpp_source.html#l00360">Zone::chercher_elements()</a>, and <a class="el" href="Champ__front__recyclage_8cpp_source.html#l00472">Champ_front_recyclage::initialiser()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <a class="code" href="classArrOfInt.html#a9b3afbb46b16870dbd36236c8935b535">resize_array</a>(n, opt);
}
</pre></div>
</div>
</div>
<a class="anchor" id="a90c131eb221769da60d9bc77fa432bcb"></a><!-- doxytag: member="ArrOfInt::self_cast" ref="a90c131eb221769da60d9bc77fa432bcb" args="(const Objet_U &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp; ArrOfInt::self_cast </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classObjet__U.html">Objet_U</a> &amp;&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>methode ajoutee pour caster en python </p>

<p>Reimplemented from <a class="el" href="classArray__base.html#a64527ccffc076b9bf4777de657a636e5">Array_base</a>.</p>

<p>Reimplemented in <a class="el" href="classEsp__Dist.html#aa2b50802582c671252c3c6acd772a846">Esp_Dist</a>, <a class="el" href="classIntTab.html#ad174adc199ebb42810210e7ff8a67420">IntTab</a>, <a class="el" href="classIntTrav.html#a20166c53b260e13437d8ffb2fed54e08">IntTrav</a>, and <a class="el" href="classIntVect.html#a3ca22cbd556e588c550df446b1c35c85">IntVect</a>.</p>

<p>Definition at line <a class="el" href="ArrOfInt_8cpp_source.html#l00038">38</a> of file <a class="el" href="ArrOfInt_8cpp_source.html">ArrOfInt.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{
</pre></div>
</div>
</div>
<a class="anchor" id="acb778cd9e23f16950cd99e0faac8d0b6"></a><!-- doxytag: member="ArrOfInt::self_cast" ref="acb778cd9e23f16950cd99e0faac8d0b6" args="(Objet_U &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp; ArrOfInt::self_cast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classObjet__U.html">Objet_U</a> &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="classArray__base.html#a2caf0d582315a1559c4eef365c47c7a1">Array_base</a>.</p>

<p>Reimplemented in <a class="el" href="classEsp__Dist.html#a7224b1bd04e9e6cc71f6eb9b6a78b355">Esp_Dist</a>, <a class="el" href="classIntTab.html#af14be73bc740acc62f8132df6c2997b5">IntTab</a>, <a class="el" href="classIntTrav.html#a67b981e22e67d0c490f17808406a6f70">IntTrav</a>, and <a class="el" href="classIntVect.html#add13cabec411f731b82d54caf716fd92">IntVect</a>.</p>

<p>Definition at line <a class="el" href="ArrOfInt_8cpp_source.html#l00038">38</a> of file <a class="el" href="ArrOfInt_8cpp_source.html">ArrOfInt.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{
</pre></div>
</div>
</div>
<a class="anchor" id="a95dce3e5a03c189d89146d9fd34e8d07"></a><!-- doxytag: member="ArrOfInt::set_mem_storage" ref="a95dce3e5a03c189d89146d9fd34e8d07" args="(const Storage storage)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ArrOfInt::set_mem_storage </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classArrOfInt.html#ae96e99b17332a05cd91a09a2b6bb3cc4">Storage</a>&#160;</td>
          <td class="paramname"><em>storage</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Change le mode d'allocation memoire lors des resize&lt;br&gt;(voir VIntdata et Int_ptr_trav)<br/>
Exemple pour creer un tableau avec allocation temporaire:<br/>
<a class="el" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a> tab; // Creation d'un tableau vide<br/>
tab.set_mem_storage(TEMP_STORAGE); // Changement de mode d'allocation<br/>
tab.resize(n); // Allocation memoire. </p>

<p>Definition at line <a class="el" href="ArrOfInt_8cpp_source.html#l00424">424</a> of file <a class="el" href="ArrOfInt_8cpp_source.html">ArrOfInt.cpp</a>.</p>

<p>References <a class="el" href="ArrOfInt_8h_source.html#l00195">storage_type_</a>.</p>

<p>Referenced by <a class="el" href="IntTrav_8cpp_source.html#l00051">IntTrav::IntTrav()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <a class="code" href="classArrOfInt.html#a5a5cbc9e1c2d4ba877ca0bd697ea56bc">storage_type_</a> = storage;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a22d744bcd452d039580d1d9186f02b4e"></a><!-- doxytag: member="ArrOfInt::set_smart_resize" ref="a22d744bcd452d039580d1d9186f02b4e" args="(int flag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ArrOfInt::set_smart_resize </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Change le mode l'allocation memoire: reallocation d'un tableau<br/>
a chaque changement de taille (flag = 0) ou reallocation<br/>
uniquement si la taille augmente et par doublement de la taille<br/>
du tableau (flag = 1). </p>

<p>Definition at line <a class="el" href="ArrOfInt_8cpp_source.html#l00443">443</a> of file <a class="el" href="ArrOfInt_8cpp_source.html">ArrOfInt.cpp</a>.</p>

<p>References <a class="el" href="ArrOfInt_8h_source.html#l00191">smart_resize_</a>.</p>

<p>Referenced by <a class="el" href="Objet__a__lire_8cpp_source.html#l00155">Objet_a_lire::add_dict()</a>, <a class="el" href="MD__Vector__composite_8cpp_source.html#l00307">MD_Vector_composite::add_part()</a>, <a class="el" href="Debog_8cpp_source.html#l00311">Debog_Pb::add_renum_item()</a>, <a class="el" href="Domaine_8cpp_source.html#l00259">Domaine::ajouter()</a>, <a class="el" href="Sonde_8cpp_source.html#l01493">Sonde::ajouter_bords()</a>, <a class="el" href="Polyedre_8cpp_source.html#l00585">Polyedre::ajouter_elements()</a>, <a class="el" href="Scatter_8cpp_source.html#l01151">Scatter::ajouter_joints()</a>, <a class="el" href="Matrix__tools_8cpp_source.html#l00268">Matrix_tools::allocate_for_scaled_addition()</a>, <a class="el" href="Matrix__tools_8cpp_source.html#l00311">Matrix_tools::allocate_for_symmetric_scaled_addition()</a>, <a class="el" href="MD__Vector__composite_8cpp_source.html#l00136">append_global_md()</a>, <a class="el" href="Array__tools_8cpp_source.html#l00497">array_smart_allocate()</a>, <a class="el" href="SETS_8cpp_source.html#l00496">SETS::assembler()</a>, <a class="el" href="Assembleur__P__PolyMAC_8cpp_source.html#l00091">Assembleur_P_PolyMAC::assembler_mat()</a>, <a class="el" href="Assembleur__P__CoviMAC_8cpp_source.html#l00068">Assembleur_P_CoviMAC::assembler_mat()</a>, <a class="el" href="Octree__Int_8cpp_source.html#l00088">Octree_Int::build()</a>, <a class="el" href="Raffiner__Simplexes_8cpp_source.html#l00512">build_edges()</a>, <a class="el" href="Raffiner__Simplexes_8cpp_source.html#l00722">build_frontier()</a>, <a class="el" href="Polygone_8cpp_source.html#l00092">Polygone::build_reduced()</a>, <a class="el" href="Polyedre_8cpp_source.html#l00649">Polyedre::build_reduced()</a>, <a class="el" href="Moyenne__volumique_8cpp_source.html#l00548">Calcul_integrale_locale::Calcul_integrale_locale()</a>, <a class="el" href="DomaineCutter_8cpp_source.html#l01002">calculer_elements_voisins_bords()</a>, <a class="el" href="Scatter_8cpp_source.html#l00937">Scatter::calculer_espace_distant()</a>, <a class="el" href="Scatter_8cpp_source.html#l02184">Scatter::calculer_espace_distant_elements()</a>, <a class="el" href="Scatter_8cpp_source.html#l01219">calculer_espace_distant_item()</a>, <a class="el" href="Partitionneur__base_8cpp_source.html#l00147">Partitionneur_base::calculer_graphe_connexions_periodiques()</a>, <a class="el" href="Scatter_8cpp_source.html#l01929">calculer_liste_complete_aretes_joint()</a>, <a class="el" href="Scatter_8cpp_source.html#l01899">calculer_liste_complete_sommets_joint()</a>, <a class="el" href="Scatter_8cpp_source.html#l01353">Scatter::calculer_renum_items_communs()</a>, <a class="el" href="Array__tools_8cpp_source.html#l00456">calculer_renum_sans_doublons()</a>, <a class="el" href="Scatter_8cpp_source.html#l00297">Scatter::check_consistancy_remote_items()</a>, <a class="el" href="Raccord__distant__homogene_8cpp_source.html#l00237">Raccord_distant_homogene::completer()</a>, <a class="el" href="Connex__components_8cpp_source.html#l00215">compute_global_connex_components()</a>, <a class="el" href="DomaineCutter_8cpp_source.html#l00517">DomaineCutter::construire_elements_distants_ssdom()</a>, <a class="el" href="DomaineCutter_8cpp_source.html#l00736">DomaineCutter::construire_faces_joints_ssdom()</a>, <a class="el" href="Domain__Graph_8cpp_source.html#l00170">Domain_Graph::construire_graph_elem_elem()</a>, <a class="el" href="Domain__Graph_8cpp_source.html#l00102">Domain_Graph::construire_graph_from_segment()</a>, <a class="el" href="DomaineCutter_8cpp_source.html#l00245">construire_liste_faces_sous_domaine()</a>, <a class="el" href="Scatter_8cpp_source.html#l01409">Scatter::construire_md_vector()</a>, <a class="el" href="Partitionneur__Tranche_8cpp_source.html#l00185">Partitionneur_Tranche::construire_partition()</a>, <a class="el" href="Corriger__frontiere__periodique_8cpp_source.html#l00135">Corriger_frontiere_periodique::corriger_coordonnees_sommets_perio()</a>, <a class="el" href="Scatter_8cpp_source.html#l02035">Scatter::corriger_espace_distant_elements_perio()</a>, <a class="el" href="Partitionneur__base_8cpp_source.html#l00260">Partitionneur_base::corriger_sommets_bord()</a>, <a class="el" href="Faces__builder_8cpp_source.html#l00940">Zone::creer_aretes()</a>, <a class="el" href="Faces__builder_8cpp_source.html#l00414">Faces_builder::creer_faces_frontiere()</a>, <a class="el" href="Faces__builder_8cpp_source.html#l00562">Faces_builder::creer_faces_internes()</a>, <a class="el" href="Faces__builder_8cpp_source.html#l00070">Faces_builder::creer_faces_reeles()</a>, <a class="el" href="MD__Vector__tools_8cpp_source.html#l00341">creer_md_vect_renum()</a>, <a class="el" href="Op__Grad__VDF__Face_8cpp_source.html#l00082">Op_Grad_VDF_Face::dimensionner()</a>, <a class="el" href="Masse__PolyMAC__Face_8cpp_source.html#l00120">Masse_PolyMAC_Face::dimensionner()</a>, <a class="el" href="Masse__PolyMAC__Elem_8cpp_source.html#l00120">Masse_PolyMAC_Elem::dimensionner()</a>, <a class="el" href="Op__Grad__PolyMAC__Face_8cpp_source.html#l00079">Op_Grad_PolyMAC_Face::dimensionner()</a>, <a class="el" href="Op__Div__PolyMAC_8cpp_source.html#l00151">Op_Div_PolyMAC::dimensionner()</a>, <a class="el" href="Op__Diff__PolyMAC__Face_8cpp_source.html#l00071">Op_Diff_PolyMAC_Face::dimensionner()</a>, <a class="el" href="Op__Diff__PolyMAC__Elem_8cpp_source.html#l00179">Op_Diff_PolyMAC_Elem::dimensionner()</a>, <a class="el" href="Op__Conv__EF__Stab__PolyMAC__Face_8cpp_source.html#l00090">Op_Conv_EF_Stab_PolyMAC_Face::dimensionner()</a>, <a class="el" href="Op__Div__CoviMAC_8cpp_source.html#l00070">Op_Div_CoviMAC::dimensionner()</a>, <a class="el" href="Op__VDF__Elem_8cpp_source.html#l00182">Op_VDF_Elem::dimensionner_bloc_vitesse()</a>, <a class="el" href="Op__PolyMAC__Elem_8cpp_source.html#l00188">Op_PolyMAC_Elem::dimensionner_bloc_vitesse()</a>, <a class="el" href="Masse__CoviMAC__Face_8cpp_source.html#l00096">Masse_CoviMAC_Face::dimensionner_blocs()</a>, <a class="el" href="Op__Conv__EF__Stab__CoviMAC__Elem_8cpp_source.html#l00147">QDM_Multiphase::dimensionner_blocs()</a>, <a class="el" href="Op__Diff__VDF__Elem__base_8cpp_source.html#l00173">Op_Diff_VDF_Elem_base::dimensionner_termes_croises()</a>, <a class="el" href="Op__Diff__PolyMAC__Elem_8cpp_source.html#l00212">Op_Diff_PolyMAC_Elem::dimensionner_termes_croises()</a>, <a class="el" href="Schema__Comm_8cpp_source.html#l00261">Schema_Comm::echange_taille()</a>, <a class="el" href="DomaineCutter_8cpp_source.html#l01268">DomaineCutter::ecrire_zones()</a>, <a class="el" href="Matrix__tools_8cpp_source.html#l00544">Matrix_tools::extend_matrix_stencil()</a>, <a class="el" href="MD__Vector__tools_8cpp_source.html#l00302">extract_blocs()</a>, <a class="el" href="Domaine__bord_8cpp_source.html#l00109">Domaine_bord::extraire_domaine_bord()</a>, <a class="el" href="Zone__CoviMAC_8cpp_source.html#l00837">Zone_CoviMAC::fgrad()</a>, <a class="el" href="MaillerParallel_8cpp_source.html#l00355">find_joint_faces()</a>, <a class="el" href="MaillerParallel_8cpp_source.html#l00232">find_matching_coordinates()</a>, <a class="el" href="Matrice__Morse_8cpp_source.html#l01920">Matrice_Morse::get_stencil()</a>, <a class="el" href="Matrice__Dense_8cpp_source.html#l00343">Matrice_Dense::get_stencil()</a>, <a class="el" href="Matrice__Morse_8cpp_source.html#l01968">Matrice_Morse::get_stencil_and_coefficients()</a>, <a class="el" href="Matrice__Morse__Sym_8cpp_source.html#l00693">Matrice_Morse_Sym::get_symmetric_stencil()</a>, <a class="el" href="Matrice__Morse__Sym_8cpp_source.html#l00748">Matrice_Morse_Sym::get_symmetric_stencil_and_coefficients()</a>, <a class="el" href="Champ__implementation__P1_8cpp_source.html#l00165">Champ_implementation_P1::init_from_file()</a>, <a class="el" href="Zone__PolyMAC_8cpp_source.html#l01249">Zone_PolyMAC::init_m1_2d()</a>, <a class="el" href="Zone__PolyMAC_8cpp_source.html#l01272">Zone_PolyMAC::init_m1_3d()</a>, <a class="el" href="Zone__PolyMAC_8cpp_source.html#l01059">Zone_PolyMAC::init_m2()</a>, <a class="el" href="Zone__PolyMAC_8cpp_source.html#l01331">Zone_PolyMAC::init_m2solv()</a>, <a class="el" href="Champ__Face__PolyMAC_8cpp_source.html#l00186">Champ_Face_PolyMAC::init_ra()</a>, <a class="el" href="Zone__PolyMAC_8cpp_source.html#l01156">Zone_PolyMAC::init_rf()</a>, <a class="el" href="Zone__CoviMAC_8cpp_source.html#l00711">Zone_CoviMAC::init_stencils()</a>, <a class="el" href="Champ__Face__PolyMAC_8cpp_source.html#l00236">Champ_Face_PolyMAC::init_va()</a>, <a class="el" href="Zone__PolyMAC_8cpp_source.html#l01134">Zone_PolyMAC::init_ve()</a>, <a class="el" href="Zone__CoviMAC_8cpp_source.html#l00688">Zone_CoviMAC::init_ve()</a>, <a class="el" href="Champ__Face__CoviMAC_8cpp_source.html#l00169">Champ_Face_CoviMAC::init_ve2()</a>, <a class="el" href="Zone__PolyMAC_8cpp_source.html#l01201">Zone_PolyMAC::init_we_2d()</a>, <a class="el" href="Zone__PolyMAC_8cpp_source.html#l01221">Zone_PolyMAC::init_we_3d()</a>, <a class="el" href="Champ__front__recyclage_8cpp_source.html#l00472">Champ_front_recyclage::initialiser()</a>, <a class="el" href="Scatter_8cpp_source.html#l01561">Traduction_Indice_Global_Local::initialiser()</a>, <a class="el" href="Remove__Invalid__Internal__Boundaries_8cpp_source.html#l00044">Remove_Invalid_Internal_Boundaries::interpreter_()</a>, <a class="el" href="Redresser__hexaedres__vdf_8cpp_source.html#l00042">Redresser_hexaedres_vdf::interpreter_()</a>, <a class="el" href="Create__domain__from__sous__zone_8cpp_source.html#l00045">Create_domain_from_sous_zone::interpreter_()</a>, <a class="el" href="Zone__VEF__PreP1b_8cpp_source.html#l00810">Zone_VEF_PreP1b::lecture_ok_arete()</a>, <a class="el" href="EcritureLectureSpecial_8cpp_source.html#l00328">lire_special()</a>, <a class="el" href="MD__Vector__std_8cpp_source.html#l00065">MD_Vector_std::MD_Vector_std()</a>, <a class="el" href="Scatter_8cpp_source.html#l00463">Scatter::mergeDomains()</a>, <a class="el" href="Champ__front__recyclage_8cpp_source.html#l00721">Champ_front_recyclage::mettre_a_jour()</a>, <a class="el" href="DomaineCutter_8cpp_source.html#l00432">parcourir_epaisseurs_elements()</a>, <a class="el" href="Champ__Fonc__MED_8cpp_source.html#l00077">Champ_Fonc_MED::readOn()</a>, <a class="el" href="Raffiner__Simplexes_8cpp_source.html#l00788">Raffiner_Simplexes::refine_domain()</a>, <a class="el" href="Scatter_8cpp_source.html#l01807">Scatter::reordonner_faces_de_joint()</a>, <a class="el" href="Reordonner__faces__periodiques_8cpp_source.html#l00114">Reordonner_faces_periodiques::reordonner_faces_periodiques()</a>, <a class="el" href="Schema__Comm_8cpp_source.html#l00063">Schema_Comm::Schema_Comm()</a>, <a class="el" href="Schema__Comm__Vecteurs_8cpp_source.html#l00069">Schema_Comm_Vecteurs::Schema_Comm_Vecteurs()</a>, and <a class="el" href="Connex__components_8cpp_source.html#l00048">search_connex_components_local()</a>.</p>
<div class="fragment"><pre class="fragment">{
  assert(flag == 0 || flag == 1);
  <a class="code" href="classArrOfInt.html#a9170b6699fa2b83ccc8c9a451e18bd44">smart_resize_</a> = flag;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a0f41611fce0a58c3ef3409dc1af8904d"></a><!-- doxytag: member="ArrOfInt::size_array" ref="a0f41611fce0a58c3ef3409dc1af8904d" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ArrOfInt::size_array </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Renvoie la taille du tableau (nombre d'elements declares<br/>
a la construction ou a <a class="el" href="classArrOfInt.html#a9b3afbb46b16870dbd36236c8935b535">resize_array()</a>).<br/>
C'est le nombre d'elements accessibles a operator[]. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>int </dd></dl>

<p>Definition at line <a class="el" href="ArrOfInt_8h_source.html#l00342">342</a> of file <a class="el" href="ArrOfInt_8h_source.html">ArrOfInt.h</a>.</p>

<p>References <a class="el" href="ArrOfInt_8h_source.html#l00180">size_array_</a>.</p>

<p>Referenced by <a class="el" href="Schema__Comm__Vecteurs_8h_source.html#l00128">Schema_Comm_Vecteurs::add()</a>, <a class="el" href="RTabInt_8cpp_source.html#l00084">RTabInt::add()</a>, <a class="el" href="CSR__Builder_8h_source.html#l00054">CSR_Builder::add_coeff()</a>, <a class="el" href="Debog_8cpp_source.html#l00311">Debog_Pb::add_renum_item()</a>, <a class="el" href="Champ__base_8cpp_source.html#l00657">add_sommets_communs()</a>, <a class="el" href="MD__Vector__std_8cpp_source.html#l00652">add_to_vect_blocs()</a>, <a class="el" href="MD__Vector__std_8cpp_source.html#l00413">add_to_vect_items()</a>, <a class="el" href="Polygone_8cpp_source.html#l00419">Polygone::affecte_connectivite_numero_global()</a>, <a class="el" href="Polyedre_8cpp_source.html#l00465">Polyedre::affecte_connectivite_numero_global()</a>, <a class="el" href="Convert__ICoCoTrioField_8cpp_source.html#l00039">affecte_int_avec_inttab()</a>, <a class="el" href="DoubleVect_8cpp_source.html#l01531">ajoute_alpha_v()</a>, <a class="el" href="DoubleVect_8cpp_source.html#l01594">ajoute_carre()</a>, <a class="el" href="DoubleVect_8cpp_source.html#l01657">ajoute_produit_scalaire()</a>, <a class="el" href="DoubleTab_8cpp_source.html#l00668">DoubleTab::ajoute_produit_tensoriel()</a>, <a class="el" href="Op__Conv__VEF__Face_8cpp_source.html#l00121">Op_Conv_VEF_Face::ajouter()</a>, <a class="el" href="Domaine_8cpp_source.html#l00259">Domaine::ajouter()</a>, <a class="el" href="Polyedre_8cpp_source.html#l00585">Polyedre::ajouter_elements()</a>, <a class="el" href="Scatter_8cpp_source.html#l01151">Scatter::ajouter_joints()</a>, <a class="el" href="DomaineCutter_8cpp_source.html#l00396">ajouter_joints()</a>, <a class="el" href="Matrice__SuperMorse_8cpp_source.html#l00032">Matrice_SuperMorse::ajouter_mult_vect_et_prodscal()</a>, <a class="el" href="Matrice__Morse_8cpp_source.html#l00936">Matrice_Morse::ajouter_multvect_()</a>, <a class="el" href="Faces__builder_8cpp_source.html#l00302">Faces_builder::ajouter_une_face()</a>, <a class="el" href="Array__tools_8cpp_source.html#l00515">append_array_to_array()</a>, <a class="el" href="MD__Vector__composite_8cpp_source.html#l00115">append_blocs()</a>, <a class="el" href="MD__Vector__composite_8cpp_source.html#l00136">append_global_md()</a>, <a class="el" href="MD__Vector__base2_8h_source.html#l00092">MD_Vector_base2::append_item_to_blocs()</a>, <a class="el" href="MD__Vector__composite_8cpp_source.html#l00102">append_items()</a>, <a class="el" href="IntTab_8h_source.html#l00261">IntTab::append_line()</a>, <a class="el" href="Array__tools_8cpp_source.html#l00155">array_bsearch()</a>, <a class="el" href="Array__tools_8cpp_source.html#l00078">array_calculer_intersection()</a>, <a class="el" href="Array__tools_8cpp_source.html#l00036">array_retirer_doublons()</a>, <a class="el" href="Scatter_8cpp_source.html#l00806">array_retirer_elements()</a>, <a class="el" href="Scatter_8cpp_source.html#l00778">array_trier_retirer_doublons()</a>, <a class="el" href="ArrOfInt_8cpp_source.html#l00391">ArrOfInt()</a>, <a class="el" href="ArrOfInt_8cpp_source.html#l01042">attach_array()</a>, <a class="el" href="MaillerParallel_8cpp_source.html#l00421">auto_build_joints()</a>, <a class="el" href="Schema__Comm__Vecteurs_8cpp_source.html#l00180">Schema_Comm_Vecteurs::begin_comm()</a>, <a class="el" href="Octree__Int_8cpp_source.html#l00088">Octree_Int::build()</a>, <a class="el" href="Refine__Mesh_8cpp_source.html#l00248">Refine_Mesh::build_edges()</a>, <a class="el" href="Raffiner__Simplexes_8cpp_source.html#l00722">build_frontier()</a>, <a class="el" href="Octree__Int_8cpp_source.html#l00300">Octree_Int::build_octree_floor()</a>, <a class="el" href="Octree__Int_8cpp_source.html#l00316">Octree_Int::build_octree_recursively()</a>, <a class="el" href="Polygone_8cpp_source.html#l00092">Polygone::build_reduced()</a>, <a class="el" href="Polyedre_8cpp_source.html#l00649">Polyedre::build_reduced()</a>, <a class="el" href="Moyenne__volumique_8cpp_source.html#l00579">Calcul_integrale_locale::calculer()</a>, <a class="el" href="DomaineCutter_8cpp_source.html#l01002">calculer_elements_voisins_bords()</a>, <a class="el" href="Scatter_8cpp_source.html#l00937">Scatter::calculer_espace_distant()</a>, <a class="el" href="Scatter_8cpp_source.html#l02184">Scatter::calculer_espace_distant_elements()</a>, <a class="el" href="Scatter_8cpp_source.html#l01219">calculer_espace_distant_item()</a>, <a class="el" href="Scatter_8cpp_source.html#l01929">calculer_liste_complete_aretes_joint()</a>, <a class="el" href="Scatter_8cpp_source.html#l01899">calculer_liste_complete_sommets_joint()</a>, <a class="el" href="Scatter_8cpp_source.html#l02864">Scatter::calculer_nb_items_virtuels()</a>, <a class="el" href="Scatter_8cpp_source.html#l01353">Scatter::calculer_renum_items_communs()</a>, <a class="el" href="Array__tools_8cpp_source.html#l00456">calculer_renum_sans_doublons()</a>, <a class="el" href="DoubleVect_8cpp_source.html#l01782">carre()</a>, <a class="el" href="Schema__Comm__Vecteurs_8cpp_source.html#l00265">Schema_Comm_Vecteurs::check_buffers_full()</a>, <a class="el" href="Scatter_8cpp_source.html#l00297">Scatter::check_consistancy_remote_items()</a>, <a class="el" href="Faces__builder_8cpp_source.html#l00248">Faces_builder::check_erreur_faces()</a>, <a class="el" href="Check__espace__virtuel_8cpp_source.html#l00052">check_espace_virtuel_vect()</a>, <a class="el" href="Static__Int__Lists_8cpp_source.html#l00065">check_index_data()</a>, <a class="el" href="Schema__Comm__Vecteurs_8cpp_source.html#l00315">Schema_Comm_Vecteurs::check_next_area()</a>, <a class="el" href="Schema__Comm_8cpp_source.html#l00466">check_PE_in_list()</a>, <a class="el" href="Schema__Comm_8cpp_source.html#l00549">Schema_Comm::check_send_recv_pe_list()</a>, <a class="el" href="Scatter_8cpp_source.html#l02512">Scatter::Chercher_Correspondance()</a>, <a class="el" href="Zone_8cpp_source.html#l00360">Zone::chercher_elements()</a>, <a class="el" href="Partitionneur__base_8cpp_source.html#l00103">chercher_elems_voisins_faces()</a>, <a class="el" href="Matrice__Morse__Sym_8cpp_source.html#l00928">Matrice_Morse_Sym::compacte()</a>, <a class="el" href="Raccord__distant__homogene_8cpp_source.html#l00237">Raccord_distant_homogene::completer()</a>, <a class="el" href="Periodique_8cpp_source.html#l00072">Periodique::completer()</a>, <a class="el" href="Connex__components_8cpp_source.html#l00215">compute_global_connex_components()</a>, <a class="el" href="Connex__components_8cpp_source.html#l00125">compute_graph_connex_components()</a>, <a class="el" href="Polyedre_8cpp_source.html#l00671">Polyedre::compute_virtual_index()</a>, <a class="el" href="Zone__Cl__dis__base_8cpp_source.html#l00432">Zone_Cl_dis_base::condition_limite_de_la_face_virtuelle()</a>, <a class="el" href="Octree_8cpp_source.html#l00807">Octree::construire()</a>, <a class="el" href="Scatter_8cpp_source.html#l02653">Scatter::construire_correspondance_items_par_coordonnees()</a>, <a class="el" href="DomaineCutter_8cpp_source.html#l00517">DomaineCutter::construire_elements_distants_ssdom()</a>, <a class="el" href="DomaineCutter_8cpp_source.html#l00192">construire_elems_sous_domaine()</a>, <a class="el" href="DomaineCutter_8cpp_source.html#l00736">DomaineCutter::construire_faces_joints_ssdom()</a>, <a class="el" href="Domain__Graph_8cpp_source.html#l00170">Domain_Graph::construire_graph_elem_elem()</a>, <a class="el" href="Domain__Graph_8cpp_source.html#l00102">Domain_Graph::construire_graph_from_segment()</a>, <a class="el" href="DomaineCutter_8cpp_source.html#l00245">construire_liste_faces_sous_domaine()</a>, <a class="el" href="DomaineCutter_8cpp_source.html#l00091">construire_liste_sommets_sousdomaine()</a>, <a class="el" href="Scatter_8cpp_source.html#l01409">Scatter::construire_md_vector()</a>, <a class="el" href="Partitionneur__Tranche_8cpp_source.html#l00185">Partitionneur_Tranche::construire_partition()</a>, <a class="el" href="Partitionneur__Partition_8cpp_source.html#l00078">Partitionneur_Partition::construire_partition()</a>, <a class="el" href="Zone__VEF__PreP1b_8cpp_source.html#l00504">Zone_VEF_PreP1b::construire_renum_arete_perio()</a>, <a class="el" href="DomaineCutter_8cpp_source.html#l00643">DomaineCutter::construire_sommets_joints_ssdom()</a>, <a class="el" href="Segment_8cpp_source.html#l00212">Segment::contient()</a>, <a class="el" href="Point_8cpp_source.html#l00188">Point::contient()</a>, <a class="el" href="IntVect_8cpp_source.html#l00165">IntVect::copy()</a>, <a class="el" href="IntVect_8cpp_source.html#l00190">IntVect::copy_()</a>, <a class="el" href="Champ__P1iP1B__implementation_8cpp_source.html#l00359">corriger()</a>, <a class="el" href="Scatter_8cpp_source.html#l02035">Scatter::corriger_espace_distant_elements_perio()</a>, <a class="el" href="Partitionneur__base_8cpp_source.html#l00260">Partitionneur_base::corriger_sommets_bord()</a>, <a class="el" href="PE__Groups_8cpp_source.html#l00051">PE_Groups::create_group()</a>, <a class="el" href="DecoupeBord_8cpp_source.html#l00285">create_listb_geom()</a>, <a class="el" href="DecoupeBord_8cpp_source.html#l00230">create_listb_naif()</a>, <a class="el" href="Faces__builder_8cpp_source.html#l00940">Zone::creer_aretes()</a>, <a class="el" href="Faces__builder_8cpp_source.html#l00414">Faces_builder::creer_faces_frontiere()</a>, <a class="el" href="Faces__builder_8cpp_source.html#l00562">Faces_builder::creer_faces_internes()</a>, <a class="el" href="Zone__VEF_8cpp_source.html#l00565">Zone_VEF::creer_faces_virtuelles_non_std()</a>, <a class="el" href="Zone__PolyMAC_8cpp_source.html#l00830">Zone_PolyMAC::creer_faces_virtuelles_non_std()</a>, <a class="el" href="Zone__EF_8cpp_source.html#l00908">Zone_EF::creer_faces_virtuelles_non_std()</a>, <a class="el" href="MD__Vector__tools_8cpp_source.html#l00341">creer_md_vect_renum()</a>, <a class="el" href="MD__Vector__tools_8cpp_source.html#l00638">MD_Vector_tools::creer_md_vect_renum_auto()</a>, <a class="el" href="SSOR_8cpp_source.html#l00179">descente()</a>, <a class="el" href="SSOR_8cpp_source.html#l00411">descente_assert()</a>, <a class="el" href="SSOR_8cpp_source.html#l01239">descente_assert_precond_diag()</a>, <a class="el" href="SSOR_8cpp_source.html#l00461">descente_bloc_extradiag_assert()</a>, <a class="el" href="SSOR_8cpp_source.html#l00793">descente_diag_ok_assert()</a>, <a class="el" href="SSOR_8cpp_source.html#l01025">descente_precond_diag()</a>, <a class="el" href="Matrice__Morse_8cpp_source.html#l00514">Matrice_Morse::dimensionner()</a>, <a class="el" href="Zone__CoviMAC_8cpp_source.html#l00610">disp_ia()</a>, <a class="el" href="Scatter_8cpp_source.html#l00101">dump_lata()</a>, <a class="el" href="Schema__Comm_8cpp_source.html#l00311">Schema_Comm::echange_messages()</a>, <a class="el" href="Schema__Comm_8cpp_source.html#l00261">Schema_Comm::echange_taille()</a>, <a class="el" href="Schema__Comm_8cpp_source.html#l00380">Schema_Comm::echange_taille_et_messages()</a>, <a class="el" href="Decouper_8cpp_source.html#l00224">Decouper::ecrire()</a>, <a class="el" href="Debog_8cpp_source.html#l00956">Debog_Pb::ecrire_partie()</a>, <a class="el" href="DomaineCutter_8cpp_source.html#l01268">DomaineCutter::ecrire_zones()</a>, <a class="el" href="Op__EF__base_8cpp_source.html#l00466">Op_EF_base::elem_contribue()</a>, <a class="el" href="SETS_8cpp_source.html#l00331">SETS::eliminer()</a>, <a class="el" href="Schema__Comm_8cpp_source.html#l00430">Schema_Comm::end_comm()</a>, <a class="el" href="Schema__Comm__Vecteurs_8cpp_source.html#l00110">Schema_Comm_Vecteurs::end_init()</a>, <a class="el" href="communications_8cpp_source.html#l00473">envoyer_all_to_all()</a>, <a class="el" href="Op__Rot__VEFP1B_8cpp_source.html#l00067">est_un_coin()</a>, <a class="el" href="Schema__Comm__Vecteurs_8cpp_source.html#l00206">Schema_Comm_Vecteurs::exchange()</a>, <a class="el" href="Schema__Comm_8cpp_source.html#l00179">exchange_data()</a>, <a class="el" href="MD__Vector__tools_8cpp_source.html#l00702">MD_Vector_tools::extend()</a>, <a class="el" href="MD__Vector__tools_8cpp_source.html#l00302">extract_blocs()</a>, <a class="el" href="Connectivite__som__elem_8cpp_source.html#l00108">find_adjacent_elements()</a>, <a class="el" href="Op__Div__VEFP1B__Elem_8cpp_source.html#l00140">find_cl_face()</a>, <a class="el" href="Refine__Mesh_8cpp_source.html#l00681">Refine_Mesh::find_edge()</a>, <a class="el" href="MD__Vector__composite_8cpp_source.html#l00125">find_in_array()</a>, <a class="el" href="MaillerParallel_8cpp_source.html#l00355">find_joint_faces()</a>, <a class="el" href="MaillerParallel_8cpp_source.html#l00232">find_matching_coordinates()</a>, <a class="el" href="Static__Int__Lists_8h_source.html#l00113">Static_Int_Lists::get_nb_lists()</a>, <a class="el" href="MD__Vector__tools_8cpp_source.html#l00240">get_seq_flags()</a>, <a class="el" href="Matrice__Morse_8cpp_source.html#l01920">Matrice_Morse::get_stencil()</a>, <a class="el" href="Matrice__Morse_8cpp_source.html#l01968">Matrice_Morse::get_stencil_and_coefficients()</a>, <a class="el" href="Polyedre_8cpp_source.html#l00439">Polyedre::get_tab_faces_sommets_locaux()</a>, <a class="el" href="ArrOfInt_8cpp_source.html#l00747">imax_array()</a>, <a class="el" href="ArrOfInt_8cpp_source.html#l00719">imin_array()</a>, <a class="el" href="Sonde_8cpp_source.html#l01456">Sonde::init_bords()</a>, <a class="el" href="Champ__implementation__P1_8cpp_source.html#l00165">Champ_implementation_P1::init_from_file()</a>, <a class="el" href="Comm__Group__Noparallel_8cpp_source.html#l00038">Comm_Group_Noparallel::init_group()</a>, <a class="el" href="Comm__Group_8cpp_source.html#l00089">Comm_Group::init_group()</a>, <a class="el" href="ConstDoubleTab__parts_8cpp_source.html#l00028">init_parts()</a>, <a class="el" href="Raccord__distant__homogene_8cpp_source.html#l00267">Raccord_distant_homogene::initialise()</a>, <a class="el" href="Champ__front__recyclage_8cpp_source.html#l00472">Champ_front_recyclage::initialiser()</a>, <a class="el" href="Scatter_8cpp_source.html#l01561">Traduction_Indice_Global_Local::initialiser()</a>, <a class="el" href="DomaineCutter_8cpp_source.html#l01066">DomaineCutter::initialiser()</a>, <a class="el" href="Partitionneur__Tranche_8cpp_source.html#l00077">Partitionneur_Tranche::initialiser()</a>, <a class="el" href="Sonde_8cpp_source.html#l00720">Sonde::initialiser()</a>, <a class="el" href="MD__Vector__std_8cpp_source.html#l00265">initialize_comm_()</a>, <a class="el" href="ArrOfInt_8cpp_source.html#l01098">inject_array()</a>, <a class="el" href="Execute__parallel_8cpp_source.html#l00059">Execute_parallel::interpreter()</a>, <a class="el" href="MaillerParallel_8cpp_source.html#l00534">MaillerParallel::interpreter()</a>, <a class="el" href="Remove__Invalid__Internal__Boundaries_8cpp_source.html#l00044">Remove_Invalid_Internal_Boundaries::interpreter_()</a>, <a class="el" href="Redresser__hexaedres__vdf_8cpp_source.html#l00042">Redresser_hexaedres_vdf::interpreter_()</a>, <a class="el" href="DecoupeBord_8cpp_source.html#l00434">DecoupeBord::interpreter_()</a>, <a class="el" href="Create__domain__from__sous__zone_8cpp_source.html#l00045">Create_domain_from_sous_zone::interpreter_()</a>, <a class="el" href="IntTrav_8cpp_source.html#l00112">IntTrav::IntTrav()</a>, <a class="el" href="DoubleVect_8cpp_source.html#l00379">invalidate_data()</a>, <a class="el" href="Probleme__Couple_8cpp_source.html#l00105">Probleme_Couple::iterateTimeStep()</a>, <a class="el" href="Zone__VEF__PreP1b_8cpp_source.html#l00810">Zone_VEF_PreP1b::lecture_ok_arete()</a>, <a class="el" href="IntVect_8h_source.html#l00150">IntVect::line_size()</a>, <a class="el" href="Champ__Fonc__MED_8cpp_source.html#l00313">Champ_Fonc_MED::lire()</a>, <a class="el" href="EcritureLectureSpecial_8cpp_source.html#l00328">lire_special()</a>, <a class="el" href="Perte__Charge__Singuliere_8cpp_source.html#l00127">Perte_Charge_Singuliere::lire_surfaces()</a>, <a class="el" href="IntVect_8cpp_source.html#l00297">IntVect::lit()</a>, <a class="el" href="IntTab_8cpp_source.html#l00588">IntTab::lit()</a>, <a class="el" href="DoubleTab_8cpp_source.html#l00607">local_carre_norme_tab()</a>, <a class="el" href="DoubleVect_8cpp_source.html#l00481">local_carre_norme_vect()</a>, <a class="el" href="DoubleVect_8cpp_source.html#l00716">local_imax_vect()</a>, <a class="el" href="DoubleVect_8cpp_source.html#l00603">local_imin_vect()</a>, <a class="el" href="DoubleTab_8cpp_source.html#l00636">local_max_abs_tab()</a>, <a class="el" href="DoubleVect_8cpp_source.html#l00829">local_max_abs_vect()</a>, <a class="el" href="DoubleVect_8cpp_source.html#l00773">local_max_vect()</a>, <a class="el" href="DoubleVect_8cpp_source.html#l00886">local_min_abs_vect()</a>, <a class="el" href="DoubleVect_8cpp_source.html#l00660">local_min_vect()</a>, <a class="el" href="DoubleVect_8cpp_source.html#l00419">local_prodscal()</a>, <a class="el" href="DoubleVect_8cpp_source.html#l00541">local_somme_vect()</a>, <a class="el" href="ArrOfInt_8cpp_source.html#l00832">max_abs_array()</a>, <a class="el" href="ArrOfInt_8cpp_source.html#l00798">max_array()</a>, <a class="el" href="MD__Vector__std_8cpp_source.html#l00457">max_to_vect_items()</a>, <a class="el" href="MD__Vector__std_8cpp_source.html#l00065">MD_Vector_std::MD_Vector_std()</a>, <a class="el" href="Champ__Don__Face__lu_8cpp_source.html#l00032">meme_point()</a>, <a class="el" href="Scatter_8cpp_source.html#l00463">Scatter::mergeDomains()</a>, <a class="el" href="Champ__front__recyclage_8cpp_source.html#l00721">Champ_front_recyclage::mettre_a_jour()</a>, <a class="el" href="Sonde_8cpp_source.html#l01537">Sonde::mettre_a_jour_bords()</a>, <a class="el" href="ArrOfInt_8cpp_source.html#l00861">min_abs_array()</a>, <a class="el" href="ArrOfInt_8cpp_source.html#l00776">min_array()</a>, <a class="el" href="MD__Vector__std_8cpp_source.html#l00503">mincol1_to_vect_items()</a>, <a class="el" href="Zone__VEF__PreP1b_8cpp_source.html#l00223">Zone_VEF_PreP1b::modifier_pour_Cl()</a>, <a class="el" href="Raffiner__isotrope__parallele_8cpp_source.html#l00055">mon_construire_correspondance_items_par_coordonnees()</a>, <a class="el" href="communications_8cpp_source.html#l00629">mp_collective_op()</a>, <a class="el" href="Front__VF_8h_source.html#l00066">Front_VF::nb_faces_tot()</a>, <a class="el" href="Frontiere_8h_source.html#l00199">Frontiere::nb_faces_virt()</a>, <a class="el" href="Zone__VEF__PreP1b_8cpp_source.html#l00204">next()</a>, <a class="el" href="Front__VF_8h_source.html#l00084">Front_VF::num_local_face()</a>, <a class="el" href="IntTab_8cpp_source.html#l00512">IntTab::operator()()</a>, <a class="el" href="DoubleTab_8cpp_source.html#l00479">DoubleTab::operator()()</a>, <a class="el" href="ArrOfInt_8cpp_source.html#l01157">operator+=()</a>, <a class="el" href="ArrOfInt_8cpp_source.html#l01196">operator-=()</a>, <a class="el" href="Memoire_8cpp_source.html#l00587">operator&lt;&lt;()</a>, <a class="el" href="IntTab_8cpp_source.html#l00463">IntTab::operator=()</a>, <a class="el" href="ArrOfInt_8cpp_source.html#l00468">operator=()</a>, <a class="el" href="ArrOfInt_8cpp_source.html#l00686">operator==()</a>, <a class="el" href="DoubleVect_8cpp_source.html#l00943">operator_abs()</a>, <a class="el" href="DoubleVect_8cpp_source.html#l00999">operator_add()</a>, <a class="el" href="DoubleVect_8cpp_source.html#l01838">operator_divide()</a>, <a class="el" href="DoubleVect_8cpp_source.html#l01412">operator_egal()</a>, <a class="el" href="DoubleVect_8cpp_source.html#l01902">operator_inverse()</a>, <a class="el" href="DoubleVect_8cpp_source.html#l01237">operator_multiply()</a>, <a class="el" href="DoubleVect_8cpp_source.html#l01356">operator_negate()</a>, <a class="el" href="DoubleVect_8cpp_source.html#l01118">operator_sub()</a>, <a class="el" href="DomaineCutter_8cpp_source.html#l00432">parcourir_epaisseurs_elements()</a>, <a class="el" href="Solv__GCP_8cpp_source.html#l00124">Solv_GCP::prepare_data()</a>, <a class="el" href="MD__Vector__std_8cpp_source.html#l00699">MD_Vector_std::prepare_send_data()</a>, <a class="el" href="IntTab_8cpp_source.html#l00046">IntTab::printOn()</a>, <a class="el" href="ArrOfInt_8cpp_source.html#l00264">printOn()</a>, <a class="el" href="MD__Vector__std_8cpp_source.html#l00736">MD_Vector_std::process_recv_data()</a>, <a class="el" href="DoubleVect_8cpp_source.html#l01726">racine_carree()</a>, <a class="el" href="Octree_8cpp_source.html#l01688">OctreeFloor::rang_elem_depuis_loc()</a>, <a class="el" href="Octree_8cpp_source.html#l01630">OctreeFloor::rang_elem_loc()</a>, <a class="el" href="Objet__a__lire_8cpp_source.html#l00207">Objet_a_lire::read()</a>, <a class="el" href="MD__Vector__std_8cpp_source.html#l00558">read_from_vect_blocs()</a>, <a class="el" href="MD__Vector__std_8cpp_source.html#l00325">read_from_vect_items()</a>, <a class="el" href="Champ__Fonc__MED_8cpp_source.html#l00077">Champ_Fonc_MED::readOn()</a>, <a class="el" href="MD__Vector__std_8cpp_source.html#l00219">MD_Vector_std::readOn()</a>, <a class="el" href="IntVect_8cpp_source.html#l00057">IntVect::readOn()</a>, <a class="el" href="IntTab_8cpp_source.html#l00070">IntTab::readOn()</a>, <a class="el" href="IntTab_8cpp_source.html#l00229">IntTab::ref()</a>, <a class="el" href="IntVect_8cpp_source.html#l00234">IntVect::ref_array()</a>, <a class="el" href="IntTab_8cpp_source.html#l00292">IntTab::ref_array()</a>, <a class="el" href="IntTab_8cpp_source.html#l00279">IntTab::ref_data()</a>, <a class="el" href="IntTab_8cpp_source.html#l00306">IntTab::ref_tab()</a>, <a class="el" href="Raffiner__Simplexes_8cpp_source.html#l00788">Raffiner_Simplexes::refine_domain()</a>, <a class="el" href="SSOR_8cpp_source.html#l00353">remontee()</a>, <a class="el" href="SSOR_8cpp_source.html#l00695">remontee_assert()</a>, <a class="el" href="SSOR_8cpp_source.html#l01400">remontee_assert_precond_diag()</a>, <a class="el" href="SSOR_8cpp_source.html#l00552">remontee_bloc_extradiag_assert()</a>, <a class="el" href="SSOR_8cpp_source.html#l00967">remontee_diag_ok_assert()</a>, <a class="el" href="SSOR_8cpp_source.html#l01186">remontee_precond_diag()</a>, <a class="el" href="DomaineCutter_8cpp_source.html#l00167">remplir_coordsommets_sous_domaine()</a>, <a class="el" href="Check__espace__virtuel_8cpp_source.html#l00067">remplir_items_non_calcules_()</a>, <a class="el" href="Zone__Cl__VEF_8cpp_source.html#l00151">Zone_Cl_VEF::remplir_volumes_entrelaces_Cl()</a>, <a class="el" href="Zone_8cpp_source.html#l00747">Zone::renum_joint_common_items()</a>, <a class="el" href="Matrice__Morse__Sym_8cpp_source.html#l00988">Matrice_Morse_Sym::renumerote()</a>, <a class="el" href="Zone__VEF_8cpp_source.html#l00118">Zone_VEF::reordonner()</a>, <a class="el" href="Zone__PolyMAC_8cpp_source.html#l00156">Zone_PolyMAC::reordonner()</a>, <a class="el" href="Zone__EF_8cpp_source.html#l00231">Zone_EF::reordonner()</a>, <a class="el" href="Zone__CoviMAC_8cpp_source.html#l00153">Zone_CoviMAC::reordonner()</a>, <a class="el" href="Scatter_8cpp_source.html#l01807">Scatter::reordonner_faces_de_joint()</a>, <a class="el" href="Zone__VDF_8cpp_source.html#l00102">reordonner_vdf()</a>, <a class="el" href="Precond__local_8cpp_source.html#l00183">Precond_local::res_syst_loc_hybride()</a>, <a class="el" href="RTabInt_8h_source.html#l00082">RTabInt::resize()</a>, <a class="el" href="IntVect_8h_source.html#l00179">IntVect::resize()</a>, <a class="el" href="IntTab_8cpp_source.html#l00423">IntTab::resize()</a>, <a class="el" href="DoubleTab_8cpp_source.html#l00390">DoubleTab::resize()</a>, <a class="el" href="IntTab_8cpp_source.html#l00344">IntTab::resize_dim0()</a>, <a class="el" href="Comm__Group__Noparallel_8cpp_source.html#l00120">Comm_Group_Noparallel::reverse_send_recv_list()</a>, <a class="el" href="communications_8cpp_source.html#l00561">reverse_send_recv_pe_list()</a>, <a class="el" href="Connex__components_8cpp_source.html#l00048">search_connex_components_local()</a>, <a class="el" href="Octree__Int_8cpp_source.html#l00173">Octree_Int::search_elements_box()</a>, <a class="el" href="Octree__Double_8cpp_source.html#l00244">Octree_Double::search_elements_box()</a>, <a class="el" href="Octree__Double_8cpp_source.html#l00289">Octree_Double::search_nodes_close_to()</a>, <a class="el" href="Comm__Group__Noparallel_8cpp_source.html#l00128">Comm_Group_Noparallel::send_recv_start()</a>, <a class="el" href="Comm__Group__MPI_8cpp_source.html#l00289">Comm_Group_MPI::send_recv_start()</a>, <a class="el" href="Static__Int__Lists_8cpp_source.html#l00155">Static_Int_Lists::set()</a>, <a class="el" href="Static__Int__Lists_8cpp_source.html#l00057">Static_Int_Lists::set_data()</a>, <a class="el" href="Static__Int__Lists_8cpp_source.html#l00036">Static_Int_Lists::set_list_sizes()</a>, <a class="el" href="IntVect_8cpp_source.html#l00247">IntVect::set_md_vector()</a>, <a class="el" href="IntVect_8h_source.html#l00121">IntVect::size_reelle()</a>, <a class="el" href="IntVect_8h_source.html#l00145">IntVect::size_totale()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00286">sort()</a>, <a class="el" href="SSOR_8cpp_source.html#l01459">SSOR::ssor()</a>, <a class="el" href="DoubleVect_8cpp_source.html#l02029">tab_divide_any_shape_()</a>, <a class="el" href="DoubleVect_8cpp_source.html#l01959">tab_multiply_any_shape_()</a>, <a class="el" href="Octree_8cpp_source.html#l01772">OctreeFloor::taille()</a>, <a class="el" href="Raccord__distant__homogene_8cpp_source.html#l00121">Raccord_distant_homogene::trace_elem_distant()</a>, <a class="el" href="Raccord__distant__homogene_8cpp_source.html#l00167">Raccord_distant_homogene::trace_face_distant()</a>, <a class="el" href="Scatter_8cpp_source.html#l01678">Traduction_Indice_Global_Local::traduire_indice_global_vers_local()</a>, <a class="el" href="Array__tools_8cpp_source.html#l00342">tri_lexicographique_tableau_indirect()</a>, <a class="el" href="Trier_8cpp_source.html#l00072">trier()</a>, <a class="el" href="Trier_8cpp_source.html#l00060">trier_abs()</a>, <a class="el" href="Partitionneur__Tranche_8cpp_source.html#l00110">trier_index_colonne_i()</a>, <a class="el" href="Static__Int__Lists_8cpp_source.html#l00091">Static_Int_Lists::trier_liste()</a>, <a class="el" href="Champ__som__lu__VDF_8cpp_source.html#l00143">Champ_som_lu_VDF::valeur_aux_elems()</a>, <a class="el" href="Champ__som__lu_8cpp_source.html#l00153">Champ_som_lu::valeur_aux_elems()</a>, <a class="el" href="Champ__som__lu__VDF_8cpp_source.html#l00234">Champ_som_lu_VDF::valeur_aux_elems_compo()</a>, <a class="el" href="Champ__som__lu_8cpp_source.html#l00314">Champ_som_lu::valeur_aux_elems_compo()</a>, <a class="el" href="Champ__implementation__Q1_8cpp_source.html#l00132">Champ_implementation_Q1::value_interpolation()</a>, <a class="el" href="Champ__implementation__P1_8cpp_source.html#l00116">Champ_implementation_P1::value_interpolation()</a>, <a class="el" href="Zone__VEF__PreP1b_8cpp_source.html#l00677">Zone_VEF_PreP1b::verifie_ok_arete()</a>, <a class="el" href="Assembleur__P__VEFPreP1B_8cpp_source.html#l00751">Assembleur_P_VEFPreP1B::verifier_dirichlet()</a>, <a class="el" href="Debog_8cpp_source.html#l01161">Debog_Pb::verifier_gen()</a>, <a class="el" href="MD__Vector__std_8cpp_source.html#l00605">write_to_vect_blocs()</a>, and <a class="el" href="MD__Vector__std_8cpp_source.html#l00369">write_to_vect_items()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">return</span> <a class="code" href="classArrOfInt.html#a23d1b6526fd584ba8de321ee7d1f1c1b">size_array_</a>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a52bfe11d364b9b9a9e9618f77856790f"></a><!-- doxytag: member="ArrOfInt::taille_memoire" ref="a52bfe11d364b9b9a9e9618f77856790f" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned ArrOfInt::taille_memoire </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implements <a class="el" href="classObjet__U.html#a0ee0946339f09a2c73c09fcda71c3be2">Objet_U</a>.</p>

<p>Reimplemented in <a class="el" href="classEsp__Dist.html#a30b144bb9ca0fa70ada4315d6e359f36">Esp_Dist</a>, <a class="el" href="classIntTab.html#a96785b082fc6ec5545c3460d86cd0e5c">IntTab</a>, <a class="el" href="classIntTrav.html#a70d2d04b986849ede415c4617686ef6f">IntTrav</a>, and <a class="el" href="classIntVect.html#a305def9936c452807caa99702df90bc6">IntVect</a>.</p>

<p>Definition at line <a class="el" href="ArrOfInt_8cpp_source.html#l00038">38</a> of file <a class="el" href="ArrOfInt_8cpp_source.html">ArrOfInt.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{
</pre></div>
</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="ab799099ee6d316bdaad7d7f3e99f0637"></a><!-- doxytag: member="ArrOfInt::data_" ref="ab799099ee6d316bdaad7d7f3e99f0637" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int* <a class="el" href="classArrOfInt.html#ab799099ee6d316bdaad7d7f3e99f0637">ArrOfInt::data_</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="ArrOfInt_8h_source.html#l00176">176</a> of file <a class="el" href="ArrOfInt_8h_source.html">ArrOfInt.h</a>.</p>

<p>Referenced by <a class="el" href="ArrOfInt_8h_source.html#l00371">addr()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00355">append_array()</a>, <a class="el" href="ArrOfInt_8cpp_source.html#l00911">array_trier_retirer_doublons()</a>, <a class="el" href="ArrOfInt_8cpp_source.html#l00343">ArrOfInt()</a>, <a class="el" href="ArrOfInt_8cpp_source.html#l01042">attach_array()</a>, <a class="el" href="ArrOfInt_8cpp_source.html#l01002">detach_array()</a>, <a class="el" href="ArrOfInt_8cpp_source.html#l00651">fill_default_value()</a>, <a class="el" href="ArrOfInt_8cpp_source.html#l01098">inject_array()</a>, <a class="el" href="ArrOfInt_8cpp_source.html#l00542">memory_resize()</a>, <a class="el" href="ArrOfInt_8cpp_source.html#l01157">operator+=()</a>, <a class="el" href="ArrOfInt_8cpp_source.html#l01196">operator-=()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00288">operator=()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00306">operator[]()</a>, <a class="el" href="ArrOfInt_8cpp_source.html#l00897">ordonne_array()</a>, <a class="el" href="ArrOfInt_8cpp_source.html#l00264">printOn()</a>, <a class="el" href="ArrOfInt_8cpp_source.html#l00291">readOn()</a>, <a class="el" href="ArrOfInt_8cpp_source.html#l00976">ref_data()</a>, and <a class="el" href="ArrOfInt_8h_source.html#l00256">resize_array_()</a>.</p>

</div>
</div>
<a class="anchor" id="a008742084e91090da12686a49537843c"></a><!-- doxytag: member="ArrOfInt::info_obj" ref="a008742084e91090da12686a49537843c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classType__info.html">Type_info</a> <a class="el" href="classArrOfInt.html#a008742084e91090da12686a49537843c">ArrOfInt::info_obj</a><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="classArray__base.html#af95fada2845d7f9bae474221a2e12d9a">Array_base</a>.</p>

<p>Reimplemented in <a class="el" href="classEsp__Dist.html#ad4abf8f3b1fd845cb14312735c7d7941">Esp_Dist</a>, <a class="el" href="classIntTab.html#a2a2ddbc874ead0d5471a0d152262c950">IntTab</a>, <a class="el" href="classIntTrav.html#a3c9f0286119b40d7b8290fee5ad09f5b">IntTrav</a>, and <a class="el" href="classIntVect.html#a8c2abd2c7633bb083b518451bd88fd39">IntVect</a>.</p>

<p>Definition at line <a class="el" href="ArrOfInt_8h_source.html#l00074">74</a> of file <a class="el" href="ArrOfInt_8h_source.html">ArrOfInt.h</a>.</p>

</div>
</div>
<a class="anchor" id="a9cda25dd5c640c8523243990b6c0b845"></a><!-- doxytag: member="ArrOfInt::memory_size_" ref="a9cda25dd5c640c8523243990b6c0b845" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classArrOfInt.html#a9cda25dd5c640c8523243990b6c0b845">ArrOfInt::memory_size_</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="ArrOfInt_8h_source.html#l00185">185</a> of file <a class="el" href="ArrOfInt_8h_source.html">ArrOfInt.h</a>.</p>

<p>Referenced by <a class="el" href="ArrOfInt_8cpp_source.html#l00391">ArrOfInt()</a>, <a class="el" href="ArrOfInt_8cpp_source.html#l01042">attach_array()</a>, <a class="el" href="ArrOfInt_8cpp_source.html#l01002">detach_array()</a>, <a class="el" href="ArrOfInt_8cpp_source.html#l00651">fill_default_value()</a>, <a class="el" href="ArrOfInt_8cpp_source.html#l00542">memory_resize()</a>, <a class="el" href="ArrOfInt_8cpp_source.html#l00976">ref_data()</a>, and <a class="el" href="ArrOfInt_8h_source.html#l00256">resize_array_()</a>.</p>

</div>
</div>
<a class="anchor" id="a54afaafbf7fa8c80696da7a2c3d3f48b"></a><!-- doxytag: member="ArrOfInt::p_" ref="a54afaafbf7fa8c80696da7a2c3d3f48b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVIntdata.html">VIntdata</a>* <a class="el" href="classArrOfInt.html#a54afaafbf7fa8c80696da7a2c3d3f48b">ArrOfInt::p_</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="ArrOfInt_8h_source.html#l00168">168</a> of file <a class="el" href="ArrOfInt_8h_source.html">ArrOfInt.h</a>.</p>

<p>Referenced by <a class="el" href="ArrOfInt_8cpp_source.html#l00343">ArrOfInt()</a>, <a class="el" href="ArrOfInt_8cpp_source.html#l01042">attach_array()</a>, <a class="el" href="ArrOfInt_8cpp_source.html#l01002">detach_array()</a>, <a class="el" href="ArrOfInt_8cpp_source.html#l00542">memory_resize()</a>, <a class="el" href="ArrOfInt_8cpp_source.html#l01134">ref_count()</a>, and <a class="el" href="ArrOfInt_8h_source.html#l00256">resize_array_()</a>.</p>

</div>
</div>
<a class="anchor" id="a23d1b6526fd584ba8de321ee7d1f1c1b"></a><!-- doxytag: member="ArrOfInt::size_array_" ref="a23d1b6526fd584ba8de321ee7d1f1c1b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classArrOfInt.html#a23d1b6526fd584ba8de321ee7d1f1c1b">ArrOfInt::size_array_</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="ArrOfInt_8h_source.html#l00180">180</a> of file <a class="el" href="ArrOfInt_8h_source.html">ArrOfInt.h</a>.</p>

<p>Referenced by <a class="el" href="ArrOfInt_8h_source.html#l00355">append_array()</a>, <a class="el" href="ArrOfInt_8cpp_source.html#l00911">array_trier_retirer_doublons()</a>, <a class="el" href="ArrOfInt_8cpp_source.html#l00391">ArrOfInt()</a>, <a class="el" href="ArrOfInt_8cpp_source.html#l01042">attach_array()</a>, <a class="el" href="ArrOfInt_8cpp_source.html#l01002">detach_array()</a>, <a class="el" href="ArrOfInt_8cpp_source.html#l00542">memory_resize()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00288">operator=()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00306">operator[]()</a>, <a class="el" href="ArrOfInt_8cpp_source.html#l00897">ordonne_array()</a>, <a class="el" href="ArrOfInt_8cpp_source.html#l00976">ref_data()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00240">resize_array()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00256">resize_array_()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00342">size_array()</a>, and <a class="el" href="ArrOfInt_8cpp_source.html#l00317">~ArrOfInt()</a>.</p>

</div>
</div>
<a class="anchor" id="a9170b6699fa2b83ccc8c9a451e18bd44"></a><!-- doxytag: member="ArrOfInt::smart_resize_" ref="a9170b6699fa2b83ccc8c9a451e18bd44" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classArrOfInt.html#a9170b6699fa2b83ccc8c9a451e18bd44">ArrOfInt::smart_resize_</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="ArrOfInt_8h_source.html#l00191">191</a> of file <a class="el" href="ArrOfInt_8h_source.html">ArrOfInt.h</a>.</p>

<p>Referenced by <a class="el" href="ArrOfInt_8h_source.html#l00355">append_array()</a>, <a class="el" href="ArrOfInt_8cpp_source.html#l00391">ArrOfInt()</a>, <a class="el" href="ArrOfInt_8cpp_source.html#l01042">attach_array()</a>, <a class="el" href="ArrOfInt_8cpp_source.html#l00542">memory_resize()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00256">resize_array_()</a>, and <a class="el" href="ArrOfInt_8cpp_source.html#l00443">set_smart_resize()</a>.</p>

</div>
</div>
<a class="anchor" id="a5a5cbc9e1c2d4ba877ca0bd697ea56bc"></a><!-- doxytag: member="ArrOfInt::storage_type_" ref="a5a5cbc9e1c2d4ba877ca0bd697ea56bc" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classArrOfInt.html#ae96e99b17332a05cd91a09a2b6bb3cc4">Storage</a> <a class="el" href="classArrOfInt.html#a5a5cbc9e1c2d4ba877ca0bd697ea56bc">ArrOfInt::storage_type_</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="ArrOfInt_8h_source.html#l00195">195</a> of file <a class="el" href="ArrOfInt_8h_source.html">ArrOfInt.h</a>.</p>

<p>Referenced by <a class="el" href="ArrOfInt_8cpp_source.html#l00391">ArrOfInt()</a>, <a class="el" href="ArrOfInt_8cpp_source.html#l00433">get_mem_storage()</a>, <a class="el" href="ArrOfInt_8cpp_source.html#l00542">memory_resize()</a>, and <a class="el" href="ArrOfInt_8cpp_source.html#l00424">set_mem_storage()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/Kernel/Math/<a class="el" href="ArrOfInt_8h_source.html">ArrOfInt.h</a></li>
<li>src/Kernel/Math/<a class="el" href="ArrOfInt_8cpp_source.html">ArrOfInt.cpp</a></li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Tue Dec 14 2021 19:36:06 for TRUST by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
