<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>TRUST: src/VEF/Operateurs/Op_Conv_Centre_old_VEF_Face.cpp Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">TRUST&#160;<span id="projectnumber">1.8.4</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
<div class="header">
  <div class="headertitle">
<div class="title">src/VEF/Operateurs/Op_Conv_Centre_old_VEF_Face.cpp</div>  </div>
</div>
<div class="contents">
<a href="Op__Conv__Centre__old__VEF__Face_8cpp.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/****************************************************************************</span>
<a name="l00002"></a>00002 <span class="comment">* Copyright (c) 2015 - 2016, CEA</span>
<a name="l00003"></a>00003 <span class="comment">* All rights reserved.</span>
<a name="l00004"></a>00004 <span class="comment">*</span>
<a name="l00005"></a>00005 <span class="comment">* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</span>
<a name="l00006"></a>00006 <span class="comment">* 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.</span>
<a name="l00007"></a>00007 <span class="comment">* 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.</span>
<a name="l00008"></a>00008 <span class="comment">* 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.</span>
<a name="l00009"></a>00009 <span class="comment">*</span>
<a name="l00010"></a>00010 <span class="comment">* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.</span>
<a name="l00011"></a>00011 <span class="comment">* IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;</span>
<a name="l00012"></a>00012 <span class="comment">* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>
<a name="l00013"></a>00013 <span class="comment">*</span>
<a name="l00014"></a>00014 <span class="comment">*****************************************************************************/</span>
<a name="l00015"></a>00015 <span class="comment">//</span>
<a name="l00016"></a>00016 <span class="comment">// </span>
<a name="l00017"></a>00017 <span class="comment">// File:        Op_Conv_Centre_old_VEF_Face.cpp</span>
<a name="l00018"></a>00018 <span class="comment">// Directory:   $TRUST_ROOT/src/VEF/Operateurs</span>
<a name="l00019"></a>00019 <span class="comment">// Version:     /main/23</span>
<a name="l00020"></a>00020 <span class="comment">// </span>
<a name="l00021"></a>00021 <span class="comment">//</span>
<a name="l00022"></a>00022 
<a name="l00023"></a>00023 <span class="preprocessor">#include &lt;<a class="code" href="Op__Conv__Centre__old__VEF__Face_8h.html">Op_Conv_Centre_old_VEF_Face.h</a>&gt;</span>
<a name="l00024"></a>00024 
<a name="l00025"></a><a class="code" href="Op__Conv__Centre__old__VEF__Face_8cpp.html#a219c513fefd3607f1fcd9f64e76a86a0">00025</a> <a class="code" href="Op__Diff__CoviMAC__Face_8cpp.html#aa86ec8ba612a969d9b4370b775037144">Implemente_instanciable</a>(<a class="code" href="classOp__Conv__Centre__old__VEF__Face.html" title="class Op_Conv_Centre_old_VEF_Face Cette classe represente l&#39;operateur de convection associe a une equ...">Op_Conv_Centre_old_VEF_Face</a>,<span class="stringliteral">&quot;Op_Conv_Centre_old_VEF_P1NC&quot;</span>,<a class="code" href="classOp__Conv__VEF__base.html" title="class Op_Conv_VEF_base Classe de base des operateurs de convection VEF">Op_Conv_VEF_base</a>);
<a name="l00026"></a>00026 
<a name="l00027"></a>00027 <span class="comment"></span>
<a name="l00028"></a>00028 <span class="comment">////!&lt; printOn </span>
<a name="l00029"></a>00029 <span class="comment"></span><span class="comment">//</span>
<a name="l00030"></a>00030 
<a name="l00031"></a><a class="code" href="classOp__Conv__Centre__old__VEF__Face.html#a127ff312dc2f3a33b685b78772fe98b2">00031</a> <a class="code" href="classSortie.html" title="Classe de base des flux de sortie. Elle sait ecrire des types simples&lt;br&gt;(entiers, flottants) et des Ob...">Sortie</a>&amp; <a class="code" href="classOp__Conv__Centre__old__VEF__Face.html#a127ff312dc2f3a33b685b78772fe98b2" title="NE FAIT RIEN A surcharger dans les classes derivees.">Op_Conv_Centre_old_VEF_Face::printOn</a>(<a class="code" href="classSortie.html" title="Classe de base des flux de sortie. Elle sait ecrire des types simples&lt;br&gt;(entiers, flottants) et des Ob...">Sortie</a>&amp; s )<span class="keyword"> const</span>
<a name="l00032"></a>00032 <span class="keyword"></span>{
<a name="l00033"></a>00033   <span class="keywordflow">return</span> s &lt;&lt; <a class="code" href="classObjet__U.html#aa58e9a81c0ddc2c1149053b8f96698ac" title="renvoie la chaine identifiant la classe.">que_suis_je</a>() ;
<a name="l00034"></a>00034 }
<a name="l00035"></a>00035 <span class="comment"></span>
<a name="l00036"></a>00036 <span class="comment">////!&lt; readOn </span>
<a name="l00037"></a>00037 <span class="comment"></span><span class="comment">//</span>
<a name="l00038"></a>00038 
<a name="l00039"></a><a class="code" href="classOp__Conv__Centre__old__VEF__Face.html#a1a445a5102888befb8d55840a1ea59ad">00039</a> <a class="code" href="classEntree.html" title="Classe de definition des operateurs et methodes pour toute lecture dans un flot d&#39;entree (fichier...">Entree</a>&amp; <a class="code" href="classOp__Conv__Centre__old__VEF__Face.html#a1a445a5102888befb8d55840a1ea59ad" title="NE FAIT RIEN A surcharger dans les classes derivees.">Op_Conv_Centre_old_VEF_Face::readOn</a>(<a class="code" href="classEntree.html" title="Classe de definition des operateurs et methodes pour toute lecture dans un flot d&#39;entree (fichier...">Entree</a>&amp; s )
<a name="l00040"></a>00040 {
<a name="l00041"></a>00041   <span class="keywordflow">return</span> s ;
<a name="l00042"></a>00042 }
<a name="l00043"></a>00043 
<a name="l00044"></a>00044 <span class="comment">// </span>
<a name="l00045"></a>00045 <span class="comment">// Fonctions de la classe Op_Conv_Centre_old_VEF_Face</span>
<a name="l00046"></a>00046 <span class="comment">// </span>
<a name="l00047"></a><a class="code" href="classOp__Conv__Centre__old__VEF__Face.html#ac4180ff13055d6e9d0a3b32cd626024f">00047</a> <span class="keywordtype">void</span> <a class="code" href="classOp__Conv__Centre__old__VEF__Face.html#ac4180ff13055d6e9d0a3b32cd626024f">Op_Conv_Centre_old_VEF_Face::associer</a>(<span class="keyword">const</span> <a class="code" href="classZone__dis.html" title="classe Zone_dis Classe generique de la hierarchie des zones discretisees. Un objet de type Zone_dis p...">Zone_dis</a>&amp; zone_dis,
<a name="l00048"></a>00048                                            <span class="keyword">const</span> <a class="code" href="classZone__Cl__dis.html" title="classe Zone_Cl_dis Classe generique de la hierarchie des conditions aux limites discretisees. Un objet Zone_Cl_dis peut referencer n&#39;importe quel derivant de Zone_Cl_dis_base. La plupart des methodes appellent les methodes de l&#39;objet Probleme sous-jacent via la methode valeur() declaree grace a la macro Declare_deriv().;">Zone_Cl_dis</a>&amp; zone_cl_dis,
<a name="l00049"></a>00049                                            <span class="keyword">const</span> <a class="code" href="classChamp__Inc.html">Champ_Inc</a>&amp; ch_transporte)
<a name="l00050"></a>00050 {
<a name="l00051"></a>00051   <span class="keyword">const</span> <a class="code" href="classZone__VEF.html" title="class Zone_VEF Classe instanciable qui derive de Zone_VF. Cette classe contient les informations geom...">Zone_VEF</a>&amp; zvef = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classZone__VEF.html" title="class Zone_VEF Classe instanciable qui derive de Zone_VF. Cette classe contient les informations geom...">Zone_VEF</a>,zone_dis.<a class="code" href="classDeriv__Zone__dis__base.html#a30ff47fc0684fe134e8c74c35b268941">valeur</a>());
<a name="l00052"></a>00052   <span class="keyword">const</span> <a class="code" href="classZone__Cl__VEF.html">Zone_Cl_VEF</a>&amp; zclvef = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classZone__Cl__VEF.html">Zone_Cl_VEF</a>,zone_cl_dis.<a class="code" href="classDeriv__Zone__Cl__dis__base.html#a6b56880f00b604e1f13970ec6d5bc077">valeur</a>());
<a name="l00053"></a>00053   <span class="keyword">const</span> <a class="code" href="classChamp__Inc__base.html" title="Classe Champ_Inc_base Classe de base des champs inconnues qui sont les champs calcules par une equati...">Champ_Inc_base</a>&amp; le_ch_transporte = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classChamp__Inc__base.html" title="Classe Champ_Inc_base Classe de base des champs inconnues qui sont les champs calcules par une equati...">Champ_Inc_base</a>,ch_transporte.<a class="code" href="classDeriv__Champ__Inc__base.html#a9e0b743a3e124e7114fa977b36b68225">valeur</a>());
<a name="l00054"></a>00054 
<a name="l00055"></a>00055   <a class="code" href="classOp__Conv__VEF__base.html#a6c29a488a6805ba4a9f2f059cdba77ae">la_zone_vef</a> = zvef;
<a name="l00056"></a>00056   <a class="code" href="classOp__Conv__VEF__base.html#a03f677ee7911706a4f85cd37e0ca4535">la_zcl_vef</a> = zclvef;
<a name="l00057"></a>00057   <a class="code" href="classOp__Conv__Centre__old__VEF__Face.html#a2d52371f8873a272d09ae9f903e98e22">champ_transporte</a> = le_ch_transporte;
<a name="l00058"></a>00058 
<a name="l00059"></a>00059   <a class="code" href="classOp__Conv__VEF__base.html#a32b54e8fd5340e238cf4f28ff6e743ec" title="tableau qui sert pour le calcul du pas de temps de stabilite">fluent</a>.<a class="code" href="classDoubleVect.html#a990500e5bf63a8ca55fd833d111e135c" title="met l&#39;objet dans l&#39;etat obtenu par le constructeur par defaut. (voir ArrOfDouble::reset())">reset</a>();
<a name="l00060"></a>00060   la_zone_vef.valeur().creer_tableau_faces(<a class="code" href="classOp__Conv__VEF__base.html#a32b54e8fd5340e238cf4f28ff6e743ec" title="tableau qui sert pour le calcul du pas de temps de stabilite">fluent</a>);
<a name="l00061"></a>00061 }
<a name="l00062"></a>00062 
<a name="l00063"></a><a class="code" href="classOp__Conv__Centre__old__VEF__Face.html#a3591fd76f65fe4df14342af2707a2c90">00063</a> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; <a class="code" href="classOp__Conv__Centre__old__VEF__Face.html#a3591fd76f65fe4df14342af2707a2c90">Op_Conv_Centre_old_VEF_Face::ajouter</a>(<span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; transporte,
<a name="l00064"></a>00064                                                 <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; resu)<span class="keyword"> const</span>
<a name="l00065"></a>00065 <span class="keyword"></span>{
<a name="l00066"></a>00066   <span class="keyword">const</span> <a class="code" href="classZone__Cl__VEF.html">Zone_Cl_VEF</a>&amp; zone_Cl_VEF = <a class="code" href="classOp__Conv__VEF__base.html#a03f677ee7911706a4f85cd37e0ca4535">la_zcl_vef</a>.<a class="code" href="classRef__Zone__Cl__VEF.html#a0970d7253def65ad4f0c5ce1830fd243">valeur</a>();
<a name="l00067"></a>00067   <span class="keyword">const</span> <a class="code" href="classZone__VEF.html" title="class Zone_VEF Classe instanciable qui derive de Zone_VF. Cette classe contient les informations geom...">Zone_VEF</a>&amp; zone_VEF = <a class="code" href="classOp__Conv__VEF__base.html#a6c29a488a6805ba4a9f2f059cdba77ae">la_zone_vef</a>.<a class="code" href="classRef__Zone__VEF.html#aafd9a5ee1a76f290c9c6b5447b0c8d30">valeur</a>();
<a name="l00068"></a>00068 <span class="comment">// const Champ_Inc_base&amp; le_transporte = champ_transporte.valeur();</span>
<a name="l00069"></a>00069   <span class="keyword">const</span> <a class="code" href="classChamp__Inc__base.html" title="Classe Champ_Inc_base Classe de base des champs inconnues qui sont les champs calcules par une equati...">Champ_Inc_base</a>&amp; la_vitesse =<a class="code" href="classOp__Conv__VEF__base.html#a5547875832fb45e09b1115372fb76ffd">vitesse_</a>.<a class="code" href="classRef__Champ__Inc__base.html#a17553641a4c06730e1562125e07b3490">valeur</a>();
<a name="l00070"></a>00070 
<a name="l00071"></a>00071   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; elem_faces = zone_VEF.<a class="code" href="classZone__VF.html#a067e462dcd3ab92b0f6d945b19e4eb37" title="renvoie le numero de le ieme face de la maille num_elem la facon dont ces faces sont numerotees est l...">elem_faces</a>();
<a name="l00072"></a>00072   <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; face_normales = zone_VEF.<a class="code" href="classZone__VEF.html#a5742d75972e4846bf9fbb6ed5715053e">face_normales</a>();
<a name="l00073"></a>00073   <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; facette_normales = zone_VEF.<a class="code" href="classZone__VEF.html#a581b1ca0e62c668c92f104351d19fda6">facette_normales</a>();
<a name="l00074"></a>00074 <span class="comment">// const DoubleVect&amp; volumes_entrelaces = zone_VEF.volumes_entrelaces();</span>
<a name="l00075"></a>00075   <span class="keyword">const</span> <a class="code" href="classZone.html" title="classe Zone Une Zone est un maillage compose d&#39;un ensemble d&#39;elements geometriques de meme type...">Zone</a>&amp; zone = zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>();
<a name="l00076"></a>00076 <span class="comment">// const int nb_faces = zone_VEF.nb_faces();</span>
<a name="l00077"></a>00077   <span class="keyword">const</span> <span class="keywordtype">int</span> nfa7 = zone_VEF.<a class="code" href="classZone__VEF.html#a46693c060b8096fb2595ca72192eea2a">type_elem</a>().<a class="code" href="classElem__VEF.html#a4a34777c0083b38dd34c8a400d5b4e90">nb_facette</a>();
<a name="l00078"></a>00078 <span class="comment">// const int nb_elem = zone_VEF.nb_elem();</span>
<a name="l00079"></a>00079   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_elem_tot = zone_VEF.<a class="code" href="classZone__dis__base.html#a4d6aa445f152aa6dc54d66ea7a071147">nb_elem_tot</a>();
<a name="l00080"></a>00080   <span class="keyword">const</span> <a class="code" href="classIntVect.html">IntVect</a>&amp; rang_elem_non_std = zone_VEF.<a class="code" href="classZone__VEF.html#a4b2171a85e5fc33663a3366acb713584">rang_elem_non_std</a>();
<a name="l00081"></a>00081 
<a name="l00082"></a>00082 
<a name="l00083"></a>00083   <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; normales_facettes_Cl = zone_Cl_VEF.<a class="code" href="classZone__Cl__VEF.html#a83c05e82370553470ed05f10932e0f3f">normales_facettes_Cl</a>();
<a name="l00084"></a>00084 <span class="comment">// const DoubleVect&amp; volumes_entrelaces_Cl = zone_Cl_VEF.volumes_entrelaces_Cl();</span>
<a name="l00085"></a>00085 
<a name="l00086"></a>00086   <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; porosite_face = zone_VEF.<a class="code" href="classZone__VF.html#ad9d74d1d9da9f50ab26768dbbca7711b">porosite_face</a>();
<a name="l00087"></a>00087   <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; fluent_ = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classDoubleVect.html">DoubleVect</a>, <a class="code" href="classOp__Conv__VEF__base.html#a32b54e8fd5340e238cf4f28ff6e743ec" title="tableau qui sert pour le calcul du pas de temps de stabilite">fluent</a>);
<a name="l00088"></a>00088 
<a name="l00089"></a>00089   <span class="keywordtype">int</span> nfac = zone.<a class="code" href="classZone.html#a548fbc7518be2f122b1a5c9589a443c2" title="Renvoie le nombre de face de type i des elements geometriques constituants la zone. Ex: les objets de la classe Prisme ont 2 types de faces: triangle ou quadrangle.">nb_faces_elem</a>();
<a name="l00090"></a>00090   <span class="keywordtype">int</span> nsom = zone.<a class="code" href="classZone.html#ae0b34a93b9ae8146df2d1884157afe9f" title="Renvoie le nombre de sommets des elements geometriques constituants la zone. Tous les elements de la ...">nb_som_elem</a>();
<a name="l00091"></a>00091   <span class="keywordtype">int</span> nb_som_facette = zone.<a class="code" href="classZone.html#a18cf83cd0f9c368dcfa32fb802a0ac94" title="Renvoie un element geometrique du type de ceux qui constituent la zone. (version const)">type_elem</a>().<a class="code" href="classElem__geom.html#ab55aa8b4ec6aa60cfde5d5fc134c5333" title="Appel a l&#39;objet sous-jacent Renvoie le nombre de sommets des faces du type specifie.">nb_som_face</a>();
<a name="l00092"></a>00092 
<a name="l00093"></a>00093 
<a name="l00094"></a>00094 <span class="comment">// Pour le traitement de la convection on distingue les polyedres</span>
<a name="l00095"></a>00095 <span class="comment">// standard qui ne &quot;voient&quot; pas les conditions aux limites et les</span>
<a name="l00096"></a>00096 <span class="comment">// polyedres non standard qui ont au moins une face sur le bord.</span>
<a name="l00097"></a>00097 <span class="comment">// Un polyedre standard a n facettes sur lesquelles on applique le</span>
<a name="l00098"></a>00098 <span class="comment">// schema de convection.</span>
<a name="l00099"></a>00099 <span class="comment">// Pour un polyedre non standard qui porte des conditions aux limites</span>
<a name="l00100"></a>00100 <span class="comment">// de Dirichlet, une partie des facettes sont portees par les faces.</span>
<a name="l00101"></a>00101 <span class="comment">// En bref pour un polyedre le traitement de la convection depend</span>
<a name="l00102"></a>00102 <span class="comment">// du type (triangle, tetraedre ...) et du nombre de faces de Dirichlet.</span>
<a name="l00103"></a>00103 
<a name="l00104"></a>00104   <span class="keywordtype">double</span> psc;
<a name="l00105"></a>00105   <span class="keywordtype">double</span> flux;
<a name="l00106"></a>00106   <span class="keywordtype">int</span> poly,face_adj,fa7,i,j,comp0,n_bord;
<a name="l00107"></a>00107   <span class="keywordtype">int</span> num_face, rang ,itypcl;
<a name="l00108"></a>00108   <span class="keywordtype">int</span> num10, num20, num_som;
<a name="l00109"></a>00109 
<a name="l00110"></a>00110   <span class="keywordtype">int</span> ncomp_ch_transporte;
<a name="l00111"></a>00111   <span class="keywordflow">if</span> (transporte.<a class="code" href="classDoubleTab.html#ae6dda48778e7107e1beb723beef1f75b" title="Returns the number of dimensions of the array (&gt;= 1)">nb_dim</a>() == 1)
<a name="l00112"></a>00112     ncomp_ch_transporte=1;
<a name="l00113"></a>00113   <span class="keywordflow">else</span>
<a name="l00114"></a>00114     ncomp_ch_transporte= transporte.<a class="code" href="classDoubleTab.html#ac3805e2637a3b880ba2d3e650c69dac4" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(1);
<a name="l00115"></a>00115 
<a name="l00116"></a>00116 <span class="comment">// MODIF SB su 10/09/03</span>
<a name="l00117"></a>00117 <span class="comment">// Pour les 3 elements suivants, il y a autant de sommets que de face</span>
<a name="l00118"></a>00118 <span class="comment">// constituant l&#39;element geometrique</span>
<a name="l00119"></a>00119 <span class="comment">// PB avec les hexa, 8 sommets et 6 faces, donc l&#39;utilisation du tableau</span>
<a name="l00120"></a>00120 <span class="comment">// face[i] ne fonctionne plus</span>
<a name="l00121"></a>00121 <span class="comment">// la methode retenue pour eviter de calculer la vitesse aux sommets sans</span>
<a name="l00122"></a>00122 <span class="comment">// les fonctions de forme n&#39;est donc pas utilisable,</span>
<a name="l00123"></a>00123 <span class="comment">// pour l&#39;hexa on n&#39;a pas acces a la face.</span>
<a name="l00124"></a>00124 <span class="comment">// il existe le tableau Face=&gt;sommets mais pas l&#39;inverse.</span>
<a name="l00125"></a>00125 <span class="comment">// trop couteux et pour le moment on n&#39;etend pas les porosites aux hexa</span>
<a name="l00126"></a>00126 
<a name="l00127"></a>00127   <span class="keywordtype">int</span> istetra=0;
<a name="l00128"></a>00128   <span class="keyword">const</span> <a class="code" href="classElem__VEF__base.html">Elem_VEF_base</a>&amp; type_elemvef= zone_VEF.<a class="code" href="classZone__VEF.html#a46693c060b8096fb2595ca72192eea2a">type_elem</a>().<a class="code" href="classDeriv__Elem__VEF__base.html#a2886905d5071be902c77248b69ca0b7b">valeur</a>();
<a name="l00129"></a>00129   <a class="code" href="classNom.html" title="class Nom Une chaine de caractere pour nommer les objets de TRUST">Nom</a> nom_elem=type_elemvef.<a class="code" href="classObjet__U.html#aa58e9a81c0ddc2c1149053b8f96698ac" title="renvoie la chaine identifiant la classe.">que_suis_je</a>();
<a name="l00130"></a>00130   <span class="keywordflow">if</span> ((nom_elem==<span class="stringliteral">&quot;Tetra_VEF&quot;</span>)||(nom_elem==<span class="stringliteral">&quot;Tri_VEF&quot;</span>))
<a name="l00131"></a>00131     istetra=1;
<a name="l00132"></a>00132 
<a name="l00133"></a>00133   <a class="code" href="classIntVect.html">IntVect</a> face(nfac);
<a name="l00134"></a>00134   <a class="code" href="classDoubleVect.html">DoubleVect</a> vs(<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>);
<a name="l00135"></a>00135   <a class="code" href="classDoubleVect.html">DoubleVect</a> vc(<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>);
<a name="l00136"></a>00136   <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a> vsom(nsom,<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>);
<a name="l00137"></a>00137   <a class="code" href="classDoubleVect.html">DoubleVect</a> cc(<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>);
<a name="l00138"></a>00138 
<a name="l00139"></a>00139 <span class="comment">// declaration pour le champ transporte</span>
<a name="l00140"></a>00140 
<a name="l00141"></a>00141   <a class="code" href="classDoubleVect.html">DoubleVect</a> ts(ncomp_ch_transporte);
<a name="l00142"></a>00142   <a class="code" href="classDoubleVect.html">DoubleVect</a> tc(ncomp_ch_transporte);
<a name="l00143"></a>00143   <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a> tsom(nsom,ncomp_ch_transporte);
<a name="l00144"></a>00144 
<a name="l00145"></a>00145 
<a name="l00146"></a>00146 <span class="comment">// On remet a zero le tableau qui sert pour</span>
<a name="l00147"></a>00147 <span class="comment">// le calcul du pas de temps de stabilite</span>
<a name="l00148"></a>00148   fluent_ = 0;
<a name="l00149"></a>00149 
<a name="l00150"></a>00150 <span class="comment">// Traitement particulier pour les faces de periodicite</span>
<a name="l00151"></a>00151 
<a name="l00152"></a>00152   <span class="keywordtype">int</span> nb_faces_perio = 0;
<a name="l00153"></a>00153   <span class="keywordflow">for</span> (n_bord=0; n_bord&lt;zone_VEF.<a class="code" href="classZone__dis__base.html#af22167d614644f55591a29c77eb1c009">nb_front_Cl</a>(); n_bord++)
<a name="l00154"></a>00154     {
<a name="l00155"></a>00155       <span class="keyword">const</span> <a class="code" href="classCond__lim.html" title="classe Cond_lim Classe generique servant a representer n&#39;importe quelle classe derivee de la classe C...">Cond_lim</a>&amp; la_cl = zone_Cl_VEF.<a class="code" href="classZone__Cl__dis__base.html#af75e0ed7786863e4d333bfb29d67c323" title="Renvoie la i-ieme condition aux limites. (version const)">les_conditions_limites</a>(n_bord);
<a name="l00156"></a>00156       <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>()))
<a name="l00157"></a>00157         {
<a name="l00158"></a>00158           <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp; le_bord = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>,la_cl.<a class="code" href="classCond__lim.html#a5b2d24809cee07727006a891d4ce8d22" title="Appel a l&#39;objet sous-jacent Renvoie la frontiere discretisee associee a la condition aux limites...">frontiere_dis</a>());
<a name="l00159"></a>00159           <span class="keywordtype">int</span> num1 = le_bord.<a class="code" href="classFront__VF.html#a4986f0c65653fe9eb40bbbff5a97bf16" title="Numero de la premiere face du bord dans la liste des faces.">num_premiere_face</a>();
<a name="l00160"></a>00160           <span class="keywordtype">int</span> num2 = num1 + le_bord.<a class="code" href="classFront__VF.html#a341e2fcb5117b96e745fd7078ba86bab" title="Nombre de faces reelles du bord.">nb_faces</a>();
<a name="l00161"></a>00161           <span class="keywordflow">for</span> (num_face=num1; num_face&lt;num2; num_face++)
<a name="l00162"></a>00162             nb_faces_perio++;
<a name="l00163"></a>00163         }
<a name="l00164"></a>00164     }
<a name="l00165"></a>00165 
<a name="l00166"></a>00166   <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a> tab;
<a name="l00167"></a>00167   <span class="keywordflow">if</span> (ncomp_ch_transporte == 1)
<a name="l00168"></a>00168     tab.<a class="code" href="classDoubleTab.html#ae83b4d31205c53d9c8d2b43da178ce75" title="Change la taille du vecteur (identique a resize_array() pour le traitement des anciennes valeurs et d...">resize</a>(nb_faces_perio);
<a name="l00169"></a>00169   <span class="keywordflow">else</span>
<a name="l00170"></a>00170     tab.<a class="code" href="classDoubleTab.html#ae83b4d31205c53d9c8d2b43da178ce75" title="Change la taille du vecteur (identique a resize_array() pour le traitement des anciennes valeurs et d...">resize</a>(nb_faces_perio,ncomp_ch_transporte);
<a name="l00171"></a>00171 
<a name="l00172"></a>00172   nb_faces_perio=0;
<a name="l00173"></a>00173   <span class="keywordflow">for</span> (n_bord=0; n_bord&lt;zone_VEF.<a class="code" href="classZone__dis__base.html#af22167d614644f55591a29c77eb1c009">nb_front_Cl</a>(); n_bord++)
<a name="l00174"></a>00174     {
<a name="l00175"></a>00175       <span class="keyword">const</span> <a class="code" href="classCond__lim.html" title="classe Cond_lim Classe generique servant a representer n&#39;importe quelle classe derivee de la classe C...">Cond_lim</a>&amp; la_cl = zone_Cl_VEF.<a class="code" href="classZone__Cl__dis__base.html#af75e0ed7786863e4d333bfb29d67c323" title="Renvoie la i-ieme condition aux limites. (version const)">les_conditions_limites</a>(n_bord);
<a name="l00176"></a>00176       <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>()))
<a name="l00177"></a>00177         {
<a name="l00178"></a>00178 <span class="comment">// const Periodique&amp; la_cl_perio = ref_cast(Periodique, la_cl.valeur());</span>
<a name="l00179"></a>00179           <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp; le_bord = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>,la_cl.<a class="code" href="classCond__lim.html#a5b2d24809cee07727006a891d4ce8d22" title="Appel a l&#39;objet sous-jacent Renvoie la frontiere discretisee associee a la condition aux limites...">frontiere_dis</a>());
<a name="l00180"></a>00180           <span class="keywordtype">int</span> num1 = le_bord.<a class="code" href="classFront__VF.html#a4986f0c65653fe9eb40bbbff5a97bf16" title="Numero de la premiere face du bord dans la liste des faces.">num_premiere_face</a>();
<a name="l00181"></a>00181           <span class="keywordtype">int</span> num2 = num1 + le_bord.<a class="code" href="classFront__VF.html#a341e2fcb5117b96e745fd7078ba86bab" title="Nombre de faces reelles du bord.">nb_faces</a>();
<a name="l00182"></a>00182           <span class="keywordflow">for</span> (num_face=num1; num_face&lt;num2; num_face++)
<a name="l00183"></a>00183             {
<a name="l00184"></a>00184               <span class="keywordflow">if</span> (ncomp_ch_transporte == 1)
<a name="l00185"></a>00185                 tab(nb_faces_perio) = resu(num_face);
<a name="l00186"></a>00186               <span class="keywordflow">else</span>
<a name="l00187"></a>00187                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> comp=0; comp&lt;ncomp_ch_transporte; comp++)
<a name="l00188"></a>00188                   tab(nb_faces_perio,comp) = resu(num_face,comp);
<a name="l00189"></a>00189               nb_faces_perio++;
<a name="l00190"></a>00190             }
<a name="l00191"></a>00191         }
<a name="l00192"></a>00192     }
<a name="l00193"></a>00193 
<a name="l00194"></a>00194 
<a name="l00195"></a>00195 <span class="comment">// Les polyedres non standard sont ranges en 2 groupes dans la Zone_VEF:</span>
<a name="l00196"></a>00196 <span class="comment">// - polyedres bords et joints</span>
<a name="l00197"></a>00197 <span class="comment">// - polyedres bords et non joints</span>
<a name="l00198"></a>00198 <span class="comment">// On traite les polyedres en suivant l&#39;ordre dans lequel ils figurent</span>
<a name="l00199"></a>00199 <span class="comment">// dans la zone</span>
<a name="l00200"></a>00200 
<a name="l00201"></a>00201 <span class="comment">// boucle sur les polys</span>
<a name="l00202"></a>00202   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; KEL=zone_VEF.<a class="code" href="classZone__VEF.html#a46693c060b8096fb2595ca72192eea2a">type_elem</a>().<a class="code" href="classDeriv__Elem__VEF__base.html#a2886905d5071be902c77248b69ca0b7b">valeur</a>().<a class="code" href="classElem__VEF__base.html#ab129610ef702aa8c9c98dcb4c7551172">KEL</a>();
<a name="l00203"></a>00203   <span class="keywordflow">for</span> (poly=0; poly&lt;nb_elem_tot; poly++)
<a name="l00204"></a>00204     {
<a name="l00205"></a>00205 
<a name="l00206"></a>00206       rang = rang_elem_non_std(poly);
<a name="l00207"></a>00207       <span class="keywordflow">if</span> (rang==-1)
<a name="l00208"></a>00208         itypcl=0;
<a name="l00209"></a>00209       <span class="keywordflow">else</span>
<a name="l00210"></a>00210         itypcl=zone_Cl_VEF.<a class="code" href="classZone__Cl__VEF.html#a483bdab7690f844ed04e3defe04ec70a">type_elem_Cl</a>(rang);
<a name="l00211"></a>00211 
<a name="l00212"></a>00212 <span class="comment">// calcul des numeros des faces du polyedre</span>
<a name="l00213"></a>00213       <span class="keywordflow">for</span> (face_adj=0; face_adj&lt;nfac; face_adj++)
<a name="l00214"></a>00214         face[face_adj]= elem_faces(poly,face_adj);
<a name="l00215"></a>00215 
<a name="l00216"></a>00216       <span class="keywordflow">for</span> (j=0; j&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; j++)
<a name="l00217"></a>00217         {
<a name="l00218"></a>00218           vs[j] = la_vitesse(face[0],j)*porosite_face(face[0]);
<a name="l00219"></a>00219           <span class="keywordflow">for</span> (i=1; i&lt;nfac; i++)
<a name="l00220"></a>00220             vs[j]+= la_vitesse(face[i],j)*porosite_face(face[i]);
<a name="l00221"></a>00221         }
<a name="l00222"></a>00222 <span class="comment">// int ncomp;</span>
<a name="l00223"></a>00223       <span class="keywordflow">if</span> (istetra==1)
<a name="l00224"></a>00224         {
<a name="l00225"></a>00225           <span class="keywordflow">for</span> (j=0; j&lt;nsom; j++)
<a name="l00226"></a>00226             {
<a name="l00227"></a>00227               <span class="keywordflow">for</span> (<span class="keywordtype">int</span> ncomp=0; ncomp&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>; ncomp++)
<a name="l00228"></a>00228                 vsom(j,ncomp) =vs[ncomp] - Objet_U::dimension*la_vitesse(face[j],ncomp)*porosite_face(face[j]);
<a name="l00229"></a>00229             }
<a name="l00230"></a>00230         }
<a name="l00231"></a>00231       <span class="keywordflow">else</span>
<a name="l00232"></a>00232         {
<a name="l00233"></a>00233 <span class="comment">// pour que cela soit valide avec les hexa</span>
<a name="l00234"></a>00234 <span class="comment">// On va utliser les fonctions de forme implementees dans la classe Champs_P1_impl ou Champs_Q1_impl</span>
<a name="l00235"></a>00235 <span class="comment">// int ncomp;</span>
<a name="l00236"></a>00236           <span class="keywordflow">for</span> (j=0; j&lt;nsom; j++)
<a name="l00237"></a>00237             {
<a name="l00238"></a>00238               num_som = zone.<a class="code" href="classZone.html#aa164c00997bc77a365a6da57bbec29ce" title="Renvoie le numero (global) j-ieme sommet du i-ieme element.">sommet_elem</a>(poly,j);
<a name="l00239"></a>00239               <span class="keywordflow">for</span> (<span class="keywordtype">int</span> ncomp=0; ncomp&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; ncomp++)
<a name="l00240"></a>00240                 {
<a name="l00241"></a>00241                   vsom(j,ncomp) = la_vitesse.<a class="code" href="classChamp__base.html#ad78f84c898b6fca623a30a9ae665c269" title="renvoi la compo eme corrdonne des valeurs a l&#39;element le_poly au sommet sommet">valeur_a_sommet_compo</a>(num_som,poly,ncomp);
<a name="l00242"></a>00242                 }
<a name="l00243"></a>00243             }
<a name="l00244"></a>00244         }
<a name="l00245"></a>00245 
<a name="l00246"></a>00246 <span class="comment">// calcul de vc</span>
<a name="l00247"></a>00247       zone_VEF.<a class="code" href="classZone__VEF.html#a46693c060b8096fb2595ca72192eea2a">type_elem</a>().<a class="code" href="classElem__VEF.html#ab0be052b1bfa6135cb9b8288086f098e">calcul_vc</a>(face,vc,vs,vsom,<a class="code" href="classOp__Conv__VEF__base.html#a4872ffd7c638ecc415191d92d7f5f507">vitesse</a>(),
<a name="l00248"></a>00248                                      itypcl,porosite_face);
<a name="l00249"></a>00249 
<a name="l00250"></a>00250 <span class="comment">// calcul du champ transporte aux sommets des polyedres ,tsom</span>
<a name="l00251"></a>00251       <span class="keywordflow">if</span>(ncomp_ch_transporte == 1)
<a name="l00252"></a>00252         {
<a name="l00253"></a>00253           ts[0]=transporte(face[0]);
<a name="l00254"></a>00254           <span class="keywordflow">for</span> (i=1; i&lt;nfac; i++)
<a name="l00255"></a>00255             ts[0]+= transporte(face[i]);
<a name="l00256"></a>00256 
<a name="l00257"></a>00257           <span class="keywordflow">for</span> (i=0; i&lt;nsom; i++)
<a name="l00258"></a>00258             tsom(i,0) = ts[0] - dimension*transporte(face[i],0);
<a name="l00259"></a>00259         }
<a name="l00260"></a>00260       <span class="keywordflow">else</span>
<a name="l00261"></a>00261         {
<a name="l00262"></a>00262           <span class="keywordflow">for</span> (j=0; j&lt;ncomp_ch_transporte; j++)
<a name="l00263"></a>00263             {
<a name="l00264"></a>00264               ts[j] = transporte(face[0],j);
<a name="l00265"></a>00265               <span class="keywordflow">for</span> (i=1; i&lt;nfac; i++)
<a name="l00266"></a>00266                 ts[j]+= transporte(face[i],j);
<a name="l00267"></a>00267             }
<a name="l00268"></a>00268           <span class="keywordflow">for</span> (i=0; i&lt;nsom; i++)
<a name="l00269"></a>00269             <span class="keywordflow">for</span> (j=0; j&lt;ncomp_ch_transporte; j++)
<a name="l00270"></a>00270               tsom(i,j) = ts[j] - dimension*transporte(face[i],j);
<a name="l00271"></a>00271         }
<a name="l00272"></a>00272 
<a name="l00273"></a>00273 <span class="comment">// calcul du champ transporte au centre de gravite ,tc</span>
<a name="l00274"></a>00274 
<a name="l00275"></a>00275       <span class="keywordflow">for</span> (j=0; j&lt;ncomp_ch_transporte; j++)
<a name="l00276"></a>00276         tc[j] = ts[j]/nfac;
<a name="l00277"></a>00277 
<a name="l00278"></a>00278 
<a name="l00279"></a>00279 <span class="comment">// Boucle sur les facettes du polyedre non standard:</span>
<a name="l00280"></a>00280 
<a name="l00281"></a>00281       <span class="keywordflow">for</span> (fa7=0; fa7&lt;nfa7; fa7++)
<a name="l00282"></a>00282         {
<a name="l00283"></a>00283           num10 = face[KEL(0,fa7)];
<a name="l00284"></a>00284           num20 = face[KEL(1,fa7)];
<a name="l00285"></a>00285           <span class="keywordflow">if</span> (rang==-1)
<a name="l00286"></a>00286             <span class="keywordflow">for</span> (i=0; i&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; i++)
<a name="l00287"></a>00287               cc[i] = facette_normales(poly,fa7,i);
<a name="l00288"></a>00288           <span class="keywordflow">else</span>
<a name="l00289"></a>00289             <span class="keywordflow">for</span> (i=0; i&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; i++)
<a name="l00290"></a>00290               cc[i] = normales_facettes_Cl(rang,fa7,i);
<a name="l00291"></a>00291 
<a name="l00292"></a>00292 <span class="comment">// On applique le schema de convection a chaque sommet de la facette</span>
<a name="l00293"></a>00293 
<a name="l00294"></a>00294 <span class="comment">// On traite le ou les sommets qui sont aussi des sommets du polyedre</span>
<a name="l00295"></a>00295 
<a name="l00296"></a>00296           <span class="keywordtype">int</span> isom;
<a name="l00297"></a>00297           <span class="keywordflow">for</span> (i=0; i&lt;nb_som_facette-1; i++)
<a name="l00298"></a>00298             {
<a name="l00299"></a>00299               isom = KEL(i+2,fa7);
<a name="l00300"></a>00300               psc =0;
<a name="l00301"></a>00301               <span class="keywordflow">for</span> (j=0; j&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; j++)
<a name="l00302"></a>00302                 psc+= vsom(isom,j)*cc[j];
<a name="l00303"></a>00303               psc /= nb_som_facette;
<a name="l00304"></a>00304 
<a name="l00305"></a>00305               <span class="keywordflow">if</span>(psc &gt;= 0)
<a name="l00306"></a>00306                 fluent_[num20] += psc;
<a name="l00307"></a>00307               <span class="keywordflow">else</span>
<a name="l00308"></a>00308                 fluent_[num10] -= psc;
<a name="l00309"></a>00309 
<a name="l00310"></a>00310 <span class="comment">// ecriture du flux</span>
<a name="l00311"></a>00311               <span class="keywordflow">if</span> (ncomp_ch_transporte == 1)
<a name="l00312"></a>00312                 {
<a name="l00313"></a>00313                   flux = tsom(isom,0)*psc;
<a name="l00314"></a>00314                   resu(num10) -= flux;
<a name="l00315"></a>00315                   resu(num20) += flux;
<a name="l00316"></a>00316                 }
<a name="l00317"></a>00317               <span class="keywordflow">else</span>
<a name="l00318"></a>00318                 <span class="keywordflow">for</span> (comp0=0; comp0&lt;ncomp_ch_transporte; comp0++)
<a name="l00319"></a>00319                   {
<a name="l00320"></a>00320                     flux = tsom(isom,comp0)*psc;
<a name="l00321"></a>00321                     resu(num10, comp0) -= flux;
<a name="l00322"></a>00322                     resu(num20, comp0) += flux;
<a name="l00323"></a>00323                   }
<a name="l00324"></a>00324             }
<a name="l00325"></a>00325 
<a name="l00326"></a>00326 
<a name="l00327"></a>00327 <span class="comment">// On traite le sommet confondu avec le centre de gravite du polyedre</span>
<a name="l00328"></a>00328 
<a name="l00329"></a>00329           psc=0;
<a name="l00330"></a>00330           <span class="keywordflow">for</span> (j=0; j&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; j++)
<a name="l00331"></a>00331             psc += vc[j]*cc[j];
<a name="l00332"></a>00332           psc /= nb_som_facette;
<a name="l00333"></a>00333 
<a name="l00334"></a>00334           <span class="keywordflow">if</span>(psc &gt;= 0)
<a name="l00335"></a>00335             fluent_[num20] += psc;
<a name="l00336"></a>00336           <span class="keywordflow">else</span>
<a name="l00337"></a>00337             fluent_[num10] -= psc;
<a name="l00338"></a>00338 
<a name="l00339"></a>00339 <span class="comment">// ecriture du flux</span>
<a name="l00340"></a>00340 
<a name="l00341"></a>00341           <span class="keywordflow">if</span> (ncomp_ch_transporte == 1)
<a name="l00342"></a>00342             {
<a name="l00343"></a>00343               flux = tc[0]*psc;
<a name="l00344"></a>00344               resu(num10) -= flux;
<a name="l00345"></a>00345               resu(num20) += flux;
<a name="l00346"></a>00346             }
<a name="l00347"></a>00347           <span class="keywordflow">else</span>
<a name="l00348"></a>00348             <span class="keywordflow">for</span> (comp0=0; comp0&lt;ncomp_ch_transporte; comp0++)
<a name="l00349"></a>00349               {
<a name="l00350"></a>00350                 flux = tc[comp0]*psc;
<a name="l00351"></a>00351                 resu(num10, comp0) -= flux;
<a name="l00352"></a>00352                 resu(num20, comp0) += flux;
<a name="l00353"></a>00353               }
<a name="l00354"></a>00354         }
<a name="l00355"></a>00355 
<a name="l00356"></a>00356     } <span class="comment">//!&lt; fin de la boucle</span>
<a name="l00357"></a>00357 <span class="comment"></span>
<a name="l00358"></a>00358   <span class="keywordtype">int</span> voisine;
<a name="l00359"></a>00359   nb_faces_perio = 0;
<a name="l00360"></a>00360   <span class="keywordtype">double</span> diff1,diff2;
<a name="l00361"></a>00361 
<a name="l00362"></a>00362 <span class="comment">// Dimensionnement du tableau des flux convectifs au bord du domaine</span>
<a name="l00363"></a>00363 <span class="comment">// de calcul</span>
<a name="l00364"></a>00364   <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; flux_b = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>,<a class="code" href="classOperateur__base.html#a451f51b41518ddbc0d3f586a8177d319" title="Tableau contenant les flux sur les bords de l&#39;operateur.">flux_bords_</a>);
<a name="l00365"></a>00365   flux_b.<a class="code" href="classDoubleTab.html#ae83b4d31205c53d9c8d2b43da178ce75" title="Change la taille du vecteur (identique a resize_array() pour le traitement des anciennes valeurs et d...">resize</a>(zone_VEF.<a class="code" href="classZone__VF.html#a8815e2276637c0db23868f043dc43e58" title="renvoie le nombre de faces sur lesquelles sont appliquees les conditions limites : bords...">nb_faces_bord</a>(),ncomp_ch_transporte);
<a name="l00366"></a>00366   flux_b = 0.;
<a name="l00367"></a>00367 
<a name="l00368"></a>00368 <span class="comment">// Boucle sur les bords pour traiter les conditions aux limites</span>
<a name="l00369"></a>00369 <span class="comment">// il y a prise en compte d&#39;un terme de convection pour les</span>
<a name="l00370"></a>00370 <span class="comment">// conditions aux limites de Neumann_sortie_libre seulement</span>
<a name="l00371"></a>00371 
<a name="l00372"></a>00372   <span class="keywordflow">for</span> (n_bord=0; n_bord&lt;zone_VEF.<a class="code" href="classZone__dis__base.html#af22167d614644f55591a29c77eb1c009">nb_front_Cl</a>(); n_bord++)
<a name="l00373"></a>00373     {
<a name="l00374"></a>00374 
<a name="l00375"></a>00375       <span class="keyword">const</span> <a class="code" href="classCond__lim.html" title="classe Cond_lim Classe generique servant a representer n&#39;importe quelle classe derivee de la classe C...">Cond_lim</a>&amp; la_cl = zone_Cl_VEF.<a class="code" href="classZone__Cl__dis__base.html#af75e0ed7786863e4d333bfb29d67c323" title="Renvoie la i-ieme condition aux limites. (version const)">les_conditions_limites</a>(n_bord);
<a name="l00376"></a>00376 
<a name="l00377"></a>00377       <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classNeumann__sortie__libre.html" title="classe Neumann_sortie_libre Cette classe represente une frontiere ouverte sans vitesse imposee Pour l...">Neumann_sortie_libre</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>()))
<a name="l00378"></a>00378         {
<a name="l00379"></a>00379           <span class="keyword">const</span> <a class="code" href="classNeumann__sortie__libre.html" title="classe Neumann_sortie_libre Cette classe represente une frontiere ouverte sans vitesse imposee Pour l...">Neumann_sortie_libre</a>&amp; la_sortie_libre = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classNeumann__sortie__libre.html" title="classe Neumann_sortie_libre Cette classe represente une frontiere ouverte sans vitesse imposee Pour l...">Neumann_sortie_libre</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>());
<a name="l00380"></a>00380           <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp; le_bord = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>,la_cl.<a class="code" href="classCond__lim.html#a5b2d24809cee07727006a891d4ce8d22" title="Appel a l&#39;objet sous-jacent Renvoie la frontiere discretisee associee a la condition aux limites...">frontiere_dis</a>());
<a name="l00381"></a>00381           <span class="keywordtype">int</span> num1 = le_bord.num_premiere_face();
<a name="l00382"></a>00382           <span class="keywordtype">int</span> num2 = num1 + le_bord.nb_faces();
<a name="l00383"></a>00383           <span class="keywordflow">for</span> (num_face=num1; num_face&lt;num2; num_face++)
<a name="l00384"></a>00384             {
<a name="l00385"></a>00385               psc =0;
<a name="l00386"></a>00386               <span class="keywordflow">for</span> (i=0; i&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; i++)
<a name="l00387"></a>00387                 psc += la_vitesse(num_face,i)*face_normales(num_face,i)*porosite_face(num_face);
<a name="l00388"></a>00388               <span class="keywordflow">if</span> (psc&gt;0)
<a name="l00389"></a>00389                 <span class="keywordflow">if</span> (ncomp_ch_transporte == 1)
<a name="l00390"></a>00390                   {
<a name="l00391"></a>00391                     resu(num_face) -= psc*transporte(num_face);
<a name="l00392"></a>00392                     flux_b(num_face,0) -= psc*transporte(num_face);
<a name="l00393"></a>00393                   }
<a name="l00394"></a>00394                 <span class="keywordflow">else</span>
<a name="l00395"></a>00395                   <span class="keywordflow">for</span> (i=0; i&lt;ncomp_ch_transporte; i++)
<a name="l00396"></a>00396                     {
<a name="l00397"></a>00397                       resu(num_face,i) -= psc*transporte(num_face,i);
<a name="l00398"></a>00398                       flux_b(num_face,i) -= psc*transporte(num_face,i);
<a name="l00399"></a>00399                     }
<a name="l00400"></a>00400               <span class="keywordflow">else</span>
<a name="l00401"></a>00401                 {
<a name="l00402"></a>00402                   <span class="keywordflow">if</span> (ncomp_ch_transporte == 1)
<a name="l00403"></a>00403                     {
<a name="l00404"></a>00404                       resu(num_face) -= psc*la_sortie_libre.<a class="code" href="classNeumann__sortie__libre.html#a886f1804fa2a9028fc56a0778a72a75d" title="Renvoie la valeur de la i-eme composante du champ impose a l&#39;exterieur de la frontiere.">val_ext</a>(num_face-num1);
<a name="l00405"></a>00405                       flux_b(num_face,0) -= psc*la_sortie_libre.<a class="code" href="classNeumann__sortie__libre.html#a886f1804fa2a9028fc56a0778a72a75d" title="Renvoie la valeur de la i-eme composante du champ impose a l&#39;exterieur de la frontiere.">val_ext</a>(num_face-num1);
<a name="l00406"></a>00406                     }
<a name="l00407"></a>00407                   <span class="keywordflow">else</span>
<a name="l00408"></a>00408                     <span class="keywordflow">for</span> (i=0; i&lt;ncomp_ch_transporte; i++)
<a name="l00409"></a>00409                       {
<a name="l00410"></a>00410                         resu(num_face,i) -= psc*la_sortie_libre.<a class="code" href="classNeumann__sortie__libre.html#a886f1804fa2a9028fc56a0778a72a75d" title="Renvoie la valeur de la i-eme composante du champ impose a l&#39;exterieur de la frontiere.">val_ext</a>(num_face-num1,i);
<a name="l00411"></a>00411                         flux_b(num_face,i) -= psc*la_sortie_libre.<a class="code" href="classNeumann__sortie__libre.html#a886f1804fa2a9028fc56a0778a72a75d" title="Renvoie la valeur de la i-eme composante du champ impose a l&#39;exterieur de la frontiere.">val_ext</a>(num_face-num1,i);
<a name="l00412"></a>00412                       }
<a name="l00413"></a>00413                   fluent_[num_face] -= psc;
<a name="l00414"></a>00414                 }
<a name="l00415"></a>00415             }
<a name="l00416"></a>00416         }
<a name="l00417"></a>00417       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>()))
<a name="l00418"></a>00418         {
<a name="l00419"></a>00419           <span class="keyword">const</span> <a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>&amp; la_cl_perio = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>());
<a name="l00420"></a>00420           <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp; le_bord = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>,la_cl.<a class="code" href="classCond__lim.html#a5b2d24809cee07727006a891d4ce8d22" title="Appel a l&#39;objet sous-jacent Renvoie la frontiere discretisee associee a la condition aux limites...">frontiere_dis</a>());
<a name="l00421"></a>00421           <span class="keywordtype">int</span> num1 = le_bord.num_premiere_face();
<a name="l00422"></a>00422           <span class="keywordtype">int</span> num2 = num1 + le_bord.nb_faces();
<a name="l00423"></a>00423           <a class="code" href="classIntVect.html">IntVect</a> fait(le_bord.nb_faces());
<a name="l00424"></a>00424           fait = 0;
<a name="l00425"></a>00425           <span class="keywordflow">for</span> (num_face=num1; num_face&lt;num2; num_face++)
<a name="l00426"></a>00426             {
<a name="l00427"></a>00427               <span class="keywordflow">if</span> (fait[num_face-num1] == 0)
<a name="l00428"></a>00428                 {
<a name="l00429"></a>00429                   voisine = la_cl_perio.<a class="code" href="classPeriodique.html#a207b86556f199a63ea059b841851ca6a">face_associee</a>(num_face-num1) + num1;
<a name="l00430"></a>00430 
<a name="l00431"></a>00431                   <span class="keywordflow">if</span> (ncomp_ch_transporte == 1)
<a name="l00432"></a>00432                     {
<a name="l00433"></a>00433                       diff1 = resu(num_face)-tab(nb_faces_perio);
<a name="l00434"></a>00434                       diff2 = resu(voisine)-tab(nb_faces_perio+voisine-num_face);
<a name="l00435"></a>00435                       resu(voisine)  += diff1;
<a name="l00436"></a>00436                       resu(num_face) += diff2;
<a name="l00437"></a>00437                       flux_b(voisine,0) += diff1;
<a name="l00438"></a>00438                       flux_b(num_face,0) += diff2;
<a name="l00439"></a>00439                     }
<a name="l00440"></a>00440                   <span class="keywordflow">else</span>
<a name="l00441"></a>00441                     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> comp=0; comp&lt;ncomp_ch_transporte; comp++)
<a name="l00442"></a>00442                       {
<a name="l00443"></a>00443                         diff1 = resu(num_face,comp)-tab(nb_faces_perio,comp);
<a name="l00444"></a>00444                         diff2 = resu(voisine,comp)-tab(nb_faces_perio+voisine-num_face,comp);
<a name="l00445"></a>00445                         resu(voisine,comp)  += diff1;
<a name="l00446"></a>00446                         resu(num_face,comp) += diff2;
<a name="l00447"></a>00447                         flux_b(voisine,comp) += diff1;
<a name="l00448"></a>00448                         flux_b(num_face,comp) += diff2;
<a name="l00449"></a>00449                       }
<a name="l00450"></a>00450 
<a name="l00451"></a>00451                   fait[num_face-num1]= 1;
<a name="l00452"></a>00452                   fait[voisine-num1] = 1;
<a name="l00453"></a>00453                 }
<a name="l00454"></a>00454               nb_faces_perio++;
<a name="l00455"></a>00455             }
<a name="l00456"></a>00456         }
<a name="l00457"></a>00457     }
<a name="l00458"></a>00458   <a class="code" href="classOp__VEF__Face.html#a6c8ce571769b4f2e20b07cbb7a6944f2">modifier_flux</a>(*<span class="keyword">this</span>);
<a name="l00459"></a>00459   <span class="keywordflow">return</span> resu;
<a name="l00460"></a>00460 
<a name="l00461"></a>00461 }
<a name="l00462"></a>00462 
</pre></div></div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Tue Dec 14 2021 19:35:42 for TRUST by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
