<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>TRUST: PE_Groups Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">TRUST&#160;<span id="projectnumber">1.8.4</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pri-static-methods">Static Private Member Functions</a> &#124;
<a href="#pri-static-attribs">Static Private Attributes</a>  </div>
  <div class="headertitle">
<div class="title">PE_Groups Class Reference</div>  </div>
</div>
<div class="contents">
<!-- doxytag: class="PE_Groups" -->
<p>:<br/>
Cette classe regroupe des fonctions permettant la creation, la<br/>
destruction et le changement du groupe de processeurs actif.<br/>
La creation du groupe principal doit etre dans le <a class="el" href="MAIN_8cpp.html">MAIN.cpp</a><br/>
et il faut initialiser <a class="el" href="classPE__Groups.html" title=": Cette classe regroupe des fonctions permettant la creation, la destruction et le changement du grou...">PE_Groups</a> en lui donnant le groupe principal.<br/>
Les autres groupes crees seront du meme type.<br/>
Voir aussi la class <a class="el" href="classComm__Group.html" title=": Cette classe decrit un groupe de processeurs sur lesquels une portion de code s&#39;execute simultaneme...">Comm_Group</a>  
 <a href="classPE__Groups.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="PE__Groups_8h_source.html">PE_Groups.h</a>&gt;</code></p>

<p><a href="classPE__Groups-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classComm__Group.html">Comm_Group</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPE__Groups.html#ae6ca0277a58f2ab34ebfb3216578fa75">current_group</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">renvoie une reference au groupe de processeurs actif courant  <a href="#ae6ca0277a58f2ab34ebfb3216578fa75"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPE__Groups.html#a9882412c8e813c12d2fce5dbb2996430">create_group</a> (const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;liste_pe, <a class="el" href="classDeriv__Comm__Group.html">Deriv_Comm_Group</a> &amp;group, int force_Comm_Group_NoParallel=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creation d'un nouveau groupe de processeurs<br/>
(utilisation possible n'importe ou dans le code)<br/>
Il faut l'appeler simultanement sur tous les processeurs du groupe <a class="el" href="classPE__Groups.html#ae6ca0277a58f2ab34ebfb3216578fa75" title="renvoie une reference au groupe de processeurs actif courant">current_group()</a><br/>
avec le meme tableau liste_pe. liste_pe est la liste des rangs dans le groupe<br/>
courant des processeurs que l'on veut inclure dans le groupe. Le premier de la<br/>
liste sera le maitre du groupe. La liste ne doit pas comporter de doublon et<br/>
doit contenir au moins un processeur.<br/>
La methode type et initialize l'objet group.<br/>
Il faut ensuite appeler <a class="el" href="classPE__Groups.html#a1df95ab36f35005ab28fd5c134794772" title="Si le processeur local appartient au groupe, le groupe courant pour ce processeur devient &quot;group&quot; e...">enter_group()</a> et <a class="el" href="classPE__Groups.html#af49cb26695386d2e0de890aadc39057e" title="Retourne dans le groupe ou l&#39;on etait avant le dernier enter_group() reussi (dont le resultat a ete 1...">exit_group()</a> (autant de fois qu'on veut)  <a href="#a9882412c8e813c12d2fce5dbb2996430"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPE__Groups.html#a1df95ab36f35005ab28fd5c134794772">enter_group</a> (const <a class="el" href="classComm__Group.html">Comm_Group</a> &amp;group)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Si le processeur local appartient au groupe, le groupe courant<br/>
pour ce processeur devient "group" et on renvoie 1, sinon on renvoie 0.<br/>
Une reference au groupe actuel est sauvegardee et sera restauree quand on<br/>
appellera <a class="el" href="classPE__Groups.html#af49cb26695386d2e0de890aadc39057e" title="Retourne dans le groupe ou l&#39;on etait avant le dernier enter_group() reussi (dont le resultat a ete 1...">exit_group()</a>.<br/>
Cette methode doit etre appelee simultanement sur tous les processeurs<br/>
du groupe "group".<br/>
Attention: a chaque <a class="el" href="classPE__Groups.html#a1df95ab36f35005ab28fd5c134794772" title="Si le processeur local appartient au groupe, le groupe courant pour ce processeur devient &quot;group&quot; e...">enter_group()</a> doit correspondre un <a class="el" href="classPE__Groups.html#af49cb26695386d2e0de890aadc39057e" title="Retourne dans le groupe ou l&#39;on etait avant le dernier enter_group() reussi (dont le resultat a ete 1...">exit_group()</a>.<br/>
Cependant, il n'est pas interdit d'entrer plusieurs fois de suite dans le<br/>
meme groupe, ni d'entrer dans un groupe plus grand que le groupe actuel.<br/>
Exemple : group1 et group2 forment une partition du <a class="el" href="classPE__Groups.html#af38ed6631e572dc5117361b3f26a47a3" title="Renvoie une reference au groupe de tous les processeurs TRUST.">groupe_TRUST()</a><br/>
int sync_point(int x)<br/>
{<br/>
<a class="el" href="classPE__Groups.html#a1df95ab36f35005ab28fd5c134794772" title="Si le processeur local appartient au groupe, le groupe courant pour ce processeur devient &quot;group&quot; e...">PE_Groups::enter_group</a>(<a class="el" href="classPE__Groups.html#af38ed6631e572dc5117361b3f26a47a3" title="Renvoie une reference au groupe de tous les processeurs TRUST.">groupe_TRUST()</a>);<br/>
int i = mp_sum(x);<br/>
<a class="el" href="classPE__Groups.html#af49cb26695386d2e0de890aadc39057e" title="Retourne dans le groupe ou l&#39;on etait avant le dernier enter_group() reussi (dont le resultat a ete 1...">PE_Groups::exit_group()</a>;<br/>
return i;<br/>
}<br/>
if (PE_Groups::enter_group(group1)) {<br/>
s1 = mp_sum(x); // Somme sur le groupe 2<br/>
// <a class="el" href="classPoint.html" title="Classe Point Cette classe represente l&#39;element geometrique segment. Un Point a 1 face et 1 sommets...">Point</a> de synchro avec l'autre groupe:<br/>
s_all = sync_point(x);<br/>
} else if (PE_Groups::enter_group(group2)) {<br/>
s2 = mp_sum(x);<br/>
// <a class="el" href="classPoint.html" title="Classe Point Cette classe represente l&#39;element geometrique segment. Un Point a 1 face et 1 sommets...">Point</a> de synchro avec l'autre groupe:<br/>
s_all = sync_point(x);<br/>
} else {<br/>
Cerr &lt;&lt; "Error: processor " &lt;&lt; me() &lt;&lt; " is not within a subgroup.";<br/>
exit();<br/>
}<br/>
<a class="el" href="classPE__Groups.html#af49cb26695386d2e0de890aadc39057e" title="Retourne dans le groupe ou l&#39;on etait avant le dernier enter_group() reussi (dont le resultat a ete 1...">PE_Groups::exit_group()</a>; // Sort du sous-groupe.  <a href="#a1df95ab36f35005ab28fd5c134794772"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPE__Groups.html#af49cb26695386d2e0de890aadc39057e">exit_group</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne dans le groupe ou l'on etait avant le dernier<br/>
<a class="el" href="classPE__Groups.html#a1df95ab36f35005ab28fd5c134794772" title="Si le processeur local appartient au groupe, le groupe courant pour ce processeur devient &quot;group&quot; e...">enter_group()</a> reussi (dont le resultat a ete 1).<br/>
Cette methode doit etre appelee simultanement sur tous les processeurs<br/>
du <a class="el" href="classPE__Groups.html#ae6ca0277a58f2ab34ebfb3216578fa75" title="renvoie une reference au groupe de processeurs actif courant">current_group()</a> actif juste avant <a class="el" href="classPE__Groups.html#af49cb26695386d2e0de890aadc39057e" title="Retourne dans le groupe ou l&#39;on etait avant le dernier enter_group() reussi (dont le resultat a ete 1...">exit_group()</a>).  <a href="#af49cb26695386d2e0de890aadc39057e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const int &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPE__Groups.html#a6fe714bb78ca65d4731c8b95db492172">get_nb_groups</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPE__Groups.html#aed0079543355fa583812b12a49056707">rank_translate</a> (int rank, const <a class="el" href="classComm__Group.html">Comm_Group</a> &amp;group, const <a class="el" href="classComm__Group.html">Comm_Group</a> &amp;dest_group=current_group())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calcule le rank dans le groupe courant du processeur de rang "rank" dans le "group".<br/>
Il faut que 0 &lt;= rank &lt; group.nproc()<br/>
Si le processeur en question n'appartient pas au groupe courant, renvoie -1.  <a href="#aed0079543355fa583812b12a49056707"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classComm__Group.html">Comm_Group</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPE__Groups.html#af38ed6631e572dc5117361b3f26a47a3">groupe_TRUST</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Renvoie une reference au groupe de tous les processeurs TRUST.  <a href="#af38ed6631e572dc5117361b3f26a47a3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPE__Groups.html#a96163527a12b74c0caf330ac7349d634">initialize</a> (const <a class="el" href="classComm__Group.html">Comm_Group</a> &amp;groupe_trio_u)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Methode a appeler au debut de l'execution (<a class="el" href="MAIN_8cpp.html">MAIN.cpp</a>)<br/>
Elle initialise <a class="el" href="classPE__Groups.html#ae6ca0277a58f2ab34ebfb3216578fa75" title="renvoie une reference au groupe de processeurs actif courant">current_group()</a> avec groupe_trio_u.  <a href="#a96163527a12b74c0caf330ac7349d634"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPE__Groups.html#a711ec244f2a93cc54863f63053a5bdd8">finalize</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Methode a appeler en fin d'execution, une fois qu'on est revenu<br/>
dans le <a class="el" href="classPE__Groups.html#af38ed6631e572dc5117361b3f26a47a3" title="Renvoie une reference au groupe de tous les processeurs TRUST.">groupe_TRUST()</a> et juste avant de detruire de <a class="el" href="classComm__Group.html" title=": Cette classe decrit un groupe de processeurs sur lesquels une portion de code s&#39;execute simultaneme...">Comm_Group</a><br/>
principal.  <a href="#a711ec244f2a93cc54863f63053a5bdd8"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pri-static-methods"></a>
Static Private Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPE__Groups.html#acbc7b643af10631009f4d96f6564e41d">check_current_group</a> ()</td></tr>
<tr><td colspan="2"><h2><a name="pri-static-attribs"></a>
Static Private Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classComm__Group.html">Comm_Group</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPE__Groups.html#a9d07be726ca7ac3b026415210437067d">current_group_</a> = 0</td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>:<br/>
Cette classe regroupe des fonctions permettant la creation, la<br/>
destruction et le changement du groupe de processeurs actif.<br/>
La creation du groupe principal doit etre dans le <a class="el" href="MAIN_8cpp.html">MAIN.cpp</a><br/>
et il faut initialiser <a class="el" href="classPE__Groups.html" title=": Cette classe regroupe des fonctions permettant la creation, la destruction et le changement du grou...">PE_Groups</a> en lui donnant le groupe principal.<br/>
Les autres groupes crees seront du meme type.<br/>
Voir aussi la class <a class="el" href="classComm__Group.html" title=": Cette classe decrit un groupe de processeurs sur lesquels une portion de code s&#39;execute simultaneme...">Comm_Group</a> </p>

<p>Definition at line <a class="el" href="PE__Groups_8h_source.html#l00033">33</a> of file <a class="el" href="PE__Groups_8h_source.html">PE_Groups.h</a>.</p>
</div><hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="acbc7b643af10631009f4d96f6564e41d"></a><!-- doxytag: member="PE_Groups::check_current_group" ref="acbc7b643af10631009f4d96f6564e41d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PE_Groups::check_current_group </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="PE__Groups_8cpp_source.html#l00035">35</a> of file <a class="el" href="PE__Groups_8cpp_source.html">PE_Groups.cpp</a>.</p>

<p>References <a class="el" href="Source__Generique__Face__PolyMAC_8cpp_source.html#l00045">valeur()</a>.</p>

<p>Referenced by <a class="el" href="PE__Groups_8h_source.html#l00054">current_group()</a>.</p>
<div class="fragment"><pre class="fragment">{
  assert(<a class="code" href="PE__Groups_8cpp.html#ae5dcb44242d12656bf1a5945b165aebc">ngroups</a> &gt; 0);
  assert(<a class="code" href="classPE__Groups.html#a9d07be726ca7ac3b026415210437067d">current_group_</a> == &amp;(<a class="code" href="PE__Groups_8cpp.html#a2d9739a5d1332e53b0013698914d796c">groups</a>[<a class="code" href="PE__Groups_8cpp.html#ae5dcb44242d12656bf1a5945b165aebc">ngroups</a>-1].<a class="code" href="Source__Generique__Face__PolyMAC_8cpp.html#a7d7b5d77a3caa1af70f5e1c9108de5a1">valeur</a>()));
  <span class="keywordflow">return</span> 1;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a9882412c8e813c12d2fce5dbb2996430"></a><!-- doxytag: member="PE_Groups::create_group" ref="a9882412c8e813c12d2fce5dbb2996430" args="(const ArrOfInt &amp;liste_pe, Deriv_Comm_Group &amp;group, int force_Comm_Group_NoParallel=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PE_Groups::create_group </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>liste_pe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDeriv__Comm__Group.html">Deriv_Comm_Group</a> &amp;&#160;</td>
          <td class="paramname"><em>group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>force_Comm_Group_NoParallel</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creation d'un nouveau groupe de processeurs<br/>
(utilisation possible n'importe ou dans le code)<br/>
Il faut l'appeler simultanement sur tous les processeurs du groupe <a class="el" href="classPE__Groups.html#ae6ca0277a58f2ab34ebfb3216578fa75" title="renvoie une reference au groupe de processeurs actif courant">current_group()</a><br/>
avec le meme tableau liste_pe. liste_pe est la liste des rangs dans le groupe<br/>
courant des processeurs que l'on veut inclure dans le groupe. Le premier de la<br/>
liste sera le maitre du groupe. La liste ne doit pas comporter de doublon et<br/>
doit contenir au moins un processeur.<br/>
La methode type et initialize l'objet group.<br/>
Il faut ensuite appeler <a class="el" href="classPE__Groups.html#a1df95ab36f35005ab28fd5c134794772" title="Si le processeur local appartient au groupe, le groupe courant pour ce processeur devient &quot;group&quot; e...">enter_group()</a> et <a class="el" href="classPE__Groups.html#af49cb26695386d2e0de890aadc39057e" title="Retourne dans le groupe ou l&#39;on etait avant le dernier enter_group() reussi (dont le resultat a ete 1...">exit_group()</a> (autant de fois qu'on veut) </p>

<p>Definition at line <a class="el" href="PE__Groups_8cpp_source.html#l00051">51</a> of file <a class="el" href="PE__Groups_8cpp_source.html">PE_Groups.cpp</a>.</p>

<p>References <a class="el" href="PE__Groups_8cpp_source.html#l00030">groups</a>, <a class="el" href="Comm__Group_8cpp_source.html#l00089">Comm_Group::init_group()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00342">ArrOfInt::size_array()</a>, and <a class="el" href="Source__Generique__Face__PolyMAC_8cpp_source.html#l00045">valeur()</a>.</p>

<p>Referenced by <a class="el" href="Execute__parallel_8cpp_source.html#l00059">Execute_parallel::interpreter()</a>, <a class="el" href="LataToMED_8cpp_source.html#l00191">latatoother::interpreter()</a>, and <a class="el" href="Debog_8cpp_source.html#l00361">Debog_Pb::read_geometry_data()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">if</span> (liste_pe.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>()==1 &amp;&amp; force_Comm_Group_NoParallel)
    {
<span class="comment">// On cree un groupe non parallele si c&#39;est possible et si c&#39;est impose</span>
      group.<a class="code" href="classDeriv__.html#ad1d33400ed15b6ff96579ed82d9e2719" title="Essaie de creer une instance du type &quot;type&quot;. si type n&#39;est pas un type ou type n&#39;est pas instanciab...">typer</a>(<span class="stringliteral">&quot;Comm_Group_NoParallel&quot;</span>);
    }
  <span class="keywordflow">else</span>
    {
<span class="comment">// On cree un groupe du meme type que le groupe_TRUST</span>
      group.<a class="code" href="classDeriv__.html#ad1d33400ed15b6ff96579ed82d9e2719" title="Essaie de creer une instance du type &quot;type&quot;. si type n&#39;est pas un type ou type n&#39;est pas instanciab...">typer</a>(<a class="code" href="PE__Groups_8cpp.html#a2d9739a5d1332e53b0013698914d796c">groups</a>[0].<a class="code" href="Source__Generique__Face__PolyMAC_8cpp.html#a7d7b5d77a3caa1af70f5e1c9108de5a1">valeur</a>().que_suis_je());
    }
  group.<a class="code" href="classDeriv__Comm__Group.html#a5e72ace93b65cd47119ade73f8ee91dc">valeur</a>().<a class="code" href="classComm__Group.html#ad3853172658b85b4737846cc8ac72507" title="Cette fonction doit etre appelee simultanement par tous les PEs du groupe current_group avec les meme...">init_group</a>(liste_pe);
}
</pre></div>
</div>
</div>
<a class="anchor" id="ae6ca0277a58f2ab34ebfb3216578fa75"></a><!-- doxytag: member="PE_Groups::current_group" ref="ae6ca0277a58f2ab34ebfb3216578fa75" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classComm__Group.html">Comm_Group</a> &amp; PE_Groups::current_group </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>renvoie une reference au groupe de processeurs actif courant </p>

<p>Definition at line <a class="el" href="PE__Groups_8h_source.html#l00054">54</a> of file <a class="el" href="PE__Groups_8h_source.html">PE_Groups.h</a>.</p>

<p>References <a class="el" href="PE__Groups_8cpp_source.html#l00035">check_current_group()</a>, and <a class="el" href="PE__Groups_8h_source.html#l00050">current_group_</a>.</p>

<p>Referenced by <a class="el" href="Process_8cpp_source.html#l00127">Process::barrier()</a>, <a class="el" href="Schema__Comm_8cpp_source.html#l00166">Schema_Comm::begin_comm()</a>, <a class="el" href="Solv__Petsc_8cpp_source.html#l00087">Solv_Petsc::create_solver()</a>, <a class="el" href="Schema__Comm_8cpp_source.html#l00311">Schema_Comm::echange_messages()</a>, <a class="el" href="Schema__Comm_8cpp_source.html#l00261">Schema_Comm::echange_taille()</a>, <a class="el" href="Schema__Comm_8cpp_source.html#l00430">Schema_Comm::end_comm()</a>, <a class="el" href="PE__Groups_8cpp_source.html#l00097">enter_group()</a>, <a class="el" href="communications_8cpp_source.html#l00473">envoyer_all_to_all()</a>, <a class="el" href="communications_8cpp_source.html#l00427">envoyer_all_to_all_()</a>, <a class="el" href="communications_8cpp_source.html#l00133">envoyer_array_()</a>, <a class="el" href="communications_8cpp_source.html#l00330">envoyer_broadcast_()</a>, <a class="el" href="communications_8cpp_source.html#l00349">envoyer_broadcast_buffered_()</a>, <a class="el" href="communications_8cpp_source.html#l00074">envoyer_buffered_()</a>, <a class="el" href="Schema__Comm__Vecteurs_8cpp_source.html#l00206">Schema_Comm_Vecteurs::exchange()</a>, <a class="el" href="PE__Groups_8cpp_source.html#l00131">exit_group()</a>, <a class="el" href="mon__main_8cpp_source.html#l00241">mon_main::finalize()</a>, <a class="el" href="Comm__Group__MPI_8cpp_source.html#l00641">Comm_Group_MPI::init_group()</a>, <a class="el" href="Comm__Group_8cpp_source.html#l00089">Comm_Group::init_group()</a>, <a class="el" href="communications_8cpp_source.html#l00733">is_parallel_object()</a>, <a class="el" href="Process_8cpp_source.html#l00095">Process::je_suis_maitre()</a>, <a class="el" href="Process_8cpp_source.html#l00117">Process::me()</a>, <a class="el" href="Process_8cpp_source.html#l00199">Process::mp_and()</a>, <a class="el" href="communications_8cpp_source.html#l00629">mp_collective_op()</a>, <a class="el" href="Process_8cpp_source.html#l00156">Process::mp_max()</a>, <a class="el" href="communications_8cpp_source.html#l00588">mp_max()</a>, <a class="el" href="Process_8cpp_source.html#l00167">Process::mp_min()</a>, <a class="el" href="communications_8cpp_source.html#l00598">mp_min()</a>, <a class="el" href="Process_8cpp_source.html#l00178">Process::mp_sum()</a>, <a class="el" href="communications_8cpp_source.html#l00608">mppartial_sum()</a>, <a class="el" href="communications_8cpp_source.html#l00617">mpsum_multiple()</a>, <a class="el" href="Process_8cpp_source.html#l00109">Process::nproc()</a>, <a class="el" href="Schema__Comm_8cpp_source.html#l00103">Schema_Comm::operator=()</a>, <a class="el" href="EcrFicPartageMPIIO_8cpp_source.html#l00079">EcrFicPartageMPIIO::ouvrir()</a>, <a class="el" href="communications_8cpp_source.html#l00170">recevoir_array_()</a>, <a class="el" href="communications_8cpp_source.html#l00109">recevoir_buffered_()</a>, <a class="el" href="communications_8cpp_source.html#l00561">reverse_send_recv_pe_list()</a>, <a class="el" href="Schema__Comm_8cpp_source.html#l00063">Schema_Comm::Schema_Comm()</a>, <a class="el" href="Schema__Comm_8cpp_source.html#l00122">Schema_Comm::set_group()</a>, <a class="el" href="Schema__Comm_8cpp_source.html#l00146">Schema_Comm::set_send_recv_pe_list()</a>, and <a class="el" href="EcrFicPartage_8cpp_source.html#l00216">EcrFicPartage::syncfile()</a>.</p>
<div class="fragment"><pre class="fragment">{
  assert(<a class="code" href="classPE__Groups.html#acbc7b643af10631009f4d96f6564e41d">check_current_group</a>());
  <span class="keywordflow">return</span> *<a class="code" href="classPE__Groups.html#a9d07be726ca7ac3b026415210437067d">current_group_</a>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a1df95ab36f35005ab28fd5c134794772"></a><!-- doxytag: member="PE_Groups::enter_group" ref="a1df95ab36f35005ab28fd5c134794772" args="(const Comm_Group &amp;group)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PE_Groups::enter_group </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classComm__Group.html">Comm_Group</a> &amp;&#160;</td>
          <td class="paramname"><em>group</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Si le processeur local appartient au groupe, le groupe courant<br/>
pour ce processeur devient "group" et on renvoie 1, sinon on renvoie 0.<br/>
Une reference au groupe actuel est sauvegardee et sera restauree quand on<br/>
appellera <a class="el" href="classPE__Groups.html#af49cb26695386d2e0de890aadc39057e" title="Retourne dans le groupe ou l&#39;on etait avant le dernier enter_group() reussi (dont le resultat a ete 1...">exit_group()</a>.<br/>
Cette methode doit etre appelee simultanement sur tous les processeurs<br/>
du groupe "group".<br/>
Attention: a chaque <a class="el" href="classPE__Groups.html#a1df95ab36f35005ab28fd5c134794772" title="Si le processeur local appartient au groupe, le groupe courant pour ce processeur devient &quot;group&quot; e...">enter_group()</a> doit correspondre un <a class="el" href="classPE__Groups.html#af49cb26695386d2e0de890aadc39057e" title="Retourne dans le groupe ou l&#39;on etait avant le dernier enter_group() reussi (dont le resultat a ete 1...">exit_group()</a>.<br/>
Cependant, il n'est pas interdit d'entrer plusieurs fois de suite dans le<br/>
meme groupe, ni d'entrer dans un groupe plus grand que le groupe actuel.<br/>
Exemple : group1 et group2 forment une partition du <a class="el" href="classPE__Groups.html#af38ed6631e572dc5117361b3f26a47a3" title="Renvoie une reference au groupe de tous les processeurs TRUST.">groupe_TRUST()</a><br/>
int sync_point(int x)<br/>
{<br/>
<a class="el" href="classPE__Groups.html#a1df95ab36f35005ab28fd5c134794772" title="Si le processeur local appartient au groupe, le groupe courant pour ce processeur devient &quot;group&quot; e...">PE_Groups::enter_group</a>(<a class="el" href="classPE__Groups.html#af38ed6631e572dc5117361b3f26a47a3" title="Renvoie une reference au groupe de tous les processeurs TRUST.">groupe_TRUST()</a>);<br/>
int i = mp_sum(x);<br/>
<a class="el" href="classPE__Groups.html#af49cb26695386d2e0de890aadc39057e" title="Retourne dans le groupe ou l&#39;on etait avant le dernier enter_group() reussi (dont le resultat a ete 1...">PE_Groups::exit_group()</a>;<br/>
return i;<br/>
}<br/>
if (PE_Groups::enter_group(group1)) {<br/>
s1 = mp_sum(x); // Somme sur le groupe 2<br/>
// <a class="el" href="classPoint.html" title="Classe Point Cette classe represente l&#39;element geometrique segment. Un Point a 1 face et 1 sommets...">Point</a> de synchro avec l'autre groupe:<br/>
s_all = sync_point(x);<br/>
} else if (PE_Groups::enter_group(group2)) {<br/>
s2 = mp_sum(x);<br/>
// <a class="el" href="classPoint.html" title="Classe Point Cette classe represente l&#39;element geometrique segment. Un Point a 1 face et 1 sommets...">Point</a> de synchro avec l'autre groupe:<br/>
s_all = sync_point(x);<br/>
} else {<br/>
Cerr &lt;&lt; "Error: processor " &lt;&lt; me() &lt;&lt; " is not within a subgroup.";<br/>
exit();<br/>
}<br/>
<a class="el" href="classPE__Groups.html#af49cb26695386d2e0de890aadc39057e" title="Retourne dans le groupe ou l&#39;on etait avant le dernier enter_group() reussi (dont le resultat a ete 1...">PE_Groups::exit_group()</a>; // Sort du sous-groupe. </p>

<p>Definition at line <a class="el" href="PE__Groups_8cpp_source.html#l00097">97</a> of file <a class="el" href="PE__Groups_8cpp_source.html">PE_Groups.cpp</a>.</p>

<p>References <a class="el" href="classComm__Group.html#ac20236e71fc50066d225761ba1349c69">Comm_Group::barrier()</a>, <a class="el" href="EntreeSortie_8h_source.html#l00032">Cerr</a>, <a class="el" href="Comm__Group_8h_source.html#l00143">Comm_Group::check_enabled()</a>, <a class="el" href="PE__Groups_8h_source.html#l00054">current_group()</a>, <a class="el" href="PE__Groups_8h_source.html#l00050">current_group_</a>, <a class="el" href="Process_8cpp_source.html#l00223">Process::exit()</a>, <a class="el" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>, <a class="el" href="PE__Groups_8cpp_source.html#l00030">groups</a>, <a class="el" href="PE__Groups_8cpp_source.html#l00032">max_ngroups</a>, <a class="el" href="PE__Groups_8cpp_source.html#l00031">ngroups</a>, and <a class="el" href="PE__Groups_8cpp_source.html#l00149">rank_translate()</a>.</p>

<p>Referenced by <a class="el" href="Execute__parallel_8cpp_source.html#l00059">Execute_parallel::interpreter()</a>, <a class="el" href="LataToMED_8cpp_source.html#l00191">latatoother::interpreter()</a>, and <a class="el" href="Debog_8cpp_source.html#l00361">Debog_Pb::read_geometry_data()</a>.</p>
<div class="fragment"><pre class="fragment">{
  assert(&amp;group != &amp;<a class="code" href="classPE__Groups.html#ae6ca0277a58f2ab34ebfb3216578fa75" title="renvoie une reference au groupe de processeurs actif courant">current_group</a>());
  <span class="keywordflow">if</span> (<a class="code" href="PE__Groups_8cpp.html#ae5dcb44242d12656bf1a5945b165aebc">ngroups</a> &gt;= <a class="code" href="PE__Groups_8cpp.html#a3ae4574832316cee14227e61468689c7">max_ngroups</a>-1)
    {
      <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Comm_Group::enter_group : fatal, too many groups&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
      <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">Process::exit</a>();
    }
  <span class="keywordtype">int</span> my_rank_in_group = <a class="code" href="classPE__Groups.html#aed0079543355fa583812b12a49056707" title="Calcule le rank dans le groupe courant du processeur de rang &quot;rank&quot; dans le &quot;group&quot;. Il faut que 0 &lt;= rank &lt; group.nproc() Si le processeur en question n&#39;appartient pas au groupe courant, renvoie -1.">rank_translate</a>(<a class="code" href="classPE__Groups.html#ae6ca0277a58f2ab34ebfb3216578fa75" title="renvoie une reference au groupe de processeurs actif courant">current_group</a>().rank(), <a class="code" href="classPE__Groups.html#ae6ca0277a58f2ab34ebfb3216578fa75" title="renvoie une reference au groupe de processeurs actif courant">current_group</a>(), group);
  <span class="keywordflow">if</span> (my_rank_in_group &gt;= 0)
    {
<span class="comment">// Sauvegarde du pointeur sur le groupe actuel et changement du</span>
<span class="comment">// current_group() :</span>
      <a class="code" href="PE__Groups_8cpp.html#a2d9739a5d1332e53b0013698914d796c">groups</a>[<a class="code" href="PE__Groups_8cpp.html#ae5dcb44242d12656bf1a5945b165aebc">ngroups</a>] = group;
      <a class="code" href="classPE__Groups.html#a9d07be726ca7ac3b026415210437067d">current_group_</a> = &amp;group;
      <a class="code" href="PE__Groups_8cpp.html#ae5dcb44242d12656bf1a5945b165aebc">ngroups</a>++;
<span class="comment">// Attention, on a change de current_group() !</span>

<span class="comment">// On verifie que tous les processeurs du nouveau groupe sont la:</span>
      <span class="keywordflow">if</span> (<a class="code" href="classComm__Group.html#a0f230fe65c9f52fd2a168a1ea70e7b15">Comm_Group::check_enabled</a>())
        <a class="code" href="classPE__Groups.html#ae6ca0277a58f2ab34ebfb3216578fa75" title="renvoie une reference au groupe de processeurs actif courant">current_group</a>().<a class="code" href="classComm__Group.html#ac20236e71fc50066d225761ba1349c69">barrier</a>(0);

      <span class="keywordflow">return</span> 1;
    }
  <span class="keywordflow">else</span>
    {
      <span class="keywordflow">return</span> 0;
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="af49cb26695386d2e0de890aadc39057e"></a><!-- doxytag: member="PE_Groups::exit_group" ref="af49cb26695386d2e0de890aadc39057e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PE_Groups::exit_group </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retourne dans le groupe ou l'on etait avant le dernier<br/>
<a class="el" href="classPE__Groups.html#a1df95ab36f35005ab28fd5c134794772" title="Si le processeur local appartient au groupe, le groupe courant pour ce processeur devient &quot;group&quot; e...">enter_group()</a> reussi (dont le resultat a ete 1).<br/>
Cette methode doit etre appelee simultanement sur tous les processeurs<br/>
du <a class="el" href="classPE__Groups.html#ae6ca0277a58f2ab34ebfb3216578fa75" title="renvoie une reference au groupe de processeurs actif courant">current_group()</a> actif juste avant <a class="el" href="classPE__Groups.html#af49cb26695386d2e0de890aadc39057e" title="Retourne dans le groupe ou l&#39;on etait avant le dernier enter_group() reussi (dont le resultat a ete 1...">exit_group()</a>). </p>

<p>Definition at line <a class="el" href="PE__Groups_8cpp_source.html#l00131">131</a> of file <a class="el" href="PE__Groups_8cpp_source.html">PE_Groups.cpp</a>.</p>

<p>References <a class="el" href="classComm__Group.html#ac20236e71fc50066d225761ba1349c69">Comm_Group::barrier()</a>, <a class="el" href="EntreeSortie_8h_source.html#l00032">Cerr</a>, <a class="el" href="Comm__Group_8h_source.html#l00143">Comm_Group::check_enabled()</a>, <a class="el" href="PE__Groups_8h_source.html#l00054">current_group()</a>, <a class="el" href="PE__Groups_8h_source.html#l00050">current_group_</a>, <a class="el" href="Process_8cpp_source.html#l00223">Process::exit()</a>, <a class="el" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>, <a class="el" href="PE__Groups_8cpp_source.html#l00030">groups</a>, <a class="el" href="PE__Groups_8cpp_source.html#l00031">ngroups</a>, and <a class="el" href="Ref__Comm__Group_8h_source.html#l00029">Ref_Comm_Group::valeur()</a>.</p>

<p>Referenced by <a class="el" href="Execute__parallel_8cpp_source.html#l00059">Execute_parallel::interpreter()</a>, <a class="el" href="LataToMED_8cpp_source.html#l00191">latatoother::interpreter()</a>, and <a class="el" href="Debog_8cpp_source.html#l00361">Debog_Pb::read_geometry_data()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">if</span> (<a class="code" href="classComm__Group.html#a0f230fe65c9f52fd2a168a1ea70e7b15">Comm_Group::check_enabled</a>())
    <a class="code" href="classPE__Groups.html#ae6ca0277a58f2ab34ebfb3216578fa75" title="renvoie une reference au groupe de processeurs actif courant">current_group</a>().<a class="code" href="classComm__Group.html#ac20236e71fc50066d225761ba1349c69">barrier</a>(0);

  <span class="keywordflow">if</span> (<a class="code" href="PE__Groups_8cpp.html#ae5dcb44242d12656bf1a5945b165aebc">ngroups</a> &lt;= 1)
    {
      <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Comm_Group::exit_group() error : trying to exit from TRUST main group.&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
      <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">Process::exit</a>();
    }
  <a class="code" href="PE__Groups_8cpp.html#ae5dcb44242d12656bf1a5945b165aebc">ngroups</a>--;
  <a class="code" href="classPE__Groups.html#a9d07be726ca7ac3b026415210437067d">current_group_</a> = &amp;(<a class="code" href="PE__Groups_8cpp.html#a2d9739a5d1332e53b0013698914d796c">groups</a>[<a class="code" href="PE__Groups_8cpp.html#ae5dcb44242d12656bf1a5945b165aebc">ngroups</a>-1].<a class="code" href="classRef__Comm__Group.html#a46f3361cb566b4a386f75f7f9570fe9a">valeur</a>());
}
</pre></div>
</div>
</div>
<a class="anchor" id="a711ec244f2a93cc54863f63053a5bdd8"></a><!-- doxytag: member="PE_Groups::finalize" ref="a711ec244f2a93cc54863f63053a5bdd8" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PE_Groups::finalize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Methode a appeler en fin d'execution, une fois qu'on est revenu<br/>
dans le <a class="el" href="classPE__Groups.html#af38ed6631e572dc5117361b3f26a47a3" title="Renvoie une reference au groupe de tous les processeurs TRUST.">groupe_TRUST()</a> et juste avant de detruire de <a class="el" href="classComm__Group.html" title=": Cette classe decrit un groupe de processeurs sur lesquels une portion de code s&#39;execute simultaneme...">Comm_Group</a><br/>
principal. </p>

<p>Definition at line <a class="el" href="PE__Groups_8cpp_source.html#l00180">180</a> of file <a class="el" href="PE__Groups_8cpp_source.html">PE_Groups.cpp</a>.</p>

<p>References <a class="el" href="PE__Groups_8h_source.html#l00050">current_group_</a>, <a class="el" href="PE__Groups_8cpp_source.html#l00030">groups</a>, <a class="el" href="PE__Groups_8cpp_source.html#l00031">ngroups</a>, and <a class="el" href="Ref___8cpp_source.html#l00072">Ref_::reset()</a>.</p>

<p>Referenced by <a class="el" href="Process_8cpp_source.html#l00228">Process::exit()</a>.</p>
<div class="fragment"><pre class="fragment">{
  assert(<a class="code" href="PE__Groups_8cpp.html#ae5dcb44242d12656bf1a5945b165aebc">ngroups</a> == 1);
  <a class="code" href="PE__Groups_8cpp.html#a2d9739a5d1332e53b0013698914d796c">groups</a>[0].<a class="code" href="classRef__.html#aefc8130f02e22c692853dd435cbd1c18" title="Annule la ref.">reset</a>();
  <a class="code" href="PE__Groups_8cpp.html#ae5dcb44242d12656bf1a5945b165aebc">ngroups</a> = 0;
  <a class="code" href="classPE__Groups.html#a9d07be726ca7ac3b026415210437067d">current_group_</a> = 0;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a6fe714bb78ca65d4731c8b95db492172"></a><!-- doxytag: member="PE_Groups::get_nb_groups" ref="a6fe714bb78ca65d4731c8b95db492172" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int &amp; PE_Groups::get_nb_groups </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="PE__Groups_8cpp_source.html#l00187">187</a> of file <a class="el" href="PE__Groups_8cpp_source.html">PE_Groups.cpp</a>.</p>

<p>References <a class="el" href="PE__Groups_8cpp_source.html#l00031">ngroups</a>.</p>

<p>Referenced by <a class="el" href="Solv__Petsc_8cpp_source.html#l00087">Solv_Petsc::create_solver()</a>, and <a class="el" href="Process_8cpp_source.html#l00462">get_Cerr()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">return</span> <a class="code" href="PE__Groups_8cpp.html#ae5dcb44242d12656bf1a5945b165aebc">ngroups</a> ;
}
</pre></div>
</div>
</div>
<a class="anchor" id="af38ed6631e572dc5117361b3f26a47a3"></a><!-- doxytag: member="PE_Groups::groupe_TRUST" ref="af38ed6631e572dc5117361b3f26a47a3" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classComm__Group.html">Comm_Group</a> &amp; PE_Groups::groupe_TRUST </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Renvoie une reference au groupe de tous les processeurs TRUST. </p>

<p><p>&lt; Initialized ? </p>
</p>

<p>Definition at line <a class="el" href="PE__Groups_8cpp_source.html#l00159">159</a> of file <a class="el" href="PE__Groups_8cpp_source.html">PE_Groups.cpp</a>.</p>

<p>References <a class="el" href="PE__Groups_8cpp_source.html#l00030">groups</a>, <a class="el" href="PE__Groups_8cpp_source.html#l00031">ngroups</a>, and <a class="el" href="Ref__Comm__Group_8h_source.html#l00029">Ref_Comm_Group::valeur()</a>.</p>

<p>Referenced by <a class="el" href="Convert__ICoCoTrioField_8cpp_source.html#l00139">build_medfield()</a>, <a class="el" href="Process_8cpp_source.html#l00228">Process::exit()</a>, <a class="el" href="Schema__Comm__Vecteurs_8cpp_source.html#l00040">Schema_Comm_Vecteurs_Static_Data::init()</a>, <a class="el" href="Comm__Group_8cpp_source.html#l00089">Comm_Group::init_group()</a>, <a class="el" href="Postraitement__lata_8cpp_source.html#l00542">Postraitement_lata::postraiter()</a>, and <a class="el" href="Postraitement__lata_8cpp_source.html#l00409">Postraitement_lata::postraiter_liste_champs()</a>.</p>
<div class="fragment"><pre class="fragment">{
  assert(<a class="code" href="PE__Groups_8cpp.html#ae5dcb44242d12656bf1a5945b165aebc">ngroups</a> &gt; 0); <span class="comment">//!&lt; Initialized ?</span>
<span class="comment"></span>  <span class="keywordflow">return</span> <a class="code" href="PE__Groups_8cpp.html#a2d9739a5d1332e53b0013698914d796c">groups</a>[0].<a class="code" href="classRef__Comm__Group.html#a46f3361cb566b4a386f75f7f9570fe9a">valeur</a>();
}
</pre></div>
</div>
</div>
<a class="anchor" id="a96163527a12b74c0caf330ac7349d634"></a><!-- doxytag: member="PE_Groups::initialize" ref="a96163527a12b74c0caf330ac7349d634" args="(const Comm_Group &amp;groupe_trio_u)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PE_Groups::initialize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classComm__Group.html">Comm_Group</a> &amp;&#160;</td>
          <td class="paramname"><em>groupe_trio_u</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Methode a appeler au debut de l'execution (<a class="el" href="MAIN_8cpp.html">MAIN.cpp</a>)<br/>
Elle initialise <a class="el" href="classPE__Groups.html#ae6ca0277a58f2ab34ebfb3216578fa75" title="renvoie une reference au groupe de processeurs actif courant">current_group()</a> avec groupe_trio_u. </p>

<p>Definition at line <a class="el" href="PE__Groups_8cpp_source.html#l00168">168</a> of file <a class="el" href="PE__Groups_8cpp_source.html">PE_Groups.cpp</a>.</p>

<p>References <a class="el" href="PE__Groups_8h_source.html#l00050">current_group_</a>, <a class="el" href="PE__Groups_8cpp_source.html#l00030">groups</a>, and <a class="el" href="PE__Groups_8cpp_source.html#l00031">ngroups</a>.</p>

<p>Referenced by <a class="el" href="mon__main_8cpp_source.html#l00178">mon_main::init_parallel()</a>.</p>
<div class="fragment"><pre class="fragment">{
  assert(<a class="code" href="PE__Groups_8cpp.html#ae5dcb44242d12656bf1a5945b165aebc">ngroups</a> == 0);
  <a class="code" href="PE__Groups_8cpp.html#ae5dcb44242d12656bf1a5945b165aebc">ngroups</a> = 1;
  <a class="code" href="PE__Groups_8cpp.html#a2d9739a5d1332e53b0013698914d796c">groups</a>[0] = groupe_trio_u;
  <a class="code" href="classPE__Groups.html#a9d07be726ca7ac3b026415210437067d">current_group_</a> = &amp;groupe_trio_u;
}
</pre></div>
</div>
</div>
<a class="anchor" id="aed0079543355fa583812b12a49056707"></a><!-- doxytag: member="PE_Groups::rank_translate" ref="aed0079543355fa583812b12a49056707" args="(int rank, const Comm_Group &amp;group, const Comm_Group &amp;dest_group=current_group())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PE_Groups::rank_translate </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classComm__Group.html">Comm_Group</a> &amp;&#160;</td>
          <td class="paramname"><em>group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classComm__Group.html">Comm_Group</a> &amp;&#160;</td>
          <td class="paramname"><em>dest_group</em> = <code>current_group()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calcule le rank dans le groupe courant du processeur de rang "rank" dans le "group".<br/>
Il faut que 0 &lt;= rank &lt; group.nproc()<br/>
Si le processeur en question n'appartient pas au groupe courant, renvoie -1. </p>

<p>Definition at line <a class="el" href="PE__Groups_8cpp_source.html#l00149">149</a> of file <a class="el" href="PE__Groups_8cpp_source.html">PE_Groups.cpp</a>.</p>

<p>References <a class="el" href="Comm__Group_8h_source.html#l00125">Comm_Group::local_ranks_</a>, and <a class="el" href="Comm__Group_8h_source.html#l00128">Comm_Group::world_ranks_</a>.</p>

<p>Referenced by <a class="el" href="PE__Groups_8cpp_source.html#l00097">enter_group()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">const</span> <span class="keywordtype">int</span> world_rank = group.<a class="code" href="classComm__Group.html#a11c755475a554801c9f99d98120b710a">world_ranks_</a>[rank];
  <span class="keyword">const</span> <span class="keywordtype">int</span> local_rank = dest_group.<a class="code" href="classComm__Group.html#ac76484cbcd0cdac9f3448e33aeccdc4d">local_ranks_</a>[world_rank];
  <span class="keywordflow">return</span> local_rank;
}
</pre></div>
</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="a9d07be726ca7ac3b026415210437067d"></a><!-- doxytag: member="PE_Groups::current_group_" ref="a9d07be726ca7ac3b026415210437067d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classComm__Group.html">Comm_Group</a> * <a class="el" href="classPE__Groups.html#a9d07be726ca7ac3b026415210437067d">PE_Groups::current_group_</a> = 0<code> [static, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="PE__Groups_8h_source.html#l00050">50</a> of file <a class="el" href="PE__Groups_8h_source.html">PE_Groups.h</a>.</p>

<p>Referenced by <a class="el" href="PE__Groups_8h_source.html#l00054">current_group()</a>, <a class="el" href="PE__Groups_8cpp_source.html#l00097">enter_group()</a>, <a class="el" href="PE__Groups_8cpp_source.html#l00131">exit_group()</a>, <a class="el" href="PE__Groups_8cpp_source.html#l00180">finalize()</a>, and <a class="el" href="PE__Groups_8cpp_source.html#l00168">initialize()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/Kernel/Utilitaires/<a class="el" href="PE__Groups_8h_source.html">PE_Groups.h</a></li>
<li>src/Kernel/Utilitaires/<a class="el" href="PE__Groups_8cpp_source.html">PE_Groups.cpp</a></li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Tue Dec 14 2021 19:37:34 for TRUST by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
