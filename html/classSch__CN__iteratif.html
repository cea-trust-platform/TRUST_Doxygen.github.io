<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>TRUST: Sch_CN_iteratif Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">TRUST&#160;<span id="projectnumber">1.8.4</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-types">Protected Types</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a>  </div>
  <div class="headertitle">
<div class="title">Sch_CN_iteratif Class Reference</div>  </div>
</div>
<div class="contents">
<!-- doxytag: class="Sch_CN_iteratif" --><!-- doxytag: inherits="Schema_Temps_base" -->
<p>classe <a class="el" href="classSch__CN__iteratif.html" title="classe Sch_CN_iteratif Schema en temps alternant un demi-pas de temps d&#39;Euler implicite et un demi-pa...">Sch_CN_iteratif</a><br/>
Schema en temps alternant un demi-pas de temps d'Euler implicite et un demi-pas de temps de LeapFrog.<br/>
La resolution implicite est iterative (point fixe).<br/>
Le pas de temps est calcule comme le produit du pas de temps de stabilite explicite par un facsec.<br/>
Le facsec est ajuste automatiquement pour que la resolution converge en un nombre d'iterations predefini.<br/>
Les caracteristiques de chaque iteration sont ecrites dans le fichier dt_CN.<br/>
La resolution est gouvernee par 4 parametres (valeurs par defauts entre parentheses) :<br/>
* seuil (1e-3) : le seuil de convergence. Plus il est bas, plus la resolution est precise.<br/>
* facsec_max (2) : la valeur du facsec que l'on ne veut pas depasser (eviter les instabilites et capter les phenomenes physiques)<br/>
* niter_min (2) : le nombre minimum d'iterations. En deca, on continue a iterer meme si on semble avoir atteint la convergence.<br/>
* niter_avg (3) : le nombre d'iterations que l'on souhaite faire pour arriver a convergence.<br/>
* niter_max (6) : le nombre d'iteration au-dela duquel on reessaye avec un facsec plus petit.<br/>
Conseil pour le choix des parametres d'ajustement du facsec :<br/>
* Choisir seuil en fonction de la precision desiree.<br/>
* Choisir niter_min : 2 garantit un schema d'ordre 2 en temps.<br/>
* Si on cherche un stationnaire, choisir seuil_statio &gt;= seuil.<br/>
* Choisir facsec_max en fonction des phenomenes physiques a capter.<br/>
* Commencer par tester avec une grande valeur de niter_avg. Observer le comportement du nombre d'iterations.<br/>
Il bute sur une valeur maximum avant de retomber.<br/>
* Choisir niter_avg aux 2/3 de cette valeur maximum, et niter_max aux 4/3 ou au double environ.  
 <a href="classSch__CN__iteratif.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="Sch__CN__iteratif_8h_source.html">Sch_CN_iteratif.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Sch_CN_iteratif:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classSch__CN__iteratif.png" usemap="#Sch_CN_iteratif_map" alt=""/>
  <map id="Sch_CN_iteratif_map" name="Sch_CN_iteratif_map">
<area href="classSchema__Temps__base.html" title="classe Schema_Temps_base" alt="Schema_Temps_base" shape="rect" coords="0,112,134,136"/>
<area href="classObjet__U.html" title="classe Objet_U Cette classe est la classe de base des Objets de TRUST Dans les classes derivees de Ob..." alt="Objet_U" shape="rect" coords="0,56,134,80"/>
<area href="classProcess.html" title="Classe de base de TRUST (notamment Objet_U). Elle fournit quelques services de base accessibles de pa..." alt="Process" shape="rect" coords="0,0,134,24"/>
<area href="classSch__CN__EX__iteratif.html" title="classe Sch_CN_EX_iteratif Ce schema en temps implemente quelques astuces en plus de Sch_CN_iteratif p..." alt="Sch_CN_EX_iteratif" shape="rect" coords="0,224,134,248"/>
</map>
 </div></div>

<p><a href="classSch__CN__iteratif-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSch__CN__iteratif.html#a693f89d0f86fedadca604729a77dec9d">Sch_CN_iteratif</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSch__CN__iteratif.html#a909b33ca07743c44df11c4e43ad30a05">~Sch_CN_iteratif</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSch__CN__iteratif.html#ad34d2d173b546f6f239b8f3a3faedf39">taille_memoire</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSch__CN__iteratif.html#a295e3906e599d0168342d8bb9a8243e6">duplique</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classType__info.html">Type_info</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSch__CN__iteratif.html#ad8c9b28358ada18f0bc17f54b52b4a71">get_info</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Donne des informations sur le type de l'Objet_U.  <a href="#ad8c9b28358ada18f0bc17f54b52b4a71"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSch__CN__iteratif.html#af4fc4f7fe8f53992f17065eacf86d2bd">nb_valeurs_temporelles</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Renvoie le nombre de valeurs temporelles a conserver.<br/>
Ici : n, n+1/2 et n+1, donc 3.  <a href="#af4fc4f7fe8f53992f17065eacf86d2bd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSch__CN__iteratif.html#a71f38a24b942bc119ea7850505cab649">nb_valeurs_futures</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Renvoie le nombre de valeurs temporelles futures.<br/>
Ici : n+1/2 et n+1 donc 2.  <a href="#a71f38a24b942bc119ea7850505cab649"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSch__CN__iteratif.html#ac28599b004c8f4294d97ec104eaabe42">temps_futur</a> (int i) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Renvoie le le temps a la i-eme valeur future.  <a href="#ac28599b004c8f4294d97ec104eaabe42"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSch__CN__iteratif.html#a25915a5d6b52705f709025aca71f489d">temps_defaut</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Renvoie le temps que doivent utiliser les champs a<br/>
l'appel de valeurs()<br/>
Ici : t(n+1/2)  <a href="#a25915a5d6b52705f709025aca71f489d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSch__CN__iteratif.html#aa8ef3d17ee10c76043e3738b0ca31c1e">initTimeStep</a> (double dt)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSch__CN__iteratif.html#a99b8ea6d0194f9a4f6b34472dcdb841f">iterateTimeStep</a> (bool &amp;converged)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the U(n+1) unknown for each equation (if solved) of the problem with the selected time scheme.  <a href="#a99b8ea6d0194f9a4f6b34472dcdb841f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSch__CN__iteratif.html#abfd314442a69f22406b0645e71849ff9">faire_un_pas_de_temps_eqn_base</a> (<a class="el" href="classEquation__base.html">Equation_base</a> &amp;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSch__CN__iteratif.html#a6d94ef995fc9c970c5462deff5d3cef8">completer</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSch__CN__iteratif.html#a15f385781f069e7dc343bef216084f5b">set_param</a> (<a class="el" href="classParam.html">Param</a> &amp;titi)</td></tr>
<tr><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classObjet__U.html">Objet_U</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSch__CN__iteratif.html#a6affcbee80525e6ce27df4d8274b0deb">cree_instance</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classType__info.html">Type_info</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSch__CN__iteratif.html#ada7e22678ea5d7311a63cedc65a14781">info</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Donne des informations sur le type de l'Objet_U.  <a href="#ada7e22678ea5d7311a63cedc65a14781"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSch__CN__iteratif.html">Sch_CN_iteratif</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSch__CN__iteratif.html#af4f2c2bbc60f7929232d44f4dcf73f85">self_cast</a> (<a class="el" href="classObjet__U.html">Objet_U</a> &amp;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classSch__CN__iteratif.html">Sch_CN_iteratif</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSch__CN__iteratif.html#ab52c843e6a5cf940daa7f5abaef0920c">self_cast</a> (const <a class="el" href="classObjet__U.html">Objet_U</a> &amp;)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">methode ajoutee pour caster en python  <a href="#ab52c843e6a5cf940daa7f5abaef0920c"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classType__info.html">Type_info</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSch__CN__iteratif.html#a4fb4b6044915a602bd98632bf07e5e67">info_obj</a></td></tr>
<tr><td colspan="2"><h2><a name="pro-types"></a>
Protected Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSch__CN__iteratif.html#a38c9cbfc3b5889e7abed6783aeace1c6">type_convergence</a> { <br/>
&#160;&#160;<a class="el" href="classSch__CN__iteratif.html#a38c9cbfc3b5889e7abed6783aeace1c6ae13cc0f35ce7a8939bf5f0eba9197533">DIVERGENCE</a>, 
<a class="el" href="classSch__CN__iteratif.html#a38c9cbfc3b5889e7abed6783aeace1c6ae286f9849cb30d69f60b17feea70cee6">NON_CONVERGENCE</a>, 
<a class="el" href="classSch__CN__iteratif.html#a38c9cbfc3b5889e7abed6783aeace1c6af38229d31137d128193200dddeb199c1">CONVERGENCE_LENTE</a>, 
<a class="el" href="classSch__CN__iteratif.html#a38c9cbfc3b5889e7abed6783aeace1c6ad1ae98000096423125c874be1694a3d1">CONVERGENCE_RAPIDE</a>, 
<br/>
&#160;&#160;<a class="el" href="classSch__CN__iteratif.html#a38c9cbfc3b5889e7abed6783aeace1c6add0e9382f85b678d333ad2d5ff54638d">CONVERGENCE_OK</a>
<br/>
 }</td></tr>
<tr><td colspan="2"><h2><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classSortie.html">Sortie</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSch__CN__iteratif.html#af196b2dec8898ba995eba8cf2ea37b64">printOn</a> (<a class="el" href="classSortie.html">Sortie</a> &amp;x) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Surcharge <a class="el" href="classObjet__U.html#a68f520bd9ba3e848370861d6610720b5" title="Ecriture de l&#39;objet sur un flot de sortie Methode a surcharger.">Objet_U::printOn</a>(<a class="el" href="classSortie.html" title="Classe de base des flux de sortie. Elle sait ecrire des types simples&lt;br&gt;(entiers, flottants) et des Ob...">Sortie</a>&amp;)<br/>
Imprime le schema en temps sur un flot de sortie.<br/>
!! Attention n'est pas symetrique de la lecture !!<br/>
On ecrit les differents parametres du schema en temps.  <a href="#af196b2dec8898ba995eba8cf2ea37b64"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classEntree.html">Entree</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSch__CN__iteratif.html#a368cc7bc7444d872827c52982c7a8b76">readOn</a> (<a class="el" href="classEntree.html">Entree</a> &amp;)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Lecture d'un schema en temps a partir d'un flot d'entree.<br/>
Le format de lecture attendu est le suivant:<br/>
{<br/>
[<a class="el" href="classMotcle.html" title="Une chaine de caractere (Nom) en majuscules.">Motcle</a> valeur_reelle]<br/>
}<br/>
Les mots clefs peuvent etre:<br/>
tinit, tmax, nb_pas_dt_max, dt_min, dt_max,<br/>
dt_sauv, dt_impr, facsec, seuil_statio,.  <a href="#a368cc7bc7444d872827c52982c7a8b76"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSch__CN__iteratif.html#a0986d7724a3324ac4b4a86f1ad449c51">convergence</a> (const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;u0, const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;up1, const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;delta, int p) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Indique si le calcul iteratif a converge.<br/>
Critere de convergence utilise :<br/>
|| u(n+1,p+1) - u(n+1,p) || &lt; seuil * || u(n+1/2,p+1) ||<br/>
C'est equivalent a<br/>
|| u(n+1,p) - u(n+1) || &lt; seuil * || (Id-(dt/2).(df/du))^-1 || * || u(n+1/2,p+1) ||<br/>
ou u(n+1) est la solution exacte en n+1,<br/>
df/du est le lagrangien de f(u), pris en u(n+1/2)<br/>
et les normes sont compatibles entre matrices et vecteurs (ici norme infinie).  <a href="#a0986d7724a3324ac4b4a86f1ad449c51"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSch__CN__iteratif.html#a5a4bd9e2782c8e8066b737d83feb09df">divergence</a> (const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;u0, const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;up1, const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;delta, int p) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Indique si le calcul iteratif a diverge.  <a href="#a5a4bd9e2782c8e8066b737d83feb09df"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSch__CN__iteratif.html#ac083ab5828482f83fa510827f052d0de">ajuster_facsec</a> (<a class="el" href="classSch__CN__iteratif.html#a38c9cbfc3b5889e7abed6783aeace1c6">type_convergence</a> cv)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSch__CN__iteratif.html#a02a2ed7ab40f5cc6a0118e3acaa1926e">iterateTimeStepOnEquation</a> (int i, bool &amp;converged)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calcule une iteration de la resolution sur l'equation i.<br/>
Calcule u(n+1/2,p+1)=u(n)+f(u(n+1/2,p))*dt/2<br/>
et u(n+1,p+1)=u(n)+f(u(n+1/2,p))*dt<br/>
ou f donne du/dt en fonction de u<br/>
Retourne true dans converged si ca ne bouge plus d'une iteration a l'autre, false sinon<br/>
Renvoie true si OK pour continuer a iterer, false sinon (diverge ou trop d'iterations)  <a href="#a02a2ed7ab40f5cc6a0118e3acaa1926e"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSch__CN__iteratif.html#ab1627c25875c72516ce79c044ea8c38e">seuil</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">To determine convergence.  <a href="#ab1627c25875c72516ce79c044ea8c38e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSch__CN__iteratif.html#a5afdda57e3a767717a0e2dac900f8490">niter_min</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimum number of iterations (before, continue to iterate)  <a href="#a5afdda57e3a767717a0e2dac900f8490"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSch__CN__iteratif.html#a4b93c13f52ae52886a176c7df396a2a8">niter_max</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of iterations (after, considered as not convergent)  <a href="#a4b93c13f52ae52886a176c7df396a2a8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSch__CN__iteratif.html#a9467b12b7d6a5f2c3b7eb48f3e0c176c">niter_avg</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Average number of iterations wanted (facsec adjusted to fit that number)  <a href="#a9467b12b7d6a5f2c3b7eb48f3e0c176c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSch__CN__iteratif.html#ae7e2aeaa5d411a5b2e746db7fc40581f">facsec_max</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum facsec (not to miss the physics)  <a href="#ae7e2aeaa5d411a5b2e746db7fc40581f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSch__CN__iteratif.html#a12e6e86233c59d24175c78441f0e7046">iteration</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of iterations done for the current time step.  <a href="#a12e6e86233c59d24175c78441f0e7046"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSch__CN__iteratif.html#ad7bc392b49ba97e340e165f4372f86a9">last_facsec</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">facsec at the beginning of time step resolution, to avoid changing facsec several times for the same time step.  <a href="#ad7bc392b49ba97e340e165f4372f86a9"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>classe <a class="el" href="classSch__CN__iteratif.html" title="classe Sch_CN_iteratif Schema en temps alternant un demi-pas de temps d&#39;Euler implicite et un demi-pa...">Sch_CN_iteratif</a><br/>
Schema en temps alternant un demi-pas de temps d'Euler implicite et un demi-pas de temps de LeapFrog.<br/>
La resolution implicite est iterative (point fixe).<br/>
Le pas de temps est calcule comme le produit du pas de temps de stabilite explicite par un facsec.<br/>
Le facsec est ajuste automatiquement pour que la resolution converge en un nombre d'iterations predefini.<br/>
Les caracteristiques de chaque iteration sont ecrites dans le fichier dt_CN.<br/>
La resolution est gouvernee par 4 parametres (valeurs par defauts entre parentheses) :<br/>
* seuil (1e-3) : le seuil de convergence. Plus il est bas, plus la resolution est precise.<br/>
* facsec_max (2) : la valeur du facsec que l'on ne veut pas depasser (eviter les instabilites et capter les phenomenes physiques)<br/>
* niter_min (2) : le nombre minimum d'iterations. En deca, on continue a iterer meme si on semble avoir atteint la convergence.<br/>
* niter_avg (3) : le nombre d'iterations que l'on souhaite faire pour arriver a convergence.<br/>
* niter_max (6) : le nombre d'iteration au-dela duquel on reessaye avec un facsec plus petit.<br/>
Conseil pour le choix des parametres d'ajustement du facsec :<br/>
* Choisir seuil en fonction de la precision desiree.<br/>
* Choisir niter_min : 2 garantit un schema d'ordre 2 en temps.<br/>
* Si on cherche un stationnaire, choisir seuil_statio &gt;= seuil.<br/>
* Choisir facsec_max en fonction des phenomenes physiques a capter.<br/>
* Commencer par tester avec une grande valeur de niter_avg. Observer le comportement du nombre d'iterations.<br/>
Il bute sur une valeur maximum avant de retomber.<br/>
* Choisir niter_avg aux 2/3 de cette valeur maximum, et niter_max aux 4/3 ou au double environ. </p>

<p>Definition at line <a class="el" href="Sch__CN__iteratif_8h_source.html#l00057">57</a> of file <a class="el" href="Sch__CN__iteratif_8h_source.html">Sch_CN_iteratif.h</a>.</p>
</div><hr/><h2>Member Enumeration Documentation</h2>
<a class="anchor" id="a38c9cbfc3b5889e7abed6783aeace1c6"></a><!-- doxytag: member="Sch_CN_iteratif::type_convergence" ref="a38c9cbfc3b5889e7abed6783aeace1c6" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classSch__CN__iteratif.html#a38c9cbfc3b5889e7abed6783aeace1c6">Sch_CN_iteratif::type_convergence</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a38c9cbfc3b5889e7abed6783aeace1c6ae13cc0f35ce7a8939bf5f0eba9197533"></a><!-- doxytag: member="DIVERGENCE" ref="a38c9cbfc3b5889e7abed6783aeace1c6ae13cc0f35ce7a8939bf5f0eba9197533" args="" -->DIVERGENCE</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a38c9cbfc3b5889e7abed6783aeace1c6ae286f9849cb30d69f60b17feea70cee6"></a><!-- doxytag: member="NON_CONVERGENCE" ref="a38c9cbfc3b5889e7abed6783aeace1c6ae286f9849cb30d69f60b17feea70cee6" args="" -->NON_CONVERGENCE</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a38c9cbfc3b5889e7abed6783aeace1c6af38229d31137d128193200dddeb199c1"></a><!-- doxytag: member="CONVERGENCE_LENTE" ref="a38c9cbfc3b5889e7abed6783aeace1c6af38229d31137d128193200dddeb199c1" args="" -->CONVERGENCE_LENTE</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a38c9cbfc3b5889e7abed6783aeace1c6ad1ae98000096423125c874be1694a3d1"></a><!-- doxytag: member="CONVERGENCE_RAPIDE" ref="a38c9cbfc3b5889e7abed6783aeace1c6ad1ae98000096423125c874be1694a3d1" args="" -->CONVERGENCE_RAPIDE</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a38c9cbfc3b5889e7abed6783aeace1c6add0e9382f85b678d333ad2d5ff54638d"></a><!-- doxytag: member="CONVERGENCE_OK" ref="a38c9cbfc3b5889e7abed6783aeace1c6add0e9382f85b678d333ad2d5ff54638d" args="" -->CONVERGENCE_OK</em>&nbsp;</td><td>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="Sch__CN__iteratif_8h_source.html#l00090">90</a> of file <a class="el" href="Sch__CN__iteratif_8h_source.html">Sch_CN_iteratif.h</a>.</p>
<div class="fragment"><pre class="fragment">{<a class="code" href="classSch__CN__iteratif.html#a38c9cbfc3b5889e7abed6783aeace1c6ae13cc0f35ce7a8939bf5f0eba9197533">DIVERGENCE</a>, <a class="code" href="classSch__CN__iteratif.html#a38c9cbfc3b5889e7abed6783aeace1c6ae286f9849cb30d69f60b17feea70cee6">NON_CONVERGENCE</a>, <a class="code" href="classSch__CN__iteratif.html#a38c9cbfc3b5889e7abed6783aeace1c6af38229d31137d128193200dddeb199c1">CONVERGENCE_LENTE</a>, <a class="code" href="classSch__CN__iteratif.html#a38c9cbfc3b5889e7abed6783aeace1c6ad1ae98000096423125c874be1694a3d1">CONVERGENCE_RAPIDE</a>, <a class="code" href="classSch__CN__iteratif.html#a38c9cbfc3b5889e7abed6783aeace1c6add0e9382f85b678d333ad2d5ff54638d">CONVERGENCE_OK</a>};
</pre></div>
</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a693f89d0f86fedadca604729a77dec9d"></a><!-- doxytag: member="Sch_CN_iteratif::Sch_CN_iteratif" ref="a693f89d0f86fedadca604729a77dec9d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Sch_CN_iteratif::Sch_CN_iteratif </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Sch__CN__iteratif_8cpp_source.html#l00031">31</a> of file <a class="el" href="Sch__CN__iteratif_8cpp_source.html">Sch_CN_iteratif.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a909b33ca07743c44df11c4e43ad30a05"></a><!-- doxytag: member="Sch_CN_iteratif::~Sch_CN_iteratif" ref="a909b33ca07743c44df11c4e43ad30a05" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Sch_CN_iteratif::~Sch_CN_iteratif </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Sch__CN__iteratif_8cpp_source.html#l00031">31</a> of file <a class="el" href="Sch__CN__iteratif_8cpp_source.html">Sch_CN_iteratif.cpp</a>.</p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="ac083ab5828482f83fa510827f052d0de"></a><!-- doxytag: member="Sch_CN_iteratif::ajuster_facsec" ref="ac083ab5828482f83fa510827f052d0de" args="(type_convergence cv)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Sch_CN_iteratif::ajuster_facsec </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSch__CN__iteratif.html#a38c9cbfc3b5889e7abed6783aeace1c6">type_convergence</a>&#160;</td>
          <td class="paramname"><em>cv</em></td><td>)</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>&lt; On n'ajuste qu'une fois pour un initTimeStep. </p>
</p>

<p>Reimplemented in <a class="el" href="classSch__CN__EX__iteratif.html#ab378aec8359a9984f16c607638934b8f">Sch_CN_EX_iteratif</a>.</p>

<p>Definition at line <a class="el" href="Sch__CN__iteratif_8cpp_source.html#l00053">53</a> of file <a class="el" href="Sch__CN__iteratif_8cpp_source.html">Sch_CN_iteratif.cpp</a>.</p>

<p>References <a class="el" href="Sch__CN__iteratif_8h_source.html#l00090">CONVERGENCE_LENTE</a>, <a class="el" href="Sch__CN__iteratif_8h_source.html#l00090">CONVERGENCE_OK</a>, <a class="el" href="Sch__CN__iteratif_8h_source.html#l00090">CONVERGENCE_RAPIDE</a>, <a class="el" href="Sch__CN__iteratif_8h_source.html#l00090">DIVERGENCE</a>, <a class="el" href="Schema__Temps__base_8h_source.html#l00383">Schema_Temps_base::facsec_</a>, <a class="el" href="Sch__CN__iteratif_8h_source.html#l00102">facsec_max</a>, <a class="el" href="Sch__CN__iteratif_8h_source.html#l00106">last_facsec</a>, <a class="el" href="Double_8h_source.html#l00199">min()</a>, and <a class="el" href="Sch__CN__iteratif_8h_source.html#l00090">NON_CONVERGENCE</a>.</p>

<p>Referenced by <a class="el" href="Sch__CN__iteratif_8cpp_source.html#l00164">iterateTimeStep()</a>.</p>
<div class="fragment"><pre class="fragment">{

  <span class="keywordflow">if</span> (<a class="code" href="classSchema__Temps__base.html#a8cdc40f1adfd8ff29d7f9c75330920ee">facsec_</a>!=<a class="code" href="classSch__CN__iteratif.html#ad7bc392b49ba97e340e165f4372f86a9" title="facsec at the beginning of time step resolution, to avoid changing facsec several times for the same ...">last_facsec</a>) <span class="comment">//!&lt; On n&#39;ajuste qu&#39;une fois pour un initTimeStep.</span>
<span class="comment"></span>    <span class="keywordflow">return</span>;

  <span class="keywordflow">switch</span> (cv)
    {
    <span class="keywordflow">case</span> <a class="code" href="classSch__CN__iteratif.html#a38c9cbfc3b5889e7abed6783aeace1c6ae13cc0f35ce7a8939bf5f0eba9197533">DIVERGENCE</a>:
<span class="comment">// le critere de divergence a ete atteint</span>
      <a class="code" href="classSchema__Temps__base.html#a8cdc40f1adfd8ff29d7f9c75330920ee">facsec_</a>=<a class="code" href="classSch__CN__iteratif.html#ad7bc392b49ba97e340e165f4372f86a9" title="facsec at the beginning of time step resolution, to avoid changing facsec several times for the same ...">last_facsec</a>*0.8;
      <span class="keywordflow">break</span>;
    <span class="keywordflow">case</span> <a class="code" href="classSch__CN__iteratif.html#a38c9cbfc3b5889e7abed6783aeace1c6ae286f9849cb30d69f60b17feea70cee6">NON_CONVERGENCE</a>:
<span class="comment">// ni le critere de divergence ni le critere de convergence</span>
<span class="comment">// n&#39;ont ete atteints en niter_max iterations</span>
      <a class="code" href="classSchema__Temps__base.html#a8cdc40f1adfd8ff29d7f9c75330920ee">facsec_</a>=<a class="code" href="classSch__CN__iteratif.html#ad7bc392b49ba97e340e165f4372f86a9" title="facsec at the beginning of time step resolution, to avoid changing facsec several times for the same ...">last_facsec</a>*0.9;
      <span class="keywordflow">break</span>;
    <span class="keywordflow">case</span> <a class="code" href="classSch__CN__iteratif.html#a38c9cbfc3b5889e7abed6783aeace1c6af38229d31137d128193200dddeb199c1">CONVERGENCE_LENTE</a>:
<span class="comment">// le critere de convergence a ete atteint en plus que niter_avg</span>
<span class="comment">// iterations</span>
      <a class="code" href="classSchema__Temps__base.html#a8cdc40f1adfd8ff29d7f9c75330920ee">facsec_</a>=<a class="code" href="classSch__CN__iteratif.html#ad7bc392b49ba97e340e165f4372f86a9" title="facsec at the beginning of time step resolution, to avoid changing facsec several times for the same ...">last_facsec</a>*0.99;
      <span class="keywordflow">break</span>;
    <span class="keywordflow">case</span> <a class="code" href="classSch__CN__iteratif.html#a38c9cbfc3b5889e7abed6783aeace1c6ad1ae98000096423125c874be1694a3d1">CONVERGENCE_RAPIDE</a>:
<span class="comment">// le critere de convergence a ete atteint en moins que niter_avg</span>
<span class="comment">// iterations</span>
      <a class="code" href="classSchema__Temps__base.html#a8cdc40f1adfd8ff29d7f9c75330920ee">facsec_</a>=<a class="code" href="classSch__CN__iteratif.html#ad7bc392b49ba97e340e165f4372f86a9" title="facsec at the beginning of time step resolution, to avoid changing facsec several times for the same ...">last_facsec</a>*1.01;
      <span class="keywordflow">break</span>;
    <span class="keywordflow">case</span> <a class="code" href="classSch__CN__iteratif.html#a38c9cbfc3b5889e7abed6783aeace1c6add0e9382f85b678d333ad2d5ff54638d">CONVERGENCE_OK</a>:
<span class="comment">// le critere de convergence a ete atteint en niter_avg iterations</span>
      <span class="keywordflow">break</span>;
    <span class="keywordflow">default</span>:
      <span class="keywordflow">break</span>;
    }
  <a class="code" href="classSchema__Temps__base.html#a8cdc40f1adfd8ff29d7f9c75330920ee">facsec_</a>=<a class="code" href="Double_8h.html#a2f8edc4561e9744ed4233b205fa7ec32">min</a>(<a class="code" href="classSchema__Temps__base.html#a8cdc40f1adfd8ff29d7f9c75330920ee">facsec_</a>,<a class="code" href="classSch__CN__iteratif.html#ae7e2aeaa5d411a5b2e746db7fc40581f" title="Maximum facsec (not to miss the physics)">facsec_max</a>);
}
</pre></div>
</div>
</div>
<a class="anchor" id="a6d94ef995fc9c970c5462deff5d3cef8"></a><!-- doxytag: member="Sch_CN_iteratif::completer" ref="a6d94ef995fc9c970c5462deff5d3cef8" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Sch_CN_iteratif::completer </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implements <a class="el" href="classSchema__Temps__base.html#af7184469580a32593530c8dff9d01af2">Schema_Temps_base</a>.</p>

<p>Definition at line <a class="el" href="Sch__CN__iteratif_8h_source.html#l00085">85</a> of file <a class="el" href="Sch__CN__iteratif_8h_source.html">Sch_CN_iteratif.h</a>.</p>
<div class="fragment"><pre class="fragment">{}
</pre></div>
</div>
</div>
<a class="anchor" id="a0986d7724a3324ac4b4a86f1ad449c51"></a><!-- doxytag: member="Sch_CN_iteratif::convergence" ref="a0986d7724a3324ac4b4a86f1ad449c51" args="(const DoubleTab &amp;u0, const DoubleTab &amp;up1, const DoubleTab &amp;delta, int p) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Sch_CN_iteratif::convergence </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>u0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>up1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>delta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Indique si le calcul iteratif a converge.<br/>
Critere de convergence utilise :<br/>
|| u(n+1,p+1) - u(n+1,p) || &lt; seuil * || u(n+1/2,p+1) ||<br/>
C'est equivalent a<br/>
|| u(n+1,p) - u(n+1) || &lt; seuil * || (Id-(dt/2).(df/du))^-1 || * || u(n+1/2,p+1) ||<br/>
ou u(n+1) est la solution exacte en n+1,<br/>
df/du est le lagrangien de f(u), pris en u(n+1/2)<br/>
et les normes sont compatibles entre matrices et vecteurs (ici norme infinie). </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>bool<br/>
 Signification: true=converge, false=non converge<br/>
 Contraintes: </dd></dl>

<p><p>&lt; pour etre certain que tout le monde fait la meme chose </p>
</p>

<p>Definition at line <a class="el" href="Sch__CN__iteratif_8cpp_source.html#l00390">390</a> of file <a class="el" href="Sch__CN__iteratif_8cpp_source.html">Sch_CN_iteratif.cpp</a>.</p>

<p>References <a class="el" href="communications_8cpp_source.html#l00375">envoyer_broadcast()</a>, <a class="el" href="DoubleVect_8cpp_source.html#l02277">mp_max_abs_vect()</a>, and <a class="el" href="Sch__CN__iteratif_8h_source.html#l00098">seuil</a>.</p>

<p>Referenced by <a class="el" href="Sch__CN__iteratif_8cpp_source.html#l00257">iterateTimeStepOnEquation()</a>, and <a class="el" href="Sch__CN__EX__iteratif_8cpp_source.html#l00096">Sch_CN_EX_iteratif::iterateTimeStepOnNS()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">double</span> a = <a class="code" href="DoubleVect_8cpp.html#acb21ec8c0b3909c26b20e3f3455e0289">mp_max_abs_vect</a>(delta);
  <span class="keywordtype">double</span> b = <a class="code" href="DoubleVect_8cpp.html#acb21ec8c0b3909c26b20e3f3455e0289">mp_max_abs_vect</a>(up1);
  <span class="keywordtype">int</span> resu = (2. * a) &lt; (<a class="code" href="classSch__CN__iteratif.html#ab1627c25875c72516ce79c044ea8c38e" title="To determine convergence.">seuil</a> * b);
  <a class="code" href="communications_8cpp.html#a2335b36078ae87e23dab400a6e129a3c">envoyer_broadcast</a>(resu, 0); <span class="comment">//!&lt; pour etre certain que tout le monde fait la meme chose</span>
<span class="comment"></span>  <span class="keywordflow">return</span> resu;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a6affcbee80525e6ce27df4d8274b0deb"></a><!-- doxytag: member="Sch_CN_iteratif::cree_instance" ref="a6affcbee80525e6ce27df4d8274b0deb" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classObjet__U.html">Objet_U</a> * Sch_CN_iteratif::cree_instance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented in <a class="el" href="classSch__CN__EX__iteratif.html#aa6ab2b4ecdbd70e8ae12e1e4720e687e">Sch_CN_EX_iteratif</a>.</p>

<p>Definition at line <a class="el" href="Sch__CN__iteratif_8cpp_source.html#l00031">31</a> of file <a class="el" href="Sch__CN__iteratif_8cpp_source.html">Sch_CN_iteratif.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5a4bd9e2782c8e8066b737d83feb09df"></a><!-- doxytag: member="Sch_CN_iteratif::divergence" ref="a5a4bd9e2782c8e8066b737d83feb09df" args="(const DoubleTab &amp;u0, const DoubleTab &amp;up1, const DoubleTab &amp;delta, int p) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Sch_CN_iteratif::divergence </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>u0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>up1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>delta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Indique si le calcul iteratif a diverge. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>bool<br/>
 Signification: true=diverge, false=non diverge<br/>
 Contraintes: </dd></dl>

<p>Definition at line <a class="el" href="Sch__CN__iteratif_8cpp_source.html#l00424">424</a> of file <a class="el" href="Sch__CN__iteratif_8cpp_source.html">Sch_CN_iteratif.cpp</a>.</p>

<p>Referenced by <a class="el" href="Sch__CN__iteratif_8cpp_source.html#l00257">iterateTimeStepOnEquation()</a>, and <a class="el" href="Sch__CN__EX__iteratif_8cpp_source.html#l00096">Sch_CN_EX_iteratif::iterateTimeStepOnNS()</a>.</p>
<div class="fragment"><pre class="fragment">{
<span class="comment">// WEC : ameliorable...</span>
  <span class="keywordflow">return</span> <span class="keyword">false</span>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a295e3906e599d0168342d8bb9a8243e6"></a><!-- doxytag: member="Sch_CN_iteratif::duplique" ref="a295e3906e599d0168342d8bb9a8243e6" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Sch_CN_iteratif::duplique </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implements <a class="el" href="classSchema__Temps__base.html#af2574e62fa1ab6c6f3e1ee33c0bac644">Schema_Temps_base</a>.</p>

<p>Reimplemented in <a class="el" href="classSch__CN__EX__iteratif.html#a5f820c5c4705a2ee40516624786e9cb3">Sch_CN_EX_iteratif</a>.</p>

<p>Definition at line <a class="el" href="Sch__CN__iteratif_8cpp_source.html#l00031">31</a> of file <a class="el" href="Sch__CN__iteratif_8cpp_source.html">Sch_CN_iteratif.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="abfd314442a69f22406b0645e71849ff9"></a><!-- doxytag: member="Sch_CN_iteratif::faire_un_pas_de_temps_eqn_base" ref="abfd314442a69f22406b0645e71849ff9" args="(Equation_base &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Sch_CN_iteratif::faire_un_pas_de_temps_eqn_base </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEquation__base.html">Equation_base</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implements <a class="el" href="classSchema__Temps__base.html#aaf384ecbdb1555490cad2f1779dd5a9c">Schema_Temps_base</a>.</p>

<p>Definition at line <a class="el" href="Sch__CN__iteratif_8cpp_source.html#l00350">350</a> of file <a class="el" href="Sch__CN__iteratif_8cpp_source.html">Sch_CN_iteratif.cpp</a>.</p>

<p>References <a class="el" href="EntreeSortie_8h_source.html#l00032">Cerr</a>, <a class="el" href="Process_8cpp_source.html#l00223">Process::exit()</a>, and <a class="el" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>.</p>
<div class="fragment"><pre class="fragment">{
  <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Sch_CN_iteratif::faire_un_pas_de_temps_eqn_base non code!&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
  <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">exit</a>();
  <span class="keywordflow">return</span> 0;
}
</pre></div>
</div>
</div>
<a class="anchor" id="ad8c9b28358ada18f0bc17f54b52b4a71"></a><!-- doxytag: member="Sch_CN_iteratif::get_info" ref="ad8c9b28358ada18f0bc17f54b52b4a71" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classType__info.html">Type_info</a> * Sch_CN_iteratif::get_info </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Donne des informations sur le type de l'Objet_U. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>const Type_info*<br/>
 Signification: structure regroupant les informations sur le type de l'Objet_U<br/>
 Contraintes: </dd></dl>

<p>Reimplemented from <a class="el" href="classSchema__Temps__base.html#a789e0dadecd8e28bf74963678f6f438b">Schema_Temps_base</a>.</p>

<p>Reimplemented in <a class="el" href="classSch__CN__EX__iteratif.html#ab2d2d0a4f28f35615aa7ef27c4dca396">Sch_CN_EX_iteratif</a>.</p>

<p>Definition at line <a class="el" href="Sch__CN__iteratif_8cpp_source.html#l00031">31</a> of file <a class="el" href="Sch__CN__iteratif_8cpp_source.html">Sch_CN_iteratif.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ada7e22678ea5d7311a63cedc65a14781"></a><!-- doxytag: member="Sch_CN_iteratif::info" ref="ada7e22678ea5d7311a63cedc65a14781" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classType__info.html">Type_info</a> * Sch_CN_iteratif::info </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Donne des informations sur le type de l'Objet_U. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>const Type_info*<br/>
 Signification: structure regroupant les informations sur le type de l'Objet_U<br/>
 Contraintes: </dd></dl>

<p>Reimplemented from <a class="el" href="classSchema__Temps__base.html#a24d53a2e64f35bfad1660c256c9fe6cc">Schema_Temps_base</a>.</p>

<p>Reimplemented in <a class="el" href="classSch__CN__EX__iteratif.html#a46f9f025dce0984581c818b74a86a363">Sch_CN_EX_iteratif</a>.</p>

<p>Definition at line <a class="el" href="Sch__CN__iteratif_8cpp_source.html#l00031">31</a> of file <a class="el" href="Sch__CN__iteratif_8cpp_source.html">Sch_CN_iteratif.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa8ef3d17ee10c76043e3738b0ca31c1e"></a><!-- doxytag: member="Sch_CN_iteratif::initTimeStep" ref="aa8ef3d17ee10c76043e3738b0ca31c1e" args="(double dt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Sch_CN_iteratif::initTimeStep </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dt</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>&lt; sinon deja appele par validateTimeStep Plus necessaire car desormais dt_ est mis a jour dans Schema_Temps_base::computeTimeStep(bool&amp; stop) facsec_=dt/dt_; </p>
</p>

<p>Reimplemented from <a class="el" href="classSchema__Temps__base.html#a9917c2c7e04733506b1c46d0a463701a">Schema_Temps_base</a>.</p>

<p>Definition at line <a class="el" href="Sch__CN__iteratif_8cpp_source.html#l00149">149</a> of file <a class="el" href="Sch__CN__iteratif_8cpp_source.html">Sch_CN_iteratif.cpp</a>.</p>

<p>References <a class="el" href="Schema__Temps__base_8h_source.html#l00383">Schema_Temps_base::facsec_</a>, <a class="el" href="Sch__CN__iteratif_8h_source.html#l00105">iteration</a>, <a class="el" href="Sch__CN__iteratif_8h_source.html#l00106">last_facsec</a>, <a class="el" href="Schema__Temps__base_8cpp_source.html#l00769">Schema_Temps_base::mettre_a_jour_dt_stab()</a>, and <a class="el" href="Schema__Temps__base_8h_source.html#l00754">Schema_Temps_base::nb_pas_dt()</a>.</p>
<div class="fragment"><pre class="fragment">{

  <span class="keywordflow">if</span> (<a class="code" href="classSchema__Temps__base.html#a247769eddf9c0bfcaabc50b8dd90d401" title="Renvoie le nombre de pas de temps effectues.">nb_pas_dt</a>()==0)
    <a class="code" href="classSchema__Temps__base.html#ad95c1e999ba471e5a95760e37aebb05f">mettre_a_jour_dt_stab</a>(); <span class="comment">//!&lt; sinon deja appele par validateTimeStep Plus necessaire car desormais dt_ est mis a jour dans Schema_Temps_base::computeTimeStep(bool&amp; stop) facsec_=dt/dt_;</span>
<span class="comment"></span><span class="comment">//</span>
<span class="comment">//</span>
  <a class="code" href="classSch__CN__iteratif.html#ad7bc392b49ba97e340e165f4372f86a9" title="facsec at the beginning of time step resolution, to avoid changing facsec several times for the same ...">last_facsec</a>=<a class="code" href="classSchema__Temps__base.html#a8cdc40f1adfd8ff29d7f9c75330920ee">facsec_</a>;

  <a class="code" href="classSch__CN__iteratif.html#a12e6e86233c59d24175c78441f0e7046" title="Number of iterations done for the current time step.">iteration</a>=0;

  <span class="keywordflow">return</span> <a class="code" href="classSch__CN__iteratif.html#aa8ef3d17ee10c76043e3738b0ca31c1e">Schema_Temps_base::initTimeStep</a>(dt);
}
</pre></div>
</div>
</div>
<a class="anchor" id="a99b8ea6d0194f9a4f6b34472dcdb841f"></a><!-- doxytag: member="Sch_CN_iteratif::iterateTimeStep" ref="a99b8ea6d0194f9a4f6b34472dcdb841f" args="(bool &amp;converged)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Sch_CN_iteratif::iterateTimeStep </td>
          <td>(</td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>converged</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate the U(n+1) unknown for each equation (if solved) of the problem with the selected time scheme. </p>

<p><p>&lt; Continuer a iterer de toutes facons</p>
<p>&lt; Convergence trop rapide, augmenter facsec</p>
<p>&lt; Convergence trop lente, reduire facsec </p>
</p>

<p>Reimplemented from <a class="el" href="classSchema__Temps__base.html#ac2664c716af1b7d2526580fae4cd9362">Schema_Temps_base</a>.</p>

<p>Definition at line <a class="el" href="Sch__CN__iteratif_8cpp_source.html#l00164">164</a> of file <a class="el" href="Sch__CN__iteratif_8cpp_source.html">Sch_CN_iteratif.cpp</a>.</p>

<p>References <a class="el" href="Sch__CN__iteratif_8cpp_source.html#l00053">ajuster_facsec()</a>, <a class="el" href="Sortie__Fichier__base_8cpp_source.html#l00126">Sortie_Fichier_base::close()</a>, <a class="el" href="Sch__CN__iteratif_8h_source.html#l00090">CONVERGENCE_LENTE</a>, <a class="el" href="Sch__CN__iteratif_8h_source.html#l00090">CONVERGENCE_OK</a>, <a class="el" href="Sch__CN__iteratif_8h_source.html#l00090">CONVERGENCE_RAPIDE</a>, <a class="el" href="Sch__CN__iteratif_8h_source.html#l00090">DIVERGENCE</a>, <a class="el" href="Schema__Temps__base_8h_source.html#l00365">Schema_Temps_base::dt_</a>, <a class="el" href="Schema__Temps__base_8h_source.html#l00383">Schema_Temps_base::facsec_</a>, <a class="el" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>, <a class="el" href="Sch__CN__iteratif_8cpp_source.html#l00257">iterateTimeStepOnEquation()</a>, <a class="el" href="Sch__CN__iteratif_8h_source.html#l00105">iteration</a>, <a class="el" href="Process_8cpp_source.html#l00095">Process::je_suis_maitre()</a>, <a class="el" href="Sch__CN__iteratif_8h_source.html#l00106">last_facsec</a>, <a class="el" href="Probleme__base_8h_source.html#l00295">Probleme_base::le_nom()</a>, <a class="el" href="Sch__CN__iteratif_8h_source.html#l00101">niter_avg</a>, <a class="el" href="Sch__CN__iteratif_8h_source.html#l00100">niter_max</a>, <a class="el" href="Sch__CN__iteratif_8h_source.html#l00099">niter_min</a>, <a class="el" href="classProbleme__base.html#abefceb0ac0d0b35d42a4daaa82a95f59">Probleme_base::nombre_d_equations()</a>, <a class="el" href="Sch__CN__iteratif_8h_source.html#l00090">NON_CONVERGENCE</a>, <a class="el" href="Sortie__Fichier__base_8cpp_source.html#l00161">Sortie_Fichier_base::ouvrir()</a>, <a class="el" href="Schema__Temps__base_8cpp_source.html#l01027">Schema_Temps_base::pb_base()</a>, and <a class="el" href="Schema__Temps__base_8h_source.html#l00676">Schema_Temps_base::temps_courant()</a>.</p>
<div class="fragment"><pre class="fragment">{

  <a class="code" href="classProbleme__base.html" title="classe Probleme_base C&#39;est un Probleme_U qui n&#39;est pas un couplage. Le role d&#39;un Probleme_base est la...">Probleme_base</a>&amp; pb = <a class="code" href="classSchema__Temps__base.html#a6e2edfe46a7f27b6fc8f114d92c35dc2">pb_base</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_eqn=pb.<a class="code" href="classProbleme__base.html#abefceb0ac0d0b35d42a4daaa82a95f59">nombre_d_equations</a>();

  <a class="code" href="classSFichier.html" title="Cette classe est a la classe C++ ofstream ce que la classe Sortie est a la classe C++ ostream Elle re...">SFichier</a> fic;
  fic.<a class="code" href="classSortie__Fichier__base.html#a7e75e18ed580cd4d45912ec202caa2b2">ouvrir</a>(<span class="stringliteral">&quot;dt_CN&quot;</span>,ios::app);

  <span class="keywordflow">if</span> (<a class="code" href="classProcess.html#acd052b99706c577f8a5b6656217cf4c2" title="renvoie 1 si on est sur le processeur maitre du groupe courant (c&#39;est a dire me() == 0)...">je_suis_maitre</a>())
    {
      fic &lt;&lt; <span class="stringliteral">&quot;Sch_CN_iteratif : pb= &quot;</span> &lt;&lt;  pb.<a class="code" href="classProbleme__base.html#a58bc0b101f3f3f1d8522a9f41f1fad7b" title="surcharge Objet_U::le_nom() Renvoie le nom du probleme">le_nom</a>()
          &lt;&lt; <span class="stringliteral">&quot; present= &quot;</span> &lt;&lt; <a class="code" href="classSchema__Temps__base.html#a5054df01edb6d4f7baec7e612d423834" title="Renvoie le temps courant.">temps_courant</a>()
          &lt;&lt; <span class="stringliteral">&quot; dt= &quot;</span> &lt;&lt; <a class="code" href="classSchema__Temps__base.html#a41d96b9bfd9ead46031343c31f9bfe5d" title="Pas de temps de calcul.">dt_</a>
          &lt;&lt; <span class="stringliteral">&quot; iteration= &quot;</span> &lt;&lt; <a class="code" href="classSch__CN__iteratif.html#a12e6e86233c59d24175c78441f0e7046" title="Number of iterations done for the current time step.">iteration</a>
          &lt;&lt; <span class="stringliteral">&quot; last_facsec= &quot;</span> &lt;&lt; <a class="code" href="classSch__CN__iteratif.html#ad7bc392b49ba97e340e165f4372f86a9" title="facsec at the beginning of time step resolution, to avoid changing facsec several times for the same ...">last_facsec</a>;
    }
  converged=<span class="keyword">true</span>;
  <span class="keywordtype">bool</span> diverged=<span class="keyword">false</span>;

  <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;nb_eqn &amp;&amp; !diverged; i++)
    {
      <span class="keywordtype">bool</span> cv;
      diverged = diverged || !<a class="code" href="classSch__CN__iteratif.html#a02a2ed7ab40f5cc6a0118e3acaa1926e" title="Calcule une iteration de la resolution sur l&#39;equation i. Calcule u(n+1/2,p+1)=u(n)+f(u(n+1/2,p))*dt/2 et u(n+1,p+1)=u(n)+f(u(n+1/2,p))*dt ou f donne du/dt en fonction de u Retourne true dans converged si ca ne bouge plus d&#39;une iteration a l&#39;autre, false sinon Renvoie true si OK pour continuer a iterer, false sinon (diverge ou trop d&#39;iterations)">iterateTimeStepOnEquation</a>(i,cv);
      converged = converged &amp;&amp; cv;
    }

  <a class="code" href="classSch__CN__iteratif.html#a12e6e86233c59d24175c78441f0e7046" title="Number of iterations done for the current time step.">iteration</a> ++;
  <span class="keywordflow">if</span> (<a class="code" href="classSch__CN__iteratif.html#a12e6e86233c59d24175c78441f0e7046" title="Number of iterations done for the current time step.">iteration</a>&lt;<a class="code" href="classSch__CN__iteratif.html#a5afdda57e3a767717a0e2dac900f8490" title="Minimum number of iterations (before, continue to iterate)">niter_min</a>)
    converged=<span class="keyword">false</span>; <span class="comment">//!&lt; Continuer a iterer de toutes facons</span>
<span class="comment"></span>
<span class="comment">// Un peu de bon sens...</span>
  assert(!(converged&amp;&amp;diverged));

<span class="comment">// Si convergence</span>
  <span class="keywordflow">if</span> (converged)
    {
      <span class="keywordflow">if</span> (<a class="code" href="classSch__CN__iteratif.html#a12e6e86233c59d24175c78441f0e7046" title="Number of iterations done for the current time step.">iteration</a>&lt;<a class="code" href="classSch__CN__iteratif.html#a9467b12b7d6a5f2c3b7eb48f3e0c176c" title="Average number of iterations wanted (facsec adjusted to fit that number)">niter_avg</a>) <span class="comment">//!&lt; Convergence trop rapide, augmenter facsec</span>
<span class="comment"></span>        <a class="code" href="classSch__CN__iteratif.html#ac083ab5828482f83fa510827f052d0de">ajuster_facsec</a>(<a class="code" href="classSch__CN__iteratif.html#a38c9cbfc3b5889e7abed6783aeace1c6ad1ae98000096423125c874be1694a3d1">CONVERGENCE_RAPIDE</a>);
      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="classSch__CN__iteratif.html#a12e6e86233c59d24175c78441f0e7046" title="Number of iterations done for the current time step.">iteration</a>&gt;<a class="code" href="classSch__CN__iteratif.html#a9467b12b7d6a5f2c3b7eb48f3e0c176c" title="Average number of iterations wanted (facsec adjusted to fit that number)">niter_avg</a>) <span class="comment">//!&lt; Convergence trop lente, reduire facsec</span>
<span class="comment"></span>        <a class="code" href="classSch__CN__iteratif.html#ac083ab5828482f83fa510827f052d0de">ajuster_facsec</a>(<a class="code" href="classSch__CN__iteratif.html#a38c9cbfc3b5889e7abed6783aeace1c6af38229d31137d128193200dddeb199c1">CONVERGENCE_LENTE</a>);
      <span class="keywordflow">else</span>
        <a class="code" href="classSch__CN__iteratif.html#ac083ab5828482f83fa510827f052d0de">ajuster_facsec</a>(<a class="code" href="classSch__CN__iteratif.html#a38c9cbfc3b5889e7abed6783aeace1c6add0e9382f85b678d333ad2d5ff54638d">CONVERGENCE_OK</a>);
      <span class="keywordflow">if</span> (<a class="code" href="classProcess.html#acd052b99706c577f8a5b6656217cf4c2" title="renvoie 1 si on est sur le processeur maitre du groupe courant (c&#39;est a dire me() == 0)...">je_suis_maitre</a>())
        {
          fic &lt;&lt; <span class="stringliteral">&quot; facsec= &quot;</span> &lt;&lt; <a class="code" href="classSchema__Temps__base.html#a8cdc40f1adfd8ff29d7f9c75330920ee">facsec_</a>
              &lt;&lt; <span class="stringliteral">&quot; result= CONVERGENCE&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
        }
      fic.<a class="code" href="classSortie__Fichier__base.html#ac246a47c4438e3183322c20db2a3323c">close</a>();
      <span class="keywordflow">return</span> <span class="keyword">true</span>;
    }

<span class="comment">// Si divergence</span>
  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (diverged)
    {
      <a class="code" href="classSch__CN__iteratif.html#ac083ab5828482f83fa510827f052d0de">ajuster_facsec</a>(<a class="code" href="classSch__CN__iteratif.html#a38c9cbfc3b5889e7abed6783aeace1c6ae13cc0f35ce7a8939bf5f0eba9197533">DIVERGENCE</a>);
      <span class="keywordflow">if</span> (<a class="code" href="classProcess.html#acd052b99706c577f8a5b6656217cf4c2" title="renvoie 1 si on est sur le processeur maitre du groupe courant (c&#39;est a dire me() == 0)...">je_suis_maitre</a>())
        {
          fic &lt;&lt; <span class="stringliteral">&quot; facsec= &quot;</span> &lt;&lt; <a class="code" href="classSchema__Temps__base.html#a8cdc40f1adfd8ff29d7f9c75330920ee">facsec_</a>
              &lt;&lt; <span class="stringliteral">&quot; result= DIVERGENCE&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
        }
      <span class="keywordflow">return</span> <span class="keyword">false</span>;
    }

<span class="comment">// Si pas converge assez vite</span>
  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="classSch__CN__iteratif.html#a12e6e86233c59d24175c78441f0e7046" title="Number of iterations done for the current time step.">iteration</a>==<a class="code" href="classSch__CN__iteratif.html#a4b93c13f52ae52886a176c7df396a2a8" title="Maximum number of iterations (after, considered as not convergent)">niter_max</a>-1)
    {
      <a class="code" href="classSch__CN__iteratif.html#ac083ab5828482f83fa510827f052d0de">ajuster_facsec</a>(<a class="code" href="classSch__CN__iteratif.html#a38c9cbfc3b5889e7abed6783aeace1c6ae286f9849cb30d69f60b17feea70cee6">NON_CONVERGENCE</a>);
      <span class="keywordflow">if</span> (<a class="code" href="classProcess.html#acd052b99706c577f8a5b6656217cf4c2" title="renvoie 1 si on est sur le processeur maitre du groupe courant (c&#39;est a dire me() == 0)...">je_suis_maitre</a>())
        {
          fic &lt;&lt; <span class="stringliteral">&quot; facsec= &quot;</span> &lt;&lt; <a class="code" href="classSchema__Temps__base.html#a8cdc40f1adfd8ff29d7f9c75330920ee">facsec_</a>
              &lt;&lt; <span class="stringliteral">&quot; result= NON_CONVERGENCE&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
        }
      <span class="keywordflow">return</span> <span class="keyword">false</span>;
    }

<span class="comment">// Sinon, en cours de convergence</span>
  <span class="keywordflow">if</span> (<a class="code" href="classProcess.html#acd052b99706c577f8a5b6656217cf4c2" title="renvoie 1 si on est sur le processeur maitre du groupe courant (c&#39;est a dire me() == 0)...">je_suis_maitre</a>())
    {
      fic &lt;&lt; <span class="stringliteral">&quot; facsec= &quot;</span> &lt;&lt; <a class="code" href="classSchema__Temps__base.html#a8cdc40f1adfd8ff29d7f9c75330920ee">facsec_</a>
          &lt;&lt; <span class="stringliteral">&quot; result= CONTINUE&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
    }
  <span class="keywordflow">return</span> <span class="keyword">true</span>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a02a2ed7ab40f5cc6a0118e3acaa1926e"></a><!-- doxytag: member="Sch_CN_iteratif::iterateTimeStepOnEquation" ref="a02a2ed7ab40f5cc6a0118e3acaa1926e" args="(int i, bool &amp;converged)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Sch_CN_iteratif::iterateTimeStepOnEquation </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>converged</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calcule une iteration de la resolution sur l'equation i.<br/>
Calcule u(n+1/2,p+1)=u(n)+f(u(n+1/2,p))*dt/2<br/>
et u(n+1,p+1)=u(n)+f(u(n+1/2,p))*dt<br/>
ou f donne du/dt en fonction de u<br/>
Retourne true dans converged si ca ne bouge plus d'une iteration a l'autre, false sinon<br/>
Renvoie true si OK pour continuer a iterer, false sinon (diverge ou trop d'iterations) </p>

<p><p>&lt; delta = Contient u(n+1/2,p+1) - u(n+1/2,p) </p>
</p>

<p>Reimplemented in <a class="el" href="classSch__CN__EX__iteratif.html#a75d64662977dfdb35ec8ca164e549c2b">Sch_CN_EX_iteratif</a>.</p>

<p>Definition at line <a class="el" href="Sch__CN__iteratif_8cpp_source.html#l00257">257</a> of file <a class="el" href="Sch__CN__iteratif_8cpp_source.html">Sch_CN_iteratif.cpp</a>.</p>

<p>References <a class="el" href="Champ__Inc_8cpp_source.html#l00411">Champ_Inc::avancer()</a>, <a class="el" href="Sch__CN__iteratif_8cpp_source.html#l00390">convergence()</a>, <a class="el" href="EntreeSortie_8h_source.html#l00033">Cout</a>, <a class="el" href="Equation__base_8cpp_source.html#l00818">Equation_base::derivee_en_temps_inco()</a>, <a class="el" href="Sch__CN__iteratif_8cpp_source.html#l00424">divergence()</a>, <a class="el" href="DoubleVect_8cpp_source.html#l00277">DoubleVect::echange_espace_virtuel()</a>, <a class="el" href="classProbleme__base.html#ae97586575b7e510d7945ce3a894b806a">Probleme_base::equation()</a>, <a class="el" href="Equation__base_8cpp_source.html#l00069">Equation_base::equation_non_resolue()</a>, <a class="el" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>, <a class="el" href="Zone__Cl__dis_8h_source.html#l00108">Zone_Cl_dis::imposer_cond_lim()</a>, <a class="el" href="classEquation__base.html#a5a1fce9487b9a8dd17020914100c2c89">Equation_base::inconnue()</a>, <a class="el" href="Sch__CN__iteratif_8h_source.html#l00105">iteration</a>, <a class="el" href="Schema__Temps__base_8h_source.html#l00754">Schema_Temps_base::nb_pas_dt()</a>, <a class="el" href="Schema__Temps__base_8cpp_source.html#l01027">Schema_Temps_base::pb_base()</a>, <a class="el" href="Objet__U_8cpp_source.html#l00132">Objet_U::que_suis_je()</a>, <a class="el" href="Champ__Inc_8cpp_source.html#l00431">Champ_Inc::reculer()</a>, <a class="el" href="Equation__base_8cpp_source.html#l01120">Equation_base::schema_temps()</a>, <a class="el" href="Schema__Temps__base_8h_source.html#l00284">Schema_Temps_base::set_stationnaire_atteint()</a>, <a class="el" href="Schema__Temps__base_8h_source.html#l00676">Schema_Temps_base::temps_courant()</a>, <a class="el" href="Sch__CN__iteratif_8cpp_source.html#l00125">temps_futur()</a>, <a class="el" href="Schema__Temps__base_8cpp_source.html#l01068">Schema_Temps_base::update_critere_statio()</a>, <a class="el" href="Champ__Inc_8cpp_source.html#l00245">Champ_Inc::valeurs()</a>, and <a class="el" href="Equation__base_8h_source.html#l00391">Equation_base::zone_Cl_dis()</a>.</p>

<p>Referenced by <a class="el" href="Sch__CN__iteratif_8cpp_source.html#l00164">iterateTimeStep()</a>.</p>
<div class="fragment"><pre class="fragment">{

  <a class="code" href="classProbleme__base.html" title="classe Probleme_base C&#39;est un Probleme_U qui n&#39;est pas un couplage. Le role d&#39;un Probleme_base est la...">Probleme_base</a>&amp; pb = <a class="code" href="classSchema__Temps__base.html#a6e2edfe46a7f27b6fc8f114d92c35dc2">pb_base</a>();
  <a class="code" href="classEquation__base.html">Equation_base</a>&amp; eqn = pb.<a class="code" href="classProbleme__base.html#ae97586575b7e510d7945ce3a894b806a">equation</a>(i);
  <span class="keywordflow">if</span> (eqn.<a class="code" href="classEquation__base.html#a0a497f27296625af895ffe40e48d109e">equation_non_resolue</a>())
    {
      <a class="code" href="EntreeSortie_8h.html#a1007c2f57f1c8fc7334a3f62aab08414">Cout</a>&lt;&lt; <span class="stringliteral">&quot;====================================================&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
      <a class="code" href="EntreeSortie_8h.html#a1007c2f57f1c8fc7334a3f62aab08414">Cout</a>&lt;&lt; eqn.<a class="code" href="classObjet__U.html#aa58e9a81c0ddc2c1149053b8f96698ac" title="renvoie la chaine identifiant la classe.">que_suis_je</a>()&lt;&lt;<span class="stringliteral">&quot; equation is not solved.&quot;</span>&lt;&lt;finl;
      <a class="code" href="EntreeSortie_8h.html#a1007c2f57f1c8fc7334a3f62aab08414">Cout</a>&lt;&lt; <span class="stringliteral">&quot;====================================================&quot;</span> &lt;&lt; finl;
<span class="comment">// On calcule une fois la derivee pour avoir les flux bord</span>
      <span class="keywordflow">if</span> (eqn.<a class="code" href="classEquation__base.html#abc11e51aa75b4c7aa55c27f71eb2f2c4" title="Renvoie le schema en temps associe a l&#39;equation.">schema_temps</a>().<a class="code" href="classSchema__Temps__base.html#a247769eddf9c0bfcaabc50b8dd90d401" title="Renvoie le nombre de pas de temps effectues.">nb_pas_dt</a>()==0)
        {
          <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a> inconnue_valeurs(eqn.<a class="code" href="classEquation__base.html#a5a1fce9487b9a8dd17020914100c2c89">inconnue</a>().<a class="code" href="classChamp__Inc.html#a28ef3d411d12cb5684ac5e799efb7d24" title="Appel a l&#39;objet sous-jacent Renvoie le tableau des valeurs au temps courant.">valeurs</a>());
          eqn.<a class="code" href="classEquation__base.html#a97aa87b0cf6205ef437a6774adf1bd47" title="Returns the time derivative of the unknown I of the equation: dI/dt = M-1*(sum(operators(I) + sources...">derivee_en_temps_inco</a>(inconnue_valeurs);
        }
      converged=<span class="keyword">true</span>;
      <span class="keywordflow">return</span> <span class="keyword">true</span>;
    }
  <span class="keywordtype">double</span> temps_intermediaire=<a class="code" href="classSch__CN__iteratif.html#ac28599b004c8f4294d97ec104eaabe42" title="Renvoie le le temps a la i-eme valeur future.">temps_futur</a>(1);
  <span class="keywordtype">double</span> temps_final=<a class="code" href="classSch__CN__iteratif.html#ac28599b004c8f4294d97ec104eaabe42" title="Renvoie le le temps a la i-eme valeur future.">temps_futur</a>(2);
  <span class="keywordtype">double</span> dt_intermediaire=temps_intermediaire-<a class="code" href="classSchema__Temps__base.html#a5054df01edb6d4f7baec7e612d423834" title="Renvoie le temps courant.">temps_courant</a>();
  <span class="keywordtype">double</span> dt_final=temps_final-<a class="code" href="classSchema__Temps__base.html#a5054df01edb6d4f7baec7e612d423834" title="Renvoie le temps courant.">temps_courant</a>();

  <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; present = eqn.<a class="code" href="classEquation__base.html#a5a1fce9487b9a8dd17020914100c2c89">inconnue</a>().<a class="code" href="classChamp__Inc.html#a28ef3d411d12cb5684ac5e799efb7d24" title="Appel a l&#39;objet sous-jacent Renvoie le tableau des valeurs au temps courant.">valeurs</a>();
  <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; intermediaire = eqn.<a class="code" href="classEquation__base.html#a5a1fce9487b9a8dd17020914100c2c89">inconnue</a>()-&gt;<a class="code" href="classChamp__Inc.html#a28ef3d411d12cb5684ac5e799efb7d24" title="Appel a l&#39;objet sous-jacent Renvoie le tableau des valeurs au temps courant.">valeurs</a>(temps_intermediaire);
  <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; <span class="keyword">final</span> = eqn.<a class="code" href="classEquation__base.html#a5a1fce9487b9a8dd17020914100c2c89">inconnue</a>()-&gt;<a class="code" href="classChamp__Inc.html#a28ef3d411d12cb5684ac5e799efb7d24" title="Appel a l&#39;objet sous-jacent Renvoie le tableau des valeurs au temps courant.">valeurs</a>(temps_final);

  <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a> dudt(present);

  <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a> delta(intermediaire);
  delta*=-1;

<span class="comment">// On impose les CLs Dirichlet au temps intermediaire.</span>
<span class="comment">// En effet, les operateurs de diffusion n&#39;utilisent que</span>
<span class="comment">// l&#39;inconnue et ne vont pas lire les CLs.</span>
<span class="comment">// Cela permet en particulier d&#39;avoir l&#39;egalite des flux en pb</span>
<span class="comment">// couple thermique VEF avec Chap_front_contact_VEF, meme avant convergence.</span>
<span class="comment">// WEC :  /!\ la vitesse au temps intermediaire</span>
<span class="comment">// n&#39;est pas forcement a divergence nulle.</span>
  eqn.<a class="code" href="classEquation__base.html#af265fe0ea30868eb2176a0c887e4efab" title="Renvoie la zone des conditions aux limite discretisee associee a l&#39;equation.">zone_Cl_dis</a>()-&gt;<a class="code" href="classZone__Cl__dis.html#a9a1b2c60317659659ff316f39fd27ed8" title="Appel a l&#39;objet sous-jacent. Impose les conditions aux limites a un temps donne du Champ_Inc...">imposer_cond_lim</a>(eqn.<a class="code" href="classEquation__base.html#a5a1fce9487b9a8dd17020914100c2c89">inconnue</a>(),temps_intermediaire);

<span class="comment">// Calcul de la derivee dudt pour la valeur intermediaire de l&#39;inconnue.</span>
<span class="comment">// Bidouille : Comme les operateurs prennent par defaut le present,</span>
<span class="comment">// on avance temporairement l&#39;inconnue.</span>

  eqn.<a class="code" href="classEquation__base.html#a5a1fce9487b9a8dd17020914100c2c89">inconnue</a>().<a class="code" href="classChamp__Inc.html#a30e1d6e21e00fd942e85d0f6469d9722" title="Appel a l&#39;objet sous-jacent Avance le temps courant du champ de i pas de temps.">avancer</a>();
  eqn.<a class="code" href="classEquation__base.html#a97aa87b0cf6205ef437a6774adf1bd47" title="Returns the time derivative of the unknown I of the equation: dI/dt = M-1*(sum(operators(I) + sources...">derivee_en_temps_inco</a>(dudt);
  eqn.<a class="code" href="classEquation__base.html#a5a1fce9487b9a8dd17020914100c2c89">inconnue</a>().<a class="code" href="classChamp__Inc.html#a241a2a375658a606c3d659600a991bb5" title="Appel a l&#39;objet sous-jacent Recule le temps courant du champ de i pas de temps.">reculer</a>();

<span class="comment">// Mise a jour des valeurs de l&#39;inconnue aux temps intermediaire et final</span>
<span class="comment">// intermediaire = present + dt_intermediaire * dudt;</span>
<span class="comment">// final =  present + dt_final * dudt;</span>
  intermediaire = dudt;
  intermediaire*= dt_intermediaire;
  intermediaire+= present;
  eqn.<a class="code" href="classEquation__base.html#af265fe0ea30868eb2176a0c887e4efab" title="Renvoie la zone des conditions aux limite discretisee associee a l&#39;equation.">zone_Cl_dis</a>().<a class="code" href="classZone__Cl__dis.html#a9a1b2c60317659659ff316f39fd27ed8" title="Appel a l&#39;objet sous-jacent. Impose les conditions aux limites a un temps donne du Champ_Inc...">imposer_cond_lim</a>(eqn.<a class="code" href="classEquation__base.html#a5a1fce9487b9a8dd17020914100c2c89">inconnue</a>(),temps_intermediaire);
  intermediaire.<a class="code" href="classDoubleVect.html#abfebbc2f685ce7bc4b80c720d7da9bf3">echange_espace_virtuel</a>();
  <span class="keyword">final</span> = dudt;
  <span class="keyword">final</span>*= dt_final;
  <span class="keyword">final</span>+= present;
  eqn.<a class="code" href="classEquation__base.html#af265fe0ea30868eb2176a0c887e4efab" title="Renvoie la zone des conditions aux limite discretisee associee a l&#39;equation.">zone_Cl_dis</a>().<a class="code" href="classZone__Cl__dis.html#a9a1b2c60317659659ff316f39fd27ed8" title="Appel a l&#39;objet sous-jacent. Impose les conditions aux limites a un temps donne du Champ_Inc...">imposer_cond_lim</a>(eqn.<a class="code" href="classEquation__base.html#a5a1fce9487b9a8dd17020914100c2c89">inconnue</a>(),temps_final);
  <span class="keyword">final</span>.echange_espace_virtuel();

  delta+=intermediaire; <span class="comment">//!&lt; delta = Contient u(n+1/2,p+1) - u(n+1/2,p)</span>
<span class="comment"></span>
<span class="comment">// Si l&#39;equation a diverge</span>
  <span class="keywordflow">if</span> (<a class="code" href="classSch__CN__iteratif.html#a5a4bd9e2782c8e8066b737d83feb09df" title="Indique si le calcul iteratif a diverge.">divergence</a>(present,intermediaire,delta,<a class="code" href="classSch__CN__iteratif.html#a12e6e86233c59d24175c78441f0e7046" title="Number of iterations done for the current time step.">iteration</a>))
    {
      converged=<span class="keyword">false</span>;
      <span class="keywordflow">return</span> <span class="keyword">false</span>;
    }

<span class="comment">// Si l&#39;equation a converge</span>
  <span class="keywordflow">if</span> (<a class="code" href="classSch__CN__iteratif.html#a0986d7724a3324ac4b4a86f1ad449c51" title="Indique si le calcul iteratif a converge. Critere de convergence utilise : || u(n+1,p+1) - u(n+1,p) || &lt; seuil * || u(n+1/2,p+1) || C&#39;est equivalent a || u(n+1,p) - u(n+1) || &lt; seuil * || (Id-(dt/2).(df/du))^-1 || * || u(n+1/2,p+1) || ou u(n+1) est la solution exacte en n+1, df/du est le lagrangien de f(u), pris en u(n+1/2) et les normes sont compatibles entre matrices et vecteurs (ici norme infinie).">convergence</a>(present,intermediaire,delta,<a class="code" href="classSch__CN__iteratif.html#a12e6e86233c59d24175c78441f0e7046" title="Number of iterations done for the current time step.">iteration</a>))
    {
      converged=<span class="keyword">true</span>;
      delta=<span class="keyword">final</span>;
      delta-=present;
      delta/=dt_final;
      <a class="code" href="classSchema__Temps__base.html#ae688058ec9592383f84aeb6de1d56158" title="//Actualisation de stationnaire_atteint_ et residu_ (critere residu_&lt;seuil_statio_)">update_critere_statio</a>(delta, eqn);
    }
  <span class="keywordflow">else</span>
    {
      <a class="code" href="classSchema__Temps__base.html#a0919fb0885a396e98f578047cc1cc5e3">set_stationnaire_atteint</a>()=0;
      converged=<span class="keyword">false</span>;
    }
  <span class="keywordflow">return</span> <span class="keyword">true</span>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a71f38a24b942bc119ea7850505cab649"></a><!-- doxytag: member="Sch_CN_iteratif::nb_valeurs_futures" ref="a71f38a24b942bc119ea7850505cab649" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Sch_CN_iteratif::nb_valeurs_futures </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Renvoie le nombre de valeurs temporelles futures.<br/>
Ici : n+1/2 et n+1 donc 2. </p>

<p>Implements <a class="el" href="classSchema__Temps__base.html#a9d24dd8112258e09c09a9b58c4b7e335">Schema_Temps_base</a>.</p>

<p>Definition at line <a class="el" href="Sch__CN__iteratif_8cpp_source.html#l00118">118</a> of file <a class="el" href="Sch__CN__iteratif_8cpp_source.html">Sch_CN_iteratif.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">return</span> 2;
}
</pre></div>
</div>
</div>
<a class="anchor" id="af4fc4f7fe8f53992f17065eacf86d2bd"></a><!-- doxytag: member="Sch_CN_iteratif::nb_valeurs_temporelles" ref="af4fc4f7fe8f53992f17065eacf86d2bd" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Sch_CN_iteratif::nb_valeurs_temporelles </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Renvoie le nombre de valeurs temporelles a conserver.<br/>
Ici : n, n+1/2 et n+1, donc 3. </p>

<p>Implements <a class="el" href="classSchema__Temps__base.html#acbe9f5266e4b4267a53fdbb9157718c5">Schema_Temps_base</a>.</p>

<p>Definition at line <a class="el" href="Sch__CN__iteratif_8cpp_source.html#l00110">110</a> of file <a class="el" href="Sch__CN__iteratif_8cpp_source.html">Sch_CN_iteratif.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">return</span> 3;
}
</pre></div>
</div>
</div>
<a class="anchor" id="af196b2dec8898ba995eba8cf2ea37b64"></a><!-- doxytag: member="Sch_CN_iteratif::printOn" ref="af196b2dec8898ba995eba8cf2ea37b64" args="(Sortie &amp;x) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSortie.html">Sortie</a> &amp; Sch_CN_iteratif::printOn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSortie.html">Sortie</a> &amp;&#160;</td>
          <td class="paramname"><em>os</em></td><td>)</td>
          <td> const<code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Surcharge <a class="el" href="classObjet__U.html#a68f520bd9ba3e848370861d6610720b5" title="Ecriture de l&#39;objet sur un flot de sortie Methode a surcharger.">Objet_U::printOn</a>(<a class="el" href="classSortie.html" title="Classe de base des flux de sortie. Elle sait ecrire des types simples&lt;br&gt;(entiers, flottants) et des Ob...">Sortie</a>&amp;)<br/>
Imprime le schema en temps sur un flot de sortie.<br/>
!! Attention n'est pas symetrique de la lecture !!<br/>
On ecrit les differents parametres du schema en temps. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="classSortie.html" title="Classe de base des flux de sortie. Elle sait ecrire des types simples&lt;br&gt;(entiers, flottants) et des Ob...">Sortie</a>&amp;<br/>
 Signification: le flot de sortie modifie<br/>
 Contraintes: </dd></dl>

<p>Reimplemented from <a class="el" href="classSchema__Temps__base.html#acc4b58bf5e915fc12e5a1f331fc724b3">Schema_Temps_base</a>.</p>

<p>Reimplemented in <a class="el" href="classSch__CN__EX__iteratif.html#a068ee013cbe548f8e64394e0b88a7a6d">Sch_CN_EX_iteratif</a>.</p>

<p>Definition at line <a class="el" href="Sch__CN__iteratif_8cpp_source.html#l00034">34</a> of file <a class="el" href="Sch__CN__iteratif_8cpp_source.html">Sch_CN_iteratif.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">return</span>  <a class="code" href="classSch__CN__iteratif.html#af196b2dec8898ba995eba8cf2ea37b64" title="Surcharge Objet_U::printOn(Sortie&amp;) Imprime le schema en temps sur un flot de sortie. !! Attention n&#39;est pas symetrique de la lecture !! On ecrit les differents parametres du schema en temps.">Schema_Temps_base::printOn</a>(s);
}
</pre></div>
</div>
</div>
<a class="anchor" id="a368cc7bc7444d872827c52982c7a8b76"></a><!-- doxytag: member="Sch_CN_iteratif::readOn" ref="a368cc7bc7444d872827c52982c7a8b76" args="(Entree &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEntree.html">Entree</a> &amp; Sch_CN_iteratif::readOn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEntree.html">Entree</a> &amp;&#160;</td>
          <td class="paramname"><em>is</em></td><td>)</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Lecture d'un schema en temps a partir d'un flot d'entree.<br/>
Le format de lecture attendu est le suivant:<br/>
{<br/>
[<a class="el" href="classMotcle.html" title="Une chaine de caractere (Nom) en majuscules.">Motcle</a> valeur_reelle]<br/>
}<br/>
Les mots clefs peuvent etre:<br/>
tinit, tmax, nb_pas_dt_max, dt_min, dt_max,<br/>
dt_sauv, dt_impr, facsec, seuil_statio,. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="classEntree.html" title="Classe de definition des operateurs et methodes pour toute lecture dans un flot d&#39;entree (fichier...">Entree</a>&amp;<br/>
 Signification: le flot d'entree modifie<br/>
 Contraintes: </dd></dl>

<p>Reimplemented from <a class="el" href="classSchema__Temps__base.html#ae0e4d857b7bc4684c70386177330cdf0">Schema_Temps_base</a>.</p>

<p>Reimplemented in <a class="el" href="classSch__CN__EX__iteratif.html#ab90ed6e94ff2ad5357bf511c6d333490">Sch_CN_EX_iteratif</a>.</p>

<p>Definition at line <a class="el" href="Sch__CN__iteratif_8cpp_source.html#l00040">40</a> of file <a class="el" href="Sch__CN__iteratif_8cpp_source.html">Sch_CN_iteratif.cpp</a>.</p>

<p>References <a class="el" href="Sch__CN__iteratif_8h_source.html#l00102">facsec_max</a>, <a class="el" href="Sch__CN__iteratif_8h_source.html#l00101">niter_avg</a>, <a class="el" href="Sch__CN__iteratif_8h_source.html#l00100">niter_max</a>, <a class="el" href="Sch__CN__iteratif_8h_source.html#l00099">niter_min</a>, and <a class="el" href="Sch__CN__iteratif_8h_source.html#l00098">seuil</a>.</p>
<div class="fragment"><pre class="fragment">{
  <a class="code" href="classSch__CN__iteratif.html#ab1627c25875c72516ce79c044ea8c38e" title="To determine convergence.">seuil</a>=1.e-3;
  <a class="code" href="classSch__CN__iteratif.html#a5afdda57e3a767717a0e2dac900f8490" title="Minimum number of iterations (before, continue to iterate)">niter_min</a>=2;
  <a class="code" href="classSch__CN__iteratif.html#a4b93c13f52ae52886a176c7df396a2a8" title="Maximum number of iterations (after, considered as not convergent)">niter_max</a>=6;
  <a class="code" href="classSch__CN__iteratif.html#a9467b12b7d6a5f2c3b7eb48f3e0c176c" title="Average number of iterations wanted (facsec adjusted to fit that number)">niter_avg</a>=3;
  <a class="code" href="classSch__CN__iteratif.html#ae7e2aeaa5d411a5b2e746db7fc40581f" title="Maximum facsec (not to miss the physics)">facsec_max</a>=2;

  <a class="code" href="classSch__CN__iteratif.html#a368cc7bc7444d872827c52982c7a8b76" title="Lecture d&#39;un schema en temps a partir d&#39;un flot d&#39;entree. Le format de lecture attendu est le suivant...">Schema_Temps_base::readOn</a>(s) ;

  <span class="keywordflow">return</span> s;
}
</pre></div>
</div>
</div>
<a class="anchor" id="ab52c843e6a5cf940daa7f5abaef0920c"></a><!-- doxytag: member="Sch_CN_iteratif::self_cast" ref="ab52c843e6a5cf940daa7f5abaef0920c" args="(const Objet_U &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSch__CN__iteratif.html">Sch_CN_iteratif</a> &amp; Sch_CN_iteratif::self_cast </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classObjet__U.html">Objet_U</a> &amp;&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>methode ajoutee pour caster en python </p>

<p>Reimplemented from <a class="el" href="classSchema__Temps__base.html#a96743df6a667bb804829411d1db7f8ab">Schema_Temps_base</a>.</p>

<p>Reimplemented in <a class="el" href="classSch__CN__EX__iteratif.html#afd3663139a9df1f47e2b583a8b8c22fe">Sch_CN_EX_iteratif</a>.</p>

<p>Definition at line <a class="el" href="Sch__CN__iteratif_8cpp_source.html#l00031">31</a> of file <a class="el" href="Sch__CN__iteratif_8cpp_source.html">Sch_CN_iteratif.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="af4f2c2bbc60f7929232d44f4dcf73f85"></a><!-- doxytag: member="Sch_CN_iteratif::self_cast" ref="af4f2c2bbc60f7929232d44f4dcf73f85" args="(Objet_U &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSch__CN__iteratif.html">Sch_CN_iteratif</a> &amp; Sch_CN_iteratif::self_cast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classObjet__U.html">Objet_U</a> &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="classSchema__Temps__base.html#a67d4fcae915b09a905100547ed86b106">Schema_Temps_base</a>.</p>

<p>Reimplemented in <a class="el" href="classSch__CN__EX__iteratif.html#afb96ee43f992ae8ddf47ae453c934e12">Sch_CN_EX_iteratif</a>.</p>

<p>Definition at line <a class="el" href="Sch__CN__iteratif_8cpp_source.html#l00031">31</a> of file <a class="el" href="Sch__CN__iteratif_8cpp_source.html">Sch_CN_iteratif.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a15f385781f069e7dc343bef216084f5b"></a><!-- doxytag: member="Sch_CN_iteratif::set_param" ref="a15f385781f069e7dc343bef216084f5b" args="(Param &amp;titi)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Sch_CN_iteratif::set_param </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParam.html">Param</a> &amp;&#160;</td>
          <td class="paramname"><em>titi</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="classSchema__Temps__base.html#a40580afb2766399945c3bcae105be78e">Schema_Temps_base</a>.</p>

<p>Reimplemented in <a class="el" href="classSch__CN__EX__iteratif.html#aa7a02b86b52120dc2afdb162feaab604">Sch_CN_EX_iteratif</a>.</p>

<p>Definition at line <a class="el" href="Sch__CN__iteratif_8cpp_source.html#l00088">88</a> of file <a class="el" href="Sch__CN__iteratif_8cpp_source.html">Sch_CN_iteratif.cpp</a>.</p>

<p>References <a class="el" href="Param_8cpp_source.html#l00386">Param::ajouter()</a>, <a class="el" href="Sch__CN__iteratif_8h_source.html#l00102">facsec_max</a>, <a class="el" href="Sch__CN__iteratif_8h_source.html#l00101">niter_avg</a>, <a class="el" href="Sch__CN__iteratif_8h_source.html#l00100">niter_max</a>, <a class="el" href="Sch__CN__iteratif_8h_source.html#l00099">niter_min</a>, and <a class="el" href="Sch__CN__iteratif_8h_source.html#l00098">seuil</a>.</p>
<div class="fragment"><pre class="fragment">{
  param.ajouter(<span class="stringliteral">&quot;seuil&quot;</span>,&amp;<a class="code" href="classSch__CN__iteratif.html#ab1627c25875c72516ce79c044ea8c38e" title="To determine convergence.">seuil</a>);
  param.ajouter(<span class="stringliteral">&quot;niter_min&quot;</span>,&amp;<a class="code" href="classSch__CN__iteratif.html#a5afdda57e3a767717a0e2dac900f8490" title="Minimum number of iterations (before, continue to iterate)">niter_min</a>);
  param.ajouter(<span class="stringliteral">&quot;niter_max&quot;</span>,&amp;<a class="code" href="classSch__CN__iteratif.html#a4b93c13f52ae52886a176c7df396a2a8" title="Maximum number of iterations (after, considered as not convergent)">niter_max</a>);
  param.ajouter(<span class="stringliteral">&quot;niter_avg&quot;</span>,&amp;<a class="code" href="classSch__CN__iteratif.html#a9467b12b7d6a5f2c3b7eb48f3e0c176c" title="Average number of iterations wanted (facsec adjusted to fit that number)">niter_avg</a>);
  param.ajouter(<span class="stringliteral">&quot;facsec_max&quot;</span>,&amp;<a class="code" href="classSch__CN__iteratif.html#ae7e2aeaa5d411a5b2e746db7fc40581f" title="Maximum facsec (not to miss the physics)">facsec_max</a>);
  <a class="code" href="classSch__CN__iteratif.html#a15f385781f069e7dc343bef216084f5b">Schema_Temps_base::set_param</a>(param);
}
</pre></div>
</div>
</div>
<a class="anchor" id="ad34d2d173b546f6f239b8f3a3faedf39"></a><!-- doxytag: member="Sch_CN_iteratif::taille_memoire" ref="ad34d2d173b546f6f239b8f3a3faedf39" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned Sch_CN_iteratif::taille_memoire </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implements <a class="el" href="classObjet__U.html#a0ee0946339f09a2c73c09fcda71c3be2">Objet_U</a>.</p>

<p>Reimplemented in <a class="el" href="classSch__CN__EX__iteratif.html#a7987c0489335ac2335775c4c2f90ee5d">Sch_CN_EX_iteratif</a>.</p>

<p>Definition at line <a class="el" href="Sch__CN__iteratif_8cpp_source.html#l00031">31</a> of file <a class="el" href="Sch__CN__iteratif_8cpp_source.html">Sch_CN_iteratif.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a25915a5d6b52705f709025aca71f489d"></a><!-- doxytag: member="Sch_CN_iteratif::temps_defaut" ref="a25915a5d6b52705f709025aca71f489d" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Sch_CN_iteratif::temps_defaut </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Renvoie le temps que doivent utiliser les champs a<br/>
l'appel de valeurs()<br/>
Ici : t(n+1/2) </p>

<p>Implements <a class="el" href="classSchema__Temps__base.html#ade057f30f3f9cf15a3e1feb74dd36058">Schema_Temps_base</a>.</p>

<p>Definition at line <a class="el" href="Sch__CN__iteratif_8cpp_source.html#l00138">138</a> of file <a class="el" href="Sch__CN__iteratif_8cpp_source.html">Sch_CN_iteratif.cpp</a>.</p>

<p>References <a class="el" href="Sch__CN__iteratif_8cpp_source.html#l00125">temps_futur()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">return</span> <a class="code" href="classSch__CN__iteratif.html#ac28599b004c8f4294d97ec104eaabe42" title="Renvoie le le temps a la i-eme valeur future.">temps_futur</a>(1);
}
</pre></div>
</div>
</div>
<a class="anchor" id="ac28599b004c8f4294d97ec104eaabe42"></a><!-- doxytag: member="Sch_CN_iteratif::temps_futur" ref="ac28599b004c8f4294d97ec104eaabe42" args="(int i) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Sch_CN_iteratif::temps_futur </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Renvoie le le temps a la i-eme valeur future. </p>

<p>Implements <a class="el" href="classSchema__Temps__base.html#a46d916b7db340c822e87edf21ab77c00">Schema_Temps_base</a>.</p>

<p>Definition at line <a class="el" href="Sch__CN__iteratif_8cpp_source.html#l00125">125</a> of file <a class="el" href="Sch__CN__iteratif_8cpp_source.html">Sch_CN_iteratif.cpp</a>.</p>

<p>References <a class="el" href="Schema__Temps__base_8h_source.html#l00576">Schema_Temps_base::pas_de_temps()</a>, and <a class="el" href="Schema__Temps__base_8h_source.html#l00676">Schema_Temps_base::temps_courant()</a>.</p>

<p>Referenced by <a class="el" href="Sch__CN__iteratif_8cpp_source.html#l00257">iterateTimeStepOnEquation()</a>, <a class="el" href="Sch__CN__EX__iteratif_8cpp_source.html#l00096">Sch_CN_EX_iteratif::iterateTimeStepOnNS()</a>, <a class="el" href="Sch__CN__EX__iteratif_8cpp_source.html#l00184">Sch_CN_EX_iteratif::iterateTimeStepOnOther()</a>, and <a class="el" href="Sch__CN__iteratif_8cpp_source.html#l00138">temps_defaut()</a>.</p>
<div class="fragment"><pre class="fragment">{
  assert(i&gt;0 &amp;&amp; i&lt;=2);
  <span class="keywordflow">if</span> (i==2)
    <span class="keywordflow">return</span> <a class="code" href="classSchema__Temps__base.html#a5054df01edb6d4f7baec7e612d423834" title="Renvoie le temps courant.">temps_courant</a>()+<a class="code" href="classSchema__Temps__base.html#a0e4f67ef6086c09434ddc161668077b2" title="Renvoie le pas de temps (delta_t) courant.">pas_de_temps</a>();
  <span class="keywordflow">else</span>
    <span class="keywordflow">return</span> <a class="code" href="classSchema__Temps__base.html#a5054df01edb6d4f7baec7e612d423834" title="Renvoie le temps courant.">temps_courant</a>()+<a class="code" href="classSchema__Temps__base.html#a0e4f67ef6086c09434ddc161668077b2" title="Renvoie le pas de temps (delta_t) courant.">pas_de_temps</a>()/2;
}
</pre></div>
</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="ae7e2aeaa5d411a5b2e746db7fc40581f"></a><!-- doxytag: member="Sch_CN_iteratif::facsec_max" ref="ae7e2aeaa5d411a5b2e746db7fc40581f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classSch__CN__iteratif.html#ae7e2aeaa5d411a5b2e746db7fc40581f">Sch_CN_iteratif::facsec_max</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Maximum facsec (not to miss the physics) </p>

<p>Definition at line <a class="el" href="Sch__CN__iteratif_8h_source.html#l00102">102</a> of file <a class="el" href="Sch__CN__iteratif_8h_source.html">Sch_CN_iteratif.h</a>.</p>

<p>Referenced by <a class="el" href="Sch__CN__iteratif_8cpp_source.html#l00053">ajuster_facsec()</a>, <a class="el" href="Sch__CN__EX__iteratif_8cpp_source.html#l00264">Sch_CN_EX_iteratif::ajuster_facsec()</a>, <a class="el" href="Sch__CN__iteratif_8cpp_source.html#l00040">readOn()</a>, <a class="el" href="Sch__CN__EX__iteratif_8cpp_source.html#l00039">Sch_CN_EX_iteratif::readOn()</a>, and <a class="el" href="Sch__CN__iteratif_8cpp_source.html#l00088">set_param()</a>.</p>

</div>
</div>
<a class="anchor" id="a4fb4b6044915a602bd98632bf07e5e67"></a><!-- doxytag: member="Sch_CN_iteratif::info_obj" ref="a4fb4b6044915a602bd98632bf07e5e67" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classType__info.html">Type_info</a> <a class="el" href="classSch__CN__iteratif.html#a4fb4b6044915a602bd98632bf07e5e67">Sch_CN_iteratif::info_obj</a><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="classSchema__Temps__base.html#aa1a13529c963ca0e4f5b8bd5bd63e914">Schema_Temps_base</a>.</p>

<p>Reimplemented in <a class="el" href="classSch__CN__EX__iteratif.html#a3f2942d38780a17d1da014cdd148469d">Sch_CN_EX_iteratif</a>.</p>

<p>Definition at line <a class="el" href="Sch__CN__iteratif_8h_source.html#l00059">59</a> of file <a class="el" href="Sch__CN__iteratif_8h_source.html">Sch_CN_iteratif.h</a>.</p>

</div>
</div>
<a class="anchor" id="a12e6e86233c59d24175c78441f0e7046"></a><!-- doxytag: member="Sch_CN_iteratif::iteration" ref="a12e6e86233c59d24175c78441f0e7046" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classSch__CN__iteratif.html#a12e6e86233c59d24175c78441f0e7046">Sch_CN_iteratif::iteration</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Number of iterations done for the current time step. </p>

<p>Definition at line <a class="el" href="Sch__CN__iteratif_8h_source.html#l00105">105</a> of file <a class="el" href="Sch__CN__iteratif_8h_source.html">Sch_CN_iteratif.h</a>.</p>

<p>Referenced by <a class="el" href="Sch__CN__iteratif_8cpp_source.html#l00149">initTimeStep()</a>, <a class="el" href="Sch__CN__iteratif_8cpp_source.html#l00164">iterateTimeStep()</a>, <a class="el" href="Sch__CN__iteratif_8cpp_source.html#l00257">iterateTimeStepOnEquation()</a>, and <a class="el" href="Sch__CN__EX__iteratif_8cpp_source.html#l00096">Sch_CN_EX_iteratif::iterateTimeStepOnNS()</a>.</p>

</div>
</div>
<a class="anchor" id="ad7bc392b49ba97e340e165f4372f86a9"></a><!-- doxytag: member="Sch_CN_iteratif::last_facsec" ref="ad7bc392b49ba97e340e165f4372f86a9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classSch__CN__iteratif.html#ad7bc392b49ba97e340e165f4372f86a9">Sch_CN_iteratif::last_facsec</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>facsec at the beginning of time step resolution, to avoid changing facsec several times for the same time step. </p>

<p>Definition at line <a class="el" href="Sch__CN__iteratif_8h_source.html#l00106">106</a> of file <a class="el" href="Sch__CN__iteratif_8h_source.html">Sch_CN_iteratif.h</a>.</p>

<p>Referenced by <a class="el" href="Sch__CN__iteratif_8cpp_source.html#l00053">ajuster_facsec()</a>, <a class="el" href="Sch__CN__EX__iteratif_8cpp_source.html#l00264">Sch_CN_EX_iteratif::ajuster_facsec()</a>, <a class="el" href="Sch__CN__iteratif_8cpp_source.html#l00149">initTimeStep()</a>, and <a class="el" href="Sch__CN__iteratif_8cpp_source.html#l00164">iterateTimeStep()</a>.</p>

</div>
</div>
<a class="anchor" id="a9467b12b7d6a5f2c3b7eb48f3e0c176c"></a><!-- doxytag: member="Sch_CN_iteratif::niter_avg" ref="a9467b12b7d6a5f2c3b7eb48f3e0c176c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classSch__CN__iteratif.html#a9467b12b7d6a5f2c3b7eb48f3e0c176c">Sch_CN_iteratif::niter_avg</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Average number of iterations wanted (facsec adjusted to fit that number) </p>

<p>Definition at line <a class="el" href="Sch__CN__iteratif_8h_source.html#l00101">101</a> of file <a class="el" href="Sch__CN__iteratif_8h_source.html">Sch_CN_iteratif.h</a>.</p>

<p>Referenced by <a class="el" href="Sch__CN__iteratif_8cpp_source.html#l00164">iterateTimeStep()</a>, <a class="el" href="Sch__CN__iteratif_8cpp_source.html#l00040">readOn()</a>, <a class="el" href="Sch__CN__EX__iteratif_8cpp_source.html#l00039">Sch_CN_EX_iteratif::readOn()</a>, and <a class="el" href="Sch__CN__iteratif_8cpp_source.html#l00088">set_param()</a>.</p>

</div>
</div>
<a class="anchor" id="a4b93c13f52ae52886a176c7df396a2a8"></a><!-- doxytag: member="Sch_CN_iteratif::niter_max" ref="a4b93c13f52ae52886a176c7df396a2a8" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classSch__CN__iteratif.html#a4b93c13f52ae52886a176c7df396a2a8">Sch_CN_iteratif::niter_max</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Maximum number of iterations (after, considered as not convergent) </p>

<p>Definition at line <a class="el" href="Sch__CN__iteratif_8h_source.html#l00100">100</a> of file <a class="el" href="Sch__CN__iteratif_8h_source.html">Sch_CN_iteratif.h</a>.</p>

<p>Referenced by <a class="el" href="Sch__CN__iteratif_8cpp_source.html#l00164">iterateTimeStep()</a>, <a class="el" href="Sch__CN__iteratif_8cpp_source.html#l00040">readOn()</a>, <a class="el" href="Sch__CN__EX__iteratif_8cpp_source.html#l00039">Sch_CN_EX_iteratif::readOn()</a>, and <a class="el" href="Sch__CN__iteratif_8cpp_source.html#l00088">set_param()</a>.</p>

</div>
</div>
<a class="anchor" id="a5afdda57e3a767717a0e2dac900f8490"></a><!-- doxytag: member="Sch_CN_iteratif::niter_min" ref="a5afdda57e3a767717a0e2dac900f8490" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classSch__CN__iteratif.html#a5afdda57e3a767717a0e2dac900f8490">Sch_CN_iteratif::niter_min</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Minimum number of iterations (before, continue to iterate) </p>

<p>Definition at line <a class="el" href="Sch__CN__iteratif_8h_source.html#l00099">99</a> of file <a class="el" href="Sch__CN__iteratif_8h_source.html">Sch_CN_iteratif.h</a>.</p>

<p>Referenced by <a class="el" href="Sch__CN__iteratif_8cpp_source.html#l00164">iterateTimeStep()</a>, <a class="el" href="Sch__CN__iteratif_8cpp_source.html#l00040">readOn()</a>, <a class="el" href="Sch__CN__EX__iteratif_8cpp_source.html#l00039">Sch_CN_EX_iteratif::readOn()</a>, and <a class="el" href="Sch__CN__iteratif_8cpp_source.html#l00088">set_param()</a>.</p>

</div>
</div>
<a class="anchor" id="ab1627c25875c72516ce79c044ea8c38e"></a><!-- doxytag: member="Sch_CN_iteratif::seuil" ref="ab1627c25875c72516ce79c044ea8c38e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classSch__CN__iteratif.html#ab1627c25875c72516ce79c044ea8c38e">Sch_CN_iteratif::seuil</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>To determine convergence. </p>

<p>Definition at line <a class="el" href="Sch__CN__iteratif_8h_source.html#l00098">98</a> of file <a class="el" href="Sch__CN__iteratif_8h_source.html">Sch_CN_iteratif.h</a>.</p>

<p>Referenced by <a class="el" href="Sch__CN__iteratif_8cpp_source.html#l00390">convergence()</a>, <a class="el" href="Sch__CN__iteratif_8cpp_source.html#l00040">readOn()</a>, <a class="el" href="Sch__CN__EX__iteratif_8cpp_source.html#l00039">Sch_CN_EX_iteratif::readOn()</a>, and <a class="el" href="Sch__CN__iteratif_8cpp_source.html#l00088">set_param()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/ThHyd/Schemas_Temps/<a class="el" href="Sch__CN__iteratif_8h_source.html">Sch_CN_iteratif.h</a></li>
<li>src/ThHyd/Schemas_Temps/<a class="el" href="Sch__CN__iteratif_8cpp_source.html">Sch_CN_iteratif.cpp</a></li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Tue Dec 14 2021 19:37:49 for TRUST by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
