<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>TRUST: src/VDF/Solveurs/Assembleur_P_VDF.cpp Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">TRUST&#160;<span id="projectnumber">1.8.4</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
<div class="header">
  <div class="headertitle">
<div class="title">src/VDF/Solveurs/Assembleur_P_VDF.cpp</div>  </div>
</div>
<div class="contents">
<a href="Assembleur__P__VDF_8cpp.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/****************************************************************************</span>
<a name="l00002"></a>00002 <span class="comment">* Copyright (c) 2019, CEA</span>
<a name="l00003"></a>00003 <span class="comment">* All rights reserved.</span>
<a name="l00004"></a>00004 <span class="comment">*</span>
<a name="l00005"></a>00005 <span class="comment">* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</span>
<a name="l00006"></a>00006 <span class="comment">* 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.</span>
<a name="l00007"></a>00007 <span class="comment">* 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.</span>
<a name="l00008"></a>00008 <span class="comment">* 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.</span>
<a name="l00009"></a>00009 <span class="comment">*</span>
<a name="l00010"></a>00010 <span class="comment">* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.</span>
<a name="l00011"></a>00011 <span class="comment">* IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;</span>
<a name="l00012"></a>00012 <span class="comment">* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>
<a name="l00013"></a>00013 <span class="comment">*</span>
<a name="l00014"></a>00014 <span class="comment">*****************************************************************************/</span>
<a name="l00015"></a>00015 <span class="comment">//</span>
<a name="l00016"></a>00016 <span class="comment">// </span>
<a name="l00017"></a>00017 <span class="comment">// File:        Assembleur_P_VDF.cpp</span>
<a name="l00018"></a>00018 <span class="comment">// Directory:   $TRUST_ROOT/src/VDF/Solveurs</span>
<a name="l00019"></a>00019 <span class="comment">// Version:     /main/32</span>
<a name="l00020"></a>00020 <span class="comment">// </span>
<a name="l00021"></a>00021 <span class="comment">//</span>
<a name="l00022"></a>00022 
<a name="l00023"></a>00023 <span class="preprocessor">#include &lt;<a class="code" href="Assembleur__P__VDF_8h.html">Assembleur_P_VDF.h</a>&gt;</span>
<a name="l00024"></a>00024 <span class="preprocessor">#include &lt;<a class="code" href="Zone__Cl__VDF_8h.html">Zone_Cl_VDF.h</a>&gt;</span>
<a name="l00025"></a>00025 <span class="preprocessor">#include &lt;<a class="code" href="Zone__VDF_8h.html">Zone_VDF.h</a>&gt;</span>
<a name="l00026"></a>00026 <span class="preprocessor">#include &lt;<a class="code" href="Periodique_8h.html">Periodique.h</a>&gt;</span>
<a name="l00027"></a>00027 <span class="preprocessor">#include &lt;<a class="code" href="Symetrie_8h.html">Symetrie.h</a>&gt;</span>
<a name="l00028"></a>00028 <span class="preprocessor">#include &lt;<a class="code" href="Neumann__sortie__libre_8h.html">Neumann_sortie_libre.h</a>&gt;</span>
<a name="l00029"></a>00029 <span class="preprocessor">#include &lt;<a class="code" href="Entree__fluide__vitesse__imposee_8h.html">Entree_fluide_vitesse_imposee.h</a>&gt;</span>
<a name="l00030"></a>00030 <span class="preprocessor">#include &lt;<a class="code" href="Dirichlet__paroi__fixe_8h.html">Dirichlet_paroi_fixe.h</a>&gt;</span>
<a name="l00031"></a>00031 <span class="preprocessor">#include &lt;<a class="code" href="Dirichlet__paroi__defilante_8h.html">Dirichlet_paroi_defilante.h</a>&gt;</span>
<a name="l00032"></a>00032 <span class="preprocessor">#include &lt;<a class="code" href="Champ__front__instationnaire__base_8h.html">Champ_front_instationnaire_base.h</a>&gt;</span>
<a name="l00033"></a>00033 <span class="preprocessor">#include &lt;<a class="code" href="Champ__front__var__instationnaire_8h.html">Champ_front_var_instationnaire.h</a>&gt;</span>
<a name="l00034"></a>00034 <span class="preprocessor">#include &lt;<a class="code" href="Matrice__Bloc_8h.html">Matrice_Bloc.h</a>&gt;</span>
<a name="l00035"></a>00035 <span class="preprocessor">#include &lt;<a class="code" href="Debog_8h.html">Debog.h</a>&gt;</span>
<a name="l00036"></a>00036 <span class="preprocessor">#include &lt;<a class="code" href="Option__VDF_8h.html">Option_VDF.h</a>&gt;</span>
<a name="l00037"></a>00037 <span class="preprocessor">#include &lt;<a class="code" href="Champ__Fonc__Face_8h.html">Champ_Fonc_Face.h</a>&gt;</span>
<a name="l00038"></a>00038 <span class="preprocessor">#include &lt;<a class="code" href="Matrice__Morse__Sym_8h.html">Matrice_Morse_Sym.h</a>&gt;</span>
<a name="l00039"></a>00039 
<a name="l00040"></a><a class="code" href="Assembleur__P__VDF_8cpp.html#ac86b4af7f447a8a08201b34164c3231b">00040</a> <a class="code" href="Declare__Inst_8h.html#afcab3f7633508e92f2077d767e19bc60">Implemente_instanciable_sans_constructeur</a>(<a class="code" href="classAssembleur__P__VDF.html">Assembleur_P_VDF</a>,<span class="stringliteral">&quot;Assembleur_P_VDF&quot;</span>,<a class="code" href="classAssembleur__base.html">Assembleur_base</a>);
<a name="l00041"></a>00041 
<a name="l00042"></a><a class="code" href="classAssembleur__P__VDF.html#af7a5bf2f0a8a8f6ba21650a19c3dc7f1">00042</a> <a class="code" href="classAssembleur__P__VDF.html#af7a5bf2f0a8a8f6ba21650a19c3dc7f1">Assembleur_P_VDF::Assembleur_P_VDF</a>() :
<a name="l00043"></a>00043   has_P_ref(0)
<a name="l00044"></a>00044 {
<a name="l00045"></a>00045 }
<a name="l00046"></a>00046 
<a name="l00047"></a><a class="code" href="classAssembleur__P__VDF.html#a2b5c25eb00889312bb6e6dc92e1d2616">00047</a> <a class="code" href="classSortie.html" title="Classe de base des flux de sortie. Elle sait ecrire des types simples&lt;br&gt;(entiers, flottants) et des Ob...">Sortie</a>&amp; <a class="code" href="classAssembleur__P__VDF.html#a2b5c25eb00889312bb6e6dc92e1d2616" title="Ecriture de l&#39;objet sur un flot de sortie Methode a surcharger.">Assembleur_P_VDF::printOn</a>(<a class="code" href="classSortie.html" title="Classe de base des flux de sortie. Elle sait ecrire des types simples&lt;br&gt;(entiers, flottants) et des Ob...">Sortie</a>&amp; s )<span class="keyword"> const</span>
<a name="l00048"></a>00048 <span class="keyword"></span>{
<a name="l00049"></a>00049   <span class="keywordflow">return</span> s &lt;&lt; <a class="code" href="classObjet__U.html#aa58e9a81c0ddc2c1149053b8f96698ac" title="renvoie la chaine identifiant la classe.">que_suis_je</a>() &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; <a class="code" href="classObjet__U.html#a70413a8785d36bf5105fced1c89d0d2b" title="Donne le nom de l&#39;Objet_U Methode a surcharger : renvoie &quot;neant&quot; dans cette implementation.">le_nom</a>() ;
<a name="l00050"></a>00050 }
<a name="l00051"></a>00051 
<a name="l00052"></a><a class="code" href="classAssembleur__P__VDF.html#adba7dcdab645b9099b6134d74189677b">00052</a> <a class="code" href="classEntree.html" title="Classe de definition des operateurs et methodes pour toute lecture dans un flot d&#39;entree (fichier...">Entree</a>&amp; <a class="code" href="classAssembleur__P__VDF.html#adba7dcdab645b9099b6134d74189677b" title="Lecture d&#39;un Objet_U sur un flot d&#39;entree Methode a surcharger.">Assembleur_P_VDF::readOn</a>(<a class="code" href="classEntree.html" title="Classe de definition des operateurs et methodes pour toute lecture dans un flot d&#39;entree (fichier...">Entree</a>&amp; s )
<a name="l00053"></a>00053 {
<a name="l00054"></a>00054   <span class="keywordflow">return</span> <a class="code" href="classAssembleur__P__VDF.html#adba7dcdab645b9099b6134d74189677b" title="Lecture d&#39;un Objet_U sur un flot d&#39;entree Methode a surcharger.">Assembleur_base::readOn</a>(s);
<a name="l00055"></a>00055 }
<a name="l00056"></a>00056 
<a name="l00057"></a>00057 <span class="comment">//</span>
<a name="l00058"></a>00058 <span class="comment">//</span>
<a name="l00059"></a>00059 <span class="comment">//</span>
<a name="l00060"></a>00060 <span class="comment">//</span>
<a name="l00061"></a>00061 <span class="comment">//</span>
<a name="l00062"></a>00062 <span class="comment">//</span>
<a name="l00063"></a>00063 <span class="comment">//</span><span class="comment"></span>
<a name="l00064"></a>00064 <span class="comment">//! Remplit le tableau faces avec la liste des indices des faces periodiques&lt;br&gt;dans le tableau faces_voisins. Chaque face periodique figure deux fois&lt;br&gt;dans faces_voisins (a chaque face correspond la face opposee). On ne&lt;br&gt;met dans le tableau faces que celle des deux qui a l&#39;indice le + petit&lt;br&gt;dans la liste des faces de chaque bord periodique.&lt;br&gt;Valeur de retour:&lt;br&gt;nombre de faces periodiques (egal a la taille du tableau faces).</span>
<a name="l00065"></a><a class="code" href="classAssembleur__P__VDF.html#a48da6c5fc5769465a659da41fab00812">00065</a> <span class="comment"></span><span class="keywordtype">int</span> <a class="code" href="classAssembleur__P__VDF.html#a48da6c5fc5769465a659da41fab00812" title="Remplit le tableau faces avec la liste des indices des faces periodiques dans le tableau faces_voisin...">Assembleur_P_VDF::liste_faces_periodiques</a>(<a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; faces)
<a name="l00066"></a>00066 {
<a name="l00067"></a>00067 <span class="comment">// On commence par surestimer largement la taille du tableau :</span>
<a name="l00068"></a>00068 <span class="comment">// nombre de faces de bord</span>
<a name="l00069"></a>00069   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_faces_bord = <a class="code" href="classAssembleur__P__VDF.html#a4ce1358c35e162057c7968aa583cd581">la_zone_VDF</a>.<a class="code" href="classRef__Zone__VDF.html#a84151da4db745d02791d6246e3682b67">valeur</a>().<a class="code" href="classZone__VF.html#a8815e2276637c0db23868f043dc43e58" title="renvoie le nombre de faces sur lesquelles sont appliquees les conditions limites : bords...">nb_faces_bord</a>();
<a name="l00070"></a>00070   faces.<a class="code" href="classArrOfInt.html#a9b3afbb46b16870dbd36236c8935b535">resize_array</a>(nb_faces_bord);
<a name="l00071"></a>00071 
<a name="l00072"></a>00072 <span class="comment">// Recherche des faces periodiques dans les conditions aux limites:</span>
<a name="l00073"></a>00073   <span class="keyword">const</span> <a class="code" href="classConds__lim.html">Conds_lim</a>&amp; les_cl = <a class="code" href="classAssembleur__P__VDF.html#a0b984a6831f2750865e12296e5e07a2b">la_zone_Cl_VDF</a>.<a class="code" href="classRef__Zone__Cl__VDF.html#a1e655604e840cda5b393e45f975b73ff">valeur</a>().<a class="code" href="classZone__Cl__dis__base.html#af75e0ed7786863e4d333bfb29d67c323" title="Renvoie la i-ieme condition aux limites. (version const)">les_conditions_limites</a>();
<a name="l00074"></a>00074   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_cl = les_cl.<a class="code" href="classvect__impl.html#a78155bfbd6b61f4710b9830641ed1694">size</a>();
<a name="l00075"></a>00075   <span class="keywordtype">int</span> nb_faces_periodiques = 0;
<a name="l00076"></a>00076   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> num_cl = 0; num_cl &lt; nb_cl; num_cl++)
<a name="l00077"></a>00077     {
<a name="l00078"></a>00078       <span class="keyword">const</span> <a class="code" href="classCond__lim__base.html" title="classe Cond_lim_base Classe de base pour la hierarchie des classes qui representent les differentes c...">Cond_lim_base</a>&amp; la_cl = les_cl[num_cl].valeur();
<a name="l00079"></a>00079 <span class="comment">// Selectionne uniquement les conditions Periodique</span>
<a name="l00080"></a>00080       <span class="keywordflow">if</span> ( ! <a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>,la_cl))
<a name="l00081"></a>00081         <span class="keywordflow">continue</span>;
<a name="l00082"></a>00082       <span class="keyword">const</span> <a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>&amp; la_cl_perio = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>, la_cl);
<a name="l00083"></a>00083       <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp;    frontiere = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>, la_cl.<a class="code" href="classCond__lim__base.html#ad88b3b516351146c85e8fce1df0f691a" title="Renvoie la frontiere discretisee a laquelle les conditions aux limites s&#39;appliquent.">frontiere_dis</a>());
<a name="l00084"></a>00084       <span class="keyword">const</span> <span class="keywordtype">int</span> nb_faces_cl = frontiere.<a class="code" href="classFront__VF.html#a341e2fcb5117b96e745fd7078ba86bab" title="Nombre de faces reelles du bord.">nb_faces</a>();
<a name="l00085"></a>00085       <span class="keyword">const</span> <span class="keywordtype">int</span> num_premiere_face = frontiere.<a class="code" href="classFront__VF.html#a4986f0c65653fe9eb40bbbff5a97bf16" title="Numero de la premiere face du bord dans la liste des faces.">num_premiere_face</a>();
<a name="l00086"></a>00086       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; nb_faces_cl; i++)
<a name="l00087"></a>00087         {
<a name="l00088"></a>00088 <span class="comment">// Numero de la face opposee dans le tableau des faces du bord:</span>
<a name="l00089"></a>00089           <span class="keyword">const</span> <span class="keywordtype">int</span> <a class="code" href="AssembleurPP1BUtil_8cpp.html#a3e374d53ebc7860e1c2f0b7906f2936d">face_associee</a> = la_cl_perio.<a class="code" href="classPeriodique.html#a207b86556f199a63ea059b841851ca6a">face_associee</a>(i);
<a name="l00090"></a>00090           <span class="keywordflow">if</span> (face_associee &gt; i)
<a name="l00091"></a>00091             {
<a name="l00092"></a>00092               <span class="keyword">const</span> <span class="keywordtype">int</span> num_face_global = num_premiere_face + i;
<a name="l00093"></a>00093               faces[nb_faces_periodiques] = num_face_global;
<a name="l00094"></a>00094               nb_faces_periodiques++;
<a name="l00095"></a>00095             }
<a name="l00096"></a>00096         }
<a name="l00097"></a>00097     }
<a name="l00098"></a>00098 
<a name="l00099"></a>00099 <span class="comment">// Taille finale du tableau faces</span>
<a name="l00100"></a>00100   faces.<a class="code" href="classArrOfInt.html#a9b3afbb46b16870dbd36236c8935b535">resize_array</a>(nb_faces_periodiques);
<a name="l00101"></a>00101   <span class="keywordflow">return</span> nb_faces_periodiques;
<a name="l00102"></a>00102 }
<a name="l00103"></a>00103 
<a name="l00104"></a>00104 <span class="comment">//</span>
<a name="l00105"></a>00105 <span class="comment">//</span>
<a name="l00106"></a>00106 <span class="comment">//</span>
<a name="l00107"></a>00107 <span class="comment">//</span>
<a name="l00108"></a>00108 <span class="comment">//</span>
<a name="l00109"></a>00109 <span class="comment">//</span>
<a name="l00110"></a>00110 <span class="comment">//</span><span class="comment"></span>
<a name="l00111"></a>00111 <span class="comment">//! Determine les elements non nuls de la matrice et prepare le stockage.&lt;br&gt;Matrice creuse de taille nb_elements (lignes) * nb_elem_tot (colonnes)&lt;br&gt;Codee comme une matrice bloc composee de deux matrices morse:&lt;br&gt;* Matrice carree symetrique nb_elements * nb_elements&lt;br&gt;(contient les termes M(i,j) ou i et j sont des numeros d&#39;elements reels)&lt;br&gt;* Matrice rectangle nb_elements * (nb_elem_tot - nb_elem)&lt;br&gt;(contient les termes M(i,j) ou i est reel et j est virtuel</span>
<a name="l00112"></a><a class="code" href="classAssembleur__P__VDF.html#aa56befba8f81a9161c144f009d3cdddd">00112</a> <span class="comment"></span><span class="keywordtype">int</span> <a class="code" href="classAssembleur__P__VDF.html#aa56befba8f81a9161c144f009d3cdddd" title="Determine les elements non nuls de la matrice et prepare le stockage. Matrice creuse de taille nb_ele...">Assembleur_P_VDF::construire</a>(<a class="code" href="classMatrice.html">Matrice</a>&amp; la_matrice)
<a name="l00113"></a>00113 {
<a name="l00114"></a>00114   <span class="keywordtype">int</span> i;
<a name="l00115"></a>00115   <span class="keyword">const</span> <a class="code" href="classZone__VDF.html" title="class Zone_VDF Classe instanciable qui derive de Zone_VF. Cette classe contient les informations geom...">Zone_VDF</a>&amp; zone_vdf   = <a class="code" href="classAssembleur__P__VDF.html#a4ce1358c35e162057c7968aa583cd581">la_zone_VDF</a>.<a class="code" href="classRef__Zone__VDF.html#a84151da4db745d02791d6246e3682b67">valeur</a>();
<a name="l00116"></a>00116   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; face_voisins = zone_vdf.<a class="code" href="classZone__VF.html#a49d4322f5585a8fa95748ca785b70702" title="renvoie l&#39;element voisin de numface dans la direction i. i=0 : dans le sens oppose de l&#39;axe orthogona...">face_voisins</a>();
<a name="l00117"></a>00117 
<a name="l00118"></a>00118 <span class="comment">// Comptage du nombre total d&#39;elements non nuls:</span>
<a name="l00119"></a>00119 <span class="comment">// matrice carree : nombre de faces internes / 2 + nb_elem + nbfaces periodiques</span>
<a name="l00120"></a>00120 <span class="comment">// (chaque face interne donne un coef, et on a un element</span>
<a name="l00121"></a>00121 <span class="comment">// diagonal et chaque face periodique donne aussi un coef)</span>
<a name="l00122"></a>00122 <span class="comment">// matrice rectangle : nombre de faces de joint</span>
<a name="l00123"></a>00123 
<a name="l00124"></a>00124 
<a name="l00125"></a>00125 <span class="comment">// Premiere etape : comptage du nombre d&#39;elements non nuls sur chaque ligne</span>
<a name="l00126"></a>00126 <span class="comment">// Pour chaque ligne de la matrice carree, nombre d&#39;elements non nuls</span>
<a name="l00127"></a>00127   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_elem     = zone_vdf.<a class="code" href="classZone__dis__base.html#a790cb2f6bc2928518799e748313d0eb3">nb_elem</a>();
<a name="l00128"></a>00128   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_elem_tot = zone_vdf.<a class="code" href="classZone__dis__base.html#a4d6aa445f152aa6dc54d66ea7a071147">nb_elem_tot</a>();
<a name="l00129"></a>00129   <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> carre_nb_non_zero(nb_elem);
<a name="l00130"></a>00130 <span class="comment">// Idem pour le rectangle</span>
<a name="l00131"></a>00131   <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> rect_nb_non_zero(nb_elem);
<a name="l00132"></a>00132 <span class="comment">// Il y a l&#39;element sur la diagonale :</span>
<a name="l00133"></a>00133   carre_nb_non_zero = 1;
<a name="l00134"></a>00134   rect_nb_non_zero = 0;
<a name="l00135"></a>00135   <span class="keywordtype">int</span> carre_nb_non_zero_tot = nb_elem;
<a name="l00136"></a>00136   <span class="keywordtype">int</span> rect_nb_non_zero_tot = 0;
<a name="l00137"></a>00137 
<a name="l00138"></a>00138 <span class="comment">// Plus un element non nul pour chaque face interne et chaque face periodique</span>
<a name="l00139"></a>00139 <span class="comment">// (matrice symetrique, on ne stocke que l&#39;element m(line,col) avec col&gt;line)</span>
<a name="l00140"></a>00140 
<a name="l00141"></a>00141   <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> liste_faces_perio;
<a name="l00142"></a>00142   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_faces_periodiques = <a class="code" href="classAssembleur__P__VDF.html#a48da6c5fc5769465a659da41fab00812" title="Remplit le tableau faces avec la liste des indices des faces periodiques dans le tableau faces_voisin...">liste_faces_periodiques</a>(liste_faces_perio);
<a name="l00143"></a>00143   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_faces_internes = zone_vdf.<a class="code" href="classZone__VF.html#a1210c3de419eab8ce27debddd632218e" title="une face est interne ssi elle separe deux elements. renvoie le nombre de faces internes.">nb_faces_internes</a>();
<a name="l00144"></a>00144   <span class="keyword">const</span> <span class="keywordtype">int</span> premiere_face_interne = zone_vdf.<a class="code" href="classZone__VF.html#a12869806fa4834aca8f2964e16509dfd" title="une face est interne ssi elle separe deux elements. renvoie le numero de la premiere face interne...">premiere_face_int</a>();
<a name="l00145"></a>00145   <span class="keywordflow">for</span> (i = 0; i &lt; nb_faces_internes + nb_faces_periodiques; i++)
<a name="l00146"></a>00146     {
<a name="l00147"></a>00147       <span class="keywordtype">int</span> face;
<a name="l00148"></a>00148       <span class="keywordflow">if</span> (i &lt; nb_faces_internes) <span class="comment">//!&lt; Astuce pour boucler sur les faces internes et periodiques</span>
<a name="l00149"></a>00149 <span class="comment"></span>        face = premiere_face_interne + i;
<a name="l00150"></a>00150       <span class="keywordflow">else</span>
<a name="l00151"></a>00151         face = liste_faces_perio[i - nb_faces_internes];
<a name="l00152"></a>00152 
<a name="l00153"></a>00153       <span class="keywordtype">int</span> elem0 = face_voisins(face,0);
<a name="l00154"></a>00154       <span class="keywordtype">int</span> elem1 = face_voisins(face,1);
<a name="l00155"></a>00155       <span class="keywordflow">if</span> (elem0 &gt; elem1)
<a name="l00156"></a>00156         {
<a name="l00157"></a>00157           <span class="keywordtype">int</span> tmp = elem1;
<a name="l00158"></a>00158           elem1 = elem0;
<a name="l00159"></a>00159           elem0 = tmp;
<a name="l00160"></a>00160         }
<a name="l00161"></a>00161       <span class="keywordflow">if</span> (elem0 &lt; nb_elem)   <span class="comment">//!&lt; elem0 est reel</span>
<a name="l00162"></a>00162 <span class="comment"></span>        {
<a name="l00163"></a>00163           <span class="keywordflow">if</span> (elem1 &lt; nb_elem)      <span class="comment">//!&lt; elem1 reel</span>
<a name="l00164"></a>00164 <span class="comment"></span>            {
<a name="l00165"></a>00165               carre_nb_non_zero[elem0] ++;
<a name="l00166"></a>00166               carre_nb_non_zero_tot ++;
<a name="l00167"></a>00167             }
<a name="l00168"></a>00168           <span class="keywordflow">else</span>                      <span class="comment">//!&lt; elem1 virtuel</span>
<a name="l00169"></a>00169 <span class="comment"></span>            {
<a name="l00170"></a>00170               rect_nb_non_zero[elem0] ++;
<a name="l00171"></a>00171               rect_nb_non_zero_tot ++;
<a name="l00172"></a>00172             }
<a name="l00173"></a>00173         }
<a name="l00174"></a>00174     }
<a name="l00175"></a>00175 
<a name="l00176"></a>00176 <span class="comment">// Typage et dimensionnement de la matrice de pression</span>
<a name="l00177"></a>00177   la_matrice.<a class="code" href="classDeriv__.html#ad1d33400ed15b6ff96579ed82d9e2719" title="Essaie de creer une instance du type &quot;type&quot;. si type n&#39;est pas un type ou type n&#39;est pas instanciab...">typer</a>(<span class="stringliteral">&quot;Matrice_Bloc&quot;</span>);
<a name="l00178"></a>00178   <a class="code" href="classMatrice__Bloc.html">Matrice_Bloc</a>&amp; matrice =<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Bloc.html">Matrice_Bloc</a> , la_matrice.<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>());
<a name="l00179"></a>00179   matrice.<a class="code" href="classMatrice__Bloc.html#a1db7c549cc1be958d5f00c29cd0f3a8c">dimensionner</a>(1,2);
<a name="l00180"></a>00180   matrice.<a class="code" href="classMatrice__Bloc.html#a7ffa38f7b93454432b2df7c616ed0a4e">get_bloc</a>(0,0).<a class="code" href="classDeriv__.html#ad1d33400ed15b6ff96579ed82d9e2719" title="Essaie de creer une instance du type &quot;type&quot;. si type n&#39;est pas un type ou type n&#39;est pas instanciab...">typer</a>(<span class="stringliteral">&quot;Matrice_Morse_Sym&quot;</span>);
<a name="l00181"></a>00181   matrice.<a class="code" href="classMatrice__Bloc.html#a7ffa38f7b93454432b2df7c616ed0a4e">get_bloc</a>(0,1).<a class="code" href="classDeriv__.html#ad1d33400ed15b6ff96579ed82d9e2719" title="Essaie de creer une instance du type &quot;type&quot;. si type n&#39;est pas un type ou type n&#39;est pas instanciab...">typer</a>(<span class="stringliteral">&quot;Matrice_Morse&quot;</span>);
<a name="l00182"></a>00182   <a class="code" href="classMatrice__Morse__Sym.html" title="Classe Matrice_Morse_Sym Represente une matrice M (creuse) symetrique stockee au format Morse Symetri...">Matrice_Morse_Sym</a>&amp; <a class="code" href="Double_8h.html#aa4be1ab61f49e9ebb241ed3f4957fd4a" title="fonctions utiles sur les double">carre</a> = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Morse__Sym.html" title="Classe Matrice_Morse_Sym Represente une matrice M (creuse) symetrique stockee au format Morse Symetri...">Matrice_Morse_Sym</a> ,matrice.<a class="code" href="classMatrice__Bloc.html#a7ffa38f7b93454432b2df7c616ed0a4e">get_bloc</a>(0,0).<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>());
<a name="l00183"></a>00183   <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp;      rect  = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a> ,     matrice.<a class="code" href="classMatrice__Bloc.html#a7ffa38f7b93454432b2df7c616ed0a4e">get_bloc</a>(0,1).<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>());
<a name="l00184"></a>00184 
<a name="l00185"></a>00185   carre.<a class="code" href="classMatrice__Morse.html#ae95f9ed88a8a3fc637cd2a705cead9c8" title="Size the matrix with n lines and n columns and nnz zero-values coefficients.">dimensionner</a>(nb_elem, carre_nb_non_zero_tot);
<a name="l00186"></a>00186   rect.dimensionner(nb_elem, nb_elem_tot - nb_elem, rect_nb_non_zero_tot);
<a name="l00187"></a>00187 
<a name="l00188"></a>00188   {
<a name="l00189"></a>00189     <span class="keyword">const</span> <span class="keywordtype">int</span> nb_faces_bord = zone_vdf.<a class="code" href="classZone__VF.html#a8815e2276637c0db23868f043dc43e58" title="renvoie le nombre de faces sur lesquelles sont appliquees les conditions limites : bords...">nb_faces_bord</a>();
<a name="l00190"></a>00190     <a class="code" href="classAssembleur__P__VDF.html#af8eca29a2e48d27e8e1f77e0945dc38d">les_coeff_pression</a>.<a class="code" href="classArrOfDouble.html#a610464f4b3dccac6f814915b526783ed">resize_array</a>(nb_faces_bord);
<a name="l00191"></a>00191   }
<a name="l00192"></a>00192   <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; carre_tab1 = carre.<a class="code" href="classMatrice__Morse.html#a7a49c763706dcfaed900f9d2cbb68716">get_set_tab1</a>();
<a name="l00193"></a>00193   <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; rect_tab1 = rect.get_set_tab1();
<a name="l00194"></a>00194 
<a name="l00195"></a>00195 <span class="comment">// Matrice creuse, stockage morse avec des indices fortran:</span>
<a name="l00196"></a>00196 <span class="comment">// lignes numerotees 1..n, colonnes 1..m</span>
<a name="l00197"></a>00197 <span class="comment">// Le k-ieme coefficient non nul de la ligne i (1&lt;=i&lt;=n) est (avec 1&lt;=k)</span>
<a name="l00198"></a>00198 <span class="comment">// M(i,j) = coeff_[tab1_[k]]     en fortran</span>
<a name="l00199"></a>00199 <span class="comment">// M(i,j) = coeff_[tab1_[k-1]-1] en C</span>
<a name="l00200"></a>00200 <span class="comment">// Le numero j de la colonne ou se trouve ce coefficient (1&lt;=j&lt;=m) est</span>
<a name="l00201"></a>00201 <span class="comment">// j = tab2_[tab1_[k]]     en fortran</span>
<a name="l00202"></a>00202 <span class="comment">// j = tab2_[tab1_[k-1]-1] en C</span>
<a name="l00203"></a>00203 <span class="comment">// </span>
<a name="l00204"></a>00204 <span class="comment">// Calcul de l&#39;indice du premier coefficient de la ligne i</span>
<a name="l00205"></a>00205 <span class="comment">// dans le tableau d&#39;indices morse des deux matrices (tab1_)</span>
<a name="l00206"></a>00206   {
<a name="l00207"></a>00207     <span class="keywordtype">int</span> indice = 1; <span class="comment">//!&lt; tab1_ contient un indice fortran (1er element en 1)</span>
<a name="l00208"></a>00208 <span class="comment"></span>    <span class="keywordflow">for</span> (i = 0; i &lt; nb_elem; i++)
<a name="l00209"></a>00209       {
<a name="l00210"></a>00210         carre_tab1[i] = indice;
<a name="l00211"></a>00211         indice += carre_nb_non_zero[i];
<a name="l00212"></a>00212       }
<a name="l00213"></a>00213     carre_tab1[i] = indice;
<a name="l00214"></a>00214 
<a name="l00215"></a>00215     indice = 1;
<a name="l00216"></a>00216     <span class="keywordflow">for</span> (i = 0; i &lt; nb_elem; i++)
<a name="l00217"></a>00217       {
<a name="l00218"></a>00218         rect_tab1[i] = indice;
<a name="l00219"></a>00219         indice += rect_nb_non_zero[i];
<a name="l00220"></a>00220       }
<a name="l00221"></a>00221     rect_tab1[i] = indice;
<a name="l00222"></a>00222   }
<a name="l00223"></a>00223 
<a name="l00224"></a>00224 <span class="comment">// Deuxieme etape : remplissage de tab2_ = numero de la colonne de chaque</span>
<a name="l00225"></a>00225 <span class="comment">// terme non nul de la matrice</span>
<a name="l00226"></a>00226   <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; carre_tab2 = carre.<a class="code" href="classMatrice__Morse.html#af11c5853518e9e6db4c7e6e6acc8d7fd">get_set_tab2</a>();
<a name="l00227"></a>00227   <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; rect_tab2 = rect.get_set_tab2();
<a name="l00228"></a>00228 
<a name="l00229"></a>00229   carre_tab2 = -1;
<a name="l00230"></a>00230   rect_tab2 = -1;
<a name="l00231"></a>00231 
<a name="l00232"></a>00232 <span class="comment">// Terme diagonal:</span>
<a name="l00233"></a>00233   <span class="keywordflow">for</span> (i = 1; i &lt;= nb_elem; i++)
<a name="l00234"></a>00234     carre_tab2[carre_tab1[i-1]-1] = i; <span class="comment">//!&lt; Indice fortran 1&lt;=i&lt;=nb_elem</span>
<a name="l00235"></a>00235 <span class="comment"></span>
<a name="l00236"></a>00236   carre_nb_non_zero = 1; <span class="comment">//!&lt; Nombre de coefficients non nuls sur chaque ligne</span>
<a name="l00237"></a>00237 <span class="comment"></span>  rect_nb_non_zero = 0;
<a name="l00238"></a>00238 
<a name="l00239"></a>00239 <span class="comment">// Termes extra-diagonaux:</span>
<a name="l00240"></a>00240   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i_face = 0; i_face &lt; nb_faces_internes + nb_faces_periodiques; i_face++)
<a name="l00241"></a>00241     {
<a name="l00242"></a>00242 
<a name="l00243"></a>00243 <span class="comment">// Calcul du numero de la face a traiter</span>
<a name="l00244"></a>00244       <span class="keyword">const</span> <span class="keywordtype">int</span> face = (i_face &lt; nb_faces_internes)
<a name="l00245"></a>00245                        ? premiere_face_interne + i_face
<a name="l00246"></a>00246                        : liste_faces_perio[i_face - nb_faces_internes];
<a name="l00247"></a>00247 
<a name="l00248"></a>00248       <span class="keywordtype">int</span> elem0 = face_voisins(face,0);
<a name="l00249"></a>00249       <span class="keywordtype">int</span> elem1 = face_voisins(face,1);
<a name="l00250"></a>00250       <span class="keywordflow">if</span> (elem0 &gt; elem1)
<a name="l00251"></a>00251         {
<a name="l00252"></a>00252           <span class="keywordtype">int</span> tmp = elem1;
<a name="l00253"></a>00253           elem1 = elem0;
<a name="l00254"></a>00254           elem0 = tmp;
<a name="l00255"></a>00255         }
<a name="l00256"></a>00256       assert(elem0 &gt;= 0);            <span class="comment">//!&lt; Verifie qu&#39;on a bien deux elements voisins</span>
<a name="l00257"></a>00257 <span class="comment"></span>      <span class="keywordflow">if</span> (elem0 &lt; nb_elem)                              <span class="comment">//!&lt; elem0 est reel</span>
<a name="l00258"></a>00258 <span class="comment"></span>        {
<a name="l00259"></a>00259           <span class="keyword">const</span> <span class="keywordtype">int</span> ligne = elem0 + 1;                 <span class="comment">//!&lt; Indice fortran</span>
<a name="l00260"></a>00260 <span class="comment"></span>          <span class="keywordflow">if</span> (elem1 &lt; nb_elem)                            <span class="comment">//!&lt; elem1 est reel aussi</span>
<a name="l00261"></a>00261 <span class="comment"></span>            {
<a name="l00262"></a>00262               <span class="keyword">const</span> <span class="keywordtype">int</span> colonne = elem1 + 1;             <span class="comment">//!&lt; Indice fortran</span>
<a name="l00263"></a>00263 <span class="comment"></span>              <span class="keyword">const</span> <span class="keywordtype">int</span> n = carre_nb_non_zero[ligne-1]++;
<a name="l00264"></a>00264               <span class="keyword">const</span> <span class="keywordtype">int</span> index = carre_tab1[ligne-1] + n; <span class="comment">//!&lt; Indice fortran dans tab2</span>
<a name="l00265"></a>00265 <span class="comment"></span>              carre_tab2[index - 1] = colonne;
<a name="l00266"></a>00266             }
<a name="l00267"></a>00267           <span class="keywordflow">else</span>                                           <span class="comment">//!&lt; elem1 est virtuel</span>
<a name="l00268"></a>00268 <span class="comment"></span>            {
<a name="l00269"></a>00269               <span class="keyword">const</span> <span class="keywordtype">int</span> colonne = elem1 - nb_elem + 1;  <span class="comment">//!&lt; Indice fortran</span>
<a name="l00270"></a>00270 <span class="comment"></span>              <span class="keyword">const</span> <span class="keywordtype">int</span> n = rect_nb_non_zero[ligne-1]++;
<a name="l00271"></a>00271               <span class="keyword">const</span> <span class="keywordtype">int</span> index = rect_tab1[ligne-1] + n; <span class="comment">//!&lt; Indice fortran dans tab2</span>
<a name="l00272"></a>00272 <span class="comment"></span>              rect_tab2[index - 1] = colonne;
<a name="l00273"></a>00273             }
<a name="l00274"></a>00274         }
<a name="l00275"></a>00275     }
<a name="l00276"></a>00276 
<a name="l00277"></a>00277   <span class="keywordflow">return</span> 1;
<a name="l00278"></a>00278 }
<a name="l00279"></a>00279 
<a name="l00280"></a>00280 <span class="comment">// Precondition:</span>
<a name="l00281"></a>00281 <span class="comment">// La matrice doit etre typee et dimensionnee, tab1_ et tab2_ remplis</span>
<a name="l00282"></a>00282 <span class="comment">// avec les elements non nuls de la matrice.</span>
<a name="l00283"></a>00283 <span class="comment">// On suppose que le tableau tab2_ est inchange depuis son remplissage dans</span>
<a name="l00284"></a>00284 <span class="comment">// &quot;construire&quot;. Le remplissage se fait avec des boucles identiques pour que</span>
<a name="l00285"></a>00285 <span class="comment">// tab2 et coeff se correspondent.</span>
<a name="l00286"></a>00286 <span class="comment">// </span>
<a name="l00287"></a>00287 <span class="comment">// A essayer : trier les elements d&#39;une ligne par ordre croissant de numero de</span>
<a name="l00288"></a>00288 <span class="comment">// colonne et utiliser un acces matrice(ligne,colonne) avec recherche binaire.</span>
<a name="l00289"></a>00289 <span class="comment">// C&#39;est plus lisible.</span>
<a name="l00290"></a>00290 <span class="comment">// </span>
<a name="l00291"></a>00291 <span class="comment">// La matrice M est telle que si le vecteur P(i) contient la valeur de la pression au centre</span>
<a name="l00292"></a>00292 <span class="comment">// des elements Omega(i), alors le vecteur A=M*P est tel que A(i) vaut :</span>
<a name="l00293"></a>00293 <span class="comment">// A(i) = - INTEGRALE sur Omega(i)             (div (porosite/rho * grad P) * dOmega)</span>
<a name="l00294"></a>00294 <span class="comment">// = - INTEGRALE sur le bord de Omega(i)) (porosite/rho * gradP * Normale * ds)</span>
<a name="l00295"></a>00295 <span class="comment">// </span>
<a name="l00296"></a>00296 <span class="comment">// On discretise grad P = (P(i+1) - P(i)) / h, avec h = volume(Omega&#39;) / surface(face)</span>
<a name="l00297"></a>00297 <span class="comment">// (Omega&#39; est le volume de controle de la qdm)</span>
<a name="l00298"></a>00298 <span class="comment">//</span>
<a name="l00299"></a>00299 <span class="comment">//</span>
<a name="l00300"></a>00300 <span class="comment">//</span><span class="comment"></span>
<a name="l00301"></a>00301 <span class="comment">//! Calcul des coefficients de la matrice de pression avec un champ de rho.&lt;br&gt;Si rho_ptr == 0, on calcule la matrice -div( porosite * grad P ),&lt;br&gt;sinon on calcule -div( porosite/rho grad P ) et *rho_ptr doit etre un Champ_Fonc_Face.</span>
<a name="l00302"></a>00302 <span class="comment"></span>
<a name="l00303"></a><a class="code" href="classAssembleur__P__VDF.html#ae6419915244b87d5c8f186d7c4fc1992">00303</a> <span class="keywordtype">int</span> <a class="code" href="classAssembleur__P__VDF.html#ae6419915244b87d5c8f186d7c4fc1992" title="Calcul des coefficients de la matrice de pression avec un champ de rho. Si rho_ptr == 0...">Assembleur_P_VDF::remplir</a>(<a class="code" href="classMatrice.html">Matrice</a>&amp; la_matrice, <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; volumes_entrelaces,<span class="keyword">const</span> <a class="code" href="classChamp__Don__base.html" title="classe Champ_Don_base classe de base des Champs donnes (non calcules) les proprietes physiques sont d...">Champ_Don_base</a> * rho_ptr)
<a name="l00304"></a>00304 {
<a name="l00305"></a>00305   <span class="keyword">const</span> <a class="code" href="classZone__VDF.html" title="class Zone_VDF Classe instanciable qui derive de Zone_VF. Cette classe contient les informations geom...">Zone_VDF</a>&amp; zone_vdf   = <a class="code" href="classAssembleur__P__VDF.html#a4ce1358c35e162057c7968aa583cd581">la_zone_VDF</a>.<a class="code" href="classRef__Zone__VDF.html#a84151da4db745d02791d6246e3682b67">valeur</a>();
<a name="l00306"></a>00306   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; face_voisins = zone_vdf.<a class="code" href="classZone__VF.html#a49d4322f5585a8fa95748ca785b70702" title="renvoie l&#39;element voisin de numface dans la direction i. i=0 : dans le sens oppose de l&#39;axe orthogona...">face_voisins</a>();
<a name="l00307"></a>00307   <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; face_surfaces = zone_vdf.<a class="code" href="classZone__VF.html#a40c3382b189a4fc508cf1c3e37b04b21">face_surfaces</a>();
<a name="l00308"></a>00308 <span class="comment">// const DoubleVect &amp; volumes_entrelaces = zone_vdf.volumes_entrelaces();</span>
<a name="l00309"></a>00309   <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; porosite_face = zone_vdf.<a class="code" href="classZone__VF.html#ad9d74d1d9da9f50ab26768dbbca7711b">porosite_face</a>();
<a name="l00310"></a>00310 
<a name="l00311"></a>00311 
<a name="l00312"></a>00312   <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a> * valeurs_rho = 0;
<a name="l00313"></a>00313   <span class="keywordflow">if</span> (rho_ptr)
<a name="l00314"></a>00314     {
<a name="l00315"></a>00315       assert(<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classChamp__Fonc__Face.html" title="classe Champ_Fonc_Face">Champ_Fonc_Face</a>, *rho_ptr));
<a name="l00316"></a>00316       valeurs_rho = &amp; (rho_ptr-&gt;<a class="code" href="classChamp__Don__base.html#ac0ac51817e03e27c28d2b96bb15db9a0" title="Surcharge Champ_base::valeurs() Renvoie le tableau des valeurs.">valeurs</a>());
<a name="l00317"></a>00317     }
<a name="l00318"></a>00318 
<a name="l00319"></a>00319 <span class="comment">// Raccourcis vers la partie carree (coefficients elements reels/reels)</span>
<a name="l00320"></a>00320 <span class="comment">// et la partie rectangulaire (elements reels / elements virtuels) de la matrice</span>
<a name="l00321"></a>00321   <a class="code" href="classMatrice__Bloc.html">Matrice_Bloc</a>&amp; matrice = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Bloc.html">Matrice_Bloc</a>, la_matrice.<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>());
<a name="l00322"></a>00322   <a class="code" href="classMatrice__Morse__Sym.html" title="Classe Matrice_Morse_Sym Represente une matrice M (creuse) symetrique stockee au format Morse Symetri...">Matrice_Morse_Sym</a>&amp; <a class="code" href="Double_8h.html#aa4be1ab61f49e9ebb241ed3f4957fd4a" title="fonctions utiles sur les double">carre</a> = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Morse__Sym.html" title="Classe Matrice_Morse_Sym Represente une matrice M (creuse) symetrique stockee au format Morse Symetri...">Matrice_Morse_Sym</a>, matrice.<a class="code" href="classMatrice__Bloc.html#a7ffa38f7b93454432b2df7c616ed0a4e">get_bloc</a>(0,0).<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>());
<a name="l00323"></a>00323   <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp;      rect  = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>,     matrice.<a class="code" href="classMatrice__Bloc.html#a7ffa38f7b93454432b2df7c616ed0a4e">get_bloc</a>(0,1).<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>());
<a name="l00324"></a>00324 
<a name="l00325"></a>00325   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_elem = zone_vdf.<a class="code" href="classZone__dis__base.html#a790cb2f6bc2928518799e748313d0eb3">nb_elem</a>();
<a name="l00326"></a>00326   <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> carre_nb_non_zero(nb_elem);
<a name="l00327"></a>00327   <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> rect_nb_non_zero(nb_elem);
<a name="l00328"></a>00328   carre_nb_non_zero = 1;
<a name="l00329"></a>00329   rect_nb_non_zero = 0;
<a name="l00330"></a>00330 
<a name="l00331"></a>00331   <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; carre_tab1 = carre.get_set_tab1();
<a name="l00332"></a>00332   <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; rect_tab1 = rect.get_set_tab1();
<a name="l00333"></a>00333   <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a>&amp; carre_coeff = carre.get_set_coeff();
<a name="l00334"></a>00334   <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a>&amp; rect_coeff = rect.get_set_coeff();
<a name="l00335"></a>00335 
<a name="l00336"></a>00336   carre_coeff = 0.;
<a name="l00337"></a>00337   rect_coeff = 0.;
<a name="l00338"></a>00338 
<a name="l00339"></a>00339 <span class="comment">// Traitement des faces internes et periodiques :</span>
<a name="l00340"></a>00340 <span class="comment">// Pour chaque face entre deux elements elem0 et elem1, y a quatre termes a ajouter :</span>
<a name="l00341"></a>00341 <span class="comment">// M(elem0,elem0)</span>
<a name="l00342"></a>00342 <span class="comment">// M(elem0,elem1)</span>
<a name="l00343"></a>00343 <span class="comment">// M(elem1,elem1)</span>
<a name="l00344"></a>00344 <span class="comment">// M(elem1,elem0)  (omis car la matrice est stockee symetrique)</span>
<a name="l00345"></a>00345 
<a name="l00346"></a>00346 <span class="comment">// Construction de la liste des faces periodiques</span>
<a name="l00347"></a>00347   <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> liste_faces_perio;
<a name="l00348"></a>00348   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_faces_periodiques = <a class="code" href="classAssembleur__P__VDF.html#a48da6c5fc5769465a659da41fab00812" title="Remplit le tableau faces avec la liste des indices des faces periodiques dans le tableau faces_voisin...">liste_faces_periodiques</a>(liste_faces_perio);
<a name="l00349"></a>00349   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_faces_internes = zone_vdf.<a class="code" href="classZone__VF.html#a1210c3de419eab8ce27debddd632218e" title="une face est interne ssi elle separe deux elements. renvoie le nombre de faces internes.">nb_faces_internes</a>();
<a name="l00350"></a>00350   <span class="keyword">const</span> <span class="keywordtype">int</span> premiere_face_interne = zone_vdf.<a class="code" href="classZone__VF.html#a12869806fa4834aca8f2964e16509dfd" title="une face est interne ssi elle separe deux elements. renvoie le numero de la premiere face interne...">premiere_face_int</a>();
<a name="l00351"></a>00351   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i_face = 0; i_face &lt; nb_faces_internes + nb_faces_periodiques; i_face++)
<a name="l00352"></a>00352     {
<a name="l00353"></a>00353 
<a name="l00354"></a>00354 <span class="comment">// Calcul du numero de la face a traiter</span>
<a name="l00355"></a>00355       <span class="keyword">const</span> <span class="keywordtype">int</span> num_face = (i_face &lt; nb_faces_internes)
<a name="l00356"></a>00356                            ? premiere_face_interne + i_face
<a name="l00357"></a>00357                            : liste_faces_perio[i_face - nb_faces_internes];
<a name="l00358"></a>00358 <span class="comment">// Calcul de rho sur cette face</span>
<a name="l00359"></a>00359       <span class="keyword">const</span> <span class="keywordtype">double</span> rho_face = (valeurs_rho) ? (*valeurs_rho)[num_face] : 1.;
<a name="l00360"></a>00360 <span class="comment">// Calcul du coefficient</span>
<a name="l00361"></a>00361       <span class="keyword">const</span> <span class="keywordtype">double</span> surface  = face_surfaces[num_face];
<a name="l00362"></a>00362       <span class="keyword">const</span> <span class="keywordtype">double</span> volume   = volumes_entrelaces[num_face];
<a name="l00363"></a>00363       <span class="keyword">const</span> <span class="keywordtype">double</span> porosite = porosite_face[num_face];
<a name="l00364"></a>00364       <span class="keyword">const</span> <span class="keywordtype">double</span> coefficient = surface * surface * porosite / (volume * rho_face);
<a name="l00365"></a>00365 <span class="comment">// Numeros des deux elements voisins (le plus petit dans elem0)</span>
<a name="l00366"></a>00366       <span class="keywordtype">int</span> elem0 = face_voisins(num_face,0);
<a name="l00367"></a>00367       <span class="keywordtype">int</span> elem1 = face_voisins(num_face,1);
<a name="l00368"></a>00368       <span class="keywordflow">if</span> (elem0 &gt; elem1)
<a name="l00369"></a>00369         {
<a name="l00370"></a>00370           <span class="keywordtype">int</span> tmp = elem1;
<a name="l00371"></a>00371           elem1 = elem0;
<a name="l00372"></a>00372           elem0 = tmp;
<a name="l00373"></a>00373         }
<a name="l00374"></a>00374       <span class="keywordflow">if</span> (elem0 &lt; nb_elem)
<a name="l00375"></a>00375         {
<a name="l00376"></a>00376 <span class="comment">// elem0 est reel</span>
<a name="l00377"></a>00377           <span class="keyword">const</span> <span class="keywordtype">int</span> ligne = elem0 + 1;   <span class="comment">//!&lt; Indice fortran Indice fortran de l&#39;element diagonal (elem0, elem0)</span>
<a name="l00378"></a>00378 <span class="comment"></span><span class="comment">//</span>
<a name="l00379"></a>00379           <span class="keyword">const</span> <span class="keywordtype">int</span> index_diag = carre_tab1[ligne-1];
<a name="l00380"></a>00380           carre_coeff[index_diag - 1] += coefficient;
<a name="l00381"></a>00381           <span class="keywordflow">if</span> (elem1 &lt; nb_elem)
<a name="l00382"></a>00382             {
<a name="l00383"></a>00383 <span class="comment">// elem1 est reel aussi</span>
<a name="l00384"></a>00384 <span class="comment">// Indice fortran de l&#39;element diagonal (elem1, elem1)</span>
<a name="l00385"></a>00385               <span class="keyword">const</span> <span class="keywordtype">int</span> index_diag1 = carre_tab1[elem1]; <span class="comment">//!&lt; a la ligne elem1+1 Indice fortran de l&#39;element extradiagonal (elem0, elem1)</span>
<a name="l00386"></a>00386 <span class="comment"></span><span class="comment">//</span>
<a name="l00387"></a>00387               <span class="keyword">const</span> <span class="keywordtype">int</span> n = carre_nb_non_zero[ligne-1]++;
<a name="l00388"></a>00388               <span class="keyword">const</span> <span class="keywordtype">int</span> index = index_diag + n;
<a name="l00389"></a>00389 <span class="comment">// Coefficient diagonal</span>
<a name="l00390"></a>00390               carre_coeff[index_diag1 - 1] += coefficient;
<a name="l00391"></a>00391 <span class="comment">// Coefficient extra-diagonal</span>
<a name="l00392"></a>00392               carre_coeff[index - 1] = - coefficient;
<a name="l00393"></a>00393               assert(carre.get_tab2()(index - 1) == elem1 + 1);
<a name="l00394"></a>00394             }
<a name="l00395"></a>00395           <span class="keywordflow">else</span>
<a name="l00396"></a>00396             {
<a name="l00397"></a>00397 <span class="comment">// elem1 est virtuel</span>
<a name="l00398"></a>00398               <span class="keyword">const</span> <span class="keywordtype">int</span> n = rect_nb_non_zero[ligne-1]++;
<a name="l00399"></a>00399               <span class="keyword">const</span> <span class="keywordtype">int</span> index = rect_tab1[ligne-1] + n; <span class="comment">//!&lt; Indice fortran dans tab2 Coefficient extra-diagonal</span>
<a name="l00400"></a>00400 <span class="comment"></span><span class="comment">//</span>
<a name="l00401"></a>00401               rect_coeff[index - 1] = - coefficient;
<a name="l00402"></a>00402               assert(rect.get_tab2()(index - 1) == elem1 - nb_elem + 1);
<a name="l00403"></a>00403             }
<a name="l00404"></a>00404         }
<a name="l00405"></a>00405     }
<a name="l00406"></a>00406 
<a name="l00407"></a>00407 <span class="comment">// Traitement des conditions aux limites</span>
<a name="l00408"></a>00408   <span class="keyword">const</span> <a class="code" href="classConds__lim.html">Conds_lim</a>&amp; les_cl = <a class="code" href="classAssembleur__P__VDF.html#a0b984a6831f2750865e12296e5e07a2b">la_zone_Cl_VDF</a>.<a class="code" href="classRef__Zone__Cl__VDF.html#a1e655604e840cda5b393e45f975b73ff">valeur</a>().<a class="code" href="classZone__Cl__dis__base.html#af75e0ed7786863e4d333bfb29d67c323" title="Renvoie la i-ieme condition aux limites. (version const)">les_conditions_limites</a>();
<a name="l00409"></a>00409   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_cl = les_cl.<a class="code" href="classvect__impl.html#a78155bfbd6b61f4710b9830641ed1694">size</a>();
<a name="l00410"></a>00410   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> num_cl = 0; num_cl &lt; nb_cl; num_cl++)
<a name="l00411"></a>00411     {
<a name="l00412"></a>00412       <span class="keyword">const</span> <a class="code" href="classCond__lim__base.html" title="classe Cond_lim_base Classe de base pour la hierarchie des classes qui representent les differentes c...">Cond_lim_base</a>&amp; la_cl = les_cl[num_cl].valeur();
<a name="l00413"></a>00413       <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp; la_front_dis = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>,la_cl.<a class="code" href="classCond__lim__base.html#ad88b3b516351146c85e8fce1df0f691a" title="Renvoie la frontiere discretisee a laquelle les conditions aux limites s&#39;appliquent.">frontiere_dis</a>());
<a name="l00414"></a>00414 
<a name="l00415"></a>00415 <span class="comment">// Test sur les conditions limites en 2D RZ (on doit avoir symetrie selon l&#39;axe de revolution)</span>
<a name="l00416"></a>00416       <span class="keywordflow">if</span> (<a class="code" href="classObjet__U.html#a9a47c1add9760324894500792c17a178">bidim_axi</a> &amp;&amp; !<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classSymetrie.html" title="classe Symetrie Sur les faces de symetrie on a les proprietes suivantes: - composante normale de la v...">Symetrie</a>,la_cl))
<a name="l00417"></a>00417         {
<a name="l00418"></a>00418           <span class="keyword">const</span> <span class="keywordtype">int</span> ndeb = la_front_dis.<a class="code" href="classFront__VF.html#a4986f0c65653fe9eb40bbbff5a97bf16" title="Numero de la premiere face du bord dans la liste des faces.">num_premiere_face</a>();
<a name="l00419"></a>00419           <span class="keyword">const</span> <span class="keywordtype">int</span> nfin = ndeb + la_front_dis.<a class="code" href="classFront__VF.html#a341e2fcb5117b96e745fd7078ba86bab" title="Nombre de faces reelles du bord.">nb_faces</a>();
<a name="l00420"></a>00420           <span class="keywordflow">if</span> (nfin&gt;ndeb &amp;&amp; <a class="code" href="Double_8h.html#ac86f5f350b0f95fd8c34b0ac8d720f6f">est_egal</a>(face_surfaces[ndeb],0))
<a name="l00421"></a>00421             {
<a name="l00422"></a>00422               <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;\nFirst face surface is smaller than PrecisionGeom = &quot;</span> &lt;&lt; <a class="code" href="classObjet__U.html#a7447e25c68cc8d3a1c06cf99f0565cff">precision_geom</a> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
<a name="l00423"></a>00423               <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;May be you have an error in the definition of the boundary conditions.&quot;</span> &lt;&lt; finl;
<a name="l00424"></a>00424               <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;The axis of revolution for this 2D calculation is along Y.&quot;</span> &lt;&lt; finl;
<a name="l00425"></a>00425               <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;So you must specify symmetry boundary condition (symetrie keyword) for the boundary &quot;</span> &lt;&lt; la_front_dis.<a class="code" href="classFrontiere__dis__base.html#a5a7eb46dc3af8a7d4225adc1814845d8" title="Renvoie le nom de la frontiere geometrique.">le_nom</a>() &lt;&lt; finl;
<a name="l00426"></a>00426               <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">exit</a>();
<a name="l00427"></a>00427             }
<a name="l00428"></a>00428         }
<a name="l00429"></a>00429 
<a name="l00430"></a>00430 <span class="comment">// Pour chaque face de bord entre elem0 et un element fictif exterieur</span>
<a name="l00431"></a>00431 <span class="comment">// a pression imposee P0, on a :</span>
<a name="l00432"></a>00432 <span class="comment">// grad P = (P(elem0) - P0) * surface / volume_entrelace</span>
<a name="l00433"></a>00433 <span class="comment">// elem0 est une inconnue, P0 est ajoute au second membre dans &quot;modifier_secmem&quot;.</span>
<a name="l00434"></a>00434       <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classNeumann__sortie__libre.html" title="classe Neumann_sortie_libre Cette classe represente une frontiere ouverte sans vitesse imposee Pour l...">Neumann_sortie_libre</a>,la_cl))
<a name="l00435"></a>00435         {
<a name="l00436"></a>00436           <a class="code" href="classAssembleur__P__VDF.html#a9d277900967c598cd61dcc14dcb7ebbd">has_P_ref</a> = 1;
<a name="l00437"></a>00437           carre.set_est_definie(1);
<a name="l00438"></a>00438           <span class="keyword">const</span> <span class="keywordtype">int</span> ndeb = la_front_dis.<a class="code" href="classFront__VF.html#a4986f0c65653fe9eb40bbbff5a97bf16" title="Numero de la premiere face du bord dans la liste des faces.">num_premiere_face</a>();
<a name="l00439"></a>00439           <span class="keyword">const</span> <span class="keywordtype">int</span> nfin = ndeb + la_front_dis.<a class="code" href="classFront__VF.html#a341e2fcb5117b96e745fd7078ba86bab" title="Nombre de faces reelles du bord.">nb_faces</a>();
<a name="l00440"></a>00440           <span class="keywordflow">for</span> (<span class="keywordtype">int</span> num_face = ndeb; num_face &lt; nfin; num_face++)
<a name="l00441"></a>00441             {
<a name="l00442"></a>00442 <span class="comment">// Calcul de rho sur cette face</span>
<a name="l00443"></a>00443               <span class="keyword">const</span> <span class="keywordtype">double</span> rho_face = (valeurs_rho) ? (*valeurs_rho)[num_face] : 1.;
<a name="l00444"></a>00444 <span class="comment">// Calcul du coefficient a ajouter dans la matrice</span>
<a name="l00445"></a>00445               <span class="keyword">const</span> <span class="keywordtype">double</span> surface  = face_surfaces[num_face];
<a name="l00446"></a>00446 <span class="comment">// Attention: le volume entrelace a une valeur particuliere au bord</span>
<a name="l00447"></a>00447 <span class="comment">// (voir Zone_VDF::calculer_volumes_entrelaces() )</span>
<a name="l00448"></a>00448               <span class="keyword">const</span> <span class="keywordtype">double</span> volume   = volumes_entrelaces[num_face];
<a name="l00449"></a>00449               <span class="keyword">const</span> <span class="keywordtype">double</span> porosite = porosite_face[num_face];
<a name="l00450"></a>00450               <span class="keyword">const</span> <span class="keywordtype">double</span> coefficient = <a class="code" href="classOption__VDF.html#abc56a584319b990ca8259b5219d28270">Option_VDF::coeff_P_neumann</a> * surface * surface * porosite / (volume * rho_face);
<a name="l00451"></a>00451               assert(coefficient &gt; 0.);
<a name="l00452"></a>00452 <span class="comment">// Numero de l&#39;element voisin (l&#39;un est -1, l&#39;autre est un element reel)</span>
<a name="l00453"></a>00453               <span class="keyword">const</span> <span class="keywordtype">int</span> elem0 = face_voisins(num_face, 0);
<a name="l00454"></a>00454               <span class="keyword">const</span> <span class="keywordtype">int</span> elem1 = face_voisins(num_face, 1);
<a name="l00455"></a>00455               assert(elem0 == -1 || elem1 == -1);
<a name="l00456"></a>00456               <span class="keyword">const</span> <span class="keywordtype">int</span> elem = elem0 + elem1 + 1;
<a name="l00457"></a>00457 <span class="comment">// Ajout du coefficient a la matrice</span>
<a name="l00458"></a>00458               assert(elem &lt; nb_elem);
<a name="l00459"></a>00459               <span class="keyword">const</span> <span class="keywordtype">int</span> index = carre_tab1[elem]; <span class="comment">//!&lt; Indice fortran</span>
<a name="l00460"></a>00460 <span class="comment"></span>              carre_coeff[index - 1] += coefficient;
<a name="l00461"></a>00461               <a class="code" href="classAssembleur__P__VDF.html#af8eca29a2e48d27e8e1f77e0945dc38d">les_coeff_pression</a>[num_face] = coefficient;
<a name="l00462"></a>00462             }
<a name="l00463"></a>00463         }
<a name="l00464"></a>00464       <span class="keywordflow">else</span>
<a name="l00465"></a>00465         {
<a name="l00466"></a>00466 <span class="comment">// Pour les autres conditions aux limites, aucun terme supplementaire dans</span>
<a name="l00467"></a>00467 <span class="comment">// la matrice (grad P scalaire n = 0 sur le bord,</span>
<a name="l00468"></a>00468 <span class="comment">// ou derivee en temps de grad P scalaire n = 0 sur le bord)</span>
<a name="l00469"></a>00469         }
<a name="l00470"></a>00470     }
<a name="l00471"></a>00471   <a class="code" href="classAssembleur__P__VDF.html#a9d277900967c598cd61dcc14dcb7ebbd">has_P_ref</a> = (int)<a class="code" href="classProcess.html#a1e9d9f9899b71927cfafae14c7bd048d" title="Calcule le max de x sur tous les processeurs du groupe courant. Remarques : Cette methode doit etre a...">mp_max</a>(<a class="code" href="classAssembleur__P__VDF.html#a9d277900967c598cd61dcc14dcb7ebbd">has_P_ref</a>);
<a name="l00472"></a>00472 
<a name="l00473"></a>00473 <span class="comment">// Verification sanitaire: pas d&#39;element nul sur la diagonale</span>
<a name="l00474"></a>00474   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; nb_elem; i++)
<a name="l00475"></a>00475     {
<a name="l00476"></a>00476       <span class="keyword">const</span> <span class="keywordtype">int</span> index = carre_tab1[i];
<a name="l00477"></a>00477       <span class="keyword">const</span> <span class="keywordtype">double</span> coeff_diagonal = carre_coeff[index - 1];
<a name="l00478"></a>00478       <span class="keywordflow">if</span> (coeff_diagonal == 0.)
<a name="l00479"></a>00479         {
<a name="l00480"></a>00480 <span class="comment">// La maille i n&#39;a pas de voisin: pression quelconque</span>
<a name="l00481"></a>00481           carre_coeff[index - 1] = 1.;
<a name="l00482"></a>00482         }
<a name="l00483"></a>00483     }
<a name="l00484"></a>00484 
<a name="l00485"></a>00485   carre.compacte();
<a name="l00486"></a>00486   rect.compacte();
<a name="l00487"></a>00487   <span class="keywordflow">return</span> 1;
<a name="l00488"></a>00488 }
<a name="l00489"></a>00489 
<a name="l00490"></a>00490 <span class="comment">//</span>
<a name="l00491"></a>00491 <span class="comment">//</span>
<a name="l00492"></a>00492 <span class="comment">//</span>
<a name="l00493"></a>00493 <span class="comment">//</span>
<a name="l00494"></a>00494 <span class="comment">//</span>
<a name="l00495"></a>00495 <span class="comment">//</span>
<a name="l00496"></a>00496 <span class="comment">//</span><span class="comment"></span>
<a name="l00497"></a>00497 <span class="comment">//! Modification du second membre pour appliquer les conditions aux limites.&lt;br&gt;Les conditions prises en charge sont&lt;br&gt;Neumann_sortie_libre,&lt;br&gt;Entree_fluide_vitesse_imposee,&lt;br&gt;Dirichlet_paroi_defilante (rien a faire),&lt;br&gt;Dirichlet_paroi_fixe (rien a faire),&lt;br&gt;Symetrie (rien a faire)</span>
<a name="l00498"></a><a class="code" href="classAssembleur__P__VDF.html#adcac76493991056ab933d63ebff5e780">00498</a> <span class="comment"></span><span class="keywordtype">int</span> <a class="code" href="classAssembleur__P__VDF.html#adcac76493991056ab933d63ebff5e780" title="Modification du second membre pour appliquer les conditions aux limites. Les conditions prises en cha...">Assembleur_P_VDF::modifier_secmem</a>(<a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; secmem)
<a name="l00499"></a>00499 {
<a name="l00500"></a>00500   <span class="keyword">const</span> <a class="code" href="classZone__Cl__VDF.html" title="&lt; namespace TypeAreteCoinVDF">Zone_Cl_VDF</a>&amp; la_zone_cl = <a class="code" href="classAssembleur__P__VDF.html#a0b984a6831f2750865e12296e5e07a2b">la_zone_Cl_VDF</a>.<a class="code" href="classRef__Zone__Cl__VDF.html#a1e655604e840cda5b393e45f975b73ff">valeur</a>();
<a name="l00501"></a>00501   <span class="keywordtype">int</span> nb_cond_lim = la_zone_cl.<a class="code" href="classZone__Cl__dis__base.html#aa6f1df56cfd6e2eae83cc991c7cc9b41" title="Renvoie le nombre de conditions aux limites.">nb_cond_lim</a>();
<a name="l00502"></a>00502 
<a name="l00503"></a>00503   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> indice_cl = 0; indice_cl &lt; nb_cond_lim; indice_cl++)
<a name="l00504"></a>00504     {
<a name="l00505"></a>00505       <span class="keyword">const</span> <a class="code" href="classCond__lim__base.html" title="classe Cond_lim_base Classe de base pour la hierarchie des classes qui representent les differentes c...">Cond_lim_base</a>&amp; la_cl_base =
<a name="l00506"></a>00506         la_zone_cl.<a class="code" href="classZone__Cl__dis__base.html#af75e0ed7786863e4d333bfb29d67c323" title="Renvoie la i-ieme condition aux limites. (version const)">les_conditions_limites</a>(indice_cl).<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>();
<a name="l00507"></a>00507 
<a name="l00508"></a>00508       <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp; frontiere_vf = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>, la_cl_base.<a class="code" href="classCond__lim__base.html#ad88b3b516351146c85e8fce1df0f691a" title="Renvoie la frontiere discretisee a laquelle les conditions aux limites s&#39;appliquent.">frontiere_dis</a>());
<a name="l00509"></a>00509 
<a name="l00510"></a>00510       <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classNeumann__sortie__libre.html" title="classe Neumann_sortie_libre Cette classe represente une frontiere ouverte sans vitesse imposee Pour l...">Neumann_sortie_libre</a>, la_cl_base))
<a name="l00511"></a>00511         {
<a name="l00512"></a>00512           <a class="code" href="classAssembleur__P__VDF.html#a3e01aa32a7925771e8f8abf2f3556ebb" title="Modification du second membre du solveur en pression pour une condition &quot;Neumann_sortie_libre&quot;. Calcul en &quot;increment de pression&quot; : ajouter l&#39;increment de pression, c&#39;est a dire zero (c.l. instationnaire non supportee) Calcul en &quot;pression&quot; : Ajout du terme Pimpose * surface / volume_entrelace au second membre dans la discretisation de la pression au bord (entre un element elem0 et un element fictif exterieur a pression imposee) : grad P = (P(elem0) - Pimpose) * surface / volume_entrelace.">modifier_secmem_pression_imposee</a>(<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>( <a class="code" href="classNeumann__sortie__libre.html" title="classe Neumann_sortie_libre Cette classe represente une frontiere ouverte sans vitesse imposee Pour l...">Neumann_sortie_libre</a>, la_cl_base),
<a name="l00513"></a>00513                                            frontiere_vf,
<a name="l00514"></a>00514                                            secmem);
<a name="l00515"></a>00515         }
<a name="l00516"></a>00516       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classEntree__fluide__vitesse__imposee.html" title="classe Entree_fluide_vitesse_imposee Cas particulier de la classe Dirichlet_entree_fluide pour la vit...">Entree_fluide_vitesse_imposee</a>, la_cl_base))
<a name="l00517"></a>00517         {
<a name="l00518"></a>00518           <a class="code" href="classAssembleur__P__VDF.html#a9479432519c9424e8d5c6be2ce7a5493" title="Modification du second membre du systeme en pression pour une condition aux limites de vitesse impose...">modifier_secmem_vitesse_imposee</a>(<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classEntree__fluide__vitesse__imposee.html" title="classe Entree_fluide_vitesse_imposee Cas particulier de la classe Dirichlet_entree_fluide pour la vit...">Entree_fluide_vitesse_imposee</a> ,la_cl_base),
<a name="l00519"></a>00519                                           frontiere_vf,
<a name="l00520"></a>00520                                           secmem);
<a name="l00521"></a>00521         }
<a name="l00522"></a>00522       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classDirichlet__paroi__defilante.html" title="classe Dirichlet_paroi_defilante Impose la vitesse de paroi dnas une equation de type Navier_Stokes...">Dirichlet_paroi_defilante</a>, la_cl_base))
<a name="l00523"></a>00523         {
<a name="l00524"></a>00524 <span class="comment">// Pour une paroi defilante, rien a faire.</span>
<a name="l00525"></a>00525         }
<a name="l00526"></a>00526       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classDirichlet__paroi__fixe.html" title="classe Dirichlet_paroi_fixe Represente une paroi immobile dans une equation de type Navier_Stokes...">Dirichlet_paroi_fixe</a>, la_cl_base))
<a name="l00527"></a>00527         {
<a name="l00528"></a>00528 <span class="comment">// Rien a faire non plus.</span>
<a name="l00529"></a>00529         }
<a name="l00530"></a>00530       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classSymetrie.html" title="classe Symetrie Sur les faces de symetrie on a les proprietes suivantes: - composante normale de la v...">Symetrie</a>, la_cl_base))
<a name="l00531"></a>00531         {
<a name="l00532"></a>00532 <span class="comment">// Encore rien a faire</span>
<a name="l00533"></a>00533         }
<a name="l00534"></a>00534       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>, la_cl_base))
<a name="l00535"></a>00535         {
<a name="l00536"></a>00536 <span class="comment">// Rien a faire</span>
<a name="l00537"></a>00537         }
<a name="l00538"></a>00538       <span class="keywordflow">else</span>
<a name="l00539"></a>00539         {
<a name="l00540"></a>00540           <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Erreur dans Assembleur_P_VDF::modifier_secmem\n la condition aux limites &quot;</span>;
<a name="l00541"></a>00541           <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; la_cl_base.<a class="code" href="classObjet__U.html#aa58e9a81c0ddc2c1149053b8f96698ac" title="renvoie la chaine identifiant la classe.">que_suis_je</a>() &lt;&lt; <span class="stringliteral">&quot; n&#39;est pas prise en charge.&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
<a name="l00542"></a>00542           assert(0);
<a name="l00543"></a>00543           <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">exit</a>();
<a name="l00544"></a>00544         }
<a name="l00545"></a>00545     }
<a name="l00546"></a>00546   secmem.<a class="code" href="classDoubleVect.html#abfebbc2f685ce7bc4b80c720d7da9bf3">echange_espace_virtuel</a>();
<a name="l00547"></a>00547   <span class="keywordflow">return</span> 1;
<a name="l00548"></a>00548 }
<a name="l00549"></a>00549 
<a name="l00550"></a>00550 <span class="comment">//</span>
<a name="l00551"></a>00551 <span class="comment">//</span>
<a name="l00552"></a>00552 <span class="comment">//</span>
<a name="l00553"></a>00553 <span class="comment">//</span>
<a name="l00554"></a>00554 <span class="comment">//</span>
<a name="l00555"></a>00555 <span class="comment">//</span>
<a name="l00556"></a>00556 <span class="comment">//</span>
<a name="l00557"></a>00557 <span class="comment">//</span><span class="comment"></span>
<a name="l00558"></a>00558 <span class="comment">//! Modification du second membre du solveur en pression pour une condition&lt;br&gt;&quot;Neumann_sortie_libre&quot;.&lt;br&gt;Calcul en &quot;increment de pression&quot; :&lt;br&gt;ajouter l&#39;increment de pression, c&#39;est a dire zero (c.l. instationnaire non supportee)&lt;br&gt;Calcul en &quot;pression&quot; :&lt;br&gt;Ajout du terme Pimpose * surface / volume_entrelace au second membre dans la discretisation de la&lt;br&gt;pression au bord (entre un element elem0 et un element fictif exterieur a pression imposee) :&lt;br&gt;grad P = (P(elem0) - Pimpose) * surface / volume_entrelace</span>
<a name="l00559"></a>00559 <span class="comment"></span>
<a name="l00560"></a><a class="code" href="classAssembleur__P__VDF.html#a3e01aa32a7925771e8f8abf2f3556ebb">00560</a> <span class="keywordtype">void</span> <a class="code" href="classAssembleur__P__VDF.html#a3e01aa32a7925771e8f8abf2f3556ebb" title="Modification du second membre du solveur en pression pour une condition &quot;Neumann_sortie_libre&quot;. Calcul en &quot;increment de pression&quot; : ajouter l&#39;increment de pression, c&#39;est a dire zero (c.l. instationnaire non supportee) Calcul en &quot;pression&quot; : Ajout du terme Pimpose * surface / volume_entrelace au second membre dans la discretisation de la pression au bord (entre un element elem0 et un element fictif exterieur a pression imposee) : grad P = (P(elem0) - Pimpose) * surface / volume_entrelace.">Assembleur_P_VDF::modifier_secmem_pression_imposee</a>(<span class="keyword">const</span> <a class="code" href="classNeumann__sortie__libre.html" title="classe Neumann_sortie_libre Cette classe represente une frontiere ouverte sans vitesse imposee Pour l...">Neumann_sortie_libre</a>&amp; cond_lim,
<a name="l00561"></a>00561                                                         <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp; frontiere_vf,
<a name="l00562"></a>00562                                                         <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; secmem)
<a name="l00563"></a>00563 {
<a name="l00564"></a>00564   <span class="keyword">const</span> <a class="code" href="classZone__VDF.html" title="class Zone_VDF Classe instanciable qui derive de Zone_VF. Cette classe contient les informations geom...">Zone_VDF</a>&amp; la_zone = <a class="code" href="classAssembleur__P__VDF.html#a4ce1358c35e162057c7968aa583cd581">la_zone_VDF</a>.<a class="code" href="classRef__Zone__VDF.html#a84151da4db745d02791d6246e3682b67">valeur</a>();
<a name="l00565"></a>00565   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; face_voisins = la_zone.<a class="code" href="classZone__VF.html#a49d4322f5585a8fa95748ca785b70702" title="renvoie l&#39;element voisin de numface dans la direction i. i=0 : dans le sens oppose de l&#39;axe orthogona...">face_voisins</a>();
<a name="l00566"></a>00566   <span class="keywordflow">if</span> (<a class="code" href="classAssembleur__base.html#afb2f8c92496b38dcafa391fe380c0385" title="Renvoie la valeur du drapeau resoudre_increment_pression_ (0 ou 1) Renvoie -1 si le drapeau n&#39;a pas e...">get_resoudre_increment_pression</a>())
<a name="l00567"></a>00567     {
<a name="l00568"></a>00568       <span class="comment">/*</span>
<a name="l00569"></a>00569 <span class="comment">        const Champ_front_base &amp; champ_front = cond_lim.champ_front().valeur();</span>
<a name="l00570"></a>00570 <span class="comment">        if (sub_type(Champ_front_instationnaire_base, champ_front)</span>
<a name="l00571"></a>00571 <span class="comment">        || sub_type(Champ_front_var_instationnaire, champ_front)) {</span>
<a name="l00572"></a>00572 <span class="comment">        Cerr &lt;&lt; &quot;Erreur dans Assembleur_P_VDF::modifier_secmem_pression_imposee\n &quot;;</span>
<a name="l00573"></a>00573 <span class="comment">        Cerr &lt;&lt; champ_front.que_suis_je();</span>
<a name="l00574"></a>00574 <span class="comment">        Cerr &lt;&lt; &quot; + resoudre_increment_pression non code&quot; &lt;&lt; finl;</span>
<a name="l00575"></a>00575 <span class="comment">        assert(0);</span>
<a name="l00576"></a>00576 <span class="comment">        exit();</span>
<a name="l00577"></a>00577 <span class="comment">        } else {</span>
<a name="l00578"></a>00578 <span class="comment">        // Champ stationnaire, on ajoute un increment de pression nul.</span>
<a name="l00579"></a>00579 <span class="comment">        // Donc rien a faire.</span>
<a name="l00580"></a>00580 <span class="comment">        }</span>
<a name="l00581"></a>00581 <span class="comment">      */</span>
<a name="l00582"></a>00582     }
<a name="l00583"></a>00583   <span class="keywordflow">else</span>
<a name="l00584"></a>00584     {
<a name="l00585"></a>00585       <span class="keyword">const</span> <span class="keywordtype">int</span> nb_faces = frontiere_vf.<a class="code" href="classFront__VF.html#a341e2fcb5117b96e745fd7078ba86bab" title="Nombre de faces reelles du bord.">nb_faces</a>();
<a name="l00586"></a>00586       <span class="keyword">const</span> <span class="keywordtype">int</span> num_premiere_face = frontiere_vf.<a class="code" href="classFront__VF.html#a4986f0c65653fe9eb40bbbff5a97bf16" title="Numero de la premiere face du bord dans la liste des faces.">num_premiere_face</a>();
<a name="l00587"></a>00587       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; nb_faces; i++)
<a name="l00588"></a>00588         {
<a name="l00589"></a>00589           <span class="keyword">const</span> <span class="keywordtype">int</span> num_face = num_premiere_face + i;
<a name="l00590"></a>00590           <span class="keyword">const</span> <span class="keywordtype">double</span> Pimp = cond_lim.<a class="code" href="classNeumann.html#a4f6ee6cc54ca6471254c2a530c5b70b5" title="Renvoie la valeur du flux impose sur la i-eme composante du champ representant le flux a la frontiere...">flux_impose</a>(i);
<a name="l00591"></a>00591           <span class="keyword">const</span> <span class="keywordtype">double</span> coef = <a class="code" href="classAssembleur__P__VDF.html#af8eca29a2e48d27e8e1f77e0945dc38d">les_coeff_pression</a>[num_face] * Pimp;
<a name="l00592"></a>00592           <span class="keyword">const</span> <span class="keywordtype">int</span> elem = face_voisins(num_face, 0) + face_voisins(num_face, 1) + 1;
<a name="l00593"></a>00593           secmem[elem] += coef;
<a name="l00594"></a>00594         }
<a name="l00595"></a>00595     }
<a name="l00596"></a>00596 }
<a name="l00597"></a>00597 
<a name="l00598"></a>00598 <span class="comment">//</span>
<a name="l00599"></a>00599 <span class="comment">//</span>
<a name="l00600"></a>00600 <span class="comment">//</span>
<a name="l00601"></a>00601 <span class="comment">//</span><span class="comment"></span>
<a name="l00602"></a>00602 <span class="comment">//! Modification du second membre du systeme en pression pour une condition aux limites&lt;br&gt;de vitesse imposee.&lt;br&gt;Si on resout en increment de pression, ...&lt;br&gt;sinon rien a faire.</span>
<a name="l00603"></a><a class="code" href="classAssembleur__P__VDF.html#a9479432519c9424e8d5c6be2ce7a5493">00603</a> <span class="comment"></span><span class="keywordtype">void</span> <a class="code" href="classAssembleur__P__VDF.html#a9479432519c9424e8d5c6be2ce7a5493" title="Modification du second membre du systeme en pression pour une condition aux limites de vitesse impose...">Assembleur_P_VDF::modifier_secmem_vitesse_imposee</a>(<span class="keyword">const</span> <a class="code" href="classEntree__fluide__vitesse__imposee.html" title="classe Entree_fluide_vitesse_imposee Cas particulier de la classe Dirichlet_entree_fluide pour la vit...">Entree_fluide_vitesse_imposee</a>&amp; cond_lim,
<a name="l00604"></a>00604                                                        <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp; frontiere_vf,
<a name="l00605"></a>00605                                                        <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; secmem)
<a name="l00606"></a>00606 {
<a name="l00607"></a>00607   <span class="keyword">const</span> <a class="code" href="classChamp__front__base.html" title="classe Champ_front_base Classe de base pour la hierarchie des champs aux frontieres. Un objet Champ_front_base definit un champ sur la frontiere d&#39;un domaine. Un objet de type Champ_front_base sera associe a chaque condition aux limites. Champ_front_base derive de Champ_Proto, afin d&#39;avoir une interface conforme a tous les champs, et d&#39;heriter des operations courantes sur les Champs. Les deux methodes principales sont initialiser et mettre_a_jour. Ce sont les deux seules qui peuvent modifier les valeurs du champ. La methode initialiser est appelee une fois au debut du calcul. Elle ne doit pas dependre de donnees exterieures a l&#39;equation qui porte la CL (en effet, rien ne garantit que ces donnees sont initialisees). En revanche, les valeurs de l&#39;inconnue sur laquelle porte la CL peuvent etre utiles pour l&#39;initialisation =&gt; l&#39;inconnue est passee en parametre en lecture seule. La methode mettre_a_jour est appelee au debut de chaque pas de temps ou sous-pas-de-temps, elle peut utiliser des donnees exterieures a l&#39;equation. A charge a l&#39;algorithme de s&#39;assurer que ces donnees sont pertinentes... Dans le cas de champs stationnaires, la methode mettre_a_jour n&#39;a rien a faire et les valeurs sont remplies une fois pour toutes par la methode initialiser. Dans le cas de champs instationnaires, il y a plusieurs valeurs en temps et chacune peut etre mise a jour. Les Champ_front sont divises en : * Champ_front_uniforme, constant dans le temps et l&#39;espace * Champ_front_instationnaire_base, uniformes en espace mais variables en temps * Champ_front_var, variables en espace. Les Champ_front_var sont ensuite classes selon qu&#39;ils sont stationnaires ou instationnaires. Les valeurs sont stockees dans une roue de DoubleTab. Si le champ est uniforme en espace, les DoubleTab sont dimensionnes a 1. S&#39;il est stationnaire, la roue n&#39;a qu&#39;une valeur temporelle et le temps qui lui est assigne n&#39;a pas de sens. S&#39;il est instationnaire, les valeurs temporelles sont celles de l&#39;inconnue de l&#39;equation a laquelle se rapporte le champ.">Champ_front_base</a>&amp; champ_front = cond_lim.<a class="code" href="classCond__lim__base.html#a8cddc02f544ee44bebd5bae0e6a9581c">champ_front</a>().<a class="code" href="classDeriv__Champ__front__base.html#a5405a20c106b868a23805a45c4436a53">valeur</a>();
<a name="l00608"></a>00608   <span class="keyword">const</span> <a class="code" href="classZone__VDF.html" title="class Zone_VDF Classe instanciable qui derive de Zone_VF. Cette classe contient les informations geom...">Zone_VDF</a>&amp; la_zone = <a class="code" href="classAssembleur__P__VDF.html#a4ce1358c35e162057c7968aa583cd581">la_zone_VDF</a>.<a class="code" href="classRef__Zone__VDF.html#a84151da4db745d02791d6246e3682b67">valeur</a>();
<a name="l00609"></a>00609   <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; face_surfaces = la_zone.<a class="code" href="classZone__VF.html#a40c3382b189a4fc508cf1c3e37b04b21">face_surfaces</a>();
<a name="l00610"></a>00610   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; face_voisins = la_zone.<a class="code" href="classZone__VF.html#a49d4322f5585a8fa95748ca785b70702" title="renvoie l&#39;element voisin de numface dans la direction i. i=0 : dans le sens oppose de l&#39;axe orthogona...">face_voisins</a>();
<a name="l00611"></a>00611 
<a name="l00612"></a>00612   <span class="keywordflow">if</span> (<a class="code" href="classAssembleur__base.html#a3744c3df3886e9fc65246c2eb1abb794" title="Renvoie la valeur du drapeau resoudre_en_u_ (0 ou 1) Renvoie -1 si le drapeau n&#39;a pas ete initialise...">get_resoudre_en_u</a>())
<a name="l00613"></a>00613     {
<a name="l00614"></a>00614       <span class="keywordtype">int</span> gpoint_variable;
<a name="l00615"></a>00615       <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classChamp__front__instationnaire__base.html" title="classe Champ_front_base Classe de base pour les Champs aux frontieres instationnaires, mais uniformes en espace. Les aspects temporels sont equivalents a ceux de Ch_front_var_instationnaire. En revanche, le tableau de valeurs est dimensionne a une seule valeur et n&#39;a pas d&#39;espace virtuel.">Champ_front_instationnaire_base</a>, champ_front))
<a name="l00616"></a>00616         gpoint_variable = 0; <span class="comment">//!&lt; Instationnaire uniforme</span>
<a name="l00617"></a>00617 <span class="comment"></span>      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classChamp__front__var__instationnaire.html" title="classe Champ_front_var_instationnaire Classe derivee de Champ_front_var qui represente les champs aux...">Champ_front_var_instationnaire</a>, champ_front))
<a name="l00618"></a>00618         gpoint_variable = 1; <span class="comment">//!&lt; Instationnaire variable</span>
<a name="l00619"></a>00619 <span class="comment"></span>      <span class="keywordflow">else</span>
<a name="l00620"></a>00620         gpoint_variable = -1; <span class="comment">//!&lt; Stationnaire</span>
<a name="l00621"></a>00621 <span class="comment"></span>
<a name="l00622"></a>00622       <span class="keywordflow">if</span> (gpoint_variable &gt;= 0)
<a name="l00623"></a>00623         {
<a name="l00624"></a>00624           <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; tab_gpoint = (gpoint_variable)
<a name="l00625"></a>00625                                         ? <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classChamp__front__var__instationnaire.html" title="classe Champ_front_var_instationnaire Classe derivee de Champ_front_var qui represente les champs aux...">Champ_front_var_instationnaire</a>,  champ_front).Gpoint()
<a name="l00626"></a>00626                                         : <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classChamp__front__instationnaire__base.html" title="classe Champ_front_base Classe de base pour les Champs aux frontieres instationnaires, mais uniformes en espace. Les aspects temporels sont equivalents a ceux de Ch_front_var_instationnaire. En revanche, le tableau de valeurs est dimensionne a une seule valeur et n&#39;a pas d&#39;espace virtuel.">Champ_front_instationnaire_base</a>, champ_front).Gpoint();
<a name="l00627"></a>00627 
<a name="l00628"></a>00628           <span class="keyword">const</span> <span class="keywordtype">int</span> nb_faces = frontiere_vf.<a class="code" href="classFront__VF.html#a341e2fcb5117b96e745fd7078ba86bab" title="Nombre de faces reelles du bord.">nb_faces</a>();
<a name="l00629"></a>00629           <span class="keyword">const</span> <span class="keywordtype">int</span> num_premiere_face = frontiere_vf.<a class="code" href="classFront__VF.html#a4986f0c65653fe9eb40bbbff5a97bf16" title="Numero de la premiere face du bord dans la liste des faces.">num_premiere_face</a>();
<a name="l00630"></a>00630           <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; nb_faces; i++)
<a name="l00631"></a>00631             {
<a name="l00632"></a>00632               <span class="keyword">const</span> <span class="keywordtype">int</span> num_face = num_premiere_face + i;
<a name="l00633"></a>00633               <span class="keyword">const</span> <span class="keywordtype">double</span> surface = face_surfaces(num_face);
<a name="l00634"></a>00634               <span class="keyword">const</span> <span class="keywordtype">int</span> elem0 = face_voisins(num_face, 0);
<a name="l00635"></a>00635               <span class="keyword">const</span> <span class="keywordtype">int</span> elem1 = face_voisins(num_face, 1);
<a name="l00636"></a>00636 <span class="comment">// gpoint est relatif a la normale a la face (elle pointe vers elem1)</span>
<a name="l00637"></a>00637 <span class="comment">// La normale est-elle entrante ou sortante ?</span>
<a name="l00638"></a>00638               <span class="keyword">const</span> <span class="keywordtype">double</span> signe = (elem0 &lt; 0) ? 1. : -1.;
<a name="l00639"></a>00639 <span class="comment">// Numero de l&#39;element adjacent a la face de bord</span>
<a name="l00640"></a>00640               <span class="keyword">const</span> <span class="keywordtype">int</span> elem = elem0 + elem1 + 1;
<a name="l00641"></a>00641               <span class="keyword">const</span> <span class="keywordtype">int</span> ori = la_zone.<a class="code" href="classZone__VDF.html#a9a9bd747218e463b3408a3590c12814c" title="inline DoubleVect&amp; Zone_VDF::porosite_face() { return porosite_face_; }">orientation</a>(num_face);
<a name="l00642"></a>00642               <span class="keyword">const</span> <span class="keywordtype">double</span> gpoint = (gpoint_variable) ? tab_gpoint(i, ori) : tab_gpoint(ori);
<a name="l00643"></a>00643 
<a name="l00644"></a>00644               secmem[elem] += signe * surface * gpoint;
<a name="l00645"></a>00645             }
<a name="l00646"></a>00646         }
<a name="l00647"></a>00647       <span class="keywordflow">else</span>
<a name="l00648"></a>00648         {
<a name="l00649"></a>00649 <span class="comment">// Le champ frontiere est stationnaire, rien a faire.</span>
<a name="l00650"></a>00650         }
<a name="l00651"></a>00651     }
<a name="l00652"></a>00652   <span class="keywordflow">else</span>
<a name="l00653"></a>00653     {
<a name="l00654"></a>00654 <span class="comment">// Resolution en pression: la condition aux limites est imposee ailleurs</span>
<a name="l00655"></a>00655     }
<a name="l00656"></a>00656 }
<a name="l00657"></a>00657 
<a name="l00658"></a><a class="code" href="classAssembleur__P__VDF.html#a47e1e481696ee70a0a542926e77573b2">00658</a> <span class="keywordtype">int</span> <a class="code" href="classAssembleur__P__VDF.html#a47e1e481696ee70a0a542926e77573b2">Assembleur_P_VDF::modifier_solution</a>(<a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; pression)
<a name="l00659"></a>00659 {
<a name="l00660"></a>00660 <span class="comment">// Projection :</span>
<a name="l00661"></a>00661   <span class="keywordtype">double</span> press_0;
<a name="l00662"></a>00662   <span class="keywordflow">if</span>(!<a class="code" href="classAssembleur__P__VDF.html#a9d277900967c598cd61dcc14dcb7ebbd">has_P_ref</a>)
<a name="l00663"></a>00663     {
<a name="l00664"></a>00664 <span class="comment">// On prend la pression minimale comme pression de reference</span>
<a name="l00665"></a>00665 <span class="comment">// afin d&#39;avoir la meme pression de reference en sequentiel et parallele</span>
<a name="l00666"></a>00666       press_0=<a class="code" href="Double_8h.html#ae0ee0cebfad5968da0ad6cc7a49e16b6">DMAXFLOAT</a>;
<a name="l00667"></a>00667       <span class="keywordtype">int</span> nb_elem=<a class="code" href="classAssembleur__P__VDF.html#a4ce1358c35e162057c7968aa583cd581">la_zone_VDF</a>.<a class="code" href="classRef__Zone__VDF.html#a84151da4db745d02791d6246e3682b67">valeur</a>().<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#a7f249429803b27139a1c54436f6164a5" title="Renvoie le nombre d&#39;elements de la zone.">nb_elem</a>();
<a name="l00668"></a>00668       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> n=0; n&lt;nb_elem; n++)
<a name="l00669"></a>00669         <span class="keywordflow">if</span> (pression[n] &lt; press_0)
<a name="l00670"></a>00670           press_0 = pression[n];
<a name="l00671"></a>00671       press_0 = <a class="code" href="classProcess.html#a05de57db7288d95f9e67046af585d5ff" title="Calcule le min de x sur tous les processeurs du groupe courant. Voir aussi mp_max()">mp_min</a>(press_0);
<a name="l00672"></a>00672       pression -=press_0;
<a name="l00673"></a>00673       pression.<a class="code" href="classDoubleVect.html#abfebbc2f685ce7bc4b80c720d7da9bf3">echange_espace_virtuel</a>();
<a name="l00674"></a>00674     }
<a name="l00675"></a>00675   <span class="keywordflow">return</span> 1;
<a name="l00676"></a>00676 }
<a name="l00677"></a><a class="code" href="classAssembleur__P__VDF.html#a7360af042ae3d4713acc92707c421a48">00677</a> <span class="keywordtype">int</span> <a class="code" href="classAssembleur__P__VDF.html#a7360af042ae3d4713acc92707c421a48">Assembleur_P_VDF::assembler_mat</a>(<a class="code" href="classMatrice.html">Matrice</a>&amp; matrice,<span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; volumes_entrelaces,<span class="keywordtype">int</span> incr_pression,<span class="keywordtype">int</span> resoudre_en_u)
<a name="l00678"></a>00678 {
<a name="l00679"></a>00679   <span class="keywordflow">if</span> (! matrice.<a class="code" href="classO__U__Ptr.html#a16f216b2d169e885876419182658ddcc" title="Renvoie 1 si le pointeur est non_nul Renvoie 0 sinon.">non_nul</a>())
<a name="l00680"></a>00680     {
<a name="l00681"></a>00681       <span class="keywordflow">if</span> (<a class="code" href="classProcess.html#acd052b99706c577f8a5b6656217cf4c2" title="renvoie 1 si on est sur le processeur maitre du groupe courant (c&#39;est a dire me() == 0)...">je_suis_maitre</a>())
<a name="l00682"></a>00682         <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Assemblage de la matrice pression : Assembleur_P_VDF::assembler&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
<a name="l00683"></a>00683 <span class="comment">// Par defaut, resolution en increment de pression</span>
<a name="l00684"></a>00684       <a class="code" href="classAssembleur__P__VDF.html#aa56befba8f81a9161c144f009d3cdddd" title="Determine les elements non nuls de la matrice et prepare le stockage. Matrice creuse de taille nb_ele...">construire</a>(matrice);
<a name="l00685"></a>00685     }
<a name="l00686"></a>00686   <a class="code" href="classAssembleur__base.html#ad134c3371f3ced3768a1704be52e0fe8" title="Definit la valeur du drapeau resoudre_increment_pression_. Ce drapeau determine si le solveur en pres...">set_resoudre_increment_pression</a>(incr_pression);
<a name="l00687"></a>00687   <a class="code" href="classAssembleur__base.html#a9cdaa49e5340da74de179c2f22f08605" title="Definit la valeur du drapeau resoudre_en_u__. Ce drapeau determine si le solveur en pression resou en...">set_resoudre_en_u</a>(resoudre_en_u);
<a name="l00688"></a>00688 
<a name="l00689"></a>00689   <a class="code" href="classAssembleur__P__VDF.html#ae6419915244b87d5c8f186d7c4fc1992" title="Calcul des coefficients de la matrice de pression avec un champ de rho. Si rho_ptr == 0...">remplir</a>(matrice,volumes_entrelaces, 0);
<a name="l00690"></a>00690   <span class="keywordflow">return</span> 1;
<a name="l00691"></a>00691 }
<a name="l00692"></a>00692 
<a name="l00693"></a>00693 <span class="comment">//</span>
<a name="l00694"></a>00694 <span class="comment">//</span>
<a name="l00695"></a>00695 <span class="comment">//</span><span class="comment"></span>
<a name="l00696"></a>00696 <span class="comment">//! Assemblage de la matrice de pression M telle que&lt;br&gt;M*P = div(porosite * grad (P))&lt;br&gt;et calcul des coefficients pour modifier_secmem.</span>
<a name="l00697"></a><a class="code" href="classAssembleur__P__VDF.html#a043e47e99329ef400ed57fce0a54ffc7">00697</a> <span class="comment"></span><span class="keywordtype">int</span> <a class="code" href="classAssembleur__P__VDF.html#a043e47e99329ef400ed57fce0a54ffc7" title="Assemblage de la matrice de pression M telle que M*P = div(porosite * grad (P)) et calcul des coeffic...">Assembleur_P_VDF::assembler</a>(<a class="code" href="classMatrice.html">Matrice</a>&amp; matrice)
<a name="l00698"></a>00698 {
<a name="l00699"></a>00699   <span class="keywordflow">if</span> (<a class="code" href="classProcess.html#acd052b99706c577f8a5b6656217cf4c2" title="renvoie 1 si on est sur le processeur maitre du groupe courant (c&#39;est a dire me() == 0)...">je_suis_maitre</a>())
<a name="l00700"></a>00700     <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Assemblage de la matrice pression : Assembleur_P_VDF::assembler&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
<a name="l00701"></a>00701 <span class="comment">// Par defaut, resolution en increment de pression</span>
<a name="l00702"></a>00702   <a class="code" href="classAssembleur__base.html#ad134c3371f3ced3768a1704be52e0fe8" title="Definit la valeur du drapeau resoudre_increment_pression_. Ce drapeau determine si le solveur en pres...">set_resoudre_increment_pression</a>(1);
<a name="l00703"></a>00703   <a class="code" href="classAssembleur__base.html#a9cdaa49e5340da74de179c2f22f08605" title="Definit la valeur du drapeau resoudre_en_u__. Ce drapeau determine si le solveur en pression resou en...">set_resoudre_en_u</a>(1);
<a name="l00704"></a>00704   <a class="code" href="classAssembleur__P__VDF.html#aa56befba8f81a9161c144f009d3cdddd" title="Determine les elements non nuls de la matrice et prepare le stockage. Matrice creuse de taille nb_ele...">construire</a>(matrice);
<a name="l00705"></a>00705   <span class="keyword">const</span> <a class="code" href="classZone__VDF.html" title="class Zone_VDF Classe instanciable qui derive de Zone_VF. Cette classe contient les informations geom...">Zone_VDF</a>&amp; zone_vdf   = <a class="code" href="classAssembleur__P__VDF.html#a4ce1358c35e162057c7968aa583cd581">la_zone_VDF</a>.<a class="code" href="classRef__Zone__VDF.html#a84151da4db745d02791d6246e3682b67">valeur</a>();
<a name="l00706"></a>00706 
<a name="l00707"></a>00707   <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; volumes_entrelaces = zone_vdf.<a class="code" href="classZone__VF.html#a64f0b549e5aea1656855113e3510f418">volumes_entrelaces</a>();
<a name="l00708"></a>00708   <a class="code" href="classAssembleur__P__VDF.html#ae6419915244b87d5c8f186d7c4fc1992" title="Calcul des coefficients de la matrice de pression avec un champ de rho. Si rho_ptr == 0...">remplir</a>(matrice,volumes_entrelaces, 0);
<a name="l00709"></a>00709   <span class="keywordflow">return</span> 1;
<a name="l00710"></a>00710 }
<a name="l00711"></a>00711 
<a name="l00712"></a>00712 <span class="comment">//</span>
<a name="l00713"></a>00713 <span class="comment">//</span>
<a name="l00714"></a>00714 <span class="comment">//</span>
<a name="l00715"></a>00715 <span class="comment">//</span>
<a name="l00716"></a>00716 <span class="comment">//</span>
<a name="l00717"></a>00717 <span class="comment">//</span>
<a name="l00718"></a>00718 <span class="comment">//</span>
<a name="l00719"></a>00719 <span class="comment">//</span>
<a name="l00720"></a>00720 <span class="comment">//</span><span class="comment"></span>
<a name="l00721"></a>00721 <span class="comment">//! Assemblage de la matrice de pression M telle que&lt;br&gt;M*P = div(porosite/rho * grad (P))&lt;br&gt;et calcul des coefficients pour modifier_secmem.&lt;br&gt;Parametre: matrice&lt;br&gt;Signification: La matrice a assembler.&lt;br&gt;Contrainte:    Soit la matrice n&#39;est pas encore typee (alors on la &quot;construit&quot;),&lt;br&gt;soit c&#39;est la meme que lors de l&#39;appel precedent.&lt;br&gt;Parametre: rho&lt;br&gt;Contrainte: Doit etre un champ de type Champ_Fonc_Face.</span>
<a name="l00722"></a><a class="code" href="classAssembleur__P__VDF.html#aafa5800907c06a84ce79890cc9f736e7">00722</a> <span class="comment"></span><span class="keywordtype">int</span> <a class="code" href="classAssembleur__P__VDF.html#aafa5800907c06a84ce79890cc9f736e7" title="Assemblage de la matrice de pression M telle que M*P = div(porosite/rho * grad (P)) et calcul des coe...">Assembleur_P_VDF::assembler_rho_variable</a>(<a class="code" href="classMatrice.html">Matrice</a>&amp; matrice,
<a name="l00723"></a>00723                                              <span class="keyword">const</span> <a class="code" href="classChamp__Don__base.html" title="classe Champ_Don_base classe de base des Champs donnes (non calcules) les proprietes physiques sont d...">Champ_Don_base</a>&amp; rho)
<a name="l00724"></a>00724 {
<a name="l00725"></a>00725 <span class="comment">// assembler_rho_variable a ete introduit pour le front-tracking:</span>
<a name="l00726"></a>00726 <span class="comment">// il faut dire explicitement si on resout en increment de pression</span>
<a name="l00727"></a>00727   assert(<a class="code" href="classAssembleur__base.html#afb2f8c92496b38dcafa391fe380c0385" title="Renvoie la valeur du drapeau resoudre_increment_pression_ (0 ou 1) Renvoie -1 si le drapeau n&#39;a pas e...">get_resoudre_increment_pression</a>() &gt;= 0);
<a name="l00728"></a>00728 <span class="comment">// idem pour resoudre en u</span>
<a name="l00729"></a>00729   assert(<a class="code" href="classAssembleur__base.html#a3744c3df3886e9fc65246c2eb1abb794" title="Renvoie la valeur du drapeau resoudre_en_u_ (0 ou 1) Renvoie -1 si le drapeau n&#39;a pas ete initialise...">get_resoudre_en_u</a>() &gt;= 0);
<a name="l00730"></a>00730 <span class="comment">// Si la matrice n&#39;a pas encore ete typee, il faut la construire :</span>
<a name="l00731"></a>00731   <span class="keywordflow">if</span> (! matrice.<a class="code" href="classO__U__Ptr.html#a16f216b2d169e885876419182658ddcc" title="Renvoie 1 si le pointeur est non_nul Renvoie 0 sinon.">non_nul</a>())
<a name="l00732"></a>00732     {
<a name="l00733"></a>00733       <span class="keywordflow">if</span> (<a class="code" href="classProcess.html#acd052b99706c577f8a5b6656217cf4c2" title="renvoie 1 si on est sur le processeur maitre du groupe courant (c&#39;est a dire me() == 0)...">je_suis_maitre</a>())
<a name="l00734"></a>00734         {
<a name="l00735"></a>00735           <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Assemblage de la matrice pression : &quot;</span>;
<a name="l00736"></a>00736           <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Assembleur_P_VDF::assembler_rho_variable&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
<a name="l00737"></a>00737         }
<a name="l00738"></a>00738       <a class="code" href="classAssembleur__P__VDF.html#aa56befba8f81a9161c144f009d3cdddd" title="Determine les elements non nuls de la matrice et prepare le stockage. Matrice creuse de taille nb_ele...">construire</a>(matrice);
<a name="l00739"></a>00739     }
<a name="l00740"></a>00740   <span class="keyword">const</span> <a class="code" href="classZone__VDF.html" title="class Zone_VDF Classe instanciable qui derive de Zone_VF. Cette classe contient les informations geom...">Zone_VDF</a>&amp; zone_vdf   = <a class="code" href="classAssembleur__P__VDF.html#a4ce1358c35e162057c7968aa583cd581">la_zone_VDF</a>.<a class="code" href="classRef__Zone__VDF.html#a84151da4db745d02791d6246e3682b67">valeur</a>();
<a name="l00741"></a>00741 
<a name="l00742"></a>00742   <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; volumes_entrelaces = zone_vdf.<a class="code" href="classZone__VF.html#a64f0b549e5aea1656855113e3510f418">volumes_entrelaces</a>();
<a name="l00743"></a>00743   <a class="code" href="classAssembleur__P__VDF.html#ae6419915244b87d5c8f186d7c4fc1992" title="Calcul des coefficients de la matrice de pression avec un champ de rho. Si rho_ptr == 0...">remplir</a>(matrice,volumes_entrelaces, &amp; rho);
<a name="l00744"></a>00744   <span class="keywordflow">return</span> 1;
<a name="l00745"></a>00745 }
<a name="l00746"></a>00746 
<a name="l00747"></a>00747 <span class="comment">// Precondition:</span>
<a name="l00748"></a>00748 <span class="comment">// Parametre: DoubleTab&amp; tab_rho</span>
<a name="l00749"></a>00749 <span class="comment">// Signification: mass volumique</span>
<a name="l00750"></a>00750 <span class="comment">// Valeurs par defaut:</span>
<a name="l00751"></a>00751 <span class="comment">// Contraintes: reference constante</span>
<a name="l00752"></a>00752 <span class="comment">// Acces: lecture</span>
<a name="l00753"></a>00753 <span class="comment">// Exception:</span>
<a name="l00754"></a>00754 <span class="comment">// Effets de bord:</span>
<a name="l00755"></a>00755 <span class="comment">// Postcondition:</span>
<a name="l00756"></a>00756 <span class="comment">//</span>
<a name="l00757"></a>00757 <span class="comment">//</span>
<a name="l00758"></a>00758 <span class="comment">//</span>
<a name="l00759"></a>00759 <span class="comment">//</span><span class="comment"></span>
<a name="l00760"></a>00760 <span class="comment">//! Assemble la matrice de pression pour un fluide quasi compressible.&lt;br&gt;La matrice M est telle que M*P = div( porosite * grad(P) ).&lt;br&gt;Le drapeau resoudre_increment_pression est mis a zero s&#39;il n&#39;a pas&lt;br&gt;encore ete assigne.</span>
<a name="l00761"></a>00761 <span class="comment"></span><span class="comment">/** \return int&lt;br&gt;</span>
<a name="l00762"></a>00762 <span class="comment">Signification: renvoie toujours 1&lt;br&gt;</span>
<a name="l00763"></a>00763 <span class="comment">Contraintes: */</span>
<a name="l00764"></a><a class="code" href="classAssembleur__P__VDF.html#a1813c6eb0764db3280e0891e73b1ca60">00764</a> <span class="keywordtype">int</span> <a class="code" href="classAssembleur__P__VDF.html#a1813c6eb0764db3280e0891e73b1ca60" title="Assemble la matrice de pression pour un fluide quasi compressible. La matrice M est telle que M*P = d...">Assembleur_P_VDF::assembler_QC</a>(<span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; tab_rho, <a class="code" href="classMatrice.html">Matrice</a>&amp; matrice)
<a name="l00765"></a>00765 {
<a name="l00766"></a>00766 <span class="comment">// Par defaut pour le qc: resolution en pression et pas en increment pression.</span>
<a name="l00767"></a>00767   <span class="keywordflow">if</span> (<a class="code" href="classAssembleur__base.html#afb2f8c92496b38dcafa391fe380c0385" title="Renvoie la valeur du drapeau resoudre_increment_pression_ (0 ou 1) Renvoie -1 si le drapeau n&#39;a pas e...">get_resoudre_increment_pression</a>() &lt; 0)
<a name="l00768"></a>00768     {
<a name="l00769"></a>00769       <a class="code" href="classAssembleur__base.html#ad134c3371f3ced3768a1704be52e0fe8" title="Definit la valeur du drapeau resoudre_increment_pression_. Ce drapeau determine si le solveur en pres...">set_resoudre_increment_pression</a>(1);
<a name="l00770"></a>00770       <a class="code" href="classAssembleur__base.html#a9cdaa49e5340da74de179c2f22f08605" title="Definit la valeur du drapeau resoudre_en_u__. Ce drapeau determine si le solveur en pression resou en...">set_resoudre_en_u</a>(0);
<a name="l00771"></a>00771     }
<a name="l00772"></a>00772   <span class="keywordflow">if</span> (! matrice.<a class="code" href="classO__U__Ptr.html#a16f216b2d169e885876419182658ddcc" title="Renvoie 1 si le pointeur est non_nul Renvoie 0 sinon.">non_nul</a>())
<a name="l00773"></a>00773     {
<a name="l00774"></a>00774       <span class="keywordflow">if</span> (<a class="code" href="classProcess.html#acd052b99706c577f8a5b6656217cf4c2" title="renvoie 1 si on est sur le processeur maitre du groupe courant (c&#39;est a dire me() == 0)...">je_suis_maitre</a>())
<a name="l00775"></a>00775         {
<a name="l00776"></a>00776           <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Assemblage de la matrice pression : &quot;</span>;
<a name="l00777"></a>00777           <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Assembleur_P_VDF::assembler_QC&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
<a name="l00778"></a>00778         }
<a name="l00779"></a>00779       <a class="code" href="classAssembleur__P__VDF.html#aa56befba8f81a9161c144f009d3cdddd" title="Determine les elements non nuls de la matrice et prepare le stockage. Matrice creuse de taille nb_ele...">construire</a>(matrice);
<a name="l00780"></a>00780       <span class="keyword">const</span> <a class="code" href="classZone__VDF.html" title="class Zone_VDF Classe instanciable qui derive de Zone_VF. Cette classe contient les informations geom...">Zone_VDF</a>&amp; zone_vdf   = <a class="code" href="classAssembleur__P__VDF.html#a4ce1358c35e162057c7968aa583cd581">la_zone_VDF</a>.<a class="code" href="classRef__Zone__VDF.html#a84151da4db745d02791d6246e3682b67">valeur</a>();
<a name="l00781"></a>00781 
<a name="l00782"></a>00782       <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; volumes_entrelaces = zone_vdf.<a class="code" href="classZone__VF.html#a64f0b549e5aea1656855113e3510f418">volumes_entrelaces</a>();
<a name="l00783"></a>00783       <a class="code" href="classAssembleur__P__VDF.html#ae6419915244b87d5c8f186d7c4fc1992" title="Calcul des coefficients de la matrice de pression avec un champ de rho. Si rho_ptr == 0...">remplir</a>(matrice,volumes_entrelaces, 0);
<a name="l00784"></a>00784 
<a name="l00785"></a>00785       <a class="code" href="classMatrice__Bloc.html">Matrice_Bloc</a>&amp; matrice_bloc=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Bloc.html">Matrice_Bloc</a>,matrice.<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>());
<a name="l00786"></a>00786       <a class="code" href="classMatrice__Morse__Sym.html" title="Classe Matrice_Morse_Sym Represente une matrice M (creuse) symetrique stockee au format Morse Symetri...">Matrice_Morse_Sym</a>&amp; la_matrice =<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Morse__Sym.html" title="Classe Matrice_Morse_Sym Represente une matrice M (creuse) symetrique stockee au format Morse Symetri...">Matrice_Morse_Sym</a>,matrice_bloc.<a class="code" href="classMatrice__Bloc.html#a7ffa38f7b93454432b2df7c616ed0a4e">get_bloc</a>(0,0).<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>());
<a name="l00787"></a>00787       <span class="keywordflow">if</span> (la_matrice.get_est_definie()!=1)
<a name="l00788"></a>00788         {
<a name="l00789"></a>00789           <span class="keywordflow">if</span> ((<a class="code" href="classProcess.html#acd052b99706c577f8a5b6656217cf4c2" title="renvoie 1 si on est sur le processeur maitre du groupe courant (c&#39;est a dire me() == 0)...">je_suis_maitre</a>()) &amp;&amp; (la_matrice.nb_lignes()==0) &amp;&amp; (la_matrice.nb_colonnes()==0))
<a name="l00790"></a>00790             {
<a name="l00791"></a>00791               <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a>&lt;&lt;<span class="stringliteral">&quot;Pressure matrix will not be defined.&quot;</span>&lt;&lt;<a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
<a name="l00792"></a>00792               <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">exit</a>();
<a name="l00793"></a>00793             }
<a name="l00794"></a>00794 
<a name="l00795"></a>00795           <span class="keywordflow">if</span> ((la_matrice.nb_lignes()&gt;0) &amp;&amp; (la_matrice.nb_colonnes()&gt;0))
<a name="l00796"></a>00796             {
<a name="l00797"></a>00797               <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a>&lt;&lt;<span class="stringliteral">&quot;la_matrice(0,0)&quot;</span>&lt;&lt;la_matrice(0,0)&lt;&lt;<a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
<a name="l00798"></a>00798               <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a>&lt;&lt;<span class="stringliteral">&quot;Pas de pression imposee  --&gt; P(0)=0&quot;</span>&lt;&lt;finl;
<a name="l00799"></a>00799               <span class="keywordflow">if</span> (<a class="code" href="classProcess.html#acd052b99706c577f8a5b6656217cf4c2" title="renvoie 1 si on est sur le processeur maitre du groupe courant (c&#39;est a dire me() == 0)...">je_suis_maitre</a>())    la_matrice(0,0) *= 2;
<a name="l00800"></a>00800             }
<a name="l00801"></a>00801           la_matrice.set_est_definie(1);
<a name="l00802"></a>00802         }
<a name="l00803"></a>00803     }
<a name="l00804"></a>00804   <span class="keywordflow">return</span> 1;
<a name="l00805"></a>00805 }
<a name="l00806"></a>00806 
<a name="l00807"></a><a class="code" href="classAssembleur__P__VDF.html#ac88b839fd9e38462641eac2515a74e12">00807</a> <span class="keyword">const</span> <a class="code" href="classZone__dis__base.html" title="classe Zone_dis_base Cette classe est la base de la hierarchie des zones discretisees. Un objet Zone est associe a la zone discretise. A chaque methode numerique de Trio U correspond une classe derivant de Zone_dis_base implementant les outils necessaires a la methode.">Zone_dis_base</a>&amp; <a class="code" href="classAssembleur__P__VDF.html#ac88b839fd9e38462641eac2515a74e12">Assembleur_P_VDF::zone_dis_base</a>()<span class="keyword"> const</span>
<a name="l00808"></a>00808 <span class="keyword"></span>{
<a name="l00809"></a>00809   <span class="keywordflow">return</span> <a class="code" href="classAssembleur__P__VDF.html#a4ce1358c35e162057c7968aa583cd581">la_zone_VDF</a>.<a class="code" href="classRef__Zone__VDF.html#a84151da4db745d02791d6246e3682b67">valeur</a>();
<a name="l00810"></a>00810 }
<a name="l00811"></a>00811 
<a name="l00812"></a><a class="code" href="classAssembleur__P__VDF.html#adf03371f0f2cb7af8d04c4f6154588f1">00812</a> <span class="keyword">const</span> <a class="code" href="classZone__Cl__dis__base.html" title="classe Zone_Cl_dis_base Les objets Zone_Cl_dis_base representent les conditions aux limites discretis...">Zone_Cl_dis_base</a>&amp; <a class="code" href="classAssembleur__P__VDF.html#adf03371f0f2cb7af8d04c4f6154588f1">Assembleur_P_VDF::zone_Cl_dis_base</a>()<span class="keyword"> const</span>
<a name="l00813"></a>00813 <span class="keyword"></span>{
<a name="l00814"></a>00814   <span class="keywordflow">return</span> <a class="code" href="classAssembleur__P__VDF.html#a0b984a6831f2750865e12296e5e07a2b">la_zone_Cl_VDF</a>.<a class="code" href="classRef__Zone__Cl__VDF.html#a1e655604e840cda5b393e45f975b73ff">valeur</a>();
<a name="l00815"></a>00815 }
<a name="l00816"></a>00816 
<a name="l00817"></a><a class="code" href="classAssembleur__P__VDF.html#a72f34b9bd041058658eb11612911bbb1">00817</a> <span class="keywordtype">void</span> <a class="code" href="classAssembleur__P__VDF.html#a72f34b9bd041058658eb11612911bbb1">Assembleur_P_VDF::associer_zone_dis_base</a>(<span class="keyword">const</span> <a class="code" href="classZone__dis__base.html" title="classe Zone_dis_base Cette classe est la base de la hierarchie des zones discretisees. Un objet Zone est associe a la zone discretise. A chaque methode numerique de Trio U correspond une classe derivant de Zone_dis_base implementant les outils necessaires a la methode.">Zone_dis_base</a>&amp; la_zone_dis)
<a name="l00818"></a>00818 {
<a name="l00819"></a>00819   <a class="code" href="classAssembleur__P__VDF.html#a4ce1358c35e162057c7968aa583cd581">la_zone_VDF</a> = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classZone__VDF.html" title="class Zone_VDF Classe instanciable qui derive de Zone_VF. Cette classe contient les informations geom...">Zone_VDF</a>, la_zone_dis);
<a name="l00820"></a>00820 }
<a name="l00821"></a>00821 
<a name="l00822"></a><a class="code" href="classAssembleur__P__VDF.html#a3e68b615f3394b7dd7002e5e10dee8ad">00822</a> <span class="keywordtype">void</span> <a class="code" href="classAssembleur__P__VDF.html#a3e68b615f3394b7dd7002e5e10dee8ad">Assembleur_P_VDF::associer_zone_cl_dis_base</a>(<span class="keyword">const</span> <a class="code" href="classZone__Cl__dis__base.html" title="classe Zone_Cl_dis_base Les objets Zone_Cl_dis_base representent les conditions aux limites discretis...">Zone_Cl_dis_base</a>&amp; la_zone_Cl_dis)
<a name="l00823"></a>00823 {
<a name="l00824"></a>00824   <a class="code" href="classAssembleur__P__VDF.html#a0b984a6831f2750865e12296e5e07a2b">la_zone_Cl_VDF</a> = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classZone__Cl__VDF.html" title="&lt; namespace TypeAreteCoinVDF">Zone_Cl_VDF</a>, la_zone_Cl_dis);
<a name="l00825"></a>00825 }
<a name="l00826"></a>00826 
<a name="l00827"></a><a class="code" href="classAssembleur__P__VDF.html#ac0f82190e804db68a60b05e3fbfa06fd">00827</a> <span class="keywordtype">void</span> <a class="code" href="classAssembleur__P__VDF.html#ac0f82190e804db68a60b05e3fbfa06fd">Assembleur_P_VDF::completer</a>(<span class="keyword">const</span> <a class="code" href="classEquation__base.html">Equation_base</a>&amp; Eqn)
<a name="l00828"></a>00828 {
<a name="l00829"></a>00829 <span class="comment">// CCa 30/04/99 : je ne sais pas si je dois faire qqchose</span>
<a name="l00830"></a>00830   ;
<a name="l00831"></a>00831 }
<a name="l00832"></a>00832 
</pre></div></div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Tue Dec 14 2021 19:35:40 for TRUST by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
