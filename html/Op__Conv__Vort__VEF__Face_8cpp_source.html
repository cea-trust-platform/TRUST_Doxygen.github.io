<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>TRUST: src/VEF/Operateurs/Op_Conv_Vort_VEF_Face.cpp Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">TRUST&#160;<span id="projectnumber">1.8.4</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
<div class="header">
  <div class="headertitle">
<div class="title">src/VEF/Operateurs/Op_Conv_Vort_VEF_Face.cpp</div>  </div>
</div>
<div class="contents">
<a href="Op__Conv__Vort__VEF__Face_8cpp.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/****************************************************************************</span>
<a name="l00002"></a>00002 <span class="comment">* Copyright (c) 2015 - 2016, CEA</span>
<a name="l00003"></a>00003 <span class="comment">* All rights reserved.</span>
<a name="l00004"></a>00004 <span class="comment">*</span>
<a name="l00005"></a>00005 <span class="comment">* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</span>
<a name="l00006"></a>00006 <span class="comment">* 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.</span>
<a name="l00007"></a>00007 <span class="comment">* 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.</span>
<a name="l00008"></a>00008 <span class="comment">* 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.</span>
<a name="l00009"></a>00009 <span class="comment">*</span>
<a name="l00010"></a>00010 <span class="comment">* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.</span>
<a name="l00011"></a>00011 <span class="comment">* IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;</span>
<a name="l00012"></a>00012 <span class="comment">* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>
<a name="l00013"></a>00013 <span class="comment">*</span>
<a name="l00014"></a>00014 <span class="comment">*****************************************************************************/</span>
<a name="l00015"></a>00015 <span class="comment">//</span>
<a name="l00016"></a>00016 <span class="comment">// </span>
<a name="l00017"></a>00017 <span class="comment">// File:        Op_Conv_Vort_VEF_Face.cpp</span>
<a name="l00018"></a>00018 <span class="comment">// Directory:   $TRUST_ROOT/src/VEF/Operateurs</span>
<a name="l00019"></a>00019 <span class="comment">// Version:     /main/16</span>
<a name="l00020"></a>00020 <span class="comment">// </span>
<a name="l00021"></a>00021 <span class="comment">//</span>
<a name="l00022"></a>00022 
<a name="l00023"></a>00023 <span class="preprocessor">#include &lt;<a class="code" href="Op__Conv__Vort__VEF__Face_8h.html">Op_Conv_Vort_VEF_Face.h</a>&gt;</span>
<a name="l00024"></a>00024 <span class="preprocessor">#include &lt;<a class="code" href="Champ__P1NC_8h.html">Champ_P1NC.h</a>&gt;</span>
<a name="l00025"></a>00025 
<a name="l00026"></a><a class="code" href="Op__Conv__Vort__VEF__Face_8cpp.html#ab0e92cacf9017c506c5beb1220db773d">00026</a> <a class="code" href="Op__Diff__CoviMAC__Face_8cpp.html#aa86ec8ba612a969d9b4370b775037144">Implemente_instanciable</a>(<a class="code" href="classOp__Conv__Vort__VEF__Face.html" title="class Op_Conv_Vort_VEF_Face Cette classe represente l&#39;operateur de convection associe a une equation ...">Op_Conv_Vort_VEF_Face</a>,<span class="stringliteral">&quot;Op_Conv_Conserve_Ec_VEF_P1NC&quot;</span>,<a class="code" href="classOp__Conv__VEF__base.html" title="class Op_Conv_VEF_base Classe de base des operateurs de convection VEF">Op_Conv_VEF_base</a>);
<a name="l00027"></a>00027 
<a name="l00028"></a>00028 <span class="comment"></span>
<a name="l00029"></a>00029 <span class="comment">////!&lt; printOn </span>
<a name="l00030"></a>00030 <span class="comment"></span><span class="comment">//</span>
<a name="l00031"></a>00031 
<a name="l00032"></a><a class="code" href="classOp__Conv__Vort__VEF__Face.html#a9486db7bc3b5a62160a17073bfab8ef3">00032</a> <a class="code" href="classSortie.html" title="Classe de base des flux de sortie. Elle sait ecrire des types simples&lt;br&gt;(entiers, flottants) et des Ob...">Sortie</a>&amp; <a class="code" href="classOp__Conv__Vort__VEF__Face.html#a9486db7bc3b5a62160a17073bfab8ef3" title="NE FAIT RIEN A surcharger dans les classes derivees.">Op_Conv_Vort_VEF_Face::printOn</a>(<a class="code" href="classSortie.html" title="Classe de base des flux de sortie. Elle sait ecrire des types simples&lt;br&gt;(entiers, flottants) et des Ob...">Sortie</a>&amp; s )<span class="keyword"> const</span>
<a name="l00033"></a>00033 <span class="keyword"></span>{
<a name="l00034"></a>00034   <span class="keywordflow">return</span> s &lt;&lt; <a class="code" href="classObjet__U.html#aa58e9a81c0ddc2c1149053b8f96698ac" title="renvoie la chaine identifiant la classe.">que_suis_je</a>() ;
<a name="l00035"></a>00035 }
<a name="l00036"></a>00036 <span class="comment"></span>
<a name="l00037"></a>00037 <span class="comment">////!&lt; readOn </span>
<a name="l00038"></a>00038 <span class="comment"></span><span class="comment">//</span>
<a name="l00039"></a>00039 
<a name="l00040"></a><a class="code" href="classOp__Conv__Vort__VEF__Face.html#ae3c44a067757169c3bbf7359516ef880">00040</a> <a class="code" href="classEntree.html" title="Classe de definition des operateurs et methodes pour toute lecture dans un flot d&#39;entree (fichier...">Entree</a>&amp; <a class="code" href="classOp__Conv__Vort__VEF__Face.html#ae3c44a067757169c3bbf7359516ef880" title="NE FAIT RIEN A surcharger dans les classes derivees.">Op_Conv_Vort_VEF_Face::readOn</a>(<a class="code" href="classEntree.html" title="Classe de definition des operateurs et methodes pour toute lecture dans un flot d&#39;entree (fichier...">Entree</a>&amp; s )
<a name="l00041"></a>00041 {
<a name="l00042"></a>00042   <span class="keywordflow">return</span> s ;
<a name="l00043"></a>00043 }
<a name="l00044"></a>00044 
<a name="l00045"></a>00045 
<a name="l00046"></a><a class="code" href="classOp__Conv__Vort__VEF__Face.html#a0bc7a291895ecba9782022a408bfdfd9">00046</a> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; <a class="code" href="classOp__Conv__Vort__VEF__Face.html#a0bc7a291895ecba9782022a408bfdfd9">Op_Conv_Vort_VEF_Face::ajouter</a>(<span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; transporte,
<a name="l00047"></a>00047                                           <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; resu)<span class="keyword"> const</span>
<a name="l00048"></a>00048 <span class="keyword"></span>{
<a name="l00049"></a>00049   <span class="keyword">const</span> <a class="code" href="classZone__Cl__VEF.html">Zone_Cl_VEF</a>&amp; zone_Cl_VEF = <a class="code" href="classOp__Conv__VEF__base.html#a03f677ee7911706a4f85cd37e0ca4535">la_zcl_vef</a>.<a class="code" href="classRef__Zone__Cl__VEF.html#a0970d7253def65ad4f0c5ce1830fd243">valeur</a>();
<a name="l00050"></a>00050   <span class="keyword">const</span> <a class="code" href="classZone__VEF.html" title="class Zone_VEF Classe instanciable qui derive de Zone_VF. Cette classe contient les informations geom...">Zone_VEF</a>&amp; zone_VEF = <a class="code" href="classOp__Conv__VEF__base.html#a6c29a488a6805ba4a9f2f059cdba77ae">la_zone_vef</a>.<a class="code" href="classRef__Zone__VEF.html#aafd9a5ee1a76f290c9c6b5447b0c8d30">valeur</a>();
<a name="l00051"></a>00051   <span class="keyword">const</span> <a class="code" href="classChamp__Inc__base.html" title="Classe Champ_Inc_base Classe de base des champs inconnues qui sont les champs calcules par une equati...">Champ_Inc_base</a>&amp; la_vitesse=<a class="code" href="classOp__Conv__VEF__base.html#a5547875832fb45e09b1115372fb76ffd">vitesse_</a>.<a class="code" href="classRef__Champ__Inc__base.html#a17553641a4c06730e1562125e07b3490">valeur</a>();
<a name="l00052"></a>00052   <span class="keyword">const</span> <a class="code" href="classChamp__P1NC.html">Champ_P1NC</a>&amp; vit = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classChamp__P1NC.html">Champ_P1NC</a>,<a class="code" href="classOp__Conv__VEF__base.html#a5547875832fb45e09b1115372fb76ffd">vitesse_</a>.<a class="code" href="classRef__Champ__Inc__base.html#a17553641a4c06730e1562125e07b3490">valeur</a>());
<a name="l00053"></a>00053 
<a name="l00054"></a>00054   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; elem_faces = zone_VEF.<a class="code" href="classZone__VF.html#a067e462dcd3ab92b0f6d945b19e4eb37" title="renvoie le numero de le ieme face de la maille num_elem la facon dont ces faces sont numerotees est l...">elem_faces</a>();
<a name="l00055"></a>00055   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; face_voisins = zone_VEF.<a class="code" href="classZone__VF.html#a49d4322f5585a8fa95748ca785b70702" title="renvoie l&#39;element voisin de numface dans la direction i. i=0 : dans le sens oppose de l&#39;axe orthogona...">face_voisins</a>();
<a name="l00056"></a>00056   <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; facette_normales = zone_VEF.<a class="code" href="classZone__VEF.html#a581b1ca0e62c668c92f104351d19fda6">facette_normales</a>();
<a name="l00057"></a>00057   <span class="keyword">const</span> <a class="code" href="classZone.html" title="classe Zone Une Zone est un maillage compose d&#39;un ensemble d&#39;elements geometriques de meme type...">Zone</a>&amp; zone = zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>();
<a name="l00058"></a>00058   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_faces = zone_VEF.<a class="code" href="classZone__VF.html#aede27992d9f2eedd52c24d4a80ff7ffb" title="renvoie le nombre global de faces.">nb_faces</a>();
<a name="l00059"></a>00059   <span class="keyword">const</span> <span class="keywordtype">int</span> nfa7 = zone_VEF.<a class="code" href="classZone__VEF.html#a46693c060b8096fb2595ca72192eea2a">type_elem</a>().<a class="code" href="classElem__VEF.html#a4a34777c0083b38dd34c8a400d5b4e90">nb_facette</a>();
<a name="l00060"></a>00060   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_elem = zone_VEF.<a class="code" href="classZone__dis__base.html#a790cb2f6bc2928518799e748313d0eb3">nb_elem</a>();
<a name="l00061"></a>00061   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_elem_tot = zone_VEF.<a class="code" href="classZone__dis__base.html#a4d6aa445f152aa6dc54d66ea7a071147">nb_elem_tot</a>();
<a name="l00062"></a>00062   <span class="keyword">const</span> <a class="code" href="classIntVect.html">IntVect</a>&amp; rang_elem_non_std = zone_VEF.<a class="code" href="classZone__VEF.html#a4b2171a85e5fc33663a3366acb713584">rang_elem_non_std</a>();
<a name="l00063"></a>00063 
<a name="l00064"></a>00064 
<a name="l00065"></a>00065   <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; normales_facettes_Cl = zone_Cl_VEF.<a class="code" href="classZone__Cl__VEF.html#a83c05e82370553470ed05f10932e0f3f">normales_facettes_Cl</a>();
<a name="l00066"></a>00066   <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; fluent_ = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classDoubleVect.html">DoubleVect</a>, <a class="code" href="classOp__Conv__VEF__base.html#a32b54e8fd5340e238cf4f28ff6e743ec" title="tableau qui sert pour le calcul du pas de temps de stabilite">fluent</a>);
<a name="l00067"></a>00067 
<a name="l00068"></a>00068   <span class="keywordtype">int</span> nfac = zone.<a class="code" href="classZone.html#a548fbc7518be2f122b1a5c9589a443c2" title="Renvoie le nombre de face de type i des elements geometriques constituants la zone. Ex: les objets de la classe Prisme ont 2 types de faces: triangle ou quadrangle.">nb_faces_elem</a>();
<a name="l00069"></a>00069 
<a name="l00070"></a>00070   <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; volumes = zone_VEF.<a class="code" href="classZone__VF.html#aea771c835e561469d2d21dbca5fac1cf" title="renvoie le volume de la maille i.">volumes</a>();
<a name="l00071"></a>00071   <span class="keywordtype">int</span> comp0;
<a name="l00072"></a>00072   <span class="keywordtype">double</span> flux;<span class="comment">//,flux_int;</span>
<a name="l00073"></a>00073   <span class="keywordtype">int</span> num_face;
<a name="l00074"></a>00074   <span class="keywordtype">int</span> elem0,elem1;
<a name="l00075"></a>00075   <span class="keywordtype">double</span> vol0,vol1;
<a name="l00076"></a>00076   <span class="keywordtype">double</span> inter,a0,a1,a2,f_int;
<a name="l00077"></a>00077 
<a name="l00078"></a>00078   <a class="code" href="classIntVect.html">IntVect</a> face(nfac);
<a name="l00079"></a>00079   <a class="code" href="classDoubleVect.html">DoubleVect</a> cc(<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>);
<a name="l00080"></a>00080   <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a> psc(nfac);
<a name="l00081"></a>00081 
<a name="l00082"></a>00082   <span class="keywordtype">int</span> num_int;
<a name="l00083"></a>00083   <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a> autre_num_face(<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>-1);
<a name="l00084"></a>00084   <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a> autre_num_face_loc(<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>-1);
<a name="l00085"></a>00085   <span class="keywordtype">int</span> poly,face_adj,fa7,i,j,n_bord;
<a name="l00086"></a>00086   <span class="keywordtype">int</span> rang ;
<a name="l00087"></a>00087   <span class="keywordtype">int</span> num10, num20;
<a name="l00088"></a>00088   <span class="keywordtype">int</span> nu1, nu2;
<a name="l00089"></a>00089   <span class="keywordtype">int</span> num_calc;
<a name="l00090"></a>00090 
<a name="l00091"></a>00091 
<a name="l00092"></a>00092 <span class="comment">// Pour le traitement de la convection on distingue les polyedres</span>
<a name="l00093"></a>00093 <span class="comment">// standard qui ne &quot;voient&quot; pas les conditions aux limites et les</span>
<a name="l00094"></a>00094 <span class="comment">// polyedres non standard qui ont au moins une face sur le bord.</span>
<a name="l00095"></a>00095 <span class="comment">// Un polyedre standard a n facettes sur lesquelles on applique le</span>
<a name="l00096"></a>00096 <span class="comment">// schema de convection.</span>
<a name="l00097"></a>00097 <span class="comment">// Pour un polyedre non standard qui porte des conditions aux limites</span>
<a name="l00098"></a>00098 <span class="comment">// de Dirichlet, une partie des facettes sont portees par les faces.</span>
<a name="l00099"></a>00099 <span class="comment">// En bref pour un polyedre le traitement de la convection depend</span>
<a name="l00100"></a>00100 <span class="comment">// du type (triangle, tetraedre ...) et du nombre de faces de Dirichlet.</span>
<a name="l00101"></a>00101 
<a name="l00102"></a>00102   <span class="keywordtype">int</span> ncomp_ch_transporte;
<a name="l00103"></a>00103   <span class="keywordflow">if</span> (transporte.<a class="code" href="classDoubleTab.html#ae6dda48778e7107e1beb723beef1f75b" title="Returns the number of dimensions of the array (&gt;= 1)">nb_dim</a>() == 1)
<a name="l00104"></a>00104     ncomp_ch_transporte=1;
<a name="l00105"></a>00105   <span class="keywordflow">else</span>
<a name="l00106"></a>00106     ncomp_ch_transporte= transporte.<a class="code" href="classDoubleTab.html#ac3805e2637a3b880ba2d3e650c69dac4" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(1);
<a name="l00107"></a>00107 
<a name="l00108"></a>00108 <span class="comment">// Cerr &lt;&lt; &quot;ncomp_ch_transporte=&quot; &lt;&lt; ncomp_ch_transporte &lt;&lt; finl;</span>
<a name="l00109"></a>00109 
<a name="l00110"></a>00110 <span class="comment">// On remet a zero le tableau qui sert pour</span>
<a name="l00111"></a>00111 <span class="comment">// le calcul du pas de temps de stabilite</span>
<a name="l00112"></a>00112   fluent_ = 0;
<a name="l00113"></a>00113 
<a name="l00114"></a>00114 <span class="comment">// ATENTION : PBL pour determiner le fluent</span>
<a name="l00115"></a>00115 <span class="comment">// ********   on le met a 1!!!</span>
<a name="l00116"></a>00116 <span class="comment">// fluent_ = 1.;</span>
<a name="l00117"></a>00117 
<a name="l00118"></a>00118 
<a name="l00119"></a>00119 <span class="comment">// Traitement particulier pour les faces de periodicite</span>
<a name="l00120"></a>00120 
<a name="l00121"></a>00121   <span class="keywordtype">int</span> nb_faces_perio = 0;
<a name="l00122"></a>00122   <span class="keywordflow">for</span> (n_bord=0; n_bord&lt;zone_VEF.<a class="code" href="classZone__dis__base.html#af22167d614644f55591a29c77eb1c009">nb_front_Cl</a>(); n_bord++)
<a name="l00123"></a>00123     {
<a name="l00124"></a>00124       <span class="keyword">const</span> <a class="code" href="classCond__lim.html" title="classe Cond_lim Classe generique servant a representer n&#39;importe quelle classe derivee de la classe C...">Cond_lim</a>&amp; la_cl = zone_Cl_VEF.<a class="code" href="classZone__Cl__dis__base.html#af75e0ed7786863e4d333bfb29d67c323" title="Renvoie la i-ieme condition aux limites. (version const)">les_conditions_limites</a>(n_bord);
<a name="l00125"></a>00125       <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>()))
<a name="l00126"></a>00126         {
<a name="l00127"></a>00127           <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp; le_bord = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>,la_cl.<a class="code" href="classCond__lim.html#a5b2d24809cee07727006a891d4ce8d22" title="Appel a l&#39;objet sous-jacent Renvoie la frontiere discretisee associee a la condition aux limites...">frontiere_dis</a>());
<a name="l00128"></a>00128           <span class="keywordtype">int</span> num1 = le_bord.<a class="code" href="classFront__VF.html#a4986f0c65653fe9eb40bbbff5a97bf16" title="Numero de la premiere face du bord dans la liste des faces.">num_premiere_face</a>();
<a name="l00129"></a>00129           <span class="keywordtype">int</span> num2 = num1 + le_bord.<a class="code" href="classFront__VF.html#a341e2fcb5117b96e745fd7078ba86bab" title="Nombre de faces reelles du bord.">nb_faces</a>();
<a name="l00130"></a>00130           <span class="keywordflow">for</span> (num_face=num1; num_face&lt;num2; num_face++)
<a name="l00131"></a>00131             nb_faces_perio++;
<a name="l00132"></a>00132         }
<a name="l00133"></a>00133     }
<a name="l00134"></a>00134 
<a name="l00135"></a>00135   <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a> tab;
<a name="l00136"></a>00136   <span class="keywordflow">if</span> (ncomp_ch_transporte == 1)
<a name="l00137"></a>00137     tab.<a class="code" href="classDoubleTab.html#ae83b4d31205c53d9c8d2b43da178ce75" title="Change la taille du vecteur (identique a resize_array() pour le traitement des anciennes valeurs et d...">resize</a>(nb_faces_perio);
<a name="l00138"></a>00138   <span class="keywordflow">else</span>
<a name="l00139"></a>00139     tab.<a class="code" href="classDoubleTab.html#ae83b4d31205c53d9c8d2b43da178ce75" title="Change la taille du vecteur (identique a resize_array() pour le traitement des anciennes valeurs et d...">resize</a>(nb_faces_perio,ncomp_ch_transporte);
<a name="l00140"></a>00140 
<a name="l00141"></a>00141   nb_faces_perio=0;
<a name="l00142"></a>00142   <span class="keywordflow">for</span> (n_bord=0; n_bord&lt;zone_VEF.<a class="code" href="classZone__dis__base.html#af22167d614644f55591a29c77eb1c009">nb_front_Cl</a>(); n_bord++)
<a name="l00143"></a>00143     {
<a name="l00144"></a>00144       <span class="keyword">const</span> <a class="code" href="classCond__lim.html" title="classe Cond_lim Classe generique servant a representer n&#39;importe quelle classe derivee de la classe C...">Cond_lim</a>&amp; la_cl = zone_Cl_VEF.<a class="code" href="classZone__Cl__dis__base.html#af75e0ed7786863e4d333bfb29d67c323" title="Renvoie la i-ieme condition aux limites. (version const)">les_conditions_limites</a>(n_bord);
<a name="l00145"></a>00145       <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>()))
<a name="l00146"></a>00146         {
<a name="l00147"></a>00147 <span class="comment">// const Periodique&amp; la_cl_perio = ref_cast(Periodique, la_cl.valeur());</span>
<a name="l00148"></a>00148           <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp; le_bord = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>,la_cl.<a class="code" href="classCond__lim.html#a5b2d24809cee07727006a891d4ce8d22" title="Appel a l&#39;objet sous-jacent Renvoie la frontiere discretisee associee a la condition aux limites...">frontiere_dis</a>());
<a name="l00149"></a>00149           <span class="keywordtype">int</span> num1 = le_bord.<a class="code" href="classFront__VF.html#a4986f0c65653fe9eb40bbbff5a97bf16" title="Numero de la premiere face du bord dans la liste des faces.">num_premiere_face</a>();
<a name="l00150"></a>00150           <span class="keywordtype">int</span> num2 = num1 + le_bord.<a class="code" href="classFront__VF.html#a341e2fcb5117b96e745fd7078ba86bab" title="Nombre de faces reelles du bord.">nb_faces</a>();
<a name="l00151"></a>00151           <span class="keywordflow">for</span> (num_face=num1; num_face&lt;num2; num_face++)
<a name="l00152"></a>00152             {
<a name="l00153"></a>00153               <span class="keywordflow">if</span> (ncomp_ch_transporte == 1)
<a name="l00154"></a>00154                 tab(nb_faces_perio) = resu(num_face);
<a name="l00155"></a>00155               <span class="keywordflow">else</span>
<a name="l00156"></a>00156                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> comp=0; comp&lt;ncomp_ch_transporte; comp++)
<a name="l00157"></a>00157                   tab(nb_faces_perio,comp) = resu(num_face,comp);
<a name="l00158"></a>00158               nb_faces_perio++;
<a name="l00159"></a>00159             }
<a name="l00160"></a>00160         }
<a name="l00161"></a>00161     }
<a name="l00162"></a>00162 
<a name="l00163"></a>00163 <span class="comment">// Cerr &lt;&lt; &quot;tab=&quot; &lt;&lt; tab &lt;&lt; finl;</span>
<a name="l00164"></a>00164 
<a name="l00165"></a>00165 <span class="comment">// Les polyedres non standard sont ranges en 2 groupes dans la Zone_VEF:</span>
<a name="l00166"></a>00166 <span class="comment">// - polyedres bords et joints</span>
<a name="l00167"></a>00167 <span class="comment">// - polyedres bords et non joints</span>
<a name="l00168"></a>00168 <span class="comment">// On traite les polyedres en suivant l&#39;ordre dans lequel ils figurent</span>
<a name="l00169"></a>00169 <span class="comment">// dans la zone</span>
<a name="l00170"></a>00170 
<a name="l00171"></a>00171 <span class="comment">// boucle sur les polys</span>
<a name="l00172"></a>00172 
<a name="l00173"></a>00173 
<a name="l00174"></a>00174 <span class="comment">// Boucle pour ajouter la partie : Gradient(U^2/2)</span>
<a name="l00175"></a>00175 <span class="comment">// ******* boucle sur les elements</span>
<a name="l00176"></a>00176 <span class="comment">// 06/01/2000 On ne s&#39;occupe pas encore des conditions aux limites (sauf periodique)</span>
<a name="l00177"></a>00177   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; KEL=zone_VEF.<a class="code" href="classZone__VEF.html#a46693c060b8096fb2595ca72192eea2a">type_elem</a>().<a class="code" href="classDeriv__Elem__VEF__base.html#a2886905d5071be902c77248b69ca0b7b">valeur</a>().<a class="code" href="classElem__VEF__base.html#ab129610ef702aa8c9c98dcb4c7551172">KEL</a>();
<a name="l00178"></a>00178   <span class="keywordflow">for</span> (poly=0; poly&lt;nb_elem_tot; poly++)
<a name="l00179"></a>00179     {
<a name="l00180"></a>00180 
<a name="l00181"></a>00181       rang = rang_elem_non_std(poly);
<a name="l00182"></a>00182 
<a name="l00183"></a>00183 <span class="comment">// calcul des numeros des faces du polyedre</span>
<a name="l00184"></a>00184       <span class="keywordflow">for</span> (face_adj=0; face_adj&lt;nfac; face_adj++)
<a name="l00185"></a>00185         face[face_adj]= elem_faces(poly,face_adj);
<a name="l00186"></a>00186 
<a name="l00187"></a>00187 <span class="comment">// On cherche les numeros globaux de toutes les faces</span>
<a name="l00188"></a>00188       <span class="keywordflow">for</span> (fa7=0; fa7&lt;nfa7; fa7++)
<a name="l00189"></a>00189         {
<a name="l00190"></a>00190           nu1=-1;
<a name="l00191"></a>00191           nu2=-1;
<a name="l00192"></a>00192           num10 = face[KEL(0,fa7)];
<a name="l00193"></a>00193           num20 = face[KEL(1,fa7)];
<a name="l00194"></a>00194 <span class="comment">// La facette est entouree des faces num1 et num2</span>
<a name="l00195"></a>00195 <span class="comment">// Cerr &lt;&lt; &quot;num1=&quot; &lt;&lt; num1 &lt;&lt; &quot;  num2=&quot; &lt;&lt; num2 &lt;&lt; finl;</span>
<a name="l00196"></a>00196 
<a name="l00197"></a>00197 <span class="comment">// i=0;</span>
<a name="l00198"></a>00198 <span class="comment">// j=0;</span>
<a name="l00199"></a>00199 <span class="comment">// while(i&lt;nfac)</span>
<a name="l00200"></a>00200 <span class="comment">// {</span>
<a name="l00201"></a>00201 <span class="comment">// num_int = face[i];</span>
<a name="l00202"></a>00202 <span class="comment">// if ((num_int!= num1)&amp;&amp;(num_int!= num2))</span>
<a name="l00203"></a>00203 <span class="comment">// {</span>
<a name="l00204"></a>00204 <span class="comment">// autre_num_face(j)=num_int;</span>
<a name="l00205"></a>00205 <span class="comment">// j++;</span>
<a name="l00206"></a>00206 <span class="comment">// }</span>
<a name="l00207"></a>00207 <span class="comment">// i++;</span>
<a name="l00208"></a>00208 <span class="comment">// }</span>
<a name="l00209"></a>00209 
<a name="l00210"></a>00210 <span class="comment">// On cherche le numero des autres faces (locaux et globaux)</span>
<a name="l00211"></a>00211 
<a name="l00212"></a>00212           i=0;
<a name="l00213"></a>00213           j=0;
<a name="l00214"></a>00214 <span class="comment">// k=0;</span>
<a name="l00215"></a>00215           <span class="keywordflow">while</span>(i&lt;nfac)
<a name="l00216"></a>00216             {
<a name="l00217"></a>00217               num_int = face[i];
<a name="l00218"></a>00218               <span class="keywordflow">if</span> (num_int == num10)
<a name="l00219"></a>00219                 {
<a name="l00220"></a>00220                   nu1=i;
<a name="l00221"></a>00221                 }
<a name="l00222"></a>00222               <span class="keywordflow">else</span> <span class="keywordflow">if</span> (num_int == num20)
<a name="l00223"></a>00223                 {
<a name="l00224"></a>00224                   nu2=i;
<a name="l00225"></a>00225                 }
<a name="l00226"></a>00226               <span class="keywordflow">else</span>
<a name="l00227"></a>00227                 {
<a name="l00228"></a>00228                   autre_num_face_loc(j)=i;
<a name="l00229"></a>00229                   autre_num_face(j)=num_int;
<a name="l00230"></a>00230                   j++;
<a name="l00231"></a>00231                 }
<a name="l00232"></a>00232               i++;
<a name="l00233"></a>00233             }
<a name="l00234"></a>00234 
<a name="l00235"></a>00235 <span class="comment">// Cerr &lt;&lt; &quot;num1=&quot; &lt;&lt; num1 &lt;&lt; &quot;  num2=&quot; &lt;&lt; num2 &lt;&lt; &quot;  autre_num_face(0)=&quot; &lt;&lt; autre_num_face(0) &lt;&lt; finl;</span>
<a name="l00236"></a>00236 <span class="comment">// if (dimension==3)</span>
<a name="l00237"></a>00237 <span class="comment">// Cerr &lt;&lt; &quot;autre_num_face(1)=&quot; &lt;&lt; autre_num_face(1) &lt;&lt; finl;</span>
<a name="l00238"></a>00238 
<a name="l00239"></a>00239           <span class="keywordflow">if</span> (rang==-1)
<a name="l00240"></a>00240             {
<a name="l00241"></a>00241               <span class="keywordflow">for</span> (i=0; i&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; i++)
<a name="l00242"></a>00242                 cc[i] = facette_normales(poly,fa7,i);
<a name="l00243"></a>00243             }
<a name="l00244"></a>00244           <span class="keywordflow">else</span>
<a name="l00245"></a>00245             <span class="keywordflow">for</span> (i=0; i&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; i++)
<a name="l00246"></a>00246               cc[i] = normales_facettes_Cl(rang,fa7,i);
<a name="l00247"></a>00247 
<a name="l00248"></a>00248 <span class="comment">// On calcule les produits scalaires u(xi).n.S  // &gt;&gt;&gt; calcul de fluent!!</span>
<a name="l00249"></a>00249           <span class="keywordflow">for</span> (i=0; i&lt;nfac; i ++)
<a name="l00250"></a>00250             {
<a name="l00251"></a>00251               psc[i] = 0.;
<a name="l00252"></a>00252               <span class="keywordflow">for</span> (j=0; j&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; j++)
<a name="l00253"></a>00253                 {
<a name="l00254"></a>00254                   psc[i]+= la_vitesse(face[i],j)*cc[j];
<a name="l00255"></a>00255                 }
<a name="l00256"></a>00256             }
<a name="l00257"></a>00257 
<a name="l00258"></a>00258 <span class="comment">// Calcul du flux</span>
<a name="l00259"></a>00259 <span class="comment">// Boucle sur les composantes : uu+vv+(ww)</span>
<a name="l00260"></a>00260           flux = 0.;
<a name="l00261"></a>00261           <span class="keywordflow">if</span> (dimension == 2)
<a name="l00262"></a>00262             {
<a name="l00263"></a>00263               f_int =  2.*((psc[nu1]+psc[nu2])- psc[autre_num_face_loc(0)])/3.;
<a name="l00264"></a>00264             }
<a name="l00265"></a>00265           <span class="keywordflow">else</span>
<a name="l00266"></a>00266             {
<a name="l00267"></a>00267 <span class="comment">// (dimension == 3)</span>
<a name="l00268"></a>00268               assert(dimension == 3);
<a name="l00269"></a>00269               {
<a name="l00270"></a>00270                 f_int = 3.*(psc[nu1]+psc[nu2]);
<a name="l00271"></a>00271                 f_int -= (psc[autre_num_face_loc(0)]+psc[autre_num_face_loc(1)]);
<a name="l00272"></a>00272                 f_int /= 4.;
<a name="l00273"></a>00273               }
<a name="l00274"></a>00274             }
<a name="l00275"></a>00275           <span class="keywordflow">if</span> (f_int &gt;= 0.)
<a name="l00276"></a>00276             num_calc = num10;
<a name="l00277"></a>00277           <span class="keywordflow">else</span>
<a name="l00278"></a>00278             num_calc = num20;
<a name="l00279"></a>00279 
<a name="l00280"></a>00280           flux = 0.;
<a name="l00281"></a>00281           <span class="keywordflow">for</span> (comp0=0; comp0&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; comp0++)
<a name="l00282"></a>00282             flux += la_vitesse(num_calc,comp0)*la_vitesse(num_calc,comp0);
<a name="l00283"></a>00283 
<a name="l00284"></a>00284           <span class="keywordflow">for</span> (comp0=0; comp0&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; comp0++)
<a name="l00285"></a>00285             {
<a name="l00286"></a>00286               resu(num10, comp0) -= 0.5*flux*cc[comp0];
<a name="l00287"></a>00287               resu(num20, comp0) += 0.5*flux*cc[comp0];
<a name="l00288"></a>00288             }
<a name="l00289"></a>00289 
<a name="l00290"></a>00290 <span class="comment">// *** ??? : evaluation du fluent</span>
<a name="l00291"></a>00291           <span class="keywordflow">if</span> (f_int&gt;0.)
<a name="l00292"></a>00292             {
<a name="l00293"></a>00293 <span class="comment">// fluent_[num2] += dabs(f_int);</span>
<a name="l00294"></a>00294               fluent_[num20] = ( fluent_[num20] &gt; <a class="code" href="Double_8h.html#aaecd4ca8a2fe69cc6568af2938b94d2e">dabs</a>(f_int))? fluent_[num20] : <a class="code" href="Double_8h.html#aaecd4ca8a2fe69cc6568af2938b94d2e">dabs</a>(f_int);
<a name="l00295"></a>00295             }
<a name="l00296"></a>00296           <span class="keywordflow">else</span>
<a name="l00297"></a>00297             {
<a name="l00298"></a>00298               fluent_[num10] = ( fluent_[num10] &gt; <a class="code" href="Double_8h.html#aaecd4ca8a2fe69cc6568af2938b94d2e">dabs</a>(f_int))? fluent_[num10] : <a class="code" href="Double_8h.html#aaecd4ca8a2fe69cc6568af2938b94d2e">dabs</a>(f_int);
<a name="l00299"></a>00299 <span class="comment">// fluent_[num1] += dabs(f_int);</span>
<a name="l00300"></a>00300             }
<a name="l00301"></a>00301 
<a name="l00302"></a>00302         }
<a name="l00303"></a>00303     }
<a name="l00304"></a>00304 
<a name="l00305"></a>00305 <span class="comment">// FIN DE LA BOUCLE SUR LES ELEMENTS</span><span class="comment"></span>
<a name="l00306"></a>00306 <span class="comment">  //////////!&lt; On fait la compensation ici, car la boucle suivante est sur les faces</span>
<a name="l00307"></a>00307 <span class="comment">  //////////!&lt; En le faisant a la fin, on aurait deux fois la contribution aux faces</span>
<a name="l00308"></a>00308 <span class="comment"></span>  <span class="keywordtype">int</span> voisine;
<a name="l00309"></a>00309   nb_faces_perio = 0;
<a name="l00310"></a>00310   <span class="keywordtype">double</span> diff1,diff2;
<a name="l00311"></a>00311 
<a name="l00312"></a>00312 <span class="comment">// Dimensionnement du tableau des flux convectifs au bord du domaine</span>
<a name="l00313"></a>00313 <span class="comment">// de calcul</span>
<a name="l00314"></a>00314   <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; flux_b = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>,<a class="code" href="classOperateur__base.html#a451f51b41518ddbc0d3f586a8177d319" title="Tableau contenant les flux sur les bords de l&#39;operateur.">flux_bords_</a>);
<a name="l00315"></a>00315   flux_b.<a class="code" href="classDoubleTab.html#ae83b4d31205c53d9c8d2b43da178ce75" title="Change la taille du vecteur (identique a resize_array() pour le traitement des anciennes valeurs et d...">resize</a>(zone_VEF.<a class="code" href="classZone__VF.html#a8815e2276637c0db23868f043dc43e58" title="renvoie le nombre de faces sur lesquelles sont appliquees les conditions limites : bords...">nb_faces_bord</a>(),ncomp_ch_transporte);
<a name="l00316"></a>00316   flux_b = 0.;
<a name="l00317"></a>00317 
<a name="l00318"></a>00318 <span class="comment">// Boucle sur les bords pour traiter les conditions aux limites</span>
<a name="l00319"></a>00319 
<a name="l00320"></a>00320   <span class="keywordflow">for</span> (n_bord=0; n_bord&lt;zone_VEF.<a class="code" href="classZone__dis__base.html#af22167d614644f55591a29c77eb1c009">nb_front_Cl</a>(); n_bord++)
<a name="l00321"></a>00321     {
<a name="l00322"></a>00322       <span class="keyword">const</span> <a class="code" href="classCond__lim.html" title="classe Cond_lim Classe generique servant a representer n&#39;importe quelle classe derivee de la classe C...">Cond_lim</a>&amp; la_cl = zone_Cl_VEF.<a class="code" href="classZone__Cl__dis__base.html#af75e0ed7786863e4d333bfb29d67c323" title="Renvoie la i-ieme condition aux limites. (version const)">les_conditions_limites</a>(n_bord);
<a name="l00323"></a>00323 
<a name="l00324"></a>00324       <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>()))
<a name="l00325"></a>00325         {
<a name="l00326"></a>00326           <span class="keyword">const</span> <a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>&amp; la_cl_perio = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>());
<a name="l00327"></a>00327           <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp; le_bord = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>,la_cl.<a class="code" href="classCond__lim.html#a5b2d24809cee07727006a891d4ce8d22" title="Appel a l&#39;objet sous-jacent Renvoie la frontiere discretisee associee a la condition aux limites...">frontiere_dis</a>());
<a name="l00328"></a>00328           <span class="keywordtype">int</span> num1 = le_bord.num_premiere_face();
<a name="l00329"></a>00329           <span class="keywordtype">int</span> num2 = num1 + le_bord.nb_faces();
<a name="l00330"></a>00330           <a class="code" href="classIntVect.html">IntVect</a> fait(le_bord.nb_faces());
<a name="l00331"></a>00331           fait = 0;
<a name="l00332"></a>00332           <span class="keywordflow">for</span> (num_face=num1; num_face&lt;num2; num_face++)
<a name="l00333"></a>00333             {
<a name="l00334"></a>00334               <span class="keywordflow">if</span> (fait[num_face-num1] == 0)
<a name="l00335"></a>00335                 {
<a name="l00336"></a>00336                   voisine = la_cl_perio.<a class="code" href="classPeriodique.html#a207b86556f199a63ea059b841851ca6a">face_associee</a>(num_face-num1) + num1;
<a name="l00337"></a>00337 
<a name="l00338"></a>00338                   <span class="keywordflow">if</span> (ncomp_ch_transporte == 1)
<a name="l00339"></a>00339                     {
<a name="l00340"></a>00340                       diff1 = resu(num_face)-tab(nb_faces_perio);
<a name="l00341"></a>00341                       diff2 = resu(voisine)-tab(nb_faces_perio+voisine-num_face);
<a name="l00342"></a>00342                       resu(voisine)  += diff1;
<a name="l00343"></a>00343                       resu(num_face) += diff2;
<a name="l00344"></a>00344                       flux_b(voisine,0) += diff1;
<a name="l00345"></a>00345                       flux_b(num_face,0) += diff2;
<a name="l00346"></a>00346                     }
<a name="l00347"></a>00347                   <span class="keywordflow">else</span>
<a name="l00348"></a>00348                     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> comp=0; comp&lt;ncomp_ch_transporte; comp++)
<a name="l00349"></a>00349                       {
<a name="l00350"></a>00350                         diff1 = resu(num_face,comp)-tab(nb_faces_perio,comp);
<a name="l00351"></a>00351                         diff2 = resu(voisine,comp)-tab(nb_faces_perio+voisine-num_face,comp);
<a name="l00352"></a>00352                         resu(voisine,comp)  += diff1;
<a name="l00353"></a>00353                         resu(num_face,comp) += diff2;
<a name="l00354"></a>00354                         flux_b(voisine,comp) += diff1;
<a name="l00355"></a>00355                         flux_b(num_face,comp) += diff2;
<a name="l00356"></a>00356                       }
<a name="l00357"></a>00357 
<a name="l00358"></a>00358                   fait[num_face-num1]= 1;
<a name="l00359"></a>00359                   fait[voisine-num1] = 1;
<a name="l00360"></a>00360                 }
<a name="l00361"></a>00361               nb_faces_perio++;
<a name="l00362"></a>00362             }
<a name="l00363"></a>00363         }
<a name="l00364"></a>00364     }
<a name="l00365"></a>00365 
<a name="l00366"></a>00366 <span class="comment">//</span>
<a name="l00367"></a>00367 <span class="comment">// Boucle pour ajouter la partie avec la vorticite</span>
<a name="l00368"></a>00368 <span class="comment">// ****** Boucle sur les faces</span>
<a name="l00369"></a>00369 
<a name="l00370"></a>00370 <span class="comment">// Calcul de la vorticite</span>
<a name="l00371"></a>00371   <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a> vorticite;
<a name="l00372"></a>00372   <span class="keywordflow">if</span> (<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a> == 2)
<a name="l00373"></a>00373     vorticite.<a class="code" href="classDoubleTab.html#ae83b4d31205c53d9c8d2b43da178ce75" title="Change la taille du vecteur (identique a resize_array() pour le traitement des anciennes valeurs et d...">resize</a>(nb_elem);
<a name="l00374"></a>00374   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a> == 3)
<a name="l00375"></a>00375     vorticite.<a class="code" href="classDoubleTab.html#ae83b4d31205c53d9c8d2b43da178ce75" title="Change la taille du vecteur (identique a resize_array() pour le traitement des anciennes valeurs et d...">resize</a>(nb_elem,<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>);
<a name="l00376"></a>00376 
<a name="l00377"></a>00377   vit.<a class="code" href="classChamp__P1NC.html#ad1820c9409b86519f9f3a38d754bec4e">cal_rot_ordre1</a>(vorticite);
<a name="l00378"></a>00378 
<a name="l00379"></a>00379 <span class="comment">// Cerr &lt;&lt; &quot;vorticite=&quot; &lt;&lt; vorticite &lt;&lt; finl;</span>
<a name="l00380"></a>00380 
<a name="l00381"></a>00381   <span class="keywordflow">for</span> (num_face=0; num_face&lt;nb_faces; num_face++)
<a name="l00382"></a>00382     {
<a name="l00383"></a>00383       vol0=-1;
<a name="l00384"></a>00384       vol1=-1;
<a name="l00385"></a>00385       elem0 = face_voisins(num_face,0);
<a name="l00386"></a>00386       elem1 = face_voisins(num_face,1);
<a name="l00387"></a>00387 
<a name="l00388"></a>00388       <span class="keywordflow">if</span> (elem0 != -1)
<a name="l00389"></a>00389         vol0 = volumes(elem0);
<a name="l00390"></a>00390 
<a name="l00391"></a>00391       <span class="keywordflow">if</span> (elem1 != -1)
<a name="l00392"></a>00392         vol1 = volumes(elem1);
<a name="l00393"></a>00393 
<a name="l00394"></a>00394 <span class="comment">// Cerr &lt;&lt; &quot;vol0=&quot; &lt;&lt; vol0 &lt;&lt; &quot;  vol1=&quot; &lt;&lt; vol1 &lt;&lt; finl;</span>
<a name="l00395"></a>00395 
<a name="l00396"></a>00396       <span class="keywordflow">if</span> (<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a> == 2)
<a name="l00397"></a>00397         {
<a name="l00398"></a>00398 <span class="comment">// for (comp=0;comp&lt;dimension;comp++)</span>
<a name="l00399"></a>00399 <span class="comment">// {</span>
<a name="l00400"></a>00400           assert(vol0&gt;0);
<a name="l00401"></a>00401           assert(vol1&gt;0);
<a name="l00402"></a>00402           inter  = vorticite[elem0]*vol0/3.+vorticite[elem1]*vol1/3.;
<a name="l00403"></a>00403 
<a name="l00404"></a>00404           resu(num_face,0) -= -inter*la_vitesse(num_face,1);
<a name="l00405"></a>00405           resu(num_face,1) -= inter*la_vitesse(num_face,0);
<a name="l00406"></a>00406 
<a name="l00407"></a>00407 <span class="comment">// signe - car on est dans le second membre</span>
<a name="l00408"></a>00408 
<a name="l00409"></a>00409 <span class="comment">// *** PBL : evaluation du fluent</span>
<a name="l00410"></a>00410 <span class="comment">// if(psc &gt;= 0)</span>
<a name="l00411"></a>00411 <span class="comment">// fluent_[num2] += psc;</span>
<a name="l00412"></a>00412 <span class="comment">// else</span>
<a name="l00413"></a>00413 <span class="comment">// fluent_[num1] -= psc;</span>
<a name="l00414"></a>00414         }
<a name="l00415"></a>00415       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a> == 3)
<a name="l00416"></a>00416         {
<a name="l00417"></a>00417           assert(vol0&gt;0);
<a name="l00418"></a>00418           assert(vol1&gt;0);
<a name="l00419"></a>00419 <span class="comment">// vect(a) = vorticite*Vol</span>
<a name="l00420"></a>00420           a0 = vorticite(elem0,0)*vol0/4. + vorticite(elem1,0)*vol1/4.;
<a name="l00421"></a>00421           a1 = vorticite(elem0,1)*vol0/4. + vorticite(elem1,1)*vol1/4.;
<a name="l00422"></a>00422           a2 = vorticite(elem0,2)*vol0/4. + vorticite(elem1,2)*vol1/4.;
<a name="l00423"></a>00423 
<a name="l00424"></a>00424           resu(num_face,0) -= a1*la_vitesse(num_face,2)-a2*la_vitesse(num_face,1) ;
<a name="l00425"></a>00425           resu(num_face,1) -= a2*la_vitesse(num_face,0)-a0*la_vitesse(num_face,2) ;
<a name="l00426"></a>00426           resu(num_face,2) -= a0*la_vitesse(num_face,1)-a1*la_vitesse(num_face,0) ;
<a name="l00427"></a>00427 
<a name="l00428"></a>00428 <span class="comment">// signe - car on est dans le second membre</span>
<a name="l00429"></a>00429 
<a name="l00430"></a>00430 <span class="comment">// *** PBL : evaluation du fluent</span>
<a name="l00431"></a>00431 <span class="comment">// if(psc &gt;= 0)</span>
<a name="l00432"></a>00432 <span class="comment">// fluent_[num2] += psc;</span>
<a name="l00433"></a>00433 <span class="comment">// else</span>
<a name="l00434"></a>00434 <span class="comment">// fluent_[num1] -= psc;</span>
<a name="l00435"></a>00435         }
<a name="l00436"></a>00436     }
<a name="l00437"></a>00437 
<a name="l00438"></a>00438   <span class="comment">//******* VERIF PERIO</span>
<a name="l00439"></a>00439   <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;DEBUT VERIF PERIO&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
<a name="l00440"></a>00440   <span class="comment">//  Cerr &lt;&lt; &quot;nb_front_Cl=&quot; &lt;&lt; zone_VEF.nb_front_Cl() &lt;&lt; finl;</span>
<a name="l00441"></a>00441   <span class="keywordflow">for</span> (n_bord=0; n_bord&lt;zone_VEF.<a class="code" href="classZone__dis__base.html#af22167d614644f55591a29c77eb1c009">nb_front_Cl</a>(); n_bord++)
<a name="l00442"></a>00442     {
<a name="l00443"></a>00443       <span class="keyword">const</span> <a class="code" href="classCond__lim.html" title="classe Cond_lim Classe generique servant a representer n&#39;importe quelle classe derivee de la classe C...">Cond_lim</a>&amp; la_cl = zone_Cl_VEF.<a class="code" href="classZone__Cl__dis__base.html#af75e0ed7786863e4d333bfb29d67c323" title="Renvoie la i-ieme condition aux limites. (version const)">les_conditions_limites</a>(n_bord);
<a name="l00444"></a>00444 
<a name="l00445"></a>00445       <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>()))
<a name="l00446"></a>00446         {
<a name="l00447"></a>00447           <span class="keyword">const</span> <a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>&amp; la_cl_perio = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>());
<a name="l00448"></a>00448           <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp; le_bord = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>,la_cl.<a class="code" href="classCond__lim.html#a5b2d24809cee07727006a891d4ce8d22" title="Appel a l&#39;objet sous-jacent Renvoie la frontiere discretisee associee a la condition aux limites...">frontiere_dis</a>());
<a name="l00449"></a>00449           <span class="keywordtype">int</span> num1 = le_bord.num_premiere_face();
<a name="l00450"></a>00450           <span class="keywordtype">int</span> num2 = num1 + le_bord.nb_faces();
<a name="l00451"></a>00451           <span class="comment">//          Cerr &lt;&lt; &quot;num1=&quot; &lt;&lt; num1 &lt;&lt; &quot;  num2=&quot; &lt;&lt; num2 &lt;&lt; finl;</span>
<a name="l00452"></a>00452           <span class="keywordflow">for</span> (num_face=num1; num_face&lt;num2; num_face++)
<a name="l00453"></a>00453             {
<a name="l00454"></a>00454               voisine = la_cl_perio.<a class="code" href="classPeriodique.html#a207b86556f199a63ea059b841851ca6a">face_associee</a>(num_face-num1) + num1;
<a name="l00455"></a>00455               <span class="keywordflow">for</span> (<span class="keywordtype">int</span> ii=0; ii&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; ii++)
<a name="l00456"></a>00456                 {
<a name="l00457"></a>00457                   <span class="keywordflow">if</span> ( resu(num_face,ii)!=resu(voisine,ii) )
<a name="l00458"></a>00458                     {
<a name="l00459"></a>00459                       <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Pbl de periodicite a la face&quot;</span> &lt;&lt; num_face &lt;&lt; finl;
<a name="l00460"></a>00460                       <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;diff = &quot;</span> &lt;&lt; resu(num_face,ii)-resu(voisine,ii)  &lt;&lt; finl;
<a name="l00461"></a>00461                     }
<a name="l00462"></a>00462                 }
<a name="l00463"></a>00463             }
<a name="l00464"></a>00464         }
<a name="l00465"></a>00465     }
<a name="l00466"></a>00466   <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;FIN VERIF PERIO&quot;</span> &lt;&lt; finl;
<a name="l00467"></a>00467   <span class="comment">//******* FIN VERIF PERIO</span>
<a name="l00468"></a>00468 
<a name="l00469"></a>00469   <a class="code" href="classOp__VEF__Face.html#a6c8ce571769b4f2e20b07cbb7a6944f2">modifier_flux</a>(*<span class="keyword">this</span>);
<a name="l00470"></a>00470   <span class="keywordflow">return</span> resu;
<a name="l00471"></a>00471 }
<a name="l00472"></a>00472 
</pre></div></div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Tue Dec 14 2021 19:35:43 for TRUST by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
