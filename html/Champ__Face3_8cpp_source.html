<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>TRUST: src/VDF/Champs/Champ_Face3.cpp Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">TRUST&#160;<span id="projectnumber">1.8.4</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
<div class="header">
  <div class="headertitle">
<div class="title">src/VDF/Champs/Champ_Face3.cpp</div>  </div>
</div>
<div class="contents">
<a href="Champ__Face3_8cpp.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/****************************************************************************</span>
<a name="l00002"></a>00002 <span class="comment">* Copyright (c) 2021, CEA</span>
<a name="l00003"></a>00003 <span class="comment">* All rights reserved.</span>
<a name="l00004"></a>00004 <span class="comment">*</span>
<a name="l00005"></a>00005 <span class="comment">* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</span>
<a name="l00006"></a>00006 <span class="comment">* 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.</span>
<a name="l00007"></a>00007 <span class="comment">* 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.</span>
<a name="l00008"></a>00008 <span class="comment">* 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.</span>
<a name="l00009"></a>00009 <span class="comment">*</span>
<a name="l00010"></a>00010 <span class="comment">* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.</span>
<a name="l00011"></a>00011 <span class="comment">* IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;</span>
<a name="l00012"></a>00012 <span class="comment">* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>
<a name="l00013"></a>00013 <span class="comment">*</span>
<a name="l00014"></a>00014 <span class="comment">*****************************************************************************/</span>
<a name="l00015"></a>00015 <span class="comment">//</span>
<a name="l00016"></a>00016 <span class="comment">// </span>
<a name="l00017"></a>00017 <span class="comment">// File:        Champ_Face3.cpp</span>
<a name="l00018"></a>00018 <span class="comment">// Directory:   $TRUST_ROOT/src/VDF/Champs</span>
<a name="l00019"></a>00019 <span class="comment">// Version:     /main/28</span>
<a name="l00020"></a>00020 <span class="comment">// </span>
<a name="l00021"></a>00021 <span class="comment">//</span>
<a name="l00022"></a>00022 
<a name="l00023"></a>00023 <span class="preprocessor">#include &lt;<a class="code" href="Champ__Face_8h.html">Champ_Face.h</a>&gt;</span>
<a name="l00024"></a>00024 <span class="preprocessor">#include &lt;<a class="code" href="Champ__Uniforme_8h.html">Champ_Uniforme.h</a>&gt;</span>
<a name="l00025"></a>00025 <span class="preprocessor">#include &lt;<a class="code" href="Zone__Cl__VDF_8h.html">Zone_Cl_VDF.h</a>&gt;</span>
<a name="l00026"></a>00026 <span class="preprocessor">#include &lt;<a class="code" href="Dirichlet__paroi__fixe_8h.html">Dirichlet_paroi_fixe.h</a>&gt;</span>
<a name="l00027"></a>00027 <span class="preprocessor">#include &lt;<a class="code" href="Fluide__base_8h.html">Fluide_base.h</a>&gt;</span>
<a name="l00028"></a>00028 <span class="preprocessor">#include &lt;<a class="code" href="Equation__base_8h.html">Equation_base.h</a>&gt;</span>
<a name="l00029"></a>00029 <span class="preprocessor">#include &lt;<a class="code" href="Mod__turb__hyd__base_8h.html">Mod_turb_hyd_base.h</a>&gt;</span>
<a name="l00030"></a>00030 <span class="preprocessor">#include &lt;<a class="code" href="distances__VDF_8h.html">distances_VDF.h</a>&gt;</span>
<a name="l00031"></a>00031 
<a name="l00032"></a>00032 <span class="keywordtype">void</span> <a class="code" href="Champ__Face2_8cpp.html#a55b486be8c7ed3ced7518eb23eb1a2a7">calrotord2centelemdim2</a>(<a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; rot, <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; val,
<a name="l00033"></a>00033                             <span class="keyword">const</span> <a class="code" href="classZone__VDF.html" title="class Zone_VDF Classe instanciable qui derive de Zone_VF. Cette classe contient les informations geom...">Zone_VDF</a>&amp; zone_VDF,
<a name="l00034"></a>00034                             <span class="keywordtype">int</span> nb_elem, <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; face_voisins,
<a name="l00035"></a>00035                             <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; elem_faces);
<a name="l00036"></a>00036 
<a name="l00037"></a>00037 <span class="comment">// Traitement des elements internes</span>
<a name="l00038"></a><a class="code" href="Champ__Face3_8cpp.html#a701e9944e0baf4b85e01159b39b6688e">00038</a> <span class="keywordtype">void</span> <a class="code" href="Champ__Face3_8cpp.html#a701e9944e0baf4b85e01159b39b6688e">calcul_interne3D</a>(<span class="keywordtype">int</span> num_elem,
<a name="l00039"></a>00039                       <span class="keywordtype">int</span> elx0,<span class="keywordtype">int</span> elx1,
<a name="l00040"></a>00040                       <span class="keywordtype">int</span> ely0,<span class="keywordtype">int</span> ely1,
<a name="l00041"></a>00041                       <span class="keywordtype">int</span> elz0,<span class="keywordtype">int</span> elz1,
<a name="l00042"></a>00042                       <span class="keyword">const</span> <a class="code" href="classZone__VDF.html" title="class Zone_VDF Classe instanciable qui derive de Zone_VF. Cette classe contient les informations geom...">Zone_VDF</a>&amp; zone_VDF,
<a name="l00043"></a>00043                       <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; val,<a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; rot)
<a name="l00044"></a>00044 {
<a name="l00045"></a>00045   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; elem_faces = zone_VDF.<a class="code" href="classZone__VF.html#a067e462dcd3ab92b0f6d945b19e4eb37" title="renvoie le numero de le ieme face de la maille num_elem la facon dont ces faces sont numerotees est l...">elem_faces</a>();
<a name="l00046"></a>00046   <span class="keywordtype">double</span> delta_x_0,delta_x_1,delta_y_0,delta_y_1,delta_z_0,delta_z_1;
<a name="l00047"></a>00047   <span class="keywordtype">double</span> delta_x,delta_y,delta_z;
<a name="l00048"></a>00048   <span class="keywordtype">double</span> deriv_wy,deriv_vz,deriv_uz,deriv_wx,deriv_vx,deriv_uy;
<a name="l00049"></a>00049 
<a name="l00050"></a>00050   deriv_wy = 0;
<a name="l00051"></a>00051   deriv_vz = 0;
<a name="l00052"></a>00052   deriv_uz = 0;
<a name="l00053"></a>00053   deriv_wx = 0;
<a name="l00054"></a>00054   deriv_vx = 0;
<a name="l00055"></a>00055   deriv_uy = 0;
<a name="l00056"></a>00056 
<a name="l00057"></a>00057   delta_x_0 = zone_VDF.<a class="code" href="classZone__VDF.html#a79bbd491752b86e5a186e50c9e5f8656">dist_elem_period</a>(num_elem,elx0,0);
<a name="l00058"></a>00058   delta_x_1 = zone_VDF.<a class="code" href="classZone__VDF.html#a79bbd491752b86e5a186e50c9e5f8656">dist_elem_period</a>(elx1,num_elem,0);
<a name="l00059"></a>00059   delta_y_0 = zone_VDF.<a class="code" href="classZone__VDF.html#a79bbd491752b86e5a186e50c9e5f8656">dist_elem_period</a>(num_elem,ely0,1);
<a name="l00060"></a>00060   delta_y_1 = zone_VDF.<a class="code" href="classZone__VDF.html#a79bbd491752b86e5a186e50c9e5f8656">dist_elem_period</a>(ely1,num_elem,1);
<a name="l00061"></a>00061   delta_z_0 = zone_VDF.<a class="code" href="classZone__VDF.html#a79bbd491752b86e5a186e50c9e5f8656">dist_elem_period</a>(num_elem,elz0,2);
<a name="l00062"></a>00062   delta_z_1 = zone_VDF.<a class="code" href="classZone__VDF.html#a79bbd491752b86e5a186e50c9e5f8656">dist_elem_period</a>(elz1,num_elem,2);
<a name="l00063"></a>00063 
<a name="l00064"></a>00064   delta_x = (delta_x_1-delta_x_0)*(delta_x_1+delta_x_0)/(delta_x_1*delta_x_0);
<a name="l00065"></a>00065   delta_y = (delta_y_1-delta_y_0)*(delta_y_1+delta_y_0)/(delta_y_1*delta_y_0);
<a name="l00066"></a>00066   delta_z = (delta_z_1-delta_z_0)*(delta_z_1+delta_z_0)/(delta_z_1*delta_z_0);
<a name="l00067"></a>00067 
<a name="l00068"></a>00068   deriv_vz = (delta_z_0/delta_z_1*val(elem_faces(elz1,1))
<a name="l00069"></a>00069               + delta_z*val(elem_faces(num_elem,1))
<a name="l00070"></a>00070               - delta_z_1/delta_z_0*val(elem_faces(elz0,1)));
<a name="l00071"></a>00071   deriv_vz += (delta_z_0/delta_z_1*val(elem_faces(elz1,4))
<a name="l00072"></a>00072                + delta_z*val(elem_faces(num_elem,4))
<a name="l00073"></a>00073                - delta_z_1/delta_z_0*val(elem_faces(elz0,4)));
<a name="l00074"></a>00074   deriv_vz *= 0.5/(delta_z_0 + delta_z_1);
<a name="l00075"></a>00075 
<a name="l00076"></a>00076   deriv_wy = (delta_y_0/delta_y_1*val(elem_faces(ely1,2))
<a name="l00077"></a>00077               + delta_y*val(elem_faces(num_elem,2))
<a name="l00078"></a>00078               - delta_y_1/delta_y_0*val(elem_faces(ely0,2)));
<a name="l00079"></a>00079   deriv_wy += (delta_y_0/delta_y_1*val(elem_faces(ely1,5))
<a name="l00080"></a>00080                + delta_y*val(elem_faces(num_elem,5))
<a name="l00081"></a>00081                - delta_y_1/delta_y_0*val(elem_faces(ely0,5)));
<a name="l00082"></a>00082   deriv_wy *= 0.5/(delta_y_0 + delta_y_1);
<a name="l00083"></a>00083 
<a name="l00084"></a>00084 
<a name="l00085"></a>00085   deriv_uz = (delta_z_0/delta_z_1*val(elem_faces(elz1,0))
<a name="l00086"></a>00086               + delta_z*val(elem_faces(num_elem,0))
<a name="l00087"></a>00087               - delta_z_1/delta_z_0*val(elem_faces(elz0,0)));
<a name="l00088"></a>00088   deriv_uz += (delta_z_0/delta_z_1*val(elem_faces(elz1,3))
<a name="l00089"></a>00089                + delta_z*val(elem_faces(num_elem,3))
<a name="l00090"></a>00090                - delta_z_1/delta_z_0*val(elem_faces(elz0,3)));
<a name="l00091"></a>00091   deriv_uz *= 0.5/(delta_z_0 + delta_z_1);
<a name="l00092"></a>00092 
<a name="l00093"></a>00093   deriv_wx = (delta_x_0/delta_x_1*val(elem_faces(elx1,2))
<a name="l00094"></a>00094               + delta_x*val(elem_faces(num_elem,2))
<a name="l00095"></a>00095               - delta_x_1/delta_x_0*val(elem_faces(elx0,2)));
<a name="l00096"></a>00096   deriv_wx += (delta_x_0/delta_x_1*val(elem_faces(elx1,5))
<a name="l00097"></a>00097                + delta_x*val(elem_faces(num_elem,5))
<a name="l00098"></a>00098                - delta_x_1/delta_x_0*val(elem_faces(elx0,5)));
<a name="l00099"></a>00099   deriv_wx *= 0.5/(delta_x_0 + delta_x_1);
<a name="l00100"></a>00100 
<a name="l00101"></a>00101   deriv_vx = (delta_x_0/delta_x_1*val(elem_faces(elx1,1))
<a name="l00102"></a>00102               + delta_x*val(elem_faces(num_elem,1))
<a name="l00103"></a>00103               - delta_x_1/delta_x_0*val(elem_faces(elx0,1)));
<a name="l00104"></a>00104   deriv_vx += (delta_x_0/delta_x_1*val(elem_faces(elx1,4))
<a name="l00105"></a>00105                + delta_x*val(elem_faces(num_elem,4))
<a name="l00106"></a>00106                - delta_x_1/delta_x_0*val(elem_faces(elx0,4)));
<a name="l00107"></a>00107   deriv_vx *= 0.5/(delta_x_0 + delta_x_1);
<a name="l00108"></a>00108 
<a name="l00109"></a>00109   deriv_uy = (delta_y_0/delta_y_1*val(elem_faces(ely1,0))
<a name="l00110"></a>00110               + delta_y*val(elem_faces(num_elem,0))
<a name="l00111"></a>00111               - delta_y_1/delta_y_0*val(elem_faces(ely0,0)));
<a name="l00112"></a>00112   deriv_uy += (delta_y_0/delta_y_1*val(elem_faces(ely1,3))
<a name="l00113"></a>00113                + delta_y*val(elem_faces(num_elem,3))
<a name="l00114"></a>00114                - delta_y_1/delta_y_0*val(elem_faces(ely0,3)));
<a name="l00115"></a>00115   deriv_uy *= 0.5/(delta_y_0 + delta_y_1);
<a name="l00116"></a>00116 
<a name="l00117"></a>00117   rot(num_elem,0) = deriv_wy - deriv_vz;
<a name="l00118"></a>00118   rot(num_elem,1) = deriv_uz - deriv_wx;
<a name="l00119"></a>00119   rot(num_elem,2) = deriv_vx - deriv_uy;
<a name="l00120"></a>00120 
<a name="l00121"></a>00121 }
<a name="l00122"></a>00122 
<a name="l00123"></a>00123 <span class="comment">// Traitement des elements bord</span>
<a name="l00124"></a><a class="code" href="Champ__Face3_8cpp.html#a5e855238159aa648d515cdc0d8a5d8cf">00124</a> <span class="keywordtype">void</span> <a class="code" href="Champ__Face3_8cpp.html#a5e855238159aa648d515cdc0d8a5d8cf">calcul_bord3D</a>(<span class="keywordtype">int</span> num_elem,
<a name="l00125"></a>00125                    <span class="keywordtype">int</span> elx0,<span class="keywordtype">int</span> elx1,
<a name="l00126"></a>00126                    <span class="keywordtype">int</span> ely0,<span class="keywordtype">int</span> ely1,
<a name="l00127"></a>00127                    <span class="keywordtype">int</span> elz0,<span class="keywordtype">int</span> elz1,
<a name="l00128"></a>00128                    <span class="keyword">const</span> <a class="code" href="classZone__VDF.html" title="class Zone_VDF Classe instanciable qui derive de Zone_VF. Cette classe contient les informations geom...">Zone_VDF</a>&amp; zone_VDF,
<a name="l00129"></a>00129                    <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; val,<a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; rot)
<a name="l00130"></a>00130 {
<a name="l00131"></a>00131   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; elem_faces = zone_VDF.<a class="code" href="classZone__VF.html#a067e462dcd3ab92b0f6d945b19e4eb37" title="renvoie le numero de le ieme face de la maille num_elem la facon dont ces faces sont numerotees est l...">elem_faces</a>();
<a name="l00132"></a>00132   <span class="keywordtype">double</span> delta_x_0,delta_x_1,delta_y_0,delta_y_1,delta_z_0,delta_z_1;
<a name="l00133"></a>00133   <span class="keywordtype">double</span> delta_x,delta_y,delta_z;
<a name="l00134"></a>00134   <span class="keywordtype">double</span> deriv_wy,deriv_vz,deriv_uz,deriv_wx,deriv_vx,deriv_uy;
<a name="l00135"></a>00135 
<a name="l00136"></a>00136   deriv_wy = 0;
<a name="l00137"></a>00137   deriv_vz = 0;
<a name="l00138"></a>00138   deriv_uz = 0;
<a name="l00139"></a>00139   deriv_wx = 0;
<a name="l00140"></a>00140   deriv_vx = 0;
<a name="l00141"></a>00141   deriv_uy = 0;
<a name="l00142"></a>00142 
<a name="l00143"></a>00143 <span class="comment">// Traitement des elements bord</span>
<a name="l00144"></a>00144 
<a name="l00145"></a>00145   <span class="keywordflow">if</span> ( (elx0 == -1) || (elx1 == -1) )
<a name="l00146"></a>00146     {
<a name="l00147"></a>00147       <span class="keywordflow">if</span> (elx0 == -1)
<a name="l00148"></a>00148         {
<a name="l00149"></a>00149           <span class="keywordflow">if</span> (elx1 != -1)
<a name="l00150"></a>00150             {
<a name="l00151"></a>00151               delta_x_1 = zone_VDF.<a class="code" href="classZone__VDF.html#a79bbd491752b86e5a186e50c9e5f8656">dist_elem_period</a>(elx1,num_elem,0);
<a name="l00152"></a>00152               deriv_vx = (val(elem_faces(elx1,1))-val(elem_faces(num_elem,1))
<a name="l00153"></a>00153                           + val(elem_faces(elx1,4))-val(elem_faces(num_elem,4)));
<a name="l00154"></a>00154               deriv_vx *= 0.5/delta_x_1;
<a name="l00155"></a>00155               deriv_wx = (val(elem_faces(elx1,2))-val(elem_faces(num_elem,2))
<a name="l00156"></a>00156                           + val(elem_faces(elx1,5))-val(elem_faces(num_elem,5)));
<a name="l00157"></a>00157               deriv_wx *= 0.5/delta_x_1;
<a name="l00158"></a>00158             }
<a name="l00159"></a>00159           <span class="keywordflow">else</span>
<a name="l00160"></a>00160             {
<a name="l00161"></a>00161               deriv_vx = 0;
<a name="l00162"></a>00162               deriv_wx = 0;
<a name="l00163"></a>00163             }
<a name="l00164"></a>00164         }
<a name="l00165"></a>00165       <span class="keywordflow">else</span> <span class="comment">//!&lt; elx1 = -1 et elx0 != -1</span>
<a name="l00166"></a>00166 <span class="comment"></span>        {
<a name="l00167"></a>00167           delta_x_0 = zone_VDF.<a class="code" href="classZone__VDF.html#a79bbd491752b86e5a186e50c9e5f8656">dist_elem_period</a>(num_elem,elx0,0);
<a name="l00168"></a>00168           deriv_vx = (val(elem_faces(num_elem,1))-val(elem_faces(elx0,1))
<a name="l00169"></a>00169                       + val(elem_faces(num_elem,4))-val(elem_faces(elx0,4)));
<a name="l00170"></a>00170           deriv_vx *= 0.5/delta_x_0;
<a name="l00171"></a>00171           deriv_wx = (val(elem_faces(num_elem,2))-val(elem_faces(elx0,2))
<a name="l00172"></a>00172                       + val(elem_faces(num_elem,5))-val(elem_faces(elx0,5)));
<a name="l00173"></a>00173           deriv_wx *= 0.5/delta_x_0;
<a name="l00174"></a>00174         }
<a name="l00175"></a>00175 
<a name="l00176"></a>00176       <span class="keywordflow">if</span> ( (ely0 == -1) || (ely1 == -1) )
<a name="l00177"></a>00177         {
<a name="l00178"></a>00178           <span class="keywordflow">if</span> (ely0 == -1)
<a name="l00179"></a>00179             {
<a name="l00180"></a>00180               <span class="keywordflow">if</span> (ely1 != -1)
<a name="l00181"></a>00181                 {
<a name="l00182"></a>00182                   delta_y_1 = zone_VDF.<a class="code" href="classZone__VDF.html#a79bbd491752b86e5a186e50c9e5f8656">dist_elem_period</a>(ely1,num_elem,1);
<a name="l00183"></a>00183                   deriv_uy = (val(elem_faces(ely1,0))-val(elem_faces(num_elem,0))
<a name="l00184"></a>00184                               + val(elem_faces(ely1,3))-val(elem_faces(num_elem,3)));
<a name="l00185"></a>00185                   deriv_uy *= 0.5/delta_y_1;
<a name="l00186"></a>00186                   deriv_wy = (val(elem_faces(ely1,2))-val(elem_faces(num_elem,2))
<a name="l00187"></a>00187                               + val(elem_faces(ely1,5))-val(elem_faces(num_elem,5)));
<a name="l00188"></a>00188                   deriv_wy *= 0.5/delta_y_1;
<a name="l00189"></a>00189                 }
<a name="l00190"></a>00190               <span class="keywordflow">else</span>
<a name="l00191"></a>00191                 {
<a name="l00192"></a>00192                   deriv_uy = 0;
<a name="l00193"></a>00193                   deriv_wy = 0;
<a name="l00194"></a>00194                 }
<a name="l00195"></a>00195             }
<a name="l00196"></a>00196           <span class="keywordflow">else</span> <span class="comment">//!&lt; ely1 = -1 et ely0 != -1</span>
<a name="l00197"></a>00197 <span class="comment"></span>            {
<a name="l00198"></a>00198               delta_y_0 = zone_VDF.<a class="code" href="classZone__VDF.html#a79bbd491752b86e5a186e50c9e5f8656">dist_elem_period</a>(num_elem,ely0,1);
<a name="l00199"></a>00199               deriv_uy = (val(elem_faces(num_elem,0))-val(elem_faces(ely0,0))
<a name="l00200"></a>00200                           + val(elem_faces(num_elem,3))-val(elem_faces(ely0,3)));
<a name="l00201"></a>00201               deriv_uy *= 0.5/delta_y_0;
<a name="l00202"></a>00202               deriv_wy = (val(elem_faces(num_elem,2))-val(elem_faces(ely0,2))
<a name="l00203"></a>00203                           + val(elem_faces(num_elem,5))-val(elem_faces(ely0,5)));
<a name="l00204"></a>00204               deriv_wy *= 0.5/delta_y_0;
<a name="l00205"></a>00205             }
<a name="l00206"></a>00206         }
<a name="l00207"></a>00207       <span class="keywordflow">else</span>
<a name="l00208"></a>00208         {
<a name="l00209"></a>00209           delta_y_0 = zone_VDF.<a class="code" href="classZone__VDF.html#a79bbd491752b86e5a186e50c9e5f8656">dist_elem_period</a>(num_elem,ely0,1);
<a name="l00210"></a>00210           delta_y_1 = zone_VDF.<a class="code" href="classZone__VDF.html#a79bbd491752b86e5a186e50c9e5f8656">dist_elem_period</a>(ely1,num_elem,1);
<a name="l00211"></a>00211           delta_y = (delta_y_1-delta_y_0)*(delta_y_1+delta_y_0)/(delta_y_1*delta_y_0);
<a name="l00212"></a>00212 
<a name="l00213"></a>00213           deriv_uy = (delta_y_0/delta_y_1*val(elem_faces(ely1,0))
<a name="l00214"></a>00214                       + delta_y*val(elem_faces(num_elem,0))
<a name="l00215"></a>00215                       - delta_y_1/delta_y_0*val(elem_faces(ely0,0)));
<a name="l00216"></a>00216           deriv_uy += (delta_y_0/delta_y_1*val(elem_faces(ely1,3))
<a name="l00217"></a>00217                        + delta_y*val(elem_faces(num_elem,3))
<a name="l00218"></a>00218                        - delta_y_1/delta_y_0*val(elem_faces(ely0,3)));
<a name="l00219"></a>00219           deriv_uy *= 0.5/(delta_y_0 + delta_y_1);
<a name="l00220"></a>00220 
<a name="l00221"></a>00221           deriv_wy = (delta_y_0/delta_y_1*val(elem_faces(ely1,2))
<a name="l00222"></a>00222                       + delta_y*val(elem_faces(num_elem,2))
<a name="l00223"></a>00223                       - delta_y_1/delta_y_0*val(elem_faces(ely0,2)));
<a name="l00224"></a>00224           deriv_wy += (delta_y_0/delta_y_1*val(elem_faces(ely1,5))
<a name="l00225"></a>00225                        + delta_y*val(elem_faces(num_elem,5))
<a name="l00226"></a>00226                        - delta_y_1/delta_y_0*val(elem_faces(ely0,5)));
<a name="l00227"></a>00227           deriv_wy *= 0.5/(delta_y_0 + delta_y_1);
<a name="l00228"></a>00228         }
<a name="l00229"></a>00229 
<a name="l00230"></a>00230       <span class="keywordflow">if</span> ( (elz0 == -1) || (elz1 == -1) )
<a name="l00231"></a>00231         {
<a name="l00232"></a>00232           <span class="keywordflow">if</span> (elz0 == -1)
<a name="l00233"></a>00233             {
<a name="l00234"></a>00234               <span class="keywordflow">if</span> (elz1 != -1)
<a name="l00235"></a>00235                 {
<a name="l00236"></a>00236                   delta_z_1 = zone_VDF.<a class="code" href="classZone__VDF.html#a79bbd491752b86e5a186e50c9e5f8656">dist_elem_period</a>(elz1,num_elem,2);
<a name="l00237"></a>00237                   deriv_uz = (val(elem_faces(elz1,0))-val(elem_faces(num_elem,0))
<a name="l00238"></a>00238                               + val(elem_faces(elz1,3))-val(elem_faces(num_elem,3)));
<a name="l00239"></a>00239                   deriv_uz *= 0.5/delta_z_1;
<a name="l00240"></a>00240                   deriv_vz = (val(elem_faces(elz1,1))-val(elem_faces(num_elem,1))
<a name="l00241"></a>00241                               + val(elem_faces(elz1,4))-val(elem_faces(num_elem,4)));
<a name="l00242"></a>00242                   deriv_vz *= 0.5/delta_z_1;
<a name="l00243"></a>00243                 }
<a name="l00244"></a>00244               <span class="keywordflow">else</span>
<a name="l00245"></a>00245                 {
<a name="l00246"></a>00246                   deriv_uz = 0;
<a name="l00247"></a>00247                   deriv_vz = 0;
<a name="l00248"></a>00248                 }
<a name="l00249"></a>00249             }
<a name="l00250"></a>00250           <span class="keywordflow">else</span> <span class="comment">//!&lt; elz1 = -1 et elz0 != -1</span>
<a name="l00251"></a>00251 <span class="comment"></span>            {
<a name="l00252"></a>00252               delta_z_0 = zone_VDF.<a class="code" href="classZone__VDF.html#a79bbd491752b86e5a186e50c9e5f8656">dist_elem_period</a>(num_elem,elz0,2);
<a name="l00253"></a>00253               deriv_uz = (val(elem_faces(num_elem,0))-val(elem_faces(elz0,0))
<a name="l00254"></a>00254                           + val(elem_faces(num_elem,3))-val(elem_faces(elz0,3)));
<a name="l00255"></a>00255               deriv_uz *= 0.5/delta_z_0;
<a name="l00256"></a>00256               deriv_vz =(val(elem_faces(num_elem,1))-val(elem_faces(elz0,1))
<a name="l00257"></a>00257                          + val(elem_faces(num_elem,4))-val(elem_faces(elz0,4)));
<a name="l00258"></a>00258               deriv_vz *= 0.5/delta_z_0;
<a name="l00259"></a>00259             }
<a name="l00260"></a>00260         }
<a name="l00261"></a>00261       <span class="keywordflow">else</span>
<a name="l00262"></a>00262         {
<a name="l00263"></a>00263           delta_z_0 = zone_VDF.<a class="code" href="classZone__VDF.html#a79bbd491752b86e5a186e50c9e5f8656">dist_elem_period</a>(num_elem,elz0,2);
<a name="l00264"></a>00264           delta_z_1 = zone_VDF.<a class="code" href="classZone__VDF.html#a79bbd491752b86e5a186e50c9e5f8656">dist_elem_period</a>(elz1,num_elem,2);
<a name="l00265"></a>00265           delta_z = (delta_z_1-delta_z_0)*(delta_z_1+delta_z_0)/(delta_z_1*delta_z_0);
<a name="l00266"></a>00266 
<a name="l00267"></a>00267           deriv_uz = (delta_z_0/delta_z_1*val(elem_faces(elz1,0))
<a name="l00268"></a>00268                       + delta_z*val(elem_faces(num_elem,0))
<a name="l00269"></a>00269                       - delta_z_1/delta_z_0*val(elem_faces(elz0,0)));
<a name="l00270"></a>00270           deriv_uz += (delta_z_0/delta_z_1*val(elem_faces(elz1,3))
<a name="l00271"></a>00271                        + delta_z*val(elem_faces(num_elem,3))
<a name="l00272"></a>00272                        - delta_z_1/delta_z_0*val(elem_faces(elz0,3)));
<a name="l00273"></a>00273           deriv_uz *= 0.5/(delta_z_0 + delta_z_1);
<a name="l00274"></a>00274 
<a name="l00275"></a>00275           deriv_vz = (delta_z_0/delta_z_1*val(elem_faces(elz1,1))
<a name="l00276"></a>00276                       + delta_z*val(elem_faces(num_elem,1))
<a name="l00277"></a>00277                       - delta_z_1/delta_z_0*val(elem_faces(elz0,1)));
<a name="l00278"></a>00278           deriv_vz += (delta_z_0/delta_z_1*val(elem_faces(elz1,4))
<a name="l00279"></a>00279                        + delta_z*val(elem_faces(num_elem,4))
<a name="l00280"></a>00280                        - delta_z_1/delta_z_0*val(elem_faces(elz0,4)));
<a name="l00281"></a>00281           deriv_vz *= 0.5/(delta_z_0 + delta_z_1);
<a name="l00282"></a>00282         }
<a name="l00283"></a>00283 
<a name="l00284"></a>00284     }
<a name="l00285"></a>00285   <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( (ely0 == -1) || (ely1 == -1) )
<a name="l00286"></a>00286     {
<a name="l00287"></a>00287 
<a name="l00288"></a>00288       <span class="keywordflow">if</span> (ely0 == -1)
<a name="l00289"></a>00289         {
<a name="l00290"></a>00290           <span class="keywordflow">if</span> (ely1 != -1)
<a name="l00291"></a>00291             {
<a name="l00292"></a>00292               delta_y_1 = zone_VDF.<a class="code" href="classZone__VDF.html#a79bbd491752b86e5a186e50c9e5f8656">dist_elem_period</a>(ely1,num_elem,1);
<a name="l00293"></a>00293               deriv_uy = (val(elem_faces(ely1,0))-val(elem_faces(num_elem,0))
<a name="l00294"></a>00294                           + val(elem_faces(ely1,3))-val(elem_faces(num_elem,3)));
<a name="l00295"></a>00295               deriv_uy *= 0.5/delta_y_1;
<a name="l00296"></a>00296               deriv_wy = (val(elem_faces(ely1,2))-val(elem_faces(num_elem,2))
<a name="l00297"></a>00297                           + val(elem_faces(ely1,5))-val(elem_faces(num_elem,5)));
<a name="l00298"></a>00298               deriv_wy *= 0.5/delta_y_1;
<a name="l00299"></a>00299             }
<a name="l00300"></a>00300           <span class="keywordflow">else</span>
<a name="l00301"></a>00301             {
<a name="l00302"></a>00302               deriv_uy = 0;
<a name="l00303"></a>00303               deriv_wy = 0;
<a name="l00304"></a>00304             }
<a name="l00305"></a>00305         }
<a name="l00306"></a>00306       <span class="keywordflow">else</span>  <span class="comment">//!&lt; ely1 = -1 et ely0 != -1</span>
<a name="l00307"></a>00307 <span class="comment"></span>        {
<a name="l00308"></a>00308           delta_y_0 = zone_VDF.<a class="code" href="classZone__VDF.html#a79bbd491752b86e5a186e50c9e5f8656">dist_elem_period</a>(num_elem,ely0,1);
<a name="l00309"></a>00309           deriv_uy = (val(elem_faces(num_elem,0))-val(elem_faces(ely0,0))
<a name="l00310"></a>00310                       + val(elem_faces(num_elem,3))-val(elem_faces(ely0,3)));
<a name="l00311"></a>00311           deriv_uy *= 0.5/delta_y_0;
<a name="l00312"></a>00312           deriv_wy = (val(elem_faces(num_elem,2))-val(elem_faces(ely0,2))
<a name="l00313"></a>00313                       + val(elem_faces(num_elem,5))-val(elem_faces(ely0,5)));
<a name="l00314"></a>00314           deriv_wy *= 0.5/delta_y_0;
<a name="l00315"></a>00315         }
<a name="l00316"></a>00316 
<a name="l00317"></a>00317       delta_x_0 = zone_VDF.<a class="code" href="classZone__VDF.html#a79bbd491752b86e5a186e50c9e5f8656">dist_elem_period</a>(num_elem,elx0,0);
<a name="l00318"></a>00318       delta_x_1 = zone_VDF.<a class="code" href="classZone__VDF.html#a79bbd491752b86e5a186e50c9e5f8656">dist_elem_period</a>(elx1,num_elem,0);
<a name="l00319"></a>00319       delta_x = (delta_x_1-delta_x_0)*(delta_x_1+delta_x_0)/(delta_x_1*delta_x_0);
<a name="l00320"></a>00320 
<a name="l00321"></a>00321       deriv_wx = (delta_x_0/delta_x_1*val(elem_faces(elx1,2))
<a name="l00322"></a>00322                   + delta_x*val(elem_faces(num_elem,2))
<a name="l00323"></a>00323                   - delta_x_1/delta_x_0*val(elem_faces(elx0,2)));
<a name="l00324"></a>00324       deriv_wx += (delta_x_0/delta_x_1*val(elem_faces(elx1,5))
<a name="l00325"></a>00325                    + delta_x*val(elem_faces(num_elem,5))
<a name="l00326"></a>00326                    - delta_x_1/delta_x_0*val(elem_faces(elx0,5)));
<a name="l00327"></a>00327       deriv_wx *= 0.5/(delta_x_0 + delta_x_1);
<a name="l00328"></a>00328 
<a name="l00329"></a>00329       deriv_vx = (delta_x_0/delta_x_1*val(elem_faces(elx1,1))
<a name="l00330"></a>00330                   + delta_x*val(elem_faces(num_elem,1))
<a name="l00331"></a>00331                   - delta_x_1/delta_x_0*val(elem_faces(elx0,1)));
<a name="l00332"></a>00332       deriv_vx += (delta_x_0/delta_x_1*val(elem_faces(elx1,4))
<a name="l00333"></a>00333                    + delta_x*val(elem_faces(num_elem,4))
<a name="l00334"></a>00334                    - delta_x_1/delta_x_0*val(elem_faces(elx0,4)));
<a name="l00335"></a>00335       deriv_vx *= 0.5/(delta_x_0 + delta_x_1);
<a name="l00336"></a>00336 
<a name="l00337"></a>00337 
<a name="l00338"></a>00338       <span class="keywordflow">if</span> ( (elz0 == -1) || (elz1 == -1) )
<a name="l00339"></a>00339         {
<a name="l00340"></a>00340           <span class="keywordflow">if</span> (elz0 == -1)
<a name="l00341"></a>00341             {
<a name="l00342"></a>00342               <span class="keywordflow">if</span> (elz1 != -1)
<a name="l00343"></a>00343                 {
<a name="l00344"></a>00344                   delta_z_1 = zone_VDF.<a class="code" href="classZone__VDF.html#a79bbd491752b86e5a186e50c9e5f8656">dist_elem_period</a>(elz1,num_elem,2);
<a name="l00345"></a>00345                   deriv_uz = (val(elem_faces(elz1,0))-val(elem_faces(num_elem,0))
<a name="l00346"></a>00346                               + val(elem_faces(elz1,3))-val(elem_faces(num_elem,3)));
<a name="l00347"></a>00347                   deriv_uz *= 0.5/delta_z_1;
<a name="l00348"></a>00348                   deriv_vz = (val(elem_faces(elz1,1))-val(elem_faces(num_elem,1))
<a name="l00349"></a>00349                               + val(elem_faces(elz1,4))-val(elem_faces(num_elem,4)));
<a name="l00350"></a>00350                   deriv_vz *= 0.5/delta_z_1;
<a name="l00351"></a>00351                 }
<a name="l00352"></a>00352               <span class="keywordflow">else</span>
<a name="l00353"></a>00353                 {
<a name="l00354"></a>00354                   deriv_uz = 0;
<a name="l00355"></a>00355                   deriv_vz = 0;
<a name="l00356"></a>00356                 }
<a name="l00357"></a>00357             }
<a name="l00358"></a>00358           <span class="keywordflow">else</span>
<a name="l00359"></a>00359             {
<a name="l00360"></a>00360               delta_z_0 = zone_VDF.<a class="code" href="classZone__VDF.html#a79bbd491752b86e5a186e50c9e5f8656">dist_elem_period</a>(num_elem,elz0,2);
<a name="l00361"></a>00361               deriv_uz = (val(elem_faces(num_elem,0))-val(elem_faces(elz0,0))
<a name="l00362"></a>00362                           + val(elem_faces(num_elem,3))-val(elem_faces(elz0,3)));
<a name="l00363"></a>00363               deriv_uz *= 0.5/delta_z_0;
<a name="l00364"></a>00364               deriv_vz =(val(elem_faces(num_elem,1))-val(elem_faces(elz0,1))
<a name="l00365"></a>00365                          + val(elem_faces(num_elem,4))-val(elem_faces(elz0,4)));
<a name="l00366"></a>00366               deriv_vz *= 0.5/delta_z_0;
<a name="l00367"></a>00367             }
<a name="l00368"></a>00368         }
<a name="l00369"></a>00369       <span class="keywordflow">else</span>
<a name="l00370"></a>00370         {
<a name="l00371"></a>00371           delta_z_0 = zone_VDF.<a class="code" href="classZone__VDF.html#a79bbd491752b86e5a186e50c9e5f8656">dist_elem_period</a>(num_elem,elz0,2);
<a name="l00372"></a>00372           delta_z_1 = zone_VDF.<a class="code" href="classZone__VDF.html#a79bbd491752b86e5a186e50c9e5f8656">dist_elem_period</a>(elz1,num_elem,2);
<a name="l00373"></a>00373           delta_z = (delta_z_1-delta_z_0)*(delta_z_1+delta_z_0)/(delta_z_1*delta_z_0);
<a name="l00374"></a>00374 
<a name="l00375"></a>00375           deriv_uz = (delta_z_0/delta_z_1*val(elem_faces(elz1,0))
<a name="l00376"></a>00376                       + delta_z*val(elem_faces(num_elem,0))
<a name="l00377"></a>00377                       - delta_z_1/delta_z_0*val(elem_faces(elz0,0)));
<a name="l00378"></a>00378           deriv_uz += (delta_z_0/delta_z_1*val(elem_faces(elz1,3))
<a name="l00379"></a>00379                        + delta_z*val(elem_faces(num_elem,3))
<a name="l00380"></a>00380                        - delta_z_1/delta_z_0*val(elem_faces(elz0,3)));
<a name="l00381"></a>00381           deriv_uz *= 0.5/(delta_z_0 + delta_z_1);
<a name="l00382"></a>00382 
<a name="l00383"></a>00383           deriv_vz = (delta_z_0/delta_z_1*val(elem_faces(elz1,1))
<a name="l00384"></a>00384                       + delta_z*val(elem_faces(num_elem,1))
<a name="l00385"></a>00385                       - delta_z_1/delta_z_0*val(elem_faces(elz0,1)));
<a name="l00386"></a>00386           deriv_vz += (delta_z_0/delta_z_1*val(elem_faces(elz1,4))
<a name="l00387"></a>00387                        + delta_z*val(elem_faces(num_elem,4))
<a name="l00388"></a>00388                        - delta_z_1/delta_z_0*val(elem_faces(elz0,4)));
<a name="l00389"></a>00389           deriv_vz *= 0.5/(delta_z_0 + delta_z_1);
<a name="l00390"></a>00390         }
<a name="l00391"></a>00391     }
<a name="l00392"></a>00392   <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( (elz0 == -1) || (elz1 == -1) )
<a name="l00393"></a>00393     {
<a name="l00394"></a>00394       <span class="keywordflow">if</span> (elz0 == -1)
<a name="l00395"></a>00395         {
<a name="l00396"></a>00396           <span class="keywordflow">if</span> (elz1 != -1)
<a name="l00397"></a>00397             {
<a name="l00398"></a>00398               delta_z_1 = zone_VDF.<a class="code" href="classZone__VDF.html#a79bbd491752b86e5a186e50c9e5f8656">dist_elem_period</a>(elz1,num_elem,2);
<a name="l00399"></a>00399               deriv_uz = (val(elem_faces(elz1,0))-val(elem_faces(num_elem,0))
<a name="l00400"></a>00400                           + val(elem_faces(elz1,3))-val(elem_faces(num_elem,3)));
<a name="l00401"></a>00401               deriv_uz *= 0.5/delta_z_1;
<a name="l00402"></a>00402               deriv_vz = (val(elem_faces(elz1,1))-val(elem_faces(num_elem,1))
<a name="l00403"></a>00403                           + val(elem_faces(elz1,4))-val(elem_faces(num_elem,4)));
<a name="l00404"></a>00404               deriv_vz *= 0.5/delta_z_1;
<a name="l00405"></a>00405             }
<a name="l00406"></a>00406           <span class="keywordflow">else</span>
<a name="l00407"></a>00407             {
<a name="l00408"></a>00408               deriv_uz = 0;
<a name="l00409"></a>00409               deriv_vz = 0;
<a name="l00410"></a>00410             }
<a name="l00411"></a>00411         }
<a name="l00412"></a>00412       <span class="keywordflow">else</span> <span class="comment">//!&lt; elz1 = -1 et elz0 != -1</span>
<a name="l00413"></a>00413 <span class="comment"></span>        {
<a name="l00414"></a>00414           delta_z_0 = zone_VDF.<a class="code" href="classZone__VDF.html#a79bbd491752b86e5a186e50c9e5f8656">dist_elem_period</a>(num_elem,elz0,2);
<a name="l00415"></a>00415           deriv_uz = (val(elem_faces(num_elem,0))-val(elem_faces(elz0,0))
<a name="l00416"></a>00416                       + val(elem_faces(num_elem,3))-val(elem_faces(elz0,3)));
<a name="l00417"></a>00417           deriv_uz *= 0.5/delta_z_0;
<a name="l00418"></a>00418           deriv_vz =(val(elem_faces(num_elem,1))-val(elem_faces(elz0,1))
<a name="l00419"></a>00419                      + val(elem_faces(num_elem,4))-val(elem_faces(elz0,4)));
<a name="l00420"></a>00420           deriv_vz *= 0.5/delta_z_0;
<a name="l00421"></a>00421         }
<a name="l00422"></a>00422 
<a name="l00423"></a>00423       delta_x_0 = zone_VDF.<a class="code" href="classZone__VDF.html#a79bbd491752b86e5a186e50c9e5f8656">dist_elem_period</a>(num_elem,elx0,0);
<a name="l00424"></a>00424       delta_x_1 = zone_VDF.<a class="code" href="classZone__VDF.html#a79bbd491752b86e5a186e50c9e5f8656">dist_elem_period</a>(elx1,num_elem,0);
<a name="l00425"></a>00425       delta_x = (delta_x_1-delta_x_0)*(delta_x_1+delta_x_0)/(delta_x_1*delta_x_0);
<a name="l00426"></a>00426 
<a name="l00427"></a>00427       deriv_wx = (delta_x_0/delta_x_1*val(elem_faces(elx1,2))
<a name="l00428"></a>00428                   + delta_x*val(elem_faces(num_elem,2))
<a name="l00429"></a>00429                   - delta_x_1/delta_x_0*val(elem_faces(elx0,2)));
<a name="l00430"></a>00430       deriv_wx += (delta_x_0/delta_x_1*val(elem_faces(elx1,5))
<a name="l00431"></a>00431                    + delta_x*val(elem_faces(num_elem,5))
<a name="l00432"></a>00432                    - delta_x_1/delta_x_0*val(elem_faces(elx0,5)));
<a name="l00433"></a>00433       deriv_wx *= 0.5/(delta_x_0 + delta_x_1);
<a name="l00434"></a>00434 
<a name="l00435"></a>00435       deriv_vx = (delta_x_0/delta_x_1*val(elem_faces(elx1,1))
<a name="l00436"></a>00436                   + delta_x*val(elem_faces(num_elem,1))
<a name="l00437"></a>00437                   - delta_x_1/delta_x_0*val(elem_faces(elx0,1)));
<a name="l00438"></a>00438       deriv_vx += (delta_x_0/delta_x_1*val(elem_faces(elx1,4))
<a name="l00439"></a>00439                    + delta_x*val(elem_faces(num_elem,4))
<a name="l00440"></a>00440                    - delta_x_1/delta_x_0*val(elem_faces(elx0,4)));
<a name="l00441"></a>00441       deriv_vx *= 0.5/(delta_x_0 + delta_x_1);
<a name="l00442"></a>00442 
<a name="l00443"></a>00443       delta_y_0 = zone_VDF.<a class="code" href="classZone__VDF.html#a79bbd491752b86e5a186e50c9e5f8656">dist_elem_period</a>(num_elem,ely0,1);
<a name="l00444"></a>00444       delta_y_1 = zone_VDF.<a class="code" href="classZone__VDF.html#a79bbd491752b86e5a186e50c9e5f8656">dist_elem_period</a>(ely1,num_elem,1);
<a name="l00445"></a>00445       delta_y = (delta_y_1-delta_y_0)*(delta_y_1+delta_y_0)/(delta_y_1*delta_y_0);
<a name="l00446"></a>00446 
<a name="l00447"></a>00447       deriv_wy = (delta_y_0/delta_y_1*val(elem_faces(ely1,2))
<a name="l00448"></a>00448                   + delta_y*val(elem_faces(num_elem,2))
<a name="l00449"></a>00449                   - delta_y_1/delta_y_0*val(elem_faces(ely0,2)));
<a name="l00450"></a>00450       deriv_wy += (delta_y_0/delta_y_1*val(elem_faces(ely1,5))
<a name="l00451"></a>00451                    + delta_y*val(elem_faces(num_elem,5))
<a name="l00452"></a>00452                    - delta_y_1/delta_y_0*val(elem_faces(ely0,5)));
<a name="l00453"></a>00453       deriv_wy *= 0.5/(delta_y_0 + delta_y_1);
<a name="l00454"></a>00454 
<a name="l00455"></a>00455       deriv_uy = (delta_y_0/delta_y_1*val(elem_faces(ely1,0))
<a name="l00456"></a>00456                   + delta_y*val(elem_faces(num_elem,0))
<a name="l00457"></a>00457                   - delta_y_1/delta_y_0*val(elem_faces(ely0,0)));
<a name="l00458"></a>00458       deriv_uy += (delta_y_0/delta_y_1*val(elem_faces(ely1,3))
<a name="l00459"></a>00459                    + delta_y*val(elem_faces(num_elem,3))
<a name="l00460"></a>00460                    - delta_y_1/delta_y_0*val(elem_faces(ely0,3)));
<a name="l00461"></a>00461       deriv_uy *= 0.5/(delta_y_0 + delta_y_1);
<a name="l00462"></a>00462     }
<a name="l00463"></a>00463 
<a name="l00464"></a>00464   rot(num_elem,0) = deriv_wy - deriv_vz;
<a name="l00465"></a>00465   rot(num_elem,1) = deriv_uz - deriv_wx;
<a name="l00466"></a>00466   rot(num_elem,2) = deriv_vx - deriv_uy;
<a name="l00467"></a>00467 }
<a name="l00468"></a>00468 
<a name="l00469"></a><a class="code" href="Champ__Face3_8cpp.html#ad6f2d561a2b01a55d910955d7b4964a9">00469</a> <span class="keywordtype">void</span> <a class="code" href="Champ__Face3_8cpp.html#ad6f2d561a2b01a55d910955d7b4964a9">calrotord2centelemdim3</a>(<a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; rot, <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; val, <span class="keyword">const</span> <a class="code" href="classZone__VDF.html" title="class Zone_VDF Classe instanciable qui derive de Zone_VF. Cette classe contient les informations geom...">Zone_VDF</a>&amp; zone_VDF,
<a name="l00470"></a>00470                             <span class="keywordtype">int</span> nb_elem, <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; face_voisins, <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; elem_faces)
<a name="l00471"></a>00471 {
<a name="l00472"></a>00472   <span class="keywordflow">if</span>(rot.<a class="code" href="classDoubleTab.html#ac3805e2637a3b880ba2d3e650c69dac4" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(0)!=nb_elem)
<a name="l00473"></a>00473     rot.<a class="code" href="classDoubleTab.html#ae83b4d31205c53d9c8d2b43da178ce75" title="Change la taille du vecteur (identique a resize_array() pour le traitement des anciennes valeurs et d...">resize</a>(nb_elem, 3);
<a name="l00474"></a>00474   <span class="keywordtype">int</span> elx0,elx1,ely0,ely1,elz0,elz1;
<a name="l00475"></a>00475 
<a name="l00476"></a>00476   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> num_elem=0; num_elem&lt;nb_elem; num_elem++)
<a name="l00477"></a>00477     {
<a name="l00478"></a>00478 
<a name="l00479"></a>00479       elx0 = face_voisins(elem_faces(num_elem,0),0);
<a name="l00480"></a>00480       elx1 = face_voisins(elem_faces(num_elem,3),1);
<a name="l00481"></a>00481       ely0 = face_voisins(elem_faces(num_elem,1),0);
<a name="l00482"></a>00482       ely1 = face_voisins(elem_faces(num_elem,4),1);
<a name="l00483"></a>00483       elz0 = face_voisins(elem_faces(num_elem,2),0);
<a name="l00484"></a>00484       elz1 = face_voisins(elem_faces(num_elem,5),1);
<a name="l00485"></a>00485 
<a name="l00486"></a>00486       <span class="keywordflow">if</span> ( (elx0 != -1) &amp;&amp; (elx1 != -1) &amp;&amp; (ely0 != -1)
<a name="l00487"></a>00487            &amp;&amp; (ely1 != -1) &amp;&amp; (elz0 != -1) &amp;&amp; (elz1 != -1) )
<a name="l00488"></a>00488 <span class="comment">// Cas d&#39;un element interne</span>
<a name="l00489"></a>00489 
<a name="l00490"></a>00490         <a class="code" href="Champ__Face3_8cpp.html#a701e9944e0baf4b85e01159b39b6688e">calcul_interne3D</a>(num_elem,elx0,elx1,ely0,ely1,elz0,elz1,zone_VDF,val,rot);
<a name="l00491"></a>00491       <span class="keywordflow">else</span>
<a name="l00492"></a>00492         <a class="code" href="Champ__Face3_8cpp.html#a5e855238159aa648d515cdc0d8a5d8cf">calcul_bord3D</a>(num_elem,elx0,elx1,ely0,ely1,elz0,elz1,zone_VDF,val,rot);
<a name="l00493"></a>00493     }
<a name="l00494"></a>00494 }
<a name="l00495"></a>00495 
<a name="l00496"></a>00496 
<a name="l00497"></a>00497 
<a name="l00498"></a><a class="code" href="classChamp__Face.html#a571ff22af5c4c516d6497521acc85b78">00498</a> <span class="keywordtype">void</span> <a class="code" href="classChamp__Face.html#a571ff22af5c4c516d6497521acc85b78">Champ_Face::calculer_rotationnel_ordre2_centre_element</a>(<a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; rot)<span class="keyword"> const</span>
<a name="l00499"></a>00499 <span class="keyword"></span>{
<a name="l00500"></a>00500   <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; val = <a class="code" href="classChamp__Inc__base.html#adb537f43f1649e103a8980314c7ed175" title="Renvoie le tableau des valeurs du champ au temps courant.">valeurs</a>();
<a name="l00501"></a>00501   <span class="keyword">const</span> <a class="code" href="classZone__VDF.html" title="class Zone_VDF Classe instanciable qui derive de Zone_VF. Cette classe contient les informations geom...">Zone_VDF</a>&amp; zone_VDF = <a class="code" href="classChamp__Face.html#a84b6abcd128000e1d5759caaa7ae0dee">la_zone_VDF</a>.<a class="code" href="classRef__Zone__VDF.html#a84151da4db745d02791d6246e3682b67">valeur</a>();
<a name="l00502"></a>00502   <span class="keywordtype">int</span> nb_elem = zone_VDF.<a class="code" href="classZone__dis__base.html#a790cb2f6bc2928518799e748313d0eb3">nb_elem</a>();
<a name="l00503"></a>00503   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; face_voisins = zone_VDF.<a class="code" href="classZone__VF.html#a49d4322f5585a8fa95748ca785b70702" title="renvoie l&#39;element voisin de numface dans la direction i. i=0 : dans le sens oppose de l&#39;axe orthogona...">face_voisins</a>();
<a name="l00504"></a>00504   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; elem_faces = zone_VDF.<a class="code" href="classZone__VF.html#a067e462dcd3ab92b0f6d945b19e4eb37" title="renvoie le numero de le ieme face de la maille num_elem la facon dont ces faces sont numerotees est l...">elem_faces</a>();
<a name="l00505"></a>00505 
<a name="l00506"></a>00506   <span class="keywordflow">if</span> (<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a> == 2 )
<a name="l00507"></a>00507     <a class="code" href="Champ__Face2_8cpp.html#a55b486be8c7ed3ced7518eb23eb1a2a7">calrotord2centelemdim2</a>(rot, val, zone_VDF, nb_elem, face_voisins, elem_faces);
<a name="l00508"></a>00508   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a> == 3)
<a name="l00509"></a>00509     <a class="code" href="Champ__Face3_8cpp.html#ad6f2d561a2b01a55d910955d7b4964a9">calrotord2centelemdim3</a>(rot, val, zone_VDF, nb_elem, face_voisins, elem_faces);
<a name="l00510"></a>00510 }
<a name="l00511"></a>00511 
<a name="l00512"></a><a class="code" href="classChamp__Face.html#acf53603772c19f139b42df93d48c5032">00512</a> <span class="keywordtype">int</span> <a class="code" href="classChamp__Face.html#acf53603772c19f139b42df93d48c5032">Champ_Face::imprime</a>(<a class="code" href="classSortie.html" title="Classe de base des flux de sortie. Elle sait ecrire des types simples&lt;br&gt;(entiers, flottants) et des Ob...">Sortie</a>&amp; os, <span class="keywordtype">int</span> ncomp)<span class="keyword"> const</span>
<a name="l00513"></a>00513 <span class="keyword"></span>{
<a name="l00514"></a>00514   <a class="code" href="classChamp__Face__implementation.html#a3cd1b0b8e7cf82f417bd3414efcf3ec7">imprime_Face</a>(os,ncomp);
<a name="l00515"></a>00515   <span class="keywordflow">return</span> 1;
<a name="l00516"></a>00516 }
<a name="l00517"></a>00517 
<a name="l00518"></a>00518 
<a name="l00519"></a><a class="code" href="classChamp__Face.html#a30c21c0f12fe00680722fc07cc3d54be">00519</a> <span class="keywordtype">void</span> <a class="code" href="classChamp__Face.html#a30c21c0f12fe00680722fc07cc3d54be">Champ_Face::calcul_critere_Q</a>(<a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; Q, <span class="keyword">const</span> <a class="code" href="classZone__Cl__VDF.html" title="&lt; namespace TypeAreteCoinVDF">Zone_Cl_VDF</a>&amp; zone_Cl_VDF)
<a name="l00520"></a>00520 {
<a name="l00521"></a>00521 <span class="comment">// Q=0.5*(\Omega_{ij}*\Omega_{ij}-S_{ij}*S_{ij})=-0.25*du_i/dx_j*du_j/dx_i</span>
<a name="l00522"></a>00522 
<a name="l00523"></a>00523   <span class="keyword">const</span> <a class="code" href="classZone__VDF.html" title="class Zone_VDF Classe instanciable qui derive de Zone_VF. Cette classe contient les informations geom...">Zone_VDF</a>&amp; zone_VDF = <a class="code" href="classChamp__Face.html#a84b6abcd128000e1d5759caaa7ae0dee">la_zone_VDF</a>.<a class="code" href="classRef__Zone__VDF.html#a84151da4db745d02791d6246e3682b67">valeur</a>();
<a name="l00524"></a>00524   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_elem = zone_VDF.<a class="code" href="classZone__dis__base.html#a790cb2f6bc2928518799e748313d0eb3">nb_elem</a>();
<a name="l00525"></a>00525   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_elem_tot = zone_VDF.<a class="code" href="classZone__dis__base.html#a4d6aa445f152aa6dc54d66ea7a071147">nb_elem_tot</a>();
<a name="l00526"></a>00526   <span class="keywordtype">int</span> num_elem,i,j;
<a name="l00527"></a>00527   <span class="keywordtype">double</span> crit,deriv1,deriv2;
<a name="l00528"></a>00528 
<a name="l00529"></a>00529   <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a> gradient_elem(nb_elem_tot,<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>,<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>);
<a name="l00530"></a>00530   gradient_elem=0.;
<a name="l00531"></a>00531 
<a name="l00532"></a>00532   <a class="code" href="classChamp__Face.html" title="class Champ_Face Cette classe sert a representer un champ vectoriel dont on ne calcule que les compos...">Champ_Face</a>&amp; vit = *<span class="keyword">this</span>;
<a name="l00533"></a>00533   <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; vitesse = <a class="code" href="classChamp__Inc__base.html#adb537f43f1649e103a8980314c7ed175" title="Renvoie le tableau des valeurs du champ au temps courant.">valeurs</a>();
<a name="l00534"></a>00534 
<a name="l00535"></a>00535   vit.<a class="code" href="classChamp__Face.html#a97fa360dcacec544bd83d2da89a7769c">calcul_duidxj</a>(vitesse,gradient_elem,zone_Cl_VDF);
<a name="l00536"></a>00536 
<a name="l00537"></a>00537   <span class="keywordflow">for</span> (num_elem=0; num_elem&lt;nb_elem; num_elem++)
<a name="l00538"></a>00538     {
<a name="l00539"></a>00539       crit = 0.;
<a name="l00540"></a>00540       <span class="keywordflow">for</span> (i=0; i&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; i++)
<a name="l00541"></a>00541         <span class="keywordflow">for</span>(j=0; j&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; j++)
<a name="l00542"></a>00542           {
<a name="l00543"></a>00543             deriv1 = gradient_elem(num_elem,i,j);
<a name="l00544"></a>00544             deriv2 = gradient_elem(num_elem,j,i);
<a name="l00545"></a>00545 
<a name="l00546"></a>00546             crit += -0.25*deriv1*deriv2;
<a name="l00547"></a>00547           }
<a name="l00548"></a>00548       Q[num_elem] = crit;
<a name="l00549"></a>00549     }
<a name="l00550"></a>00550 
<a name="l00551"></a>00551 }
<a name="l00552"></a>00552 
<a name="l00553"></a>00553 
<a name="l00554"></a>00554 
<a name="l00555"></a><a class="code" href="classChamp__Face.html#a7c36a9d06fd62b53ce2fe1d778f33128">00555</a> <span class="keywordtype">void</span> <a class="code" href="classChamp__Face.html#a7c36a9d06fd62b53ce2fe1d778f33128">Champ_Face::calcul_y_plus</a>(<a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; y_plus, <span class="keyword">const</span> <a class="code" href="classZone__Cl__VDF.html" title="&lt; namespace TypeAreteCoinVDF">Zone_Cl_VDF</a>&amp; zone_Cl_VDF)
<a name="l00556"></a>00556 {
<a name="l00557"></a>00557 <span class="comment">// On initialise le champ y_plus avec une valeur negative,</span>
<a name="l00558"></a>00558 <span class="comment">// comme ca lorsqu&#39;on veut visualiser le champ pres de la paroi,</span>
<a name="l00559"></a>00559 <span class="comment">// on n&#39;a qu&#39;a supprimer les valeurs negatives et n&#39;apparaissent</span>
<a name="l00560"></a>00560 <span class="comment">// que les valeurs aux parois.</span>
<a name="l00561"></a>00561 
<a name="l00562"></a>00562   <span class="keywordtype">int</span> ndeb,nfin,elem,ori,l_unif;
<a name="l00563"></a>00563   <span class="keywordtype">double</span> norm_tau,u_etoile,norm_v=0, dist, val0, val1, val2, d_visco=0, visco=1.;
<a name="l00564"></a>00564   y_plus=-1.;
<a name="l00565"></a>00565 
<a name="l00566"></a>00566   <span class="keyword">const</span> <a class="code" href="classChamp__Face.html" title="class Champ_Face Cette classe sert a representer un champ vectoriel dont on ne calcule que les compos...">Champ_Face</a>&amp; vit = *<span class="keyword">this</span>;
<a name="l00567"></a>00567   <span class="keyword">const</span> <a class="code" href="classZone__VDF.html" title="class Zone_VDF Classe instanciable qui derive de Zone_VF. Cette classe contient les informations geom...">Zone_VDF</a>&amp; zone_VDF = <a class="code" href="classChamp__Face.html#a84b6abcd128000e1d5759caaa7ae0dee">la_zone_VDF</a>.<a class="code" href="classRef__Zone__VDF.html#a84151da4db745d02791d6246e3682b67">valeur</a>();
<a name="l00568"></a>00568   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; face_voisins = zone_VDF.<a class="code" href="classZone__VF.html#a49d4322f5585a8fa95748ca785b70702" title="renvoie l&#39;element voisin de numface dans la direction i. i=0 : dans le sens oppose de l&#39;axe orthogona...">face_voisins</a>();
<a name="l00569"></a>00569   <span class="keyword">const</span> <a class="code" href="classIntVect.html">IntVect</a>&amp; orientation = zone_VDF.<a class="code" href="classZone__VDF.html#a9a9bd747218e463b3408a3590c12814c" title="inline DoubleVect&amp; Zone_VDF::porosite_face() { return porosite_face_; }">orientation</a>();
<a name="l00570"></a>00570   <span class="keyword">const</span> <a class="code" href="classEquation__base.html">Equation_base</a>&amp; eqn_hydr = <a class="code" href="classMorEqn.html#a615dd9abff96edcb625fa0424a489864" title="Renvoie la reference sur l&#39;equation pointe par MorEqn::mon_equation. (version const)">equation</a>();
<a name="l00571"></a>00571   <span class="keyword">const</span> <a class="code" href="classFluide__base.html" title="classe Fluide_base Cette classe represente un d&#39;un fluide incompressible ainsi que ses proprietes: - ...">Fluide_base</a>&amp; le_fluide = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFluide__base.html" title="classe Fluide_base Cette classe represente un d&#39;un fluide incompressible ainsi que ses proprietes: - ...">Fluide_base</a>, eqn_hydr.<a class="code" href="classEquation__base.html#a181e9899e2d927eb14c835d9d9334f46">milieu</a>());
<a name="l00572"></a>00572   <span class="keyword">const</span> <a class="code" href="classChamp__Don.html" title="classe Champ_Don Classe generique de la hierarchie des champs donnes, un objet Champ_Don peut referen...">Champ_Don</a>&amp; ch_visco_cin = le_fluide.<a class="code" href="classFluide__base.html#a37eb07407d8aa121049355ecc4f8c8dd" title="Renvoie la viscosite cinematique, nu. (vesrion const)">viscosite_cinematique</a>();
<a name="l00573"></a>00573   <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; tab_visco = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>,ch_visco_cin-&gt;valeurs());
<a name="l00574"></a>00574 <span class="comment">// DoubleTab&amp; tab_visco = ch_visco_cin.valeur().valeurs();</span>
<a name="l00575"></a>00575 
<a name="l00576"></a>00576   <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classChamp__Uniforme.html" title="classe Champ_Uniforme Represente un champ constant dans l&#39;espace et dans le temps.">Champ_Uniforme</a>, ch_visco_cin.valeur()))
<a name="l00577"></a>00577     {
<a name="l00578"></a>00578       visco = tab_visco(0,0);
<a name="l00579"></a>00579       l_unif = 1;
<a name="l00580"></a>00580     }
<a name="l00581"></a>00581   <span class="keywordflow">else</span>
<a name="l00582"></a>00582     l_unif = 0;
<a name="l00583"></a>00583 
<a name="l00584"></a>00584   <span class="comment">/* GF on a pas a change tab_visco ici !</span>
<a name="l00585"></a>00585 <span class="comment">  if (!l_unif)</span>
<a name="l00586"></a>00586 <span class="comment">    {</span>
<a name="l00587"></a>00587 <span class="comment">      const int n = tab_visco.size_array();</span>
<a name="l00588"></a>00588 <span class="comment">      ArrOfDouble&amp; v = tab_visco;</span>
<a name="l00589"></a>00589 <span class="comment">      for (int i = 0; i &lt; n; i++)</span>
<a name="l00590"></a>00590 <span class="comment">        if (v[i] &lt; DMINFLOAT)</span>
<a name="l00591"></a>00591 <span class="comment">          v[i] = DMINFLOAT;</span>
<a name="l00592"></a>00592 <span class="comment">    }</span>
<a name="l00593"></a>00593 <span class="comment">// Changer uniquement les valeurs &lt; DMINFLOAT (l&#39;ancien code n&#39;est pas parallele)</span>
<a name="l00594"></a>00594 <span class="comment">  */</span>
<a name="l00595"></a>00595 
<a name="l00596"></a>00596   <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a> yplus_faces( 1, 1 ); <span class="comment">//!&lt; will contain yplus values if available</span>
<a name="l00597"></a>00597 <span class="comment"></span>  <span class="keywordtype">int</span> yplus_already_computed=0; <span class="comment">//!&lt; flag</span>
<a name="l00598"></a>00598 <span class="comment"></span>
<a name="l00599"></a>00599   <span class="keyword">const</span> <a class="code" href="classRef__Objet__U.html">RefObjU</a>&amp; modele_turbulence = eqn_hydr.<a class="code" href="classEquation__base.html#ab0bb5d06bdc91e131dc9d5f9d7b57095">get_modele</a>(<a class="code" href="Equation__base_8h.html#a2c9d34b2cc47e5b2b18347de20a77db5a0fecbd75e0b8b4c37ffd696e173a14c7">TURBULENCE</a>);
<a name="l00600"></a>00600   <span class="keywordflow">if</span> (modele_turbulence.<a class="code" href="classO__U__Ptr.html#a16f216b2d169e885876419182658ddcc" title="Renvoie 1 si le pointeur est non_nul Renvoie 0 sinon.">non_nul</a>() &amp;&amp; <a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classMod__turb__hyd__base.html" title="Classe Mod_turb_hyd_base Cette classe sert de base a la hierarchie des classes qui representent un mo...">Mod_turb_hyd_base</a>,modele_turbulence.<a class="code" href="classRef__Objet__U.html#ad875112c0fd275aa0c0aa710481ab11e">valeur</a>()))
<a name="l00601"></a>00601     {
<a name="l00602"></a>00602       <span class="keyword">const</span> <a class="code" href="classMod__turb__hyd__base.html" title="Classe Mod_turb_hyd_base Cette classe sert de base a la hierarchie des classes qui representent un mo...">Mod_turb_hyd_base</a>&amp; mod_turb = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMod__turb__hyd__base.html" title="Classe Mod_turb_hyd_base Cette classe sert de base a la hierarchie des classes qui representent un mo...">Mod_turb_hyd_base</a>,modele_turbulence.<a class="code" href="classRef__Objet__U.html#ad875112c0fd275aa0c0aa710481ab11e">valeur</a>());
<a name="l00603"></a>00603       <span class="keyword">const</span> <a class="code" href="classTurbulence__paroi__base.html" title="Classe Turbulence_paroi_base Classe de base pour la hierarchie des classes representant les modeles d...">Turbulence_paroi_base</a>&amp; loipar = mod_turb.<a class="code" href="classMod__turb__hyd__base.html#ac9de8c2c64dcf77d28790e021c07c61e">loi_paroi</a>();
<a name="l00604"></a>00604       <span class="keywordflow">if</span>( loipar.use_shear( ) )
<a name="l00605"></a>00605         {
<a name="l00606"></a>00606           yplus_faces.<a class="code" href="classDoubleTab.html#ae83b4d31205c53d9c8d2b43da178ce75" title="Change la taille du vecteur (identique a resize_array() pour le traitement des anciennes valeurs et d...">resize</a>( <a class="code" href="classChamp__Face.html#a84b6abcd128000e1d5759caaa7ae0dee">la_zone_VDF</a>-&gt;nb_faces_tot( ) );
<a name="l00607"></a>00607           yplus_faces.<a class="code" href="classDoubleTab.html#afc7cddeeec2c80636e54eaf330ac41ad" title="fait pointer le tableau sur le vecteur v et en associant la meme structure parallele. Attention, si line_size du vecteur v est different de 1, on cree un tableau bidimensionnel (on peut avoir un vecteur de ce type si on copie un Tab dans un Vect puis on prend une ref sur ce Vect).">ref</a>( loipar.tab_d_plus( ) );
<a name="l00608"></a>00608           yplus_already_computed = 1;
<a name="l00609"></a>00609         }
<a name="l00610"></a>00610     }
<a name="l00611"></a>00611 
<a name="l00612"></a>00612   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> n_bord=0; n_bord&lt;zone_VDF.<a class="code" href="classZone__dis__base.html#af22167d614644f55591a29c77eb1c009">nb_front_Cl</a>(); n_bord++)
<a name="l00613"></a>00613     {
<a name="l00614"></a>00614       <span class="keyword">const</span> <a class="code" href="classCond__lim.html" title="classe Cond_lim Classe generique servant a representer n&#39;importe quelle classe derivee de la classe C...">Cond_lim</a>&amp; la_cl = zone_Cl_VDF.<a class="code" href="classZone__Cl__dis__base.html#af75e0ed7786863e4d333bfb29d67c323" title="Renvoie la i-ieme condition aux limites. (version const)">les_conditions_limites</a>(n_bord);
<a name="l00615"></a>00615 
<a name="l00616"></a>00616       <span class="keywordflow">if</span> ( <a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classDirichlet__paroi__fixe.html" title="classe Dirichlet_paroi_fixe Represente une paroi immobile dans une equation de type Navier_Stokes...">Dirichlet_paroi_fixe</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>()))
<a name="l00617"></a>00617         {
<a name="l00618"></a>00618           <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp; le_bord = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>,la_cl.<a class="code" href="classCond__lim.html#a5b2d24809cee07727006a891d4ce8d22" title="Appel a l&#39;objet sous-jacent Renvoie la frontiere discretisee associee a la condition aux limites...">frontiere_dis</a>());
<a name="l00619"></a>00619           ndeb = le_bord.<a class="code" href="classFront__VF.html#a4986f0c65653fe9eb40bbbff5a97bf16" title="Numero de la premiere face du bord dans la liste des faces.">num_premiere_face</a>();
<a name="l00620"></a>00620           nfin = ndeb + le_bord.<a class="code" href="classFront__VF.html#a341e2fcb5117b96e745fd7078ba86bab" title="Nombre de faces reelles du bord.">nb_faces</a>();
<a name="l00621"></a>00621 
<a name="l00622"></a>00622 
<a name="l00623"></a>00623           <span class="keywordflow">for</span> (<span class="keywordtype">int</span> num_face=ndeb; num_face&lt;nfin; num_face++)
<a name="l00624"></a>00624             {
<a name="l00625"></a>00625 
<a name="l00626"></a>00626               <span class="keywordflow">if</span>( face_voisins( num_face, 0 ) != -1 )
<a name="l00627"></a>00627                 elem = face_voisins( num_face, 0 ) ;
<a name="l00628"></a>00628               <span class="keywordflow">else</span>
<a name="l00629"></a>00629                 elem = face_voisins( num_face, 1 ) ;
<a name="l00630"></a>00630 
<a name="l00631"></a>00631               <span class="keywordflow">if</span>( yplus_already_computed )
<a name="l00632"></a>00632                 {
<a name="l00633"></a>00633 <span class="comment">// y+ is only defined on faces so we take the face value to put in the element</span>
<a name="l00634"></a>00634                   y_plus( elem ) = yplus_faces( num_face );
<a name="l00635"></a>00635                 }
<a name="l00636"></a>00636               <span class="keywordflow">else</span>
<a name="l00637"></a>00637                 {
<a name="l00638"></a>00638 
<a name="l00639"></a>00639                   <span class="keywordflow">if</span> ( <a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a> == 2 )
<a name="l00640"></a>00640                     {
<a name="l00641"></a>00641                       ori = orientation(num_face);
<a name="l00642"></a>00642                       norm_v=<a class="code" href="distances__VDF_8cpp.html#af3a381c8e91b87fe5405eefe7df5c5e3">norm_2D_vit</a>(vit,elem,ori,zone_VDF,val0);
<a name="l00643"></a>00643                     }
<a name="l00644"></a>00644                   <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( <a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a> == 3)
<a name="l00645"></a>00645                     {
<a name="l00646"></a>00646                       ori = orientation(num_face);
<a name="l00647"></a>00647                       norm_v=<a class="code" href="distances__VDF_8cpp.html#a15f59f570345b3bba6c96f78698709df">norm_3D_vit</a>(vit,elem,ori,zone_VDF,val1,val2);
<a name="l00648"></a>00648                     } <span class="comment">//!&lt; dim 3</span>
<a name="l00649"></a>00649 <span class="comment"></span>
<a name="l00650"></a>00650                   <span class="keywordflow">if</span> ( <a class="code" href="classObjet__U.html#ad9b82ace9d4c7902ec704b6a78f76991">axi</a> )
<a name="l00651"></a>00651                     dist=zone_VDF.<a class="code" href="classZone__VDF.html#ad0dad29b88fed624a33187ba9aad15c2">dist_norm_bord_axi</a>(num_face);
<a name="l00652"></a>00652                   <span class="keywordflow">else</span>
<a name="l00653"></a>00653                     dist=zone_VDF.<a class="code" href="classZone__VDF.html#a369e50f57ce994a9afe43ff2e3ff813b">dist_norm_bord</a>(num_face);
<a name="l00654"></a>00654                   <span class="keywordflow">if</span> ( l_unif )
<a name="l00655"></a>00655                     d_visco = visco;
<a name="l00656"></a>00656                   <span class="keywordflow">else</span>
<a name="l00657"></a>00657                     d_visco = tab_visco[elem];
<a name="l00658"></a>00658 
<a name="l00659"></a>00659 <span class="comment">// PQ : 01/10/03 : corrections par rapport a la version premiere</span>
<a name="l00660"></a>00660                   norm_tau = d_visco*norm_v/dist;
<a name="l00661"></a>00661 
<a name="l00662"></a>00662                   u_etoile = sqrt(norm_tau);
<a name="l00663"></a>00663                   y_plus(elem) = dist*u_etoile/d_visco;
<a name="l00664"></a>00664 
<a name="l00665"></a>00665                 } <span class="comment">//!&lt; else yplus already computed</span>
<a name="l00666"></a>00666 <span class="comment"></span>
<a name="l00667"></a>00667             } <span class="comment">//!&lt; loop on faces</span>
<a name="l00668"></a>00668 <span class="comment"></span>
<a name="l00669"></a>00669         } <span class="comment">//!&lt; Fin paroi fixe</span>
<a name="l00670"></a>00670 <span class="comment"></span>
<a name="l00671"></a>00671     } <span class="comment">//!&lt; Fin boucle sur les bords</span>
<a name="l00672"></a>00672 <span class="comment"></span>}
<a name="l00673"></a>00673 
<a name="l00674"></a>00674 <span class="comment">//</span>
<a name="l00675"></a>00675 <span class="comment">// Methode qui renvoie gij aux elements a partir de la vitesse aux faces</span>
<a name="l00676"></a>00676 <span class="comment">// (gij represente la derivee partielle dui/dxj)</span>
<a name="l00677"></a>00677 <span class="comment">// </span>
<a name="l00678"></a>00678 <span class="comment">// A partir de gij, on peut calculer Sij = 0.5(gij(i,j)+gij(j,i))</span>
<a name="l00679"></a>00679 <span class="comment">// </span>
<a name="l00680"></a>00680 <span class="comment">//</span>
<a name="l00681"></a>00681 
<a name="l00682"></a><a class="code" href="classChamp__Face.html#aa9df636d19ddaaefc669ba3a26a0e561">00682</a> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; <a class="code" href="classChamp__Face.html#a97fa360dcacec544bd83d2da89a7769c">Champ_Face::calcul_duidxj</a>(<span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; vitesse, <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; gij, <span class="keyword">const</span> <a class="code" href="classZone__Cl__VDF.html" title="&lt; namespace TypeAreteCoinVDF">Zone_Cl_VDF</a>&amp; zone_Cl_VDF)<span class="keyword"> const</span>
<a name="l00683"></a>00683 <span class="keyword"></span>{
<a name="l00684"></a>00684 
<a name="l00685"></a>00685   <span class="keyword">const</span> <a class="code" href="classChamp__Face.html" title="class Champ_Face Cette classe sert a representer un champ vectoriel dont on ne calcule que les compos...">Champ_Face</a>&amp; vit = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classChamp__Face.html" title="class Champ_Face Cette classe sert a representer un champ vectoriel dont on ne calcule que les compos...">Champ_Face</a>, <a class="code" href="classMorEqn.html#a47b12fa29b57783a8a5897f7611e2176">mon_equation</a>-&gt;inconnue().<a class="code" href="classRef__Equation__base.html#a7bb6fb60cb55bef0eef1b0e8718300a4">valeur</a>());
<a name="l00686"></a>00686   <span class="keyword">const</span> <a class="code" href="classZone__VDF.html" title="class Zone_VDF Classe instanciable qui derive de Zone_VF. Cette classe contient les informations geom...">Zone_VDF</a>&amp; zone_VDF = <a class="code" href="classChamp__Face.html#a84b6abcd128000e1d5759caaa7ae0dee">la_zone_VDF</a>.<a class="code" href="classRef__Zone__VDF.html#a84151da4db745d02791d6246e3682b67">valeur</a>();
<a name="l00687"></a>00687   <span class="keywordtype">int</span> nb_elem = zone_VDF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#aa3a33e8b723618b9092460007153e42d" title="Renvoie le nombre total d&#39;elements de la zone.">nb_elem_tot</a>();
<a name="l00688"></a>00688   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; face_voisins = zone_VDF.face_voisins();
<a name="l00689"></a>00689   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; elem_faces = zone_VDF.elem_faces();
<a name="l00690"></a>00690   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; Qdm = zone_VDF.Qdm();
<a name="l00691"></a>00691   <span class="keyword">const</span> <a class="code" href="classIntVect.html">IntVect</a>&amp; orientation = zone_VDF.orientation();
<a name="l00692"></a>00692 
<a name="l00693"></a>00693   <span class="keywordtype">int</span> premiere_arete_mixte = zone_VDF.premiere_arete_mixte();
<a name="l00694"></a>00694   <span class="keywordtype">int</span> premiere_arete_interne =  zone_VDF.premiere_arete_interne();
<a name="l00695"></a>00695   <span class="keywordtype">int</span> derniere_arete_mixte = premiere_arete_mixte+zone_VDF.nb_aretes_mixtes();
<a name="l00696"></a>00696   <span class="keywordtype">int</span> derniere_arete_interne = premiere_arete_interne+zone_VDF.nb_aretes_internes();
<a name="l00697"></a>00697   <span class="keywordtype">int</span> elem;
<a name="l00698"></a>00698   <span class="keywordtype">int</span> num_arete;
<a name="l00699"></a>00699   <a class="code" href="classIntVect.html">IntVect</a> element(4);
<a name="l00700"></a>00700 
<a name="l00701"></a>00701   <span class="keywordtype">int</span> num0,num1,num2,num3,signe;
<a name="l00702"></a>00702   <span class="keywordtype">int</span> ndeb = zone_VDF.premiere_arete_bord();
<a name="l00703"></a>00703   <span class="keywordtype">int</span> nfin = ndeb + zone_VDF.nb_aretes_bord();
<a name="l00704"></a>00704   <span class="keywordtype">int</span> n_type;
<a name="l00705"></a>00705 
<a name="l00706"></a>00706   gij = 0.;
<a name="l00707"></a>00707 
<a name="l00708"></a>00708 
<a name="l00709"></a>00709 <span class="comment">//</span>
<a name="l00710"></a>00710 <span class="comment">// On parcourt toutes les aretes qui permettent</span>
<a name="l00711"></a>00711 <span class="comment">// de calculer les termes croises dui/dxj.</span>
<a name="l00712"></a>00712 <span class="comment">// </span>
<a name="l00713"></a>00713 <span class="comment">// (les termes non-croises sont calcules</span>
<a name="l00714"></a>00714 <span class="comment">// en bouclant sur les elements)</span>
<a name="l00715"></a>00715 <span class="comment">//</span>
<a name="l00716"></a>00716 
<a name="l00717"></a>00717   <span class="keywordflow">for</span> (num_arete=ndeb; num_arete&lt;nfin; num_arete++)
<a name="l00718"></a>00718     {
<a name="l00719"></a>00719       n_type=zone_Cl_VDF.<a class="code" href="classZone__Cl__VDF.html#ae99f1fd7eda112296855c945b44aa85c">type_arete_bord</a>(num_arete-ndeb);
<a name="l00720"></a>00720 
<a name="l00721"></a>00721       <span class="keywordflow">if</span> (n_type == 4) <span class="comment">//!&lt; arete de type periodicite</span>
<a name="l00722"></a>00722 <span class="comment"></span>        {
<a name="l00723"></a>00723           num0 = Qdm(num_arete,0);
<a name="l00724"></a>00724           num1 = Qdm(num_arete,1);
<a name="l00725"></a>00725           num2 = Qdm(num_arete,2);
<a name="l00726"></a>00726           num3 = Qdm(num_arete,3);
<a name="l00727"></a>00727           <span class="keywordtype">int</span> i=0;
<a name="l00728"></a>00728           <span class="keywordtype">int</span> j=0;
<a name="l00729"></a>00729           i=orientation(num0);
<a name="l00730"></a>00730           j=orientation(num2);
<a name="l00731"></a>00731 
<a name="l00732"></a>00732           <span class="keywordtype">double</span> temp1 = (vitesse[num1]-vitesse[num0])
<a name="l00733"></a>00733                          /zone_VDF.dist_face_period(num0,num1,j);            <span class="comment">//!&lt; dui/dxj</span>
<a name="l00734"></a>00734 <span class="comment"></span>          <span class="keywordtype">double</span> temp2 = (vitesse[num3]-vitesse[num2])
<a name="l00735"></a>00735                          /zone_VDF.dist_face_period(num2,num3,i);            <span class="comment">//!&lt; duj/dxi</span>
<a name="l00736"></a>00736 <span class="comment"></span>          element(0) = face_voisins(num0,0);
<a name="l00737"></a>00737           element(1) = face_voisins(num0,1);
<a name="l00738"></a>00738           element(2) = face_voisins(num1,0);
<a name="l00739"></a>00739           element(3) = face_voisins(num1,1);
<a name="l00740"></a>00740           <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k=0 ; k&lt;4 ; k++)
<a name="l00741"></a>00741             {
<a name="l00742"></a>00742               gij(element(k),i,j)+=temp1*0.5*0.25;
<a name="l00743"></a>00743               gij(element(k),j,i)+=temp2*0.5*0.25;
<a name="l00744"></a>00744 
<a name="l00745"></a>00745 <span class="comment">// Justification des coeff derriere :</span>
<a name="l00746"></a>00746 <span class="comment">// 1) 0.5 : pour la periodicite,</span>
<a name="l00747"></a>00747 <span class="comment">// car on distribuera deux fois sur</span>
<a name="l00748"></a>00748 <span class="comment">// les elements qui &quot;touchent&quot; cette arete</span>
<a name="l00749"></a>00749 <span class="comment">// puisqu&#39;elle existe en double.</span>
<a name="l00750"></a>00750 <span class="comment">// 2) 0.25 : on distribue le gradient de vitesse</span>
<a name="l00751"></a>00751 <span class="comment">// sur les 4 elements qui l&#39;entourent.</span>
<a name="l00752"></a>00752             }        <span class="comment">//!&lt; fin du for k</span>
<a name="l00753"></a>00753 <span class="comment"></span>        }
<a name="l00754"></a>00754       <span class="keywordflow">else</span>
<a name="l00755"></a>00755         {
<a name="l00756"></a>00756           num0 = Qdm(num_arete,0);
<a name="l00757"></a>00757           num1 = Qdm(num_arete,1);
<a name="l00758"></a>00758           num2 = Qdm(num_arete,2);
<a name="l00759"></a>00759           signe = Qdm(num_arete,3);
<a name="l00760"></a>00760           <span class="keywordtype">int</span> j=0;
<a name="l00761"></a>00761           j=orientation(num2);
<a name="l00762"></a>00762 
<a name="l00763"></a>00763           <span class="keywordtype">double</span> temp2;
<a name="l00764"></a>00764           <span class="keywordtype">double</span> temp1 = (vitesse[num1]-vitesse[num0])
<a name="l00765"></a>00765                          /zone_VDF.dist_face_period(num0,num1,j);        <span class="comment">//!&lt; dui/dxj</span>
<a name="l00766"></a>00766 <span class="comment"></span>          <span class="keywordtype">double</span> vit_imp = 0.5*(vit.<a class="code" href="classChamp__Face.html#a613ea150dbc6a9b5f288011f90484381">val_imp_face_bord_private</a>(num0,j)+
<a name="l00767"></a>00767                                 vit.<a class="code" href="classChamp__Face.html#a613ea150dbc6a9b5f288011f90484381">val_imp_face_bord_private</a>(num1,j));                <span class="comment">//!&lt; vitesse tangentielle Dans cette partie, on conserve le codage de Hyd_SGE_Wale_VDF (num1 et non num2) pour calculer la distance entre le centre de la maille et le bord.</span>
<a name="l00768"></a>00768 <span class="comment"></span><span class="comment">//</span>
<a name="l00769"></a>00769 <span class="comment">//</span>
<a name="l00770"></a>00770 
<a name="l00771"></a>00771           temp2 = -signe*(vitesse[num2]-vit_imp)/zone_VDF.dist_norm_bord(num1);
<a name="l00772"></a>00772 
<a name="l00773"></a>00773           element(0) = face_voisins(num2,0);
<a name="l00774"></a>00774           element(1) = face_voisins(num2,1);
<a name="l00775"></a>00775 
<a name="l00776"></a>00776           <span class="keywordtype">int</span> i=orientation(num0);
<a name="l00777"></a>00777 
<a name="l00778"></a>00778           <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k=0 ; k&lt;2 ; k++)
<a name="l00779"></a>00779             {
<a name="l00780"></a>00780               gij(element(k),i,j)+=temp1*0.25;
<a name="l00781"></a>00781               gij(element(k),j,i)+=temp2*0.25;
<a name="l00782"></a>00782 
<a name="l00783"></a>00783 <span class="comment">// Justification des coeff derriere :</span>
<a name="l00784"></a>00784 <span class="comment">// 1) 0.25 : on distribue le gradient de vitesse</span>
<a name="l00785"></a>00785 <span class="comment">// sur les 4 elements qui l&#39;entourent.</span>
<a name="l00786"></a>00786             } <span class="comment">//!&lt; fin du for k</span>
<a name="l00787"></a>00787 <span class="comment"></span>        }
<a name="l00788"></a>00788     }
<a name="l00789"></a>00789 
<a name="l00790"></a>00790 
<a name="l00791"></a>00791   <span class="comment">//*******************************</span>
<a name="l00792"></a>00792   <span class="comment">//On parcourt les aretes coins</span>
<a name="l00793"></a>00793   <span class="comment">//*******************************</span>
<a name="l00794"></a>00794 
<a name="l00795"></a>00795   ndeb = zone_VDF.premiere_arete_coin();
<a name="l00796"></a>00796   nfin = ndeb + zone_VDF.nb_aretes_coin();
<a name="l00797"></a>00797 
<a name="l00798"></a>00798   <span class="keywordflow">for</span> (num_arete=ndeb; num_arete&lt;nfin; num_arete++)
<a name="l00799"></a>00799     {
<a name="l00800"></a>00800       n_type=zone_Cl_VDF.<a class="code" href="classZone__Cl__VDF.html#ae0bee7198d75e43dbc46a5b4e181b736">type_arete_coin</a>(num_arete-ndeb);
<a name="l00801"></a>00801       <span class="comment">//***************************************</span>
<a name="l00802"></a>00802       <span class="comment">// Traitement des aretes coin perio-perio</span>
<a name="l00803"></a>00803       <span class="comment">//***************************************</span>
<a name="l00804"></a>00804 
<a name="l00805"></a>00805       <span class="keywordflow">if</span> (n_type == 0) <span class="comment">// arete de type periodicite-periodicite</span>
<a name="l00806"></a>00806         {
<a name="l00807"></a>00807           num0 = Qdm(num_arete,0);
<a name="l00808"></a>00808           num1 = Qdm(num_arete,1);
<a name="l00809"></a>00809           num2 = Qdm(num_arete,2);
<a name="l00810"></a>00810           num3 = Qdm(num_arete,3);
<a name="l00811"></a>00811           <span class="keywordtype">int</span> i=0;
<a name="l00812"></a>00812           <span class="keywordtype">int</span> j=0;
<a name="l00813"></a>00813           i=orientation(num0);
<a name="l00814"></a>00814           j=orientation(num2);
<a name="l00815"></a>00815 
<a name="l00816"></a>00816           <span class="keywordtype">double</span> temp1 = (vitesse[num1]-vitesse[num0])
<a name="l00817"></a>00817                          /zone_VDF.dist_face_period(num0,num1,j);        <span class="comment">// dui/dxj</span>
<a name="l00818"></a>00818           <span class="keywordtype">double</span> temp2 = (vitesse[num3]-vitesse[num2])
<a name="l00819"></a>00819                          /zone_VDF.dist_face_period(num2,num3,i);        <span class="comment">// duj/dxi</span>
<a name="l00820"></a>00820           element(0) = face_voisins(num0,0);
<a name="l00821"></a>00821           element(1) = face_voisins(num0,1);
<a name="l00822"></a>00822           element(2) = face_voisins(num1,0);
<a name="l00823"></a>00823           element(3) = face_voisins(num1,1);
<a name="l00824"></a>00824           <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k=0 ; k&lt;4 ; k++)
<a name="l00825"></a>00825             {
<a name="l00826"></a>00826               gij(element(k),i,j)+=temp1*0.5*0.5*0.25;
<a name="l00827"></a>00827               gij(element(k),j,i)+=temp2*0.5*0.5*0.25;
<a name="l00828"></a>00828 
<a name="l00829"></a>00829               <span class="comment">// Justification des coeff derriere :</span>
<a name="l00830"></a>00830               <span class="comment">// 1) 0.5 : pour la periodicite,</span>
<a name="l00831"></a>00831               <span class="comment">//           car on distribuera deux fois sur</span>
<a name="l00832"></a>00832               <span class="comment">//           les elements qui &quot;touchent&quot; cette arete</span>
<a name="l00833"></a>00833               <span class="comment">//           puisqu&#39;elle existe en double.</span>
<a name="l00834"></a>00834               <span class="comment">// 2) 0.5 : idem ci-dessus, car cette fois-ci on a</span>
<a name="l00835"></a>00835               <span class="comment">//           un coin perio-perio.</span>
<a name="l00836"></a>00836               <span class="comment">// 3) 0.25 : on distribue le gradient de vitesse</span>
<a name="l00837"></a>00837               <span class="comment">//            sur les 4 elements qui l&#39;entourent.</span>
<a name="l00838"></a>00838             } <span class="comment">// fin du for k</span>
<a name="l00839"></a>00839 
<a name="l00840"></a>00840         }
<a name="l00841"></a>00841 
<a name="l00842"></a>00842       <span class="comment">//***************************************</span>
<a name="l00843"></a>00843       <span class="comment">// Traitement des aretes coin perio-paroi</span>
<a name="l00844"></a>00844       <span class="comment">//***************************************</span>
<a name="l00845"></a>00845       <span class="keywordflow">if</span> (n_type == 1) <span class="comment">// arete de type periodicite-paroi</span>
<a name="l00846"></a>00846         {
<a name="l00847"></a>00847           num0 = Qdm(num_arete,0);
<a name="l00848"></a>00848           num1 = Qdm(num_arete,1);
<a name="l00849"></a>00849           num2 = Qdm(num_arete,2);
<a name="l00850"></a>00850           signe = Qdm(num_arete,3);
<a name="l00851"></a>00851           <span class="keywordtype">int</span> j=0;
<a name="l00852"></a>00852           j=orientation(num2);
<a name="l00853"></a>00853 
<a name="l00854"></a>00854           <span class="keywordtype">double</span> temp2;
<a name="l00855"></a>00855           <span class="keywordtype">double</span> temp1 = (vitesse[num1]-vitesse[num0])
<a name="l00856"></a>00856                          /zone_VDF.dist_face_period(num0,num1,j);                <span class="comment">// dui/dxj</span>
<a name="l00857"></a>00857           <span class="keywordtype">double</span> vit_imp = 0.5*(vit.<a class="code" href="classChamp__Face.html#a613ea150dbc6a9b5f288011f90484381">val_imp_face_bord_private</a>(num0,j)+
<a name="l00858"></a>00858                                 vit.<a class="code" href="classChamp__Face.html#a613ea150dbc6a9b5f288011f90484381">val_imp_face_bord_private</a>(num1,j));        <span class="comment">// vitesse tangentielle</span>
<a name="l00859"></a>00859 
<a name="l00860"></a>00860           temp2  = -signe*(vitesse[num2]-vit_imp)/zone_VDF.dist_norm_bord(num1);
<a name="l00861"></a>00861 
<a name="l00862"></a>00862           element(0) = face_voisins(num2,0);
<a name="l00863"></a>00863           element(1) = face_voisins(num2,1);
<a name="l00864"></a>00864 
<a name="l00865"></a>00865           <span class="keywordtype">int</span> i=orientation(num1);
<a name="l00866"></a>00866 
<a name="l00867"></a>00867           <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k=0 ; k&lt;2 ; k++)
<a name="l00868"></a>00868             {
<a name="l00869"></a>00869               gij(element(k),i,j)+=temp1*0.5*0.25;
<a name="l00870"></a>00870               gij(element(k),j,i)+=temp2*0.5*0.25;
<a name="l00871"></a>00871 
<a name="l00872"></a>00872               <span class="comment">// Justification des coeff derriere :</span>
<a name="l00873"></a>00873               <span class="comment">// 1) 0.5 : pour la periodicite,</span>
<a name="l00874"></a>00874               <span class="comment">//           car on distribuera deux fois sur</span>
<a name="l00875"></a>00875               <span class="comment">//           les elements qui &quot;touchent&quot; cette arete</span>
<a name="l00876"></a>00876               <span class="comment">//           puisqu&#39;elle existe en double.</span>
<a name="l00877"></a>00877               <span class="comment">// 2) 0.25 : on distribue le gradient de vitesse</span>
<a name="l00878"></a>00878               <span class="comment">//            sur les 4 elements qui l&#39;entourent.</span>
<a name="l00879"></a>00879             } <span class="comment">// fin du for k</span>
<a name="l00880"></a>00880         }
<a name="l00881"></a>00881     }
<a name="l00882"></a>00882 
<a name="l00883"></a>00883 
<a name="l00884"></a>00884   <span class="comment">// 1ere partie:boucles sur les aretes et remplissage de Sij pour la partie</span>
<a name="l00885"></a>00885   <span class="comment">// derivees croisees (dui/dxj)</span>
<a name="l00886"></a>00886   <span class="comment">// vitesse[face] renvoie la vitesse NORMALE a la face</span>
<a name="l00887"></a>00887   <span class="comment">//   for (num_arete = premiere_arete_bord ; num_arete&lt;derniere_arete_bord ; num_arete ++)</span>
<a name="l00888"></a>00888   <span class="comment">//     {</span>
<a name="l00889"></a>00889   <span class="comment">//       const IntVect&amp; type_arete_bord = zone_Cl_VDF.type_arete_bord();</span>
<a name="l00890"></a>00890 
<a name="l00891"></a>00891 
<a name="l00892"></a>00892   <span class="keywordflow">for</span>(num_arete=premiere_arete_mixte ; num_arete&lt;derniere_arete_mixte ; num_arete ++)
<a name="l00893"></a>00893     {
<a name="l00894"></a>00894       num0 = Qdm(num_arete,0);
<a name="l00895"></a>00895       num1 = Qdm(num_arete,1);
<a name="l00896"></a>00896       num2 = Qdm(num_arete,2);
<a name="l00897"></a>00897       num3 = Qdm(num_arete,3);
<a name="l00898"></a>00898       <span class="keywordtype">int</span> i=0;
<a name="l00899"></a>00899       <span class="keywordtype">int</span> j=0;
<a name="l00900"></a>00900       i=orientation(num0);
<a name="l00901"></a>00901       j=orientation(num2);
<a name="l00902"></a>00902 
<a name="l00903"></a>00903       <span class="keywordtype">double</span> temp1 = (vitesse[num1]-vitesse[num0])
<a name="l00904"></a>00904                      /zone_VDF.dist_face_period(num0,num1,j);        <span class="comment">// dui/dxj</span>
<a name="l00905"></a>00905       <span class="keywordtype">double</span> temp2 = (vitesse[num3]-vitesse[num2])
<a name="l00906"></a>00906                      /zone_VDF.dist_face_period(num2,num3,i);        <span class="comment">// duj/dxi</span>
<a name="l00907"></a>00907 
<a name="l00908"></a>00908       element(0) = face_voisins(num0,0);
<a name="l00909"></a>00909       element(1) = face_voisins(num0,1);
<a name="l00910"></a>00910       element(2) = face_voisins(num1,0);
<a name="l00911"></a>00911       element(3) = face_voisins(num1,1);
<a name="l00912"></a>00912 
<a name="l00913"></a>00913       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k=0 ; k&lt;4 ; k++)
<a name="l00914"></a>00914         {
<a name="l00915"></a>00915           <span class="keywordflow">if</span> (element(k)!=-1)
<a name="l00916"></a>00916             {
<a name="l00917"></a>00917               gij(element(k),i,j)+=temp1*0.25;
<a name="l00918"></a>00918               gij(element(k),j,i)+=temp2*0.25;
<a name="l00919"></a>00919 
<a name="l00920"></a>00920               <span class="comment">// Justification des coeff derriere :</span>
<a name="l00921"></a>00921               <span class="comment">// 1) 0.25 : on distribue le gradient de vitesse</span>
<a name="l00922"></a>00922               <span class="comment">//            sur les 3 elements qui l&#39;entourent.</span>
<a name="l00923"></a>00923               <span class="comment">//            C&#39;est pour cela que l&#39;on regarde si element(k)!=-1,</span>
<a name="l00924"></a>00924               <span class="comment">//            car dans ce cas la, c&#39;est qu&#39;il s&#39;agit de &quot;la case qui manque&quot; !</span>
<a name="l00925"></a>00925             } <span class="comment">// fin de else if</span>
<a name="l00926"></a>00926         } <span class="comment">// fin du for k</span>
<a name="l00927"></a>00927     } <span class="comment">// fin de la boucle sur les aretes mixtes</span>
<a name="l00928"></a>00928 
<a name="l00929"></a>00929 
<a name="l00930"></a>00930   <span class="keywordflow">for</span> (num_arete=premiere_arete_interne ; num_arete&lt;derniere_arete_interne ; num_arete ++)
<a name="l00931"></a>00931     {
<a name="l00932"></a>00932       num0 = Qdm(num_arete,0);
<a name="l00933"></a>00933       num1 = Qdm(num_arete,1);
<a name="l00934"></a>00934       num2 = Qdm(num_arete,2);
<a name="l00935"></a>00935       num3 = Qdm(num_arete,3);
<a name="l00936"></a>00936       <span class="keywordtype">int</span> i=0;
<a name="l00937"></a>00937       <span class="keywordtype">int</span> j=0;
<a name="l00938"></a>00938       i=orientation(num0);
<a name="l00939"></a>00939       j=orientation(num2);
<a name="l00940"></a>00940 
<a name="l00941"></a>00941       <span class="keywordtype">double</span> temp1 = (vitesse[num1]-vitesse[num0])
<a name="l00942"></a>00942                      /zone_VDF.dist_face_period(num0,num1,j);        <span class="comment">// dui/dxj</span>
<a name="l00943"></a>00943       assert(<a class="code" href="Double_8h.html#ac86f5f350b0f95fd8c34b0ac8d720f6f">est_egal</a>(zone_VDF.dist_face_period(num0,num1,j),zone_VDF.dist_face(num0,num1,j)));
<a name="l00944"></a>00944       <span class="keywordtype">double</span> temp2 = (vitesse[num3]-vitesse[num2])
<a name="l00945"></a>00945                      /zone_VDF.dist_face_period(num2,num3,i);        <span class="comment">// duj/dxi</span>
<a name="l00946"></a>00946       assert(<a class="code" href="Double_8h.html#ac86f5f350b0f95fd8c34b0ac8d720f6f">est_egal</a>(zone_VDF.dist_face_period(num2,num3,j),zone_VDF.dist_face(num2,num3,j)));
<a name="l00947"></a>00947       element(0) = face_voisins(num0,0);
<a name="l00948"></a>00948       element(1) = face_voisins(num0,1);
<a name="l00949"></a>00949       element(2) = face_voisins(num1,0);
<a name="l00950"></a>00950       element(3) = face_voisins(num1,1);
<a name="l00951"></a>00951       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k=0 ; k&lt;4 ; k++)
<a name="l00952"></a>00952         {
<a name="l00953"></a>00953           gij(element(k),i,j)+=temp1*0.25;
<a name="l00954"></a>00954           gij(element(k),j,i)+=temp2*0.25;
<a name="l00955"></a>00955 
<a name="l00956"></a>00956           <span class="comment">// Justification des coeff :</span>
<a name="l00957"></a>00957           <span class="comment">// 1) 0.25 : on distribue le gradient de vitesse</span>
<a name="l00958"></a>00958           <span class="comment">//            sur les 4 elements qui l&#39;entourent.</span>
<a name="l00959"></a>00959         } <span class="comment">// fin du for k</span>
<a name="l00960"></a>00960     } <span class="comment">// fin de la boucle sur les aretes internes</span>
<a name="l00961"></a>00961 
<a name="l00962"></a>00962 
<a name="l00963"></a>00963 
<a name="l00964"></a>00964   <span class="comment">// 2eme partie: boucle sur les elements et remplissage de Sij pour les</span>
<a name="l00965"></a>00965   <span class="comment">//  derivees non croisees (dui/dxi).</span>
<a name="l00966"></a>00966   <span class="comment">// En fait dans ces cas la, on calcul directement le gradient dans l&#39;element</span>
<a name="l00967"></a>00967   <span class="comment">//  et on ne redistribue pas.</span>
<a name="l00968"></a>00968 
<a name="l00969"></a>00969   <span class="keywordflow">for</span>(elem=0 ; elem&lt;nb_elem ; elem ++)
<a name="l00970"></a>00970     {
<a name="l00971"></a>00971       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0 ; i&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a> ; i++)
<a name="l00972"></a>00972         {
<a name="l00973"></a>00973           <span class="keywordtype">double</span> temp1 = (vitesse[elem_faces(elem,i)]
<a name="l00974"></a>00974                           -vitesse[elem_faces(elem,i+dimension)])
<a name="l00975"></a>00975                          /zone_VDF.dim_elem(elem,orientation(elem_faces(elem,i)));
<a name="l00976"></a>00976 
<a name="l00977"></a>00977           gij(elem,i,i)=-temp1;
<a name="l00978"></a>00978 
<a name="l00979"></a>00979         }
<a name="l00980"></a>00980     }
<a name="l00981"></a>00981 
<a name="l00982"></a>00982   <span class="keywordflow">return</span> gij;
<a name="l00983"></a>00983 }
<a name="l00984"></a>00984 <span class="comment"></span>
<a name="l00985"></a>00985 <span class="comment">/////////////////////////////////////////////////////////////////////////////////////////////////////</span>
<a name="l00986"></a>00986 <span class="comment"></span><span class="comment">//Methode qui renvoie gij aux elements a partir de la vitesse aux elements</span>
<a name="l00987"></a>00987 <span class="comment">//(gij represente la derivee partielle dui/dxj)</span>
<a name="l00988"></a>00988 <span class="comment">//</span>
<a name="l00989"></a>00989 <span class="comment">//A partir de gij, on peut calculer Sij = 0.5(gij(i,j)+gij(j,i))</span>
<a name="l00990"></a>00990 <span class="comment">//</span><span class="comment"></span>
<a name="l00991"></a>00991 <span class="comment">////////////////////////////////////////////////////////////////////////////////////////////////////</span>
<a name="l00992"></a>00992 <span class="comment"></span>
<a name="l00993"></a>00993 
<a name="l00994"></a><a class="code" href="classChamp__Face.html#a97fa360dcacec544bd83d2da89a7769c">00994</a> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; <a class="code" href="classChamp__Face.html#a97fa360dcacec544bd83d2da89a7769c">Champ_Face::calcul_duidxj</a>(<span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; in_vel, <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; gij)<span class="keyword"> const</span>
<a name="l00995"></a>00995 <span class="keyword"></span>{
<a name="l00996"></a>00996 
<a name="l00997"></a>00997   <span class="keyword">const</span> <a class="code" href="classZone__VDF.html" title="class Zone_VDF Classe instanciable qui derive de Zone_VF. Cette classe contient les informations geom...">Zone_VDF</a>&amp; zone_VDF = <a class="code" href="classChamp__Face.html#a84b6abcd128000e1d5759caaa7ae0dee">la_zone_VDF</a>.<a class="code" href="classRef__Zone__VDF.html#a84151da4db745d02791d6246e3682b67">valeur</a>();
<a name="l00998"></a>00998   <span class="keywordtype">int</span> nb_elem_tot = zone_VDF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#aa3a33e8b723618b9092460007153e42d" title="Renvoie le nombre total d&#39;elements de la zone.">nb_elem_tot</a>();
<a name="l00999"></a>00999   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; face_voisins = zone_VDF.<a class="code" href="classZone__VF.html#a49d4322f5585a8fa95748ca785b70702" title="renvoie l&#39;element voisin de numface dans la direction i. i=0 : dans le sens oppose de l&#39;axe orthogona...">face_voisins</a>();
<a name="l01000"></a>01000   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; elem_faces = zone_VDF.<a class="code" href="classZone__VF.html#a067e462dcd3ab92b0f6d945b19e4eb37" title="renvoie le numero de le ieme face de la maille num_elem la facon dont ces faces sont numerotees est l...">elem_faces</a>();
<a name="l01001"></a>01001 
<a name="l01002"></a>01002   <span class="keywordtype">int</span> element_number;
<a name="l01003"></a>01003   <span class="keywordtype">int</span> num0,num1,num2,num3,num4,num5;
<a name="l01004"></a>01004   <span class="keywordtype">int</span> f0,<a class="code" href="Lois__sodium_8h.html#a3034a1fb8c782842a2b9473c0f02a448">f1</a>,<a class="code" href="Lois__sodium_8h.html#a23f45359b08cb1d0538697b4f2d3dbbe">f2</a>,f3,f4,f5;
<a name="l01005"></a>01005 
<a name="l01006"></a>01006 
<a name="l01007"></a>01007   <span class="comment">//</span>
<a name="l01008"></a>01008   <span class="comment">// Calculate the Sij tensor</span>
<a name="l01009"></a>01009   <span class="comment">//</span>
<a name="l01010"></a>01010   <span class="keywordflow">if</span> (<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a> ==2)
<a name="l01011"></a>01011     {
<a name="l01012"></a>01012       <span class="keywordflow">for</span> (element_number=0 ; element_number&lt;nb_elem_tot ; element_number ++)
<a name="l01013"></a>01013         {
<a name="l01014"></a>01014           f0 = elem_faces(element_number,0);
<a name="l01015"></a>01015           num0 = face_voisins(f0,0);
<a name="l01016"></a>01016           <span class="keywordflow">if</span> (num0 == -1)
<a name="l01017"></a>01017             num0 = element_number;
<a name="l01018"></a>01018           f1 = elem_faces(element_number,1);
<a name="l01019"></a>01019           num1 = face_voisins(f1,0);
<a name="l01020"></a>01020           <span class="keywordflow">if</span> (num1 == -1)
<a name="l01021"></a>01021             num1 = element_number;
<a name="l01022"></a>01022           f2 = elem_faces(element_number,2);
<a name="l01023"></a>01023           num2 = face_voisins(f2,1);
<a name="l01024"></a>01024           <span class="keywordflow">if</span> (num2 == -1)
<a name="l01025"></a>01025             num2 = element_number;
<a name="l01026"></a>01026           f3 = elem_faces(element_number,3);
<a name="l01027"></a>01027           num3 = face_voisins(f3,1);
<a name="l01028"></a>01028           <span class="keywordflow">if</span> (num3 == -1)
<a name="l01029"></a>01029             num3 = element_number;
<a name="l01030"></a>01030 
<a name="l01031"></a>01031           gij(element_number,0,0)=0.5*((in_vel(num2,0)-in_vel(num0,0))/
<a name="l01032"></a>01032                                        zone_VDF.<a class="code" href="classZone__VDF.html#a16d2b5b0bd1f52fa6aed11d2e59a10b0">dim_elem</a>(element_number,0));
<a name="l01033"></a>01033           gij(element_number,0,1) = 0.5*((in_vel(num3,0)-in_vel(num1,0))/zone_VDF.<a class="code" href="classZone__VDF.html#a16d2b5b0bd1f52fa6aed11d2e59a10b0">dim_elem</a>(element_number,1));
<a name="l01034"></a>01034           gij(element_number,1,0) = 0.5*((in_vel(num2,1)-in_vel(num0,1))/zone_VDF.<a class="code" href="classZone__VDF.html#a16d2b5b0bd1f52fa6aed11d2e59a10b0">dim_elem</a>(element_number,0));
<a name="l01035"></a>01035           gij(element_number,1,1)=0.5*((in_vel(num3,1)-in_vel(num1,1))/
<a name="l01036"></a>01036                                        zone_VDF.<a class="code" href="classZone__VDF.html#a16d2b5b0bd1f52fa6aed11d2e59a10b0">dim_elem</a>(element_number,1));
<a name="l01037"></a>01037         }
<a name="l01038"></a>01038     }
<a name="l01039"></a>01039   <span class="keywordflow">else</span>
<a name="l01040"></a>01040     {
<a name="l01041"></a>01041       <span class="keywordflow">for</span> (element_number=0 ; element_number&lt;nb_elem_tot ; element_number ++)
<a name="l01042"></a>01042         {
<a name="l01043"></a>01043           f0 = elem_faces(element_number,0);
<a name="l01044"></a>01044           num0 = face_voisins(f0,0);
<a name="l01045"></a>01045           <span class="keywordflow">if</span> (num0 == -1)
<a name="l01046"></a>01046             num0 = element_number;
<a name="l01047"></a>01047           f1 = elem_faces(element_number,1);
<a name="l01048"></a>01048           num1 = face_voisins(f1,0);
<a name="l01049"></a>01049           <span class="keywordflow">if</span> (num1 == -1)
<a name="l01050"></a>01050             num1 = element_number;
<a name="l01051"></a>01051           f2 = elem_faces(element_number,2);
<a name="l01052"></a>01052           num2 = face_voisins(f2,0);
<a name="l01053"></a>01053           <span class="keywordflow">if</span> (num2 == -1)
<a name="l01054"></a>01054             num2 = element_number;
<a name="l01055"></a>01055           f3 = elem_faces(element_number,3);
<a name="l01056"></a>01056           num3 = face_voisins(f3,1);
<a name="l01057"></a>01057           <span class="keywordflow">if</span> (num3 == -1)
<a name="l01058"></a>01058             num3 = element_number;
<a name="l01059"></a>01059           f4 = elem_faces(element_number,4);
<a name="l01060"></a>01060           num4 = face_voisins(f4,1);
<a name="l01061"></a>01061           <span class="keywordflow">if</span> (num4 == -1)
<a name="l01062"></a>01062             num4 = element_number;
<a name="l01063"></a>01063           f5 = elem_faces(element_number,5);
<a name="l01064"></a>01064           num5 = face_voisins(f5,1);
<a name="l01065"></a>01065           <span class="keywordflow">if</span> (num5 == -1)
<a name="l01066"></a>01066             num5 = element_number;
<a name="l01067"></a>01067 
<a name="l01068"></a>01068           gij(element_number,0,0)=0.5*((in_vel(num3,0)-in_vel(num0,0))/
<a name="l01069"></a>01069                                        zone_VDF.<a class="code" href="classZone__VDF.html#a16d2b5b0bd1f52fa6aed11d2e59a10b0">dim_elem</a>(element_number,0));
<a name="l01070"></a>01070 
<a name="l01071"></a>01071           gij(element_number,0,1) = 0.5*((in_vel(num4,0)-in_vel(num1,0))/
<a name="l01072"></a>01072                                          zone_VDF.<a class="code" href="classZone__VDF.html#a16d2b5b0bd1f52fa6aed11d2e59a10b0">dim_elem</a>(element_number,1));
<a name="l01073"></a>01073           gij(element_number,1,0) = 0.5*((in_vel(num3,1)-in_vel(num0,1))/
<a name="l01074"></a>01074                                          zone_VDF.<a class="code" href="classZone__VDF.html#a16d2b5b0bd1f52fa6aed11d2e59a10b0">dim_elem</a>(element_number,0));
<a name="l01075"></a>01075 
<a name="l01076"></a>01076           gij(element_number,0,2) =  0.5*((in_vel(num5,0)-in_vel(num2,0))/
<a name="l01077"></a>01077                                           zone_VDF.<a class="code" href="classZone__VDF.html#a16d2b5b0bd1f52fa6aed11d2e59a10b0">dim_elem</a>(element_number,2));
<a name="l01078"></a>01078 
<a name="l01079"></a>01079           gij(element_number,2,0) = 0.5*((in_vel(num3,2)-in_vel(num0,2))/
<a name="l01080"></a>01080                                          zone_VDF.<a class="code" href="classZone__VDF.html#a16d2b5b0bd1f52fa6aed11d2e59a10b0">dim_elem</a>(element_number,0));
<a name="l01081"></a>01081 
<a name="l01082"></a>01082           gij(element_number,1,1)=0.5*((in_vel(num4,1)-in_vel(num1,1))/
<a name="l01083"></a>01083                                        zone_VDF.<a class="code" href="classZone__VDF.html#a16d2b5b0bd1f52fa6aed11d2e59a10b0">dim_elem</a>(element_number,1));
<a name="l01084"></a>01084 
<a name="l01085"></a>01085           gij(element_number,1,2) = 0.5*((in_vel(num5,1)-in_vel(num2,1))/
<a name="l01086"></a>01086                                          zone_VDF.<a class="code" href="classZone__VDF.html#a16d2b5b0bd1f52fa6aed11d2e59a10b0">dim_elem</a>(element_number,2));
<a name="l01087"></a>01087           gij(element_number,2,1) = 0.5*((in_vel(num4,2)-in_vel(num1,2))/
<a name="l01088"></a>01088                                          zone_VDF.<a class="code" href="classZone__VDF.html#a16d2b5b0bd1f52fa6aed11d2e59a10b0">dim_elem</a>(element_number,1));
<a name="l01089"></a>01089 
<a name="l01090"></a>01090           gij(element_number,2,2)=0.5*((in_vel(num5,2)-in_vel(num2,2))/
<a name="l01091"></a>01091                                        zone_VDF.<a class="code" href="classZone__VDF.html#a16d2b5b0bd1f52fa6aed11d2e59a10b0">dim_elem</a>(element_number,2));
<a name="l01092"></a>01092 
<a name="l01093"></a>01093         }
<a name="l01094"></a>01094     }
<a name="l01095"></a>01095 
<a name="l01096"></a>01096   <span class="keywordflow">return</span> gij;
<a name="l01097"></a>01097 
<a name="l01098"></a>01098 }
<a name="l01099"></a>01099 <span class="comment">/*</span>
<a name="l01100"></a>01100 <span class="comment"></span>
<a name="l01101"></a>01101 <span class="comment">DoubleTab&amp; Champ_Face::calcul_Sij(const DoubleTab&amp; duidxj, DoubleTab&amp; Sij, const Zone_Cl_VDF&amp; zone_Cl_VDF)</span>
<a name="l01102"></a>01102 <span class="comment">{</span>
<a name="l01103"></a>01103 <span class="comment"></span>
<a name="l01104"></a>01104 <span class="comment">const Zone_VDF&amp; zone_VDF = la_zone_VDF.valeur();</span>
<a name="l01105"></a>01105 <span class="comment">const int nb_elem_tot = zone_VDF.nb_elem_tot();</span>
<a name="l01106"></a>01106 <span class="comment">int i,j,elem;</span>
<a name="l01107"></a>01107 <span class="comment"></span>
<a name="l01108"></a>01108 <span class="comment">for(elem=0 ; elem&lt;nb_elem_tot ; elem ++)</span>
<a name="l01109"></a>01109 <span class="comment">{</span>
<a name="l01110"></a>01110 <span class="comment"></span>
<a name="l01111"></a>01111 <span class="comment">for(i=0 ; i&lt;dimension ; i ++)</span>
<a name="l01112"></a>01112 <span class="comment">for(j=0 ; j&lt;dimension ; j ++)</span>
<a name="l01113"></a>01113 <span class="comment">{</span>
<a name="l01114"></a>01114 <span class="comment">Sij(elem,i,j)=0.5*(duidxj(elem,i,j) + duidxj(elem,j,i));</span>
<a name="l01115"></a>01115 <span class="comment">}</span>
<a name="l01116"></a>01116 <span class="comment">}</span>
<a name="l01117"></a>01117 <span class="comment"></span>
<a name="l01118"></a>01118 <span class="comment">return Sij;</span>
<a name="l01119"></a>01119 <span class="comment">}</span>
<a name="l01120"></a>01120 <span class="comment">*/</span>
<a name="l01121"></a>01121 
<a name="l01122"></a>01122 <span class="comment"></span>
<a name="l01123"></a>01123 <span class="comment">/////////////////////////////////////////////////////////////////////////////////////////////////////</span>
<a name="l01124"></a>01124 <span class="comment"></span><span class="comment">//Methode qui renvoie SMA_barre aux elements a partir de la vitesse aux faces</span>
<a name="l01125"></a>01125 <span class="comment">//SMA_barre = Sij*Sij (sommation sur les indices i et j)</span><span class="comment"></span>
<a name="l01126"></a>01126 <span class="comment">////////////////////////////////////////////////////////////////////////////////////////////////////</span>
<a name="l01127"></a>01127 <span class="comment"></span>
<a name="l01128"></a><a class="code" href="classChamp__Face.html#a00a53900838fa2618886381781fe6d6f">01128</a> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; <a class="code" href="classChamp__Face.html#a00a53900838fa2618886381781fe6d6f">Champ_Face::calcul_S_barre_sans_contrib_paroi</a>(<span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; vitesse, <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; SMA_barre, <span class="keyword">const</span> <a class="code" href="classZone__Cl__VDF.html" title="&lt; namespace TypeAreteCoinVDF">Zone_Cl_VDF</a>&amp; zone_Cl_VDF)<span class="keyword"> const</span>
<a name="l01129"></a>01129 <span class="keyword"></span>{
<a name="l01130"></a>01130   <span class="comment">// On calcule directement S_barre(num_elem)!!!!!!!!!!</span>
<a name="l01131"></a>01131   <span class="comment">// Le parametre contribution_paroi (ici fixe a 0) permet de ne pas prendre en compte</span>
<a name="l01132"></a>01132   <span class="comment">// la contribution de la paroi au produit SMA_barre = Sij*Sij</span>
<a name="l01133"></a>01133 
<a name="l01134"></a>01134   <span class="keywordtype">int</span> contribution_paroi;
<a name="l01135"></a>01135   contribution_paroi=0;
<a name="l01136"></a>01136 
<a name="l01137"></a>01137   <span class="keyword">const</span> <a class="code" href="classChamp__Face.html" title="class Champ_Face Cette classe sert a representer un champ vectoriel dont on ne calcule que les compos...">Champ_Face</a>&amp; vit = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classChamp__Face.html" title="class Champ_Face Cette classe sert a representer un champ vectoriel dont on ne calcule que les compos...">Champ_Face</a>, <a class="code" href="classMorEqn.html#a47b12fa29b57783a8a5897f7611e2176">mon_equation</a>-&gt;inconnue().<a class="code" href="classRef__Equation__base.html#a7bb6fb60cb55bef0eef1b0e8718300a4">valeur</a>());
<a name="l01138"></a>01138   <span class="keyword">const</span> <a class="code" href="classZone__VDF.html" title="class Zone_VDF Classe instanciable qui derive de Zone_VF. Cette classe contient les informations geom...">Zone_VDF</a>&amp; zone_VDF = <a class="code" href="classChamp__Face.html#a84b6abcd128000e1d5759caaa7ae0dee">la_zone_VDF</a>.<a class="code" href="classRef__Zone__VDF.html#a84151da4db745d02791d6246e3682b67">valeur</a>();
<a name="l01139"></a>01139 
<a name="l01140"></a>01140   <span class="keywordtype">int</span> nb_elem = zone_VDF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#a7f249429803b27139a1c54436f6164a5" title="Renvoie le nombre d&#39;elements de la zone.">nb_elem</a>();
<a name="l01141"></a>01141   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; face_voisins = zone_VDF.face_voisins();
<a name="l01142"></a>01142   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; elem_faces = zone_VDF.elem_faces();
<a name="l01143"></a>01143   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; Qdm = zone_VDF.Qdm();
<a name="l01144"></a>01144   <span class="keyword">const</span> <a class="code" href="classIntVect.html">IntVect</a>&amp; orientation = zone_VDF.orientation();
<a name="l01145"></a>01145 
<a name="l01146"></a>01146   <span class="keywordtype">int</span> premiere_arete_mixte = zone_VDF.premiere_arete_mixte();
<a name="l01147"></a>01147   <span class="keywordtype">int</span> premiere_arete_interne =  zone_VDF.premiere_arete_interne();
<a name="l01148"></a>01148   <span class="keywordtype">int</span> derniere_arete_mixte = premiere_arete_mixte+zone_VDF.nb_aretes_mixtes();
<a name="l01149"></a>01149   <span class="keywordtype">int</span> derniere_arete_interne = premiere_arete_interne+zone_VDF.nb_aretes_internes();
<a name="l01150"></a>01150   <span class="keywordtype">int</span> elem;
<a name="l01151"></a>01151   <span class="keywordtype">int</span> num_arete;
<a name="l01152"></a>01152   <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> element(4);
<a name="l01153"></a>01153 
<a name="l01154"></a>01154   <span class="keywordtype">int</span> num0,num1,num2,num3,signe;
<a name="l01155"></a>01155   <span class="keywordtype">int</span> ndeb = zone_VDF.premiere_arete_bord();
<a name="l01156"></a>01156   <span class="keywordtype">int</span> nfin = ndeb + zone_VDF.nb_aretes_bord();
<a name="l01157"></a>01157   <span class="keywordtype">int</span> n_type;
<a name="l01158"></a>01158 
<a name="l01159"></a>01159   <span class="keywordflow">for</span> (num_arete=ndeb; num_arete&lt;nfin; num_arete++)
<a name="l01160"></a>01160     {
<a name="l01161"></a>01161       n_type=zone_Cl_VDF.<a class="code" href="classZone__Cl__VDF.html#ae99f1fd7eda112296855c945b44aa85c">type_arete_bord</a>(num_arete-ndeb);
<a name="l01162"></a>01162 
<a name="l01163"></a>01163       <span class="keywordflow">if</span> (n_type == 4) <span class="comment">// arete de type periodicite</span>
<a name="l01164"></a>01164         {
<a name="l01165"></a>01165           num0 = Qdm(num_arete,0);
<a name="l01166"></a>01166           num1 = Qdm(num_arete,1);
<a name="l01167"></a>01167           num2 = Qdm(num_arete,2);
<a name="l01168"></a>01168           num3 = Qdm(num_arete,3);
<a name="l01169"></a>01169           <span class="keywordtype">int</span> i=0;
<a name="l01170"></a>01170           <span class="keywordtype">int</span> j=0;
<a name="l01171"></a>01171           i=orientation(num0);
<a name="l01172"></a>01172           j=orientation(num2);
<a name="l01173"></a>01173 
<a name="l01174"></a>01174           <span class="keywordtype">double</span> temp1 = (vitesse[num1]-vitesse[num0])
<a name="l01175"></a>01175                          /zone_VDF.dist_face_period(num0,num1,j);            <span class="comment">// dv/dx</span>
<a name="l01176"></a>01176           <span class="keywordtype">double</span> temp2 = (vitesse[num3]-vitesse[num2])
<a name="l01177"></a>01177                          /zone_VDF.dist_face_period(num2,num3,i);            <span class="comment">// du/dy</span>
<a name="l01178"></a>01178           element(0) = face_voisins(num0,0);
<a name="l01179"></a>01179           element(1) = face_voisins(num0,1);
<a name="l01180"></a>01180           element(2) = face_voisins(num1,0);
<a name="l01181"></a>01181           element(3) = face_voisins(num1,1);
<a name="l01182"></a>01182           <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k=0 ; k&lt;4 ; k++)
<a name="l01183"></a>01183             {
<a name="l01184"></a>01184               SMA_barre(element(k))+=0.5*(temp1+temp2)*(temp1+temp2)*0.25;
<a name="l01185"></a>01185               <span class="comment">// Justification du coeff :</span>
<a name="l01186"></a>01186               <span class="comment">// on calcule la somme des termes croises :</span>
<a name="l01187"></a>01187               <span class="comment">// 2*( (0.5*Sij)^2+(0.5*Sji)^2)</span>
<a name="l01188"></a>01188               <span class="comment">// Comme on est sur les aretes et qu on distribue sur l&#39;element</span>
<a name="l01189"></a>01189               <span class="comment">// il faut multiplier par 0.25</span>
<a name="l01190"></a>01190               <span class="comment">// d ou : 0.25*(2*(2*0.5^2))=0.25*4*0.25=0.25!!!!!!</span>
<a name="l01191"></a>01191               <span class="comment">// le 0.5 devant vient du fait que nous parcourons les faces de periodicite</span>
<a name="l01192"></a>01192               <span class="comment">// comme les aretes periodiques sont les &quot;memes&quot;, on ajoute deux fois ce qu il faut</span>
<a name="l01193"></a>01193               <span class="comment">// aux elements -&gt; 0.5!!!</span>
<a name="l01194"></a>01194             }        <span class="comment">// fin du for k</span>
<a name="l01195"></a>01195         }
<a name="l01196"></a>01196       <span class="keywordflow">else</span>
<a name="l01197"></a>01197         {
<a name="l01198"></a>01198           num0 = Qdm(num_arete,0);
<a name="l01199"></a>01199           num1 = Qdm(num_arete,1);
<a name="l01200"></a>01200           num2 = Qdm(num_arete,2);
<a name="l01201"></a>01201           signe = Qdm(num_arete,3);
<a name="l01202"></a>01202           <span class="keywordtype">int</span> j=0;
<a name="l01203"></a>01203           j=orientation(num2);
<a name="l01204"></a>01204 
<a name="l01205"></a>01205           <span class="keywordtype">double</span> temp2;
<a name="l01206"></a>01206           <span class="keywordtype">double</span> temp1 = (vitesse[num1]-vitesse[num0])
<a name="l01207"></a>01207                          /zone_VDF.dist_face_period(num0,num1,j);        <span class="comment">// dv/dx</span>
<a name="l01208"></a>01208           <span class="keywordtype">double</span> vit_imp = 0.5*(vit.<a class="code" href="classChamp__Face.html#a613ea150dbc6a9b5f288011f90484381">val_imp_face_bord_private</a>(num0,j)+
<a name="l01209"></a>01209                                 vit.<a class="code" href="classChamp__Face.html#a613ea150dbc6a9b5f288011f90484381">val_imp_face_bord_private</a>(num1,j));                <span class="comment">// vitesse tangentielle</span>
<a name="l01210"></a>01210 
<a name="l01211"></a>01211           <span class="keywordflow">if</span> ( n_type == 0 &amp;&amp; contribution_paroi == 0 )
<a name="l01212"></a>01212             temp2 = 0;
<a name="l01213"></a>01213           <span class="keywordflow">else</span>
<a name="l01214"></a>01214             temp2  = -signe*(vitesse[num2]-vit_imp)/zone_VDF.dist_norm_bord(num1);
<a name="l01215"></a>01215 
<a name="l01216"></a>01216           element(0) = face_voisins(num2,0);
<a name="l01217"></a>01217           element(1) = face_voisins(num2,1);
<a name="l01218"></a>01218 
<a name="l01219"></a>01219           <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k=0 ; k&lt;2 ; k++)
<a name="l01220"></a>01220             {
<a name="l01221"></a>01221               SMA_barre(element(k))+=(temp1+temp2)*(temp1+temp2)*0.25;
<a name="l01222"></a>01222               <span class="comment">// Justification du coeff :</span>
<a name="l01223"></a>01223               <span class="comment">// on calcule la somme des termes croises :</span>
<a name="l01224"></a>01224               <span class="comment">// 2*( (0.5*Sij)^2+(0.5*Sji)^2)</span>
<a name="l01225"></a>01225               <span class="comment">// Comme on est sur les aretes et qu on distribue sur l&#39;element</span>
<a name="l01226"></a>01226               <span class="comment">// il faut multiplier par 0.25</span>
<a name="l01227"></a>01227               <span class="comment">// d ou : 0.25*(2*(2*0.5^2))=0.25*4*0.25=0.25!!!!!!</span>
<a name="l01228"></a>01228               <span class="comment">// Prise en compte des 2 termes symetriques : SijSij+SjiSji</span>
<a name="l01229"></a>01229             }                <span class="comment">// fin du for k</span>
<a name="l01230"></a>01230         }
<a name="l01231"></a>01231     }
<a name="l01232"></a>01232 
<a name="l01233"></a>01233 <span class="comment"></span>
<a name="l01234"></a>01234 <span class="comment">  /////////////////////////////////</span>
<a name="l01235"></a>01235 <span class="comment"></span>  <span class="comment">//On parcourt les aretes coins</span><span class="comment"></span>
<a name="l01236"></a>01236 <span class="comment">  ////////////////////////////////</span>
<a name="l01237"></a>01237 <span class="comment"></span>
<a name="l01238"></a>01238   ndeb = zone_VDF.premiere_arete_coin();
<a name="l01239"></a>01239   nfin = ndeb + zone_VDF.nb_aretes_coin();
<a name="l01240"></a>01240 
<a name="l01241"></a>01241   <span class="keywordflow">for</span> (num_arete=ndeb; num_arete&lt;nfin; num_arete++)
<a name="l01242"></a>01242     {
<a name="l01243"></a>01243       n_type=zone_Cl_VDF.<a class="code" href="classZone__Cl__VDF.html#ae0bee7198d75e43dbc46a5b4e181b736">type_arete_coin</a>(num_arete-ndeb);<span class="comment"></span>
<a name="l01244"></a>01244 <span class="comment">      //////////////////////////////////////////</span>
<a name="l01245"></a>01245 <span class="comment"></span>      <span class="comment">// Traitement des aretes coin perio-perio</span><span class="comment"></span>
<a name="l01246"></a>01246 <span class="comment">      //////////////////////////////////////////</span>
<a name="l01247"></a>01247 <span class="comment"></span>
<a name="l01248"></a>01248       <span class="keywordflow">if</span> (n_type == 0) <span class="comment">// arete de type periodicite-periodicite</span>
<a name="l01249"></a>01249         {
<a name="l01250"></a>01250           num0 = Qdm(num_arete,0);
<a name="l01251"></a>01251           num1 = Qdm(num_arete,1);
<a name="l01252"></a>01252           num2 = Qdm(num_arete,2);
<a name="l01253"></a>01253           num3 = Qdm(num_arete,3);
<a name="l01254"></a>01254           <span class="keywordtype">int</span> i=0;
<a name="l01255"></a>01255           <span class="keywordtype">int</span> j=0;
<a name="l01256"></a>01256           i=orientation(num0);
<a name="l01257"></a>01257           j=orientation(num2);
<a name="l01258"></a>01258 
<a name="l01259"></a>01259           <span class="keywordtype">double</span> temp1 = (vitesse[num1]-vitesse[num0])
<a name="l01260"></a>01260                          /zone_VDF.dist_face_period(num0,num1,j);            <span class="comment">// dv/dx</span>
<a name="l01261"></a>01261           <span class="keywordtype">double</span> temp2 = (vitesse[num3]-vitesse[num2])
<a name="l01262"></a>01262                          /zone_VDF.dist_face_period(num2,num3,i);            <span class="comment">// du/dy</span>
<a name="l01263"></a>01263           element(0) = face_voisins(num0,0);
<a name="l01264"></a>01264           element(1) = face_voisins(num0,1);
<a name="l01265"></a>01265           element(2) = face_voisins(num1,0);
<a name="l01266"></a>01266           element(3) = face_voisins(num1,1);
<a name="l01267"></a>01267           <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k=0 ; k&lt;4 ; k++)
<a name="l01268"></a>01268             {
<a name="l01269"></a>01269               SMA_barre(element(k))+=0.5*0.5*(temp1+temp2)*(temp1+temp2)*0.25;
<a name="l01270"></a>01270               <span class="comment">// Justification du coeff :</span>
<a name="l01271"></a>01271               <span class="comment">// on calcule la somme des termes croises :</span>
<a name="l01272"></a>01272               <span class="comment">// 2*( (0.5*Sij)^2+(0.5*Sji)^2)</span>
<a name="l01273"></a>01273               <span class="comment">// Comme on est sur les aretes et qu on distribue sur l&#39;element</span>
<a name="l01274"></a>01274               <span class="comment">// il faut multiplier par 0.25</span>
<a name="l01275"></a>01275               <span class="comment">// d ou : 0.25*(2*(2*0.5^2))=0.25*4*0.25=0.25!!!!!!</span>
<a name="l01276"></a>01276               <span class="comment">// le 0.5 devant vient du fait que nous parcourons les faces de periodicite</span>
<a name="l01277"></a>01277               <span class="comment">// comme les aretes periodiques sont les &quot;memes&quot;, on ajoute deux fois ce qu il faut</span>
<a name="l01278"></a>01278               <span class="comment">// aux elements -&gt; 0.5!!!</span>
<a name="l01279"></a>01279               <span class="comment">// encore un *0.5 car ce sont des aretes perio perio donc que l on parcourt 4 fois!!!!</span>
<a name="l01280"></a>01280             }        <span class="comment">// fin du for k</span>
<a name="l01281"></a>01281 
<a name="l01282"></a>01282         }
<a name="l01283"></a>01283 <span class="comment"></span>
<a name="l01284"></a>01284 <span class="comment">      //////////////////////////////////////////</span>
<a name="l01285"></a>01285 <span class="comment"></span>      <span class="comment">// Traitement des aretes coin perio-paroi</span><span class="comment"></span>
<a name="l01286"></a>01286 <span class="comment">      //////////////////////////////////////////</span>
<a name="l01287"></a>01287 <span class="comment"></span>      <span class="keywordflow">if</span> (n_type == 1) <span class="comment">// arete de type periodicite-paroi</span>
<a name="l01288"></a>01288         {
<a name="l01289"></a>01289           num0 = Qdm(num_arete,0);
<a name="l01290"></a>01290           num1 = Qdm(num_arete,1);
<a name="l01291"></a>01291           num2 = Qdm(num_arete,2);
<a name="l01292"></a>01292           signe = Qdm(num_arete,3);
<a name="l01293"></a>01293           <span class="keywordtype">int</span> j=0;
<a name="l01294"></a>01294           j=orientation(num2);
<a name="l01295"></a>01295 
<a name="l01296"></a>01296           <span class="keywordtype">double</span> temp2;
<a name="l01297"></a>01297           <span class="keywordtype">double</span> temp1 = (vitesse[num1]-vitesse[num0])
<a name="l01298"></a>01298                          /zone_VDF.dist_face_period(num0,num1,j);        <span class="comment">// dv/dx</span>
<a name="l01299"></a>01299           <span class="keywordtype">double</span> vit_imp = 0.5*(vit.<a class="code" href="classChamp__Face.html#a613ea150dbc6a9b5f288011f90484381">val_imp_face_bord_private</a>(num0,j)+
<a name="l01300"></a>01300                                 vit.<a class="code" href="classChamp__Face.html#a613ea150dbc6a9b5f288011f90484381">val_imp_face_bord_private</a>(num1,j));             <span class="comment">// vitesse tangentielle</span>
<a name="l01301"></a>01301 
<a name="l01302"></a>01302           <span class="keywordflow">if</span> ( contribution_paroi == 0 )
<a name="l01303"></a>01303             temp2 = 0;
<a name="l01304"></a>01304           <span class="keywordflow">else</span>
<a name="l01305"></a>01305             temp2  = -signe*(vitesse[num2]-vit_imp)/zone_VDF.dist_norm_bord(num1);
<a name="l01306"></a>01306 
<a name="l01307"></a>01307           element(0) = face_voisins(num2,0);
<a name="l01308"></a>01308           element(1) = face_voisins(num2,1);
<a name="l01309"></a>01309 
<a name="l01310"></a>01310           <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k=0 ; k&lt;2 ; k++)
<a name="l01311"></a>01311             {
<a name="l01312"></a>01312               SMA_barre(element(k))+=0.5*(temp1+temp2)*(temp1+temp2)*0.25;
<a name="l01313"></a>01313               <span class="comment">// Justification du coeff :</span>
<a name="l01314"></a>01314               <span class="comment">// on calcule la somme des termes croises :</span>
<a name="l01315"></a>01315               <span class="comment">// 2*( (0.5*Sij)^2+(0.5*Sji)^2)</span>
<a name="l01316"></a>01316               <span class="comment">// Comme on est sur les aretes et qu on distribue sur l&#39;element</span>
<a name="l01317"></a>01317               <span class="comment">// il faut multiplier par 0.25</span>
<a name="l01318"></a>01318               <span class="comment">// d ou : 0.25*(2*(2*0.5^2))=0.25*4*0.25=0.25!!!!!!</span>
<a name="l01319"></a>01319               <span class="comment">// Prise en compte des 2 termes symetriques : SijSij+SjiSji</span>
<a name="l01320"></a>01320               <span class="comment">// encore un *0.5 car ce sont des aretes perio perio donc que l on parcourt 2 fois!!!!</span>
<a name="l01321"></a>01321 
<a name="l01322"></a>01322             }                <span class="comment">// fin du for k</span>
<a name="l01323"></a>01323         }
<a name="l01324"></a>01324     }
<a name="l01325"></a>01325 
<a name="l01326"></a>01326 
<a name="l01327"></a>01327   <span class="comment">// 1ere partie:boucles sur les aretes et remplissage de Sij pour la partie</span>
<a name="l01328"></a>01328   <span class="comment">// derivees croisees (dv/dx+du/dy)</span>
<a name="l01329"></a>01329   <span class="comment">// vitesse[face] renvoie la vitesse NORMALE a la face</span>
<a name="l01330"></a>01330   <span class="comment">//   for (num_arete = premiere_arete_bord ; num_arete&lt;derniere_arete_bord ; num_arete ++)</span>
<a name="l01331"></a>01331   <span class="comment">//     {</span>
<a name="l01332"></a>01332   <span class="comment">//       const IntVect&amp; type_arete_bord = zone_Cl_VDF.type_arete_bord();</span>
<a name="l01333"></a>01333 
<a name="l01334"></a>01334 
<a name="l01335"></a>01335   <span class="keywordflow">for</span>(num_arete=premiere_arete_mixte ; num_arete&lt;derniere_arete_mixte ; num_arete ++)
<a name="l01336"></a>01336     {
<a name="l01337"></a>01337       num0 = Qdm(num_arete,0);
<a name="l01338"></a>01338       num1 = Qdm(num_arete,1);
<a name="l01339"></a>01339       num2 = Qdm(num_arete,2);
<a name="l01340"></a>01340       num3 = Qdm(num_arete,3);
<a name="l01341"></a>01341       <span class="keywordtype">int</span> i=0;
<a name="l01342"></a>01342       <span class="keywordtype">int</span> j=0;
<a name="l01343"></a>01343       i=orientation(num0);
<a name="l01344"></a>01344       j=orientation(num2);
<a name="l01345"></a>01345 
<a name="l01346"></a>01346       <span class="keywordtype">double</span> temp1 = (vitesse[num1]-vitesse[num0])
<a name="l01347"></a>01347                      /zone_VDF.dist_face_period(num0,num1,j);          <span class="comment">// dv/dx</span>
<a name="l01348"></a>01348       <span class="keywordtype">double</span> temp2 = (vitesse[num3]-vitesse[num2])
<a name="l01349"></a>01349                      /zone_VDF.dist_face_period(num2,num3,i);          <span class="comment">// du/dy</span>
<a name="l01350"></a>01350 
<a name="l01351"></a>01351       element(0) = face_voisins(num0,0);
<a name="l01352"></a>01352       element(1) = face_voisins(num0,1);
<a name="l01353"></a>01353       element(2) = face_voisins(num1,0);
<a name="l01354"></a>01354       element(3) = face_voisins(num1,1);
<a name="l01355"></a>01355 
<a name="l01356"></a>01356       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k=0 ; k&lt;4 ; k++)
<a name="l01357"></a>01357         {
<a name="l01358"></a>01358           <span class="keywordflow">if</span> (element(k)!=-1)
<a name="l01359"></a>01359             {
<a name="l01360"></a>01360               SMA_barre(element(k))+=(temp1+temp2)*(temp1+temp2)*0.25;
<a name="l01361"></a>01361               <span class="comment">// Justification du coeff :</span>
<a name="l01362"></a>01362               <span class="comment">// on calcule la somme des termes croises :</span>
<a name="l01363"></a>01363               <span class="comment">// 2*( (0.5*Sij)^2+(0.5*Sji)^2)</span>
<a name="l01364"></a>01364               <span class="comment">// Comme on est sur les aretes et qu on distribue sur l&#39;element</span>
<a name="l01365"></a>01365               <span class="comment">// il faut multiplier par 0.25</span>
<a name="l01366"></a>01366               <span class="comment">// d ou : 0.25*(2*(2*0.5^2))=0.25*4*0.25=0.25!!!!!!</span>
<a name="l01367"></a>01367               <span class="comment">// Prise en compte des 2 termes symetriques : SijSij+SjiSji</span>
<a name="l01368"></a>01368             }        <span class="comment">// fin de else if</span>
<a name="l01369"></a>01369         }                <span class="comment">// fin du for k</span>
<a name="l01370"></a>01370     }                <span class="comment">// fin de la boucle sur les aretes mixtes</span>
<a name="l01371"></a>01371 
<a name="l01372"></a>01372 
<a name="l01373"></a>01373   <span class="keywordflow">for</span> (num_arete=premiere_arete_interne ; num_arete&lt;derniere_arete_interne ; num_arete ++)
<a name="l01374"></a>01374     {
<a name="l01375"></a>01375       num0 = Qdm(num_arete,0);
<a name="l01376"></a>01376       num1 = Qdm(num_arete,1);
<a name="l01377"></a>01377       num2 = Qdm(num_arete,2);
<a name="l01378"></a>01378       num3 = Qdm(num_arete,3);
<a name="l01379"></a>01379       <span class="keywordtype">int</span> i=0;
<a name="l01380"></a>01380       <span class="keywordtype">int</span> j=0;
<a name="l01381"></a>01381       i=orientation(num0);
<a name="l01382"></a>01382       j=orientation(num2);
<a name="l01383"></a>01383 
<a name="l01384"></a>01384       <span class="keywordtype">double</span> temp1 = (vitesse[num1]-vitesse[num0])
<a name="l01385"></a>01385                      /zone_VDF.dist_face_period(num0,num1,j);            <span class="comment">// dv/dx</span>
<a name="l01386"></a>01386       <span class="keywordtype">double</span> temp2 = (vitesse[num3]-vitesse[num2])
<a name="l01387"></a>01387                      /zone_VDF.dist_face_period(num2,num3,i);            <span class="comment">// du/dy</span>
<a name="l01388"></a>01388       element(0) = face_voisins(num0,0);
<a name="l01389"></a>01389       element(1) = face_voisins(num0,1);
<a name="l01390"></a>01390       element(2) = face_voisins(num1,0);
<a name="l01391"></a>01391       element(3) = face_voisins(num1,1);
<a name="l01392"></a>01392       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k=0 ; k&lt;4 ; k++)
<a name="l01393"></a>01393         {
<a name="l01394"></a>01394           SMA_barre(element(k))+=(temp1+temp2)*(temp1+temp2)*0.25;
<a name="l01395"></a>01395           <span class="comment">// Justification du coeff :</span>
<a name="l01396"></a>01396           <span class="comment">// on calcule la somme des termes croises :</span>
<a name="l01397"></a>01397           <span class="comment">// 2*( (0.5*Sij)^2+(0.5*Sji)^2)</span>
<a name="l01398"></a>01398           <span class="comment">// Comme on est sur les aretes et qu on distribue sur l&#39;element</span>
<a name="l01399"></a>01399           <span class="comment">// il faut multiplier par 0.25</span>
<a name="l01400"></a>01400           <span class="comment">// d ou : 0.25*(2*(2*0.5^2))=0.25*4*0.25=0.25!!!!!!</span>
<a name="l01401"></a>01401           <span class="comment">// Prise en compte des 2 termes symetriques : SijSij+SjiSji</span>
<a name="l01402"></a>01402         }        <span class="comment">// fin du for k</span>
<a name="l01403"></a>01403     }        <span class="comment">// fin de la boucle sur les aretes internes</span>
<a name="l01404"></a>01404 
<a name="l01405"></a>01405 
<a name="l01406"></a>01406   <span class="comment">// 2eme partie: boucle sur les elements et remplissage de Sij pour les</span>
<a name="l01407"></a>01407   <span class="comment">// derivees non croisees (du/dx et dv/dy)</span>
<a name="l01408"></a>01408 
<a name="l01409"></a>01409   <span class="keywordflow">for</span>(elem=0 ; elem&lt;nb_elem ; elem ++)
<a name="l01410"></a>01410     {
<a name="l01411"></a>01411       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0 ; i&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a> ; i++)
<a name="l01412"></a>01412         {
<a name="l01413"></a>01413           <span class="keywordtype">double</span> temp1 = (vitesse[elem_faces(elem,i)]
<a name="l01414"></a>01414                           -vitesse[elem_faces(elem,i+dimension)])
<a name="l01415"></a>01415                          /zone_VDF.dim_elem(elem,orientation(elem_faces(elem,i)));
<a name="l01416"></a>01416           SMA_barre(elem)+=2.0*temp1*temp1;
<a name="l01417"></a>01417         }
<a name="l01418"></a>01418     }
<a name="l01419"></a>01419 
<a name="l01420"></a>01420   <span class="comment">// On prend la racine carre!!!!!  ATTENTION SMA_barre=invariant au carre!!!</span>
<a name="l01421"></a>01421   <span class="comment">//  racine_carree(SMA_barre)</span>
<a name="l01422"></a>01422 
<a name="l01423"></a>01423 
<a name="l01424"></a>01424   <span class="keywordflow">return</span> SMA_barre;
<a name="l01425"></a>01425 }
<a name="l01426"></a>01426 
<a name="l01427"></a><a class="code" href="classChamp__Face.html#a08f4717bc89dc38dfb7b9e3627ab5592">01427</a> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; <a class="code" href="classChamp__Face.html#a08f4717bc89dc38dfb7b9e3627ab5592">Champ_Face::calcul_S_barre</a>(<span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; vitesse,<a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; SMA_barre,<span class="keyword">const</span> <a class="code" href="classZone__Cl__VDF.html" title="&lt; namespace TypeAreteCoinVDF">Zone_Cl_VDF</a>&amp; zone_Cl_VDF)<span class="keyword"> const</span>
<a name="l01428"></a>01428 <span class="keyword"></span>{
<a name="l01429"></a>01429   <span class="keyword">const</span> <a class="code" href="classZone__VDF.html" title="class Zone_VDF Classe instanciable qui derive de Zone_VF. Cette classe contient les informations geom...">Zone_VDF</a>&amp; zone_VDF = <a class="code" href="classChamp__Face.html#a84b6abcd128000e1d5759caaa7ae0dee">la_zone_VDF</a>.<a class="code" href="classRef__Zone__VDF.html#a84151da4db745d02791d6246e3682b67">valeur</a>();
<a name="l01430"></a>01430   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_elem_tot = zone_VDF.<a class="code" href="classZone__dis__base.html#a4d6aa445f152aa6dc54d66ea7a071147">nb_elem_tot</a>();
<a name="l01431"></a>01431   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_elem = zone_VDF.<a class="code" href="classZone__dis__base.html#a790cb2f6bc2928518799e748313d0eb3">nb_elem</a>();
<a name="l01432"></a>01432 
<a name="l01433"></a>01433   <span class="keywordtype">int</span> i,j;
<a name="l01434"></a>01434   <span class="keywordtype">int</span> elem;
<a name="l01435"></a>01435   <span class="keywordtype">double</span> Sij,temp;
<a name="l01436"></a>01436 
<a name="l01437"></a>01437   <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a> duidxj(nb_elem_tot,<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>,<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>);
<a name="l01438"></a>01438 
<a name="l01439"></a>01439   <a class="code" href="classChamp__Face.html#a97fa360dcacec544bd83d2da89a7769c">calcul_duidxj</a>(vitesse,duidxj,zone_Cl_VDF);
<a name="l01440"></a>01440 
<a name="l01441"></a>01441   <span class="keywordflow">for</span> (elem=0 ; elem&lt;nb_elem; elem++)
<a name="l01442"></a>01442     {
<a name="l01443"></a>01443       temp = 0.;
<a name="l01444"></a>01444       <span class="keywordflow">for</span> ( i=0 ; i&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a> ; i++)
<a name="l01445"></a>01445         <span class="keywordflow">for</span> ( j=0 ; j&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a> ; j++)
<a name="l01446"></a>01446           {
<a name="l01447"></a>01447             Sij=0.5*(duidxj(elem,i,j) + duidxj(elem,j,i));
<a name="l01448"></a>01448             temp+=Sij*Sij;
<a name="l01449"></a>01449           }
<a name="l01450"></a>01450       SMA_barre(elem)=2.*temp;
<a name="l01451"></a>01451     }
<a name="l01452"></a>01452 
<a name="l01453"></a>01453   <span class="keywordflow">return</span> SMA_barre;
<a name="l01454"></a>01454 
<a name="l01455"></a>01455 }
<a name="l01456"></a>01456 
<a name="l01457"></a><a class="code" href="classChamp__Face.html#ad4426ef99f2611353a16a374a5c2c2fb">01457</a> <span class="keywordtype">void</span> <a class="code" href="classChamp__Face.html#ad4426ef99f2611353a16a374a5c2c2fb">Champ_Face::calcul_grad_u</a>(<span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; vitesse, <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; grad_u, <span class="keyword">const</span> <a class="code" href="classZone__Cl__VDF.html" title="&lt; namespace TypeAreteCoinVDF">Zone_Cl_VDF</a>&amp; zone_Cl_VDF)
<a name="l01458"></a>01458 {
<a name="l01459"></a>01459   <span class="keyword">const</span> <a class="code" href="classZone__VDF.html" title="class Zone_VDF Classe instanciable qui derive de Zone_VF. Cette classe contient les informations geom...">Zone_VDF</a>&amp; zone_VDF = <a class="code" href="classChamp__Face.html#a84b6abcd128000e1d5759caaa7ae0dee">la_zone_VDF</a>.<a class="code" href="classRef__Zone__VDF.html#a84151da4db745d02791d6246e3682b67">valeur</a>();
<a name="l01460"></a>01460   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_elem = zone_VDF.<a class="code" href="classZone__dis__base.html#a790cb2f6bc2928518799e748313d0eb3">nb_elem</a>();
<a name="l01461"></a>01461   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_elem_tot = zone_VDF.<a class="code" href="classZone__dis__base.html#a4d6aa445f152aa6dc54d66ea7a071147">nb_elem_tot</a>();
<a name="l01462"></a>01462 
<a name="l01463"></a>01463   <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a> gradient_elem(nb_elem_tot,<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>,<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>);
<a name="l01464"></a>01464   gradient_elem=0.;
<a name="l01465"></a>01465 
<a name="l01466"></a>01466   <a class="code" href="classChamp__Face.html#a97fa360dcacec544bd83d2da89a7769c">calcul_duidxj</a>(vitesse,gradient_elem,zone_Cl_VDF);
<a name="l01467"></a>01467 
<a name="l01468"></a>01468   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> elem=0; elem&lt;nb_elem; elem++)
<a name="l01469"></a>01469     {
<a name="l01470"></a>01470       <span class="keywordtype">int</span> comp=0;
<a name="l01471"></a>01471       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; i++)
<a name="l01472"></a>01472         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j=0; j&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; j++)
<a name="l01473"></a>01473           {
<a name="l01474"></a>01474             grad_u(elem,comp) = gradient_elem(elem,i,j);
<a name="l01475"></a>01475             comp++;
<a name="l01476"></a>01476           }
<a name="l01477"></a>01477     }
<a name="l01478"></a>01478 }
<a name="l01479"></a>01479 
</pre></div></div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Tue Dec 14 2021 19:35:37 for TRUST by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
