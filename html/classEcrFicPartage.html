<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>TRUST: EcrFicPartage Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">TRUST&#160;<span id="projectnumber">1.8.4</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a>  </div>
  <div class="headertitle">
<div class="title">EcrFicPartage Class Reference</div>  </div>
</div>
<div class="contents">
<!-- doxytag: class="EcrFicPartage" --><!-- doxytag: inherits="SFichier" -->
<p><code>#include &lt;<a class="el" href="EcrFicPartage_8h_source.html">EcrFicPartage.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for EcrFicPartage:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classEcrFicPartage.png" usemap="#EcrFicPartage_map" alt=""/>
  <map id="EcrFicPartage_map" name="EcrFicPartage_map">
<area href="classSFichier.html" title="Cette classe est a la classe C++ ofstream ce que la classe Sortie est a la classe C++ ostream Elle re..." alt="SFichier" shape="rect" coords="68,168,194,192"/>
<area href="classSortie__Fichier__base.html" alt="Sortie_Fichier_base" shape="rect" coords="68,112,194,136"/>
<area href="classSortie.html" title="Classe de base des flux de sortie. Elle sait ecrire des types simples&lt;br&gt;(entiers, flottants) et des Ob..." alt="Sortie" shape="rect" coords="0,56,126,80"/>
<area href="classObjet__U.html" title="classe Objet_U Cette classe est la classe de base des Objets de TRUST Dans les classes derivees de Ob..." alt="Objet_U" shape="rect" coords="136,56,262,80"/>
<area href="classProcess.html" title="Classe de base de TRUST (notamment Objet_U). Elle fournit quelques services de base accessibles de pa..." alt="Process" shape="rect" coords="136,0,262,24"/>
<area href="classEcrFicPartageBin.html" title="Ecriture dans un fichier partage Cette classe derive de Ecr_Fic_Par, en utilisant une sortie en binai..." alt="EcrFicPartageBin" shape="rect" coords="68,280,194,304"/>
</map>
 </div></div>

<p><a href="classEcrFicPartage-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEcrFicPartage.html#ab011af8fedecd133790f92166030ec74">taille_memoire</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEcrFicPartage.html#a2e278f5777ab2f241e03d195beba4a9b">duplique</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classType__info.html">Type_info</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEcrFicPartage.html#adc8bdff66a90051bf150233bc54d806a">get_info</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Donne des informations sur le type de l'Objet_U.  <a href="#adc8bdff66a90051bf150233bc54d806a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEcrFicPartage.html#ad13ad4c0968c94a9904900187b06b442">EcrFicPartage</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEcrFicPartage.html#a3d0605e5fc538ffef780121e45724e0e">EcrFicPartage</a> (const char *name, std::_Ios_Openmode mode=ios::out)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructeur<br/>
Ouvre le fichier avec les parametres mode et prot donnes<br/>
Ces parametres sont les parametres de la methode open standard.  <a href="#a3d0605e5fc538ffef780121e45724e0e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEcrFicPartage.html#aae9fd9a7163d0edcb12e0235a2eabdfa">ouvrir</a> (const char *name, std::_Ios_Openmode mode=ios::out)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Ouvre le fichier avec les parametres mode et prot donnes<br/>
Ces parametres sont les parametres de la methode open standard.  <a href="#aae9fd9a7163d0edcb12e0235a2eabdfa"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEcrFicPartage.html#aceaf0416c7b90a4270cb7b714e70e440">~EcrFicPartage</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">ferme le fichier  <a href="#aceaf0416c7b90a4270cb7b714e70e440"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEcrFicPartage.html#aa1268f27f87790ead9fc158587252134">close</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSortie.html">Sortie</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEcrFicPartage.html#a94805a085e3c4312dc43cb65217b8d1b">lockfile</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Permet au processus appelant de bloquer en attente de la ressource commune a tous les processus qui est le fichier partage.<br/>
Si le processus appelant cette methode n'est pas le premier, il atend du processus precedent l'endroit ou il doit se positionner dans le fichier pour effectuer sa prochaine ecriture.<br/>
Cette methode est systematiquement appelee avant toute nouvelle ecriture dans le fichier.  <a href="#a94805a085e3c4312dc43cb65217b8d1b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSortie.html">Sortie</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEcrFicPartage.html#a9e949d929e1f36fad99b492c32caea50">unlockfile</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Permet de debloquer la ressource critique pour leprocessus suivant.<br/>
Le processus appelant, sauf si c'est le premier processus du groupe, envoie<br/>
sa position courante au precessus suivant dans le groupe. Cette methode est<br/>
a appeler apres chaque ecriture dans le fichier.  <a href="#a9e949d929e1f36fad99b492c32caea50"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSortie.html">Sortie</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEcrFicPartage.html#a76131150f8293c86eb36f4b45125183d">syncfile</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Provoque l'ecriture sur disque des donnees accumulees sur les differents processeurs<br/>
depuis le dernier appel a <a class="el" href="classEcrFicPartage.html#a76131150f8293c86eb36f4b45125183d" title="Provoque l&#39;ecriture sur disque des donnees accumulees sur les differents processeurs depuis le dernie...">syncfile()</a>.<br/>
Les donnees sont ecrites dans l'ordre croissant des processeurs.<br/>
Cette fonction doit etre appelee le meme nombre de fois sur tous les processeurs !<br/>
Exemple:<br/>
processeur 0: processeur 1:<br/>
file &lt;&lt; "pe0 : 1" &lt;&lt; finl; file &lt;&lt; "pe1 : 1" &lt;&lt; finl;<br/>
file &lt;&lt; "pe0 : 2" &lt;&lt; finl; file &lt;&lt; "pe1 : 2" &lt;&lt; finl;<br/>
file.syncfile(); file.syncfile();<br/>
file &lt;&lt; "pe0 : 3" &lt;&lt; finl; file &lt;&lt; "pe1 : 3" &lt;&lt; finl;<br/>
file &lt;&lt; "pe0 : 4" &lt;&lt; finl;<br/>
file.syncfile(); file.syncfile();<br/>
file &lt;&lt; "pe0 : end" &lt;&lt; finl; // le processeur 1 n'ecrit pas de donnees<br/>
file.syncfile(); file.syncfile();<br/>
Contenu du fichier :<br/>
pe0 : 1<br/>
pe0 : 2<br/>
pe1 : 1<br/>
pe1 : 2<br/>
pe0 : 3<br/>
pe0 : 4<br/>
pe1 : 3<br/>
pe0 : end.  <a href="#a76131150f8293c86eb36f4b45125183d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEcrFicPartage.html#a8c1c382e3081ddf0ea26cf119d370e59">precision</a> (int)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEcrFicPartage.html#a811959dea3aa5f0ea0054a0b4dd16739">get_precision</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSortie.html">Sortie</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEcrFicPartage.html#a19beb0cfbe321168ef1bd1d9ab59e69b">flush</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Force l'ecriture sur disque des donnees dans le tampon<br/>
Utilise l'implementation de la classe ofstream.  <a href="#a19beb0cfbe321168ef1bd1d9ab59e69b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEcrFicPartage.html#adb24de67c7f2227a9128cdd84a710616">set_bin</a> (int bin)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Change le mode d'ecriture du fichier.<br/>
Cette methode peut etre appelee n'importe quand. Attention<br/>
cependant pour les fichiers Ecrire_Fichier_Partage :<br/>
il faut faire le changement uniquement au debut de l'ecriture<br/>
d'un bloc, juste apres <a class="el" href="classEcrFicPartage.html#a76131150f8293c86eb36f4b45125183d" title="Provoque l&#39;ecriture sur disque des donnees accumulees sur les differents processeurs depuis le dernie...">syncfile()</a> (sinon, mauvaise traduction<br/>
des retours a la ligne lors du syncfile suivant).  <a href="#adb24de67c7f2227a9128cdd84a710616"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSortie.html">Sortie</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEcrFicPartage.html#a3b5541a6972a356191be34d6578f755e">operator&lt;&lt;</a> (const <a class="el" href="classSeparateur.html">Separateur</a> &amp;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSortie.html">Sortie</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEcrFicPartage.html#ad1ab873008c81030c1b0f40c03eda449">operator&lt;&lt;</a> (const int &amp;ob)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Methode de bas niveau pour ecrire un int ou flottant dans le stream.<br/>
Dans l'implementation de la classe de base, on ecrit dans ostream_.<br/>
En binaire on utilise ostream::write(), en ascii ostream::operato&lt;&lt;()  <a href="#ad1ab873008c81030c1b0f40c03eda449"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSortie.html">Sortie</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEcrFicPartage.html#a55c2e94b2db5cd07c22536c0deb4e892">operator&lt;&lt;</a> (const unsigned &amp;ob)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Methode de bas niveau pour ecrire un int ou flottant dans le stream.<br/>
Dans l'implementation de la classe de base, on ecrit dans ostream_.<br/>
En binaire on utilise ostream::write(), en ascii ostream::operato&lt;&lt;()  <a href="#a55c2e94b2db5cd07c22536c0deb4e892"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSortie.html">Sortie</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEcrFicPartage.html#a1a80508e8e357c4b7080f7d56130fcf1">operator&lt;&lt;</a> (const long &amp;ob)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Methode de bas niveau pour ecrire un int ou flottant dans le stream.<br/>
Dans l'implementation de la classe de base, on ecrit dans ostream_.<br/>
En binaire on utilise ostream::write(), en ascii ostream::operato&lt;&lt;()  <a href="#a1a80508e8e357c4b7080f7d56130fcf1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSortie.html">Sortie</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEcrFicPartage.html#aaf70923fb42404699be6dbdceb4d7027">operator&lt;&lt;</a> (const float &amp;ob)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Methode de bas niveau pour ecrire un int ou flottant dans le stream.<br/>
Dans l'implementation de la classe de base, on ecrit dans ostream_.<br/>
En binaire on utilise ostream::write(), en ascii ostream::operato&lt;&lt;()  <a href="#aaf70923fb42404699be6dbdceb4d7027"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSortie.html">Sortie</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEcrFicPartage.html#a189eb76a59ec0d7d870b405526767d9d">operator&lt;&lt;</a> (const double &amp;ob)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Methode de bas niveau pour ecrire un int ou flottant dans le stream.<br/>
Dans l'implementation de la classe de base, on ecrit dans ostream_.<br/>
En binaire on utilise ostream::write(), en ascii ostream::operato&lt;&lt;()  <a href="#a189eb76a59ec0d7d870b405526767d9d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSortie.html">Sortie</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEcrFicPartage.html#adc2129c198646c93d58443bc3285c158">operator&lt;&lt;</a> (const char *ob)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Ecriture d'une chaine de caracteres. Attention, pour pouvoir<br/>
relire correctement la chaine en mode ascii, celle-ci ne doit<br/>
pas contenir de separateur (ni espace, ni retour a la ligne, ...)  <a href="#adc2129c198646c93d58443bc3285c158"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSortie.html">Sortie</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEcrFicPartage.html#a0a89ccff21e560d07025565deacb18e8">operator&lt;&lt;</a> (const <a class="el" href="classObjet__U.html">Objet_U</a> &amp;ob)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Ecriture d'un objet ou d'une variable.<br/>
Dans cette implementation (et dans la plupart des classes derivees)<br/>
on appelle simplement ob.printOn (a l'exception de <a class="el" href="classSortie__Nulle.html" title="Classe derivee de Sortie qui ne sort les donnees nulle part (c&#39;est une poubelle) Classe utilisee dans...">Sortie_Nulle</a>)<br/>
Attention, si on veut que le flux puisse etre indifferemment ASCII ou BINAIRE,<br/>
il faut inserer "\&lt;\&lt; space \&lt;\&lt;" ou "\&lt;\&lt; finl \&lt;\&lt;" pour separer les objets.  <a href="#a0a89ccff21e560d07025565deacb18e8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEcrFicPartage.html#a094c8d2595ad65459f6a4ec3f95116fb">put</a> (const unsigned *ob, int n, int pas)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Methode de bas niveau pour ecrire un tableau d'ints ou reels dans le stream.<br/>
Dans l'implementation de la classe de base, on ecrit dans ostream_.<br/>
En binaire on utilise ostream::write(), en ascii ostream::operato&lt;&lt;()<br/>
En ascii, on revient a la ligne chaque fois qu'on a ecrit "nb_col" valeurs et a la<br/>
fin du tableau.<br/>
Valeur de retour : ostream_-&gt;good()  <a href="#a094c8d2595ad65459f6a4ec3f95116fb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEcrFicPartage.html#ab64aaefd82509f7eefe9f6b00d644218">put</a> (const int *ob, int n, int pas)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Methode de bas niveau pour ecrire un tableau d'ints ou reels dans le stream.<br/>
Dans l'implementation de la classe de base, on ecrit dans ostream_.<br/>
En binaire on utilise ostream::write(), en ascii ostream::operato&lt;&lt;()<br/>
En ascii, on revient a la ligne chaque fois qu'on a ecrit "nb_col" valeurs et a la<br/>
fin du tableau.<br/>
Valeur de retour : ostream_-&gt;good()  <a href="#ab64aaefd82509f7eefe9f6b00d644218"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEcrFicPartage.html#a0aa8991f02d9c6833c6aef4d36d15b4e">put</a> (const long *ob, int n, int pas)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Methode de bas niveau pour ecrire un tableau d'ints ou reels dans le stream.<br/>
Dans l'implementation de la classe de base, on ecrit dans ostream_.<br/>
En binaire on utilise ostream::write(), en ascii ostream::operato&lt;&lt;()<br/>
En ascii, on revient a la ligne chaque fois qu'on a ecrit "nb_col" valeurs et a la<br/>
fin du tableau.<br/>
Valeur de retour : ostream_-&gt;good()  <a href="#a0aa8991f02d9c6833c6aef4d36d15b4e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEcrFicPartage.html#adffdcc51062693ba00cbd35ab46256c6">put</a> (const float *ob, int n, int pas)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Methode de bas niveau pour ecrire un tableau d'ints ou reels dans le stream.<br/>
Dans l'implementation de la classe de base, on ecrit dans ostream_.<br/>
En binaire on utilise ostream::write(), en ascii ostream::operato&lt;&lt;()<br/>
En ascii, on revient a la ligne chaque fois qu'on a ecrit "nb_col" valeurs et a la<br/>
fin du tableau.<br/>
Valeur de retour : ostream_-&gt;good()  <a href="#adffdcc51062693ba00cbd35ab46256c6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEcrFicPartage.html#a2ffd89cb7d702874733b578564b570d1">put</a> (const double *ob, int n, int pas)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Methode de bas niveau pour ecrire un tableau d'ints ou reels dans le stream.<br/>
Dans l'implementation de la classe de base, on ecrit dans ostream_.<br/>
En binaire on utilise ostream::write(), en ascii ostream::operato&lt;&lt;()<br/>
En ascii, on revient a la ligne chaque fois qu'on a ecrit "nb_col" valeurs et a la<br/>
fin du tableau.<br/>
Valeur de retour : ostream_-&gt;good()  <a href="#a2ffd89cb7d702874733b578564b570d1"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classObjet__U.html">Objet_U</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEcrFicPartage.html#af446e697fca7a05e0af136e31ef6c94e">cree_instance</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classType__info.html">Type_info</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEcrFicPartage.html#a3a2539fd4af5af366d0e13243bad8bec">info</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Donne des informations sur le type de l'Objet_U.  <a href="#a3a2539fd4af5af366d0e13243bad8bec"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classEcrFicPartage.html">EcrFicPartage</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEcrFicPartage.html#afa97df57b8b28ad33808d6e06c78d9e5">self_cast</a> (<a class="el" href="classObjet__U.html">Objet_U</a> &amp;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classEcrFicPartage.html">EcrFicPartage</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEcrFicPartage.html#a6f9978b776dada7412d1f0ae41bf4ee3">self_cast</a> (const <a class="el" href="classObjet__U.html">Objet_U</a> &amp;)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">methode ajoutee pour caster en python  <a href="#a6f9978b776dada7412d1f0ae41bf4ee3"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classType__info.html">Type_info</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEcrFicPartage.html#af7001bb72377d9abbd05f6b5d078e1dc">info_obj</a></td></tr>
<tr><td colspan="2"><h2><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classSortie.html">Sortie</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEcrFicPartage.html#af73850d5cd351152f6ce39c3bc070538">printOn</a> (<a class="el" href="classSortie.html">Sortie</a> &amp;x) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Ecriture de l'objet sur un flot de sortie<br/>
Methode a surcharger.  <a href="#af73850d5cd351152f6ce39c3bc070538"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classEntree.html">Entree</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEcrFicPartage.html#ad5ef0fd6736fef7d84261a529baf0a70">readOn</a> (<a class="el" href="classEntree.html">Entree</a> &amp;)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Lecture d'un <a class="el" href="classObjet__U.html" title="classe Objet_U Cette classe est la classe de base des Objets de TRUST Dans les classes derivees de Ob...">Objet_U</a> sur un flot d'entree<br/>
Methode a surcharger.  <a href="#ad5ef0fd6736fef7d84261a529baf0a70"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classNom.html">Nom</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEcrFicPartage.html#a9ccc856a8ece1ab74bd5168532e3a0e1">nom_fic_</a></td></tr>
<tr><td colspan="2"><h2><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOBuffer.html">OBuffer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEcrFicPartage.html#a9ebbbdcb9b4aedc112671e2f075944d4">get_obuffer</a> ()</td></tr>
<tr><td colspan="2"><h2><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOBuffer.html">OBuffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEcrFicPartage.html#a1991e2a3b5a5a12278155b6ed8fb0b3e">obuffer_ptr_</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointeur : permet de ne pas inclure <a class="el" href="OBuffer_8h.html">OBuffer.h</a>.  <a href="#a1991e2a3b5a5a12278155b6ed8fb0b3e"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock">
<p>Definition at line <a class="el" href="EcrFicPartage_8h_source.html#l00045">45</a> of file <a class="el" href="EcrFicPartage_8h_source.html">EcrFicPartage.h</a>.</p>
</div><hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ad13ad4c0968c94a9904900187b06b442"></a><!-- doxytag: member="EcrFicPartage::EcrFicPartage" ref="ad13ad4c0968c94a9904900187b06b442" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EcrFicPartage::EcrFicPartage </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="EcrFicPartage_8cpp_source.html#l00044">44</a> of file <a class="el" href="EcrFicPartage_8cpp_source.html">EcrFicPartage.cpp</a>.</p>

<p>References <a class="el" href="EcrFicPartage_8h_source.html#l00091">obuffer_ptr_</a>, and <a class="el" href="EcrFicPartage_8cpp_source.html#l00411">set_bin()</a>.</p>
<div class="fragment"><pre class="fragment">                             : <a class="code" href="classSFichier.html#a3b95ef6bdb32e6e59f0d85ac903aafb7">SFichier</a>()
{
  <a class="code" href="classEcrFicPartage.html#a1991e2a3b5a5a12278155b6ed8fb0b3e" title="Pointeur : permet de ne pas inclure OBuffer.h.">obuffer_ptr_</a> = <span class="keyword">new</span> <a class="code" href="classOBuffer.html">OBuffer</a>;
  <a class="code" href="classEcrFicPartage.html#adb24de67c7f2227a9128cdd84a710616" title="Change le mode d&#39;ecriture du fichier. Cette methode peut etre appelee n&#39;importe quand. Attention cependant pour les fichiers Ecrire_Fichier_Partage : il faut faire le changement uniquement au debut de l&#39;ecriture d&#39;un bloc, juste apres syncfile() (sinon, mauvaise traduction des retours a la ligne lors du syncfile suivant).">set_bin</a>(0);
}
</pre></div>
</div>
</div>
<a class="anchor" id="a3d0605e5fc538ffef780121e45724e0e"></a><!-- doxytag: member="EcrFicPartage::EcrFicPartage" ref="a3d0605e5fc538ffef780121e45724e0e" args="(const char *name, std::_Ios_Openmode mode=ios::out)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EcrFicPartage::EcrFicPartage </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::_Ios_Openmode&#160;</td>
          <td class="paramname"><em>mode</em> = <code>ios::out</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructeur<br/>
Ouvre le fichier avec les parametres mode et prot donnes<br/>
Ces parametres sont les parametres de la methode open standard. </p>

<p>Definition at line <a class="el" href="EcrFicPartage_8cpp_source.html#l00054">54</a> of file <a class="el" href="EcrFicPartage_8cpp_source.html">EcrFicPartage.cpp</a>.</p>

<p>References <a class="el" href="EcrFicPartage_8h_source.html#l00091">obuffer_ptr_</a>, <a class="el" href="EcrFicPartage_8cpp_source.html#l00073">ouvrir()</a>, and <a class="el" href="EcrFicPartage_8cpp_source.html#l00411">set_bin()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <a class="code" href="classEcrFicPartage.html#a1991e2a3b5a5a12278155b6ed8fb0b3e" title="Pointeur : permet de ne pas inclure OBuffer.h.">obuffer_ptr_</a> = <span class="keyword">new</span> <a class="code" href="classOBuffer.html">OBuffer</a>;
  <a class="code" href="classEcrFicPartage.html#adb24de67c7f2227a9128cdd84a710616" title="Change le mode d&#39;ecriture du fichier. Cette methode peut etre appelee n&#39;importe quand. Attention cependant pour les fichiers Ecrire_Fichier_Partage : il faut faire le changement uniquement au debut de l&#39;ecriture d&#39;un bloc, juste apres syncfile() (sinon, mauvaise traduction des retours a la ligne lors du syncfile suivant).">set_bin</a>(0);

  <a class="code" href="classEcrFicPartage.html#aae9fd9a7163d0edcb12e0235a2eabdfa" title="Ouvre le fichier avec les parametres mode et prot donnes Ces parametres sont les parametres de la met...">ouvrir</a>(name, mode);
}
</pre></div>
</div>
</div>
<a class="anchor" id="aceaf0416c7b90a4270cb7b714e70e440"></a><!-- doxytag: member="EcrFicPartage::~EcrFicPartage" ref="aceaf0416c7b90a4270cb7b714e70e440" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EcrFicPartage::~EcrFicPartage </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>ferme le fichier </p>

<p>Definition at line <a class="el" href="EcrFicPartage_8cpp_source.html#l00104">104</a> of file <a class="el" href="EcrFicPartage_8cpp_source.html">EcrFicPartage.cpp</a>.</p>

<p>References <a class="el" href="EcrFicPartage_8cpp_source.html#l00115">close()</a>, and <a class="el" href="EcrFicPartage_8h_source.html#l00091">obuffer_ptr_</a>.</p>
<div class="fragment"><pre class="fragment">{

  <a class="code" href="classEcrFicPartage.html#aa1268f27f87790ead9fc158587252134">close</a>();
  <span class="keyword">delete</span> <a class="code" href="classEcrFicPartage.html#a1991e2a3b5a5a12278155b6ed8fb0b3e" title="Pointeur : permet de ne pas inclure OBuffer.h.">obuffer_ptr_</a>;
  <a class="code" href="classEcrFicPartage.html#a1991e2a3b5a5a12278155b6ed8fb0b3e" title="Pointeur : permet de ne pas inclure OBuffer.h.">obuffer_ptr_</a> = 0;


}
</pre></div>
</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="aa1268f27f87790ead9fc158587252134"></a><!-- doxytag: member="EcrFicPartage::close" ref="aa1268f27f87790ead9fc158587252134" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EcrFicPartage::close </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="classSortie__Fichier__base.html#ac246a47c4438e3183322c20db2a3323c">Sortie_Fichier_base</a>.</p>

<p>Definition at line <a class="el" href="EcrFicPartage_8cpp_source.html#l00115">115</a> of file <a class="el" href="EcrFicPartage_8cpp_source.html">EcrFicPartage.cpp</a>.</p>

<p>References <a class="el" href="Process_8cpp_source.html#l00127">Process::barrier()</a>, <a class="el" href="EntreeSortie_8h_source.html#l00032">Cerr</a>, <a class="el" href="Process_8cpp_source.html#l00223">Process::exit()</a>, <a class="el" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>, <a class="el" href="EcrFicPartage_8cpp_source.html#l00062">get_obuffer()</a>, <a class="el" href="Process_8cpp_source.html#l00095">Process::je_suis_maitre()</a>, <a class="el" href="OBuffer_8cpp_source.html#l00101">OBuffer::len()</a>, <a class="el" href="Process_8cpp_source.html#l00117">Process::me()</a>, <a class="el" href="Process_8cpp_source.html#l00178">Process::mp_sum()</a>, <a class="el" href="EcrFicPartage_8h_source.html#l00087">nom_fic_</a>, <a class="el" href="OBuffer_8cpp_source.html#l00093">OBuffer::str()</a>, and <a class="el" href="EcrFicPartage_8cpp_source.html#l00216">syncfile()</a>.</p>

<p>Referenced by <a class="el" href="Traitement__particulier__NS__chmoy__faceperio__VEF_8cpp_source.html#l00111">Traitement_particulier_NS_chmoy_faceperio_VEF::calcul_chmoy_faceperio()</a>, <a class="el" href="Zone__VEF__PreP1b_8cpp_source.html#l00328">Zone_VEF_PreP1b::construire_ok_arete()</a>, <a class="el" href="Equation__base_8cpp_source.html#l00383">Equation_base::ecrire_fichier_xyz()</a>, <a class="el" href="Traitement__particulier__NS__chmoy__faceperio__VEF_8cpp_source.html#l00077">Traitement_particulier_NS_chmoy_faceperio_VEF::init_calcul_stats()</a>, and <a class="el" href="EcrFicPartage_8cpp_source.html#l00104">~EcrFicPartage()</a>.</p>
<div class="fragment"><pre class="fragment">{
<span class="comment">// Verification sanitaire : tout le monde est la ?</span>
  <a class="code" href="classProcess.html#aa9e74a5c06a68ea38298a08ea401e7b1" title="Synchronise tous les processeurs du groupe courant&lt;br&gt;(attend que tous les processeurs soient arrives...">barrier</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> buflen = <a class="code" href="classEcrFicPartage.html#a9ebbbdcb9b4aedc112671e2f075944d4">get_obuffer</a>().<a class="code" href="classOBuffer.html#a109d45b98ea859e3f95c3e0bbd0536ee">len</a>();
  <span class="keywordflow">if</span>(buflen &gt; 0)
    {
      <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;***** WARNING : EcrFicPartage::close() ******* &quot;</span>&lt;&lt;<a class="code" href="classEcrFicPartage.html#a9ccc856a8ece1ab74bd5168532e3a0e1">nom_fic_</a>
           &lt;&lt; <span class="stringliteral">&quot;\non PE &quot;</span> &lt;&lt; <a class="code" href="classProcess.html#ab55ba07167ec807ed3a145cac0f5dca4" title="renvoie mon rang dans le groupe de communication courant. Voir Comm_Group::rank() et PE_Groups::curre...">me</a>() &lt;&lt; <span class="stringliteral">&quot; the buffer is not empty\n&quot;</span>
           &lt;&lt; <span class="stringliteral">&quot;  (Missing syncfile) : one makes a last syncfile&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
      <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a>&lt;&lt;<a class="code" href="classEcrFicPartage.html#a9ebbbdcb9b4aedc112671e2f075944d4">get_obuffer</a>().<a class="code" href="classOBuffer.html#a9d360f12115bd70e3564148554f46dd5" title="Renvoie un pointeur sur le debut du buffer.">str</a>()&lt;&lt;finl;
    }
<span class="preprocessor">#ifndef NDEBUG</span>
<span class="preprocessor"></span><span class="comment">// Y a-t-il un processeur sur lequel il reste des donnees</span>
  <span class="keyword">const</span> <span class="keywordtype">int</span> maxbuflen = <a class="code" href="classProcess.html#a7d23bc1ef94b3f0623fbc79d034c27fd" title="Calcule la somme de x sur tous les processeurs du groupe courant. Voir aussi mp_max()">mp_sum</a>(buflen);
  <span class="keywordflow">if</span> (maxbuflen &gt; 0)
    <a class="code" href="classEcrFicPartage.html#a76131150f8293c86eb36f4b45125183d" title="Provoque l&#39;ecriture sur disque des donnees accumulees sur les differents processeurs depuis le dernie...">syncfile</a>();
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>  <span class="keywordflow">if</span>(<a class="code" href="classProcess.html#acd052b99706c577f8a5b6656217cf4c2" title="renvoie 1 si on est sur le processeur maitre du groupe courant (c&#39;est a dire me() == 0)...">je_suis_maitre</a>())
    <a class="code" href="classEcrFicPartage.html#aa1268f27f87790ead9fc158587252134">SFichier::close</a>();
<span class="preprocessor">#ifndef NDEBUG</span>
<span class="preprocessor"></span>  <span class="keywordflow">if</span> (maxbuflen &gt; 0)
    {
      <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a>&lt;&lt;<span class="stringliteral">&quot;It missed a syncfile somewhere&quot;</span>&lt;&lt;finl;
      <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a>&lt;&lt;<span class="stringliteral">&quot;Indeed, maxbuflen =&quot;</span> &lt;&lt; maxbuflen &lt;&lt; finl;
      <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a>&lt;&lt;<span class="stringliteral">&quot;GF prefers to stop the calculation to correct &quot;</span>&lt;&lt;finl;
      <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">exit</a>();
    }
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>}
</pre></div>
</div>
</div>
<a class="anchor" id="af446e697fca7a05e0af136e31ef6c94e"></a><!-- doxytag: member="EcrFicPartage::cree_instance" ref="af446e697fca7a05e0af136e31ef6c94e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classObjet__U.html">Objet_U</a> * EcrFicPartage::cree_instance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="classSFichier.html#a7e88828cf1ded012a80b30b17f34e1ff">SFichier</a>.</p>

<p>Reimplemented in <a class="el" href="classEcrFicPartageBin.html#a0713bb96e821d2761f6964cd7d3d7308">EcrFicPartageBin</a>.</p>

<p>Definition at line <a class="el" href="EcrFicPartage_8cpp_source.html#l00032">32</a> of file <a class="el" href="EcrFicPartage_8cpp_source.html">EcrFicPartage.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2e278f5777ab2f241e03d195beba4a9b"></a><!-- doxytag: member="EcrFicPartage::duplique" ref="a2e278f5777ab2f241e03d195beba4a9b" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int EcrFicPartage::duplique </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="classSFichier.html#a726eae8177896e823586ae13d5335438">SFichier</a>.</p>

<p>Reimplemented in <a class="el" href="classEcrFicPartageBin.html#af6abf6791840b5e3da62642ce0376440">EcrFicPartageBin</a>.</p>

<p>Definition at line <a class="el" href="EcrFicPartage_8cpp_source.html#l00032">32</a> of file <a class="el" href="EcrFicPartage_8cpp_source.html">EcrFicPartage.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a19beb0cfbe321168ef1bd1d9ab59e69b"></a><!-- doxytag: member="EcrFicPartage::flush" ref="a19beb0cfbe321168ef1bd1d9ab59e69b" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSortie.html">Sortie</a> &amp; EcrFicPartage::flush </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Force l'ecriture sur disque des donnees dans le tampon<br/>
Utilise l'implementation de la classe ofstream. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="classSortie.html" title="Classe de base des flux de sortie. Elle sait ecrire des types simples&lt;br&gt;(entiers, flottants) et des Ob...">Sortie</a>&amp;<br/>
 Signification: *this<br/>
 Contraintes: </dd></dl>

<p>Reimplemented from <a class="el" href="classSortie__Fichier__base.html#a8efa6533c9a25aa6c4ee3c5f8783f5f7">Sortie_Fichier_base</a>.</p>

<p>Definition at line <a class="el" href="EcrFicPartage_8cpp_source.html#l00419">419</a> of file <a class="el" href="EcrFicPartage_8cpp_source.html">EcrFicPartage.cpp</a>.</p>

<p>Referenced by <a class="el" href="Format__Post__XYZ_8cpp_source.html#l00292">Format_Post_XYZ::ecrire_champ_xyz()</a>, <a class="el" href="Format__Post__Lml_8cpp_source.html#l00266">Format_Post_Lml::ecrire_domaine_lml()</a>, <a class="el" href="Format__Post__Lml_8cpp_source.html#l00214">Format_Post_Lml::ecrire_entete_lml()</a>, <a class="el" href="Format__Post__Lml_8cpp_source.html#l00601">Format_Post_Lml::ecrire_item_int_lml()</a>, <a class="el" href="Format__Post__Lml_8cpp_source.html#l00451">Format_Post_Lml::ecrire_temps_lml()</a>, and <a class="el" href="Format__Post__Lml_8cpp_source.html#l00236">Format_Post_Lml::finir_lml()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">return</span> (*<span class="keyword">this</span>);
}
</pre></div>
</div>
</div>
<a class="anchor" id="adc8bdff66a90051bf150233bc54d806a"></a><!-- doxytag: member="EcrFicPartage::get_info" ref="adc8bdff66a90051bf150233bc54d806a" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classType__info.html">Type_info</a> * EcrFicPartage::get_info </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Donne des informations sur le type de l'Objet_U. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>const Type_info*<br/>
 Signification: structure regroupant les informations sur le type de l'Objet_U<br/>
 Contraintes: </dd></dl>

<p>Reimplemented from <a class="el" href="classSFichier.html#a31f7468135f288d1fa00677c97a04bd1">SFichier</a>.</p>

<p>Reimplemented in <a class="el" href="classEcrFicPartageBin.html#a9e89aceeac61d0c0ce73a8d5f00249f0">EcrFicPartageBin</a>.</p>

<p>Definition at line <a class="el" href="EcrFicPartage_8cpp_source.html#l00032">32</a> of file <a class="el" href="EcrFicPartage_8cpp_source.html">EcrFicPartage.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9ebbbdcb9b4aedc112671e2f075944d4"></a><!-- doxytag: member="EcrFicPartage::get_obuffer" ref="a9ebbbdcb9b4aedc112671e2f075944d4" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOBuffer.html">OBuffer</a> &amp; EcrFicPartage::get_obuffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="EcrFicPartage_8cpp_source.html#l00062">62</a> of file <a class="el" href="EcrFicPartage_8cpp_source.html">EcrFicPartage.cpp</a>.</p>

<p>References <a class="el" href="EcrFicPartage_8h_source.html#l00091">obuffer_ptr_</a>.</p>

<p>Referenced by <a class="el" href="EcrFicPartage_8cpp_source.html#l00115">close()</a>, <a class="el" href="EcrFicPartage_8cpp_source.html#l00321">get_precision()</a>, <a class="el" href="EcrFicPartage_8cpp_source.html#l00326">operator&lt;&lt;()</a>, <a class="el" href="EcrFicPartage_8cpp_source.html#l00073">ouvrir()</a>, <a class="el" href="EcrFicPartage_8cpp_source.html#l00316">precision()</a>, <a class="el" href="EcrFicPartage_8cpp_source.html#l00369">put()</a>, <a class="el" href="EcrFicPartage_8cpp_source.html#l00411">set_bin()</a>, and <a class="el" href="EcrFicPartage_8cpp_source.html#l00216">syncfile()</a>.</p>
<div class="fragment"><pre class="fragment">{
  assert(<a class="code" href="classEcrFicPartage.html#a1991e2a3b5a5a12278155b6ed8fb0b3e" title="Pointeur : permet de ne pas inclure OBuffer.h.">obuffer_ptr_</a>);
  <span class="keywordflow">return</span> *<a class="code" href="classEcrFicPartage.html#a1991e2a3b5a5a12278155b6ed8fb0b3e" title="Pointeur : permet de ne pas inclure OBuffer.h.">obuffer_ptr_</a>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a811959dea3aa5f0ea0054a0b4dd16739"></a><!-- doxytag: member="EcrFicPartage::get_precision" ref="a811959dea3aa5f0ea0054a0b4dd16739" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int EcrFicPartage::get_precision </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="classSortie__Fichier__base.html#a14d2f634a031fd5b1a9455a1bdfbf661">Sortie_Fichier_base</a>.</p>

<p>Definition at line <a class="el" href="EcrFicPartage_8cpp_source.html#l00321">321</a> of file <a class="el" href="EcrFicPartage_8cpp_source.html">EcrFicPartage.cpp</a>.</p>

<p>References <a class="el" href="EcrFicPartage_8cpp_source.html#l00062">get_obuffer()</a>, and <a class="el" href="OBuffer_8cpp_source.html#l00057">OBuffer::get_precision()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">return</span> <a class="code" href="classEcrFicPartage.html#a9ebbbdcb9b4aedc112671e2f075944d4">get_obuffer</a>().<a class="code" href="classOBuffer.html#a38e5a3f2279880dee58b3e6245dd5736">get_precision</a>();
}
</pre></div>
</div>
</div>
<a class="anchor" id="a3a2539fd4af5af366d0e13243bad8bec"></a><!-- doxytag: member="EcrFicPartage::info" ref="a3a2539fd4af5af366d0e13243bad8bec" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classType__info.html">Type_info</a> * EcrFicPartage::info </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Donne des informations sur le type de l'Objet_U. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>const Type_info*<br/>
 Signification: structure regroupant les informations sur le type de l'Objet_U<br/>
 Contraintes: </dd></dl>

<p>Reimplemented from <a class="el" href="classSFichier.html#a6f60a693cfe3261b7d24fdbb17f99f2e">SFichier</a>.</p>

<p>Reimplemented in <a class="el" href="classEcrFicPartageBin.html#a711ab5ffe7acc49b8ee032d6b2659570">EcrFicPartageBin</a>.</p>

<p>Definition at line <a class="el" href="EcrFicPartage_8cpp_source.html#l00032">32</a> of file <a class="el" href="EcrFicPartage_8cpp_source.html">EcrFicPartage.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a94805a085e3c4312dc43cb65217b8d1b"></a><!-- doxytag: member="EcrFicPartage::lockfile" ref="a94805a085e3c4312dc43cb65217b8d1b" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSortie.html">Sortie</a> &amp; EcrFicPartage::lockfile </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Permet au processus appelant de bloquer en attente de la ressource commune a tous les processus qui est le fichier partage.<br/>
Si le processus appelant cette methode n'est pas le premier, il atend du processus precedent l'endroit ou il doit se positionner dans le fichier pour effectuer sa prochaine ecriture.<br/>
Cette methode est systematiquement appelee avant toute nouvelle ecriture dans le fichier. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="classSortie.html" title="Classe de base des flux de sortie. Elle sait ecrire des types simples&lt;br&gt;(entiers, flottants) et des Ob...">Sortie</a>&amp;<br/>
 Signification: *this<br/>
 Contraintes: </dd></dl>

<p>Reimplemented from <a class="el" href="classSortie.html#a835d483aba6ab6351414e92f891bad81">Sortie</a>.</p>

<p>Definition at line <a class="el" href="EcrFicPartage_8cpp_source.html#l00161">161</a> of file <a class="el" href="EcrFicPartage_8cpp_source.html">EcrFicPartage.cpp</a>.</p>

<p>Referenced by <a class="el" href="Format__Post__Lml_8cpp_source.html#l00464">Format_Post_Lml::ecrire_champ_lml()</a>, <a class="el" href="Format__Post__Lml_8cpp_source.html#l00266">Format_Post_Lml::ecrire_domaine_lml()</a>, <a class="el" href="Equation__base_8cpp_source.html#l00383">Equation_base::ecrire_fichier_xyz()</a>, and <a class="el" href="Format__Post__Lml_8cpp_source.html#l00601">Format_Post_Lml::ecrire_item_int_lml()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">return</span> *<span class="keyword">this</span>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a3b5541a6972a356191be34d6578f755e"></a><!-- doxytag: member="EcrFicPartage::operator&lt;&lt;" ref="a3b5541a6972a356191be34d6578f755e" args="(const Separateur &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSortie.html">Sortie</a> &amp; EcrFicPartage::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSeparateur.html">Separateur</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="classSortie.html#a36ef2c9f55625cb7652c74d81f2d76de">Sortie</a>.</p>

<p>Definition at line <a class="el" href="EcrFicPartage_8cpp_source.html#l00326">326</a> of file <a class="el" href="EcrFicPartage_8cpp_source.html">EcrFicPartage.cpp</a>.</p>

<p>References <a class="el" href="EcrFicPartage_8cpp_source.html#l00062">get_obuffer()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <a class="code" href="classEcrFicPartage.html#a9ebbbdcb9b4aedc112671e2f075944d4">get_obuffer</a>() &lt;&lt; s;
  <span class="keywordflow">return</span> *<span class="keyword">this</span>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="aaf70923fb42404699be6dbdceb4d7027"></a><!-- doxytag: member="EcrFicPartage::operator&lt;&lt;" ref="aaf70923fb42404699be6dbdceb4d7027" args="(const float &amp;ob)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSortie.html">Sortie</a> &amp; EcrFicPartage::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">const float &amp;&#160;</td>
          <td class="paramname"><em>ob</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Methode de bas niveau pour ecrire un int ou flottant dans le stream.<br/>
Dans l'implementation de la classe de base, on ecrit dans ostream_.<br/>
En binaire on utilise ostream::write(), en ascii ostream::operato&lt;&lt;() </p>

<p>Reimplemented from <a class="el" href="classSortie.html#ae86c4be35ac9aea5bd8e8115fb0feae5">Sortie</a>.</p>

<p>Definition at line <a class="el" href="EcrFicPartage_8cpp_source.html#l00357">357</a> of file <a class="el" href="EcrFicPartage_8cpp_source.html">EcrFicPartage.cpp</a>.</p>

<p>References <a class="el" href="EcrFicPartage_8cpp_source.html#l00062">get_obuffer()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <a class="code" href="classEcrFicPartage.html#a9ebbbdcb9b4aedc112671e2f075944d4">get_obuffer</a>() &lt;&lt; ob;
  <span class="keywordflow">return</span> *<span class="keyword">this</span>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="ad1ab873008c81030c1b0f40c03eda449"></a><!-- doxytag: member="EcrFicPartage::operator&lt;&lt;" ref="ad1ab873008c81030c1b0f40c03eda449" args="(const int &amp;ob)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSortie.html">Sortie</a> &amp; EcrFicPartage::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>ob</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Methode de bas niveau pour ecrire un int ou flottant dans le stream.<br/>
Dans l'implementation de la classe de base, on ecrit dans ostream_.<br/>
En binaire on utilise ostream::write(), en ascii ostream::operato&lt;&lt;() </p>

<p>Reimplemented from <a class="el" href="classSortie.html#a1c0e2f2fe5f2c09566033dc2a3e861b9">Sortie</a>.</p>

<p>Definition at line <a class="el" href="EcrFicPartage_8cpp_source.html#l00338">338</a> of file <a class="el" href="EcrFicPartage_8cpp_source.html">EcrFicPartage.cpp</a>.</p>

<p>References <a class="el" href="EcrFicPartage_8cpp_source.html#l00062">get_obuffer()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <a class="code" href="classEcrFicPartage.html#a9ebbbdcb9b4aedc112671e2f075944d4">get_obuffer</a>() &lt;&lt; ob;
  <span class="keywordflow">return</span> *<span class="keyword">this</span>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a55c2e94b2db5cd07c22536c0deb4e892"></a><!-- doxytag: member="EcrFicPartage::operator&lt;&lt;" ref="a55c2e94b2db5cd07c22536c0deb4e892" args="(const unsigned &amp;ob)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSortie.html">Sortie</a> &amp; EcrFicPartage::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">const unsigned &amp;&#160;</td>
          <td class="paramname"><em>ob</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Methode de bas niveau pour ecrire un int ou flottant dans le stream.<br/>
Dans l'implementation de la classe de base, on ecrit dans ostream_.<br/>
En binaire on utilise ostream::write(), en ascii ostream::operato&lt;&lt;() </p>

<p>Reimplemented from <a class="el" href="classSortie.html#adcd343c7639877812a5822bb3b8cb49c">Sortie</a>.</p>

<p>Definition at line <a class="el" href="EcrFicPartage_8cpp_source.html#l00344">344</a> of file <a class="el" href="EcrFicPartage_8cpp_source.html">EcrFicPartage.cpp</a>.</p>

<p>References <a class="el" href="EcrFicPartage_8cpp_source.html#l00062">get_obuffer()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <a class="code" href="classEcrFicPartage.html#a9ebbbdcb9b4aedc112671e2f075944d4">get_obuffer</a>() &lt;&lt; ob;
  <span class="keywordflow">return</span> *<span class="keyword">this</span>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a1a80508e8e357c4b7080f7d56130fcf1"></a><!-- doxytag: member="EcrFicPartage::operator&lt;&lt;" ref="a1a80508e8e357c4b7080f7d56130fcf1" args="(const long &amp;ob)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSortie.html">Sortie</a> &amp; EcrFicPartage::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">const long &amp;&#160;</td>
          <td class="paramname"><em>ob</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Methode de bas niveau pour ecrire un int ou flottant dans le stream.<br/>
Dans l'implementation de la classe de base, on ecrit dans ostream_.<br/>
En binaire on utilise ostream::write(), en ascii ostream::operato&lt;&lt;() </p>

<p>Reimplemented from <a class="el" href="classSortie.html#a496d561284b31eafddf17d209ab89ebb">Sortie</a>.</p>

<p>Definition at line <a class="el" href="EcrFicPartage_8cpp_source.html#l00351">351</a> of file <a class="el" href="EcrFicPartage_8cpp_source.html">EcrFicPartage.cpp</a>.</p>

<p>References <a class="el" href="EcrFicPartage_8cpp_source.html#l00062">get_obuffer()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <a class="code" href="classEcrFicPartage.html#a9ebbbdcb9b4aedc112671e2f075944d4">get_obuffer</a>() &lt;&lt; ob;
  <span class="keywordflow">return</span> *<span class="keyword">this</span>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a189eb76a59ec0d7d870b405526767d9d"></a><!-- doxytag: member="EcrFicPartage::operator&lt;&lt;" ref="a189eb76a59ec0d7d870b405526767d9d" args="(const double &amp;ob)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSortie.html">Sortie</a> &amp; EcrFicPartage::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>ob</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Methode de bas niveau pour ecrire un int ou flottant dans le stream.<br/>
Dans l'implementation de la classe de base, on ecrit dans ostream_.<br/>
En binaire on utilise ostream::write(), en ascii ostream::operato&lt;&lt;() </p>

<p>Reimplemented from <a class="el" href="classSortie.html#a549c4d26ca7d420bad336c0edf13492d">Sortie</a>.</p>

<p>Definition at line <a class="el" href="EcrFicPartage_8cpp_source.html#l00362">362</a> of file <a class="el" href="EcrFicPartage_8cpp_source.html">EcrFicPartage.cpp</a>.</p>

<p>References <a class="el" href="EcrFicPartage_8cpp_source.html#l00062">get_obuffer()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <a class="code" href="classEcrFicPartage.html#a9ebbbdcb9b4aedc112671e2f075944d4">get_obuffer</a>() &lt;&lt; ob;
  <span class="keywordflow">return</span> *<span class="keyword">this</span>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="adc2129c198646c93d58443bc3285c158"></a><!-- doxytag: member="EcrFicPartage::operator&lt;&lt;" ref="adc2129c198646c93d58443bc3285c158" args="(const char *ob)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSortie.html">Sortie</a> &amp; EcrFicPartage::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>ob</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Ecriture d'une chaine de caracteres. Attention, pour pouvoir<br/>
relire correctement la chaine en mode ascii, celle-ci ne doit<br/>
pas contenir de separateur (ni espace, ni retour a la ligne, ...) </p>

<p>Reimplemented from <a class="el" href="classSortie.html#a42d6162d4c64ce999be1bcb4509912d0">Sortie</a>.</p>

<p>Definition at line <a class="el" href="EcrFicPartage_8cpp_source.html#l00405">405</a> of file <a class="el" href="EcrFicPartage_8cpp_source.html">EcrFicPartage.cpp</a>.</p>

<p>References <a class="el" href="EcrFicPartage_8cpp_source.html#l00062">get_obuffer()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <a class="code" href="classEcrFicPartage.html#a9ebbbdcb9b4aedc112671e2f075944d4">get_obuffer</a>() &lt;&lt; ob;
  <span class="keywordflow">return</span> *<span class="keyword">this</span>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a0a89ccff21e560d07025565deacb18e8"></a><!-- doxytag: member="EcrFicPartage::operator&lt;&lt;" ref="a0a89ccff21e560d07025565deacb18e8" args="(const Objet_U &amp;ob)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSortie.html">Sortie</a> &amp; EcrFicPartage::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classObjet__U.html">Objet_U</a> &amp;&#160;</td>
          <td class="paramname"><em>ob</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Ecriture d'un objet ou d'une variable.<br/>
Dans cette implementation (et dans la plupart des classes derivees)<br/>
on appelle simplement ob.printOn (a l'exception de <a class="el" href="classSortie__Nulle.html" title="Classe derivee de Sortie qui ne sort les donnees nulle part (c&#39;est une poubelle) Classe utilisee dans...">Sortie_Nulle</a>)<br/>
Attention, si on veut que le flux puisse etre indifferemment ASCII ou BINAIRE,<br/>
il faut inserer "\&lt;\&lt; space \&lt;\&lt;" ou "\&lt;\&lt; finl \&lt;\&lt;" pour separer les objets. </p>

<p>Reimplemented from <a class="el" href="classSortie.html#a7f429425dc28cee3daa801dbcb976b1c">Sortie</a>.</p>

<p>Definition at line <a class="el" href="EcrFicPartage_8cpp_source.html#l00332">332</a> of file <a class="el" href="EcrFicPartage_8cpp_source.html">EcrFicPartage.cpp</a>.</p>

<p>References <a class="el" href="EcrFicPartage_8cpp_source.html#l00062">get_obuffer()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <a class="code" href="classEcrFicPartage.html#a9ebbbdcb9b4aedc112671e2f075944d4">get_obuffer</a>() &lt;&lt; ob;
  <span class="keywordflow">return</span> *<span class="keyword">this</span>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="aae9fd9a7163d0edcb12e0235a2eabdfa"></a><!-- doxytag: member="EcrFicPartage::ouvrir" ref="aae9fd9a7163d0edcb12e0235a2eabdfa" args="(const char *name, std::_Ios_Openmode mode=ios::out)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int EcrFicPartage::ouvrir </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::_Ios_Openmode&#160;</td>
          <td class="paramname"><em>mode</em> = <code>ios::out</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Ouvre le fichier avec les parametres mode et prot donnes<br/>
Ces parametres sont les parametres de la methode open standard. </p>

<p>Reimplemented from <a class="el" href="classSortie__Fichier__base.html#a7e75e18ed580cd4d45912ec202caa2b2">Sortie_Fichier_base</a>.</p>

<p>Definition at line <a class="el" href="EcrFicPartage_8cpp_source.html#l00073">73</a> of file <a class="el" href="EcrFicPartage_8cpp_source.html">EcrFicPartage.cpp</a>.</p>

<p>References <a class="el" href="Process_8cpp_source.html#l00127">Process::barrier()</a>, <a class="el" href="EcrFicPartage_8cpp_source.html#l00062">get_obuffer()</a>, <a class="el" href="Process_8cpp_source.html#l00095">Process::je_suis_maitre()</a>, <a class="el" href="OBuffer_8cpp_source.html#l00041">OBuffer::new_buffer()</a>, <a class="el" href="EcrFicPartage_8h_source.html#l00087">nom_fic_</a>, <a class="el" href="arch_8cpp_source.html#l00064">pwd()</a>, and <a class="el" href="EcrFicPartage_8cpp_source.html#l00216">syncfile()</a>.</p>

<p>Referenced by <a class="el" href="Zone__VEF__PreP1b_8cpp_source.html#l00328">Zone_VEF_PreP1b::construire_ok_arete()</a>, <a class="el" href="EcrFicPartage_8cpp_source.html#l00054">EcrFicPartage()</a>, <a class="el" href="EcrFicPartageBin_8h_source.html#l00048">EcrFicPartageBin::EcrFicPartageBin()</a>, <a class="el" href="Format__Post__Lml_8cpp_source.html#l00464">Format_Post_Lml::ecrire_champ_lml()</a>, <a class="el" href="Format__Post__XYZ_8cpp_source.html#l00292">Format_Post_XYZ::ecrire_champ_xyz()</a>, <a class="el" href="Format__Post__Lml_8cpp_source.html#l00266">Format_Post_Lml::ecrire_domaine_lml()</a>, <a class="el" href="Format__Post__Lml_8cpp_source.html#l00214">Format_Post_Lml::ecrire_entete_lml()</a>, <a class="el" href="Equation__base_8cpp_source.html#l00383">Equation_base::ecrire_fichier_xyz()</a>, <a class="el" href="Format__Post__Lml_8cpp_source.html#l00601">Format_Post_Lml::ecrire_item_int_lml()</a>, <a class="el" href="Format__Post__Lml_8cpp_source.html#l00451">Format_Post_Lml::ecrire_temps_lml()</a>, <a class="el" href="Format__Post__Lml_8cpp_source.html#l00236">Format_Post_Lml::finir_lml()</a>, <a class="el" href="Turbulence__paroi__scal__base_8cpp_source.html#l00108">Turbulence_paroi_scal_base::ouvrir_fichier_partage()</a>, <a class="el" href="Turbulence__paroi__base_8cpp_source.html#l00186">Turbulence_paroi_base::ouvrir_fichier_partage()</a>, and <a class="el" href="Operateur__base_8cpp_source.html#l00528">Operateur_base::ouvrir_fichier_partage()</a>.</p>
<div class="fragment"><pre class="fragment">{
<span class="comment">// Verification sanitaire : tous les processeurs sont la ?</span>
  <a class="code" href="classProcess.html#aa9e74a5c06a68ea38298a08ea401e7b1" title="Synchronise tous les processeurs du groupe courant&lt;br&gt;(attend que tous les processeurs soient arrives...">barrier</a>();

  <span class="keywordtype">int</span> ok = 1;
  <span class="keywordflow">if</span>(<a class="code" href="classProcess.html#acd052b99706c577f8a5b6656217cf4c2" title="renvoie 1 si on est sur le processeur maitre du groupe courant (c&#39;est a dire me() == 0)...">je_suis_maitre</a>())
    {
<span class="preprocessor">#ifdef FILESYSTEM_NON_GLOBAL</span>
<span class="preprocessor"></span>      <a class="code" href="classEcrFicPartage.html#a9ccc856a8ece1ab74bd5168532e3a0e1">nom_fic_</a> = <a class="code" href="arch_8cpp.html#a7a8e98611cd2044f91732950bd1c303b" title="_ARCH_H_">pwd</a>();
      <a class="code" href="classEcrFicPartage.html#a9ccc856a8ece1ab74bd5168532e3a0e1">nom_fic_</a> += <span class="stringliteral">&quot;/&quot;</span>;
      <a class="code" href="classEcrFicPartage.html#a9ccc856a8ece1ab74bd5168532e3a0e1">nom_fic_</a> += name;
<span class="preprocessor">#else</span>
<span class="preprocessor"></span>      <a class="code" href="classEcrFicPartage.html#a9ccc856a8ece1ab74bd5168532e3a0e1">nom_fic_</a> = name;
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span><span class="comment">// Seul le maitre ouvre le fichier</span>
      ok = <a class="code" href="classEcrFicPartage.html#aae9fd9a7163d0edcb12e0235a2eabdfa" title="Ouvre le fichier avec les parametres mode et prot donnes Ces parametres sont les parametres de la met...">SFichier::ouvrir</a>((<span class="keyword">const</span> <span class="keywordtype">char</span> *)<a class="code" href="classEcrFicPartage.html#a9ccc856a8ece1ab74bd5168532e3a0e1">nom_fic_</a>, mode);
    }
  <a class="code" href="classEcrFicPartage.html#a76131150f8293c86eb36f4b45125183d" title="Provoque l&#39;ecriture sur disque des donnees accumulees sur les differents processeurs depuis le dernie...">syncfile</a>();

<span class="comment">// Modif B.Math. 22/09/2004: tous les processeurs passent par le buffer,</span>
<span class="comment">// y compris le maitre.</span>
  <a class="code" href="classEcrFicPartage.html#a9ebbbdcb9b4aedc112671e2f075944d4">get_obuffer</a>().<a class="code" href="classOBuffer.html#a7e2534175cc05e76081bc01566e5e4bc">new_buffer</a>();
  <span class="keywordflow">return</span> ok;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a8c1c382e3081ddf0ea26cf119d370e59"></a><!-- doxytag: member="EcrFicPartage::precision" ref="a8c1c382e3081ddf0ea26cf119d370e59" args="(int)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EcrFicPartage::precision </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="classSortie__Fichier__base.html#a489ca01946f4e2a7a9aa8f3a3d949b08">Sortie_Fichier_base</a>.</p>

<p>Definition at line <a class="el" href="EcrFicPartage_8cpp_source.html#l00316">316</a> of file <a class="el" href="EcrFicPartage_8cpp_source.html">EcrFicPartage.cpp</a>.</p>

<p>References <a class="el" href="EcrFicPartage_8cpp_source.html#l00062">get_obuffer()</a>, and <a class="el" href="OBuffer_8cpp_source.html#l00051">OBuffer::precision()</a>.</p>

<p>Referenced by <a class="el" href="Traitement__particulier__NS__chmoy__faceperio__VEF_8cpp_source.html#l00111">Traitement_particulier_NS_chmoy_faceperio_VEF::calcul_chmoy_faceperio()</a>, <a class="el" href="Equation__base_8cpp_source.html#l00383">Equation_base::ecrire_fichier_xyz()</a>, <a class="el" href="Traitement__particulier__NS__chmoy__faceperio__VEF_8cpp_source.html#l00077">Traitement_particulier_NS_chmoy_faceperio_VEF::init_calcul_stats()</a>, and <a class="el" href="Operateur__base_8cpp_source.html#l00528">Operateur_base::ouvrir_fichier_partage()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <a class="code" href="classEcrFicPartage.html#a9ebbbdcb9b4aedc112671e2f075944d4">get_obuffer</a>().<a class="code" href="classOBuffer.html#a37a50db9fdc60a9a2ff2cbd07ba152d8">precision</a>(i);
}
</pre></div>
</div>
</div>
<a class="anchor" id="af73850d5cd351152f6ce39c3bc070538"></a><!-- doxytag: member="EcrFicPartage::printOn" ref="af73850d5cd351152f6ce39c3bc070538" args="(Sortie &amp;x) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSortie.html">Sortie</a> &amp; EcrFicPartage::printOn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSortie.html">Sortie</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td> const<code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Ecriture de l'objet sur un flot de sortie<br/>
Methode a surcharger. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="classSortie.html" title="Classe de base des flux de sortie. Elle sait ecrire des types simples&lt;br&gt;(entiers, flottants) et des Ob...">Sortie</a>&amp;<br/>
 Signification: flot de sortie modifie<br/>
 Contraintes: </dd></dl>

<p>Reimplemented from <a class="el" href="classSFichier.html#a5842ce9f4ddfa7ba4419d38a12ab79ce">SFichier</a>.</p>

<p>Reimplemented in <a class="el" href="classEcrFicPartageBin.html#a637894c6c2a620447eabd8b448e574d9">EcrFicPartageBin</a>.</p>

<p>Definition at line <a class="el" href="EcrFicPartage_8cpp_source.html#l00039">39</a> of file <a class="el" href="EcrFicPartage_8cpp_source.html">EcrFicPartage.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">throw</span>;
  <span class="keywordflow">return</span> s;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a0aa8991f02d9c6833c6aef4d36d15b4e"></a><!-- doxytag: member="EcrFicPartage::put" ref="a0aa8991f02d9c6833c6aef4d36d15b4e" args="(const long *ob, int n, int pas)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int EcrFicPartage::put </td>
          <td>(</td>
          <td class="paramtype">const long *&#160;</td>
          <td class="paramname"><em>ob</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nb_colonnes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Methode de bas niveau pour ecrire un tableau d'ints ou reels dans le stream.<br/>
Dans l'implementation de la classe de base, on ecrit dans ostream_.<br/>
En binaire on utilise ostream::write(), en ascii ostream::operato&lt;&lt;()<br/>
En ascii, on revient a la ligne chaque fois qu'on a ecrit "nb_col" valeurs et a la<br/>
fin du tableau.<br/>
Valeur de retour : ostream_-&gt;good() </p>

<p>Reimplemented from <a class="el" href="classSortie.html#a2cfe3a4ebb18061eb88d1375b43aa839">Sortie</a>.</p>

<p>Definition at line <a class="el" href="EcrFicPartage_8cpp_source.html#l00382">382</a> of file <a class="el" href="EcrFicPartage_8cpp_source.html">EcrFicPartage.cpp</a>.</p>

<p>References <a class="el" href="EcrFicPartage_8cpp_source.html#l00062">get_obuffer()</a>, and <a class="el" href="Sortie_8cpp_source.html#l00176">Sortie::put()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <a class="code" href="classEcrFicPartage.html#a9ebbbdcb9b4aedc112671e2f075944d4">get_obuffer</a>().<a class="code" href="classSortie.html#aa3f46aaccaff0f83c018784b50d8ea24" title="Methode de bas niveau pour ecrire un tableau d&#39;ints ou reels dans le stream. Dans l&#39;implementation de...">put</a>(ob,n,pas);
  <span class="keywordflow">return</span> 1;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a094c8d2595ad65459f6a4ec3f95116fb"></a><!-- doxytag: member="EcrFicPartage::put" ref="a094c8d2595ad65459f6a4ec3f95116fb" args="(const unsigned *ob, int n, int pas)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int EcrFicPartage::put </td>
          <td>(</td>
          <td class="paramtype">const unsigned *&#160;</td>
          <td class="paramname"><em>ob</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nb_colonnes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Methode de bas niveau pour ecrire un tableau d'ints ou reels dans le stream.<br/>
Dans l'implementation de la classe de base, on ecrit dans ostream_.<br/>
En binaire on utilise ostream::write(), en ascii ostream::operato&lt;&lt;()<br/>
En ascii, on revient a la ligne chaque fois qu'on a ecrit "nb_col" valeurs et a la<br/>
fin du tableau.<br/>
Valeur de retour : ostream_-&gt;good() </p>

<p>Reimplemented from <a class="el" href="classSortie.html#aa3f46aaccaff0f83c018784b50d8ea24">Sortie</a>.</p>

<p>Definition at line <a class="el" href="EcrFicPartage_8cpp_source.html#l00369">369</a> of file <a class="el" href="EcrFicPartage_8cpp_source.html">EcrFicPartage.cpp</a>.</p>

<p>References <a class="el" href="EcrFicPartage_8cpp_source.html#l00062">get_obuffer()</a>, and <a class="el" href="Sortie_8cpp_source.html#l00176">Sortie::put()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <a class="code" href="classEcrFicPartage.html#a9ebbbdcb9b4aedc112671e2f075944d4">get_obuffer</a>().<a class="code" href="classSortie.html#aa3f46aaccaff0f83c018784b50d8ea24" title="Methode de bas niveau pour ecrire un tableau d&#39;ints ou reels dans le stream. Dans l&#39;implementation de...">put</a>(ob,n,pas);
  <span class="keywordflow">return</span> 1;
}
</pre></div>
</div>
</div>
<a class="anchor" id="adffdcc51062693ba00cbd35ab46256c6"></a><!-- doxytag: member="EcrFicPartage::put" ref="adffdcc51062693ba00cbd35ab46256c6" args="(const float *ob, int n, int pas)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int EcrFicPartage::put </td>
          <td>(</td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>ob</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nb_colonnes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Methode de bas niveau pour ecrire un tableau d'ints ou reels dans le stream.<br/>
Dans l'implementation de la classe de base, on ecrit dans ostream_.<br/>
En binaire on utilise ostream::write(), en ascii ostream::operato&lt;&lt;()<br/>
En ascii, on revient a la ligne chaque fois qu'on a ecrit "nb_col" valeurs et a la<br/>
fin du tableau.<br/>
Valeur de retour : ostream_-&gt;good() </p>

<p>Reimplemented from <a class="el" href="classSortie.html#a0dc36cb9e13f5be19a28b5e763e67e60">Sortie</a>.</p>

<p>Definition at line <a class="el" href="EcrFicPartage_8cpp_source.html#l00387">387</a> of file <a class="el" href="EcrFicPartage_8cpp_source.html">EcrFicPartage.cpp</a>.</p>

<p>References <a class="el" href="EcrFicPartage_8cpp_source.html#l00062">get_obuffer()</a>, and <a class="el" href="Sortie_8cpp_source.html#l00176">Sortie::put()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <a class="code" href="classEcrFicPartage.html#a9ebbbdcb9b4aedc112671e2f075944d4">get_obuffer</a>().<a class="code" href="classSortie.html#aa3f46aaccaff0f83c018784b50d8ea24" title="Methode de bas niveau pour ecrire un tableau d&#39;ints ou reels dans le stream. Dans l&#39;implementation de...">put</a>(ob,n,pas);
  <span class="keywordflow">return</span> 1;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a2ffd89cb7d702874733b578564b570d1"></a><!-- doxytag: member="EcrFicPartage::put" ref="a2ffd89cb7d702874733b578564b570d1" args="(const double *ob, int n, int pas)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int EcrFicPartage::put </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>ob</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nb_colonnes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Methode de bas niveau pour ecrire un tableau d'ints ou reels dans le stream.<br/>
Dans l'implementation de la classe de base, on ecrit dans ostream_.<br/>
En binaire on utilise ostream::write(), en ascii ostream::operato&lt;&lt;()<br/>
En ascii, on revient a la ligne chaque fois qu'on a ecrit "nb_col" valeurs et a la<br/>
fin du tableau.<br/>
Valeur de retour : ostream_-&gt;good() </p>

<p>Reimplemented from <a class="el" href="classSortie.html#a3ccfdd7f9f0e258d5193758d25b28b1d">Sortie</a>.</p>

<p>Definition at line <a class="el" href="EcrFicPartage_8cpp_source.html#l00392">392</a> of file <a class="el" href="EcrFicPartage_8cpp_source.html">EcrFicPartage.cpp</a>.</p>

<p>References <a class="el" href="EcrFicPartage_8cpp_source.html#l00062">get_obuffer()</a>, and <a class="el" href="Sortie_8cpp_source.html#l00176">Sortie::put()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <a class="code" href="classEcrFicPartage.html#a9ebbbdcb9b4aedc112671e2f075944d4">get_obuffer</a>().<a class="code" href="classSortie.html#aa3f46aaccaff0f83c018784b50d8ea24" title="Methode de bas niveau pour ecrire un tableau d&#39;ints ou reels dans le stream. Dans l&#39;implementation de...">put</a>(ob,n,pas);
  <span class="keywordflow">return</span> 1;
}
</pre></div>
</div>
</div>
<a class="anchor" id="ab64aaefd82509f7eefe9f6b00d644218"></a><!-- doxytag: member="EcrFicPartage::put" ref="ab64aaefd82509f7eefe9f6b00d644218" args="(const int *ob, int n, int pas)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int EcrFicPartage::put </td>
          <td>(</td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>ob</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nb_colonnes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Methode de bas niveau pour ecrire un tableau d'ints ou reels dans le stream.<br/>
Dans l'implementation de la classe de base, on ecrit dans ostream_.<br/>
En binaire on utilise ostream::write(), en ascii ostream::operato&lt;&lt;()<br/>
En ascii, on revient a la ligne chaque fois qu'on a ecrit "nb_col" valeurs et a la<br/>
fin du tableau.<br/>
Valeur de retour : ostream_-&gt;good() </p>

<p>Reimplemented from <a class="el" href="classSortie.html#accee158a4354a9f13a3e21f7d73d4b3d">Sortie</a>.</p>

<p>Definition at line <a class="el" href="EcrFicPartage_8cpp_source.html#l00376">376</a> of file <a class="el" href="EcrFicPartage_8cpp_source.html">EcrFicPartage.cpp</a>.</p>

<p>References <a class="el" href="EcrFicPartage_8cpp_source.html#l00062">get_obuffer()</a>, and <a class="el" href="Sortie_8cpp_source.html#l00176">Sortie::put()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <a class="code" href="classEcrFicPartage.html#a9ebbbdcb9b4aedc112671e2f075944d4">get_obuffer</a>().<a class="code" href="classSortie.html#aa3f46aaccaff0f83c018784b50d8ea24" title="Methode de bas niveau pour ecrire un tableau d&#39;ints ou reels dans le stream. Dans l&#39;implementation de...">put</a>(ob,n,pas);
  <span class="keywordflow">return</span> 1;
}
</pre></div>
</div>
</div>
<a class="anchor" id="ad5ef0fd6736fef7d84261a529baf0a70"></a><!-- doxytag: member="EcrFicPartage::readOn" ref="ad5ef0fd6736fef7d84261a529baf0a70" args="(Entree &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEntree.html">Entree</a> &amp; EcrFicPartage::readOn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEntree.html">Entree</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Lecture d'un <a class="el" href="classObjet__U.html" title="classe Objet_U Cette classe est la classe de base des Objets de TRUST Dans les classes derivees de Ob...">Objet_U</a> sur un flot d'entree<br/>
Methode a surcharger. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="classEntree.html" title="Classe de definition des operateurs et methodes pour toute lecture dans un flot d&#39;entree (fichier...">Entree</a>&amp; s<br/>
 Signification: flot d'entree modifie<br/>
 Contraintes: </dd></dl>

<p>Reimplemented from <a class="el" href="classSFichier.html#a882387fcbfb321e0cdb03a12d75884c2">SFichier</a>.</p>

<p>Reimplemented in <a class="el" href="classEcrFicPartageBin.html#a71e19f9d271bcc3e02b4f3048dbaed0e">EcrFicPartageBin</a>.</p>

<p>Definition at line <a class="el" href="EcrFicPartage_8cpp_source.html#l00033">33</a> of file <a class="el" href="EcrFicPartage_8cpp_source.html">EcrFicPartage.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">throw</span>;
  <span class="keywordflow">return</span> s;
}
</pre></div>
</div>
</div>
<a class="anchor" id="afa97df57b8b28ad33808d6e06c78d9e5"></a><!-- doxytag: member="EcrFicPartage::self_cast" ref="afa97df57b8b28ad33808d6e06c78d9e5" args="(Objet_U &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEcrFicPartage.html">EcrFicPartage</a> &amp; EcrFicPartage::self_cast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classObjet__U.html">Objet_U</a> &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="classSFichier.html#a17c5f989790e4d40c4b25c80ccb0b133">SFichier</a>.</p>

<p>Reimplemented in <a class="el" href="classEcrFicPartageBin.html#a85ee258b47fb006596420abc82c1ecbd">EcrFicPartageBin</a>.</p>

<p>Definition at line <a class="el" href="EcrFicPartage_8cpp_source.html#l00032">32</a> of file <a class="el" href="EcrFicPartage_8cpp_source.html">EcrFicPartage.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6f9978b776dada7412d1f0ae41bf4ee3"></a><!-- doxytag: member="EcrFicPartage::self_cast" ref="a6f9978b776dada7412d1f0ae41bf4ee3" args="(const Objet_U &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEcrFicPartage.html">EcrFicPartage</a> &amp; EcrFicPartage::self_cast </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classObjet__U.html">Objet_U</a> &amp;&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>methode ajoutee pour caster en python </p>

<p>Reimplemented from <a class="el" href="classSFichier.html#a6a96e7336551c18155a4bc7fa58009cb">SFichier</a>.</p>

<p>Reimplemented in <a class="el" href="classEcrFicPartageBin.html#ae361fd3c46bf733b38f11dfc2da03ed4">EcrFicPartageBin</a>.</p>

<p>Definition at line <a class="el" href="EcrFicPartage_8cpp_source.html#l00032">32</a> of file <a class="el" href="EcrFicPartage_8cpp_source.html">EcrFicPartage.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="adb24de67c7f2227a9128cdd84a710616"></a><!-- doxytag: member="EcrFicPartage::set_bin" ref="adb24de67c7f2227a9128cdd84a710616" args="(int bin)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int EcrFicPartage::set_bin </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bin</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Change le mode d'ecriture du fichier.<br/>
Cette methode peut etre appelee n'importe quand. Attention<br/>
cependant pour les fichiers Ecrire_Fichier_Partage :<br/>
il faut faire le changement uniquement au debut de l'ecriture<br/>
d'un bloc, juste apres <a class="el" href="classEcrFicPartage.html#a76131150f8293c86eb36f4b45125183d" title="Provoque l&#39;ecriture sur disque des donnees accumulees sur les differents processeurs depuis le dernie...">syncfile()</a> (sinon, mauvaise traduction<br/>
des retours a la ligne lors du syncfile suivant). </p>

<p>Reimplemented from <a class="el" href="classSortie.html#a1b830c79a55971e0ae7281d13e06cb44">Sortie</a>.</p>

<p>Definition at line <a class="el" href="EcrFicPartage_8cpp_source.html#l00411">411</a> of file <a class="el" href="EcrFicPartage_8cpp_source.html">EcrFicPartage.cpp</a>.</p>

<p>References <a class="el" href="Sortie_8h_source.html#l00114">Sortie::bin_</a>, <a class="el" href="EcrFicPartage_8cpp_source.html#l00062">get_obuffer()</a>, and <a class="el" href="OBuffer_8cpp_source.html#l00106">OBuffer::set_bin()</a>.</p>

<p>Referenced by <a class="el" href="EcrFicPartage_8cpp_source.html#l00044">EcrFicPartage()</a>, <a class="el" href="EcrFicPartageBin_8h_source.html#l00044">EcrFicPartageBin::EcrFicPartageBin()</a>, and <a class="el" href="Equation__base_8cpp_source.html#l00383">Equation_base::ecrire_fichier_xyz()</a>.</p>
<div class="fragment"><pre class="fragment">{
  assert(bin==0 || bin==1);
  <a class="code" href="classSortie.html#a7291aca32660e875543da1f0260b3773">bin_</a> = bin;
  <a class="code" href="classEcrFicPartage.html#a9ebbbdcb9b4aedc112671e2f075944d4">get_obuffer</a>().<a class="code" href="classOBuffer.html#a6586e53b7e61d60ba8468fc07160f2a9" title="Change le mode d&#39;ecriture du fichier. Cette methode peut etre appelee n&#39;importe quand. Attention cependant pour les fichiers Ecrire_Fichier_Partage : il faut faire le changement uniquement au debut de l&#39;ecriture d&#39;un bloc, juste apres syncfile() (sinon, mauvaise traduction des retours a la ligne lors du syncfile suivant).">set_bin</a>(<a class="code" href="classSortie.html#a7291aca32660e875543da1f0260b3773">bin_</a>);
  <span class="keywordflow">return</span> <a class="code" href="classSortie.html#a7291aca32660e875543da1f0260b3773">bin_</a>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a76131150f8293c86eb36f4b45125183d"></a><!-- doxytag: member="EcrFicPartage::syncfile" ref="a76131150f8293c86eb36f4b45125183d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSortie.html">Sortie</a> &amp; EcrFicPartage::syncfile </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Provoque l'ecriture sur disque des donnees accumulees sur les differents processeurs<br/>
depuis le dernier appel a <a class="el" href="classEcrFicPartage.html#a76131150f8293c86eb36f4b45125183d" title="Provoque l&#39;ecriture sur disque des donnees accumulees sur les differents processeurs depuis le dernie...">syncfile()</a>.<br/>
Les donnees sont ecrites dans l'ordre croissant des processeurs.<br/>
Cette fonction doit etre appelee le meme nombre de fois sur tous les processeurs !<br/>
Exemple:<br/>
processeur 0: processeur 1:<br/>
file &lt;&lt; "pe0 : 1" &lt;&lt; finl; file &lt;&lt; "pe1 : 1" &lt;&lt; finl;<br/>
file &lt;&lt; "pe0 : 2" &lt;&lt; finl; file &lt;&lt; "pe1 : 2" &lt;&lt; finl;<br/>
file.syncfile(); file.syncfile();<br/>
file &lt;&lt; "pe0 : 3" &lt;&lt; finl; file &lt;&lt; "pe1 : 3" &lt;&lt; finl;<br/>
file &lt;&lt; "pe0 : 4" &lt;&lt; finl;<br/>
file.syncfile(); file.syncfile();<br/>
file &lt;&lt; "pe0 : end" &lt;&lt; finl; // le processeur 1 n'ecrit pas de donnees<br/>
file.syncfile(); file.syncfile();<br/>
Contenu du fichier :<br/>
pe0 : 1<br/>
pe0 : 2<br/>
pe1 : 1<br/>
pe1 : 2<br/>
pe0 : 3<br/>
pe0 : 4<br/>
pe1 : 3<br/>
pe0 : end. </p>

<p><p>&lt; Faire coucou au processeur p pour qu'il envoie ses donnees </p>
</p>

<p>Reimplemented from <a class="el" href="classSortie.html#ae98acb70e7f3886cab47a51f2de6a976">Sortie</a>.</p>

<p>Definition at line <a class="el" href="EcrFicPartage_8cpp_source.html#l00216">216</a> of file <a class="el" href="EcrFicPartage_8cpp_source.html">EcrFicPartage.cpp</a>.</p>

<p>References <a class="el" href="Statistiques_8h_source.html#l00219">Statistiques::begin_count()</a>, <a class="el" href="Sortie_8h_source.html#l00114">Sortie::bin_</a>, <a class="el" href="PE__Groups_8h_source.html#l00054">PE_Groups::current_group()</a>, <a class="el" href="Statistiques_8h_source.html#l00237">Statistiques::end_count()</a>, <a class="el" href="communications_8cpp_source.html#l00200">envoyer()</a>, <a class="el" href="EcrFicPartage_8cpp_source.html#l00062">get_obuffer()</a>, <a class="el" href="Sortie_8cpp_source.html#l00111">Sortie::get_ostream()</a>, <a class="el" href="Process_8cpp_source.html#l00095">Process::je_suis_maitre()</a>, <a class="el" href="OBuffer_8cpp_source.html#l00101">OBuffer::len()</a>, <a class="el" href="Process_8cpp_source.html#l00117">Process::me()</a>, <a class="el" href="OBuffer_8cpp_source.html#l00041">OBuffer::new_buffer()</a>, <a class="el" href="Process_8cpp_source.html#l00109">Process::nproc()</a>, <a class="el" href="OBuffer_8cpp_source.html#l00085">OBuffer::put_null_char()</a>, <a class="el" href="communications_8cpp_source.html#l00246">recevoir()</a>, <a class="el" href="classComm__Group.html#ae3622cd7a58e3dfeba7bf9496c298d0f">Comm_Group::recv()</a>, <a class="el" href="classComm__Group.html#a5489eba2c9ba6099899f96e2621131f6">Comm_Group::send()</a>, <a class="el" href="Statistiques_8h_source.html#l00190">statistiques()</a>, and <a class="el" href="OBuffer_8cpp_source.html#l00093">OBuffer::str()</a>.</p>

<p>Referenced by <a class="el" href="Traitement__particulier__NS__chmoy__faceperio__VEF_8cpp_source.html#l00111">Traitement_particulier_NS_chmoy_faceperio_VEF::calcul_chmoy_faceperio()</a>, <a class="el" href="EcrFicPartage_8cpp_source.html#l00115">close()</a>, <a class="el" href="Zone__VEF__PreP1b_8cpp_source.html#l00328">Zone_VEF_PreP1b::construire_ok_arete()</a>, <a class="el" href="Statistiques_8cpp_source.html#l00631">Statistiques::dump()</a>, <a class="el" href="Format__Post__Lml_8cpp_source.html#l00464">Format_Post_Lml::ecrire_champ_lml()</a>, <a class="el" href="Format__Post__XYZ_8cpp_source.html#l00292">Format_Post_XYZ::ecrire_champ_xyz()</a>, <a class="el" href="Format__Post__Lml_8cpp_source.html#l00266">Format_Post_Lml::ecrire_domaine_lml()</a>, <a class="el" href="Format__Post__Lml_8cpp_source.html#l00214">Format_Post_Lml::ecrire_entete_lml()</a>, <a class="el" href="Equation__base_8cpp_source.html#l00383">Equation_base::ecrire_fichier_xyz()</a>, <a class="el" href="Format__Post__Lml_8cpp_source.html#l00601">Format_Post_Lml::ecrire_item_int_lml()</a>, <a class="el" href="Format__Post__Lml_8cpp_source.html#l00451">Format_Post_Lml::ecrire_temps_lml()</a>, <a class="el" href="Format__Post__Lml_8cpp_source.html#l00236">Format_Post_Lml::finir_lml()</a>, <a class="el" href="Op__VEF__Face_8cpp_source.html#l00456">Op_VEF_Face::impr()</a>, <a class="el" href="Op__Div__VEF__Elem_8cpp_source.html#l00089">Op_Div_VEF_Elem::impr()</a>, <a class="el" href="Op__Grad__VDF__Face_8cpp_source.html#l00242">Op_Grad_VDF_Face::impr()</a>, <a class="el" href="T__It__VDF__Face_8h_source.html#l01082">T_It_VDF_Face&lt; _TYPE_ &gt;::impr()</a>, <a class="el" href="T__It__VDF__Elem_8h_source.html#l00800">T_It_VDF_Elem&lt; _TYPE_ &gt;::impr()</a>, <a class="el" href="Op__Grad__PolyMAC__Face_8cpp_source.html#l00212">Op_Grad_PolyMAC_Face::impr()</a>, <a class="el" href="Op__Div__PolyMAC_8cpp_source.html#l00189">Op_Div_PolyMAC::impr()</a>, <a class="el" href="Op__Diff__PolyMAC__base_8cpp_source.html#l00163">Op_Diff_PolyMAC_base::impr()</a>, <a class="el" href="T__It__PolyMAC__Elem_8h_source.html#l01087">T_It_PolyMAC_Elem&lt; _TYPE_ &gt;::impr()</a>, <a class="el" href="Op__Grad__VEF__P1B__Face_8cpp_source.html#l00640">Op_Grad_VEF_P1B_Face::impr()</a>, <a class="el" href="Op__Grad__EF_8cpp_source.html#l00336">Op_Grad_EF::impr()</a>, <a class="el" href="Op__EF__base_8cpp_source.html#l00311">Op_EF_base::impr()</a>, <a class="el" href="Op__Div__EF_8cpp_source.html#l00120">Op_Div_EF::impr()</a>, <a class="el" href="Op__Div__CoviMAC_8cpp_source.html#l00127">Op_Div_CoviMAC::impr()</a>, <a class="el" href="Op__Diff__CoviMAC__base_8cpp_source.html#l00123">Op_Diff_CoviMAC_base::impr()</a>, <a class="el" href="Op__Conv__CoviMAC__base_8cpp_source.html#l00168">Op_Conv_CoviMAC_base::impr()</a>, <a class="el" href="Traitement__particulier__NS__chmoy__faceperio__VEF_8cpp_source.html#l00077">Traitement_particulier_NS_chmoy_faceperio_VEF::init_calcul_stats()</a>, and <a class="el" href="EcrFicPartage_8cpp_source.html#l00073">ouvrir()</a>.</p>
<div class="fragment"><pre class="fragment">{
<span class="comment">// En mode ascii, les donnees sont converties en ascii lors de l&#39;ecriture dans</span>
<span class="comment">// le buffer. Une deuxieme conversion a lieu lors de l&#39;ecriture sur disque</span>
<span class="comment">// (selon le systeme d&#39;exploitation, &#39;\n&#39; est code differemment par exemple)</span>
<span class="comment">// Donc, en ascii, on utilisera</span>
<span class="comment">// file &lt;&lt; buffer;</span>
<span class="comment">// et en binaire</span>
<span class="comment">// file.write(buffer, size);</span>
<span class="comment">// Or file &lt;&lt; buffer determine la longueur du buffer en cherchant de caractere &#39;\0&#39;</span>
<span class="comment">// Par consequent, en ascii, il faut que le buffer finisse par un caractere &#39;\0&#39;</span>
<span class="comment">// que l&#39;on ajoute ici:</span>

  <span class="keywordflow">if</span> (! <a class="code" href="classSortie.html#a7291aca32660e875543da1f0260b3773">bin_</a>)
    {
      <a class="code" href="classEcrFicPartage.html#a9ebbbdcb9b4aedc112671e2f075944d4">get_obuffer</a>().<a class="code" href="classOBuffer.html#aacd7a477ffa16ab1d0512e5755fe3aee" title="ajoute le caractere nul a la fin du buffer pour en faire une chaine de caracteres valide...">put_null_char</a>();
    }

  <span class="keyword">const</span> <a class="code" href="classComm__Group.html" title=": Cette classe decrit un groupe de processeurs sur lesquels une portion de code s&#39;execute simultaneme...">Comm_Group</a>&amp; group = <a class="code" href="classPE__Groups.html#ae6ca0277a58f2ab34ebfb3216578fa75" title="renvoie une reference au groupe de processeurs actif courant">PE_Groups::current_group</a>();
  <span class="keywordflow">if</span>(<a class="code" href="classProcess.html#acd052b99706c577f8a5b6656217cf4c2" title="renvoie 1 si on est sur le processeur maitre du groupe courant (c&#39;est a dire me() == 0)...">je_suis_maitre</a>())
    {
      <span class="keywordtype">int</span> p;
      <span class="keyword">const</span> <span class="keywordtype">int</span> nb_proc = <a class="code" href="classProcess.html#a6bf692ce58d9578aa62ac3c07b8caaa1" title="renvoie le nombre de processeurs dans le groupe courant Voir Comm_Group::nproc() et PE_Groups::curren...">nproc</a>();
      <span class="keywordflow">for</span>(p=0; p&lt;nb_proc; p++)
        {
          <span class="keyword">const</span> <span class="keywordtype">char</span> * buffer_data = 0;
          <span class="keywordtype">char</span> * allocated_buffer = 0;
          <span class="keywordtype">int</span> buf_size;

<span class="comment">// On recupere les donnees du processeur p, soit directement (p==me()),</span>
<span class="comment">// soit par communication :</span>
          <span class="keywordflow">if</span> (p == <a class="code" href="classProcess.html#ab55ba07167ec807ed3a145cac0f5dca4" title="renvoie mon rang dans le groupe de communication courant. Voir Comm_Group::rank() et PE_Groups::curre...">me</a>())
            {
<span class="comment">// Ecriture de mes propres donnees : je les prends dans le buffer.</span>
<span class="comment">// Ce pointeur peut etre nul:</span>
              buffer_data = <a class="code" href="classEcrFicPartage.html#a9ebbbdcb9b4aedc112671e2f075944d4">get_obuffer</a>().<a class="code" href="classOBuffer.html#a9d360f12115bd70e3564148554f46dd5" title="Renvoie un pointeur sur le debut du buffer.">str</a>();
              buf_size = <a class="code" href="classEcrFicPartage.html#a9ebbbdcb9b4aedc112671e2f075944d4">get_obuffer</a>().<a class="code" href="classOBuffer.html#a109d45b98ea859e3f95c3e0bbd0536ee">len</a>();
            }
          <span class="keywordflow">else</span>
            {
<span class="comment">// Ecriture des donnees d&#39;un autre processeur, je les recupere.</span>
              <span class="keywordtype">int</span> dummy = 0;
              <a class="code" href="communications_8cpp.html#af9feb6405277b375b2ebcbfaec9f8af3">envoyer</a>(dummy, p, 100); <span class="comment">//!&lt; Faire coucou au processeur p pour qu&#39;il envoie ses donnees</span>
<span class="comment"></span>              <a class="code" href="communications_8cpp.html#a729d9499913e22a5f0db62ef07b9793f">recevoir</a>(buf_size, p, 100);
              <span class="keywordflow">if</span> (buf_size &gt; 0)
                {
                  buffer_data = allocated_buffer = <span class="keyword">new</span> <span class="keywordtype">char</span>[buf_size];
                  group.<a class="code" href="classComm__Group.html#ae3622cd7a58e3dfeba7bf9496c298d0f" title="Reception bloquante.">recv</a>(p, allocated_buffer, buf_size, 100);
                }
            }
<span class="comment">// Ecriture dans le fichier disque</span>
          <span class="keywordflow">if</span> (buf_size &gt; 0)
            {
              assert(buffer_data);
              ostream&amp; os = <a class="code" href="classSortie.html#a2b296619da65cf49f0e8934ee51ad3ed">get_ostream</a>();
              <span class="keywordflow">if</span> (<a class="code" href="classSortie.html#a7291aca32660e875543da1f0260b3773">bin_</a>)
                {
<span class="comment">// Ecriture binaire sans conversion :</span>
                  <a class="code" href="Statistiques_8h.html#a7bb2ce53a9ec088bba93ddcfce2b8cb1">statistiques</a>().<a class="code" href="classStatistiques.html#affcd058809786918ed173aaf681d0843">begin_count</a>(<a class="code" href="EcrFicPartage_8cpp.html#ac3170aa88556995818da56645453d290">IO_EcrireFicPartageBin_counter_</a>);
                  os.write(buffer_data, buf_size);
                  <a class="code" href="Statistiques_8h.html#a7bb2ce53a9ec088bba93ddcfce2b8cb1">statistiques</a>().<a class="code" href="classStatistiques.html#a0faf52d1b518f5b0b2177f22efcc222d" title="Arret du compteur counter_id. On ajoute quantity a la somme des &#39;quantity&#39; (par defaut 0) stockees po...">end_count</a>(<a class="code" href="EcrFicPartage_8cpp.html#ac3170aa88556995818da56645453d290">IO_EcrireFicPartageBin_counter_</a>, buf_size);
                }
              <span class="keywordflow">else</span>
                {
<span class="comment">// On verifie que le buffer finit bien par un caractere 0 :</span>
                  assert(buffer_data[buf_size-1] == 0);
<span class="comment">// Ecriture de buffer_data comme une chaine</span>
<span class="comment">// (conversion des \n sur certains systemes, etc...)</span>
                  os &lt;&lt; buffer_data;
                }
            }
          <span class="keywordflow">if</span> (allocated_buffer)
            <span class="keyword">delete</span>[] allocated_buffer;
        }
<span class="comment">// Force a tout ecrire sur le disque tout de suite:</span>
<span class="comment">// (appel a la fonction flush de bas niveau, pas celle de trio).</span>
      <a class="code" href="classSortie.html#a2b296619da65cf49f0e8934ee51ad3ed">get_ostream</a>().flush();
    }
  <span class="keywordflow">else</span>
    {
<span class="comment">// Envoi du buffer au processeur maitre:</span>
<span class="comment">// On attend qu&#39;il demande les donnees pour ne pas engorger le reseau :</span>
<span class="comment">// (sinon tous les processeurs envoient simultanement leurs donnees)</span>
      <span class="keywordtype">int</span> dummy;
      <a class="code" href="communications_8cpp.html#a729d9499913e22a5f0db62ef07b9793f">recevoir</a>(dummy, 0, 100);
      <span class="keywordtype">int</span> buf_size = <a class="code" href="classEcrFicPartage.html#a9ebbbdcb9b4aedc112671e2f075944d4">get_obuffer</a>().<a class="code" href="classOBuffer.html#a109d45b98ea859e3f95c3e0bbd0536ee">len</a>();
      <a class="code" href="communications_8cpp.html#af9feb6405277b375b2ebcbfaec9f8af3">envoyer</a>(buf_size, 0, 100);
<span class="comment">// Si la taille est non nulle, on envoie le buffer :</span>
      <span class="keywordflow">if</span> (buf_size &gt; 0)
        {
          <span class="keyword">const</span> <span class="keywordtype">char</span> * buffer_data = <a class="code" href="classEcrFicPartage.html#a9ebbbdcb9b4aedc112671e2f075944d4">get_obuffer</a>().<a class="code" href="classOBuffer.html#a9d360f12115bd70e3564148554f46dd5" title="Renvoie un pointeur sur le debut du buffer.">str</a>();
          group.<a class="code" href="classComm__Group.html#a5489eba2c9ba6099899f96e2621131f6" title="Envoi bloquant.">send</a>(0, buffer_data, buf_size, 100);
        }
    }

<span class="comment">// On vide le buffer :</span>
  <a class="code" href="classEcrFicPartage.html#a9ebbbdcb9b4aedc112671e2f075944d4">get_obuffer</a>().<a class="code" href="classOBuffer.html#a7e2534175cc05e76081bc01566e5e4bc">new_buffer</a>();
  <span class="keywordflow">return</span> *<span class="keyword">this</span>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="ab011af8fedecd133790f92166030ec74"></a><!-- doxytag: member="EcrFicPartage::taille_memoire" ref="ab011af8fedecd133790f92166030ec74" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned EcrFicPartage::taille_memoire </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="classSFichier.html#aab63c10622522ac3654bd9c1b735071e">SFichier</a>.</p>

<p>Reimplemented in <a class="el" href="classEcrFicPartageBin.html#a1f18176abbb03cad08e4f684354d2c54">EcrFicPartageBin</a>.</p>

<p>Definition at line <a class="el" href="EcrFicPartage_8cpp_source.html#l00032">32</a> of file <a class="el" href="EcrFicPartage_8cpp_source.html">EcrFicPartage.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9e949d929e1f36fad99b492c32caea50"></a><!-- doxytag: member="EcrFicPartage::unlockfile" ref="a9e949d929e1f36fad99b492c32caea50" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSortie.html">Sortie</a> &amp; EcrFicPartage::unlockfile </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Permet de debloquer la ressource critique pour leprocessus suivant.<br/>
Le processus appelant, sauf si c'est le premier processus du groupe, envoie<br/>
sa position courante au precessus suivant dans le groupe. Cette methode est<br/>
a appeler apres chaque ecriture dans le fichier. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="classSortie.html" title="Classe de base des flux de sortie. Elle sait ecrire des types simples&lt;br&gt;(entiers, flottants) et des Ob...">Sortie</a>&amp;<br/>
 Signification: *this<br/>
 Contraintes: </dd></dl>

<p>Reimplemented from <a class="el" href="classSortie.html#a542584d49a2cd8f74aebb9ab4a0f469b">Sortie</a>.</p>

<p>Definition at line <a class="el" href="EcrFicPartage_8cpp_source.html#l00184">184</a> of file <a class="el" href="EcrFicPartage_8cpp_source.html">EcrFicPartage.cpp</a>.</p>

<p>Referenced by <a class="el" href="Format__Post__Lml_8cpp_source.html#l00464">Format_Post_Lml::ecrire_champ_lml()</a>, <a class="el" href="Format__Post__XYZ_8cpp_source.html#l00292">Format_Post_XYZ::ecrire_champ_xyz()</a>, <a class="el" href="Format__Post__Lml_8cpp_source.html#l00266">Format_Post_Lml::ecrire_domaine_lml()</a>, <a class="el" href="Equation__base_8cpp_source.html#l00383">Equation_base::ecrire_fichier_xyz()</a>, and <a class="el" href="Format__Post__Lml_8cpp_source.html#l00601">Format_Post_Lml::ecrire_item_int_lml()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">return</span> *<span class="keyword">this</span>;
}
</pre></div>
</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="af7001bb72377d9abbd05f6b5d078e1dc"></a><!-- doxytag: member="EcrFicPartage::info_obj" ref="af7001bb72377d9abbd05f6b5d078e1dc" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classType__info.html">Type_info</a> <a class="el" href="classEcrFicPartage.html#af7001bb72377d9abbd05f6b5d078e1dc">EcrFicPartage::info_obj</a><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="classSFichier.html#a05964c97c00185068df05afcdf55d7fd">SFichier</a>.</p>

<p>Reimplemented in <a class="el" href="classEcrFicPartageBin.html#a28b813d0cbb33ee748af5ae1cbc6fc66">EcrFicPartageBin</a>.</p>

<p>Definition at line <a class="el" href="EcrFicPartage_8h_source.html#l00048">48</a> of file <a class="el" href="EcrFicPartage_8h_source.html">EcrFicPartage.h</a>.</p>

</div>
</div>
<a class="anchor" id="a9ccc856a8ece1ab74bd5168532e3a0e1"></a><!-- doxytag: member="EcrFicPartage::nom_fic_" ref="a9ccc856a8ece1ab74bd5168532e3a0e1" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNom.html">Nom</a> <a class="el" href="classEcrFicPartage.html#a9ccc856a8ece1ab74bd5168532e3a0e1">EcrFicPartage::nom_fic_</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="EcrFicPartage_8h_source.html#l00087">87</a> of file <a class="el" href="EcrFicPartage_8h_source.html">EcrFicPartage.h</a>.</p>

<p>Referenced by <a class="el" href="EcrFicPartage_8cpp_source.html#l00115">close()</a>, and <a class="el" href="EcrFicPartage_8cpp_source.html#l00073">ouvrir()</a>.</p>

</div>
</div>
<a class="anchor" id="a1991e2a3b5a5a12278155b6ed8fb0b3e"></a><!-- doxytag: member="EcrFicPartage::obuffer_ptr_" ref="a1991e2a3b5a5a12278155b6ed8fb0b3e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOBuffer.html">OBuffer</a>* <a class="el" href="classEcrFicPartage.html#a1991e2a3b5a5a12278155b6ed8fb0b3e">EcrFicPartage::obuffer_ptr_</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Pointeur : permet de ne pas inclure <a class="el" href="OBuffer_8h.html">OBuffer.h</a>. </p>

<p>Definition at line <a class="el" href="EcrFicPartage_8h_source.html#l00091">91</a> of file <a class="el" href="EcrFicPartage_8h_source.html">EcrFicPartage.h</a>.</p>

<p>Referenced by <a class="el" href="EcrFicPartage_8cpp_source.html#l00044">EcrFicPartage()</a>, <a class="el" href="EcrFicPartage_8cpp_source.html#l00062">get_obuffer()</a>, and <a class="el" href="EcrFicPartage_8cpp_source.html#l00104">~EcrFicPartage()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/Kernel/Utilitaires/<a class="el" href="EcrFicPartage_8h_source.html">EcrFicPartage.h</a></li>
<li>src/Kernel/Utilitaires/<a class="el" href="EcrFicPartage_8cpp_source.html">EcrFicPartage.cpp</a></li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Tue Dec 14 2021 19:36:38 for TRUST by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
