<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>TRUST: src/Kernel/Geometrie/Connex_components.cpp File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">TRUST&#160;<span id="projectnumber">1.8.4</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">src/Kernel/Geometrie/Connex_components.cpp File Reference</div>  </div>
</div>
<div class="contents">
<div class="textblock"><code>#include &lt;<a class="el" href="Connex__components_8h_source.html">Connex_components.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="IntTab_8h_source.html">IntTab.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="communications_8h_source.html">communications.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="ArrOfBit_8h_source.html">ArrOfBit.h</a>&gt;</code><br/>
</div>
<p><a href="Connex__components_8cpp_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Connex__components_8cpp.html#ad771774190b40158b92030966f3f5a17">search_connex_components_local</a> (const <a class="el" href="classIntTab.html">IntTab</a> &amp;elem_faces, const <a class="el" href="classIntTab.html">IntTab</a> &amp;faces_elem, <a class="el" href="classIntVect.html">IntVect</a> &amp;num_compo)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calcul des ensembles connexes par faces d'elements<br/>
non "marques" (les elements sont relies entre eux par un graphe<br/>
symetrique passant par les faces).<br/>
Une portion de domaine connexe porte un numero 0 &lt;= i &lt; N<br/>
unique et est delimite soit par un bord, soit par un element voisin "marque"<br/>
par num_compo[elem] = -1.<br/>
Cette methode est sequentielle (peut etre appelee sur un seul processeur)<br/>
Parametre: elem_faces<br/>
graph de connectivite elements-faces (pour chaque element i, indices<br/>
des faces de cet element), voir <a class="el" href="classZone__VF.html#a8e09b61902b9f1d2c4c7bedc3b8f39d3" title="renvoie le tableau de connectivite element/faces">Zone_VF::elem_faces()</a><br/>
Parametre: faces_elem<br/>
graph de connectivite faces-elements (pour chaque face, indice du<br/>
ou des deux elements adjacents), voir <a class="el" href="classZone__VF.html#a816ac37fd526f962468cae6fbd8061f8" title="renvoie le tableaux des volumes des connectivites face elements cf au dessus.">Zone_VF::face_voisins()</a><br/>
Parametre: num_compo<br/>
En entree, un tableau tel que num_compo.size_array() == elem_faces.dimension_tot(0),<br/>
et dont certaines valeurs valent -1 (elements marques), et d'autres non.<br/>
En sortie: les elements pour lesquels num_compo = -1 ne sont pas modifies, les autres<br/>
sont numerotes par composante connexe locale. On remplit tout le tableau<br/>
jusqu'a size_tot() y compris les elements virtuels. Les numeros de composantes<br/>
sont locaux a ce processeur.<br/>
Valeur de retour: N, nombre de composantes connexes locales.  <a href="#ad771774190b40158b92030966f3f5a17"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Connex__components_8cpp.html#a1e4b3977c09e7f6f4e8a3d554c05e727">compute_graph_connex_components</a> (const <a class="el" href="classIntTab.html">IntTab</a> &amp;graph, <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;connex_components)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">recherche des composantes connexes d'un graphe local (non distribue<br/>
sur les processeurs) non symetrique.<br/>
Parametre: graph<br/>
On suppose que "graph" est un tableau a deux colonnes<br/>
contenant des couples d'indices de "sommets" d'un graphe. Ces couples definissent<br/>
un graphe dont on veut chercher les composantes connexes:<br/>
deux indices i et j sont dans la meme composante connexe si et seulement si il<br/>
existe une suite de couples qui relient directement ou indirectement i et j.<br/>
Parametre: connex_components<br/>
On suppose que connex_components est dimensionne a nb_sommets, le nombre de sommets du graphe.<br/>
On met dans connex_components[i] le numero de la composante connexe du graphe a laquelle appartient<br/>
le "sommet" i. On attribue tous les numeros i tels que 0 &lt;= i &lt; N<br/>
Valeur de retour: le nombre N de composantes connexes trouvees.  <a href="#a1e4b3977c09e7f6f4e8a3d554c05e727"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Connex__components_8cpp.html#a476f055e17d2b6b039961d59afb7ebcb">compute_global_connex_components</a> (<a class="el" href="classIntVect.html">IntVect</a> &amp;num_compo, int nb_local_components)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Recherche les composantes connexes d'un ensemble d'elements distribue sur<br/>
tous les processeurs. Cette methode est parallele et doit etre appelee en<br/>
meme temps sur tous les processeurs.<br/>
Parametre: num_compo<br/>
num_compo doit avoir au moins une couche d'elements virtuels et doit contenir<br/>
le resultat de la methode <a class="el" href="Connex__components_8cpp.html#ad771774190b40158b92030966f3f5a17" title="Calcul des ensembles connexes par faces d&#39;elements non &quot;marques&quot; (les elements sont relies entre eu...">search_connex_components_local()</a>. Les elements<br/>
virtuels ont donc ete remplis avec des numeros de composantes connexes locales.<br/>
Le tableau num_compo ne doit PAS avoir subi echange_espace_virtuel !!!<br/>
On cherche a l'aide des elements virtuels les composantes connexes connectees<br/>
entre elles entre deux processeurs et on leur attribue un numero unique i tel<br/>
que tous les indices 0 &lt;= i &lt; N sont utilises.<br/>
Parametre: nb_local_components<br/>
doit contenir le nombre de composantes connexes locales utilisees<br/>
dans num_compo a l'entree (egale a la valeur de retour de la fonction<br/>
<a class="el" href="Connex__components_8cpp.html#ad771774190b40158b92030966f3f5a17" title="Calcul des ensembles connexes par faces d&#39;elements non &quot;marques&quot; (les elements sont relies entre eu...">search_connex_components_local()</a>).<br/>
Valeur de retour: nombre N de composantes connexes globales trouvees.  <a href="#a476f055e17d2b6b039961d59afb7ebcb"></a><br/></td></tr>
</table>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a476f055e17d2b6b039961d59afb7ebcb"></a><!-- doxytag: member="Connex_components.cpp::compute_global_connex_components" ref="a476f055e17d2b6b039961d59afb7ebcb" args="(IntVect &amp;num_compo, int nb_local_components)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int compute_global_connex_components </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classIntVect.html">IntVect</a> &amp;&#160;</td>
          <td class="paramname"><em>num_compo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nb_local_components</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Recherche les composantes connexes d'un ensemble d'elements distribue sur<br/>
tous les processeurs. Cette methode est parallele et doit etre appelee en<br/>
meme temps sur tous les processeurs.<br/>
Parametre: num_compo<br/>
num_compo doit avoir au moins une couche d'elements virtuels et doit contenir<br/>
le resultat de la methode <a class="el" href="Connex__components_8cpp.html#ad771774190b40158b92030966f3f5a17" title="Calcul des ensembles connexes par faces d&#39;elements non &quot;marques&quot; (les elements sont relies entre eu...">search_connex_components_local()</a>. Les elements<br/>
virtuels ont donc ete remplis avec des numeros de composantes connexes locales.<br/>
Le tableau num_compo ne doit PAS avoir subi echange_espace_virtuel !!!<br/>
On cherche a l'aide des elements virtuels les composantes connexes connectees<br/>
entre elles entre deux processeurs et on leur attribue un numero unique i tel<br/>
que tous les indices 0 &lt;= i &lt; N sont utilises.<br/>
Parametre: nb_local_components<br/>
doit contenir le nombre de composantes connexes locales utilisees<br/>
dans num_compo a l'entree (egale a la valeur de retour de la fonction<br/>
<a class="el" href="Connex__components_8cpp.html#ad771774190b40158b92030966f3f5a17" title="Calcul des ensembles connexes par faces d&#39;elements non &quot;marques&quot; (les elements sont relies entre eu...">search_connex_components_local()</a>).<br/>
Valeur de retour: nombre N de composantes connexes globales trouvees. </p>

<p>Definition at line <a class="el" href="Connex__components_8cpp_source.html#l00215">215</a> of file <a class="el" href="Connex__components_8cpp_source.html">Connex_components.cpp</a>.</p>

<p>References <a class="el" href="Connex__components_8cpp_source.html#l00125">compute_graph_connex_components()</a>, <a class="el" href="IntTab_8h_source.html#l00233">IntTab::dimension()</a>, <a class="el" href="IntVect_8cpp_source.html#l00276">IntVect::echange_espace_virtuel()</a>, <a class="el" href="communications_8cpp_source.html#l00200">envoyer()</a>, <a class="el" href="communications_8cpp_source.html#l00375">envoyer_broadcast()</a>, <a class="el" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>, <a class="el" href="Process_8cpp_source.html#l00095">Process::je_suis_maitre()</a>, <a class="el" href="Process_8cpp_source.html#l00345">Process::Journal()</a>, <a class="el" href="ArrOfDouble_8cpp_source.html#l00814">max_array()</a>, <a class="el" href="Process_8cpp_source.html#l00178">Process::mp_sum()</a>, <a class="el" href="communications_8cpp_source.html#l00608">mppartial_sum()</a>, <a class="el" href="Process_8cpp_source.html#l00109">Process::nproc()</a>, <a class="el" href="communications_8cpp_source.html#l00246">recevoir()</a>, <a class="el" href="IntTab_8cpp_source.html#l00353">IntTab::resize()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00240">ArrOfInt::resize_array()</a>, <a class="el" href="ArrOfInt_8cpp_source.html#l00443">ArrOfInt::set_smart_resize()</a>, <a class="el" href="IntVect_8h_source.html#l00139">IntVect::size()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00342">ArrOfInt::size_array()</a>, <a class="el" href="IntVect_8h_source.html#l00145">IntVect::size_totale()</a>, and <a class="el" href="ArrOfBit_8h_source.html#l00073">ArrOfBit::testsetbit()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">const</span> <span class="keywordtype">int</span> nbelem = num_compo.<a class="code" href="classIntVect.html#ad90cfd411cbbd631ccf1935bb36f7c40" title="Identique a size_reelle()">size</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> nbelem_tot = num_compo.<a class="code" href="classIntVect.html#afa716e1f0a1f0f74f4f73e95b5651412" title="Identique a size_array()">size_totale</a>();
<span class="comment">// int i;</span>

<span class="comment">// Transformation des indices locaux de composantes connexes en un indice global</span>
<span class="comment">// (on ajoute un decalage aux indices globaux avec mppartial_sum())</span>
  <span class="keyword">const</span> <span class="keywordtype">int</span> decalage = <a class="code" href="communications_8cpp.html#a13b5bdc7cfe14771b52a033b1ecbc071" title="Calul de la somme partielle de i sur les processeurs 0 a me()-1 (renvoie 0 sur le processeur 0)...">mppartial_sum</a>(nb_local_components);
  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_total_components = <a class="code" href="classProcess.html#a7d23bc1ef94b3f0623fbc79d034c27fd" title="Calcule la somme de x sur tous les processeurs du groupe courant. Voir aussi mp_max()">Process::mp_sum</a>(nb_local_components);
  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; nbelem_tot; i++)
    <span class="keywordflow">if</span> (num_compo[i] &gt;= 0)
      num_compo[i] += decalage;

<span class="comment">// Pour trouver les correspondances entre un numero de composante locale et un</span>
<span class="comment">// numero de la meme composante sur le processeur voisin, on cree une copie du</span>
<span class="comment">// tableau num_compo sur laquelle on fait un echange_espace_virtuel(). Ainsi,</span>
<span class="comment">// sur les cases virtuelles du tableau, on a dans num_compo le numero de la</span>
<span class="comment">// composante locale et dans copie_compo le numero de cette meme composante sur</span>
<span class="comment">// le processeur proprietaire de l&#39;element. Donc ces deux numeros designent</span>
<span class="comment">// la meme composante connexe.</span>
  <a class="code" href="classIntVect.html">IntVect</a> copie_compo(num_compo);
  copie_compo.echange_espace_virtuel();

<span class="comment">// Recherche des equivalences entre les numeros des composantes locales et</span>
<span class="comment">// les numeros des composantes voisines. On construit un graphe dont les</span>
<span class="comment">// liens relient les composantes equivalentes.</span>
<span class="comment">// Tableau de marqeurs pour les equivalences deja trouvees.</span>
<span class="comment">// Dimensions = nb composantes locales * nb_composantes total</span>
<span class="comment">// (pour ne pas prendre en compte la meme composante plusieurs fois).</span>
  <a class="code" href="classArrOfBit.html">ArrOfBit</a> markers(nb_local_components * nb_total_components);
  markers = 0;
<span class="comment">// Tableau de correspondances entre composantes connexes locales et distantes</span>
  <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a> graph;
  graph.<a class="code" href="classArrOfInt.html#a22d744bcd452d039580d1d9186f02b4e" title="Change le mode l&#39;allocation memoire: reallocation d&#39;un tableau a chaque changement de taille (flag = ...">set_smart_resize</a>(1);
  <span class="keywordtype">int</span> graph_size = 0;
<span class="comment">// Parcours des elements virtuels uniquement</span>
  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = nbelem; i &lt; nbelem_tot; i++)
    {
      <span class="keywordtype">int</span> compo = num_compo[i];
      <span class="keywordflow">if</span> (compo &lt; 0)
        <span class="keywordflow">continue</span>;
      <span class="keywordtype">int</span> compo2 = copie_compo[i];
<span class="comment">// Index du couple compo2/compo dans le tableau markers</span>
<span class="comment">// Le tableau num_compo ne doit contenir que des composantes locales:</span>
      assert(compo &gt;= decalage &amp;&amp; compo - decalage &lt; nb_local_components);
<span class="comment">// compo2 est forcement une composante distante.</span>
      assert(compo2 &lt; decalage || compo2 - decalage &gt;= nb_local_components);
      <span class="keyword">const</span> <span class="keywordtype">int</span> index = (compo - decalage) * nb_total_components + compo2;
      <span class="keywordflow">if</span> (!markers.testsetbit(index))
        {
          graph.<a class="code" href="classIntTab.html#a22e6bed6826b3688d4d0181cbf3b7a38" title="Change la taille du vecteur (identique a resize_array() pour le traitement des anciennes valeurs et d...">resize</a>(graph_size+1, 2);
<span class="comment">// On met le plus petit numero de composante en colonne 0:</span>
          <span class="keywordflow">if</span> (compo2 &lt; compo)
            {
              <span class="keywordtype">int</span> tmp = compo;
              compo = compo2;
              compo2 = tmp;
            }
          graph(graph_size, 0) = compo;
          graph(graph_size, 1) = compo2;
          graph_size++;
        }
    }

  <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> renum;
  <span class="keywordflow">if</span> (<a class="code" href="classProcess.html#acd052b99706c577f8a5b6656217cf4c2" title="renvoie 1 si on est sur le processeur maitre du groupe courant (c&#39;est a dire me() == 0)...">Process::je_suis_maitre</a>())
    {
<span class="comment">// Reception des portions de graphe des autres processeurs</span>
      <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a> tmp;
      <span class="keyword">const</span> <span class="keywordtype">int</span> nproc = <a class="code" href="classProcess.html#a6bf692ce58d9578aa62ac3c07b8caaa1" title="renvoie le nombre de processeurs dans le groupe courant Voir Comm_Group::nproc() et PE_Groups::curren...">Process::nproc</a>();
      <span class="keywordtype">int</span> pe;
      <span class="keywordflow">for</span> (pe = 1; pe &lt; nproc; pe++)
        {
          <a class="code" href="communications_8cpp.html#a729d9499913e22a5f0db62ef07b9793f">recevoir</a>(tmp, pe, 54 <span class="comment">/* tag */</span>);
          <span class="keyword">const</span> <span class="keywordtype">int</span> n2 = tmp.<a class="code" href="classIntTab.html#abc3b32c94925a82f69d5b153a356e359" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(0);
          graph.<a class="code" href="classIntTab.html#a22e6bed6826b3688d4d0181cbf3b7a38" title="Change la taille du vecteur (identique a resize_array() pour le traitement des anciennes valeurs et d...">resize</a>(graph_size + n2, 2);
          <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; n2; i++)
            {
              graph(graph_size, 0) = tmp(i, 0);
              graph(graph_size, 1) = tmp(i, 1);
              graph_size++;
            }
        }
<span class="comment">// Calcul des composantes connexes du graphe</span>
      renum.<a class="code" href="classArrOfInt.html#a9b3afbb46b16870dbd36236c8935b535">resize_array</a>(nb_total_components);
      <span class="keyword">const</span> <span class="keywordtype">int</span> n = <a class="code" href="Connex__components_8cpp.html#a1e4b3977c09e7f6f4e8a3d554c05e727" title="recherche des composantes connexes d&#39;un graphe local (non distribue sur les processeurs) non symetriq...">compute_graph_connex_components</a>(graph, renum);
      <a class="code" href="classProcess.html#a57e0f54b11e6eaadbea224fa904b18dd" title="Renvoie un objet statique de type Sortie qui sert de journal d&#39;evenements. Si message_level &lt;= verbose...">Process::Journal</a>() &lt;&lt; <span class="stringliteral">&quot;compute_global_connex_components: nb_components=&quot;</span> &lt;&lt; n &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
    }
  <span class="keywordflow">else</span>
    {
<span class="comment">// Envoi du graphe local au processeur 0</span>
      <a class="code" href="communications_8cpp.html#af9feb6405277b375b2ebcbfaec9f8af3">envoyer</a>(graph, 0, 54 <span class="comment">/* tag */</span>);
    }

<span class="comment">// Reception des composantes connexes</span>
  <a class="code" href="communications_8cpp.html#a2335b36078ae87e23dab400a6e129a3c">envoyer_broadcast</a>(renum, 0 <span class="comment">/* processeur source */</span>);

<span class="comment">// Renumerotation des composantes dans num_compo</span>
  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; nbelem_tot; i++)
    {
      <span class="keyword">const</span> <span class="keywordtype">int</span> x = num_compo[i];
      <span class="keywordflow">if</span> (x &gt;= 0)
        {
          <span class="keyword">const</span> <span class="keywordtype">int</span> new_x = renum[x];
          num_compo[i] = new_x;
        }
    }
<span class="comment">// Verification: si on fait un echange espace virtuel,</span>
<span class="comment">// cela ne doit par changer le numero des composantes</span>
<span class="comment">// connexes !</span>

  <span class="keywordtype">int</span> nb_components = 0;
<span class="comment">// Tous les processeurs possedent le meme tableau renum, tout le monde</span>
<span class="comment">// calcule donc le meme maximum !</span>
  <span class="keywordflow">if</span> (renum.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() &gt; 0)
    nb_components = <a class="code" href="ArrOfDouble_8cpp.html#a95241fccf4bed7fb7a4e2340b7735f14" title="Retourne la valeur maximale.">max_array</a>(renum) + 1;
  <span class="keywordflow">return</span> nb_components;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a1e4b3977c09e7f6f4e8a3d554c05e727"></a><!-- doxytag: member="Connex_components.cpp::compute_graph_connex_components" ref="a1e4b3977c09e7f6f4e8a3d554c05e727" args="(const IntTab &amp;graph, ArrOfInt &amp;connex_components)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int compute_graph_connex_components </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIntTab.html">IntTab</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>connex_components</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>recherche des composantes connexes d'un graphe local (non distribue<br/>
sur les processeurs) non symetrique.<br/>
Parametre: graph<br/>
On suppose que "graph" est un tableau a deux colonnes<br/>
contenant des couples d'indices de "sommets" d'un graphe. Ces couples definissent<br/>
un graphe dont on veut chercher les composantes connexes:<br/>
deux indices i et j sont dans la meme composante connexe si et seulement si il<br/>
existe une suite de couples qui relient directement ou indirectement i et j.<br/>
Parametre: connex_components<br/>
On suppose que connex_components est dimensionne a nb_sommets, le nombre de sommets du graphe.<br/>
On met dans connex_components[i] le numero de la composante connexe du graphe a laquelle appartient<br/>
le "sommet" i. On attribue tous les numeros i tels que 0 &lt;= i &lt; N<br/>
Valeur de retour: le nombre N de composantes connexes trouvees. </p>

<p><p>&lt; fin de liste</p>
<p>&lt; la plus petite</p>
<p>&lt; la plus grande </p>
</p>

<p>Definition at line <a class="el" href="Connex__components_8cpp_source.html#l00125">125</a> of file <a class="el" href="Connex__components_8cpp_source.html">Connex_components.cpp</a>.</p>

<p>References <a class="el" href="IntTab_8h_source.html#l00233">IntTab::dimension()</a>, <a class="el" href="Zone__VEF__PreP1b_8cpp_source.html#l00204">next()</a>, and <a class="el" href="ArrOfInt_8h_source.html#l00342">ArrOfInt::size_array()</a>.</p>

<p>Referenced by <a class="el" href="Connex__components_8cpp_source.html#l00215">compute_global_connex_components()</a>.</p>
<div class="fragment"><pre class="fragment">{
<span class="comment">// connex_components doit deja avoir la bonne taille en entree !</span>
  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_sommets = connex_components.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>();

<span class="comment">// renum_data definit des listes chainees de numeros de &quot;sommets&quot; appartenant a</span>
<span class="comment">// la meme composante connexe.</span>
<span class="comment">// renum_data(i,0)= numero du premier &quot;sommet&quot; de la liste a laquelle appartient i</span>
<span class="comment">// renum_data(i,1)= numero du &quot;sommet&quot; suivant dans la liste</span>
  <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a> renum_data(nb_sommets, 2);
<span class="comment">// Au debut, chaque sommet est toute seule dans une liste:</span>
  <span class="keywordtype">int</span> i_sommet;
  <span class="keywordflow">for</span> (i_sommet = 0; i_sommet &lt; nb_sommets; i_sommet++)
    {
      renum_data(i_sommet, 0) = i_sommet;
      renum_data(i_sommet, 1) = -1; <span class="comment">//!&lt; fin de liste</span>
<span class="comment"></span>    }
  <span class="keyword">const</span> <span class="keywordtype">int</span> nbcouples = graph.<a class="code" href="classIntTab.html#abc3b32c94925a82f69d5b153a356e359" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(0);
  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i_couple = 0; i_couple &lt; nbcouples; i_couple++)
    {
      <span class="keyword">const</span> <span class="keywordtype">int</span> compo1 = graph(i_couple, 0); <span class="comment">//!&lt; la plus petite</span>
<span class="comment"></span>      <span class="keyword">const</span> <span class="keywordtype">int</span> compo2 = graph(i_couple, 1); <span class="comment">//!&lt; la plus grande</span>
<span class="comment"></span>      assert(compo1 != compo2);
<span class="comment">// Si les deux composantes sont deja dans la meme liste,</span>
<span class="comment">// ne rien faire.</span>
      <span class="keywordflow">if</span> (renum_data(compo1, 0) == renum_data(compo2, 0))
        <span class="keywordflow">continue</span>;
<span class="comment">// Reunir la liste1 contenant compo1 et la liste2 contenant compo2:</span>
<span class="comment">// 1) trouver la fin de la premiere liste</span>
      <span class="keywordtype">int</span> fin_liste1 = compo1;
      <span class="keywordflow">for</span> (;;)
        {
          <span class="keyword">const</span> <span class="keywordtype">int</span> <a class="code" href="Zone__VEF__PreP1b_8cpp.html#a24a462bbedad66c2a21f5f6f84b8ec5b">next</a> = renum_data(fin_liste1, 1);
          <span class="keywordflow">if</span> (next &lt; 0)
            <span class="keywordflow">break</span>;
          fin_liste1 = <a class="code" href="Zone__VEF__PreP1b_8cpp.html#a24a462bbedad66c2a21f5f6f84b8ec5b">next</a>;
        }
<span class="comment">// 2) brancher la liste2 a la fin de la liste1 :</span>
      <span class="keyword">const</span> <span class="keywordtype">int</span> debut_liste2 = renum_data(compo2, 0);
      renum_data(fin_liste1, 1) = debut_liste2;
<span class="comment">// 2) mettre a jour le debut de liste pour liste2 :</span>
      i_sommet = debut_liste2;
      <span class="keyword">const</span> <span class="keywordtype">int</span> debut_liste1 = renum_data(compo1, 0);
      <span class="keywordflow">do</span>
        {
          renum_data(i_sommet, 0) = debut_liste1;
          i_sommet = renum_data(i_sommet, 1);
        }
      <span class="keywordflow">while</span> (i_sommet &gt;= 0);
    }

<span class="comment">// Creation d&#39;une numerotation contigue pour les composantes:</span>
<span class="comment">// Prochain numero a attribuer</span>
  <span class="keywordtype">int</span> count = 0;
  connex_components = -1;
  <span class="keywordflow">for</span> (i_sommet = 0; i_sommet &lt; nb_sommets; i_sommet++)
    {
      <span class="keywordflow">if</span> (connex_components[i_sommet] &lt; 0)
        {
<span class="comment">// sommet pas encore traite</span>
<span class="comment">// Associe un nouveau numero a tous les sommets de la composante</span>
<span class="comment">// connexe a laquelle appartient i_sommet:</span>
          <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = renum_data(i_sommet, 0); i &gt;= 0; i = renum_data(i, 1))
            connex_components[i] = count;
<span class="comment">// Nouveau numero pour la prochaine composante</span>
          count++;
        }
    }
<span class="comment">// On renvoie le nombre de composantes connexes trouvees</span>
  <span class="keywordflow">return</span> count;
}
</pre></div>
</div>
</div>
<a class="anchor" id="ad771774190b40158b92030966f3f5a17"></a><!-- doxytag: member="Connex_components.cpp::search_connex_components_local" ref="ad771774190b40158b92030966f3f5a17" args="(const IntTab &amp;elem_faces, const IntTab &amp;faces_elem, IntVect &amp;num_compo)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int search_connex_components_local </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIntTab.html">IntTab</a> &amp;&#160;</td>
          <td class="paramname"><em>elem_faces</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIntTab.html">IntTab</a> &amp;&#160;</td>
          <td class="paramname"><em>faces_elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classIntVect.html">IntVect</a> &amp;&#160;</td>
          <td class="paramname"><em>num_compo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calcul des ensembles connexes par faces d'elements<br/>
non "marques" (les elements sont relies entre eux par un graphe<br/>
symetrique passant par les faces).<br/>
Une portion de domaine connexe porte un numero 0 &lt;= i &lt; N<br/>
unique et est delimite soit par un bord, soit par un element voisin "marque"<br/>
par num_compo[elem] = -1.<br/>
Cette methode est sequentielle (peut etre appelee sur un seul processeur)<br/>
Parametre: elem_faces<br/>
graph de connectivite elements-faces (pour chaque element i, indices<br/>
des faces de cet element), voir <a class="el" href="classZone__VF.html#a8e09b61902b9f1d2c4c7bedc3b8f39d3" title="renvoie le tableau de connectivite element/faces">Zone_VF::elem_faces()</a><br/>
Parametre: faces_elem<br/>
graph de connectivite faces-elements (pour chaque face, indice du<br/>
ou des deux elements adjacents), voir <a class="el" href="classZone__VF.html#a816ac37fd526f962468cae6fbd8061f8" title="renvoie le tableaux des volumes des connectivites face elements cf au dessus.">Zone_VF::face_voisins()</a><br/>
Parametre: num_compo<br/>
En entree, un tableau tel que num_compo.size_array() == elem_faces.dimension_tot(0),<br/>
et dont certaines valeurs valent -1 (elements marques), et d'autres non.<br/>
En sortie: les elements pour lesquels num_compo = -1 ne sont pas modifies, les autres<br/>
sont numerotes par composante connexe locale. On remplit tout le tableau<br/>
jusqu'a size_tot() y compris les elements virtuels. Les numeros de composantes<br/>
sont locaux a ce processeur.<br/>
Valeur de retour: N, nombre de composantes connexes locales. </p>

<p>Definition at line <a class="el" href="Connex__components_8cpp_source.html#l00048">48</a> of file <a class="el" href="Connex__components_8cpp_source.html">Connex_components.cpp</a>.</p>

<p>References <a class="el" href="ArrOfInt_8h_source.html#l00355">ArrOfInt::append_array()</a>, <a class="el" href="IntTab_8h_source.html#l00233">IntTab::dimension()</a>, <a class="el" href="IntTab_8h_source.html#l00244">IntTab::dimension_tot()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00240">ArrOfInt::resize_array()</a>, <a class="el" href="ArrOfInt_8cpp_source.html#l00443">ArrOfInt::set_smart_resize()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00342">ArrOfInt::size_array()</a>, and <a class="el" href="IntVect_8h_source.html#l00145">IntVect::size_totale()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">const</span> <span class="keywordtype">int</span> nbelem = num_compo.<a class="code" href="classIntVect.html#afa716e1f0a1f0f74f4f73e95b5651412" title="Identique a size_array()">size_totale</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_voisins = elem_faces.<a class="code" href="classIntTab.html#abc3b32c94925a82f69d5b153a356e359" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(1);
  assert(elem_faces.<a class="code" href="classIntTab.html#a71e9b9ddc1793094b1b3f109377952b1" title="Returns the total dimensions of the multi-dimensionnal array, including virtual items (used in parall...">dimension_tot</a>(0) == nbelem);
  {
    <span class="keywordtype">int</span> i;
    <span class="keywordflow">for</span> (i = 0; i &lt; nbelem; i++)
      <span class="keywordflow">if</span> (num_compo[i] != -1)
        num_compo[i] = -2;
  }
  <span class="keywordtype">int</span> start_element = 0;
  <span class="keywordtype">int</span> num_compo_courant = 0;
  <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> liste_elems;
  liste_elems.<a class="code" href="classArrOfInt.html#a22d744bcd452d039580d1d9186f02b4e" title="Change le mode l&#39;allocation memoire: reallocation d&#39;un tableau a chaque changement de taille (flag = ...">set_smart_resize</a>(1);
  <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> tmp_liste;
  tmp_liste.<a class="code" href="classArrOfInt.html#a22d744bcd452d039580d1d9186f02b4e" title="Change le mode l&#39;allocation memoire: reallocation d&#39;un tableau a chaque changement de taille (flag = ...">set_smart_resize</a>(1);
  <span class="keywordflow">do</span>
    {
<span class="comment">// Cherche le prochain element non attribue a une composante connexe</span>
      <span class="keywordflow">while</span> (start_element &lt; nbelem &amp;&amp; num_compo[start_element] &gt;= -1)
        start_element++;
      <span class="keywordflow">if</span> (start_element == nbelem)
        <span class="keywordflow">break</span>;
<span class="comment">// Recherche des elements de la composante connexe a partir de cet element</span>
      liste_elems.<a class="code" href="classArrOfInt.html#a9b3afbb46b16870dbd36236c8935b535">resize_array</a>(1);
      liste_elems[0] = start_element;
      num_compo[start_element] = num_compo_courant;
      <span class="keywordflow">while</span> (liste_elems.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() &gt; 0)
        {
          tmp_liste.<a class="code" href="classArrOfInt.html#a9b3afbb46b16870dbd36236c8935b535">resize_array</a>(0);
          <span class="keyword">const</span> <span class="keywordtype">int</span> liste_elems_size = liste_elems.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>();
          <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i_elem = 0; i_elem &lt; liste_elems_size; i_elem++)
            {
              <span class="keyword">const</span> <span class="keywordtype">int</span> elem = liste_elems[i_elem];
<span class="comment">// Ajout des voisins non attribues de cet element dans la liste a</span>
<span class="comment">// traiter a l&#39;etape suivante</span>
              <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; nb_voisins; j++)
                {
                  <span class="keyword">const</span> <span class="keywordtype">int</span> face = elem_faces(elem, j);
                  <span class="keyword">const</span> <span class="keywordtype">int</span> voisin = faces_elem(face, 0) + faces_elem(face, 1) - elem;
                  <span class="keywordflow">if</span> (voisin &gt;= 0)
                    {
                      <span class="keyword">const</span> <span class="keywordtype">int</span> num = num_compo[voisin];
                      <span class="keywordflow">if</span> (num == -2)
                        {
                          num_compo[voisin] = num_compo_courant;
                          tmp_liste.<a class="code" href="classArrOfInt.html#a3f39d0966599416e7b1f7cd8159d8d01" title="Ajoute une case en fin de tableau et y stocke la &quot;valeur&quot;.">append_array</a>(voisin);
                        }
                    }
                }
            }
          liste_elems = tmp_liste;
        }
      num_compo_courant++;
    }
  <span class="keywordflow">while</span> (1);
<span class="comment">// Renvoie le nombre de composantes connexes locales trouvees</span>
  <span class="keywordflow">return</span> num_compo_courant;
}
</pre></div>
</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Tue Dec 14 2021 19:35:49 for TRUST by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
