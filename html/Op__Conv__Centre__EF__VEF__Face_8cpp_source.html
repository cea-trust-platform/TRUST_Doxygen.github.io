<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>TRUST: src/VEF/Operateurs/Op_Conv_Centre_EF_VEF_Face.cpp Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">TRUST&#160;<span id="projectnumber">1.8.4</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
<div class="header">
  <div class="headertitle">
<div class="title">src/VEF/Operateurs/Op_Conv_Centre_EF_VEF_Face.cpp</div>  </div>
</div>
<div class="contents">
<a href="Op__Conv__Centre__EF__VEF__Face_8cpp.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/****************************************************************************</span>
<a name="l00002"></a>00002 <span class="comment">* Copyright (c) 2015 - 2016, CEA</span>
<a name="l00003"></a>00003 <span class="comment">* All rights reserved.</span>
<a name="l00004"></a>00004 <span class="comment">*</span>
<a name="l00005"></a>00005 <span class="comment">* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</span>
<a name="l00006"></a>00006 <span class="comment">* 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.</span>
<a name="l00007"></a>00007 <span class="comment">* 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.</span>
<a name="l00008"></a>00008 <span class="comment">* 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.</span>
<a name="l00009"></a>00009 <span class="comment">*</span>
<a name="l00010"></a>00010 <span class="comment">* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.</span>
<a name="l00011"></a>00011 <span class="comment">* IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;</span>
<a name="l00012"></a>00012 <span class="comment">* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>
<a name="l00013"></a>00013 <span class="comment">*</span>
<a name="l00014"></a>00014 <span class="comment">*****************************************************************************/</span>
<a name="l00015"></a>00015 <span class="comment">//</span>
<a name="l00016"></a>00016 <span class="comment">// </span>
<a name="l00017"></a>00017 <span class="comment">// File:        Op_Conv_Centre_EF_VEF_Face.cpp</span>
<a name="l00018"></a>00018 <span class="comment">// Directory:   $TRUST_ROOT/src/VEF/Operateurs</span>
<a name="l00019"></a>00019 <span class="comment">// Version:     /main/17</span>
<a name="l00020"></a>00020 <span class="comment">// </span>
<a name="l00021"></a>00021 <span class="comment">//</span>
<a name="l00022"></a>00022 
<a name="l00023"></a>00023 <span class="preprocessor">#include &lt;<a class="code" href="Op__Conv__Centre__EF__VEF__Face_8h.html">Op_Conv_Centre_EF_VEF_Face.h</a>&gt;</span>
<a name="l00024"></a>00024 
<a name="l00025"></a><a class="code" href="Op__Conv__Centre__EF__VEF__Face_8cpp.html#a9f9f809be9c16f9f1f55e541e54c2134">00025</a> <a class="code" href="Op__Diff__CoviMAC__Face_8cpp.html#aa86ec8ba612a969d9b4370b775037144">Implemente_instanciable</a>(<a class="code" href="classOp__Conv__Centre__EF__VEF__Face.html" title="class Op_Conv_Centre_EF_VEF_Face Cette classe represente l&#39;operateur de convection associe a une equa...">Op_Conv_Centre_EF_VEF_Face</a>,<span class="stringliteral">&quot;Op_Conv_Centre_EF_VEF_P1NC&quot;</span>,<a class="code" href="classOp__Conv__VEF__base.html" title="class Op_Conv_VEF_base Classe de base des operateurs de convection VEF">Op_Conv_VEF_base</a>);
<a name="l00026"></a>00026 
<a name="l00027"></a>00027 <span class="comment"></span>
<a name="l00028"></a>00028 <span class="comment">////!&lt; printOn </span>
<a name="l00029"></a>00029 <span class="comment"></span><span class="comment">//</span>
<a name="l00030"></a>00030 
<a name="l00031"></a><a class="code" href="classOp__Conv__Centre__EF__VEF__Face.html#aaf3595258f3a8804df29d60f6273389f">00031</a> <a class="code" href="classSortie.html" title="Classe de base des flux de sortie. Elle sait ecrire des types simples&lt;br&gt;(entiers, flottants) et des Ob...">Sortie</a>&amp; <a class="code" href="classOp__Conv__Centre__EF__VEF__Face.html#aaf3595258f3a8804df29d60f6273389f" title="NE FAIT RIEN A surcharger dans les classes derivees.">Op_Conv_Centre_EF_VEF_Face::printOn</a>(<a class="code" href="classSortie.html" title="Classe de base des flux de sortie. Elle sait ecrire des types simples&lt;br&gt;(entiers, flottants) et des Ob...">Sortie</a>&amp; s )<span class="keyword"> const</span>
<a name="l00032"></a>00032 <span class="keyword"></span>{
<a name="l00033"></a>00033   <span class="keywordflow">return</span> s &lt;&lt; <a class="code" href="classObjet__U.html#aa58e9a81c0ddc2c1149053b8f96698ac" title="renvoie la chaine identifiant la classe.">que_suis_je</a>() ;
<a name="l00034"></a>00034 }
<a name="l00035"></a>00035 <span class="comment"></span>
<a name="l00036"></a>00036 <span class="comment">////!&lt; readOn </span>
<a name="l00037"></a>00037 <span class="comment"></span><span class="comment">//</span>
<a name="l00038"></a>00038 
<a name="l00039"></a><a class="code" href="classOp__Conv__Centre__EF__VEF__Face.html#aae07b152ff1d421237ea2598a45ff519">00039</a> <a class="code" href="classEntree.html" title="Classe de definition des operateurs et methodes pour toute lecture dans un flot d&#39;entree (fichier...">Entree</a>&amp; <a class="code" href="classOp__Conv__Centre__EF__VEF__Face.html#aae07b152ff1d421237ea2598a45ff519" title="NE FAIT RIEN A surcharger dans les classes derivees.">Op_Conv_Centre_EF_VEF_Face::readOn</a>(<a class="code" href="classEntree.html" title="Classe de definition des operateurs et methodes pour toute lecture dans un flot d&#39;entree (fichier...">Entree</a>&amp; s )
<a name="l00040"></a>00040 {
<a name="l00041"></a>00041   <span class="keywordflow">return</span> s ;
<a name="l00042"></a>00042 }
<a name="l00043"></a>00043 
<a name="l00044"></a>00044 <span class="comment">// ATTENTION!!!!!! les modifs concernant fluent_ et autre_num_face_loc sont faites qu en 3D!!!!</span>
<a name="l00045"></a>00045 <span class="comment">// C.A. 30/06/99</span>
<a name="l00046"></a>00046 
<a name="l00047"></a>00047 <span class="comment">//</span>
<a name="l00048"></a>00048 <span class="comment">// </span>
<a name="l00049"></a>00049 <span class="comment">// Implementation des fonctions</span>
<a name="l00050"></a>00050 <span class="comment">// </span>
<a name="l00051"></a>00051 <span class="comment">// de la classe Op_Conv_Centre_EF_VEF_Face</span>
<a name="l00052"></a>00052 <span class="comment">// </span>
<a name="l00053"></a>00053 <span class="comment">//</span>
<a name="l00054"></a>00054 
<a name="l00055"></a>00055 
<a name="l00056"></a><a class="code" href="classOp__Conv__Centre__EF__VEF__Face.html#a7ea2ab9e5aaf91f656d64862e00d2502">00056</a> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; <a class="code" href="classOp__Conv__Centre__EF__VEF__Face.html#a7ea2ab9e5aaf91f656d64862e00d2502">Op_Conv_Centre_EF_VEF_Face::ajouter</a>(<span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; transporte,
<a name="l00057"></a>00057                                                <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; resu)<span class="keyword"> const</span>
<a name="l00058"></a>00058 <span class="keyword"></span>{
<a name="l00059"></a>00059   <span class="keyword">const</span> <a class="code" href="classZone__Cl__VEF.html">Zone_Cl_VEF</a>&amp; zone_Cl_VEF = <a class="code" href="classOp__Conv__VEF__base.html#a03f677ee7911706a4f85cd37e0ca4535">la_zcl_vef</a>.<a class="code" href="classRef__Zone__Cl__VEF.html#a0970d7253def65ad4f0c5ce1830fd243">valeur</a>();
<a name="l00060"></a>00060   <span class="keyword">const</span> <a class="code" href="classZone__VEF.html" title="class Zone_VEF Classe instanciable qui derive de Zone_VF. Cette classe contient les informations geom...">Zone_VEF</a>&amp; zone_VEF = <a class="code" href="classOp__Conv__VEF__base.html#a6c29a488a6805ba4a9f2f059cdba77ae">la_zone_vef</a>.<a class="code" href="classRef__Zone__VEF.html#aafd9a5ee1a76f290c9c6b5447b0c8d30">valeur</a>();
<a name="l00061"></a>00061   <span class="keyword">const</span> <a class="code" href="classChamp__Inc__base.html" title="Classe Champ_Inc_base Classe de base des champs inconnues qui sont les champs calcules par une equati...">Champ_Inc_base</a>&amp; la_vitesse=<a class="code" href="classOp__Conv__VEF__base.html#a5547875832fb45e09b1115372fb76ffd">vitesse_</a>.<a class="code" href="classRef__Champ__Inc__base.html#a17553641a4c06730e1562125e07b3490">valeur</a>();
<a name="l00062"></a>00062 
<a name="l00063"></a>00063   <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; porosite_face = zone_VEF.<a class="code" href="classZone__VF.html#ad9d74d1d9da9f50ab26768dbbca7711b">porosite_face</a>();
<a name="l00064"></a>00064 
<a name="l00065"></a>00065   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; elem_faces = zone_VEF.<a class="code" href="classZone__VF.html#a067e462dcd3ab92b0f6d945b19e4eb37" title="renvoie le numero de le ieme face de la maille num_elem la facon dont ces faces sont numerotees est l...">elem_faces</a>();
<a name="l00066"></a>00066   <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; face_normales = zone_VEF.<a class="code" href="classZone__VEF.html#a5742d75972e4846bf9fbb6ed5715053e">face_normales</a>();
<a name="l00067"></a>00067   <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; facette_normales = zone_VEF.<a class="code" href="classZone__VEF.html#a581b1ca0e62c668c92f104351d19fda6">facette_normales</a>();
<a name="l00068"></a>00068   <span class="keyword">const</span> <a class="code" href="classZone.html" title="classe Zone Une Zone est un maillage compose d&#39;un ensemble d&#39;elements geometriques de meme type...">Zone</a>&amp; zone = zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>();
<a name="l00069"></a>00069   <span class="keyword">const</span> <span class="keywordtype">int</span> nfa7 = zone_VEF.<a class="code" href="classZone__VEF.html#a46693c060b8096fb2595ca72192eea2a">type_elem</a>().<a class="code" href="classElem__VEF.html#a4a34777c0083b38dd34c8a400d5b4e90">nb_facette</a>();
<a name="l00070"></a>00070   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_elem_tot = zone_VEF.<a class="code" href="classZone__dis__base.html#a4d6aa445f152aa6dc54d66ea7a071147">nb_elem_tot</a>();
<a name="l00071"></a>00071   <span class="keyword">const</span> <a class="code" href="classIntVect.html">IntVect</a>&amp; rang_elem_non_std = zone_VEF.<a class="code" href="classZone__VEF.html#a4b2171a85e5fc33663a3366acb713584">rang_elem_non_std</a>();
<a name="l00072"></a>00072 
<a name="l00073"></a>00073 
<a name="l00074"></a>00074   <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; normales_facettes_Cl = zone_Cl_VEF.<a class="code" href="classZone__Cl__VEF.html#a83c05e82370553470ed05f10932e0f3f">normales_facettes_Cl</a>();
<a name="l00075"></a>00075   <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; fluent_ = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classDoubleVect.html">DoubleVect</a>, <a class="code" href="classOp__Conv__VEF__base.html#a32b54e8fd5340e238cf4f28ff6e743ec" title="tableau qui sert pour le calcul du pas de temps de stabilite">fluent</a>);
<a name="l00076"></a>00076 
<a name="l00077"></a>00077   <span class="keywordtype">int</span> nfac = zone.<a class="code" href="classZone.html#a548fbc7518be2f122b1a5c9589a443c2" title="Renvoie le nombre de face de type i des elements geometriques constituants la zone. Ex: les objets de la classe Prisme ont 2 types de faces: triangle ou quadrangle.">nb_faces_elem</a>();
<a name="l00078"></a>00078   <span class="keywordtype">int</span> nsom = zone.<a class="code" href="classZone.html#ae0b34a93b9ae8146df2d1884157afe9f" title="Renvoie le nombre de sommets des elements geometriques constituants la zone. Tous les elements de la ...">nb_som_elem</a>();
<a name="l00079"></a>00079 
<a name="l00080"></a>00080 
<a name="l00081"></a>00081 <span class="comment">// Pour le traitement de la convection on distingue les polyedres</span>
<a name="l00082"></a>00082 <span class="comment">// standard qui ne &quot;voient&quot; pas les conditions aux limites et les</span>
<a name="l00083"></a>00083 <span class="comment">// polyedres non standard qui ont au moins une face sur le bord.</span>
<a name="l00084"></a>00084 <span class="comment">// Un polyedre standard a n facettes sur lesquelles on applique le</span>
<a name="l00085"></a>00085 <span class="comment">// schema de convection.</span>
<a name="l00086"></a>00086 <span class="comment">// Pour un polyedre non standard qui porte des conditions aux limites</span>
<a name="l00087"></a>00087 <span class="comment">// de Dirichlet, une partie des facettes sont portees par les faces.</span>
<a name="l00088"></a>00088 <span class="comment">// En bref pour un polyedre le traitement de la convection depend</span>
<a name="l00089"></a>00089 <span class="comment">// du type (triangle, tetraedre ...) et du nombre de faces de Dirichlet.</span>
<a name="l00090"></a>00090 
<a name="l00091"></a>00091   <span class="keywordtype">double</span> flux;
<a name="l00092"></a>00092   <span class="keywordtype">int</span> poly,face_adj,fa7,i,j,comp0,n_bord;
<a name="l00093"></a>00093   <span class="keywordtype">int</span> num_face, rang ,itypcl;
<a name="l00094"></a>00094   <span class="keywordtype">int</span> num10, num20;
<a name="l00095"></a>00095 
<a name="l00096"></a>00096   <span class="keywordtype">int</span> ncomp_ch_transporte;
<a name="l00097"></a>00097   <span class="keywordflow">if</span> (transporte.<a class="code" href="classDoubleTab.html#ae6dda48778e7107e1beb723beef1f75b" title="Returns the number of dimensions of the array (&gt;= 1)">nb_dim</a>() == 1)
<a name="l00098"></a>00098     ncomp_ch_transporte=1;
<a name="l00099"></a>00099   <span class="keywordflow">else</span>
<a name="l00100"></a>00100     ncomp_ch_transporte= transporte.<a class="code" href="classDoubleTab.html#ac3805e2637a3b880ba2d3e650c69dac4" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(1);
<a name="l00101"></a>00101 
<a name="l00102"></a>00102   <a class="code" href="classIntVect.html">IntVect</a> face(nfac);
<a name="l00103"></a>00103   <a class="code" href="classDoubleVect.html">DoubleVect</a> cc(<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>);
<a name="l00104"></a>00104 
<a name="l00105"></a>00105 <span class="comment">//</span>
<a name="l00106"></a>00106   <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a> psc(nfac);
<a name="l00107"></a>00107   <span class="keywordtype">int</span> num_int;
<a name="l00108"></a>00108   <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a> autre_num_face(<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>-1);
<a name="l00109"></a>00109   <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a> autre_num_face_loc(<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>-1);
<a name="l00110"></a>00110   <span class="keywordtype">double</span> coef1=0.,coef2=0.,coef3=0.;
<a name="l00111"></a>00111 <span class="comment">// double psc1;</span>
<a name="l00112"></a>00112   <span class="keywordtype">int</span> nu1,nu2;
<a name="l00113"></a>00113 <span class="comment">// int k;</span>
<a name="l00114"></a>00114   <span class="keywordtype">double</span> f_int;
<a name="l00115"></a>00115 
<a name="l00116"></a>00116   <a class="code" href="classDoubleVect.html">DoubleVect</a> vs(<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>);
<a name="l00117"></a>00117   <a class="code" href="classDoubleVect.html">DoubleVect</a> vc(<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>);
<a name="l00118"></a>00118   <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a> vsom(nsom,<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>);
<a name="l00119"></a>00119 
<a name="l00120"></a>00120 <span class="comment">// On remet a zero le tableau qui sert pour</span>
<a name="l00121"></a>00121 <span class="comment">// le calcul du pas de temps de stabilite</span>
<a name="l00122"></a>00122   fluent_ = 0;
<a name="l00123"></a>00123 
<a name="l00124"></a>00124 <span class="comment">// Traitement particulier pour les faces de periodicite</span>
<a name="l00125"></a>00125 
<a name="l00126"></a>00126   <span class="keywordtype">int</span> nb_faces_perio = 0;
<a name="l00127"></a>00127   <span class="keywordflow">for</span> (n_bord=0; n_bord&lt;zone_VEF.<a class="code" href="classZone__dis__base.html#af22167d614644f55591a29c77eb1c009">nb_front_Cl</a>(); n_bord++)
<a name="l00128"></a>00128     {
<a name="l00129"></a>00129       <span class="keyword">const</span> <a class="code" href="classCond__lim.html" title="classe Cond_lim Classe generique servant a representer n&#39;importe quelle classe derivee de la classe C...">Cond_lim</a>&amp; la_cl = zone_Cl_VEF.<a class="code" href="classZone__Cl__dis__base.html#af75e0ed7786863e4d333bfb29d67c323" title="Renvoie la i-ieme condition aux limites. (version const)">les_conditions_limites</a>(n_bord);
<a name="l00130"></a>00130       <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>()))
<a name="l00131"></a>00131         {
<a name="l00132"></a>00132           <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp; le_bord = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>,la_cl.<a class="code" href="classCond__lim.html#a5b2d24809cee07727006a891d4ce8d22" title="Appel a l&#39;objet sous-jacent Renvoie la frontiere discretisee associee a la condition aux limites...">frontiere_dis</a>());
<a name="l00133"></a>00133           <span class="keywordtype">int</span> num1 = le_bord.<a class="code" href="classFront__VF.html#a4986f0c65653fe9eb40bbbff5a97bf16" title="Numero de la premiere face du bord dans la liste des faces.">num_premiere_face</a>();
<a name="l00134"></a>00134           <span class="keywordtype">int</span> num2 = num1 + le_bord.<a class="code" href="classFront__VF.html#a341e2fcb5117b96e745fd7078ba86bab" title="Nombre de faces reelles du bord.">nb_faces</a>();
<a name="l00135"></a>00135           <span class="keywordflow">for</span> (num_face=num1; num_face&lt;num2; num_face++)
<a name="l00136"></a>00136             nb_faces_perio++;
<a name="l00137"></a>00137         }
<a name="l00138"></a>00138     }
<a name="l00139"></a>00139 
<a name="l00140"></a>00140   <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a> tab;
<a name="l00141"></a>00141   <span class="keywordflow">if</span> (ncomp_ch_transporte == 1)
<a name="l00142"></a>00142     tab.<a class="code" href="classDoubleTab.html#ae83b4d31205c53d9c8d2b43da178ce75" title="Change la taille du vecteur (identique a resize_array() pour le traitement des anciennes valeurs et d...">resize</a>(nb_faces_perio);
<a name="l00143"></a>00143   <span class="keywordflow">else</span>
<a name="l00144"></a>00144     tab.<a class="code" href="classDoubleTab.html#ae83b4d31205c53d9c8d2b43da178ce75" title="Change la taille du vecteur (identique a resize_array() pour le traitement des anciennes valeurs et d...">resize</a>(nb_faces_perio,ncomp_ch_transporte);
<a name="l00145"></a>00145 
<a name="l00146"></a>00146   nb_faces_perio=0;
<a name="l00147"></a>00147   <span class="keywordflow">for</span> (n_bord=0; n_bord&lt;zone_VEF.<a class="code" href="classZone__dis__base.html#af22167d614644f55591a29c77eb1c009">nb_front_Cl</a>(); n_bord++)
<a name="l00148"></a>00148     {
<a name="l00149"></a>00149       <span class="keyword">const</span> <a class="code" href="classCond__lim.html" title="classe Cond_lim Classe generique servant a representer n&#39;importe quelle classe derivee de la classe C...">Cond_lim</a>&amp; la_cl = zone_Cl_VEF.<a class="code" href="classZone__Cl__dis__base.html#af75e0ed7786863e4d333bfb29d67c323" title="Renvoie la i-ieme condition aux limites. (version const)">les_conditions_limites</a>(n_bord);
<a name="l00150"></a>00150       <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>()))
<a name="l00151"></a>00151         {
<a name="l00152"></a>00152 <span class="comment">// const Periodique&amp; la_cl_perio = ref_cast(Periodique, la_cl.valeur());</span>
<a name="l00153"></a>00153           <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp; le_bord = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>,la_cl.<a class="code" href="classCond__lim.html#a5b2d24809cee07727006a891d4ce8d22" title="Appel a l&#39;objet sous-jacent Renvoie la frontiere discretisee associee a la condition aux limites...">frontiere_dis</a>());
<a name="l00154"></a>00154           <span class="keywordtype">int</span> num1 = le_bord.<a class="code" href="classFront__VF.html#a4986f0c65653fe9eb40bbbff5a97bf16" title="Numero de la premiere face du bord dans la liste des faces.">num_premiere_face</a>();
<a name="l00155"></a>00155           <span class="keywordtype">int</span> num2 = num1 + le_bord.<a class="code" href="classFront__VF.html#a341e2fcb5117b96e745fd7078ba86bab" title="Nombre de faces reelles du bord.">nb_faces</a>();
<a name="l00156"></a>00156           <span class="keywordflow">for</span> (num_face=num1; num_face&lt;num2; num_face++)
<a name="l00157"></a>00157             {
<a name="l00158"></a>00158               <span class="keywordflow">if</span> (ncomp_ch_transporte == 1)
<a name="l00159"></a>00159                 tab(nb_faces_perio) = resu(num_face);
<a name="l00160"></a>00160               <span class="keywordflow">else</span>
<a name="l00161"></a>00161                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> comp=0; comp&lt;ncomp_ch_transporte; comp++)
<a name="l00162"></a>00162                   tab(nb_faces_perio,comp) = resu(num_face,comp);
<a name="l00163"></a>00163               nb_faces_perio++;
<a name="l00164"></a>00164             }
<a name="l00165"></a>00165         }
<a name="l00166"></a>00166     }
<a name="l00167"></a>00167 
<a name="l00168"></a>00168 
<a name="l00169"></a>00169 <span class="comment">// Les polyedres non standard sont ranges en 2 groupes dans la Zone_VEF:</span>
<a name="l00170"></a>00170 <span class="comment">// - polyedres bords et joints</span>
<a name="l00171"></a>00171 <span class="comment">// - polyedres bords et non joints</span>
<a name="l00172"></a>00172 <span class="comment">// On traite les polyedres en suivant l&#39;ordre dans lequel ils figurent</span>
<a name="l00173"></a>00173 <span class="comment">// dans la zone</span>
<a name="l00174"></a>00174 
<a name="l00175"></a>00175 <span class="comment">// boucle sur les polys</span>
<a name="l00176"></a>00176   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; KEL=zone_VEF.<a class="code" href="classZone__VEF.html#a46693c060b8096fb2595ca72192eea2a">type_elem</a>().<a class="code" href="classDeriv__Elem__VEF__base.html#a2886905d5071be902c77248b69ca0b7b">valeur</a>().<a class="code" href="classElem__VEF__base.html#ab129610ef702aa8c9c98dcb4c7551172">KEL</a>();
<a name="l00177"></a>00177   <span class="keywordflow">for</span> (poly=0; poly&lt;nb_elem_tot; poly++)
<a name="l00178"></a>00178     {
<a name="l00179"></a>00179 
<a name="l00180"></a>00180       rang = rang_elem_non_std(poly);
<a name="l00181"></a>00181       <span class="keywordflow">if</span> (rang==-1)
<a name="l00182"></a>00182         itypcl=0;
<a name="l00183"></a>00183       <span class="keywordflow">else</span>
<a name="l00184"></a>00184         itypcl=zone_Cl_VEF.<a class="code" href="classZone__Cl__VEF.html#a483bdab7690f844ed04e3defe04ec70a">type_elem_Cl</a>(rang);
<a name="l00185"></a>00185 
<a name="l00186"></a>00186 <span class="comment">// calcul des numeros des faces du polyedre</span>
<a name="l00187"></a>00187       <span class="keywordflow">for</span> (face_adj=0; face_adj&lt;nfac; face_adj++)
<a name="l00188"></a>00188         face[face_adj]= elem_faces(poly,face_adj);
<a name="l00189"></a>00189 
<a name="l00190"></a>00190 <span class="comment">// On cherche les numeros locaux de tpoutes les faces</span>
<a name="l00191"></a>00191       <span class="keywordflow">for</span> (fa7=0; fa7&lt;nfa7; fa7++)
<a name="l00192"></a>00192         {
<a name="l00193"></a>00193           nu1=-1;
<a name="l00194"></a>00194           nu2=-1;
<a name="l00195"></a>00195           num10 = face[KEL(0,fa7)];
<a name="l00196"></a>00196           num20 = face[KEL(1,fa7)];
<a name="l00197"></a>00197 <span class="comment">// La facette est entouree des faces num1 et num2</span>
<a name="l00198"></a>00198 <span class="comment">// Cerr &lt;&lt; &quot;num1=&quot; &lt;&lt; num1 &lt;&lt; &quot;  num2=&quot; &lt;&lt; num2 &lt;&lt; finl;</span>
<a name="l00199"></a>00199 
<a name="l00200"></a>00200 <span class="comment">// On cherche le numero des autres faces</span>
<a name="l00201"></a>00201 
<a name="l00202"></a>00202           i=0;
<a name="l00203"></a>00203           j=0;
<a name="l00204"></a>00204 <span class="comment">// k=0;</span>
<a name="l00205"></a>00205           <span class="keywordflow">while</span>(i&lt;nfac)
<a name="l00206"></a>00206             {
<a name="l00207"></a>00207               num_int = face[i];
<a name="l00208"></a>00208               <span class="keywordflow">if</span> (num_int == num10)
<a name="l00209"></a>00209                 {
<a name="l00210"></a>00210                   nu1=i;
<a name="l00211"></a>00211 <span class="comment">// Cerr &lt;&lt; &quot;nu1 (dans les boucles)=&quot; &lt;&lt; nu1 &lt;&lt; finl;</span>
<a name="l00212"></a>00212                 }
<a name="l00213"></a>00213               <span class="keywordflow">else</span> <span class="keywordflow">if</span> (num_int == num20)
<a name="l00214"></a>00214                 {
<a name="l00215"></a>00215                   nu2=i;
<a name="l00216"></a>00216 <span class="comment">// Cerr &lt;&lt; &quot;nu2 (dans les boucles)=&quot; &lt;&lt; nu2 &lt;&lt; finl;</span>
<a name="l00217"></a>00217                 }
<a name="l00218"></a>00218               <span class="keywordflow">else</span>
<a name="l00219"></a>00219                 {
<a name="l00220"></a>00220                   autre_num_face_loc(j)=i;
<a name="l00221"></a>00221                   autre_num_face(j)=num_int;
<a name="l00222"></a>00222 <span class="comment">// Cerr &lt;&lt; &quot;autre_num_face (dans les boucles)=&quot; &lt;&lt; autre_num_face(j) &lt;&lt; finl;</span>
<a name="l00223"></a>00223                   j++;
<a name="l00224"></a>00224 <span class="comment">// k++;</span>
<a name="l00225"></a>00225                 }
<a name="l00226"></a>00226               i++;
<a name="l00227"></a>00227             }
<a name="l00228"></a>00228 
<a name="l00229"></a>00229           <span class="keywordflow">if</span> (rang==-1)
<a name="l00230"></a>00230             {
<a name="l00231"></a>00231               <span class="keywordflow">for</span> (i=0; i&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; i++)
<a name="l00232"></a>00232                 cc[i] = facette_normales(poly,fa7,i);
<a name="l00233"></a>00233             }
<a name="l00234"></a>00234           <span class="keywordflow">else</span>
<a name="l00235"></a>00235             <span class="keywordflow">for</span> (i=0; i&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; i++)
<a name="l00236"></a>00236               cc[i] = normales_facettes_Cl(rang,fa7,i);
<a name="l00237"></a>00237 
<a name="l00238"></a>00238 <span class="comment">// On calcule les produits scalaires u(xi).n.S</span>
<a name="l00239"></a>00239           <span class="keywordflow">for</span> (i=0; i&lt;nfac; i ++)
<a name="l00240"></a>00240             {
<a name="l00241"></a>00241               psc[i] = 0.;
<a name="l00242"></a>00242               <span class="keywordflow">for</span> (j=0; j&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; j++)
<a name="l00243"></a>00243                 {
<a name="l00244"></a>00244 <span class="comment">// Cerr &lt;&lt; &quot;cc[j]=&quot; &lt;&lt; cc[j] &lt;&lt; finl;</span>
<a name="l00245"></a>00245 <span class="comment">// Cerr &lt;&lt; &quot;la_vitesse(face[i],j)=&quot; &lt;&lt; la_vitesse(face[i],j) &lt;&lt; finl;</span>
<a name="l00246"></a>00246 
<a name="l00247"></a>00247                   psc[i]+= la_vitesse(face[i],j)*cc[j]*porosite_face(face[i]);
<a name="l00248"></a>00248                 }
<a name="l00249"></a>00249 <span class="comment">// Cerr &lt;&lt; &quot;psc[&quot; &lt;&lt; i &lt;&lt; &quot;]=&quot; &lt;&lt;  psc[i] &lt;&lt; finl;</span>
<a name="l00250"></a>00250             }
<a name="l00251"></a>00251 
<a name="l00252"></a>00252 <span class="comment">// assert(ncomp_ch_transporte==dimension);</span>
<a name="l00253"></a>00253 <span class="comment">// Ce schema est valable (enfin je crois...) uniquement quand ch_transporte = ch_tranportant = vitesse??</span>
<a name="l00254"></a>00254 
<a name="l00255"></a>00255 
<a name="l00256"></a>00256           <span class="keywordflow">if</span> (dimension == 2)
<a name="l00257"></a>00257             {
<a name="l00258"></a>00258               <span class="keywordflow">switch</span>(itypcl)
<a name="l00259"></a>00259                 {
<a name="l00260"></a>00260                 <span class="keywordflow">case</span> 0:
<a name="l00261"></a>00261                   {
<a name="l00262"></a>00262                     coef1  = 13.0*( psc[nu1]+psc[nu2] ) ;
<a name="l00263"></a>00263                     coef1 -=  8.0*psc[autre_num_face_loc(0)];
<a name="l00264"></a>00264 
<a name="l00265"></a>00265                     coef2  =  8.0*( psc[nu1]+psc[nu2] ) ;
<a name="l00266"></a>00266                     coef2 -=  7.0*psc[autre_num_face_loc(0)];
<a name="l00267"></a>00267 
<a name="l00268"></a>00268                     <span class="keywordflow">if</span> (ncomp_ch_transporte == 1)
<a name="l00269"></a>00269                       {
<a name="l00270"></a>00270                         flux  = (transporte(num10)+transporte(num20))*coef1;
<a name="l00271"></a>00271                         flux -=  transporte(autre_num_face(0))*coef2;
<a name="l00272"></a>00272                         flux /= 27.;
<a name="l00273"></a>00273                         resu(num10) -= flux;
<a name="l00274"></a>00274                       }
<a name="l00275"></a>00275                     <span class="keywordflow">else</span>
<a name="l00276"></a>00276                       {
<a name="l00277"></a>00277                         <span class="keywordflow">for</span> (comp0=0; comp0&lt;ncomp_ch_transporte; comp0++)
<a name="l00278"></a>00278                           {
<a name="l00279"></a>00279                             flux  = (transporte(num10,comp0)+transporte(num20,comp0))*coef1;
<a name="l00280"></a>00280                             flux -=  transporte(autre_num_face(0),comp0)*coef2;
<a name="l00281"></a>00281                             flux /= 27.;
<a name="l00282"></a>00282                             resu(num10, comp0) -= flux;
<a name="l00283"></a>00283                             resu(num20, comp0) += flux;
<a name="l00284"></a>00284                           }
<a name="l00285"></a>00285                       }
<a name="l00286"></a>00286 <span class="comment">// Pour la calcul du pas de temps de stabilite</span>
<a name="l00287"></a>00287                     fluent_[num10] += 2.*((psc[nu1]+psc[nu2])- psc[autre_num_face_loc(0)])/3.;
<a name="l00288"></a>00288                     fluent_[num10] -= 2.*((psc[nu1]+psc[nu2])- psc[autre_num_face_loc(0)])/3.;
<a name="l00289"></a>00289                     <span class="keywordflow">break</span>;
<a name="l00290"></a>00290                   }
<a name="l00291"></a>00291                 <span class="keywordflow">default</span> :
<a name="l00292"></a>00292                   {
<a name="l00293"></a>00293                     <span class="keywordtype">int</span> numfa7;
<a name="l00294"></a>00294 <span class="comment">// !!!!!! on a traite que le cas ou le champ transporte est vecteur!!!</span>
<a name="l00295"></a>00295                     <span class="keywordflow">if</span> ((itypcl==1)||(itypcl==2)||(itypcl==4))     <span class="comment">//!&lt; 1 face de Dirichlet!!</span>
<a name="l00296"></a>00296 <span class="comment"></span>                      {
<a name="l00297"></a>00297                         <span class="keywordflow">switch</span>(itypcl)
<a name="l00298"></a>00298                           {
<a name="l00299"></a>00299                           <span class="keywordflow">case</span> 1 :
<a name="l00300"></a>00300                             {
<a name="l00301"></a>00301                               numfa7 = 2;
<a name="l00302"></a>00302                               <span class="keywordflow">break</span>;
<a name="l00303"></a>00303                             }
<a name="l00304"></a>00304                           <span class="keywordflow">case</span> 2 :
<a name="l00305"></a>00305                             {
<a name="l00306"></a>00306                               numfa7 = 1;
<a name="l00307"></a>00307                               <span class="keywordflow">break</span>;
<a name="l00308"></a>00308                             }
<a name="l00309"></a>00309                           <span class="keywordflow">case</span> 4 :
<a name="l00310"></a>00310                             {
<a name="l00311"></a>00311                               numfa7 = 0;
<a name="l00312"></a>00312                               <span class="keywordflow">break</span>;
<a name="l00313"></a>00313                             }
<a name="l00314"></a>00314                           <span class="keywordflow">default</span> :
<a name="l00315"></a>00315                             {
<a name="l00316"></a>00316                               numfa7=-1;
<a name="l00317"></a>00317                               <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;C est pas possible!!!&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
<a name="l00318"></a>00318                               <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">exit</a>();
<a name="l00319"></a>00319                               <span class="keywordflow">break</span>;
<a name="l00320"></a>00320                             }
<a name="l00321"></a>00321                           }
<a name="l00322"></a>00322 
<a name="l00323"></a>00323 <span class="comment">// if (fa7 == itypcl)</span>
<a name="l00324"></a>00324                         <span class="keywordflow">if</span> (fa7 == numfa7)  <span class="comment">//!&lt; On est sur la fa7 non confondu avec la face de Dirichlet</span>
<a name="l00325"></a>00325 <span class="comment"></span>                          {
<a name="l00326"></a>00326                             coef1  = 2.*( psc[nu1]+psc[nu2] ) ;
<a name="l00327"></a>00327                             coef1 -= psc[numfa7];
<a name="l00328"></a>00328 
<a name="l00329"></a>00329                             coef2  =   psc[nu1]+psc[nu2] ;
<a name="l00330"></a>00330                             coef2 -=  2.*psc[numfa7];
<a name="l00331"></a>00331 
<a name="l00332"></a>00332                             <span class="keywordflow">for</span> (comp0=0; comp0&lt;ncomp_ch_transporte; comp0++)
<a name="l00333"></a>00333                               {
<a name="l00334"></a>00334                                 flux  = (transporte(num10,comp0)+transporte(num20,comp0))*coef1;
<a name="l00335"></a>00335                                 flux -=  transporte(numfa7,comp0)*coef2;
<a name="l00336"></a>00336                                 flux /= 6.;
<a name="l00337"></a>00337                                 resu(num10, comp0) -= flux;
<a name="l00338"></a>00338                                 resu(num20, comp0) += flux;
<a name="l00339"></a>00339                               }
<a name="l00340"></a>00340 <span class="comment">// Pour la calcul du pas de temps de stabilite</span>
<a name="l00341"></a>00341                             fluent_[num10] += 0.5*(psc[nu1]+psc[nu2]);
<a name="l00342"></a>00342                             fluent_[num20] -= 0.5*(psc[nu1]+psc[nu2]);
<a name="l00343"></a>00343 <span class="comment">// fluent_[num1] = ( fluent_[num1] &gt; f_int) ? fluent_[num1] : f_int ;</span>
<a name="l00344"></a>00344                           }
<a name="l00345"></a>00345                         <span class="keywordflow">else</span>
<a name="l00346"></a>00346                           {
<a name="l00347"></a>00347 <span class="comment">// Pour les fa7 confondus</span>
<a name="l00348"></a>00348                             <span class="keywordflow">if</span> (fa7 == nu2)
<a name="l00349"></a>00349                               {
<a name="l00350"></a>00350                                 coef1  = 2.*( psc[nu1]-psc[nu2] ) ;
<a name="l00351"></a>00351                                 coef1 += 3.*psc[numfa7];
<a name="l00352"></a>00352 
<a name="l00353"></a>00353                                 coef2  =  3.*(psc[nu1]-psc[nu2]) ;
<a name="l00354"></a>00354                                 coef2 +=  6.*psc[numfa7];
<a name="l00355"></a>00355 
<a name="l00356"></a>00356 
<a name="l00357"></a>00357                                 <span class="keywordflow">for</span> (comp0=0; comp0&lt;ncomp_ch_transporte; comp0++)
<a name="l00358"></a>00358                                   {
<a name="l00359"></a>00359                                     flux  = (transporte(face[nu1],comp0)-transporte(face[nu2],comp0))*coef1;
<a name="l00360"></a>00360                                     flux +=  transporte(face[numfa7],comp0)*coef2;
<a name="l00361"></a>00361                                     flux /= 6.;
<a name="l00362"></a>00362                                     resu(face[nu1],comp0) -= flux;  <span class="comment">//!&lt; est ce le bon signe?????????????????????? Cerr &lt;&lt; &quot;num1=&quot; &lt;&lt; num1 &lt;&lt; &quot;  num2=&quot; &lt;&lt; num2 &lt;&lt; finl;</span>
<a name="l00363"></a>00363 <span class="comment"></span><span class="comment">//</span>
<a name="l00364"></a>00364                                   }
<a name="l00365"></a>00365 <span class="comment">// Pour la calcul du pas de temps de stabilite</span>
<a name="l00366"></a>00366                                 fluent_[face[nu1]] -=  0.5*(psc[nu1]-psc[nu2])+psc[numfa7]; <span class="comment">//!&lt; signe????????</span>
<a name="l00367"></a>00367 <span class="comment"></span>
<a name="l00368"></a>00368 <span class="comment">//</span>
<a name="l00369"></a>00369                               }
<a name="l00370"></a>00370                             <span class="keywordflow">else</span>
<a name="l00371"></a>00371                               {
<a name="l00372"></a>00372 <span class="comment">// fa7 == nu1</span>
<a name="l00373"></a>00373                                 coef1  = 2.*( psc[nu2]-psc[nu1] ) ;
<a name="l00374"></a>00374                                 coef1 += 3.*psc[numfa7];
<a name="l00375"></a>00375 
<a name="l00376"></a>00376                                 coef2  =  3.*(psc[nu2]-psc[nu1]) ;
<a name="l00377"></a>00377                                 coef2 +=  6.*psc[numfa7];  <span class="comment">//!&lt; est ce la bonne numerotation?</span>
<a name="l00378"></a>00378 <span class="comment"></span>
<a name="l00379"></a>00379 
<a name="l00380"></a>00380                                 <span class="keywordflow">for</span> (comp0=0; comp0&lt;ncomp_ch_transporte; comp0++)
<a name="l00381"></a>00381                                   {
<a name="l00382"></a>00382                                     flux  = (transporte(face[nu2],comp0)-transporte(face[nu1],comp0))*coef1;
<a name="l00383"></a>00383                                     flux +=  transporte(face[numfa7],comp0)*coef2;
<a name="l00384"></a>00384                                     flux /= 6.;
<a name="l00385"></a>00385                                     resu(face[nu1],comp0) -= flux;  <span class="comment">//!&lt; est ce le bon signe????????????????? Cerr &lt;&lt; &quot;num1=&quot; &lt;&lt; num1 &lt;&lt; &quot;  num2=&quot; &lt;&lt; num2 &lt;&lt; finl;</span>
<a name="l00386"></a>00386 <span class="comment"></span><span class="comment">//</span>
<a name="l00387"></a>00387                                   }
<a name="l00388"></a>00388 <span class="comment">// Pour la calcul du pas de temps de stabilite</span>
<a name="l00389"></a>00389                                 fluent_[face[nu1]] -=  0.5*(psc[nu2]-psc[nu1])+psc[numfa7];   <span class="comment">//!&lt; signe?????????????????</span>
<a name="l00390"></a>00390 <span class="comment"></span>
<a name="l00391"></a>00391 <span class="comment">//</span>
<a name="l00392"></a>00392                               }
<a name="l00393"></a>00393                           }
<a name="l00394"></a>00394                       }
<a name="l00395"></a>00395                     <span class="keywordflow">else</span>
<a name="l00396"></a>00396                       {
<a name="l00397"></a>00397 <span class="comment">// 2 faces de Dirichlet!!!!!</span>
<a name="l00398"></a>00398 <span class="comment">// meme expression pour les 3 fa7 (confondues avec les faces de bord)</span>
<a name="l00399"></a>00399 <span class="comment">// On suppose que la num fa7 = num face</span>
<a name="l00400"></a>00400 
<a name="l00401"></a>00401 <span class="comment">// Recuperation des numeros des autres faces</span>
<a name="l00402"></a>00402                         <span class="keywordflow">switch</span>(fa7)
<a name="l00403"></a>00403                           {
<a name="l00404"></a>00404                           <span class="keywordflow">case</span> 0 :
<a name="l00405"></a>00405                             {
<a name="l00406"></a>00406                               nu1 = 1;
<a name="l00407"></a>00407                               nu2 = 2;
<a name="l00408"></a>00408                               <span class="keywordflow">break</span>;
<a name="l00409"></a>00409                             }
<a name="l00410"></a>00410                           <span class="keywordflow">case</span> 1 :
<a name="l00411"></a>00411                             {
<a name="l00412"></a>00412                               nu1 = 0;
<a name="l00413"></a>00413                               nu2 = 2;
<a name="l00414"></a>00414                               <span class="keywordflow">break</span>;
<a name="l00415"></a>00415                             }
<a name="l00416"></a>00416                           <span class="keywordflow">case</span> 2 :
<a name="l00417"></a>00417                             {
<a name="l00418"></a>00418                               nu1 = 1;
<a name="l00419"></a>00419                               nu2 = 0;
<a name="l00420"></a>00420                               <span class="keywordflow">break</span>;
<a name="l00421"></a>00421                             }
<a name="l00422"></a>00422                           <span class="keywordflow">default</span> :
<a name="l00423"></a>00423                             {
<a name="l00424"></a>00424                               nu1=-1;
<a name="l00425"></a>00425                               nu2=-1;
<a name="l00426"></a>00426                               <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;On arrete tout, c est pas possible!!!!&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
<a name="l00427"></a>00427                               <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;sinon c est que je n ai rien compris!!!&quot;</span> &lt;&lt; finl;
<a name="l00428"></a>00428                               <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">exit</a>();
<a name="l00429"></a>00429                             }
<a name="l00430"></a>00430                           }
<a name="l00431"></a>00431 <span class="comment">// Cerr &lt;&lt; &quot;fa7=&quot; &lt;&lt; fa7 &lt;&lt; &quot;   nu1=&quot; &lt;&lt; nu1 &lt;&lt; &quot;   nu2=&quot; &lt;&lt; nu2 &lt;&lt; finl;</span>
<a name="l00432"></a>00432                         coef1  = psc[fa7];
<a name="l00433"></a>00433                         coef2  = (psc[nu1]-psc[nu2])/3.;
<a name="l00434"></a>00434                         <span class="keywordflow">for</span> (comp0=0; comp0&lt;ncomp_ch_transporte; comp0++)
<a name="l00435"></a>00435                           {
<a name="l00436"></a>00436                             flux  = transporte(face[fa7],comp0)*coef1;
<a name="l00437"></a>00437                             flux += (transporte(face[nu1],comp0)-transporte(face[nu2],comp0))*coef2;
<a name="l00438"></a>00438                             flux /= 6.;
<a name="l00439"></a>00439                             resu(face[nu1],comp0) -= flux;  <span class="comment">//!&lt; est ce le bon signe?</span>
<a name="l00440"></a>00440 <span class="comment"></span>                          }
<a name="l00441"></a>00441 <span class="comment">// Pour la calcul du pas de temps de stabilite</span>
<a name="l00442"></a>00442                         fluent_[face[fa7]] -=  psc[fa7];
<a name="l00443"></a>00443 <span class="comment">// f_int =  psc[fa7];</span>
<a name="l00444"></a>00444 <span class="comment">// fluent_[face[fa7]] = ( fluent_[face[fa7]] &gt; f_int) ? fluent_[face[fa7]]  : f_int ;</span>
<a name="l00445"></a>00445 <span class="comment">//</span>
<a name="l00446"></a>00446                       }
<a name="l00447"></a>00447                     <span class="keywordflow">break</span>;
<a name="l00448"></a>00448                   }
<a name="l00449"></a>00449                 }
<a name="l00450"></a>00450             }          <span class="comment">//!&lt; FIN de if(dimension == 2)</span>
<a name="l00451"></a>00451 <span class="comment"></span>          <span class="keywordflow">else</span> <span class="keywordflow">if</span> (dimension == 3)
<a name="l00452"></a>00452             {
<a name="l00453"></a>00453               <span class="keywordflow">switch</span>(itypcl)
<a name="l00454"></a>00454                 {
<a name="l00455"></a>00455                 <span class="keywordflow">case</span> 0:
<a name="l00456"></a>00456                   {
<a name="l00457"></a>00457                     coef1  =  19.0*( psc[nu1]+psc[nu2] ) ;
<a name="l00458"></a>00458                     coef1 -=   7.0*(psc[autre_num_face_loc(0)]+psc[autre_num_face_loc(1)]);
<a name="l00459"></a>00459 <span class="comment">// Cerr &lt;&lt; &quot;coef1=&quot; &lt;&lt; coef1 &lt;&lt; finl;</span>
<a name="l00460"></a>00460 
<a name="l00461"></a>00461                     coef2  =   7.0*( psc[nu1]+psc[nu2] ) ;
<a name="l00462"></a>00462                     coef2 -=  15.0*psc[autre_num_face_loc(0)];
<a name="l00463"></a>00463                     coef2 +=   9.0*psc[autre_num_face_loc(1)];
<a name="l00464"></a>00464 <span class="comment">// Cerr &lt;&lt; &quot;coef2=&quot; &lt;&lt; coef2 &lt;&lt; finl;</span>
<a name="l00465"></a>00465 
<a name="l00466"></a>00466                     coef3  =   7.0*( psc[nu1]+psc[nu2] ) ;
<a name="l00467"></a>00467                     coef3 +=   9.0*psc[autre_num_face_loc(0)];
<a name="l00468"></a>00468                     coef3 -=  15.0*psc[autre_num_face_loc(1)];
<a name="l00469"></a>00469 <span class="comment">// Cerr &lt;&lt; &quot;coef3=&quot; &lt;&lt; coef3 &lt;&lt; finl;</span>
<a name="l00470"></a>00470 
<a name="l00471"></a>00471                     <span class="keywordflow">for</span> (comp0=0; comp0&lt;ncomp_ch_transporte; comp0++)
<a name="l00472"></a>00472                       {
<a name="l00473"></a>00473                         flux  = (transporte(num10,comp0)+transporte(num20,comp0))*coef1;
<a name="l00474"></a>00474                         flux -=  transporte(autre_num_face(0),comp0)*coef2;
<a name="l00475"></a>00475                         flux -=  transporte(autre_num_face(1),comp0)*coef3;
<a name="l00476"></a>00476                         flux /= 32.;
<a name="l00477"></a>00477                         resu(num10, comp0) -= flux;
<a name="l00478"></a>00478                         resu(num20, comp0) += flux;
<a name="l00479"></a>00479                         <span class="comment">//************Calcul de fluent pour le pas de temps</span>
<a name="l00480"></a>00480                         <span class="comment">// f_int = 0.5*cc[comp]*(la_vitesse(num1,comp)+la_vitesse(num2,comp));</span>
<a name="l00481"></a>00481 
<a name="l00482"></a>00482                         <span class="comment">//  if (f_int&gt;=0.)</span>
<a name="l00483"></a>00483                         <span class="comment">//                             fluent_[num2] += f_int ;</span>
<a name="l00484"></a>00484                         <span class="comment">//                           else</span>
<a name="l00485"></a>00485                         <span class="comment">//                             fluent_[num1] -= f_int ;</span>
<a name="l00486"></a>00486                       }
<a name="l00487"></a>00487                     f_int = 3.*(psc[nu1]+psc[nu2]);
<a name="l00488"></a>00488                     f_int -= (psc[autre_num_face_loc(0)]+psc[autre_num_face_loc(1)]);
<a name="l00489"></a>00489                     f_int /= 4.;
<a name="l00490"></a>00490                     <span class="keywordflow">if</span> (f_int&gt;=0.)
<a name="l00491"></a>00491                       {
<a name="l00492"></a>00492                         <span class="comment">//fluent_[num2] += f_int ;</span>
<a name="l00493"></a>00493                         fluent_[num20] = ( fluent_[num20] &gt; <a class="code" href="Double_8h.html#aaecd4ca8a2fe69cc6568af2938b94d2e">dabs</a>(f_int))? fluent_[num20] : <a class="code" href="Double_8h.html#aaecd4ca8a2fe69cc6568af2938b94d2e">dabs</a>(f_int);
<a name="l00494"></a>00494                       }
<a name="l00495"></a>00495                     <span class="keywordflow">else</span>
<a name="l00496"></a>00496                       {
<a name="l00497"></a>00497                         <span class="comment">//fluent_[num1] -= f_int ;</span>
<a name="l00498"></a>00498                         fluent_[num10] = ( fluent_[num10] &gt; <a class="code" href="Double_8h.html#aaecd4ca8a2fe69cc6568af2938b94d2e">dabs</a>(f_int))? fluent_[num10] : <a class="code" href="Double_8h.html#aaecd4ca8a2fe69cc6568af2938b94d2e">dabs</a>(f_int);
<a name="l00499"></a>00499                       }
<a name="l00500"></a>00500 
<a name="l00501"></a>00501 
<a name="l00502"></a>00502 
<a name="l00503"></a>00503                     <span class="keywordflow">break</span>;
<a name="l00504"></a>00504                   }
<a name="l00505"></a>00505                 <span class="keywordflow">default</span>:
<a name="l00506"></a>00506                   {
<a name="l00507"></a>00507                     <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Dans le default!!&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
<a name="l00508"></a>00508                     <span class="keywordtype">int</span> nu3=-1;
<a name="l00509"></a>00509                     <span class="keywordflow">if</span> (fa7 == itypcl)
<a name="l00510"></a>00510                       {
<a name="l00511"></a>00511                         i=0;
<a name="l00512"></a>00512                         <span class="keywordflow">while</span>(i&lt;nfac) <span class="comment">// on cherche le 4ieme point!!</span>
<a name="l00513"></a>00513                           {
<a name="l00514"></a>00514                             nu3 = i;
<a name="l00515"></a>00515                             <span class="keywordflow">if</span> (nu3 == fa7)
<a name="l00516"></a>00516                               i++;
<a name="l00517"></a>00517                             <span class="keywordflow">else</span> <span class="keywordflow">if</span> (nu3 == nu1)
<a name="l00518"></a>00518                               i++;
<a name="l00519"></a>00519                             <span class="keywordflow">else</span> <span class="keywordflow">if</span> (nu3 == nu2)
<a name="l00520"></a>00520                               i++;
<a name="l00521"></a>00521                             <span class="keywordflow">else</span>
<a name="l00522"></a>00522                               i=nfac;
<a name="l00523"></a>00523                           }
<a name="l00524"></a>00524                         coef1  =  6.*( psc[nu1]+psc[nu2] ) ;
<a name="l00525"></a>00525                         coef1 -=  3.*psc[nu3]+psc[fa7];
<a name="l00526"></a>00526 
<a name="l00527"></a>00527                         coef2  =   3.0*( psc[nu1]+psc[nu2] ) ;
<a name="l00528"></a>00528                         coef2 -=   7.0*psc[nu3];
<a name="l00529"></a>00529                         coef2 +=   4.0*psc[fa7];
<a name="l00530"></a>00530 
<a name="l00531"></a>00531                         coef3  =   psc[nu1]+psc[nu2];
<a name="l00532"></a>00532                         coef3 +=   psc[nu3];
<a name="l00533"></a>00533                         coef3 -=   7.*psc[fa7];
<a name="l00534"></a>00534 
<a name="l00535"></a>00535                         <span class="keywordflow">for</span> (comp0=0; comp0&lt;ncomp_ch_transporte; comp0++)
<a name="l00536"></a>00536                           {
<a name="l00537"></a>00537                             flux  = (transporte(num10,comp0)+transporte(num20,comp0))*coef1;
<a name="l00538"></a>00538                             flux -=  transporte(face[nu3],comp0)*coef2;
<a name="l00539"></a>00539                             flux -=  transporte(face[fa7],comp0)*coef3;
<a name="l00540"></a>00540                             flux /= 12.;
<a name="l00541"></a>00541                             resu(num10, comp0) -= flux;
<a name="l00542"></a>00542                             resu(num20, comp0) += flux;
<a name="l00543"></a>00543                             <span class="comment">// Pour la calcul du pas de temps de stabilite</span>
<a name="l00544"></a>00544                             <span class="comment">// SIGNE????????????</span>
<a name="l00545"></a>00545                             <span class="comment">//                                  f_int = dabs(flux/transporte(num1,comp));</span>
<a name="l00546"></a>00546                             f_int = 3.*(psc[nu1]+psc[nu2]);
<a name="l00547"></a>00547                             f_int -= (psc[autre_num_face_loc(0)]+psc[autre_num_face_loc(1)]);
<a name="l00548"></a>00548                             f_int /= 4.;
<a name="l00549"></a>00549                             <span class="comment">// fluent_[num1] -= f_int ;</span>
<a name="l00550"></a>00550                             <span class="comment">//                               fluent_[num2] += f_int ;</span>
<a name="l00551"></a>00551                             <span class="keywordflow">if</span> (f_int &gt;=0.)
<a name="l00552"></a>00552                               fluent_[num20] += f_int ;
<a name="l00553"></a>00553                             <span class="keywordflow">else</span>
<a name="l00554"></a>00554                               fluent_[num10] -= f_int ;
<a name="l00555"></a>00555 
<a name="l00556"></a>00556                             <span class="comment">//                              fluent_[num1] = ( fluent_[num1] &gt; f_int) ? fluent_[num1]  : f_int ;</span><span class="comment"></span>
<a name="l00557"></a>00557 <span class="comment">                            //////////////////////////////////////////////</span>
<a name="l00558"></a>00558 <span class="comment"></span>                            <span class="comment">//                          Cerr &lt;&lt; &quot;flux=&quot; &lt;&lt; flux &lt;&lt; finl;</span>
<a name="l00559"></a>00559                           }
<a name="l00560"></a>00560                       }
<a name="l00561"></a>00561                     <span class="keywordflow">else</span>
<a name="l00562"></a>00562                       {
<a name="l00563"></a>00563                         <span class="comment">// J ai l impression que ce n est pas fini???!!!!!!!!!!</span>
<a name="l00564"></a>00564                       }
<a name="l00565"></a>00565                     <span class="keywordflow">break</span>;
<a name="l00566"></a>00566                   }
<a name="l00567"></a>00567                 }
<a name="l00568"></a>00568             }
<a name="l00569"></a>00569         }
<a name="l00570"></a>00570     }
<a name="l00571"></a>00571   <span class="comment">//  Cerr &lt;&lt; &quot;vitesse=&quot; &lt;&lt; la_vitesse.valeurs() &lt;&lt; finl;</span>
<a name="l00572"></a>00572 
<a name="l00573"></a>00573 
<a name="l00574"></a>00574   <span class="keywordtype">int</span> voisine;
<a name="l00575"></a>00575   nb_faces_perio = 0;
<a name="l00576"></a>00576   <span class="keywordtype">double</span> diff1,diff2;
<a name="l00577"></a>00577   <span class="keywordtype">double</span> pscav;
<a name="l00578"></a>00578 
<a name="l00579"></a>00579   <span class="comment">// Dimensionnement du tableau des flux convectifs au bord du domaine</span>
<a name="l00580"></a>00580   <span class="comment">// de calcul</span>
<a name="l00581"></a>00581   <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; flux_b = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>,<a class="code" href="classOperateur__base.html#a451f51b41518ddbc0d3f586a8177d319" title="Tableau contenant les flux sur les bords de l&#39;operateur.">flux_bords_</a>);
<a name="l00582"></a>00582   flux_b.<a class="code" href="classDoubleTab.html#ae83b4d31205c53d9c8d2b43da178ce75" title="Change la taille du vecteur (identique a resize_array() pour le traitement des anciennes valeurs et d...">resize</a>(zone_VEF.<a class="code" href="classZone__VF.html#a8815e2276637c0db23868f043dc43e58" title="renvoie le nombre de faces sur lesquelles sont appliquees les conditions limites : bords...">nb_faces_bord</a>(),ncomp_ch_transporte);
<a name="l00583"></a>00583   flux_b = 0.;
<a name="l00584"></a>00584 
<a name="l00585"></a>00585   <span class="comment">// Boucle sur les bords pour traiter les conditions aux limites</span>
<a name="l00586"></a>00586   <span class="comment">// il y a prise en compte d&#39;un terme de convection pour les</span>
<a name="l00587"></a>00587   <span class="comment">// conditions aux limites de Neumann_sortie_libre seulement</span>
<a name="l00588"></a>00588 
<a name="l00589"></a>00589   <span class="keywordflow">for</span> (n_bord=0; n_bord&lt;zone_VEF.<a class="code" href="classZone__dis__base.html#af22167d614644f55591a29c77eb1c009">nb_front_Cl</a>(); n_bord++)
<a name="l00590"></a>00590     {
<a name="l00591"></a>00591 
<a name="l00592"></a>00592       <span class="keyword">const</span> <a class="code" href="classCond__lim.html" title="classe Cond_lim Classe generique servant a representer n&#39;importe quelle classe derivee de la classe C...">Cond_lim</a>&amp; la_cl = zone_Cl_VEF.<a class="code" href="classZone__Cl__dis__base.html#af75e0ed7786863e4d333bfb29d67c323" title="Renvoie la i-ieme condition aux limites. (version const)">les_conditions_limites</a>(n_bord);
<a name="l00593"></a>00593 
<a name="l00594"></a>00594       <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classNeumann__sortie__libre.html" title="classe Neumann_sortie_libre Cette classe represente une frontiere ouverte sans vitesse imposee Pour l...">Neumann_sortie_libre</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>()))
<a name="l00595"></a>00595         {<span class="comment"></span>
<a name="l00596"></a>00596 <span class="comment">          ////////////ATTENTION!!!!!!!!!!! Cela correspond a l ancien schema et pas au EF!!</span>
<a name="l00597"></a>00597 <span class="comment"></span>          <span class="keyword">const</span> <a class="code" href="classNeumann__sortie__libre.html" title="classe Neumann_sortie_libre Cette classe represente une frontiere ouverte sans vitesse imposee Pour l...">Neumann_sortie_libre</a>&amp; la_sortie_libre = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classNeumann__sortie__libre.html" title="classe Neumann_sortie_libre Cette classe represente une frontiere ouverte sans vitesse imposee Pour l...">Neumann_sortie_libre</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>());
<a name="l00598"></a>00598           <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp; le_bord = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>,la_cl.<a class="code" href="classCond__lim.html#a5b2d24809cee07727006a891d4ce8d22" title="Appel a l&#39;objet sous-jacent Renvoie la frontiere discretisee associee a la condition aux limites...">frontiere_dis</a>());
<a name="l00599"></a>00599           <span class="keywordtype">int</span> num1 = le_bord.num_premiere_face();
<a name="l00600"></a>00600           <span class="keywordtype">int</span> num2 = num1 + le_bord.nb_faces();
<a name="l00601"></a>00601           <span class="keywordflow">for</span> (num_face=num1; num_face&lt;num2; num_face++)
<a name="l00602"></a>00602             {
<a name="l00603"></a>00603               pscav =0;
<a name="l00604"></a>00604               <span class="keywordflow">for</span> (i=0; i&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; i++)
<a name="l00605"></a>00605                 pscav += la_vitesse(num_face,i)*face_normales(num_face,i)*porosite_face(num_face);
<a name="l00606"></a>00606               <span class="keywordflow">if</span> (pscav&gt;0)
<a name="l00607"></a>00607                 <span class="keywordflow">if</span> (ncomp_ch_transporte == 1)
<a name="l00608"></a>00608                   {
<a name="l00609"></a>00609                     resu(num_face) -= pscav*transporte(num_face);
<a name="l00610"></a>00610                     flux_b(num_face,0) -= pscav*transporte(num_face);
<a name="l00611"></a>00611                   }
<a name="l00612"></a>00612                 <span class="keywordflow">else</span>
<a name="l00613"></a>00613                   <span class="keywordflow">for</span> (i=0; i&lt;ncomp_ch_transporte; i++)
<a name="l00614"></a>00614                     {
<a name="l00615"></a>00615                       resu(num_face,i) -= pscav*transporte(num_face,i);
<a name="l00616"></a>00616                       flux_b(num_face,i) -= pscav*transporte(num_face,i);
<a name="l00617"></a>00617                     }
<a name="l00618"></a>00618               <span class="keywordflow">else</span>
<a name="l00619"></a>00619                 {
<a name="l00620"></a>00620                   <span class="keywordflow">if</span> (ncomp_ch_transporte == 1)
<a name="l00621"></a>00621                     {
<a name="l00622"></a>00622                       resu(num_face) -= pscav*la_sortie_libre.<a class="code" href="classNeumann__sortie__libre.html#a886f1804fa2a9028fc56a0778a72a75d" title="Renvoie la valeur de la i-eme composante du champ impose a l&#39;exterieur de la frontiere.">val_ext</a>(num_face-num1);
<a name="l00623"></a>00623                       flux_b(num_face,0) -= pscav*la_sortie_libre.<a class="code" href="classNeumann__sortie__libre.html#a886f1804fa2a9028fc56a0778a72a75d" title="Renvoie la valeur de la i-eme composante du champ impose a l&#39;exterieur de la frontiere.">val_ext</a>(num_face-num1);
<a name="l00624"></a>00624                     }
<a name="l00625"></a>00625                   <span class="keywordflow">else</span>
<a name="l00626"></a>00626                     <span class="keywordflow">for</span> (i=0; i&lt;ncomp_ch_transporte; i++)
<a name="l00627"></a>00627                       {
<a name="l00628"></a>00628                         resu(num_face,i) -= pscav*la_sortie_libre.<a class="code" href="classNeumann__sortie__libre.html#a886f1804fa2a9028fc56a0778a72a75d" title="Renvoie la valeur de la i-eme composante du champ impose a l&#39;exterieur de la frontiere.">val_ext</a>(num_face-num1,i);
<a name="l00629"></a>00629                         flux_b(num_face,i) -= pscav*la_sortie_libre.<a class="code" href="classNeumann__sortie__libre.html#a886f1804fa2a9028fc56a0778a72a75d" title="Renvoie la valeur de la i-eme composante du champ impose a l&#39;exterieur de la frontiere.">val_ext</a>(num_face-num1,i);
<a name="l00630"></a>00630                       }
<a name="l00631"></a>00631                   fluent_[num_face] -= pscav;
<a name="l00632"></a>00632                 }
<a name="l00633"></a>00633             }
<a name="l00634"></a>00634           <span class="comment">//        Cerr &lt;&lt; &quot;Pour l instant Neumann_sortie_libre pas possible!!!&quot; &lt;&lt; finl;</span>
<a name="l00635"></a>00635         }
<a name="l00636"></a>00636       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>()))
<a name="l00637"></a>00637         {
<a name="l00638"></a>00638           <span class="keyword">const</span> <a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>&amp; la_cl_perio = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>());
<a name="l00639"></a>00639           <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp; le_bord = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>,la_cl.<a class="code" href="classCond__lim.html#a5b2d24809cee07727006a891d4ce8d22" title="Appel a l&#39;objet sous-jacent Renvoie la frontiere discretisee associee a la condition aux limites...">frontiere_dis</a>());
<a name="l00640"></a>00640           <span class="keywordtype">int</span> num1 = le_bord.num_premiere_face();
<a name="l00641"></a>00641           <span class="keywordtype">int</span> num2 = num1 + le_bord.nb_faces();
<a name="l00642"></a>00642           <a class="code" href="classIntVect.html">IntVect</a> fait(le_bord.nb_faces());
<a name="l00643"></a>00643           fait = 0;
<a name="l00644"></a>00644           <span class="keywordflow">for</span> (num_face=num1; num_face&lt;num2; num_face++)
<a name="l00645"></a>00645             {
<a name="l00646"></a>00646               <span class="keywordflow">if</span> (fait[num_face-num1] == 0)
<a name="l00647"></a>00647                 {
<a name="l00648"></a>00648                   voisine = la_cl_perio.<a class="code" href="classPeriodique.html#a207b86556f199a63ea059b841851ca6a">face_associee</a>(num_face-num1) + num1;
<a name="l00649"></a>00649 
<a name="l00650"></a>00650                   <span class="keywordflow">if</span> (ncomp_ch_transporte == 1)
<a name="l00651"></a>00651                     {
<a name="l00652"></a>00652                       diff1 = resu(num_face)-tab(nb_faces_perio);
<a name="l00653"></a>00653                       diff2 = resu(voisine)-tab(nb_faces_perio+voisine-num_face);
<a name="l00654"></a>00654                       resu(voisine)  += diff1;
<a name="l00655"></a>00655                       resu(num_face) += diff2;
<a name="l00656"></a>00656                       flux_b(voisine,0) += diff1;
<a name="l00657"></a>00657                       flux_b(num_face,0) += diff1;
<a name="l00658"></a>00658                       <span class="comment">// Pour la calcul du pas de temps de stabilite</span>
<a name="l00659"></a>00659                       <span class="comment">// RIEN en periodique ??? (faces deja traites avant??????)</span><span class="comment"></span>
<a name="l00660"></a>00660 <span class="comment">                      //////////////////////////////////////////////</span>
<a name="l00661"></a>00661 <span class="comment"></span>                    }
<a name="l00662"></a>00662                   <span class="keywordflow">else</span>
<a name="l00663"></a>00663                     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> comp=0; comp&lt;ncomp_ch_transporte; comp++)
<a name="l00664"></a>00664                       {
<a name="l00665"></a>00665                         diff1 = resu(num_face,comp)-tab(nb_faces_perio,comp);
<a name="l00666"></a>00666                         diff2 = resu(voisine,comp)-tab(nb_faces_perio+voisine-num_face,comp);
<a name="l00667"></a>00667                         <span class="comment">//                       Cerr &lt;&lt; &quot;num_face=&quot; &lt;&lt; num_face &lt;&lt; &quot;  diff1=&quot; &lt;&lt; diff1 &lt;&lt; finl;</span>
<a name="l00668"></a>00668                         <span class="comment">//                       Cerr &lt;&lt; &quot;voisine=&quot; &lt;&lt; voisine &lt;&lt; &quot;  diff2=&quot; &lt;&lt; diff2 &lt;&lt; finl;</span>
<a name="l00669"></a>00669                         resu(voisine,comp)  += diff1;
<a name="l00670"></a>00670                         resu(num_face,comp) += diff2;
<a name="l00671"></a>00671                         flux_b(voisine,comp) += diff1;
<a name="l00672"></a>00672                         flux_b(num_face,comp) += diff1;
<a name="l00673"></a>00673                         <span class="comment">// Pour la calcul du pas de temps de stabilite</span>
<a name="l00674"></a>00674                         <span class="comment">// RIEN en periodique ??? (faces deja traites avant??????)</span><span class="comment"></span>
<a name="l00675"></a>00675 <span class="comment">                        //////////////////////////////////////////////</span>
<a name="l00676"></a>00676 <span class="comment"></span>                      }
<a name="l00677"></a>00677 
<a name="l00678"></a>00678                   fait[num_face-num1]= 1;
<a name="l00679"></a>00679                   fait[voisine-num1] = 1;
<a name="l00680"></a>00680                 }
<a name="l00681"></a>00681               nb_faces_perio++;
<a name="l00682"></a>00682             }
<a name="l00683"></a>00683         }
<a name="l00684"></a>00684     }
<a name="l00685"></a>00685   <a class="code" href="classOp__VEF__Face.html#a6c8ce571769b4f2e20b07cbb7a6944f2">modifier_flux</a>(*<span class="keyword">this</span>);
<a name="l00686"></a>00686   <span class="keywordflow">return</span> resu;
<a name="l00687"></a>00687 
<a name="l00688"></a>00688 }
<a name="l00689"></a>00689 
</pre></div></div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Tue Dec 14 2021 19:35:42 for TRUST by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
