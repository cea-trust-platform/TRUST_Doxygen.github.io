<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>TRUST: src/VEF/Operateurs/Op_Conv_DI_L2_VEF_Face.cpp Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">TRUST&#160;<span id="projectnumber">1.8.4</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
<div class="header">
  <div class="headertitle">
<div class="title">src/VEF/Operateurs/Op_Conv_DI_L2_VEF_Face.cpp</div>  </div>
</div>
<div class="contents">
<a href="Op__Conv__DI__L2__VEF__Face_8cpp.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/****************************************************************************</span>
<a name="l00002"></a>00002 <span class="comment">* Copyright (c) 2015 - 2016, CEA</span>
<a name="l00003"></a>00003 <span class="comment">* All rights reserved.</span>
<a name="l00004"></a>00004 <span class="comment">*</span>
<a name="l00005"></a>00005 <span class="comment">* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</span>
<a name="l00006"></a>00006 <span class="comment">* 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.</span>
<a name="l00007"></a>00007 <span class="comment">* 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.</span>
<a name="l00008"></a>00008 <span class="comment">* 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.</span>
<a name="l00009"></a>00009 <span class="comment">*</span>
<a name="l00010"></a>00010 <span class="comment">* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.</span>
<a name="l00011"></a>00011 <span class="comment">* IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;</span>
<a name="l00012"></a>00012 <span class="comment">* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>
<a name="l00013"></a>00013 <span class="comment">*</span>
<a name="l00014"></a>00014 <span class="comment">*****************************************************************************/</span>
<a name="l00015"></a>00015 <span class="comment">//</span>
<a name="l00016"></a>00016 <span class="comment">// </span>
<a name="l00017"></a>00017 <span class="comment">// File:        Op_Conv_DI_L2_VEF_Face.cpp</span>
<a name="l00018"></a>00018 <span class="comment">// Directory:   $TRUST_ROOT/src/VEF/Operateurs</span>
<a name="l00019"></a>00019 <span class="comment">// Version:     /main/21</span>
<a name="l00020"></a>00020 <span class="comment">// </span>
<a name="l00021"></a>00021 <span class="comment">//</span>
<a name="l00022"></a>00022 
<a name="l00023"></a>00023 
<a name="l00024"></a>00024 <span class="preprocessor">#include &lt;<a class="code" href="Op__Conv__DI__L2__VEF__Face_8h.html">Op_Conv_DI_L2_VEF_Face.h</a>&gt;</span>
<a name="l00025"></a>00025 <span class="preprocessor">#include &lt;<a class="code" href="Champ__P1NC_8h.html">Champ_P1NC.h</a>&gt;</span>
<a name="l00026"></a>00026 <span class="preprocessor">#include &lt;<a class="code" href="Schema__Temps__base_8h.html">Schema_Temps_base.h</a>&gt;</span>
<a name="l00027"></a>00027 
<a name="l00028"></a>00028 
<a name="l00029"></a><a class="code" href="Op__Conv__DI__L2__VEF__Face_8cpp.html#a501215bc3d37a94369ce7535e19171ae">00029</a> <a class="code" href="Op__Diff__CoviMAC__Face_8cpp.html#aa86ec8ba612a969d9b4370b775037144">Implemente_instanciable</a>(<a class="code" href="classOp__Conv__DI__L2__VEF__Face.html" title="class Op_Conv_DI_L2_VEF_Face Cette classe represente l&#39;operateur de convection associe a une equation...">Op_Conv_DI_L2_VEF_Face</a>,<span class="stringliteral">&quot;Op_Conv_DI_L2_VEF_P1NC&quot;</span>,<a class="code" href="classOp__Conv__VEF__base.html" title="class Op_Conv_VEF_base Classe de base des operateurs de convection VEF">Op_Conv_VEF_base</a>);
<a name="l00030"></a>00030 
<a name="l00031"></a>00031 <span class="comment"></span>
<a name="l00032"></a>00032 <span class="comment">////!&lt; printOn </span>
<a name="l00033"></a>00033 <span class="comment"></span><span class="comment">//</span>
<a name="l00034"></a>00034 
<a name="l00035"></a><a class="code" href="classOp__Conv__DI__L2__VEF__Face.html#ad89573ed9a2598a52abc88ef93ed564c">00035</a> <a class="code" href="classSortie.html" title="Classe de base des flux de sortie. Elle sait ecrire des types simples&lt;br&gt;(entiers, flottants) et des Ob...">Sortie</a>&amp; <a class="code" href="classOp__Conv__DI__L2__VEF__Face.html#ad89573ed9a2598a52abc88ef93ed564c" title="NE FAIT RIEN A surcharger dans les classes derivees.">Op_Conv_DI_L2_VEF_Face::printOn</a>(<a class="code" href="classSortie.html" title="Classe de base des flux de sortie. Elle sait ecrire des types simples&lt;br&gt;(entiers, flottants) et des Ob...">Sortie</a>&amp; s )<span class="keyword"> const</span>
<a name="l00036"></a>00036 <span class="keyword"></span>{
<a name="l00037"></a>00037   <span class="keywordflow">return</span> s &lt;&lt; <a class="code" href="classObjet__U.html#aa58e9a81c0ddc2c1149053b8f96698ac" title="renvoie la chaine identifiant la classe.">que_suis_je</a>() ;
<a name="l00038"></a>00038 }
<a name="l00039"></a>00039 <span class="comment"></span>
<a name="l00040"></a>00040 <span class="comment">////!&lt; readOn </span>
<a name="l00041"></a>00041 <span class="comment"></span><span class="comment">//</span>
<a name="l00042"></a>00042 
<a name="l00043"></a><a class="code" href="classOp__Conv__DI__L2__VEF__Face.html#a3ceed9301c07d8e4e11b1c7f7756197d">00043</a> <a class="code" href="classEntree.html" title="Classe de definition des operateurs et methodes pour toute lecture dans un flot d&#39;entree (fichier...">Entree</a>&amp; <a class="code" href="classOp__Conv__DI__L2__VEF__Face.html#a3ceed9301c07d8e4e11b1c7f7756197d" title="NE FAIT RIEN A surcharger dans les classes derivees.">Op_Conv_DI_L2_VEF_Face::readOn</a>(<a class="code" href="classEntree.html" title="Classe de definition des operateurs et methodes pour toute lecture dans un flot d&#39;entree (fichier...">Entree</a>&amp; s )
<a name="l00044"></a>00044 {
<a name="l00045"></a>00045   <span class="keywordflow">return</span> s ;
<a name="l00046"></a>00046 }
<a name="l00047"></a>00047 
<a name="l00048"></a>00048 <span class="comment">// </span>
<a name="l00049"></a>00049 <span class="comment">// Fonctions de la classe Op_Conv_DI_L2_VEF_Face</span>
<a name="l00050"></a>00050 <span class="comment">// </span>
<a name="l00051"></a>00051 
<a name="l00052"></a><a class="code" href="classOp__Conv__DI__L2__VEF__Face.html#a5bfbdf23352bc549d46734254b2619ab">00052</a> <span class="keywordtype">void</span> <a class="code" href="classOp__Conv__DI__L2__VEF__Face.html#a5bfbdf23352bc549d46734254b2619ab">Op_Conv_DI_L2_VEF_Face::associer_vitesse</a>(<span class="keyword">const</span> <a class="code" href="classChamp__base.html" title="classe Champ_base Cette classe est la base de la hierarchie des champs. Ses membres sont les attribut...">Champ_base</a>&amp; vit)
<a name="l00053"></a>00053 {
<a name="l00054"></a>00054   <span class="keyword">const</span> <a class="code" href="classChamp__P1NC.html">Champ_P1NC</a>&amp; inco = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classChamp__P1NC.html">Champ_P1NC</a>,vit);
<a name="l00055"></a>00055   <a class="code" href="classOp__Conv__VEF__base.html#a5547875832fb45e09b1115372fb76ffd">vitesse_</a>= inco;
<a name="l00056"></a>00056 }
<a name="l00057"></a>00057 
<a name="l00058"></a>00058 
<a name="l00059"></a><a class="code" href="Op__Conv__DI__L2__VEF__Face_8cpp.html#a2b16b9d1aa7325c6557e4d7dd8d9e68a">00059</a> <span class="keywordtype">void</span> <a class="code" href="Op__Conv__DI__L2__VEF__Face_8cpp.html#a2b16b9d1aa7325c6557e4d7dd8d9e68a">flora</a>(<a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a> A, <span class="keywordtype">int</span>&amp; N , <a class="code" href="classDoubleVect.html">DoubleVect</a> B, <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; U, <span class="keywordtype">int</span>&amp; test_flora)
<a name="l00060"></a>00060 {
<a name="l00061"></a>00061 <span class="comment">// cette procedure correspond a la methode d&#39;elimination de Gauss</span>
<a name="l00062"></a>00062   test_flora = 0; <span class="comment">//test pour savoir si la matrice est inversible(0) ou non(1)</span>
<a name="l00063"></a>00063   <span class="keywordtype">int</span> N1 = N-1;
<a name="l00064"></a>00064   <span class="keywordtype">int</span> m, <a class="code" href="stat__counters_8cpp.html#a0b22d8bb1162b491f7d0505b588a9d06">m1</a>, i, i1, k, l;
<a name="l00065"></a>00065   <span class="keywordtype">double</span> quo,SU;
<a name="l00066"></a>00066   <span class="keywordflow">for</span>(m=0; m&lt;N1; m++)
<a name="l00067"></a>00067     {
<a name="l00068"></a>00068       m1 = m+1;
<a name="l00069"></a>00069       <span class="keywordflow">if</span>(<a class="code" href="Double_8h.html#aaecd4ca8a2fe69cc6568af2938b94d2e">dabs</a>(A(m,m)) &gt; 1e-20)
<a name="l00070"></a>00070         {
<a name="l00071"></a>00071           <span class="keywordflow">for</span>(i=m1; i&lt;N; i++)
<a name="l00072"></a>00072             {
<a name="l00073"></a>00073               quo = A(i,m)/A(m,m);
<a name="l00074"></a>00074               <span class="keywordflow">for</span>(k=m; k&lt;N; k++)
<a name="l00075"></a>00075                 A(i,k) =A(i,k)-quo*A(m,k);
<a name="l00076"></a>00076               B(i) = B(i)-quo*B(m);
<a name="l00077"></a>00077             }
<a name="l00078"></a>00078         }
<a name="l00079"></a>00079       <span class="keywordflow">else</span>
<a name="l00080"></a>00080         {
<a name="l00081"></a>00081           <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a>&lt;&lt;<span class="stringliteral">&quot;Erreur flora: matrice non inversible a l&#39;indice &quot;</span>&lt;&lt;m&lt;&lt;<a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
<a name="l00082"></a>00082           test_flora = 1;
<a name="l00083"></a>00083         }
<a name="l00084"></a>00084 
<a name="l00085"></a>00085     }
<a name="l00086"></a>00086   <span class="keywordflow">if</span>(<a class="code" href="Double_8h.html#aaecd4ca8a2fe69cc6568af2938b94d2e">dabs</a>(A(N-1,N-1)) &gt;= 1e-20)
<a name="l00087"></a>00087     {
<a name="l00088"></a>00088       U(N-1) = B(N-1)/A(N-1,N-1);
<a name="l00089"></a>00089       <span class="keywordflow">for</span>(l=0; l&lt;N1; l++)
<a name="l00090"></a>00090         {
<a name="l00091"></a>00091           i = N1-l-1;
<a name="l00092"></a>00092           SU = 0;
<a name="l00093"></a>00093           i1 = i+1;
<a name="l00094"></a>00094           <span class="keywordflow">for</span>(k=i1; k&lt;N; k++)
<a name="l00095"></a>00095             SU = SU+A(i,k)*U(k);
<a name="l00096"></a>00096           U(i) = (B(i)-SU)/A(i,i);
<a name="l00097"></a>00097         }
<a name="l00098"></a>00098     }
<a name="l00099"></a>00099   <span class="keywordflow">else</span>
<a name="l00100"></a>00100     {
<a name="l00101"></a>00101       <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a>&lt;&lt;<span class="stringliteral">&quot;Erreur flora: matrice non inversible a l&#39;indice&quot;</span>&lt;&lt;N-1&lt;&lt;<a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
<a name="l00102"></a>00102       test_flora = 1;
<a name="l00103"></a>00103     }
<a name="l00104"></a>00104 }
<a name="l00105"></a>00105 
<a name="l00106"></a>00106 
<a name="l00107"></a><a class="code" href="Op__Conv__DI__L2__VEF__Face_8cpp.html#a7231c8f5ccebe8a7addc6f8b65d88d0f">00107</a> <span class="keywordtype">void</span> <a class="code" href="Op__Conv__DI__L2__VEF__Face_8cpp.html#a7231c8f5ccebe8a7addc6f8b65d88d0f">flora_p</a>(<a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; A, <span class="keywordtype">int</span>&amp; N, <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; B, <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; U, <span class="keywordtype">int</span>&amp; test_flora)
<a name="l00108"></a>00108 {
<a name="l00109"></a>00109 <span class="comment">// cette procedure correspond a la methode d&#39;elimination de Gauss</span>
<a name="l00110"></a>00110   test_flora = 1;<span class="comment">//test pour savoir si la matrice est inversible(1) ou non(0)</span>
<a name="l00111"></a>00111   <span class="keywordtype">int</span> N1 = N-1;
<a name="l00112"></a>00112   <span class="keywordtype">int</span> m, <a class="code" href="stat__counters_8cpp.html#a0b22d8bb1162b491f7d0505b588a9d06">m1</a>, i, j, i1, k, l;
<a name="l00113"></a>00113   <span class="keywordtype">int</span> <a class="code" href="Op__Grad__EF_8cpp.html#abc0897c211f7aa4541da5833388f868b">test</a>=0;
<a name="l00114"></a>00114   <span class="keywordtype">double</span> quo, SU, x, y;
<a name="l00115"></a>00115   <span class="keywordflow">for</span>(m=0; m&lt;N1; m++)
<a name="l00116"></a>00116     {
<a name="l00117"></a>00117       m1 = m+1;
<a name="l00118"></a>00118       <span class="keywordflow">if</span>(<a class="code" href="Double_8h.html#aaecd4ca8a2fe69cc6568af2938b94d2e">dabs</a>(A(m,m))  &gt;= 1.e-10)
<a name="l00119"></a>00119         {
<a name="l00120"></a>00120           <span class="keywordflow">for</span>(i=m1; i&lt;N; i++)
<a name="l00121"></a>00121             {
<a name="l00122"></a>00122               quo = A(i,m)/A(m,m);
<a name="l00123"></a>00123               <span class="keywordflow">for</span>(k=m; k&lt;N; k++)
<a name="l00124"></a>00124                 A(i,k) =A(i,k)-quo*A(m,k);
<a name="l00125"></a>00125               B(i) = B(i)-quo*B(m);
<a name="l00126"></a>00126             }
<a name="l00127"></a>00127         }
<a name="l00128"></a>00128       <span class="keywordflow">else</span>
<a name="l00129"></a>00129         {
<a name="l00130"></a>00130           j=m+1;
<a name="l00131"></a>00131           <span class="keywordflow">while</span>(j&lt;N &amp;&amp; test == 0)
<a name="l00132"></a>00132             {
<a name="l00133"></a>00133               <span class="keywordflow">if</span>(<a class="code" href="Double_8h.html#aaecd4ca8a2fe69cc6568af2938b94d2e">dabs</a>(A(m,j)) &gt;= 1.e-10) test =1;
<a name="l00134"></a>00134               j++;
<a name="l00135"></a>00135             }
<a name="l00136"></a>00136           <span class="keywordflow">if</span>(j == N)
<a name="l00137"></a>00137             {
<a name="l00138"></a>00138               <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a>&lt;&lt;<span class="stringliteral">&quot;Erreur flora: matrice non inversible a l&#39;indice &quot;</span>&lt;&lt;m&lt;&lt;<a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
<a name="l00139"></a>00139               test_flora = 1;
<a name="l00140"></a>00140             }
<a name="l00141"></a>00141           <span class="keywordflow">else</span>         <span class="comment">//echange des colonnes m et j</span>
<a name="l00142"></a>00142             {
<a name="l00143"></a>00143               <span class="keywordflow">for</span>(i=0; i&lt;N; i++)
<a name="l00144"></a>00144                 {
<a name="l00145"></a>00145                   x=A(i,m);
<a name="l00146"></a>00146                   A(i,m)=A(i,j);
<a name="l00147"></a>00147                   A(i,j)=x;
<a name="l00148"></a>00148                   y=B(m);
<a name="l00149"></a>00149                   B(m)=B(j);
<a name="l00150"></a>00150                   B(j)=y;
<a name="l00151"></a>00151                 }
<a name="l00152"></a>00152             }
<a name="l00153"></a>00153           test_flora = 0;
<a name="l00154"></a>00154 
<a name="l00155"></a>00155         }
<a name="l00156"></a>00156 
<a name="l00157"></a>00157     }
<a name="l00158"></a>00158   <span class="keywordflow">if</span>(<a class="code" href="Double_8h.html#aaecd4ca8a2fe69cc6568af2938b94d2e">dabs</a>(A(N-1,N-1)) &gt;= 1.e-10)
<a name="l00159"></a>00159     {
<a name="l00160"></a>00160       U(N-1) = B(N-1)/A(N-1,N-1);
<a name="l00161"></a>00161       <span class="keywordflow">for</span>(l=0; l&lt;N1; l++)
<a name="l00162"></a>00162         {
<a name="l00163"></a>00163           i = N1-l-1;
<a name="l00164"></a>00164           SU = 0;
<a name="l00165"></a>00165           i1 = i+1;
<a name="l00166"></a>00166           <span class="keywordflow">for</span>(k=i1; k&lt;N; k++)
<a name="l00167"></a>00167             SU = SU+A(i,k)*U(k);
<a name="l00168"></a>00168           U(i) = (B(i)-SU)/A(i,i);
<a name="l00169"></a>00169         }
<a name="l00170"></a>00170     }
<a name="l00171"></a>00171   <span class="keywordflow">else</span>
<a name="l00172"></a>00172     {
<a name="l00173"></a>00173 <span class="comment">// Cerr&lt;&lt;&quot;Erreur flora: matrice non inversible a l&#39;indice&quot;&lt;&lt;N-1&lt;&lt;finl;</span>
<a name="l00174"></a>00174       test_flora = 0;
<a name="l00175"></a>00175     }
<a name="l00176"></a>00176 }
<a name="l00177"></a>00177 
<a name="l00178"></a>00178 
<a name="l00179"></a><a class="code" href="Op__Conv__DI__L2__VEF__Face_8cpp.html#af302806fe220448c4a7acdcc3cf936d5">00179</a> <span class="keywordtype">void</span> <a class="code" href="Op__Conv__DI__L2__VEF__Face_8cpp.html#af302806fe220448c4a7acdcc3cf936d5">qrdcmp</a>(<a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; A, <span class="keywordtype">int</span>&amp; N, <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; C, <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; D, <span class="keywordtype">int</span>&amp; sing)
<a name="l00180"></a>00180 {
<a name="l00181"></a>00181 <span class="comment">// construit la decomposition QR de A. Le triangle superieur R est stockee dans le triangle superieur de A,</span>
<a name="l00182"></a>00182 <span class="comment">// exepte les elements de la diagonale, qui sont stockes dans D. La matrice orthogonale Q est representee</span>
<a name="l00183"></a>00183 <span class="comment">// comme un produit de N-1 matrice Q(1), ..., Q(N-1) ou Q(j) = Id-(uj*ujt)/cj. La ieme composante de uj est 0</span>
<a name="l00184"></a>00184 <span class="comment">// pour i=1, ...,j-1 et A(i,j) pour i=j, ..., N. sing retourne 0 si la decomposition est possible et 1 sinon.</span>
<a name="l00185"></a>00185 
<a name="l00186"></a>00186   <span class="keywordtype">int</span> i, j, k;
<a name="l00187"></a>00187   <span class="keywordtype">double</span> scale, sigma, sum, tau;
<a name="l00188"></a>00188   sing =0;
<a name="l00189"></a>00189   <span class="keywordflow">for</span>(k=0; k&lt;N-1; k++)
<a name="l00190"></a>00190     {
<a name="l00191"></a>00191       scale = 0.;
<a name="l00192"></a>00192       <span class="keywordflow">for</span>(i=k; i&lt;N; i++)
<a name="l00193"></a>00193         <span class="keywordflow">if</span>(scale &lt; <a class="code" href="Double_8h.html#aaecd4ca8a2fe69cc6568af2938b94d2e">dabs</a>(A(i,k)))                scale = <a class="code" href="Double_8h.html#aaecd4ca8a2fe69cc6568af2938b94d2e">dabs</a>(A(i,k));
<a name="l00194"></a>00194       <span class="keywordflow">if</span>(<a class="code" href="Double_8h.html#aaecd4ca8a2fe69cc6568af2938b94d2e">dabs</a>(scale)&lt;1.e-15)
<a name="l00195"></a>00195         {
<a name="l00196"></a>00196 <span class="comment">// cas singulier</span>
<a name="l00197"></a>00197           <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot; huhu &quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a> ;
<a name="l00198"></a>00198           sing = 1;
<a name="l00199"></a>00199           C(k) = 0;
<a name="l00200"></a>00200           D(k) = 0;
<a name="l00201"></a>00201           return ;
<a name="l00202"></a>00202         }
<a name="l00203"></a>00203       <span class="keywordflow">else</span>
<a name="l00204"></a>00204         {
<a name="l00205"></a>00205           <span class="keywordflow">for</span>(i=k; i&lt;N; i++)        A(i,k) /= scale;
<a name="l00206"></a>00206           <span class="keywordflow">for</span>(sum=0.0,i=k; i&lt;N; i++)        sum += (A(i,k) * A(i,k));
<a name="l00207"></a>00207           <span class="keywordflow">if</span>(A(k,k)&gt;0) sigma = sqrt(sum);
<a name="l00208"></a>00208           <span class="keywordflow">else</span>        sigma = -1*sqrt(sum);
<a name="l00209"></a>00209           A(k,k) += sigma;
<a name="l00210"></a>00210           C(k) = sigma*A(k,k);
<a name="l00211"></a>00211           D(k) = -1*scale*sigma;
<a name="l00212"></a>00212           <span class="keywordflow">for</span>(j=k+1; j&lt;N; j++)
<a name="l00213"></a>00213             {
<a name="l00214"></a>00214               <span class="keywordflow">for</span>(sum=0.0,i=k; i&lt;N; i++)        sum += A(i,k)*A(i,j);
<a name="l00215"></a>00215               tau = sum/C(k);
<a name="l00216"></a>00216               <span class="keywordflow">for</span>(i=k; i&lt;N; i++)        A(i,j) -= tau*A(i,k);
<a name="l00217"></a>00217             }
<a name="l00218"></a>00218         }
<a name="l00219"></a>00219     }
<a name="l00220"></a>00220   D(N-1) = A(N-1,N-1);
<a name="l00221"></a>00221   <span class="keywordflow">if</span>(<a class="code" href="Double_8h.html#aaecd4ca8a2fe69cc6568af2938b94d2e">dabs</a>(D(N-1)) &lt;1.e-12)
<a name="l00222"></a>00222     {
<a name="l00223"></a>00223       <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot; hoho &quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a> ;
<a name="l00224"></a>00224       sing =1;
<a name="l00225"></a>00225     }
<a name="l00226"></a>00226 }
<a name="l00227"></a>00227 
<a name="l00228"></a>00228 
<a name="l00229"></a><a class="code" href="Op__Conv__DI__L2__VEF__Face_8cpp.html#a52eddf3029fda85a03ca998f5e5fc83d">00229</a> <span class="keywordtype">void</span> <a class="code" href="Op__Conv__DI__L2__VEF__Face_8cpp.html#a52eddf3029fda85a03ca998f5e5fc83d">rsolv</a>(<a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; A, <span class="keywordtype">int</span>&amp; N, <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; D, <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; B)
<a name="l00230"></a>00230 {
<a name="l00231"></a>00231 <span class="comment">// resout le systeme Rx=B, ou R est triangulaire superieure stockee dans A et D, provenant de qrdcmp</span>
<a name="l00232"></a>00232 <span class="comment">// le resultat est stocke dans B.</span>
<a name="l00233"></a>00233   <span class="keywordtype">int</span> i, j;
<a name="l00234"></a>00234   <span class="keywordtype">double</span> sum;
<a name="l00235"></a>00235   B(N-1) /= D(N-1);
<a name="l00236"></a>00236   <span class="keywordflow">for</span>(i=N-2; i&gt;=0; i--)
<a name="l00237"></a>00237     {
<a name="l00238"></a>00238       <span class="keywordflow">for</span>(sum=0.0,j=i+1; j&lt;N; j++)        sum += A(i,j)*B(j);
<a name="l00239"></a>00239       B(i) = (B(i)-sum)/D(i);
<a name="l00240"></a>00240     }
<a name="l00241"></a>00241 }
<a name="l00242"></a>00242 
<a name="l00243"></a><a class="code" href="Op__Conv__DI__L2__VEF__Face_8cpp.html#aeb9cb62959f7dc5e3b7695f8a22eaed5">00243</a> <span class="keywordtype">void</span> <a class="code" href="Op__Conv__DI__L2__VEF__Face_8cpp.html#aeb9cb62959f7dc5e3b7695f8a22eaed5">qrsolv</a>( <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; A, <span class="keywordtype">int</span>&amp; N, <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; B, <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; X, <span class="keywordtype">int</span>&amp; sing,
<a name="l00244"></a>00244              <span class="keywordtype">int</span>&amp; ncomp, <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; C, <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; D)
<a name="l00245"></a>00245 {
<a name="l00246"></a>00246 <span class="comment">// resout le systeme lineaire Ax=B</span>
<a name="l00247"></a>00247 <span class="comment">// DoubleVect C(N), D(N);</span>
<a name="l00248"></a>00248   <span class="keywordtype">int</span> i, j;
<a name="l00249"></a>00249   <span class="keywordtype">double</span> sum, tau;
<a name="l00250"></a>00250   <span class="keywordflow">if</span>(ncomp == 0 ) <a class="code" href="Op__Conv__DI__L2__VEF__Face_8cpp.html#af302806fe220448c4a7acdcc3cf936d5">qrdcmp</a>(A, N, C, D, sing);
<a name="l00251"></a>00251   <span class="keywordflow">if</span>(sing == 0)
<a name="l00252"></a>00252     {
<a name="l00253"></a>00253       <span class="keywordflow">for</span>(j=0; j&lt;N-1; j++)
<a name="l00254"></a>00254         {
<a name="l00255"></a>00255           <span class="keywordflow">for</span>(sum=0.0,i=j; i&lt;N; i++)        sum += A(i,j)*B(i);
<a name="l00256"></a>00256           tau = sum/C(j);
<a name="l00257"></a>00257           <span class="keywordflow">for</span>(i=j; i&lt;N; i++)        B(i) -= tau*A(i,j);
<a name="l00258"></a>00258         }
<a name="l00259"></a>00259       <a class="code" href="Op__Conv__DI__L2__VEF__Face_8cpp.html#a52eddf3029fda85a03ca998f5e5fc83d">rsolv</a>(A, N, D, B);<span class="comment">//resout Rx=QtB</span>
<a name="l00260"></a>00260       <span class="keywordflow">for</span>(i=0; i&lt;N; i++)        X(i) = B(i);
<a name="l00261"></a>00261     }
<a name="l00262"></a>00262 <span class="comment">// else        Cerr&lt;&lt;&quot;erreur&quot;&lt;&lt;finl;</span>
<a name="l00263"></a>00263 }
<a name="l00264"></a>00264 
<a name="l00265"></a>00265 
<a name="l00266"></a>00266 
<a name="l00267"></a>00267 
<a name="l00268"></a>00268 <span class="comment">// methode du gradient biconjugue</span>
<a name="l00269"></a><a class="code" href="Op__Conv__DI__L2__VEF__Face_8cpp.html#a6bbe9284b04c135e7cd484dc3bca8e29">00269</a> <span class="keywordtype">void</span> <a class="code" href="Op__Conv__DI__L2__VEF__Face_8cpp.html#a6bbe9284b04c135e7cd484dc3bca8e29">gradient_biconjugue</a>(<a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a> A, <span class="keywordtype">int</span> n, <a class="code" href="classDoubleVect.html">DoubleVect</a> b, <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; x, <span class="keywordtype">int</span>&amp; sing, <span class="keywordtype">int</span>&amp; niter)
<a name="l00270"></a>00270 {
<a name="l00271"></a>00271   <span class="keywordflow">if</span> (<a class="code" href="classProcess.html#a6bf692ce58d9578aa62ac3c07b8caaa1" title="renvoie le nombre de processeurs dans le groupe courant Voir Comm_Group::nproc() et PE_Groups::curren...">Process::nproc</a>() &gt; 1)
<a name="l00272"></a>00272     {
<a name="l00273"></a>00273       <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;OpVEF_DI_L2.cpp: gradient_biconjugue() n&#39;est pas parallele&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
<a name="l00274"></a>00274       assert(0);
<a name="l00275"></a>00275       <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">Process::exit</a>();
<a name="l00276"></a>00276     }
<a name="l00277"></a>00277 
<a name="l00278"></a>00278   <span class="keywordtype">double</span> seuil ;
<a name="l00279"></a>00279   <span class="keywordtype">double</span> dnew  = 1. ;
<a name="l00280"></a>00280 
<a name="l00281"></a>00281   <span class="keywordtype">double</span> dold, alfa, beta ;
<a name="l00282"></a>00282   niter = 0 ;
<a name="l00283"></a>00283   sing = 0 ;
<a name="l00284"></a>00284 
<a name="l00285"></a>00285   <a class="code" href="classDoubleVect.html">DoubleVect</a> r(n) ;
<a name="l00286"></a>00286   <a class="code" href="classDoubleVect.html">DoubleVect</a> r_tilda(n);
<a name="l00287"></a>00287   <a class="code" href="classDoubleVect.html">DoubleVect</a> p(n) ;
<a name="l00288"></a>00288   <a class="code" href="classDoubleVect.html">DoubleVect</a> p_tilda(n);
<a name="l00289"></a>00289   <a class="code" href="classDoubleVect.html">DoubleVect</a> q(n) ;
<a name="l00290"></a>00290   <a class="code" href="classDoubleVect.html">DoubleVect</a> u(n);
<a name="l00291"></a>00291   <span class="keywordtype">double</span> r_norme, b_norme = <a class="code" href="ArrOfDouble_8cpp.html#af3b2ac08cde80e3eadd7a83f5fd06ab7" title="Calcul de la norme du vecteur dx (fonction blas DNRM2, soit racine carree(somme des dx[i]*dx[i])...">norme_array</a>(b);
<a name="l00292"></a>00292 
<a name="l00293"></a>00293   <span class="keywordtype">int</span> i,j;
<a name="l00294"></a>00294 
<a name="l00295"></a>00295   <span class="keywordflow">if</span>(b_norme &gt; 1.e-7 )
<a name="l00296"></a>00296     seuil = 1.e-5/b_norme;
<a name="l00297"></a>00297   <span class="keywordflow">else</span> seuil = 1.e-10;
<a name="l00298"></a>00298 
<a name="l00299"></a>00299   r = 0. ;
<a name="l00300"></a>00300   p = 0. ;
<a name="l00301"></a>00301   q = 0. ;
<a name="l00302"></a>00302 
<a name="l00303"></a>00303   <span class="keywordflow">for</span>(i=0; i&lt;n; i++)
<a name="l00304"></a>00304     p(i) = b(i);
<a name="l00305"></a>00305 
<a name="l00306"></a>00306   <span class="keywordtype">int</span> nmax = 50 ;
<a name="l00307"></a>00307 
<a name="l00308"></a>00308   <span class="keywordflow">for</span>(i=0; i&lt;n; i++)
<a name="l00309"></a>00309     <span class="keywordflow">for</span>(j=0; j&lt;n; j++)
<a name="l00310"></a>00310       {
<a name="l00311"></a>00311         r(i) = p(i)-A(i,j)*x(j) ;
<a name="l00312"></a>00312         r_tilda(i) = r(i) ;
<a name="l00313"></a>00313       }
<a name="l00314"></a>00314 
<a name="l00315"></a>00315   p = 0 ;
<a name="l00316"></a>00316   dold = <a class="code" href="ArrOfDouble_8cpp.html#af541bfdadae7483016c96f13760598ac" title="Produit scalaire de deux &quot;array&quot;. (dotproduct_array remplace operator* car le nom indique clairemen...">dotproduct_array</a>(r_tilda, r);
<a name="l00317"></a>00317   r_norme = <a class="code" href="ArrOfDouble_8cpp.html#af3b2ac08cde80e3eadd7a83f5fd06ab7" title="Calcul de la norme du vecteur dx (fonction blas DNRM2, soit racine carree(somme des dx[i]*dx[i])...">norme_array</a>(r);
<a name="l00318"></a>00318 
<a name="l00319"></a>00319   <span class="keywordflow">if</span>(sqrt(dold) &gt; seuil)
<a name="l00320"></a>00320     {
<a name="l00321"></a>00321       <span class="keywordflow">while</span> ( ( r_norme &gt; seuil ) &amp;&amp; (niter++ &lt; nmax) )
<a name="l00322"></a>00322         {
<a name="l00323"></a>00323           assert(<a class="code" href="classProcess.html#a6bf692ce58d9578aa62ac3c07b8caaa1" title="renvoie le nombre de processeurs dans le groupe courant Voir Comm_Group::nproc() et PE_Groups::curren...">Process::nproc</a>() == 1); <span class="comment">//!&lt; B.M. code visiblement faux en parallele</span>
<a name="l00324"></a>00324 <span class="comment"></span>          dnew = <a class="code" href="ArrOfDouble_8cpp.html#af541bfdadae7483016c96f13760598ac" title="Produit scalaire de deux &quot;array&quot;. (dotproduct_array remplace operator* car le nom indique clairemen...">dotproduct_array</a>(r_tilda, r);
<a name="l00325"></a>00325 
<a name="l00326"></a>00326           <span class="keywordflow">if</span>(dold == 0.)        niter = nmax ;
<a name="l00327"></a>00327           <span class="keywordflow">else</span>
<a name="l00328"></a>00328             {
<a name="l00329"></a>00329               beta = dnew/dold ;
<a name="l00330"></a>00330               <span class="keywordflow">for</span>(i=0; i&lt;n; i++)
<a name="l00331"></a>00331                 {
<a name="l00332"></a>00332                   p(i) = r(i)+beta*p(i) ;
<a name="l00333"></a>00333                   p_tilda(i) = r_tilda(i)+beta*p_tilda(i) ;
<a name="l00334"></a>00334                 }
<a name="l00335"></a>00335 
<a name="l00336"></a>00336               q = 0. ;
<a name="l00337"></a>00337               <span class="keywordflow">for</span>(i=0; i&lt;n; i++)
<a name="l00338"></a>00338                 <span class="keywordflow">for</span>(j=0; j&lt;n; j++)
<a name="l00339"></a>00339                   q(i) += A(i,j)*p(j) ;
<a name="l00340"></a>00340 
<a name="l00341"></a>00341               beta = <a class="code" href="ArrOfDouble_8cpp.html#af541bfdadae7483016c96f13760598ac" title="Produit scalaire de deux &quot;array&quot;. (dotproduct_array remplace operator* car le nom indique clairemen...">dotproduct_array</a>(p_tilda, q) ;
<a name="l00342"></a>00342 <span class="comment">// Cerr&lt;&lt;&quot;beta :&quot;&lt;&lt;beta&lt;&lt;finl ;</span>
<a name="l00343"></a>00343               <span class="keywordflow">if</span>(beta == 0.)        niter = nmax ;
<a name="l00344"></a>00344               <span class="keywordflow">else</span>
<a name="l00345"></a>00345                 {
<a name="l00346"></a>00346                   alfa = dnew / beta ;
<a name="l00347"></a>00347 
<a name="l00348"></a>00348                   x.<a class="code" href="classDoubleVect.html#a87fba260b7a2a4a051d7a591d19ac11d" title="x+=alpha*y sans echange_espace_virtuel">ajoute_sans_ech_esp_virt</a>(alfa, p);
<a name="l00349"></a>00349                   r.<a class="code" href="classDoubleVect.html#a87fba260b7a2a4a051d7a591d19ac11d" title="x+=alpha*y sans echange_espace_virtuel">ajoute_sans_ech_esp_virt</a>(-alfa, q);
<a name="l00350"></a>00350 
<a name="l00351"></a>00351                   q = 0. ;
<a name="l00352"></a>00352                   <span class="keywordflow">for</span>(i=0; i&lt;n; i++)
<a name="l00353"></a>00353                     <span class="keywordflow">for</span>(j=0; j&lt;n; j++)
<a name="l00354"></a>00354                       q(i) += A(j,i)*p_tilda(j) ;
<a name="l00355"></a>00355 
<a name="l00356"></a>00356                   r_tilda.<a class="code" href="classDoubleVect.html#a87fba260b7a2a4a051d7a591d19ac11d" title="x+=alpha*y sans echange_espace_virtuel">ajoute_sans_ech_esp_virt</a>(-alfa, q);
<a name="l00357"></a>00357 
<a name="l00358"></a>00358                   dold = dnew;
<a name="l00359"></a>00359 <span class="comment">// assert(dnew &gt;= 0.);</span>
<a name="l00360"></a>00360                   r_norme = <a class="code" href="ArrOfDouble_8cpp.html#af3b2ac08cde80e3eadd7a83f5fd06ab7" title="Calcul de la norme du vecteur dx (fonction blas DNRM2, soit racine carree(somme des dx[i]*dx[i])...">norme_array</a>(r);
<a name="l00361"></a>00361 <span class="comment">// Cerr &lt;&lt; &quot; niter &quot; &lt;&lt; niter &lt;&lt; &quot; dnew &quot; &lt;&lt; dnew &lt;&lt;finl ;</span>
<a name="l00362"></a>00362 <span class="comment">// Cerr &lt;&lt; &quot; r &quot; &lt;&lt; r.norme() &lt;&lt; finl;</span>
<a name="l00363"></a>00363 <span class="comment">// Cerr &lt;&lt; &quot; x &quot; &lt;&lt; x &lt;&lt; finl;</span>
<a name="l00364"></a>00364                 }
<a name="l00365"></a>00365             }
<a name="l00366"></a>00366         }
<a name="l00367"></a>00367     }
<a name="l00368"></a>00368   <span class="keywordflow">if</span> ( niter &gt;= nmax) sing = 1 ;
<a name="l00369"></a>00369 <span class="comment">// Cerr&lt;&lt;&quot;niter :&quot;&lt;&lt;niter&lt;&lt;finl;</span>
<a name="l00370"></a>00370 }
<a name="l00371"></a>00371 
<a name="l00372"></a>00372 
<a name="l00373"></a>00373 <span class="comment">// convbis correspond au calcul de -1*terme_convection</span>
<a name="l00374"></a>00374 
<a name="l00375"></a><a class="code" href="Op__Conv__DI__L2__VEF__Face_8cpp.html#a6e738f8d47f58274f5e8517a60d03104">00375</a> <span class="keywordtype">void</span> <a class="code" href="Op__Conv__DI__L2__VEF__Face_8cpp.html#a6e738f8d47f58274f5e8517a60d03104">convbis</a>(<span class="keywordtype">double</span> psc,<span class="keywordtype">int</span> num1,<span class="keywordtype">int</span> num2,
<a name="l00376"></a>00376              <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; transporte, <span class="keywordtype">int</span> ncomp,
<a name="l00377"></a>00377              <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; resu, <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; fluent)
<a name="l00378"></a>00378 {
<a name="l00379"></a>00379   <span class="keywordtype">int</span> comp,amont;
<a name="l00380"></a>00380   <span class="keywordtype">double</span> flux;
<a name="l00381"></a>00381 
<a name="l00382"></a>00382   <span class="keywordflow">if</span> (psc &gt;= 0)
<a name="l00383"></a>00383     {
<a name="l00384"></a>00384       amont = num1;
<a name="l00385"></a>00385       fluent[num2] += psc;
<a name="l00386"></a>00386     }
<a name="l00387"></a>00387   <span class="keywordflow">else</span>
<a name="l00388"></a>00388     {
<a name="l00389"></a>00389       amont = num2;
<a name="l00390"></a>00390       fluent[num1] -= psc;
<a name="l00391"></a>00391     }
<a name="l00392"></a>00392 
<a name="l00393"></a>00393   <span class="keywordflow">if</span> (ncomp == 1)
<a name="l00394"></a>00394     {
<a name="l00395"></a>00395       flux = transporte(amont)*psc;
<a name="l00396"></a>00396       resu(num1) -= flux;
<a name="l00397"></a>00397       resu(num2) += flux;
<a name="l00398"></a>00398     }
<a name="l00399"></a>00399   <span class="keywordflow">else</span>
<a name="l00400"></a>00400     <span class="keywordflow">for</span> (comp=0; comp&lt;ncomp; comp++)
<a name="l00401"></a>00401       {
<a name="l00402"></a>00402         flux = transporte(amont,comp)*psc;
<a name="l00403"></a>00403         resu(num1,comp) -= flux;
<a name="l00404"></a>00404         resu(num2,comp) += flux;
<a name="l00405"></a>00405       }
<a name="l00406"></a>00406 }
<a name="l00407"></a>00407 
<a name="l00408"></a>00408 
<a name="l00409"></a><a class="code" href="classOp__Conv__DI__L2__VEF__Face.html#a38bf438326ae602cf6154f0eaf5e2d42">00409</a> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; <a class="code" href="classOp__Conv__DI__L2__VEF__Face.html#a38bf438326ae602cf6154f0eaf5e2d42">Op_Conv_DI_L2_VEF_Face::ajouter</a>(<span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; transporte,
<a name="l00410"></a>00410                                            <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; resu)<span class="keyword"> const</span>
<a name="l00411"></a>00411 <span class="keyword"></span>{
<a name="l00412"></a>00412   <span class="keyword">const</span> <a class="code" href="classZone__Cl__VEF.html">Zone_Cl_VEF</a>&amp; zone_Cl_VEF = <a class="code" href="classOp__Conv__VEF__base.html#a03f677ee7911706a4f85cd37e0ca4535">la_zcl_vef</a>.<a class="code" href="classRef__Zone__Cl__VEF.html#a0970d7253def65ad4f0c5ce1830fd243">valeur</a>();
<a name="l00413"></a>00413   <span class="keyword">const</span> <a class="code" href="classZone__VEF.html" title="class Zone_VEF Classe instanciable qui derive de Zone_VF. Cette classe contient les informations geom...">Zone_VEF</a>&amp; zone_VEF = <a class="code" href="classOp__Conv__VEF__base.html#a6c29a488a6805ba4a9f2f059cdba77ae">la_zone_vef</a>.<a class="code" href="classRef__Zone__VEF.html#aafd9a5ee1a76f290c9c6b5447b0c8d30">valeur</a>();
<a name="l00414"></a>00414   <span class="keyword">const</span> <a class="code" href="classChamp__Inc__base.html" title="Classe Champ_Inc_base Classe de base des champs inconnues qui sont les champs calcules par une equati...">Champ_Inc_base</a>&amp; la_vitesse=<a class="code" href="classOp__Conv__VEF__base.html#a5547875832fb45e09b1115372fb76ffd">vitesse_</a>.<a class="code" href="classRef__Champ__Inc__base.html#a17553641a4c06730e1562125e07b3490">valeur</a>();
<a name="l00415"></a>00415 
<a name="l00416"></a>00416   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; elem_faces = zone_VEF.<a class="code" href="classZone__VF.html#a067e462dcd3ab92b0f6d945b19e4eb37" title="renvoie le numero de le ieme face de la maille num_elem la facon dont ces faces sont numerotees est l...">elem_faces</a>();
<a name="l00417"></a>00417   <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; face_normales = zone_VEF.<a class="code" href="classZone__VEF.html#a5742d75972e4846bf9fbb6ed5715053e">face_normales</a>();
<a name="l00418"></a>00418   <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; facette_normales = zone_VEF.<a class="code" href="classZone__VEF.html#a581b1ca0e62c668c92f104351d19fda6">facette_normales</a>();
<a name="l00419"></a>00419 <span class="comment">// const DoubleVect&amp; volumes_entrelaces = zone_VEF.volumes_entrelaces();</span>
<a name="l00420"></a>00420   <span class="keyword">const</span> <a class="code" href="classZone.html" title="classe Zone Une Zone est un maillage compose d&#39;un ensemble d&#39;elements geometriques de meme type...">Zone</a>&amp; zone = zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>();
<a name="l00421"></a>00421 <span class="comment">// const int nb_faces = zone_VEF.nb_faces();</span>
<a name="l00422"></a>00422   <span class="keyword">const</span> <span class="keywordtype">int</span> nfa7 = zone_VEF.<a class="code" href="classZone__VEF.html#a46693c060b8096fb2595ca72192eea2a">type_elem</a>().<a class="code" href="classElem__VEF.html#a4a34777c0083b38dd34c8a400d5b4e90">nb_facette</a>();
<a name="l00423"></a>00423 <span class="comment">// const int nb_elem = zone_VEF.nb_elem();</span>
<a name="l00424"></a>00424   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_elem_tot = zone_VEF.<a class="code" href="classZone__dis__base.html#a4d6aa445f152aa6dc54d66ea7a071147">nb_elem_tot</a>();
<a name="l00425"></a>00425   <span class="keyword">const</span> <a class="code" href="classIntVect.html">IntVect</a>&amp; rang_elem_non_std = zone_VEF.<a class="code" href="classZone__VEF.html#a4b2171a85e5fc33663a3366acb713584">rang_elem_non_std</a>();
<a name="l00426"></a>00426   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; face_voisins = zone_VEF.<a class="code" href="classZone__VF.html#a49d4322f5585a8fa95748ca785b70702" title="renvoie l&#39;element voisin de numface dans la direction i. i=0 : dans le sens oppose de l&#39;axe orthogona...">face_voisins</a>();
<a name="l00427"></a>00427   <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; porosite_face = zone_VEF.<a class="code" href="classZone__VF.html#ad9d74d1d9da9f50ab26768dbbca7711b">porosite_face</a>();
<a name="l00428"></a>00428 
<a name="l00429"></a>00429   <span class="comment">/*  const IntTab&amp; face_voisins = zone_VEF.face_voisins();</span>
<a name="l00430"></a>00430 <span class="comment">      int jjj;</span>
<a name="l00431"></a>00431 <span class="comment">      for(jjj = 0;jjj&lt;zone_VEF.nb_faces_tot();jjj++)</span>
<a name="l00432"></a>00432 <span class="comment">      Cerr&lt;&lt;&quot;face_voisins : face = &quot;&lt;&lt;jjj&lt;&lt;&quot; : &quot;&lt;&lt;face_voisins(jjj,0)&lt;&lt;&quot;, &quot;&lt;&lt;face_voisins(jjj,1)&lt;&lt;finl;*/</span>
<a name="l00433"></a>00433 
<a name="l00434"></a>00434 
<a name="l00435"></a>00435   <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; normales_facettes_Cl = zone_Cl_VEF.<a class="code" href="classZone__Cl__VEF.html#a83c05e82370553470ed05f10932e0f3f">normales_facettes_Cl</a>();
<a name="l00436"></a>00436 <span class="comment">// const DoubleVect&amp; volumes_entrelaces_Cl = zone_Cl_VEF.volumes_entrelaces_Cl();</span>
<a name="l00437"></a>00437   <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; fluent_ = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classDoubleVect.html">DoubleVect</a>, <a class="code" href="classOp__Conv__VEF__base.html#a32b54e8fd5340e238cf4f28ff6e743ec" title="tableau qui sert pour le calcul du pas de temps de stabilite">fluent</a>);
<a name="l00438"></a>00438 
<a name="l00439"></a>00439   <span class="keywordtype">int</span> nfac = zone.<a class="code" href="classZone.html#a548fbc7518be2f122b1a5c9589a443c2" title="Renvoie le nombre de face de type i des elements geometriques constituants la zone. Ex: les objets de la classe Prisme ont 2 types de faces: triangle ou quadrangle.">nb_faces_elem</a>();
<a name="l00440"></a>00440   <span class="keywordtype">int</span> nsom = zone.<a class="code" href="classZone.html#ae0b34a93b9ae8146df2d1884157afe9f" title="Renvoie le nombre de sommets des elements geometriques constituants la zone. Tous les elements de la ...">nb_som_elem</a>();
<a name="l00441"></a>00441   <span class="keywordtype">int</span> nb_som_facette = zone.<a class="code" href="classZone.html#a18cf83cd0f9c368dcfa32fb802a0ac94" title="Renvoie un element geometrique du type de ceux qui constituent la zone. (version const)">type_elem</a>().<a class="code" href="classElem__geom.html#ab55aa8b4ec6aa60cfde5d5fc134c5333" title="Appel a l&#39;objet sous-jacent Renvoie le nombre de sommets des faces du type specifie.">nb_som_face</a>();
<a name="l00442"></a>00442 
<a name="l00443"></a>00443 <span class="comment">// int premiere_face_int = zone_VEF.premiere_face_int();</span>
<a name="l00444"></a>00444 
<a name="l00445"></a>00445 <span class="comment">// Pour le traitement de la convection on distingue les polyedres</span>
<a name="l00446"></a>00446 <span class="comment">// standard qui ne &quot;voient&quot; pas les conditions aux limites et les</span>
<a name="l00447"></a>00447 <span class="comment">// polyedres non standard qui ont au moins une face sur le bord.</span>
<a name="l00448"></a>00448 <span class="comment">// Un polyedre standard a n facettes sur lesquelles on applique le</span>
<a name="l00449"></a>00449 <span class="comment">// schema de convection.</span>
<a name="l00450"></a>00450 <span class="comment">// Pour un polyedre non standard qui porte des conditions aux limites</span>
<a name="l00451"></a>00451 <span class="comment">// de Dirichlet, une partie des facettes sont portees par les faces.</span>
<a name="l00452"></a>00452 <span class="comment">// En bref pour un polyedre le traitement de la convection depend</span>
<a name="l00453"></a>00453 <span class="comment">// du type (triangle, tetraedre ...) et du nombre de faces de Dirichlet.</span>
<a name="l00454"></a>00454 
<a name="l00455"></a>00455   <span class="keywordtype">double</span> psc;
<a name="l00456"></a>00456   <span class="keywordtype">int</span> poly,face_adj,fa7,i,j,n_bord;
<a name="l00457"></a>00457   <span class="keywordtype">int</span> num_face, rang ,itypcl;
<a name="l00458"></a>00458   <span class="keywordtype">int</span> num10,num20;
<a name="l00459"></a>00459   <span class="keywordtype">int</span> ncomp_ch_transporte, first;
<a name="l00460"></a>00460   <span class="keywordflow">if</span> (transporte.<a class="code" href="classDoubleTab.html#ae6dda48778e7107e1beb723beef1f75b" title="Returns the number of dimensions of the array (&gt;= 1)">nb_dim</a>() == 1)
<a name="l00461"></a>00461     ncomp_ch_transporte=1;
<a name="l00462"></a>00462   <span class="keywordflow">else</span>
<a name="l00463"></a>00463     ncomp_ch_transporte= transporte.<a class="code" href="classDoubleTab.html#ac3805e2637a3b880ba2d3e650c69dac4" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(1);
<a name="l00464"></a>00464 
<a name="l00465"></a>00465   <a class="code" href="classIntVect.html">IntVect</a> face(nfac);
<a name="l00466"></a>00466   <a class="code" href="classDoubleVect.html">DoubleVect</a> vs(<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>);
<a name="l00467"></a>00467   <a class="code" href="classDoubleVect.html">DoubleVect</a> vc(<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>);
<a name="l00468"></a>00468   <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>  vsom(nsom,<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>);
<a name="l00469"></a>00469   <a class="code" href="classDoubleVect.html">DoubleVect</a> cc(<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>);
<a name="l00470"></a>00470   <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a> derive(1,1) ;
<a name="l00471"></a>00471   <span class="keywordtype">int</span> N ,M , sing , cal_amont;
<a name="l00472"></a>00472   <a class="code" href="classDoubleVect.html">DoubleVect</a> trans(ncomp_ch_transporte) ;
<a name="l00473"></a>00473   <span class="keywordflow">if</span> (<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a> == 2)
<a name="l00474"></a>00474     {
<a name="l00475"></a>00475       N = 5 ;
<a name="l00476"></a>00476       M = 8 ;
<a name="l00477"></a>00477       derive.<a class="code" href="classDoubleTab.html#ae83b4d31205c53d9c8d2b43da178ce75" title="Change la taille du vecteur (identique a resize_array() pour le traitement des anciennes valeurs et d...">resize</a>(N,ncomp_ch_transporte) ;
<a name="l00478"></a>00478     }
<a name="l00479"></a>00479   <span class="keywordflow">else</span> <span class="comment">//!&lt; (dimension == 3)</span>
<a name="l00480"></a>00480 <span class="comment"></span>    {
<a name="l00481"></a>00481       N = 9 ;
<a name="l00482"></a>00482       M = 15 ;
<a name="l00483"></a>00483       derive.<a class="code" href="classDoubleTab.html#ae83b4d31205c53d9c8d2b43da178ce75" title="Change la taille du vecteur (identique a resize_array() pour le traitement des anciennes valeurs et d...">resize</a>(N,ncomp_ch_transporte) ;
<a name="l00484"></a>00484     }
<a name="l00485"></a>00485 <span class="comment">// On remet a zero le tableau qui sert pour</span>
<a name="l00486"></a>00486 <span class="comment">// le calcul du pas de temps de stabilite</span>
<a name="l00487"></a>00487   fluent_ = 0;
<a name="l00488"></a>00488 
<a name="l00489"></a>00489 <span class="comment">// Traitement particulier pour les faces de periodicite</span>
<a name="l00490"></a>00490 
<a name="l00491"></a>00491   <span class="keywordtype">int</span> nb_faces_perio = 0;
<a name="l00492"></a>00492 <span class="comment">// Boucle pour compter le nombre de faces de periodicite</span>
<a name="l00493"></a>00493   <span class="keywordflow">for</span> (n_bord=0; n_bord&lt;zone_VEF.<a class="code" href="classZone__dis__base.html#af22167d614644f55591a29c77eb1c009">nb_front_Cl</a>(); n_bord++)
<a name="l00494"></a>00494     {
<a name="l00495"></a>00495       <span class="keyword">const</span> <a class="code" href="classCond__lim.html" title="classe Cond_lim Classe generique servant a representer n&#39;importe quelle classe derivee de la classe C...">Cond_lim</a>&amp; la_cl = zone_Cl_VEF.<a class="code" href="classZone__Cl__dis__base.html#af75e0ed7786863e4d333bfb29d67c323" title="Renvoie la i-ieme condition aux limites. (version const)">les_conditions_limites</a>(n_bord);
<a name="l00496"></a>00496       <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>()))
<a name="l00497"></a>00497         {
<a name="l00498"></a>00498           <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp; le_bord = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>,la_cl.<a class="code" href="classCond__lim.html#a5b2d24809cee07727006a891d4ce8d22" title="Appel a l&#39;objet sous-jacent Renvoie la frontiere discretisee associee a la condition aux limites...">frontiere_dis</a>());
<a name="l00499"></a>00499           nb_faces_perio += le_bord.<a class="code" href="classFront__VF.html#a341e2fcb5117b96e745fd7078ba86bab" title="Nombre de faces reelles du bord.">nb_faces</a>();
<a name="l00500"></a>00500         }
<a name="l00501"></a>00501     }
<a name="l00502"></a>00502 
<a name="l00503"></a>00503   <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a> tab;
<a name="l00504"></a>00504   <span class="keywordflow">if</span> (ncomp_ch_transporte == 1)
<a name="l00505"></a>00505     tab.<a class="code" href="classDoubleTab.html#ae83b4d31205c53d9c8d2b43da178ce75" title="Change la taille du vecteur (identique a resize_array() pour le traitement des anciennes valeurs et d...">resize</a>(nb_faces_perio);
<a name="l00506"></a>00506   <span class="keywordflow">else</span>
<a name="l00507"></a>00507     tab.<a class="code" href="classDoubleTab.html#ae83b4d31205c53d9c8d2b43da178ce75" title="Change la taille du vecteur (identique a resize_array() pour le traitement des anciennes valeurs et d...">resize</a>(nb_faces_perio,ncomp_ch_transporte);
<a name="l00508"></a>00508 
<a name="l00509"></a>00509 <span class="comment">// Boucle pour remplir tab</span>
<a name="l00510"></a>00510   nb_faces_perio=0;
<a name="l00511"></a>00511   <span class="keywordflow">for</span> (n_bord=0; n_bord&lt;zone_VEF.<a class="code" href="classZone__dis__base.html#af22167d614644f55591a29c77eb1c009">nb_front_Cl</a>(); n_bord++)
<a name="l00512"></a>00512     {
<a name="l00513"></a>00513       <span class="keyword">const</span> <a class="code" href="classCond__lim.html" title="classe Cond_lim Classe generique servant a representer n&#39;importe quelle classe derivee de la classe C...">Cond_lim</a>&amp; la_cl = zone_Cl_VEF.<a class="code" href="classZone__Cl__dis__base.html#af75e0ed7786863e4d333bfb29d67c323" title="Renvoie la i-ieme condition aux limites. (version const)">les_conditions_limites</a>(n_bord);
<a name="l00514"></a>00514       <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>()))
<a name="l00515"></a>00515         {
<a name="l00516"></a>00516 <span class="comment">// const Periodique&amp; la_cl_perio = ref_cast(Periodique, la_cl.valeur());</span>
<a name="l00517"></a>00517           <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp; le_bord = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>,la_cl.<a class="code" href="classCond__lim.html#a5b2d24809cee07727006a891d4ce8d22" title="Appel a l&#39;objet sous-jacent Renvoie la frontiere discretisee associee a la condition aux limites...">frontiere_dis</a>());
<a name="l00518"></a>00518           <span class="keywordtype">int</span> num1 = le_bord.<a class="code" href="classFront__VF.html#a4986f0c65653fe9eb40bbbff5a97bf16" title="Numero de la premiere face du bord dans la liste des faces.">num_premiere_face</a>();
<a name="l00519"></a>00519           <span class="keywordtype">int</span> num2 = num1 + le_bord.<a class="code" href="classFront__VF.html#a341e2fcb5117b96e745fd7078ba86bab" title="Nombre de faces reelles du bord.">nb_faces</a>();
<a name="l00520"></a>00520           <span class="keywordflow">for</span> (num_face=num1; num_face&lt;num2; num_face++)
<a name="l00521"></a>00521             {
<a name="l00522"></a>00522               <span class="keywordflow">if</span> (ncomp_ch_transporte == 1)
<a name="l00523"></a>00523                 tab(nb_faces_perio) = resu(num_face);
<a name="l00524"></a>00524               <span class="keywordflow">else</span>
<a name="l00525"></a>00525                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> comp=0; comp&lt;ncomp_ch_transporte; comp++)
<a name="l00526"></a>00526                   tab(nb_faces_perio,comp) = resu(num_face,comp);
<a name="l00527"></a>00527               nb_faces_perio++;
<a name="l00528"></a>00528             }
<a name="l00529"></a>00529         }
<a name="l00530"></a>00530     }
<a name="l00531"></a>00531 
<a name="l00532"></a>00532 
<a name="l00533"></a>00533 <span class="comment">// Les polyedres non standard sont ranges en 2 groupes dans la Zone_VEF:</span>
<a name="l00534"></a>00534 <span class="comment">// - polyedres bords et joints</span>
<a name="l00535"></a>00535 <span class="comment">// - polyedres bords et non joints</span>
<a name="l00536"></a>00536 <span class="comment">// On traite les polyedres en suivant l&#39;ordre dans lequel ils figurent</span>
<a name="l00537"></a>00537 <span class="comment">// dans la zone</span>
<a name="l00538"></a>00538 
<a name="l00539"></a>00539 <span class="comment">// boucle sur les polys</span>
<a name="l00540"></a>00540 
<a name="l00541"></a>00541   <span class="keywordtype">int</span> nlim = -1 ;
<a name="l00542"></a>00542   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; KEL=zone_VEF.<a class="code" href="classZone__VEF.html#a46693c060b8096fb2595ca72192eea2a">type_elem</a>().<a class="code" href="classDeriv__Elem__VEF__base.html#a2886905d5071be902c77248b69ca0b7b">valeur</a>().<a class="code" href="classElem__VEF__base.html#ab129610ef702aa8c9c98dcb4c7551172">KEL</a>();
<a name="l00543"></a>00543   <span class="keywordflow">for</span> (poly=0; poly&lt;nb_elem_tot; poly++)
<a name="l00544"></a>00544     {
<a name="l00545"></a>00545 
<a name="l00546"></a>00546       rang = rang_elem_non_std(poly);
<a name="l00547"></a>00547       <span class="keywordflow">if</span> (rang==-1)
<a name="l00548"></a>00548         itypcl=0;
<a name="l00549"></a>00549       <span class="keywordflow">else</span>
<a name="l00550"></a>00550         itypcl=zone_Cl_VEF.<a class="code" href="classZone__Cl__VEF.html#a483bdab7690f844ed04e3defe04ec70a">type_elem_Cl</a>(rang);
<a name="l00551"></a>00551 
<a name="l00552"></a>00552 <span class="comment">// calcul des numeros des faces du polyedre</span>
<a name="l00553"></a>00553       <span class="keywordflow">for</span> (face_adj=0; face_adj&lt;nfac; face_adj++)
<a name="l00554"></a>00554         face[face_adj]= elem_faces(poly,face_adj);
<a name="l00555"></a>00555 
<a name="l00556"></a>00556 <span class="comment">// calcul de la vitesse aux sommets des polyedres</span>
<a name="l00557"></a>00557       <span class="keywordflow">for</span> (j=0; j&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; j++)
<a name="l00558"></a>00558         {
<a name="l00559"></a>00559           vs[j] = la_vitesse(face[0],j);
<a name="l00560"></a>00560           <span class="keywordflow">for</span> (i=1; i&lt;nfac; i++)
<a name="l00561"></a>00561             vs[j]+= la_vitesse(face[i],j);
<a name="l00562"></a>00562         }
<a name="l00563"></a>00563       <span class="keywordflow">for</span> (i=0; i&lt;nsom; i++)
<a name="l00564"></a>00564         <span class="keywordflow">for</span> (j=0; j&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; j++)
<a name="l00565"></a>00565           vsom(i,j) = vs[j] - dimension*la_vitesse(face[i],j);
<a name="l00566"></a>00566 
<a name="l00567"></a>00567 <span class="comment">// calcul de vc</span>
<a name="l00568"></a>00568       zone_VEF.<a class="code" href="classZone__VEF.html#a46693c060b8096fb2595ca72192eea2a">type_elem</a>().<a class="code" href="classElem__VEF.html#ab0be052b1bfa6135cb9b8288086f098e">calcul_vc</a>(face,vc,vs,vsom,<a class="code" href="classOp__Conv__VEF__base.html#a4872ffd7c638ecc415191d92d7f5f507">vitesse</a>(),
<a name="l00569"></a>00569                                      itypcl,porosite_face);
<a name="l00570"></a>00570 
<a name="l00571"></a>00571 
<a name="l00572"></a>00572       <span class="comment">/*    Cerr&lt;&lt;&quot;premiere_face_int = &quot;&lt;&lt;premiere_face_int&lt;&lt;&quot;, zone_VEF.nb_faces_joint() = &quot;&lt;&lt;zone_VEF.nb_faces_joint()&lt;&lt;finl;</span>
<a name="l00573"></a>00573 <span class="comment">            Cerr&lt;&lt;&quot;premiere_face_std() = &quot;&lt;&lt;zone_VEF.premiere_face_std()&lt;&lt;finl;</span>
<a name="l00574"></a>00574 <span class="comment">            Cerr&lt;&lt;&quot;nb_elem() = &quot;&lt;&lt;zone_VEF.nb_elem()&lt;&lt;&quot;, nb_elem_tot() = &quot;&lt;&lt;zone_VEF.nb_elem_tot()&lt;&lt;finl;</span>
<a name="l00575"></a>00575 <span class="comment">            Cerr&lt;&lt;&quot;nb_faces() = &quot;&lt;&lt;zone_VEF.nb_faces()&lt;&lt;&quot;, nb_faces_tot() = &quot;&lt;&lt;zone_VEF.nb_faces_tot()&lt;&lt;finl;</span>
<a name="l00576"></a>00576 <span class="comment">            Cerr&lt;&lt;&quot;nb_faces_bord() = &quot;&lt;&lt;zone_VEF.nb_faces_bord()&lt;&lt;&quot;, premiere_face_bord() = &quot;&lt;&lt;zone_VEF.premiere_face_bord()&lt;&lt;finl;*/</span>
<a name="l00577"></a>00577 
<a name="l00578"></a>00578       cal_amont = 0 ;
<a name="l00579"></a>00579 
<a name="l00580"></a>00580       <span class="keywordtype">int</span> elem0,elem1,face_adj_glob;
<a name="l00581"></a>00581       <span class="keywordflow">for</span> (face_adj=0; face_adj&lt;nfac; face_adj++)
<a name="l00582"></a>00582         {
<a name="l00583"></a>00583           face_adj_glob = face[face_adj];
<a name="l00584"></a>00584           elem0 = face_voisins(face_adj_glob,0);
<a name="l00585"></a>00585           elem1 = face_voisins(face_adj_glob,1);
<a name="l00586"></a>00586           <span class="keywordflow">if</span> ((elem0 == -1) || (elem1 == -1))
<a name="l00587"></a>00587             cal_amont++ ;
<a name="l00588"></a>00588         }
<a name="l00589"></a>00589 
<a name="l00590"></a>00590 <span class="comment">// calcul polynom de reconstruction</span>
<a name="l00591"></a>00591       <span class="keywordflow">if</span>(dimension == 2 )
<a name="l00592"></a>00592         {
<a name="l00593"></a>00593           <span class="keywordflow">if</span> ( cal_amont == 0) <a class="code" href="classOp__Conv__DI__L2__VEF__Face.html#aaea4484c77ff4a8a996428ce9a3e2c65">poly_DI_L2_2d</a>(N,M,derive,poly,ncomp_ch_transporte,transporte,sing);
<a name="l00594"></a>00594         }
<a name="l00595"></a>00595       <span class="keywordflow">else</span>
<a name="l00596"></a>00596         {
<a name="l00597"></a>00597           <span class="keywordflow">if</span> ( cal_amont == 0) <a class="code" href="classOp__Conv__DI__L2__VEF__Face.html#ada551c11f243074a4c2293e615c44059">poly_DI_L2_3d</a>(N,M,derive,poly,ncomp_ch_transporte,transporte,sing);
<a name="l00598"></a>00598         }
<a name="l00599"></a>00599 
<a name="l00600"></a>00600 <span class="comment">// Boucle sur les facettes du polyedre</span>
<a name="l00601"></a>00601 
<a name="l00602"></a>00602       <span class="keywordflow">for</span> (fa7=0; fa7&lt;nfa7; fa7++)
<a name="l00603"></a>00603         {
<a name="l00604"></a>00604           <span class="keywordflow">if</span> (rang==-1)
<a name="l00605"></a>00605             <span class="keywordflow">for</span> (i=0; i&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; i++)
<a name="l00606"></a>00606               cc[i] = facette_normales(poly,fa7,i);
<a name="l00607"></a>00607           <span class="keywordflow">else</span>
<a name="l00608"></a>00608             <span class="keywordflow">for</span> (i=0; i&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; i++)
<a name="l00609"></a>00609               cc[i] = normales_facettes_Cl(rang,fa7,i);
<a name="l00610"></a>00610 
<a name="l00611"></a>00611 <span class="comment">// On applique le schema de convection a chaque sommet de la facette</span>
<a name="l00612"></a>00612 
<a name="l00613"></a>00613 <span class="comment">// reconstruction seulement wenn first = 0</span>
<a name="l00614"></a>00614 
<a name="l00615"></a>00615           first = -1 ;
<a name="l00616"></a>00616 
<a name="l00617"></a>00617 <span class="comment">// On traite le ou les sommets qui sont aussi des sommets du polyedre</span>
<a name="l00618"></a>00618           <span class="keywordflow">for</span> (i=0; i&lt;nb_som_facette-1; i++)
<a name="l00619"></a>00619             {
<a name="l00620"></a>00620               first++ ;
<a name="l00621"></a>00621 
<a name="l00622"></a>00622               psc =0;
<a name="l00623"></a>00623               <span class="keywordflow">for</span> (j=0; j&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; j++)
<a name="l00624"></a>00624                 psc+= (vc(j)/<span class="keywordtype">double</span>(nb_som_facette-1)+vsom(KEL(i+2,fa7),j))*cc[j];
<a name="l00625"></a>00625               psc /= nb_som_facette;
<a name="l00626"></a>00626 
<a name="l00627"></a>00627               num10 = face[KEL(0,fa7)];
<a name="l00628"></a>00628               num20 = face[KEL(1,fa7)];
<a name="l00629"></a>00629 
<a name="l00630"></a>00630               <span class="keywordflow">if</span> ( cal_amont &gt; 0)
<a name="l00631"></a>00631                 {
<a name="l00632"></a>00632                   <a class="code" href="Op__Conv__DI__L2__VEF__Face_8cpp.html#a6e738f8d47f58274f5e8517a60d03104">convbis</a>(psc,num10,num20,transporte,ncomp_ch_transporte,resu,fluent_);
<a name="l00633"></a>00633                 }
<a name="l00634"></a>00634               <span class="keywordflow">else</span>
<a name="l00635"></a>00635                 {
<a name="l00636"></a>00636                   <span class="keywordflow">if</span>(dimension == 2 )
<a name="l00637"></a>00637                     {
<a name="l00638"></a>00638                       <a class="code" href="classOp__Conv__DI__L2__VEF__Face.html#a16dc52476bc30af35f4016ec4c79b867">reconst_DI_L2_2d</a>(derive,poly,psc,num10,num20,transporte,ncomp_ch_transporte,resu,fluent_,sing,
<a name="l00639"></a>00639                                        nlim );
<a name="l00640"></a>00640                     }
<a name="l00641"></a>00641                   <span class="keywordflow">else</span>
<a name="l00642"></a>00642                     {
<a name="l00643"></a>00643                       <a class="code" href="classOp__Conv__DI__L2__VEF__Face.html#a2f3d4e8e1bc00c9d02e95e1cbecc1eac">reconst_DI_L2_3d</a>(derive,poly,psc,num10,num20,transporte,ncomp_ch_transporte,resu,fluent_,sing,
<a name="l00644"></a>00644                                        first,trans,nlim);
<a name="l00645"></a>00645                     }
<a name="l00646"></a>00646                 }
<a name="l00647"></a>00647             }
<a name="l00648"></a>00648 
<a name="l00649"></a>00649         }
<a name="l00650"></a>00650 
<a name="l00651"></a>00651     } <span class="comment">//!&lt; fin de la boucle</span>
<a name="l00652"></a>00652 <span class="comment"></span>
<a name="l00653"></a>00653   <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot; limitiert in &quot;</span> &lt;&lt; nlim &lt;&lt; <span class="stringliteral">&quot; valeurs &quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a> ;
<a name="l00654"></a>00654 
<a name="l00655"></a>00655   <span class="keywordtype">int</span> voisine;
<a name="l00656"></a>00656   nb_faces_perio = 0;
<a name="l00657"></a>00657   <span class="keywordtype">double</span> diff1,diff2;
<a name="l00658"></a>00658 
<a name="l00659"></a>00659 <span class="comment">// Dimensionnement du tableau des flux convectifs au bord du domaine</span>
<a name="l00660"></a>00660 <span class="comment">// de calcul</span>
<a name="l00661"></a>00661   <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; flux_b = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>,<a class="code" href="classOperateur__base.html#a451f51b41518ddbc0d3f586a8177d319" title="Tableau contenant les flux sur les bords de l&#39;operateur.">flux_bords_</a>);
<a name="l00662"></a>00662   flux_b.<a class="code" href="classDoubleTab.html#ae83b4d31205c53d9c8d2b43da178ce75" title="Change la taille du vecteur (identique a resize_array() pour le traitement des anciennes valeurs et d...">resize</a>(zone_VEF.<a class="code" href="classZone__VF.html#a8815e2276637c0db23868f043dc43e58" title="renvoie le nombre de faces sur lesquelles sont appliquees les conditions limites : bords...">nb_faces_bord</a>(),ncomp_ch_transporte);
<a name="l00663"></a>00663   flux_b = 0.;
<a name="l00664"></a>00664 
<a name="l00665"></a>00665 <span class="comment">// Boucle sur les bords pour traiter les conditions aux limites</span>
<a name="l00666"></a>00666 <span class="comment">// il y a prise en compte d&#39;un terme de convection pour les</span>
<a name="l00667"></a>00667 <span class="comment">// conditions aux limites de Neumann_sortie_libre seulement</span>
<a name="l00668"></a>00668 
<a name="l00669"></a>00669   <span class="keywordflow">for</span> (n_bord=0; n_bord&lt;zone_VEF.<a class="code" href="classZone__dis__base.html#af22167d614644f55591a29c77eb1c009">nb_front_Cl</a>(); n_bord++)
<a name="l00670"></a>00670     {
<a name="l00671"></a>00671 
<a name="l00672"></a>00672       <span class="keyword">const</span> <a class="code" href="classCond__lim.html" title="classe Cond_lim Classe generique servant a representer n&#39;importe quelle classe derivee de la classe C...">Cond_lim</a>&amp; la_cl = zone_Cl_VEF.<a class="code" href="classZone__Cl__dis__base.html#af75e0ed7786863e4d333bfb29d67c323" title="Renvoie la i-ieme condition aux limites. (version const)">les_conditions_limites</a>(n_bord);
<a name="l00673"></a>00673 
<a name="l00674"></a>00674       <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classNeumann__sortie__libre.html" title="classe Neumann_sortie_libre Cette classe represente une frontiere ouverte sans vitesse imposee Pour l...">Neumann_sortie_libre</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>()))
<a name="l00675"></a>00675         {
<a name="l00676"></a>00676           <span class="keyword">const</span> <a class="code" href="classNeumann__sortie__libre.html" title="classe Neumann_sortie_libre Cette classe represente une frontiere ouverte sans vitesse imposee Pour l...">Neumann_sortie_libre</a>&amp; la_sortie_libre = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classNeumann__sortie__libre.html" title="classe Neumann_sortie_libre Cette classe represente une frontiere ouverte sans vitesse imposee Pour l...">Neumann_sortie_libre</a>, la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>());
<a name="l00677"></a>00677           <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp; le_bord = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>,la_cl.<a class="code" href="classCond__lim.html#a5b2d24809cee07727006a891d4ce8d22" title="Appel a l&#39;objet sous-jacent Renvoie la frontiere discretisee associee a la condition aux limites...">frontiere_dis</a>());
<a name="l00678"></a>00678           <span class="keywordtype">int</span> num1 = le_bord.num_premiere_face();
<a name="l00679"></a>00679           <span class="keywordtype">int</span> num2 = num1 + le_bord.nb_faces();
<a name="l00680"></a>00680           <span class="keywordflow">for</span> (num_face=num1; num_face&lt;num2; num_face++)
<a name="l00681"></a>00681             {
<a name="l00682"></a>00682               psc =0;
<a name="l00683"></a>00683               <span class="keywordflow">for</span> (i=0; i&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; i++)
<a name="l00684"></a>00684                 psc += la_vitesse(num_face,i)*face_normales(num_face,i);
<a name="l00685"></a>00685               <span class="keywordflow">if</span> (psc&gt;0)
<a name="l00686"></a>00686                 <span class="keywordflow">if</span> (ncomp_ch_transporte == 1)
<a name="l00687"></a>00687                   {
<a name="l00688"></a>00688                     resu(num_face) -= psc*transporte(num_face);
<a name="l00689"></a>00689                     flux_b(num_face,0) -= psc*transporte(num_face);
<a name="l00690"></a>00690                   }
<a name="l00691"></a>00691                 <span class="keywordflow">else</span>
<a name="l00692"></a>00692                   <span class="keywordflow">for</span> (i=0; i&lt;ncomp_ch_transporte; i++)
<a name="l00693"></a>00693                     {
<a name="l00694"></a>00694                       resu(num_face,i) -= psc*transporte(num_face,i);
<a name="l00695"></a>00695                       flux_b(num_face,i) -= psc*transporte(num_face,i);
<a name="l00696"></a>00696                     }
<a name="l00697"></a>00697               <span class="keywordflow">else</span>
<a name="l00698"></a>00698                 {
<a name="l00699"></a>00699                   <span class="keywordflow">if</span> (ncomp_ch_transporte == 1)
<a name="l00700"></a>00700                     {
<a name="l00701"></a>00701                       resu(num_face) -= psc*la_sortie_libre.<a class="code" href="classNeumann__sortie__libre.html#a886f1804fa2a9028fc56a0778a72a75d" title="Renvoie la valeur de la i-eme composante du champ impose a l&#39;exterieur de la frontiere.">val_ext</a>(num_face-num1);
<a name="l00702"></a>00702                       flux_b(num_face,0) -= psc*la_sortie_libre.<a class="code" href="classNeumann__sortie__libre.html#a886f1804fa2a9028fc56a0778a72a75d" title="Renvoie la valeur de la i-eme composante du champ impose a l&#39;exterieur de la frontiere.">val_ext</a>(num_face-num1);
<a name="l00703"></a>00703                     }
<a name="l00704"></a>00704                   <span class="keywordflow">else</span>
<a name="l00705"></a>00705                     <span class="keywordflow">for</span> (i=0; i&lt;ncomp_ch_transporte; i++)
<a name="l00706"></a>00706                       {
<a name="l00707"></a>00707                         resu(num_face,i) -= psc*la_sortie_libre.<a class="code" href="classNeumann__sortie__libre.html#a886f1804fa2a9028fc56a0778a72a75d" title="Renvoie la valeur de la i-eme composante du champ impose a l&#39;exterieur de la frontiere.">val_ext</a>(num_face-num1,i);
<a name="l00708"></a>00708                         flux_b(num_face,i) -= psc*la_sortie_libre.<a class="code" href="classNeumann__sortie__libre.html#a886f1804fa2a9028fc56a0778a72a75d" title="Renvoie la valeur de la i-eme composante du champ impose a l&#39;exterieur de la frontiere.">val_ext</a>(num_face-num1);
<a name="l00709"></a>00709                       }
<a name="l00710"></a>00710                   fluent_[num_face] -= psc;
<a name="l00711"></a>00711                 }
<a name="l00712"></a>00712             }
<a name="l00713"></a>00713         }
<a name="l00714"></a>00714       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>()))
<a name="l00715"></a>00715         {
<a name="l00716"></a>00716           <span class="keyword">const</span> <a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>&amp; la_cl_perio = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>, la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>());
<a name="l00717"></a>00717           <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp; le_bord = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>,la_cl.<a class="code" href="classCond__lim.html#a5b2d24809cee07727006a891d4ce8d22" title="Appel a l&#39;objet sous-jacent Renvoie la frontiere discretisee associee a la condition aux limites...">frontiere_dis</a>());
<a name="l00718"></a>00718           <span class="keywordtype">int</span> num1 = le_bord.num_premiere_face();
<a name="l00719"></a>00719           <span class="keywordtype">int</span> num2 = num1 + le_bord.nb_faces();
<a name="l00720"></a>00720           <a class="code" href="classIntVect.html">IntVect</a> fait(le_bord.nb_faces());
<a name="l00721"></a>00721           fait = 0;
<a name="l00722"></a>00722           <span class="keywordflow">for</span> (num_face=num1; num_face&lt;num2; num_face++)
<a name="l00723"></a>00723             {
<a name="l00724"></a>00724               <span class="keywordflow">if</span> (fait[num_face-num1] == 0)
<a name="l00725"></a>00725                 {
<a name="l00726"></a>00726                   voisine = la_cl_perio.<a class="code" href="classPeriodique.html#a207b86556f199a63ea059b841851ca6a">face_associee</a>(num_face-num1) + num1;
<a name="l00727"></a>00727 
<a name="l00728"></a>00728                   <span class="keywordflow">if</span> (ncomp_ch_transporte == 1)
<a name="l00729"></a>00729                     {
<a name="l00730"></a>00730                       diff1 = resu(num_face)-tab(nb_faces_perio);
<a name="l00731"></a>00731                       diff2 = resu(voisine)-tab(nb_faces_perio+voisine-num_face);
<a name="l00732"></a>00732                       resu(voisine)  += diff1;
<a name="l00733"></a>00733                       resu(num_face) += diff2;
<a name="l00734"></a>00734                       flux_b(voisine,1) += diff1;
<a name="l00735"></a>00735                       flux_b(num_face,0) += diff2;
<a name="l00736"></a>00736                     }
<a name="l00737"></a>00737                   <span class="keywordflow">else</span>
<a name="l00738"></a>00738                     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> comp=0; comp&lt;ncomp_ch_transporte; comp++)
<a name="l00739"></a>00739                       {
<a name="l00740"></a>00740                         diff1 = resu(num_face,comp)-tab(nb_faces_perio,comp);
<a name="l00741"></a>00741                         diff2 = resu(voisine,comp)-tab(nb_faces_perio+voisine-num_face,comp);
<a name="l00742"></a>00742                         resu(voisine,comp)  += diff1;
<a name="l00743"></a>00743                         resu(num_face,comp) += diff2;
<a name="l00744"></a>00744                         flux_b(voisine,comp) += diff1;
<a name="l00745"></a>00745                         flux_b(num_face,comp) += diff2;
<a name="l00746"></a>00746                       }
<a name="l00747"></a>00747 
<a name="l00748"></a>00748                   fait[num_face-num1]= 1;
<a name="l00749"></a>00749                   fait[voisine-num1] = 1;
<a name="l00750"></a>00750                 }
<a name="l00751"></a>00751               nb_faces_perio++;
<a name="l00752"></a>00752             }
<a name="l00753"></a>00753         }
<a name="l00754"></a>00754     }
<a name="l00755"></a>00755   <a class="code" href="classOp__VEF__Face.html#a6c8ce571769b4f2e20b07cbb7a6944f2">modifier_flux</a>(*<span class="keyword">this</span>);
<a name="l00756"></a>00756   <span class="keywordflow">return</span> resu;
<a name="l00757"></a>00757 
<a name="l00758"></a>00758 }
<a name="l00759"></a>00759 
<a name="l00760"></a>00760 
<a name="l00761"></a><a class="code" href="classOp__Conv__DI__L2__VEF__Face.html#a16dc52476bc30af35f4016ec4c79b867">00761</a> <span class="keywordtype">void</span> <a class="code" href="classOp__Conv__DI__L2__VEF__Face.html#a16dc52476bc30af35f4016ec4c79b867">Op_Conv_DI_L2_VEF_Face::reconst_DI_L2_2d</a>(<a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; derive ,<span class="keywordtype">int</span> poly,
<a name="l00762"></a>00762                                               <span class="keywordtype">double</span> psc,<span class="keywordtype">int</span> num1,<span class="keywordtype">int</span> num2,
<a name="l00763"></a>00763                                               <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; transporte,
<a name="l00764"></a>00764                                               <span class="keywordtype">int</span> ncomp,
<a name="l00765"></a>00765                                               <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; resu,
<a name="l00766"></a>00766                                               <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; tab_fluent, <span class="keywordtype">int</span> sing, <span class="keywordtype">int</span>&amp; nlim)<span class="keyword"> const</span>
<a name="l00767"></a>00767 <span class="keyword"></span>{
<a name="l00768"></a>00768 
<a name="l00769"></a>00769 <span class="comment">// Cerr &lt;&lt; &quot; in reconst_DI_L2_2d &quot; &lt;&lt; sing &lt;&lt; finl ;</span>
<a name="l00770"></a>00770 
<a name="l00771"></a>00771   <span class="keyword">const</span> <a class="code" href="classZone__VEF.html" title="class Zone_VEF Classe instanciable qui derive de Zone_VF. Cette classe contient les informations geom...">Zone_VEF</a>&amp; zone_VEF = <a class="code" href="classOp__Conv__VEF__base.html#a6c29a488a6805ba4a9f2f059cdba77ae">la_zone_vef</a>.<a class="code" href="classRef__Zone__VEF.html#aafd9a5ee1a76f290c9c6b5447b0c8d30">valeur</a>();
<a name="l00772"></a>00772 
<a name="l00773"></a>00773   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; elem_faces = zone_VEF.<a class="code" href="classZone__VF.html#a067e462dcd3ab92b0f6d945b19e4eb37" title="renvoie le numero de le ieme face de la maille num_elem la facon dont ces faces sont numerotees est l...">elem_faces</a>();
<a name="l00774"></a>00774 <span class="comment">// const IntTab&amp; face_voisins = zone_VEF.face_voisins();</span>
<a name="l00775"></a>00775 
<a name="l00776"></a>00776   <span class="keyword">const</span> <a class="code" href="classZone.html" title="classe Zone Une Zone est un maillage compose d&#39;un ensemble d&#39;elements geometriques de meme type...">Zone</a>&amp; zone = zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>();
<a name="l00777"></a>00777 
<a name="l00778"></a>00778   <span class="keywordtype">int</span> nfac = zone.<a class="code" href="classZone.html#a548fbc7518be2f122b1a5c9589a443c2" title="Renvoie le nombre de face de type i des elements geometriques constituants la zone. Ex: les objets de la classe Prisme ont 2 types de faces: triangle ou quadrangle.">nb_faces_elem</a>();
<a name="l00779"></a>00779 
<a name="l00780"></a>00780   <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; xv = zone_VEF.<a class="code" href="classZone__VF.html#a918c0885a9b67317fcce3a0535306542">xv</a>();
<a name="l00781"></a>00781   <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; xp = zone_VEF.<a class="code" href="classZone__VF.html#a87a29f0223c71256a25ee343c9277599">xp</a>();
<a name="l00782"></a>00782 
<a name="l00783"></a>00783   <span class="keywordtype">double</span> dt=<a class="code" href="classMorEqn.html#a615dd9abff96edcb625fa0424a489864" title="Renvoie la reference sur l&#39;equation pointe par MorEqn::mon_equation. (version const)">equation</a>().<a class="code" href="classEquation__base.html#abc11e51aa75b4c7aa55c27f71eb2f2c4" title="Renvoie le schema en temps associe a l&#39;equation.">schema_temps</a>().<a class="code" href="classSchema__Temps__base.html#a0e4f67ef6086c09434ddc161668077b2" title="Renvoie le pas de temps (delta_t) courant.">pas_de_temps</a>();
<a name="l00784"></a>00784   <span class="keyword">const</span> <a class="code" href="classChamp__Inc__base.html" title="Classe Champ_Inc_base Classe de base des champs inconnues qui sont les champs calcules par une equati...">Champ_Inc_base</a>&amp; la_vitesse=<a class="code" href="classOp__Conv__VEF__base.html#a5547875832fb45e09b1115372fb76ffd">vitesse_</a>.<a class="code" href="classRef__Champ__Inc__base.html#a17553641a4c06730e1562125e07b3490">valeur</a>();
<a name="l00785"></a>00785 
<a name="l00786"></a>00786   <span class="keywordtype">int</span> i, j, face_adj , face_glob, numg=-1 ;
<a name="l00787"></a>00787   <a class="code" href="classDoubleVect.html">DoubleVect</a> dist(<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>) ;
<a name="l00788"></a>00788   <a class="code" href="classDoubleVect.html">DoubleVect</a> trans_c_g(ncomp) ;
<a name="l00789"></a>00789   <a class="code" href="classDoubleVect.html">DoubleVect</a> vs(ncomp) ;
<a name="l00790"></a>00790   <a class="code" href="classDoubleVect.html">DoubleVect</a> trans(ncomp) ;
<a name="l00791"></a>00791   <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a> coor_trans(<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>,<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>) ;
<a name="l00792"></a>00792 
<a name="l00793"></a>00793   trans_c_g = 0. ;
<a name="l00794"></a>00794 
<a name="l00795"></a>00795   <span class="keywordflow">for</span> (j=0; j&lt;ncomp; j++)
<a name="l00796"></a>00796     {
<a name="l00797"></a>00797       <span class="keywordflow">for</span>(face_adj=0; face_adj&lt;nfac; face_adj ++)
<a name="l00798"></a>00798         {
<a name="l00799"></a>00799           face_glob = elem_faces(poly, face_adj);
<a name="l00800"></a>00800 
<a name="l00801"></a>00801           <span class="keywordflow">if</span> (ncomp == 1) trans_c_g(0) += transporte(face_glob)/double(nfac) ;
<a name="l00802"></a>00802           <span class="keywordflow">else</span> trans_c_g(j) += transporte(face_glob,j)/double(nfac) ;
<a name="l00803"></a>00803 
<a name="l00804"></a>00804           <span class="keywordflow">if</span> ((face_glob != num1) &amp;&amp; (face_glob != num2)) numg = face_glob ;
<a name="l00805"></a>00805 
<a name="l00806"></a>00806         }
<a name="l00807"></a>00807     }
<a name="l00808"></a>00808   <span class="keywordtype">int</span> num3 = elem_faces(poly, 0 ) ;
<a name="l00809"></a>00809 
<a name="l00810"></a>00810 <span class="comment">// coor_trans(0,0) = cos(3.14159/4.) ;</span>
<a name="l00811"></a>00811 <span class="comment">// coor_trans(0,1) = cos(3.14159/4.) ;</span>
<a name="l00812"></a>00812 <span class="comment">// coor_trans(1,0) = cos(3.14159/2.-3.14159/4.) ;</span>
<a name="l00813"></a>00813 <span class="comment">// coor_trans(1,1) = cos(3.14159/2.+3.14159/4.) ;</span>
<a name="l00814"></a>00814   coor_trans(0,0) = 1. ;
<a name="l00815"></a>00815   coor_trans(0,1) = 0. ;
<a name="l00816"></a>00816   coor_trans(1,0) = 0. ;
<a name="l00817"></a>00817   coor_trans(1,1) = 1. ;
<a name="l00818"></a>00818 
<a name="l00819"></a>00819   <span class="keywordflow">for</span> (i=0; i&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; i++) vs(i)= (la_vitesse(num1,i)+la_vitesse(num2,i)) / 2.;
<a name="l00820"></a>00820 
<a name="l00821"></a>00821   dist = 0. ;
<a name="l00822"></a>00822 
<a name="l00823"></a>00823   <span class="keywordflow">for</span> (i=0; i&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; i++)
<a name="l00824"></a>00824     <span class="keywordflow">for</span> (j=0; j&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; j++)
<a name="l00825"></a>00825       dist(i) += (2.*xp(poly,j) - xv(numg,j)  -  xv(num3,j) - vs(j)*dt/2. ) * coor_trans(i,j) ;
<a name="l00826"></a>00826 
<a name="l00827"></a>00827   <span class="keywordtype">double</span> dtrans_max, dtrans_min, dtrans_cen ;
<a name="l00828"></a>00828 
<a name="l00829"></a>00829   <span class="keywordtype">int</span> amont, aval ;
<a name="l00830"></a>00830 
<a name="l00831"></a>00831   <span class="keywordflow">if</span> (psc &gt;= 0)
<a name="l00832"></a>00832     {
<a name="l00833"></a>00833       amont = num1;
<a name="l00834"></a>00834       aval  = num2;
<a name="l00835"></a>00835     }
<a name="l00836"></a>00836   <span class="keywordflow">else</span>
<a name="l00837"></a>00837     {
<a name="l00838"></a>00838       amont = num2;
<a name="l00839"></a>00839       aval  = num1;
<a name="l00840"></a>00840     }
<a name="l00841"></a>00841 
<a name="l00842"></a>00842   <span class="keywordflow">for</span> (j=0; j&lt;ncomp; j++)
<a name="l00843"></a>00843     {
<a name="l00844"></a>00844 
<a name="l00845"></a>00845       <span class="keywordflow">if</span> (sing == 0 )
<a name="l00846"></a>00846         {
<a name="l00847"></a>00847           <span class="keywordflow">if</span>(ncomp == 1)
<a name="l00848"></a>00848             {
<a name="l00849"></a>00849               trans(0) = transporte(num3) + derive(4)*dist(0) * coor_trans(0,0)
<a name="l00850"></a>00850                          + derive(3)*dist(1) * coor_trans(1,1)
<a name="l00851"></a>00851                          + 1./2.*( derive(2)*dist(0)*dist(0) + derive(1)*dist(1)*dist(1) )
<a name="l00852"></a>00852                          + derive(0)*dist(0)*dist(1)    ;
<a name="l00853"></a>00853 
<a name="l00854"></a>00854               dtrans_cen =  transporte(amont) + transporte(aval) - trans_c_g(0) ;
<a name="l00855"></a>00855               dtrans_max =  <a class="code" href="Double_8h.html#aec69e4c89b77badf104ae9d6ae393b2c">dmax</a>( transporte(amont), dtrans_cen ) ;
<a name="l00856"></a>00856               dtrans_min =  <a class="code" href="Double_8h.html#a04e03b7aad55468a8b8eae326087338a">dmin</a>( transporte(amont), dtrans_cen ) ;
<a name="l00857"></a>00857             }
<a name="l00858"></a>00858           <span class="keywordflow">else</span>
<a name="l00859"></a>00859             {
<a name="l00860"></a>00860               trans(j) = transporte(num3,j) + derive(4,j)*dist(0) * coor_trans(0,0)
<a name="l00861"></a>00861                          + derive(3,j)*dist(1) * coor_trans(1,1)
<a name="l00862"></a>00862                          + 1./2.*( derive(2,j)*dist(0)*dist(0) + derive(1,j)*dist(1)*dist(1) )
<a name="l00863"></a>00863                          + derive(0,j)*dist(0)*dist(1)    ;
<a name="l00864"></a>00864 
<a name="l00865"></a>00865 
<a name="l00866"></a>00866 <span class="comment">// dtrans_cen =  transporte(num1,j) + transporte(num2,j) - trans_c_g(j) ;</span>
<a name="l00867"></a>00867 <span class="comment">// dtrans_cen =  1./2.*(transporte(amont,j) + transporte(aval,j)) ;</span>
<a name="l00868"></a>00868               dtrans_cen =  transporte(num1,j) + transporte(num2,j) - trans_c_g(j) ;
<a name="l00869"></a>00869 
<a name="l00870"></a>00870 <span class="comment">// dtrans_max =  dmax( transporte(amont,j), transporte(aval,j)) ;</span>
<a name="l00871"></a>00871               dtrans_max =  <a class="code" href="Double_8h.html#aec69e4c89b77badf104ae9d6ae393b2c">dmax</a>( transporte(amont,j) , dtrans_cen) ;
<a name="l00872"></a>00872               dtrans_min =  <a class="code" href="Double_8h.html#a04e03b7aad55468a8b8eae326087338a">dmin</a>( transporte(amont,j) , dtrans_cen) ;
<a name="l00873"></a>00873 <span class="comment">// dtrans_min =  dmin( dtrans_min, dtrans_cen) ;</span>
<a name="l00874"></a>00874 
<a name="l00875"></a>00875             }
<a name="l00876"></a>00876 
<a name="l00877"></a>00877           <span class="keywordflow">if</span> (trans(j) &gt; dtrans_max )
<a name="l00878"></a>00878             {
<a name="l00879"></a>00879 <span class="comment">// Cerr &lt;&lt; &quot;lim_max &quot;&lt;&lt; finl ;</span>
<a name="l00880"></a>00880               nlim++ ;
<a name="l00881"></a>00881               trans(j) = dtrans_max ;
<a name="l00882"></a>00882             }
<a name="l00883"></a>00883           <span class="keywordflow">if</span> (trans(j) &lt; dtrans_min )
<a name="l00884"></a>00884             {
<a name="l00885"></a>00885 <span class="comment">// Cerr &lt;&lt; &quot;lim_min &quot;&lt;&lt; finl ;</span>
<a name="l00886"></a>00886               nlim++ ;
<a name="l00887"></a>00887               trans(j) = dtrans_min ;
<a name="l00888"></a>00888             }
<a name="l00889"></a>00889         }
<a name="l00890"></a>00890       <span class="keywordflow">else</span>
<a name="l00891"></a>00891         {
<a name="l00892"></a>00892           <span class="keywordflow">if</span>(ncomp == 1) trans(0) = ( transporte(num1) + transporte(num2) ) - trans_c_g(0) ;
<a name="l00893"></a>00893           <span class="keywordflow">else</span>           trans(j) = ( transporte(num1,j) + transporte(num2,j) ) - trans_c_g(j) ;
<a name="l00894"></a>00894           <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot; singx != 0 &quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a> ;
<a name="l00895"></a>00895         }
<a name="l00896"></a>00896     }
<a name="l00897"></a>00897 
<a name="l00898"></a>00898 <span class="comment">// double kwave = 1. ;</span>
<a name="l00899"></a>00899 <span class="comment">// double lo_x = xv(num1,0)+xv(num2,0)-xp(poly,0) ;</span>
<a name="l00900"></a>00900 <span class="comment">// double lo_y = xv(num1,1)+xv(num2,1)-xp(poly,1) ;</span>
<a name="l00901"></a>00901 
<a name="l00902"></a>00902 <span class="comment">// double exact0= -sin(kwave*lo_x)*cos(kwave*lo_y);</span>
<a name="l00903"></a>00903 <span class="comment">// double exact1=  cos(kwave*lo_x)*sin(kwave*lo_y);</span>
<a name="l00904"></a>00904 <span class="comment">// double exact0 = kwave*lo_x*lo_x ;</span>
<a name="l00905"></a>00905 <span class="comment">// double exact1 = kwave*lo_y*lo_y ;</span>
<a name="l00906"></a>00906 
<a name="l00907"></a>00907 <span class="comment">// double moyenne0 = ( transporte(num1,0) + transporte(num2,0) ) - trans_c_g(0)  ;</span>
<a name="l00908"></a>00908 <span class="comment">// double moyenne1 = ( transporte(num1,1) + transporte(num2,1) ) - trans_c_g(1)  ;</span>
<a name="l00909"></a>00909 
<a name="l00910"></a>00910 <span class="comment">// double xv1 = (xv(num1,0)+xv(num2,0)-xp(poly,0)) - (xv(num3,0) + dist(0) - coor_trans(0) ) ;</span>
<a name="l00911"></a>00911 <span class="comment">// double xv2 = (xv(num1,1)+xv(num2,1)-xp(poly,1)) - (xv(num3,1) + dist(1) - coor_trans(1) ) ;</span>
<a name="l00912"></a>00912 
<a name="l00913"></a>00913 <span class="comment">// double moyenne0 = transporte(numg,0) ;</span>
<a name="l00914"></a>00914 <span class="comment">// double moyenne1 = transporte(numg,1) ;</span>
<a name="l00915"></a>00915 
<a name="l00916"></a>00916 <span class="comment">// if (sing == 0 ) Cerr &lt;&lt; exact0 &lt;&lt; &quot; &quot; &lt;&lt; moyenne0 &lt;&lt; &quot; &quot; &lt;&lt; trans(0)  &lt;&lt; &quot; &quot;</span>
<a name="l00917"></a>00917 <span class="comment">// &lt;&lt; exact1 &lt;&lt; &quot; &quot; &lt;&lt; moyenne1 &lt;&lt; &quot; &quot; &lt;&lt; trans(1) &lt;&lt; finl ;</span>
<a name="l00918"></a>00918 
<a name="l00919"></a>00919 <span class="comment">// if (sing == 0 ) Cerr &lt;&lt; moyenne0 &lt;&lt; &quot; &quot; &lt;&lt; trans(0)  &lt;&lt; &quot; &quot;</span>
<a name="l00920"></a>00920 <span class="comment">// &lt;&lt; moyenne1 &lt;&lt; &quot; &quot; &lt;&lt; trans(1) &lt;&lt; finl ;</span>
<a name="l00921"></a>00921 <span class="comment">// Cerr &lt;&lt; numg &lt;&lt;  &quot; &quot; &lt;&lt; num3 &lt;&lt; finl ;</span>
<a name="l00922"></a>00922 
<a name="l00923"></a>00923   <span class="keywordtype">double</span> flux;
<a name="l00924"></a>00924 
<a name="l00925"></a>00925   <span class="keywordflow">if</span> (psc &gt;= 0)
<a name="l00926"></a>00926     {
<a name="l00927"></a>00927       tab_fluent[num2] += psc;
<a name="l00928"></a>00928     }
<a name="l00929"></a>00929   <span class="keywordflow">else</span>
<a name="l00930"></a>00930     {
<a name="l00931"></a>00931       tab_fluent[num1] -= psc;
<a name="l00932"></a>00932     }
<a name="l00933"></a>00933 
<a name="l00934"></a>00934   <span class="keywordflow">if</span> (ncomp == 1)
<a name="l00935"></a>00935     {
<a name="l00936"></a>00936       flux = trans(0)*psc;
<a name="l00937"></a>00937       resu(num1) -= flux;
<a name="l00938"></a>00938       resu(num2) += flux;
<a name="l00939"></a>00939     }
<a name="l00940"></a>00940   <span class="keywordflow">else</span>
<a name="l00941"></a>00941     {
<a name="l00942"></a>00942       <span class="keywordflow">for</span> (i=0; i&lt;ncomp; i++)
<a name="l00943"></a>00943         {
<a name="l00944"></a>00944           flux = trans(i)*psc;
<a name="l00945"></a>00945           resu(num1,i) -= flux;
<a name="l00946"></a>00946           resu(num2,i) += flux;
<a name="l00947"></a>00947         }
<a name="l00948"></a>00948     }
<a name="l00949"></a>00949 
<a name="l00950"></a>00950 }
<a name="l00951"></a>00951 
<a name="l00952"></a><a class="code" href="classOp__Conv__DI__L2__VEF__Face.html#a2f3d4e8e1bc00c9d02e95e1cbecc1eac">00952</a> <span class="keywordtype">void</span> <a class="code" href="classOp__Conv__DI__L2__VEF__Face.html#a2f3d4e8e1bc00c9d02e95e1cbecc1eac">Op_Conv_DI_L2_VEF_Face::reconst_DI_L2_3d</a>(<a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; derive, <span class="keywordtype">int</span> poly,
<a name="l00953"></a>00953                                               <span class="keywordtype">double</span> psc,<span class="keywordtype">int</span> num1,<span class="keywordtype">int</span> num2,
<a name="l00954"></a>00954                                               <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; transporte,
<a name="l00955"></a>00955                                               <span class="keywordtype">int</span> ncomp,
<a name="l00956"></a>00956                                               <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; resu,
<a name="l00957"></a>00957                                               <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; tab_fluent ,
<a name="l00958"></a>00958                                               <span class="keywordtype">int</span> sing, <span class="keywordtype">int</span> first, <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; trans,
<a name="l00959"></a>00959                                               <span class="keywordtype">int</span>&amp; nlim)<span class="keyword"> const</span>
<a name="l00960"></a>00960 <span class="keyword"></span>{
<a name="l00961"></a>00961 
<a name="l00962"></a>00962   <span class="keyword">const</span> <a class="code" href="classZone__VEF.html" title="class Zone_VEF Classe instanciable qui derive de Zone_VF. Cette classe contient les informations geom...">Zone_VEF</a>&amp; zone_VEF = <a class="code" href="classOp__Conv__VEF__base.html#a6c29a488a6805ba4a9f2f059cdba77ae">la_zone_vef</a>.<a class="code" href="classRef__Zone__VEF.html#aafd9a5ee1a76f290c9c6b5447b0c8d30">valeur</a>();
<a name="l00963"></a>00963 
<a name="l00964"></a>00964   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; elem_faces = zone_VEF.<a class="code" href="classZone__VF.html#a067e462dcd3ab92b0f6d945b19e4eb37" title="renvoie le numero de le ieme face de la maille num_elem la facon dont ces faces sont numerotees est l...">elem_faces</a>();
<a name="l00965"></a>00965 <span class="comment">// const IntTab&amp; face_voisins = zone_VEF.face_voisins();</span>
<a name="l00966"></a>00966 
<a name="l00967"></a>00967 <span class="comment">// const int nb_faces = zone_VEF.nb_faces();</span>
<a name="l00968"></a>00968 <span class="comment">// const int nfa7 = zone_VEF.type_elem().nb_facette();</span>
<a name="l00969"></a>00969 <span class="comment">// const int nb_elem = zone_VEF.nb_elem();</span>
<a name="l00970"></a>00970 <span class="comment">// const int nb_elem_tot = zone_VEF.nb_elem_tot();</span>
<a name="l00971"></a>00971 <span class="comment">// int premiere_face_std = zone_VEF.premiere_face_std();</span>
<a name="l00972"></a>00972 
<a name="l00973"></a>00973   <span class="keyword">const</span> <a class="code" href="classZone.html" title="classe Zone Une Zone est un maillage compose d&#39;un ensemble d&#39;elements geometriques de meme type...">Zone</a>&amp; zone = zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>();
<a name="l00974"></a>00974 
<a name="l00975"></a>00975   <span class="keywordtype">int</span> nfac = zone.<a class="code" href="classZone.html#a548fbc7518be2f122b1a5c9589a443c2" title="Renvoie le nombre de face de type i des elements geometriques constituants la zone. Ex: les objets de la classe Prisme ont 2 types de faces: triangle ou quadrangle.">nb_faces_elem</a>();
<a name="l00976"></a>00976 <span class="comment">// int nsom = zone.nb_som_elem();</span>
<a name="l00977"></a>00977 <span class="comment">// int nb_som_facette = zone.type_elem().nb_som_face();</span>
<a name="l00978"></a>00978 
<a name="l00979"></a>00979   <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; xv = zone_VEF.<a class="code" href="classZone__VF.html#a918c0885a9b67317fcce3a0535306542">xv</a>();
<a name="l00980"></a>00980   <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; xp = zone_VEF.<a class="code" href="classZone__VF.html#a87a29f0223c71256a25ee343c9277599">xp</a>();
<a name="l00981"></a>00981 
<a name="l00982"></a>00982 
<a name="l00983"></a>00983   <span class="keywordtype">double</span> dt=<a class="code" href="classMorEqn.html#a615dd9abff96edcb625fa0424a489864" title="Renvoie la reference sur l&#39;equation pointe par MorEqn::mon_equation. (version const)">equation</a>().<a class="code" href="classEquation__base.html#abc11e51aa75b4c7aa55c27f71eb2f2c4" title="Renvoie le schema en temps associe a l&#39;equation.">schema_temps</a>().<a class="code" href="classSchema__Temps__base.html#a0e4f67ef6086c09434ddc161668077b2" title="Renvoie le pas de temps (delta_t) courant.">pas_de_temps</a>();
<a name="l00984"></a>00984   <span class="keyword">const</span> <a class="code" href="classChamp__Inc__base.html" title="Classe Champ_Inc_base Classe de base des champs inconnues qui sont les champs calcules par une equati...">Champ_Inc_base</a>&amp; la_vitesse=<a class="code" href="classOp__Conv__VEF__base.html#a5547875832fb45e09b1115372fb76ffd">vitesse_</a>.<a class="code" href="classRef__Champ__Inc__base.html#a17553641a4c06730e1562125e07b3490">valeur</a>();
<a name="l00985"></a>00985 
<a name="l00986"></a>00986   <span class="keywordtype">double</span> dtrans_max, dtrans_min, dtrans_cen;<span class="comment">//, dtrans_aval ;</span>
<a name="l00987"></a>00987 
<a name="l00988"></a>00988   <span class="keywordtype">int</span> i, j, face_adj , face_glob ;
<a name="l00989"></a>00989 
<a name="l00990"></a>00990   <a class="code" href="classDoubleVect.html">DoubleVect</a> dist(<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>) ;
<a name="l00991"></a>00991   <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a> coor_trans(<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>,<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>) ;
<a name="l00992"></a>00992 
<a name="l00993"></a>00993   <a class="code" href="classDoubleVect.html">DoubleVect</a> trans_c_g(ncomp) ;
<a name="l00994"></a>00994   <span class="keywordtype">double</span> flux;
<a name="l00995"></a>00995   <a class="code" href="classIntVect.html">IntVect</a> face(nfac) ;
<a name="l00996"></a>00996 
<a name="l00997"></a>00997   <a class="code" href="classDoubleVect.html">DoubleVect</a> vs(<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>) ;
<a name="l00998"></a>00998 
<a name="l00999"></a>00999   <span class="keywordtype">int</span> amont, aval ;
<a name="l01000"></a>01000 
<a name="l01001"></a>01001   <span class="keywordflow">if</span> (psc &gt;= 0)
<a name="l01002"></a>01002     {
<a name="l01003"></a>01003       amont = num1;
<a name="l01004"></a>01004       aval  = num2;
<a name="l01005"></a>01005     }
<a name="l01006"></a>01006   <span class="keywordflow">else</span>
<a name="l01007"></a>01007     {
<a name="l01008"></a>01008       amont = num2;
<a name="l01009"></a>01009       aval  = num1;
<a name="l01010"></a>01010     }
<a name="l01011"></a>01011 
<a name="l01012"></a>01012   <span class="keywordflow">if</span>(first == 0)
<a name="l01013"></a>01013     {
<a name="l01014"></a>01014       trans_c_g = 0. ;
<a name="l01015"></a>01015 
<a name="l01016"></a>01016       <span class="keywordflow">for</span>(face_adj=0; face_adj&lt;nfac; face_adj ++)
<a name="l01017"></a>01017         {
<a name="l01018"></a>01018           face_glob = elem_faces(poly, face_adj );
<a name="l01019"></a>01019           face(face_adj) = face_glob ;
<a name="l01020"></a>01020           <span class="keywordflow">for</span> (i=0; i&lt;ncomp; i++)
<a name="l01021"></a>01021             trans_c_g(i) += transporte(face_glob,i)/double(nfac) ;
<a name="l01022"></a>01022 
<a name="l01023"></a>01023         }
<a name="l01024"></a>01024       <span class="keywordtype">int</span> num3 = elem_faces(poly, 0 ) ;
<a name="l01025"></a>01025 
<a name="l01026"></a>01026       coor_trans(0,0) = cos(3.14159/4.) ;
<a name="l01027"></a>01027       coor_trans(0,1) = cos(3.14159/4.) ;
<a name="l01028"></a>01028       coor_trans(0,2) = cos(3.14159/2.) ;
<a name="l01029"></a>01029 
<a name="l01030"></a>01030       coor_trans(1,0) = cos(3.14159/2.-3.14159/4.) ;
<a name="l01031"></a>01031       coor_trans(1,1) = cos(3.14159/2.+3.14159/4.) ;
<a name="l01032"></a>01032       coor_trans(1,2) = cos(3.14159/2.) ;
<a name="l01033"></a>01033 
<a name="l01034"></a>01034       coor_trans(2,0) = cos(3.14159/2.) ;
<a name="l01035"></a>01035       coor_trans(2,1) = cos(3.14159/2.) ;
<a name="l01036"></a>01036       coor_trans(2,2) = cos(0.) ;
<a name="l01037"></a>01037 
<a name="l01038"></a>01038 <span class="comment">// coor_trans = 0.;</span>
<a name="l01039"></a>01039 <span class="comment">// coor_trans(0,0) = 1. ;</span>
<a name="l01040"></a>01040 <span class="comment">// coor_trans(1,1) = 1. ;</span>
<a name="l01041"></a>01041 <span class="comment">// coor_trans(2,2) = 1. ;</span>
<a name="l01042"></a>01042 
<a name="l01043"></a>01043       vs =0. ;
<a name="l01044"></a>01044       <span class="keywordflow">for</span>(face_adj=0; face_adj&lt;nfac; face_adj ++)
<a name="l01045"></a>01045         {
<a name="l01046"></a>01046           face_glob = elem_faces(poly, face_adj );
<a name="l01047"></a>01047           face(face_adj) = face_glob ;
<a name="l01048"></a>01048           <span class="keywordflow">for</span> (i=0; i&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; i++)
<a name="l01049"></a>01049             vs(i) -= la_vitesse(face_glob,i)/double(nfac) ;
<a name="l01050"></a>01050 
<a name="l01051"></a>01051         }
<a name="l01052"></a>01052       <span class="keywordflow">for</span> (i=0; i&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; i++) vs(i) += la_vitesse(num1,i) + la_vitesse(num2,i) ;
<a name="l01053"></a>01053 
<a name="l01054"></a>01054       dist = 0. ;
<a name="l01055"></a>01055 
<a name="l01056"></a>01056       <span class="keywordflow">for</span>(face_adj=0; face_adj&lt;nfac; face_adj ++)
<a name="l01057"></a>01057         {
<a name="l01058"></a>01058           face_glob = elem_faces(poly, face_adj);
<a name="l01059"></a>01059           <span class="keywordflow">if</span> ((face_glob == num1) || (face_glob == num2 ))
<a name="l01060"></a>01060             <span class="keywordflow">for</span> (i=0; i&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; i++)
<a name="l01061"></a>01061               <span class="keywordflow">for</span> (j=0; j&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; j++)
<a name="l01062"></a>01062                 dist(i) += xv(face_glob,j) * coor_trans(i,j) ;
<a name="l01063"></a>01063         }
<a name="l01064"></a>01064 
<a name="l01065"></a>01065       <span class="keywordflow">for</span>(i=0; i&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; i++)
<a name="l01066"></a>01066         <span class="keywordflow">for</span> (j=0; j&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; j++)
<a name="l01067"></a>01067           dist(i) -= (xp(poly,j) + xv(num3,j) + vs(j)*dt/2.) * coor_trans(i,j) ;
<a name="l01068"></a>01068 
<a name="l01069"></a>01069       <span class="keywordflow">for</span> (j=0; j&lt;ncomp; j++)
<a name="l01070"></a>01070         {
<a name="l01071"></a>01071           <span class="keywordflow">if</span> (sing == 0 )
<a name="l01072"></a>01072             {
<a name="l01073"></a>01073               <span class="keywordflow">if</span>(ncomp == 1)
<a name="l01074"></a>01074                 {
<a name="l01075"></a>01075                   trans(j) = transporte(num3,j) + derive(8)*dist(0) * coor_trans(0,0)
<a name="l01076"></a>01076                              + derive(7)*dist(1) * coor_trans(1,1)
<a name="l01077"></a>01077                              + derive(6)*dist(2) * coor_trans(2,2)
<a name="l01078"></a>01078                              + 1./2.*( derive(5)*dist(0)*dist(0) + derive(4)*dist(1)*dist(1)
<a name="l01079"></a>01079                                        + derive(3)*dist(2)*dist(2) )
<a name="l01080"></a>01080                              + derive(2)*dist(0)*dist(1) + derive(1)*dist(0)*dist(2)
<a name="l01081"></a>01081                              + derive(0)*dist(1)*dist(2) ;
<a name="l01082"></a>01082 
<a name="l01083"></a>01083                   dtrans_cen =  transporte(amont) + transporte(aval) - trans_c_g(0) ;
<a name="l01084"></a>01084 <span class="comment">// dtrans_max =  dmax( transporte(amont), transporte(aval) ) ;</span>
<a name="l01085"></a>01085                   dtrans_max =  <a class="code" href="Double_8h.html#aec69e4c89b77badf104ae9d6ae393b2c">dmax</a>( transporte(amont), dtrans_cen ) ;
<a name="l01086"></a>01086                   dtrans_min =  <a class="code" href="Double_8h.html#a04e03b7aad55468a8b8eae326087338a">dmin</a>( transporte(amont), dtrans_cen ) ;
<a name="l01087"></a>01087 <span class="comment">// dtrans_min =  dmin( dtrans_min, dtrans_cen ) ;</span>
<a name="l01088"></a>01088                 }
<a name="l01089"></a>01089               <span class="keywordflow">else</span>
<a name="l01090"></a>01090                 {
<a name="l01091"></a>01091                   trans(j) = transporte(num3,j) + derive(8,j)*dist(0) * coor_trans(0,0)
<a name="l01092"></a>01092                              + derive(7,j)*dist(1) * coor_trans(1,1)
<a name="l01093"></a>01093                              + derive(6,j)*dist(2) * coor_trans(2,2)
<a name="l01094"></a>01094                              + 1./2.*( derive(5,j)*dist(0)*dist(0) + derive(4,j)*dist(1)*dist(1)
<a name="l01095"></a>01095                                        + derive(3,j)*dist(2)*dist(2) )
<a name="l01096"></a>01096                              +         derive(2,j)*dist(0)*dist(1) + derive(1,j)*dist(0)*dist(2)
<a name="l01097"></a>01097                              +         derive(0,j)*dist(1)*dist(2) ;
<a name="l01098"></a>01098 
<a name="l01099"></a>01099                   dtrans_cen  =  transporte(amont,j) + transporte(aval,j) - trans_c_g(j) ;
<a name="l01100"></a>01100                   dtrans_max =  <a class="code" href="Double_8h.html#aec69e4c89b77badf104ae9d6ae393b2c">dmax</a>( transporte(amont,j), dtrans_cen ) ;
<a name="l01101"></a>01101 
<a name="l01102"></a>01102                   dtrans_min =  <a class="code" href="Double_8h.html#a04e03b7aad55468a8b8eae326087338a">dmin</a>( transporte(amont,j), dtrans_cen ) ;
<a name="l01103"></a>01103 
<a name="l01104"></a>01104                 }
<a name="l01105"></a>01105 
<a name="l01106"></a>01106               <span class="keywordflow">if</span> (trans(j) &gt; dtrans_max )
<a name="l01107"></a>01107                 {
<a name="l01108"></a>01108 <span class="comment">// Cerr &lt;&lt; &quot; lim max in element &quot; &lt;&lt; poly &lt;&lt; finl ;</span>
<a name="l01109"></a>01109                   trans(j) = dtrans_max ;
<a name="l01110"></a>01110                   nlim++ ;
<a name="l01111"></a>01111                 }
<a name="l01112"></a>01112               <span class="keywordflow">if</span> (trans(j) &lt; dtrans_min )
<a name="l01113"></a>01113                 {
<a name="l01114"></a>01114 <span class="comment">// Cerr &lt;&lt; &quot; lim min in element &quot; &lt;&lt; poly &lt;&lt; finl ;</span>
<a name="l01115"></a>01115                   trans(j) = dtrans_min ;
<a name="l01116"></a>01116                   nlim++ ;
<a name="l01117"></a>01117                 }
<a name="l01118"></a>01118 
<a name="l01119"></a>01119             }
<a name="l01120"></a>01120           <span class="keywordflow">else</span>
<a name="l01121"></a>01121             {
<a name="l01122"></a>01122               <span class="keywordflow">if</span>(ncomp == 1)
<a name="l01123"></a>01123                 {
<a name="l01124"></a>01124                   trans(0) =  transporte(num1) + transporte(num2)  - trans_c_g(0) ;
<a name="l01125"></a>01125 
<a name="l01126"></a>01126                 }
<a name="l01127"></a>01127               <span class="keywordflow">else</span>
<a name="l01128"></a>01128                 {
<a name="l01129"></a>01129                   trans(j) =  transporte(num1,j) + transporte(num2,j)  - trans_c_g(j) ;
<a name="l01130"></a>01130 <span class="comment">// Cerr &lt;&lt; &quot; singx != 0 &quot; &lt;&lt; finl ;</span>
<a name="l01131"></a>01131                 }
<a name="l01132"></a>01132             }
<a name="l01133"></a>01133         }
<a name="l01134"></a>01134 <span class="comment">// double lo_x = xv(num1,0)+xv(num2,0)-xp(poly,0) ;</span>
<a name="l01135"></a>01135 <span class="comment">// double lo_y = xv(num1,1)+xv(num2,1)-xp(poly,1) ;</span>
<a name="l01136"></a>01136 <span class="comment">// double lo_z = xv(num1,2)+xv(num2,2)-xp(poly,2) ;</span>
<a name="l01137"></a>01137 
<a name="l01138"></a>01138 <span class="comment">// double exact0= -sin(kwave*lo_x)*cos(kwave*lo_y);</span>
<a name="l01139"></a>01139 <span class="comment">// double exact1=  cos(kwave*lo_x)*sin(kwave*lo_y);</span>
<a name="l01140"></a>01140 
<a name="l01141"></a>01141 <span class="comment">// double exact0 = lo_x*lo_x   ;</span>
<a name="l01142"></a>01142 <span class="comment">// double exact1 = lo_y*lo_y   ;</span>
<a name="l01143"></a>01143 <span class="comment">// double exact2 = lo_z*lo_z   ;</span>
<a name="l01144"></a>01144 
<a name="l01145"></a>01145 <span class="comment">// double moyenne0 =  ( transporte(num1,0) + transporte(num2,0) ) - trans_c_g(0) ;</span>
<a name="l01146"></a>01146 <span class="comment">// double moyenne1 =  ( transporte(num1,1) + transporte(num2,1) ) - trans_c_g(1) ;</span>
<a name="l01147"></a>01147 <span class="comment">// double moyenne2 =  ( transporte(num1,2) + transporte(num2,2) ) - trans_c_g(2) ;</span>
<a name="l01148"></a>01148 <span class="comment">// double moyenne0 =   transporte(num1,0) ;</span>
<a name="l01149"></a>01149 <span class="comment">// double moyenne1 =   transporte(num1,1) ;</span>
<a name="l01150"></a>01150 <span class="comment">// double moyenne2 =   transporte(num1,2) ;   ;</span>
<a name="l01151"></a>01151 
<a name="l01152"></a>01152 <span class="comment">// double x0 =  ( xv(num1,0) + xv(num2,0) ) - xp(poly,0) ;</span>
<a name="l01153"></a>01153 <span class="comment">// double x1 =  ( xv(num1,1) + xv(num2,1) ) - xp(poly,1) ;</span>
<a name="l01154"></a>01154 <span class="comment">// double x2 =  ( xv(num1,2) + xv(num2,2) ) - xp(poly,2) ;</span>
<a name="l01155"></a>01155 <span class="comment">// double x0 =   xv(num1,0) ;</span>
<a name="l01156"></a>01156 <span class="comment">// double x1 =   xv(num1,1) ;</span>
<a name="l01157"></a>01157 <span class="comment">// double x2 =   xv(num1,2) ;</span>
<a name="l01158"></a>01158 
<a name="l01159"></a>01159 <span class="comment">// double y0 =   xv(num3,0) + dist(0) ;</span>
<a name="l01160"></a>01160 <span class="comment">// double y1 =   xv(num3,1) + dist(1) ;</span>
<a name="l01161"></a>01161 <span class="comment">// double y2 =   xv(num3,2) + dist(2) ;</span>
<a name="l01162"></a>01162 
<a name="l01163"></a>01163 <span class="comment">// if (sing == 0 ) Cerr &lt;&lt; moyenne0 &lt;&lt;  &quot;  &quot; &lt;&lt;trans(0) &lt;&lt; &quot;  &quot; &lt;&lt; moyenne1 &lt;&lt;</span>
<a name="l01164"></a>01164 <span class="comment">// &quot;  &quot; &lt;&lt; trans(1) &lt;&lt; &quot;  &quot; &lt;&lt; moyenne2 &lt;&lt; &quot;  &quot; &lt;&lt; trans(2) &lt;&lt;finl ;</span>
<a name="l01165"></a>01165 <span class="comment">// Cerr &lt;&lt; &quot; exact0&quot; &lt;&lt;  &quot; &quot; &lt;&lt; exact0 &lt;&lt; &quot;  &quot; &lt;&lt; &quot;exact1&quot; &lt;&lt;  &quot; &quot; &lt;&lt; exact1</span>
<a name="l01166"></a>01166 <span class="comment">// &lt;&lt; &quot; exact2&quot; &lt;&lt;  &quot; &quot; &lt;&lt; exact2 &lt;&lt; finl ;</span>
<a name="l01167"></a>01167 
<a name="l01168"></a>01168 <span class="comment">// Cerr &lt;&lt; x0&lt;&lt;  &quot; &quot; &lt;&lt; y0 &lt;&lt;  &quot; &quot;&lt;&lt;x1 &lt;&lt;  &quot; &quot;&lt;&lt; y1&lt;&lt;  &quot; &quot; &lt;&lt; x2 &lt;&lt;  &quot; &quot;&lt;&lt; y2 &lt;&lt; finl ;</span>
<a name="l01169"></a>01169     } <span class="comment">//!&lt; ende first = 0 und normal weiter</span>
<a name="l01170"></a>01170 <span class="comment"></span>
<a name="l01171"></a>01171   <span class="keywordflow">if</span> (psc &gt;= 0)
<a name="l01172"></a>01172     {
<a name="l01173"></a>01173       tab_fluent[num2] += psc;
<a name="l01174"></a>01174     }
<a name="l01175"></a>01175   <span class="keywordflow">else</span>
<a name="l01176"></a>01176     {
<a name="l01177"></a>01177       tab_fluent[num1] -= psc;
<a name="l01178"></a>01178     }
<a name="l01179"></a>01179 
<a name="l01180"></a>01180   <span class="keywordflow">if</span> (ncomp == 1)
<a name="l01181"></a>01181     {
<a name="l01182"></a>01182       flux = trans(0)*psc;
<a name="l01183"></a>01183       resu(num1) -= flux;
<a name="l01184"></a>01184       resu(num2) += flux;
<a name="l01185"></a>01185     }
<a name="l01186"></a>01186   <span class="keywordflow">else</span>
<a name="l01187"></a>01187     {
<a name="l01188"></a>01188       <span class="keywordflow">for</span> (i=0; i&lt;ncomp; i++)
<a name="l01189"></a>01189         {
<a name="l01190"></a>01190           flux = trans(i)*psc;
<a name="l01191"></a>01191           resu(num1,i) -= flux;
<a name="l01192"></a>01192           resu(num2,i) += flux;
<a name="l01193"></a>01193         }
<a name="l01194"></a>01194     }
<a name="l01195"></a>01195 
<a name="l01196"></a>01196 }
<a name="l01197"></a><a class="code" href="classOp__Conv__DI__L2__VEF__Face.html#aaea4484c77ff4a8a996428ce9a3e2c65">01197</a> <span class="keywordtype">void</span> <a class="code" href="classOp__Conv__DI__L2__VEF__Face.html#aaea4484c77ff4a8a996428ce9a3e2c65">Op_Conv_DI_L2_VEF_Face::poly_DI_L2_2d</a>(<span class="keywordtype">int</span> N, <span class="keywordtype">int</span> M, <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; derive ,<span class="keywordtype">int</span> poly, <span class="keywordtype">int</span> ncomp,
<a name="l01198"></a>01198                                            <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; transporte, <span class="keywordtype">int</span>&amp; sing)<span class="keyword"> const</span>
<a name="l01199"></a>01199 <span class="keyword"></span>{
<a name="l01200"></a>01200 <span class="comment">// Cerr &lt;&lt; &quot; in           poly_DI_L2_2d &quot; &lt;&lt; finl ;</span>
<a name="l01201"></a>01201   <span class="keyword">const</span> <a class="code" href="classZone__VEF.html" title="class Zone_VEF Classe instanciable qui derive de Zone_VF. Cette classe contient les informations geom...">Zone_VEF</a>&amp; zone_VEF = <a class="code" href="classOp__Conv__VEF__base.html#a6c29a488a6805ba4a9f2f059cdba77ae">la_zone_vef</a>.<a class="code" href="classRef__Zone__VEF.html#aafd9a5ee1a76f290c9c6b5447b0c8d30">valeur</a>();
<a name="l01202"></a>01202 
<a name="l01203"></a>01203   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; elem_faces = zone_VEF.<a class="code" href="classZone__VF.html#a067e462dcd3ab92b0f6d945b19e4eb37" title="renvoie le numero de le ieme face de la maille num_elem la facon dont ces faces sont numerotees est l...">elem_faces</a>();
<a name="l01204"></a>01204   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; face_voisins = zone_VEF.<a class="code" href="classZone__VF.html#a49d4322f5585a8fa95748ca785b70702" title="renvoie l&#39;element voisin de numface dans la direction i. i=0 : dans le sens oppose de l&#39;axe orthogona...">face_voisins</a>();
<a name="l01205"></a>01205 
<a name="l01206"></a>01206   <span class="keyword">const</span> <a class="code" href="classZone.html" title="classe Zone Une Zone est un maillage compose d&#39;un ensemble d&#39;elements geometriques de meme type...">Zone</a>&amp; zone = zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>();
<a name="l01207"></a>01207 
<a name="l01208"></a>01208   <span class="keywordtype">int</span> nfac = zone.<a class="code" href="classZone.html#a548fbc7518be2f122b1a5c9589a443c2" title="Renvoie le nombre de face de type i des elements geometriques constituants la zone. Ex: les objets de la classe Prisme ont 2 types de faces: triangle ou quadrangle.">nb_faces_elem</a>();
<a name="l01209"></a>01209 
<a name="l01210"></a>01210   <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; xv = zone_VEF.<a class="code" href="classZone__VF.html#a918c0885a9b67317fcce3a0535306542">xv</a>();
<a name="l01211"></a>01211   <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; xp = zone_VEF.<a class="code" href="classZone__VF.html#a87a29f0223c71256a25ee343c9277599">xp</a>();
<a name="l01212"></a>01212 
<a name="l01213"></a>01213   <span class="keywordtype">int</span> i, j, face_adj , face_glob , poly1 ;
<a name="l01214"></a>01214   <a class="code" href="classDoubleVect.html">DoubleVect</a> dist(<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>) ;
<a name="l01215"></a>01215   <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a> coor_trans(<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>,<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>) ;
<a name="l01216"></a>01216   <a class="code" href="classIntVect.html">IntVect</a> face(nfac) ;
<a name="l01217"></a>01217 
<a name="l01218"></a>01218   <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a> L(M,N) ;
<a name="l01219"></a>01219   <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a> B(M,ncomp) ;
<a name="l01220"></a>01220   <a class="code" href="classDoubleVect.html">DoubleVect</a> dTransp_x(N) ;
<a name="l01221"></a>01221   <a class="code" href="classDoubleVect.html">DoubleVect</a>  C(N) ;
<a name="l01222"></a>01222   <a class="code" href="classDoubleVect.html">DoubleVect</a> D(N) ;
<a name="l01223"></a>01223   <a class="code" href="classDoubleVect.html">DoubleVect</a> SM(N) ;
<a name="l01224"></a>01224   <span class="keywordtype">double</span> poid ;
<a name="l01225"></a>01225 
<a name="l01226"></a>01226   <span class="keywordflow">for</span>(face_adj=0; face_adj&lt;nfac; face_adj ++)
<a name="l01227"></a>01227     {
<a name="l01228"></a>01228       face_glob = elem_faces(poly, face_adj );
<a name="l01229"></a>01229       face(face_adj) = face_glob ;
<a name="l01230"></a>01230     }
<a name="l01231"></a>01231 
<a name="l01232"></a>01232   <span class="keywordtype">int</span> num3 = elem_faces(poly, 0);
<a name="l01233"></a>01233 
<a name="l01234"></a>01234 <span class="comment">// coor_trans(0) =  cos(    (xv(num3,1) - xp(poly,1)) / (xv(num3,0) - xp(poly,0))) ;</span>
<a name="l01235"></a>01235 <span class="comment">// coor_trans(1) =  cos(1.- (xv(num3,1) - xp(poly,1)) / (xv(num3,0) - xp(poly,0))) ;</span>
<a name="l01236"></a>01236 
<a name="l01237"></a>01237 <span class="comment">// coor_trans(0,0) = cos(3.14159/4.) ;</span>
<a name="l01238"></a>01238 <span class="comment">// coor_trans(0,1) = cos(3.14159/4.) ;</span>
<a name="l01239"></a>01239 <span class="comment">// coor_trans(1,0) = cos(3.14159/2.-3.14159/4.) ;</span>
<a name="l01240"></a>01240 <span class="comment">// coor_trans(1,1) = cos(3.14159/2.+3.14159/4.) ;</span>
<a name="l01241"></a>01241   coor_trans(0,0) = 1. ;
<a name="l01242"></a>01242   coor_trans(0,1) = 0. ;
<a name="l01243"></a>01243   coor_trans(1,0) = 0. ;
<a name="l01244"></a>01244   coor_trans(1,1) = 1. ;
<a name="l01245"></a>01245   <span class="keywordtype">int</span> row = -1 ;
<a name="l01246"></a>01246 
<a name="l01247"></a>01247   <span class="keywordflow">for</span>(<span class="keywordtype">int</span> face_adj_poly =0; face_adj_poly &lt; nfac; face_adj_poly ++)
<a name="l01248"></a>01248     {
<a name="l01249"></a>01249       poly1 = face_voisins(face[face_adj_poly],0);
<a name="l01250"></a>01250       <span class="keywordflow">if</span> (poly1 == poly ) poly1 = face_voisins(face[face_adj_poly], 1);
<a name="l01251"></a>01251 
<a name="l01252"></a>01252       <span class="keywordflow">for</span>(face_adj=0; face_adj&lt;nfac; face_adj ++)
<a name="l01253"></a>01253         {
<a name="l01254"></a>01254           face_glob = elem_faces(poly1, face_adj);
<a name="l01255"></a>01255           <span class="keywordflow">if</span> (face_glob != num3 )
<a name="l01256"></a>01256             {
<a name="l01257"></a>01257               row++ ;
<a name="l01258"></a>01258               dist = 0.;
<a name="l01259"></a>01259               <span class="keywordflow">for</span> (i=0; i&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; i++)
<a name="l01260"></a>01260                 <span class="keywordflow">for</span> (j=0; j&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; j++)
<a name="l01261"></a>01261                   dist(i) += (xv(face_glob,j) - xv(num3,j)) * coor_trans(i,j) ;
<a name="l01262"></a>01262 
<a name="l01263"></a>01263               poid = 0. ;
<a name="l01264"></a>01264               <span class="keywordflow">for</span> (i=0; i&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; i++)
<a name="l01265"></a>01265                 poid += ( (xv(face_glob,i)-xp(poly,i)) * (xv(face_glob,i)-xp(poly,i)) );
<a name="l01266"></a>01266               poid = 1./sqrt(poid) ;
<a name="l01267"></a>01267 
<a name="l01268"></a>01268               L(row,4) = poid * dist(0) * coor_trans(0,0) ;
<a name="l01269"></a>01269               L(row,3) = poid * dist(1) * coor_trans(1,1) ;
<a name="l01270"></a>01270               L(row,2) = poid * 1./2.*dist(0)*dist(0) ;
<a name="l01271"></a>01271               L(row,1) = poid * 1./2.*dist(1)*dist(1) ;
<a name="l01272"></a>01272               L(row,0) = poid * dist(0)*dist(1) ;
<a name="l01273"></a>01273 
<a name="l01274"></a>01274               <span class="keywordflow">if</span> (ncomp == 1)
<a name="l01275"></a>01275                 B(row,0) = poid * (transporte(face_glob)  - transporte(num3) )  ;
<a name="l01276"></a>01276               <span class="keywordflow">else</span> <span class="keywordflow">for</span> (j=0; j&lt;ncomp; j++)
<a name="l01277"></a>01277                   B(row,j) = poid * (transporte(face_glob,j) - transporte(num3,j)) ;
<a name="l01278"></a>01278 
<a name="l01279"></a>01279             }
<a name="l01280"></a>01280         }
<a name="l01281"></a>01281 
<a name="l01282"></a>01282     }
<a name="l01283"></a>01283 
<a name="l01284"></a>01284   <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a> Lij(N,N) ;
<a name="l01285"></a>01285   <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a> Bij(N,ncomp) ;
<a name="l01286"></a>01286 
<a name="l01287"></a>01287   <span class="keywordflow">for</span> (j=0; j&lt;N; j++)
<a name="l01288"></a>01288     <span class="keywordflow">for</span> (i=0; i&lt;ncomp; i++)
<a name="l01289"></a>01289       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k=0; k&lt;M; k++)       Bij(j,i) += L(k,j) * B(k,i) ;
<a name="l01290"></a>01290 
<a name="l01291"></a>01291   <span class="keywordflow">for</span> (i=0; i&lt;N; i++)
<a name="l01292"></a>01292     <span class="keywordflow">for</span> (j=0; j&lt;N; j++)
<a name="l01293"></a>01293       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k=0; k&lt;M; k++)       Lij(i,j) += L(k,i) * L(k,j) ;
<a name="l01294"></a>01294 
<a name="l01295"></a>01295 
<a name="l01296"></a>01296   <span class="keywordflow">for</span> (j=0; j&lt;ncomp; j++)
<a name="l01297"></a>01297     {
<a name="l01298"></a>01298       <span class="keywordflow">for</span> (i=0; i&lt;N; i++)   SM(i)=Bij(i,j) ;
<a name="l01299"></a>01299 
<a name="l01300"></a>01300       <a class="code" href="Op__Conv__DI__L2__VEF__Face_8cpp.html#aeb9cb62959f7dc5e3b7695f8a22eaed5">qrsolv</a>(Lij, N, SM, dTransp_x, sing, j, C, D);
<a name="l01301"></a>01301 
<a name="l01302"></a>01302       <span class="keywordflow">if</span> (sing == 0 )
<a name="l01303"></a>01303         {
<a name="l01304"></a>01304           <span class="keywordflow">if</span>(ncomp == 1)
<a name="l01305"></a>01305             {
<a name="l01306"></a>01306               <span class="keywordflow">for</span> (<span class="keywordtype">int</span> val_N= 0; val_N &lt; N ; val_N++ )
<a name="l01307"></a>01307                 derive(val_N) = dTransp_x(val_N) ;
<a name="l01308"></a>01308             }
<a name="l01309"></a>01309           <span class="keywordflow">else</span>
<a name="l01310"></a>01310             {
<a name="l01311"></a>01311               <span class="keywordflow">for</span> (<span class="keywordtype">int</span> val_N= 0; val_N &lt; N ; val_N++ )
<a name="l01312"></a>01312                 derive(val_N,j) = dTransp_x(val_N) ;
<a name="l01313"></a>01313             }
<a name="l01314"></a>01314         }
<a name="l01315"></a>01315     }
<a name="l01316"></a>01316 }
<a name="l01317"></a>01317 
<a name="l01318"></a><a class="code" href="classOp__Conv__DI__L2__VEF__Face.html#ada551c11f243074a4c2293e615c44059">01318</a> <span class="keywordtype">void</span> <a class="code" href="classOp__Conv__DI__L2__VEF__Face.html#ada551c11f243074a4c2293e615c44059">Op_Conv_DI_L2_VEF_Face::poly_DI_L2_3d</a>(<span class="keywordtype">int</span> N, <span class="keywordtype">int</span> M, <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; derive ,<span class="keywordtype">int</span> poly, <span class="keywordtype">int</span> ncomp,
<a name="l01319"></a>01319                                            <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; transporte ,<span class="keywordtype">int</span>&amp; sing)<span class="keyword"> const</span>
<a name="l01320"></a>01320 <span class="keyword"></span>{
<a name="l01321"></a>01321 <span class="comment">// Cerr&lt;&lt;&quot;Op_Conv_DI_L2_VEF_Face::poly_DI_L2_3d 0 &quot;&lt;&lt;finl;</span>
<a name="l01322"></a>01322   <span class="keyword">const</span> <a class="code" href="classZone__VEF.html" title="class Zone_VEF Classe instanciable qui derive de Zone_VF. Cette classe contient les informations geom...">Zone_VEF</a>&amp; zone_VEF = <a class="code" href="classOp__Conv__VEF__base.html#a6c29a488a6805ba4a9f2f059cdba77ae">la_zone_vef</a>.<a class="code" href="classRef__Zone__VEF.html#aafd9a5ee1a76f290c9c6b5447b0c8d30">valeur</a>();
<a name="l01323"></a>01323 
<a name="l01324"></a>01324   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; elem_faces = zone_VEF.<a class="code" href="classZone__VF.html#a067e462dcd3ab92b0f6d945b19e4eb37" title="renvoie le numero de le ieme face de la maille num_elem la facon dont ces faces sont numerotees est l...">elem_faces</a>();
<a name="l01325"></a>01325   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; face_voisins = zone_VEF.<a class="code" href="classZone__VF.html#a49d4322f5585a8fa95748ca785b70702" title="renvoie l&#39;element voisin de numface dans la direction i. i=0 : dans le sens oppose de l&#39;axe orthogona...">face_voisins</a>();
<a name="l01326"></a>01326 
<a name="l01327"></a>01327   <span class="keyword">const</span> <a class="code" href="classZone.html" title="classe Zone Une Zone est un maillage compose d&#39;un ensemble d&#39;elements geometriques de meme type...">Zone</a>&amp; zone = zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>();
<a name="l01328"></a>01328 
<a name="l01329"></a>01329   <span class="keywordtype">int</span> nfac = zone.<a class="code" href="classZone.html#a548fbc7518be2f122b1a5c9589a443c2" title="Renvoie le nombre de face de type i des elements geometriques constituants la zone. Ex: les objets de la classe Prisme ont 2 types de faces: triangle ou quadrangle.">nb_faces_elem</a>();
<a name="l01330"></a>01330 
<a name="l01331"></a>01331   <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; xv = zone_VEF.<a class="code" href="classZone__VF.html#a918c0885a9b67317fcce3a0535306542">xv</a>();
<a name="l01332"></a>01332   <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; xp = zone_VEF.<a class="code" href="classZone__VF.html#a87a29f0223c71256a25ee343c9277599">xp</a>();
<a name="l01333"></a>01333 
<a name="l01334"></a>01334   <span class="keywordtype">int</span> i, j, face_adj , face_glob , poly1 ;
<a name="l01335"></a>01335 
<a name="l01336"></a>01336   <a class="code" href="classDoubleVect.html">DoubleVect</a> dist(<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>) ;
<a name="l01337"></a>01337   <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a> coor_trans(<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>,<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>) ;
<a name="l01338"></a>01338   <a class="code" href="classIntVect.html">IntVect</a> face(nfac) ;
<a name="l01339"></a>01339 
<a name="l01340"></a>01340   <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a> L(M,N) ;
<a name="l01341"></a>01341   <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a> B(M,ncomp) ;
<a name="l01342"></a>01342   <a class="code" href="classDoubleVect.html">DoubleVect</a> dTransp_x(N) ;
<a name="l01343"></a>01343   <a class="code" href="classDoubleVect.html">DoubleVect</a>  C(N) ;
<a name="l01344"></a>01344   <a class="code" href="classDoubleVect.html">DoubleVect</a> D(N) ;
<a name="l01345"></a>01345   <a class="code" href="classDoubleVect.html">DoubleVect</a> SM(N) ;
<a name="l01346"></a>01346   <span class="keywordtype">double</span> poid ;
<a name="l01347"></a>01347 <span class="comment">// Cerr&lt;&lt;&quot;Op_Conv_DI_L2_VEF_Face::poly_DI_L2_3d 1 &quot;&lt;&lt;finl;</span>
<a name="l01348"></a>01348 
<a name="l01349"></a>01349   <span class="keywordflow">for</span>(face_adj=0; face_adj&lt;nfac; face_adj ++)
<a name="l01350"></a>01350     {
<a name="l01351"></a>01351       face_glob = elem_faces(poly, face_adj );
<a name="l01352"></a>01352       face(face_adj) = face_glob ;
<a name="l01353"></a>01353     }
<a name="l01354"></a>01354 <span class="comment">// Cerr&lt;&lt;&quot;Op_Conv_DI_L2_VEF_Face::poly_DI_L2_3d 2 &quot;&lt;&lt;finl;</span>
<a name="l01355"></a>01355 
<a name="l01356"></a>01356   <span class="keywordtype">int</span> num3 = elem_faces(poly, 0);
<a name="l01357"></a>01357 
<a name="l01358"></a>01358   coor_trans(0,0) = cos(3.14159/4.) ;
<a name="l01359"></a>01359   coor_trans(0,1) = cos(3.14159/4.) ;
<a name="l01360"></a>01360   coor_trans(0,2) = cos(3.14159/2.) ;
<a name="l01361"></a>01361 
<a name="l01362"></a>01362   coor_trans(1,0) = cos(3.14159/2.-3.14159/4.) ;
<a name="l01363"></a>01363   coor_trans(1,1) = cos(3.14159/2.+3.14159/4.) ;
<a name="l01364"></a>01364   coor_trans(1,2) = cos(3.14159/2.) ;
<a name="l01365"></a>01365 
<a name="l01366"></a>01366   coor_trans(2,0) = cos(3.14159/2.) ;
<a name="l01367"></a>01367   coor_trans(2,1) = cos(3.14159/2.) ;
<a name="l01368"></a>01368   coor_trans(2,2) = cos(0.) ;
<a name="l01369"></a>01369 
<a name="l01370"></a>01370 <span class="comment">// coor_trans = 0.;</span>
<a name="l01371"></a>01371 <span class="comment">// coor_trans(0,0) = 1. ;</span>
<a name="l01372"></a>01372 <span class="comment">// coor_trans(1,1) = 1. ;</span>
<a name="l01373"></a>01373 <span class="comment">// coor_trans(2,2) = 1. ;</span>
<a name="l01374"></a>01374 
<a name="l01375"></a>01375   <span class="keywordtype">int</span> row = -1 ;
<a name="l01376"></a>01376 <span class="comment">// Cerr&lt;&lt;&quot;Op_Conv_DI_L2_VEF_Face::poly_DI_L2_3d 3 &quot;&lt;&lt;finl;</span>
<a name="l01377"></a>01377 
<a name="l01378"></a>01378   <span class="keywordflow">for</span>(<span class="keywordtype">int</span> face_adj_poly =0; face_adj_poly &lt; nfac; face_adj_poly ++)
<a name="l01379"></a>01379     {
<a name="l01380"></a>01380       poly1 = face_voisins(face[face_adj_poly],0);
<a name="l01381"></a>01381 <span class="comment">// Cerr&lt;&lt;&quot;avant poly = &quot;&lt;&lt;poly&lt;&lt;&quot;, poly1 = &quot;&lt;&lt;poly1&lt;&lt;&quot;, proc = &quot;&lt;&lt;me()&lt;&lt;finl;</span>
<a name="l01382"></a>01382 <span class="comment">// Cerr&lt;&lt;&quot;face[face_adj_poly] = &quot;&lt;&lt;face[face_adj_poly]&lt;&lt;finl;</span>
<a name="l01383"></a>01383       <span class="keywordflow">if</span> (poly1 == poly ) poly1 = face_voisins(face[face_adj_poly], 1);
<a name="l01384"></a>01384 <span class="comment">// Cerr&lt;&lt;&quot;apres poly = &quot;&lt;&lt;poly&lt;&lt;&quot;, poly1 = &quot;&lt;&lt;poly1&lt;&lt;&quot;, proc = &quot;&lt;&lt;me()&lt;&lt;finl;</span>
<a name="l01385"></a>01385       <span class="keywordflow">for</span>(face_adj=0; face_adj&lt;nfac; face_adj ++)
<a name="l01386"></a>01386         {
<a name="l01387"></a>01387           face_glob = elem_faces(poly1, face_adj);
<a name="l01388"></a>01388           <span class="keywordflow">if</span> (face_glob != num3 )
<a name="l01389"></a>01389             {
<a name="l01390"></a>01390               row++ ;
<a name="l01391"></a>01391               dist=0 ;
<a name="l01392"></a>01392               <span class="keywordflow">for</span> (i=0; i&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; i++)
<a name="l01393"></a>01393                 <span class="keywordflow">for</span> (j=0; j&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; j++)
<a name="l01394"></a>01394                   dist(i) += (xv(face_glob,j) - xv(num3,j)) * coor_trans(i,j) ;
<a name="l01395"></a>01395 
<a name="l01396"></a>01396               poid = 0. ;
<a name="l01397"></a>01397               <span class="keywordflow">for</span> (i=0; i&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; i++)
<a name="l01398"></a>01398                 poid += ( (xv(face_glob,i)-xp(poly,i)) * (xv(face_glob,i)-xp(poly,i)) );
<a name="l01399"></a>01399               poid = 1./(poid) ;
<a name="l01400"></a>01400 
<a name="l01401"></a>01401 
<a name="l01402"></a>01402               L(row,8) = poid*dist(0) * coor_trans(0,0) ;
<a name="l01403"></a>01403               L(row,7) = poid*dist(1) * coor_trans(1,1) ;
<a name="l01404"></a>01404               L(row,6) = poid*dist(2) * coor_trans(2,2) ;
<a name="l01405"></a>01405               L(row,5) = poid*1./2.*dist(0)*dist(0) ;
<a name="l01406"></a>01406               L(row,4) = poid*1./2.*dist(1)*dist(1) ;
<a name="l01407"></a>01407               L(row,3) = poid*1./2.*dist(2)*dist(2) ;
<a name="l01408"></a>01408               L(row,2) = poid*dist(0)*dist(1) ;
<a name="l01409"></a>01409               L(row,1) = poid*dist(0)*dist(2) ;
<a name="l01410"></a>01410               L(row,0) = poid*dist(1)*dist(2) ;
<a name="l01411"></a>01411 
<a name="l01412"></a>01412               <span class="keywordflow">if</span> (ncomp == 1)
<a name="l01413"></a>01413                 B(row,0) = poid * (transporte(face_glob)  - transporte(num3) )  ;
<a name="l01414"></a>01414               <span class="keywordflow">else</span> <span class="keywordflow">for</span> (j=0; j&lt;ncomp; j++)
<a name="l01415"></a>01415                   B(row,j) = poid * (transporte(face_glob,j) - transporte(num3,j)) ;
<a name="l01416"></a>01416             }
<a name="l01417"></a>01417         }
<a name="l01418"></a>01418     }
<a name="l01419"></a>01419 
<a name="l01420"></a>01420 <span class="comment">// Cerr&lt;&lt;&quot;Op_Conv_DI_L2_VEF_Face::poly_DI_L2_3d 4 &quot;&lt;&lt;finl;</span>
<a name="l01421"></a>01421 
<a name="l01422"></a>01422   <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a> Lij(N,N) ;
<a name="l01423"></a>01423   <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a> Bij(N,ncomp) ;
<a name="l01424"></a>01424 
<a name="l01425"></a>01425   <span class="keywordflow">for</span> (j=0; j&lt;N; j++)
<a name="l01426"></a>01426     <span class="keywordflow">for</span> (i=0; i&lt;ncomp; i++)
<a name="l01427"></a>01427       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k=0; k&lt;M; k++)       Bij(j,i) += L(k,j) * B(k,i) ;
<a name="l01428"></a>01428 
<a name="l01429"></a>01429 <span class="comment">// Cerr&lt;&lt;&quot;Op_Conv_DI_L2_VEF_Face::poly_DI_L2_3d 5 &quot;&lt;&lt;finl;</span>
<a name="l01430"></a>01430 
<a name="l01431"></a>01431   <span class="keywordflow">for</span> (i=0; i&lt;N; i++)
<a name="l01432"></a>01432     <span class="keywordflow">for</span> (j=0; j&lt;N; j++)
<a name="l01433"></a>01433       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k=0; k&lt;M; k++)       Lij(i,j) += L(k,i) * L(k,j) ;
<a name="l01434"></a>01434 <span class="comment">// Cerr&lt;&lt;&quot;Op_Conv_DI_L2_VEF_Face::poly_DI_L2_3d 6 &quot;&lt;&lt;finl;</span>
<a name="l01435"></a>01435 
<a name="l01436"></a>01436 
<a name="l01437"></a>01437   <span class="keywordflow">for</span> (j=0; j&lt;ncomp; j++)
<a name="l01438"></a>01438     {
<a name="l01439"></a>01439       <span class="keywordflow">for</span> (i=0; i&lt;N; i++) SM(i)=Bij(i,j) ;
<a name="l01440"></a>01440 
<a name="l01441"></a>01441       <a class="code" href="Op__Conv__DI__L2__VEF__Face_8cpp.html#aeb9cb62959f7dc5e3b7695f8a22eaed5">qrsolv</a>(Lij, N, SM, dTransp_x, sing, j, C, D);
<a name="l01442"></a>01442 
<a name="l01443"></a>01443       <span class="keywordflow">if</span> (sing == 0 )
<a name="l01444"></a>01444         {
<a name="l01445"></a>01445           <span class="keywordflow">if</span>(ncomp == 1)
<a name="l01446"></a>01446             {
<a name="l01447"></a>01447               <span class="keywordflow">for</span> (<span class="keywordtype">int</span> val_N= 0; val_N &lt; N ; val_N++ )
<a name="l01448"></a>01448                 derive(val_N) = dTransp_x(val_N) ;
<a name="l01449"></a>01449             }
<a name="l01450"></a>01450           <span class="keywordflow">else</span>
<a name="l01451"></a>01451             {
<a name="l01452"></a>01452               <span class="keywordflow">for</span> (<span class="keywordtype">int</span> val_N= 0; val_N &lt; N ; val_N++ )
<a name="l01453"></a>01453                 derive(val_N,j) = dTransp_x(val_N) ;
<a name="l01454"></a>01454             }
<a name="l01455"></a>01455         }
<a name="l01456"></a>01456     }
<a name="l01457"></a>01457 
<a name="l01458"></a>01458 <span class="comment">// Cerr&lt;&lt;&quot;Op_Conv_DI_L2_VEF_Face::poly_DI_L2_3d 7 &quot;&lt;&lt;finl;</span>
<a name="l01459"></a>01459 
<a name="l01460"></a>01460 }
<a name="l01461"></a>01461 
<a name="l01462"></a>01462 
</pre></div></div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Tue Dec 14 2021 19:35:42 for TRUST by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
