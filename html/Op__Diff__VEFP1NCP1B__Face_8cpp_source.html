<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>TRUST: src/P1NCP1B/Operateurs/Op_Diff_VEFP1NCP1B_Face.cpp Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">TRUST&#160;<span id="projectnumber">1.8.4</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
<div class="header">
  <div class="headertitle">
<div class="title">src/P1NCP1B/Operateurs/Op_Diff_VEFP1NCP1B_Face.cpp</div>  </div>
</div>
<div class="contents">
<a href="Op__Diff__VEFP1NCP1B__Face_8cpp.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/****************************************************************************</span>
<a name="l00002"></a>00002 <span class="comment">* Copyright (c) 2021, CEA</span>
<a name="l00003"></a>00003 <span class="comment">* All rights reserved.</span>
<a name="l00004"></a>00004 <span class="comment">*</span>
<a name="l00005"></a>00005 <span class="comment">* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</span>
<a name="l00006"></a>00006 <span class="comment">* 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.</span>
<a name="l00007"></a>00007 <span class="comment">* 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.</span>
<a name="l00008"></a>00008 <span class="comment">* 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.</span>
<a name="l00009"></a>00009 <span class="comment">*</span>
<a name="l00010"></a>00010 <span class="comment">* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.</span>
<a name="l00011"></a>00011 <span class="comment">* IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;</span>
<a name="l00012"></a>00012 <span class="comment">* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>
<a name="l00013"></a>00013 <span class="comment">*</span>
<a name="l00014"></a>00014 <span class="comment">*****************************************************************************/</span>
<a name="l00015"></a>00015 <span class="comment">//</span>
<a name="l00016"></a>00016 <span class="comment">// </span>
<a name="l00017"></a>00017 <span class="comment">// File:        Op_Diff_VEFP1NCP1B_Face.cpp</span>
<a name="l00018"></a>00018 <span class="comment">// Directory:   $TRUST_ROOT/src/P1NCP1B/Operateurs</span>
<a name="l00019"></a>00019 <span class="comment">// Version:     /main/26</span>
<a name="l00020"></a>00020 <span class="comment">// </span>
<a name="l00021"></a>00021 <span class="comment">//</span>
<a name="l00022"></a>00022 
<a name="l00023"></a>00023 <span class="preprocessor">#include &lt;<a class="code" href="Op__Diff__VEFP1NCP1B__Face_8h.html">Op_Diff_VEFP1NCP1B_Face.h</a>&gt;</span>
<a name="l00024"></a>00024 <span class="preprocessor">#include &lt;<a class="code" href="Champ__P1NC_8h.html">Champ_P1NC.h</a>&gt;</span>
<a name="l00025"></a>00025 <span class="preprocessor">#include &lt;<a class="code" href="Champ__Don_8h.html">Champ_Don.h</a>&gt;</span>
<a name="l00026"></a>00026 <span class="preprocessor">#include &lt;<a class="code" href="Dirichlet_8h.html">Dirichlet.h</a>&gt;</span>
<a name="l00027"></a>00027 <span class="preprocessor">#include &lt;<a class="code" href="Dirichlet__homogene_8h.html">Dirichlet_homogene.h</a>&gt;</span>
<a name="l00028"></a>00028 <span class="preprocessor">#include &lt;<a class="code" href="Periodique_8h.html">Periodique.h</a>&gt;</span>
<a name="l00029"></a>00029 <span class="preprocessor">#include &lt;<a class="code" href="Neumann__paroi_8h.html">Neumann_paroi.h</a>&gt;</span>
<a name="l00030"></a>00030 <span class="preprocessor">#include &lt;<a class="code" href="Neumann__homogene_8h.html">Neumann_homogene.h</a>&gt;</span>
<a name="l00031"></a>00031 <span class="preprocessor">#include &lt;<a class="code" href="Neumann__sortie__libre_8h.html">Neumann_sortie_libre.h</a>&gt;</span>
<a name="l00032"></a>00032 <span class="preprocessor">#include &lt;<a class="code" href="Echange__externe__impose_8h.html">Echange_externe_impose.h</a>&gt;</span>
<a name="l00033"></a>00033 <span class="preprocessor">#include &lt;<a class="code" href="Symetrie_8h.html">Symetrie.h</a>&gt;</span>
<a name="l00034"></a>00034 <span class="preprocessor">#include &lt;<a class="code" href="Champ__Uniforme_8h.html">Champ_Uniforme.h</a>&gt;</span>
<a name="l00035"></a>00035 <span class="preprocessor">#include &lt;<a class="code" href="Domaine_8h.html">Domaine.h</a>&gt;</span>
<a name="l00036"></a>00036 <span class="preprocessor">#include &lt;<a class="code" href="Ref__Champ__P1NC_8h.html">Ref_Champ_P1NC.h</a>&gt;</span>
<a name="l00037"></a>00037 <span class="preprocessor">#include &lt;<a class="code" href="Debog_8h.html">Debog.h</a>&gt;</span>
<a name="l00038"></a>00038 <span class="preprocessor">#include &lt;<a class="code" href="DoubleLists_8h.html">DoubleLists.h</a>&gt;</span>
<a name="l00039"></a>00039 <span class="preprocessor">#include &lt;<a class="code" href="Champ__front__txyz_8h.html">Champ_front_txyz.h</a>&gt;</span>
<a name="l00040"></a>00040 <span class="preprocessor">#include &lt;<a class="code" href="Champ__Don__lu_8h.html">Champ_Don_lu.h</a>&gt;</span>
<a name="l00041"></a>00041 <span class="preprocessor">#include &lt;<a class="code" href="Champ__Don__Fonc__xyz_8h.html">Champ_Don_Fonc_xyz.h</a>&gt;</span>
<a name="l00042"></a>00042 <span class="preprocessor">#include &lt;<a class="code" href="Champ__Uniforme__Morceaux_8h.html">Champ_Uniforme_Morceaux.h</a>&gt;</span>
<a name="l00043"></a>00043 <span class="preprocessor">#include &lt;<a class="code" href="Schema__Temps__base_8h.html">Schema_Temps_base.h</a>&gt;</span>
<a name="l00044"></a>00044 <span class="preprocessor">#include &lt;<a class="code" href="Porosites__champ_8h.html">Porosites_champ.h</a>&gt;</span>
<a name="l00045"></a>00045 <span class="preprocessor">#include &lt;<a class="code" href="Check__espace__virtuel_8h.html">Check_espace_virtuel.h</a>&gt;</span>
<a name="l00046"></a>00046 <span class="preprocessor">#include &lt;<a class="code" href="Conduction_8h.html">Conduction.h</a>&gt;</span>
<a name="l00047"></a>00047 <span class="preprocessor">#include &lt;fstream&gt;</span>
<a name="l00048"></a>00048 <span class="keyword">using</span> std::ofstream;
<a name="l00049"></a>00049 <span class="keyword">using</span> std::endl;
<a name="l00050"></a>00050 
<a name="l00051"></a><a class="code" href="Op__Diff__VEFP1NCP1B__Face_8cpp.html#aece898edf37830577f945f563115ee3f">00051</a> <a class="code" href="Declare__Inst_8h.html#afcab3f7633508e92f2077d767e19bc60">Implemente_instanciable_sans_constructeur</a>(<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html" title="class Op_Diff_VEF_Face Cette classe represente l&#39;operateur de diffusion La discretisation est VEF Le ...">Op_Diff_VEFP1NCP1B_Face</a>,<span class="stringliteral">&quot;Op_Diff_VEFP1NCP1B_const_P1NC&quot;</span>,<a class="code" href="classOp__Diff__VEF__Face.html" title="class Op_Diff_VEF_Face Cette classe represente l&#39;operateur de diffusion La discretisation est VEF Le ...">Op_Diff_VEF_Face</a>);
<a name="l00052"></a>00052 
<a name="l00053"></a>00053 
<a name="l00054"></a><a class="code" href="Op__Diff__VEFP1NCP1B__Face_8cpp.html#a4e834c1f122c09080eb7a6226c2f1185">00054</a> <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">double</span> <a class="code" href="Op__Diff__VEFP1NCP1B__Face_8cpp.html#a4e834c1f122c09080eb7a6226c2f1185">maximum</a>(<span class="keyword">const</span> <span class="keywordtype">double</span>&amp; x,
<a name="l00055"></a>00055                              <span class="keyword">const</span> <span class="keywordtype">double</span>&amp; y)
<a name="l00056"></a>00056 {
<a name="l00057"></a>00057   <span class="keywordflow">if</span>(x&lt;y)
<a name="l00058"></a>00058     <span class="keywordflow">return</span> y;
<a name="l00059"></a>00059   <span class="keywordflow">return</span> x;
<a name="l00060"></a>00060 }
<a name="l00061"></a>00061 <span class="comment">/*</span>
<a name="l00062"></a>00062 <span class="comment">static inline double maximum(const double&amp; x,</span>
<a name="l00063"></a>00063 <span class="comment">                             const double&amp; y,</span>
<a name="l00064"></a>00064 <span class="comment">                             const double&amp; z)</span>
<a name="l00065"></a>00065 <span class="comment">{</span>
<a name="l00066"></a>00066 <span class="comment">  return maximum(maximum(x,y),z);</span>
<a name="l00067"></a>00067 <span class="comment">}</span>
<a name="l00068"></a>00068 <span class="comment">*/</span>
<a name="l00069"></a><a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#aef4397519e8b079cab62f05a5a491326">00069</a> <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#aef4397519e8b079cab62f05a5a491326">Op_Diff_VEFP1NCP1B_Face::Op_Diff_VEFP1NCP1B_Face</a>()
<a name="l00070"></a>00070 {
<a name="l00071"></a>00071 <span class="comment">// Initialisation des attributs</span>
<a name="l00072"></a>00072   <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a463106e6f719474777b7cc6c5e813354">convexite_</a>=1.e-3;
<a name="l00073"></a>00073   <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#acbd7461fb999d27a3c1ba0320f13563a">alphaE</a>=1;
<a name="l00074"></a>00074   <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a0ff8784f933eedd5f6a52db444f2d71b">alphaS</a>=1;
<a name="l00075"></a>00075   <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a3ca993ddf7251f0c1f79b9c659d5a96f">alphaA</a>=0;
<a name="l00076"></a>00076   <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#aa413a1aa88ba72b238a4bc1067f5a869">test_</a>=0;
<a name="l00077"></a>00077   <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a90fc51e82567cc139118e78417436ef2">coeff_</a>=1.;<span class="comment">//alphaE+alphaS;</span>
<a name="l00078"></a>00078   <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a34224d2dfd0ecb6877ce4dc87abff1f0">decentrage_</a>=1;
<a name="l00079"></a>00079   <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a168b650a02b7a56f11b3205e7ea0e019">is_laplacian_filled_</a>=0;
<a name="l00080"></a>00080 }
<a name="l00081"></a>00081 
<a name="l00082"></a><a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a40338f037cc176acacb1a23eab51e65e">00082</a> <a class="code" href="classSortie.html" title="Classe de base des flux de sortie. Elle sait ecrire des types simples&lt;br&gt;(entiers, flottants) et des Ob...">Sortie</a>&amp; <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a40338f037cc176acacb1a23eab51e65e" title="NE FAIT RIEN A surcharger dans les classes derivees.">Op_Diff_VEFP1NCP1B_Face::printOn</a>(<a class="code" href="classSortie.html" title="Classe de base des flux de sortie. Elle sait ecrire des types simples&lt;br&gt;(entiers, flottants) et des Ob...">Sortie</a>&amp; s )<span class="keyword"> const</span>
<a name="l00083"></a>00083 <span class="keyword"></span>{
<a name="l00084"></a>00084   <span class="keywordflow">return</span> s &lt;&lt; <a class="code" href="classObjet__U.html#aa58e9a81c0ddc2c1149053b8f96698ac" title="renvoie la chaine identifiant la classe.">que_suis_je</a>() ;
<a name="l00085"></a>00085 }
<a name="l00086"></a>00086 <span class="comment"></span>
<a name="l00087"></a>00087 <span class="comment">////!&lt; readOn </span>
<a name="l00088"></a>00088 <span class="comment"></span><span class="comment">//</span>
<a name="l00089"></a>00089 
<a name="l00090"></a><a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a16d0bd30f8c55391616349f7fc3c1f1a">00090</a> <a class="code" href="classEntree.html" title="Classe de definition des operateurs et methodes pour toute lecture dans un flot d&#39;entree (fichier...">Entree</a>&amp; <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a16d0bd30f8c55391616349f7fc3c1f1a" title="NE FAIT RIEN A surcharger dans les classes derivees.">Op_Diff_VEFP1NCP1B_Face::readOn</a>(<a class="code" href="classEntree.html" title="Classe de definition des operateurs et methodes pour toute lecture dans un flot d&#39;entree (fichier...">Entree</a>&amp; s )
<a name="l00091"></a>00091 {
<a name="l00092"></a>00092 <span class="comment">// Les mots a reconnaitre</span>
<a name="l00093"></a>00093   <a class="code" href="classMotcle.html" title="Une chaine de caractere (Nom) en majuscules.">Motcle</a> motlu, accouverte = <span class="stringliteral">&quot;{&quot;</span> , accfermee = <span class="stringliteral">&quot;}&quot;</span> ;
<a name="l00094"></a>00094   <a class="code" href="classMotcles.html" title="Un tableau d&#39;objets de la classe Motcle.">Motcles</a> les_mots(6);
<a name="l00095"></a>00095   {
<a name="l00096"></a>00096     les_mots[0] = <span class="stringliteral">&quot;alphaE&quot;</span>;
<a name="l00097"></a>00097     les_mots[1] = <span class="stringliteral">&quot;alphaS&quot;</span>;
<a name="l00098"></a>00098     les_mots[2] = <span class="stringliteral">&quot;alphaA&quot;</span>;
<a name="l00099"></a>00099     les_mots[3] = <span class="stringliteral">&quot;test&quot;</span>;
<a name="l00100"></a>00100     les_mots[4] = <span class="stringliteral">&quot;decentrage&quot;</span>;
<a name="l00101"></a>00101     les_mots[5] = <span class="stringliteral">&quot;epsilon&quot;</span>;
<a name="l00102"></a>00102   }
<a name="l00103"></a>00103 
<a name="l00104"></a>00104 <span class="comment">// Verification de la syntaxe</span>
<a name="l00105"></a>00105   s &gt;&gt; motlu;
<a name="l00106"></a>00106   <span class="keywordflow">if</span> (motlu!=accouverte)
<a name="l00107"></a>00107     <span class="keywordflow">if</span> (<a class="code" href="classProcess.html#acd052b99706c577f8a5b6656217cf4c2" title="renvoie 1 si on est sur le processeur maitre du groupe courant (c&#39;est a dire me() == 0)...">Process::je_suis_maitre</a>())
<a name="l00108"></a>00108       {
<a name="l00109"></a>00109         <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Erreur Op_Diff_VEFP1NCP1B_Face::readOn()&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
<a name="l00110"></a>00110         <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Depuis la 1.5.5, la syntaxe du mot cle P1NCP1B a change.&quot;</span>
<a name="l00111"></a>00111              &lt;&lt; finl;
<a name="l00112"></a>00112         <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Il faut commencer par une accolade ouvrante {&quot;</span> &lt;&lt; finl;
<a name="l00113"></a>00113         <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;et les options eventuelles sont entre les accolades :&quot;</span>
<a name="l00114"></a>00114              &lt;&lt; finl;
<a name="l00115"></a>00115         <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Diffusion { P1NCP1B } -&gt; Diffusion { P1NCB { } }&quot;</span> &lt;&lt; finl;
<a name="l00116"></a>00116         <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">exit</a>();
<a name="l00117"></a>00117       }
<a name="l00118"></a>00118 
<a name="l00119"></a>00119 
<a name="l00120"></a>00120 <span class="comment">// Lecture des parametres</span>
<a name="l00121"></a>00121   s &gt;&gt; motlu;
<a name="l00122"></a>00122   <span class="keywordflow">while</span>(motlu!=accfermee)
<a name="l00123"></a>00123     {
<a name="l00124"></a>00124       <span class="keywordtype">int</span> rang = les_mots.<a class="code" href="classMotcles.html#afecd68f73e904bc129022a236ff6ab15">search</a>(motlu);
<a name="l00125"></a>00125 
<a name="l00126"></a>00126       <span class="keywordflow">switch</span>(rang)
<a name="l00127"></a>00127         {
<a name="l00128"></a>00128         <span class="keywordflow">case</span> 0 :
<a name="l00129"></a>00129 
<a name="l00130"></a>00130           s &gt;&gt; <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#acbd7461fb999d27a3c1ba0320f13563a">alphaE</a>;
<a name="l00131"></a>00131           <span class="keywordflow">break</span>;
<a name="l00132"></a>00132 
<a name="l00133"></a>00133         <span class="keywordflow">case</span> 1 :
<a name="l00134"></a>00134 
<a name="l00135"></a>00135           s &gt;&gt; <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a0ff8784f933eedd5f6a52db444f2d71b">alphaS</a>;
<a name="l00136"></a>00136           <span class="keywordflow">break</span>;
<a name="l00137"></a>00137 
<a name="l00138"></a>00138         <span class="keywordflow">case</span> 2 :
<a name="l00139"></a>00139 
<a name="l00140"></a>00140           <span class="keywordflow">if</span> (<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>==3)
<a name="l00141"></a>00141             s &gt;&gt; <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a3ca993ddf7251f0c1f79b9c659d5a96f">alphaA</a>;
<a name="l00142"></a>00142           <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="classProcess.html#acd052b99706c577f8a5b6656217cf4c2" title="renvoie 1 si on est sur le processeur maitre du groupe courant (c&#39;est a dire me() == 0)...">Process::je_suis_maitre</a>())
<a name="l00143"></a>00143             {
<a name="l00144"></a>00144               <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Erreur Op_Diff_VEFP1NCP1B_Face::readOn()&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
<a name="l00145"></a>00145               <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;L&#39;option alphaA ne peut etre activee qu&#39;en &quot;</span>
<a name="l00146"></a>00146                    &lt;&lt; <span class="stringliteral">&quot;dimension 3&quot;</span> &lt;&lt; finl;
<a name="l00147"></a>00147               <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Sortie du programme&quot;</span> &lt;&lt; finl;
<a name="l00148"></a>00148               <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">exit</a>();
<a name="l00149"></a>00149             }
<a name="l00150"></a>00150           <span class="keywordflow">break</span>;
<a name="l00151"></a>00151 
<a name="l00152"></a>00152         <span class="keywordflow">case</span> 3 :
<a name="l00153"></a>00153 
<a name="l00154"></a>00154           <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#aa413a1aa88ba72b238a4bc1067f5a869">test_</a>=1;
<a name="l00155"></a>00155           <span class="keywordflow">break</span>;
<a name="l00156"></a>00156 
<a name="l00157"></a>00157         <span class="keywordflow">case</span> 4 :
<a name="l00158"></a>00158 
<a name="l00159"></a>00159           s &gt;&gt; <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a34224d2dfd0ecb6877ce4dc87abff1f0">decentrage_</a>;
<a name="l00160"></a>00160           <span class="keywordflow">break</span>;
<a name="l00161"></a>00161 
<a name="l00162"></a>00162         <span class="keywordflow">case</span> 5 :
<a name="l00163"></a>00163 
<a name="l00164"></a>00164           s &gt;&gt; <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a463106e6f719474777b7cc6c5e813354">convexite_</a>;
<a name="l00165"></a>00165           <span class="keywordflow">break</span>;
<a name="l00166"></a>00166 
<a name="l00167"></a>00167         <span class="keywordflow">default</span> :
<a name="l00168"></a>00168 
<a name="l00169"></a>00169           <span class="keywordflow">if</span> (<a class="code" href="classProcess.html#acd052b99706c577f8a5b6656217cf4c2" title="renvoie 1 si on est sur le processeur maitre du groupe courant (c&#39;est a dire me() == 0)...">Process::je_suis_maitre</a>())
<a name="l00170"></a>00170             {
<a name="l00171"></a>00171               <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Erreur Op_Diff_VEFP1NCP1B_Face::readOn()&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
<a name="l00172"></a>00172               <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Mot clef &quot;</span> &lt;&lt; motlu &lt;&lt; <span class="stringliteral">&quot; non reconnu&quot;</span> &lt;&lt; finl;
<a name="l00173"></a>00173               <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Les mots clef reconnus sont : &quot;</span> &lt;&lt; les_mots &lt;&lt; finl;
<a name="l00174"></a>00174               <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Sortie du programme&quot;</span> &lt;&lt; finl;
<a name="l00175"></a>00175               <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">exit</a>();
<a name="l00176"></a>00176             }
<a name="l00177"></a>00177           <span class="keywordflow">break</span>;
<a name="l00178"></a>00178         }<span class="comment">//fin du switch</span>
<a name="l00179"></a>00179 
<a name="l00180"></a>00180 <span class="comment">// Suite de la lecture</span>
<a name="l00181"></a>00181       s &gt;&gt; motlu;
<a name="l00182"></a>00182     }<span class="comment">//fin du while</span>
<a name="l00183"></a>00183 
<a name="l00184"></a>00184   <span class="keywordflow">if</span> (<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#acbd7461fb999d27a3c1ba0320f13563a">alphaE</a> &amp;&amp; !<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a0ff8784f933eedd5f6a52db444f2d71b">alphaS</a>) <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a463106e6f719474777b7cc6c5e813354">convexite_</a>=1.;
<a name="l00185"></a>00185   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a0ff8784f933eedd5f6a52db444f2d71b">alphaS</a> &amp;&amp; !<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#acbd7461fb999d27a3c1ba0320f13563a">alphaE</a>) <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a463106e6f719474777b7cc6c5e813354">convexite_</a>=0.;
<a name="l00186"></a>00186 
<a name="l00187"></a>00187   <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a90fc51e82567cc139118e78417436ef2">coeff_</a>=1.;<span class="comment">//alphaE+alphaS;</span>
<a name="l00188"></a>00188 
<a name="l00189"></a>00189   <span class="keywordflow">return</span> s;
<a name="l00190"></a>00190 }
<a name="l00191"></a>00191 <span class="comment"></span>
<a name="l00192"></a>00192 <span class="comment">////!&lt; associer </span>
<a name="l00193"></a>00193 <span class="comment"></span><span class="comment">//</span>
<a name="l00194"></a>00194 
<a name="l00195"></a>00195 
<a name="l00196"></a>00196 
<a name="l00197"></a>00197 
<a name="l00198"></a>00198 
<a name="l00199"></a><a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a0c7833289430f6a53298a97b059f7301">00199</a> <span class="keywordtype">void</span> <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a0c7833289430f6a53298a97b059f7301">Op_Diff_VEFP1NCP1B_Face::associer</a>(<span class="keyword">const</span> <a class="code" href="classZone__dis.html" title="classe Zone_dis Classe generique de la hierarchie des zones discretisees. Un objet de type Zone_dis p...">Zone_dis</a>&amp; zone_dis,
<a name="l00200"></a>00200                                        <span class="keyword">const</span> <a class="code" href="classZone__Cl__dis.html" title="classe Zone_Cl_dis Classe generique de la hierarchie des conditions aux limites discretisees. Un objet Zone_Cl_dis peut referencer n&#39;importe quel derivant de Zone_Cl_dis_base. La plupart des methodes appellent les methodes de l&#39;objet Probleme sous-jacent via la methode valeur() declaree grace a la macro Declare_deriv().;">Zone_Cl_dis</a>&amp; zone_cl_dis,
<a name="l00201"></a>00201                                        <span class="keyword">const</span> <a class="code" href="classChamp__Inc.html">Champ_Inc</a>&amp; ch_diffuse)
<a name="l00202"></a>00202 {
<a name="l00203"></a>00203   <span class="keyword">const</span> <a class="code" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a>&amp; zvef = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a>,zone_dis.<a class="code" href="classDeriv__Zone__dis__base.html#a30ff47fc0684fe134e8c74c35b268941">valeur</a>());
<a name="l00204"></a>00204   <span class="keyword">const</span> <a class="code" href="classZone__Cl__VEFP1B.html">Zone_Cl_VEFP1B</a>&amp; zclvef = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classZone__Cl__VEFP1B.html">Zone_Cl_VEFP1B</a>,zone_cl_dis.<a class="code" href="classDeriv__Zone__Cl__dis__base.html#a6b56880f00b604e1f13970ec6d5bc077">valeur</a>());
<a name="l00205"></a>00205 
<a name="l00206"></a>00206 <span class="comment">// On bloque la symetrie dans l operateur de diffusion P1NC sur vitesse (OK pour scalaire)</span>
<a name="l00207"></a>00207   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i&lt;zclvef.nb_cond_lim(); i++)
<a name="l00208"></a>00208     {
<a name="l00209"></a>00209       <a class="code" href="classCond__lim.html" title="classe Cond_lim Classe generique servant a representer n&#39;importe quelle classe derivee de la classe C...">Cond_lim</a> la_cl = zclvef.les_conditions_limites(i);
<a name="l00210"></a>00210       <span class="keywordflow">if</span> ( <a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classSymetrie.html" title="classe Symetrie Sur les faces de symetrie on a les proprietes suivantes: - composante normale de la v...">Symetrie</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>()) &amp;&amp; (ch_diffuse.<a class="code" href="classDeriv__Champ__Inc__base.html#a9e0b743a3e124e7114fa977b36b68225">valeur</a>().<a class="code" href="classField__base.html#a75bf4e0a6258589a83801c0383d049cc" title="Renvoie la nature d&#39;un champ (scalaire, multiscalaire, vectoriel).">nature_du_champ</a>()==<a class="code" href="Field__base_8h.html#a1b86c8f670a9b34da7f628a821fb646ba66d795f4e2fbb5636a3966c73964c5e7">vectoriel</a>) )
<a name="l00211"></a>00211         {
<a name="l00212"></a>00212           <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;\nBoundary conditions of &#39;Symetrie&#39; type with P1NCP1B diffusion operator are only allowed for Conduction equation!&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
<a name="l00213"></a>00213           <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Here you use a P1NCP1B diffusion operator in a &#39;&quot;</span> &lt;&lt; <a class="code" href="classMorEqn.html#a615dd9abff96edcb625fa0424a489864" title="Renvoie la reference sur l&#39;equation pointe par MorEqn::mon_equation. (version const)">equation</a>().<a class="code" href="classObjet__U.html#aa58e9a81c0ddc2c1149053b8f96698ac" title="renvoie la chaine identifiant la classe.">que_suis_je</a>() &lt;&lt; <span class="stringliteral">&quot;&#39; equation where&quot;</span> &lt;&lt; finl;
<a name="l00214"></a>00214           <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;boundary condition number &quot;</span> &lt;&lt; i &lt;&lt; <span class="stringliteral">&quot;, on boundary &#39;&quot;</span> &lt;&lt; la_cl.<a class="code" href="classCond__lim.html#a5b2d24809cee07727006a891d4ce8d22" title="Appel a l&#39;objet sous-jacent Renvoie la frontiere discretisee associee a la condition aux limites...">frontiere_dis</a>().<a class="code" href="classFrontiere__dis__base.html#a5a7eb46dc3af8a7d4225adc1814845d8" title="Renvoie le nom de la frontiere geometrique.">le_nom</a>() &lt;&lt; <span class="stringliteral">&quot;&#39; has been assigned to: &#39;&quot;</span> &lt;&lt; la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>().<a class="code" href="classObjet__U.html#aa58e9a81c0ddc2c1149053b8f96698ac" title="renvoie la chaine identifiant la classe.">que_suis_je</a>() &lt;&lt; <span class="stringliteral">&quot;&#39;.&quot;</span> &lt;&lt; finl;
<a name="l00215"></a>00215           <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">Process::exit</a>();
<a name="l00216"></a>00216         }
<a name="l00217"></a>00217     }
<a name="l00218"></a>00218 
<a name="l00219"></a>00219   <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classChamp__P1NC.html">Champ_P1NC</a>,ch_diffuse.<a class="code" href="classDeriv__Champ__Inc__base.html#a9e0b743a3e124e7114fa977b36b68225">valeur</a>()))
<a name="l00220"></a>00220     {
<a name="l00221"></a>00221       <span class="keyword">const</span> <a class="code" href="classChamp__P1NC.html">Champ_P1NC</a>&amp; inco = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classChamp__P1NC.html">Champ_P1NC</a>,ch_diffuse.<a class="code" href="classDeriv__Champ__Inc__base.html#a9e0b743a3e124e7114fa977b36b68225">valeur</a>());
<a name="l00222"></a>00222       <a class="code" href="classOp__Diff__VEF__base.html#abbeb435814253a33ecaf170b6f03829f">inconnue_</a> = inco;
<a name="l00223"></a>00223     }
<a name="l00224"></a>00224 
<a name="l00225"></a>00225   <a class="code" href="classOp__Diff__VEF__base.html#aadbdb144954bc7c5b56862e1f9f3c7f9">la_zone_vef</a> = zvef;
<a name="l00226"></a>00226   <a class="code" href="classOp__Diff__VEF__base.html#a721f395a27f12a95882437c614e16a7d">la_zcl_vef</a> = zclvef;
<a name="l00227"></a>00227 }
<a name="l00228"></a>00228 
<a name="l00229"></a><a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a67fc124061be17772b3fd1728709213f">00229</a> <span class="keywordtype">void</span> <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a67fc124061be17772b3fd1728709213f" title="Associe l&#39;operateur a la zone_dis, la zone_Cl_dis, et a l&#39;inconnue de son equation.">Op_Diff_VEFP1NCP1B_Face::completer</a>()
<a name="l00230"></a>00230 {
<a name="l00231"></a>00231   <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a67fc124061be17772b3fd1728709213f" title="Associe l&#39;operateur a la zone_dis, la zone_Cl_dis, et a l&#39;inconnue de son equation.">Op_Diff_VEF_Face::completer</a>();
<a name="l00232"></a>00232 
<a name="l00233"></a>00233   <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a0939691aa4e08464a51cb16c33a62d51">initialiser</a>();
<a name="l00234"></a>00234 }
<a name="l00235"></a>00235 
<a name="l00236"></a>00236 <span class="comment">// ATTENTION : NE TIENT PAS COMPTE DE LA POROSITE 09/04/2009</span>
<a name="l00237"></a><a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#aed99737b6470f55a7423b4c6c956db05">00237</a> <span class="keywordtype">double</span> <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#aed99737b6470f55a7423b4c6c956db05" title="Calcul dt_stab.">Op_Diff_VEFP1NCP1B_Face::calculer_dt_stab</a>()<span class="keyword"> const</span>
<a name="l00238"></a>00238 <span class="keyword"></span>{
<a name="l00239"></a>00239   <span class="keyword">const</span> <a class="code" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a>&amp; zone_VEF=<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a8d6cebdde81108b4c492d8af3d6d60ae">zone_VEFPreP1B</a>();
<a name="l00240"></a>00240   <span class="keyword">const</span> <a class="code" href="classZone.html" title="classe Zone Une Zone est un maillage compose d&#39;un ensemble d&#39;elements geometriques de meme type...">Zone</a>&amp; zone=zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>();
<a name="l00241"></a>00241   <span class="keyword">const</span> <a class="code" href="classZone__Cl__VEF.html">Zone_Cl_VEF</a>&amp; zone_Cl_VEF=<a class="code" href="classOp__Diff__VEF__base.html#a721f395a27f12a95882437c614e16a7d">la_zcl_vef</a>.<a class="code" href="classRef__Zone__Cl__VEF.html#a0970d7253def65ad4f0c5ce1830fd243">valeur</a>();
<a name="l00242"></a>00242   <span class="keyword">const</span> <a class="code" href="classConds__lim.html">Conds_lim</a>&amp; les_cl = zone_Cl_VEF.<a class="code" href="classZone__Cl__dis__base.html#af75e0ed7786863e4d333bfb29d67c323" title="Renvoie la i-ieme condition aux limites. (version const)">les_conditions_limites</a>();
<a name="l00243"></a>00243 
<a name="l00244"></a>00244   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_faces=zone_VEF.<a class="code" href="classZone__VF.html#aede27992d9f2eedd52c24d4a80ff7ffb" title="renvoie le nombre global de faces.">nb_faces</a>();
<a name="l00245"></a>00245   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_faces_tot=zone_VEF.<a class="code" href="classZone__VF.html#a50fd21c9535680489015a3c8b88c685a" title="renvoie le nombre total de faces. C&#39;est-a-dire faces reelles + faces virtuelles">nb_faces_tot</a>();
<a name="l00246"></a>00246 
<a name="l00247"></a>00247   <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; volumes_entrelaces=zone_VEF.<a class="code" href="classZone__VF.html#a64f0b549e5aea1656855113e3510f418">volumes_entrelaces</a>();
<a name="l00248"></a>00248   <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; porosite_elem = zone_VEF.<a class="code" href="classZone__VF.html#afd135a1b227731193b1a97b7ed525435">porosite_elem</a>();
<a name="l00249"></a>00249 
<a name="l00250"></a>00250   <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a> coeffOperateur(nb_faces_tot);
<a name="l00251"></a>00251   coeffOperateur=0.;
<a name="l00252"></a>00252 
<a name="l00253"></a>00253   <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a> nu;
<a name="l00254"></a>00254 
<a name="l00255"></a>00255   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_bords=les_cl.<a class="code" href="classvect__impl.html#a78155bfbd6b61f4710b9830641ed1694">size</a>();
<a name="l00256"></a>00256   <span class="keyword">const</span> <span class="keywordtype">int</span> marq = <a class="code" href="classOp__Diff__VEF__base.html#ae7df69707cc2304c930eb103390e99f0">phi_psi_diffuse</a>(<a class="code" href="classMorEqn.html#a615dd9abff96edcb625fa0424a489864" title="Renvoie la reference sur l&#39;equation pointe par MorEqn::mon_equation. (version const)">equation</a>());
<a name="l00257"></a>00257 
<a name="l00258"></a>00258   <span class="keywordtype">int</span> face=0;
<a name="l00259"></a>00259   <span class="keywordtype">int</span> ind_face=0;
<a name="l00260"></a>00260   <span class="keywordtype">int</span> num1=0,num2=0;
<a name="l00261"></a>00261   <span class="keywordtype">int</span> n_bord=0;
<a name="l00262"></a>00262 
<a name="l00263"></a>00263   <span class="keywordtype">double</span> dt_stab=<a class="code" href="Double_8h.html#ae0ee0cebfad5968da0ad6cc7a49e16b6">DMAXFLOAT</a>;
<a name="l00264"></a>00264 
<a name="l00265"></a>00265 <span class="comment">// Calcul de la porosite</span>
<a name="l00266"></a>00266   <a class="code" href="classOp__Diff__VEF__base.html#aaf04f2c605558b7b05aa8c60f84fb9e1">remplir_nu</a>(<a class="code" href="classOp__Diff__VEF__base.html#ab1309af47a0c41f00181e031fbfda002">nu_</a>);
<a name="l00267"></a>00267   <a class="code" href="Porosites__champ_8cpp.html#a2340e7d73d0f9d34926d012fe1b1d884" title="renvoit le tableau res, res=org si flag=0, res= porosite*org sinon attention ne pas modifier res car ...">modif_par_porosite_si_flag</a>(<a class="code" href="classOp__Diff__VEF__base.html#ab1309af47a0c41f00181e031fbfda002">nu_</a>,nu,!marq,porosite_elem);
<a name="l00268"></a>00268 
<a name="l00269"></a>00269 <span class="comment">// Calcul : contribution des parties P0, P1 et Pa au dt_stab</span>
<a name="l00270"></a>00270   <span class="keywordflow">if</span> (<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#acbd7461fb999d27a3c1ba0320f13563a">alphaE</a>) <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a992a4048490448ef27d6ef07e730eda5">calculer_dt_stab_elem</a>(nu,coeffOperateur);
<a name="l00271"></a>00271   <span class="keywordflow">if</span> (<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a0ff8784f933eedd5f6a52db444f2d71b">alphaS</a>)
<a name="l00272"></a>00272     {
<a name="l00273"></a>00273       <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a> nu_p1;
<a name="l00274"></a>00274       zone.<a class="code" href="classZone.html#a379ad2206b5a13a4f4f3df6d44c7546a" title="Renvoie le domaine dont la zone fait partie. (version const)">domaine</a>().<a class="code" href="classDomaine.html#a32c7de9f9e8e78e3d5ea68715b2ceb2b" title="Cree un tableau ayant une &quot;ligne&quot; par sommet du maillage. Voir MD_Vector_tools::creer_tableau_distrib...">creer_tableau_sommets</a>(nu_p1);
<a name="l00275"></a>00275       <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a997bacd7fe35872ff44036e9e9f40996" title="Calcule la diffusivite &quot;nu_p1&quot; aux sommets du maillage en fonction de la diffusivite &quot;nu_elem&quot; au...">remplir_nu_p1</a>(nu,nu_p1);
<a name="l00276"></a>00276       <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a4f0227976726b0e66cbe318901d690d3">calculer_dt_stab_som</a>(nu_p1,coeffOperateur);
<a name="l00277"></a>00277     }
<a name="l00278"></a>00278   <span class="keywordflow">if</span> (<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a3ca993ddf7251f0c1f79b9c659d5a96f">alphaA</a>)
<a name="l00279"></a>00279     {
<a name="l00280"></a>00280       <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a> nu_pA;
<a name="l00281"></a>00281       zone_VEF.<a class="code" href="classZone__VF.html#ae77f9ddf0711c0bcf2162921698d0bea">creer_tableau_aretes</a>(nu_pA);
<a name="l00282"></a>00282       <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a3b64900128cbb94e4b8980e5ac10b49d">remplir_nu_pA</a>(nu,nu_pA);
<a name="l00283"></a>00283       <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#ac2cf135bf96f42a0eca42e7ff3c30d48">calculer_dt_stab_aretes</a>(nu_pA,coeffOperateur);
<a name="l00284"></a>00284     }
<a name="l00285"></a>00285 <span class="comment">// Calcul : modification pour tenir compte de la matrice de masse</span>
<a name="l00286"></a>00286   <span class="keywordflow">for</span> (face=0; face&lt;nb_faces; face++)
<a name="l00287"></a>00287     {
<a name="l00288"></a>00288       coeffOperateur(face)/=volumes_entrelaces(face);
<a name="l00289"></a>00289       assert(coeffOperateur(face)&gt;=0.);
<a name="l00290"></a>00290       coeffOperateur(face)=1./(coeffOperateur(face)+<a class="code" href="Double_8h.html#a0a3fffa6d17ad8f7de4bb337c6266561">DMINFLOAT</a>);
<a name="l00291"></a>00291     }
<a name="l00292"></a>00292 
<a name="l00293"></a>00293 <span class="comment">// Calcul : modification pour les faces de Dirichlet</span>
<a name="l00294"></a>00294   <span class="keywordflow">for</span> (n_bord=0; n_bord&lt;nb_bords; n_bord++)
<a name="l00295"></a>00295     {
<a name="l00296"></a>00296       <span class="keyword">const</span> <a class="code" href="classCond__lim.html" title="classe Cond_lim Classe generique servant a representer n&#39;importe quelle classe derivee de la classe C...">Cond_lim</a>&amp; la_cl = zone_Cl_VEF.<a class="code" href="classZone__Cl__dis__base.html#af75e0ed7786863e4d333bfb29d67c323" title="Renvoie la i-ieme condition aux limites. (version const)">les_conditions_limites</a>(n_bord);
<a name="l00297"></a>00297       <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp; le_bord = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>,la_cl.<a class="code" href="classCond__lim.html#a5b2d24809cee07727006a891d4ce8d22" title="Appel a l&#39;objet sous-jacent Renvoie la frontiere discretisee associee a la condition aux limites...">frontiere_dis</a>());
<a name="l00298"></a>00298 
<a name="l00299"></a>00299       num1=0;
<a name="l00300"></a>00300       num2=le_bord.<a class="code" href="classFront__VF.html#a341e2fcb5117b96e745fd7078ba86bab" title="Nombre de faces reelles du bord.">nb_faces</a>();
<a name="l00301"></a>00301 
<a name="l00302"></a>00302       <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classDirichlet__homogene.html" title="Classe Dirichlet_homogene Cette classe est la classe de base de la hierarchie des conditions aux limi...">Dirichlet_homogene</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>()) ||
<a name="l00303"></a>00303           <a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classDirichlet.html" title="classe Dirichlet Cette classe est la classe de base de la hierarchie des conditions aux limites de ty...">Dirichlet</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>())
<a name="l00304"></a>00304          )
<a name="l00305"></a>00305         <span class="keywordflow">for</span> (ind_face=num1; ind_face&lt;num2; ind_face++)
<a name="l00306"></a>00306           {
<a name="l00307"></a>00307             face=le_bord.<a class="code" href="classFront__VF.html#a3402a19d7e54ed797d2b18e9a47ead1e" title="Renvoie le numero de face de la ieme face du bord.">num_face</a>(ind_face);
<a name="l00308"></a>00308             coeffOperateur(face)=1.e20;
<a name="l00309"></a>00309           }
<a name="l00310"></a>00310     }
<a name="l00311"></a>00311 
<a name="l00312"></a>00312 <span class="comment">// Calcul du pas de temps de stabilite</span>
<a name="l00313"></a>00313 <span class="comment">// : on en a besoin que sur les faces reelles</span>
<a name="l00314"></a>00314   <span class="keywordflow">for</span> (face=0; face&lt;nb_faces; face++)
<a name="l00315"></a>00315     <span class="keywordflow">if</span> (coeffOperateur(face)&lt;dt_stab)
<a name="l00316"></a>00316       dt_stab=coeffOperateur(face);
<a name="l00317"></a>00317 
<a name="l00318"></a>00318   dt_stab=<a class="code" href="classProcess.html#a05de57db7288d95f9e67046af585d5ff" title="Calcule le min de x sur tous les processeurs du groupe courant. Voir aussi mp_max()">Process::mp_min</a>(dt_stab);
<a name="l00319"></a>00319   <span class="keywordflow">return</span> dt_stab;
<a name="l00320"></a>00320 }
<a name="l00321"></a>00321 
<a name="l00322"></a>00322 <span class="keywordtype">void</span> <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a992a4048490448ef27d6ef07e730eda5">Op_Diff_VEFP1NCP1B_Face::</a>
<a name="l00323"></a><a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a992a4048490448ef27d6ef07e730eda5">00323</a> <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a992a4048490448ef27d6ef07e730eda5">calculer_dt_stab_elem</a>(<span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; nu, <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; coeffOperateur)<span class="keyword"> const</span>
<a name="l00324"></a>00324 <span class="keyword"></span>{
<a name="l00325"></a>00325   <span class="keyword">const</span> <a class="code" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a>&amp; zone_VEF=<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a8d6cebdde81108b4c492d8af3d6d60ae">zone_VEFPreP1B</a>();
<a name="l00326"></a>00326   <span class="keyword">const</span> <a class="code" href="classZone.html" title="classe Zone Une Zone est un maillage compose d&#39;un ensemble d&#39;elements geometriques de meme type...">Zone</a>&amp; zone=zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>();
<a name="l00327"></a>00327   <span class="keyword">const</span> <a class="code" href="classZone__Cl__VEF.html">Zone_Cl_VEF</a>&amp; zone_Cl_VEF=<a class="code" href="classOp__Diff__VEF__base.html#a721f395a27f12a95882437c614e16a7d">la_zcl_vef</a>.<a class="code" href="classRef__Zone__Cl__VEF.html#a0970d7253def65ad4f0c5ce1830fd243">valeur</a>();
<a name="l00328"></a>00328   <span class="keyword">const</span> <a class="code" href="classConds__lim.html">Conds_lim</a>&amp; les_cl = zone_Cl_VEF.<a class="code" href="classZone__Cl__dis__base.html#af75e0ed7786863e4d333bfb29d67c323" title="Renvoie la i-ieme condition aux limites. (version const)">les_conditions_limites</a>();
<a name="l00329"></a>00329 
<a name="l00330"></a>00330   <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; face_normales=zone_VEF.<a class="code" href="classZone__VEF.html#a5742d75972e4846bf9fbb6ed5715053e">face_normales</a>();
<a name="l00331"></a>00331   <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; volumes=zone_VEF.<a class="code" href="classZone__VF.html#aea771c835e561469d2d21dbca5fac1cf" title="renvoie le volume de la maille i.">volumes</a>();
<a name="l00332"></a>00332 
<a name="l00333"></a>00333   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; elem_faces=zone_VEF.<a class="code" href="classZone__VF.html#a067e462dcd3ab92b0f6d945b19e4eb37" title="renvoie le numero de le ieme face de la maille num_elem la facon dont ces faces sont numerotees est l...">elem_faces</a>();
<a name="l00334"></a>00334 
<a name="l00335"></a>00335   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_elem_tot=zone.<a class="code" href="classZone.html#aa3a33e8b723618b9092460007153e42d" title="Renvoie le nombre total d&#39;elements de la zone.">nb_elem_tot</a>();
<a name="l00336"></a>00336   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_faces_elem=zone.<a class="code" href="classZone.html#a548fbc7518be2f122b1a5c9589a443c2" title="Renvoie le nombre de face de type i des elements geometriques constituants la zone. Ex: les objets de la classe Prisme ont 2 types de faces: triangle ou quadrangle.">nb_faces_elem</a>();
<a name="l00337"></a>00337   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_bords=les_cl.<a class="code" href="classvect__impl.html#a78155bfbd6b61f4710b9830641ed1694">size</a>();
<a name="l00338"></a>00338 
<a name="l00339"></a>00339   <span class="keywordtype">int</span> elem=0;
<a name="l00340"></a>00340   <span class="keywordtype">int</span> face=0,face_loc=0;
<a name="l00341"></a>00341   <span class="keywordtype">int</span> faceAss=0,faceAss_loc=0;
<a name="l00342"></a>00342   <span class="keywordtype">int</span> dim=0;
<a name="l00343"></a>00343   <span class="keywordtype">int</span> ind_face=0;
<a name="l00344"></a>00344   <span class="keywordtype">int</span> num1=0,num2=0;
<a name="l00345"></a>00345   <span class="keywordtype">int</span> n_bord=0;
<a name="l00346"></a>00346 
<a name="l00347"></a>00347   <span class="keywordtype">double</span> psc=0.;
<a name="l00348"></a>00348   <span class="keywordtype">double</span> volume=0.;
<a name="l00349"></a>00349   <span class="keywordtype">double</span> nu_elem=0.;
<a name="l00350"></a>00350   <span class="keywordtype">double</span> <a class="code" href="Champ__P1iP1B__implementation_8cpp.html#aa8c8f49390c3cf7c702d71a71bc977e3">coeff</a>=0.;
<a name="l00351"></a>00351 
<a name="l00352"></a>00352   <span class="keywordflow">for</span> (elem=0; elem&lt;nb_elem_tot; elem++)
<a name="l00353"></a>00353     {
<a name="l00354"></a>00354       volume=volumes(elem);
<a name="l00355"></a>00355       nu_elem=<a class="code" href="classOp__Diff__VEF__base.html#ab1309af47a0c41f00181e031fbfda002">nu_</a>(elem);
<a name="l00356"></a>00356 
<a name="l00357"></a>00357       <span class="keywordflow">for</span> (face_loc=0; face_loc&lt;nb_faces_elem; face_loc++)
<a name="l00358"></a>00358         {
<a name="l00359"></a>00359           face=elem_faces(elem,face_loc);
<a name="l00360"></a>00360 
<a name="l00361"></a>00361           psc=0.;
<a name="l00362"></a>00362           <span class="keywordflow">for</span> (dim=0; dim&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; dim++)
<a name="l00363"></a>00363             psc+=face_normales(face,dim)*face_normales(face,dim);
<a name="l00364"></a>00364 
<a name="l00365"></a>00365           coeff=nu_elem;
<a name="l00366"></a>00366           coeff/=volume;
<a name="l00367"></a>00367           coeff*=psc;
<a name="l00368"></a>00368           coeff*=<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a463106e6f719474777b7cc6c5e813354">convexite_</a>;
<a name="l00369"></a>00369           coeffOperateur(face)+=<a class="code" href="Champ__P1iP1B__implementation_8cpp.html#aa8c8f49390c3cf7c702d71a71bc977e3">coeff</a>;
<a name="l00370"></a>00370         }
<a name="l00371"></a>00371     }
<a name="l00372"></a>00372 
<a name="l00373"></a>00373   <span class="keywordflow">for</span> (n_bord=0; n_bord&lt;nb_bords; n_bord++)
<a name="l00374"></a>00374     {
<a name="l00375"></a>00375       <span class="keyword">const</span> <a class="code" href="classCond__lim.html" title="classe Cond_lim Classe generique servant a representer n&#39;importe quelle classe derivee de la classe C...">Cond_lim</a>&amp; la_cl = zone_Cl_VEF.<a class="code" href="classZone__Cl__dis__base.html#af75e0ed7786863e4d333bfb29d67c323" title="Renvoie la i-ieme condition aux limites. (version const)">les_conditions_limites</a>(n_bord);
<a name="l00376"></a>00376       <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp; le_bord = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>,la_cl.<a class="code" href="classCond__lim.html#a5b2d24809cee07727006a891d4ce8d22" title="Appel a l&#39;objet sous-jacent Renvoie la frontiere discretisee associee a la condition aux limites...">frontiere_dis</a>());
<a name="l00377"></a>00377 
<a name="l00378"></a>00378       num1=0;
<a name="l00379"></a>00379       num2=le_bord.<a class="code" href="classFront__VF.html#a341e2fcb5117b96e745fd7078ba86bab" title="Nombre de faces reelles du bord.">nb_faces</a>();
<a name="l00380"></a>00380 
<a name="l00381"></a>00381       <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>()))
<a name="l00382"></a>00382         {
<a name="l00383"></a>00383           <span class="keyword">const</span> <a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>&amp; la_cl_perio = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>, la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>());
<a name="l00384"></a>00384 
<a name="l00385"></a>00385           <span class="keywordflow">for</span> (ind_face=num1; ind_face&lt;num2; ind_face++)
<a name="l00386"></a>00386             {
<a name="l00387"></a>00387               face=le_bord.<a class="code" href="classFront__VF.html#a3402a19d7e54ed797d2b18e9a47ead1e" title="Renvoie le numero de face de la ieme face du bord.">num_face</a>(ind_face);
<a name="l00388"></a>00388               faceAss_loc=la_cl_perio.<a class="code" href="classPeriodique.html#a207b86556f199a63ea059b841851ca6a">face_associee</a>(ind_face);
<a name="l00389"></a>00389               faceAss=le_bord.<a class="code" href="classFront__VF.html#a3402a19d7e54ed797d2b18e9a47ead1e" title="Renvoie le numero de face de la ieme face du bord.">num_face</a>(faceAss_loc);
<a name="l00390"></a>00390 
<a name="l00391"></a>00391               <span class="keywordflow">if</span> (face&lt;faceAss)
<a name="l00392"></a>00392                 {
<a name="l00393"></a>00393                   coeffOperateur(faceAss)+=coeffOperateur(face);
<a name="l00394"></a>00394                   coeffOperateur(face)=coeffOperateur(faceAss);
<a name="l00395"></a>00395                 }
<a name="l00396"></a>00396             }
<a name="l00397"></a>00397         }
<a name="l00398"></a>00398     }
<a name="l00399"></a>00399 }
<a name="l00400"></a>00400 
<a name="l00401"></a>00401 <span class="keywordtype">void</span> <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a4f0227976726b0e66cbe318901d690d3">Op_Diff_VEFP1NCP1B_Face::</a>
<a name="l00402"></a><a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a4f0227976726b0e66cbe318901d690d3">00402</a> <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a4f0227976726b0e66cbe318901d690d3">calculer_dt_stab_som</a>(<span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; nu_som, <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; coeffOperateur)<span class="keyword"> const</span>
<a name="l00403"></a>00403 <span class="keyword"></span>{
<a name="l00404"></a>00404   <span class="keyword">const</span> <a class="code" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a>&amp; zone_VEF=<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a8d6cebdde81108b4c492d8af3d6d60ae">zone_VEFPreP1B</a>();
<a name="l00405"></a>00405 
<a name="l00406"></a>00406   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_faces=zone_VEF.<a class="code" href="classZone__VF.html#aede27992d9f2eedd52c24d4a80ff7ffb" title="renvoie le nombre global de faces.">nb_faces</a>();
<a name="l00407"></a>00407 
<a name="l00408"></a>00408   <span class="keywordtype">int</span> face=0;
<a name="l00409"></a>00409   <span class="keywordtype">int</span> face_C=0;
<a name="l00410"></a>00410 
<a name="l00411"></a>00411   <span class="keywordflow">if</span> (<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#af990901466d6341a02f7fd028353e028">laplacien_p1_</a>.<a class="code" href="classMatrice__Morse.html#a1f9bd6aedb226c86b7299689fa5b821a">nb_lignes</a>()&lt;2) <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#af8e127ec31241c8d2aab78ad951aa253" title="on dimensionne notre matrice.">dimensionner</a>(<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#af990901466d6341a02f7fd028353e028">laplacien_p1_</a>);
<a name="l00412"></a>00412   <span class="keywordflow">if</span> (!<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a168b650a02b7a56f11b3205e7ea0e019">is_laplacian_filled_</a>) <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a7d0688de99484ee5807a0846219ebe2d">calculer_laplacien_som</a>(nu_som);
<a name="l00413"></a>00413 
<a name="l00414"></a>00414 <span class="comment">// REMARQUE : on multiplie par -1 car laplacien_p1_=+Delta</span>
<a name="l00415"></a>00415   <span class="keywordflow">for</span> (face=0; face&lt;nb_faces; face++)
<a name="l00416"></a>00416     {
<a name="l00417"></a>00417       face_C=face*<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#aecdf3d22b30add37625e545939004844">dim_ch_</a>;<span class="comment">//pour le cas vectoriel</span>
<a name="l00418"></a>00418       coeffOperateur(face)+=-1.*<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#af990901466d6341a02f7fd028353e028">laplacien_p1_</a>(face_C,face_C);
<a name="l00419"></a>00419     }
<a name="l00420"></a>00420 }
<a name="l00421"></a>00421 
<a name="l00422"></a>00422 <span class="keywordtype">void</span> <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#ac2cf135bf96f42a0eca42e7ff3c30d48">Op_Diff_VEFP1NCP1B_Face::</a>
<a name="l00423"></a><a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#ac2cf135bf96f42a0eca42e7ff3c30d48">00423</a> <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#ac2cf135bf96f42a0eca42e7ff3c30d48">calculer_dt_stab_aretes</a>(<span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; nu, <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; coeffOperateur)<span class="keyword"> const</span>
<a name="l00424"></a>00424 <span class="keyword"></span>{
<a name="l00425"></a>00425   <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a>&lt;&lt;<span class="stringliteral">&quot;Error in Op_Diff_VEFP1NCP1B_Face::calculer_dt_stab_aretes()&quot;</span>&lt;&lt;<a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
<a name="l00426"></a>00426   <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a>&lt;&lt;<span class="stringliteral">&quot;Function not coded&quot;</span>&lt;&lt;finl;
<a name="l00427"></a>00427   <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a>&lt;&lt;<span class="stringliteral">&quot;Exit&quot;</span>&lt;&lt;finl;
<a name="l00428"></a>00428   <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">exit</a>();
<a name="l00429"></a>00429 }
<a name="l00430"></a>00430 
<a name="l00431"></a>00431 
<a name="l00432"></a>00432 <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a054036b7f0ee412cb3a959885d915f2f">Op_Diff_VEFP1NCP1B_Face::</a>
<a name="l00433"></a><a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a054036b7f0ee412cb3a959885d915f2f">00433</a> <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a054036b7f0ee412cb3a959885d915f2f">calculer_gradient_elem</a>(<span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; inconnue)<span class="keyword"> const</span>
<a name="l00434"></a>00434 <span class="keyword"></span>{
<a name="l00435"></a>00435   <span class="keyword">const</span> <a class="code" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a>&amp; zone_VEF = <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a8d6cebdde81108b4c492d8af3d6d60ae">zone_VEFPreP1B</a>();
<a name="l00436"></a>00436 
<a name="l00437"></a>00437   <span class="keyword">const</span> <a class="code" href="classZone.html" title="classe Zone Une Zone est un maillage compose d&#39;un ensemble d&#39;elements geometriques de meme type...">Zone</a>&amp; zone = zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>();
<a name="l00438"></a>00438   <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; face_normales = zone_VEF.<a class="code" href="classZone__VEF.html#a5742d75972e4846bf9fbb6ed5715053e">face_normales</a>();
<a name="l00439"></a>00439   <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; volumes = zone_VEF.<a class="code" href="classZone__VF.html#aea771c835e561469d2d21dbca5fac1cf" title="renvoie le volume de la maille i.">volumes</a>();
<a name="l00440"></a>00440   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; elem_faces=zone_VEF.<a class="code" href="classZone__VF.html#a067e462dcd3ab92b0f6d945b19e4eb37" title="renvoie le numero de le ieme face de la maille num_elem la facon dont ces faces sont numerotees est l...">elem_faces</a>();
<a name="l00441"></a>00441   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; face_voisins=zone_VEF.<a class="code" href="classZone__VF.html#a49d4322f5585a8fa95748ca785b70702" title="renvoie l&#39;element voisin de numface dans la direction i. i=0 : dans le sens oppose de l&#39;axe orthogona...">face_voisins</a>();
<a name="l00442"></a>00442 
<a name="l00443"></a>00443   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_faces_elem=zone.<a class="code" href="classZone.html#a548fbc7518be2f122b1a5c9589a443c2" title="Renvoie le nombre de face de type i des elements geometriques constituants la zone. Ex: les objets de la classe Prisme ont 2 types de faces: triangle ou quadrangle.">nb_faces_elem</a>();
<a name="l00444"></a>00444   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_elem_tot=zone.<a class="code" href="classZone.html#aa3a33e8b723618b9092460007153e42d" title="Renvoie le nombre total d&#39;elements de la zone.">nb_elem_tot</a>();
<a name="l00445"></a>00445   <span class="keywordtype">int</span> elem=0,face_loc=0,face=0,compi=0,compj=0;
<a name="l00446"></a>00446 
<a name="l00447"></a>00447   <span class="keywordtype">double</span> signe=0.;
<a name="l00448"></a>00448   <span class="keywordtype">double</span> volume=0.;
<a name="l00449"></a>00449 
<a name="l00450"></a>00450 <span class="comment">// Valeurs INTEGRALES du gradient_p0_</span>
<a name="l00451"></a>00451   <span class="keywordflow">for</span>(elem=0; elem&lt;nb_elem_tot; elem++)
<a name="l00452"></a>00452     <span class="keywordflow">for</span>(face_loc=0; face_loc&lt;nb_faces_elem; face_loc++)
<a name="l00453"></a>00453       {
<a name="l00454"></a>00454         face=elem_faces(elem,face_loc);
<a name="l00455"></a>00455 
<a name="l00456"></a>00456         signe=1;
<a name="l00457"></a>00457         <span class="keywordflow">if</span>(elem!=face_voisins(face,0)) signe=-1;
<a name="l00458"></a>00458 
<a name="l00459"></a>00459         <span class="keywordflow">for</span>(compi=0; compi&lt;<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#aecdf3d22b30add37625e545939004844">dim_ch_</a>; compi++)
<a name="l00460"></a>00460           <span class="keywordflow">for</span>(compj=0; compj&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; compj++)
<a name="l00461"></a>00461             <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#af276a7ed4462dd7921988559f8289460">gradient_p0_</a>(elem,compi,compj)+=signe*
<a name="l00462"></a>00462                                             inconnue[face*dim_ch_+compi]*
<a name="l00463"></a>00463                                             face_normales(face,compj);
<a name="l00464"></a>00464       }
<a name="l00465"></a>00465 
<a name="l00466"></a>00466 <span class="comment">// Valeurs NODALES du gradient_p0_</span>
<a name="l00467"></a>00467   <span class="keywordflow">for</span> (elem=0; elem&lt;nb_elem_tot; elem++)
<a name="l00468"></a>00468     {
<a name="l00469"></a>00469       volume = volumes(elem);
<a name="l00470"></a>00470 
<a name="l00471"></a>00471       <span class="keywordflow">for</span> (compi=0; compi&lt;<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#aecdf3d22b30add37625e545939004844">dim_ch_</a>; compi++)
<a name="l00472"></a>00472         <span class="keywordflow">for</span> (compj=0; compj&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; compj++)
<a name="l00473"></a>00473           <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#af276a7ed4462dd7921988559f8289460">gradient_p0_</a>(elem,compi,compj)/=(<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a90fc51e82567cc139118e78417436ef2">coeff_</a>*volume);
<a name="l00474"></a>00474     }
<a name="l00475"></a>00475 
<a name="l00476"></a>00476 <span class="comment">// REMARQUE : cet echange_espace_virtuel() est NECESSAIRE</span>
<a name="l00477"></a>00477 <span class="comment">// dans le cas ou alphaS==1 et/ou alphaA=1</span>
<a name="l00478"></a>00478   <span class="keywordflow">if</span> (<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a0ff8784f933eedd5f6a52db444f2d71b">alphaS</a>) <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#af276a7ed4462dd7921988559f8289460">gradient_p0_</a>*=<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a463106e6f719474777b7cc6c5e813354">convexite_</a>;
<a name="l00479"></a>00479   <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#af276a7ed4462dd7921988559f8289460">gradient_p0_</a>.<a class="code" href="classDoubleVect.html#abfebbc2f685ce7bc4b80c720d7da9bf3">echange_espace_virtuel</a>();
<a name="l00480"></a>00480   <a class="code" href="classOp__Diff__VEF__Face.html#aa3a7ae47654aef0e801eb78dc6a980af">Debog::verifier</a>(<span class="stringliteral">&quot;OpDifP1NCP1B Gradient P0 : &quot;</span>,<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#af276a7ed4462dd7921988559f8289460">gradient_p0_</a>);
<a name="l00481"></a>00481 
<a name="l00482"></a>00482   <span class="keywordflow">return</span> <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#af276a7ed4462dd7921988559f8289460">gradient_p0_</a>;
<a name="l00483"></a>00483 }
<a name="l00484"></a>00484 
<a name="l00485"></a>00485 <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a5e85dd4ed5a586f2787a149790ba0714">Op_Diff_VEFP1NCP1B_Face::</a>
<a name="l00486"></a><a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a5e85dd4ed5a586f2787a149790ba0714">00486</a> <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a5e85dd4ed5a586f2787a149790ba0714">calculer_gradient_som</a>(<span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; inconnue)<span class="keyword"> const</span>
<a name="l00487"></a>00487 <span class="keyword"></span>{
<a name="l00488"></a>00488   <span class="keyword">const</span> <a class="code" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a>&amp; zone_VEF = <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a8d6cebdde81108b4c492d8af3d6d60ae">zone_VEFPreP1B</a>();
<a name="l00489"></a>00489   <span class="keyword">const</span> <a class="code" href="classZone__Cl__VEF.html">Zone_Cl_VEF</a>&amp; zone_Cl_VEF = <a class="code" href="classOp__Diff__VEF__base.html#a721f395a27f12a95882437c614e16a7d">la_zcl_vef</a>.<a class="code" href="classRef__Zone__Cl__VEF.html#a0970d7253def65ad4f0c5ce1830fd243">valeur</a>();
<a name="l00490"></a>00490   <span class="keyword">const</span> <a class="code" href="classZone.html" title="classe Zone Une Zone est un maillage compose d&#39;un ensemble d&#39;elements geometriques de meme type...">Zone</a>&amp; zone = zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>();
<a name="l00491"></a>00491   <span class="keyword">const</span> <a class="code" href="classDomaine.html" title="Classe Domaine Un Domaine represente le domaine (spatial) de resolution d&#39;un Probleme. Un Domaine a un Nom, il est constitue d&#39;une ou plusieurs Zone qui peuvent etre eventuellement decoupees en Sous_Zone. Un Domaine porte l&#39;ensemble des sommets utilises par ses Zones. On peut vouloir resoudre des problemes de type different sur plusieurs domaines, geometriquement les domaines sont alors couples par des surfaces qu&#39;on appelle Raccord.">Domaine</a>&amp; dom=zone.<a class="code" href="classZone.html#a379ad2206b5a13a4f4f3df6d44c7546a" title="Renvoie le domaine dont la zone fait partie. (version const)">domaine</a>();
<a name="l00492"></a>00492 
<a name="l00493"></a>00493   <span class="keyword">const</span> <a class="code" href="classConds__lim.html">Conds_lim</a>&amp; les_cl = zone_Cl_VEF.<a class="code" href="classZone__Cl__dis__base.html#af75e0ed7786863e4d333bfb29d67c323" title="Renvoie la i-ieme condition aux limites. (version const)">les_conditions_limites</a>();
<a name="l00494"></a>00494 
<a name="l00495"></a>00495   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_faces_elem=zone.<a class="code" href="classZone.html#a548fbc7518be2f122b1a5c9589a443c2" title="Renvoie le nombre de face de type i des elements geometriques constituants la zone. Ex: les objets de la classe Prisme ont 2 types de faces: triangle ou quadrangle.">nb_faces_elem</a>();
<a name="l00496"></a>00496   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_som_face=zone_VEF.<a class="code" href="classZone__VF.html#a990808f967f351edbb83ff11d60b7445" title="renvoie le nombre de sommets par face. Rque : on a suppose que toutes les faces avait le meme nombre ...">nb_som_face</a>();
<a name="l00497"></a>00497   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_elem_tot=zone_VEF.<a class="code" href="classZone__dis__base.html#a4d6aa445f152aa6dc54d66ea7a071147">nb_elem_tot</a>();
<a name="l00498"></a>00498   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_som=zone_VEF.<a class="code" href="classZone__VEF__PreP1b.html#a7fa6f80d06f2f6d193e9311abc68412c">nb_som</a>();
<a name="l00499"></a>00499   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_som_tot=zone_VEF.<a class="code" href="classZone__dis__base.html#a8f793341b7a41d67561ba563ae0f69a0">nb_som_tot</a>();
<a name="l00500"></a>00500   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_bords =les_cl.<a class="code" href="classvect__impl.html#a78155bfbd6b61f4710b9830641ed1694">size</a>();
<a name="l00501"></a>00501   <span class="keywordtype">int</span> elem=0,face_loc=0,som_loc=0,face=0;
<a name="l00502"></a>00502   <span class="keywordtype">int</span> compi=0,compj=0,som=0,num1=0,num2=0;
<a name="l00503"></a>00503   <span class="keywordtype">int</span> i=0,ind_face=0;
<a name="l00504"></a>00504   <span class="keywordtype">int</span> n_bord=0;
<a name="l00505"></a>00505 
<a name="l00506"></a>00506   <span class="keyword">const</span> <span class="keywordtype">double</span> coeff_som=1./(<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>)/(<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>+1);
<a name="l00507"></a>00507   <span class="keywordtype">double</span> signe=0.;
<a name="l00508"></a>00508 
<a name="l00509"></a>00509   <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; face_normales = zone_VEF.<a class="code" href="classZone__VEF.html#a5742d75972e4846bf9fbb6ed5715053e">face_normales</a>();
<a name="l00510"></a>00510   <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; volume_aux_sommets=zone_VEF.<a class="code" href="classZone__VEF__PreP1b.html#ac8282d378ae480144d75129df4a8c55c">volume_aux_sommets</a>();
<a name="l00511"></a>00511 
<a name="l00512"></a>00512   <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a> secmem(<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a076341d23635d4ad7b0bfc19a03a7722">gradient_p1_</a>);
<a name="l00513"></a>00513   <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a> sigma(<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>);
<a name="l00514"></a>00514 
<a name="l00515"></a>00515   <a class="code" href="classDoubleVect.html">DoubleVect</a> secmemij;
<a name="l00516"></a>00516   <a class="code" href="classDoubleVect.html">DoubleVect</a> gradij;
<a name="l00517"></a>00517   dom.<a class="code" href="classDomaine.html#a32c7de9f9e8e78e3d5ea68715b2ceb2b" title="Cree un tableau ayant une &quot;ligne&quot; par sommet du maillage. Voir MD_Vector_tools::creer_tableau_distrib...">creer_tableau_sommets</a>(secmemij);
<a name="l00518"></a>00518   dom.<a class="code" href="classDomaine.html#a32c7de9f9e8e78e3d5ea68715b2ceb2b" title="Cree un tableau ayant une &quot;ligne&quot; par sommet du maillage. Voir MD_Vector_tools::creer_tableau_distrib...">creer_tableau_sommets</a>(gradij);
<a name="l00519"></a>00519 
<a name="l00520"></a>00520   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; som_elem=zone.<a class="code" href="classZone.html#ac115e8342be89afb882b7b61cc343267" title="Renvoie le tableau des sommets des elements.">les_elems</a>();
<a name="l00521"></a>00521   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; elem_faces=zone_VEF.<a class="code" href="classZone__VF.html#a067e462dcd3ab92b0f6d945b19e4eb37" title="renvoie le numero de le ieme face de la maille num_elem la facon dont ces faces sont numerotees est l...">elem_faces</a>();
<a name="l00522"></a>00522   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; face_voisins=zone_VEF.<a class="code" href="classZone__VF.html#a49d4322f5585a8fa95748ca785b70702" title="renvoie l&#39;element voisin de numface dans la direction i. i=0 : dans le sens oppose de l&#39;axe orthogona...">face_voisins</a>();
<a name="l00523"></a>00523   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; face_sommets=zone_VEF.<a class="code" href="classZone__VF.html#a298e73b18e17da55f421b1fb0879bd46" title="renvoie le numero du ieme sommet de la face num_face.">face_sommets</a>();
<a name="l00524"></a>00524 
<a name="l00525"></a>00525 <span class="comment">// Le second membre du systeme a inverser</span>
<a name="l00526"></a>00526   secmem=0.;
<a name="l00527"></a>00527   <span class="keywordflow">for</span>(elem=0; elem&lt;nb_elem_tot; elem++)
<a name="l00528"></a>00528     {
<a name="l00529"></a>00529       sigma = 0;
<a name="l00530"></a>00530       <span class="keywordflow">for</span>(face_loc=0; face_loc&lt;nb_faces_elem; face_loc++)
<a name="l00531"></a>00531         {
<a name="l00532"></a>00532           face = elem_faces(elem,face_loc);
<a name="l00533"></a>00533 
<a name="l00534"></a>00534           <span class="keywordflow">for</span>(compi=0; compi&lt;<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#aecdf3d22b30add37625e545939004844">dim_ch_</a>; compi++)
<a name="l00535"></a>00535             sigma[compi]+=inconnue[face*dim_ch_+compi];
<a name="l00536"></a>00536         }
<a name="l00537"></a>00537 
<a name="l00538"></a>00538       <span class="keywordflow">for</span>(face_loc=0; face_loc&lt;nb_faces_elem; face_loc++)
<a name="l00539"></a>00539         {
<a name="l00540"></a>00540           som = dom.<a class="code" href="classDomaine.html#a37cc657f1907d53b0d5a573da862af80">get_renum_som_perio</a>(som_elem(elem,face_loc));
<a name="l00541"></a>00541           face = elem_faces(elem,face_loc);
<a name="l00542"></a>00542 
<a name="l00543"></a>00543           signe=1;
<a name="l00544"></a>00544           <span class="keywordflow">if</span>(elem!=face_voisins(face,0)) signe=-1;
<a name="l00545"></a>00545 
<a name="l00546"></a>00546           <span class="keywordflow">for</span>(compi=0; compi&lt;<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#aecdf3d22b30add37625e545939004844">dim_ch_</a>; compi++)
<a name="l00547"></a>00547             <span class="keywordflow">for</span>(compj=0; compj&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; compj++)
<a name="l00548"></a>00548               secmem(som,compi,compj)+=coeff_som*signe*
<a name="l00549"></a>00549                                        sigma[compi]*face_normales(face,compj);
<a name="l00550"></a>00550         }
<a name="l00551"></a>00551     }
<a name="l00552"></a>00552 
<a name="l00553"></a>00553   secmem.<a class="code" href="classDoubleVect.html#abfebbc2f685ce7bc4b80c720d7da9bf3">echange_espace_virtuel</a>();
<a name="l00554"></a>00554   <a class="code" href="classOp__Diff__VEF__Face.html#aa3a7ae47654aef0e801eb78dc6a980af">Debog::verifier</a>(<span class="stringliteral">&quot;OpDifP1NCP1B secmem, avant CL : &quot;</span>, secmem);
<a name="l00555"></a>00555 
<a name="l00556"></a>00556 <span class="comment">// Les conditions aux limites pour le second membre</span>
<a name="l00557"></a>00557   <span class="keywordflow">for</span> (n_bord=0; n_bord&lt;nb_bords; n_bord++)
<a name="l00558"></a>00558     {
<a name="l00559"></a>00559       <span class="keyword">const</span> <a class="code" href="classCond__lim.html" title="classe Cond_lim Classe generique servant a representer n&#39;importe quelle classe derivee de la classe C...">Cond_lim</a>&amp; la_cl = zone_Cl_VEF.<a class="code" href="classZone__Cl__dis__base.html#af75e0ed7786863e4d333bfb29d67c323" title="Renvoie la i-ieme condition aux limites. (version const)">les_conditions_limites</a>(n_bord);
<a name="l00560"></a>00560       <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp; le_bord = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>,la_cl.<a class="code" href="classCond__lim.html#a5b2d24809cee07727006a891d4ce8d22" title="Appel a l&#39;objet sous-jacent Renvoie la frontiere discretisee associee a la condition aux limites...">frontiere_dis</a>());
<a name="l00561"></a>00561 
<a name="l00562"></a>00562       num1=0;
<a name="l00563"></a>00563       num2=le_bord.<a class="code" href="classFront__VF.html#aed4006d91bf2ef3af2b9f7933d863a09" title="Nombre de faces reelles et virtuelles du bord.">nb_faces_tot</a>();
<a name="l00564"></a>00564 
<a name="l00565"></a>00565       <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classDirichlet__homogene.html" title="Classe Dirichlet_homogene Cette classe est la classe de base de la hierarchie des conditions aux limi...">Dirichlet_homogene</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>()))
<a name="l00566"></a>00566         {
<a name="l00567"></a>00567 <span class="comment">// On ne fait rien et c&#39;est normal</span>
<a name="l00568"></a>00568         }
<a name="l00569"></a>00569       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classDirichlet.html" title="classe Dirichlet Cette classe est la classe de base de la hierarchie des conditions aux limites de ty...">Dirichlet</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>()))
<a name="l00570"></a>00570         {
<a name="l00571"></a>00571           <span class="keyword">const</span> <a class="code" href="classDirichlet.html" title="classe Dirichlet Cette classe est la classe de base de la hierarchie des conditions aux limites de ty...">Dirichlet</a>&amp; dirichlet =
<a name="l00572"></a>00572             <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classDirichlet.html" title="classe Dirichlet Cette classe est la classe de base de la hierarchie des conditions aux limites de ty...">Dirichlet</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>());
<a name="l00573"></a>00573 
<a name="l00574"></a>00574           <span class="keywordtype">double</span> x=0.,y=0.,z=0.;
<a name="l00575"></a>00575           <span class="keywordtype">double</span> inconnue_pt=0.;
<a name="l00576"></a>00576           <span class="keywordtype">double</span> temps = <a class="code" href="classMorEqn.html#a615dd9abff96edcb625fa0424a489864" title="Renvoie la reference sur l&#39;equation pointe par MorEqn::mon_equation. (version const)">equation</a>().<a class="code" href="classEquation__base.html#abc11e51aa75b4c7aa55c27f71eb2f2c4" title="Renvoie le schema en temps associe a l&#39;equation.">schema_temps</a>().<a class="code" href="classSchema__Temps__base.html#a5054df01edb6d4f7baec7e612d423834" title="Renvoie le temps courant.">temps_courant</a>();
<a name="l00577"></a>00577 
<a name="l00578"></a>00578           <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; coord_sommets = dom.<a class="code" href="classDomaine.html#aecd32c3eecc15cce7d1a0e468dadbf96" title="Renvoie le tableau des coordonnees des noeuds (sommets). (acces en lecture)">coord_sommets</a>();
<a name="l00579"></a>00579 
<a name="l00580"></a>00580           <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classChamp__front__txyz.html" title="classe Champ_front_txyz Classe derivee de Champ_front_var qui represente les champs aux frontieres an...">Champ_front_txyz</a>,dirichlet.<a class="code" href="classCond__lim__base.html#a8cddc02f544ee44bebd5bae0e6a9581c">champ_front</a>().<a class="code" href="classDeriv__Champ__front__base.html#a5405a20c106b868a23805a45c4436a53">valeur</a>()))
<a name="l00581"></a>00581             {
<a name="l00582"></a>00582               <span class="keyword">const</span> <a class="code" href="classChamp__front__txyz.html" title="classe Champ_front_txyz Classe derivee de Champ_front_var qui represente les champs aux frontieres an...">Champ_front_txyz</a>&amp; champ_front =
<a name="l00583"></a>00583                 <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classChamp__front__txyz.html" title="classe Champ_front_txyz Classe derivee de Champ_front_var qui represente les champs aux frontieres an...">Champ_front_txyz</a>,dirichlet.<a class="code" href="classCond__lim__base.html#a8cddc02f544ee44bebd5bae0e6a9581c">champ_front</a>().<a class="code" href="classDeriv__Champ__front__base.html#a5405a20c106b868a23805a45c4436a53">valeur</a>());
<a name="l00584"></a>00584 
<a name="l00585"></a>00585               <span class="keywordflow">for</span> (ind_face=num1; ind_face&lt;num2; ind_face++)
<a name="l00586"></a>00586                 {
<a name="l00587"></a>00587                   face=le_bord.<a class="code" href="classFront__VF.html#a3402a19d7e54ed797d2b18e9a47ead1e" title="Renvoie le numero de face de la ieme face du bord.">num_face</a>(ind_face);
<a name="l00588"></a>00588 
<a name="l00589"></a>00589                   <span class="keywordflow">for</span>(som_loc=0; som_loc&lt;nb_som_face; som_loc++)
<a name="l00590"></a>00590                     {
<a name="l00591"></a>00591                       som=dom.<a class="code" href="classDomaine.html#a37cc657f1907d53b0d5a573da862af80">get_renum_som_perio</a>(face_sommets(face,som_loc));
<a name="l00592"></a>00592 
<a name="l00593"></a>00593 <span class="comment">// Formule d&#39;integration numerique exacte pour les polynomes de degre 2</span>
<a name="l00594"></a>00594                       <span class="keywordflow">if</span> (<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>==2) <span class="comment">//formule de Simpson</span>
<a name="l00595"></a>00595                         {
<a name="l00596"></a>00596 <span class="comment">// Coordonnees du sommet &quot;som&quot;</span>
<a name="l00597"></a>00597                           x=coord_sommets(som,0);
<a name="l00598"></a>00598                           y=coord_sommets(som,1);
<a name="l00599"></a>00599 
<a name="l00600"></a>00600 <span class="comment">// Valeur de l&#39;inconnue au point d&#39;integration</span>
<a name="l00601"></a>00601                           <span class="keywordflow">for</span> (compi=0; compi&lt;<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#aecdf3d22b30add37625e545939004844">dim_ch_</a>; compi++)
<a name="l00602"></a>00602                             {
<a name="l00603"></a>00603                               inconnue_pt=
<a name="l00604"></a>00604                                 champ_front.<a class="code" href="classChamp__front__txyz.html#a99389bead147fbe4cd5d9839a8e7caea">valeur_au_temps_et_au_point</a>(temps,som,x,y,z,compi);
<a name="l00605"></a>00605 
<a name="l00606"></a>00606                               <span class="keywordflow">for</span> (compj=0; compj&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; compj++)
<a name="l00607"></a>00607                                 secmem(som,compi,compj) +=
<a name="l00608"></a>00608                                   1./6*(2*inconnue[face*dim_ch_+compi]+inconnue_pt)
<a name="l00609"></a>00609                                   *face_normales(face,compj) ;
<a name="l00610"></a>00610                             }
<a name="l00611"></a>00611                         }<span class="comment">//fin du if sur dimension==2</span>
<a name="l00612"></a>00612 
<a name="l00613"></a>00613                       <span class="keywordflow">else</span> <span class="comment">//formule exacte pour les polynomes de degre 2</span>
<a name="l00614"></a>00614                         {
<a name="l00615"></a>00615 <span class="comment">// On suppose que l&#39;element considere est un TETRAEDRE</span>
<a name="l00616"></a>00616                           <span class="keywordflow">for</span> (i=1; i&lt;3; i++)
<a name="l00617"></a>00617                             {
<a name="l00618"></a>00618                               <span class="keywordtype">int</span> som2=face_sommets(face,(som_loc+i)%nb_som_face);
<a name="l00619"></a>00619                               som2=dom.<a class="code" href="classDomaine.html#a37cc657f1907d53b0d5a573da862af80">get_renum_som_perio</a>(som2);
<a name="l00620"></a>00620 
<a name="l00621"></a>00621 <span class="comment">// Coordonnees des points d&#39;integration</span>
<a name="l00622"></a>00622                               x=(coord_sommets(som,0)+coord_sommets(som2,0))/2.;
<a name="l00623"></a>00623                               y=(coord_sommets(som,1)+coord_sommets(som2,1))/2.;
<a name="l00624"></a>00624                               z=(coord_sommets(som,2)+coord_sommets(som2,2))/2.;
<a name="l00625"></a>00625 
<a name="l00626"></a>00626 <span class="comment">// Vitesse au point d&#39;integration</span>
<a name="l00627"></a>00627                               <span class="keywordflow">for</span> (compi=0; compi&lt;<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#aecdf3d22b30add37625e545939004844">dim_ch_</a>; compi++)
<a name="l00628"></a>00628                                 {
<a name="l00629"></a>00629                                   inconnue_pt=
<a name="l00630"></a>00630                                     champ_front.<a class="code" href="classChamp__front__txyz.html#a99389bead147fbe4cd5d9839a8e7caea">valeur_au_temps_et_au_point</a>(temps,som,x,y,z,compi);
<a name="l00631"></a>00631 
<a name="l00632"></a>00632                                   <span class="keywordflow">for</span> (compj=0; compj&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; compj++)
<a name="l00633"></a>00633                                     secmem(som, compi, compj) += 1./dimension*
<a name="l00634"></a>00634                                                                  1/2.*inconnue_pt*face_normales(face,compj) ;
<a name="l00635"></a>00635                                 }
<a name="l00636"></a>00636                             }
<a name="l00637"></a>00637                         }<span class="comment">//fin du else sur la dimension</span>
<a name="l00638"></a>00638 
<a name="l00639"></a>00639                     }<span class="comment">//fin du for sur &quot;som_loc&quot;</span>
<a name="l00640"></a>00640 
<a name="l00641"></a>00641                 }<span class="comment">//fin du for sur &quot;ind_face&quot;</span>
<a name="l00642"></a>00642 
<a name="l00643"></a>00643             }<span class="comment">//fin du if sur &quot;Champ_front_txyz&quot;</span>
<a name="l00644"></a>00644           <span class="keywordflow">else</span>
<a name="l00645"></a>00645             {
<a name="l00646"></a>00646               <span class="keywordflow">for</span> (ind_face=num1; ind_face&lt;num2; ind_face++)
<a name="l00647"></a>00647                 {
<a name="l00648"></a>00648                   face = le_bord.<a class="code" href="classFront__VF.html#a3402a19d7e54ed797d2b18e9a47ead1e" title="Renvoie le numero de face de la ieme face du bord.">num_face</a>(ind_face);
<a name="l00649"></a>00649 
<a name="l00650"></a>00650                   <span class="keywordflow">for</span>(som_loc=0; som_loc&lt;nb_som_face; som_loc++)
<a name="l00651"></a>00651                     {
<a name="l00652"></a>00652                       som=dom.<a class="code" href="classDomaine.html#a37cc657f1907d53b0d5a573da862af80">get_renum_som_perio</a>(face_sommets(face,som_loc));
<a name="l00653"></a>00653 
<a name="l00654"></a>00654                       <span class="keywordflow">for</span> (compi=0; compi&lt;<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#aecdf3d22b30add37625e545939004844">dim_ch_</a>; compi++)
<a name="l00655"></a>00655                         <span class="keywordflow">for</span> (compj=0; compj&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; compj++)
<a name="l00656"></a>00656                           secmem(som,compi,compj) += 1./dimension*
<a name="l00657"></a>00657                                                      inconnue[face*dim_ch_+compi]*face_normales(face,compj) ;
<a name="l00658"></a>00658 
<a name="l00659"></a>00659                     }<span class="comment">//fin du for sur &quot;som_loc&quot;</span>
<a name="l00660"></a>00660 
<a name="l00661"></a>00661                 }<span class="comment">//fin du for sur &quot;ind_face&quot;</span>
<a name="l00662"></a>00662             }
<a name="l00663"></a>00663 
<a name="l00664"></a>00664         }<span class="comment">//fin du if sur &quot;Dirichlet&quot;</span>
<a name="l00665"></a>00665 
<a name="l00666"></a>00666       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>()))
<a name="l00667"></a>00667         {
<a name="l00668"></a>00668           <span class="keywordflow">for</span> (ind_face=num1; ind_face&lt;num2; ind_face++)
<a name="l00669"></a>00669             {
<a name="l00670"></a>00670               face = le_bord.<a class="code" href="classFront__VF.html#a3402a19d7e54ed797d2b18e9a47ead1e" title="Renvoie le numero de face de la ieme face du bord.">num_face</a>(ind_face);
<a name="l00671"></a>00671 
<a name="l00672"></a>00672               <span class="keywordflow">for</span>(som_loc=0; som_loc&lt;nb_som_face; som_loc++)
<a name="l00673"></a>00673                 {
<a name="l00674"></a>00674                   som=dom.<a class="code" href="classDomaine.html#a37cc657f1907d53b0d5a573da862af80">get_renum_som_perio</a>(face_sommets(face,som_loc));
<a name="l00675"></a>00675 
<a name="l00676"></a>00676                   <span class="keywordflow">for</span> (compi=0; compi&lt;<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#aecdf3d22b30add37625e545939004844">dim_ch_</a>; compi++)
<a name="l00677"></a>00677                     <span class="keywordflow">for</span> (compj=0; compj&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; compj++)
<a name="l00678"></a>00678                       secmem(som,compi,compj) += 1./dimension*
<a name="l00679"></a>00679                                                  inconnue[face*dim_ch_+compi]*face_normales(face,compj) ;
<a name="l00680"></a>00680 
<a name="l00681"></a>00681                 }<span class="comment">//fin du for sur &quot;som_loc&quot;</span>
<a name="l00682"></a>00682 
<a name="l00683"></a>00683             }<span class="comment">//fin du for sur &quot;ind_face&quot;</span>
<a name="l00684"></a>00684 
<a name="l00685"></a>00685         }<span class="comment">//fin du if sur &quot;!Periodique&quot;</span>
<a name="l00686"></a>00686 
<a name="l00687"></a>00687     }<span class="comment">//fin du for sur &quot;n_bord&quot;</span>
<a name="l00688"></a>00688 
<a name="l00689"></a>00689   secmem.<a class="code" href="classDoubleVect.html#abfebbc2f685ce7bc4b80c720d7da9bf3">echange_espace_virtuel</a>();
<a name="l00690"></a>00690   <a class="code" href="classOp__Diff__VEF__Face.html#aa3a7ae47654aef0e801eb78dc6a980af">Debog::verifier</a>(<span class="stringliteral">&quot;OpDifP1NCP1B secmem, apres CL : &quot;</span>, secmem);
<a name="l00691"></a>00691 
<a name="l00692"></a>00692 <span class="comment">// Calcul de la solution du systeme a inverser</span>
<a name="l00693"></a>00693   <span class="keywordflow">for</span> (compi=0; compi&lt;<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#aecdf3d22b30add37625e545939004844">dim_ch_</a>; compi++)
<a name="l00694"></a>00694     <span class="keywordflow">for</span> (compj=0; compj&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; compj++)
<a name="l00695"></a>00695       {
<a name="l00696"></a>00696         <span class="keywordflow">for</span>(i=0; i&lt;nb_som_tot; i++)
<a name="l00697"></a>00697           {
<a name="l00698"></a>00698             som=dom.<a class="code" href="classDomaine.html#a37cc657f1907d53b0d5a573da862af80">get_renum_som_perio</a>(i);
<a name="l00699"></a>00699             secmemij(som)=secmem(som,compi,compj);
<a name="l00700"></a>00700           }
<a name="l00701"></a>00701 
<a name="l00702"></a>00702 <span class="comment">// Resolution du systeme</span>
<a name="l00703"></a>00703         <span class="keywordflow">for</span>(i=0; i&lt;nb_som; i++)
<a name="l00704"></a>00704           {
<a name="l00705"></a>00705             som=dom.<a class="code" href="classDomaine.html#a37cc657f1907d53b0d5a573da862af80">get_renum_som_perio</a>(i);
<a name="l00706"></a>00706             gradij(som)=secmemij(som)/(<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a90fc51e82567cc139118e78417436ef2">coeff_</a>*volume_aux_sommets(som));
<a name="l00707"></a>00707           }
<a name="l00708"></a>00708 
<a name="l00709"></a>00709         <span class="keywordflow">for</span>(i=0; i&lt;nb_som_tot; i++)
<a name="l00710"></a>00710           {
<a name="l00711"></a>00711             som=dom.<a class="code" href="classDomaine.html#a37cc657f1907d53b0d5a573da862af80">get_renum_som_perio</a>(i);
<a name="l00712"></a>00712             <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a076341d23635d4ad7b0bfc19a03a7722">gradient_p1_</a>(som,compi,compj)
<a name="l00713"></a>00713               =gradij(som);
<a name="l00714"></a>00714           }
<a name="l00715"></a>00715       }
<a name="l00716"></a>00716 
<a name="l00717"></a>00717   <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a076341d23635d4ad7b0bfc19a03a7722">gradient_p1_</a>.<a class="code" href="classDoubleVect.html#abfebbc2f685ce7bc4b80c720d7da9bf3">echange_espace_virtuel</a>();
<a name="l00718"></a>00718   <a class="code" href="classOp__Diff__VEF__Face.html#aa3a7ae47654aef0e801eb78dc6a980af">Debog::verifier</a>(<span class="stringliteral">&quot;OpDifP1NCP1B Gradient P1 : &quot;</span>,<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a076341d23635d4ad7b0bfc19a03a7722">gradient_p1_</a>);
<a name="l00719"></a>00719 
<a name="l00720"></a>00720   <span class="keywordflow">return</span> <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a076341d23635d4ad7b0bfc19a03a7722">gradient_p1_</a>;
<a name="l00721"></a>00721 }
<a name="l00722"></a>00722 
<a name="l00723"></a>00723 <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#afb9be14ba93fdea98e9f53d952752034">Op_Diff_VEFP1NCP1B_Face::</a>
<a name="l00724"></a><a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#afb9be14ba93fdea98e9f53d952752034">00724</a> <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#afb9be14ba93fdea98e9f53d952752034">calculer_gradient_aretes</a>(<span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; inconnue)<span class="keyword"> const</span>
<a name="l00725"></a>00725 <span class="keyword"></span>{
<a name="l00726"></a>00726   <span class="keywordflow">return</span> <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#ad5225e89df933786053e400ee9b04db0">gradient_pa_</a>;
<a name="l00727"></a>00727 }
<a name="l00728"></a>00728 
<a name="l00729"></a>00729 
<a name="l00730"></a>00730 <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a325ae974e29dd047801de2efaeea1174">Op_Diff_VEFP1NCP1B_Face::</a>
<a name="l00731"></a><a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a325ae974e29dd047801de2efaeea1174">00731</a> <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a325ae974e29dd047801de2efaeea1174">corriger_div_pour_Cl</a>(<span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; inconnue,<span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; nu,
<a name="l00732"></a>00732                      <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; div)<span class="keyword"> const</span>
<a name="l00733"></a>00733 <span class="keyword"></span>{
<a name="l00734"></a>00734   <span class="keyword">const</span> <a class="code" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a>&amp; zone_VEF = <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a8d6cebdde81108b4c492d8af3d6d60ae">zone_VEFPreP1B</a>();
<a name="l00735"></a>00735   <span class="keyword">const</span> <a class="code" href="classZone__Cl__VEF.html">Zone_Cl_VEF</a>&amp; zone_Cl_VEF=<a class="code" href="classOp__Diff__VEF__base.html#a721f395a27f12a95882437c614e16a7d">la_zcl_vef</a>.<a class="code" href="classRef__Zone__Cl__VEF.html#a0970d7253def65ad4f0c5ce1830fd243">valeur</a>();
<a name="l00736"></a>00736   <span class="keyword">const</span> <a class="code" href="classConds__lim.html">Conds_lim</a>&amp; les_cl = zone_Cl_VEF.<a class="code" href="classZone__Cl__dis__base.html#af75e0ed7786863e4d333bfb29d67c323" title="Renvoie la i-ieme condition aux limites. (version const)">les_conditions_limites</a>();
<a name="l00737"></a>00737 <span class="preprocessor">#ifndef NDEBUG</span>
<a name="l00738"></a>00738 <span class="preprocessor"></span>  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; face_voisins=zone_VEF.<a class="code" href="classZone__VF.html#a49d4322f5585a8fa95748ca785b70702" title="renvoie l&#39;element voisin de numface dans la direction i. i=0 : dans le sens oppose de l&#39;axe orthogona...">face_voisins</a>();
<a name="l00739"></a>00739 <span class="preprocessor">#endif</span>
<a name="l00740"></a>00740 <span class="preprocessor"></span>  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_bords =les_cl.<a class="code" href="classvect__impl.html#a78155bfbd6b61f4710b9830641ed1694">size</a>();
<a name="l00741"></a>00741   <span class="keywordtype">int</span> n_bord=0, num1=0, num2=0;
<a name="l00742"></a>00742   <span class="keywordtype">int</span> face=0, face_asso_loc=0, <a class="code" href="AssembleurPP1BUtil_8cpp.html#a3e374d53ebc7860e1c2f0b7906f2936d">face_associee</a>=0;
<a name="l00743"></a>00743   <span class="keywordtype">int</span> ind_face=0, comp=0;
<a name="l00744"></a>00744 
<a name="l00745"></a>00745   <span class="keywordtype">double</span> flux=0.;
<a name="l00746"></a>00746 
<a name="l00747"></a>00747   <span class="keywordflow">for</span> (n_bord=0; n_bord&lt;nb_bords; n_bord++)
<a name="l00748"></a>00748     {
<a name="l00749"></a>00749       <span class="keyword">const</span> <a class="code" href="classCond__lim.html" title="classe Cond_lim Classe generique servant a representer n&#39;importe quelle classe derivee de la classe C...">Cond_lim</a>&amp; la_cl = zone_Cl_VEF.<a class="code" href="classZone__Cl__dis__base.html#af75e0ed7786863e4d333bfb29d67c323" title="Renvoie la i-ieme condition aux limites. (version const)">les_conditions_limites</a>(n_bord);
<a name="l00750"></a>00750       <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp; le_bord = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>,la_cl.<a class="code" href="classCond__lim.html#a5b2d24809cee07727006a891d4ce8d22" title="Appel a l&#39;objet sous-jacent Renvoie la frontiere discretisee associee a la condition aux limites...">frontiere_dis</a>());
<a name="l00751"></a>00751 
<a name="l00752"></a>00752 <span class="comment">// Reinitialisation de num1 et num2</span>
<a name="l00753"></a>00753       num1 = 0;
<a name="l00754"></a>00754       num2 = le_bord.<a class="code" href="classFront__VF.html#a341e2fcb5117b96e745fd7078ba86bab" title="Nombre de faces reelles du bord.">nb_faces</a>();
<a name="l00755"></a>00755 
<a name="l00756"></a>00756       <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>()))
<a name="l00757"></a>00757         {
<a name="l00758"></a>00758 <span class="comment">// periodicite</span>
<a name="l00759"></a>00759           <span class="keyword">const</span> <a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>&amp; la_cl_perio = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>, la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>());
<a name="l00760"></a>00760 
<a name="l00761"></a>00761           <span class="keywordflow">for</span> (ind_face=num1; ind_face&lt;num2; ind_face++)
<a name="l00762"></a>00762             {
<a name="l00763"></a>00763               face = le_bord.<a class="code" href="classFront__VF.html#a3402a19d7e54ed797d2b18e9a47ead1e" title="Renvoie le numero de face de la ieme face du bord.">num_face</a>(ind_face);
<a name="l00764"></a>00764               face_asso_loc=la_cl_perio.<a class="code" href="classPeriodique.html#a207b86556f199a63ea059b841851ca6a">face_associee</a>(ind_face);
<a name="l00765"></a>00765               <a class="code" href="AssembleurPP1BUtil_8cpp.html#a3e374d53ebc7860e1c2f0b7906f2936d">face_associee</a>=le_bord.<a class="code" href="classFront__VF.html#a3402a19d7e54ed797d2b18e9a47ead1e" title="Renvoie le numero de face de la ieme face du bord.">num_face</a>(face_asso_loc);
<a name="l00766"></a>00766 
<a name="l00767"></a>00767               <span class="keywordflow">if</span> (face&lt;<a class="code" href="AssembleurPP1BUtil_8cpp.html#a3e374d53ebc7860e1c2f0b7906f2936d">face_associee</a>)
<a name="l00768"></a>00768                 <span class="keywordflow">for</span> (comp=0; comp&lt;<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#aecdf3d22b30add37625e545939004844">dim_ch_</a>; comp++)
<a name="l00769"></a>00769                   {
<a name="l00770"></a>00770                     div[face*dim_ch_+comp]+=div[<a class="code" href="AssembleurPP1BUtil_8cpp.html#a3e374d53ebc7860e1c2f0b7906f2936d">face_associee</a>*dim_ch_+comp];
<a name="l00771"></a>00771                     div[<a class="code" href="AssembleurPP1BUtil_8cpp.html#a3e374d53ebc7860e1c2f0b7906f2936d">face_associee</a>*dim_ch_+comp]=div[face*dim_ch_+comp];
<a name="l00772"></a>00772                   }
<a name="l00773"></a>00773 
<a name="l00774"></a>00774             }<span class="comment">//fin du if sur for &quot;ind_face&quot;</span>
<a name="l00775"></a>00775 
<a name="l00776"></a>00776         }<span class="comment">//fin de la periodicite</span>
<a name="l00777"></a>00777 
<a name="l00778"></a>00778       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classNeumann__paroi.html" title="Classe Neumann_paroi Cette condition limite correspond a un flux impose pour l&#39;equation de transport ...">Neumann_paroi</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>()))
<a name="l00779"></a>00779         {
<a name="l00780"></a>00780           <span class="keyword">const</span> <a class="code" href="classNeumann__paroi.html" title="Classe Neumann_paroi Cette condition limite correspond a un flux impose pour l&#39;equation de transport ...">Neumann_paroi</a>&amp; la_cl_paroi =
<a name="l00781"></a>00781             <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classNeumann__paroi.html" title="Classe Neumann_paroi Cette condition limite correspond a un flux impose pour l&#39;equation de transport ...">Neumann_paroi</a>, la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>());
<a name="l00782"></a>00782 
<a name="l00783"></a>00783           <span class="keywordflow">for</span> (ind_face=num1; ind_face&lt;num2; ind_face++)
<a name="l00784"></a>00784             {
<a name="l00785"></a>00785               face = le_bord.<a class="code" href="classFront__VF.html#a3402a19d7e54ed797d2b18e9a47ead1e" title="Renvoie le numero de face de la ieme face du bord.">num_face</a>(ind_face);
<a name="l00786"></a>00786 
<a name="l00787"></a>00787               assert(face_voisins(face,0)!=-1);
<a name="l00788"></a>00788 
<a name="l00789"></a>00789               <span class="keywordflow">for</span> (comp=0; comp&lt;<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#aecdf3d22b30add37625e545939004844">dim_ch_</a>; comp++)
<a name="l00790"></a>00790                 {
<a name="l00791"></a>00791                   flux=la_cl_paroi.<a class="code" href="classNeumann__paroi.html#a76b977c608b621e7dd7106401ab44936" title="Renvoie la valeur du flux impose sur la i-eme composante du champ representant le flux a la frontiere...">flux_impose</a>(ind_face,comp)
<a name="l00792"></a>00792                        *zone_VEF.<a class="code" href="classZone__VF.html#af42306af8f7398c037e978377924ebe8">surface</a>(face);
<a name="l00793"></a>00793 
<a name="l00794"></a>00794                   div[face*dim_ch_+comp]+=flux;
<a name="l00795"></a>00795                 }
<a name="l00796"></a>00796             }
<a name="l00797"></a>00797 
<a name="l00798"></a>00798         }<span class="comment">//fin if sur &quot;Neumann&quot;</span>
<a name="l00799"></a>00799       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classEchange__externe__impose.html" title="Classe Echange_externe_impose: Cette classe represente le cas particulier de la classe Echange_impose...">Echange_externe_impose</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>()))
<a name="l00800"></a>00800         {
<a name="l00801"></a>00801           <span class="keyword">const</span> <a class="code" href="classEchange__externe__impose.html" title="Classe Echange_externe_impose: Cette classe represente le cas particulier de la classe Echange_impose...">Echange_externe_impose</a>&amp; la_cl_paroi=
<a name="l00802"></a>00802             <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classEchange__externe__impose.html" title="Classe Echange_externe_impose: Cette classe represente le cas particulier de la classe Echange_impose...">Echange_externe_impose</a>, la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>());
<a name="l00803"></a>00803 
<a name="l00804"></a>00804           <span class="keywordflow">for</span> (ind_face=num1; ind_face&lt;num2; ind_face++)
<a name="l00805"></a>00805             {
<a name="l00806"></a>00806               face = le_bord.<a class="code" href="classFront__VF.html#a3402a19d7e54ed797d2b18e9a47ead1e" title="Renvoie le numero de face de la ieme face du bord.">num_face</a>(ind_face);
<a name="l00807"></a>00807 
<a name="l00808"></a>00808               <span class="keywordflow">for</span> (comp=0; comp&lt;<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#aecdf3d22b30add37625e545939004844">dim_ch_</a>; comp++)
<a name="l00809"></a>00809                 {
<a name="l00810"></a>00810                   flux=la_cl_paroi.<a class="code" href="classEchange__impose__base.html#a1e75de051a3afbd228374eabc5be9485" title="Renvoie la valeur du coefficient d&#39;echange de chaleur impose sur la i-eme composante du champ de fron...">h_imp</a>(ind_face,comp)
<a name="l00811"></a>00811                        *zone_VEF.<a class="code" href="classZone__VF.html#af42306af8f7398c037e978377924ebe8">surface</a>(face);
<a name="l00812"></a>00812                   flux*=(la_cl_paroi.<a class="code" href="classEchange__impose__base.html#ad2ef464a05e25ba48a5c75af56352440" title="Renvoie la valeur de la temperature imposee sur la i-eme composante du champ de frontiere.">T_ext</a>(ind_face,comp)-inconnue[face*dim_ch_+comp]);
<a name="l00813"></a>00813 
<a name="l00814"></a>00814                   div[face*dim_ch_+comp]+=flux;
<a name="l00815"></a>00815                 }
<a name="l00816"></a>00816             }
<a name="l00817"></a>00817         }
<a name="l00818"></a>00818     }<span class="comment">//fin du for sur &quot;n_bords&quot;</span>
<a name="l00819"></a>00819 
<a name="l00820"></a>00820   div.<a class="code" href="classDoubleVect.html#abfebbc2f685ce7bc4b80c720d7da9bf3">echange_espace_virtuel</a>();
<a name="l00821"></a>00821   <a class="code" href="classOp__Diff__VEF__Face.html#aa3a7ae47654aef0e801eb78dc6a980af">Debog::verifier</a>(<span class="stringliteral">&quot;OpDifP1NCP1B divergence apres CL : &quot;</span>, div);
<a name="l00822"></a>00822   <span class="keywordflow">return</span> div;
<a name="l00823"></a>00823 }
<a name="l00824"></a>00824 
<a name="l00825"></a>00825 <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a529ec43db5b4b872207a7bb2dd40a7ba">Op_Diff_VEFP1NCP1B_Face::</a>
<a name="l00826"></a><a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a529ec43db5b4b872207a7bb2dd40a7ba">00826</a> <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a529ec43db5b4b872207a7bb2dd40a7ba">calculer_divergence_elem</a>(<a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; div)<span class="keyword"> const</span>
<a name="l00827"></a>00827 <span class="keyword"></span>{
<a name="l00828"></a>00828   <span class="keyword">const</span> <a class="code" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a>&amp; zone_VEF = <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a8d6cebdde81108b4c492d8af3d6d60ae">zone_VEFPreP1B</a>();
<a name="l00829"></a>00829 
<a name="l00830"></a>00830   <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; face_normales = zone_VEF.<a class="code" href="classZone__VEF.html#a5742d75972e4846bf9fbb6ed5715053e">face_normales</a>();
<a name="l00831"></a>00831 
<a name="l00832"></a>00832   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; elem_faces=zone_VEF.<a class="code" href="classZone__VF.html#a067e462dcd3ab92b0f6d945b19e4eb37" title="renvoie le numero de le ieme face de la maille num_elem la facon dont ces faces sont numerotees est l...">elem_faces</a>();
<a name="l00833"></a>00833   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; face_voisins=zone_VEF.<a class="code" href="classZone__VF.html#a49d4322f5585a8fa95748ca785b70702" title="renvoie l&#39;element voisin de numface dans la direction i. i=0 : dans le sens oppose de l&#39;axe orthogona...">face_voisins</a>();
<a name="l00834"></a>00834 
<a name="l00835"></a>00835   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_faces_elem=zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#a548fbc7518be2f122b1a5c9589a443c2" title="Renvoie le nombre de face de type i des elements geometriques constituants la zone. Ex: les objets de la classe Prisme ont 2 types de faces: triangle ou quadrangle.">nb_faces_elem</a>();
<a name="l00836"></a>00836   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_elem_tot=zone_VEF.<a class="code" href="classZone__dis__base.html#a4d6aa445f152aa6dc54d66ea7a071147">nb_elem_tot</a>();
<a name="l00837"></a>00837   <span class="keywordtype">int</span> elem=0,face_loc=0,face=0,compi=0,compj=0;
<a name="l00838"></a>00838 
<a name="l00839"></a>00839   <span class="keywordtype">double</span> signe=0.;
<a name="l00840"></a>00840 
<a name="l00841"></a>00841   <span class="keywordflow">for</span>(elem=0; elem&lt;nb_elem_tot; elem++)
<a name="l00842"></a>00842     <span class="keywordflow">for</span>(face_loc=0; face_loc&lt;nb_faces_elem; face_loc++)
<a name="l00843"></a>00843       {
<a name="l00844"></a>00844         face=elem_faces(elem,face_loc);
<a name="l00845"></a>00845 
<a name="l00846"></a>00846         signe=1.;
<a name="l00847"></a>00847         <span class="keywordflow">if</span>(elem!=face_voisins(face,0)) signe=-1.;
<a name="l00848"></a>00848 
<a name="l00849"></a>00849         <span class="keywordflow">for</span>(compi=0; compi&lt;<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#aecdf3d22b30add37625e545939004844">dim_ch_</a>; compi++)
<a name="l00850"></a>00850           <span class="keywordflow">for</span>(compj=0; compj&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; compj++)
<a name="l00851"></a>00851             div[face*dim_ch_+compi]-=
<a name="l00852"></a>00852               <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#af276a7ed4462dd7921988559f8289460">gradient_p0_</a>(elem,compi,compj)
<a name="l00853"></a>00853               *signe*face_normales(face,compj);
<a name="l00854"></a>00854       }
<a name="l00855"></a>00855 
<a name="l00856"></a>00856   div.<a class="code" href="classDoubleVect.html#abfebbc2f685ce7bc4b80c720d7da9bf3">echange_espace_virtuel</a>();
<a name="l00857"></a>00857   <a class="code" href="classOp__Diff__VEF__Face.html#aa3a7ae47654aef0e801eb78dc6a980af">Debog::verifier</a>(<span class="stringliteral">&quot;OpDifP1NCP1B divergence P0 : &quot;</span>, div);
<a name="l00858"></a>00858   <span class="keywordflow">return</span> div;
<a name="l00859"></a>00859 }
<a name="l00860"></a>00860 
<a name="l00861"></a>00861 <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#aa940ce85caaf77638f592302b1fd8561">Op_Diff_VEFP1NCP1B_Face::</a>
<a name="l00862"></a><a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#aa940ce85caaf77638f592302b1fd8561">00862</a> <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#aa940ce85caaf77638f592302b1fd8561">calculer_divergence_som</a>(<a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; div)<span class="keyword"> const</span>
<a name="l00863"></a>00863 <span class="keyword"></span>{
<a name="l00864"></a>00864   <span class="keyword">const</span> <a class="code" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a>&amp; zone_VEF = <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a8d6cebdde81108b4c492d8af3d6d60ae">zone_VEFPreP1B</a>();
<a name="l00865"></a>00865   <span class="keyword">const</span> <a class="code" href="classZone.html" title="classe Zone Une Zone est un maillage compose d&#39;un ensemble d&#39;elements geometriques de meme type...">Zone</a>&amp; zone = zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>();
<a name="l00866"></a>00866   <span class="keyword">const</span> <a class="code" href="classDomaine.html" title="Classe Domaine Un Domaine represente le domaine (spatial) de resolution d&#39;un Probleme. Un Domaine a un Nom, il est constitue d&#39;une ou plusieurs Zone qui peuvent etre eventuellement decoupees en Sous_Zone. Un Domaine porte l&#39;ensemble des sommets utilises par ses Zones. On peut vouloir resoudre des problemes de type different sur plusieurs domaines, geometriquement les domaines sont alors couples par des surfaces qu&#39;on appelle Raccord.">Domaine</a>&amp; dom=zone.<a class="code" href="classZone.html#a379ad2206b5a13a4f4f3df6d44c7546a" title="Renvoie le domaine dont la zone fait partie. (version const)">domaine</a>();
<a name="l00867"></a>00867 
<a name="l00868"></a>00868   <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; face_normales = zone_VEF.<a class="code" href="classZone__VEF.html#a5742d75972e4846bf9fbb6ed5715053e">face_normales</a>();
<a name="l00869"></a>00869   <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a> sigma(<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>);
<a name="l00870"></a>00870 
<a name="l00871"></a>00871   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; som_elem=zone.<a class="code" href="classZone.html#ac115e8342be89afb882b7b61cc343267" title="Renvoie le tableau des sommets des elements.">les_elems</a>();
<a name="l00872"></a>00872   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; elem_faces=zone_VEF.<a class="code" href="classZone__VF.html#a067e462dcd3ab92b0f6d945b19e4eb37" title="renvoie le numero de le ieme face de la maille num_elem la facon dont ces faces sont numerotees est l...">elem_faces</a>();
<a name="l00873"></a>00873   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; face_voisins=zone_VEF.<a class="code" href="classZone__VF.html#a49d4322f5585a8fa95748ca785b70702" title="renvoie l&#39;element voisin de numface dans la direction i. i=0 : dans le sens oppose de l&#39;axe orthogona...">face_voisins</a>();
<a name="l00874"></a>00874 
<a name="l00875"></a>00875   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_faces_elem=zone.<a class="code" href="classZone.html#a548fbc7518be2f122b1a5c9589a443c2" title="Renvoie le nombre de face de type i des elements geometriques constituants la zone. Ex: les objets de la classe Prisme ont 2 types de faces: triangle ou quadrangle.">nb_faces_elem</a>();
<a name="l00876"></a>00876   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_som_face=zone_VEF.<a class="code" href="classZone__VF.html#a990808f967f351edbb83ff11d60b7445" title="renvoie le nombre de sommets par face. Rque : on a suppose que toutes les faces avait le meme nombre ...">nb_som_face</a>();
<a name="l00877"></a>00877   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_elem_tot=zone_VEF.<a class="code" href="classZone__dis__base.html#a4d6aa445f152aa6dc54d66ea7a071147">nb_elem_tot</a>();
<a name="l00878"></a>00878   <span class="keywordtype">int</span> elem=0,face_loc=0,face_loc2=0,face=0;
<a name="l00879"></a>00879   <span class="keywordtype">int</span> compi=0,compj=0,som=0,ind_face=0;
<a name="l00880"></a>00880   <span class="keywordtype">int</span> num1=0, num2=0,som_loc=0;
<a name="l00881"></a>00881 
<a name="l00882"></a>00882   <span class="keyword">static</span> <span class="keywordtype">double</span> coeff_som=1./(<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>)/(<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>+1);
<a name="l00883"></a>00883   <span class="keywordtype">double</span> signe=0.;
<a name="l00884"></a>00884 
<a name="l00885"></a>00885 <span class="comment">// Algorithme sans tenir compte des CL</span>
<a name="l00886"></a>00886   <span class="keywordflow">for</span>(elem=0; elem&lt;nb_elem_tot; elem++)
<a name="l00887"></a>00887     <span class="keywordflow">for</span>(face_loc=0; face_loc&lt;nb_faces_elem; face_loc++)
<a name="l00888"></a>00888       {
<a name="l00889"></a>00889         som=dom.<a class="code" href="classDomaine.html#a37cc657f1907d53b0d5a573da862af80">get_renum_som_perio</a>(som_elem(elem,face_loc));
<a name="l00890"></a>00890         face=elem_faces(elem,face_loc);
<a name="l00891"></a>00891 
<a name="l00892"></a>00892         signe=1;
<a name="l00893"></a>00893         <span class="keywordflow">if</span>(elem!=face_voisins(face,0)) signe=-1;
<a name="l00894"></a>00894 
<a name="l00895"></a>00895         <span class="keywordflow">for</span>(compj=0; compj&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; compj++)
<a name="l00896"></a>00896           sigma[compj]=signe*face_normales(face,compj);
<a name="l00897"></a>00897 
<a name="l00898"></a>00898         <span class="keywordflow">for</span>(face_loc2=0; face_loc2&lt;nb_faces_elem; face_loc2++)
<a name="l00899"></a>00899           <span class="keywordflow">for</span>(compi=0; compi&lt;<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#aecdf3d22b30add37625e545939004844">dim_ch_</a>; compi++)
<a name="l00900"></a>00900             <span class="keywordflow">for</span>(compj=0; compj&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; compj++)
<a name="l00901"></a>00901               div[elem_faces(elem,face_loc2)*dim_ch_+compi]-=
<a name="l00902"></a>00902                 coeff_som*<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a076341d23635d4ad7b0bfc19a03a7722">gradient_p1_</a>(som,compi,compj)*sigma[compj];
<a name="l00903"></a>00903       }
<a name="l00904"></a>00904 
<a name="l00905"></a>00905 <span class="comment">// Les conditions aux limites</span>
<a name="l00906"></a>00906   <span class="keyword">const</span> <a class="code" href="classZone__Cl__VEF.html">Zone_Cl_VEF</a>&amp; zone_Cl_VEF = <a class="code" href="classOp__Diff__VEF__base.html#a721f395a27f12a95882437c614e16a7d">la_zcl_vef</a>.<a class="code" href="classRef__Zone__Cl__VEF.html#a0970d7253def65ad4f0c5ce1830fd243">valeur</a>();
<a name="l00907"></a>00907   <span class="keyword">const</span> <a class="code" href="classConds__lim.html">Conds_lim</a>&amp; les_cl = zone_Cl_VEF.<a class="code" href="classZone__Cl__dis__base.html#af75e0ed7786863e4d333bfb29d67c323" title="Renvoie la i-ieme condition aux limites. (version const)">les_conditions_limites</a>();
<a name="l00908"></a>00908   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; face_sommets = zone_VEF.<a class="code" href="classZone__VF.html#a298e73b18e17da55f421b1fb0879bd46" title="renvoie le numero du ieme sommet de la face num_face.">face_sommets</a>();
<a name="l00909"></a>00909   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_bords =les_cl.<a class="code" href="classvect__impl.html#a78155bfbd6b61f4710b9830641ed1694">size</a>();
<a name="l00910"></a>00910 
<a name="l00911"></a>00911   <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a> gradient_bord(<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#aecdf3d22b30add37625e545939004844">dim_ch_</a>,<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>);
<a name="l00912"></a>00912 
<a name="l00913"></a>00913   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> n_bord=0; n_bord&lt;nb_bords; n_bord++)
<a name="l00914"></a>00914     {
<a name="l00915"></a>00915       <span class="keyword">const</span> <a class="code" href="classCond__lim.html" title="classe Cond_lim Classe generique servant a representer n&#39;importe quelle classe derivee de la classe C...">Cond_lim</a>&amp; la_cl = zone_Cl_VEF.<a class="code" href="classZone__Cl__dis__base.html#af75e0ed7786863e4d333bfb29d67c323" title="Renvoie la i-ieme condition aux limites. (version const)">les_conditions_limites</a>(n_bord);
<a name="l00916"></a>00916       <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp; le_bord = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>,la_cl.<a class="code" href="classCond__lim.html#a5b2d24809cee07727006a891d4ce8d22" title="Appel a l&#39;objet sous-jacent Renvoie la frontiere discretisee associee a la condition aux limites...">frontiere_dis</a>());
<a name="l00917"></a>00917       num1 = 0;
<a name="l00918"></a>00918       num2 = le_bord.<a class="code" href="classFront__VF.html#a341e2fcb5117b96e745fd7078ba86bab" title="Nombre de faces reelles du bord.">nb_faces</a>();
<a name="l00919"></a>00919 
<a name="l00920"></a>00920       <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classNeumann.html" title="Classe Neumann Cette classe est la classe de base de la hierarchie des conditions aux limites de type...">Neumann</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>()) ||
<a name="l00921"></a>00921           <a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classNeumann__val__ext.html" title="Classe Neumann_val_ext Cette classe est la classe de base de la hierarchie des conditions aux limites...">Neumann_val_ext</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>()) ||
<a name="l00922"></a>00922           <a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classNeumann__homogene.html" title="Classe Neumann_homogene Cette classe est la classe de base de la hierarchie des conditions aux limite...">Neumann_homogene</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>()) ||
<a name="l00923"></a>00923           <a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classSymetrie.html" title="classe Symetrie Sur les faces de symetrie on a les proprietes suivantes: - composante normale de la v...">Symetrie</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>())
<a name="l00924"></a>00924          )
<a name="l00925"></a>00925         {
<a name="l00926"></a>00926           <span class="keywordflow">for</span> (ind_face=num1; ind_face&lt;num2; ind_face++)
<a name="l00927"></a>00927             {
<a name="l00928"></a>00928 <span class="comment">// Le numero de la face (qui peut etre virtuelle)</span>
<a name="l00929"></a>00929               face=le_bord.<a class="code" href="classFront__VF.html#a3402a19d7e54ed797d2b18e9a47ead1e" title="Renvoie le numero de face de la ieme face du bord.">num_face</a>(ind_face);
<a name="l00930"></a>00930 
<a name="l00931"></a>00931 <span class="comment">// Le numero de l&#39;element voisin</span>
<a name="l00932"></a>00932               elem=face_voisins(face,0);
<a name="l00933"></a>00933               assert(elem!=-1);
<a name="l00934"></a>00934 
<a name="l00935"></a>00935 <span class="comment">// Calcul du gradient au milieu de la face de bord</span>
<a name="l00936"></a>00936 <span class="comment">// On prend une integration numerique approchee</span>
<a name="l00937"></a>00937               gradient_bord=0.;
<a name="l00938"></a>00938               <span class="keywordflow">for</span> (som_loc=0; som_loc&lt;nb_som_face; som_loc++)
<a name="l00939"></a>00939                 {
<a name="l00940"></a>00940                   som=dom.<a class="code" href="classDomaine.html#a37cc657f1907d53b0d5a573da862af80">get_renum_som_perio</a>(face_sommets(face,som_loc));
<a name="l00941"></a>00941 
<a name="l00942"></a>00942                   <span class="keywordflow">for</span>(compi=0; compi&lt;<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#aecdf3d22b30add37625e545939004844">dim_ch_</a>; compi++)
<a name="l00943"></a>00943                     <span class="keywordflow">for</span>(compj=0; compj&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; compj++)
<a name="l00944"></a>00944                       gradient_bord(compi,compj)+=
<a name="l00945"></a>00945                         <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a076341d23635d4ad7b0bfc19a03a7722">gradient_p1_</a>(som,compi,compj);
<a name="l00946"></a>00946                 }
<a name="l00947"></a>00947               gradient_bord/=<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>;
<a name="l00948"></a>00948 
<a name="l00949"></a>00949 <span class="comment">// Calcul divergence au bord : formule d&#39;integration numerique</span>
<a name="l00950"></a>00950 <span class="comment">// exacte pour polynome d&#39;ordre 1</span>
<a name="l00951"></a>00951               <span class="keywordflow">for</span>(compi=0; compi&lt;<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#aecdf3d22b30add37625e545939004844">dim_ch_</a>; compi++)
<a name="l00952"></a>00952                 <span class="keywordflow">for</span>(compj=0; compj&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; compj++)
<a name="l00953"></a>00953                   div[face*dim_ch_+compi]-=
<a name="l00954"></a>00954                     gradient_bord(compi,compj)
<a name="l00955"></a>00955                     *face_normales(face,compj);
<a name="l00956"></a>00956 
<a name="l00957"></a>00957             }<span class="comment">//fin du for sur &quot;ind_face&quot;</span>
<a name="l00958"></a>00958 
<a name="l00959"></a>00959         }<span class="comment">//fin du if sur &quot;Neumann_paroi&quot;, &quot;Neumann&quot;, &quot;Symetrie&quot;</span>
<a name="l00960"></a>00960 
<a name="l00961"></a>00961     }<span class="comment">//fin du for sur &quot;n_bords&quot;</span>
<a name="l00962"></a>00962 
<a name="l00963"></a>00963   div.<a class="code" href="classDoubleVect.html#abfebbc2f685ce7bc4b80c720d7da9bf3">echange_espace_virtuel</a>();
<a name="l00964"></a>00964   <a class="code" href="classOp__Diff__VEF__Face.html#aa3a7ae47654aef0e801eb78dc6a980af">Debog::verifier</a>(<span class="stringliteral">&quot;OpDifP1NCP1B divergence P1 : &quot;</span>, div);
<a name="l00965"></a>00965   <span class="keywordflow">return</span> div;
<a name="l00966"></a>00966 }
<a name="l00967"></a>00967 
<a name="l00968"></a>00968 <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a3315f6694fb97261a1fdefe4d52d83b1">Op_Diff_VEFP1NCP1B_Face::</a>
<a name="l00969"></a><a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a3315f6694fb97261a1fdefe4d52d83b1">00969</a> <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a3315f6694fb97261a1fdefe4d52d83b1">calculer_divergence_aretes</a>(<a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; div)<span class="keyword"> const</span>
<a name="l00970"></a>00970 <span class="keyword"></span>{
<a name="l00971"></a>00971   <span class="keywordflow">return</span> div;
<a name="l00972"></a>00972 }
<a name="l00973"></a>00973 
<a name="l00974"></a>00974 <span class="keywordtype">void</span> <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a7d0688de99484ee5807a0846219ebe2d">Op_Diff_VEFP1NCP1B_Face::</a>
<a name="l00975"></a><a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a7d0688de99484ee5807a0846219ebe2d">00975</a> <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a7d0688de99484ee5807a0846219ebe2d">calculer_laplacien_som</a>(<span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; nu_som)<span class="keyword"> const</span>
<a name="l00976"></a>00976 <span class="keyword"></span>{
<a name="l00977"></a>00977   <span class="keyword">const</span> <a class="code" href="classChamp__base.html" title="classe Champ_base Cette classe est la base de la hierarchie des champs. Ses membres sont les attribut...">Champ_base</a>&amp; diffu=<a class="code" href="classOp__Diff__VEF__Face.html#aedc62e780da1eac2bb6c2756397a219f">diffusivite</a>();
<a name="l00978"></a>00978 
<a name="l00979"></a>00979   <span class="keywordtype">bool</span> testl=<span class="keyword">false</span>;
<a name="l00980"></a>00980   testl|=<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classChamp__Don__Fonc__xyz.html" title="class Champ_Don_Fonc_xyz Cette classe represente un champ de donnees fonction des variables d&#39;espaces...">Champ_Don_Fonc_xyz</a>,diffu);
<a name="l00981"></a>00981   testl|=<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classChamp__Don__lu.html" title="class Champ_Don_lu Cette classe represente un champ de donnees que l&#39;on lit dans un fichier avec les ...">Champ_Don_lu</a>,diffu);
<a name="l00982"></a>00982   testl|=<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classChamp__Uniforme.html" title="classe Champ_Uniforme Represente un champ constant dans l&#39;espace et dans le temps.">Champ_Uniforme</a>,diffu);
<a name="l00983"></a>00983   testl|=<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classChamp__Uniforme__Morceaux.html" title="classe Champ_Uniforme_Morceaux Cette classe represente champ constant par morceaux dans l&#39;espace et c...">Champ_Uniforme_Morceaux</a>,diffu);
<a name="l00984"></a>00984   testl|=<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classChamp__Fonc__base.html" title="classe Champ_Fonc_base Classe de base des champs qui sont fonction d&#39;une grandeur calculee au cours d...">Champ_Fonc_base</a>,diffu);
<a name="l00985"></a>00985   <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a168b650a02b7a56f11b3205e7ea0e019">is_laplacian_filled_</a>=testl;
<a name="l00986"></a>00986 
<a name="l00987"></a>00987   <span class="keyword">const</span> <a class="code" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a>&amp; zone_VEF = <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a8d6cebdde81108b4c492d8af3d6d60ae">zone_VEFPreP1B</a>();
<a name="l00988"></a>00988 
<a name="l00989"></a>00989   <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; <a class="code" href="Champ__P1iP1B__implementation_8cpp.html#aa8c8f49390c3cf7c702d71a71bc977e3">coeff</a>=<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#af990901466d6341a02f7fd028353e028">laplacien_p1_</a>.<a class="code" href="classMatrice__Morse.html#acd067e8514e5741f52b18a1d99746d11">get_set_coeff</a>();
<a name="l00990"></a>00990 
<a name="l00991"></a>00991   <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; inconnue1=<a class="code" href="classMorEqn.html#a615dd9abff96edcb625fa0424a489864" title="Renvoie la reference sur l&#39;equation pointe par MorEqn::mon_equation. (version const)">equation</a>().<a class="code" href="classEquation__base.html#a5a1fce9487b9a8dd17020914100c2c89">inconnue</a>().<a class="code" href="classChamp__Inc.html#a28ef3d411d12cb5684ac5e799efb7d24" title="Appel a l&#39;objet sous-jacent Renvoie le tableau des valeurs au temps courant.">valeurs</a>();
<a name="l00992"></a>00992   <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; porosite_face=zone_VEF.<a class="code" href="classZone__VF.html#ad9d74d1d9da9f50ab26768dbbca7711b">porosite_face</a>();
<a name="l00993"></a>00993 
<a name="l00994"></a>00994   assert(<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#af990901466d6341a02f7fd028353e028">laplacien_p1_</a>.<a class="code" href="classMatrice__Morse.html#a1f9bd6aedb226c86b7299689fa5b821a">nb_lignes</a>()&gt;2);
<a name="l00995"></a>00995 
<a name="l00996"></a>00996   coeff=0.;
<a name="l00997"></a>00997   <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#ae979dc98da8579c81ed4abf017475277">ajouter_contribution_som</a>(inconnue1,porosite_face,nu_som,<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#af990901466d6341a02f7fd028353e028">laplacien_p1_</a>);
<a name="l00998"></a>00998   coeff*=-1;<span class="comment">//pour l&#39;explicite</span>
<a name="l00999"></a>00999 }
<a name="l01000"></a>01000 
<a name="l01001"></a>01001 <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a758c8869b8f0b8bd04a888995a9e3249">Op_Diff_VEFP1NCP1B_Face::</a>
<a name="l01002"></a><a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a758c8869b8f0b8bd04a888995a9e3249">01002</a> <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a758c8869b8f0b8bd04a888995a9e3249">ajouter</a>(<span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; inconnue, <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; resu)<span class="keyword"> const</span>
<a name="l01003"></a>01003 <span class="keyword"></span>{
<a name="l01004"></a>01004   <span class="keyword">const</span> <a class="code" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a>&amp; zone_VEF = <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a8d6cebdde81108b4c492d8af3d6d60ae">zone_VEFPreP1B</a>();
<a name="l01005"></a>01005   <span class="keyword">const</span> <a class="code" href="classZone.html" title="classe Zone Une Zone est un maillage compose d&#39;un ensemble d&#39;elements geometriques de meme type...">Zone</a>&amp; zone=zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>();
<a name="l01006"></a>01006 
<a name="l01007"></a>01007   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_aretes_tot=zone.<a class="code" href="classZone.html#a59ae0ababf85ce303a7c6f339430e335" title="renvoie le nombre d&#39;aretes total (reelles+virtuelles).">nb_aretes_tot</a>();
<a name="l01008"></a>01008 
<a name="l01009"></a>01009 <span class="comment">// Recuperation de la diffusivite</span>
<a name="l01010"></a>01010   <a class="code" href="classOp__Diff__VEF__base.html#aaf04f2c605558b7b05aa8c60f84fb9e1">remplir_nu</a>(<a class="code" href="classOp__Diff__VEF__base.html#ab1309af47a0c41f00181e031fbfda002">nu_</a>);
<a name="l01011"></a>01011 
<a name="l01012"></a>01012 <span class="comment">// Pour tenir compte de la porosite</span>
<a name="l01013"></a>01013   <span class="keyword">const</span> <span class="keywordtype">int</span> marq = <a class="code" href="classOp__Diff__VEF__base.html#ae7df69707cc2304c930eb103390e99f0">phi_psi_diffuse</a>(<a class="code" href="classMorEqn.html#a615dd9abff96edcb625fa0424a489864" title="Renvoie la reference sur l&#39;equation pointe par MorEqn::mon_equation. (version const)">equation</a>());
<a name="l01014"></a>01014   <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; porosite_face = zone_VEF.<a class="code" href="classZone__VF.html#ad9d74d1d9da9f50ab26768dbbca7711b">porosite_face</a>();
<a name="l01015"></a>01015   <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; porosite_elem = zone_VEF.<a class="code" href="classZone__VF.html#afd135a1b227731193b1a97b7ed525435">porosite_elem</a>();
<a name="l01016"></a>01016 
<a name="l01017"></a>01017   <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a> nu,nu_p1,nu_pA;
<a name="l01018"></a>01018   <a class="code" href="Porosites__champ_8cpp.html#a2340e7d73d0f9d34926d012fe1b1d884" title="renvoit le tableau res, res=org si flag=0, res= porosite*org sinon attention ne pas modifier res car ...">modif_par_porosite_si_flag</a>(<a class="code" href="classOp__Diff__VEF__base.html#ab1309af47a0c41f00181e031fbfda002">nu_</a>,nu,!marq,porosite_elem);
<a name="l01019"></a>01019 
<a name="l01020"></a>01020   <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a> inconnue1;
<a name="l01021"></a>01021   <a class="code" href="Porosites__champ_8cpp.html#a2340e7d73d0f9d34926d012fe1b1d884" title="renvoit le tableau res, res=org si flag=0, res= porosite*org sinon attention ne pas modifier res car ...">modif_par_porosite_si_flag</a>(inconnue,inconnue1,marq,porosite_face);
<a name="l01022"></a>01022 
<a name="l01023"></a>01023 <span class="comment">// Pour des raisons pratiques</span>
<a name="l01024"></a>01024   <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; inconnue2 = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classDoubleVect.html">DoubleVect</a>,inconnue1);
<a name="l01025"></a>01025   <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; resu2 = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classDoubleVect.html">DoubleVect</a>,resu);
<a name="l01026"></a>01026   <a class="code" href="classDoubleVect.html">DoubleVect</a> resu3(resu2);
<a name="l01027"></a>01027   resu3=0.;
<a name="l01028"></a>01028 
<a name="l01029"></a>01029   <span class="keywordflow">if</span> (<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#acbd7461fb999d27a3c1ba0320f13563a">alphaE</a>)
<a name="l01030"></a>01030     {
<a name="l01031"></a>01031       <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#af276a7ed4462dd7921988559f8289460">gradient_p0_</a>=0.;
<a name="l01032"></a>01032       <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a054036b7f0ee412cb3a959885d915f2f">calculer_gradient_elem</a>(inconnue2);
<a name="l01033"></a>01033 
<a name="l01034"></a>01034       <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a9e35f1eae54ef9533a3409a26826428f">corriger_pour_diffusivite</a>(nu,<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#af276a7ed4462dd7921988559f8289460">gradient_p0_</a>);
<a name="l01035"></a>01035       <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#af276a7ed4462dd7921988559f8289460">gradient_p0_</a>*=<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a463106e6f719474777b7cc6c5e813354">convexite_</a>;
<a name="l01036"></a>01036 
<a name="l01037"></a>01037       <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a529ec43db5b4b872207a7bb2dd40a7ba">calculer_divergence_elem</a>(resu3);
<a name="l01038"></a>01038       <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a16f33e9d0867d5888e2faf4d87c85989">calculer_flux_bords_elem</a>(inconnue2);
<a name="l01039"></a>01039     }
<a name="l01040"></a>01040   <span class="keywordflow">if</span> (<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a3ca993ddf7251f0c1f79b9c659d5a96f">alphaA</a>)
<a name="l01041"></a>01041     {
<a name="l01042"></a>01042       <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#ad5225e89df933786053e400ee9b04db0">gradient_pa_</a>=0.;
<a name="l01043"></a>01043       nu_pA.<a class="code" href="classDoubleTab.html#ae83b4d31205c53d9c8d2b43da178ce75" title="Change la taille du vecteur (identique a resize_array() pour le traitement des anciennes valeurs et d...">resize</a>(nb_aretes_tot);
<a name="l01044"></a>01044       <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a3b64900128cbb94e4b8980e5ac10b49d">remplir_nu_pA</a>(nu,nu_pA);
<a name="l01045"></a>01045 
<a name="l01046"></a>01046       <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#afb9be14ba93fdea98e9f53d952752034">calculer_gradient_aretes</a>(inconnue2);
<a name="l01047"></a>01047 
<a name="l01048"></a>01048       <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a9e35f1eae54ef9533a3409a26826428f">corriger_pour_diffusivite</a>(nu_pA,<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#ad5225e89df933786053e400ee9b04db0">gradient_pa_</a>);
<a name="l01049"></a>01049 
<a name="l01050"></a>01050       <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a3315f6694fb97261a1fdefe4d52d83b1">calculer_divergence_aretes</a>(resu3);
<a name="l01051"></a>01051       <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a4de56f9fddbc93956dc697dcf31f7583">calculer_flux_bords_aretes</a>(inconnue2);
<a name="l01052"></a>01052     }
<a name="l01053"></a>01053   <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a325ae974e29dd047801de2efaeea1174">corriger_div_pour_Cl</a>(inconnue2,nu,resu3);
<a name="l01054"></a>01054 
<a name="l01055"></a>01055 <span class="comment">// Le corriger_div_pour_Cl() doit etre fait AVANT le calcul</span>
<a name="l01056"></a>01056 <span class="comment">// de la partie p1 car la matrice est deja codee pour tenir</span>
<a name="l01057"></a>01057 <span class="comment">// compte des coefficients periodiques</span>
<a name="l01058"></a>01058 <span class="comment">// REMARQUE IMPORTANTE : pour des raisons techniques inherentes</span>
<a name="l01059"></a>01059 <span class="comment">// a TrioU, le calcul du dt_stab a lieu AVANT l&#39;application</span>
<a name="l01060"></a>01060 <span class="comment">// de la fonction ajouter(). Or le dt_stab a besoin de la matrice</span>
<a name="l01061"></a>01061 <span class="comment">// pour etre correctement calcule par consequent, la matrice</span>
<a name="l01062"></a>01062 <span class="comment">// laplacien_p1_ est construite dans la fonction calculer_dt_stab()</span>
<a name="l01063"></a>01063 <span class="comment">// et est seulement reutilisee ici.</span>
<a name="l01064"></a>01064   <span class="keywordflow">if</span> (<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a0ff8784f933eedd5f6a52db444f2d71b">alphaS</a>)
<a name="l01065"></a>01065     {
<a name="l01066"></a>01066       zone.<a class="code" href="classZone.html#a379ad2206b5a13a4f4f3df6d44c7546a" title="Renvoie le domaine dont la zone fait partie. (version const)">domaine</a>().<a class="code" href="classDomaine.html#a32c7de9f9e8e78e3d5ea68715b2ceb2b" title="Cree un tableau ayant une &quot;ligne&quot; par sommet du maillage. Voir MD_Vector_tools::creer_tableau_distrib...">creer_tableau_sommets</a>(nu_p1);
<a name="l01067"></a>01067       <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a997bacd7fe35872ff44036e9e9f40996" title="Calcule la diffusivite &quot;nu_p1&quot; aux sommets du maillage en fonction de la diffusivite &quot;nu_elem&quot; au...">remplir_nu_p1</a>(nu,nu_p1);
<a name="l01068"></a>01068       <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#af990901466d6341a02f7fd028353e028">laplacien_p1_</a>.<a class="code" href="classMatrice__Base.html#a6ccb4d20d3877cf09f5178ff72af5406" title="Operation de multiplication-accumulation (saxpy) matrice vecteur. Operation: r = r + A*x...">ajouter_multvect</a>(inconnue2,resu3);
<a name="l01069"></a>01069 
<a name="l01070"></a>01070       <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a076341d23635d4ad7b0bfc19a03a7722">gradient_p1_</a>=0.;
<a name="l01071"></a>01071       <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a5e85dd4ed5a586f2787a149790ba0714">calculer_gradient_som</a>(inconnue2);
<a name="l01072"></a>01072       <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a9e35f1eae54ef9533a3409a26826428f">corriger_pour_diffusivite</a>(nu_p1,<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a076341d23635d4ad7b0bfc19a03a7722">gradient_p1_</a>);
<a name="l01073"></a>01073       <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a076341d23635d4ad7b0bfc19a03a7722">gradient_p1_</a>*=(1.-<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a463106e6f719474777b7cc6c5e813354">convexite_</a>);
<a name="l01074"></a>01074       <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#aeb1ae7dfd65857f58bbe29defb6bf747">calculer_flux_bords_som</a>(inconnue2);
<a name="l01075"></a>01075     }
<a name="l01076"></a>01076 
<a name="l01077"></a>01077   <span class="keywordflow">if</span> (<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#aa413a1aa88ba72b238a4bc1067f5a869">test_</a>) <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a4f8b23049afd6589ab4f1fa9619458f9">test</a>();
<a name="l01078"></a>01078 
<a name="l01079"></a>01079   resu2+=resu3;
<a name="l01080"></a>01080   resu.<a class="code" href="classDoubleVect.html#abfebbc2f685ce7bc4b80c720d7da9bf3">echange_espace_virtuel</a>();
<a name="l01081"></a>01081   <a class="code" href="classOp__VEF__Face.html#a6c8ce571769b4f2e20b07cbb7a6944f2">modifier_flux</a>(*<span class="keyword">this</span>);
<a name="l01082"></a>01082   <span class="keywordflow">return</span> resu;
<a name="l01083"></a>01083 }
<a name="l01084"></a>01084 
<a name="l01085"></a>01085 <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a2f86fceb1e62fd028ed023cecf1ac447">Op_Diff_VEFP1NCP1B_Face::</a>
<a name="l01086"></a><a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a2f86fceb1e62fd028ed023cecf1ac447">01086</a> <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a2f86fceb1e62fd028ed023cecf1ac447">calculer</a>(<span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; inconnue, <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; resu)<span class="keyword"> const</span>
<a name="l01087"></a>01087 <span class="keyword"></span>{
<a name="l01088"></a>01088   resu = 0;
<a name="l01089"></a>01089   <span class="keywordflow">return</span> <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a758c8869b8f0b8bd04a888995a9e3249">ajouter</a>(inconnue,resu);
<a name="l01090"></a>01090 }
<a name="l01091"></a>01091 
<a name="l01092"></a>01092 <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a9e35f1eae54ef9533a3409a26826428f">Op_Diff_VEFP1NCP1B_Face::</a>
<a name="l01093"></a><a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a9e35f1eae54ef9533a3409a26826428f">01093</a> <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a9e35f1eae54ef9533a3409a26826428f">corriger_pour_diffusivite</a>(<span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; nu,<a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; grad)<span class="keyword"> const</span>
<a name="l01094"></a>01094 <span class="keyword"></span>{
<a name="l01095"></a>01095   <a class="code" href="DoubleVect_8cpp.html#ae2081ab8f1947e8400a928ca3b172e29">tab_multiply_any_shape</a>(grad, nu);
<a name="l01096"></a>01096   <span class="keywordflow">return</span> grad;
<a name="l01097"></a>01097 }
<a name="l01098"></a>01098 
<a name="l01099"></a>01099 
<a name="l01100"></a><a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a0939691aa4e08464a51cb16c33a62d51">01100</a> <span class="keywordtype">void</span> <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a0939691aa4e08464a51cb16c33a62d51">Op_Diff_VEFP1NCP1B_Face::initialiser</a>()
<a name="l01101"></a>01101 {
<a name="l01102"></a>01102   <span class="keyword">const</span> <a class="code" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a>&amp; zone_VEF = <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a8d6cebdde81108b4c492d8af3d6d60ae">zone_VEFPreP1B</a>();
<a name="l01103"></a>01103 
<a name="l01104"></a>01104   <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; unknown = <a class="code" href="classMorEqn.html#a615dd9abff96edcb625fa0424a489864" title="Renvoie la reference sur l&#39;equation pointe par MorEqn::mon_equation. (version const)">equation</a>().<a class="code" href="classEquation__base.html#a5a1fce9487b9a8dd17020914100c2c89">inconnue</a>().<a class="code" href="classChamp__Inc.html#a28ef3d411d12cb5684ac5e799efb7d24" title="Appel a l&#39;objet sous-jacent Renvoie le tableau des valeurs au temps courant.">valeurs</a>();
<a name="l01105"></a>01105   <span class="keyword">const</span> <span class="keywordtype">int</span> size = unknown.<a class="code" href="classDoubleVect.html#ab02d01cd1bdab66fbd66f9a47cc29e10">line_size</a>();
<a name="l01106"></a>01106 
<a name="l01107"></a>01107 <span class="comment">// Definition des gradients</span>
<a name="l01108"></a>01108   <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#af276a7ed4462dd7921988559f8289460">gradient_p0_</a>.<a class="code" href="classDoubleTab.html#ae83b4d31205c53d9c8d2b43da178ce75" title="Change la taille du vecteur (identique a resize_array() pour le traitement des anciennes valeurs et d...">resize</a>(0, size, <a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>);
<a name="l01109"></a>01109   zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#a600fa15a19c7e1384564dffd83ecab4d" title="creation d&#39;un tableau parallele de valeurs aux elements. Voir MD_Vector_tools::creer_tableau_distribu...">creer_tableau_elements</a>(<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#af276a7ed4462dd7921988559f8289460">gradient_p0_</a>);
<a name="l01110"></a>01110 
<a name="l01111"></a>01111   <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a076341d23635d4ad7b0bfc19a03a7722">gradient_p1_</a>.<a class="code" href="classDoubleTab.html#ae83b4d31205c53d9c8d2b43da178ce75" title="Change la taille du vecteur (identique a resize_array() pour le traitement des anciennes valeurs et d...">resize</a>(0, size, <a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>);
<a name="l01112"></a>01112   zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#a379ad2206b5a13a4f4f3df6d44c7546a" title="Renvoie le domaine dont la zone fait partie. (version const)">domaine</a>().<a class="code" href="classDomaine.html#a32c7de9f9e8e78e3d5ea68715b2ceb2b" title="Cree un tableau ayant une &quot;ligne&quot; par sommet du maillage. Voir MD_Vector_tools::creer_tableau_distrib...">creer_tableau_sommets</a>(<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a076341d23635d4ad7b0bfc19a03a7722">gradient_p1_</a>);
<a name="l01113"></a>01113 
<a name="l01114"></a>01114   <span class="keywordflow">if</span> (<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a3ca993ddf7251f0c1f79b9c659d5a96f">alphaA</a>)
<a name="l01115"></a>01115     {
<a name="l01116"></a>01116       <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#ad5225e89df933786053e400ee9b04db0">gradient_pa_</a>.<a class="code" href="classDoubleTab.html#ae83b4d31205c53d9c8d2b43da178ce75" title="Change la taille du vecteur (identique a resize_array() pour le traitement des anciennes valeurs et d...">resize</a>(0, size, <a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>);
<a name="l01117"></a>01117       zone_VEF.<a class="code" href="classZone__VF.html#ae77f9ddf0711c0bcf2162921698d0bea">creer_tableau_aretes</a>(<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#ad5225e89df933786053e400ee9b04db0">gradient_pa_</a>);
<a name="l01118"></a>01118     }
<a name="l01119"></a>01119 
<a name="l01120"></a>01120 <span class="comment">// Initialisation de l&#39;attribut dim_ch_</span>
<a name="l01121"></a>01121   <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#aecdf3d22b30add37625e545939004844">dim_ch_</a>=size;
<a name="l01122"></a>01122 
<a name="l01123"></a>01123 <span class="comment">// Dimensionnemt du tableau flux_bords</span>
<a name="l01124"></a>01124   <a class="code" href="classOperateur__base.html#a451f51b41518ddbc0d3f586a8177d319" title="Tableau contenant les flux sur les bords de l&#39;operateur.">flux_bords_</a>.<a class="code" href="classDoubleTab.html#ae83b4d31205c53d9c8d2b43da178ce75" title="Change la taille du vecteur (identique a resize_array() pour le traitement des anciennes valeurs et d...">resize</a>(zone_VEF.<a class="code" href="classZone__VF.html#a8815e2276637c0db23868f043dc43e58" title="renvoie le nombre de faces sur lesquelles sont appliquees les conditions limites : bords...">nb_faces_bord</a>(),size);
<a name="l01125"></a>01125   <a class="code" href="classOperateur__base.html#a451f51b41518ddbc0d3f586a8177d319" title="Tableau contenant les flux sur les bords de l&#39;operateur.">flux_bords_</a>=0.;
<a name="l01126"></a>01126 }
<a name="l01127"></a>01127 
<a name="l01128"></a>01128 <span class="comment">// Fonction qui calcule le flux aux bords du domaine</span>
<a name="l01129"></a><a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a16f33e9d0867d5888e2faf4d87c85989">01129</a> <span class="keywordtype">void</span> <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a16f33e9d0867d5888e2faf4d87c85989">Op_Diff_VEFP1NCP1B_Face::calculer_flux_bords_elem</a>(<span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; inconnue)<span class="keyword"> const</span>
<a name="l01130"></a>01130 <span class="keyword"></span>{
<a name="l01131"></a>01131   <span class="keyword">const</span> <a class="code" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a>&amp; zone_VEF = <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a8d6cebdde81108b4c492d8af3d6d60ae">zone_VEFPreP1B</a>();
<a name="l01132"></a>01132   <span class="keyword">const</span> <a class="code" href="classZone__Cl__VEF.html">Zone_Cl_VEF</a>&amp; zone_Cl_VEF = <a class="code" href="classOp__Diff__VEF__base.html#a721f395a27f12a95882437c614e16a7d">la_zcl_vef</a>.<a class="code" href="classRef__Zone__Cl__VEF.html#a0970d7253def65ad4f0c5ce1830fd243">valeur</a>();
<a name="l01133"></a>01133 
<a name="l01134"></a>01134   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; face_voisins=zone_VEF.<a class="code" href="classZone__VF.html#a49d4322f5585a8fa95748ca785b70702" title="renvoie l&#39;element voisin de numface dans la direction i. i=0 : dans le sens oppose de l&#39;axe orthogona...">face_voisins</a>();
<a name="l01135"></a>01135 
<a name="l01136"></a>01136   <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; face_normales=zone_VEF.<a class="code" href="classZone__VEF.html#a5742d75972e4846bf9fbb6ed5715053e">face_normales</a>();
<a name="l01137"></a>01137 
<a name="l01138"></a>01138   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_bords=zone_VEF.<a class="code" href="classZone__dis__base.html#af22167d614644f55591a29c77eb1c009">nb_front_Cl</a>();
<a name="l01139"></a>01139 
<a name="l01140"></a>01140   <span class="keywordtype">int</span> face=0;
<a name="l01141"></a>01141   <span class="keywordtype">int</span> elem=0;
<a name="l01142"></a>01142   <span class="keywordtype">int</span> n_bord=0,ind_face=0;
<a name="l01143"></a>01143   <span class="keywordtype">int</span> num1=0,num2=0;
<a name="l01144"></a>01144   <span class="keywordtype">int</span> compi=0,compj=0;
<a name="l01145"></a>01145 
<a name="l01146"></a>01146   <span class="keywordtype">double</span> surface=0.;
<a name="l01147"></a>01147   <span class="keywordtype">double</span> Text=0.;
<a name="l01148"></a>01148 
<a name="l01149"></a>01149   <span class="keywordtype">double</span> coeff_conv=1.;
<a name="l01150"></a>01150   <span class="keywordflow">if</span> (<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a0ff8784f933eedd5f6a52db444f2d71b">alphaS</a>) coeff_conv=<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a463106e6f719474777b7cc6c5e813354">convexite_</a>;
<a name="l01151"></a>01151 
<a name="l01152"></a>01152   <span class="keywordflow">for</span> (n_bord=0; n_bord&lt;nb_bords; n_bord++)
<a name="l01153"></a>01153     {
<a name="l01154"></a>01154       <span class="keyword">const</span> <a class="code" href="classCond__lim.html" title="classe Cond_lim Classe generique servant a representer n&#39;importe quelle classe derivee de la classe C...">Cond_lim</a>&amp; la_cl = zone_Cl_VEF.<a class="code" href="classZone__Cl__dis__base.html#af75e0ed7786863e4d333bfb29d67c323" title="Renvoie la i-ieme condition aux limites. (version const)">les_conditions_limites</a>(n_bord);
<a name="l01155"></a>01155       <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp; le_bord = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>,la_cl.<a class="code" href="classCond__lim.html#a5b2d24809cee07727006a891d4ce8d22" title="Appel a l&#39;objet sous-jacent Renvoie la frontiere discretisee associee a la condition aux limites...">frontiere_dis</a>());
<a name="l01156"></a>01156 
<a name="l01157"></a>01157       num1=0;
<a name="l01158"></a>01158       num2=le_bord.<a class="code" href="classFront__VF.html#a341e2fcb5117b96e745fd7078ba86bab" title="Nombre de faces reelles du bord.">nb_faces</a>();
<a name="l01159"></a>01159 
<a name="l01160"></a>01160       <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classNeumann__paroi.html" title="Classe Neumann_paroi Cette condition limite correspond a un flux impose pour l&#39;equation de transport ...">Neumann_paroi</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>()))
<a name="l01161"></a>01161         {
<a name="l01162"></a>01162           <span class="keyword">const</span> <a class="code" href="classNeumann__paroi.html" title="Classe Neumann_paroi Cette condition limite correspond a un flux impose pour l&#39;equation de transport ...">Neumann_paroi</a>&amp; la_cl_paroi=
<a name="l01163"></a>01163             <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classNeumann__paroi.html" title="Classe Neumann_paroi Cette condition limite correspond a un flux impose pour l&#39;equation de transport ...">Neumann_paroi</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>());
<a name="l01164"></a>01164 
<a name="l01165"></a>01165           <span class="keywordflow">for</span> (ind_face=num1; ind_face&lt;num2; ind_face++)
<a name="l01166"></a>01166             {
<a name="l01167"></a>01167               face=le_bord.<a class="code" href="classFront__VF.html#a3402a19d7e54ed797d2b18e9a47ead1e" title="Renvoie le numero de face de la ieme face du bord.">num_face</a>(ind_face);
<a name="l01168"></a>01168               surface=zone_VEF.<a class="code" href="classZone__VF.html#a40c3382b189a4fc508cf1c3e37b04b21">face_surfaces</a>(face);
<a name="l01169"></a>01169 
<a name="l01170"></a>01170               <span class="keywordflow">for</span> (compi=0; compi&lt;<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#aecdf3d22b30add37625e545939004844">dim_ch_</a>; compi++)
<a name="l01171"></a>01171                 <a class="code" href="classOperateur__base.html#a451f51b41518ddbc0d3f586a8177d319" title="Tableau contenant les flux sur les bords de l&#39;operateur.">flux_bords_</a>(face,compi)=coeff_conv*
<a name="l01172"></a>01172                                         la_cl_paroi.<a class="code" href="classNeumann__paroi.html#a76b977c608b621e7dd7106401ab44936" title="Renvoie la valeur du flux impose sur la i-eme composante du champ representant le flux a la frontiere...">flux_impose</a>(ind_face,compi)*
<a name="l01173"></a>01173                                         surface;
<a name="l01174"></a>01174             }
<a name="l01175"></a>01175         }
<a name="l01176"></a>01176       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classEchange__externe__impose.html" title="Classe Echange_externe_impose: Cette classe represente le cas particulier de la classe Echange_impose...">Echange_externe_impose</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>()))
<a name="l01177"></a>01177         {
<a name="l01178"></a>01178           <span class="keyword">const</span> <a class="code" href="classEchange__externe__impose.html" title="Classe Echange_externe_impose: Cette classe represente le cas particulier de la classe Echange_impose...">Echange_externe_impose</a>&amp; la_cl_paroi=
<a name="l01179"></a>01179             <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classEchange__externe__impose.html" title="Classe Echange_externe_impose: Cette classe represente le cas particulier de la classe Echange_impose...">Echange_externe_impose</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>());
<a name="l01180"></a>01180 
<a name="l01181"></a>01181           <span class="keywordflow">for</span> (ind_face=num1; ind_face&lt;num2; ind_face++)
<a name="l01182"></a>01182             {
<a name="l01183"></a>01183               face=le_bord.<a class="code" href="classFront__VF.html#a3402a19d7e54ed797d2b18e9a47ead1e" title="Renvoie le numero de face de la ieme face du bord.">num_face</a>(ind_face);
<a name="l01184"></a>01184               surface=zone_VEF.<a class="code" href="classZone__VF.html#a40c3382b189a4fc508cf1c3e37b04b21">face_surfaces</a>(face);
<a name="l01185"></a>01185 
<a name="l01186"></a>01186               <span class="keywordflow">for</span> (compi=0; compi&lt;<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#aecdf3d22b30add37625e545939004844">dim_ch_</a>; compi++)
<a name="l01187"></a>01187                 {
<a name="l01188"></a>01188                   Text=la_cl_paroi.<a class="code" href="classEchange__impose__base.html#ad2ef464a05e25ba48a5c75af56352440" title="Renvoie la valeur de la temperature imposee sur la i-eme composante du champ de frontiere.">T_ext</a>(ind_face,compi);
<a name="l01189"></a>01189 
<a name="l01190"></a>01190                   <a class="code" href="classOperateur__base.html#a451f51b41518ddbc0d3f586a8177d319" title="Tableau contenant les flux sur les bords de l&#39;operateur.">flux_bords_</a>(face,compi)=coeff_conv*la_cl_paroi.<a class="code" href="classEchange__impose__base.html#a1e75de051a3afbd228374eabc5be9485" title="Renvoie la valeur du coefficient d&#39;echange de chaleur impose sur la i-eme composante du champ de fron...">h_imp</a>(ind_face,compi)*surface;
<a name="l01191"></a>01191                   <a class="code" href="classOperateur__base.html#a451f51b41518ddbc0d3f586a8177d319" title="Tableau contenant les flux sur les bords de l&#39;operateur.">flux_bords_</a>(face,compi)*=(Text-inconnue[face*dim_ch_+compi]);
<a name="l01192"></a>01192                 }
<a name="l01193"></a>01193             }
<a name="l01194"></a>01194         }
<a name="l01195"></a>01195       <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( <a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classNeumann__homogene.html" title="Classe Neumann_homogene Cette classe est la classe de base de la hierarchie des conditions aux limite...">Neumann_homogene</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>()) ||
<a name="l01196"></a>01196                 <a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classNeumann__sortie__libre.html" title="classe Neumann_sortie_libre Cette classe represente une frontiere ouverte sans vitesse imposee Pour l...">Neumann_sortie_libre</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>()) ||
<a name="l01197"></a>01197                 <a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classSymetrie.html" title="classe Symetrie Sur les faces de symetrie on a les proprietes suivantes: - composante normale de la v...">Symetrie</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>())
<a name="l01198"></a>01198               )
<a name="l01199"></a>01199         {
<a name="l01200"></a>01200           <span class="keywordflow">for</span> (ind_face=num1; ind_face&lt;num2; ind_face++)
<a name="l01201"></a>01201             {
<a name="l01202"></a>01202               face=le_bord.<a class="code" href="classFront__VF.html#a3402a19d7e54ed797d2b18e9a47ead1e" title="Renvoie le numero de face de la ieme face du bord.">num_face</a>(ind_face);
<a name="l01203"></a>01203 
<a name="l01204"></a>01204               <span class="keywordflow">for</span> (compi=0; compi&lt;<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#aecdf3d22b30add37625e545939004844">dim_ch_</a>; compi++)
<a name="l01205"></a>01205                 <a class="code" href="classOperateur__base.html#a451f51b41518ddbc0d3f586a8177d319" title="Tableau contenant les flux sur les bords de l&#39;operateur.">flux_bords_</a>(face,compi)=0.;
<a name="l01206"></a>01206             }
<a name="l01207"></a>01207         }
<a name="l01208"></a>01208       <span class="keywordflow">else</span>
<a name="l01209"></a>01209         {
<a name="l01210"></a>01210           <span class="keywordflow">for</span> (ind_face=num1; ind_face&lt;num2; ind_face++)
<a name="l01211"></a>01211             {
<a name="l01212"></a>01212               face=le_bord.<a class="code" href="classFront__VF.html#a3402a19d7e54ed797d2b18e9a47ead1e" title="Renvoie le numero de face de la ieme face du bord.">num_face</a>(ind_face);
<a name="l01213"></a>01213               elem=face_voisins(face,0);
<a name="l01214"></a>01214               assert(elem!=-1);
<a name="l01215"></a>01215 
<a name="l01216"></a>01216 <span class="comment">// le coefficient de convexite est deja dans gradient_p0_</span>
<a name="l01217"></a>01217               <span class="keywordflow">for</span> (compi=0; compi&lt;<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#aecdf3d22b30add37625e545939004844">dim_ch_</a>; compi++)
<a name="l01218"></a>01218                 <span class="keywordflow">for</span> (compj=0; compj&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; compj++)
<a name="l01219"></a>01219                   <a class="code" href="classOperateur__base.html#a451f51b41518ddbc0d3f586a8177d319" title="Tableau contenant les flux sur les bords de l&#39;operateur.">flux_bords_</a>(face,compi)=<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#af276a7ed4462dd7921988559f8289460">gradient_p0_</a>(elem,compi,compj)
<a name="l01220"></a>01220                                           *face_normales(face,compj);
<a name="l01221"></a>01221             }
<a name="l01222"></a>01222         }
<a name="l01223"></a>01223     }<span class="comment">//fin du for sur n_bord</span>
<a name="l01224"></a>01224 }
<a name="l01225"></a>01225 
<a name="l01226"></a>01226 <span class="comment">// Fonction qui calcule le flux aux bords du domaine</span>
<a name="l01227"></a><a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#aeb1ae7dfd65857f58bbe29defb6bf747">01227</a> <span class="keywordtype">void</span> <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#aeb1ae7dfd65857f58bbe29defb6bf747">Op_Diff_VEFP1NCP1B_Face::calculer_flux_bords_som</a>(<span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; inconnue)<span class="keyword"> const</span>
<a name="l01228"></a>01228 <span class="keyword"></span>{
<a name="l01229"></a>01229   <span class="keyword">const</span> <a class="code" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a>&amp; zone_VEF = <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a8d6cebdde81108b4c492d8af3d6d60ae">zone_VEFPreP1B</a>();
<a name="l01230"></a>01230   <span class="keyword">const</span> <a class="code" href="classZone__Cl__VEF.html">Zone_Cl_VEF</a>&amp; zone_Cl_VEF = <a class="code" href="classOp__Diff__VEF__base.html#a721f395a27f12a95882437c614e16a7d">la_zcl_vef</a>.<a class="code" href="classRef__Zone__Cl__VEF.html#a0970d7253def65ad4f0c5ce1830fd243">valeur</a>();
<a name="l01231"></a>01231   <span class="keyword">const</span> <a class="code" href="classZone.html" title="classe Zone Une Zone est un maillage compose d&#39;un ensemble d&#39;elements geometriques de meme type...">Zone</a>&amp; zone = zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>();
<a name="l01232"></a>01232   <span class="keyword">const</span> <a class="code" href="classDomaine.html" title="Classe Domaine Un Domaine represente le domaine (spatial) de resolution d&#39;un Probleme. Un Domaine a un Nom, il est constitue d&#39;une ou plusieurs Zone qui peuvent etre eventuellement decoupees en Sous_Zone. Un Domaine porte l&#39;ensemble des sommets utilises par ses Zones. On peut vouloir resoudre des problemes de type different sur plusieurs domaines, geometriquement les domaines sont alors couples par des surfaces qu&#39;on appelle Raccord.">Domaine</a>&amp; dom=zone.<a class="code" href="classZone.html#a379ad2206b5a13a4f4f3df6d44c7546a" title="Renvoie le domaine dont la zone fait partie. (version const)">domaine</a>();
<a name="l01233"></a>01233 
<a name="l01234"></a>01234   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; face_sommets=zone_VEF.<a class="code" href="classZone__VF.html#a298e73b18e17da55f421b1fb0879bd46" title="renvoie le numero du ieme sommet de la face num_face.">face_sommets</a>();
<a name="l01235"></a>01235 
<a name="l01236"></a>01236   <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; face_normales=zone_VEF.<a class="code" href="classZone__VEF.html#a5742d75972e4846bf9fbb6ed5715053e">face_normales</a>();
<a name="l01237"></a>01237 
<a name="l01238"></a>01238   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_som_face=zone_VEF.<a class="code" href="classZone__VF.html#a990808f967f351edbb83ff11d60b7445" title="renvoie le nombre de sommets par face. Rque : on a suppose que toutes les faces avait le meme nombre ...">nb_som_face</a>();
<a name="l01239"></a>01239   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_bords=zone_VEF.<a class="code" href="classZone__dis__base.html#af22167d614644f55591a29c77eb1c009">nb_front_Cl</a>();
<a name="l01240"></a>01240 
<a name="l01241"></a>01241   <span class="keywordtype">int</span> face=0;
<a name="l01242"></a>01242   <span class="keywordtype">int</span> som=0,som_loc=0;
<a name="l01243"></a>01243   <span class="keywordtype">int</span> n_bord=0,ind_face=0;
<a name="l01244"></a>01244   <span class="keywordtype">int</span> num1=0,num2=0;
<a name="l01245"></a>01245   <span class="keywordtype">int</span> compi=0,compj=0;
<a name="l01246"></a>01246 
<a name="l01247"></a>01247   <span class="keywordtype">double</span> surface=0.;
<a name="l01248"></a>01248   <span class="keywordtype">double</span> Text=0.;
<a name="l01249"></a>01249   <span class="keywordtype">double</span> coeff_conv=1.;
<a name="l01250"></a>01250   <span class="keywordflow">if</span> (<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#acbd7461fb999d27a3c1ba0320f13563a">alphaE</a>) coeff_conv=1.-<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a463106e6f719474777b7cc6c5e813354">convexite_</a>;
<a name="l01251"></a>01251 
<a name="l01252"></a>01252   <span class="keywordflow">for</span> (n_bord=0; n_bord&lt;nb_bords; n_bord++)
<a name="l01253"></a>01253     {
<a name="l01254"></a>01254       <span class="keyword">const</span> <a class="code" href="classCond__lim.html" title="classe Cond_lim Classe generique servant a representer n&#39;importe quelle classe derivee de la classe C...">Cond_lim</a>&amp; la_cl = zone_Cl_VEF.<a class="code" href="classZone__Cl__dis__base.html#af75e0ed7786863e4d333bfb29d67c323" title="Renvoie la i-ieme condition aux limites. (version const)">les_conditions_limites</a>(n_bord);
<a name="l01255"></a>01255       <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp; le_bord = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>,la_cl.<a class="code" href="classCond__lim.html#a5b2d24809cee07727006a891d4ce8d22" title="Appel a l&#39;objet sous-jacent Renvoie la frontiere discretisee associee a la condition aux limites...">frontiere_dis</a>());
<a name="l01256"></a>01256 
<a name="l01257"></a>01257       num1=0;
<a name="l01258"></a>01258       num2=le_bord.<a class="code" href="classFront__VF.html#a341e2fcb5117b96e745fd7078ba86bab" title="Nombre de faces reelles du bord.">nb_faces</a>();
<a name="l01259"></a>01259 
<a name="l01260"></a>01260       <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classNeumann__paroi.html" title="Classe Neumann_paroi Cette condition limite correspond a un flux impose pour l&#39;equation de transport ...">Neumann_paroi</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>()))
<a name="l01261"></a>01261         {
<a name="l01262"></a>01262           <span class="keyword">const</span> <a class="code" href="classNeumann__paroi.html" title="Classe Neumann_paroi Cette condition limite correspond a un flux impose pour l&#39;equation de transport ...">Neumann_paroi</a>&amp; la_cl_paroi=
<a name="l01263"></a>01263             <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classNeumann__paroi.html" title="Classe Neumann_paroi Cette condition limite correspond a un flux impose pour l&#39;equation de transport ...">Neumann_paroi</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>());
<a name="l01264"></a>01264 
<a name="l01265"></a>01265           <span class="keywordflow">for</span> (ind_face=num1; ind_face&lt;num2; ind_face++)
<a name="l01266"></a>01266             {
<a name="l01267"></a>01267               face=le_bord.<a class="code" href="classFront__VF.html#a3402a19d7e54ed797d2b18e9a47ead1e" title="Renvoie le numero de face de la ieme face du bord.">num_face</a>(ind_face);
<a name="l01268"></a>01268               surface=zone_VEF.<a class="code" href="classZone__VF.html#a40c3382b189a4fc508cf1c3e37b04b21">face_surfaces</a>(face);
<a name="l01269"></a>01269 
<a name="l01270"></a>01270               <span class="keywordflow">for</span> (compi=0; compi&lt;<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#aecdf3d22b30add37625e545939004844">dim_ch_</a>; compi++)
<a name="l01271"></a>01271                 <a class="code" href="classOperateur__base.html#a451f51b41518ddbc0d3f586a8177d319" title="Tableau contenant les flux sur les bords de l&#39;operateur.">flux_bords_</a>(face,compi)=coeff_conv*
<a name="l01272"></a>01272                                         la_cl_paroi.<a class="code" href="classNeumann__paroi.html#a76b977c608b621e7dd7106401ab44936" title="Renvoie la valeur du flux impose sur la i-eme composante du champ representant le flux a la frontiere...">flux_impose</a>(ind_face,compi)*
<a name="l01273"></a>01273                                         surface;
<a name="l01274"></a>01274             }
<a name="l01275"></a>01275         }
<a name="l01276"></a>01276       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classEchange__externe__impose.html" title="Classe Echange_externe_impose: Cette classe represente le cas particulier de la classe Echange_impose...">Echange_externe_impose</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>()))
<a name="l01277"></a>01277         {
<a name="l01278"></a>01278           <span class="keyword">const</span> <a class="code" href="classEchange__externe__impose.html" title="Classe Echange_externe_impose: Cette classe represente le cas particulier de la classe Echange_impose...">Echange_externe_impose</a>&amp; la_cl_paroi=
<a name="l01279"></a>01279             <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classEchange__externe__impose.html" title="Classe Echange_externe_impose: Cette classe represente le cas particulier de la classe Echange_impose...">Echange_externe_impose</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>());
<a name="l01280"></a>01280 
<a name="l01281"></a>01281           <span class="keywordflow">for</span> (ind_face=num1; ind_face&lt;num2; ind_face++)
<a name="l01282"></a>01282             {
<a name="l01283"></a>01283               face=le_bord.<a class="code" href="classFront__VF.html#a3402a19d7e54ed797d2b18e9a47ead1e" title="Renvoie le numero de face de la ieme face du bord.">num_face</a>(ind_face);
<a name="l01284"></a>01284               surface=zone_VEF.<a class="code" href="classZone__VF.html#a40c3382b189a4fc508cf1c3e37b04b21">face_surfaces</a>(face);
<a name="l01285"></a>01285 
<a name="l01286"></a>01286               <span class="keywordflow">for</span> (compi=0; compi&lt;<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#aecdf3d22b30add37625e545939004844">dim_ch_</a>; compi++)
<a name="l01287"></a>01287                 {
<a name="l01288"></a>01288                   Text=la_cl_paroi.<a class="code" href="classEchange__impose__base.html#ad2ef464a05e25ba48a5c75af56352440" title="Renvoie la valeur de la temperature imposee sur la i-eme composante du champ de frontiere.">T_ext</a>(ind_face,compi);
<a name="l01289"></a>01289 
<a name="l01290"></a>01290                   <a class="code" href="classOperateur__base.html#a451f51b41518ddbc0d3f586a8177d319" title="Tableau contenant les flux sur les bords de l&#39;operateur.">flux_bords_</a>(face,compi)=coeff_conv*la_cl_paroi.<a class="code" href="classEchange__impose__base.html#a1e75de051a3afbd228374eabc5be9485" title="Renvoie la valeur du coefficient d&#39;echange de chaleur impose sur la i-eme composante du champ de fron...">h_imp</a>(ind_face,compi)*surface;
<a name="l01291"></a>01291                   <a class="code" href="classOperateur__base.html#a451f51b41518ddbc0d3f586a8177d319" title="Tableau contenant les flux sur les bords de l&#39;operateur.">flux_bords_</a>(face,compi)*=(Text-inconnue[face*dim_ch_+compi]);
<a name="l01292"></a>01292                 }
<a name="l01293"></a>01293             }
<a name="l01294"></a>01294         }
<a name="l01295"></a>01295       <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( <a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classNeumann__homogene.html" title="Classe Neumann_homogene Cette classe est la classe de base de la hierarchie des conditions aux limite...">Neumann_homogene</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>()) ||
<a name="l01296"></a>01296                 <a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classNeumann__sortie__libre.html" title="classe Neumann_sortie_libre Cette classe represente une frontiere ouverte sans vitesse imposee Pour l...">Neumann_sortie_libre</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>()) ||
<a name="l01297"></a>01297                 <a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classSymetrie.html" title="classe Symetrie Sur les faces de symetrie on a les proprietes suivantes: - composante normale de la v...">Symetrie</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>())
<a name="l01298"></a>01298               )
<a name="l01299"></a>01299         {
<a name="l01300"></a>01300           <span class="keywordflow">for</span> (ind_face=num1; ind_face&lt;num2; ind_face++)
<a name="l01301"></a>01301             {
<a name="l01302"></a>01302               face=le_bord.<a class="code" href="classFront__VF.html#a3402a19d7e54ed797d2b18e9a47ead1e" title="Renvoie le numero de face de la ieme face du bord.">num_face</a>(ind_face);
<a name="l01303"></a>01303 
<a name="l01304"></a>01304               <span class="keywordflow">for</span> (compi=0; compi&lt;<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#aecdf3d22b30add37625e545939004844">dim_ch_</a>; compi++)
<a name="l01305"></a>01305                 <a class="code" href="classOperateur__base.html#a451f51b41518ddbc0d3f586a8177d319" title="Tableau contenant les flux sur les bords de l&#39;operateur.">flux_bords_</a>(face,compi)=0.;
<a name="l01306"></a>01306             }
<a name="l01307"></a>01307         }
<a name="l01308"></a>01308       <span class="keywordflow">else</span>
<a name="l01309"></a>01309         {
<a name="l01310"></a>01310           <span class="keywordflow">for</span> (ind_face=num1; ind_face&lt;num2; ind_face++)
<a name="l01311"></a>01311             {
<a name="l01312"></a>01312               face=le_bord.<a class="code" href="classFront__VF.html#a3402a19d7e54ed797d2b18e9a47ead1e" title="Renvoie le numero de face de la ieme face du bord.">num_face</a>(ind_face);
<a name="l01313"></a>01313 
<a name="l01314"></a>01314 <span class="comment">// le coefficient de convexite est deja dans gradient_p1_</span>
<a name="l01315"></a>01315               <span class="keywordflow">for</span> (som_loc=0; som_loc&lt;nb_som_face; som_loc++)
<a name="l01316"></a>01316                 {
<a name="l01317"></a>01317                   som=face_sommets(face,som_loc);
<a name="l01318"></a>01318                   som=dom.<a class="code" href="classDomaine.html#a37cc657f1907d53b0d5a573da862af80">get_renum_som_perio</a>(som);
<a name="l01319"></a>01319 
<a name="l01320"></a>01320                   <span class="keywordflow">for</span> (compi=0; compi&lt;<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#aecdf3d22b30add37625e545939004844">dim_ch_</a>; compi++)
<a name="l01321"></a>01321                     <span class="keywordflow">for</span> (compj=0; compj&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; compj++)
<a name="l01322"></a>01322                       <a class="code" href="classOperateur__base.html#a451f51b41518ddbc0d3f586a8177d319" title="Tableau contenant les flux sur les bords de l&#39;operateur.">flux_bords_</a>(face,compi)+=<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a076341d23635d4ad7b0bfc19a03a7722">gradient_p1_</a>(som,compi,compj)*
<a name="l01323"></a>01323                                                face_normales(face,compj);
<a name="l01324"></a>01324                 }
<a name="l01325"></a>01325 
<a name="l01326"></a>01326               <span class="keywordflow">for</span> (compi=0; compi&lt;<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#aecdf3d22b30add37625e545939004844">dim_ch_</a>; compi++)
<a name="l01327"></a>01327                 <a class="code" href="classOperateur__base.html#a451f51b41518ddbc0d3f586a8177d319" title="Tableau contenant les flux sur les bords de l&#39;operateur.">flux_bords_</a>(face,compi)/=nb_som_face;
<a name="l01328"></a>01328             }
<a name="l01329"></a>01329         }
<a name="l01330"></a>01330     }<span class="comment">//fin du for sur n_bord</span>
<a name="l01331"></a>01331 }
<a name="l01332"></a>01332 
<a name="l01333"></a>01333 <span class="comment">// Fonction qui calcule le flux aux bords du domaine</span>
<a name="l01334"></a><a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a4de56f9fddbc93956dc697dcf31f7583">01334</a> <span class="keywordtype">void</span> <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a4de56f9fddbc93956dc697dcf31f7583">Op_Diff_VEFP1NCP1B_Face::calculer_flux_bords_aretes</a>(<span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; inconnue)<span class="keyword"> const</span>
<a name="l01335"></a>01335 <span class="keyword"></span>{
<a name="l01336"></a>01336   <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a>&lt;&lt;<span class="stringliteral">&quot;Op_Dift_VEF_P1NCP1B_Face::calculer_flux_bords_aretes() not coded&quot;</span>&lt;&lt;<a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
<a name="l01337"></a>01337   <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a>&lt;&lt;<span class="stringliteral">&quot;Exit&quot;</span>&lt;&lt;finl;
<a name="l01338"></a>01338   <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">exit</a>();
<a name="l01339"></a>01339 }
<a name="l01340"></a>01340 
<a name="l01341"></a>01341 
<a name="l01342"></a>01342 <span class="comment">//</span>
<a name="l01343"></a>01343 <span class="comment">// Fonctions pour l&#39;implicite</span>
<a name="l01344"></a>01344 <span class="comment">//</span>
<a name="l01345"></a>01345 <span class="keywordtype">void</span> <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a10ecca846d2d639a93ea61ed25cc5458">Op_Diff_VEFP1NCP1B_Face::</a>
<a name="l01346"></a><a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a10ecca846d2d639a93ea61ed25cc5458">01346</a> <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a10ecca846d2d639a93ea61ed25cc5458">ajouter_contribution_elem</a>(<span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; inconnue,<span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; porosite_face,
<a name="l01347"></a>01347                           <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; nu,<a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; matrice)<span class="keyword"> const</span>
<a name="l01348"></a>01348 <span class="keyword"></span>{
<a name="l01349"></a>01349   <span class="keyword">const</span> <a class="code" href="classZone__Cl__VEF.html">Zone_Cl_VEF</a>&amp; zone_Cl_VEF = <a class="code" href="classOp__Diff__VEF__base.html#a721f395a27f12a95882437c614e16a7d">la_zcl_vef</a>.<a class="code" href="classRef__Zone__Cl__VEF.html#a0970d7253def65ad4f0c5ce1830fd243">valeur</a>();
<a name="l01350"></a>01350   <span class="keyword">const</span> <a class="code" href="classZone__VEF.html" title="class Zone_VEF Classe instanciable qui derive de Zone_VF. Cette classe contient les informations geom...">Zone_VEF</a>&amp; zone_VEF = <a class="code" href="classOp__Diff__VEF__base.html#aadbdb144954bc7c5b56862e1f9f3c7f9">la_zone_vef</a>.<a class="code" href="classRef__Zone__VEF.html#aafd9a5ee1a76f290c9c6b5447b0c8d30">valeur</a>();
<a name="l01351"></a>01351   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; elem_faces = zone_VEF.<a class="code" href="classZone__VF.html#a067e462dcd3ab92b0f6d945b19e4eb37" title="renvoie le numero de le ieme face de la maille num_elem la facon dont ces faces sont numerotees est l...">elem_faces</a>();
<a name="l01352"></a>01352   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; face_voisins = zone_VEF.<a class="code" href="classZone__VF.html#a49d4322f5585a8fa95748ca785b70702" title="renvoie l&#39;element voisin de numface dans la direction i. i=0 : dans le sens oppose de l&#39;axe orthogona...">face_voisins</a>();
<a name="l01353"></a>01353 
<a name="l01354"></a>01354 <span class="comment">// int nb_faces_tot = zone_VEF.nb_faces_tot();</span>
<a name="l01355"></a>01355   <span class="keywordtype">int</span> nb_faces=zone_VEF.<a class="code" href="classZone__VF.html#aede27992d9f2eedd52c24d4a80ff7ffb" title="renvoie le nombre global de faces.">nb_faces</a>();
<a name="l01356"></a>01356   <span class="keywordtype">int</span> nb_faces_elem = zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#a548fbc7518be2f122b1a5c9589a443c2" title="Renvoie le nombre de face de type i des elements geometriques constituants la zone. Ex: les objets de la classe Prisme ont 2 types de faces: triangle ou quadrangle.">nb_faces_elem</a>();
<a name="l01357"></a>01357   <span class="keywordtype">int</span> nb_comp = inconnue.<a class="code" href="classDoubleVect.html#ab02d01cd1bdab66fbd66f9a47cc29e10">line_size</a>();
<a name="l01358"></a>01358 
<a name="l01359"></a>01359   <span class="keywordtype">int</span> i,j,num_face;
<a name="l01360"></a>01360   <span class="keywordtype">int</span> elem1,elem2;
<a name="l01361"></a>01361 
<a name="l01362"></a>01362   <span class="keywordtype">double</span> val;
<a name="l01363"></a>01363   <span class="keywordtype">double</span> <a class="code" href="Champ__P1iP1B__implementation_8cpp.html#aa8c8f49390c3cf7c702d71a71bc977e3">coeff</a>=1./<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a90fc51e82567cc139118e78417436ef2">coeff_</a>;
<a name="l01364"></a>01364   <span class="keywordflow">if</span> (<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a0ff8784f933eedd5f6a52db444f2d71b">alphaS</a>) coeff*=<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a463106e6f719474777b7cc6c5e813354">convexite_</a>;
<a name="l01365"></a>01365 
<a name="l01366"></a>01366   <span class="keywordtype">int</span> nb_bords=zone_VEF.<a class="code" href="classZone__dis__base.html#af22167d614644f55591a29c77eb1c009">nb_front_Cl</a>();
<a name="l01367"></a>01367   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> n_bord=0; n_bord&lt;nb_bords; n_bord++)
<a name="l01368"></a>01368     {
<a name="l01369"></a>01369       <span class="keyword">const</span> <a class="code" href="classCond__lim.html" title="classe Cond_lim Classe generique servant a representer n&#39;importe quelle classe derivee de la classe C...">Cond_lim</a>&amp; la_cl = zone_Cl_VEF.<a class="code" href="classZone__Cl__dis__base.html#af75e0ed7786863e4d333bfb29d67c323" title="Renvoie la i-ieme condition aux limites. (version const)">les_conditions_limites</a>(n_bord);
<a name="l01370"></a>01370       <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp; le_bord = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>,la_cl.<a class="code" href="classCond__lim.html#a5b2d24809cee07727006a891d4ce8d22" title="Appel a l&#39;objet sous-jacent Renvoie la frontiere discretisee associee a la condition aux limites...">frontiere_dis</a>());
<a name="l01371"></a>01371       <span class="keywordtype">int</span> num1 = le_bord.<a class="code" href="classFront__VF.html#a4986f0c65653fe9eb40bbbff5a97bf16" title="Numero de la premiere face du bord dans la liste des faces.">num_premiere_face</a>();
<a name="l01372"></a>01372       <span class="keywordtype">int</span> num2 = num1 + le_bord.<a class="code" href="classFront__VF.html#a341e2fcb5117b96e745fd7078ba86bab" title="Nombre de faces reelles du bord.">nb_faces</a>();
<a name="l01373"></a>01373 
<a name="l01374"></a>01374       <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>()))
<a name="l01375"></a>01375         {
<a name="l01376"></a>01376           <span class="keyword">const</span> <a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>&amp; la_cl_perio = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>());
<a name="l01377"></a>01377           <span class="keywordtype">int</span> fac_asso;
<a name="l01378"></a>01378           <span class="keywordflow">for</span> (num_face=num1; num_face&lt;num2; num_face++)
<a name="l01379"></a>01379             {
<a name="l01380"></a>01380               elem1 = face_voisins(num_face,0);
<a name="l01381"></a>01381               fac_asso = la_cl_perio.<a class="code" href="classPeriodique.html#a207b86556f199a63ea059b841851ca6a">face_associee</a>(num_face-num1)+num1;
<a name="l01382"></a>01382 
<a name="l01383"></a>01383 <span class="comment">// A la fin de la boucle :</span>
<a name="l01384"></a>01384 <span class="comment">// si ok=1, alors num_face appartient bien a elem1</span>
<a name="l01385"></a>01385 <span class="comment">// si ok=0, alors num_face n&#39;appartient pas a elem1 et</span>
<a name="l01386"></a>01386 <span class="comment">// fac_asso appartient a elem1</span>
<a name="l01387"></a>01387               <span class="keywordtype">int</span> ok=1;
<a name="l01388"></a>01388               <span class="keywordtype">int</span> fac_loc=0;
<a name="l01389"></a>01389               <span class="keywordflow">while</span> ((fac_loc&lt;nb_faces_elem) &amp;&amp; (elem_faces(elem1,fac_loc)!=num_face)) fac_loc++;
<a name="l01390"></a>01390               <span class="keywordflow">if</span> (fac_loc==nb_faces_elem) ok=0;
<a name="l01391"></a>01391 
<a name="l01392"></a>01392               <span class="keywordflow">for</span> (i=0; i&lt;nb_faces_elem; i++)
<a name="l01393"></a>01393                 <span class="keywordflow">if</span> ( ( (j= elem_faces(elem1,i)) &gt; num_face ) &amp;&amp; (j != fac_asso ) )
<a name="l01394"></a>01394                   {
<a name="l01395"></a>01395                     val = <a class="code" href="classOp__Diff__VEF__base.html#a0abfc9af2ce36a8d4554d0e679940257">viscA</a>(num_face,j,elem1,nu(elem1));
<a name="l01396"></a>01396 
<a name="l01397"></a>01397 <span class="comment">// int fac_loc=0;</span>
<a name="l01398"></a>01398 <span class="comment">// while ((fac_loc&lt;nb_faces_elem) &amp;&amp; (elem_faces(elem1,fac_loc)!=num_face)) fac_loc++;</span>
<a name="l01399"></a>01399 <span class="comment">// if (fac_loc==nb_faces_elem) ok=0;</span>
<a name="l01400"></a>01400 
<a name="l01401"></a>01401                     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> nc=0; nc&lt;nb_comp; nc++)
<a name="l01402"></a>01402                       {
<a name="l01403"></a>01403                         <span class="keywordtype">int</span> n0=num_face*nb_comp+nc;
<a name="l01404"></a>01404                         <span class="keywordtype">int</span> j0=j*nb_comp+nc;
<a name="l01405"></a>01405 
<a name="l01406"></a>01406                         matrice(n0,n0)+=val*porosite_face(num_face)*<a class="code" href="Champ__P1iP1B__implementation_8cpp.html#aa8c8f49390c3cf7c702d71a71bc977e3">coeff</a>;
<a name="l01407"></a>01407                         matrice(n0,j0)-=val*porosite_face(j)*<a class="code" href="Champ__P1iP1B__implementation_8cpp.html#aa8c8f49390c3cf7c702d71a71bc977e3">coeff</a>;
<a name="l01408"></a>01408 
<a name="l01409"></a>01409                         <span class="keywordflow">if</span> (!ok) n0=fac_asso*nb_comp+nc;
<a name="l01410"></a>01410                         <span class="keywordflow">if</span> (j&lt;nb_faces)
<a name="l01411"></a>01411                           {
<a name="l01412"></a>01412                             matrice(j0,n0)-=val*porosite_face((n0-nc)/nb_comp)*<a class="code" href="Champ__P1iP1B__implementation_8cpp.html#aa8c8f49390c3cf7c702d71a71bc977e3">coeff</a>;
<a name="l01413"></a>01413                             matrice(j0,j0)+=val*porosite_face(j)*<a class="code" href="Champ__P1iP1B__implementation_8cpp.html#aa8c8f49390c3cf7c702d71a71bc977e3">coeff</a>;
<a name="l01414"></a>01414                           }
<a name="l01415"></a>01415 
<a name="l01416"></a>01416                       }
<a name="l01417"></a>01417                   }
<a name="l01418"></a>01418 
<a name="l01419"></a>01419 <span class="comment">// Deuxieme element</span>
<a name="l01420"></a>01420               elem2 = face_voisins(num_face,1);
<a name="l01421"></a>01421 
<a name="l01422"></a>01422               <span class="keywordflow">for</span> (i=0; i&lt;nb_faces_elem; i++)
<a name="l01423"></a>01423                 <span class="keywordflow">if</span> ( ( (j= elem_faces(elem2,i)) &gt; num_face ) &amp;&amp; (j != fac_asso ) )
<a name="l01424"></a>01424                   {
<a name="l01425"></a>01425                     val = <a class="code" href="classOp__Diff__VEF__base.html#a0abfc9af2ce36a8d4554d0e679940257">viscA</a>(num_face,j,elem2,nu(elem2));
<a name="l01426"></a>01426 
<a name="l01427"></a>01427                     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> nc=0; nc&lt;nb_comp; nc++)
<a name="l01428"></a>01428                       {
<a name="l01429"></a>01429                         <span class="keywordtype">int</span> n0=num_face*nb_comp+nc;
<a name="l01430"></a>01430                         <span class="keywordtype">int</span> j0=j*nb_comp+nc;
<a name="l01431"></a>01431 
<a name="l01432"></a>01432                         matrice(n0,n0)+=val*porosite_face(num_face)*<a class="code" href="Champ__P1iP1B__implementation_8cpp.html#aa8c8f49390c3cf7c702d71a71bc977e3">coeff</a>;
<a name="l01433"></a>01433                         matrice(n0,j0)-=val*porosite_face(j)*<a class="code" href="Champ__P1iP1B__implementation_8cpp.html#aa8c8f49390c3cf7c702d71a71bc977e3">coeff</a>;
<a name="l01434"></a>01434                       }
<a name="l01435"></a>01435                   }
<a name="l01436"></a>01436 
<a name="l01437"></a>01437             }<span class="comment">//fin du for sur &quot;num_face&quot;</span>
<a name="l01438"></a>01438         }
<a name="l01439"></a>01439       <span class="keywordflow">else</span>
<a name="l01440"></a>01440         {
<a name="l01441"></a>01441           <span class="keywordflow">for</span> (num_face=num1; num_face&lt;num2; num_face++)
<a name="l01442"></a>01442             {
<a name="l01443"></a>01443               elem1 = face_voisins(num_face,0);
<a name="l01444"></a>01444 
<a name="l01445"></a>01445               <span class="keywordflow">for</span> (i=0; i&lt;nb_faces_elem; i++)
<a name="l01446"></a>01446                 <span class="keywordflow">if</span> ( (j= elem_faces(elem1,i)) &gt; num_face )
<a name="l01447"></a>01447                   {
<a name="l01448"></a>01448                     val = <a class="code" href="classOp__Diff__VEF__base.html#a0abfc9af2ce36a8d4554d0e679940257">viscA</a>(num_face,j,elem1,nu(elem1));
<a name="l01449"></a>01449                     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> nc=0; nc&lt;nb_comp; nc++)
<a name="l01450"></a>01450                       {
<a name="l01451"></a>01451                         <span class="keywordtype">int</span> n0=num_face*nb_comp+nc;
<a name="l01452"></a>01452                         <span class="keywordtype">int</span> j0=j*nb_comp+nc;
<a name="l01453"></a>01453 
<a name="l01454"></a>01454                         matrice(n0,n0)+=val*porosite_face(num_face)*<a class="code" href="Champ__P1iP1B__implementation_8cpp.html#aa8c8f49390c3cf7c702d71a71bc977e3">coeff</a>;
<a name="l01455"></a>01455                         matrice(n0,j0)-=val*porosite_face(j)*<a class="code" href="Champ__P1iP1B__implementation_8cpp.html#aa8c8f49390c3cf7c702d71a71bc977e3">coeff</a>;
<a name="l01456"></a>01456                         <span class="keywordflow">if</span> (j&lt;nb_faces) <span class="comment">//necessaire ????</span>
<a name="l01457"></a>01457                           {
<a name="l01458"></a>01458                             matrice(j0,n0)-=val*porosite_face(num_face)*<a class="code" href="Champ__P1iP1B__implementation_8cpp.html#aa8c8f49390c3cf7c702d71a71bc977e3">coeff</a>;
<a name="l01459"></a>01459                             matrice(j0,j0)+=val*porosite_face(j)*<a class="code" href="Champ__P1iP1B__implementation_8cpp.html#aa8c8f49390c3cf7c702d71a71bc977e3">coeff</a>;
<a name="l01460"></a>01460                           }
<a name="l01461"></a>01461 
<a name="l01462"></a>01462                       }
<a name="l01463"></a>01463                   }
<a name="l01464"></a>01464             }
<a name="l01465"></a>01465         }
<a name="l01466"></a>01466     }
<a name="l01467"></a>01467 
<a name="l01468"></a>01468 <span class="comment">// On ne remplit que les lignes reelles</span>
<a name="l01469"></a>01469   <span class="keywordflow">for</span> (num_face=zone_VEF.<a class="code" href="classZone__VF.html#a12869806fa4834aca8f2964e16509dfd" title="une face est interne ssi elle separe deux elements. renvoie le numero de la premiere face interne...">premiere_face_int</a>(); num_face&lt;nb_faces; num_face++)
<a name="l01470"></a>01470     {
<a name="l01471"></a>01471       elem1 = face_voisins(num_face,0);
<a name="l01472"></a>01472       elem2 = face_voisins(num_face,1);
<a name="l01473"></a>01473 
<a name="l01474"></a>01474       <span class="keywordflow">for</span> (i=0; i&lt;nb_faces_elem; i++)
<a name="l01475"></a>01475         {
<a name="l01476"></a>01476           <span class="keywordflow">if</span> ( (j=elem_faces(elem1,i)) &gt; num_face )
<a name="l01477"></a>01477             {
<a name="l01478"></a>01478               val = <a class="code" href="classOp__Diff__VEF__base.html#a0abfc9af2ce36a8d4554d0e679940257">viscA</a>(num_face,j,elem1,nu(elem1));
<a name="l01479"></a>01479               <span class="keywordflow">for</span> (<span class="keywordtype">int</span> nc=0; nc&lt;nb_comp; nc++)
<a name="l01480"></a>01480                 {
<a name="l01481"></a>01481                   <span class="keywordtype">int</span> n0=num_face*nb_comp+nc;
<a name="l01482"></a>01482                   <span class="keywordtype">int</span> j0=j*nb_comp+nc;
<a name="l01483"></a>01483 
<a name="l01484"></a>01484                   matrice(n0,n0)+=val*porosite_face(num_face)*<a class="code" href="Champ__P1iP1B__implementation_8cpp.html#aa8c8f49390c3cf7c702d71a71bc977e3">coeff</a>;
<a name="l01485"></a>01485                   matrice(n0,j0)-=val*porosite_face(j)*<a class="code" href="Champ__P1iP1B__implementation_8cpp.html#aa8c8f49390c3cf7c702d71a71bc977e3">coeff</a>;
<a name="l01486"></a>01486                   <span class="keywordflow">if</span> (j&lt;nb_faces)
<a name="l01487"></a>01487                     {
<a name="l01488"></a>01488                       matrice(j0,n0)-=val*porosite_face(num_face)*<a class="code" href="Champ__P1iP1B__implementation_8cpp.html#aa8c8f49390c3cf7c702d71a71bc977e3">coeff</a>;
<a name="l01489"></a>01489                       matrice(j0,j0)+=val*porosite_face(j)*<a class="code" href="Champ__P1iP1B__implementation_8cpp.html#aa8c8f49390c3cf7c702d71a71bc977e3">coeff</a>;
<a name="l01490"></a>01490                     }
<a name="l01491"></a>01491                 }
<a name="l01492"></a>01492             }
<a name="l01493"></a>01493 
<a name="l01494"></a>01494 <span class="comment">// if (elem2!=-1) //test non necessaire car la face est reelle</span>
<a name="l01495"></a>01495           <span class="keywordflow">if</span> ( (j=elem_faces(elem2,i)) &gt; num_face )
<a name="l01496"></a>01496             {
<a name="l01497"></a>01497               val= <a class="code" href="classOp__Diff__VEF__base.html#a0abfc9af2ce36a8d4554d0e679940257">viscA</a>(num_face,j,elem2,nu(elem2));
<a name="l01498"></a>01498               <span class="keywordflow">for</span> (<span class="keywordtype">int</span> nc=0; nc&lt;nb_comp; nc++)
<a name="l01499"></a>01499                 {
<a name="l01500"></a>01500                   <span class="keywordtype">int</span> n0=num_face*nb_comp+nc;
<a name="l01501"></a>01501                   <span class="keywordtype">int</span> j0=j*nb_comp+nc;
<a name="l01502"></a>01502 
<a name="l01503"></a>01503                   matrice(n0,n0)+=val*porosite_face(num_face)*<a class="code" href="Champ__P1iP1B__implementation_8cpp.html#aa8c8f49390c3cf7c702d71a71bc977e3">coeff</a>;
<a name="l01504"></a>01504                   matrice(n0,j0)-=val*porosite_face(j)*<a class="code" href="Champ__P1iP1B__implementation_8cpp.html#aa8c8f49390c3cf7c702d71a71bc977e3">coeff</a>;
<a name="l01505"></a>01505                   <span class="keywordflow">if</span> (j&lt;nb_faces)
<a name="l01506"></a>01506                     {
<a name="l01507"></a>01507                       matrice(j0,n0)-=val*porosite_face(num_face)*<a class="code" href="Champ__P1iP1B__implementation_8cpp.html#aa8c8f49390c3cf7c702d71a71bc977e3">coeff</a>;
<a name="l01508"></a>01508                       matrice(j0,j0)+=val*porosite_face(j)*<a class="code" href="Champ__P1iP1B__implementation_8cpp.html#aa8c8f49390c3cf7c702d71a71bc977e3">coeff</a>;
<a name="l01509"></a>01509                     }
<a name="l01510"></a>01510 
<a name="l01511"></a>01511                 }
<a name="l01512"></a>01512             }
<a name="l01513"></a>01513         }
<a name="l01514"></a>01514     }
<a name="l01515"></a>01515 }
<a name="l01516"></a>01516 
<a name="l01517"></a>01517 <span class="keywordtype">void</span> <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#ae979dc98da8579c81ed4abf017475277">Op_Diff_VEFP1NCP1B_Face::</a>
<a name="l01518"></a><a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#ae979dc98da8579c81ed4abf017475277">01518</a> <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#ae979dc98da8579c81ed4abf017475277">ajouter_contribution_som</a>(<span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; inconnue,<span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; porosite_face,
<a name="l01519"></a>01519                          <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; nu_som,<a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; matrice)<span class="keyword"> const</span>
<a name="l01520"></a>01520 <span class="keyword"></span>{
<a name="l01521"></a>01521   <span class="keyword">const</span> <a class="code" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a>&amp; zone_VEF=<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a8d6cebdde81108b4c492d8af3d6d60ae">zone_VEFPreP1B</a>();
<a name="l01522"></a>01522   <span class="keyword">const</span> <a class="code" href="classZone__Cl__VEF.html">Zone_Cl_VEF</a>&amp; zone_Cl_VEF = <a class="code" href="classOp__Diff__VEF__base.html#a721f395a27f12a95882437c614e16a7d">la_zcl_vef</a>.<a class="code" href="classRef__Zone__Cl__VEF.html#a0970d7253def65ad4f0c5ce1830fd243">valeur</a>();
<a name="l01523"></a>01523 
<a name="l01524"></a>01524   <a class="code" href="classIntVect.html">IntVect</a> liste_som(<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>+2);<span class="comment">//pour triangles et tetraedres</span>
<a name="l01525"></a>01525 
<a name="l01526"></a>01526   <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a> gradient0(<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>,<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>+2);
<a name="l01527"></a>01527   <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a> gradient1(<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>);
<a name="l01528"></a>01528 
<a name="l01529"></a>01529   <span class="keyword">const</span> <span class="keywordtype">int</span> premiere_face_int=zone_VEF.<a class="code" href="classZone__VF.html#a12869806fa4834aca8f2964e16509dfd" title="une face est interne ssi elle separe deux elements. renvoie le numero de la premiere face interne...">premiere_face_int</a>();
<a name="l01530"></a>01530   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_faces=zone_VEF.<a class="code" href="classZone__VF.html#aede27992d9f2eedd52c24d4a80ff7ffb" title="renvoie le nombre global de faces.">nb_faces</a>();
<a name="l01531"></a>01531   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_faces_tot=zone_VEF.<a class="code" href="classZone__VF.html#a50fd21c9535680489015a3c8b88c685a" title="renvoie le nombre total de faces. C&#39;est-a-dire faces reelles + faces virtuelles">nb_faces_tot</a>();
<a name="l01532"></a>01532   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_bords=zone_VEF.<a class="code" href="classZone__dis__base.html#af22167d614644f55591a29c77eb1c009">nb_front_Cl</a>();
<a name="l01533"></a>01533 
<a name="l01534"></a>01534   <span class="keywordtype">int</span> face=0;
<a name="l01535"></a>01535   <span class="keywordtype">int</span> ind_face=0;
<a name="l01536"></a>01536   <span class="keywordtype">int</span> n_bord=0;
<a name="l01537"></a>01537   <span class="keywordtype">int</span> num1=0,num2=0;
<a name="l01538"></a>01538 
<a name="l01539"></a>01539   <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a> coeff_perio(nb_faces_tot);
<a name="l01540"></a>01540   coeff_perio=1.;
<a name="l01541"></a>01541   <span class="keywordflow">for</span> (n_bord=0; n_bord&lt;nb_bords; n_bord++)
<a name="l01542"></a>01542     {
<a name="l01543"></a>01543       <span class="keyword">const</span> <a class="code" href="classCond__lim.html" title="classe Cond_lim Classe generique servant a representer n&#39;importe quelle classe derivee de la classe C...">Cond_lim</a>&amp; la_cl = zone_Cl_VEF.<a class="code" href="classZone__Cl__dis__base.html#af75e0ed7786863e4d333bfb29d67c323" title="Renvoie la i-ieme condition aux limites. (version const)">les_conditions_limites</a>(n_bord);
<a name="l01544"></a>01544       <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp; le_bord = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>,la_cl.<a class="code" href="classCond__lim.html#a5b2d24809cee07727006a891d4ce8d22" title="Appel a l&#39;objet sous-jacent Renvoie la frontiere discretisee associee a la condition aux limites...">frontiere_dis</a>());
<a name="l01545"></a>01545       num1=0;
<a name="l01546"></a>01546       num2=le_bord.<a class="code" href="classFront__VF.html#aed4006d91bf2ef3af2b9f7933d863a09" title="Nombre de faces reelles et virtuelles du bord.">nb_faces_tot</a>();
<a name="l01547"></a>01547 
<a name="l01548"></a>01548       <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>()))
<a name="l01549"></a>01549         <span class="keywordflow">for</span> (ind_face=num1; ind_face&lt;num2; ind_face++)
<a name="l01550"></a>01550           {
<a name="l01551"></a>01551             face=le_bord.<a class="code" href="classFront__VF.html#a3402a19d7e54ed797d2b18e9a47ead1e" title="Renvoie le numero de face de la ieme face du bord.">num_face</a>(ind_face);
<a name="l01552"></a>01552             coeff_perio(face)=0.5;
<a name="l01553"></a>01553           }
<a name="l01554"></a>01554     }
<a name="l01555"></a>01555 
<a name="l01556"></a>01556 <span class="comment">// </span>
<a name="l01557"></a>01557 <span class="comment">// Partie P1 du laplacien discret :</span>
<a name="l01558"></a>01558 <span class="comment">// on tourne sur les lignes donc nous n&#39;avons</span>
<a name="l01559"></a>01559 <span class="comment">// besoin que de remplir les lignes reelles.</span>
<a name="l01560"></a>01560 <span class="comment">// ATTENTION : le remplissage des lignes reelles</span>
<a name="l01561"></a>01561 <span class="comment">// peut induire le calcul d&#39;un coefficient</span>
<a name="l01562"></a>01562 <span class="comment">// lie a une colonne virtuelle</span>
<a name="l01563"></a>01563 <span class="comment">// </span>
<a name="l01564"></a>01564 
<a name="l01565"></a>01565   <span class="comment">/* Faces internes */</span>
<a name="l01566"></a>01566   <span class="keywordflow">for</span> (face=premiere_face_int; face&lt;nb_faces; face++)
<a name="l01567"></a>01567     {
<a name="l01568"></a>01568       <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a79b580276b1459de268cf4cfcd7b0665">coeff_matrice_som</a>(face,liste_som,
<a name="l01569"></a>01569                         gradient0,gradient1,
<a name="l01570"></a>01570                         porosite_face,nu_som,
<a name="l01571"></a>01571                         coeff_perio,matrice);
<a name="l01572"></a>01572     }
<a name="l01573"></a>01573 
<a name="l01574"></a>01574   <span class="keywordflow">for</span> (n_bord=0; n_bord&lt;nb_bords; n_bord++)
<a name="l01575"></a>01575     {
<a name="l01576"></a>01576       <span class="keyword">const</span> <a class="code" href="classCond__lim.html" title="classe Cond_lim Classe generique servant a representer n&#39;importe quelle classe derivee de la classe C...">Cond_lim</a>&amp; la_cl = zone_Cl_VEF.<a class="code" href="classZone__Cl__dis__base.html#af75e0ed7786863e4d333bfb29d67c323" title="Renvoie la i-ieme condition aux limites. (version const)">les_conditions_limites</a>(n_bord);
<a name="l01577"></a>01577       <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp; le_bord = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>,la_cl.<a class="code" href="classCond__lim.html#a5b2d24809cee07727006a891d4ce8d22" title="Appel a l&#39;objet sous-jacent Renvoie la frontiere discretisee associee a la condition aux limites...">frontiere_dis</a>());
<a name="l01578"></a>01578       num1=0;
<a name="l01579"></a>01579       num2=le_bord.<a class="code" href="classFront__VF.html#a341e2fcb5117b96e745fd7078ba86bab" title="Nombre de faces reelles du bord.">nb_faces</a>();
<a name="l01580"></a>01580 
<a name="l01581"></a>01581       <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>()))
<a name="l01582"></a>01582         {
<a name="l01583"></a>01583           <span class="keyword">const</span> <a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>&amp; la_cl_perio = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>());
<a name="l01584"></a>01584           <span class="keywordtype">int</span> faceAss=0;
<a name="l01585"></a>01585 
<a name="l01586"></a>01586           <span class="keywordflow">for</span> (ind_face=num1; ind_face&lt;num2; ind_face++)
<a name="l01587"></a>01587             {
<a name="l01588"></a>01588               face=le_bord.<a class="code" href="classFront__VF.html#a3402a19d7e54ed797d2b18e9a47ead1e" title="Renvoie le numero de face de la ieme face du bord.">num_face</a>(ind_face);
<a name="l01589"></a>01589               faceAss=le_bord.<a class="code" href="classFront__VF.html#a3402a19d7e54ed797d2b18e9a47ead1e" title="Renvoie le numero de face de la ieme face du bord.">num_face</a>(la_cl_perio.<a class="code" href="classPeriodique.html#a207b86556f199a63ea059b841851ca6a">face_associee</a>(ind_face));
<a name="l01590"></a>01590 
<a name="l01591"></a>01591 <span class="comment">// On prend la plus petite des faces pour etre sur de n&#39;oublier</span>
<a name="l01592"></a>01592 <span class="comment">// aucune face de bord</span>
<a name="l01593"></a>01593               <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a706eb5baeef2cc4eddd0ea43fb11f73c">coeff_matrice_som_perio</a>(face,faceAss,liste_som,
<a name="l01594"></a>01594                                       gradient0,gradient1,
<a name="l01595"></a>01595                                       porosite_face,nu_som,
<a name="l01596"></a>01596                                       coeff_perio,matrice);
<a name="l01597"></a>01597 
<a name="l01598"></a>01598             }
<a name="l01599"></a>01599         }
<a name="l01600"></a>01600       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classSymetrie.html" title="classe Symetrie Sur les faces de symetrie on a les proprietes suivantes: - composante normale de la v...">Symetrie</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>()))
<a name="l01601"></a>01601         <span class="keywordflow">for</span> (ind_face=num1; ind_face&lt;num2; ind_face++)
<a name="l01602"></a>01602           {
<a name="l01603"></a>01603             face=le_bord.<a class="code" href="classFront__VF.html#a3402a19d7e54ed797d2b18e9a47ead1e" title="Renvoie le numero de face de la ieme face du bord.">num_face</a>(ind_face);
<a name="l01604"></a>01604 
<a name="l01605"></a>01605             <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a40963269ea0e5eee6023bcef8f4b5162">coeff_matrice_som_symetrie</a>(face,liste_som,
<a name="l01606"></a>01606                                        gradient0,gradient1,
<a name="l01607"></a>01607                                        porosite_face,nu_som,
<a name="l01608"></a>01608                                        coeff_perio,matrice);
<a name="l01609"></a>01609           }
<a name="l01610"></a>01610 
<a name="l01611"></a>01611       <span class="keywordflow">else</span>
<a name="l01612"></a>01612         <span class="keywordflow">for</span> (ind_face=num1; ind_face&lt;num2; ind_face++)
<a name="l01613"></a>01613           {
<a name="l01614"></a>01614             face=le_bord.<a class="code" href="classFront__VF.html#a3402a19d7e54ed797d2b18e9a47ead1e" title="Renvoie le numero de face de la ieme face du bord.">num_face</a>(ind_face);
<a name="l01615"></a>01615 
<a name="l01616"></a>01616             <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#ac34445bdca920e590a8d84ca2c1099ff">coeff_matrice_som_CL</a>(face,liste_som,
<a name="l01617"></a>01617                                  gradient0,gradient1,
<a name="l01618"></a>01618                                  porosite_face,nu_som,
<a name="l01619"></a>01619                                  coeff_perio,matrice);
<a name="l01620"></a>01620           }
<a name="l01621"></a>01621     }
<a name="l01622"></a>01622 }
<a name="l01623"></a>01623 
<a name="l01624"></a>01624 <span class="keywordtype">void</span> <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#aca6b2aa015252cbc0919765131e98774">Op_Diff_VEFP1NCP1B_Face::</a>
<a name="l01625"></a><a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#aca6b2aa015252cbc0919765131e98774">01625</a> <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#aca6b2aa015252cbc0919765131e98774">ajouter_contribution_aretes</a>(<span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; inconnue,<span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; porosite_face,
<a name="l01626"></a>01626                             <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; nu,<a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; matrice)<span class="keyword"> const</span>
<a name="l01627"></a>01627 <span class="keyword"></span>{
<a name="l01628"></a>01628 }
<a name="l01629"></a>01629 
<a name="l01630"></a>01630 <span class="comment">// Fonction qui calcule les coefficients de la matrice pour une face</span>
<a name="l01631"></a>01631 <span class="comment">// INTERNE.</span>
<a name="l01632"></a>01632 <span class="keywordtype">void</span> <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a79b580276b1459de268cf4cfcd7b0665">Op_Diff_VEFP1NCP1B_Face::</a>
<a name="l01633"></a><a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a79b580276b1459de268cf4cfcd7b0665">01633</a> <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a79b580276b1459de268cf4cfcd7b0665">coeff_matrice_som</a>(<span class="keyword">const</span> <span class="keywordtype">int</span>&amp; face,<a class="code" href="classIntVect.html">IntVect</a>&amp; liste_som,
<a name="l01634"></a>01634                   <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; gradient0, <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; gradient1,
<a name="l01635"></a>01635                   <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; porosite_face,<span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; nu_som,
<a name="l01636"></a>01636                   <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; coeff_perio,<a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; matrice)<span class="keyword"> const</span>
<a name="l01637"></a>01637 <span class="keyword"></span>{
<a name="l01638"></a>01638   <span class="keyword">const</span> <a class="code" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a>&amp; zone_VEF=<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a8d6cebdde81108b4c492d8af3d6d60ae">zone_VEFPreP1B</a>();
<a name="l01639"></a>01639 
<a name="l01640"></a>01640   <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; tab1=matrice.<a class="code" href="classMatrice__Morse.html#a79b4e334152850bd36e53478debf3061">get_tab1</a>();
<a name="l01641"></a>01641   <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; tab2=matrice.<a class="code" href="classMatrice__Morse.html#a787b5a63f27063f9c891243d8f188cda">get_tab2</a>();
<a name="l01642"></a>01642 
<a name="l01643"></a>01643   <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; volume_aux_sommets=zone_VEF.<a class="code" href="classZone__VEF__PreP1b.html#ac8282d378ae480144d75129df4a8c55c">volume_aux_sommets</a>();
<a name="l01644"></a>01644 
<a name="l01645"></a>01645   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_faces=zone_VEF.<a class="code" href="classZone__VF.html#aede27992d9f2eedd52c24d4a80ff7ffb" title="renvoie le nombre global de faces.">nb_faces</a>();
<a name="l01646"></a>01646 
<a name="l01647"></a>01647   <span class="keywordtype">int</span> face_C=0;
<a name="l01648"></a>01648   <span class="keywordtype">int</span> face2=0,face2_C=0;
<a name="l01649"></a>01649   <span class="keywordtype">int</span> som_loc=0,som=0;
<a name="l01650"></a>01650   <span class="keywordtype">int</span> som_loc0=0,som_loc1=0;
<a name="l01651"></a>01651   <span class="keywordtype">int</span> debut=0,size=0;
<a name="l01652"></a>01652   <span class="keywordtype">int</span> compi=0,compj=0;
<a name="l01653"></a>01653   <span class="keywordtype">int</span> elem0=0,elem1=0;
<a name="l01654"></a>01654   <span class="keywordtype">int</span> i=0;
<a name="l01655"></a>01655   <span class="keywordtype">int</span> nnz=0;
<a name="l01656"></a>01656 
<a name="l01657"></a>01657   <span class="keywordtype">double</span> coeff_som=0.,coeff_mat=0.;
<a name="l01658"></a>01658   <span class="keywordtype">double</span> coeff_diff=0.;
<a name="l01659"></a>01659   <span class="keywordtype">double</span> psc=0.;
<a name="l01660"></a>01660   <span class="keywordtype">double</span> delta=<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a34224d2dfd0ecb6877ce4dc87abff1f0">decentrage_</a>;
<a name="l01661"></a>01661 
<a name="l01662"></a>01662   <span class="keywordtype">double</span> coeff_conv=1.;
<a name="l01663"></a>01663   <span class="keywordflow">if</span> (<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#acbd7461fb999d27a3c1ba0320f13563a">alphaE</a>) coeff_conv=(1.-<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a463106e6f719474777b7cc6c5e813354">convexite_</a>);
<a name="l01664"></a>01664 
<a name="l01665"></a>01665 <span class="comment">// Quelques verifications</span>
<a name="l01666"></a>01666   assert(gradient0.<a class="code" href="classDoubleTab.html#ae6dda48778e7107e1beb723beef1f75b" title="Returns the number of dimensions of the array (&gt;= 1)">nb_dim</a>()==2);
<a name="l01667"></a>01667   assert(gradient0.<a class="code" href="classDoubleTab.html#ac3805e2637a3b880ba2d3e650c69dac4" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(0)==<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>);
<a name="l01668"></a>01668   assert(gradient0.<a class="code" href="classDoubleTab.html#ac3805e2637a3b880ba2d3e650c69dac4" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(1)==<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>+2);
<a name="l01669"></a>01669   assert(gradient1.<a class="code" href="classDoubleTab.html#ae6dda48778e7107e1beb723beef1f75b" title="Returns the number of dimensions of the array (&gt;= 1)">nb_dim</a>()==1);
<a name="l01670"></a>01670   assert(gradient1.<a class="code" href="classDoubleTab.html#ac3805e2637a3b880ba2d3e650c69dac4" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(0)==<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>);
<a name="l01671"></a>01671   assert(liste_som.<a class="code" href="classIntVect.html#ad90cfd411cbbd631ccf1935bb36f7c40" title="Identique a size_reelle()">size</a>()==<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>+2);
<a name="l01672"></a>01672 
<a name="l01673"></a>01673 <span class="comment">// </span>
<a name="l01674"></a>01674 <span class="comment">// Partie P1 du laplacien discret</span>
<a name="l01675"></a>01675 <span class="comment">// </span>
<a name="l01676"></a>01676   liste_som=-1;
<a name="l01677"></a>01677   gradient0=0.;
<a name="l01678"></a>01678   <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a37f70143adef3313705fb8583168fd93">gradient_som</a>(face,nnz,liste_som,gradient0);
<a name="l01679"></a>01679 
<a name="l01680"></a>01680 
<a name="l01681"></a>01681   <span class="comment">/* gradient associe a &quot;face&quot; : calcul du coefficient */</span>
<a name="l01682"></a>01682   <span class="comment">/* diagonal de la matrice associee a l&#39;inconnue */</span>
<a name="l01683"></a>01683   coeff_mat=0.;
<a name="l01684"></a>01684   <span class="keywordflow">for</span> (som_loc=0; som_loc&lt;nnz; som_loc++)
<a name="l01685"></a>01685     {
<a name="l01686"></a>01686       som=liste_som(som_loc);
<a name="l01687"></a>01687       coeff_som=volume_aux_sommets(som)*<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a90fc51e82567cc139118e78417436ef2">coeff_</a>;
<a name="l01688"></a>01688 
<a name="l01689"></a>01689       psc=0.;
<a name="l01690"></a>01690       <span class="keywordflow">for</span> (compj=0; compj&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; compj++)
<a name="l01691"></a>01691         psc+=gradient0(compj,som_loc)
<a name="l01692"></a>01692              *gradient0(compj,som_loc);
<a name="l01693"></a>01693 
<a name="l01694"></a>01694       psc*=coeff_som;
<a name="l01695"></a>01695       psc*=nu_som(som);
<a name="l01696"></a>01696 
<a name="l01697"></a>01697       coeff_mat+=psc;
<a name="l01698"></a>01698     }
<a name="l01699"></a>01699   coeff_mat*=coeff_conv;
<a name="l01700"></a>01700 
<a name="l01701"></a>01701   <span class="keywordflow">for</span> (compi=0; compi&lt;<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#aecdf3d22b30add37625e545939004844">dim_ch_</a>; compi++)
<a name="l01702"></a>01702     {
<a name="l01703"></a>01703       face_C=face*dim_ch_+compi;
<a name="l01704"></a>01704       matrice(face_C,face_C)+=coeff_mat;
<a name="l01705"></a>01705     }
<a name="l01706"></a>01706 
<a name="l01707"></a>01707 
<a name="l01708"></a>01708   <span class="comment">/* calcul des coefficients extra-diagonaux de la matrice laplacien */</span>
<a name="l01709"></a>01709   <span class="comment">/* la matrice etant diagonale par bloc, on effectue le calcul du */</span>
<a name="l01710"></a>01710   <span class="comment">/* produit scalaire une seule fois avant de l&#39;affecter aux differentes */</span>
<a name="l01711"></a>01711   <span class="comment">/* composantes de la matrice */</span>
<a name="l01712"></a>01712   face_C=face*<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#aecdf3d22b30add37625e545939004844">dim_ch_</a>;
<a name="l01713"></a>01713   debut=tab1[face_C]-1;
<a name="l01714"></a>01714   size=tab1[face_C+1]-tab1[face_C];
<a name="l01715"></a>01715 
<a name="l01716"></a>01716   <span class="keywordflow">for</span> (i=1; i&lt;size; i++) <span class="comment">//i=0 -&gt; face2_C=face_C -&gt; deja rempli</span>
<a name="l01717"></a>01717     {
<a name="l01718"></a>01718       face2_C=tab2[debut+i]-1;
<a name="l01719"></a>01719       face2=face2_C/<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#aecdf3d22b30add37625e545939004844">dim_ch_</a>;<span class="comment">//division euclidienne</span>
<a name="l01720"></a>01720 
<a name="l01721"></a>01721       <span class="keywordflow">if</span> (face2&gt;face)<span class="comment">//pour la symetrie de l&#39;operateur</span>
<a name="l01722"></a>01722         {
<a name="l01723"></a>01723           coeff_mat=0.;
<a name="l01724"></a>01724           <span class="keywordflow">for</span> (som_loc=0; som_loc&lt;nnz; som_loc++)
<a name="l01725"></a>01725             {
<a name="l01726"></a>01726               som=liste_som(som_loc);
<a name="l01727"></a>01727               coeff_som=volume_aux_sommets(som)*<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a90fc51e82567cc139118e78417436ef2">coeff_</a>;
<a name="l01728"></a>01728               <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a035d8cdf71b99212df20fadc0f2c997e">isInStencil</a>(face2,som,elem0,som_loc0,elem1,som_loc1);
<a name="l01729"></a>01729 
<a name="l01730"></a>01730               <span class="keywordflow">if</span> (elem0!=-1)<span class="comment">//les deux faces se &quot;voient&quot;</span>
<a name="l01731"></a>01731                 {
<a name="l01732"></a>01732                   assert(som_loc0!=-1);
<a name="l01733"></a>01733                   gradient1=0.;
<a name="l01734"></a>01734                   <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a37f70143adef3313705fb8583168fd93">gradient_som</a>(face2,som,elem0,som_loc0,elem1,som_loc1,gradient1);
<a name="l01735"></a>01735 
<a name="l01736"></a>01736                   psc=0.;
<a name="l01737"></a>01737                   <span class="keywordflow">for</span> (compj=0; compj&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; compj++)
<a name="l01738"></a>01738                     psc+=gradient0(compj,som_loc)
<a name="l01739"></a>01739                          *gradient1(compj);
<a name="l01740"></a>01740 
<a name="l01741"></a>01741                   psc*=coeff_som;
<a name="l01742"></a>01742                   psc*=nu_som(som);
<a name="l01743"></a>01743                   coeff_mat+=psc;
<a name="l01744"></a>01744                 }
<a name="l01745"></a>01745             }
<a name="l01746"></a>01746           coeff_mat*=coeff_conv;
<a name="l01747"></a>01747           coeff_diff=-1.*delta*<a class="code" href="Op__Diff__VEFP1NCP1B__Face_8cpp.html#a4e834c1f122c09080eb7a6226c2f1185">maximum</a>(0.,coeff_mat);
<a name="l01748"></a>01748           coeff_mat+=coeff_diff;
<a name="l01749"></a>01749 
<a name="l01750"></a>01750           <span class="keywordflow">for</span> (compi=0; compi&lt;<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#aecdf3d22b30add37625e545939004844">dim_ch_</a>; compi++)
<a name="l01751"></a>01751             {
<a name="l01752"></a>01752               face_C=face*dim_ch_+compi;
<a name="l01753"></a>01753               face2_C=face2*dim_ch_+compi;
<a name="l01754"></a>01754 
<a name="l01755"></a>01755               matrice(face_C,face2_C)+=coeff_mat*coeff_perio(face2);
<a name="l01756"></a>01756               matrice(face_C,face_C)-=coeff_diff*coeff_perio(face2);
<a name="l01757"></a>01757               <span class="keywordflow">if</span> (face2&lt;nb_faces)
<a name="l01758"></a>01758                 {
<a name="l01759"></a>01759                   matrice(face2_C,face_C)+=coeff_mat;
<a name="l01760"></a>01760                   matrice(face2_C,face2_C)-=coeff_diff;
<a name="l01761"></a>01761                 }
<a name="l01762"></a>01762             }
<a name="l01763"></a>01763         }
<a name="l01764"></a>01764     }
<a name="l01765"></a>01765 }
<a name="l01766"></a>01766 
<a name="l01767"></a>01767 <span class="comment">// Fonction qui calcule les coefficients de la matrice pour une face</span>
<a name="l01768"></a>01768 <span class="comment">// de BORD qui n&#39;est ni periodique ni symetrique.</span>
<a name="l01769"></a>01769 <span class="keywordtype">void</span> <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#ac34445bdca920e590a8d84ca2c1099ff">Op_Diff_VEFP1NCP1B_Face::</a>
<a name="l01770"></a><a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#ac34445bdca920e590a8d84ca2c1099ff">01770</a> <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#ac34445bdca920e590a8d84ca2c1099ff">coeff_matrice_som_CL</a>(<span class="keyword">const</span> <span class="keywordtype">int</span>&amp; face,<a class="code" href="classIntVect.html">IntVect</a>&amp; liste_som,
<a name="l01771"></a>01771                      <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; gradient0, <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; gradient1,
<a name="l01772"></a>01772                      <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; porosite_face,<span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; nu_som,
<a name="l01773"></a>01773                      <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; coeff_perio,<a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; matrice)<span class="keyword"> const</span>
<a name="l01774"></a>01774 <span class="keyword"></span>{
<a name="l01775"></a>01775   <span class="keyword">const</span> <a class="code" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a>&amp; zone_VEF=<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a8d6cebdde81108b4c492d8af3d6d60ae">zone_VEFPreP1B</a>();
<a name="l01776"></a>01776 
<a name="l01777"></a>01777   <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; tab1=matrice.<a class="code" href="classMatrice__Morse.html#a79b4e334152850bd36e53478debf3061">get_tab1</a>();
<a name="l01778"></a>01778   <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; tab2=matrice.<a class="code" href="classMatrice__Morse.html#a787b5a63f27063f9c891243d8f188cda">get_tab2</a>();
<a name="l01779"></a>01779 
<a name="l01780"></a>01780   <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; volume_aux_sommets=zone_VEF.<a class="code" href="classZone__VEF__PreP1b.html#ac8282d378ae480144d75129df4a8c55c">volume_aux_sommets</a>();
<a name="l01781"></a>01781 
<a name="l01782"></a>01782   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_faces=zone_VEF.<a class="code" href="classZone__VF.html#aede27992d9f2eedd52c24d4a80ff7ffb" title="renvoie le nombre global de faces.">nb_faces</a>();
<a name="l01783"></a>01783 
<a name="l01784"></a>01784   <span class="keywordtype">int</span> face_C=0;
<a name="l01785"></a>01785   <span class="keywordtype">int</span> face2=0,face2_C=0;
<a name="l01786"></a>01786   <span class="keywordtype">int</span> som_loc=0,som=0;
<a name="l01787"></a>01787   <span class="keywordtype">int</span> som_loc0=0,som_loc1=0;
<a name="l01788"></a>01788   <span class="keywordtype">int</span> debut=0,size=0;
<a name="l01789"></a>01789   <span class="keywordtype">int</span> compi=0,compj=0;
<a name="l01790"></a>01790   <span class="keywordtype">int</span> elem0=0,elem1=0;
<a name="l01791"></a>01791   <span class="keywordtype">int</span> i=0;
<a name="l01792"></a>01792   <span class="keywordtype">int</span> nnz=0;
<a name="l01793"></a>01793 
<a name="l01794"></a>01794   <span class="keywordtype">double</span> coeff_som=0.,coeff_mat=0.;
<a name="l01795"></a>01795   <span class="keywordtype">double</span> coeff_diff=0.;
<a name="l01796"></a>01796   <span class="keywordtype">double</span> psc=0.;
<a name="l01797"></a>01797   <span class="keywordtype">double</span> delta=<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a34224d2dfd0ecb6877ce4dc87abff1f0">decentrage_</a>;
<a name="l01798"></a>01798 
<a name="l01799"></a>01799   <span class="keywordtype">double</span> coeff_conv=1.;
<a name="l01800"></a>01800   <span class="keywordflow">if</span> (<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#acbd7461fb999d27a3c1ba0320f13563a">alphaE</a>) coeff_conv=(1.-<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a463106e6f719474777b7cc6c5e813354">convexite_</a>);
<a name="l01801"></a>01801 
<a name="l01802"></a>01802 <span class="comment">// Quelques verifications</span>
<a name="l01803"></a>01803   assert(gradient0.<a class="code" href="classDoubleTab.html#ae6dda48778e7107e1beb723beef1f75b" title="Returns the number of dimensions of the array (&gt;= 1)">nb_dim</a>()==2);
<a name="l01804"></a>01804   assert(gradient0.<a class="code" href="classDoubleTab.html#ac3805e2637a3b880ba2d3e650c69dac4" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(0)==<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>);
<a name="l01805"></a>01805   assert(gradient0.<a class="code" href="classDoubleTab.html#ac3805e2637a3b880ba2d3e650c69dac4" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(1)==<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>+2);
<a name="l01806"></a>01806   assert(gradient1.<a class="code" href="classDoubleTab.html#ae6dda48778e7107e1beb723beef1f75b" title="Returns the number of dimensions of the array (&gt;= 1)">nb_dim</a>()==1);
<a name="l01807"></a>01807   assert(gradient1.<a class="code" href="classDoubleTab.html#ac3805e2637a3b880ba2d3e650c69dac4" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(0)==<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>);
<a name="l01808"></a>01808   assert(liste_som.<a class="code" href="classIntVect.html#ad90cfd411cbbd631ccf1935bb36f7c40" title="Identique a size_reelle()">size</a>()==<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>+2);
<a name="l01809"></a>01809 
<a name="l01810"></a>01810 <span class="comment">// </span>
<a name="l01811"></a>01811 <span class="comment">// Partie P1 du laplacien discret</span>
<a name="l01812"></a>01812 <span class="comment">// </span>
<a name="l01813"></a>01813   liste_som=-1;
<a name="l01814"></a>01814   gradient0=0.;
<a name="l01815"></a>01815   <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a253bedb1323fa89e08a8d88e2be8798d">gradient_som_CL</a>(face,nnz,liste_som,gradient0);
<a name="l01816"></a>01816 
<a name="l01817"></a>01817 
<a name="l01818"></a>01818   <span class="comment">/* gradient associe a &quot;face&quot; : calcul du coefficient */</span>
<a name="l01819"></a>01819   <span class="comment">/* diagonal de la matrice associee a l&#39;inconnue */</span>
<a name="l01820"></a>01820   coeff_mat=0.;
<a name="l01821"></a>01821   <span class="keywordflow">for</span> (som_loc=0; som_loc&lt;nnz; som_loc++)
<a name="l01822"></a>01822     {
<a name="l01823"></a>01823       som=liste_som(som_loc);
<a name="l01824"></a>01824       coeff_som=volume_aux_sommets(som)*<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a90fc51e82567cc139118e78417436ef2">coeff_</a>;
<a name="l01825"></a>01825 
<a name="l01826"></a>01826       psc=0.;
<a name="l01827"></a>01827       <span class="keywordflow">for</span> (compj=0; compj&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; compj++)
<a name="l01828"></a>01828         psc+=gradient0(compj,som_loc)
<a name="l01829"></a>01829              *gradient0(compj,som_loc);
<a name="l01830"></a>01830 
<a name="l01831"></a>01831       psc*=coeff_som;
<a name="l01832"></a>01832       psc*=nu_som(som);
<a name="l01833"></a>01833 
<a name="l01834"></a>01834       coeff_mat+=psc;
<a name="l01835"></a>01835     }
<a name="l01836"></a>01836   coeff_mat*=coeff_conv;
<a name="l01837"></a>01837 
<a name="l01838"></a>01838   <span class="keywordflow">for</span> (compi=0; compi&lt;<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#aecdf3d22b30add37625e545939004844">dim_ch_</a>; compi++)
<a name="l01839"></a>01839     {
<a name="l01840"></a>01840       face_C=face*dim_ch_+compi;
<a name="l01841"></a>01841       matrice(face_C,face_C)+=coeff_mat;
<a name="l01842"></a>01842     }
<a name="l01843"></a>01843 
<a name="l01844"></a>01844 
<a name="l01845"></a>01845   <span class="comment">/* calcul des coefficients extra-diagonaux de la matrice laplacien */</span>
<a name="l01846"></a>01846   <span class="comment">/* la matrice etant diagonale par bloc, on effectue le calcul du */</span>
<a name="l01847"></a>01847   <span class="comment">/* produit scalaire une seule fois avant de l&#39;affecter aux differentes */</span>
<a name="l01848"></a>01848   <span class="comment">/* composantes de la matrice */</span>
<a name="l01849"></a>01849   face_C=face*<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#aecdf3d22b30add37625e545939004844">dim_ch_</a>;
<a name="l01850"></a>01850   debut=tab1[face_C]-1;
<a name="l01851"></a>01851   size=tab1[face_C+1]-tab1[face_C];
<a name="l01852"></a>01852 
<a name="l01853"></a>01853   <span class="keywordflow">for</span> (i=1; i&lt;size; i++) <span class="comment">//i=0 -&gt; face2_C=face_C -&gt; deja rempli</span>
<a name="l01854"></a>01854     {
<a name="l01855"></a>01855       face2_C=tab2[debut+i]-1;
<a name="l01856"></a>01856       face2=face2_C/<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#aecdf3d22b30add37625e545939004844">dim_ch_</a>;<span class="comment">//division euclidienne</span>
<a name="l01857"></a>01857 
<a name="l01858"></a>01858       <span class="keywordflow">if</span> (face2&gt;face)<span class="comment">//pour la symetrie de l&#39;operateur</span>
<a name="l01859"></a>01859         {
<a name="l01860"></a>01860           coeff_mat=0.;
<a name="l01861"></a>01861           <span class="keywordflow">for</span> (som_loc=0; som_loc&lt;nnz; som_loc++)
<a name="l01862"></a>01862             {
<a name="l01863"></a>01863               som=liste_som(som_loc);
<a name="l01864"></a>01864               coeff_som=volume_aux_sommets(som)*<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a90fc51e82567cc139118e78417436ef2">coeff_</a>;
<a name="l01865"></a>01865               <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a035d8cdf71b99212df20fadc0f2c997e">isInStencil</a>(face2,som,elem0,som_loc0,elem1,som_loc1);
<a name="l01866"></a>01866 
<a name="l01867"></a>01867               <span class="keywordflow">if</span> (elem0!=-1)<span class="comment">//les deux faces se &quot;voient&quot;</span>
<a name="l01868"></a>01868                 {
<a name="l01869"></a>01869                   assert(som_loc0!=-1);
<a name="l01870"></a>01870                   gradient1=0.;
<a name="l01871"></a>01871                   <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a37f70143adef3313705fb8583168fd93">gradient_som</a>(face2,som,elem0,som_loc0,elem1,som_loc1,gradient1);
<a name="l01872"></a>01872 
<a name="l01873"></a>01873                   psc=0.;
<a name="l01874"></a>01874                   <span class="keywordflow">for</span> (compj=0; compj&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; compj++)
<a name="l01875"></a>01875                     psc+=gradient0(compj,som_loc)
<a name="l01876"></a>01876                          *gradient1(compj);
<a name="l01877"></a>01877 
<a name="l01878"></a>01878                   psc*=coeff_som;
<a name="l01879"></a>01879                   psc*=nu_som(som);
<a name="l01880"></a>01880                   coeff_mat+=psc;
<a name="l01881"></a>01881                 }
<a name="l01882"></a>01882             }
<a name="l01883"></a>01883           coeff_mat*=coeff_conv;
<a name="l01884"></a>01884           coeff_diff=-1.*delta*<a class="code" href="Op__Diff__VEFP1NCP1B__Face_8cpp.html#a4e834c1f122c09080eb7a6226c2f1185">maximum</a>(0.,coeff_mat);
<a name="l01885"></a>01885           coeff_mat+=coeff_diff;
<a name="l01886"></a>01886 
<a name="l01887"></a>01887           <span class="keywordflow">for</span> (compi=0; compi&lt;<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#aecdf3d22b30add37625e545939004844">dim_ch_</a>; compi++)
<a name="l01888"></a>01888             {
<a name="l01889"></a>01889               face_C=face*dim_ch_+compi;
<a name="l01890"></a>01890               face2_C=face2*dim_ch_+compi;
<a name="l01891"></a>01891 
<a name="l01892"></a>01892               matrice(face_C,face2_C)+=coeff_mat*coeff_perio(face2);
<a name="l01893"></a>01893               matrice(face_C,face_C)-=coeff_diff*coeff_perio(face2);
<a name="l01894"></a>01894               <span class="keywordflow">if</span> (face2&lt;nb_faces)
<a name="l01895"></a>01895                 {
<a name="l01896"></a>01896                   matrice(face2_C,face_C)+=coeff_mat;
<a name="l01897"></a>01897                   matrice(face2_C,face2_C)-=coeff_diff;
<a name="l01898"></a>01898                 }
<a name="l01899"></a>01899             }
<a name="l01900"></a>01900         }
<a name="l01901"></a>01901     }
<a name="l01902"></a>01902 }
<a name="l01903"></a>01903 
<a name="l01904"></a>01904 <span class="comment">// Fonction qui calcule les coefficients de la matrice pour une face</span>
<a name="l01905"></a>01905 <span class="comment">// de BORD qui est une face de SYMETRIE.</span>
<a name="l01906"></a>01906 <span class="keywordtype">void</span> <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a40963269ea0e5eee6023bcef8f4b5162">Op_Diff_VEFP1NCP1B_Face::</a>
<a name="l01907"></a><a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a40963269ea0e5eee6023bcef8f4b5162">01907</a> <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a40963269ea0e5eee6023bcef8f4b5162">coeff_matrice_som_symetrie</a>(<span class="keyword">const</span> <span class="keywordtype">int</span>&amp; face,<a class="code" href="classIntVect.html">IntVect</a>&amp; liste_som,
<a name="l01908"></a>01908                            <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; gradient0, <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; gradient1,
<a name="l01909"></a>01909                            <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; porosite_face,<span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; nu_som,
<a name="l01910"></a>01910                            <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; coeff_perio,<a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; matrice)<span class="keyword"> const</span>
<a name="l01911"></a>01911 <span class="keyword"></span>{
<a name="l01912"></a>01912   <span class="keyword">const</span> <a class="code" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a>&amp; zone_VEF=<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a8d6cebdde81108b4c492d8af3d6d60ae">zone_VEFPreP1B</a>();
<a name="l01913"></a>01913 
<a name="l01914"></a>01914   <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; tab1=matrice.<a class="code" href="classMatrice__Morse.html#a79b4e334152850bd36e53478debf3061">get_tab1</a>();
<a name="l01915"></a>01915   <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; tab2=matrice.<a class="code" href="classMatrice__Morse.html#a787b5a63f27063f9c891243d8f188cda">get_tab2</a>();
<a name="l01916"></a>01916 
<a name="l01917"></a>01917   <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; volume_aux_sommets=zone_VEF.<a class="code" href="classZone__VEF__PreP1b.html#ac8282d378ae480144d75129df4a8c55c">volume_aux_sommets</a>();
<a name="l01918"></a>01918 
<a name="l01919"></a>01919   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_faces=zone_VEF.<a class="code" href="classZone__VF.html#aede27992d9f2eedd52c24d4a80ff7ffb" title="renvoie le nombre global de faces.">nb_faces</a>();
<a name="l01920"></a>01920 
<a name="l01921"></a>01921   <span class="keywordtype">int</span> face_C=0;
<a name="l01922"></a>01922   <span class="keywordtype">int</span> face2=0,face2_C=0;
<a name="l01923"></a>01923   <span class="keywordtype">int</span> som_loc=0,som=0;
<a name="l01924"></a>01924   <span class="keywordtype">int</span> som_loc0=0,som_loc1=0;
<a name="l01925"></a>01925   <span class="keywordtype">int</span> debut=0,size=0;
<a name="l01926"></a>01926   <span class="keywordtype">int</span> compi=0,compj=0;
<a name="l01927"></a>01927   <span class="keywordtype">int</span> elem0=0,elem1=0;
<a name="l01928"></a>01928   <span class="keywordtype">int</span> i=0;
<a name="l01929"></a>01929   <span class="keywordtype">int</span> nnz=0;
<a name="l01930"></a>01930 
<a name="l01931"></a>01931   <span class="keywordtype">double</span> coeff_som=0.,coeff_mat=0.;
<a name="l01932"></a>01932   <span class="keywordtype">double</span> coeff_diff=0.;
<a name="l01933"></a>01933   <span class="keywordtype">double</span> psc=0.;
<a name="l01934"></a>01934   <span class="keywordtype">double</span> delta=<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a34224d2dfd0ecb6877ce4dc87abff1f0">decentrage_</a>;
<a name="l01935"></a>01935 
<a name="l01936"></a>01936   <span class="keywordtype">double</span> coeff_conv=1.;
<a name="l01937"></a>01937   <span class="keywordflow">if</span> (<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#acbd7461fb999d27a3c1ba0320f13563a">alphaE</a>) coeff_conv=(1.-<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a463106e6f719474777b7cc6c5e813354">convexite_</a>);
<a name="l01938"></a>01938 
<a name="l01939"></a>01939 <span class="comment">// Quelques verifications</span>
<a name="l01940"></a>01940   assert(gradient0.<a class="code" href="classDoubleTab.html#ae6dda48778e7107e1beb723beef1f75b" title="Returns the number of dimensions of the array (&gt;= 1)">nb_dim</a>()==2);
<a name="l01941"></a>01941   assert(gradient0.<a class="code" href="classDoubleTab.html#ac3805e2637a3b880ba2d3e650c69dac4" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(0)==<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>);
<a name="l01942"></a>01942   assert(gradient0.<a class="code" href="classDoubleTab.html#ac3805e2637a3b880ba2d3e650c69dac4" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(1)==<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>+2);
<a name="l01943"></a>01943   assert(gradient1.<a class="code" href="classDoubleTab.html#ae6dda48778e7107e1beb723beef1f75b" title="Returns the number of dimensions of the array (&gt;= 1)">nb_dim</a>()==1);
<a name="l01944"></a>01944   assert(gradient1.<a class="code" href="classDoubleTab.html#ac3805e2637a3b880ba2d3e650c69dac4" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(0)==<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>);
<a name="l01945"></a>01945   assert(liste_som.<a class="code" href="classIntVect.html#ad90cfd411cbbd631ccf1935bb36f7c40" title="Identique a size_reelle()">size</a>()==<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>+2);
<a name="l01946"></a>01946 
<a name="l01947"></a>01947 <span class="comment">// </span>
<a name="l01948"></a>01948 <span class="comment">// Partie P1 du laplacien discret</span>
<a name="l01949"></a>01949 <span class="comment">// </span>
<a name="l01950"></a>01950   liste_som=-1;
<a name="l01951"></a>01951   gradient0=0.;
<a name="l01952"></a>01952   <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a253bedb1323fa89e08a8d88e2be8798d">gradient_som_CL</a>(face,nnz,liste_som,gradient0);
<a name="l01953"></a>01953 
<a name="l01954"></a>01954 
<a name="l01955"></a>01955   <span class="comment">/* gradient associe a &quot;face&quot; : calcul du coefficient */</span>
<a name="l01956"></a>01956   <span class="comment">/* diagonal de la matrice associee a l&#39;inconnue */</span>
<a name="l01957"></a>01957   coeff_mat=0.;
<a name="l01958"></a>01958   <span class="keywordflow">for</span> (som_loc=0; som_loc&lt;nnz; som_loc++)
<a name="l01959"></a>01959     {
<a name="l01960"></a>01960       som=liste_som(som_loc);
<a name="l01961"></a>01961       coeff_som=volume_aux_sommets(som)*<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a90fc51e82567cc139118e78417436ef2">coeff_</a>;
<a name="l01962"></a>01962 
<a name="l01963"></a>01963       psc=0.;
<a name="l01964"></a>01964       <span class="keywordflow">for</span> (compj=0; compj&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; compj++)
<a name="l01965"></a>01965         psc+=gradient0(compj,som_loc)
<a name="l01966"></a>01966              *gradient0(compj,som_loc);
<a name="l01967"></a>01967 
<a name="l01968"></a>01968       psc*=coeff_som;
<a name="l01969"></a>01969       psc*=nu_som(som);
<a name="l01970"></a>01970 
<a name="l01971"></a>01971       coeff_mat+=psc;
<a name="l01972"></a>01972     }
<a name="l01973"></a>01973   coeff_mat*=coeff_conv;
<a name="l01974"></a>01974 
<a name="l01975"></a>01975   <span class="keywordflow">for</span> (compi=0; compi&lt;<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#aecdf3d22b30add37625e545939004844">dim_ch_</a>; compi++)
<a name="l01976"></a>01976     {
<a name="l01977"></a>01977       face_C=face*dim_ch_+compi;
<a name="l01978"></a>01978       matrice(face_C,face_C)+=coeff_mat;
<a name="l01979"></a>01979     }
<a name="l01980"></a>01980 
<a name="l01981"></a>01981 
<a name="l01982"></a>01982   <span class="comment">/* calcul des coefficients extra-diagonaux de la matrice laplacien */</span>
<a name="l01983"></a>01983   <span class="comment">/* la matrice etant diagonale par bloc, on effectue le calcul du */</span>
<a name="l01984"></a>01984   <span class="comment">/* produit scalaire une seule fois avant de l&#39;affecter aux differentes */</span>
<a name="l01985"></a>01985   <span class="comment">/* composantes de la matrice */</span>
<a name="l01986"></a>01986   <span class="comment">/* REMARQUE : la matrice est modifiee pour tenir compte des CL de */</span>
<a name="l01987"></a>01987   <span class="comment">/* symetrie, mais on ne calcule pas les modifications associees -&gt; */</span>
<a name="l01988"></a>01988   <span class="comment">/* c&#39;est la fonction Op_VEF_Face::modifier_pour_Cl() qui le fera */</span>
<a name="l01989"></a>01989   face_C=face*<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#aecdf3d22b30add37625e545939004844">dim_ch_</a>;
<a name="l01990"></a>01990   debut=tab1[face_C]-1;
<a name="l01991"></a>01991   size=tab1[face_C+1]-tab1[face_C];
<a name="l01992"></a>01992   size-=(dim_ch_-1);<span class="comment">//-&gt; pour ne pas calculer les coefficients inutiles</span>
<a name="l01993"></a>01993 
<a name="l01994"></a>01994   <span class="keywordflow">for</span> (i=1; i&lt;size; i++) <span class="comment">//i=0 -&gt; face2_C=face_C -&gt; deja rempli</span>
<a name="l01995"></a>01995     {
<a name="l01996"></a>01996       face2_C=tab2[debut+i]-1;
<a name="l01997"></a>01997       face2=face2_C/<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#aecdf3d22b30add37625e545939004844">dim_ch_</a>;<span class="comment">//division euclidienne</span>
<a name="l01998"></a>01998 
<a name="l01999"></a>01999       <span class="keywordflow">if</span> (face2&gt;face)<span class="comment">//pour la symetrie de l&#39;operateur</span>
<a name="l02000"></a>02000         {
<a name="l02001"></a>02001           coeff_mat=0.;
<a name="l02002"></a>02002           <span class="keywordflow">for</span> (som_loc=0; som_loc&lt;nnz; som_loc++)
<a name="l02003"></a>02003             {
<a name="l02004"></a>02004               som=liste_som(som_loc);
<a name="l02005"></a>02005               coeff_som=volume_aux_sommets(som)*<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a90fc51e82567cc139118e78417436ef2">coeff_</a>;
<a name="l02006"></a>02006               <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a035d8cdf71b99212df20fadc0f2c997e">isInStencil</a>(face2,som,elem0,som_loc0,elem1,som_loc1);
<a name="l02007"></a>02007 
<a name="l02008"></a>02008               <span class="keywordflow">if</span> (elem0!=-1)<span class="comment">//les deux faces se &quot;voient&quot;</span>
<a name="l02009"></a>02009                 {
<a name="l02010"></a>02010                   assert(som_loc0!=-1);
<a name="l02011"></a>02011                   gradient1=0.;
<a name="l02012"></a>02012                   <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a37f70143adef3313705fb8583168fd93">gradient_som</a>(face2,som,elem0,som_loc0,elem1,som_loc1,gradient1);
<a name="l02013"></a>02013 
<a name="l02014"></a>02014                   psc=0.;
<a name="l02015"></a>02015                   <span class="keywordflow">for</span> (compj=0; compj&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; compj++)
<a name="l02016"></a>02016                     psc+=gradient0(compj,som_loc)
<a name="l02017"></a>02017                          *gradient1(compj);
<a name="l02018"></a>02018 
<a name="l02019"></a>02019                   psc*=coeff_som;
<a name="l02020"></a>02020                   psc*=nu_som(som);
<a name="l02021"></a>02021                   coeff_mat+=psc;
<a name="l02022"></a>02022                 }
<a name="l02023"></a>02023             }
<a name="l02024"></a>02024           coeff_mat*=coeff_conv;
<a name="l02025"></a>02025           coeff_diff=-1.*delta*<a class="code" href="Op__Diff__VEFP1NCP1B__Face_8cpp.html#a4e834c1f122c09080eb7a6226c2f1185">maximum</a>(0.,coeff_mat);
<a name="l02026"></a>02026           coeff_mat+=coeff_diff;
<a name="l02027"></a>02027 
<a name="l02028"></a>02028           <span class="keywordflow">for</span> (compi=0; compi&lt;<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#aecdf3d22b30add37625e545939004844">dim_ch_</a>; compi++)
<a name="l02029"></a>02029             {
<a name="l02030"></a>02030               face_C=face*dim_ch_+compi;
<a name="l02031"></a>02031               face2_C=face2*dim_ch_+compi;
<a name="l02032"></a>02032 
<a name="l02033"></a>02033               matrice(face_C,face2_C)+=coeff_mat*coeff_perio(face2);
<a name="l02034"></a>02034               matrice(face_C,face_C)-=coeff_diff*coeff_perio(face2);
<a name="l02035"></a>02035               <span class="keywordflow">if</span> (face2&lt;nb_faces)
<a name="l02036"></a>02036                 {
<a name="l02037"></a>02037                   matrice(face2_C,face_C)+=coeff_mat;
<a name="l02038"></a>02038                   matrice(face2_C,face2_C)-=coeff_diff;
<a name="l02039"></a>02039                 }
<a name="l02040"></a>02040             }
<a name="l02041"></a>02041         }
<a name="l02042"></a>02042     }
<a name="l02043"></a>02043 }
<a name="l02044"></a>02044 
<a name="l02045"></a>02045 <span class="comment">// Fonction qui calcule les coefficients de la matrice pour une face</span>
<a name="l02046"></a>02046 <span class="comment">// PERIODIQUE.</span>
<a name="l02047"></a>02047 <span class="keywordtype">void</span> <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a706eb5baeef2cc4eddd0ea43fb11f73c">Op_Diff_VEFP1NCP1B_Face::</a>
<a name="l02048"></a><a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a706eb5baeef2cc4eddd0ea43fb11f73c">02048</a> <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a706eb5baeef2cc4eddd0ea43fb11f73c">coeff_matrice_som_perio</a>(<span class="keyword">const</span> <span class="keywordtype">int</span>&amp; face,<span class="keyword">const</span> <span class="keywordtype">int</span>&amp; faceAss, <a class="code" href="classIntVect.html">IntVect</a>&amp; liste_som,
<a name="l02049"></a>02049                         <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; gradient0, <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; gradient1,
<a name="l02050"></a>02050                         <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; porosite_face,<span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; nu_som,
<a name="l02051"></a>02051                         <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; coeff_perio,<a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; matrice)<span class="keyword"> const</span>
<a name="l02052"></a>02052 <span class="keyword"></span>{
<a name="l02053"></a>02053   <span class="keyword">const</span> <a class="code" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a>&amp; zone_VEF=<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a8d6cebdde81108b4c492d8af3d6d60ae">zone_VEFPreP1B</a>();
<a name="l02054"></a>02054 
<a name="l02055"></a>02055   <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; tab1=matrice.<a class="code" href="classMatrice__Morse.html#a79b4e334152850bd36e53478debf3061">get_tab1</a>();
<a name="l02056"></a>02056   <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; tab2=matrice.<a class="code" href="classMatrice__Morse.html#a787b5a63f27063f9c891243d8f188cda">get_tab2</a>();
<a name="l02057"></a>02057 
<a name="l02058"></a>02058   <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; volume_aux_sommets=zone_VEF.<a class="code" href="classZone__VEF__PreP1b.html#ac8282d378ae480144d75129df4a8c55c">volume_aux_sommets</a>();
<a name="l02059"></a>02059 
<a name="l02060"></a>02060   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_faces=zone_VEF.<a class="code" href="classZone__VF.html#aede27992d9f2eedd52c24d4a80ff7ffb" title="renvoie le nombre global de faces.">nb_faces</a>();
<a name="l02061"></a>02061 
<a name="l02062"></a>02062   <span class="keywordtype">int</span> face_C=0;
<a name="l02063"></a>02063   <span class="keywordtype">int</span> face2=0,face2_C=0;
<a name="l02064"></a>02064   <span class="keywordtype">int</span> som_loc=0,som=0;
<a name="l02065"></a>02065   <span class="keywordtype">int</span> som_loc0=0,som_loc1=0;
<a name="l02066"></a>02066   <span class="keywordtype">int</span> debut=0,size=0;
<a name="l02067"></a>02067   <span class="keywordtype">int</span> compi=0,compj=0;
<a name="l02068"></a>02068   <span class="keywordtype">int</span> elem0=0,elem1=0;
<a name="l02069"></a>02069   <span class="keywordtype">int</span> i=0;
<a name="l02070"></a>02070   <span class="keywordtype">int</span> nnz=0;
<a name="l02071"></a>02071 
<a name="l02072"></a>02072   <span class="keywordtype">double</span> coeff_som=0.,coeff_mat=0.;
<a name="l02073"></a>02073   <span class="keywordtype">double</span> coeff_diff=0.;
<a name="l02074"></a>02074   <span class="keywordtype">double</span> psc=0.;
<a name="l02075"></a>02075   <span class="keywordtype">double</span> delta=<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a34224d2dfd0ecb6877ce4dc87abff1f0">decentrage_</a>;
<a name="l02076"></a>02076 
<a name="l02077"></a>02077   <span class="keywordtype">double</span> coeff_conv=1.;
<a name="l02078"></a>02078   <span class="keywordflow">if</span> (<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#acbd7461fb999d27a3c1ba0320f13563a">alphaE</a>) coeff_conv=(1.-<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a463106e6f719474777b7cc6c5e813354">convexite_</a>);
<a name="l02079"></a>02079 
<a name="l02080"></a>02080 <span class="comment">// Quelques verifications</span>
<a name="l02081"></a>02081   assert(gradient0.<a class="code" href="classDoubleTab.html#ae6dda48778e7107e1beb723beef1f75b" title="Returns the number of dimensions of the array (&gt;= 1)">nb_dim</a>()==2);
<a name="l02082"></a>02082   assert(gradient0.<a class="code" href="classDoubleTab.html#ac3805e2637a3b880ba2d3e650c69dac4" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(0)==<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>);
<a name="l02083"></a>02083   assert(gradient0.<a class="code" href="classDoubleTab.html#ac3805e2637a3b880ba2d3e650c69dac4" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(1)==<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>+2);
<a name="l02084"></a>02084   assert(gradient1.<a class="code" href="classDoubleTab.html#ae6dda48778e7107e1beb723beef1f75b" title="Returns the number of dimensions of the array (&gt;= 1)">nb_dim</a>()==1);
<a name="l02085"></a>02085   assert(gradient1.<a class="code" href="classDoubleTab.html#ac3805e2637a3b880ba2d3e650c69dac4" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(0)==<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>);
<a name="l02086"></a>02086   assert(liste_som.<a class="code" href="classIntVect.html#ad90cfd411cbbd631ccf1935bb36f7c40" title="Identique a size_reelle()">size</a>()==<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>+2);
<a name="l02087"></a>02087 
<a name="l02088"></a>02088 <span class="comment">// </span>
<a name="l02089"></a>02089 <span class="comment">// Partie P1 du laplacien discret</span>
<a name="l02090"></a>02090 <span class="comment">// </span>
<a name="l02091"></a>02091   liste_som=-1;
<a name="l02092"></a>02092   gradient0=0.;
<a name="l02093"></a>02093   <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a37f70143adef3313705fb8583168fd93">gradient_som</a>(face,nnz,liste_som,gradient0);
<a name="l02094"></a>02094 
<a name="l02095"></a>02095 
<a name="l02096"></a>02096   <span class="comment">/* gradient associe a &quot;face&quot; : calcul du coefficient */</span>
<a name="l02097"></a>02097   <span class="comment">/* diagonal de la matrice associee a l&#39;inconnue */</span>
<a name="l02098"></a>02098   coeff_mat=0.;
<a name="l02099"></a>02099   <span class="keywordflow">for</span> (som_loc=0; som_loc&lt;nnz; som_loc++)
<a name="l02100"></a>02100     {
<a name="l02101"></a>02101       som=liste_som(som_loc);
<a name="l02102"></a>02102       coeff_som=volume_aux_sommets(som)*<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a90fc51e82567cc139118e78417436ef2">coeff_</a>;
<a name="l02103"></a>02103 
<a name="l02104"></a>02104       psc=0.;
<a name="l02105"></a>02105       <span class="keywordflow">for</span> (compj=0; compj&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; compj++)
<a name="l02106"></a>02106         psc+=gradient0(compj,som_loc)
<a name="l02107"></a>02107              *gradient0(compj,som_loc);
<a name="l02108"></a>02108 
<a name="l02109"></a>02109       psc*=coeff_som;
<a name="l02110"></a>02110       psc*=nu_som(som);
<a name="l02111"></a>02111 
<a name="l02112"></a>02112       coeff_mat+=psc;
<a name="l02113"></a>02113     }
<a name="l02114"></a>02114   coeff_mat*=coeff_conv;
<a name="l02115"></a>02115 
<a name="l02116"></a>02116   <span class="keywordflow">for</span> (compi=0; compi&lt;<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#aecdf3d22b30add37625e545939004844">dim_ch_</a>; compi++)
<a name="l02117"></a>02117     {
<a name="l02118"></a>02118       face_C=face*dim_ch_+compi;
<a name="l02119"></a>02119       matrice(face_C,face_C)+=coeff_mat;
<a name="l02120"></a>02120     }
<a name="l02121"></a>02121 
<a name="l02122"></a>02122 
<a name="l02123"></a>02123   <span class="comment">/* calcul des coefficients extra-diagonaux de la matrice laplacien */</span>
<a name="l02124"></a>02124   <span class="comment">/* la matrice etant diagonale par bloc, on effectue le calcul du */</span>
<a name="l02125"></a>02125   <span class="comment">/* produit scalaire une seule fois avant de l&#39;affecter aux differentes */</span>
<a name="l02126"></a>02126   <span class="comment">/* composantes de la matrice */</span>
<a name="l02127"></a>02127   face_C=face*<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#aecdf3d22b30add37625e545939004844">dim_ch_</a>;
<a name="l02128"></a>02128   debut=tab1[face_C]-1;
<a name="l02129"></a>02129   size=tab1[face_C+1]-tab1[face_C];
<a name="l02130"></a>02130 
<a name="l02131"></a>02131   <span class="keywordflow">for</span> (i=1; i&lt;size; i++) <span class="comment">//i=0 -&gt; face2_C=face_C -&gt; deja rempli</span>
<a name="l02132"></a>02132     {
<a name="l02133"></a>02133       face2_C=tab2[debut+i]-1;
<a name="l02134"></a>02134       face2=face2_C/<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#aecdf3d22b30add37625e545939004844">dim_ch_</a>;<span class="comment">//division euclidienne</span>
<a name="l02135"></a>02135 
<a name="l02136"></a>02136       <span class="keywordflow">if</span> (face2&gt;face)<span class="comment">//pour la symetrie de l&#39;operateur</span>
<a name="l02137"></a>02137         {
<a name="l02138"></a>02138           coeff_mat=0.;
<a name="l02139"></a>02139           <span class="keywordflow">for</span> (som_loc=0; som_loc&lt;nnz; som_loc++)
<a name="l02140"></a>02140             {
<a name="l02141"></a>02141               som=liste_som(som_loc);
<a name="l02142"></a>02142               coeff_som=volume_aux_sommets(som)*<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a90fc51e82567cc139118e78417436ef2">coeff_</a>;
<a name="l02143"></a>02143               <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a035d8cdf71b99212df20fadc0f2c997e">isInStencil</a>(face2,som,elem0,som_loc0,elem1,som_loc1);
<a name="l02144"></a>02144 
<a name="l02145"></a>02145               <span class="keywordflow">if</span> (elem0!=-1)<span class="comment">//les deux faces se &quot;voient&quot;</span>
<a name="l02146"></a>02146                 {
<a name="l02147"></a>02147                   assert(som_loc0!=-1);
<a name="l02148"></a>02148                   gradient1=0.;
<a name="l02149"></a>02149                   <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a37f70143adef3313705fb8583168fd93">gradient_som</a>(face2,som,elem0,som_loc0,elem1,som_loc1,gradient1);
<a name="l02150"></a>02150 
<a name="l02151"></a>02151                   psc=0.;
<a name="l02152"></a>02152                   <span class="keywordflow">for</span> (compj=0; compj&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; compj++)
<a name="l02153"></a>02153                     psc+=gradient0(compj,som_loc)
<a name="l02154"></a>02154                          *gradient1(compj);
<a name="l02155"></a>02155 
<a name="l02156"></a>02156                   psc*=coeff_som;
<a name="l02157"></a>02157                   psc*=nu_som(som);
<a name="l02158"></a>02158                   coeff_mat+=psc;
<a name="l02159"></a>02159                 }
<a name="l02160"></a>02160             }
<a name="l02161"></a>02161           coeff_mat*=coeff_conv;
<a name="l02162"></a>02162           coeff_diff=-1.*delta*<a class="code" href="Op__Diff__VEFP1NCP1B__Face_8cpp.html#a4e834c1f122c09080eb7a6226c2f1185">maximum</a>(0.,coeff_mat);
<a name="l02163"></a>02163           coeff_mat+=coeff_diff;
<a name="l02164"></a>02164 
<a name="l02165"></a>02165           <span class="keywordflow">for</span> (compi=0; compi&lt;<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#aecdf3d22b30add37625e545939004844">dim_ch_</a>; compi++)
<a name="l02166"></a>02166             {
<a name="l02167"></a>02167               face_C=face*dim_ch_+compi;
<a name="l02168"></a>02168               face2_C=face2*dim_ch_+compi;
<a name="l02169"></a>02169 
<a name="l02170"></a>02170               matrice(face_C,face2_C)+=coeff_mat*coeff_perio(face2);
<a name="l02171"></a>02171               matrice(face_C,face_C)-=coeff_diff*coeff_perio(face2);
<a name="l02172"></a>02172               <span class="keywordflow">if</span> (face2&lt;nb_faces)
<a name="l02173"></a>02173                 {
<a name="l02174"></a>02174                   matrice(face2_C,face_C)+=coeff_mat*coeff_perio(face);
<a name="l02175"></a>02175                   matrice(face2_C,face2_C)-=coeff_diff*coeff_perio(face);
<a name="l02176"></a>02176                 }
<a name="l02177"></a>02177             }
<a name="l02178"></a>02178         }
<a name="l02179"></a>02179     }
<a name="l02180"></a>02180 }
<a name="l02181"></a>02181 
<a name="l02182"></a>02182 <span class="keywordtype">void</span> <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a9fb46e714ef90e6b6eb46ce7bca4d375">Op_Diff_VEFP1NCP1B_Face::</a>
<a name="l02183"></a><a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a9fb46e714ef90e6b6eb46ce7bca4d375">02183</a> <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a9fb46e714ef90e6b6eb46ce7bca4d375">ajouter_contribution</a>(<span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; inconnue,<a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; matrice)<span class="keyword"> const</span>
<a name="l02184"></a>02184 <span class="keyword"></span>{
<a name="l02185"></a>02185   <span class="keyword">const</span> <a class="code" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a>&amp; zone_VEF=<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a8d6cebdde81108b4c492d8af3d6d60ae">zone_VEFPreP1B</a>();
<a name="l02186"></a>02186   <span class="keyword">const</span> <a class="code" href="classZone.html" title="classe Zone Une Zone est un maillage compose d&#39;un ensemble d&#39;elements geometriques de meme type...">Zone</a>&amp; zone=zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>();
<a name="l02187"></a>02187 
<a name="l02188"></a>02188 <span class="comment">// Marqueur pour tenir compte de la porosite</span>
<a name="l02189"></a>02189   <span class="keyword">const</span> <span class="keywordtype">int</span> marq=<a class="code" href="classOp__Diff__VEF__base.html#ae7df69707cc2304c930eb103390e99f0">phi_psi_diffuse</a>(<a class="code" href="classMorEqn.html#a615dd9abff96edcb625fa0424a489864" title="Renvoie la reference sur l&#39;equation pointe par MorEqn::mon_equation. (version const)">equation</a>());
<a name="l02190"></a>02190 
<a name="l02191"></a>02191 <span class="comment">// Lignes pour tenir compte de la porosite</span>
<a name="l02192"></a>02192   <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; porosite_elem=zone_VEF.<a class="code" href="classZone__VF.html#afd135a1b227731193b1a97b7ed525435">porosite_elem</a>();
<a name="l02193"></a>02193   <a class="code" href="classDoubleVect.html">DoubleVect</a> porosite_face(zone_VEF.<a class="code" href="classZone__VF.html#ad9d74d1d9da9f50ab26768dbbca7711b">porosite_face</a>());
<a name="l02194"></a>02194   <span class="keywordflow">if</span> (!marq) porosite_face=1.;
<a name="l02195"></a>02195 
<a name="l02196"></a>02196 <span class="comment">// Lignes pour tenir compte de la diffusivite</span>
<a name="l02197"></a>02197   <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a> nu,nu_p1,nu_pA;
<a name="l02198"></a>02198   <a class="code" href="classOp__Diff__VEF__base.html#aaf04f2c605558b7b05aa8c60f84fb9e1">remplir_nu</a>(<a class="code" href="classOp__Diff__VEF__base.html#ab1309af47a0c41f00181e031fbfda002">nu_</a>);
<a name="l02199"></a>02199   <a class="code" href="Porosites__champ_8cpp.html#a2340e7d73d0f9d34926d012fe1b1d884" title="renvoit le tableau res, res=org si flag=0, res= porosite*org sinon attention ne pas modifier res car ...">modif_par_porosite_si_flag</a>(<a class="code" href="classOp__Diff__VEF__base.html#ab1309af47a0c41f00181e031fbfda002">nu_</a>,nu,!marq,porosite_elem);
<a name="l02200"></a>02200 
<a name="l02201"></a>02201 <span class="comment">// RESTE juste a gerer la porosite a la face</span>
<a name="l02202"></a>02202   <span class="keywordflow">if</span> (<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#acbd7461fb999d27a3c1ba0320f13563a">alphaE</a>)
<a name="l02203"></a>02203     <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a10ecca846d2d639a93ea61ed25cc5458">ajouter_contribution_elem</a>(inconnue,porosite_face,nu,matrice);
<a name="l02204"></a>02204   <span class="keywordflow">if</span> (<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a0ff8784f933eedd5f6a52db444f2d71b">alphaS</a>)
<a name="l02205"></a>02205     {
<a name="l02206"></a>02206       zone.<a class="code" href="classZone.html#a379ad2206b5a13a4f4f3df6d44c7546a" title="Renvoie le domaine dont la zone fait partie. (version const)">domaine</a>().<a class="code" href="classDomaine.html#a32c7de9f9e8e78e3d5ea68715b2ceb2b" title="Cree un tableau ayant une &quot;ligne&quot; par sommet du maillage. Voir MD_Vector_tools::creer_tableau_distrib...">creer_tableau_sommets</a>(nu_p1);
<a name="l02207"></a>02207       <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a997bacd7fe35872ff44036e9e9f40996" title="Calcule la diffusivite &quot;nu_p1&quot; aux sommets du maillage en fonction de la diffusivite &quot;nu_elem&quot; au...">remplir_nu_p1</a>(nu,nu_p1);
<a name="l02208"></a>02208       <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#ae979dc98da8579c81ed4abf017475277">ajouter_contribution_som</a>(inconnue,porosite_face,nu_p1,matrice);
<a name="l02209"></a>02209     }
<a name="l02210"></a>02210   <span class="keywordflow">if</span> (<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a3ca993ddf7251f0c1f79b9c659d5a96f">alphaA</a>)
<a name="l02211"></a>02211     {
<a name="l02212"></a>02212       zone_VEF.<a class="code" href="classZone__VF.html#ae77f9ddf0711c0bcf2162921698d0bea">creer_tableau_aretes</a>(nu_pA);
<a name="l02213"></a>02213       <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a3b64900128cbb94e4b8980e5ac10b49d">remplir_nu_pA</a>(nu,nu_pA);
<a name="l02214"></a>02214       <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#aca6b2aa015252cbc0919765131e98774">ajouter_contribution_aretes</a>(inconnue,porosite_face,nu_pA,matrice);
<a name="l02215"></a>02215     }
<a name="l02216"></a>02216 
<a name="l02217"></a>02217   <span class="keywordflow">if</span> (<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#aa413a1aa88ba72b238a4bc1067f5a869">test_</a>) <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a4f8b23049afd6589ab4f1fa9619458f9">test</a>();
<a name="l02218"></a>02218 }
<a name="l02219"></a>02219 
<a name="l02220"></a>02220 <span class="comment">//</span>
<a name="l02221"></a>02221 <span class="comment">//</span>
<a name="l02222"></a>02222 <span class="comment">//</span>
<a name="l02223"></a>02223 <span class="comment">//</span>
<a name="l02224"></a>02224 <span class="comment">//</span>
<a name="l02225"></a>02225 <span class="comment">//</span>
<a name="l02226"></a>02226 <span class="comment">//</span><span class="comment"></span>
<a name="l02227"></a>02227 <span class="comment">//! Calcule la diffusivite &quot;nu_p1&quot; aux sommets du maillage&lt;br&gt;en fonction de la diffusivite &quot;nu_elem&quot; aux elements.&lt;br&gt;On suppose que nu_elem a son espace virtuel a jour,&lt;br&gt;que nu_p1 est dimensionne nb_dim==1 avec la structure domaine.md_vector_sommets()&lt;br&gt;En sortie l&#39;espace virtuel de nu_p1 est mis a jour&lt;br&gt;L&#39;interpolateur calculs pour un sommet la moyenne (non ponderee) des&lt;br&gt;diffusivites sur les elements adjacents a ce sommet.</span>
<a name="l02228"></a>02228 <span class="comment"></span><span class="keywordtype">void</span> <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a997bacd7fe35872ff44036e9e9f40996" title="Calcule la diffusivite &quot;nu_p1&quot; aux sommets du maillage en fonction de la diffusivite &quot;nu_elem&quot; au...">Op_Diff_VEFP1NCP1B_Face::</a>
<a name="l02229"></a><a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a997bacd7fe35872ff44036e9e9f40996">02229</a> <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a997bacd7fe35872ff44036e9e9f40996" title="Calcule la diffusivite &quot;nu_p1&quot; aux sommets du maillage en fonction de la diffusivite &quot;nu_elem&quot; au...">remplir_nu_p1</a>(<span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; nu_elem,<a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; nu_p1)<span class="keyword"> const</span>
<a name="l02230"></a>02230 <span class="keyword"></span>{
<a name="l02231"></a>02231   <span class="keyword">const</span> <a class="code" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a>&amp; zone_VEF=<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a8d6cebdde81108b4c492d8af3d6d60ae">zone_VEFPreP1B</a>();
<a name="l02232"></a>02232   <span class="keyword">const</span> <a class="code" href="classZone.html" title="classe Zone Une Zone est un maillage compose d&#39;un ensemble d&#39;elements geometriques de meme type...">Zone</a>&amp; zone=zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>();
<a name="l02233"></a>02233   <span class="keyword">const</span> <a class="code" href="classDomaine.html" title="Classe Domaine Un Domaine represente le domaine (spatial) de resolution d&#39;un Probleme. Un Domaine a un Nom, il est constitue d&#39;une ou plusieurs Zone qui peuvent etre eventuellement decoupees en Sous_Zone. Un Domaine porte l&#39;ensemble des sommets utilises par ses Zones. On peut vouloir resoudre des problemes de type different sur plusieurs domaines, geometriquement les domaines sont alors couples par des surfaces qu&#39;on appelle Raccord.">Domaine</a>&amp; dom=zone.<a class="code" href="classZone.html#a379ad2206b5a13a4f4f3df6d44c7546a" title="Renvoie le domaine dont la zone fait partie. (version const)">domaine</a>();
<a name="l02234"></a>02234 
<a name="l02235"></a>02235   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_som = dom.<a class="code" href="classDomaine.html#abc4abc8b8db5bebeb161fae4162a89ce" title="Renvoie le nombre de sommets.">nb_som</a>();
<a name="l02236"></a>02236   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_elem_tot=zone.<a class="code" href="classZone.html#aa3a33e8b723618b9092460007153e42d" title="Renvoie le nombre total d&#39;elements de la zone.">nb_elem_tot</a>();
<a name="l02237"></a>02237   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_som_elem=zone.<a class="code" href="classZone.html#ae0b34a93b9ae8146df2d1884157afe9f" title="Renvoie le nombre de sommets des elements geometriques constituants la zone. Tous les elements de la ...">nb_som_elem</a>();
<a name="l02238"></a>02238 
<a name="l02239"></a>02239   <span class="keywordtype">int</span> elem=0;
<a name="l02240"></a>02240   <span class="keywordtype">int</span> som_loc=0,som=0;
<a name="l02241"></a>02241 
<a name="l02242"></a>02242   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; elem_som=zone.<a class="code" href="classZone.html#ac115e8342be89afb882b7b61cc343267" title="Renvoie le tableau des sommets des elements.">les_elems</a>();
<a name="l02243"></a>02243 
<a name="l02244"></a>02244   <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> nb_elem_per_som(nb_som); <span class="comment">//!&lt; Intialise a zero par defaut</span>
<a name="l02245"></a>02245 <span class="comment"></span>
<a name="l02246"></a>02246   assert(nu_elem.<a class="code" href="classDoubleVect.html#a0d16d30580c90526e4895388fb44be5d">get_md_vector</a>() == zone.<a class="code" href="classZone.html#ab4c6e0d58001c0cc98d4f06e98086544" title="renvoie le descripteur parallele des tableaux aux elements de la zone">md_vector_elements</a>());
<a name="l02247"></a>02247   assert(nu_p1.<a class="code" href="classDoubleVect.html#a0d16d30580c90526e4895388fb44be5d">get_md_vector</a>() == dom.<a class="code" href="classDomaine.html#a94843a61bbc3e432cf87ef40c440fb80">md_vector_sommets</a>());
<a name="l02248"></a>02248 <span class="comment">// On a besoin que l&#39;espace virtuel de nu_elem soit a jour.</span>
<a name="l02249"></a>02249   <a class="code" href="Check__espace__virtuel_8cpp.html#a2ea8fcf12c28d0454bdc4126f8c4b186" title="en mode comm_check_enabled(), verifie si l&#39;espace virtuel du vecteur est a jour, si ce n&#39;est pas le c...">assert_espace_virtuel_vect</a>(nu_elem);
<a name="l02250"></a>02250 
<a name="l02251"></a>02251 <span class="comment">// Calcul effectif de &quot;nu_som&quot;</span>
<a name="l02252"></a>02252 
<a name="l02253"></a>02253   nu_p1=0.;
<a name="l02254"></a>02254 
<a name="l02255"></a>02255   <span class="keywordflow">for</span> (elem=0; elem&lt;nb_elem_tot; elem++)
<a name="l02256"></a>02256     {
<a name="l02257"></a>02257       <span class="keyword">const</span> <span class="keywordtype">double</span> nu = nu_elem[elem];
<a name="l02258"></a>02258       <span class="keywordflow">for</span> (som_loc=0; som_loc&lt;nb_som_elem; som_loc++)
<a name="l02259"></a>02259         {
<a name="l02260"></a>02260           som=elem_som(elem,som_loc);
<a name="l02261"></a>02261 <span class="comment">// Ne pas calculer les valeurs pour les sommets virtuels</span>
<a name="l02262"></a>02262 <span class="comment">// note BM: l&#39;algo precedent ne calculait pas correctement les valeurs non plus</span>
<a name="l02263"></a>02263           <span class="keywordflow">if</span> (som &lt; nb_som)
<a name="l02264"></a>02264             {
<a name="l02265"></a>02265               som=dom.<a class="code" href="classDomaine.html#a37cc657f1907d53b0d5a573da862af80">get_renum_som_perio</a>(som);
<a name="l02266"></a>02266               nu_p1(som) += nu;
<a name="l02267"></a>02267               nb_elem_per_som(som)++;
<a name="l02268"></a>02268             }
<a name="l02269"></a>02269         }
<a name="l02270"></a>02270     }
<a name="l02271"></a>02271 
<a name="l02272"></a>02272   <span class="keywordflow">for</span> (som = 0; som &lt; nb_som; som++)
<a name="l02273"></a>02273     {
<a name="l02274"></a>02274       <span class="keyword">const</span> <span class="keywordtype">int</span> som_perio = dom.<a class="code" href="classDomaine.html#a37cc657f1907d53b0d5a573da862af80">get_renum_som_perio</a>(som);
<a name="l02275"></a>02275       <span class="keywordtype">int</span> nvoisins = nb_elem_per_som[som_perio];
<a name="l02276"></a>02276       <span class="keywordflow">if</span> (nvoisins &gt; 0)
<a name="l02277"></a>02277         {
<a name="l02278"></a>02278 <span class="comment">// La premiere fois qu&#39;on tombe sur ce sommet on fait la division.</span>
<a name="l02279"></a>02279 <span class="comment">// On traite du meme coup le cas ou le sommet n&#39;a pas d&#39;elements voisins.</span>
<a name="l02280"></a>02280           nu_p1(som_perio) /= nvoisins;
<a name="l02281"></a>02281           nb_elem_per_som[som_perio] = 0;
<a name="l02282"></a>02282         }
<a name="l02283"></a>02283       <span class="keywordflow">if</span> (som != som_perio)
<a name="l02284"></a>02284         nu_p1(som) = nu_p1(som_perio);
<a name="l02285"></a>02285     }
<a name="l02286"></a>02286 <span class="comment">// Le codage precedent n&#39;avait apparemment pas besoin d&#39;echange espace virtuel.</span>
<a name="l02287"></a>02287 <span class="comment">// A mon avis (BM) c&#39;est un miracle du au fait qu&#39;on fait les calculs avec epaisseur2</span>
<a name="l02288"></a>02288 <span class="comment">// (calcul sur nb_som_tot, donc les sommets des elements d&#39;epaisseur 1 sont ok mais</span>
<a name="l02289"></a>02289 <span class="comment">// pas ceux d&#39;epaisseur 2)</span>
<a name="l02290"></a>02290 <span class="comment">// Je prefere ce codage: (si on enleve, ca fait des ecarts en parallele)</span>
<a name="l02291"></a>02291   nu_p1.<a class="code" href="classDoubleVect.html#abfebbc2f685ce7bc4b80c720d7da9bf3">echange_espace_virtuel</a>();
<a name="l02292"></a>02292 }
<a name="l02293"></a>02293 
<a name="l02294"></a>02294 <span class="comment">// Fonction qui calcule la diffusivite aux aretes du maillage</span>
<a name="l02295"></a>02295 <span class="comment">// a partir de la diffusivite aux elements</span>
<a name="l02296"></a>02296 <span class="comment">// CONTRAINTE : la diffusivite aux elements &quot;nu_elem&quot; doit</span>
<a name="l02297"></a>02297 <span class="comment">// deja avoir ete calculee et est consideree</span>
<a name="l02298"></a>02298 <span class="comment">// comme un parametre d&#39;entree</span>
<a name="l02299"></a>02299 <span class="comment">// CONTRAINTE : la diffusivite aux sommets &quot;nu_som&quot; doit</span>
<a name="l02300"></a>02300 <span class="comment">// deja avoir ete DIMENSIONNEE a la bonne</span>
<a name="l02301"></a>02301 <span class="comment">// taille et est consideree comme un parametre</span>
<a name="l02302"></a>02302 <span class="comment">// de sortie</span>
<a name="l02303"></a>02303 <span class="comment">// CONTRAINTE : l&#39;interpolateur choisi pour le calcul de</span>
<a name="l02304"></a>02304 <span class="comment">// &quot;nu_som&quot; est tel que pour un sommet s</span>
<a name="l02305"></a>02305 <span class="comment">// donne nous avons</span>
<a name="l02306"></a>02306 <span class="comment">// * une liste L des elements possedant le sommet s</span>
<a name="l02307"></a>02307 <span class="comment">// * la diffusivite en s est la moyenne geometrique</span>
<a name="l02308"></a>02308 <span class="comment">// des &quot;nu_elem&quot; de L</span>
<a name="l02309"></a>02309 <span class="keywordtype">void</span> <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a3b64900128cbb94e4b8980e5ac10b49d">Op_Diff_VEFP1NCP1B_Face::</a>
<a name="l02310"></a><a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a3b64900128cbb94e4b8980e5ac10b49d">02310</a> <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a3b64900128cbb94e4b8980e5ac10b49d">remplir_nu_pA</a>(<span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; nu_elem,<a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; nu_pA)<span class="keyword"> const</span>
<a name="l02311"></a>02311 <span class="keyword"></span>{
<a name="l02312"></a>02312   <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Op_Diff_VEFP1NCP1B_Face::remplir_nu_pA() not coded&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
<a name="l02313"></a>02313   <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Exit&quot;</span> &lt;&lt; finl;
<a name="l02314"></a>02314   <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">exit</a>();
<a name="l02315"></a>02315 }
<a name="l02316"></a>02316 
<a name="l02317"></a>02317 
<a name="l02318"></a>02318 <span class="comment">// Creation d&#39;une liste qui a une face donnee associe les faces</span>
<a name="l02319"></a>02319 <span class="comment">// voisines au sens du support de l&#39;operateur de diffusion P1B</span>
<a name="l02320"></a>02320 <span class="comment">// On passe par une liste intermediaire qui donne pour un sommet</span>
<a name="l02321"></a>02321 <span class="comment">// donnee, la liste des faces &quot;voyant&quot; le sommet au sens de l&#39;operateur</span>
<a name="l02322"></a>02322 <span class="comment">// de diffusion P1B</span>
<a name="l02323"></a><a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#ae2379b34f16ef970c39d7c515f51547c">02323</a> <span class="keywordtype">void</span> <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#ae2379b34f16ef970c39d7c515f51547c">Op_Diff_VEFP1NCP1B_Face::liste_face</a>(<a class="code" href="classIntLists.html" title="Un tableau de listes de type IntList.">IntLists</a>&amp; <a class="code" href="classliste.html" title="Les classes liste et liste_curseur representent une liste de Deriv&lt;Objet_U&gt; et un curseur associe...">liste</a>,<span class="keywordtype">int</span>&amp; nnz)<span class="keyword"> const</span>
<a name="l02324"></a>02324 <span class="keyword"></span>{
<a name="l02325"></a>02325   <span class="keyword">const</span> <a class="code" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a>&amp; zone_VEF = <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a8d6cebdde81108b4c492d8af3d6d60ae">zone_VEFPreP1B</a>();
<a name="l02326"></a>02326   <span class="keyword">const</span> <a class="code" href="classZone__Cl__VEF.html">Zone_Cl_VEF</a>&amp; zone_Cl_VEF = <a class="code" href="classOp__Diff__VEF__base.html#a721f395a27f12a95882437c614e16a7d">la_zcl_vef</a>.<a class="code" href="classRef__Zone__Cl__VEF.html#a0970d7253def65ad4f0c5ce1830fd243">valeur</a>();
<a name="l02327"></a>02327   <span class="keyword">const</span> <a class="code" href="classZone.html" title="classe Zone Une Zone est un maillage compose d&#39;un ensemble d&#39;elements geometriques de meme type...">Zone</a>&amp; zone = zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>();
<a name="l02328"></a>02328   <span class="keyword">const</span> <a class="code" href="classDomaine.html" title="Classe Domaine Un Domaine represente le domaine (spatial) de resolution d&#39;un Probleme. Un Domaine a un Nom, il est constitue d&#39;une ou plusieurs Zone qui peuvent etre eventuellement decoupees en Sous_Zone. Un Domaine porte l&#39;ensemble des sommets utilises par ses Zones. On peut vouloir resoudre des problemes de type different sur plusieurs domaines, geometriquement les domaines sont alors couples par des surfaces qu&#39;on appelle Raccord.">Domaine</a>&amp; dom=zone.<a class="code" href="classZone.html#a379ad2206b5a13a4f4f3df6d44c7546a" title="Renvoie le domaine dont la zone fait partie. (version const)">domaine</a>();
<a name="l02329"></a>02329 
<a name="l02330"></a>02330 
<a name="l02331"></a>02331   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; som_elem=zone.<a class="code" href="classZone.html#ac115e8342be89afb882b7b61cc343267" title="Renvoie le tableau des sommets des elements.">les_elems</a>();
<a name="l02332"></a>02332   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; elem_faces=zone_VEF.<a class="code" href="classZone__VF.html#a067e462dcd3ab92b0f6d945b19e4eb37" title="renvoie le numero de le ieme face de la maille num_elem la facon dont ces faces sont numerotees est l...">elem_faces</a>();
<a name="l02333"></a>02333   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; face_voisins=zone_VEF.<a class="code" href="classZone__VF.html#a49d4322f5585a8fa95748ca785b70702" title="renvoie l&#39;element voisin de numface dans la direction i. i=0 : dans le sens oppose de l&#39;axe orthogona...">face_voisins</a>();
<a name="l02334"></a>02334 
<a name="l02335"></a>02335   <span class="keyword">const</span> <span class="keywordtype">int</span> firstFaceInt=zone_VEF.<a class="code" href="classZone__VF.html#a12869806fa4834aca8f2964e16509dfd" title="une face est interne ssi elle separe deux elements. renvoie le numero de la premiere face interne...">premiere_face_int</a>();
<a name="l02336"></a>02336   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_som_tot=dom.<a class="code" href="classDomaine.html#a394e61cf1993665886de0fbbd0c0178e" title="Renvoie le nombre total de sommets.">nb_som_tot</a>();
<a name="l02337"></a>02337   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_elem_tot=zone_VEF.<a class="code" href="classZone__dis__base.html#a4d6aa445f152aa6dc54d66ea7a071147">nb_elem_tot</a>();
<a name="l02338"></a>02338   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_som_elem=zone.<a class="code" href="classZone.html#ae0b34a93b9ae8146df2d1884157afe9f" title="Renvoie le nombre de sommets des elements geometriques constituants la zone. Tous les elements de la ...">nb_som_elem</a>();
<a name="l02339"></a>02339   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_faces_tot=zone_VEF.<a class="code" href="classZone__VF.html#a50fd21c9535680489015a3c8b88c685a" title="renvoie le nombre total de faces. C&#39;est-a-dire faces reelles + faces virtuelles">nb_faces_tot</a>();
<a name="l02340"></a>02340   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_faces_elem=zone.<a class="code" href="classZone.html#a548fbc7518be2f122b1a5c9589a443c2" title="Renvoie le nombre de face de type i des elements geometriques constituants la zone. Ex: les objets de la classe Prisme ont 2 types de faces: triangle ou quadrangle.">nb_faces_elem</a>();
<a name="l02341"></a>02341   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_bords=zone_VEF.<a class="code" href="classZone__dis__base.html#af22167d614644f55591a29c77eb1c009">nb_front_Cl</a>();
<a name="l02342"></a>02342 
<a name="l02343"></a>02343   <span class="keywordtype">int</span> face=0,face2=0;
<a name="l02344"></a>02344   <span class="keywordtype">int</span> face_loc=0;
<a name="l02345"></a>02345   <span class="keywordtype">int</span> elem=0,elem_loc=0;
<a name="l02346"></a>02346   <span class="keywordtype">int</span> som=0,som_loc=0;
<a name="l02347"></a>02347   <span class="keywordtype">int</span> i=0,size=0;
<a name="l02348"></a>02348   <span class="keywordtype">int</span> n_bord=0,ind_face=0;
<a name="l02349"></a>02349   <span class="keywordtype">int</span> num1=0,num2=0;
<a name="l02350"></a>02350   <span class="keywordtype">int</span> tmp=0;
<a name="l02351"></a>02351 
<a name="l02352"></a>02352   <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a> faces_perio(nb_faces_tot);
<a name="l02353"></a>02353   <a class="code" href="classArrOfBit.html">ArrOfBit</a> fait(nb_faces_tot);
<a name="l02354"></a>02354   <a class="code" href="classIntLists.html" title="Un tableau de listes de type IntList.">IntLists</a> sommets_faces(nb_som_tot);
<a name="l02355"></a>02355 
<a name="l02356"></a>02356 <span class="comment">// Il faut creer un second tableau travaillant sur les faces periodiques</span>
<a name="l02357"></a>02357 <span class="comment">// sinon la matrice pourrait ne pas etre homogene a l&#39;operateur explicite</span>
<a name="l02358"></a>02358   <span class="keywordflow">for</span> (face=0; face&lt;nb_faces_tot; face++)
<a name="l02359"></a>02359     faces_perio(face)=face;
<a name="l02360"></a>02360 
<a name="l02361"></a>02361   <span class="keywordflow">for</span> (n_bord=0; n_bord&lt;nb_bords; n_bord++)
<a name="l02362"></a>02362     {
<a name="l02363"></a>02363       <span class="keyword">const</span> <a class="code" href="classCond__lim.html" title="classe Cond_lim Classe generique servant a representer n&#39;importe quelle classe derivee de la classe C...">Cond_lim</a>&amp; la_cl = zone_Cl_VEF.<a class="code" href="classZone__Cl__dis__base.html#af75e0ed7786863e4d333bfb29d67c323" title="Renvoie la i-ieme condition aux limites. (version const)">les_conditions_limites</a>(n_bord);
<a name="l02364"></a>02364       <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp; le_bord = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>,la_cl.<a class="code" href="classCond__lim.html#a5b2d24809cee07727006a891d4ce8d22" title="Appel a l&#39;objet sous-jacent Renvoie la frontiere discretisee associee a la condition aux limites...">frontiere_dis</a>());
<a name="l02365"></a>02365 
<a name="l02366"></a>02366       num1=0;
<a name="l02367"></a>02367       num2=le_bord.<a class="code" href="classFront__VF.html#aed4006d91bf2ef3af2b9f7933d863a09" title="Nombre de faces reelles et virtuelles du bord.">nb_faces_tot</a>();
<a name="l02368"></a>02368 
<a name="l02369"></a>02369       <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>()))
<a name="l02370"></a>02370         {
<a name="l02371"></a>02371           <span class="keyword">const</span> <a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>&amp; la_cl_perio = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>());
<a name="l02372"></a>02372           <span class="keywordtype">int</span> faceAss=0;
<a name="l02373"></a>02373 
<a name="l02374"></a>02374           <span class="keywordflow">for</span> (ind_face=num1; ind_face&lt;num2; ind_face++)
<a name="l02375"></a>02375             {
<a name="l02376"></a>02376               face=le_bord.<a class="code" href="classFront__VF.html#a3402a19d7e54ed797d2b18e9a47ead1e" title="Renvoie le numero de face de la ieme face du bord.">num_face</a>(ind_face);
<a name="l02377"></a>02377               faceAss=la_cl_perio.<a class="code" href="classPeriodique.html#a207b86556f199a63ea059b841851ca6a">face_associee</a>(ind_face);
<a name="l02378"></a>02378               faceAss=le_bord.<a class="code" href="classFront__VF.html#a3402a19d7e54ed797d2b18e9a47ead1e" title="Renvoie le numero de face de la ieme face du bord.">num_face</a>(faceAss);
<a name="l02379"></a>02379 
<a name="l02380"></a>02380 <span class="comment">// Test afin de ne parcourir que la moitie des faces periodiques</span>
<a name="l02381"></a>02381 <span class="comment">// sachant que l&#39;algorithme qui suit tient compte de ce choix</span>
<a name="l02382"></a>02382 <span class="comment">// REMARQUE : ce test marche aussi en parallele ou les faces</span>
<a name="l02383"></a>02383 <span class="comment">// virtuelles ne sont pas classees</span>
<a name="l02384"></a>02384               <span class="keywordflow">if</span> (face&lt;faceAss)
<a name="l02385"></a>02385                 {
<a name="l02386"></a>02386                   faces_perio(face)=faceAss;
<a name="l02387"></a>02387                   faces_perio(faceAss)=face;
<a name="l02388"></a>02388                 }
<a name="l02389"></a>02389             }
<a name="l02390"></a>02390         }
<a name="l02391"></a>02391     }
<a name="l02392"></a>02392 
<a name="l02393"></a>02393 <span class="comment">// Connectivite liee aux sommets</span>
<a name="l02394"></a>02394   <span class="keywordflow">for</span> (elem=0; elem&lt;nb_elem_tot; elem++)
<a name="l02395"></a>02395     <span class="keywordflow">for</span> (som_loc=0; som_loc&lt;nb_som_elem; som_loc++)
<a name="l02396"></a>02396       {
<a name="l02397"></a>02397         som=som_elem(elem,som_loc);
<a name="l02398"></a>02398         som=dom.<a class="code" href="classDomaine.html#a37cc657f1907d53b0d5a573da862af80">get_renum_som_perio</a>(som);
<a name="l02399"></a>02399 
<a name="l02400"></a>02400         <span class="keywordflow">for</span> (face_loc=0; face_loc&lt;nb_faces_elem; face_loc++)
<a name="l02401"></a>02401           {
<a name="l02402"></a>02402             face=elem_faces(elem,face_loc);
<a name="l02403"></a>02403 
<a name="l02404"></a>02404             sommets_faces[som].add(face);
<a name="l02405"></a>02405             <span class="keywordflow">if</span> (faces_perio(face)!=face)
<a name="l02406"></a>02406               sommets_faces[som].add(faces_perio(face));
<a name="l02407"></a>02407           }
<a name="l02408"></a>02408       }
<a name="l02409"></a>02409 
<a name="l02410"></a>02410   nnz=0;
<a name="l02411"></a>02411   liste.<a class="code" href="classIntLists.html#afa2bb253d9d4764110ca8cc4b93649ed" title="Redimensionne un tableau de listes.">dimensionner</a>(nb_faces_tot);
<a name="l02412"></a>02412 <span class="comment">// REMARQUE IMPORTANTE : IL FAUT ABSOLUMENT COMMENCER</span>
<a name="l02413"></a>02413 <span class="comment">// PAR REMPLIR LES FACES PERIODIQUES SINON :</span>
<a name="l02414"></a>02414 <span class="comment">// -LA MATRICE NE POURRA PAS ETRE PERIODIQUE</span>
<a name="l02415"></a>02415 <span class="comment">// -ET DES COEFFICIENTS POURRAIENT ETRE OUBLIES</span>
<a name="l02416"></a>02416   <span class="keywordflow">for</span> (n_bord=0; n_bord&lt;nb_bords; n_bord++)
<a name="l02417"></a>02417     {
<a name="l02418"></a>02418       <span class="keyword">const</span> <a class="code" href="classCond__lim.html" title="classe Cond_lim Classe generique servant a representer n&#39;importe quelle classe derivee de la classe C...">Cond_lim</a>&amp; la_cl = zone_Cl_VEF.<a class="code" href="classZone__Cl__dis__base.html#af75e0ed7786863e4d333bfb29d67c323" title="Renvoie la i-ieme condition aux limites. (version const)">les_conditions_limites</a>(n_bord);
<a name="l02419"></a>02419       <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp; le_bord = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>,la_cl.<a class="code" href="classCond__lim.html#a5b2d24809cee07727006a891d4ce8d22" title="Appel a l&#39;objet sous-jacent Renvoie la frontiere discretisee associee a la condition aux limites...">frontiere_dis</a>());
<a name="l02420"></a>02420 
<a name="l02421"></a>02421       num1=0;
<a name="l02422"></a>02422       num2=le_bord.<a class="code" href="classFront__VF.html#aed4006d91bf2ef3af2b9f7933d863a09" title="Nombre de faces reelles et virtuelles du bord.">nb_faces_tot</a>();
<a name="l02423"></a>02423 
<a name="l02424"></a>02424       <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>()))
<a name="l02425"></a>02425         {
<a name="l02426"></a>02426           <span class="keyword">const</span> <a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>&amp; la_cl_perio = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>());
<a name="l02427"></a>02427           <span class="keywordtype">int</span> faceAss=0;
<a name="l02428"></a>02428 
<a name="l02429"></a>02429           <span class="keywordflow">for</span> (ind_face=num1; ind_face&lt;num2; ind_face++)
<a name="l02430"></a>02430             {
<a name="l02431"></a>02431               face=le_bord.<a class="code" href="classFront__VF.html#a3402a19d7e54ed797d2b18e9a47ead1e" title="Renvoie le numero de face de la ieme face du bord.">num_face</a>(ind_face);
<a name="l02432"></a>02432               faceAss=la_cl_perio.<a class="code" href="classPeriodique.html#a207b86556f199a63ea059b841851ca6a">face_associee</a>(ind_face);
<a name="l02433"></a>02433               faceAss=le_bord.<a class="code" href="classFront__VF.html#a3402a19d7e54ed797d2b18e9a47ead1e" title="Renvoie le numero de face de la ieme face du bord.">num_face</a>(faceAss);
<a name="l02434"></a>02434 
<a name="l02435"></a>02435 <span class="comment">// Test afin de ne parcourir que la moitie des faces periodiques</span>
<a name="l02436"></a>02436 <span class="comment">// sachant que l&#39;algorithme qui suit tient compte de ce choix</span>
<a name="l02437"></a>02437 <span class="comment">// REMARQUE : ce test marche aussi en parallele ou les faces</span>
<a name="l02438"></a>02438 <span class="comment">// virtuelles ne sont pas classees</span>
<a name="l02439"></a>02439               <span class="keywordflow">if</span> (face&lt;faceAss)
<a name="l02440"></a>02440                 {
<a name="l02441"></a>02441 <span class="comment">// RAZ du tableau fait</span>
<a name="l02442"></a>02442                   fait=0;
<a name="l02443"></a>02443 
<a name="l02444"></a>02444 <span class="comment">// pour la periodicite</span>
<a name="l02445"></a>02445                   size=liste[face].<a class="code" href="classIntLists.html#a823946693bc491321765f0e6805204e2" title="retourne le nombre de listes dans le tableau">size</a>();
<a name="l02446"></a>02446                   <span class="keywordflow">for</span> (i=0; i&lt;size; i++)
<a name="l02447"></a>02447                     fait.<a class="code" href="classArrOfBit.html#a5c339cfd9dea141737e127131e52aaae" title="Met le bit e a 1.">setbit</a>(liste[face][i]);
<a name="l02448"></a>02448 
<a name="l02449"></a>02449 <span class="comment">// Pour que le premier element de la liste soit &quot;face&quot;</span>
<a name="l02450"></a>02450 <span class="comment">// Tient compte de la periodicite</span>
<a name="l02451"></a>02451                   <span class="keywordflow">if</span> (size!=0)
<a name="l02452"></a>02452                     {
<a name="l02453"></a>02453                       tmp=liste[face][0];
<a name="l02454"></a>02454                       liste[face][0]=face;
<a name="l02455"></a>02455                       liste[face].add(tmp);
<a name="l02456"></a>02456                       tmp=liste[faceAss][0];
<a name="l02457"></a>02457                       liste[faceAss][0]=faceAss;
<a name="l02458"></a>02458                       liste[faceAss].add(tmp);
<a name="l02459"></a>02459                     }
<a name="l02460"></a>02460                   <span class="keywordflow">else</span>
<a name="l02461"></a>02461                     {
<a name="l02462"></a>02462                       liste[face].add(face);
<a name="l02463"></a>02463                       liste[faceAss].add(faceAss);
<a name="l02464"></a>02464                     }
<a name="l02465"></a>02465 
<a name="l02466"></a>02466                   fait.<a class="code" href="classArrOfBit.html#a5c339cfd9dea141737e127131e52aaae" title="Met le bit e a 1.">setbit</a>(face);
<a name="l02467"></a>02467                   fait.<a class="code" href="classArrOfBit.html#a5c339cfd9dea141737e127131e52aaae" title="Met le bit e a 1.">setbit</a>(faceAss);
<a name="l02468"></a>02468                   nnz+=2;<span class="comment">//car on ajoute 2 coefficients</span>
<a name="l02469"></a>02469 
<a name="l02470"></a>02470                   <span class="keywordflow">for</span> (elem_loc=0; elem_loc&lt;2; elem_loc++)
<a name="l02471"></a>02471                     {
<a name="l02472"></a>02472                       elem=face_voisins(face,elem_loc);
<a name="l02473"></a>02473                       assert(elem!=-1);
<a name="l02474"></a>02474 
<a name="l02475"></a>02475                       <span class="keywordflow">for</span> (som_loc=0; som_loc&lt;nb_som_elem; som_loc++)
<a name="l02476"></a>02476                         {
<a name="l02477"></a>02477                           som=som_elem(elem,som_loc);
<a name="l02478"></a>02478                           som=dom.<a class="code" href="classDomaine.html#a37cc657f1907d53b0d5a573da862af80">get_renum_som_perio</a>(som);
<a name="l02479"></a>02479 
<a name="l02480"></a>02480                           size=sommets_faces[som].<a class="code" href="classIntLists.html#a823946693bc491321765f0e6805204e2" title="retourne le nombre de listes dans le tableau">size</a>();
<a name="l02481"></a>02481                           <span class="keywordflow">for</span> (i=0; i&lt;size; i++)
<a name="l02482"></a>02482                             {
<a name="l02483"></a>02483                               face2=sommets_faces[som][i];
<a name="l02484"></a>02484 
<a name="l02485"></a>02485                               <span class="keywordflow">if</span> (!fait[face2])
<a name="l02486"></a>02486                                 {
<a name="l02487"></a>02487                                   fait.<a class="code" href="classArrOfBit.html#a5c339cfd9dea141737e127131e52aaae" title="Met le bit e a 1.">setbit</a>(face2);
<a name="l02488"></a>02488                                   liste[face].add(face2);
<a name="l02489"></a>02489                                   liste[faceAss].add(face2);
<a name="l02490"></a>02490                                   liste[face2].add(face);
<a name="l02491"></a>02491                                   liste[face2].add(faceAss);
<a name="l02492"></a>02492                                   nnz+=4;<span class="comment">//car on ajoute 4 coefficients</span>
<a name="l02493"></a>02493                                 }
<a name="l02494"></a>02494 
<a name="l02495"></a>02495                             }<span class="comment">//fin du for sur &quot;i&quot;</span>
<a name="l02496"></a>02496                         }<span class="comment">//fin du for sur &quot;som_loc&quot;</span>
<a name="l02497"></a>02497                     }<span class="comment">//fin du for sur &quot;elem_loc&quot;</span>
<a name="l02498"></a>02498                 }<span class="comment">//fin du if sur &quot;face&lt;faceAss&quot;</span>
<a name="l02499"></a>02499             }<span class="comment">//fin du for sur &quot;ind_face&quot;</span>
<a name="l02500"></a>02500         }<span class="comment">//fin Periodique</span>
<a name="l02501"></a>02501     }<span class="comment">//fin n_bord</span>
<a name="l02502"></a>02502 
<a name="l02503"></a>02503 <span class="comment">// Autres conditions aux limites</span>
<a name="l02504"></a>02504   <span class="keywordflow">for</span> (n_bord=0; n_bord&lt;nb_bords; n_bord++)
<a name="l02505"></a>02505     {
<a name="l02506"></a>02506       <span class="keyword">const</span> <a class="code" href="classCond__lim.html" title="classe Cond_lim Classe generique servant a representer n&#39;importe quelle classe derivee de la classe C...">Cond_lim</a>&amp; la_cl = zone_Cl_VEF.<a class="code" href="classZone__Cl__dis__base.html#af75e0ed7786863e4d333bfb29d67c323" title="Renvoie la i-ieme condition aux limites. (version const)">les_conditions_limites</a>(n_bord);
<a name="l02507"></a>02507       <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp; le_bord = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>,la_cl.<a class="code" href="classCond__lim.html#a5b2d24809cee07727006a891d4ce8d22" title="Appel a l&#39;objet sous-jacent Renvoie la frontiere discretisee associee a la condition aux limites...">frontiere_dis</a>());
<a name="l02508"></a>02508 
<a name="l02509"></a>02509       num1=0;
<a name="l02510"></a>02510       num2=le_bord.<a class="code" href="classFront__VF.html#aed4006d91bf2ef3af2b9f7933d863a09" title="Nombre de faces reelles et virtuelles du bord.">nb_faces_tot</a>();
<a name="l02511"></a>02511 
<a name="l02512"></a>02512       <span class="keywordflow">if</span> (!<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>()))
<a name="l02513"></a>02513         <span class="keywordflow">for</span> (ind_face=num1; ind_face&lt;num2; ind_face++)
<a name="l02514"></a>02514           {
<a name="l02515"></a>02515             face=le_bord.<a class="code" href="classFront__VF.html#a3402a19d7e54ed797d2b18e9a47ead1e" title="Renvoie le numero de face de la ieme face du bord.">num_face</a>(ind_face);
<a name="l02516"></a>02516 
<a name="l02517"></a>02517 <span class="comment">// RAZ du tableau fait</span>
<a name="l02518"></a>02518             fait=0;
<a name="l02519"></a>02519 
<a name="l02520"></a>02520 <span class="comment">// pour la periodicite</span>
<a name="l02521"></a>02521             size=liste[face].<a class="code" href="classIntLists.html#a823946693bc491321765f0e6805204e2" title="retourne le nombre de listes dans le tableau">size</a>();
<a name="l02522"></a>02522             <span class="keywordflow">for</span> (i=0; i&lt;size; i++)
<a name="l02523"></a>02523               fait.<a class="code" href="classArrOfBit.html#a5c339cfd9dea141737e127131e52aaae" title="Met le bit e a 1.">setbit</a>(liste[face][i]);
<a name="l02524"></a>02524 
<a name="l02525"></a>02525 <span class="comment">// Pour que le premier element de la liste soit &quot;face&quot;</span>
<a name="l02526"></a>02526 <span class="comment">// Tient compte de la periodicite</span>
<a name="l02527"></a>02527             <span class="keywordflow">if</span> (size!=0)
<a name="l02528"></a>02528               {
<a name="l02529"></a>02529                 tmp=liste[face][0];
<a name="l02530"></a>02530                 liste[face][0]=face;
<a name="l02531"></a>02531                 liste[face].add(tmp);
<a name="l02532"></a>02532               }
<a name="l02533"></a>02533             <span class="keywordflow">else</span>
<a name="l02534"></a>02534               liste[face].add(face);
<a name="l02535"></a>02535 
<a name="l02536"></a>02536             fait.<a class="code" href="classArrOfBit.html#a5c339cfd9dea141737e127131e52aaae" title="Met le bit e a 1.">setbit</a>(face);
<a name="l02537"></a>02537             nnz++;
<a name="l02538"></a>02538 
<a name="l02539"></a>02539             elem=face_voisins(face,0);
<a name="l02540"></a>02540             assert(elem!=-1);
<a name="l02541"></a>02541 
<a name="l02542"></a>02542             <span class="keywordflow">for</span> (som_loc=0; som_loc&lt;nb_som_elem; som_loc++)
<a name="l02543"></a>02543               {
<a name="l02544"></a>02544                 som=som_elem(elem,som_loc);
<a name="l02545"></a>02545                 som=dom.<a class="code" href="classDomaine.html#a37cc657f1907d53b0d5a573da862af80">get_renum_som_perio</a>(som);
<a name="l02546"></a>02546 
<a name="l02547"></a>02547                 size=sommets_faces[som].<a class="code" href="classIntLists.html#a823946693bc491321765f0e6805204e2" title="retourne le nombre de listes dans le tableau">size</a>();
<a name="l02548"></a>02548                 <span class="keywordflow">for</span> (i=0; i&lt;size; i++)
<a name="l02549"></a>02549                   {
<a name="l02550"></a>02550                     face2=sommets_faces[som][i];
<a name="l02551"></a>02551 
<a name="l02552"></a>02552                     <span class="keywordflow">if</span> (!fait[face2])
<a name="l02553"></a>02553                       {
<a name="l02554"></a>02554                         fait.<a class="code" href="classArrOfBit.html#a5c339cfd9dea141737e127131e52aaae" title="Met le bit e a 1.">setbit</a>(face2);
<a name="l02555"></a>02555                         liste[face].add(face2);
<a name="l02556"></a>02556                         nnz++;
<a name="l02557"></a>02557                       }
<a name="l02558"></a>02558 
<a name="l02559"></a>02559                   }<span class="comment">//fin du for sur &quot;i&quot;</span>
<a name="l02560"></a>02560               }<span class="comment">//fin du for sur &quot;som_loc&quot;</span>
<a name="l02561"></a>02561           }<span class="comment">//fin du else sur !Periodique</span>
<a name="l02562"></a>02562     }<span class="comment">//fin du for sur n_bord</span>
<a name="l02563"></a>02563 
<a name="l02564"></a>02564   <span class="keywordflow">for</span> (face=firstFaceInt; face&lt;nb_faces_tot; face++)
<a name="l02565"></a>02565     <span class="keywordflow">if</span> (!zone_VEF.<a class="code" href="classZone__VF.html#a33909d3880435e82e84639b51482d2c6" title="renvoie 1 si face est une face virtuelle de bord, 0 sinon">est_une_face_virt_bord</a>(face))
<a name="l02566"></a>02566       {
<a name="l02567"></a>02567 <span class="comment">// RAZ du tableau fait</span>
<a name="l02568"></a>02568         fait=0;
<a name="l02569"></a>02569 
<a name="l02570"></a>02570 <span class="comment">// pour la periodicite</span>
<a name="l02571"></a>02571         size=liste[face].<a class="code" href="classIntLists.html#a823946693bc491321765f0e6805204e2" title="retourne le nombre de listes dans le tableau">size</a>();
<a name="l02572"></a>02572         <span class="keywordflow">for</span> (i=0; i&lt;size; i++)
<a name="l02573"></a>02573           fait.<a class="code" href="classArrOfBit.html#a5c339cfd9dea141737e127131e52aaae" title="Met le bit e a 1.">setbit</a>(liste[face][i]);
<a name="l02574"></a>02574 
<a name="l02575"></a>02575 <span class="comment">// Pour que le premier element de la liste soit &quot;face&quot;</span>
<a name="l02576"></a>02576 <span class="comment">// Tient compte de la periodicite</span>
<a name="l02577"></a>02577         <span class="keywordflow">if</span> (size!=0)
<a name="l02578"></a>02578           {
<a name="l02579"></a>02579             tmp=liste[face][0];
<a name="l02580"></a>02580             liste[face][0]=face;
<a name="l02581"></a>02581             liste[face].add(tmp);
<a name="l02582"></a>02582           }
<a name="l02583"></a>02583         <span class="keywordflow">else</span>
<a name="l02584"></a>02584           liste[face].add(face);
<a name="l02585"></a>02585 
<a name="l02586"></a>02586         fait.<a class="code" href="classArrOfBit.html#a5c339cfd9dea141737e127131e52aaae" title="Met le bit e a 1.">setbit</a>(face);
<a name="l02587"></a>02587         nnz++;
<a name="l02588"></a>02588 
<a name="l02589"></a>02589         <span class="keywordflow">for</span> (elem_loc=0; elem_loc&lt;2; elem_loc++)
<a name="l02590"></a>02590           {
<a name="l02591"></a>02591             elem=face_voisins(face,elem_loc);
<a name="l02592"></a>02592 
<a name="l02593"></a>02593             <span class="keywordflow">if</span> (elem!=-1) <span class="comment">//pour face interne de joint</span>
<a name="l02594"></a>02594               <span class="keywordflow">for</span> (som_loc=0; som_loc&lt;nb_som_elem; som_loc++)
<a name="l02595"></a>02595                 {
<a name="l02596"></a>02596                   som=som_elem(elem,som_loc);
<a name="l02597"></a>02597                   som=dom.<a class="code" href="classDomaine.html#a37cc657f1907d53b0d5a573da862af80">get_renum_som_perio</a>(som);
<a name="l02598"></a>02598 
<a name="l02599"></a>02599                   size=sommets_faces[som].<a class="code" href="classIntLists.html#a823946693bc491321765f0e6805204e2" title="retourne le nombre de listes dans le tableau">size</a>();
<a name="l02600"></a>02600                   <span class="keywordflow">for</span> (i=0; i&lt;size; i++)
<a name="l02601"></a>02601                     {
<a name="l02602"></a>02602                       face2=sommets_faces[som][i];
<a name="l02603"></a>02603 
<a name="l02604"></a>02604                       <span class="keywordflow">if</span> (!fait[face2])
<a name="l02605"></a>02605                         {
<a name="l02606"></a>02606                           fait.<a class="code" href="classArrOfBit.html#a5c339cfd9dea141737e127131e52aaae" title="Met le bit e a 1.">setbit</a>(face2);
<a name="l02607"></a>02607                           liste[face].add(face2);
<a name="l02608"></a>02608                           nnz++;
<a name="l02609"></a>02609                         }
<a name="l02610"></a>02610 
<a name="l02611"></a>02611                     }<span class="comment">//fin du for sur &quot;i&quot;</span>
<a name="l02612"></a>02612                 }<span class="comment">//fin du for sur &quot;som_loc&quot;</span>
<a name="l02613"></a>02613           }<span class="comment">//fin du for sur &quot;elem_loc&quot;</span>
<a name="l02614"></a>02614       }<span class="comment">//fin du for sur &quot;face&quot;</span>
<a name="l02615"></a>02615 }
<a name="l02616"></a>02616 
<a name="l02617"></a>02617 <span class="comment">// Fonction qui calcule pour une face &quot;face&quot; donnee et un sommet &quot;som&quot;</span>
<a name="l02618"></a>02618 <span class="comment">// du stencil de &quot;face&quot;, le gradient associe a &quot;face&quot; pour le sommet &quot;som&quot;</span>
<a name="l02619"></a>02619 <span class="comment">// ATTENTION : cette fonction ne doit etre utilisee que pour le calcul</span>
<a name="l02620"></a>02620 <span class="comment">// des gradients pour remplir une COLONNE de la matrice</span>
<a name="l02621"></a>02621 <span class="comment">// CONTRAINTE : &quot;face&quot; est le numero de la face sur laquelle on veut</span>
<a name="l02622"></a>02622 <span class="comment">// calculer le gradient. La face &quot;face&quot; est une face</span>
<a name="l02623"></a>02623 <span class="comment">// INTERNE ou PERIODIQUE.</span>
<a name="l02624"></a>02624 <span class="comment">// CONTRAINTE : le sommet &quot;som&quot; en parametre est suppose etre le</span>
<a name="l02625"></a>02625 <span class="comment">// numero d&#39;un sommet APRES renumerotation periodique</span>
<a name="l02626"></a>02626 <span class="comment">// CONTRAINTE : le sommet &quot;som&quot; DOIT appartenir au stencil de &quot;face&quot;</span>
<a name="l02627"></a>02627 <span class="comment">// CONTRAINTE : &quot;elem0&quot; et &quot;elem1&quot; sont les numeros des elements</span>
<a name="l02628"></a>02628 <span class="comment">// qui contiennent &quot;face&quot; ET &quot;som&quot;. Si l&#39;un des elements</span>
<a name="l02629"></a>02629 <span class="comment">// est a -1, c&#39;est que &quot;face&quot; et &quot;som&quot; n&#39;appartiennent</span>
<a name="l02630"></a>02630 <span class="comment">// pas a un meme element. REMARQUE : l&#39;element elem0</span>
<a name="l02631"></a>02631 <span class="comment">// est toujours suppose different de -1.</span>
<a name="l02632"></a>02632 <span class="comment">// CONTRAINTE : &quot;som_loc0&quot; et &quot;som_loc1&quot; sont les numeros locaux</span>
<a name="l02633"></a>02633 <span class="comment">// de &quot;sim_glob&quot; dans repectivement &quot;elem0&quot; et &quot;elem1&quot;.</span>
<a name="l02634"></a>02634 <span class="comment">// Si l&#39;un des elements est a -1, alors le numero local</span>
<a name="l02635"></a>02635 <span class="comment">// de sommet correspondant est a -1</span>
<a name="l02636"></a>02636 <span class="comment">// CONTRAINTE : le parametre de sortie &quot;grad&quot; contenant l&#39;evaluation</span>
<a name="l02637"></a>02637 <span class="comment">// du gradient associe a &quot;face&quot; au sommet &quot;som&quot; est</span>
<a name="l02638"></a>02638 <span class="comment">// sense etre CORRECTEMENT dimensionne AVANT l&#39;appel</span>
<a name="l02639"></a>02639 <span class="comment">// de cette fonction</span>
<a name="l02640"></a>02640 <span class="keywordtype">void</span> <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a37f70143adef3313705fb8583168fd93">Op_Diff_VEFP1NCP1B_Face::</a>
<a name="l02641"></a><a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a37f70143adef3313705fb8583168fd93">02641</a> <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a37f70143adef3313705fb8583168fd93">gradient_som</a>(<span class="keyword">const</span> <span class="keywordtype">int</span>&amp; face,<span class="keyword">const</span> <span class="keywordtype">int</span>&amp; som_glob,
<a name="l02642"></a>02642              <span class="keyword">const</span> <span class="keywordtype">int</span>&amp; elem0, <span class="keyword">const</span> <span class="keywordtype">int</span>&amp; som_loc0,
<a name="l02643"></a>02643              <span class="keyword">const</span> <span class="keywordtype">int</span>&amp; elem1, <span class="keyword">const</span> <span class="keywordtype">int</span>&amp; som_loc1,
<a name="l02644"></a>02644              <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; grad)<span class="keyword"> const</span>
<a name="l02645"></a>02645 <span class="keyword"></span>{
<a name="l02646"></a>02646   <span class="keyword">const</span> <a class="code" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a>&amp; zone_VEF = <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a8d6cebdde81108b4c492d8af3d6d60ae">zone_VEFPreP1B</a>();
<a name="l02647"></a>02647 
<a name="l02648"></a>02648   <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; face_normales=zone_VEF.<a class="code" href="classZone__VEF.html#a5742d75972e4846bf9fbb6ed5715053e">face_normales</a>();
<a name="l02649"></a>02649   <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; volume_aux_sommets=zone_VEF.<a class="code" href="classZone__VEF__PreP1b.html#ac8282d378ae480144d75129df4a8c55c">volume_aux_sommets</a>();
<a name="l02650"></a>02650 
<a name="l02651"></a>02651   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; elem_faces=zone_VEF.<a class="code" href="classZone__VF.html#a067e462dcd3ab92b0f6d945b19e4eb37" title="renvoie le numero de le ieme face de la maille num_elem la facon dont ces faces sont numerotees est l...">elem_faces</a>();
<a name="l02652"></a>02652   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; face_voisins=zone_VEF.<a class="code" href="classZone__VF.html#a49d4322f5585a8fa95748ca785b70702" title="renvoie l&#39;element voisin de numface dans la direction i. i=0 : dans le sens oppose de l&#39;axe orthogona...">face_voisins</a>();
<a name="l02653"></a>02653 
<a name="l02654"></a>02654   <span class="keyword">const</span> <span class="keywordtype">double</span> <a class="code" href="Champ__P1iP1B__implementation_8cpp.html#aa8c8f49390c3cf7c702d71a71bc977e3">coeff</a>=1./<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>;
<a name="l02655"></a>02655   <span class="keyword">const</span> <span class="keywordtype">double</span> coeff_som=coeff/(<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>+1);
<a name="l02656"></a>02656 
<a name="l02657"></a>02657   <span class="keywordtype">int</span> face_opp=0,compj=0;
<a name="l02658"></a>02658   <span class="keywordtype">int</span> elem=0;
<a name="l02659"></a>02659   <span class="keywordtype">double</span> signe=0.;
<a name="l02660"></a>02660 
<a name="l02661"></a>02661   assert(grad.<a class="code" href="classDoubleTab.html#ae6dda48778e7107e1beb723beef1f75b" title="Returns the number of dimensions of the array (&gt;= 1)">nb_dim</a>()==1);
<a name="l02662"></a>02662 
<a name="l02663"></a>02663 <span class="comment">// </span>
<a name="l02664"></a>02664 <span class="comment">// Calcul du gradient</span>
<a name="l02665"></a>02665 <span class="comment">// </span>
<a name="l02666"></a>02666 
<a name="l02667"></a>02667   <span class="comment">/* On regarde le premier element voisin */</span>
<a name="l02668"></a>02668   assert(elem0!=-1);
<a name="l02669"></a>02669   assert(som_loc0!=-1);
<a name="l02670"></a>02670 
<a name="l02671"></a>02671 <span class="comment">// Calcul du gradient local</span>
<a name="l02672"></a>02672   face_opp = elem_faces(elem0,som_loc0);
<a name="l02673"></a>02673   signe=1.;
<a name="l02674"></a>02674   <span class="keywordflow">if</span>(elem0!=face_voisins(face_opp,0)) signe=-1.;
<a name="l02675"></a>02675 
<a name="l02676"></a>02676   <span class="keywordflow">for</span>(compj=0; compj&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; compj++)
<a name="l02677"></a>02677     grad(compj)=coeff_som*signe*
<a name="l02678"></a>02678                 face_normales(face_opp,compj);
<a name="l02679"></a>02679 
<a name="l02680"></a>02680   <span class="comment">/* On regarde le deuxieme element voisin */</span>
<a name="l02681"></a>02681   <span class="keywordflow">if</span> (elem1==-1)
<a name="l02682"></a>02682     {
<a name="l02683"></a>02683       <span class="comment">/* Plusieurs possibilite :</span>
<a name="l02684"></a>02684 <span class="comment">         - &quot;face&quot; est interne reel</span>
<a name="l02685"></a>02685 <span class="comment">         - &quot;face&quot; est interne virtuel</span>
<a name="l02686"></a>02686 <span class="comment">         - &quot;face&quot; est de bord reel</span>
<a name="l02687"></a>02687 <span class="comment">         - &quot;face&quot; est de bord virtuel</span>
<a name="l02688"></a>02688 <span class="comment">         - &quot;face&quot; une face de joint */</span>
<a name="l02689"></a>02689       assert(som_loc1==-1);
<a name="l02690"></a>02690       elem=face_voisins(face,1);
<a name="l02691"></a>02691       assert(face_voisins(face,0)!=-1);
<a name="l02692"></a>02692 
<a name="l02693"></a>02693       <span class="comment">/* &quot;face&quot; est de bord */</span>
<a name="l02694"></a>02694       <span class="keywordflow">if</span> (elem==-1 &amp;&amp; face_opp!=face)
<a name="l02695"></a>02695         <span class="keywordflow">for</span> (compj=0; compj&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; compj++)
<a name="l02696"></a>02696           grad(compj)+=coeff*face_normales(face,compj) ;
<a name="l02697"></a>02697     }
<a name="l02698"></a>02698   <span class="keywordflow">else</span>
<a name="l02699"></a>02699     {
<a name="l02700"></a>02700       assert(som_loc1!=-1);
<a name="l02701"></a>02701       face_opp=elem_faces(elem1,som_loc1);
<a name="l02702"></a>02702       signe=1.;
<a name="l02703"></a>02703       <span class="keywordflow">if</span>(elem1!=face_voisins(face_opp,0)) signe=-1.;
<a name="l02704"></a>02704 
<a name="l02705"></a>02705 <span class="comment">// Calcul du gradient local</span>
<a name="l02706"></a>02706       <span class="keywordflow">for</span>(compj=0; compj&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; compj++)
<a name="l02707"></a>02707         grad(compj)+=coeff_som*signe*
<a name="l02708"></a>02708                      face_normales(face_opp,compj);
<a name="l02709"></a>02709     }
<a name="l02710"></a>02710 
<a name="l02711"></a>02711   grad/=(<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a90fc51e82567cc139118e78417436ef2">coeff_</a>*volume_aux_sommets(som_glob));
<a name="l02712"></a>02712 }
<a name="l02713"></a>02713 
<a name="l02714"></a>02714 <span class="comment">// Pour une face donnee, calcule le gradient associee a cette face</span>
<a name="l02715"></a>02715 <span class="comment">// pour chacun des sommets ou le gradient est non nul</span>
<a name="l02716"></a>02716 <span class="comment">// ATTENTION : cette fonction ne doit etre utilisee que pour le calcul</span>
<a name="l02717"></a>02717 <span class="comment">// des gradients pour remplir une LIGNE de la matrice</span>
<a name="l02718"></a>02718 <span class="comment">// CONTRAINTE : le tableau &quot;grad&quot; est sense etre correctement</span>
<a name="l02719"></a>02719 <span class="comment">// dimensionne AVANT l&#39;appel de cette fonction</span>
<a name="l02720"></a>02720 <span class="comment">// ENTREE : &quot;face&quot; est le numero global de la face INTERNE</span>
<a name="l02721"></a>02721 <span class="comment">// ou PERIODIQUE dont on veut calculer le gradient</span>
<a name="l02722"></a>02722 <span class="comment">// SORTIE : &quot;som_glob&quot; est une liste qui contient tous les sommets</span>
<a name="l02723"></a>02723 <span class="comment">// inclus dans le stencil de &quot;face&quot;</span>
<a name="l02724"></a>02724 <span class="comment">// SORTIE : &quot;nnz&quot; est le nombre de sommets inclus dans le stencil</span>
<a name="l02725"></a>02725 <span class="comment">// de face</span>
<a name="l02726"></a>02726 <span class="keywordtype">void</span> <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a37f70143adef3313705fb8583168fd93">Op_Diff_VEFP1NCP1B_Face::</a>
<a name="l02727"></a><a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#aef8420d4ce23c86e97333c7eeefb08cc">02727</a> <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a37f70143adef3313705fb8583168fd93">gradient_som</a>(<span class="keyword">const</span> <span class="keywordtype">int</span>&amp; face,<span class="keywordtype">int</span>&amp; nnz, <a class="code" href="classIntVect.html">IntVect</a>&amp; som_glob,<a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; grad)<span class="keyword"> const</span>
<a name="l02728"></a>02728 <span class="keyword"></span>{
<a name="l02729"></a>02729   <span class="keyword">const</span> <a class="code" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a>&amp; zone_VEF=<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a8d6cebdde81108b4c492d8af3d6d60ae">zone_VEFPreP1B</a>();
<a name="l02730"></a>02730   <span class="keyword">const</span> <a class="code" href="classZone.html" title="classe Zone Une Zone est un maillage compose d&#39;un ensemble d&#39;elements geometriques de meme type...">Zone</a>&amp; zone=zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>();
<a name="l02731"></a>02731   <span class="keyword">const</span> <a class="code" href="classDomaine.html" title="Classe Domaine Un Domaine represente le domaine (spatial) de resolution d&#39;un Probleme. Un Domaine a un Nom, il est constitue d&#39;une ou plusieurs Zone qui peuvent etre eventuellement decoupees en Sous_Zone. Un Domaine porte l&#39;ensemble des sommets utilises par ses Zones. On peut vouloir resoudre des problemes de type different sur plusieurs domaines, geometriquement les domaines sont alors couples par des surfaces qu&#39;on appelle Raccord.">Domaine</a>&amp; dom=zone.<a class="code" href="classZone.html#a379ad2206b5a13a4f4f3df6d44c7546a" title="Renvoie le domaine dont la zone fait partie. (version const)">domaine</a>();
<a name="l02732"></a>02732 
<a name="l02733"></a>02733   <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; face_normales=zone_VEF.<a class="code" href="classZone__VEF.html#a5742d75972e4846bf9fbb6ed5715053e">face_normales</a>();
<a name="l02734"></a>02734   <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; volume_aux_sommets=zone_VEF.<a class="code" href="classZone__VEF__PreP1b.html#ac8282d378ae480144d75129df4a8c55c">volume_aux_sommets</a>();
<a name="l02735"></a>02735 
<a name="l02736"></a>02736   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; elem_faces=zone_VEF.<a class="code" href="classZone__VF.html#a067e462dcd3ab92b0f6d945b19e4eb37" title="renvoie le numero de le ieme face de la maille num_elem la facon dont ces faces sont numerotees est l...">elem_faces</a>();
<a name="l02737"></a>02737   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; face_voisins=zone_VEF.<a class="code" href="classZone__VF.html#a49d4322f5585a8fa95748ca785b70702" title="renvoie l&#39;element voisin de numface dans la direction i. i=0 : dans le sens oppose de l&#39;axe orthogona...">face_voisins</a>();
<a name="l02738"></a>02738   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; elem_som=zone.<a class="code" href="classZone.html#ac115e8342be89afb882b7b61cc343267" title="Renvoie le tableau des sommets des elements.">les_elems</a>();
<a name="l02739"></a>02739 
<a name="l02740"></a>02740   <span class="keyword">const</span> <span class="keywordtype">double</span> <a class="code" href="Champ__P1iP1B__implementation_8cpp.html#aa8c8f49390c3cf7c702d71a71bc977e3">coeff</a>=1./<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>;
<a name="l02741"></a>02741   <span class="keyword">const</span> <span class="keywordtype">double</span> coeff_som=coeff/(<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>+1);
<a name="l02742"></a>02742 
<a name="l02743"></a>02743   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_som_elem=zone.<a class="code" href="classZone.html#ae0b34a93b9ae8146df2d1884157afe9f" title="Renvoie le nombre de sommets des elements geometriques constituants la zone. Tous les elements de la ...">nb_som_elem</a>();
<a name="l02744"></a>02744 
<a name="l02745"></a>02745   <span class="keywordtype">int</span> face_opp=0,compj=0;
<a name="l02746"></a>02746   <span class="keywordtype">int</span> som_loc=0,som=0;
<a name="l02747"></a>02747   <span class="keywordtype">int</span> loc=0;
<a name="l02748"></a>02748   <span class="keywordtype">int</span> elem=0;
<a name="l02749"></a>02749 
<a name="l02750"></a>02750   <span class="keywordtype">double</span> signe=0.;
<a name="l02751"></a>02751   <span class="keywordtype">double</span> volume=0.;
<a name="l02752"></a>02752 
<a name="l02753"></a>02753   assert(som_glob.<a class="code" href="classIntVect.html#ad90cfd411cbbd631ccf1935bb36f7c40" title="Identique a size_reelle()">size</a>()==<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>+2);
<a name="l02754"></a>02754   assert(grad.<a class="code" href="classDoubleTab.html#ae6dda48778e7107e1beb723beef1f75b" title="Returns the number of dimensions of the array (&gt;= 1)">nb_dim</a>()==2);
<a name="l02755"></a>02755   assert(grad.<a class="code" href="classDoubleTab.html#ac3805e2637a3b880ba2d3e650c69dac4" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(1)==<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>+2);
<a name="l02756"></a>02756 
<a name="l02757"></a>02757 <span class="comment">// </span>
<a name="l02758"></a>02758 <span class="comment">// Calcul du gradient</span>
<a name="l02759"></a>02759 <span class="comment">// </span>
<a name="l02760"></a>02760 
<a name="l02761"></a>02761   nnz=0;
<a name="l02762"></a>02762   <span class="comment">/* On regarde le premier element voisin */</span>
<a name="l02763"></a>02763   elem=face_voisins(face,0);
<a name="l02764"></a>02764   assert(elem!=-1);
<a name="l02765"></a>02765 
<a name="l02766"></a>02766   <span class="keywordflow">for</span> (som_loc=0; som_loc&lt;nb_som_elem; som_loc++)
<a name="l02767"></a>02767     {
<a name="l02768"></a>02768       som=elem_som(elem,som_loc);
<a name="l02769"></a>02769       som=dom.<a class="code" href="classDomaine.html#a37cc657f1907d53b0d5a573da862af80">get_renum_som_perio</a>(som);
<a name="l02770"></a>02770 
<a name="l02771"></a>02771       face_opp=elem_faces(elem,som_loc);
<a name="l02772"></a>02772       signe=1.;
<a name="l02773"></a>02773       <span class="keywordflow">if</span>(elem!=face_voisins(face_opp,0)) signe=-1.;
<a name="l02774"></a>02774 
<a name="l02775"></a>02775 <span class="comment">// ajout a la liste et incrementation du repere</span>
<a name="l02776"></a>02776       som_glob(som_loc)=som;
<a name="l02777"></a>02777       nnz++;
<a name="l02778"></a>02778 
<a name="l02779"></a>02779 <span class="comment">// Calcul du gradient local</span>
<a name="l02780"></a>02780       <span class="keywordflow">for</span>(compj=0; compj&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; compj++)
<a name="l02781"></a>02781         grad(compj,som_loc)=coeff_som*signe*
<a name="l02782"></a>02782                             face_normales(face_opp,compj);
<a name="l02783"></a>02783     }
<a name="l02784"></a>02784   assert(nnz==nb_som_elem);
<a name="l02785"></a>02785 
<a name="l02786"></a>02786   <span class="comment">/* On regarde le deuxieme element voisin */</span>
<a name="l02787"></a>02787   elem=face_voisins(face,1);
<a name="l02788"></a>02788   assert(elem!=-1);
<a name="l02789"></a>02789 
<a name="l02790"></a>02790   <span class="keywordflow">for</span> (som_loc=0; som_loc&lt;nb_som_elem; som_loc++)
<a name="l02791"></a>02791     {
<a name="l02792"></a>02792       som=elem_som(elem,som_loc);
<a name="l02793"></a>02793       som=dom.<a class="code" href="classDomaine.html#a37cc657f1907d53b0d5a573da862af80">get_renum_som_perio</a>(som);
<a name="l02794"></a>02794 
<a name="l02795"></a>02795       face_opp=elem_faces(elem,som_loc);
<a name="l02796"></a>02796       signe=1.;
<a name="l02797"></a>02797       <span class="keywordflow">if</span>(elem!=face_voisins(face_opp,0)) signe=-1.;
<a name="l02798"></a>02798 
<a name="l02799"></a>02799 <span class="comment">// Localisation dans la liste deja construite</span>
<a name="l02800"></a>02800       <span class="keywordflow">for</span> (loc=0; loc&lt;nnz; loc++)
<a name="l02801"></a>02801         <span class="keywordflow">if</span> (som_glob[loc]==som)
<a name="l02802"></a>02802           <span class="keywordflow">break</span>;
<a name="l02803"></a>02803 
<a name="l02804"></a>02804 <span class="comment">// ajout a la liste et incrementation du repere</span>
<a name="l02805"></a>02805       <span class="keywordflow">if</span> (loc==nnz)
<a name="l02806"></a>02806         {
<a name="l02807"></a>02807           som_glob(nnz)=som;
<a name="l02808"></a>02808           nnz++;
<a name="l02809"></a>02809         }
<a name="l02810"></a>02810 
<a name="l02811"></a>02811 <span class="comment">// Calcul du gradient local</span>
<a name="l02812"></a>02812       <span class="keywordflow">for</span>(compj=0; compj&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; compj++)
<a name="l02813"></a>02813         grad(compj,loc)+=coeff_som*signe*
<a name="l02814"></a>02814                          face_normales(face_opp,compj);
<a name="l02815"></a>02815     }
<a name="l02816"></a>02816   assert(nnz&lt;=(<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>+2));
<a name="l02817"></a>02817 
<a name="l02818"></a>02818   <span class="keywordflow">for</span> (som_loc=0; som_loc&lt;nnz; som_loc++)
<a name="l02819"></a>02819     {
<a name="l02820"></a>02820       som=som_glob(som_loc);
<a name="l02821"></a>02821       volume=<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a90fc51e82567cc139118e78417436ef2">coeff_</a>*volume_aux_sommets(som);
<a name="l02822"></a>02822 
<a name="l02823"></a>02823 <span class="comment">// On divise par la matrice de masse lumpee</span>
<a name="l02824"></a>02824       <span class="keywordflow">for</span>(compj=0; compj&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; compj++)
<a name="l02825"></a>02825         grad(compj,som_loc)/=volume;
<a name="l02826"></a>02826     }
<a name="l02827"></a>02827 }
<a name="l02828"></a>02828 
<a name="l02829"></a>02829 <span class="comment">// Pour une face donnee, calcule le gradient associee a cette face</span>
<a name="l02830"></a>02830 <span class="comment">// pour chacun des sommets ou le gradient est non nul</span>
<a name="l02831"></a>02831 <span class="comment">// ATTENTION : cette fonction ne doit etre utilisee que pour le calcul</span>
<a name="l02832"></a>02832 <span class="comment">// des gradients pour remplir une LIGNE de la matrice</span>
<a name="l02833"></a>02833 <span class="comment">// CONTRAINTE : le tableau &quot;grad&quot; est sense etre correctement</span>
<a name="l02834"></a>02834 <span class="comment">// dimensionne AVANT l&#39;appel de cette fonction</span>
<a name="l02835"></a>02835 <span class="comment">// ENTREE : &quot;face&quot; est le numero global de la face de BORD</span>
<a name="l02836"></a>02836 <span class="comment">// NON PERIODIQUE dont on veut calculer le gradient</span>
<a name="l02837"></a>02837 <span class="comment">// SORTIE : &quot;som_glob&quot; est une liste qui contient tous les sommets</span>
<a name="l02838"></a>02838 <span class="comment">// inclus dans le stencil de &quot;face&quot;</span>
<a name="l02839"></a>02839 <span class="comment">// SORTIE : &quot;nnz&quot; est le nombre de sommets inclus dans le stencil</span>
<a name="l02840"></a>02840 <span class="comment">// de face</span>
<a name="l02841"></a>02841 <span class="keywordtype">void</span> <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a253bedb1323fa89e08a8d88e2be8798d">Op_Diff_VEFP1NCP1B_Face::</a>
<a name="l02842"></a><a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a253bedb1323fa89e08a8d88e2be8798d">02842</a> <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a253bedb1323fa89e08a8d88e2be8798d">gradient_som_CL</a>(<span class="keyword">const</span> <span class="keywordtype">int</span>&amp; face,<span class="keywordtype">int</span>&amp; nnz, <a class="code" href="classIntVect.html">IntVect</a>&amp; som_glob,<a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; grad)<span class="keyword"> const</span>
<a name="l02843"></a>02843 <span class="keyword"></span>{
<a name="l02844"></a>02844   <span class="keyword">const</span> <a class="code" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a>&amp; zone_VEF=<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a8d6cebdde81108b4c492d8af3d6d60ae">zone_VEFPreP1B</a>();
<a name="l02845"></a>02845   <span class="keyword">const</span> <a class="code" href="classZone.html" title="classe Zone Une Zone est un maillage compose d&#39;un ensemble d&#39;elements geometriques de meme type...">Zone</a>&amp; zone=zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>();
<a name="l02846"></a>02846   <span class="keyword">const</span> <a class="code" href="classDomaine.html" title="Classe Domaine Un Domaine represente le domaine (spatial) de resolution d&#39;un Probleme. Un Domaine a un Nom, il est constitue d&#39;une ou plusieurs Zone qui peuvent etre eventuellement decoupees en Sous_Zone. Un Domaine porte l&#39;ensemble des sommets utilises par ses Zones. On peut vouloir resoudre des problemes de type different sur plusieurs domaines, geometriquement les domaines sont alors couples par des surfaces qu&#39;on appelle Raccord.">Domaine</a>&amp; dom=zone.<a class="code" href="classZone.html#a379ad2206b5a13a4f4f3df6d44c7546a" title="Renvoie le domaine dont la zone fait partie. (version const)">domaine</a>();
<a name="l02847"></a>02847 
<a name="l02848"></a>02848   <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; face_normales=zone_VEF.<a class="code" href="classZone__VEF.html#a5742d75972e4846bf9fbb6ed5715053e">face_normales</a>();
<a name="l02849"></a>02849   <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; volume_aux_sommets=zone_VEF.<a class="code" href="classZone__VEF__PreP1b.html#ac8282d378ae480144d75129df4a8c55c">volume_aux_sommets</a>();
<a name="l02850"></a>02850 
<a name="l02851"></a>02851   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; elem_faces=zone_VEF.<a class="code" href="classZone__VF.html#a067e462dcd3ab92b0f6d945b19e4eb37" title="renvoie le numero de le ieme face de la maille num_elem la facon dont ces faces sont numerotees est l...">elem_faces</a>();
<a name="l02852"></a>02852   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; face_voisins=zone_VEF.<a class="code" href="classZone__VF.html#a49d4322f5585a8fa95748ca785b70702" title="renvoie l&#39;element voisin de numface dans la direction i. i=0 : dans le sens oppose de l&#39;axe orthogona...">face_voisins</a>();
<a name="l02853"></a>02853   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; elem_som=zone.<a class="code" href="classZone.html#ac115e8342be89afb882b7b61cc343267" title="Renvoie le tableau des sommets des elements.">les_elems</a>();
<a name="l02854"></a>02854   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; face_sommets=zone_VEF.<a class="code" href="classZone__VF.html#a298e73b18e17da55f421b1fb0879bd46" title="renvoie le numero du ieme sommet de la face num_face.">face_sommets</a>();
<a name="l02855"></a>02855 
<a name="l02856"></a>02856   <span class="keyword">const</span> <span class="keywordtype">double</span> <a class="code" href="Champ__P1iP1B__implementation_8cpp.html#aa8c8f49390c3cf7c702d71a71bc977e3">coeff</a>=1./<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>;
<a name="l02857"></a>02857   <span class="keyword">const</span> <span class="keywordtype">double</span> coeff_som=coeff/(<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>+1);
<a name="l02858"></a>02858 
<a name="l02859"></a>02859   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_som_elem=zone.<a class="code" href="classZone.html#ae0b34a93b9ae8146df2d1884157afe9f" title="Renvoie le nombre de sommets des elements geometriques constituants la zone. Tous les elements de la ...">nb_som_elem</a>();
<a name="l02860"></a>02860   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_som_face=zone_VEF.<a class="code" href="classZone__VF.html#a990808f967f351edbb83ff11d60b7445" title="renvoie le nombre de sommets par face. Rque : on a suppose que toutes les faces avait le meme nombre ...">nb_som_face</a>();
<a name="l02861"></a>02861 
<a name="l02862"></a>02862   <span class="keywordtype">int</span> face_opp=0,compj=0;
<a name="l02863"></a>02863   <span class="keywordtype">int</span> som_loc=0,som=0;
<a name="l02864"></a>02864   <span class="keywordtype">int</span> loc=0;
<a name="l02865"></a>02865   <span class="keywordtype">int</span> elem=0;
<a name="l02866"></a>02866 
<a name="l02867"></a>02867   <span class="keywordtype">double</span> signe=0.;
<a name="l02868"></a>02868   <span class="keywordtype">double</span> volume=0.;
<a name="l02869"></a>02869 
<a name="l02870"></a>02870   assert(som_glob.<a class="code" href="classIntVect.html#ad90cfd411cbbd631ccf1935bb36f7c40" title="Identique a size_reelle()">size</a>()==<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>+2);
<a name="l02871"></a>02871   assert(grad.<a class="code" href="classDoubleTab.html#ae6dda48778e7107e1beb723beef1f75b" title="Returns the number of dimensions of the array (&gt;= 1)">nb_dim</a>()==2);
<a name="l02872"></a>02872   assert(grad.<a class="code" href="classDoubleTab.html#ac3805e2637a3b880ba2d3e650c69dac4" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(1)==<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>+2);
<a name="l02873"></a>02873 
<a name="l02874"></a>02874 <span class="comment">// </span>
<a name="l02875"></a>02875 <span class="comment">// Calcul du gradient</span>
<a name="l02876"></a>02876 <span class="comment">// </span>
<a name="l02877"></a>02877 
<a name="l02878"></a>02878   nnz=0;
<a name="l02879"></a>02879   <span class="comment">/* On regarde le premier element voisin */</span>
<a name="l02880"></a>02880   elem=face_voisins(face,0);
<a name="l02881"></a>02881   assert(elem!=-1);
<a name="l02882"></a>02882 
<a name="l02883"></a>02883   <span class="keywordflow">for</span> (som_loc=0; som_loc&lt;nb_som_elem; som_loc++)
<a name="l02884"></a>02884     {
<a name="l02885"></a>02885       som=elem_som(elem,som_loc);
<a name="l02886"></a>02886       som=dom.<a class="code" href="classDomaine.html#a37cc657f1907d53b0d5a573da862af80">get_renum_som_perio</a>(som);
<a name="l02887"></a>02887 
<a name="l02888"></a>02888       face_opp=elem_faces(elem,som_loc);
<a name="l02889"></a>02889       signe=1.;
<a name="l02890"></a>02890       <span class="keywordflow">if</span>(elem!=face_voisins(face_opp,0)) signe=-1.;
<a name="l02891"></a>02891 
<a name="l02892"></a>02892 <span class="comment">// ajout a la liste et incrementation du repere</span>
<a name="l02893"></a>02893       som_glob(som_loc)=som;
<a name="l02894"></a>02894       nnz++;
<a name="l02895"></a>02895 
<a name="l02896"></a>02896 <span class="comment">// Calcul du gradient local</span>
<a name="l02897"></a>02897       <span class="keywordflow">for</span>(compj=0; compj&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; compj++)
<a name="l02898"></a>02898         grad(compj,som_loc)=coeff_som*signe*
<a name="l02899"></a>02899                             face_normales(face_opp,compj);
<a name="l02900"></a>02900     }
<a name="l02901"></a>02901   assert(nnz==nb_som_elem);
<a name="l02902"></a>02902 
<a name="l02903"></a>02903   <span class="comment">/* On regarde le deuxieme element voisin */</span>
<a name="l02904"></a>02904   assert(face_voisins(face,1)==-1);
<a name="l02905"></a>02905 
<a name="l02906"></a>02906   <span class="keywordflow">for</span> (som_loc=0; som_loc&lt;nb_som_face; som_loc++) <span class="comment">//sommets de &quot;face&quot;</span>
<a name="l02907"></a>02907     {
<a name="l02908"></a>02908       som=face_sommets(face,som_loc);
<a name="l02909"></a>02909       som=dom.<a class="code" href="classDomaine.html#a37cc657f1907d53b0d5a573da862af80">get_renum_som_perio</a>(som);
<a name="l02910"></a>02910 
<a name="l02911"></a>02911       <span class="keywordflow">for</span> (loc=0; loc&lt;nnz; loc++)
<a name="l02912"></a>02912         <span class="keywordflow">if</span> (som_glob(loc)==som)
<a name="l02913"></a>02913           <span class="keywordflow">break</span>;
<a name="l02914"></a>02914       assert(som_loc&lt;nnz);
<a name="l02915"></a>02915 
<a name="l02916"></a>02916       <span class="keywordflow">for</span> (compj=0; compj&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; compj++)
<a name="l02917"></a>02917         grad(compj,loc)+=coeff*face_normales(face,compj) ;
<a name="l02918"></a>02918     }
<a name="l02919"></a>02919   assert(nnz&lt;=(<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>+2));
<a name="l02920"></a>02920 
<a name="l02921"></a>02921   <span class="keywordflow">for</span> (som_loc=0; som_loc&lt;nnz; som_loc++)
<a name="l02922"></a>02922     {
<a name="l02923"></a>02923       som=som_glob(som_loc);
<a name="l02924"></a>02924       volume=<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a90fc51e82567cc139118e78417436ef2">coeff_</a>*volume_aux_sommets(som);
<a name="l02925"></a>02925 
<a name="l02926"></a>02926 <span class="comment">// On divise par la matrice de masse lumpee</span>
<a name="l02927"></a>02927       <span class="keywordflow">for</span>(compj=0; compj&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; compj++)
<a name="l02928"></a>02928         grad(compj,som_loc)/=volume;
<a name="l02929"></a>02929     }
<a name="l02930"></a>02930 }
<a name="l02931"></a>02931 
<a name="l02932"></a>02932 
<a name="l02933"></a>02933 <span class="comment">// Fonction verifiant si &quot;som_glob&quot; est dans le stencil de &quot;face&quot;</span>
<a name="l02934"></a>02934 <span class="comment">// CONTRAINTE : &quot;som_glob&quot; DOIT etre un numero PERIODIQUE de sommet</span>
<a name="l02935"></a>02935 <span class="comment">// SORTIE : le numero des elements du stencil de &quot;face&quot; qui contiennent</span>
<a name="l02936"></a>02936 <span class="comment">// le sommet &quot;som_glob&quot;. Si le sommet n&#39;est pas contenu</span>
<a name="l02937"></a>02937 <span class="comment">// dans un des elements du stencil de &quot;face&quot; alors le numero</span>
<a name="l02938"></a>02938 <span class="comment">// de l&#39;element considere est mis a -1</span>
<a name="l02939"></a>02939 <span class="comment">// SORTIE : som_loc0 et som_loc1 sont les numeros locaux de som_glob</span>
<a name="l02940"></a>02940 <span class="comment">// dans respectivement elem0 et elem1.</span>
<a name="l02941"></a>02941 <span class="comment">// Si les sommet n&#39;est pas contenu dans un des elements du</span>
<a name="l02942"></a>02942 <span class="comment">// stencil de &quot;face&quot; alors le numero local du sommet</span>
<a name="l02943"></a>02943 <span class="comment">// correspondant est mis a -1</span>
<a name="l02944"></a><a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a035d8cdf71b99212df20fadc0f2c997e">02944</a> <span class="keywordtype">void</span> <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a035d8cdf71b99212df20fadc0f2c997e">Op_Diff_VEFP1NCP1B_Face::isInStencil</a>(<span class="keywordtype">int</span> face,<span class="keywordtype">int</span> som_glob,
<a name="l02945"></a>02945                                           <span class="keywordtype">int</span>&amp; elem0, <span class="keywordtype">int</span>&amp; som_loc0,
<a name="l02946"></a>02946                                           <span class="keywordtype">int</span>&amp; elem1, <span class="keywordtype">int</span>&amp; som_loc1)<span class="keyword"> const</span>
<a name="l02947"></a>02947 <span class="keyword"></span>{
<a name="l02948"></a>02948   <span class="keyword">const</span> <a class="code" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a>&amp; zone_VEF=<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a8d6cebdde81108b4c492d8af3d6d60ae">zone_VEFPreP1B</a>();
<a name="l02949"></a>02949   <span class="keyword">const</span> <a class="code" href="classZone.html" title="classe Zone Une Zone est un maillage compose d&#39;un ensemble d&#39;elements geometriques de meme type...">Zone</a>&amp; zone=zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>();
<a name="l02950"></a>02950   <span class="keyword">const</span> <a class="code" href="classDomaine.html" title="Classe Domaine Un Domaine represente le domaine (spatial) de resolution d&#39;un Probleme. Un Domaine a un Nom, il est constitue d&#39;une ou plusieurs Zone qui peuvent etre eventuellement decoupees en Sous_Zone. Un Domaine porte l&#39;ensemble des sommets utilises par ses Zones. On peut vouloir resoudre des problemes de type different sur plusieurs domaines, geometriquement les domaines sont alors couples par des surfaces qu&#39;on appelle Raccord.">Domaine</a>&amp; dom=zone.<a class="code" href="classZone.html#a379ad2206b5a13a4f4f3df6d44c7546a" title="Renvoie le domaine dont la zone fait partie. (version const)">domaine</a>();
<a name="l02951"></a>02951 
<a name="l02952"></a>02952   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; face_voisins=zone_VEF.<a class="code" href="classZone__VF.html#a49d4322f5585a8fa95748ca785b70702" title="renvoie l&#39;element voisin de numface dans la direction i. i=0 : dans le sens oppose de l&#39;axe orthogona...">face_voisins</a>();
<a name="l02953"></a>02953   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; elem_som=zone.<a class="code" href="classZone.html#ac115e8342be89afb882b7b61cc343267" title="Renvoie le tableau des sommets des elements.">les_elems</a>();
<a name="l02954"></a>02954 
<a name="l02955"></a>02955   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_som_elem=zone.<a class="code" href="classZone.html#ae0b34a93b9ae8146df2d1884157afe9f" title="Renvoie le nombre de sommets des elements geometriques constituants la zone. Tous les elements de la ...">nb_som_elem</a>();
<a name="l02956"></a>02956 
<a name="l02957"></a>02957   <span class="keywordtype">int</span> elem00=0,elem11=0;
<a name="l02958"></a>02958   <span class="keywordtype">int</span> som_loc=0,som=0;
<a name="l02959"></a>02959 
<a name="l02960"></a>02960   elem00=face_voisins(face,0);
<a name="l02961"></a>02961   assert(elem00!=-1);
<a name="l02962"></a>02962 
<a name="l02963"></a>02963   <span class="keywordflow">for</span> (som_loc=0; som_loc&lt;nb_som_elem; som_loc++)
<a name="l02964"></a>02964     {
<a name="l02965"></a>02965       som=elem_som(elem00,som_loc);
<a name="l02966"></a>02966       som=dom.<a class="code" href="classDomaine.html#a37cc657f1907d53b0d5a573da862af80">get_renum_som_perio</a>(som);
<a name="l02967"></a>02967 
<a name="l02968"></a>02968       <span class="keywordflow">if</span> (som_glob==som)
<a name="l02969"></a>02969         {
<a name="l02970"></a>02970           som_loc0=som_loc;
<a name="l02971"></a>02971           elem0=elem00;
<a name="l02972"></a>02972           <span class="keywordflow">break</span>;
<a name="l02973"></a>02973         }
<a name="l02974"></a>02974     }
<a name="l02975"></a>02975   <span class="keywordflow">if</span> (som_loc==nb_som_elem)
<a name="l02976"></a>02976     {
<a name="l02977"></a>02977       elem0=-1;
<a name="l02978"></a>02978       som_loc0=-1;
<a name="l02979"></a>02979     }
<a name="l02980"></a>02980 
<a name="l02981"></a>02981   elem11=face_voisins(face,1);
<a name="l02982"></a>02982   <span class="keywordflow">if</span> (elem11==-1)
<a name="l02983"></a>02983     {
<a name="l02984"></a>02984       elem1=-1;
<a name="l02985"></a>02985       som_loc1=-1;
<a name="l02986"></a>02986     }
<a name="l02987"></a>02987   <span class="keywordflow">else</span>
<a name="l02988"></a>02988     <span class="keywordflow">for</span> (som_loc=0; som_loc&lt;nb_som_elem; som_loc++)
<a name="l02989"></a>02989       {
<a name="l02990"></a>02990         som=elem_som(elem11,som_loc);
<a name="l02991"></a>02991         som=dom.<a class="code" href="classDomaine.html#a37cc657f1907d53b0d5a573da862af80">get_renum_som_perio</a>(som);
<a name="l02992"></a>02992 
<a name="l02993"></a>02993         <span class="keywordflow">if</span> (som_glob==som)
<a name="l02994"></a>02994           {
<a name="l02995"></a>02995             som_loc1=som_loc;
<a name="l02996"></a>02996             elem1=elem11;
<a name="l02997"></a>02997             <span class="keywordflow">break</span>;
<a name="l02998"></a>02998           }
<a name="l02999"></a>02999       }
<a name="l03000"></a>03000   <span class="keywordflow">if</span> (som_loc==nb_som_elem)
<a name="l03001"></a>03001     {
<a name="l03002"></a>03002       elem1=-1;
<a name="l03003"></a>03003       som_loc1=-1;
<a name="l03004"></a>03004     }
<a name="l03005"></a>03005 
<a name="l03006"></a>03006 <span class="comment">// On ordonne</span>
<a name="l03007"></a>03007   <span class="keywordflow">if</span> (elem0==-1 &amp;&amp; elem1!=-1)
<a name="l03008"></a>03008     {
<a name="l03009"></a>03009       elem0=elem1;
<a name="l03010"></a>03010       elem1=-1;
<a name="l03011"></a>03011       som_loc0=som_loc1;
<a name="l03012"></a>03012       som_loc1=-1;
<a name="l03013"></a>03013     }
<a name="l03014"></a>03014 }
<a name="l03015"></a>03015 
<a name="l03016"></a><a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#af8e127ec31241c8d2aab78ad951aa253">03016</a> <span class="keywordtype">void</span> <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#af8e127ec31241c8d2aab78ad951aa253" title="on dimensionne notre matrice.">Op_Diff_VEFP1NCP1B_Face::dimensionner</a>(<a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; matrice)<span class="keyword"> const</span>
<a name="l03017"></a>03017 <span class="keyword"></span>{
<a name="l03018"></a>03018   <span class="keyword">const</span> <a class="code" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a>&amp; zone_VEF = <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a8d6cebdde81108b4c492d8af3d6d60ae">zone_VEFPreP1B</a>();
<a name="l03019"></a>03019 
<a name="l03020"></a>03020   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_faces_tot=zone_VEF.<a class="code" href="classZone__VF.html#a50fd21c9535680489015a3c8b88c685a" title="renvoie le nombre total de faces. C&#39;est-a-dire faces reelles + faces virtuelles">nb_faces_tot</a>();
<a name="l03021"></a>03021   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_comp = <a class="code" href="classOp__Diff__VEF__base.html#abbeb435814253a33ecaf170b6f03829f">inconnue_</a>.<a class="code" href="classRef__Champ__Inc__base.html#a17553641a4c06730e1562125e07b3490">valeur</a>().<a class="code" href="classChamp__Inc__base.html#adb537f43f1649e103a8980314c7ed175" title="Renvoie le tableau des valeurs du champ au temps courant.">valeurs</a>().<a class="code" href="classDoubleVect.html#ab02d01cd1bdab66fbd66f9a47cc29e10">line_size</a>();
<a name="l03022"></a>03022 
<a name="l03023"></a>03023   <span class="keywordtype">int</span> face=0;
<a name="l03024"></a>03024   <span class="keywordtype">int</span> i=0,size=0;
<a name="l03025"></a>03025   <span class="keywordtype">int</span> comp=0,nnz=0,debut=0,face_f77=0,face_C=0;
<a name="l03026"></a>03026   <span class="keywordtype">int</span> nb_faces_of_symetry=0;
<a name="l03027"></a>03027   <span class="keywordtype">int</span> <a class="code" href="Zone__VEF__PreP1b_8cpp.html#a24a462bbedad66c2a21f5f6f84b8ec5b">next</a>=0;
<a name="l03028"></a>03028 
<a name="l03029"></a>03029   <a class="code" href="classArrOfBit.html">ArrOfBit</a> is_symetry(nb_faces_tot);
<a name="l03030"></a>03030 
<a name="l03031"></a>03031   <a class="code" href="classIntVect.html">IntVect</a>&amp; tab1 = matrice.<a class="code" href="classMatrice__Morse.html#a7a49c763706dcfaed900f9d2cbb68716">get_set_tab1</a>();
<a name="l03032"></a>03032   <a class="code" href="classIntVect.html">IntVect</a>&amp; tab2 = matrice.<a class="code" href="classMatrice__Morse.html#af11c5853518e9e6db4c7e6e6acc8d7fd">get_set_tab2</a>();
<a name="l03033"></a>03033 
<a name="l03034"></a>03034   <a class="code" href="classIntLists.html" title="Un tableau de listes de type IntList.">IntLists</a> faces_faces;
<a name="l03035"></a>03035 
<a name="l03036"></a>03036   <span class="keywordflow">if</span> (<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#acbd7461fb999d27a3c1ba0320f13563a">alphaE</a> &amp;&amp; !<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a0ff8784f933eedd5f6a52db444f2d71b">alphaS</a> &amp;&amp; !<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a3ca993ddf7251f0c1f79b9c659d5a96f">alphaA</a>)
<a name="l03037"></a>03037     <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#af8e127ec31241c8d2aab78ad951aa253" title="on dimensionne notre matrice.">Op_VEF_Face::dimensionner</a>(<a class="code" href="classOp__Diff__VEF__base.html#aadbdb144954bc7c5b56862e1f9f3c7f9">la_zone_vef</a>.<a class="code" href="classRef__Zone__VEF.html#aafd9a5ee1a76f290c9c6b5447b0c8d30">valeur</a>(), <a class="code" href="classOp__Diff__VEF__base.html#a721f395a27f12a95882437c614e16a7d">la_zcl_vef</a>.<a class="code" href="classRef__Zone__Cl__VEF.html#a0970d7253def65ad4f0c5ce1830fd243">valeur</a>(), matrice);
<a name="l03038"></a>03038 
<a name="l03039"></a>03039   <span class="keywordflow">if</span> (<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a0ff8784f933eedd5f6a52db444f2d71b">alphaS</a>)
<a name="l03040"></a>03040     {
<a name="l03041"></a>03041 <span class="comment">// Calcul de la liste des faces</span>
<a name="l03042"></a>03042       <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#ae2379b34f16ef970c39d7c515f51547c">liste_face</a>(faces_faces,nnz);
<a name="l03043"></a>03043       <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a0e34a4eb1127c6810d661018f42e840c">isFaceOfSymetry</a>(is_symetry,nb_faces_of_symetry);
<a name="l03044"></a>03044 
<a name="l03045"></a>03045 <span class="comment">// Dimensionnement des tableaux de la matrice</span>
<a name="l03046"></a>03046 <span class="comment">// REMARQUE : par essence, ce dimensionnement sera toujours plus GRAND</span>
<a name="l03047"></a>03047 <span class="comment">// que le dimensionnement par defaut issu de OP_VEF_FACE</span>
<a name="l03048"></a>03048 <span class="comment">// REMARQUE : pour tenir compte des contraintes dues aux faces de</span>
<a name="l03049"></a>03049 <span class="comment">// symetrie, le dimensionnement de la matrice doit etre legerement</span>
<a name="l03050"></a>03050 <span class="comment">// elargie</span>
<a name="l03051"></a>03051       size=nnz*nb_comp;<span class="comment">//dimensionnement sans face de symetrie</span>
<a name="l03052"></a>03052 <span class="comment">// size+=nb_faces_of_symetry*(nb_comp-1)*nb_comp;//dimensionnement avec faces de symetrie</span>
<a name="l03053"></a>03053 <span class="comment">// pour chaque face de symetrie pour chaque composante on ajoute nb_comp coeffs pour chaque face liee</span>
<a name="l03054"></a>03054       <span class="keywordflow">for</span> (face=0; face&lt;nb_faces_tot; face++)
<a name="l03055"></a>03055         <span class="keywordflow">if</span> (is_symetry[face])
<a name="l03056"></a>03056           {
<a name="l03057"></a>03057             <span class="keywordtype">int</span> nb_v=faces_faces[face].<a class="code" href="classIntLists.html#a823946693bc491321765f0e6805204e2" title="retourne le nombre de listes dans le tableau">size</a>();
<a name="l03058"></a>03058             size+=nb_v*(nb_comp-1)*nb_comp;
<a name="l03059"></a>03059           }
<a name="l03060"></a>03060 
<a name="l03061"></a>03061       matrice.<a class="code" href="classMatrice__Morse.html#ae95f9ed88a8a3fc637cd2a705cead9c8" title="Size the matrix with n lines and n columns and nnz zero-values coefficients.">dimensionner</a>(nb_faces_tot*nb_comp,size);
<a name="l03062"></a>03062 
<a name="l03063"></a>03063 <span class="comment">// Initialisation des grandeurs connues pour tab1</span>
<a name="l03064"></a>03064       tab1[nb_faces_tot*nb_comp]=size+1;
<a name="l03065"></a>03065       tab1[0]=1;
<a name="l03066"></a>03066 
<a name="l03067"></a>03067 <span class="comment">// Remplissage de tab1</span>
<a name="l03068"></a>03068 
<a name="l03069"></a>03069       <span class="comment">/* pour les autres composantes de la face 0 */</span>
<a name="l03070"></a>03070       size=faces_faces[0].<a class="code" href="classIntLists.html#a823946693bc491321765f0e6805204e2" title="retourne le nombre de listes dans le tableau">size</a>();
<a name="l03071"></a>03071       <span class="keywordflow">if</span> (is_symetry[0]) size*=(nb_comp);
<a name="l03072"></a>03072       <span class="keywordflow">for</span> (comp=1; comp&lt;nb_comp; comp++)
<a name="l03073"></a>03073         {
<a name="l03074"></a>03074           face_C=comp;
<a name="l03075"></a>03075           tab1[face_C]=tab1[face_C-1]+size;
<a name="l03076"></a>03076         }
<a name="l03077"></a>03077 
<a name="l03078"></a>03078       <span class="comment">/* pour les autres faces */</span>
<a name="l03079"></a>03079       <span class="keywordflow">for</span> (face=1; face&lt;nb_faces_tot; face++)
<a name="l03080"></a>03080         {
<a name="l03081"></a>03081           size=faces_faces[face-1].<a class="code" href="classIntLists.html#a823946693bc491321765f0e6805204e2" title="retourne le nombre de listes dans le tableau">size</a>();
<a name="l03082"></a>03082           <span class="keywordflow">if</span> (is_symetry[face-1]) size*=(nb_comp);
<a name="l03083"></a>03083           <span class="keywordflow">for</span> (comp=0; comp&lt;nb_comp; comp++)
<a name="l03084"></a>03084             {
<a name="l03085"></a>03085               face_C=face*nb_comp+comp;
<a name="l03086"></a>03086               tab1[face_C]=tab1[face_C-1]+size;
<a name="l03087"></a>03087               size=faces_faces[face].<a class="code" href="classIntLists.html#a823946693bc491321765f0e6805204e2" title="retourne le nombre de listes dans le tableau">size</a>();
<a name="l03088"></a>03088               <span class="keywordflow">if</span> (is_symetry[face]) size*=(nb_comp);
<a name="l03089"></a>03089             }
<a name="l03090"></a>03090         }
<a name="l03091"></a>03091 
<a name="l03092"></a>03092 <span class="comment">// Remplissage de tab2</span>
<a name="l03093"></a>03093       <span class="keywordflow">for</span> (face=0; face&lt;nb_faces_tot; face++)
<a name="l03094"></a>03094         {
<a name="l03095"></a>03095           size=faces_faces[face].<a class="code" href="classIntLists.html#a823946693bc491321765f0e6805204e2" title="retourne le nombre de listes dans le tableau">size</a>();
<a name="l03096"></a>03096 
<a name="l03097"></a>03097           <span class="keywordflow">for</span> (comp=0; comp&lt;nb_comp; comp++)
<a name="l03098"></a>03098             {
<a name="l03099"></a>03099               debut=tab1[face*nb_comp+comp]-1;
<a name="l03100"></a>03100 
<a name="l03101"></a>03101               <span class="keywordflow">for</span> (i=0; i&lt;size; i++)
<a name="l03102"></a>03102                 {
<a name="l03103"></a>03103                   face_C=faces_faces[face][i]*nb_comp+comp;
<a name="l03104"></a>03104                   face_f77=face_C+1;
<a name="l03105"></a>03105                   tab2[debut+i]=face_f77;
<a name="l03106"></a>03106                 }<span class="comment">//fin du for sur &quot;i&quot;</span>
<a name="l03107"></a>03107 
<a name="l03108"></a>03108             }<span class="comment">//fin du for sur &quot;comp&quot;</span>
<a name="l03109"></a>03109 
<a name="l03110"></a>03110         }<span class="comment">//fin du for sur &quot;face&quot;</span>
<a name="l03111"></a>03111 
<a name="l03112"></a>03112       <span class="keywordflow">for</span> (face=0; face&lt;nb_faces_tot; face++)
<a name="l03113"></a>03113         <span class="keywordflow">if</span> (is_symetry[face])
<a name="l03114"></a>03114           {
<a name="l03115"></a>03115             size=faces_faces[face].<a class="code" href="classIntLists.html#a823946693bc491321765f0e6805204e2" title="retourne le nombre de listes dans le tableau">size</a>();
<a name="l03116"></a>03116 
<a name="l03117"></a>03117             <span class="keywordflow">for</span> (comp=0; comp&lt;nb_comp; comp++)
<a name="l03118"></a>03118               {
<a name="l03119"></a>03119                 debut=tab1[face*nb_comp+comp]-1;
<a name="l03120"></a>03120                 debut+=size;
<a name="l03121"></a>03121                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> voi=0; voi&lt;size; voi++)
<a name="l03122"></a>03122                   {
<a name="l03123"></a>03123                     <span class="keywordtype">int</span> face2=faces_faces[face][voi];
<a name="l03124"></a>03124                     <span class="keywordflow">for</span> (i=0; i&lt;nb_comp-1; i++)
<a name="l03125"></a>03125                       {
<a name="l03126"></a>03126 <span class="comment">// reste de la division euclidienne</span>
<a name="l03127"></a>03127                         next=(comp+i+1)%nb_comp;
<a name="l03128"></a>03128                         face_C=face2*nb_comp+<a class="code" href="Zone__VEF__PreP1b_8cpp.html#a24a462bbedad66c2a21f5f6f84b8ec5b">next</a>;
<a name="l03129"></a>03129                         face_f77=face_C+1;
<a name="l03130"></a>03130                         tab2[debut+i]=face_f77;
<a name="l03131"></a>03131 <span class="comment">// Cerr &lt;&lt;face*nb_comp+comp&lt;&lt;&quot; face &quot;&lt;&lt;face &lt;&lt; &quot; comp &quot;&lt;&lt; comp&lt;&lt; &quot; face2 &quot;&lt;&lt; face2 &lt;&lt; &quot; comp &quot;&lt;&lt;next &lt;&lt;&quot; jface2 &quot;&lt;&lt; face_C&lt;&lt;finl;</span>
<a name="l03132"></a>03132                         assert(debut+i&lt;tab1[face*nb_comp+comp+1]-1);
<a name="l03133"></a>03133                       }
<a name="l03134"></a>03134                     debut+=nb_comp-1;
<a name="l03135"></a>03135                   }
<a name="l03136"></a>03136 
<a name="l03137"></a>03137               }<span class="comment">//fin du for sur &quot;comp&quot;</span>
<a name="l03138"></a>03138 
<a name="l03139"></a>03139           }<span class="comment">//fin du for sur &quot;face&quot;</span>
<a name="l03140"></a>03140 
<a name="l03141"></a>03141     }<span class="comment">//fin du if sur &quot;alphaS&quot;</span>
<a name="l03142"></a>03142 
<a name="l03143"></a>03143   <span class="keywordflow">if</span> (<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a3ca993ddf7251f0c1f79b9c659d5a96f">alphaA</a>)
<a name="l03144"></a>03144     {
<a name="l03145"></a>03145       <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Erreur Op_Dift_VEFP1NCP1B_Face::dimensionner(Matrice_Morse&amp;)&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
<a name="l03146"></a>03146       <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Le dimensionnement de la matrice implicite avec l&#39;option alphaA&quot;</span>
<a name="l03147"></a>03147            &lt;&lt; <span class="stringliteral">&quot; n&#39;est pas encore codee&quot;</span> &lt;&lt; finl;
<a name="l03148"></a>03148       <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Sortie du programme&quot;</span> &lt;&lt; finl;
<a name="l03149"></a>03149       <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">exit</a>();
<a name="l03150"></a>03150     }
<a name="l03151"></a>03151 }
<a name="l03152"></a>03152 
<a name="l03153"></a>03153 <span class="comment">// Fonction qui initialise le tableau is_symetry passe en argument :</span>
<a name="l03154"></a>03154 <span class="comment">// -si une face &quot;f&quot; est une face de symetrie alors is_symetry(f)=1</span>
<a name="l03155"></a>03155 <span class="comment">// -si une face &quot;f&quot; n&#39;est pas une face de symetrie alors is_symetry(f)=0</span>
<a name="l03156"></a>03156 <span class="comment">// La fonction renvoie egalement le nombre total de faces de symetrie (argument nnz)</span>
<a name="l03157"></a>03157 <span class="comment">// REMARQUE : le tableau &quot;is_symetry&quot; doit etre dimensionne a nb_faces_tot</span>
<a name="l03158"></a>03158 <span class="comment">// AVANT d&#39;utiliser cette fonction</span>
<a name="l03159"></a><a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a0e34a4eb1127c6810d661018f42e840c">03159</a> <span class="keywordtype">void</span> <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a0e34a4eb1127c6810d661018f42e840c">Op_Diff_VEFP1NCP1B_Face::isFaceOfSymetry</a>(<a class="code" href="classArrOfBit.html">ArrOfBit</a>&amp; is_symetry,<span class="keywordtype">int</span>&amp; nnz)<span class="keyword"> const</span>
<a name="l03160"></a>03160 <span class="keyword"></span>{
<a name="l03161"></a>03161   <span class="keyword">const</span> <a class="code" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a>&amp; zone_VEF=<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a8d6cebdde81108b4c492d8af3d6d60ae">zone_VEFPreP1B</a>();
<a name="l03162"></a>03162   <span class="keyword">const</span> <a class="code" href="classZone__Cl__VEF.html">Zone_Cl_VEF</a>&amp; zone_Cl_VEF=<a class="code" href="classOp__Diff__VEF__base.html#a721f395a27f12a95882437c614e16a7d">la_zcl_vef</a>.<a class="code" href="classRef__Zone__Cl__VEF.html#a0970d7253def65ad4f0c5ce1830fd243">valeur</a>();
<a name="l03163"></a>03163 
<a name="l03164"></a>03164   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_bords=zone_VEF.<a class="code" href="classZone__dis__base.html#af22167d614644f55591a29c77eb1c009">nb_front_Cl</a>();
<a name="l03165"></a>03165 
<a name="l03166"></a>03166   <span class="keywordtype">int</span> n_bord=0;
<a name="l03167"></a>03167   <span class="keywordtype">int</span> num1=0,num2=0;
<a name="l03168"></a>03168   <span class="keywordtype">int</span> ind_face=0;
<a name="l03169"></a>03169 
<a name="l03170"></a>03170   assert(is_symetry.<a class="code" href="classArrOfBit.html#a3dc47c19e757ec4c3c757abeec29dc3a" title="Renvoie la taille du tableau en bits.">size_array</a>()==zone_VEF.<a class="code" href="classZone__VF.html#a50fd21c9535680489015a3c8b88c685a" title="renvoie le nombre total de faces. C&#39;est-a-dire faces reelles + faces virtuelles">nb_faces_tot</a>());
<a name="l03171"></a>03171 
<a name="l03172"></a>03172 <span class="comment">// Preinitialisation</span>
<a name="l03173"></a>03173   nnz=0;
<a name="l03174"></a>03174   is_symetry=0;
<a name="l03175"></a>03175 
<a name="l03176"></a>03176 <span class="comment">// Modification pour les faces de symetrie</span>
<a name="l03177"></a>03177   <span class="keywordflow">for</span> (n_bord=0; n_bord&lt;nb_bords; n_bord++)
<a name="l03178"></a>03178     {
<a name="l03179"></a>03179       <span class="keyword">const</span> <a class="code" href="classCond__lim.html" title="classe Cond_lim Classe generique servant a representer n&#39;importe quelle classe derivee de la classe C...">Cond_lim</a>&amp; la_cl = zone_Cl_VEF.<a class="code" href="classZone__Cl__dis__base.html#af75e0ed7786863e4d333bfb29d67c323" title="Renvoie la i-ieme condition aux limites. (version const)">les_conditions_limites</a>(n_bord);
<a name="l03180"></a>03180       <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp; le_bord = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>,la_cl.<a class="code" href="classCond__lim.html#a5b2d24809cee07727006a891d4ce8d22" title="Appel a l&#39;objet sous-jacent Renvoie la frontiere discretisee associee a la condition aux limites...">frontiere_dis</a>());
<a name="l03181"></a>03181 
<a name="l03182"></a>03182       num1=0;
<a name="l03183"></a>03183       num2=le_bord.<a class="code" href="classFront__VF.html#aed4006d91bf2ef3af2b9f7933d863a09" title="Nombre de faces reelles et virtuelles du bord.">nb_faces_tot</a>();
<a name="l03184"></a>03184 
<a name="l03185"></a>03185       <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classSymetrie.html" title="classe Symetrie Sur les faces de symetrie on a les proprietes suivantes: - composante normale de la v...">Symetrie</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>()))
<a name="l03186"></a>03186         {
<a name="l03187"></a>03187           nnz+=num2;
<a name="l03188"></a>03188 
<a name="l03189"></a>03189           <span class="keywordflow">for</span> (ind_face=num1; ind_face&lt;num2; ind_face++)
<a name="l03190"></a>03190             is_symetry.<a class="code" href="classArrOfBit.html#a5c339cfd9dea141737e127131e52aaae" title="Met le bit e a 1.">setbit</a>(le_bord.<a class="code" href="classFront__VF.html#a3402a19d7e54ed797d2b18e9a47ead1e" title="Renvoie le numero de face de la ieme face du bord.">num_face</a>(ind_face));
<a name="l03191"></a>03191         }
<a name="l03192"></a>03192     }
<a name="l03193"></a>03193 }
<a name="l03194"></a>03194 
<a name="l03195"></a>03195 
<a name="l03196"></a>03196 
<a name="l03197"></a>03197 <span class="comment">//</span>
<a name="l03198"></a>03198 <span class="comment">// Fonctions de test</span>
<a name="l03199"></a>03199 <span class="comment">//</span>
<a name="l03200"></a>03200 
<a name="l03201"></a><a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a4f8b23049afd6589ab4f1fa9619458f9">03201</a> <span class="keywordtype">void</span> <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a4f8b23049afd6589ab4f1fa9619458f9">Op_Diff_VEFP1NCP1B_Face::test</a>()<span class="keyword"> const</span>
<a name="l03202"></a>03202 <span class="keyword"></span>{
<a name="l03203"></a>03203   <span class="keyword">const</span> <a class="code" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a>&amp; zone_VEF=<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a8d6cebdde81108b4c492d8af3d6d60ae">zone_VEFPreP1B</a>();
<a name="l03204"></a>03204   <span class="keyword">const</span> <a class="code" href="classZone__Cl__VEF.html">Zone_Cl_VEF</a>&amp; zone_Cl_VEF = <a class="code" href="classOp__Diff__VEF__base.html#a721f395a27f12a95882437c614e16a7d">la_zcl_vef</a>.<a class="code" href="classRef__Zone__Cl__VEF.html#a0970d7253def65ad4f0c5ce1830fd243">valeur</a>();
<a name="l03205"></a>03205   <span class="keyword">const</span> <a class="code" href="classZone.html" title="classe Zone Une Zone est un maillage compose d&#39;un ensemble d&#39;elements geometriques de meme type...">Zone</a>&amp; zone = zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>();
<a name="l03206"></a>03206   <span class="keyword">const</span> <a class="code" href="classDomaine.html" title="Classe Domaine Un Domaine represente le domaine (spatial) de resolution d&#39;un Probleme. Un Domaine a un Nom, il est constitue d&#39;une ou plusieurs Zone qui peuvent etre eventuellement decoupees en Sous_Zone. Un Domaine porte l&#39;ensemble des sommets utilises par ses Zones. On peut vouloir resoudre des problemes de type different sur plusieurs domaines, geometriquement les domaines sont alors couples par des surfaces qu&#39;on appelle Raccord.">Domaine</a>&amp; dom=zone.<a class="code" href="classZone.html#a379ad2206b5a13a4f4f3df6d44c7546a" title="Renvoie le domaine dont la zone fait partie. (version const)">domaine</a>();
<a name="l03207"></a>03207 
<a name="l03208"></a>03208   <span class="keyword">const</span> <a class="code" href="classSolveur__Masse.html" title="classe Solveur_Masse Classe generique de la hierarchie des solveurs de masse, un objet Solveur_Masse ...">Solveur_Masse</a>&amp; solveur_masse=<a class="code" href="classMorEqn.html#a615dd9abff96edcb625fa0424a489864" title="Renvoie la reference sur l&#39;equation pointe par MorEqn::mon_equation. (version const)">equation</a>().<a class="code" href="classEquation__base.html#adfedf474c07a92f6b2261ca2f1cee80e" title="Renvoie le solveur de masse associe a l&#39;equation.">solv_masse</a>();
<a name="l03209"></a>03209 
<a name="l03210"></a>03210   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_bords=zone_VEF.<a class="code" href="classZone__dis__base.html#af22167d614644f55591a29c77eb1c009">nb_front_Cl</a>();
<a name="l03211"></a>03211   <span class="keyword">const</span> <span class="keywordtype">int</span> firstFaceInt=zone_VEF.<a class="code" href="classZone__VF.html#a12869806fa4834aca8f2964e16509dfd" title="une face est interne ssi elle separe deux elements. renvoie le numero de la premiere face interne...">premiere_face_int</a>();
<a name="l03212"></a>03212   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_som_tot=dom.<a class="code" href="classDomaine.html#a394e61cf1993665886de0fbbd0c0178e" title="Renvoie le nombre total de sommets.">nb_som_tot</a>();
<a name="l03213"></a>03213 
<a name="l03214"></a>03214   <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; unknown = <a class="code" href="classMorEqn.html#a615dd9abff96edcb625fa0424a489864" title="Renvoie la reference sur l&#39;equation pointe par MorEqn::mon_equation. (version const)">equation</a>().<a class="code" href="classEquation__base.html#a5a1fce9487b9a8dd17020914100c2c89">inconnue</a>().<a class="code" href="classChamp__Inc.html#a28ef3d411d12cb5684ac5e799efb7d24" title="Appel a l&#39;objet sous-jacent Renvoie le tableau des valeurs au temps courant.">valeurs</a>();
<a name="l03215"></a>03215   <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; xv=zone_VEF.<a class="code" href="classZone__VF.html#a918c0885a9b67317fcce3a0535306542">xv</a>();
<a name="l03216"></a>03216   <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; xs=dom.<a class="code" href="classDomaine.html#a0846ac03a10b65c4df911fe35a19c02f" title="Renvoie le nombre total de sommets.">les_sommets</a>();
<a name="l03217"></a>03217 
<a name="l03218"></a>03218   <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a> inco(unknown);
<a name="l03219"></a>03219   <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; incoV=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classDoubleVect.html">DoubleVect</a>,inco);
<a name="l03220"></a>03220   incoV=0.;
<a name="l03221"></a>03221 <span class="comment">// DoubleTab inco2(unknown);</span>
<a name="l03222"></a>03222 <span class="comment">// DoubleVect&amp; inco2V=ref_cast(DoubleVect,inco2);</span>
<a name="l03223"></a>03223 <span class="comment">// inco2V=0.;</span>
<a name="l03224"></a>03224 
<a name="l03225"></a>03225   <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a> tmp(inco);
<a name="l03226"></a>03226 
<a name="l03227"></a>03227   <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a> resu(unknown);
<a name="l03228"></a>03228   <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; resuV=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classDoubleVect.html">DoubleVect</a>,resu);
<a name="l03229"></a>03229   <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a> resuMat(unknown);
<a name="l03230"></a>03230   <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; resuMatV=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classDoubleVect.html">DoubleVect</a>,resuMat);
<a name="l03231"></a>03231   <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a> gradientMat(<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>,<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>+2);
<a name="l03232"></a>03232 
<a name="l03233"></a>03233 
<a name="l03234"></a>03234   <a class="code" href="classIntVect.html">IntVect</a> som_glob(<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>+2);
<a name="l03235"></a>03235 
<a name="l03236"></a>03236 <span class="comment">// Marqueur pour tenir compte de la porosite</span>
<a name="l03237"></a>03237   <span class="keyword">const</span> <span class="keywordtype">int</span> marq=<a class="code" href="classOp__Diff__VEF__base.html#ae7df69707cc2304c930eb103390e99f0">phi_psi_diffuse</a>(<a class="code" href="classMorEqn.html#a615dd9abff96edcb625fa0424a489864" title="Renvoie la reference sur l&#39;equation pointe par MorEqn::mon_equation. (version const)">equation</a>());
<a name="l03238"></a>03238 
<a name="l03239"></a>03239 <span class="comment">// Lignes pour tenir compte de la porosite</span>
<a name="l03240"></a>03240   <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; poroE=zone_VEF.<a class="code" href="classZone__VF.html#afd135a1b227731193b1a97b7ed525435">porosite_elem</a>();
<a name="l03241"></a>03241   <a class="code" href="classDoubleVect.html">DoubleVect</a> poroF(zone_VEF.<a class="code" href="classZone__VF.html#ad9d74d1d9da9f50ab26768dbbca7711b">porosite_face</a>());
<a name="l03242"></a>03242   <span class="keywordflow">if</span> (!marq) poroF=1.;
<a name="l03243"></a>03243 
<a name="l03244"></a>03244 <span class="comment">// Lignes pour tenir compte de la diffusivite</span>
<a name="l03245"></a>03245   <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a> nu;
<a name="l03246"></a>03246   <a class="code" href="classOp__Diff__VEF__base.html#aaf04f2c605558b7b05aa8c60f84fb9e1">remplir_nu</a>(<a class="code" href="classOp__Diff__VEF__base.html#ab1309af47a0c41f00181e031fbfda002">nu_</a>);
<a name="l03247"></a>03247   <a class="code" href="Porosites__champ_8cpp.html#a2340e7d73d0f9d34926d012fe1b1d884" title="renvoit le tableau res, res=org si flag=0, res= porosite*org sinon attention ne pas modifier res car ...">modif_par_porosite_si_flag</a>(<a class="code" href="classOp__Diff__VEF__base.html#ab1309af47a0c41f00181e031fbfda002">nu_</a>,nu,!marq,poroE);
<a name="l03248"></a>03248 
<a name="l03249"></a>03249   <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a> nu_p1;
<a name="l03250"></a>03250   dom.<a class="code" href="classDomaine.html#a32c7de9f9e8e78e3d5ea68715b2ceb2b" title="Cree un tableau ayant une &quot;ligne&quot; par sommet du maillage. Voir MD_Vector_tools::creer_tableau_distrib...">creer_tableau_sommets</a>(nu_p1);
<a name="l03251"></a>03251   <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a997bacd7fe35872ff44036e9e9f40996" title="Calcule la diffusivite &quot;nu_p1&quot; aux sommets du maillage en fonction de la diffusivite &quot;nu_elem&quot; au...">remplir_nu_p1</a>(nu,nu_p1);
<a name="l03252"></a>03252 
<a name="l03253"></a>03253 <span class="comment">// Diverses variables utiles</span>
<a name="l03254"></a>03254   <span class="keywordtype">int</span> face=0;
<a name="l03255"></a>03255   <span class="keywordtype">int</span> faceAss=0;
<a name="l03256"></a>03256   <span class="keywordtype">int</span> comp=0;
<a name="l03257"></a>03257   <span class="keywordtype">int</span> size0=zone_VEF.<a class="code" href="classZone__VF.html#aede27992d9f2eedd52c24d4a80ff7ffb" title="renvoie le nombre global de faces.">nb_faces</a>();
<a name="l03258"></a>03258   <span class="keywordtype">int</span> i=0,j=0;
<a name="l03259"></a>03259   <span class="keywordtype">int</span> nnz=0;
<a name="l03260"></a>03260   <span class="keywordtype">int</span> compi=0,compj=0;
<a name="l03261"></a>03261   <span class="keywordtype">int</span> som=0;
<a name="l03262"></a>03262   <span class="keywordtype">int</span> n_bord=0;
<a name="l03263"></a>03263   <span class="keywordtype">int</span> num1=0,num2=0,ind_face=0;
<a name="l03264"></a>03264   <span class="keywordtype">int</span> ii=0;
<a name="l03265"></a>03265 
<a name="l03266"></a>03266   <span class="keywordtype">int</span> size1 = unknown.<a class="code" href="classDoubleVect.html#ab02d01cd1bdab66fbd66f9a47cc29e10">line_size</a>();
<a name="l03267"></a>03267 
<a name="l03268"></a>03268   <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a> matrice;
<a name="l03269"></a>03269   <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#af8e127ec31241c8d2aab78ad951aa253" title="on dimensionne notre matrice.">dimensionner</a>(matrice);
<a name="l03270"></a>03270   <span class="keywordflow">if</span> (<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a0ff8784f933eedd5f6a52db444f2d71b">alphaS</a>) <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#ae979dc98da8579c81ed4abf017475277">ajouter_contribution_som</a>(inco,poroF,nu_p1,matrice);
<a name="l03271"></a>03271   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#acbd7461fb999d27a3c1ba0320f13563a">alphaE</a>) <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a10ecca846d2d639a93ea61ed25cc5458">ajouter_contribution_elem</a>(inco,poroF,nu,matrice);
<a name="l03272"></a>03272 
<a name="l03273"></a>03273   <span class="keywordtype">bool</span> test1=<span class="keyword">false</span>;
<a name="l03274"></a>03274   <span class="keywordtype">double</span> <a class="code" href="Double_8h.html#a1c45761573e6cbc97cfacac78d905016">max</a>=0.;
<a name="l03275"></a>03275 
<a name="l03276"></a>03276   <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a> gradient1(<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>);
<a name="l03277"></a>03277 
<a name="l03278"></a>03278   <a class="code" href="classMotcle.html" title="Une chaine de caractere (Nom) en majuscules.">Motcle</a> type;
<a name="l03279"></a>03279   <span class="keywordflow">if</span> (<a class="code" href="classProcess.html#a6bf692ce58d9578aa62ac3c07b8caaa1" title="renvoie le nombre de processeurs dans le groupe courant Voir Comm_Group::nproc() et PE_Groups::curren...">Process::nproc</a>()&gt;1)
<a name="l03280"></a>03280     type=<span class="stringliteral">&quot;_PAR&quot;</span>;
<a name="l03281"></a>03281   <span class="keywordflow">else</span>
<a name="l03282"></a>03282     type=<span class="stringliteral">&quot;_SEQ&quot;</span>;
<a name="l03283"></a>03283 
<a name="l03284"></a>03284   <a class="code" href="classMotcles.html" title="Un tableau d&#39;objets de la classe Motcle.">Motcles</a> les_mots(8);
<a name="l03285"></a>03285   {
<a name="l03286"></a>03286     les_mots[0] = <span class="stringliteral">&quot;matrice&quot;</span>;
<a name="l03287"></a>03287     les_mots[1] = <span class="stringliteral">&quot;result&quot;</span>;
<a name="l03288"></a>03288     les_mots[2] = <span class="stringliteral">&quot;res&quot;</span>;
<a name="l03289"></a>03289     les_mots[3] = <span class="stringliteral">&quot;resMat&quot;</span>;
<a name="l03290"></a>03290     les_mots[4] = <span class="stringliteral">&quot;grad&quot;</span>;
<a name="l03291"></a>03291     les_mots[5] = <span class="stringliteral">&quot;gradMat&quot;</span>;
<a name="l03292"></a>03292     les_mots[6] = <span class="stringliteral">&quot;div&quot;</span>;
<a name="l03293"></a>03293     les_mots[7] = <span class="stringliteral">&quot;ligne_mat&quot;</span>;
<a name="l03294"></a>03294   }
<a name="l03295"></a>03295   <a class="code" href="classMotcle.html" title="Une chaine de caractere (Nom) en majuscules.">Motcle</a> proc(<a class="code" href="classProcess.html#ab55ba07167ec807ed3a145cac0f5dca4" title="renvoie mon rang dans le groupe de communication courant. Voir Comm_Group::rank() et PE_Groups::curre...">Process::me</a>());
<a name="l03296"></a>03296   proc+=<span class="stringliteral">&quot;.txt&quot;</span>;
<a name="l03297"></a>03297 
<a name="l03298"></a>03298   <span class="keywordflow">for</span> (i=0; i&lt;les_mots.<a class="code" href="classvect__impl.html#a78155bfbd6b61f4710b9830641ed1694">size</a>(); i++)
<a name="l03299"></a>03299     {
<a name="l03300"></a>03300       les_mots[i]+=type;
<a name="l03301"></a>03301       les_mots[i]+=proc;
<a name="l03302"></a>03302     }
<a name="l03303"></a>03303 
<a name="l03304"></a>03304   ofstream mat(les_mots[0].getChar());
<a name="l03305"></a>03305   <span class="keyword">const</span> <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; matConst=matrice;
<a name="l03306"></a>03306   <span class="keywordflow">for</span> (i=0; i&lt;zone_VEF.<a class="code" href="classZone__VF.html#aede27992d9f2eedd52c24d4a80ff7ffb" title="renvoie le nombre global de faces.">nb_faces</a>(); i++)
<a name="l03307"></a>03307     {
<a name="l03308"></a>03308       <span class="keywordflow">for</span> (j=0; j&lt;matConst.<a class="code" href="classMatrice__Morse.html#a94caf9937bc5a110a7179cb3e9eaa9d9">nb_colonnes</a>(); j++)
<a name="l03309"></a>03309         mat&lt;&lt;matConst(i,j)&lt;&lt;<span class="stringliteral">&quot;,&quot;</span>;
<a name="l03310"></a>03310       mat&lt;&lt;endl;
<a name="l03311"></a>03311     }
<a name="l03312"></a>03312 
<a name="l03313"></a>03313   <span class="keywordtype">double</span> coeff_diag=0.;
<a name="l03314"></a>03314   <span class="keywordtype">double</span> sum_coeff_extra_diag=0.;
<a name="l03315"></a>03315   ofstream ligneMat(les_mots[7].getChar());
<a name="l03316"></a>03316   <span class="keywordflow">for</span> (i=0; i&lt;matConst.<a class="code" href="classMatrice__Morse.html#a1f9bd6aedb226c86b7299689fa5b821a">nb_lignes</a>(); i++)
<a name="l03317"></a>03317     {
<a name="l03318"></a>03318       coeff_diag=matConst(i,i);
<a name="l03319"></a>03319       ligneMat&lt;&lt;<span class="stringliteral">&quot;Ligne : &quot;</span>&lt;&lt;i&lt;&lt;endl;
<a name="l03320"></a>03320       ligneMat&lt;&lt;<span class="stringliteral">&quot;Coeff diag : &quot;</span>&lt;&lt;coeff_diag&lt;&lt;endl;
<a name="l03321"></a>03321 
<a name="l03322"></a>03322       ligneMat&lt;&lt;<span class="stringliteral">&quot;Coeff extra diag : &quot;</span>;
<a name="l03323"></a>03323       sum_coeff_extra_diag=0.;
<a name="l03324"></a>03324       <span class="keywordflow">for</span> (j=0; j&lt;matConst.<a class="code" href="classMatrice__Morse.html#a94caf9937bc5a110a7179cb3e9eaa9d9">nb_colonnes</a>(); j++)
<a name="l03325"></a>03325         <span class="keywordflow">if</span> (j!=i) sum_coeff_extra_diag+=matConst(i,j);
<a name="l03326"></a>03326       ligneMat&lt;&lt;sum_coeff_extra_diag&lt;&lt;endl;
<a name="l03327"></a>03327 
<a name="l03328"></a>03328       ligneMat&lt;&lt;<span class="stringliteral">&quot;Coeff extra diag par colonne : &quot;</span>;
<a name="l03329"></a>03329       sum_coeff_extra_diag=0.;
<a name="l03330"></a>03330       <span class="keywordflow">for</span> (j=0; j&lt;matConst.<a class="code" href="classMatrice__Morse.html#a94caf9937bc5a110a7179cb3e9eaa9d9">nb_colonnes</a>(); j++)
<a name="l03331"></a>03331         <span class="keywordflow">if</span> (j!=i) sum_coeff_extra_diag+=matConst(j,i);
<a name="l03332"></a>03332       ligneMat&lt;&lt;sum_coeff_extra_diag&lt;&lt;endl;
<a name="l03333"></a>03333     }
<a name="l03334"></a>03334 
<a name="l03335"></a>03335 
<a name="l03336"></a>03336   <a class="code" href="classMotcle.html" title="Une chaine de caractere (Nom) en majuscules.">Motcle</a> gradi(<span class="stringliteral">&quot;grad1&quot;</span>);
<a name="l03337"></a>03337   gradi+=type;
<a name="l03338"></a>03338   gradi+=proc;
<a name="l03339"></a>03339   <span class="keywordtype">int</span> elem=0;
<a name="l03340"></a>03340   <span class="keywordtype">int</span> elem0=0,elem1=0;
<a name="l03341"></a>03341   <span class="keywordtype">int</span> som_loc0=1,som_loc1=1;
<a name="l03342"></a>03342   <span class="keywordtype">int</span> som_loc=0;
<a name="l03343"></a>03343   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_som_elem=zone.<a class="code" href="classZone.html#ae0b34a93b9ae8146df2d1884157afe9f" title="Renvoie le nombre de sommets des elements geometriques constituants la zone. Tous les elements de la ...">nb_som_elem</a>();
<a name="l03344"></a>03344   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; face_voisins=zone_VEF.<a class="code" href="classZone__VF.html#a49d4322f5585a8fa95748ca785b70702" title="renvoie l&#39;element voisin de numface dans la direction i. i=0 : dans le sens oppose de l&#39;axe orthogona...">face_voisins</a>();
<a name="l03345"></a>03345   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; elem_som=zone.<a class="code" href="classZone.html#ac115e8342be89afb882b7b61cc343267" title="Renvoie le tableau des sommets des elements.">les_elems</a>();
<a name="l03346"></a>03346   ofstream grad1(gradi.<a class="code" href="classNom.html#aa9f24bd3370b5f1c66666e65252eea05">getChar</a>());
<a name="l03347"></a>03347   <span class="keywordflow">for</span> (face=0; face&lt;size0; face++)
<a name="l03348"></a>03348     {
<a name="l03349"></a>03349       grad1&lt;&lt;<span class="stringliteral">&quot;Face : &quot;</span>&lt;&lt;face&lt;&lt;endl;
<a name="l03350"></a>03350       grad1&lt;&lt;<span class="stringliteral">&quot;(&quot;</span>;
<a name="l03351"></a>03351       <span class="keywordflow">for</span> (i=0; i&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; i++)
<a name="l03352"></a>03352         grad1&lt;&lt;xv(face,i)&lt;&lt;<span class="stringliteral">&quot;,&quot;</span>;
<a name="l03353"></a>03353       grad1&lt;&lt;<span class="stringliteral">&quot;)&quot;</span>&lt;&lt;endl;
<a name="l03354"></a>03354 
<a name="l03355"></a>03355       <span class="keywordflow">for</span> (ii=0; ii&lt;2; ii++)
<a name="l03356"></a>03356         {
<a name="l03357"></a>03357           elem=face_voisins(face,ii);
<a name="l03358"></a>03358           <span class="keywordflow">if</span> (elem!=-1)
<a name="l03359"></a>03359             <span class="keywordflow">for</span> (som_loc=0; som_loc&lt;nb_som_elem; som_loc++)
<a name="l03360"></a>03360               {
<a name="l03361"></a>03361                 som=elem_som(elem,som_loc);
<a name="l03362"></a>03362                 som=dom.<a class="code" href="classDomaine.html#a37cc657f1907d53b0d5a573da862af80">get_renum_som_perio</a>(som);
<a name="l03363"></a>03363                 <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a035d8cdf71b99212df20fadc0f2c997e">isInStencil</a>(face,som,elem0,som_loc0,elem1,som_loc1);
<a name="l03364"></a>03364 
<a name="l03365"></a>03365                 gradient1=0.;
<a name="l03366"></a>03366                 <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a37f70143adef3313705fb8583168fd93">gradient_som</a>(face,som,elem0,som_loc0,
<a name="l03367"></a>03367                              elem1,som_loc1,gradient1);
<a name="l03368"></a>03368 
<a name="l03369"></a>03369                 grad1&lt;&lt;som&lt;&lt;<span class="stringliteral">&quot;(&quot;</span>;
<a name="l03370"></a>03370                 <span class="keywordflow">for</span> (i=0; i&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; i++)
<a name="l03371"></a>03371                   grad1&lt;&lt;xs(som,i)&lt;&lt;<span class="stringliteral">&quot;,&quot;</span>;
<a name="l03372"></a>03372                 grad1&lt;&lt;<span class="stringliteral">&quot;):(&quot;</span>;
<a name="l03373"></a>03373                 <span class="keywordflow">for</span> (compj=0; compj&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; compj++)
<a name="l03374"></a>03374                   grad1&lt;&lt;gradient1(compj)&lt;&lt;<span class="stringliteral">&quot;,&quot;</span>;
<a name="l03375"></a>03375                 grad1&lt;&lt;<span class="stringliteral">&quot;)&quot;</span>&lt;&lt;endl;
<a name="l03376"></a>03376               }
<a name="l03377"></a>03377         }
<a name="l03378"></a>03378     }
<a name="l03379"></a>03379 
<a name="l03380"></a>03380   ofstream result(les_mots[1].getChar());
<a name="l03381"></a>03381   ofstream res(les_mots[2].getChar());
<a name="l03382"></a>03382   ofstream resMat(les_mots[3].getChar());
<a name="l03383"></a>03383   ofstream grad(les_mots[4].getChar());
<a name="l03384"></a>03384   ofstream gradMat(les_mots[5].getChar());
<a name="l03385"></a>03385   ofstream div(les_mots[6].getChar());
<a name="l03386"></a>03386 
<a name="l03387"></a>03387   <span class="keywordflow">for</span> (face=firstFaceInt; face&lt;size0; face++)
<a name="l03388"></a>03388     {
<a name="l03389"></a>03389       <span class="keywordflow">if</span> (<a class="code" href="classProcess.html#acd052b99706c577f8a5b6656217cf4c2" title="renvoie 1 si on est sur le processeur maitre du groupe courant (c&#39;est a dire me() == 0)...">Process::je_suis_maitre</a>()) incoV[face*size1+comp]=1.;
<a name="l03390"></a>03390       inco.<a class="code" href="classDoubleVect.html#abfebbc2f685ce7bc4b80c720d7da9bf3">echange_espace_virtuel</a>();
<a name="l03391"></a>03391 
<a name="l03392"></a>03392 <span class="comment">// Version explicite</span>
<a name="l03393"></a>03393       <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a076341d23635d4ad7b0bfc19a03a7722">gradient_p1_</a>=0.;
<a name="l03394"></a>03394       <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a5e85dd4ed5a586f2787a149790ba0714">calculer_gradient_som</a>(inco);
<a name="l03395"></a>03395 
<a name="l03396"></a>03396 <span class="comment">// Controle des gradients</span>
<a name="l03397"></a>03397       grad&lt;&lt;<span class="stringliteral">&quot;Face interne : &quot;</span>&lt;&lt;face*size1+comp&lt;&lt;endl;
<a name="l03398"></a>03398       grad&lt;&lt;<span class="stringliteral">&quot;(&quot;</span>;
<a name="l03399"></a>03399       <span class="keywordflow">for</span> (i=0; i&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; i++)
<a name="l03400"></a>03400         grad&lt;&lt;xv(face,i)&lt;&lt;<span class="stringliteral">&quot;,&quot;</span>;
<a name="l03401"></a>03401       grad&lt;&lt;<span class="stringliteral">&quot;)&quot;</span>&lt;&lt;endl;
<a name="l03402"></a>03402       <span class="keywordflow">for</span> (som=0; som&lt;nb_som_tot; som++)
<a name="l03403"></a>03403         {
<a name="l03404"></a>03404           grad &lt;&lt;som&lt;&lt;<span class="stringliteral">&quot;(&quot;</span>;
<a name="l03405"></a>03405           <span class="keywordflow">for</span> (i=0; i&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; i++)
<a name="l03406"></a>03406             grad&lt;&lt;xs(som,i)&lt;&lt;<span class="stringliteral">&quot;,&quot;</span>;
<a name="l03407"></a>03407           grad&lt;&lt;<span class="stringliteral">&quot;):(&quot;</span>;
<a name="l03408"></a>03408           <span class="keywordflow">for</span> (compi=0; compi&lt;<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#aecdf3d22b30add37625e545939004844">dim_ch_</a>; compi++)
<a name="l03409"></a>03409             <span class="keywordflow">for</span> (compj=0; compj&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; compj++)
<a name="l03410"></a>03410               grad&lt;&lt;<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a076341d23635d4ad7b0bfc19a03a7722">gradient_p1_</a>(som,compi,compj)&lt;&lt;<span class="stringliteral">&quot;,&quot;</span>;
<a name="l03411"></a>03411           grad&lt;&lt;<span class="stringliteral">&quot;)&quot;</span>&lt;&lt;endl;
<a name="l03412"></a>03412         }
<a name="l03413"></a>03413 
<a name="l03414"></a>03414       gradientMat=0.;
<a name="l03415"></a>03415       som_glob=-1;
<a name="l03416"></a>03416       <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a37f70143adef3313705fb8583168fd93">gradient_som</a>(face,nnz,som_glob,gradientMat);
<a name="l03417"></a>03417 
<a name="l03418"></a>03418       gradMat&lt;&lt;<span class="stringliteral">&quot;Face interne : &quot;</span>&lt;&lt;face*size1+comp&lt;&lt;endl;
<a name="l03419"></a>03419       gradMat&lt;&lt;<span class="stringliteral">&quot;(&quot;</span>;
<a name="l03420"></a>03420       <span class="keywordflow">for</span> (i=0; i&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; i++)
<a name="l03421"></a>03421         gradMat&lt;&lt;xv(face,i)&lt;&lt;<span class="stringliteral">&quot;,&quot;</span>;
<a name="l03422"></a>03422       gradMat&lt;&lt;<span class="stringliteral">&quot;)&quot;</span>&lt;&lt;endl;
<a name="l03423"></a>03423       <span class="keywordflow">for</span> (i=0; i&lt;nnz; i++)
<a name="l03424"></a>03424         {
<a name="l03425"></a>03425           gradMat&lt;&lt;som_glob[i]&lt;&lt;<span class="stringliteral">&quot;(&quot;</span>;
<a name="l03426"></a>03426           <span class="keywordflow">for</span> (ii=0; ii&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; ii++)
<a name="l03427"></a>03427             gradMat&lt;&lt;xs(som_glob[i],ii)&lt;&lt;<span class="stringliteral">&quot;,&quot;</span>;
<a name="l03428"></a>03428           gradMat&lt;&lt;<span class="stringliteral">&quot;):(&quot;</span>;
<a name="l03429"></a>03429           <span class="keywordflow">for</span> (compj=0; compj&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; compj++)
<a name="l03430"></a>03430             gradMat&lt;&lt;gradientMat(compj,i)&lt;&lt;<span class="stringliteral">&quot;,&quot;</span>;
<a name="l03431"></a>03431           gradMat&lt;&lt;<span class="stringliteral">&quot;)&quot;</span>&lt;&lt;endl;
<a name="l03432"></a>03432         }
<a name="l03433"></a>03433 
<a name="l03434"></a>03434       resu=0.;
<a name="l03435"></a>03435       <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#aa940ce85caaf77638f592302b1fd8561">calculer_divergence_som</a>(resu);
<a name="l03436"></a>03436       <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#af61161babbf0b5a57042d39601c47e3e">corriger_Cl_test</a>(resu);
<a name="l03437"></a>03437       solveur_masse.<a class="code" href="classSolveur__Masse.html#af7afe8c2d4d5764f7428f2cd4ef43ddb" title="Appel a l&#39;objet sous-jacent. Resoud le systeme lineaire, dont la matrice est la matrice de masse...">appliquer</a>(resu);
<a name="l03438"></a>03438       div&lt;&lt;<span class="stringliteral">&quot;Face interne : &quot;</span>&lt;&lt;face*size1+comp&lt;&lt;endl;
<a name="l03439"></a>03439       div&lt;&lt;<span class="stringliteral">&quot;(&quot;</span>;
<a name="l03440"></a>03440       <span class="keywordflow">for</span> (i=0; i&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; i++)
<a name="l03441"></a>03441         div&lt;&lt;xv(face,i)&lt;&lt;<span class="stringliteral">&quot;,&quot;</span>;
<a name="l03442"></a>03442       div&lt;&lt;<span class="stringliteral">&quot;)&quot;</span>&lt;&lt;endl;
<a name="l03443"></a>03443       <span class="keywordflow">for</span> (i=0; i&lt;size0; i++)
<a name="l03444"></a>03444         {
<a name="l03445"></a>03445           div&lt;&lt;i&lt;&lt;<span class="stringliteral">&quot;(&quot;</span>;
<a name="l03446"></a>03446           <span class="keywordflow">for</span> (ii=0; ii&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; ii++)
<a name="l03447"></a>03447             div&lt;&lt;xv(i,ii)&lt;&lt;<span class="stringliteral">&quot;,&quot;</span>;
<a name="l03448"></a>03448           div&lt;&lt;<span class="stringliteral">&quot;):=(&quot;</span>;
<a name="l03449"></a>03449           <span class="keywordflow">for</span> (j=0; j&lt;size1; j++)
<a name="l03450"></a>03450             div&lt;&lt;resu[i*size1+j]&lt;&lt;<span class="stringliteral">&quot;,&quot;</span>;
<a name="l03451"></a>03451           div&lt;&lt;<span class="stringliteral">&quot;)&quot;</span>&lt;&lt;endl;
<a name="l03452"></a>03452         }
<a name="l03453"></a>03453 
<a name="l03454"></a>03454       resu*=-1.;
<a name="l03455"></a>03455       res&lt;&lt;<span class="stringliteral">&quot;Face interne : &quot;</span>&lt;&lt;face*size1+comp&lt;&lt;endl;
<a name="l03456"></a>03456       res&lt;&lt;<span class="stringliteral">&quot;(&quot;</span>;
<a name="l03457"></a>03457       <span class="keywordflow">for</span> (i=0; i&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; i++)
<a name="l03458"></a>03458         res&lt;&lt;xv(face,i)&lt;&lt;<span class="stringliteral">&quot;,&quot;</span>;
<a name="l03459"></a>03459       res&lt;&lt;<span class="stringliteral">&quot;)&quot;</span>&lt;&lt;endl;
<a name="l03460"></a>03460       <span class="keywordflow">for</span> (i=0; i&lt;size0; i++)
<a name="l03461"></a>03461         {
<a name="l03462"></a>03462           res&lt;&lt;i&lt;&lt;<span class="stringliteral">&quot;(&quot;</span>;
<a name="l03463"></a>03463           <span class="keywordflow">for</span> (ii=0; ii&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; ii++)
<a name="l03464"></a>03464             res&lt;&lt;xv(i,ii)&lt;&lt;<span class="stringliteral">&quot;,&quot;</span>;
<a name="l03465"></a>03465           res&lt;&lt;<span class="stringliteral">&quot;):=(&quot;</span>;
<a name="l03466"></a>03466           <span class="keywordflow">for</span> (j=0; j&lt;size1; j++)
<a name="l03467"></a>03467             res&lt;&lt;resu[i*size1+j]&lt;&lt;<span class="stringliteral">&quot;,&quot;</span>;
<a name="l03468"></a>03468           res&lt;&lt;<span class="stringliteral">&quot;)&quot;</span>&lt;&lt;endl;
<a name="l03469"></a>03469         }
<a name="l03470"></a>03470 
<a name="l03471"></a>03471 <span class="comment">// Version matricielle</span>
<a name="l03472"></a>03472       resuMat=0.;
<a name="l03473"></a>03473       matrice.<a class="code" href="classMatrice__Morse.html#a7bbc0c7773ecb51c01d76adc02356dc0" title="Operation de multiplication-accumulation (saxpy) matrice matrice&lt;br&gt;(matrice X representee par un tab...">ajouter_multTab_</a>(inco,resuMat);
<a name="l03474"></a>03474       solveur_masse.<a class="code" href="classSolveur__Masse.html#af7afe8c2d4d5764f7428f2cd4ef43ddb" title="Appel a l&#39;objet sous-jacent. Resoud le systeme lineaire, dont la matrice est la matrice de masse...">appliquer</a>(resuMat);
<a name="l03475"></a>03475       resuMat.<a class="code" href="classDoubleVect.html#abfebbc2f685ce7bc4b80c720d7da9bf3">echange_espace_virtuel</a>();
<a name="l03476"></a>03476       resMat&lt;&lt;<span class="stringliteral">&quot;Face interne :&quot;</span>&lt;&lt;face*size1+comp&lt;&lt;endl;
<a name="l03477"></a>03477       resMat&lt;&lt;<span class="stringliteral">&quot;(&quot;</span>;
<a name="l03478"></a>03478       <span class="keywordflow">for</span> (i=0; i&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; i++)
<a name="l03479"></a>03479         resMat&lt;&lt;xv(face,i)&lt;&lt;<span class="stringliteral">&quot;,&quot;</span>;
<a name="l03480"></a>03480       resMat&lt;&lt;<span class="stringliteral">&quot;)&quot;</span>&lt;&lt;endl;
<a name="l03481"></a>03481       <span class="keywordflow">for</span> (i=0; i&lt;size0; i++)
<a name="l03482"></a>03482         {
<a name="l03483"></a>03483           resMat&lt;&lt;i&lt;&lt;<span class="stringliteral">&quot;(&quot;</span>;
<a name="l03484"></a>03484           <span class="keywordflow">for</span> (ii=0; ii&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; ii++)
<a name="l03485"></a>03485             resMat&lt;&lt;xv(i,ii)&lt;&lt;<span class="stringliteral">&quot;,&quot;</span>;
<a name="l03486"></a>03486           resMat&lt;&lt;<span class="stringliteral">&quot;):=(&quot;</span>;
<a name="l03487"></a>03487           <span class="keywordflow">for</span> (j=0; j&lt;size1; j++)
<a name="l03488"></a>03488             resMat&lt;&lt;resuMatV[i*size1+j]&lt;&lt;<span class="stringliteral">&quot;,&quot;</span>;
<a name="l03489"></a>03489           resMat&lt;&lt;<span class="stringliteral">&quot;)&quot;</span>&lt;&lt;endl;
<a name="l03490"></a>03490         }
<a name="l03491"></a>03491 
<a name="l03492"></a>03492 <span class="comment">// Difference entre les resultat</span>
<a name="l03493"></a>03493       resu-=resuMat;
<a name="l03494"></a>03494 
<a name="l03495"></a>03495 <span class="comment">// Affichage des differences</span>
<a name="l03496"></a>03496       max=resu.<a class="code" href="classDoubleVect.html#abdefeb5d940e66320adc0b9b11309737">local_max_abs_vect</a>();
<a name="l03497"></a>03497       <span class="keywordflow">if</span> (max&gt;1.e-14)
<a name="l03498"></a>03498         {
<a name="l03499"></a>03499           result&lt;&lt;<span class="stringliteral">&quot;Diff pour face interne : &quot;</span>&lt;&lt;face*size1+comp&lt;&lt;endl;
<a name="l03500"></a>03500           result&lt;&lt;<span class="stringliteral">&quot;(&quot;</span>;
<a name="l03501"></a>03501           <span class="keywordflow">for</span> (i=0; i&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; i++)
<a name="l03502"></a>03502             result&lt;&lt;xv(face,i)&lt;&lt;<span class="stringliteral">&quot;,&quot;</span>;
<a name="l03503"></a>03503           result&lt;&lt;<span class="stringliteral">&quot;)&quot;</span>&lt;&lt;endl;
<a name="l03504"></a>03504           <span class="keywordflow">for</span> (i=0; i&lt;size0; i++)
<a name="l03505"></a>03505             {
<a name="l03506"></a>03506               test1=<span class="keyword">false</span>;
<a name="l03507"></a>03507               <span class="keywordflow">for</span> (j=0; j&lt;size1; j++)
<a name="l03508"></a>03508                 test1|=(<a class="code" href="Double_8h.html#aaecd4ca8a2fe69cc6568af2938b94d2e">dabs</a>(resuV[i*size1+j])&gt;1.e-14);
<a name="l03509"></a>03509 
<a name="l03510"></a>03510               <span class="keywordflow">if</span> (test1)
<a name="l03511"></a>03511                 {
<a name="l03512"></a>03512                   result&lt;&lt;i&lt;&lt;<span class="stringliteral">&quot;(&quot;</span>;
<a name="l03513"></a>03513                   <span class="keywordflow">for</span> (ii=0; ii&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; ii++)
<a name="l03514"></a>03514                     result&lt;&lt;xv(i,ii)&lt;&lt;<span class="stringliteral">&quot;,&quot;</span>;
<a name="l03515"></a>03515                   result&lt;&lt;<span class="stringliteral">&quot;):=(&quot;</span>;
<a name="l03516"></a>03516                   <span class="keywordflow">for</span> (j=0; j&lt;size1; j++)
<a name="l03517"></a>03517                     result &lt;&lt;resuV[i*size1+j]&lt;&lt;<span class="stringliteral">&quot;,&quot;</span>;
<a name="l03518"></a>03518                   result &lt;&lt;<span class="stringliteral">&quot;)&quot;</span>&lt;&lt;endl;
<a name="l03519"></a>03519                 }
<a name="l03520"></a>03520             }
<a name="l03521"></a>03521         }
<a name="l03522"></a>03522       <span class="keywordflow">else</span>
<a name="l03523"></a>03523         {
<a name="l03524"></a>03524           result&lt;&lt;<span class="stringliteral">&quot;Diff pour face interne : &quot;</span>&lt;&lt;face*size1+comp&lt;&lt;endl;
<a name="l03525"></a>03525           result&lt;&lt;<span class="stringliteral">&quot;Maximum : &quot;</span>&lt;&lt;max&lt;&lt;endl;
<a name="l03526"></a>03526         }
<a name="l03527"></a>03527 
<a name="l03528"></a>03528       <span class="keywordflow">if</span> (<a class="code" href="classProcess.html#acd052b99706c577f8a5b6656217cf4c2" title="renvoie 1 si on est sur le processeur maitre du groupe courant (c&#39;est a dire me() == 0)...">Process::je_suis_maitre</a>()) incoV[face*size1+comp]=0.;
<a name="l03529"></a>03529       inco.<a class="code" href="classDoubleVect.html#abfebbc2f685ce7bc4b80c720d7da9bf3">echange_espace_virtuel</a>();
<a name="l03530"></a>03530     }
<a name="l03531"></a>03531 
<a name="l03532"></a>03532 
<a name="l03533"></a>03533   <span class="keywordflow">for</span> (n_bord=0; n_bord&lt;nb_bords; n_bord++)
<a name="l03534"></a>03534     {
<a name="l03535"></a>03535       <span class="keyword">const</span> <a class="code" href="classCond__lim.html" title="classe Cond_lim Classe generique servant a representer n&#39;importe quelle classe derivee de la classe C...">Cond_lim</a>&amp; la_cl = zone_Cl_VEF.<a class="code" href="classZone__Cl__dis__base.html#af75e0ed7786863e4d333bfb29d67c323" title="Renvoie la i-ieme condition aux limites. (version const)">les_conditions_limites</a>(n_bord);
<a name="l03536"></a>03536       <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp; le_bord = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>,la_cl.<a class="code" href="classCond__lim.html#a5b2d24809cee07727006a891d4ce8d22" title="Appel a l&#39;objet sous-jacent Renvoie la frontiere discretisee associee a la condition aux limites...">frontiere_dis</a>());
<a name="l03537"></a>03537 
<a name="l03538"></a>03538       num1=0;
<a name="l03539"></a>03539       num2=le_bord.<a class="code" href="classFront__VF.html#aed4006d91bf2ef3af2b9f7933d863a09" title="Nombre de faces reelles et virtuelles du bord.">nb_faces_tot</a>();
<a name="l03540"></a>03540 
<a name="l03541"></a>03541 <span class="comment">// Modif pour tenir compte des conditions de Dirichlet</span>
<a name="l03542"></a>03542 <span class="comment">// -&gt; la matrice de masse doit tout annuler</span>
<a name="l03543"></a>03543       <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classDirichlet__homogene.html" title="Classe Dirichlet_homogene Cette classe est la classe de base de la hierarchie des conditions aux limi...">Dirichlet_homogene</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>()))
<a name="l03544"></a>03544         {
<a name="l03545"></a>03545 <span class="comment">// Il ne sert a rien de faire un test dans ce cas</span>
<a name="l03546"></a>03546         }
<a name="l03547"></a>03547 
<a name="l03548"></a>03548       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classDirichlet.html" title="classe Dirichlet Cette classe est la classe de base de la hierarchie des conditions aux limites de ty...">Dirichlet</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>()))
<a name="l03549"></a>03549         <span class="keywordflow">for</span> (ind_face=num1; ind_face&lt;num2; ind_face++)
<a name="l03550"></a>03550           {
<a name="l03551"></a>03551             face=le_bord.<a class="code" href="classFront__VF.html#a3402a19d7e54ed797d2b18e9a47ead1e" title="Renvoie le numero de face de la ieme face du bord.">num_face</a>(ind_face);
<a name="l03552"></a>03552 
<a name="l03553"></a>03553 <span class="comment">// Version explicite</span>
<a name="l03554"></a>03554             <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a076341d23635d4ad7b0bfc19a03a7722">gradient_p1_</a>=0.;
<a name="l03555"></a>03555             <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a5e85dd4ed5a586f2787a149790ba0714">calculer_gradient_som</a>(inco);
<a name="l03556"></a>03556 
<a name="l03557"></a>03557 <span class="comment">// Controle des gradients</span>
<a name="l03558"></a>03558             grad&lt;&lt;<span class="stringliteral">&quot;Face Dirichlet : &quot;</span>&lt;&lt;face*size1+comp&lt;&lt;endl;
<a name="l03559"></a>03559             grad&lt;&lt;<span class="stringliteral">&quot;(&quot;</span>;
<a name="l03560"></a>03560             <span class="keywordflow">for</span> (i=0; i&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; i++)
<a name="l03561"></a>03561               grad&lt;&lt;xv(face,i)&lt;&lt;<span class="stringliteral">&quot;,&quot;</span>;
<a name="l03562"></a>03562             grad&lt;&lt;<span class="stringliteral">&quot;)&quot;</span>&lt;&lt;endl;
<a name="l03563"></a>03563             <span class="keywordflow">for</span> (som=0; som&lt;nb_som_tot; som++)
<a name="l03564"></a>03564               {
<a name="l03565"></a>03565                 grad &lt;&lt;som&lt;&lt;<span class="stringliteral">&quot;(&quot;</span>;
<a name="l03566"></a>03566                 <span class="keywordflow">for</span> (i=0; i&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; i++)
<a name="l03567"></a>03567                   grad&lt;&lt;xs(som,i)&lt;&lt;<span class="stringliteral">&quot;,&quot;</span>;
<a name="l03568"></a>03568                 grad&lt;&lt;<span class="stringliteral">&quot;):(&quot;</span>;
<a name="l03569"></a>03569                 <span class="keywordflow">for</span> (compi=0; compi&lt;<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#aecdf3d22b30add37625e545939004844">dim_ch_</a>; compi++)
<a name="l03570"></a>03570                   <span class="keywordflow">for</span> (compj=0; compj&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; compj++)
<a name="l03571"></a>03571                     grad&lt;&lt;<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a076341d23635d4ad7b0bfc19a03a7722">gradient_p1_</a>(som,compi,compj)&lt;&lt;<span class="stringliteral">&quot;,&quot;</span>;
<a name="l03572"></a>03572                 grad&lt;&lt;<span class="stringliteral">&quot;)&quot;</span>&lt;&lt;endl;
<a name="l03573"></a>03573               }
<a name="l03574"></a>03574 
<a name="l03575"></a>03575             gradientMat=0.;
<a name="l03576"></a>03576             som_glob=-1;
<a name="l03577"></a>03577             <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a253bedb1323fa89e08a8d88e2be8798d">gradient_som_CL</a>(face,nnz,som_glob,gradientMat);
<a name="l03578"></a>03578 
<a name="l03579"></a>03579             gradMat&lt;&lt;<span class="stringliteral">&quot;Face Dirichlet : &quot;</span>&lt;&lt;face*size1+comp&lt;&lt;endl;
<a name="l03580"></a>03580             gradMat&lt;&lt;<span class="stringliteral">&quot;(&quot;</span>;
<a name="l03581"></a>03581             <span class="keywordflow">for</span> (i=0; i&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; i++)
<a name="l03582"></a>03582               gradMat&lt;&lt;xv(face,i)&lt;&lt;<span class="stringliteral">&quot;,&quot;</span>;
<a name="l03583"></a>03583             gradMat&lt;&lt;<span class="stringliteral">&quot;)&quot;</span>&lt;&lt;endl;
<a name="l03584"></a>03584             <span class="keywordflow">for</span> (i=0; i&lt;nnz; i++)
<a name="l03585"></a>03585               {
<a name="l03586"></a>03586                 gradMat&lt;&lt;som_glob[i]&lt;&lt;<span class="stringliteral">&quot;(&quot;</span>;
<a name="l03587"></a>03587                 <span class="keywordflow">for</span> (ii=0; ii&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; ii++)
<a name="l03588"></a>03588                   gradMat&lt;&lt;xs(som_glob[i],ii)&lt;&lt;<span class="stringliteral">&quot;,&quot;</span>;
<a name="l03589"></a>03589                 gradMat&lt;&lt;<span class="stringliteral">&quot;):(&quot;</span>;
<a name="l03590"></a>03590                 <span class="keywordflow">for</span> (compj=0; compj&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; compj++)
<a name="l03591"></a>03591                   gradMat&lt;&lt;gradientMat(compj,i)&lt;&lt;<span class="stringliteral">&quot;,&quot;</span>;
<a name="l03592"></a>03592                 gradMat&lt;&lt;<span class="stringliteral">&quot;)&quot;</span>&lt;&lt;endl;
<a name="l03593"></a>03593               }
<a name="l03594"></a>03594 
<a name="l03595"></a>03595             <span class="keywordflow">for</span> (i=0; i&lt;size0; i++)
<a name="l03596"></a>03596               <span class="keywordflow">for</span> (j=0; j&lt;size1; j++)
<a name="l03597"></a>03597                 resuV[i*size1+j]=0.;
<a name="l03598"></a>03598           }
<a name="l03599"></a>03599 
<a name="l03600"></a>03600       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>()))
<a name="l03601"></a>03601         {
<a name="l03602"></a>03602           <span class="keyword">const</span> <a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>&amp; la_cl_perio = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>());
<a name="l03603"></a>03603 
<a name="l03604"></a>03604           assert(num2%2==0);
<a name="l03605"></a>03605           <span class="keywordflow">for</span> (ind_face=num1; ind_face&lt;num2; ind_face++)
<a name="l03606"></a>03606             {
<a name="l03607"></a>03607               face=le_bord.<a class="code" href="classFront__VF.html#a3402a19d7e54ed797d2b18e9a47ead1e" title="Renvoie le numero de face de la ieme face du bord.">num_face</a>(ind_face);
<a name="l03608"></a>03608               faceAss=le_bord.<a class="code" href="classFront__VF.html#a3402a19d7e54ed797d2b18e9a47ead1e" title="Renvoie le numero de face de la ieme face du bord.">num_face</a>(la_cl_perio.<a class="code" href="classPeriodique.html#a207b86556f199a63ea059b841851ca6a">face_associee</a>(ind_face));
<a name="l03609"></a>03609 
<a name="l03610"></a>03610               <span class="keywordflow">if</span> (<a class="code" href="classProcess.html#acd052b99706c577f8a5b6656217cf4c2" title="renvoie 1 si on est sur le processeur maitre du groupe courant (c&#39;est a dire me() == 0)...">Process::je_suis_maitre</a>()) incoV[face*size1+comp]=1.;
<a name="l03611"></a>03611               <span class="keywordflow">if</span> (<a class="code" href="classProcess.html#acd052b99706c577f8a5b6656217cf4c2" title="renvoie 1 si on est sur le processeur maitre du groupe courant (c&#39;est a dire me() == 0)...">Process::je_suis_maitre</a>()) incoV[faceAss*size1+comp]=1.;
<a name="l03612"></a>03612               inco.<a class="code" href="classDoubleVect.html#abfebbc2f685ce7bc4b80c720d7da9bf3">echange_espace_virtuel</a>();
<a name="l03613"></a>03613 
<a name="l03614"></a>03614 <span class="comment">// Version explicite</span>
<a name="l03615"></a>03615               <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a076341d23635d4ad7b0bfc19a03a7722">gradient_p1_</a>=0.;
<a name="l03616"></a>03616               <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a5e85dd4ed5a586f2787a149790ba0714">calculer_gradient_som</a>(inco);
<a name="l03617"></a>03617 
<a name="l03618"></a>03618 <span class="comment">// Controle des gradients</span>
<a name="l03619"></a>03619               grad &lt;&lt;<span class="stringliteral">&quot;Face perio : &quot;</span>&lt;&lt;face*size1+comp&lt;&lt;endl;
<a name="l03620"></a>03620               grad&lt;&lt;<span class="stringliteral">&quot;(&quot;</span>;
<a name="l03621"></a>03621               <span class="keywordflow">for</span> (i=0; i&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; i++)
<a name="l03622"></a>03622                 grad&lt;&lt;xv(face,i)&lt;&lt;<span class="stringliteral">&quot;,&quot;</span>;
<a name="l03623"></a>03623               grad&lt;&lt;<span class="stringliteral">&quot;)&quot;</span>&lt;&lt;endl;
<a name="l03624"></a>03624               <span class="keywordflow">for</span> (som=0; som&lt;nb_som_tot; som++)
<a name="l03625"></a>03625                 {
<a name="l03626"></a>03626                   grad &lt;&lt;som&lt;&lt;<span class="stringliteral">&quot;(&quot;</span>;
<a name="l03627"></a>03627                   <span class="keywordflow">for</span> (i=0; i&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; i++)
<a name="l03628"></a>03628                     grad&lt;&lt;xs(som,i)&lt;&lt;<span class="stringliteral">&quot;,&quot;</span>;
<a name="l03629"></a>03629                   grad&lt;&lt;<span class="stringliteral">&quot;):(&quot;</span>;
<a name="l03630"></a>03630                   <span class="keywordflow">for</span> (compi=0; compi&lt;<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#aecdf3d22b30add37625e545939004844">dim_ch_</a>; compi++)
<a name="l03631"></a>03631                     <span class="keywordflow">for</span> (compj=0; compj&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; compj++)
<a name="l03632"></a>03632                       grad&lt;&lt;<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a076341d23635d4ad7b0bfc19a03a7722">gradient_p1_</a>(som,compi,compj)&lt;&lt;<span class="stringliteral">&quot;,&quot;</span>;
<a name="l03633"></a>03633                   grad&lt;&lt;<span class="stringliteral">&quot;)&quot;</span>&lt;&lt;endl;
<a name="l03634"></a>03634                 }
<a name="l03635"></a>03635 
<a name="l03636"></a>03636               gradientMat=0.;
<a name="l03637"></a>03637               som_glob=-1;
<a name="l03638"></a>03638               <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a37f70143adef3313705fb8583168fd93">gradient_som</a>(face,nnz,som_glob,gradientMat);
<a name="l03639"></a>03639 
<a name="l03640"></a>03640               gradMat&lt;&lt;<span class="stringliteral">&quot;Face perio : &quot;</span>&lt;&lt;face*size1+comp&lt;&lt;endl;
<a name="l03641"></a>03641               gradMat&lt;&lt;<span class="stringliteral">&quot;(&quot;</span>;
<a name="l03642"></a>03642               <span class="keywordflow">for</span> (i=0; i&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; i++)
<a name="l03643"></a>03643                 gradMat&lt;&lt;xv(face,i)&lt;&lt;<span class="stringliteral">&quot;,&quot;</span>;
<a name="l03644"></a>03644               gradMat&lt;&lt;<span class="stringliteral">&quot;)&quot;</span>&lt;&lt;endl;
<a name="l03645"></a>03645               <span class="keywordflow">for</span> (i=0; i&lt;nnz; i++)
<a name="l03646"></a>03646                 {
<a name="l03647"></a>03647                   gradMat&lt;&lt;som_glob[i]&lt;&lt;<span class="stringliteral">&quot;(&quot;</span>;
<a name="l03648"></a>03648                   <span class="keywordflow">for</span> (ii=0; ii&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; ii++)
<a name="l03649"></a>03649                     gradMat&lt;&lt;xs(som_glob[i],ii)&lt;&lt;<span class="stringliteral">&quot;,&quot;</span>;
<a name="l03650"></a>03650                   gradMat&lt;&lt;<span class="stringliteral">&quot;):(&quot;</span>;
<a name="l03651"></a>03651                   <span class="keywordflow">for</span> (compj=0; compj&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; compj++)
<a name="l03652"></a>03652                     gradMat&lt;&lt;gradientMat(compj,i)&lt;&lt;<span class="stringliteral">&quot;,&quot;</span>;
<a name="l03653"></a>03653                   gradMat&lt;&lt;<span class="stringliteral">&quot;)&quot;</span>&lt;&lt;endl;
<a name="l03654"></a>03654                 }
<a name="l03655"></a>03655 
<a name="l03656"></a>03656               resu=0.;
<a name="l03657"></a>03657               <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#aa940ce85caaf77638f592302b1fd8561">calculer_divergence_som</a>(resu);
<a name="l03658"></a>03658               <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#af61161babbf0b5a57042d39601c47e3e">corriger_Cl_test</a>(resu);
<a name="l03659"></a>03659               solveur_masse.<a class="code" href="classSolveur__Masse.html#af7afe8c2d4d5764f7428f2cd4ef43ddb" title="Appel a l&#39;objet sous-jacent. Resoud le systeme lineaire, dont la matrice est la matrice de masse...">appliquer</a>(resu);
<a name="l03660"></a>03660               div&lt;&lt;<span class="stringliteral">&quot;Face perio : &quot;</span>&lt;&lt;face*size1+comp&lt;&lt;endl;
<a name="l03661"></a>03661               div&lt;&lt;<span class="stringliteral">&quot;(&quot;</span>;
<a name="l03662"></a>03662               <span class="keywordflow">for</span> (i=0; i&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; i++)
<a name="l03663"></a>03663                 div&lt;&lt;xv(face,i)&lt;&lt;<span class="stringliteral">&quot;,&quot;</span>;
<a name="l03664"></a>03664               div&lt;&lt;<span class="stringliteral">&quot;)&quot;</span>&lt;&lt;endl;
<a name="l03665"></a>03665               <span class="keywordflow">for</span> (i=0; i&lt;size0; i++)
<a name="l03666"></a>03666                 {
<a name="l03667"></a>03667                   div&lt;&lt;i&lt;&lt;<span class="stringliteral">&quot;(&quot;</span>;
<a name="l03668"></a>03668                   <span class="keywordflow">for</span> (ii=0; ii&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; ii++)
<a name="l03669"></a>03669                     div&lt;&lt;xv(i,ii)&lt;&lt;<span class="stringliteral">&quot;,&quot;</span>;
<a name="l03670"></a>03670                   div&lt;&lt;<span class="stringliteral">&quot;):=(&quot;</span>;
<a name="l03671"></a>03671                   <span class="keywordflow">for</span> (j=0; j&lt;size1; j++)
<a name="l03672"></a>03672                     div&lt;&lt;resu[i*size1+j]&lt;&lt;<span class="stringliteral">&quot;,&quot;</span>;
<a name="l03673"></a>03673                   div&lt;&lt;<span class="stringliteral">&quot;)&quot;</span>&lt;&lt;endl;
<a name="l03674"></a>03674                 }
<a name="l03675"></a>03675 
<a name="l03676"></a>03676               resu*=-1.;
<a name="l03677"></a>03677               res&lt;&lt;<span class="stringliteral">&quot;Face perio : &quot;</span>&lt;&lt;face*size1+comp&lt;&lt;endl;
<a name="l03678"></a>03678               res&lt;&lt;<span class="stringliteral">&quot;(&quot;</span>;
<a name="l03679"></a>03679               <span class="keywordflow">for</span> (i=0; i&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; i++)
<a name="l03680"></a>03680                 res&lt;&lt;xv(face,i)&lt;&lt;<span class="stringliteral">&quot;,&quot;</span>;
<a name="l03681"></a>03681               res&lt;&lt;<span class="stringliteral">&quot;)&quot;</span>&lt;&lt;endl;
<a name="l03682"></a>03682               <span class="keywordflow">for</span> (i=0; i&lt;size0; i++)
<a name="l03683"></a>03683                 {
<a name="l03684"></a>03684                   res&lt;&lt;i&lt;&lt;<span class="stringliteral">&quot;(&quot;</span>;
<a name="l03685"></a>03685                   <span class="keywordflow">for</span> (ii=0; ii&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; ii++)
<a name="l03686"></a>03686                     res&lt;&lt;xv(i,ii)&lt;&lt;<span class="stringliteral">&quot;,&quot;</span>;
<a name="l03687"></a>03687                   res&lt;&lt;<span class="stringliteral">&quot;):=(&quot;</span>;
<a name="l03688"></a>03688                   <span class="keywordflow">for</span> (j=0; j&lt;size1; j++)
<a name="l03689"></a>03689                     res&lt;&lt;resu[i*size1+j]&lt;&lt;<span class="stringliteral">&quot;,&quot;</span>;
<a name="l03690"></a>03690                   res&lt;&lt;<span class="stringliteral">&quot;)&quot;</span>&lt;&lt;endl;
<a name="l03691"></a>03691                 }
<a name="l03692"></a>03692 
<a name="l03693"></a>03693 <span class="comment">// Version matricielle</span>
<a name="l03694"></a>03694               resuMat=0.;
<a name="l03695"></a>03695               matrice.<a class="code" href="classMatrice__Morse.html#a7bbc0c7773ecb51c01d76adc02356dc0" title="Operation de multiplication-accumulation (saxpy) matrice matrice&lt;br&gt;(matrice X representee par un tab...">ajouter_multTab_</a>(inco,resuMat);
<a name="l03696"></a>03696               solveur_masse.<a class="code" href="classSolveur__Masse.html#af7afe8c2d4d5764f7428f2cd4ef43ddb" title="Appel a l&#39;objet sous-jacent. Resoud le systeme lineaire, dont la matrice est la matrice de masse...">appliquer</a>(resuMat);
<a name="l03697"></a>03697               resuMat.<a class="code" href="classDoubleVect.html#abfebbc2f685ce7bc4b80c720d7da9bf3">echange_espace_virtuel</a>();
<a name="l03698"></a>03698               resMat&lt;&lt;<span class="stringliteral">&quot;Face perio :&quot;</span>&lt;&lt;face*size1+comp&lt;&lt;endl;
<a name="l03699"></a>03699               resMat&lt;&lt;<span class="stringliteral">&quot;(&quot;</span>;
<a name="l03700"></a>03700               <span class="keywordflow">for</span> (i=0; i&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; i++)
<a name="l03701"></a>03701                 resMat&lt;&lt;xv(face,i)&lt;&lt;<span class="stringliteral">&quot;,&quot;</span>;
<a name="l03702"></a>03702               resMat&lt;&lt;<span class="stringliteral">&quot;)&quot;</span>&lt;&lt;endl;
<a name="l03703"></a>03703               <span class="keywordflow">for</span> (i=0; i&lt;size0; i++)
<a name="l03704"></a>03704                 {
<a name="l03705"></a>03705                   resMat&lt;&lt;i&lt;&lt;<span class="stringliteral">&quot;(&quot;</span>;
<a name="l03706"></a>03706                   <span class="keywordflow">for</span> (ii=0; ii&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; ii++)
<a name="l03707"></a>03707                     resMat&lt;&lt;xv(i,ii)&lt;&lt;<span class="stringliteral">&quot;,&quot;</span>;
<a name="l03708"></a>03708                   resMat&lt;&lt;<span class="stringliteral">&quot;):=(&quot;</span>;
<a name="l03709"></a>03709                   <span class="keywordflow">for</span> (j=0; j&lt;size1; j++)
<a name="l03710"></a>03710                     resMat&lt;&lt;resuMatV[i*size1+j]&lt;&lt;<span class="stringliteral">&quot;,&quot;</span>;
<a name="l03711"></a>03711                   resMat&lt;&lt;<span class="stringliteral">&quot;)&quot;</span>&lt;&lt;endl;
<a name="l03712"></a>03712                 }
<a name="l03713"></a>03713 
<a name="l03714"></a>03714 <span class="comment">// Difference entre les resultat</span>
<a name="l03715"></a>03715               resu-=resuMat;
<a name="l03716"></a>03716 
<a name="l03717"></a>03717 <span class="comment">// Affichage des differences</span>
<a name="l03718"></a>03718               max=resu.<a class="code" href="classDoubleVect.html#abdefeb5d940e66320adc0b9b11309737">local_max_abs_vect</a>();
<a name="l03719"></a>03719               <span class="keywordflow">if</span> (max&gt;1.e-14)
<a name="l03720"></a>03720                 {
<a name="l03721"></a>03721                   result&lt;&lt;<span class="stringliteral">&quot;Diff pour face perio : &quot;</span>&lt;&lt;face*size1+comp&lt;&lt;endl;
<a name="l03722"></a>03722                   result&lt;&lt;<span class="stringliteral">&quot;(&quot;</span>;
<a name="l03723"></a>03723                   <span class="keywordflow">for</span> (i=0; i&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; i++)
<a name="l03724"></a>03724                     result&lt;&lt;xv(face,i)&lt;&lt;<span class="stringliteral">&quot;,&quot;</span>;
<a name="l03725"></a>03725                   result&lt;&lt;<span class="stringliteral">&quot;)&quot;</span>&lt;&lt;endl;
<a name="l03726"></a>03726                   <span class="keywordflow">for</span> (i=0; i&lt;size0; i++)
<a name="l03727"></a>03727                     {
<a name="l03728"></a>03728                       test1=<span class="keyword">false</span>;
<a name="l03729"></a>03729                       <span class="keywordflow">for</span> (j=0; j&lt;size1; j++)
<a name="l03730"></a>03730                         test1|=(<a class="code" href="Double_8h.html#aaecd4ca8a2fe69cc6568af2938b94d2e">dabs</a>(resuV[i*size1+j])&gt;1.e-14);
<a name="l03731"></a>03731 
<a name="l03732"></a>03732                       <span class="keywordflow">if</span> (test1)
<a name="l03733"></a>03733                         {
<a name="l03734"></a>03734                           result&lt;&lt;i&lt;&lt;<span class="stringliteral">&quot;(&quot;</span>;
<a name="l03735"></a>03735                           <span class="keywordflow">for</span> (ii=0; ii&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; ii++)
<a name="l03736"></a>03736                             result&lt;&lt;xv(i,ii)&lt;&lt;<span class="stringliteral">&quot;,&quot;</span>;
<a name="l03737"></a>03737                           result&lt;&lt;<span class="stringliteral">&quot;):=(&quot;</span>;
<a name="l03738"></a>03738                           <span class="keywordflow">for</span> (j=0; j&lt;size1; j++)
<a name="l03739"></a>03739                             result &lt;&lt;resuV[i*size1+j]&lt;&lt;<span class="stringliteral">&quot;,&quot;</span>;
<a name="l03740"></a>03740                           result &lt;&lt;<span class="stringliteral">&quot;)&quot;</span>&lt;&lt;endl;
<a name="l03741"></a>03741                         }
<a name="l03742"></a>03742                     }
<a name="l03743"></a>03743                 }
<a name="l03744"></a>03744               <span class="keywordflow">else</span>
<a name="l03745"></a>03745                 {
<a name="l03746"></a>03746                   result&lt;&lt;<span class="stringliteral">&quot;Diff pour face perio : &quot;</span>&lt;&lt;face*size1+comp&lt;&lt;endl;
<a name="l03747"></a>03747                   result&lt;&lt;<span class="stringliteral">&quot;Maximum : &quot;</span>&lt;&lt;max&lt;&lt;endl;
<a name="l03748"></a>03748                 }
<a name="l03749"></a>03749 
<a name="l03750"></a>03750               <span class="keywordflow">if</span> (<a class="code" href="classProcess.html#acd052b99706c577f8a5b6656217cf4c2" title="renvoie 1 si on est sur le processeur maitre du groupe courant (c&#39;est a dire me() == 0)...">Process::je_suis_maitre</a>()) incoV[face*size1+comp]=0.;
<a name="l03751"></a>03751               <span class="keywordflow">if</span> (<a class="code" href="classProcess.html#acd052b99706c577f8a5b6656217cf4c2" title="renvoie 1 si on est sur le processeur maitre du groupe courant (c&#39;est a dire me() == 0)...">Process::je_suis_maitre</a>()) incoV[faceAss*size1+comp]=0.;
<a name="l03752"></a>03752               inco.<a class="code" href="classDoubleVect.html#abfebbc2f685ce7bc4b80c720d7da9bf3">echange_espace_virtuel</a>();
<a name="l03753"></a>03753             }
<a name="l03754"></a>03754         }<span class="comment">//fin Perio</span>
<a name="l03755"></a>03755       <span class="keywordflow">else</span>
<a name="l03756"></a>03756         <span class="keywordflow">for</span> (ind_face=num1; ind_face&lt;num2; ind_face++)
<a name="l03757"></a>03757           {
<a name="l03758"></a>03758             face=le_bord.<a class="code" href="classFront__VF.html#a3402a19d7e54ed797d2b18e9a47ead1e" title="Renvoie le numero de face de la ieme face du bord.">num_face</a>(ind_face);
<a name="l03759"></a>03759             <span class="keywordflow">if</span> (<a class="code" href="classProcess.html#acd052b99706c577f8a5b6656217cf4c2" title="renvoie 1 si on est sur le processeur maitre du groupe courant (c&#39;est a dire me() == 0)...">Process::je_suis_maitre</a>()) incoV[face*size1+comp]=1.;
<a name="l03760"></a>03760             inco.<a class="code" href="classDoubleVect.html#abfebbc2f685ce7bc4b80c720d7da9bf3">echange_espace_virtuel</a>();
<a name="l03761"></a>03761 
<a name="l03762"></a>03762 <span class="comment">// Version explicite</span>
<a name="l03763"></a>03763             <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a076341d23635d4ad7b0bfc19a03a7722">gradient_p1_</a>=0.;
<a name="l03764"></a>03764             <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a5e85dd4ed5a586f2787a149790ba0714">calculer_gradient_som</a>(inco);
<a name="l03765"></a>03765 
<a name="l03766"></a>03766 <span class="comment">// Controle des gradients</span>
<a name="l03767"></a>03767             grad &lt;&lt;<span class="stringliteral">&quot;Face CL : &quot;</span>&lt;&lt;face*size1+comp&lt;&lt;endl;
<a name="l03768"></a>03768             grad&lt;&lt;<span class="stringliteral">&quot;(&quot;</span>;
<a name="l03769"></a>03769             <span class="keywordflow">for</span> (i=0; i&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; i++)
<a name="l03770"></a>03770               grad&lt;&lt;xv(face,i)&lt;&lt;<span class="stringliteral">&quot;,&quot;</span>;
<a name="l03771"></a>03771             grad&lt;&lt;<span class="stringliteral">&quot;)&quot;</span>&lt;&lt;endl;
<a name="l03772"></a>03772             <span class="keywordflow">for</span> (som=0; som&lt;nb_som_tot; som++)
<a name="l03773"></a>03773               {
<a name="l03774"></a>03774                 grad &lt;&lt;som&lt;&lt;<span class="stringliteral">&quot;(&quot;</span>;
<a name="l03775"></a>03775                 <span class="keywordflow">for</span> (i=0; i&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; i++)
<a name="l03776"></a>03776                   grad&lt;&lt;xs(som,i)&lt;&lt;<span class="stringliteral">&quot;,&quot;</span>;
<a name="l03777"></a>03777                 grad&lt;&lt;<span class="stringliteral">&quot;):(&quot;</span>;
<a name="l03778"></a>03778                 <span class="keywordflow">for</span> (compi=0; compi&lt;<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#aecdf3d22b30add37625e545939004844">dim_ch_</a>; compi++)
<a name="l03779"></a>03779                   <span class="keywordflow">for</span> (compj=0; compj&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; compj++)
<a name="l03780"></a>03780                     grad&lt;&lt;<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a076341d23635d4ad7b0bfc19a03a7722">gradient_p1_</a>(som,compi,compj)&lt;&lt;<span class="stringliteral">&quot;,&quot;</span>;
<a name="l03781"></a>03781                 grad&lt;&lt;<span class="stringliteral">&quot;)&quot;</span>&lt;&lt;endl;
<a name="l03782"></a>03782               }
<a name="l03783"></a>03783 
<a name="l03784"></a>03784             gradientMat=0.;
<a name="l03785"></a>03785             som_glob=-1;
<a name="l03786"></a>03786             <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a253bedb1323fa89e08a8d88e2be8798d">gradient_som_CL</a>(face,nnz,som_glob,gradientMat);
<a name="l03787"></a>03787 
<a name="l03788"></a>03788             gradMat&lt;&lt;<span class="stringliteral">&quot;Face CL : &quot;</span>&lt;&lt;face*size1+comp&lt;&lt;endl;
<a name="l03789"></a>03789             gradMat&lt;&lt;<span class="stringliteral">&quot;(&quot;</span>;
<a name="l03790"></a>03790             <span class="keywordflow">for</span> (i=0; i&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; i++)
<a name="l03791"></a>03791               gradMat&lt;&lt;xv(face,i)&lt;&lt;<span class="stringliteral">&quot;,&quot;</span>;
<a name="l03792"></a>03792             gradMat&lt;&lt;<span class="stringliteral">&quot;)&quot;</span>&lt;&lt;endl;
<a name="l03793"></a>03793             <span class="keywordflow">for</span> (i=0; i&lt;nnz; i++)
<a name="l03794"></a>03794               {
<a name="l03795"></a>03795                 gradMat&lt;&lt;som_glob[i]&lt;&lt;<span class="stringliteral">&quot;(&quot;</span>;
<a name="l03796"></a>03796                 <span class="keywordflow">for</span> (ii=0; ii&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; ii++)
<a name="l03797"></a>03797                   gradMat&lt;&lt;xs(som_glob[i],ii)&lt;&lt;<span class="stringliteral">&quot;,&quot;</span>;
<a name="l03798"></a>03798                 gradMat&lt;&lt;<span class="stringliteral">&quot;):(&quot;</span>;
<a name="l03799"></a>03799                 <span class="keywordflow">for</span> (compj=0; compj&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; compj++)
<a name="l03800"></a>03800                   gradMat&lt;&lt;gradientMat(compj,i)&lt;&lt;<span class="stringliteral">&quot;,&quot;</span>;
<a name="l03801"></a>03801                 gradMat&lt;&lt;<span class="stringliteral">&quot;)&quot;</span>&lt;&lt;endl;
<a name="l03802"></a>03802               }
<a name="l03803"></a>03803 
<a name="l03804"></a>03804             resu=0.;
<a name="l03805"></a>03805             <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#aa940ce85caaf77638f592302b1fd8561">calculer_divergence_som</a>(resu);
<a name="l03806"></a>03806             <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#af61161babbf0b5a57042d39601c47e3e">corriger_Cl_test</a>(resu);
<a name="l03807"></a>03807             solveur_masse.<a class="code" href="classSolveur__Masse.html#af7afe8c2d4d5764f7428f2cd4ef43ddb" title="Appel a l&#39;objet sous-jacent. Resoud le systeme lineaire, dont la matrice est la matrice de masse...">appliquer</a>(resu);
<a name="l03808"></a>03808             div&lt;&lt;<span class="stringliteral">&quot;Face CL : &quot;</span>&lt;&lt;face*size1+comp&lt;&lt;endl;
<a name="l03809"></a>03809             div&lt;&lt;<span class="stringliteral">&quot;(&quot;</span>;
<a name="l03810"></a>03810             <span class="keywordflow">for</span> (i=0; i&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; i++)
<a name="l03811"></a>03811               div&lt;&lt;xv(face,i)&lt;&lt;<span class="stringliteral">&quot;,&quot;</span>;
<a name="l03812"></a>03812             div&lt;&lt;<span class="stringliteral">&quot;)&quot;</span>&lt;&lt;endl;
<a name="l03813"></a>03813             <span class="keywordflow">for</span> (i=0; i&lt;size0; i++)
<a name="l03814"></a>03814               {
<a name="l03815"></a>03815                 div&lt;&lt;i&lt;&lt;<span class="stringliteral">&quot;(&quot;</span>;
<a name="l03816"></a>03816                 <span class="keywordflow">for</span> (ii=0; ii&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; ii++)
<a name="l03817"></a>03817                   div&lt;&lt;xv(i,ii)&lt;&lt;<span class="stringliteral">&quot;,&quot;</span>;
<a name="l03818"></a>03818                 div&lt;&lt;<span class="stringliteral">&quot;):=(&quot;</span>;
<a name="l03819"></a>03819                 <span class="keywordflow">for</span> (j=0; j&lt;size1; j++)
<a name="l03820"></a>03820                   div&lt;&lt;resu[i*size1+j]&lt;&lt;<span class="stringliteral">&quot;,&quot;</span>;
<a name="l03821"></a>03821                 div&lt;&lt;<span class="stringliteral">&quot;)&quot;</span>&lt;&lt;endl;
<a name="l03822"></a>03822               }
<a name="l03823"></a>03823 
<a name="l03824"></a>03824             resu*=-1.;
<a name="l03825"></a>03825             res&lt;&lt;<span class="stringliteral">&quot;Face CL : &quot;</span>&lt;&lt;face*size1+comp&lt;&lt;endl;
<a name="l03826"></a>03826             res&lt;&lt;<span class="stringliteral">&quot;(&quot;</span>;
<a name="l03827"></a>03827             <span class="keywordflow">for</span> (i=0; i&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; i++)
<a name="l03828"></a>03828               res&lt;&lt;xv(face,i)&lt;&lt;<span class="stringliteral">&quot;,&quot;</span>;
<a name="l03829"></a>03829             res&lt;&lt;<span class="stringliteral">&quot;)&quot;</span>&lt;&lt;endl;
<a name="l03830"></a>03830             <span class="keywordflow">for</span> (i=0; i&lt;size0; i++)
<a name="l03831"></a>03831               {
<a name="l03832"></a>03832                 test1=<span class="keyword">false</span>;
<a name="l03833"></a>03833                 <span class="keywordflow">for</span> (j=0; j&lt;size1; j++)
<a name="l03834"></a>03834                   test1|=(<a class="code" href="Double_8h.html#aaecd4ca8a2fe69cc6568af2938b94d2e">dabs</a>(resuV[i*size1+j])&gt;max);
<a name="l03835"></a>03835 
<a name="l03836"></a>03836                 <span class="keywordflow">if</span> (test1)
<a name="l03837"></a>03837                   {
<a name="l03838"></a>03838                     res&lt;&lt;i&lt;&lt;<span class="stringliteral">&quot;(&quot;</span>;
<a name="l03839"></a>03839                     <span class="keywordflow">for</span> (ii=0; ii&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; ii++)
<a name="l03840"></a>03840                       res&lt;&lt;xv(i,ii)&lt;&lt;<span class="stringliteral">&quot;,&quot;</span>;
<a name="l03841"></a>03841                     res&lt;&lt;<span class="stringliteral">&quot;):=(&quot;</span>;
<a name="l03842"></a>03842                     <span class="keywordflow">for</span> (j=0; j&lt;size1; j++)
<a name="l03843"></a>03843                       res&lt;&lt;resu[i*size1+j]&lt;&lt;<span class="stringliteral">&quot;,&quot;</span>;
<a name="l03844"></a>03844                     res&lt;&lt;<span class="stringliteral">&quot;)&quot;</span>&lt;&lt;endl;
<a name="l03845"></a>03845                   }
<a name="l03846"></a>03846               }
<a name="l03847"></a>03847 
<a name="l03848"></a>03848 <span class="comment">// Version matricielle</span>
<a name="l03849"></a>03849             resuMat=0.;
<a name="l03850"></a>03850             matrice.<a class="code" href="classMatrice__Morse.html#a7bbc0c7773ecb51c01d76adc02356dc0" title="Operation de multiplication-accumulation (saxpy) matrice matrice&lt;br&gt;(matrice X representee par un tab...">ajouter_multTab_</a>(inco,resuMat);
<a name="l03851"></a>03851             solveur_masse.<a class="code" href="classSolveur__Masse.html#af7afe8c2d4d5764f7428f2cd4ef43ddb" title="Appel a l&#39;objet sous-jacent. Resoud le systeme lineaire, dont la matrice est la matrice de masse...">appliquer</a>(resuMat);
<a name="l03852"></a>03852             resuMat.<a class="code" href="classDoubleVect.html#abfebbc2f685ce7bc4b80c720d7da9bf3">echange_espace_virtuel</a>();
<a name="l03853"></a>03853             resMat&lt;&lt;<span class="stringliteral">&quot;Face CL :&quot;</span>&lt;&lt;face*size1+comp&lt;&lt;endl;
<a name="l03854"></a>03854             resMat&lt;&lt;<span class="stringliteral">&quot;(&quot;</span>;
<a name="l03855"></a>03855             <span class="keywordflow">for</span> (i=0; i&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; i++)
<a name="l03856"></a>03856               resMat&lt;&lt;xv(face,i)&lt;&lt;<span class="stringliteral">&quot;,&quot;</span>;
<a name="l03857"></a>03857             resMat&lt;&lt;<span class="stringliteral">&quot;)&quot;</span>&lt;&lt;endl;
<a name="l03858"></a>03858             <span class="keywordflow">for</span> (i=0; i&lt;size0; i++)
<a name="l03859"></a>03859               {
<a name="l03860"></a>03860                 resMat&lt;&lt;i&lt;&lt;<span class="stringliteral">&quot;(&quot;</span>;
<a name="l03861"></a>03861                 <span class="keywordflow">for</span> (ii=0; ii&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; ii++)
<a name="l03862"></a>03862                   resMat&lt;&lt;xv(i,ii)&lt;&lt;<span class="stringliteral">&quot;,&quot;</span>;
<a name="l03863"></a>03863                 resMat&lt;&lt;<span class="stringliteral">&quot;):=(&quot;</span>;
<a name="l03864"></a>03864                 <span class="keywordflow">for</span> (j=0; j&lt;size1; j++)
<a name="l03865"></a>03865                   resMat&lt;&lt;resuMatV[i*size1+j]&lt;&lt;<span class="stringliteral">&quot;,&quot;</span>;
<a name="l03866"></a>03866                 resMat&lt;&lt;<span class="stringliteral">&quot;)&quot;</span>&lt;&lt;endl;
<a name="l03867"></a>03867               }
<a name="l03868"></a>03868 
<a name="l03869"></a>03869 <span class="comment">// Difference entre les resultat</span>
<a name="l03870"></a>03870             resu-=resuMat;
<a name="l03871"></a>03871 
<a name="l03872"></a>03872 <span class="comment">// Affichage des differences</span>
<a name="l03873"></a>03873             max=resu.<a class="code" href="classDoubleVect.html#abdefeb5d940e66320adc0b9b11309737">local_max_abs_vect</a>();
<a name="l03874"></a>03874             <span class="keywordflow">if</span> (max&gt;1.e-14)
<a name="l03875"></a>03875               {
<a name="l03876"></a>03876                 result&lt;&lt;<span class="stringliteral">&quot;Diff pour face CL : &quot;</span>&lt;&lt;face*size1+comp&lt;&lt;endl;
<a name="l03877"></a>03877                 result&lt;&lt;<span class="stringliteral">&quot;(&quot;</span>;
<a name="l03878"></a>03878                 <span class="keywordflow">for</span> (i=0; i&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; i++)
<a name="l03879"></a>03879                   result&lt;&lt;xv(face,i)&lt;&lt;<span class="stringliteral">&quot;,&quot;</span>;
<a name="l03880"></a>03880                 result&lt;&lt;<span class="stringliteral">&quot;)&quot;</span>&lt;&lt;endl;
<a name="l03881"></a>03881                 <span class="keywordflow">for</span> (i=0; i&lt;size0; i++)
<a name="l03882"></a>03882                   {
<a name="l03883"></a>03883                     test1=<span class="keyword">false</span>;
<a name="l03884"></a>03884                     <span class="keywordflow">for</span> (j=0; j&lt;size1; j++)
<a name="l03885"></a>03885                       test1|=(<a class="code" href="Double_8h.html#aaecd4ca8a2fe69cc6568af2938b94d2e">dabs</a>(resuV[i*size1+j])&gt;1.e-14);
<a name="l03886"></a>03886 
<a name="l03887"></a>03887                     <span class="keywordflow">if</span> (test1)
<a name="l03888"></a>03888                       {
<a name="l03889"></a>03889                         result&lt;&lt;i&lt;&lt;<span class="stringliteral">&quot;(&quot;</span>;
<a name="l03890"></a>03890                         <span class="keywordflow">for</span> (ii=0; ii&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; ii++)
<a name="l03891"></a>03891                           result&lt;&lt;xv(i,ii)&lt;&lt;<span class="stringliteral">&quot;,&quot;</span>;
<a name="l03892"></a>03892                         result&lt;&lt;<span class="stringliteral">&quot;):=(&quot;</span>;
<a name="l03893"></a>03893                         <span class="keywordflow">for</span> (j=0; j&lt;size1; j++)
<a name="l03894"></a>03894                           result &lt;&lt;resuV[i*size1+j]&lt;&lt;<span class="stringliteral">&quot;,&quot;</span>;
<a name="l03895"></a>03895                         result &lt;&lt;<span class="stringliteral">&quot;)&quot;</span>&lt;&lt;endl;
<a name="l03896"></a>03896                       }
<a name="l03897"></a>03897                   }
<a name="l03898"></a>03898               }
<a name="l03899"></a>03899             <span class="keywordflow">else</span>
<a name="l03900"></a>03900               {
<a name="l03901"></a>03901                 result&lt;&lt;<span class="stringliteral">&quot;Diff pour face CL : &quot;</span>&lt;&lt;face*size1+comp&lt;&lt;endl;
<a name="l03902"></a>03902                 result&lt;&lt;<span class="stringliteral">&quot;Maximum : &quot;</span>&lt;&lt;max&lt;&lt;endl;
<a name="l03903"></a>03903               }
<a name="l03904"></a>03904 
<a name="l03905"></a>03905             <span class="keywordflow">if</span> (<a class="code" href="classProcess.html#acd052b99706c577f8a5b6656217cf4c2" title="renvoie 1 si on est sur le processeur maitre du groupe courant (c&#39;est a dire me() == 0)...">Process::je_suis_maitre</a>()) incoV[face*size1+comp]=0.;
<a name="l03906"></a>03906             inco.<a class="code" href="classDoubleVect.html#abfebbc2f685ce7bc4b80c720d7da9bf3">echange_espace_virtuel</a>();
<a name="l03907"></a>03907           }<span class="comment">//fin autres CL</span>
<a name="l03908"></a>03908     }<span class="comment">//fin du for sur n_bord</span>
<a name="l03909"></a>03909   <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">exit</a>();
<a name="l03910"></a>03910 }
<a name="l03911"></a>03911 
<a name="l03912"></a><a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#af61161babbf0b5a57042d39601c47e3e">03912</a> <span class="keywordtype">void</span> <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#af61161babbf0b5a57042d39601c47e3e">Op_Diff_VEFP1NCP1B_Face::corriger_Cl_test</a>(<a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; resu)<span class="keyword"> const</span>
<a name="l03913"></a>03913 <span class="keyword"></span>{
<a name="l03914"></a>03914   <span class="keyword">const</span> <a class="code" href="classZone__Cl__VEF.html">Zone_Cl_VEF</a>&amp; zone_Cl_VEF=<a class="code" href="classOp__Diff__VEF__base.html#a721f395a27f12a95882437c614e16a7d">la_zcl_vef</a>.<a class="code" href="classRef__Zone__Cl__VEF.html#a0970d7253def65ad4f0c5ce1830fd243">valeur</a>();
<a name="l03915"></a>03915   <span class="keyword">const</span> <a class="code" href="classConds__lim.html">Conds_lim</a>&amp; les_cl = zone_Cl_VEF.<a class="code" href="classZone__Cl__dis__base.html#af75e0ed7786863e4d333bfb29d67c323" title="Renvoie la i-ieme condition aux limites. (version const)">les_conditions_limites</a>();
<a name="l03916"></a>03916 
<a name="l03917"></a>03917   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_bords =les_cl.<a class="code" href="classvect__impl.html#a78155bfbd6b61f4710b9830641ed1694">size</a>();
<a name="l03918"></a>03918   <span class="keywordtype">int</span> n_bord=0, num1=0, num2=0;
<a name="l03919"></a>03919   <span class="keywordtype">int</span> face=0, <a class="code" href="AssembleurPP1BUtil_8cpp.html#a3e374d53ebc7860e1c2f0b7906f2936d">face_associee</a>=0;
<a name="l03920"></a>03920   <span class="keywordtype">int</span> ind_face=0, comp=0;
<a name="l03921"></a>03921 
<a name="l03922"></a>03922   <span class="keywordflow">for</span> (n_bord=0; n_bord&lt;nb_bords; n_bord++)
<a name="l03923"></a>03923     {
<a name="l03924"></a>03924       <span class="keyword">const</span> <a class="code" href="classCond__lim.html" title="classe Cond_lim Classe generique servant a representer n&#39;importe quelle classe derivee de la classe C...">Cond_lim</a>&amp; la_cl = zone_Cl_VEF.<a class="code" href="classZone__Cl__dis__base.html#af75e0ed7786863e4d333bfb29d67c323" title="Renvoie la i-ieme condition aux limites. (version const)">les_conditions_limites</a>(n_bord);
<a name="l03925"></a>03925       <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp; le_bord = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>,la_cl.<a class="code" href="classCond__lim.html#a5b2d24809cee07727006a891d4ce8d22" title="Appel a l&#39;objet sous-jacent Renvoie la frontiere discretisee associee a la condition aux limites...">frontiere_dis</a>());
<a name="l03926"></a>03926 
<a name="l03927"></a>03927       num1=0;
<a name="l03928"></a>03928       num2=le_bord.<a class="code" href="classFront__VF.html#a341e2fcb5117b96e745fd7078ba86bab" title="Nombre de faces reelles du bord.">nb_faces</a>();
<a name="l03929"></a>03929 
<a name="l03930"></a>03930       <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>()))
<a name="l03931"></a>03931         {
<a name="l03932"></a>03932           <span class="keyword">const</span> <a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>&amp; la_cl_perio = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>());
<a name="l03933"></a>03933 
<a name="l03934"></a>03934           <span class="keywordflow">for</span> (ind_face=num1; ind_face&lt;num2; ind_face++)
<a name="l03935"></a>03935             {
<a name="l03936"></a>03936               face = le_bord.<a class="code" href="classFront__VF.html#a3402a19d7e54ed797d2b18e9a47ead1e" title="Renvoie le numero de face de la ieme face du bord.">num_face</a>(ind_face);
<a name="l03937"></a>03937               <a class="code" href="AssembleurPP1BUtil_8cpp.html#a3e374d53ebc7860e1c2f0b7906f2936d">face_associee</a>=
<a name="l03938"></a>03938                 le_bord.<a class="code" href="classFront__VF.html#a3402a19d7e54ed797d2b18e9a47ead1e" title="Renvoie le numero de face de la ieme face du bord.">num_face</a>(la_cl_perio.<a class="code" href="classPeriodique.html#a207b86556f199a63ea059b841851ca6a">face_associee</a>(ind_face));
<a name="l03939"></a>03939 
<a name="l03940"></a>03940               <span class="keywordflow">if</span> (face&lt;<a class="code" href="AssembleurPP1BUtil_8cpp.html#a3e374d53ebc7860e1c2f0b7906f2936d">face_associee</a>)
<a name="l03941"></a>03941                 <span class="keywordflow">for</span> (comp=0; comp&lt;<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#aecdf3d22b30add37625e545939004844">dim_ch_</a>; comp++)
<a name="l03942"></a>03942                   {
<a name="l03943"></a>03943                     resu[face*dim_ch_+comp]+=resu[<a class="code" href="AssembleurPP1BUtil_8cpp.html#a3e374d53ebc7860e1c2f0b7906f2936d">face_associee</a>*dim_ch_+comp];
<a name="l03944"></a>03944                     resu[<a class="code" href="AssembleurPP1BUtil_8cpp.html#a3e374d53ebc7860e1c2f0b7906f2936d">face_associee</a>*dim_ch_+comp]=resu[face*dim_ch_+comp];
<a name="l03945"></a>03945                   }
<a name="l03946"></a>03946             }
<a name="l03947"></a>03947         }
<a name="l03948"></a>03948     }
<a name="l03949"></a>03949   resu.<a class="code" href="classDoubleVect.html#abfebbc2f685ce7bc4b80c720d7da9bf3">echange_espace_virtuel</a>();
<a name="l03950"></a>03950 }
<a name="l03951"></a>03951 
</pre></div></div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Tue Dec 14 2021 19:35:29 for TRUST by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
