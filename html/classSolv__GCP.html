<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>TRUST: Solv_GCP Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">TRUST&#160;<span id="projectnumber">1.8.4</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a>  </div>
  <div class="headertitle">
<div class="title">Solv_GCP Class Reference</div>  </div>
</div>
<div class="contents">
<!-- doxytag: class="Solv_GCP" --><!-- doxytag: inherits="solv_iteratif" -->
<p><code>#include &lt;<a class="el" href="Solv__GCP_8h_source.html">Solv_GCP.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Solv_GCP:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classSolv__GCP.png" usemap="#Solv_GCP_map" alt=""/>
  <map id="Solv_GCP_map" name="Solv_GCP_map">
<area href="classsolv__iteratif.html" alt="solv_iteratif" shape="rect" coords="0,168,111,192"/>
<area href="classSolveurSys__base.html" alt="SolveurSys_base" shape="rect" coords="0,112,111,136"/>
<area href="classObjet__U.html" title="classe Objet_U Cette classe est la classe de base des Objets de TRUST Dans les classes derivees de Ob..." alt="Objet_U" shape="rect" coords="0,56,111,80"/>
<area href="classProcess.html" title="Classe de base de TRUST (notamment Objet_U). Elle fournit quelques services de base accessibles de pa..." alt="Process" shape="rect" coords="0,0,111,24"/>
</map>
 </div></div>

<p><a href="classSolv__GCP-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolv__GCP.html#a37322487a24be8e6fafa440aae2f0dc4">~Solv_GCP</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolv__GCP.html#a51de77dd797bd0aa731d6b25d545b2ed">taille_memoire</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolv__GCP.html#ada69a9515ac88062920ff07bc265327f">duplique</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classType__info.html">Type_info</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolv__GCP.html#a8269ab9f90f6afb1d867960b5bbdbded">get_info</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Donne des informations sur le type de l'Objet_U.  <a href="#a8269ab9f90f6afb1d867960b5bbdbded"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolv__GCP.html#ac2abbec713f0320129df64a8fddc5826">Solv_GCP</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolv__GCP.html#ac32faafc19ecfacd8d0e4dc749eb3e64">resoudre_systeme</a> (const <a class="el" href="classMatrice__Base.html">Matrice_Base</a> &amp;, const <a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;, <a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolv__GCP.html#a2938854d2ea72586ef3e959412f31e14">resoudre_systeme</a> (const <a class="el" href="classMatrice__Base.html">Matrice_Base</a> &amp;, const <a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;, <a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;, int)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classPrecond.html">Precond</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolv__GCP.html#a10c9f9fe6f2b41d72a7f56a05cda4279">get_precond</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolv__GCP.html#a1913e3bdca62b3e5c773000ce7f40283">set_precond</a> (const <a class="el" href="classPrecond.html">Precond</a> &amp;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolv__GCP.html#a506c202030f5f801f0ae4779c24ba77b">reinit</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolv__GCP.html#a7c678ee1e78c2bd116df7a415537b715">supporte_matrice_morse_sym</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolv__GCP.html#ad5bbc31758a268ef84dcad1f914dfcc6">get_flag_updated_input</a> () const </td></tr>
<tr><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classObjet__U.html">Objet_U</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolv__GCP.html#a0cc18f4d41187fb2c21dd2c473001fba">cree_instance</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classType__info.html">Type_info</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolv__GCP.html#ad53f158cee99d7425116741ff7c2dacc">info</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Donne des informations sur le type de l'Objet_U.  <a href="#ad53f158cee99d7425116741ff7c2dacc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSolv__GCP.html">Solv_GCP</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolv__GCP.html#a59dc2a1e6216ddeadc71ecd50e273e79">self_cast</a> (<a class="el" href="classObjet__U.html">Objet_U</a> &amp;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classSolv__GCP.html">Solv_GCP</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolv__GCP.html#a7d98dbc130536e4375af1e6f9b78541d">self_cast</a> (const <a class="el" href="classObjet__U.html">Objet_U</a> &amp;)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">methode ajoutee pour caster en python  <a href="#a7d98dbc130536e4375af1e6f9b78541d"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classType__info.html">Type_info</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolv__GCP.html#a97ebbc2b0ec642843942268dd6fd3dd2">info_obj</a></td></tr>
<tr><td colspan="2"><h2><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classSortie.html">Sortie</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolv__GCP.html#a07f4bbd4ed0ae392abf49e66b9dfcae6">printOn</a> (<a class="el" href="classSortie.html">Sortie</a> &amp;x) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Ecriture de l'objet sur un flot de sortie<br/>
Methode a surcharger.  <a href="#a07f4bbd4ed0ae392abf49e66b9dfcae6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classEntree.html">Entree</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolv__GCP.html#a03d07e57b46d32e119e23b402d343454">readOn</a> (<a class="el" href="classEntree.html">Entree</a> &amp;)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Lecture d'un <a class="el" href="classObjet__U.html" title="classe Objet_U Cette classe est la classe de base des Objets de TRUST Dans les classes derivees de Ob...">Objet_U</a> sur un flot d'entree<br/>
Methode a surcharger.  <a href="#a03d07e57b46d32e119e23b402d343454"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolv__GCP.html#aeb6006a337b824f7702dbd32084580a1">prepare_data</a> (const <a class="el" href="classMatrice__Base.html">Matrice_Base</a> &amp;matrice, const <a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;secmem, <a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;solution)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolv__GCP.html#ab92ff464161604146fb820cdbf2079a1">resoudre_</a> (const <a class="el" href="classMatrice__Base.html">Matrice_Base</a> &amp;, const <a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;, <a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;, int)</td></tr>
<tr><td colspan="2"><h2><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolv__GCP.html#a2de0798151556049240ddceaedcd2010">optimized_</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPrecond.html">Precond</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolv__GCP.html#aa9aa7485970ae948b2561b89e141af13">le_precond_</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolv__GCP.html#aebbaeaa67bf2f876d354938b76e7c36a">precond_diag_</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDoubleVect.html">DoubleVect</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolv__GCP.html#af10441b3afc51b4e2a967a2f9c2e813e">tmp_p_avec_items_virt_</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDoubleVect.html">DoubleVect</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolv__GCP.html#a2dde6b48ed50f795d0df442e25543f24">resu_</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDoubleVect.html">DoubleVect</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolv__GCP.html#a491a6795972aa58d19e222211b70bb73">residu_</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDoubleVect.html">DoubleVect</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolv__GCP.html#a73cac6d4f308333325a0430590ebceec">tmp_p_</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDoubleVect.html">DoubleVect</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolv__GCP.html#a3ee6d07baa401b83335a06036b8c9d4e">tmp_solution_</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMatrice__Morse__Sym.html">Matrice_Morse_Sym</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolv__GCP.html#af90f523225473263ab3531630a418817">tmp_mat_</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMatrice__SuperMorse.html">Matrice_SuperMorse</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolv__GCP.html#ab0dde9b547a7afdbb13329529c24f995">tmp_mat_virt_</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classArrOfDouble.html">ArrOfDouble</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolv__GCP.html#a63001a11b5ed3214789975e7633eac92">tmp_data_block_</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIntVect.html">IntVect</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolv__GCP.html#ab61b9443523fdea985d32989eee85ee7">renum_</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDoubleVect.html">DoubleVect</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolv__GCP.html#aa29ed43f42e31d43acdceb9cecc084dd">inv_sqrt_diag_</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolv__GCP.html#aba192c7ac366b8c30b0eecd8629af793">reinit_</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">0=&gt; rien n'est pret 1=&gt; memoire allouee, coeffs matrice a copier, 2=&gt; ok  <a href="#aba192c7ac366b8c30b0eecd8629af793"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolv__GCP.html#a468e7aef13e89875aa96874a3cc3e0f7">nb_it_max_</a></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock">
<p>Definition at line <a class="el" href="Solv__GCP_8h_source.html#l00031">31</a> of file <a class="el" href="Solv__GCP_8h_source.html">Solv_GCP.h</a>.</p>
</div><hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a37322487a24be8e6fafa440aae2f0dc4"></a><!-- doxytag: member="Solv_GCP::~Solv_GCP" ref="a37322487a24be8e6fafa440aae2f0dc4" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Solv_GCP::~Solv_GCP </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Solv__GCP_8cpp_source.html#l00034">34</a> of file <a class="el" href="Solv__GCP_8cpp_source.html">Solv_GCP.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac2abbec713f0320129df64a8fddc5826"></a><!-- doxytag: member="Solv_GCP::Solv_GCP" ref="ac2abbec713f0320129df64a8fddc5826" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Solv_GCP::Solv_GCP </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Solv__GCP_8cpp_source.html#l00038">38</a> of file <a class="el" href="Solv__GCP_8cpp_source.html">Solv_GCP.cpp</a>.</p>

<p>References <a class="el" href="Solv__GCP_8h_source.html#l00094">nb_it_max_</a>, <a class="el" href="Solv__GCP_8h_source.html#l00054">optimized_</a>, <a class="el" href="Solv__GCP_8h_source.html#l00064">precond_diag_</a>, <a class="el" href="Solv__GCP_8h_source.html#l00093">reinit_</a>, and <a class="el" href="solv__iteratif_8h_source.html#l00039">solv_iteratif::seuil_</a>.</p>
<div class="fragment"><pre class="fragment">{
  <a class="code" href="classsolv__iteratif.html#a726974e9a0579e0c242606430dc320d4">seuil_</a>=1.e-12;
  <a class="code" href="classSolv__GCP.html#aba192c7ac366b8c30b0eecd8629af793" title="0=&gt; rien n&#39;est pret 1=&gt; memoire allouee, coeffs matrice a copier, 2=&gt; ok">reinit_</a> = 0;
  <a class="code" href="classSolv__GCP.html#aebbaeaa67bf2f876d354938b76e7c36a">precond_diag_</a> = 0;
  <a class="code" href="classSolv__GCP.html#a2de0798151556049240ddceaedcd2010">optimized_</a> = 0;
  <a class="code" href="classSolv__GCP.html#a468e7aef13e89875aa96874a3cc3e0f7">nb_it_max_</a>=-1;
}
</pre></div>
</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a0cc18f4d41187fb2c21dd2c473001fba"></a><!-- doxytag: member="Solv_GCP::cree_instance" ref="a0cc18f4d41187fb2c21dd2c473001fba" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classObjet__U.html">Objet_U</a> * Solv_GCP::cree_instance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Solv__GCP_8cpp_source.html#l00034">34</a> of file <a class="el" href="Solv__GCP_8cpp_source.html">Solv_GCP.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ada69a9515ac88062920ff07bc265327f"></a><!-- doxytag: member="Solv_GCP::duplique" ref="ada69a9515ac88062920ff07bc265327f" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Solv_GCP::duplique </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implements <a class="el" href="classsolv__iteratif.html#a8468b65144035e165938248a89c96c94">solv_iteratif</a>.</p>

<p>Definition at line <a class="el" href="Solv__GCP_8cpp_source.html#l00034">34</a> of file <a class="el" href="Solv__GCP_8cpp_source.html">Solv_GCP.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad5bbc31758a268ef84dcad1f914dfcc6"></a><!-- doxytag: member="Solv_GCP::get_flag_updated_input" ref="ad5bbc31758a268ef84dcad1f914dfcc6" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Solv_GCP::get_flag_updated_input </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="classSolveurSys__base.html#a6f583abd60c2eca53740d02963503c0f">SolveurSys_base</a>.</p>

<p>Definition at line <a class="el" href="Solv__GCP_8h_source.html#l00046">46</a> of file <a class="el" href="Solv__GCP_8h_source.html">Solv_GCP.h</a>.</p>
<div class="fragment"><pre class="fragment">  {
    <span class="keywordflow">return</span> 0;
  }
</pre></div>
</div>
</div>
<a class="anchor" id="a8269ab9f90f6afb1d867960b5bbdbded"></a><!-- doxytag: member="Solv_GCP::get_info" ref="a8269ab9f90f6afb1d867960b5bbdbded" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classType__info.html">Type_info</a> * Solv_GCP::get_info </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Donne des informations sur le type de l'Objet_U. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>const Type_info*<br/>
 Signification: structure regroupant les informations sur le type de l'Objet_U<br/>
 Contraintes: </dd></dl>

<p>Reimplemented from <a class="el" href="classsolv__iteratif.html#ac2850f6e2fae4eb0b0c1dd03ba5aee4e">solv_iteratif</a>.</p>

<p>Definition at line <a class="el" href="Solv__GCP_8cpp_source.html#l00034">34</a> of file <a class="el" href="Solv__GCP_8cpp_source.html">Solv_GCP.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a10c9f9fe6f2b41d72a7f56a05cda4279"></a><!-- doxytag: member="Solv_GCP::get_precond" ref="a10c9f9fe6f2b41d72a7f56a05cda4279" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classPrecond.html">Precond</a> &amp; Solv_GCP::get_precond </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Solv__GCP_8h_source.html#l00102">102</a> of file <a class="el" href="Solv__GCP_8h_source.html">Solv_GCP.h</a>.</p>

<p>References <a class="el" href="Solv__GCP_8h_source.html#l00055">le_precond_</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">return</span> <a class="code" href="classSolv__GCP.html#aa9aa7485970ae948b2561b89e141af13">le_precond_</a>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="ad53f158cee99d7425116741ff7c2dacc"></a><!-- doxytag: member="Solv_GCP::info" ref="ad53f158cee99d7425116741ff7c2dacc" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classType__info.html">Type_info</a> * Solv_GCP::info </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Donne des informations sur le type de l'Objet_U. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>const Type_info*<br/>
 Signification: structure regroupant les informations sur le type de l'Objet_U<br/>
 Contraintes: </dd></dl>

<p>Reimplemented from <a class="el" href="classsolv__iteratif.html#a70db21118f72529a2bd4177d286e034e">solv_iteratif</a>.</p>

<p>Definition at line <a class="el" href="Solv__GCP_8cpp_source.html#l00034">34</a> of file <a class="el" href="Solv__GCP_8cpp_source.html">Solv_GCP.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="aeb6006a337b824f7702dbd32084580a1"></a><!-- doxytag: member="Solv_GCP::prepare_data" ref="aeb6006a337b824f7702dbd32084580a1" args="(const Matrice_Base &amp;matrice, const DoubleVect &amp;secmem, DoubleVect &amp;solution)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Solv_GCP::prepare_data </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMatrice__Base.html">Matrice_Base</a> &amp;&#160;</td>
          <td class="paramname"><em>matrice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;&#160;</td>
          <td class="paramname"><em>secmem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;&#160;</td>
          <td class="paramname"><em>solution</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>&lt; fortran -&gt; c</p>
<p>&lt; vecteurs avec espace virtuel (tmp_p_)</p>
<p>&lt; vecteurs sans espace virtuel</p>
<p>&lt; pour tab1_</p>
<p>&lt; pour les coefficients</p>
<p>&lt; pour les indices matrice reel/virtuel</p>
<p>&lt; pour tab1_</p>
<p>&lt; pour les coefficients</p>
<p>&lt; pour les indices taille de tmp_mat_virt_.lignes_non_vides_</p>
<p>&lt; avec espace virtuel</p>
<p>&lt; sans l'espace virtuel</p>
<p>&lt; fortran-&gt;c</p>
<p>&lt; c-&gt;fortran</p>
<p>&lt; index dans mat.tab2_ et coeff_</p>
<p>&lt; index dans tmp_mat_.tab2_ et coeff_</p>
<p>&lt; indice fortran du debut de ligne</p>
<p>&lt; index fortran</p>
<p>&lt; indice fortran du debut de ligne</p>
<p>&lt; indice fortran</p>
<p>&lt; index fortran</p>
<p>&lt; fortran-&gt;c</p>
<p>&lt; indice fortran</p>
<p>&lt; index fortran </p>
</p>

<p>Definition at line <a class="el" href="Solv__GCP_8cpp_source.html#l00124">124</a> of file <a class="el" href="Solv__GCP_8cpp_source.html">Solv_GCP.cpp</a>.</p>

<p>References <a class="el" href="ArrOfDouble_8h_source.html#l00379">ArrOfDouble::addr()</a>, <a class="el" href="EntreeSortie_8h_source.html#l00032">Cerr</a>, <a class="el" href="MD__Vector__tools_8cpp_source.html#l00638">MD_Vector_tools::creer_md_vect_renum_auto()</a>, <a class="el" href="Process_8cpp_source.html#l00223">Process::exit()</a>, <a class="el" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>, <a class="el" href="Matrice__Bloc_8cpp_source.html#l00568">Matrice_Bloc::get_bloc()</a>, <a class="el" href="Matrice__Morse_8h_source.html#l00142">Matrice_Morse::get_coeff()</a>, <a class="el" href="DoubleVect_8h_source.html#l00101">DoubleVect::get_md_vector()</a>, <a class="el" href="classMD__Vector__base.html#ade0ef13d456f8aa11d02f51fd7912145">MD_Vector_base::get_nb_items_reels()</a>, <a class="el" href="classMD__Vector__base.html#a27d5ace2aee5ecf1d78accb7b321108d">MD_Vector_base::get_nb_items_tot()</a>, <a class="el" href="Matrice__SuperMorse_8h_source.html#l00067">Matrice_SuperMorse::get_set_coeff()</a>, <a class="el" href="Matrice__Morse_8h_source.html#l00129">Matrice_Morse::get_set_coeff()</a>, <a class="el" href="Matrice__SuperMorse_8h_source.html#l00059">Matrice_SuperMorse::get_set_tab1()</a>, <a class="el" href="Matrice__Morse_8h_source.html#l00119">Matrice_Morse::get_set_tab1()</a>, <a class="el" href="Matrice__SuperMorse_8h_source.html#l00063">Matrice_SuperMorse::get_set_tab2()</a>, <a class="el" href="Matrice__Morse_8h_source.html#l00124">Matrice_Morse::get_set_tab2()</a>, <a class="el" href="Matrice__Morse_8h_source.html#l00134">Matrice_Morse::get_tab1()</a>, <a class="el" href="Matrice__Morse_8h_source.html#l00138">Matrice_Morse::get_tab2()</a>, <a class="el" href="ArrOfDouble_8cpp_source.html#l01110">ArrOfDouble::inject_array()</a>, <a class="el" href="ArrOfInt_8cpp_source.html#l01098">ArrOfInt::inject_array()</a>, <a class="el" href="Process_8cpp_source.html#l00345">Process::Journal()</a>, <a class="el" href="Matrice__SuperMorse_8h_source.html#l00089">Matrice_SuperMorse::lignes_non_vides_</a>, <a class="el" href="DoubleVect_8h_source.html#l00164">DoubleVect::line_size()</a>, <a class="el" href="Array__base_8h_source.html#l00038">Array_base::NOCOPY_NOINIT</a>, <a class="el" href="Solv__GCP_8h_source.html#l00064">precond_diag_</a>, <a class="el" href="Cast_8h_source.html#l00059">ref_cast</a>, <a class="el" href="ArrOfInt_8cpp_source.html#l00976">ArrOfInt::ref_data()</a>, <a class="el" href="IntVect_8cpp_source.html#l00224">IntVect::ref_data()</a>, <a class="el" href="ArrOfDouble_8cpp_source.html#l00988">ArrOfDouble::ref_data()</a>, <a class="el" href="DoubleVect_8cpp_source.html#l00225">DoubleVect::ref_data()</a>, <a class="el" href="Solv__GCP_8h_source.html#l00093">reinit_</a>, <a class="el" href="Solv__GCP_8h_source.html#l00087">renum_</a>, <a class="el" href="IntVect_8cpp_source.html#l00110">IntVect::reset()</a>, <a class="el" href="Solv__GCP_8h_source.html#l00070">residu_</a>, <a class="el" href="IntVect_8h_source.html#l00179">IntVect::resize()</a>, <a class="el" href="ArrOfDouble_8h_source.html#l00244">ArrOfDouble::resize_array()</a>, <a class="el" href="Solv__GCP_8h_source.html#l00069">resu_</a>, <a class="el" href="DoubleVect_8cpp_source.html#l00248">DoubleVect::set_md_vector()</a>, <a class="el" href="IntVect_8cpp_source.html#l00247">IntVect::set_md_vector()</a>, <a class="el" href="Matrice__Morse_8cpp_source.html#l00334">Matrice_Morse::set_nb_columns()</a>, <a class="el" href="DoubleVect_8h_source.html#l00153">DoubleVect::size()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00342">ArrOfInt::size_array()</a>, <a class="el" href="ArrOfDouble_8h_source.html#l00350">ArrOfDouble::size_array()</a>, <a class="el" href="Nom_8cpp_source.html#l00040">sz</a>, <a class="el" href="Solv__GCP_8h_source.html#l00084">tmp_data_block_</a>, <a class="el" href="Solv__GCP_8h_source.html#l00078">tmp_mat_</a>, <a class="el" href="Solv__GCP_8h_source.html#l00080">tmp_mat_virt_</a>, <a class="el" href="Solv__GCP_8h_source.html#l00075">tmp_p_</a>, <a class="el" href="Solv__GCP_8h_source.html#l00066">tmp_p_avec_items_virt_</a>, <a class="el" href="Solv__GCP_8h_source.html#l00076">tmp_solution_</a>, <a class="el" href="MD__Vector_8h_source.html#l00067">MD_Vector::valeur()</a>, and <a class="el" href="Deriv__Matrice__Base_8h_source.html#l00028">Deriv_Matrice_Base::valeur()</a>.</p>

<p>Referenced by <a class="el" href="Solv__GCP_8cpp_source.html#l00404">resoudre_()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">if</span> (<a class="code" href="classSolv__GCP.html#aba192c7ac366b8c30b0eecd8629af793" title="0=&gt; rien n&#39;est pret 1=&gt; memoire allouee, coeffs matrice a copier, 2=&gt; ok">reinit_</a> == 0)
    {
<span class="comment">// Reconstruction de toute la structure (tableaux d&#39;index et coefficients)</span>

      <span class="keywordflow">if</span> (secmem.<a class="code" href="classDoubleVect.html#ab02d01cd1bdab66fbd66f9a47cc29e10">line_size</a>() != 1)
        {
          <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Error line_size&gt;1 not coded (GCP)&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
          <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">exit</a>();
        }

      <span class="keyword">const</span> <a class="code" href="classMatrice__Bloc.html">Matrice_Bloc</a>&amp; mat_bloc = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Bloc.html">Matrice_Bloc</a>, matrice);
      <span class="keyword">const</span> <a class="code" href="classMatrice__Morse__Sym.html" title="Classe Matrice_Morse_Sym Represente une matrice M (creuse) symetrique stockee au format Morse Symetri...">Matrice_Morse_Sym</a>&amp; mat = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Morse__Sym.html" title="Classe Matrice_Morse_Sym Represente une matrice M (creuse) symetrique stockee au format Morse Symetri...">Matrice_Morse_Sym</a>, mat_bloc.<a class="code" href="classMatrice__Bloc.html#a7ffa38f7b93454432b2df7c616ed0a4e">get_bloc</a>(0,0).<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>());
      <span class="keyword">const</span> <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; mat_virt = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>, mat_bloc.<a class="code" href="classMatrice__Bloc.html#a7ffa38f7b93454432b2df7c616ed0a4e">get_bloc</a>(0,1).<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>());

<span class="comment">// Determination du nombre d&#39;items reellement utilises:</span>
      {
        <span class="keyword">const</span> <span class="keywordtype">int</span> sztot_source = secmem.<a class="code" href="classArrOfDouble.html#a3c3b33bea0e88b87315c21ee94bee05f" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>();
        <span class="keyword">const</span> <span class="keywordtype">int</span> <a class="code" href="Nom_8cpp.html#a0e1ea19fb9fa7881d15d84eff4c090e1">sz</a> = secmem.<a class="code" href="classDoubleVect.html#a392c1f20b462563365389d28e0853867" title="Identique a size_reelle()">size</a>();
        <a class="code" href="classSolv__GCP.html#ab61b9443523fdea985d32989eee85ee7">renum_</a>.<a class="code" href="classIntVect.html#a273976ecf3d2d4fdbdc48ab446027e8e" title="met l&#39;objet dans l&#39;etat obtenu par le constructeur par defaut. (voir ArrOfInt::reset())">reset</a>();
        <a class="code" href="classSolv__GCP.html#ab61b9443523fdea985d32989eee85ee7">renum_</a>.<a class="code" href="classIntVect.html#a5900779fd9a3f9a82c68007a42b87d98" title="Change la taille du vecteur (identique a resize_array() pour le traitement des anciennes valeurs et d...">resize</a>(sztot_source, <a class="code" href="classArray__base.html#abee342aa9ac59623c4c782dc9d7877ffaf6ae9ba7eb51c5f298ce693345b3ec68">Array_base::NOCOPY_NOINIT</a>);
        <a class="code" href="classSolv__GCP.html#ab61b9443523fdea985d32989eee85ee7">renum_</a> = 0;
<span class="comment">// Retirer les items virtuels</span>
        <span class="keywordtype">int</span> i;
        <span class="keywordflow">for</span> (i = sz; i &lt; sztot_source; i++)
          <a class="code" href="classSolv__GCP.html#ab61b9443523fdea985d32989eee85ee7">renum_</a>[i] = -1;
        <a class="code" href="classSolv__GCP.html#ab61b9443523fdea985d32989eee85ee7">renum_</a>.<a class="code" href="classIntVect.html#aefca15627f9f7852150f4a769f00e3e2" title="associe le md_vector au vecteur et initialise l&#39;attribut size_reelle_ (voir methode size_reelle()) Si...">set_md_vector</a>(secmem.<a class="code" href="classDoubleVect.html#a0d16d30580c90526e4895388fb44be5d">get_md_vector</a>());
        <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; tab2 = mat_virt.get_tab2();
        <span class="keyword">const</span> <span class="keywordtype">int</span> n = tab2.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>();
        <span class="keywordflow">for</span> (i = 0; i &lt; n; i++)
          {
<span class="comment">// Attention: tab2 de la partie reele-virtuelle contient des indices</span>
<span class="comment">// relatifs au debut de la partie virtuelle (d&#39;ou &quot;+ sz&quot;)</span>
            <span class="keyword">const</span> <span class="keywordtype">int</span> j = tab2[i]-1 + <a class="code" href="Nom_8cpp.html#a0e1ea19fb9fa7881d15d84eff4c090e1">sz</a>; <span class="comment">//!&lt; fortran -&gt; c</span>
<span class="comment"></span>            <a class="code" href="classSolv__GCP.html#ab61b9443523fdea985d32989eee85ee7">renum_</a>[j] = 0;
          }
      }
<span class="comment">// Determination du nombre de lignes non vides de mat_virt</span>
      <span class="keywordtype">int</span> nb_lignes_mat_virt = 0;
      {
        <span class="keyword">const</span> <span class="keywordtype">int</span> n = mat_virt.get_tab1().<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() - 1;
        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; n; i++)
          <span class="keywordflow">if</span> (mat_virt.get_tab1()(i+1) - mat_virt.get_tab1()(i) &gt; 0)
            nb_lignes_mat_virt++;
      }

<span class="comment">// Descripteur contenant uniquement les items utiles:</span>
      <a class="code" href="classMD__Vector.html" title=": Cette classe est un DERIV mais l&#39;objet pointe est partage entre plusieurs instances de cette classe...">MD_Vector</a> md;
      <a class="code" href="classMD__Vector__tools.html#a773ef21e5af6331de459189d19cc340b" title="Idem que creer_md_vect_renum() mais cree une numerotation par defaut. Le tableau flags_renum doit con...">MD_Vector_tools::creer_md_vect_renum_auto</a>(<a class="code" href="classSolv__GCP.html#ab61b9443523fdea985d32989eee85ee7">renum_</a>, md);
      <span class="keyword">const</span> <span class="keywordtype">int</span> sz_tot = md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a27d5ace2aee5ecf1d78accb7b321108d">get_nb_items_tot</a>();
      <span class="keyword">const</span> <span class="keywordtype">int</span> sz = md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#ade0ef13d456f8aa11d02f51fd7912145">get_nb_items_reels</a>();

<span class="comment">// Calcul de la taille memoire requise:</span>
      <span class="keywordtype">int</span> mem_size = 0;
      mem_size += sz_tot * <span class="keyword">sizeof</span>(double); <span class="comment">//!&lt;  vecteurs avec espace virtuel (tmp_p_)</span>
<span class="comment"></span>      mem_size += sz * <span class="keyword">sizeof</span>(double) * 3; <span class="comment">//!&lt; vecteurs sans espace virtuel</span>
<span class="comment"></span>      <span class="keyword">const</span> <span class="keywordtype">int</span> nb_lignes_mat = <a class="code" href="Nom_8cpp.html#a0e1ea19fb9fa7881d15d84eff4c090e1">sz</a>;
<span class="comment">// matrice reel/reel</span>
      mem_size += (sz + 1) * <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>); <span class="comment">//!&lt; pour tab1_</span>
<span class="comment"></span>      <span class="keywordtype">int</span> nnz_reel_reel = 0;
      assert(mat.<a class="code" href="classMatrice__Morse.html#a79b4e334152850bd36e53478debf3061">get_tab1</a>().<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() == sz + 1);
      assert(mat.<a class="code" href="classMatrice__Morse.html#a787b5a63f27063f9c891243d8f188cda">get_tab2</a>().<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() == mat.<a class="code" href="classMatrice__Morse.html#aacb80dd518dcc0812e3b34edac6ab67e">get_coeff</a>().<a class="code" href="classArrOfDouble.html#a3c3b33bea0e88b87315c21ee94bee05f" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>());
      <span class="keywordflow">if</span> (! <a class="code" href="classSolv__GCP.html#aebbaeaa67bf2f876d354938b76e7c36a">precond_diag_</a>)
        {
          nnz_reel_reel = mat.<a class="code" href="classMatrice__Morse.html#aacb80dd518dcc0812e3b34edac6ab67e">get_coeff</a>().<a class="code" href="classArrOfDouble.html#a3c3b33bea0e88b87315c21ee94bee05f" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>();
        }
      <span class="keywordflow">else</span>
        {
<span class="comment">// On ne stocke pas les coefficients diagonaux:</span>
          nnz_reel_reel = mat.<a class="code" href="classMatrice__Morse.html#aacb80dd518dcc0812e3b34edac6ab67e">get_coeff</a>().<a class="code" href="classArrOfDouble.html#a3c3b33bea0e88b87315c21ee94bee05f" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() - <a class="code" href="Nom_8cpp.html#a0e1ea19fb9fa7881d15d84eff4c090e1">sz</a>;
        }
      mem_size += nnz_reel_reel * <span class="keyword">sizeof</span>(double); <span class="comment">//!&lt; pour les coefficients</span>
<span class="comment"></span>      mem_size += nnz_reel_reel * <span class="keyword">sizeof</span>(int); <span class="comment">//!&lt; pour les indices matrice reel/virtuel</span>
<span class="comment"></span><span class="comment">//</span>
      mem_size += (nb_lignes_mat_virt+1) * <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>); <span class="comment">//!&lt; pour tab1_</span>
<span class="comment"></span>      <span class="keyword">const</span> <span class="keywordtype">int</span> nnz_reel_virtuel = mat_virt.get_coeff().size_array();
      assert(mat_virt.get_tab2().size_array() == nnz_reel_virtuel);
      mem_size += nnz_reel_virtuel * <span class="keyword">sizeof</span>(double); <span class="comment">//!&lt; pour les coefficients</span>
<span class="comment"></span>      mem_size += nnz_reel_virtuel * <span class="keyword">sizeof</span>(int); <span class="comment">//!&lt; pour les indices taille de tmp_mat_virt_.lignes_non_vides_</span>
<span class="comment"></span><span class="comment">//</span>
      mem_size += nb_lignes_mat_virt * <span class="keyword">sizeof</span>(int);
<span class="comment">// aligner la taille sur un multiple de 8</span>
      <span class="keywordflow">if</span> (mem_size % 8 != 0)
        mem_size = (mem_size/8+1)*8;

<span class="comment">// Allocation des tableaux:</span>
<span class="comment">// (on met d&#39;abord tous les tableaux de double, puis a la fin les tableaux d&#39;entiers</span>
<span class="comment">// sinon il faut ajouter du padding pour aligner si on remet des double apres de int)</span>
<span class="comment">// </span>
      <a class="code" href="classProcess.html#a57e0f54b11e6eaadbea224fa904b18dd" title="Renvoie un objet statique de type Sortie qui sert de journal d&#39;evenements. Si message_level &lt;= verbose...">Journal</a>() &lt;&lt; <span class="stringliteral">&quot;Solv_GCP::prepare allocating data chunk : &quot;</span> &lt;&lt; mem_size &lt;&lt; <span class="stringliteral">&quot; bytes&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
      <a class="code" href="classSolv__GCP.html#a63001a11b5ed3214789975e7633eac92">tmp_data_block_</a>.<a class="code" href="classArrOfDouble.html#a610464f4b3dccac6f814915b526783ed">resize_array</a>(mem_size/8, <a class="code" href="classArray__base.html#abee342aa9ac59623c4c782dc9d7877ffaf6ae9ba7eb51c5f298ce693345b3ec68">Array_base::NOCOPY_NOINIT</a>);

      <span class="keywordtype">double</span> *ptr = <a class="code" href="classSolv__GCP.html#a63001a11b5ed3214789975e7633eac92">tmp_data_block_</a>.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
      <a class="code" href="classSolv__GCP.html#a2dde6b48ed50f795d0df442e25543f24">resu_</a>.<a class="code" href="classDoubleVect.html#a4cc7c18df3f14857336aee6ff41f4f49" title="voir ArrOfDouble::ref_data(). (cree un tableau sans structure parallele)">ref_data</a>(ptr, sz);
      ptr += <a class="code" href="Nom_8cpp.html#a0e1ea19fb9fa7881d15d84eff4c090e1">sz</a>;
      <a class="code" href="classSolv__GCP.html#a491a6795972aa58d19e222211b70bb73">residu_</a>.<a class="code" href="classDoubleVect.html#a4cc7c18df3f14857336aee6ff41f4f49" title="voir ArrOfDouble::ref_data(). (cree un tableau sans structure parallele)">ref_data</a>(ptr, sz);
      ptr += <a class="code" href="Nom_8cpp.html#a0e1ea19fb9fa7881d15d84eff4c090e1">sz</a>;
      <a class="code" href="classSolv__GCP.html#af10441b3afc51b4e2a967a2f9c2e813e">tmp_p_avec_items_virt_</a>.<a class="code" href="classDoubleVect.html#a4cc7c18df3f14857336aee6ff41f4f49" title="voir ArrOfDouble::ref_data(). (cree un tableau sans structure parallele)">ref_data</a>(ptr, sz_tot); <span class="comment">//!&lt; avec espace virtuel</span>
<span class="comment"></span>      <a class="code" href="classSolv__GCP.html#af10441b3afc51b4e2a967a2f9c2e813e">tmp_p_avec_items_virt_</a>.<a class="code" href="classDoubleVect.html#a63f1c9da5548085b7b2f7a9e54611a0d" title="associe le md_vector au vecteur et initialise l&#39;attribut size_reelle_ (voir methode size_reelle()) Si...">set_md_vector</a>(md);
<span class="comment">// tmp_p_ pointe sur la meme zone:</span>
      <a class="code" href="classSolv__GCP.html#a73cac6d4f308333325a0430590ebceec">tmp_p_</a>.<a class="code" href="classDoubleVect.html#a4cc7c18df3f14857336aee6ff41f4f49" title="voir ArrOfDouble::ref_data(). (cree un tableau sans structure parallele)">ref_data</a>(ptr, sz); <span class="comment">//!&lt; sans l&#39;espace virtuel</span>
<span class="comment"></span>      ptr += sz_tot;
      <a class="code" href="classSolv__GCP.html#a3ee6d07baa401b83335a06036b8c9d4e">tmp_solution_</a>.<a class="code" href="classDoubleVect.html#a4cc7c18df3f14857336aee6ff41f4f49" title="voir ArrOfDouble::ref_data(). (cree un tableau sans structure parallele)">ref_data</a>(ptr, sz);
      ptr += <a class="code" href="Nom_8cpp.html#a0e1ea19fb9fa7881d15d84eff4c090e1">sz</a>;
<span class="comment">// Allocation des tableaux pour les matrices:</span>
      <a class="code" href="classSolv__GCP.html#af90f523225473263ab3531630a418817">tmp_mat_</a>.<a class="code" href="classMatrice__Morse.html#acd067e8514e5741f52b18a1d99746d11">get_set_coeff</a>().<a class="code" href="classDoubleVect.html#a4cc7c18df3f14857336aee6ff41f4f49" title="voir ArrOfDouble::ref_data(). (cree un tableau sans structure parallele)">ref_data</a>(ptr, nnz_reel_reel);
      ptr += nnz_reel_reel;
      <a class="code" href="classSolv__GCP.html#ab0dde9b547a7afdbb13329529c24f995">tmp_mat_virt_</a>.<a class="code" href="classMatrice__SuperMorse.html#a98b6048dc2ccb53becccaff698e64e38">get_set_coeff</a>().<a class="code" href="classArrOfDouble.html#a8cc97dbe67c8001dad97008b10fa7690" title="Fait pointer le tableau vers la zone de memoire &quot;data_&quot;. On detache la zone de memoire existante...">ref_data</a>(ptr, nnz_reel_virtuel);
      ptr += nnz_reel_virtuel;
<span class="comment">// On a fini les double, on passe aux tableaux d&#39;entiers:</span>
      <span class="keywordtype">int</span> * iptr = (<span class="keywordtype">int</span>*)ptr;
      <a class="code" href="classSolv__GCP.html#af90f523225473263ab3531630a418817">tmp_mat_</a>.<a class="code" href="classMatrice__Morse.html#a7a49c763706dcfaed900f9d2cbb68716">get_set_tab1</a>().<a class="code" href="classIntVect.html#aca0cf803f3b217131c25563773c9f043" title="voir ArrOfInt::ref_data(). (cree un tableau sans structure parallele)">ref_data</a>(iptr, nb_lignes_mat + 1);
      iptr += nb_lignes_mat + 1;
      <a class="code" href="classSolv__GCP.html#af90f523225473263ab3531630a418817">tmp_mat_</a>.<a class="code" href="classMatrice__Morse.html#af11c5853518e9e6db4c7e6e6acc8d7fd">get_set_tab2</a>().<a class="code" href="classIntVect.html#aca0cf803f3b217131c25563773c9f043" title="voir ArrOfInt::ref_data(). (cree un tableau sans structure parallele)">ref_data</a>(iptr, nnz_reel_reel);
      iptr += nnz_reel_reel;
      <a class="code" href="classSolv__GCP.html#ab0dde9b547a7afdbb13329529c24f995">tmp_mat_virt_</a>.<a class="code" href="classMatrice__SuperMorse.html#a9cde1b97e8a6d898fdc67bb995544361">lignes_non_vides_</a>.<a class="code" href="classArrOfInt.html#a95b02281f2d3f210e463389ff7288169" title="Fait pointer le tableau vers la zone de memoire &quot;data_&quot;. On detache la zone de memoire existante...">ref_data</a>(iptr, nb_lignes_mat_virt);
      iptr += nb_lignes_mat_virt;
      <a class="code" href="classSolv__GCP.html#ab0dde9b547a7afdbb13329529c24f995">tmp_mat_virt_</a>.<a class="code" href="classMatrice__SuperMorse.html#a0fa4af20a68806d12a4a8efdf4979825">get_set_tab1</a>().<a class="code" href="classArrOfInt.html#a95b02281f2d3f210e463389ff7288169" title="Fait pointer le tableau vers la zone de memoire &quot;data_&quot;. On detache la zone de memoire existante...">ref_data</a>(iptr, nb_lignes_mat_virt + 1);
      iptr += nb_lignes_mat_virt + 1;
      <a class="code" href="classSolv__GCP.html#ab0dde9b547a7afdbb13329529c24f995">tmp_mat_virt_</a>.<a class="code" href="classMatrice__SuperMorse.html#adf9277e7d1424888f34f54668a61a02f">get_set_tab2</a>().<a class="code" href="classArrOfInt.html#a95b02281f2d3f210e463389ff7288169" title="Fait pointer le tableau vers la zone de memoire &quot;data_&quot;. On detache la zone de memoire existante...">ref_data</a>(iptr, nnz_reel_virtuel);
      iptr += nnz_reel_virtuel;
<span class="comment">// Allocation terminee.</span>
      assert(((<span class="keywordtype">char</span>*)iptr) &lt;= ((<span class="keywordtype">char</span>*)<a class="code" href="classSolv__GCP.html#a63001a11b5ed3214789975e7633eac92">tmp_data_block_</a>.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() + mem_size));

<span class="comment">// Remplissages des tableaux d&#39;index (tab1_, tab2_ et lignes_non_vides_)</span>
      <span class="keywordflow">if</span> (! <a class="code" href="classSolv__GCP.html#aebbaeaa67bf2f876d354938b76e7c36a">precond_diag_</a>)
        {
          <a class="code" href="classSolv__GCP.html#af90f523225473263ab3531630a418817">tmp_mat_</a>.<a class="code" href="classMatrice__Morse.html#a7a49c763706dcfaed900f9d2cbb68716">get_set_tab1</a>().<a class="code" href="classArrOfInt.html#a195c644d98bf2da2fe4f8aede4e02262" title="Copie les elements source[first_element_source + i] dans les elements (*this)[first_element_dest + i]...">inject_array</a>(mat.<a class="code" href="classMatrice__Morse.html#a79b4e334152850bd36e53478debf3061">get_tab1</a>());
          {
<span class="comment">// remplissage de tab2 (renumerotation eventuelle)</span>
            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; nnz_reel_reel; i++)
              {
                <span class="keywordtype">int</span> j = mat.<a class="code" href="classMatrice__Morse.html#a787b5a63f27063f9c891243d8f188cda">get_tab2</a>()(i)-1; <span class="comment">//!&lt; fortran-&gt;c</span>
<span class="comment"></span>                <span class="keywordtype">int</span> rj = <a class="code" href="classSolv__GCP.html#ab61b9443523fdea985d32989eee85ee7">renum_</a>[j];
                assert(rj &lt; sz_tot);
                <a class="code" href="classSolv__GCP.html#af90f523225473263ab3531630a418817">tmp_mat_</a>.<a class="code" href="classMatrice__Morse.html#af11c5853518e9e6db4c7e6e6acc8d7fd">get_set_tab2</a>()(i) = rj+1; <span class="comment">//!&lt; c-&gt;fortran</span>
<span class="comment"></span>              }
          }
          <a class="code" href="classSolv__GCP.html#af90f523225473263ab3531630a418817">tmp_mat_</a>.<a class="code" href="classMatrice__Morse.html#ab2fb02a8aba88f717c2285960f375fba">set_nb_columns</a>( sz_tot );
        }
      <span class="keywordflow">else</span>
        {
<span class="comment">// Construction de la matrice D^(-1/2) * A * D^(-1/2)</span>
<span class="comment">// on ne stocke pas les coeffs diagonaux</span>
<span class="comment">// Le remplissage de tab1_ n&#39;est pas trivial, du coup:</span>
          {
            <span class="keywordtype">int</span> src_index = 0; <span class="comment">//!&lt; index dans mat.tab2_ et coeff_</span>
<span class="comment"></span>            <span class="keywordtype">int</span> dest_index = 0; <span class="comment">//!&lt; index dans tmp_mat_.tab2_ et coeff_</span>
<span class="comment"></span>            <span class="keywordtype">int</span> i_ligne;
            <span class="keywordflow">for</span> (i_ligne = 0; i_ligne &lt; nb_lignes_mat; i_ligne++)
              {
<span class="comment">// A chaque ligne on a un coefficient de moins que dans la matrice d&#39;origine</span>
<span class="comment">// (on ne met pas le coeff diagonal)</span>
                <a class="code" href="classSolv__GCP.html#af90f523225473263ab3531630a418817">tmp_mat_</a>.<a class="code" href="classMatrice__Morse.html#a7a49c763706dcfaed900f9d2cbb68716">get_set_tab1</a>()(i_ligne) = dest_index + 1; <span class="comment">//!&lt; indice fortran du debut de ligne</span>
<span class="comment"></span>                <span class="keyword">const</span> <span class="keywordtype">int</span> ncoeff = mat.<a class="code" href="classMatrice__Morse.html#a79b4e334152850bd36e53478debf3061">get_tab1</a>()(i_ligne+1) - mat.<a class="code" href="classMatrice__Morse.html#a79b4e334152850bd36e53478debf3061">get_tab1</a>()(i_ligne) - 1;
<span class="comment">// Ne pas inserer le coeff diagonal</span>
                assert(mat.<a class="code" href="classMatrice__Morse.html#a787b5a63f27063f9c891243d8f188cda">get_tab2</a>()(src_index) == i_ligne + 1); <span class="comment">//!&lt; index fortran</span>
<span class="comment"></span>                src_index++;
<span class="comment">// Inserer les autres coeffs:</span>
                <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; ncoeff; i++, src_index++, dest_index++)
                  <a class="code" href="classSolv__GCP.html#af90f523225473263ab3531630a418817">tmp_mat_</a>.<a class="code" href="classMatrice__Morse.html#af11c5853518e9e6db4c7e6e6acc8d7fd">get_set_tab2</a>()(dest_index) = mat.<a class="code" href="classMatrice__Morse.html#a787b5a63f27063f9c891243d8f188cda">get_tab2</a>()(src_index);

              }
<span class="comment">// Fin de la derniere ligne:</span>
            <a class="code" href="classSolv__GCP.html#af90f523225473263ab3531630a418817">tmp_mat_</a>.<a class="code" href="classMatrice__Morse.html#a7a49c763706dcfaed900f9d2cbb68716">get_set_tab1</a>()(i_ligne) = dest_index + 1; <span class="comment">//!&lt; indice fortran du debut de ligne</span>
<span class="comment"></span>          }
          <a class="code" href="classSolv__GCP.html#af90f523225473263ab3531630a418817">tmp_mat_</a>.<a class="code" href="classMatrice__Morse.html#ab2fb02a8aba88f717c2285960f375fba">set_nb_columns</a>( sz_tot );
        }
<span class="comment">// remplissage de tmp_mat_virt_</span>
      {
        <a class="code" href="classSolv__GCP.html#ab0dde9b547a7afdbb13329529c24f995">tmp_mat_virt_</a>.<a class="code" href="classMatrice__SuperMorse.html#a0fa4af20a68806d12a4a8efdf4979825">get_set_tab1</a>()(0) = 1;
        <span class="keywordtype">int</span> i_ligne_dest = 0;
        <span class="keywordtype">int</span> dest_index = 0;
        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i_ligne = 0; i_ligne &lt; nb_lignes_mat; i_ligne++)
          {
            <span class="keyword">const</span> <span class="keywordtype">int</span> count = mat_virt.get_tab1()(i_ligne+1) - mat_virt.get_tab1()(i_ligne);
            <span class="keywordflow">if</span> (count &gt; 0)
              {
                <a class="code" href="classSolv__GCP.html#ab0dde9b547a7afdbb13329529c24f995">tmp_mat_virt_</a>.<a class="code" href="classMatrice__SuperMorse.html#a9cde1b97e8a6d898fdc67bb995544361">lignes_non_vides_</a>[i_ligne_dest] = i_ligne + 1; <span class="comment">//!&lt; indice fortran</span>
<span class="comment"></span>                <a class="code" href="classSolv__GCP.html#ab0dde9b547a7afdbb13329529c24f995">tmp_mat_virt_</a>.<a class="code" href="classMatrice__SuperMorse.html#a0fa4af20a68806d12a4a8efdf4979825">get_set_tab1</a>()(i_ligne_dest) = dest_index + 1; <span class="comment">//!&lt; index fortran</span>
<span class="comment"></span>                i_ligne_dest++;
                <span class="keywordtype">int</span> src_index = mat_virt.get_tab1()(i_ligne) - 1; <span class="comment">//!&lt; fortran-&gt;c</span>
<span class="comment"></span>                <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; count; i++, src_index++, dest_index++)
                  {
<span class="comment">// mat_virt contient des indices fortran relatifs au debut de la partie virtuelle,</span>
<span class="comment">// on transform en indice C, relatif au vecteur complet</span>
                    <span class="keywordtype">int</span> j = mat_virt.get_tab2()(src_index) + sz - 1;
                    <span class="keywordtype">int</span> rj = <a class="code" href="classSolv__GCP.html#ab61b9443523fdea985d32989eee85ee7">renum_</a>[j];
<span class="comment">// on stocke dans tmp_mat_virt des indices de colonnes relatifs au vecteur complet</span>
<span class="comment">// (pas seulement la partie virtuelle)</span>
                    <a class="code" href="classSolv__GCP.html#ab0dde9b547a7afdbb13329529c24f995">tmp_mat_virt_</a>.<a class="code" href="classMatrice__SuperMorse.html#adf9277e7d1424888f34f54668a61a02f">get_set_tab2</a>()(dest_index) = rj + 1; <span class="comment">//!&lt; indice fortran</span>
<span class="comment"></span>                  }
              }
          }
<span class="comment">// Fin de la derniere ligne:</span>
        <a class="code" href="classSolv__GCP.html#ab0dde9b547a7afdbb13329529c24f995">tmp_mat_virt_</a>.<a class="code" href="classMatrice__SuperMorse.html#a0fa4af20a68806d12a4a8efdf4979825">get_set_tab1</a>()(i_ligne_dest) = dest_index + 1; <span class="comment">//!&lt; index fortran</span>
<span class="comment"></span>      }
      <a class="code" href="classSolv__GCP.html#aba192c7ac366b8c30b0eecd8629af793" title="0=&gt; rien n&#39;est pret 1=&gt; memoire allouee, coeffs matrice a copier, 2=&gt; ok">reinit_</a> = 1;
    }

  <span class="keywordflow">if</span> (<a class="code" href="classSolv__GCP.html#aba192c7ac366b8c30b0eecd8629af793" title="0=&gt; rien n&#39;est pret 1=&gt; memoire allouee, coeffs matrice a copier, 2=&gt; ok">reinit_</a> &lt; 2)
    {
      <span class="keyword">const</span> <a class="code" href="classMatrice__Bloc.html">Matrice_Bloc</a>&amp; mat_bloc = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Bloc.html">Matrice_Bloc</a>, matrice);
      <span class="keyword">const</span> <a class="code" href="classMatrice__Morse__Sym.html" title="Classe Matrice_Morse_Sym Represente une matrice M (creuse) symetrique stockee au format Morse Symetri...">Matrice_Morse_Sym</a>&amp; mat = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Morse__Sym.html" title="Classe Matrice_Morse_Sym Represente une matrice M (creuse) symetrique stockee au format Morse Symetri...">Matrice_Morse_Sym</a>, mat_bloc.<a class="code" href="classMatrice__Bloc.html#a7ffa38f7b93454432b2df7c616ed0a4e">get_bloc</a>(0,0).<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>());
      <span class="keyword">const</span> <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; mat_virt = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>, mat_bloc.<a class="code" href="classMatrice__Bloc.html#a7ffa38f7b93454432b2df7c616ed0a4e">get_bloc</a>(0,1).<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>());
      <span class="keywordflow">if</span> (!<a class="code" href="classSolv__GCP.html#aebbaeaa67bf2f876d354938b76e7c36a">precond_diag_</a>)
        {
          <a class="code" href="classSolv__GCP.html#af90f523225473263ab3531630a418817">tmp_mat_</a>.<a class="code" href="classMatrice__Morse.html#acd067e8514e5741f52b18a1d99746d11">get_set_coeff</a>().<a class="code" href="classArrOfDouble.html#a2fcb2a2d3b59425c6cb37526ea6af6a3" title="Copie les elements source[first_element_source + i] dans les elements (*this)[first_element_dest + i]...">inject_array</a>(mat.<a class="code" href="classMatrice__Morse.html#aacb80dd518dcc0812e3b34edac6ab67e">get_coeff</a>());
          <a class="code" href="classSolv__GCP.html#ab0dde9b547a7afdbb13329529c24f995">tmp_mat_virt_</a>.<a class="code" href="classMatrice__SuperMorse.html#a98b6048dc2ccb53becccaff698e64e38">get_set_coeff</a>().<a class="code" href="classArrOfDouble.html#a2fcb2a2d3b59425c6cb37526ea6af6a3" title="Copie les elements source[first_element_source + i] dans les elements (*this)[first_element_dest + i]...">inject_array</a>(mat_virt.get_coeff());
        }
      <span class="keywordflow">else</span>
        {
<span class="comment">// calcul de D^(-1/2)</span>
          <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">exit</a>();
<span class="comment">// calcul du produit D^(-1/2) * A * D^(-1/2)</span>

        }
      <a class="code" href="classSolv__GCP.html#aba192c7ac366b8c30b0eecd8629af793" title="0=&gt; rien n&#39;est pret 1=&gt; memoire allouee, coeffs matrice a copier, 2=&gt; ok">reinit_</a> = 2;
    }

  <span class="keywordflow">if</span> (!<a class="code" href="classSolv__GCP.html#aebbaeaa67bf2f876d354938b76e7c36a">precond_diag_</a>)
    {
      <a class="code" href="classSolv__GCP.html#a3ee6d07baa401b83335a06036b8c9d4e">tmp_solution_</a>.<a class="code" href="classArrOfDouble.html#a2fcb2a2d3b59425c6cb37526ea6af6a3" title="Copie les elements source[first_element_source + i] dans les elements (*this)[first_element_dest + i]...">inject_array</a>(solution, <a class="code" href="classSolv__GCP.html#a3ee6d07baa401b83335a06036b8c9d4e">tmp_solution_</a>.<a class="code" href="classDoubleVect.html#a392c1f20b462563365389d28e0853867" title="Identique a size_reelle()">size</a>());
      <a class="code" href="classSolv__GCP.html#a2dde6b48ed50f795d0df442e25543f24">resu_</a>.<a class="code" href="classArrOfDouble.html#a2fcb2a2d3b59425c6cb37526ea6af6a3" title="Copie les elements source[first_element_source + i] dans les elements (*this)[first_element_dest + i]...">inject_array</a>(secmem, <a class="code" href="classSolv__GCP.html#a2dde6b48ed50f795d0df442e25543f24">resu_</a>.<a class="code" href="classArrOfDouble.html#a3c3b33bea0e88b87315c21ee94bee05f" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>());
    }
  <span class="keywordflow">else</span>
    {
      <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">exit</a>();
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a07f4bbd4ed0ae392abf49e66b9dfcae6"></a><!-- doxytag: member="Solv_GCP::printOn" ref="a07f4bbd4ed0ae392abf49e66b9dfcae6" args="(Sortie &amp;x) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSortie.html">Sortie</a> &amp; Solv_GCP::printOn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSortie.html">Sortie</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td> const<code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Ecriture de l'objet sur un flot de sortie<br/>
Methode a surcharger. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="classSortie.html" title="Classe de base des flux de sortie. Elle sait ecrire des types simples&lt;br&gt;(entiers, flottants) et des Ob...">Sortie</a>&amp;<br/>
 Signification: flot de sortie modifie<br/>
 Contraintes: </dd></dl>

<p>Reimplemented from <a class="el" href="classsolv__iteratif.html#a2517bbe1b28b5a45b2e368a09593c62c">solv_iteratif</a>.</p>

<p>Definition at line <a class="el" href="Solv__GCP_8cpp_source.html#l00047">47</a> of file <a class="el" href="Solv__GCP_8cpp_source.html">Solv_GCP.cpp</a>.</p>

<p>References <a class="el" href="Solv__GCP_8h_source.html#l00055">le_precond_</a>, <a class="el" href="SolveurSys__base_8h_source.html#l00056">SolveurSys_base::limpr()</a>, <a class="el" href="Solv__GCP_8h_source.html#l00094">nb_it_max_</a>, <a class="el" href="O__U__Ptr_8cpp_source.html#l00098">O_U_Ptr::non_nul()</a>, <a class="el" href="SolveurSys__base_8h_source.html#l00099">SolveurSys_base::save_matrice_</a>, and <a class="el" href="solv__iteratif_8h_source.html#l00039">solv_iteratif::seuil_</a>.</p>
<div class="fragment"><pre class="fragment">{
  s&lt;&lt;<span class="stringliteral">&quot; { seuil &quot;</span> &lt;&lt; <a class="code" href="classsolv__iteratif.html#a726974e9a0579e0c242606430dc320d4">seuil_</a> ;
  <span class="keywordflow">if</span> (<a class="code" href="classSolv__GCP.html#aa9aa7485970ae948b2561b89e141af13">le_precond_</a>.<a class="code" href="classO__U__Ptr.html#a16f216b2d169e885876419182658ddcc" title="Renvoie 1 si le pointeur est non_nul Renvoie 0 sinon.">non_nul</a>())
    s&lt;&lt;<span class="stringliteral">&quot; precond &quot;</span> &lt;&lt;<a class="code" href="classSolv__GCP.html#aa9aa7485970ae948b2561b89e141af13">le_precond_</a>;
  <span class="keywordflow">else</span>
    s&lt;&lt;<span class="stringliteral">&quot; precond_nul &quot;</span>;
  <span class="keywordflow">if</span> (<a class="code" href="classSolveurSys__base.html#ab3ef68bcf4e1b402c52905aa78728aef">limpr</a>()==1) s&lt;&lt;<span class="stringliteral">&quot; impr &quot;</span>;
  <span class="keywordflow">if</span> (<a class="code" href="classSolveurSys__base.html#ab3ef68bcf4e1b402c52905aa78728aef">limpr</a>()==-1) s&lt;&lt;<span class="stringliteral">&quot; quiet &quot;</span>;
  <span class="keywordflow">if</span> (<a class="code" href="classSolveurSys__base.html#a824322fe6a2c03aa986b8152aefcf14b" title="Drapeau pour savoir si un stockage disque est a refaire.">save_matrice_</a>) s&lt;&lt;<span class="stringliteral">&quot; save_matrice &quot;</span>;
  <span class="keywordflow">if</span> (<a class="code" href="classSolv__GCP.html#a468e7aef13e89875aa96874a3cc3e0f7">nb_it_max_</a>!=-1) s&lt;&lt;<span class="stringliteral">&quot; nb_it_max &quot;</span>&lt;&lt;<a class="code" href="classSolv__GCP.html#a468e7aef13e89875aa96874a3cc3e0f7">nb_it_max_</a>;

  s&lt;&lt;<span class="stringliteral">&quot; } &quot;</span>;
  <span class="keywordflow">return</span> s ;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a03d07e57b46d32e119e23b402d343454"></a><!-- doxytag: member="Solv_GCP::readOn" ref="a03d07e57b46d32e119e23b402d343454" args="(Entree &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEntree.html">Entree</a> &amp; Solv_GCP::readOn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEntree.html">Entree</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Lecture d'un <a class="el" href="classObjet__U.html" title="classe Objet_U Cette classe est la classe de base des Objets de TRUST Dans les classes derivees de Ob...">Objet_U</a> sur un flot d'entree<br/>
Methode a surcharger. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="classEntree.html" title="Classe de definition des operateurs et methodes pour toute lecture dans un flot d&#39;entree (fichier...">Entree</a>&amp; s<br/>
 Signification: flot d'entree modifie<br/>
 Contraintes: </dd></dl>

<p>Reimplemented from <a class="el" href="classsolv__iteratif.html#a1b418fc6914f6125593fe7a78fd6e39c">solv_iteratif</a>.</p>

<p>Definition at line <a class="el" href="Solv__GCP_8cpp_source.html#l00063">63</a> of file <a class="el" href="Solv__GCP_8cpp_source.html">Solv_GCP.cpp</a>.</p>

<p>References <a class="el" href="Param_8cpp_source.html#l00386">Param::ajouter()</a>, <a class="el" href="EntreeSortie_8h_source.html#l00032">Cerr</a>, <a class="el" href="Deriv___8cpp_source.html#l00077">Deriv_::detach()</a>, <a class="el" href="Process_8cpp_source.html#l00223">Process::exit()</a>, <a class="el" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>, <a class="el" href="SolveurSys__base_8h_source.html#l00047">SolveurSys_base::fixer_limpr()</a>, <a class="el" href="Solv__GCP_8h_source.html#l00055">le_precond_</a>, <a class="el" href="Solv__GCP_8h_source.html#l00094">nb_it_max_</a>, <a class="el" href="O__U__Ptr_8cpp_source.html#l00098">O_U_Ptr::non_nul()</a>, <a class="el" href="Solv__GCP_8h_source.html#l00054">optimized_</a>, <a class="el" href="Solv__GCP_8h_source.html#l00064">precond_diag_</a>, <a class="el" href="Param_8h_source.html#l00048">Param::REQUIRED</a>, <a class="el" href="SolveurSys__base_8h_source.html#l00099">SolveurSys_base::save_matrice_</a>, and <a class="el" href="solv__iteratif_8h_source.html#l00039">solv_iteratif::seuil_</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">int</span> precond_nul;
  <span class="keywordtype">int</span> impr,quiet;
  <a class="code" href="classParam.html" title="Defined below in this file.">Param</a> param((*this).que_suis_je());
  param.<a class="code" href="classParam.html#affb8a0102361201ba896bac7ca8bc21c">ajouter</a>(<span class="stringliteral">&quot;seuil&quot;</span>,&amp;<a class="code" href="classsolv__iteratif.html#a726974e9a0579e0c242606430dc320d4">seuil_</a>,<a class="code" href="classParam.html#aa4ad0ca1d49bc5f2ebc5fc83ee9df384aaf5b6dfac1c5970478525407cc6ac572">Param::REQUIRED</a>);
  param.ajouter(<span class="stringliteral">&quot;nb_it_max&quot;</span>,&amp;<a class="code" href="classSolv__GCP.html#a468e7aef13e89875aa96874a3cc3e0f7">nb_it_max_</a>);
  param.ajouter_flag(<span class="stringliteral">&quot;impr&quot;</span>,&amp;impr);
  param.ajouter_flag(<span class="stringliteral">&quot;quiet&quot;</span>,&amp;quiet);
  param.ajouter_flag(<span class="stringliteral">&quot;save_matrice|save_matrix&quot;</span>,&amp;<a class="code" href="classSolveurSys__base.html#a824322fe6a2c03aa986b8152aefcf14b" title="Drapeau pour savoir si un stockage disque est a refaire.">save_matrice_</a>);
  param.ajouter(<span class="stringliteral">&quot;precond&quot;</span>,&amp;<a class="code" href="classSolv__GCP.html#aa9aa7485970ae948b2561b89e141af13">le_precond_</a>);
  param.ajouter_flag(<span class="stringliteral">&quot;precond_nul&quot;</span>,&amp;precond_nul);
  param.ajouter_flag(<span class="stringliteral">&quot;precond_diagonal&quot;</span>, &amp;<a class="code" href="classSolv__GCP.html#aebbaeaa67bf2f876d354938b76e7c36a">precond_diag_</a>);
  param.ajouter_flag(<span class="stringliteral">&quot;optimized&quot;</span>, &amp;<a class="code" href="classSolv__GCP.html#a2de0798151556049240ddceaedcd2010">optimized_</a>);
  param.lire_avec_accolades_depuis(is);
<span class="comment">// Obligation de definir un precond</span>
  <span class="keywordflow">if</span> (!<a class="code" href="classSolv__GCP.html#aa9aa7485970ae948b2561b89e141af13">le_precond_</a>.<a class="code" href="classO__U__Ptr.html#a16f216b2d169e885876419182658ddcc" title="Renvoie 1 si le pointeur est non_nul Renvoie 0 sinon.">non_nul</a>() &amp;&amp; precond_nul==0 &amp;&amp; <a class="code" href="classSolv__GCP.html#aebbaeaa67bf2f876d354938b76e7c36a">precond_diag_</a>==0)
    {
      <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;You forgot to define a preconditionner with the keyword precond.&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
      <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;If you don&#39;t want a preconditionner, add for the solver definition:&quot;</span> &lt;&lt; finl;
      <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;precond_nul&quot;</span> &lt;&lt; finl;
      <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">Process::exit</a>();
    }
  <span class="keywordflow">if</span> (precond_nul)
    {
      <a class="code" href="classSolv__GCP.html#aa9aa7485970ae948b2561b89e141af13">le_precond_</a>.<a class="code" href="classDeriv__.html#a1792f7b005c558e7412661aeee781bd2">detach</a>();
    }
  assert(<a class="code" href="classsolv__iteratif.html#a726974e9a0579e0c242606430dc320d4">seuil_</a>&gt;0);
  <a class="code" href="classSolveurSys__base.html#a987e97740c779c1ab4192c3c1f1bbd5d">fixer_limpr</a>(impr);
  <span class="keywordflow">if</span> (quiet)
    <a class="code" href="classSolveurSys__base.html#a987e97740c779c1ab4192c3c1f1bbd5d">fixer_limpr</a>(-1);
  <span class="keywordflow">return</span> is;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a506c202030f5f801f0ae4779c24ba77b"></a><!-- doxytag: member="Solv_GCP::reinit" ref="a506c202030f5f801f0ae4779c24ba77b" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Solv_GCP::reinit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>&lt; Si reinit_ = 0, ne pas toucher. </p>
</p>

<p>Reimplemented from <a class="el" href="classSolveurSys__base.html#a8737bd7292204c64e4b7bfe4c7bd88ef">SolveurSys_base</a>.</p>

<p>Definition at line <a class="el" href="Solv__GCP_8cpp_source.html#l00115">115</a> of file <a class="el" href="Solv__GCP_8cpp_source.html">Solv_GCP.cpp</a>.</p>

<p>References <a class="el" href="Solv__GCP_8h_source.html#l00055">le_precond_</a>, <a class="el" href="O__U__Ptr_8cpp_source.html#l00098">O_U_Ptr::non_nul()</a>, <a class="el" href="Precond__base_8cpp_source.html#l00047">Precond_base::reinit()</a>, <a class="el" href="Solv__GCP_8h_source.html#l00093">reinit_</a>, and <a class="el" href="Precond_8h_source.html#l00038">Deriv_Precond_base::valeur()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">if</span> (<a class="code" href="classSolv__GCP.html#aba192c7ac366b8c30b0eecd8629af793" title="0=&gt; rien n&#39;est pret 1=&gt; memoire allouee, coeffs matrice a copier, 2=&gt; ok">reinit_</a> &gt; 1) <span class="comment">//!&lt; Si reinit_ = 0, ne pas toucher.</span>
<span class="comment"></span>    <a class="code" href="classSolv__GCP.html#aba192c7ac366b8c30b0eecd8629af793" title="0=&gt; rien n&#39;est pret 1=&gt; memoire allouee, coeffs matrice a copier, 2=&gt; ok">reinit_</a> = 1;
  <a class="code" href="classSolv__GCP.html#a506c202030f5f801f0ae4779c24ba77b">SolveurSys_base::reinit</a>();
  <span class="keywordflow">if</span> (<a class="code" href="classSolv__GCP.html#aa9aa7485970ae948b2561b89e141af13">le_precond_</a>.<a class="code" href="classO__U__Ptr.html#a16f216b2d169e885876419182658ddcc" title="Renvoie 1 si le pointeur est non_nul Renvoie 0 sinon.">non_nul</a>())
    <a class="code" href="classSolv__GCP.html#aa9aa7485970ae948b2561b89e141af13">le_precond_</a>.<a class="code" href="classDeriv__Precond__base.html#a407e470c17d054ca8d60fbc025e6b72b">valeur</a>().<a class="code" href="classPrecond__base.html#ab18d88451a29f28d526041302c811e83" title="this method must be called before preconditionner() whenever the matrix changes (coefficients only or...">reinit</a>();
}
</pre></div>
</div>
</div>
<a class="anchor" id="ab92ff464161604146fb820cdbf2079a1"></a><!-- doxytag: member="Solv_GCP::resoudre_" ref="ab92ff464161604146fb820cdbf2079a1" args="(const Matrice_Base &amp;, const DoubleVect &amp;, DoubleVect &amp;, int)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Solv_GCP::resoudre_ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMatrice__Base.html">Matrice_Base</a> &amp;&#160;</td>
          <td class="paramname"><em>matrice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;&#160;</td>
          <td class="paramname"><em>secmem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;&#160;</td>
          <td class="paramname"><em>solution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nmax</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>&lt; ne pas toucher a l'espace virtuel </p>
</p>

<p>Definition at line <a class="el" href="Solv__GCP_8cpp_source.html#l00404">404</a> of file <a class="el" href="Solv__GCP_8cpp_source.html">Solv_GCP.cpp</a>.</p>

<p>References <a class="el" href="DoubleVect_8cpp_source.html#l01531">ajoute_alpha_v()</a>, <a class="el" href="Solv__GCP_8cpp_source.html#l00378">ajoute_alpha_v_norme()</a>, <a class="el" href="Matrice__SuperMorse_8cpp_source.html#l00032">Matrice_SuperMorse::ajouter_mult_vect_et_prodscal()</a>, <a class="el" href="EntreeSortie_8h_source.html#l00032">Cerr</a>, <a class="el" href="DoubleVect_8cpp_source.html#l00166">DoubleVect::copy()</a>, <a class="el" href="EntreeSortie_8h_source.html#l00033">Cout</a>, <a class="el" href="Double_8h_source.html#l00075">DMINFLOAT</a>, <a class="el" href="DoubleVect_8cpp_source.html#l00277">DoubleVect::echange_espace_virtuel()</a>, <a class="el" href="Process_8cpp_source.html#l00223">Process::exit()</a>, <a class="el" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>, <a class="el" href="Precond__base_8h_source.html#l00052">Precond_base::get_flag_updated_input()</a>, <a class="el" href="SolveurSys__base_8h_source.html#l00091">SolveurSys_base::get_flag_updated_result()</a>, <a class="el" href="DoubleVect_8h_source.html#l00101">DoubleVect::get_md_vector()</a>, <a class="el" href="ArrOfDouble_8cpp_source.html#l01110">ArrOfDouble::inject_array()</a>, <a class="el" href="Solv__GCP_8h_source.html#l00055">le_precond_</a>, <a class="el" href="SolveurSys__base_8h_source.html#l00056">SolveurSys_base::limpr()</a>, <a class="el" href="DoubleVect_8h_source.html#l00164">DoubleVect::line_size()</a>, <a class="el" href="DoubleVect_8cpp_source.html#l00481">local_carre_norme_vect()</a>, <a class="el" href="DoubleVect_8cpp_source.html#l00419">local_prodscal()</a>, <a class="el" href="Double_8h_source.html#l00180">max()</a>, <a class="el" href="DoubleVect_8cpp_source.html#l00537">mp_carre_norme_vect()</a>, <a class="el" href="DoubleVect_8cpp_source.html#l02353">mp_norme_vect()</a>, <a class="el" href="DoubleVect_8cpp_source.html#l02342">mp_prodscal()</a>, <a class="el" href="Process_8cpp_source.html#l00178">Process::mp_sum()</a>, <a class="el" href="communications_8cpp_source.html#l00617">mpsum_multiple()</a>, <a class="el" href="Solv__GCP_8cpp_source.html#l00357">multiply_sub()</a>, <a class="el" href="Matrice__Base_8h_source.html#l00127">Matrice_Base::multvect()</a>, <a class="el" href="Matrice__Base_8h_source.html#l00135">Matrice_Base::multvect_()</a>, <a class="el" href="Matrice__Morse__Sym_8cpp_source.html#l00266">Matrice_Morse_Sym::multvect_et_prodscal()</a>, <a class="el" href="Solv__GCP_8h_source.html#l00094">nb_it_max_</a>, <a class="el" href="classMD__Vector__base.html#a47d5867ac692b62645169eae6e2cafa0">MD_Vector_base::nb_items_seq_tot()</a>, <a class="el" href="Array__base_8h_source.html#l00038">Array_base::NOCOPY_NOINIT</a>, <a class="el" href="O__U__Ptr_8cpp_source.html#l00098">O_U_Ptr::non_nul()</a>, <a class="el" href="Double_8h_source.html#l00159">norme()</a>, <a class="el" href="DoubleVect_8cpp_source.html#l01356">operator_negate()</a>, <a class="el" href="DoubleVect_8cpp_source.html#l01118">operator_sub()</a>, <a class="el" href="Solv__GCP_8h_source.html#l00054">optimized_</a>, <a class="el" href="Precond__base_8cpp_source.html#l00086">Precond_base::preconditionner()</a>, <a class="el" href="Solv__GCP_8cpp_source.html#l00124">prepare_data()</a>, <a class="el" href="DoubleVect_8cpp_source.html#l00133">DoubleVect::ref()</a>, <a class="el" href="DoubleVect_8cpp_source.html#l00111">DoubleVect::reset()</a>, <a class="el" href="Solv__GCP_8h_source.html#l00070">residu_</a>, <a class="el" href="Solv__GCP_8h_source.html#l00069">resu_</a>, <a class="el" href="solv__iteratif_8h_source.html#l00039">solv_iteratif::seuil_</a>, <a class="el" href="DoubleVect_8h_source.html#l00135">DoubleVect::size_reelle()</a>, <a class="el" href="DoubleVect_8h_source.html#l00147">DoubleVect::size_reelle_ok()</a>, <a class="el" href="DoubleVect_8h_source.html#l00159">DoubleVect::size_totale()</a>, <a class="el" href="Solv__GCP_8h_source.html#l00078">tmp_mat_</a>, <a class="el" href="Solv__GCP_8h_source.html#l00080">tmp_mat_virt_</a>, <a class="el" href="Solv__GCP_8h_source.html#l00075">tmp_p_</a>, <a class="el" href="Solv__GCP_8h_source.html#l00066">tmp_p_avec_items_virt_</a>, <a class="el" href="Solv__GCP_8h_source.html#l00076">tmp_solution_</a>, <a class="el" href="Precond_8h_source.html#l00038">Deriv_Precond_base::valeur()</a>, <a class="el" href="MD__Vector_8h_source.html#l00067">MD_Vector::valeur()</a>, and <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_REAL_ITEMS</a>.</p>

<p>Referenced by <a class="el" href="Solv__GCP_8cpp_source.html#l00097">resoudre_systeme()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">const</span> <span class="keywordtype">int</span> n_items_reels = solution.<a class="code" href="classDoubleVect.html#aafef4b3a96cdc428d62c5cedc9af6112">size_reelle_ok</a>() ? solution.<a class="code" href="classDoubleVect.html#a4a6987db458541cdcd10495955f25263" title="Taille de l&#39;espace &quot;reel&quot; du vecteur. (si md_vector_ est nul, cette valeur est identique a size_arr...">size_reelle</a>() : solution.<a class="code" href="classDoubleVect.html#ad2d21b364e1c6559771970596a25c006" title="Identique a size_array()">size_totale</a>();
  {
    <span class="keyword">const</span> <span class="keywordtype">int</span> nb_items_seq = solution.<a class="code" href="classDoubleVect.html#a0d16d30580c90526e4895388fb44be5d">get_md_vector</a>().<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a47d5867ac692b62645169eae6e2cafa0">nb_items_seq_tot</a>();
    <span class="keyword">const</span> <span class="keywordtype">int</span> ls = secmem.<a class="code" href="classDoubleVect.html#ab02d01cd1bdab66fbd66f9a47cc29e10">line_size</a>();
    <span class="keyword">const</span> <span class="keywordtype">int</span> nb_inco_tot = nb_items_seq * ls;
    nmax = <a class="code" href="Double_8h.html#a1c45761573e6cbc97cfacac78d905016">max</a>(nb_inco_tot, nmax);
  }

  <span class="keyword">const</span> <span class="keywordtype">int</span> avec_precond = <a class="code" href="classSolv__GCP.html#aa9aa7485970ae948b2561b89e141af13">le_precond_</a>.<a class="code" href="classO__U__Ptr.html#a16f216b2d169e885876419182658ddcc" title="Renvoie 1 si le pointeur est non_nul Renvoie 0 sinon.">non_nul</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> precond_requires_echange_espace_virtuel =
    avec_precond &amp;&amp; (<a class="code" href="classSolv__GCP.html#aa9aa7485970ae948b2561b89e141af13">le_precond_</a>.<a class="code" href="classDeriv__Precond__base.html#a407e470c17d054ca8d60fbc025e6b72b">valeur</a>().<a class="code" href="classPrecond__base.html#a2f72ac102a2808186830135a6facc84b">get_flag_updated_input</a>());

  <span class="keyword">const</span> <span class="keywordtype">int</span> optimized = <a class="code" href="classSolv__GCP.html#a2de0798151556049240ddceaedcd2010">optimized_</a>;

  <span class="keywordflow">if</span> (optimized)
    {
      <a class="code" href="classSolv__GCP.html#aeb6006a337b824f7702dbd32084580a1">prepare_data</a>(matrice, secmem, solution);
    }
  <span class="keywordflow">else</span>
    {
      <a class="code" href="classSolv__GCP.html#a2dde6b48ed50f795d0df442e25543f24">resu_</a>.<a class="code" href="classDoubleVect.html#a990500e5bf63a8ca55fd833d111e135c" title="met l&#39;objet dans l&#39;etat obtenu par le constructeur par defaut. (voir ArrOfDouble::reset())">reset</a>();
      <a class="code" href="classSolv__GCP.html#a491a6795972aa58d19e222211b70bb73">residu_</a>.<a class="code" href="classDoubleVect.html#a990500e5bf63a8ca55fd833d111e135c" title="met l&#39;objet dans l&#39;etat obtenu par le constructeur par defaut. (voir ArrOfDouble::reset())">reset</a>();
      <a class="code" href="classSolv__GCP.html#af10441b3afc51b4e2a967a2f9c2e813e">tmp_p_avec_items_virt_</a>.<a class="code" href="classDoubleVect.html#a990500e5bf63a8ca55fd833d111e135c" title="met l&#39;objet dans l&#39;etat obtenu par le constructeur par defaut. (voir ArrOfDouble::reset())">reset</a>();
      <a class="code" href="classSolv__GCP.html#a2dde6b48ed50f795d0df442e25543f24">resu_</a>.<a class="code" href="classDoubleVect.html#aaccfc72d49151e3105aba476fa9f414b" title="copie de la structure et des valeurs (si opt==COPY_INIT) du tableau v. Attention, v doit vraiment etr...">copy</a>(solution, <a class="code" href="classArray__base.html#abee342aa9ac59623c4c782dc9d7877ffaf6ae9ba7eb51c5f298ce693345b3ec68">Array_base::NOCOPY_NOINIT</a>);
      <a class="code" href="classSolv__GCP.html#a491a6795972aa58d19e222211b70bb73">residu_</a>.<a class="code" href="classDoubleVect.html#aaccfc72d49151e3105aba476fa9f414b" title="copie de la structure et des valeurs (si opt==COPY_INIT) du tableau v. Attention, v doit vraiment etr...">copy</a>(solution, <a class="code" href="classArray__base.html#abee342aa9ac59623c4c782dc9d7877ffaf6ae9ba7eb51c5f298ce693345b3ec68">Array_base::NOCOPY_NOINIT</a>);
      <a class="code" href="classSolv__GCP.html#af10441b3afc51b4e2a967a2f9c2e813e">tmp_p_avec_items_virt_</a>.<a class="code" href="classDoubleVect.html#aaccfc72d49151e3105aba476fa9f414b" title="copie de la structure et des valeurs (si opt==COPY_INIT) du tableau v. Attention, v doit vraiment etr...">copy</a>(solution, <a class="code" href="classArray__base.html#abee342aa9ac59623c4c782dc9d7877ffaf6ae9ba7eb51c5f298ce693345b3ec68">Array_base::NOCOPY_NOINIT</a>);
      <a class="code" href="classSolv__GCP.html#a73cac6d4f308333325a0430590ebceec">tmp_p_</a>.<a class="code" href="classDoubleVect.html#a2b45ece955d7d57746fa32b5a6a89cc2" title="detache le tableau et l&#39;attache a v (sauf si v==*this, ne fait rien) Fait pointer le tableau sur la m...">ref</a>(<a class="code" href="classSolv__GCP.html#af10441b3afc51b4e2a967a2f9c2e813e">tmp_p_avec_items_virt_</a>);
      <a class="code" href="classSolv__GCP.html#a3ee6d07baa401b83335a06036b8c9d4e">tmp_solution_</a>.<a class="code" href="classDoubleVect.html#a2b45ece955d7d57746fa32b5a6a89cc2" title="detache le tableau et l&#39;attache a v (sauf si v==*this, ne fait rien) Fait pointer le tableau sur la m...">ref</a>(solution);
      <a class="code" href="classSolv__GCP.html#a2dde6b48ed50f795d0df442e25543f24">resu_</a>.<a class="code" href="classArrOfDouble.html#a2fcb2a2d3b59425c6cb37526ea6af6a3" title="Copie les elements source[first_element_source + i] dans les elements (*this)[first_element_dest + i]...">inject_array</a>(secmem);
    }

  <a class="code" href="classSolv__GCP.html#af10441b3afc51b4e2a967a2f9c2e813e">tmp_p_avec_items_virt_</a>.<a class="code" href="classArrOfDouble.html#a2fcb2a2d3b59425c6cb37526ea6af6a3" title="Copie les elements source[first_element_source + i] dans les elements (*this)[first_element_dest + i]...">inject_array</a>(<a class="code" href="classSolv__GCP.html#a3ee6d07baa401b83335a06036b8c9d4e">tmp_solution_</a>, n_items_reels);
  <a class="code" href="classSolv__GCP.html#af10441b3afc51b4e2a967a2f9c2e813e">tmp_p_avec_items_virt_</a>.<a class="code" href="classDoubleVect.html#abfebbc2f685ce7bc4b80c720d7da9bf3">echange_espace_virtuel</a>();
<span class="comment">// On n&#39;a pas besoin que residu ait son espace virtuel a jour</span>
<span class="comment">// En revanche, on a besoin de l&#39;espace virtuel de tmp_p_...</span>
  <span class="keywordflow">if</span> (optimized)
    {
      <a class="code" href="classSolv__GCP.html#af90f523225473263ab3531630a418817">tmp_mat_</a>.<a class="code" href="classMatrice__Base.html#a8e710142a55d65a007a89e0ccc36ed62">multvect_</a>(<a class="code" href="classSolv__GCP.html#af10441b3afc51b4e2a967a2f9c2e813e">tmp_p_avec_items_virt_</a>, <a class="code" href="classSolv__GCP.html#a491a6795972aa58d19e222211b70bb73">residu_</a>);
<span class="comment">// calcul du produit, le produit scalaire n&#39;est pas utilise:</span>
      <a class="code" href="classSolv__GCP.html#ab0dde9b547a7afdbb13329529c24f995">tmp_mat_virt_</a>.<a class="code" href="classMatrice__SuperMorse.html#ad818064b928adc13f9d986d11d4ff35a" title="Calcul de &quot;resu += MATRICE * x&quot; et d&#39;un produit scalaire (c&#39;est une brique de base pour le gradient...">ajouter_mult_vect_et_prodscal</a>(<a class="code" href="classSolv__GCP.html#af10441b3afc51b4e2a967a2f9c2e813e">tmp_p_avec_items_virt_</a>, <a class="code" href="classSolv__GCP.html#a491a6795972aa58d19e222211b70bb73">residu_</a>);
    }
  <span class="keywordflow">else</span>
    {
      matrice.<a class="code" href="classMatrice__Base.html#a05caa487a25a6d5e7fbd38d4b2f4ee1e" title="Multiplication d&#39;un vecteur par la matrice. Operation: r = A*x.">multvect</a>(<a class="code" href="classSolv__GCP.html#af10441b3afc51b4e2a967a2f9c2e813e">tmp_p_avec_items_virt_</a>, <a class="code" href="classSolv__GCP.html#a491a6795972aa58d19e222211b70bb73">residu_</a>);
    }
<span class="comment">// ATTENTION: on suppose que secmem a ete copie dans resu_</span>
  <a class="code" href="DoubleVect_8cpp.html#a813958fe17f5746cc80e1e21d0b10a6a">operator_sub</a>(<a class="code" href="classSolv__GCP.html#a491a6795972aa58d19e222211b70bb73">residu_</a>, <a class="code" href="classSolv__GCP.html#a2dde6b48ed50f795d0df442e25543f24">resu_</a>, <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caab47906d8d2e6c20f8ba32e4acb6edbe0">VECT_REAL_ITEMS</a>); <span class="comment">//!&lt; ne pas toucher a l&#39;espace virtuel</span>
<span class="comment"></span>
  <span class="keywordflow">if</span> (avec_precond)
    {
      <span class="keywordflow">if</span> (precond_requires_echange_espace_virtuel)
        <a class="code" href="classSolv__GCP.html#a491a6795972aa58d19e222211b70bb73">residu_</a>.<a class="code" href="classDoubleVect.html#abfebbc2f685ce7bc4b80c720d7da9bf3">echange_espace_virtuel</a>();

      <span class="keywordflow">if</span> (optimized)
        <a class="code" href="classSolv__GCP.html#aa9aa7485970ae948b2561b89e141af13">le_precond_</a>.<a class="code" href="classDeriv__Precond__base.html#a407e470c17d054ca8d60fbc025e6b72b">valeur</a>().<a class="code" href="classPrecond__base.html#a20061d7ebbe45f61a6e2c65c723b3da3" title="Call to the prepare() method if reinit() has been called previously, then call to preconditionner_()...">preconditionner</a>(<a class="code" href="classSolv__GCP.html#af90f523225473263ab3531630a418817">tmp_mat_</a>, <a class="code" href="classSolv__GCP.html#a491a6795972aa58d19e222211b70bb73">residu_</a>, <a class="code" href="classSolv__GCP.html#a73cac6d4f308333325a0430590ebceec">tmp_p_</a>);
      <span class="keywordflow">else</span>
        <a class="code" href="classSolv__GCP.html#aa9aa7485970ae948b2561b89e141af13">le_precond_</a>.<a class="code" href="classDeriv__Precond__base.html#a407e470c17d054ca8d60fbc025e6b72b">valeur</a>().<a class="code" href="classPrecond__base.html#a20061d7ebbe45f61a6e2c65c723b3da3" title="Call to the prepare() method if reinit() has been called previously, then call to preconditionner_()...">preconditionner</a>(matrice, <a class="code" href="classSolv__GCP.html#a491a6795972aa58d19e222211b70bb73">residu_</a>, <a class="code" href="classSolv__GCP.html#a73cac6d4f308333325a0430590ebceec">tmp_p_</a>);

    }
  <span class="keywordflow">else</span>
    {
      <a class="code" href="classSolv__GCP.html#a73cac6d4f308333325a0430590ebceec">tmp_p_</a>.<a class="code" href="classArrOfDouble.html#a2fcb2a2d3b59425c6cb37526ea6af6a3" title="Copie les elements source[first_element_source + i] dans les elements (*this)[first_element_dest + i]...">inject_array</a>(<a class="code" href="classSolv__GCP.html#a491a6795972aa58d19e222211b70bb73">residu_</a>, n_items_reels);
    }
  <span class="keywordtype">double</span> dold = <a class="code" href="DoubleVect_8cpp.html#a07d13cbdadca6b60d5e128653f52a4bb">mp_prodscal</a>(<a class="code" href="classSolv__GCP.html#a491a6795972aa58d19e222211b70bb73">residu_</a>, <a class="code" href="classSolv__GCP.html#a73cac6d4f308333325a0430590ebceec">tmp_p_</a>);

  <a class="code" href="DoubleVect_8cpp.html#a037eedbd9167441dbd379675d4b2fe55">operator_negate</a>(<a class="code" href="classSolv__GCP.html#a73cac6d4f308333325a0430590ebceec">tmp_p_</a>, <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caab47906d8d2e6c20f8ba32e4acb6edbe0">VECT_REAL_ITEMS</a>);

  <span class="keywordtype">double</span> <a class="code" href="Double_8h.html#ac842198e9490fae75825cab2a03eed2d">norme</a> = <a class="code" href="DoubleVect_8cpp.html#afaa33f0032aa927d8d54ff9fb002b749">mp_norme_vect</a>(<a class="code" href="classSolv__GCP.html#a491a6795972aa58d19e222211b70bb73">residu_</a>);
  <span class="keywordtype">double</span> norme_b = <a class="code" href="DoubleVect_8cpp.html#afaa33f0032aa927d8d54ff9fb002b749">mp_norme_vect</a>(<a class="code" href="classSolv__GCP.html#a2dde6b48ed50f795d0df442e25543f24">resu_</a>);

  <span class="keywordflow">if</span> (<a class="code" href="classSolveurSys__base.html#ab3ef68bcf4e1b402c52905aa78728aef">limpr</a>()==1)
    {
      <span class="keywordtype">double</span> norme_relative=(norme_b&gt;<a class="code" href="Double_8h.html#a0a3fffa6d17ad8f7de4bb337c6266561">DMINFLOAT</a>?norme/(norme_b+<a class="code" href="Double_8h.html#a0a3fffa6d17ad8f7de4bb337c6266561">DMINFLOAT</a>):norme);
      <a class="code" href="EntreeSortie_8h.html#a1007c2f57f1c8fc7334a3f62aab08414">Cout</a> &lt;&lt; <span class="stringliteral">&quot;Norm of the residue: &quot;</span> &lt;&lt; norme &lt;&lt; <span class="stringliteral">&quot; (&quot;</span> &lt;&lt; norme_relative &lt;&lt; <span class="stringliteral">&quot;)&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
    }
  <span class="keywordtype">int</span> niter = 0;
  <span class="keywordtype">int</span> nb_it_max=nmax;
  <span class="keywordflow">if</span> (<a class="code" href="classSolv__GCP.html#a468e7aef13e89875aa96874a3cc3e0f7">nb_it_max_</a>&gt;-1)
    nb_it_max=<a class="code" href="classSolv__GCP.html#a468e7aef13e89875aa96874a3cc3e0f7">nb_it_max_</a>;
  <span class="keywordflow">while</span> ( ( norme &gt; <a class="code" href="classsolv__iteratif.html#a726974e9a0579e0c242606430dc320d4">seuil_</a> ) &amp;&amp; (niter++ &lt; nmax) &amp;&amp;( niter&lt;nb_it_max))
    {
<span class="comment">// Precondition pour multvect</span>
<span class="comment">// (le seul echange espace virtuel de l&#39;algo sauf si le precond en a besoin)</span>
      <a class="code" href="classSolv__GCP.html#af10441b3afc51b4e2a967a2f9c2e813e">tmp_p_avec_items_virt_</a>.<a class="code" href="classDoubleVect.html#abfebbc2f685ce7bc4b80c720d7da9bf3">echange_espace_virtuel</a>();
<span class="comment">// En revanche, on n&#39;a pas besoin de l&#39;espace virtuel a jour de resu:</span>
      <span class="keywordtype">double</span> resu_scalaire_p_local;
      <span class="keywordflow">if</span> (optimized)
        {
          resu_scalaire_p_local = <a class="code" href="classSolv__GCP.html#af90f523225473263ab3531630a418817">tmp_mat_</a>.<a class="code" href="classMatrice__Morse__Sym.html#a32f04eb58027168900262c381afc7c89">multvect_et_prodscal</a>(<a class="code" href="classSolv__GCP.html#af10441b3afc51b4e2a967a2f9c2e813e">tmp_p_avec_items_virt_</a>, <a class="code" href="classSolv__GCP.html#a2dde6b48ed50f795d0df442e25543f24">resu_</a>);
          resu_scalaire_p_local += <a class="code" href="classSolv__GCP.html#ab0dde9b547a7afdbb13329529c24f995">tmp_mat_virt_</a>.<a class="code" href="classMatrice__SuperMorse.html#ad818064b928adc13f9d986d11d4ff35a" title="Calcul de &quot;resu += MATRICE * x&quot; et d&#39;un produit scalaire (c&#39;est une brique de base pour le gradient...">ajouter_mult_vect_et_prodscal</a>(<a class="code" href="classSolv__GCP.html#af10441b3afc51b4e2a967a2f9c2e813e">tmp_p_avec_items_virt_</a>, <a class="code" href="classSolv__GCP.html#a2dde6b48ed50f795d0df442e25543f24">resu_</a>);
        }
      <span class="keywordflow">else</span>
        {
          matrice.<a class="code" href="classMatrice__Base.html#a05caa487a25a6d5e7fbd38d4b2f4ee1e" title="Multiplication d&#39;un vecteur par la matrice. Operation: r = A*x.">multvect</a>(<a class="code" href="classSolv__GCP.html#af10441b3afc51b4e2a967a2f9c2e813e">tmp_p_avec_items_virt_</a>, <a class="code" href="classSolv__GCP.html#a2dde6b48ed50f795d0df442e25543f24">resu_</a>);
          resu_scalaire_p_local = <a class="code" href="DoubleVect_8cpp.html#acbe5711639fbfe2e85d5f87bf81f851a" title="Renvoie la somme des x[i]*y[i] pour les items sequentiels sur ce processeur. (tous les items si pas d...">local_prodscal</a>(<a class="code" href="classSolv__GCP.html#a2dde6b48ed50f795d0df442e25543f24">resu_</a>, <a class="code" href="classSolv__GCP.html#af10441b3afc51b4e2a967a2f9c2e813e">tmp_p_avec_items_virt_</a>);
        }
      <span class="keyword">const</span> <span class="keywordtype">double</span> resu_scalaire_p = <a class="code" href="classProcess.html#a7d23bc1ef94b3f0623fbc79d034c27fd" title="Calcule la somme de x sur tous les processeurs du groupe courant. Voir aussi mp_max()">mp_sum</a>(resu_scalaire_p_local);
      <span class="keyword">const</span> <span class="keywordtype">double</span> alfa = dold / resu_scalaire_p;
      <a class="code" href="DoubleVect_8cpp.html#a3cf7911dc14efcacd03f9915978b2b88">ajoute_alpha_v</a>(<a class="code" href="classSolv__GCP.html#a3ee6d07baa401b83335a06036b8c9d4e">tmp_solution_</a>, alfa, <a class="code" href="classSolv__GCP.html#a73cac6d4f308333325a0430590ebceec">tmp_p_</a>, <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caab47906d8d2e6c20f8ba32e4acb6edbe0">VECT_REAL_ITEMS</a>);

      <span class="keywordtype">double</span> norme_residu_locale;
      <span class="keywordflow">if</span> (optimized)
        {
          norme_residu_locale = <a class="code" href="Solv__GCP_8cpp.html#a39937d853c6c6660fb5193a686ace132">ajoute_alpha_v_norme</a>(<a class="code" href="classSolv__GCP.html#a491a6795972aa58d19e222211b70bb73">residu_</a>, alfa, <a class="code" href="classSolv__GCP.html#a2dde6b48ed50f795d0df442e25543f24">resu_</a>);
        }
      <span class="keywordflow">else</span>
        {
          <a class="code" href="DoubleVect_8cpp.html#a3cf7911dc14efcacd03f9915978b2b88">ajoute_alpha_v</a>(<a class="code" href="classSolv__GCP.html#a491a6795972aa58d19e222211b70bb73">residu_</a>, alfa, <a class="code" href="classSolv__GCP.html#a2dde6b48ed50f795d0df442e25543f24">resu_</a>);
          norme_residu_locale = <a class="code" href="DoubleVect_8cpp.html#aec1f3fbee9c49f94ac517feea6a8d6ed">local_carre_norme_vect</a>(<a class="code" href="classSolv__GCP.html#a491a6795972aa58d19e222211b70bb73">residu_</a>);
        }

      <span class="keywordflow">if</span>(avec_precond)
        {
          <span class="keywordflow">if</span> (precond_requires_echange_espace_virtuel)
            <a class="code" href="classSolv__GCP.html#a491a6795972aa58d19e222211b70bb73">residu_</a>.<a class="code" href="classDoubleVect.html#abfebbc2f685ce7bc4b80c720d7da9bf3">echange_espace_virtuel</a>();
          <span class="keywordflow">if</span> (optimized)
            <a class="code" href="classSolv__GCP.html#aa9aa7485970ae948b2561b89e141af13">le_precond_</a>.<a class="code" href="classDeriv__Precond__base.html#a407e470c17d054ca8d60fbc025e6b72b">valeur</a>().<a class="code" href="classPrecond__base.html#a20061d7ebbe45f61a6e2c65c723b3da3" title="Call to the prepare() method if reinit() has been called previously, then call to preconditionner_()...">preconditionner</a>(<a class="code" href="classSolv__GCP.html#af90f523225473263ab3531630a418817">tmp_mat_</a>, <a class="code" href="classSolv__GCP.html#a491a6795972aa58d19e222211b70bb73">residu_</a>, <a class="code" href="classSolv__GCP.html#a2dde6b48ed50f795d0df442e25543f24">resu_</a>);
          <span class="keywordflow">else</span>
            <a class="code" href="classSolv__GCP.html#aa9aa7485970ae948b2561b89e141af13">le_precond_</a>.<a class="code" href="classDeriv__Precond__base.html#a407e470c17d054ca8d60fbc025e6b72b">valeur</a>().<a class="code" href="classPrecond__base.html#a20061d7ebbe45f61a6e2c65c723b3da3" title="Call to the prepare() method if reinit() has been called previously, then call to preconditionner_()...">preconditionner</a>(matrice, <a class="code" href="classSolv__GCP.html#a491a6795972aa58d19e222211b70bb73">residu_</a>, <a class="code" href="classSolv__GCP.html#a2dde6b48ed50f795d0df442e25543f24">resu_</a>);

          <span class="keywordtype">double</span> residu_scalaire_resu = <a class="code" href="DoubleVect_8cpp.html#acbe5711639fbfe2e85d5f87bf81f851a" title="Renvoie la somme des x[i]*y[i] pour les items sequentiels sur ce processeur. (tous les items si pas d...">local_prodscal</a>(<a class="code" href="classSolv__GCP.html#a491a6795972aa58d19e222211b70bb73">residu_</a>, <a class="code" href="classSolv__GCP.html#a2dde6b48ed50f795d0df442e25543f24">resu_</a>);
          norme = norme_residu_locale;
<span class="comment">// optimisation: on calcule en une seule fois les deux sommes</span>
          <a class="code" href="communications_8cpp.html#af63556e6cd8ba837d64821d5e66a090e">mpsum_multiple</a>(residu_scalaire_resu, norme);
          assert(residu_scalaire_resu &gt;= 0);
          <a class="code" href="Solv__GCP_8cpp.html#ab5770466cce112d525bb5d526fec71cd">multiply_sub</a>(<a class="code" href="classSolv__GCP.html#a73cac6d4f308333325a0430590ebceec">tmp_p_</a>, <a class="code" href="classSolv__GCP.html#a2dde6b48ed50f795d0df442e25543f24">resu_</a>, residu_scalaire_resu / dold);
          dold = residu_scalaire_resu;
        }
      <span class="keywordflow">else</span>
        {
          <span class="keyword">const</span> <span class="keywordtype">double</span> dnew = <a class="code" href="DoubleVect_8cpp.html#aab5110c88e5f7519eb6b7e603130b702">mp_carre_norme_vect</a>(<a class="code" href="classSolv__GCP.html#a491a6795972aa58d19e222211b70bb73">residu_</a>);
          norme = <a class="code" href="classProcess.html#a7d23bc1ef94b3f0623fbc79d034c27fd" title="Calcule la somme de x sur tous les processeurs du groupe courant. Voir aussi mp_max()">mp_sum</a>(norme_residu_locale);
          assert(dnew &gt;= 0);
          <a class="code" href="Solv__GCP_8cpp.html#ab5770466cce112d525bb5d526fec71cd">multiply_sub</a>(<a class="code" href="classSolv__GCP.html#a73cac6d4f308333325a0430590ebceec">tmp_p_</a>, <a class="code" href="classSolv__GCP.html#a491a6795972aa58d19e222211b70bb73">residu_</a>, dnew / dold);
          dold = dnew;
        }
      norme = sqrt(norme);

      <span class="keywordflow">if</span> (<a class="code" href="classSolveurSys__base.html#ab3ef68bcf4e1b402c52905aa78728aef">limpr</a>()==1)
        {
          <a class="code" href="EntreeSortie_8h.html#a1007c2f57f1c8fc7334a3f62aab08414">Cout</a> &lt;&lt; norme &lt;&lt; <span class="stringliteral">&quot; &quot;</span>;
          <span class="keywordflow">if</span> ((niter % 15) == 0) <a class="code" href="EntreeSortie_8h.html#a1007c2f57f1c8fc7334a3f62aab08414">Cout</a> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a> ;
        }
    }
  <span class="keywordflow">if</span> ((<a class="code" href="classSolv__GCP.html#a468e7aef13e89875aa96874a3cc3e0f7">nb_it_max_</a>&lt;0)&amp;&amp; (norme &gt; <a class="code" href="classsolv__iteratif.html#a726974e9a0579e0c242606430dc320d4">seuil_</a>))
    {
      <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;No convergence after : &quot;</span> &lt;&lt; niter &lt;&lt; <span class="stringliteral">&quot; iterations\n&quot;</span>;
      <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot; Residue : &quot;</span>&lt;&lt; norme &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;
      <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot; threshold : &quot;</span>&lt;&lt; <a class="code" href="classsolv__iteratif.html#a726974e9a0579e0c242606430dc320d4">seuil_</a> &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;
      <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Change your data set.&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
      <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">exit</a>();
    }

  <span class="keywordflow">if</span> (optimized)
    solution.<a class="code" href="classArrOfDouble.html#a2fcb2a2d3b59425c6cb37526ea6af6a3" title="Copie les elements source[first_element_source + i] dans les elements (*this)[first_element_dest + i]...">inject_array</a>(<a class="code" href="classSolv__GCP.html#a3ee6d07baa401b83335a06036b8c9d4e">tmp_solution_</a>, n_items_reels);

<span class="comment">// The user wants a result with updated virtual space:</span>
  <span class="keywordflow">if</span> (<a class="code" href="classSolveurSys__base.html#a338dcdf8a39dba544729c2ffd96ae37f">get_flag_updated_result</a>())
    solution.<a class="code" href="classDoubleVect.html#abfebbc2f685ce7bc4b80c720d7da9bf3">echange_espace_virtuel</a>();

<span class="comment">// On affiche quand meme le nombre d&#39;iterations</span>
  <span class="keywordflow">if</span> (<a class="code" href="classSolveurSys__base.html#ab3ef68bcf4e1b402c52905aa78728aef">limpr</a>()&gt;-1)
    {
      <span class="keywordtype">double</span> norme_relative=(norme_b&gt;0?norme/(norme_b+<a class="code" href="Double_8h.html#a0a3fffa6d17ad8f7de4bb337c6266561">DMINFLOAT</a>):norme);
      <a class="code" href="EntreeSortie_8h.html#a1007c2f57f1c8fc7334a3f62aab08414">Cout</a> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
      <a class="code" href="EntreeSortie_8h.html#a1007c2f57f1c8fc7334a3f62aab08414">Cout</a> &lt;&lt; <span class="stringliteral">&quot;Final residue: &quot;</span> &lt;&lt; norme &lt;&lt; <span class="stringliteral">&quot; ( &quot;</span> &lt;&lt; norme_relative &lt;&lt; <span class="stringliteral">&quot; )&quot;</span>&lt;&lt;finl;
    }
  <span class="keywordflow">return</span>(niter);

}
</pre></div>
</div>
</div>
<a class="anchor" id="a2938854d2ea72586ef3e959412f31e14"></a><!-- doxytag: member="Solv_GCP::resoudre_systeme" ref="a2938854d2ea72586ef3e959412f31e14" args="(const Matrice_Base &amp;, const DoubleVect &amp;, DoubleVect &amp;, int)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Solv_GCP::resoudre_systeme </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMatrice__Base.html">Matrice_Base</a> &amp;&#160;</td>
          <td class="paramname"><em>matrice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;&#160;</td>
          <td class="paramname"><em>secmem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;&#160;</td>
          <td class="paramname"><em>solution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nmax</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="classSolveurSys__base.html#a8c42bf5160d595afada02074ccc7f91e">SolveurSys_base</a>.</p>

<p>Definition at line <a class="el" href="Solv__GCP_8cpp_source.html#l00105">105</a> of file <a class="el" href="Solv__GCP_8cpp_source.html">Solv_GCP.cpp</a>.</p>

<p>References <a class="el" href="Solv__GCP_8cpp_source.html#l00404">resoudre_()</a>.</p>
<div class="fragment"><pre class="fragment">{


  <span class="keywordtype">int</span> n = <a class="code" href="classSolv__GCP.html#ab92ff464161604146fb820cdbf2079a1">resoudre_</a>(matrice, secmem, solution, nmax);
  <span class="keywordflow">return</span> n;
}
</pre></div>
</div>
</div>
<a class="anchor" id="ac32faafc19ecfacd8d0e4dc749eb3e64"></a><!-- doxytag: member="Solv_GCP::resoudre_systeme" ref="ac32faafc19ecfacd8d0e4dc749eb3e64" args="(const Matrice_Base &amp;, const DoubleVect &amp;, DoubleVect &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Solv_GCP::resoudre_systeme </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMatrice__Base.html">Matrice_Base</a> &amp;&#160;</td>
          <td class="paramname"><em>matrice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;&#160;</td>
          <td class="paramname"><em>secmem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;&#160;</td>
          <td class="paramname"><em>solution</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implements <a class="el" href="classSolveurSys__base.html#a7c520c3aa574c8be3d3f27d4f700eac2">SolveurSys_base</a>.</p>

<p>Definition at line <a class="el" href="Solv__GCP_8cpp_source.html#l00097">97</a> of file <a class="el" href="Solv__GCP_8cpp_source.html">Solv_GCP.cpp</a>.</p>

<p>References <a class="el" href="Solv__GCP_8cpp_source.html#l00404">resoudre_()</a>.</p>
<div class="fragment"><pre class="fragment">{


  <span class="keywordtype">int</span> n = <a class="code" href="classSolv__GCP.html#ab92ff464161604146fb820cdbf2079a1">resoudre_</a>(matrice, secmem, solution, 100);
  <span class="keywordflow">return</span> n;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a59dc2a1e6216ddeadc71ecd50e273e79"></a><!-- doxytag: member="Solv_GCP::self_cast" ref="a59dc2a1e6216ddeadc71ecd50e273e79" args="(Objet_U &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSolv__GCP.html">Solv_GCP</a> &amp; Solv_GCP::self_cast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classObjet__U.html">Objet_U</a> &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="classsolv__iteratif.html#aaa160adcbe0dde06be4953f51c2deedc">solv_iteratif</a>.</p>

<p>Definition at line <a class="el" href="Solv__GCP_8cpp_source.html#l00034">34</a> of file <a class="el" href="Solv__GCP_8cpp_source.html">Solv_GCP.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7d98dbc130536e4375af1e6f9b78541d"></a><!-- doxytag: member="Solv_GCP::self_cast" ref="a7d98dbc130536e4375af1e6f9b78541d" args="(const Objet_U &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSolv__GCP.html">Solv_GCP</a> &amp; Solv_GCP::self_cast </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classObjet__U.html">Objet_U</a> &amp;&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>methode ajoutee pour caster en python </p>

<p>Reimplemented from <a class="el" href="classsolv__iteratif.html#afdc53703414cbb5c9d75fd92d2c952bd">solv_iteratif</a>.</p>

<p>Definition at line <a class="el" href="Solv__GCP_8cpp_source.html#l00034">34</a> of file <a class="el" href="Solv__GCP_8cpp_source.html">Solv_GCP.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1913e3bdca62b3e5c773000ce7f40283"></a><!-- doxytag: member="Solv_GCP::set_precond" ref="a1913e3bdca62b3e5c773000ce7f40283" args="(const Precond &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Solv_GCP::set_precond </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPrecond.html">Precond</a> &amp;&#160;</td>
          <td class="paramname"><em>pre</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Solv__GCP_8h_source.html#l00097">97</a> of file <a class="el" href="Solv__GCP_8h_source.html">Solv_GCP.h</a>.</p>

<p>References <a class="el" href="Solv__GCP_8h_source.html#l00055">le_precond_</a>.</p>
<div class="fragment"><pre class="fragment">{
  <a class="code" href="classSolv__GCP.html#aa9aa7485970ae948b2561b89e141af13">le_precond_</a> = pre;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a7c678ee1e78c2bd116df7a415537b715"></a><!-- doxytag: member="Solv_GCP::supporte_matrice_morse_sym" ref="a7c678ee1e78c2bd116df7a415537b715" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Solv_GCP::supporte_matrice_morse_sym </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="classSolveurSys__base.html#a0040749ba12cc2db61a39519fa519996">SolveurSys_base</a>.</p>

<p>Definition at line <a class="el" href="Solv__GCP_8h_source.html#l00041">41</a> of file <a class="el" href="Solv__GCP_8h_source.html">Solv_GCP.h</a>.</p>

<p>References <a class="el" href="Solv__GCP_8h_source.html#l00055">le_precond_</a>, <a class="el" href="O__U__Ptr_8cpp_source.html#l00098">O_U_Ptr::non_nul()</a>, and <a class="el" href="Precond_8h_source.html#l00047">Precond::supporte_matrice_morse_sym()</a>.</p>
<div class="fragment"><pre class="fragment">  {
    <span class="keywordflow">return</span> !<a class="code" href="classSolv__GCP.html#aa9aa7485970ae948b2561b89e141af13">le_precond_</a>.<a class="code" href="classO__U__Ptr.html#a16f216b2d169e885876419182658ddcc" title="Renvoie 1 si le pointeur est non_nul Renvoie 0 sinon.">non_nul</a>() || <a class="code" href="classSolv__GCP.html#aa9aa7485970ae948b2561b89e141af13">le_precond_</a>.<a class="code" href="classPrecond.html#a6f89b5a9fedaec153590f50529b4233a">supporte_matrice_morse_sym</a>();
  };
</pre></div>
</div>
</div>
<a class="anchor" id="a51de77dd797bd0aa731d6b25d545b2ed"></a><!-- doxytag: member="Solv_GCP::taille_memoire" ref="a51de77dd797bd0aa731d6b25d545b2ed" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned Solv_GCP::taille_memoire </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implements <a class="el" href="classObjet__U.html#a0ee0946339f09a2c73c09fcda71c3be2">Objet_U</a>.</p>

<p>Definition at line <a class="el" href="Solv__GCP_8cpp_source.html#l00034">34</a> of file <a class="el" href="Solv__GCP_8cpp_source.html">Solv_GCP.cpp</a>.</p>

</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="a97ebbc2b0ec642843942268dd6fd3dd2"></a><!-- doxytag: member="Solv_GCP::info_obj" ref="a97ebbc2b0ec642843942268dd6fd3dd2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classType__info.html">Type_info</a> <a class="el" href="classSolv__GCP.html#a97ebbc2b0ec642843942268dd6fd3dd2">Solv_GCP::info_obj</a><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="classsolv__iteratif.html#ac37ee462399cc229a4c2b4921a31d56c">solv_iteratif</a>.</p>

<p>Definition at line <a class="el" href="Solv__GCP_8h_source.html#l00033">33</a> of file <a class="el" href="Solv__GCP_8h_source.html">Solv_GCP.h</a>.</p>

</div>
</div>
<a class="anchor" id="aa29ed43f42e31d43acdceb9cecc084dd"></a><!-- doxytag: member="Solv_GCP::inv_sqrt_diag_" ref="aa29ed43f42e31d43acdceb9cecc084dd" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDoubleVect.html">DoubleVect</a> <a class="el" href="classSolv__GCP.html#aa29ed43f42e31d43acdceb9cecc084dd">Solv_GCP::inv_sqrt_diag_</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Solv__GCP_8h_source.html#l00092">92</a> of file <a class="el" href="Solv__GCP_8h_source.html">Solv_GCP.h</a>.</p>

</div>
</div>
<a class="anchor" id="aa9aa7485970ae948b2561b89e141af13"></a><!-- doxytag: member="Solv_GCP::le_precond_" ref="aa9aa7485970ae948b2561b89e141af13" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPrecond.html">Precond</a> <a class="el" href="classSolv__GCP.html#aa9aa7485970ae948b2561b89e141af13">Solv_GCP::le_precond_</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Solv__GCP_8h_source.html#l00055">55</a> of file <a class="el" href="Solv__GCP_8h_source.html">Solv_GCP.h</a>.</p>

<p>Referenced by <a class="el" href="Solv__GCP_8h_source.html#l00102">get_precond()</a>, <a class="el" href="Solv__GCP_8cpp_source.html#l00047">printOn()</a>, <a class="el" href="Solv__GCP_8cpp_source.html#l00063">readOn()</a>, <a class="el" href="Solv__GCP_8cpp_source.html#l00115">reinit()</a>, <a class="el" href="Solv__GCP_8cpp_source.html#l00404">resoudre_()</a>, <a class="el" href="Solv__GCP_8h_source.html#l00097">set_precond()</a>, and <a class="el" href="Solv__GCP_8h_source.html#l00041">supporte_matrice_morse_sym()</a>.</p>

</div>
</div>
<a class="anchor" id="a468e7aef13e89875aa96874a3cc3e0f7"></a><!-- doxytag: member="Solv_GCP::nb_it_max_" ref="a468e7aef13e89875aa96874a3cc3e0f7" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classSolv__GCP.html#a468e7aef13e89875aa96874a3cc3e0f7">Solv_GCP::nb_it_max_</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Solv__GCP_8h_source.html#l00094">94</a> of file <a class="el" href="Solv__GCP_8h_source.html">Solv_GCP.h</a>.</p>

<p>Referenced by <a class="el" href="Solv__GCP_8cpp_source.html#l00047">printOn()</a>, <a class="el" href="Solv__GCP_8cpp_source.html#l00063">readOn()</a>, <a class="el" href="Solv__GCP_8cpp_source.html#l00404">resoudre_()</a>, and <a class="el" href="Solv__GCP_8cpp_source.html#l00038">Solv_GCP()</a>.</p>

</div>
</div>
<a class="anchor" id="a2de0798151556049240ddceaedcd2010"></a><!-- doxytag: member="Solv_GCP::optimized_" ref="a2de0798151556049240ddceaedcd2010" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classSolv__GCP.html#a2de0798151556049240ddceaedcd2010">Solv_GCP::optimized_</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Solv__GCP_8h_source.html#l00054">54</a> of file <a class="el" href="Solv__GCP_8h_source.html">Solv_GCP.h</a>.</p>

<p>Referenced by <a class="el" href="Solv__GCP_8cpp_source.html#l00063">readOn()</a>, <a class="el" href="Solv__GCP_8cpp_source.html#l00404">resoudre_()</a>, and <a class="el" href="Solv__GCP_8cpp_source.html#l00038">Solv_GCP()</a>.</p>

</div>
</div>
<a class="anchor" id="aebbaeaa67bf2f876d354938b76e7c36a"></a><!-- doxytag: member="Solv_GCP::precond_diag_" ref="aebbaeaa67bf2f876d354938b76e7c36a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classSolv__GCP.html#aebbaeaa67bf2f876d354938b76e7c36a">Solv_GCP::precond_diag_</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Solv__GCP_8h_source.html#l00064">64</a> of file <a class="el" href="Solv__GCP_8h_source.html">Solv_GCP.h</a>.</p>

<p>Referenced by <a class="el" href="Solv__GCP_8cpp_source.html#l00124">prepare_data()</a>, <a class="el" href="Solv__GCP_8cpp_source.html#l00063">readOn()</a>, and <a class="el" href="Solv__GCP_8cpp_source.html#l00038">Solv_GCP()</a>.</p>

</div>
</div>
<a class="anchor" id="aba192c7ac366b8c30b0eecd8629af793"></a><!-- doxytag: member="Solv_GCP::reinit_" ref="aba192c7ac366b8c30b0eecd8629af793" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classSolv__GCP.html#aba192c7ac366b8c30b0eecd8629af793">Solv_GCP::reinit_</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>0=&gt; rien n'est pret 1=&gt; memoire allouee, coeffs matrice a copier, 2=&gt; ok </p>

<p>Definition at line <a class="el" href="Solv__GCP_8h_source.html#l00093">93</a> of file <a class="el" href="Solv__GCP_8h_source.html">Solv_GCP.h</a>.</p>

<p>Referenced by <a class="el" href="Solv__GCP_8cpp_source.html#l00124">prepare_data()</a>, <a class="el" href="Solv__GCP_8cpp_source.html#l00115">reinit()</a>, and <a class="el" href="Solv__GCP_8cpp_source.html#l00038">Solv_GCP()</a>.</p>

</div>
</div>
<a class="anchor" id="ab61b9443523fdea985d32989eee85ee7"></a><!-- doxytag: member="Solv_GCP::renum_" ref="ab61b9443523fdea985d32989eee85ee7" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIntVect.html">IntVect</a> <a class="el" href="classSolv__GCP.html#ab61b9443523fdea985d32989eee85ee7">Solv_GCP::renum_</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Solv__GCP_8h_source.html#l00087">87</a> of file <a class="el" href="Solv__GCP_8h_source.html">Solv_GCP.h</a>.</p>

<p>Referenced by <a class="el" href="Solv__GCP_8cpp_source.html#l00124">prepare_data()</a>.</p>

</div>
</div>
<a class="anchor" id="a491a6795972aa58d19e222211b70bb73"></a><!-- doxytag: member="Solv_GCP::residu_" ref="a491a6795972aa58d19e222211b70bb73" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDoubleVect.html">DoubleVect</a> <a class="el" href="classSolv__GCP.html#a491a6795972aa58d19e222211b70bb73">Solv_GCP::residu_</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Solv__GCP_8h_source.html#l00070">70</a> of file <a class="el" href="Solv__GCP_8h_source.html">Solv_GCP.h</a>.</p>

<p>Referenced by <a class="el" href="Solv__GCP_8cpp_source.html#l00124">prepare_data()</a>, and <a class="el" href="Solv__GCP_8cpp_source.html#l00404">resoudre_()</a>.</p>

</div>
</div>
<a class="anchor" id="a2dde6b48ed50f795d0df442e25543f24"></a><!-- doxytag: member="Solv_GCP::resu_" ref="a2dde6b48ed50f795d0df442e25543f24" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDoubleVect.html">DoubleVect</a> <a class="el" href="classSolv__GCP.html#a2dde6b48ed50f795d0df442e25543f24">Solv_GCP::resu_</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Solv__GCP_8h_source.html#l00069">69</a> of file <a class="el" href="Solv__GCP_8h_source.html">Solv_GCP.h</a>.</p>

<p>Referenced by <a class="el" href="Solv__GCP_8cpp_source.html#l00124">prepare_data()</a>, and <a class="el" href="Solv__GCP_8cpp_source.html#l00404">resoudre_()</a>.</p>

</div>
</div>
<a class="anchor" id="a63001a11b5ed3214789975e7633eac92"></a><!-- doxytag: member="Solv_GCP::tmp_data_block_" ref="a63001a11b5ed3214789975e7633eac92" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classArrOfDouble.html">ArrOfDouble</a> <a class="el" href="classSolv__GCP.html#a63001a11b5ed3214789975e7633eac92">Solv_GCP::tmp_data_block_</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Solv__GCP_8h_source.html#l00084">84</a> of file <a class="el" href="Solv__GCP_8h_source.html">Solv_GCP.h</a>.</p>

<p>Referenced by <a class="el" href="Solv__GCP_8cpp_source.html#l00124">prepare_data()</a>.</p>

</div>
</div>
<a class="anchor" id="af90f523225473263ab3531630a418817"></a><!-- doxytag: member="Solv_GCP::tmp_mat_" ref="af90f523225473263ab3531630a418817" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMatrice__Morse__Sym.html">Matrice_Morse_Sym</a> <a class="el" href="classSolv__GCP.html#af90f523225473263ab3531630a418817">Solv_GCP::tmp_mat_</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Solv__GCP_8h_source.html#l00078">78</a> of file <a class="el" href="Solv__GCP_8h_source.html">Solv_GCP.h</a>.</p>

<p>Referenced by <a class="el" href="Solv__GCP_8cpp_source.html#l00124">prepare_data()</a>, and <a class="el" href="Solv__GCP_8cpp_source.html#l00404">resoudre_()</a>.</p>

</div>
</div>
<a class="anchor" id="ab0dde9b547a7afdbb13329529c24f995"></a><!-- doxytag: member="Solv_GCP::tmp_mat_virt_" ref="ab0dde9b547a7afdbb13329529c24f995" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMatrice__SuperMorse.html">Matrice_SuperMorse</a> <a class="el" href="classSolv__GCP.html#ab0dde9b547a7afdbb13329529c24f995">Solv_GCP::tmp_mat_virt_</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Solv__GCP_8h_source.html#l00080">80</a> of file <a class="el" href="Solv__GCP_8h_source.html">Solv_GCP.h</a>.</p>

<p>Referenced by <a class="el" href="Solv__GCP_8cpp_source.html#l00124">prepare_data()</a>, and <a class="el" href="Solv__GCP_8cpp_source.html#l00404">resoudre_()</a>.</p>

</div>
</div>
<a class="anchor" id="a73cac6d4f308333325a0430590ebceec"></a><!-- doxytag: member="Solv_GCP::tmp_p_" ref="a73cac6d4f308333325a0430590ebceec" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDoubleVect.html">DoubleVect</a> <a class="el" href="classSolv__GCP.html#a73cac6d4f308333325a0430590ebceec">Solv_GCP::tmp_p_</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Solv__GCP_8h_source.html#l00075">75</a> of file <a class="el" href="Solv__GCP_8h_source.html">Solv_GCP.h</a>.</p>

<p>Referenced by <a class="el" href="Solv__GCP_8cpp_source.html#l00124">prepare_data()</a>, and <a class="el" href="Solv__GCP_8cpp_source.html#l00404">resoudre_()</a>.</p>

</div>
</div>
<a class="anchor" id="af10441b3afc51b4e2a967a2f9c2e813e"></a><!-- doxytag: member="Solv_GCP::tmp_p_avec_items_virt_" ref="af10441b3afc51b4e2a967a2f9c2e813e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDoubleVect.html">DoubleVect</a> <a class="el" href="classSolv__GCP.html#af10441b3afc51b4e2a967a2f9c2e813e">Solv_GCP::tmp_p_avec_items_virt_</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Solv__GCP_8h_source.html#l00066">66</a> of file <a class="el" href="Solv__GCP_8h_source.html">Solv_GCP.h</a>.</p>

<p>Referenced by <a class="el" href="Solv__GCP_8cpp_source.html#l00124">prepare_data()</a>, and <a class="el" href="Solv__GCP_8cpp_source.html#l00404">resoudre_()</a>.</p>

</div>
</div>
<a class="anchor" id="a3ee6d07baa401b83335a06036b8c9d4e"></a><!-- doxytag: member="Solv_GCP::tmp_solution_" ref="a3ee6d07baa401b83335a06036b8c9d4e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDoubleVect.html">DoubleVect</a> <a class="el" href="classSolv__GCP.html#a3ee6d07baa401b83335a06036b8c9d4e">Solv_GCP::tmp_solution_</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Solv__GCP_8h_source.html#l00076">76</a> of file <a class="el" href="Solv__GCP_8h_source.html">Solv_GCP.h</a>.</p>

<p>Referenced by <a class="el" href="Solv__GCP_8cpp_source.html#l00124">prepare_data()</a>, and <a class="el" href="Solv__GCP_8cpp_source.html#l00404">resoudre_()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/Kernel/Math/SolvSys/<a class="el" href="Solv__GCP_8h_source.html">Solv_GCP.h</a></li>
<li>src/Kernel/Math/SolvSys/<a class="el" href="Solv__GCP_8cpp_source.html">Solv_GCP.cpp</a></li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Tue Dec 14 2021 19:37:51 for TRUST by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
