<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>TRUST: src/Kernel/Geometrie/Connex_components.cpp Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">TRUST&#160;<span id="projectnumber">1.8.4</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
<div class="header">
  <div class="headertitle">
<div class="title">src/Kernel/Geometrie/Connex_components.cpp</div>  </div>
</div>
<div class="contents">
<a href="Connex__components_8cpp.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/****************************************************************************</span>
<a name="l00002"></a>00002 <span class="comment">* Copyright (c) 2015 - 2016, CEA</span>
<a name="l00003"></a>00003 <span class="comment">* All rights reserved.</span>
<a name="l00004"></a>00004 <span class="comment">*</span>
<a name="l00005"></a>00005 <span class="comment">* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</span>
<a name="l00006"></a>00006 <span class="comment">* 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.</span>
<a name="l00007"></a>00007 <span class="comment">* 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.</span>
<a name="l00008"></a>00008 <span class="comment">* 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.</span>
<a name="l00009"></a>00009 <span class="comment">*</span>
<a name="l00010"></a>00010 <span class="comment">* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.</span>
<a name="l00011"></a>00011 <span class="comment">* IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;</span>
<a name="l00012"></a>00012 <span class="comment">* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>
<a name="l00013"></a>00013 <span class="comment">*</span>
<a name="l00014"></a>00014 <span class="comment">*****************************************************************************/</span>
<a name="l00015"></a>00015 <span class="comment">//</span>
<a name="l00016"></a>00016 <span class="comment">// </span>
<a name="l00017"></a>00017 <span class="comment">// File:        Connex_components.cpp</span>
<a name="l00018"></a>00018 <span class="comment">// Directory:   $TRUST_ROOT/src/Kernel/Geometrie</span>
<a name="l00019"></a>00019 <span class="comment">// Version:     /main/7</span>
<a name="l00020"></a>00020 <span class="comment">// </span>
<a name="l00021"></a>00021 <span class="comment">//</span>
<a name="l00022"></a>00022 <span class="preprocessor">#include &lt;<a class="code" href="Connex__components_8h.html">Connex_components.h</a>&gt;</span>
<a name="l00023"></a>00023 <span class="preprocessor">#include &lt;<a class="code" href="IntTab_8h.html">IntTab.h</a>&gt;</span>
<a name="l00024"></a>00024 <span class="preprocessor">#include &lt;<a class="code" href="communications_8h.html">communications.h</a>&gt;</span>
<a name="l00025"></a>00025 <span class="preprocessor">#include &lt;<a class="code" href="ArrOfBit_8h.html">ArrOfBit.h</a>&gt;</span>
<a name="l00026"></a>00026 
<a name="l00027"></a>00027 <span class="comment">//</span>
<a name="l00028"></a>00028 <span class="comment">//</span>
<a name="l00029"></a>00029 <span class="comment">//</span>
<a name="l00030"></a>00030 <span class="comment">//</span>
<a name="l00031"></a>00031 <span class="comment">//</span>
<a name="l00032"></a>00032 <span class="comment">//</span>
<a name="l00033"></a>00033 <span class="comment">//</span>
<a name="l00034"></a>00034 <span class="comment">//</span>
<a name="l00035"></a>00035 <span class="comment">//</span>
<a name="l00036"></a>00036 <span class="comment">//</span>
<a name="l00037"></a>00037 <span class="comment">//</span>
<a name="l00038"></a>00038 <span class="comment">//</span>
<a name="l00039"></a>00039 <span class="comment">//</span>
<a name="l00040"></a>00040 <span class="comment">//</span>
<a name="l00041"></a>00041 <span class="comment">//</span>
<a name="l00042"></a>00042 <span class="comment">//</span>
<a name="l00043"></a>00043 <span class="comment">//</span>
<a name="l00044"></a>00044 <span class="comment">//</span>
<a name="l00045"></a>00045 <span class="comment">//</span>
<a name="l00046"></a>00046 <span class="comment">//</span><span class="comment"></span>
<a name="l00047"></a>00047 <span class="comment">//! Calcul des ensembles connexes par faces d&#39;elements&lt;br&gt;non &quot;marques&quot; (les elements sont relies entre eux par un graphe&lt;br&gt;symetrique passant par les faces).&lt;br&gt;Une portion de domaine connexe porte un numero 0 &lt;= i &lt; N&lt;br&gt;unique et est delimite soit par un bord, soit par un element voisin &quot;marque&quot;&lt;br&gt;par num_compo[elem] = -1.&lt;br&gt;Cette methode est sequentielle (peut etre appelee sur un seul processeur)&lt;br&gt;Parametre: elem_faces&lt;br&gt;graph de connectivite elements-faces (pour chaque element i, indices&lt;br&gt;des faces de cet element), voir Zone_VF::elem_faces()&lt;br&gt;Parametre: faces_elem&lt;br&gt;graph de connectivite faces-elements (pour chaque face, indice du&lt;br&gt;ou des deux elements adjacents), voir Zone_VF::face_voisins()&lt;br&gt;Parametre: num_compo&lt;br&gt;En entree, un tableau tel que num_compo.size_array() == elem_faces.dimension_tot(0),&lt;br&gt;et dont certaines valeurs valent -1 (elements marques), et d&#39;autres non.&lt;br&gt;En sortie: les elements pour lesquels num_compo = -1 ne sont pas modifies, les autres&lt;br&gt;sont numerotes par composante connexe locale. On remplit tout le tableau&lt;br&gt;jusqu&#39;a size_tot() y compris les elements virtuels. Les numeros de composantes&lt;br&gt;sont locaux a ce processeur.&lt;br&gt;Valeur de retour: N, nombre de composantes connexes locales.</span>
<a name="l00048"></a><a class="code" href="Connex__components_8h.html#ad771774190b40158b92030966f3f5a17">00048</a> <span class="comment"></span><span class="keywordtype">int</span> <a class="code" href="Connex__components_8cpp.html#ad771774190b40158b92030966f3f5a17" title="Calcul des ensembles connexes par faces d&#39;elements non &quot;marques&quot; (les elements sont relies entre eu...">search_connex_components_local</a>(<span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; elem_faces,
<a name="l00049"></a>00049                                    <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; faces_elem,
<a name="l00050"></a>00050                                    <a class="code" href="classIntVect.html">IntVect</a>&amp; num_compo)
<a name="l00051"></a>00051 {
<a name="l00052"></a>00052   <span class="keyword">const</span> <span class="keywordtype">int</span> nbelem = num_compo.<a class="code" href="classIntVect.html#afa716e1f0a1f0f74f4f73e95b5651412" title="Identique a size_array()">size_totale</a>();
<a name="l00053"></a>00053   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_voisins = elem_faces.<a class="code" href="classIntTab.html#abc3b32c94925a82f69d5b153a356e359" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(1);
<a name="l00054"></a>00054   assert(elem_faces.<a class="code" href="classIntTab.html#a71e9b9ddc1793094b1b3f109377952b1" title="Returns the total dimensions of the multi-dimensionnal array, including virtual items (used in parall...">dimension_tot</a>(0) == nbelem);
<a name="l00055"></a>00055   {
<a name="l00056"></a>00056     <span class="keywordtype">int</span> i;
<a name="l00057"></a>00057     <span class="keywordflow">for</span> (i = 0; i &lt; nbelem; i++)
<a name="l00058"></a>00058       <span class="keywordflow">if</span> (num_compo[i] != -1)
<a name="l00059"></a>00059         num_compo[i] = -2;
<a name="l00060"></a>00060   }
<a name="l00061"></a>00061   <span class="keywordtype">int</span> start_element = 0;
<a name="l00062"></a>00062   <span class="keywordtype">int</span> num_compo_courant = 0;
<a name="l00063"></a>00063   <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> liste_elems;
<a name="l00064"></a>00064   liste_elems.<a class="code" href="classArrOfInt.html#a22d744bcd452d039580d1d9186f02b4e" title="Change le mode l&#39;allocation memoire: reallocation d&#39;un tableau a chaque changement de taille (flag = ...">set_smart_resize</a>(1);
<a name="l00065"></a>00065   <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> tmp_liste;
<a name="l00066"></a>00066   tmp_liste.<a class="code" href="classArrOfInt.html#a22d744bcd452d039580d1d9186f02b4e" title="Change le mode l&#39;allocation memoire: reallocation d&#39;un tableau a chaque changement de taille (flag = ...">set_smart_resize</a>(1);
<a name="l00067"></a>00067   <span class="keywordflow">do</span>
<a name="l00068"></a>00068     {
<a name="l00069"></a>00069 <span class="comment">// Cherche le prochain element non attribue a une composante connexe</span>
<a name="l00070"></a>00070       <span class="keywordflow">while</span> (start_element &lt; nbelem &amp;&amp; num_compo[start_element] &gt;= -1)
<a name="l00071"></a>00071         start_element++;
<a name="l00072"></a>00072       <span class="keywordflow">if</span> (start_element == nbelem)
<a name="l00073"></a>00073         <span class="keywordflow">break</span>;
<a name="l00074"></a>00074 <span class="comment">// Recherche des elements de la composante connexe a partir de cet element</span>
<a name="l00075"></a>00075       liste_elems.<a class="code" href="classArrOfInt.html#a9b3afbb46b16870dbd36236c8935b535">resize_array</a>(1);
<a name="l00076"></a>00076       liste_elems[0] = start_element;
<a name="l00077"></a>00077       num_compo[start_element] = num_compo_courant;
<a name="l00078"></a>00078       <span class="keywordflow">while</span> (liste_elems.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() &gt; 0)
<a name="l00079"></a>00079         {
<a name="l00080"></a>00080           tmp_liste.<a class="code" href="classArrOfInt.html#a9b3afbb46b16870dbd36236c8935b535">resize_array</a>(0);
<a name="l00081"></a>00081           <span class="keyword">const</span> <span class="keywordtype">int</span> liste_elems_size = liste_elems.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>();
<a name="l00082"></a>00082           <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i_elem = 0; i_elem &lt; liste_elems_size; i_elem++)
<a name="l00083"></a>00083             {
<a name="l00084"></a>00084               <span class="keyword">const</span> <span class="keywordtype">int</span> elem = liste_elems[i_elem];
<a name="l00085"></a>00085 <span class="comment">// Ajout des voisins non attribues de cet element dans la liste a</span>
<a name="l00086"></a>00086 <span class="comment">// traiter a l&#39;etape suivante</span>
<a name="l00087"></a>00087               <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; nb_voisins; j++)
<a name="l00088"></a>00088                 {
<a name="l00089"></a>00089                   <span class="keyword">const</span> <span class="keywordtype">int</span> face = elem_faces(elem, j);
<a name="l00090"></a>00090                   <span class="keyword">const</span> <span class="keywordtype">int</span> voisin = faces_elem(face, 0) + faces_elem(face, 1) - elem;
<a name="l00091"></a>00091                   <span class="keywordflow">if</span> (voisin &gt;= 0)
<a name="l00092"></a>00092                     {
<a name="l00093"></a>00093                       <span class="keyword">const</span> <span class="keywordtype">int</span> num = num_compo[voisin];
<a name="l00094"></a>00094                       <span class="keywordflow">if</span> (num == -2)
<a name="l00095"></a>00095                         {
<a name="l00096"></a>00096                           num_compo[voisin] = num_compo_courant;
<a name="l00097"></a>00097                           tmp_liste.<a class="code" href="classArrOfInt.html#a3f39d0966599416e7b1f7cd8159d8d01" title="Ajoute une case en fin de tableau et y stocke la &quot;valeur&quot;.">append_array</a>(voisin);
<a name="l00098"></a>00098                         }
<a name="l00099"></a>00099                     }
<a name="l00100"></a>00100                 }
<a name="l00101"></a>00101             }
<a name="l00102"></a>00102           liste_elems = tmp_liste;
<a name="l00103"></a>00103         }
<a name="l00104"></a>00104       num_compo_courant++;
<a name="l00105"></a>00105     }
<a name="l00106"></a>00106   <span class="keywordflow">while</span> (1);
<a name="l00107"></a>00107 <span class="comment">// Renvoie le nombre de composantes connexes locales trouvees</span>
<a name="l00108"></a>00108   <span class="keywordflow">return</span> num_compo_courant;
<a name="l00109"></a>00109 }
<a name="l00110"></a>00110 
<a name="l00111"></a>00111 <span class="comment">//</span>
<a name="l00112"></a>00112 <span class="comment">//</span>
<a name="l00113"></a>00113 <span class="comment">//</span>
<a name="l00114"></a>00114 <span class="comment">//</span>
<a name="l00115"></a>00115 <span class="comment">//</span>
<a name="l00116"></a>00116 <span class="comment">//</span>
<a name="l00117"></a>00117 <span class="comment">//</span>
<a name="l00118"></a>00118 <span class="comment">//</span>
<a name="l00119"></a>00119 <span class="comment">//</span>
<a name="l00120"></a>00120 <span class="comment">//</span>
<a name="l00121"></a>00121 <span class="comment">//</span>
<a name="l00122"></a>00122 <span class="comment">//</span>
<a name="l00123"></a>00123 <span class="comment">//</span><span class="comment"></span>
<a name="l00124"></a>00124 <span class="comment">//! recherche des composantes connexes d&#39;un graphe local (non distribue&lt;br&gt;sur les processeurs) non symetrique.&lt;br&gt;Parametre: graph&lt;br&gt;On suppose que &quot;graph&quot; est un tableau a deux colonnes&lt;br&gt;contenant des couples d&#39;indices de &quot;sommets&quot; d&#39;un graphe. Ces couples definissent&lt;br&gt;un graphe dont on veut chercher les composantes connexes:&lt;br&gt;deux indices i et j sont dans la meme composante connexe si et seulement si il&lt;br&gt;existe une suite de couples qui relient directement ou indirectement i et j.&lt;br&gt;Parametre: connex_components&lt;br&gt;On suppose que connex_components est dimensionne a nb_sommets, le nombre de sommets du graphe.&lt;br&gt;On met dans connex_components[i] le numero de la composante connexe du graphe a laquelle appartient&lt;br&gt;le &quot;sommet&quot; i. On attribue tous les numeros i tels que 0 &lt;= i &lt; N&lt;br&gt;Valeur de retour: le nombre N de composantes connexes trouvees.</span>
<a name="l00125"></a><a class="code" href="Connex__components_8h.html#a1e4b3977c09e7f6f4e8a3d554c05e727">00125</a> <span class="comment"></span><span class="keywordtype">int</span> <a class="code" href="Connex__components_8cpp.html#a1e4b3977c09e7f6f4e8a3d554c05e727" title="recherche des composantes connexes d&#39;un graphe local (non distribue sur les processeurs) non symetriq...">compute_graph_connex_components</a>(<span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; graph, <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; connex_components)
<a name="l00126"></a>00126 {
<a name="l00127"></a>00127 <span class="comment">// connex_components doit deja avoir la bonne taille en entree !</span>
<a name="l00128"></a>00128   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_sommets = connex_components.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>();
<a name="l00129"></a>00129 
<a name="l00130"></a>00130 <span class="comment">// renum_data definit des listes chainees de numeros de &quot;sommets&quot; appartenant a</span>
<a name="l00131"></a>00131 <span class="comment">// la meme composante connexe.</span>
<a name="l00132"></a>00132 <span class="comment">// renum_data(i,0)= numero du premier &quot;sommet&quot; de la liste a laquelle appartient i</span>
<a name="l00133"></a>00133 <span class="comment">// renum_data(i,1)= numero du &quot;sommet&quot; suivant dans la liste</span>
<a name="l00134"></a>00134   <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a> renum_data(nb_sommets, 2);
<a name="l00135"></a>00135 <span class="comment">// Au debut, chaque sommet est toute seule dans une liste:</span>
<a name="l00136"></a>00136   <span class="keywordtype">int</span> i_sommet;
<a name="l00137"></a>00137   <span class="keywordflow">for</span> (i_sommet = 0; i_sommet &lt; nb_sommets; i_sommet++)
<a name="l00138"></a>00138     {
<a name="l00139"></a>00139       renum_data(i_sommet, 0) = i_sommet;
<a name="l00140"></a>00140       renum_data(i_sommet, 1) = -1; <span class="comment">//!&lt; fin de liste</span>
<a name="l00141"></a>00141 <span class="comment"></span>    }
<a name="l00142"></a>00142   <span class="keyword">const</span> <span class="keywordtype">int</span> nbcouples = graph.<a class="code" href="classIntTab.html#abc3b32c94925a82f69d5b153a356e359" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(0);
<a name="l00143"></a>00143   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i_couple = 0; i_couple &lt; nbcouples; i_couple++)
<a name="l00144"></a>00144     {
<a name="l00145"></a>00145       <span class="keyword">const</span> <span class="keywordtype">int</span> compo1 = graph(i_couple, 0); <span class="comment">//!&lt; la plus petite</span>
<a name="l00146"></a>00146 <span class="comment"></span>      <span class="keyword">const</span> <span class="keywordtype">int</span> compo2 = graph(i_couple, 1); <span class="comment">//!&lt; la plus grande</span>
<a name="l00147"></a>00147 <span class="comment"></span>      assert(compo1 != compo2);
<a name="l00148"></a>00148 <span class="comment">// Si les deux composantes sont deja dans la meme liste,</span>
<a name="l00149"></a>00149 <span class="comment">// ne rien faire.</span>
<a name="l00150"></a>00150       <span class="keywordflow">if</span> (renum_data(compo1, 0) == renum_data(compo2, 0))
<a name="l00151"></a>00151         <span class="keywordflow">continue</span>;
<a name="l00152"></a>00152 <span class="comment">// Reunir la liste1 contenant compo1 et la liste2 contenant compo2:</span>
<a name="l00153"></a>00153 <span class="comment">// 1) trouver la fin de la premiere liste</span>
<a name="l00154"></a>00154       <span class="keywordtype">int</span> fin_liste1 = compo1;
<a name="l00155"></a>00155       <span class="keywordflow">for</span> (;;)
<a name="l00156"></a>00156         {
<a name="l00157"></a>00157           <span class="keyword">const</span> <span class="keywordtype">int</span> <a class="code" href="Zone__VEF__PreP1b_8cpp.html#a24a462bbedad66c2a21f5f6f84b8ec5b">next</a> = renum_data(fin_liste1, 1);
<a name="l00158"></a>00158           <span class="keywordflow">if</span> (next &lt; 0)
<a name="l00159"></a>00159             <span class="keywordflow">break</span>;
<a name="l00160"></a>00160           fin_liste1 = <a class="code" href="Zone__VEF__PreP1b_8cpp.html#a24a462bbedad66c2a21f5f6f84b8ec5b">next</a>;
<a name="l00161"></a>00161         }
<a name="l00162"></a>00162 <span class="comment">// 2) brancher la liste2 a la fin de la liste1 :</span>
<a name="l00163"></a>00163       <span class="keyword">const</span> <span class="keywordtype">int</span> debut_liste2 = renum_data(compo2, 0);
<a name="l00164"></a>00164       renum_data(fin_liste1, 1) = debut_liste2;
<a name="l00165"></a>00165 <span class="comment">// 2) mettre a jour le debut de liste pour liste2 :</span>
<a name="l00166"></a>00166       i_sommet = debut_liste2;
<a name="l00167"></a>00167       <span class="keyword">const</span> <span class="keywordtype">int</span> debut_liste1 = renum_data(compo1, 0);
<a name="l00168"></a>00168       <span class="keywordflow">do</span>
<a name="l00169"></a>00169         {
<a name="l00170"></a>00170           renum_data(i_sommet, 0) = debut_liste1;
<a name="l00171"></a>00171           i_sommet = renum_data(i_sommet, 1);
<a name="l00172"></a>00172         }
<a name="l00173"></a>00173       <span class="keywordflow">while</span> (i_sommet &gt;= 0);
<a name="l00174"></a>00174     }
<a name="l00175"></a>00175 
<a name="l00176"></a>00176 <span class="comment">// Creation d&#39;une numerotation contigue pour les composantes:</span>
<a name="l00177"></a>00177 <span class="comment">// Prochain numero a attribuer</span>
<a name="l00178"></a>00178   <span class="keywordtype">int</span> count = 0;
<a name="l00179"></a>00179   connex_components = -1;
<a name="l00180"></a>00180   <span class="keywordflow">for</span> (i_sommet = 0; i_sommet &lt; nb_sommets; i_sommet++)
<a name="l00181"></a>00181     {
<a name="l00182"></a>00182       <span class="keywordflow">if</span> (connex_components[i_sommet] &lt; 0)
<a name="l00183"></a>00183         {
<a name="l00184"></a>00184 <span class="comment">// sommet pas encore traite</span>
<a name="l00185"></a>00185 <span class="comment">// Associe un nouveau numero a tous les sommets de la composante</span>
<a name="l00186"></a>00186 <span class="comment">// connexe a laquelle appartient i_sommet:</span>
<a name="l00187"></a>00187           <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = renum_data(i_sommet, 0); i &gt;= 0; i = renum_data(i, 1))
<a name="l00188"></a>00188             connex_components[i] = count;
<a name="l00189"></a>00189 <span class="comment">// Nouveau numero pour la prochaine composante</span>
<a name="l00190"></a>00190           count++;
<a name="l00191"></a>00191         }
<a name="l00192"></a>00192     }
<a name="l00193"></a>00193 <span class="comment">// On renvoie le nombre de composantes connexes trouvees</span>
<a name="l00194"></a>00194   <span class="keywordflow">return</span> count;
<a name="l00195"></a>00195 }
<a name="l00196"></a>00196 
<a name="l00197"></a>00197 <span class="comment">//</span>
<a name="l00198"></a>00198 <span class="comment">//</span>
<a name="l00199"></a>00199 <span class="comment">//</span>
<a name="l00200"></a>00200 <span class="comment">//</span>
<a name="l00201"></a>00201 <span class="comment">//</span>
<a name="l00202"></a>00202 <span class="comment">//</span>
<a name="l00203"></a>00203 <span class="comment">//</span>
<a name="l00204"></a>00204 <span class="comment">//</span>
<a name="l00205"></a>00205 <span class="comment">//</span>
<a name="l00206"></a>00206 <span class="comment">//</span>
<a name="l00207"></a>00207 <span class="comment">//</span>
<a name="l00208"></a>00208 <span class="comment">//</span>
<a name="l00209"></a>00209 <span class="comment">//</span>
<a name="l00210"></a>00210 <span class="comment">//</span>
<a name="l00211"></a>00211 <span class="comment">//</span>
<a name="l00212"></a>00212 <span class="comment">//</span>
<a name="l00213"></a>00213 <span class="comment">//</span><span class="comment"></span>
<a name="l00214"></a>00214 <span class="comment">//! Recherche les composantes connexes d&#39;un ensemble d&#39;elements distribue sur&lt;br&gt;tous les processeurs. Cette methode est parallele et doit etre appelee en&lt;br&gt;meme temps sur tous les processeurs.&lt;br&gt;Parametre: num_compo&lt;br&gt;num_compo doit avoir au moins une couche d&#39;elements virtuels et doit contenir&lt;br&gt;le resultat de la methode search_connex_components_local(). Les elements&lt;br&gt;virtuels ont donc ete remplis avec des numeros de composantes connexes locales.&lt;br&gt;Le tableau num_compo ne doit PAS avoir subi echange_espace_virtuel !!!&lt;br&gt;On cherche a l&#39;aide des elements virtuels les composantes connexes connectees&lt;br&gt;entre elles entre deux processeurs et on leur attribue un numero unique i tel&lt;br&gt;que tous les indices 0 &lt;= i &lt; N sont utilises.&lt;br&gt;Parametre: nb_local_components&lt;br&gt;doit contenir le nombre de composantes connexes locales utilisees&lt;br&gt;dans num_compo a l&#39;entree (egale a la valeur de retour de la fonction&lt;br&gt;search_connex_components_local()).&lt;br&gt;Valeur de retour: nombre N de composantes connexes globales trouvees.</span>
<a name="l00215"></a><a class="code" href="Connex__components_8h.html#a476f055e17d2b6b039961d59afb7ebcb">00215</a> <span class="comment"></span><span class="keywordtype">int</span> <a class="code" href="Connex__components_8cpp.html#a476f055e17d2b6b039961d59afb7ebcb" title="Recherche les composantes connexes d&#39;un ensemble d&#39;elements distribue sur tous les processeurs...">compute_global_connex_components</a>(<a class="code" href="classIntVect.html">IntVect</a>&amp; num_compo, <span class="keywordtype">int</span> nb_local_components)
<a name="l00216"></a>00216 {
<a name="l00217"></a>00217   <span class="keyword">const</span> <span class="keywordtype">int</span> nbelem = num_compo.<a class="code" href="classIntVect.html#ad90cfd411cbbd631ccf1935bb36f7c40" title="Identique a size_reelle()">size</a>();
<a name="l00218"></a>00218   <span class="keyword">const</span> <span class="keywordtype">int</span> nbelem_tot = num_compo.<a class="code" href="classIntVect.html#afa716e1f0a1f0f74f4f73e95b5651412" title="Identique a size_array()">size_totale</a>();
<a name="l00219"></a>00219 <span class="comment">// int i;</span>
<a name="l00220"></a>00220 
<a name="l00221"></a>00221 <span class="comment">// Transformation des indices locaux de composantes connexes en un indice global</span>
<a name="l00222"></a>00222 <span class="comment">// (on ajoute un decalage aux indices globaux avec mppartial_sum())</span>
<a name="l00223"></a>00223   <span class="keyword">const</span> <span class="keywordtype">int</span> decalage = <a class="code" href="communications_8cpp.html#a13b5bdc7cfe14771b52a033b1ecbc071" title="Calul de la somme partielle de i sur les processeurs 0 a me()-1 (renvoie 0 sur le processeur 0)...">mppartial_sum</a>(nb_local_components);
<a name="l00224"></a>00224   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_total_components = <a class="code" href="classProcess.html#a7d23bc1ef94b3f0623fbc79d034c27fd" title="Calcule la somme de x sur tous les processeurs du groupe courant. Voir aussi mp_max()">Process::mp_sum</a>(nb_local_components);
<a name="l00225"></a>00225   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; nbelem_tot; i++)
<a name="l00226"></a>00226     <span class="keywordflow">if</span> (num_compo[i] &gt;= 0)
<a name="l00227"></a>00227       num_compo[i] += decalage;
<a name="l00228"></a>00228 
<a name="l00229"></a>00229 <span class="comment">// Pour trouver les correspondances entre un numero de composante locale et un</span>
<a name="l00230"></a>00230 <span class="comment">// numero de la meme composante sur le processeur voisin, on cree une copie du</span>
<a name="l00231"></a>00231 <span class="comment">// tableau num_compo sur laquelle on fait un echange_espace_virtuel(). Ainsi,</span>
<a name="l00232"></a>00232 <span class="comment">// sur les cases virtuelles du tableau, on a dans num_compo le numero de la</span>
<a name="l00233"></a>00233 <span class="comment">// composante locale et dans copie_compo le numero de cette meme composante sur</span>
<a name="l00234"></a>00234 <span class="comment">// le processeur proprietaire de l&#39;element. Donc ces deux numeros designent</span>
<a name="l00235"></a>00235 <span class="comment">// la meme composante connexe.</span>
<a name="l00236"></a>00236   <a class="code" href="classIntVect.html">IntVect</a> copie_compo(num_compo);
<a name="l00237"></a>00237   copie_compo.<a class="code" href="classIntVect.html#ad12bea67621d1a0ee82b27c9a37ca4ef">echange_espace_virtuel</a>();
<a name="l00238"></a>00238 
<a name="l00239"></a>00239 <span class="comment">// Recherche des equivalences entre les numeros des composantes locales et</span>
<a name="l00240"></a>00240 <span class="comment">// les numeros des composantes voisines. On construit un graphe dont les</span>
<a name="l00241"></a>00241 <span class="comment">// liens relient les composantes equivalentes.</span>
<a name="l00242"></a>00242 <span class="comment">// Tableau de marqeurs pour les equivalences deja trouvees.</span>
<a name="l00243"></a>00243 <span class="comment">// Dimensions = nb composantes locales * nb_composantes total</span>
<a name="l00244"></a>00244 <span class="comment">// (pour ne pas prendre en compte la meme composante plusieurs fois).</span>
<a name="l00245"></a>00245   <a class="code" href="classArrOfBit.html">ArrOfBit</a> markers(nb_local_components * nb_total_components);
<a name="l00246"></a>00246   markers = 0;
<a name="l00247"></a>00247 <span class="comment">// Tableau de correspondances entre composantes connexes locales et distantes</span>
<a name="l00248"></a>00248   <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a> graph;
<a name="l00249"></a>00249   graph.<a class="code" href="classArrOfInt.html#a22d744bcd452d039580d1d9186f02b4e" title="Change le mode l&#39;allocation memoire: reallocation d&#39;un tableau a chaque changement de taille (flag = ...">set_smart_resize</a>(1);
<a name="l00250"></a>00250   <span class="keywordtype">int</span> graph_size = 0;
<a name="l00251"></a>00251 <span class="comment">// Parcours des elements virtuels uniquement</span>
<a name="l00252"></a>00252   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = nbelem; i &lt; nbelem_tot; i++)
<a name="l00253"></a>00253     {
<a name="l00254"></a>00254       <span class="keywordtype">int</span> compo = num_compo[i];
<a name="l00255"></a>00255       <span class="keywordflow">if</span> (compo &lt; 0)
<a name="l00256"></a>00256         <span class="keywordflow">continue</span>;
<a name="l00257"></a>00257       <span class="keywordtype">int</span> compo2 = copie_compo[i];
<a name="l00258"></a>00258 <span class="comment">// Index du couple compo2/compo dans le tableau markers</span>
<a name="l00259"></a>00259 <span class="comment">// Le tableau num_compo ne doit contenir que des composantes locales:</span>
<a name="l00260"></a>00260       assert(compo &gt;= decalage &amp;&amp; compo - decalage &lt; nb_local_components);
<a name="l00261"></a>00261 <span class="comment">// compo2 est forcement une composante distante.</span>
<a name="l00262"></a>00262       assert(compo2 &lt; decalage || compo2 - decalage &gt;= nb_local_components);
<a name="l00263"></a>00263       <span class="keyword">const</span> <span class="keywordtype">int</span> index = (compo - decalage) * nb_total_components + compo2;
<a name="l00264"></a>00264       <span class="keywordflow">if</span> (!markers.<a class="code" href="classArrOfBit.html#a68b08edd2eebc91e7bd7d34ec81f6cd2" title="Renvoie la valeur du bit e, puis met le bit e a 1.">testsetbit</a>(index))
<a name="l00265"></a>00265         {
<a name="l00266"></a>00266           graph.<a class="code" href="classIntTab.html#a22e6bed6826b3688d4d0181cbf3b7a38" title="Change la taille du vecteur (identique a resize_array() pour le traitement des anciennes valeurs et d...">resize</a>(graph_size+1, 2);
<a name="l00267"></a>00267 <span class="comment">// On met le plus petit numero de composante en colonne 0:</span>
<a name="l00268"></a>00268           <span class="keywordflow">if</span> (compo2 &lt; compo)
<a name="l00269"></a>00269             {
<a name="l00270"></a>00270               <span class="keywordtype">int</span> tmp = compo;
<a name="l00271"></a>00271               compo = compo2;
<a name="l00272"></a>00272               compo2 = tmp;
<a name="l00273"></a>00273             }
<a name="l00274"></a>00274           graph(graph_size, 0) = compo;
<a name="l00275"></a>00275           graph(graph_size, 1) = compo2;
<a name="l00276"></a>00276           graph_size++;
<a name="l00277"></a>00277         }
<a name="l00278"></a>00278     }
<a name="l00279"></a>00279 
<a name="l00280"></a>00280   <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> renum;
<a name="l00281"></a>00281   <span class="keywordflow">if</span> (<a class="code" href="classProcess.html#acd052b99706c577f8a5b6656217cf4c2" title="renvoie 1 si on est sur le processeur maitre du groupe courant (c&#39;est a dire me() == 0)...">Process::je_suis_maitre</a>())
<a name="l00282"></a>00282     {
<a name="l00283"></a>00283 <span class="comment">// Reception des portions de graphe des autres processeurs</span>
<a name="l00284"></a>00284       <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a> tmp;
<a name="l00285"></a>00285       <span class="keyword">const</span> <span class="keywordtype">int</span> nproc = <a class="code" href="classProcess.html#a6bf692ce58d9578aa62ac3c07b8caaa1" title="renvoie le nombre de processeurs dans le groupe courant Voir Comm_Group::nproc() et PE_Groups::curren...">Process::nproc</a>();
<a name="l00286"></a>00286       <span class="keywordtype">int</span> pe;
<a name="l00287"></a>00287       <span class="keywordflow">for</span> (pe = 1; pe &lt; nproc; pe++)
<a name="l00288"></a>00288         {
<a name="l00289"></a>00289           <a class="code" href="communications_8cpp.html#a729d9499913e22a5f0db62ef07b9793f">recevoir</a>(tmp, pe, 54 <span class="comment">/* tag */</span>);
<a name="l00290"></a>00290           <span class="keyword">const</span> <span class="keywordtype">int</span> n2 = tmp.<a class="code" href="classIntTab.html#abc3b32c94925a82f69d5b153a356e359" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(0);
<a name="l00291"></a>00291           graph.<a class="code" href="classIntTab.html#a22e6bed6826b3688d4d0181cbf3b7a38" title="Change la taille du vecteur (identique a resize_array() pour le traitement des anciennes valeurs et d...">resize</a>(graph_size + n2, 2);
<a name="l00292"></a>00292           <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; n2; i++)
<a name="l00293"></a>00293             {
<a name="l00294"></a>00294               graph(graph_size, 0) = tmp(i, 0);
<a name="l00295"></a>00295               graph(graph_size, 1) = tmp(i, 1);
<a name="l00296"></a>00296               graph_size++;
<a name="l00297"></a>00297             }
<a name="l00298"></a>00298         }
<a name="l00299"></a>00299 <span class="comment">// Calcul des composantes connexes du graphe</span>
<a name="l00300"></a>00300       renum.<a class="code" href="classArrOfInt.html#a9b3afbb46b16870dbd36236c8935b535">resize_array</a>(nb_total_components);
<a name="l00301"></a>00301       <span class="keyword">const</span> <span class="keywordtype">int</span> n = <a class="code" href="Connex__components_8cpp.html#a1e4b3977c09e7f6f4e8a3d554c05e727" title="recherche des composantes connexes d&#39;un graphe local (non distribue sur les processeurs) non symetriq...">compute_graph_connex_components</a>(graph, renum);
<a name="l00302"></a>00302       <a class="code" href="classProcess.html#a57e0f54b11e6eaadbea224fa904b18dd" title="Renvoie un objet statique de type Sortie qui sert de journal d&#39;evenements. Si message_level &lt;= verbose...">Process::Journal</a>() &lt;&lt; <span class="stringliteral">&quot;compute_global_connex_components: nb_components=&quot;</span> &lt;&lt; n &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
<a name="l00303"></a>00303     }
<a name="l00304"></a>00304   <span class="keywordflow">else</span>
<a name="l00305"></a>00305     {
<a name="l00306"></a>00306 <span class="comment">// Envoi du graphe local au processeur 0</span>
<a name="l00307"></a>00307       <a class="code" href="communications_8cpp.html#af9feb6405277b375b2ebcbfaec9f8af3">envoyer</a>(graph, 0, 54 <span class="comment">/* tag */</span>);
<a name="l00308"></a>00308     }
<a name="l00309"></a>00309 
<a name="l00310"></a>00310 <span class="comment">// Reception des composantes connexes</span>
<a name="l00311"></a>00311   <a class="code" href="communications_8cpp.html#a2335b36078ae87e23dab400a6e129a3c">envoyer_broadcast</a>(renum, 0 <span class="comment">/* processeur source */</span>);
<a name="l00312"></a>00312 
<a name="l00313"></a>00313 <span class="comment">// Renumerotation des composantes dans num_compo</span>
<a name="l00314"></a>00314   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; nbelem_tot; i++)
<a name="l00315"></a>00315     {
<a name="l00316"></a>00316       <span class="keyword">const</span> <span class="keywordtype">int</span> x = num_compo[i];
<a name="l00317"></a>00317       <span class="keywordflow">if</span> (x &gt;= 0)
<a name="l00318"></a>00318         {
<a name="l00319"></a>00319           <span class="keyword">const</span> <span class="keywordtype">int</span> new_x = renum[x];
<a name="l00320"></a>00320           num_compo[i] = new_x;
<a name="l00321"></a>00321         }
<a name="l00322"></a>00322     }
<a name="l00323"></a>00323 <span class="comment">// Verification: si on fait un echange espace virtuel,</span>
<a name="l00324"></a>00324 <span class="comment">// cela ne doit par changer le numero des composantes</span>
<a name="l00325"></a>00325 <span class="comment">// connexes !</span>
<a name="l00326"></a>00326 
<a name="l00327"></a>00327   <span class="keywordtype">int</span> nb_components = 0;
<a name="l00328"></a>00328 <span class="comment">// Tous les processeurs possedent le meme tableau renum, tout le monde</span>
<a name="l00329"></a>00329 <span class="comment">// calcule donc le meme maximum !</span>
<a name="l00330"></a>00330   <span class="keywordflow">if</span> (renum.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() &gt; 0)
<a name="l00331"></a>00331     nb_components = <a class="code" href="ArrOfDouble_8cpp.html#a95241fccf4bed7fb7a4e2340b7735f14" title="Retourne la valeur maximale.">max_array</a>(renum) + 1;
<a name="l00332"></a>00332   <span class="keywordflow">return</span> nb_components;
<a name="l00333"></a>00333 }
<a name="l00334"></a>00334 
<a name="l00335"></a>00335 
</pre></div></div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Tue Dec 14 2021 19:35:17 for TRUST by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
