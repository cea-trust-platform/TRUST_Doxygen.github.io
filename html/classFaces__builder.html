<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>TRUST: Faces_builder Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">TRUST&#160;<span id="projectnumber">1.8.4</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-static-methods">Static Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a>  </div>
  <div class="headertitle">
<div class="title">Faces_builder Class Reference</div>  </div>
</div>
<div class="contents">
<!-- doxytag: class="Faces_builder" -->
<p><code>#include &lt;<a class="el" href="Faces__builder_8h_source.html">Faces_builder.h</a>&gt;</code></p>

<p><a href="classFaces__builder-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFaces__builder.html#a690953da7fca9b33ad10747f1c606cac">Faces_builder</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFaces__builder.html#aecd26cae77aa00884a228ab14b57ddb8">reset</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFaces__builder.html#a5b48ba95888da226cbf702f677656ff6">creer_faces_reeles</a> (<a class="el" href="classZone.html">Zone</a> &amp;zone, const <a class="el" href="classStatic__Int__Lists.html">Static_Int_Lists</a> &amp;connect_som_elem, <a class="el" href="classFaces.html">Faces</a> &amp;les_faces, <a class="el" href="classIntTab.html">IntTab</a> &amp;elem_faces)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A partir de la description des elements de la zone et des frontieres&lt;br&gt;(bords, raccords, faces internes et joints) :<br/>
Remplissage des structures suivantes:<br/>
- pour les frontieres de la zone: fixer_num_premiere_face<br/>
- les_faces.faces_sommets (faces reeles)<br/>
- les_faces.faces_voisins (faces reeles)<br/>
- elem_faces (pour les faces reeles des elements reels)<br/>
(on initialise elem_faces de taille nb_elem_reels, nb_faces_par_elem)<br/>
- joints.items_communs(FACE)  <a href="#a5b48ba95888da226cbf702f677656ff6"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFaces__builder.html#a17469d1ff2feae7d358abcccd2d67831">chercher_face_element</a> (const <a class="el" href="classIntTab.html">IntTab</a> &amp;les_elements, const <a class="el" href="classIntTab.html">IntTab</a> &amp;faces_element_reference, const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;une_face, const int elem)</td></tr>
<tr><td colspan="2"><h2><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFaces__builder.html#a2a1241fa1f4adf443332bd7440e9472f">check_erreur_faces</a> (const char *message, const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;liste_faces) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">methode outil pour creer_faces_frontiere et creer_faces_internes<br/>
(si liste non vide sur au moins un processeur, affiche un message et exit()).  <a href="#a2a1241fa1f4adf443332bd7440e9472f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFaces__builder.html#ab381d2766eda537c836a664eff17f0d8">chercher_face_element</a> (const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;une_face, const int elem) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Methode outil: on suppose que "une_face" contient les indices<br/>
des sommets d'une face de l'element d'indice "elem" dans la zone.<br/>
On cherche quel est le numero de cette face sur l'element<br/>
de reference. Si les sommets ne correspondent a aucune face de<br/>
l'element, on renvoie -1.  <a href="#ab381d2766eda537c836a664eff17f0d8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFaces__builder.html#a451a0948864cba2c5cc5022a2013c83c">creer_faces_frontiere</a> (const int nb_voisins_attendus, <a class="el" href="classFrontiere.html">Frontiere</a> &amp;frontiere, <a class="el" href="classIntTab.html">IntTab</a> &amp;faces_sommets, <a class="el" href="classIntTab.html">IntTab</a> &amp;faces_voisins, <a class="el" href="classIntTab.html">IntTab</a> &amp;elem_faces) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Insere les faces de la frontiere donnee dans les trois tableaux,<br/>
a la suite des faces deja presentes dans faces_sommets.<br/>
Remplissage de :<br/>
frontiere.num_premiere_face<br/>
Completion de :<br/>
faces_sommets<br/>
elem_faces<br/>
faces_voisins.  <a href="#a451a0948864cba2c5cc5022a2013c83c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFaces__builder.html#ae52612e6c9aff57afbe490c910930516">creer_faces_internes</a> (<a class="el" href="classIntTab.html">IntTab</a> &amp;faces_sommets, <a class="el" href="classIntTab.html">IntTab</a> &amp;elem_faces, <a class="el" href="classIntTab.html">IntTab</a> &amp;faces_voisins) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Construction des faces interieures au domaine<br/>
(faces qui ont deux voisins et qui ne sont pas des "faces_bord_internes")<br/>
Les faces de joint ont deja ete creees.  <a href="#ae52612e6c9aff57afbe490c910930516"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classIntTab.html">IntTab</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFaces__builder.html#a30ad4fbd88a8069b4cfd093d1da1116c">les_elements</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classStatic__Int__Lists.html">Static_Int_Lists</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFaces__builder.html#a8a270bd6890413328324bb1506709106">connectivite_som_elem</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classIntTab.html">IntTab</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFaces__builder.html#aa173ce9252eff3fb6981b4c199137c32">faces_element_reference</a> (int elem) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">redonne les faces pour un element, dans le cas des polyhedres cela depend du numero de l'element.  <a href="#aa173ce9252eff3fb6981b4c199137c32"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pri-static-methods"></a>
Static Private Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFaces__builder.html#aacc718530a516ea356626f074b9e6bdc">ajouter_une_face</a> (const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;une_face, const int elem0, const int elem1, <a class="el" href="classIntTab.html">IntTab</a> &amp;faces_sommets, <a class="el" href="classIntTab.html">IntTab</a> &amp;faces_voisins)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">ajoute une face reelle dans faces_sommets et faces_voisins.  <a href="#aacc718530a516ea356626f074b9e6bdc"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classIntTab.html">IntTab</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFaces__builder.html#ad20059c937f9dd87de32f49c15c60202">les_elements_ptr_</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classStatic__Int__Lists.html">Static_Int_Lists</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFaces__builder.html#a63465157f176a5ff77aba327d5438f14">connectivite_som_elem_ptr_</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIntTab.html">IntTab</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFaces__builder.html#a202081564197f53d95fe6a3a2ace2caa">faces_element_reference_old_</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFaces__builder.html#a8998f284fc8c1071af65de5ba552aed0">is_polyedre_</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRef__Zone.html">Ref_Zone</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFaces__builder.html#a4da2e2efdd507fd9db4977dfad555fcf">ref_zone_</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRef__IntTab.html">Ref_IntTab</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFaces__builder.html#ae34616daf8a3bff24ad1673b447e3655">faces_sommets_</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRef__IntTab.html">Ref_IntTab</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFaces__builder.html#ae6a50f5e178055468ccd61d1b03dd496">face_elem_</a></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock">
<p>Definition at line <a class="el" href="Faces__builder_8h_source.html#l00036">36</a> of file <a class="el" href="Faces__builder_8h_source.html">Faces_builder.h</a>.</p>
</div><hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a690953da7fca9b33ad10747f1c606cac"></a><!-- doxytag: member="Faces_builder::Faces_builder" ref="a690953da7fca9b33ad10747f1c606cac" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Faces_builder::Faces_builder </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Faces__builder_8cpp_source.html#l00043">43</a> of file <a class="el" href="Faces__builder_8cpp_source.html">Faces_builder.cpp</a>.</p>
<div class="fragment"><pre class="fragment">                             :
  <a class="code" href="classFaces__builder.html#ad20059c937f9dd87de32f49c15c60202">les_elements_ptr_</a>(0),
  <a class="code" href="classFaces__builder.html#a63465157f176a5ff77aba327d5438f14">connectivite_som_elem_ptr_</a>(0),
  <a class="code" href="classFaces__builder.html#a8998f284fc8c1071af65de5ba552aed0">is_polyedre_</a>(-1)
{
}
</pre></div>
</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="aacc718530a516ea356626f074b9e6bdc"></a><!-- doxytag: member="Faces_builder::ajouter_une_face" ref="aacc718530a516ea356626f074b9e6bdc" args="(const ArrOfInt &amp;une_face, const int elem0, const int elem1, IntTab &amp;faces_sommets, IntTab &amp;faces_voisins)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Faces_builder::ajouter_une_face </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>une_face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>elem0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>elem1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classIntTab.html">IntTab</a> &amp;&#160;</td>
          <td class="paramname"><em>faces_sommets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classIntTab.html">IntTab</a> &amp;&#160;</td>
          <td class="paramname"><em>faces_voisins</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>ajoute une face reelle dans faces_sommets et faces_voisins. </p>

<p>Definition at line <a class="el" href="Faces__builder_8cpp_source.html#l00302">302</a> of file <a class="el" href="Faces__builder_8cpp_source.html">Faces_builder.cpp</a>.</p>

<p>References <a class="el" href="IntTab_8h_source.html#l00233">IntTab::dimension()</a>, <a class="el" href="IntTab_8cpp_source.html#l00353">IntTab::resize()</a>, and <a class="el" href="ArrOfInt_8h_source.html#l00342">ArrOfInt::size_array()</a>.</p>

<p>Referenced by <a class="el" href="Faces__builder_8cpp_source.html#l00414">creer_faces_frontiere()</a>, and <a class="el" href="Faces__builder_8cpp_source.html#l00562">creer_faces_internes()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">int</span> i;
  <span class="keyword">const</span> <span class="keywordtype">int</span> num_new_face        = faces_sommets.<a class="code" href="classIntTab.html#abc3b32c94925a82f69d5b153a356e359" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(0);
  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_sommets_par_face = faces_sommets.<a class="code" href="classIntTab.html#abc3b32c94925a82f69d5b153a356e359" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(1);
  <span class="keyword">const</span> <span class="keywordtype">int</span> new_size = num_new_face + 1;

  assert(une_face.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() == nb_sommets_par_face);
  faces_sommets.<a class="code" href="classIntTab.html#a22e6bed6826b3688d4d0181cbf3b7a38" title="Change la taille du vecteur (identique a resize_array() pour le traitement des anciennes valeurs et d...">resize</a>(new_size, nb_sommets_par_face);
  <span class="keywordflow">for</span> (i = 0; i &lt; nb_sommets_par_face; i++)
    faces_sommets(num_new_face, i) = une_face[i];

  faces_voisins.<a class="code" href="classIntTab.html#a22e6bed6826b3688d4d0181cbf3b7a38" title="Change la taille du vecteur (identique a resize_array() pour le traitement des anciennes valeurs et d...">resize</a>(new_size, 2);
  faces_voisins(num_new_face, 0) = elem0;
  faces_voisins(num_new_face, 1) = elem1;

  <span class="keywordflow">return</span> num_new_face;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a2a1241fa1f4adf443332bd7440e9472f"></a><!-- doxytag: member="Faces_builder::check_erreur_faces" ref="a2a1241fa1f4adf443332bd7440e9472f" args="(const char *message, const ArrOfInt &amp;liste_faces) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Faces_builder::check_erreur_faces </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>liste_faces</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>methode outil pour creer_faces_frontiere et creer_faces_internes<br/>
(si liste non vide sur au moins un processeur, affiche un message et exit()). </p>

<p>Definition at line <a class="el" href="Faces__builder_8cpp_source.html#l00248">248</a> of file <a class="el" href="Faces__builder_8cpp_source.html">Faces_builder.cpp</a>.</p>

<p>References <a class="el" href="EntreeSortie_8h_source.html#l00032">Cerr</a>, <a class="el" href="Domaine_8h_source.html#l00500">Domaine::coord_sommets()</a>, <a class="el" href="IntTab_8h_source.html#l00233">IntTab::dimension()</a>, <a class="el" href="Objet__U_8h_source.html#l00079">Objet_U::dimension</a>, <a class="el" href="Zone_8cpp_source.html#l00262">Zone::domaine()</a>, <a class="el" href="Process_8cpp_source.html#l00223">Process::exit()</a>, <a class="el" href="Faces__builder_8h_source.html#l00098">face_elem_</a>, <a class="el" href="Faces__builder_8h_source.html#l00097">faces_sommets_</a>, <a class="el" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>, <a class="el" href="Process_8cpp_source.html#l00345">Process::Journal()</a>, <a class="el" href="Faces__builder_8h_source.html#l00096">ref_zone_</a>, <a class="el" href="ArrOfInt_8h_source.html#l00342">ArrOfInt::size_array()</a>, <a class="el" href="Ref__IntTab_8h_source.html#l00026">Ref_IntTab::valeur()</a>, <a class="el" href="Ref__Zone_8h_source.html#l00033">Ref_Zone::valeur()</a>, and <a class="el" href="NettoieNoeuds_8cpp_source.html#l00258">NettoieNoeuds::verifie_noeuds()</a>.</p>

<p>Referenced by <a class="el" href="Faces__builder_8cpp_source.html#l00414">creer_faces_frontiere()</a>, and <a class="el" href="Faces__builder_8cpp_source.html#l00562">creer_faces_internes()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">const</span> <span class="keywordtype">int</span> nmax = 100;
  <span class="keywordtype">int</span> n = liste_faces.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>();
  <span class="keywordflow">if</span> (n &gt; 0)
    {
      <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;==========================&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
      <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Error!&quot;</span> &lt;&lt; finl &lt;&lt; <a class="code" href="Reordonner__faces__periodiques_8cpp.html#a137d78a01e63d3b66d1b2ed0de0f4c4c">message</a>
           &lt;&lt; <span class="stringliteral">&quot;\nSee log file of this PE for detailed info.&quot;</span>
           &lt;&lt; finl;
      <a class="code" href="classSortie.html" title="Classe de base des flux de sortie. Elle sait ecrire des types simples&lt;br&gt;(entiers, flottants) et des Ob...">Sortie</a>&amp; J = <a class="code" href="classProcess.html#a57e0f54b11e6eaadbea224fa904b18dd" title="Renvoie un objet statique de type Sortie qui sert de journal d&#39;evenements. Si message_level &lt;= verbose...">Process::Journal</a>();
      J &lt;&lt;  <span class="stringliteral">&quot;Error in Faces_builder::creer_faces_*\n&quot;</span>
        &lt;&lt; <a class="code" href="Reordonner__faces__periodiques_8cpp.html#a137d78a01e63d3b66d1b2ed0de0f4c4c">message</a> &lt;&lt; finl;
      <span class="keywordflow">if</span> (n &gt; nmax)
        {
          J &lt;&lt; <span class="stringliteral">&quot;Too many faces to display (&quot;</span> &lt;&lt; n &lt;&lt; <span class="stringliteral">&quot;) display only &quot;</span> &lt;&lt; nmax &lt;&lt; <span class="stringliteral">&quot; first faces&quot;</span> &lt;&lt; finl;
          n = nmax;
        }
      <span class="keywordtype">int</span> i;
      J &lt;&lt; <span class="stringliteral">&quot;Display format:\n&quot;</span>
        &lt;&lt; <span class="stringliteral">&quot; facenumber = face index in faces_sommet array\n&quot;</span>
        &lt;&lt; <span class="stringliteral">&quot; som1..som4 = node index\n&quot;</span>
        &lt;&lt; <span class="stringliteral">&quot; elem1 elem2 = neighbouring element number\n&quot;</span>
        &lt;&lt; <span class="stringliteral">&quot;facenumber som1 (x1 y1 z1) som2 (x2 y2 z2) [som3 (x3 y3 z3)...] elem1 elem2&quot;</span> &lt;&lt; finl;
      <span class="keywordtype">char</span> s[1000];
      <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; coord = <a class="code" href="classFaces__builder.html#a4da2e2efdd507fd9db4977dfad555fcf">ref_zone_</a>.<a class="code" href="classRef__Zone.html#ab4ba0de67809ff502efeb24c1e43bfe1">valeur</a>().<a class="code" href="classZone.html#a379ad2206b5a13a4f4f3df6d44c7546a" title="Renvoie le domaine dont la zone fait partie. (version const)">domaine</a>().<a class="code" href="classDomaine.html#aecd32c3eecc15cce7d1a0e468dadbf96" title="Renvoie le tableau des coordonnees des noeuds (sommets). (acces en lecture)">coord_sommets</a>();
      <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp;     faces = <a class="code" href="classFaces__builder.html#ae34616daf8a3bff24ad1673b447e3655">faces_sommets_</a>.<a class="code" href="classRef__IntTab.html#a554cc94104fea2e3e62fb5d935d46166">valeur</a>();
      <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp;     face_elem = <a class="code" href="classFaces__builder.html#ae6a50f5e178055468ccd61d1b03dd496">face_elem_</a>.<a class="code" href="classRef__IntTab.html#a554cc94104fea2e3e62fb5d935d46166">valeur</a>();
      <span class="keyword">const</span> <span class="keywordtype">int</span> dim = <a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>;
      <span class="keyword">const</span> <span class="keywordtype">int</span> nb_som_faces = faces.<a class="code" href="classIntTab.html#abc3b32c94925a82f69d5b153a356e359" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(1);
      <span class="keywordflow">for</span> (i = 0; i &lt; n; i++)
        {
          <span class="keywordtype">char</span> *sptr = s;
          <span class="keyword">const</span> <span class="keywordtype">int</span> iface = liste_faces[i];
          sptr += sprintf(sptr, <span class="stringliteral">&quot;%4ld &quot;</span>,(<span class="keywordtype">long</span>) iface);
          <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; nb_som_faces; j++)
            {
              <span class="keyword">const</span> <span class="keywordtype">int</span> isom = faces(iface,j);
              sptr += sprintf(sptr, <span class="stringliteral">&quot;%5ld(&quot;</span>, (<span class="keywordtype">long</span>)isom);
              <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k = 0; k &lt; dim; k++)
                <span class="keywordflow">if</span> (isom!=-1)
                  sptr += sprintf(sptr, <span class="stringliteral">&quot;%10.6f&quot;</span>, coord(isom, k));
              sptr += sprintf(sptr, <span class="stringliteral">&quot;)&quot;</span>);
            }
          sptr += sprintf(sptr, <span class="stringliteral">&quot;%4ld %4ld&quot;</span>, (<span class="keywordtype">long</span>)face_elem(iface,0),(<span class="keywordtype">long</span>) face_elem(iface,1));
          J &lt;&lt; s &lt;&lt; finl;
        }
      <a class="code" href="classNettoieNoeuds.html#a56b05b201015e968fead33b89f743db7" title="regarde si on n&#39;a pas des noeuds doubles">NettoieNoeuds::verifie_noeuds</a>(<a class="code" href="classFaces__builder.html#a4da2e2efdd507fd9db4977dfad555fcf">ref_zone_</a>.<a class="code" href="classRef__Zone.html#ab4ba0de67809ff502efeb24c1e43bfe1">valeur</a>().<a class="code" href="classZone.html#a379ad2206b5a13a4f4f3df6d44c7546a" title="Renvoie le domaine dont la zone fait partie. (version const)">domaine</a>());
      <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">Process::exit</a>();
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a17469d1ff2feae7d358abcccd2d67831"></a><!-- doxytag: member="Faces_builder::chercher_face_element" ref="a17469d1ff2feae7d358abcccd2d67831" args="(const IntTab &amp;les_elements, const IntTab &amp;faces_element_reference, const ArrOfInt &amp;une_face, const int elem)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Faces_builder::chercher_face_element </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIntTab.html">IntTab</a> &amp;&#160;</td>
          <td class="paramname"><em>les_elements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIntTab.html">IntTab</a> &amp;&#160;</td>
          <td class="paramname"><em>faces_element_reference</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>une_face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>elem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>&lt; si sommet trouve, stop</p>
<p>&lt; si sommet non trouve, stop</p>
<p>&lt; si tous les sommets ont ete trouves, stop</p>
<p>&lt; si face non trouvee </p>
</p>

<p>Definition at line <a class="el" href="Faces__builder_8cpp_source.html#l00325">325</a> of file <a class="el" href="Faces__builder_8cpp_source.html">Faces_builder.cpp</a>.</p>

<p>References <a class="el" href="IntTab_8h_source.html#l00233">IntTab::dimension()</a>.</p>

<p>Referenced by <a class="el" href="Raffiner__Simplexes_8cpp_source.html#l00722">build_frontier()</a>, <a class="el" href="Faces__builder_8cpp_source.html#l00396">chercher_face_element()</a>, <a class="el" href="Faces__builder_8cpp_source.html#l00414">creer_faces_frontiere()</a>, <a class="el" href="Faces__builder_8cpp_source.html#l00562">creer_faces_internes()</a>, and <a class="el" href="MaillerParallel_8cpp_source.html#l00355">find_joint_faces()</a>.</p>
<div class="fragment"><pre class="fragment">{
<span class="preprocessor">#ifdef old</span>
<span class="preprocessor"></span><span class="preprocessor">#ifndef NDEBUG</span>
<span class="preprocessor"></span>  <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> sommets_element(8);
<span class="preprocessor">#else</span>
<span class="preprocessor"></span>  <span class="keywordtype">int</span> sommets_element[8];
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span><span class="preprocessor">#endif</span>
<span class="preprocessor"></span>
  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_sommets_par_element    = elem_som.dimension(1);
  <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> sommets_element(nb_sommets_par_element);
  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_faces_element          = faces_element_ref.dimension(0);
  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_sommets_par_face       = faces_element_ref.dimension(1);
<span class="comment">// assert(nb_sommets_par_element &lt;= 8);</span>

  <span class="keywordtype">int</span> i;
  <span class="keywordflow">for</span> (i = 0; i &lt; nb_sommets_par_element; i++)
    sommets_element[i] = elem_som(elem, i);

  <span class="keywordtype">int</span> i_face, i_som, i_som2;
  <span class="keywordflow">for</span> (i_face = 0; i_face &lt; nb_faces_element; i_face++)
    {
      <span class="keywordflow">for</span> (i_som = 0; i_som &lt; nb_sommets_par_face; i_som++)
        {
          <span class="keyword">const</span> <span class="keywordtype">int</span> sommet_elem_ref = faces_element_ref(i_face, i_som);
          <span class="keywordtype">int</span> sommet_domaine ;
          <span class="keywordflow">if</span> (sommet_elem_ref==-1)
            sommet_domaine=-1;
          <span class="keywordflow">else</span>
            sommet_domaine = sommets_element[sommet_elem_ref];
<span class="comment">// const int sommet_domaine = sommets_element[sommet_elem_ref];</span>
          <span class="keywordflow">for</span> (i_som2 = 0; i_som2 &lt; nb_sommets_par_face; i_som2++)
            <span class="keywordflow">if</span> (une_face[i_som2] == sommet_domaine) <span class="comment">//!&lt; si sommet trouve, stop</span>
<span class="comment"></span>              <span class="keywordflow">break</span>;
          <span class="keywordflow">if</span> (i_som2 == nb_sommets_par_face) <span class="comment">//!&lt; si sommet non trouve, stop</span>
<span class="comment"></span>            <span class="keywordflow">break</span>;
        }
      <span class="keywordflow">if</span> (i_som == nb_sommets_par_face) <span class="comment">//!&lt; si tous les sommets ont ete trouves, stop</span>
<span class="comment"></span>        <span class="keywordflow">break</span>;
    }
  <span class="keywordflow">if</span> (i_face == nb_faces_element) <span class="comment">//!&lt; si face non trouvee</span>
<span class="comment"></span>    <span class="keywordflow">return</span> -1;
  <span class="keywordflow">else</span>
    <span class="keywordflow">return</span> i_face;
}
</pre></div>
</div>
</div>
<a class="anchor" id="ab381d2766eda537c836a664eff17f0d8"></a><!-- doxytag: member="Faces_builder::chercher_face_element" ref="ab381d2766eda537c836a664eff17f0d8" args="(const ArrOfInt &amp;une_face, const int elem) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Faces_builder::chercher_face_element </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>une_face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>elem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Methode outil: on suppose que "une_face" contient les indices<br/>
des sommets d'une face de l'element d'indice "elem" dans la zone.<br/>
On cherche quel est le numero de cette face sur l'element<br/>
de reference. Si les sommets ne correspondent a aucune face de<br/>
l'element, on renvoie -1. </p>

<p>Definition at line <a class="el" href="Faces__builder_8cpp_source.html#l00396">396</a> of file <a class="el" href="Faces__builder_8cpp_source.html">Faces_builder.cpp</a>.</p>

<p>References <a class="el" href="Faces__builder_8cpp_source.html#l00325">chercher_face_element()</a>, <a class="el" href="Faces__builder_8cpp_source.html#l00374">faces_element_reference()</a>, and <a class="el" href="Faces__builder_8h_source.html#l00073">les_elements()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; elem_som                = <a class="code" href="classFaces__builder.html#a30ad4fbd88a8069b4cfd093d1da1116c">les_elements</a>();
  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; faces_element_ref       = <a class="code" href="classFaces__builder.html#aa173ce9252eff3fb6981b4c199137c32" title="redonne les faces pour un element, dans le cas des polyhedres cela depend du numero de l&#39;element...">faces_element_reference</a>(elem);
  <span class="keywordtype">int</span> i_face = <a class="code" href="classFaces__builder.html#a17469d1ff2feae7d358abcccd2d67831">chercher_face_element</a>(elem_som, faces_element_ref, une_face, elem);
  <span class="keywordflow">return</span> i_face;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a8a270bd6890413328324bb1506709106"></a><!-- doxytag: member="Faces_builder::connectivite_som_elem" ref="a8a270bd6890413328324bb1506709106" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classStatic__Int__Lists.html">Static_Int_Lists</a>&amp; Faces_builder::connectivite_som_elem </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Faces__builder_8h_source.html#l00077">77</a> of file <a class="el" href="Faces__builder_8h_source.html">Faces_builder.h</a>.</p>

<p>References <a class="el" href="Faces__builder_8h_source.html#l00090">connectivite_som_elem_ptr_</a>.</p>

<p>Referenced by <a class="el" href="Faces__builder_8cpp_source.html#l00414">creer_faces_frontiere()</a>, and <a class="el" href="Faces__builder_8cpp_source.html#l00562">creer_faces_internes()</a>.</p>
<div class="fragment"><pre class="fragment">  {
    <span class="keywordflow">return</span> *<a class="code" href="classFaces__builder.html#a63465157f176a5ff77aba327d5438f14">connectivite_som_elem_ptr_</a>;
  };
</pre></div>
</div>
</div>
<a class="anchor" id="a451a0948864cba2c5cc5022a2013c83c"></a><!-- doxytag: member="Faces_builder::creer_faces_frontiere" ref="a451a0948864cba2c5cc5022a2013c83c" args="(const int nb_voisins_attendus, Frontiere &amp;frontiere, IntTab &amp;faces_sommets, IntTab &amp;faces_voisins, IntTab &amp;elem_faces) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Faces_builder::creer_faces_frontiere </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>nb_voisins_attendus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classFrontiere.html">Frontiere</a> &amp;&#160;</td>
          <td class="paramname"><em>frontiere</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classIntTab.html">IntTab</a> &amp;&#160;</td>
          <td class="paramname"><em>faces_sommets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classIntTab.html">IntTab</a> &amp;&#160;</td>
          <td class="paramname"><em>faces_voisins</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classIntTab.html">IntTab</a> &amp;&#160;</td>
          <td class="paramname"><em>elem_faces</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Insere les faces de la frontiere donnee dans les trois tableaux,<br/>
a la suite des faces deja presentes dans faces_sommets.<br/>
Remplissage de :<br/>
frontiere.num_premiere_face<br/>
Completion de :<br/>
faces_sommets<br/>
elem_faces<br/>
faces_voisins. </p>

<p>Definition at line <a class="el" href="Faces__builder_8cpp_source.html#l00414">414</a> of file <a class="el" href="Faces__builder_8cpp_source.html">Faces_builder.cpp</a>.</p>

<p>References <a class="el" href="Faces__builder_8cpp_source.html#l00302">ajouter_une_face()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00355">ArrOfInt::append_array()</a>, <a class="el" href="Faces__builder_8cpp_source.html#l00248">check_erreur_faces()</a>, <a class="el" href="Faces__builder_8cpp_source.html#l00325">chercher_face_element()</a>, <a class="el" href="Faces__builder_8h_source.html#l00077">connectivite_som_elem()</a>, <a class="el" href="IntTab_8h_source.html#l00233">IntTab::dimension()</a>, <a class="el" href="Frontiere_8h_source.html#l00175">Frontiere::faces()</a>, <a class="el" href="Faces__builder_8cpp_source.html#l00374">faces_element_reference()</a>, <a class="el" href="Connectivite__som__elem_8cpp_source.html#l00108">find_adjacent_elements()</a>, <a class="el" href="Frontiere_8h_source.html#l00212">Frontiere::fixer_num_premiere_face()</a>, <a class="el" href="Frontiere_8h_source.html#l00155">Frontiere::le_nom()</a>, <a class="el" href="Faces_8h_source.html#l00268">Faces::les_sommets()</a>, <a class="el" href="Double_8h_source.html#l00199">min()</a>, <a class="el" href="Faces_8h_source.html#l00152">Faces::nb_faces()</a>, <a class="el" href="ArrOfInt_8cpp_source.html#l00443">ArrOfInt::set_smart_resize()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00342">ArrOfInt::size_array()</a>, and <a class="el" href="Cast_8h_source.html#l00054">sub_type</a>.</p>

<p>Referenced by <a class="el" href="Faces__builder_8cpp_source.html#l00070">creer_faces_reeles()</a>.</p>
<div class="fragment"><pre class="fragment">{
  assert(nb_voisins_attendus == 1 || nb_voisins_attendus == 2);

  <span class="keyword">const</span> <a class="code" href="classStatic__Int__Lists.html" title="Cette classe permet de stocker des listes d&#39;entiers accessibles en temps constant. La taille des listes ne peut pas changer sans perdre le contenu (ce sont des listes statiques). Exemple: Static_Int_List l; ArrOfInt tailles(3); tailles[0] = 2; tailles[1] = 3; tailles[2] = 0; // On reserve la memoire pour trois listes de taille 2, 3 et 0: l.set_list_sizes(tailles); // On affecte une valeur au deuxieme element de la premiere liste: l.set_value(0,1,765); // Affiche la valeur Cout &lt;&lt; l(0,1);.">Static_Int_Lists</a>&amp; som_elem   = <a class="code" href="classFaces__builder.html#a8a270bd6890413328324bb1506709106">connectivite_som_elem</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span>   nb_sommets_par_face  = <a class="code" href="classFaces__builder.html#aa173ce9252eff3fb6981b4c199137c32" title="redonne les faces pour un element, dans le cas des polyhedres cela depend du numero de l&#39;element...">faces_element_reference</a>(0).<a class="code" href="classIntTab.html#abc3b32c94925a82f69d5b153a356e359" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(0) ? <a class="code" href="classFaces__builder.html#aa173ce9252eff3fb6981b4c199137c32" title="redonne les faces pour un element, dans le cas des polyhedres cela depend du numero de l&#39;element...">faces_element_reference</a>(0).<a class="code" href="classIntTab.html#abc3b32c94925a82f69d5b153a356e359" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(1) : 3;
  <span class="keyword">const</span> <span class="keywordtype">int</span>   num_premiere_face    = faces_sommets.<a class="code" href="classIntTab.html#abc3b32c94925a82f69d5b153a356e359" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(0);
  <span class="keyword">const</span> <span class="keywordtype">int</span>   nb_elem_reels        = elem_faces.<a class="code" href="classIntTab.html#abc3b32c94925a82f69d5b153a356e359" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(0);
  frontiere.<a class="code" href="classFrontiere.html#a66cbd407fb5a1611b9aca04bddd0f6e0">fixer_num_premiere_face</a>(num_premiere_face);

  <span class="keyword">const</span> <a class="code" href="classFaces.html" title="enum Type_Face Les differents types geometriques de faces.">Faces</a>&amp;   faces_frontiere  = frontiere.<a class="code" href="classFrontiere.html#ac64479069f0c43a17cb5766a39ce5ba8" title="Renvoie les faces de la frontiere&lt;br&gt;(version const)">faces</a>();
  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; sommets_faces_fr = faces_frontiere.<a class="code" href="classFaces.html#a07b8d8db9e3d656b93a21a49c063430c">les_sommets</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span>   nb_faces         = faces_frontiere.<a class="code" href="classFaces.html#a64d898edb20c3687d357018f1821c50a" title="Renvoie le nombre de Faces.">nb_faces</a>();
  <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>       une_face(nb_sommets_par_face);
  <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>       voisins;
  voisins.<a class="code" href="classArrOfInt.html#a22d744bcd452d039580d1d9186f02b4e" title="Change le mode l&#39;allocation memoire: reallocation d&#39;un tableau a chaque changement de taille (flag = ...">set_smart_resize</a>(1);
  <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> liste_faces_erreur0;
  liste_faces_erreur0.<a class="code" href="classArrOfInt.html#a22d744bcd452d039580d1d9186f02b4e" title="Change le mode l&#39;allocation memoire: reallocation d&#39;un tableau a chaque changement de taille (flag = ...">set_smart_resize</a>(1);
  <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> liste_faces_erreur1;
  liste_faces_erreur1.<a class="code" href="classArrOfInt.html#a22d744bcd452d039580d1d9186f02b4e" title="Change le mode l&#39;allocation memoire: reallocation d&#39;un tableau a chaque changement de taille (flag = ...">set_smart_resize</a>(1);
  <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> liste_faces_erreur2;
  liste_faces_erreur2.<a class="code" href="classArrOfInt.html#a22d744bcd452d039580d1d9186f02b4e" title="Change le mode l&#39;allocation memoire: reallocation d&#39;un tableau a chaque changement de taille (flag = ...">set_smart_resize</a>(1);
  <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> liste_faces_erreur3;
  liste_faces_erreur3.<a class="code" href="classArrOfInt.html#a22d744bcd452d039580d1d9186f02b4e" title="Change le mode l&#39;allocation memoire: reallocation d&#39;un tableau a chaque changement de taille (flag = ...">set_smart_resize</a>(1);

  <span class="keywordtype">int</span> i_face;
  <span class="keywordflow">for</span> (i_face = 0; i_face &lt; nb_faces; i_face++)
    {
      {
        <span class="keywordtype">int</span> nb_sommets_par_face_fr=sommets_faces_fr.<a class="code" href="classIntTab.html#abc3b32c94925a82f69d5b153a356e359" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(1);
        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; <a class="code" href="Double_8h.html#a2f8edc4561e9744ed4233b205fa7ec32">min</a>(nb_sommets_par_face, nb_sommets_par_face_fr); i++)
          une_face[i] = sommets_faces_fr(i_face, i);
        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = <a class="code" href="Double_8h.html#a2f8edc4561e9744ed4233b205fa7ec32">min</a>(nb_sommets_par_face, nb_sommets_par_face_fr); i &lt; nb_sommets_par_face; i++)
          une_face[i] = -1;
      }
<span class="comment">// Quels sont les elements voisins de cette face ?</span>
      <a class="code" href="Connectivite__som__elem_8cpp.html#afccbadf5344a16154a56b33dbddf88c1" title="Cherche les elements qui contiennent tous les sommets du tableau sommets_to_find (permet de trouver l...">find_adjacent_elements</a>(som_elem, une_face, voisins);
      <span class="keyword">const</span> <span class="keywordtype">int</span> nb_voisins = voisins.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>();
      <span class="keyword">const</span> <span class="keywordtype">int</span> elem0 = (nb_voisins &gt; 0) ? voisins[0] : -1;
      <span class="keyword">const</span> <span class="keywordtype">int</span> elem1 = (nb_voisins &gt; 1) ? voisins[1] : -1;
      <span class="keyword">const</span> <span class="keywordtype">int</span> indice_face =
        <a class="code" href="classFaces__builder.html#aacc718530a516ea356626f074b9e6bdc" title="ajoute une face reelle dans faces_sommets et faces_voisins.">ajouter_une_face</a>(une_face, elem0, elem1, faces_sommets, faces_voisins);

      <span class="keywordflow">switch</span>(nb_voisins)
        {
        <span class="keywordflow">case</span> 0:
          {
<span class="comment">// Erreur: la face n&#39;a pas de voisin</span>
            liste_faces_erreur0.<a class="code" href="classArrOfInt.html#a3f39d0966599416e7b1f7cd8159d8d01" title="Ajoute une case en fin de tableau et y stocke la &quot;valeur&quot;.">append_array</a>(indice_face);
            <span class="keywordflow">break</span>;
          }
        <span class="keywordflow">case</span> 1:
        <span class="keywordflow">case</span> 2:
          {
            <span class="keywordflow">if</span> (nb_voisins_attendus == nb_voisins)
              {
                <span class="keywordtype">int</span> i_voisin;
                <span class="keywordflow">for</span> (i_voisin = 0; i_voisin &lt; nb_voisins; i_voisin++)
                  {
                    <span class="keyword">const</span> <span class="keywordtype">int</span> elem = voisins[i_voisin];
<span class="comment">// Quelle est la face de l&#39;element ?</span>
                    <span class="keyword">const</span> <span class="keywordtype">int</span> i_face_elem = <a class="code" href="classFaces__builder.html#a17469d1ff2feae7d358abcccd2d67831">chercher_face_element</a>(une_face, elem);
                    <span class="keywordflow">if</span> (i_face_elem &gt;= 0)
                      {
<span class="comment">// Si c&#39;est un element reel, on associe la face</span>
                        <span class="keywordflow">if</span> (elem &lt; nb_elem_reels)
                          {
                            <span class="keywordflow">if</span> (elem_faces(elem, i_face_elem) &lt; 0)
                              {
                                elem_faces(elem, i_face_elem) = indice_face;
                              }
                            <span class="keywordflow">else</span>
                              {
<span class="comment">// Erreur: cette face existe deja (dans cette frontiere ou une autre)</span>
                                liste_faces_erreur3.<a class="code" href="classArrOfInt.html#a3f39d0966599416e7b1f7cd8159d8d01" title="Ajoute une case en fin de tableau et y stocke la &quot;valeur&quot;.">append_array</a>(indice_face);
                              }
                          }
                      }
                    <span class="keywordflow">else</span>
                      {
<span class="comment">// Erreur: la face n&#39;est pas une face de l&#39;element.</span>
                        liste_faces_erreur0.<a class="code" href="classArrOfInt.html#a3f39d0966599416e7b1f7cd8159d8d01" title="Ajoute une case en fin de tableau et y stocke la &quot;valeur&quot;.">append_array</a>(indice_face);
                      }
                  }
              }
            <span class="keywordflow">else</span>
              {
<span class="comment">// Erreur, on attendait pas ce nombre de voisins.</span>
                liste_faces_erreur1.<a class="code" href="classArrOfInt.html#a3f39d0966599416e7b1f7cd8159d8d01" title="Ajoute une case en fin de tableau et y stocke la &quot;valeur&quot;.">append_array</a>(indice_face);
              }
            <span class="keywordflow">break</span>;
          }
        <span class="keywordflow">default</span>:
<span class="comment">// Erreur, plus de deux voisins, c&#39;est n&#39;importe quoi...</span>
          liste_faces_erreur2.<a class="code" href="classArrOfInt.html#a3f39d0966599416e7b1f7cd8159d8d01" title="Ajoute une case en fin de tableau et y stocke la &quot;valeur&quot;.">append_array</a>(indice_face);
        }
    }
  <a class="code" href="classNom.html" title="class Nom Une chaine de caractere pour nommer les objets de TRUST">Nom</a> msg;
  msg = <span class="stringliteral">&quot;Boundary \&quot;&quot;</span>;
  msg += frontiere.<a class="code" href="classFrontiere.html#a2868774681d6f050479a95cbc7cd6fc9" title="Renvoie le nom de la frontiere.">le_nom</a>();
  msg += <span class="stringliteral">&quot;\&quot; contains faces which do not belong to any element.&quot;</span>;
  <a class="code" href="classFaces__builder.html#a2a1241fa1f4adf443332bd7440e9472f" title="methode outil pour creer_faces_frontiere et creer_faces_internes (si liste non vide sur au moins un p...">check_erreur_faces</a>(msg, liste_faces_erreur0);

  msg = <span class="stringliteral">&quot;Boundary \&quot;&quot;</span>;
  msg += frontiere.<a class="code" href="classFrontiere.html#a2868774681d6f050479a95cbc7cd6fc9" title="Renvoie le nom de la frontiere.">le_nom</a>();
  msg += <span class="stringliteral">&quot;\&quot; contains faces that belong to &quot;</span>;
  msg += <a class="code" href="classNom.html" title="class Nom Une chaine de caractere pour nommer les objets de TRUST">Nom</a>(3-nb_voisins_attendus);
  msg += <span class="stringliteral">&quot; elements.\n&quot;</span>;
  <span class="keywordflow">switch</span>(nb_voisins_attendus)
    {
    <span class="keywordflow">case</span> 1:
      msg += <span class="stringliteral">&quot;These faces should have only 1 neighbouring element.&quot;</span>;
      <span class="keywordflow">break</span>;
    <span class="keywordflow">case</span> 2:
      msg += <span class="stringliteral">&quot;These faces should have 2 neighbouring elements.&quot;</span>;
      <span class="keywordflow">break</span>;
    <span class="keywordflow">default</span>:
      msg = <span class="stringliteral">&quot;Internal error.&quot;</span>;
    }
  <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classJoint.html" title="La classe Joint est une Frontiere qui contient les faces et les sommets de joint avec la zone PEvoisi...">Joint</a>, frontiere))
    {
<span class="comment">// Deux sources d&#39;erreur possibles: les faces de joint sont fausses</span>
<span class="comment">// ou bien la zone ne contient pas les elements virtuels (il faut</span>
<span class="comment">// au moins que la zone contienne les elements virtuels voisins des</span>
<span class="comment">// faces de joint).</span>
      msg += <span class="stringliteral">&quot;(Error in a Joint object: internal error in the mesh splitter or scatter ? )\n&quot;</span>;
    }
  <a class="code" href="classFaces__builder.html#a2a1241fa1f4adf443332bd7440e9472f" title="methode outil pour creer_faces_frontiere et creer_faces_internes (si liste non vide sur au moins un p...">check_erreur_faces</a>(msg, liste_faces_erreur1);

  msg = <span class="stringliteral">&quot;Boundary \&quot;&quot;</span>;
  msg += frontiere.<a class="code" href="classFrontiere.html#a2868774681d6f050479a95cbc7cd6fc9" title="Renvoie le nom de la frontiere.">le_nom</a>();
  msg += <span class="stringliteral">&quot;\&quot; contains faces that belong to more than 2 elements.\n&quot;</span>;
  <a class="code" href="classFaces__builder.html#a2a1241fa1f4adf443332bd7440e9472f" title="methode outil pour creer_faces_frontiere et creer_faces_internes (si liste non vide sur au moins un p...">check_erreur_faces</a>(msg, liste_faces_erreur2);

  msg = <span class="stringliteral">&quot;Boundary \&quot;&quot;</span>;
  msg += frontiere.<a class="code" href="classFrontiere.html#a2868774681d6f050479a95cbc7cd6fc9" title="Renvoie le nom de la frontiere.">le_nom</a>();
  msg += <span class="stringliteral">&quot;\&quot; contains faces that already exist in another boundary or in this one.\n&quot;</span>;
  <a class="code" href="classFaces__builder.html#a2a1241fa1f4adf443332bd7440e9472f" title="methode outil pour creer_faces_frontiere et creer_faces_internes (si liste non vide sur au moins un p...">check_erreur_faces</a>(msg, liste_faces_erreur3);
}
</pre></div>
</div>
</div>
<a class="anchor" id="ae52612e6c9aff57afbe490c910930516"></a><!-- doxytag: member="Faces_builder::creer_faces_internes" ref="ae52612e6c9aff57afbe490c910930516" args="(IntTab &amp;faces_sommets, IntTab &amp;elem_faces, IntTab &amp;faces_voisins) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Faces_builder::creer_faces_internes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classIntTab.html">IntTab</a> &amp;&#160;</td>
          <td class="paramname"><em>faces_sommets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classIntTab.html">IntTab</a> &amp;&#160;</td>
          <td class="paramname"><em>elem_faces</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classIntTab.html">IntTab</a> &amp;&#160;</td>
          <td class="paramname"><em>faces_voisins</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construction des faces interieures au domaine<br/>
(faces qui ont deux voisins et qui ne sont pas des "faces_bord_internes")<br/>
Les faces de joint ont deja ete creees. </p>

<p><p>&lt; Il devrait au moins y avoir i_elem !!! (ou alors on a une face constitues de -1);</p>
<p>&lt; ***** La face a 1 voisin ********</p>
<p>&lt; L'element voisin est forcement i_elem Une face ayant un seul element voisin est une face de frontiere.</p>
<p>&lt; ***** La face a 2 voisins ********</p>
<p>&lt; Element voisin reel ?</p>
<p>&lt; ***** La face a &gt; 2 voisins ******** </p>
</p>

<p>Definition at line <a class="el" href="Faces__builder_8cpp_source.html#l00562">562</a> of file <a class="el" href="Faces__builder_8cpp_source.html">Faces_builder.cpp</a>.</p>

<p>References <a class="el" href="Faces__builder_8cpp_source.html#l00302">ajouter_une_face()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00355">ArrOfInt::append_array()</a>, <a class="el" href="Faces__builder_8cpp_source.html#l00248">check_erreur_faces()</a>, <a class="el" href="Faces__builder_8cpp_source.html#l00325">chercher_face_element()</a>, <a class="el" href="Faces__builder_8h_source.html#l00077">connectivite_som_elem()</a>, <a class="el" href="IntTab_8h_source.html#l00233">IntTab::dimension()</a>, <a class="el" href="Faces__builder_8cpp_source.html#l00374">faces_element_reference()</a>, <a class="el" href="Connectivite__som__elem_8cpp_source.html#l00108">find_adjacent_elements()</a>, <a class="el" href="Faces__builder_8h_source.html#l00073">les_elements()</a>, <a class="el" href="ArrOfInt_8cpp_source.html#l00443">ArrOfInt::set_smart_resize()</a>, and <a class="el" href="ArrOfInt_8h_source.html#l00342">ArrOfInt::size_array()</a>.</p>

<p>Referenced by <a class="el" href="Faces__builder_8cpp_source.html#l00070">creer_faces_reeles()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; elem_som             = <a class="code" href="classFaces__builder.html#a30ad4fbd88a8069b4cfd093d1da1116c">les_elements</a>();
  <span class="keyword">const</span> <a class="code" href="classStatic__Int__Lists.html" title="Cette classe permet de stocker des listes d&#39;entiers accessibles en temps constant. La taille des listes ne peut pas changer sans perdre le contenu (ce sont des listes statiques). Exemple: Static_Int_List l; ArrOfInt tailles(3); tailles[0] = 2; tailles[1] = 3; tailles[2] = 0; // On reserve la memoire pour trois listes de taille 2, 3 et 0: l.set_list_sizes(tailles); // On affecte une valeur au deuxieme element de la premiere liste: l.set_value(0,1,765); // Affiche la valeur Cout &lt;&lt; l(0,1);.">Static_Int_Lists</a>&amp; som_elem   = <a class="code" href="classFaces__builder.html#a8a270bd6890413328324bb1506709106">connectivite_som_elem</a>();
<span class="comment">// const IntTab &amp; faces_elem_ref       = faces_element_reference();</span>
  <span class="keyword">const</span> <span class="keywordtype">int</span>   nb_elem              = elem_som.<a class="code" href="classIntTab.html#abc3b32c94925a82f69d5b153a356e359" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(0);
  <span class="keyword">const</span> <span class="keywordtype">int</span>   nb_faces_par_element = <a class="code" href="classFaces__builder.html#aa173ce9252eff3fb6981b4c199137c32" title="redonne les faces pour un element, dans le cas des polyhedres cela depend du numero de l&#39;element...">faces_element_reference</a>(0).<a class="code" href="classIntTab.html#abc3b32c94925a82f69d5b153a356e359" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(0);
  <span class="keyword">const</span> <span class="keywordtype">int</span>   nb_sommets_par_face  = nb_faces_par_element ? <a class="code" href="classFaces__builder.html#aa173ce9252eff3fb6981b4c199137c32" title="redonne les faces pour un element, dans le cas des polyhedres cela depend du numero de l&#39;element...">faces_element_reference</a>(0).<a class="code" href="classIntTab.html#abc3b32c94925a82f69d5b153a356e359" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(1) : 3;

<span class="comment">// Tableau temporaire dans lequel on stocke les indices des sommets</span>
<span class="comment">// de la face en cours de traitement</span>
  <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> une_face(nb_sommets_par_face);
<span class="comment">// Tableau temporaire (liste des elements voisins d&#39;une face)</span>
  <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> voisins;
  voisins.<a class="code" href="classArrOfInt.html#a22d744bcd452d039580d1d9186f02b4e" title="Change le mode l&#39;allocation memoire: reallocation d&#39;un tableau a chaque changement de taille (flag = ...">set_smart_resize</a>(1);
<span class="comment">// Liste des faces n&#39;ayant qu&#39;un seul voisin et qui ne figurent pas</span>
<span class="comment">// dans les faces de bord (ce sont des erreurs):</span>
  <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> liste_faces_frontiere_non_declarees;
  liste_faces_frontiere_non_declarees.<a class="code" href="classArrOfInt.html#a22d744bcd452d039580d1d9186f02b4e" title="Change le mode l&#39;allocation memoire: reallocation d&#39;un tableau a chaque changement de taille (flag = ...">set_smart_resize</a>(1);
  <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> liste_faces_joint_non_declarees;
  liste_faces_joint_non_declarees.<a class="code" href="classArrOfInt.html#a22d744bcd452d039580d1d9186f02b4e" title="Change le mode l&#39;allocation memoire: reallocation d&#39;un tableau a chaque changement de taille (flag = ...">set_smart_resize</a>(1);
<span class="comment">// Liste des faces presentant une erreur de connectivite (plus de</span>
<span class="comment">// deux elements voisins, ou connection a des sommets qui ne</span>
<span class="comment">// sont pas une face de l&#39;element:</span>
  <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> liste_faces_erreurs_connectivite;
  liste_faces_erreurs_connectivite.<a class="code" href="classArrOfInt.html#a22d744bcd452d039580d1d9186f02b4e" title="Change le mode l&#39;allocation memoire: reallocation d&#39;un tableau a chaque changement de taille (flag = ...">set_smart_resize</a>(1);

<span class="comment">// Boucle sur les elements</span>
  <span class="keywordtype">int</span> i_elem;
  <span class="keywordflow">for</span> (i_elem = 0; i_elem &lt; nb_elem; i_elem++)
    {
      <span class="keywordtype">int</span> i_face;
<span class="comment">// Boucle sur les faces de l&#39;element</span>
      <span class="keywordflow">for</span> (i_face = 0; i_face &lt; nb_faces_par_element; i_face++)
        {

<span class="comment">// L&#39;indice de cette face dans le tableau faces_sommets.</span>
<span class="comment">// Il vaut -1 si la face n&#39;a pas encore ete creee,</span>
          <span class="keywordtype">int</span> indice_face = elem_faces(i_elem, i_face);

<span class="comment">// Calcul des indices des sommets de la face dans le domaine:</span>
          <span class="keywordtype">int</span> i;
<span class="comment">// Attention il ne faut laisser l&#39;appel ici...</span>
          <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; faces_elem_ref       = <a class="code" href="classFaces__builder.html#aa173ce9252eff3fb6981b4c199137c32" title="redonne les faces pour un element, dans le cas des polyhedres cela depend du numero de l&#39;element...">faces_element_reference</a>(i_elem);

          <span class="keywordflow">for</span> (i = 0; i &lt; nb_sommets_par_face; i++)
            {
<span class="comment">// indice du sommet sur l&#39;element de reference</span>
              <span class="keyword">const</span> <span class="keywordtype">int</span> i_som_ref = faces_elem_ref(i_face, i);
<span class="comment">// indice du sommet dans le domaine</span>
              <span class="keywordflow">if</span> (i_som_ref==-1)
                une_face[i] = -1;
              <span class="keywordflow">else</span>
                {
                  <span class="keyword">const</span> <span class="keywordtype">int</span> i_som = elem_som(i_elem, i_som_ref);
                  une_face[i] = i_som;
                }
            }
          <span class="keywordflow">if</span> (une_face[0]==-1)
            {
<span class="comment">// on a une face bidon on ne fait rien</span>
              elem_faces(i_elem, i_face) = -1;
            }
          <span class="keywordflow">else</span>
            {
<span class="comment">// Recherche des elements voisins de cette face.</span>
<span class="comment">// Le tableau &quot;voisins&quot; est classe dans l&#39;ordre croissant.</span>
              <a class="code" href="Connectivite__som__elem_8cpp.html#afccbadf5344a16154a56b33dbddf88c1" title="Cherche les elements qui contiennent tous les sommets du tableau sommets_to_find (permet de trouver l...">find_adjacent_elements</a>(som_elem, une_face, voisins);

              <span class="keyword">const</span> <span class="keywordtype">int</span> nb_voisins = voisins.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>();
              assert (nb_voisins &gt; 0); <span class="comment">//!&lt; Il devrait au moins y avoir i_elem !!! (ou alors on a une face constitues de -1);</span>
<span class="comment"></span>
              <span class="keywordflow">if</span> (nb_voisins == 1)   <span class="comment">//!&lt; ***** La face a 1 voisin ********</span>
<span class="comment"></span>                {

                  assert(voisins[0] == i_elem); <span class="comment">//!&lt; L&#39;element voisin est forcement i_elem Une face ayant un seul element voisin est une face de frontiere.</span>
<span class="comment"></span><span class="comment">//</span>
                  <span class="keywordflow">if</span> (indice_face &gt;= 0)
                    {
<span class="comment">// Ok, c&#39;est normal, les frontieres ont deja ete traitees</span>
                    }
                  <span class="keywordflow">else</span>
                    {
<span class="comment">// Erreur: la face n&#39;existe pas encore. Elle devrait avoir ete</span>
<span class="comment">// creee a partir des frontieres (creer_faces_frontiere)</span>
                      indice_face = <a class="code" href="classFaces__builder.html#aacc718530a516ea356626f074b9e6bdc" title="ajoute une face reelle dans faces_sommets et faces_voisins.">ajouter_une_face</a>(une_face, i_elem, -1,
                                                     faces_sommets, faces_voisins);
                      liste_faces_frontiere_non_declarees.<a class="code" href="classArrOfInt.html#a3f39d0966599416e7b1f7cd8159d8d01" title="Ajoute une case en fin de tableau et y stocke la &quot;valeur&quot;.">append_array</a>(indice_face);
                    }

                }
              <span class="keywordflow">else</span> <span class="keywordflow">if</span> (nb_voisins == 2)     <span class="comment">//!&lt; ***** La face a 2 voisins ********</span>
<span class="comment"></span>                {

                  <span class="keyword">const</span> <span class="keywordtype">int</span> elem0 = voisins[0];
                  <span class="keyword">const</span> <span class="keywordtype">int</span> elem1 = voisins[1];
                  assert(elem0 &lt; elem1);
                  <span class="keywordflow">if</span> (indice_face &gt;= 0)
                    {
<span class="comment">// La face a deje ete creee.</span>
                    }
                  <span class="keywordflow">else</span>
                    {
<span class="comment">// La face n&#39;existe pas encore.</span>
                      <span class="keywordflow">if</span> (elem0 == i_elem)
                        {
<span class="comment">// Les voisins sont classes: elem0 &lt; elem1</span>
<span class="comment">// donc c&#39;est la premiere fois qu&#39;on parcourt cette face dans la boucle</span>
<span class="comment">// sur les elements.</span>
                          indice_face = <a class="code" href="classFaces__builder.html#aacc718530a516ea356626f074b9e6bdc" title="ajoute une face reelle dans faces_sommets et faces_voisins.">ajouter_une_face</a>(une_face, elem0, elem1,
                                                         faces_sommets, faces_voisins);

<span class="comment">// Ou est cette face sur l&#39;element voisin ?</span>
                          <span class="keyword">const</span> <span class="keywordtype">int</span> i_face_elem1 = <a class="code" href="classFaces__builder.html#a17469d1ff2feae7d358abcccd2d67831">chercher_face_element</a>(une_face, elem1);
                          <span class="keywordflow">if</span> (i_face_elem1 &gt;= 0)
                            {
                              <span class="keywordflow">if</span> (elem1 &lt; nb_elem) <span class="comment">//!&lt; Element voisin reel ?</span>
<span class="comment"></span>                                elem_faces(elem1, i_face_elem1) = indice_face;
                            }
                          <span class="keywordflow">else</span>
                            {
<span class="comment">// Erreur, les sommets de la face sont des sommets de l&#39;element elem1</span>
<span class="comment">// mais ne sont pas sur une face de cet element. Erreur de</span>
<span class="comment">// connectivite du maillage.</span>
                              liste_faces_erreurs_connectivite.<a class="code" href="classArrOfInt.html#a3f39d0966599416e7b1f7cd8159d8d01" title="Ajoute une case en fin de tableau et y stocke la &quot;valeur&quot;.">append_array</a>(indice_face);
                            }
                          <span class="keywordflow">if</span> (elem1 &gt;= nb_elem)
                            {
<span class="comment">// Erreur : le voisin est un element virtuel, cette face</span>
<span class="comment">// devrait etre dans les faces de joint, donc deja creee.</span>
                              liste_faces_joint_non_declarees.<a class="code" href="classArrOfInt.html#a3f39d0966599416e7b1f7cd8159d8d01" title="Ajoute une case en fin de tableau et y stocke la &quot;valeur&quot;.">append_array</a>(indice_face);
                            }
                        }
                      <span class="keywordflow">else</span>
                        {
                          assert(elem1 == i_elem);
                          indice_face = <a class="code" href="classFaces__builder.html#aacc718530a516ea356626f074b9e6bdc" title="ajoute une face reelle dans faces_sommets et faces_voisins.">ajouter_une_face</a>(une_face, elem0, elem1,
                                                         faces_sommets, faces_voisins);
<span class="comment">// On aurait deja du creer cette face car elle est voisine de elem0</span>
<span class="comment">// qui est deja traite (indice plus petit). Si on arrive ici,</span>
<span class="comment">// c&#39;est que les sommets de &quot;une_face&quot; appartiennent bien a l&#39;elem0,</span>
<span class="comment">// mais qu&#39;ils ne sont pas sur une face de cet element. C&#39;est une</span>
<span class="comment">// erreur de connectivite.</span>
                          liste_faces_erreurs_connectivite.<a class="code" href="classArrOfInt.html#a3f39d0966599416e7b1f7cd8159d8d01" title="Ajoute une case en fin de tableau et y stocke la &quot;valeur&quot;.">append_array</a>(indice_face);
                        }
                    }

                }
              <span class="keywordflow">else</span>                        <span class="comment">//!&lt; ***** La face a &gt; 2 voisins ********</span>
<span class="comment"></span>                {
                  <span class="keywordflow">if</span> (indice_face &lt; 0)
                    {
                      <span class="keyword">const</span> <span class="keywordtype">int</span> elem0 = voisins[0];
                      <span class="keyword">const</span> <span class="keywordtype">int</span> elem1 = voisins[1];
                      indice_face = <a class="code" href="classFaces__builder.html#aacc718530a516ea356626f074b9e6bdc" title="ajoute une face reelle dans faces_sommets et faces_voisins.">ajouter_une_face</a>(une_face, elem0, elem1,
                                                     faces_sommets, faces_voisins);
                    }
                  liste_faces_erreurs_connectivite.<a class="code" href="classArrOfInt.html#a3f39d0966599416e7b1f7cd8159d8d01" title="Ajoute une case en fin de tableau et y stocke la &quot;valeur&quot;.">append_array</a>(indice_face);
                }

<span class="comment">// Si la face n&#39;existait pas, on l&#39;a creee et on a mis son indice</span>
<span class="comment">// dans indice_face. Sinon on a trouve l&#39;indice de la face existante.</span>
              assert(indice_face &gt;= 0);
              elem_faces(i_elem, i_face) = indice_face; <span class="comment">/* WRITE elem_faces */</span>
            }
        }
    }

<span class="comment">// Traitement des erreurs:</span>
  {
    <span class="keyword">const</span> <span class="keywordtype">char</span> * <span class="keyword">const</span> msg1 = <span class="stringliteral">&quot;We found faces which belong to one element/cell only and are not declared in any boundary ! You forgot to define at least one boundary in your mesh. Fix your mesh.\n&quot;</span>;
    <span class="keyword">const</span> <span class="keywordtype">char</span> * <span class="keyword">const</span> msg2 = <span class="stringliteral">&quot;Joint faces are incomplete: internal error in the mesh splitter\n&quot;</span>;
    <span class="keyword">const</span> <span class="keywordtype">char</span> * <span class="keyword">const</span> msg3 = <span class="stringliteral">&quot;Connectivity error in the mesh elements. Possible errors:\n- one face of one element belongs to more than 2 elements\n- two element have at least 3 common nodes but these nodes are not faces of these elements\n&quot;</span>;
    <a class="code" href="classFaces__builder.html#a2a1241fa1f4adf443332bd7440e9472f" title="methode outil pour creer_faces_frontiere et creer_faces_internes (si liste non vide sur au moins un p...">check_erreur_faces</a>(msg1, liste_faces_frontiere_non_declarees);
    <a class="code" href="classFaces__builder.html#a2a1241fa1f4adf443332bd7440e9472f" title="methode outil pour creer_faces_frontiere et creer_faces_internes (si liste non vide sur au moins un p...">check_erreur_faces</a>(msg2, liste_faces_joint_non_declarees);
    <a class="code" href="classFaces__builder.html#a2a1241fa1f4adf443332bd7440e9472f" title="methode outil pour creer_faces_frontiere et creer_faces_internes (si liste non vide sur au moins un p...">check_erreur_faces</a>(msg3, liste_faces_erreurs_connectivite);
  }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a5b48ba95888da226cbf702f677656ff6"></a><!-- doxytag: member="Faces_builder::creer_faces_reeles" ref="a5b48ba95888da226cbf702f677656ff6" args="(Zone &amp;zone, const Static_Int_Lists &amp;connect_som_elem, Faces &amp;les_faces, IntTab &amp;elem_faces)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Faces_builder::creer_faces_reeles </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classZone.html">Zone</a> &amp;&#160;</td>
          <td class="paramname"><em>zone</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classStatic__Int__Lists.html">Static_Int_Lists</a> &amp;&#160;</td>
          <td class="paramname"><em>connect_som_elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classFaces.html">Faces</a> &amp;&#160;</td>
          <td class="paramname"><em>les_faces</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classIntTab.html">IntTab</a> &amp;&#160;</td>
          <td class="paramname"><em>elem_faces</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A partir de la description des elements de la zone et des frontieres&lt;br&gt;(bords, raccords, faces internes et joints) :<br/>
Remplissage des structures suivantes:<br/>
- pour les frontieres de la zone: fixer_num_premiere_face<br/>
- les_faces.faces_sommets (faces reeles)<br/>
- les_faces.faces_voisins (faces reeles)<br/>
- elem_faces (pour les faces reeles des elements reels)<br/>
(on initialise elem_faces de taille nb_elem_reels, nb_faces_par_elem)<br/>
- joints.items_communs(FACE) </p>

<p>Definition at line <a class="el" href="Faces__builder_8cpp_source.html#l00070">70</a> of file <a class="el" href="Faces__builder_8cpp_source.html">Faces_builder.cpp</a>.</p>

<p>References <a class="el" href="EntreeSortie_8h_source.html#l00032">Cerr</a>, <a class="el" href="Faces__builder_8h_source.html#l00090">connectivite_som_elem_ptr_</a>, <a class="el" href="Faces__builder_8cpp_source.html#l00414">creer_faces_frontiere()</a>, <a class="el" href="Faces__builder_8cpp_source.html#l00562">creer_faces_internes()</a>, <a class="el" href="IntTab_8h_source.html#l00233">IntTab::dimension()</a>, <a class="el" href="Process_8cpp_source.html#l00223">Process::exit()</a>, <a class="el" href="Joint_8h_source.html#l00066">Joint::FACE</a>, <a class="el" href="Faces__builder_8h_source.html#l00098">face_elem_</a>, <a class="el" href="Zone_8h_source.html#l01059">Zone::faces_bord()</a>, <a class="el" href="Faces__builder_8cpp_source.html#l00374">faces_element_reference()</a>, <a class="el" href="Faces__builder_8h_source.html#l00093">faces_element_reference_old_</a>, <a class="el" href="Zone_8h_source.html#l01176">Zone::faces_int()</a>, <a class="el" href="Zone_8h_source.html#l01098">Zone::faces_joint()</a>, <a class="el" href="Zone_8h_source.html#l01137">Zone::faces_raccord()</a>, <a class="el" href="Faces__builder_8h_source.html#l00097">faces_sommets_</a>, <a class="el" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>, <a class="el" href="Static__Int__Lists_8h_source.html#l00113">Static_Int_Lists::get_nb_lists()</a>, <a class="el" href="classPoly__geom__base.html#aa5aae399947d9858e81d2bd6c4edf812">Poly_geom_base::get_somme_nb_faces_elem()</a>, <a class="el" href="Elem__geom__base_8cpp_source.html#l00265">Elem_geom_base::get_tab_faces_sommets_locaux()</a>, <a class="el" href="Faces__builder_8h_source.html#l00094">is_polyedre_</a>, <a class="el" href="Faces__builder_8h_source.html#l00073">les_elements()</a>, <a class="el" href="Faces__builder_8h_source.html#l00087">les_elements_ptr_</a>, <a class="el" href="Zone_8h_source.html#l00402">Zone::les_elems()</a>, <a class="el" href="Faces_8h_source.html#l00268">Faces::les_sommets()</a>, <a class="el" href="Frontiere_8h_source.html#l00114">Frontiere::nb_faces()</a>, <a class="el" href="Zone_8h_source.html#l01240">Zone::nb_faces_frontiere()</a>, <a class="el" href="Zone_8cpp_source.html#l00527">Zone::nb_faces_joint()</a>, <a class="el" href="Zone_8cpp_source.html#l00608">Zone::nb_som_tot()</a>, <a class="el" href="Frontiere_8h_source.html#l00208">Frontiere::num_premiere_face()</a>, <a class="el" href="Cast_8h_source.html#l00059">ref_cast</a>, <a class="el" href="Faces__builder_8h_source.html#l00096">ref_zone_</a>, <a class="el" href="Faces__builder_8cpp_source.html#l00050">reset()</a>, <a class="el" href="IntTab_8cpp_source.html#l00353">IntTab::resize()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00240">ArrOfInt::resize_array()</a>, <a class="el" href="Joint__Items_8cpp_source.html#l00056">Joint_Items::set_items_communs()</a>, <a class="el" href="Joint_8cpp_source.html#l00159">Joint::set_joint_item()</a>, <a class="el" href="ArrOfInt_8cpp_source.html#l00443">ArrOfInt::set_smart_resize()</a>, <a class="el" href="liste_8cpp_source.html#l00175">liste::size()</a>, <a class="el" href="Cast_8h_source.html#l00054">sub_type</a>, <a class="el" href="Zone_8h_source.html#l00491">Zone::type_elem()</a>, <a class="el" href="Raccords_8h_source.html#l00034">List_Raccord::valeur()</a>, <a class="el" href="Ref__Zone_8h_source.html#l00033">Ref_Zone::valeur()</a>, <a class="el" href="Elem__geom_8h_source.html#l00044">Deriv_Elem_geom_base::valeur()</a>, and <a class="el" href="Faces_8h_source.html#l00375">Faces::voisins()</a>.</p>

<p>Referenced by <a class="el" href="Zone__VF_8cpp_source.html#l00112">Zone_VF::discretiser()</a>, <a class="el" href="ExtrudeParoi_8cpp_source.html#l00159">ExtrudeParoi::extrude()</a>, <a class="el" href="Extruder__en3_8cpp_source.html#l00163">Extruder_en3::extruder()</a>, <a class="el" href="Extruder__en20_8cpp_source.html#l00130">Extruder_en20::extruder()</a>, <a class="el" href="Extruder_8cpp_source.html#l00140">Extruder::extruder()</a>, <a class="el" href="Extruder_8cpp_source.html#l00502">Extruder::extruder_hexa()</a>, and <a class="el" href="Distanceparoi_8cpp_source.html#l00043">Distanceparoi::interpreter_()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <a class="code" href="classFaces__builder.html#ad20059c937f9dd87de32f49c15c60202">les_elements_ptr_</a> = &amp; zone.<a class="code" href="classZone.html#ac115e8342be89afb882b7b61cc343267" title="Renvoie le tableau des sommets des elements.">les_elems</a>();

  <a class="code" href="classFaces__builder.html#a63465157f176a5ff77aba327d5438f14">connectivite_som_elem_ptr_</a> = &amp; connect_som_elem;
<span class="comment">// La connectivite doit contenir les sommets virtuels</span>
  assert(connect_som_elem.<a class="code" href="classStatic__Int__Lists.html#a5872636466919b2cb8efe715c315d7ca" title="renvoie le nombre de listes stockees">get_nb_lists</a>() == zone.<a class="code" href="classZone.html#a01ed67af826d6045ef4eacfb87a663e8" title="Renvoie le nombre total de sommets de la zone. i.e. le nombre de sommets reels et virtuels sur le pro...">nb_som_tot</a>());

<span class="comment">// Remplissage du tableau des faces de l&#39;element de reference</span>

  <a class="code" href="classFaces__builder.html#a8998f284fc8c1071af65de5ba552aed0">is_polyedre_</a>=0;
  <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classPoly__geom__base.html" title=": class Poly_geom_base &lt;Description of class Poly_geom_base&gt;">Poly_geom_base</a>,zone.<a class="code" href="classZone.html#a18cf83cd0f9c368dcfa32fb802a0ac94" title="Renvoie un element geometrique du type de ceux qui constituent la zone. (version const)">type_elem</a>().<a class="code" href="classDeriv__Elem__geom__base.html#a384b487459a33f9f521fb16539ec81de">valeur</a>()))
    {
      is_polyedre_=1;
    }
  <span class="keywordflow">else</span>
    zone.<a class="code" href="classZone.html#a18cf83cd0f9c368dcfa32fb802a0ac94" title="Renvoie un element geometrique du type de ceux qui constituent la zone. (version const)">type_elem</a>().<a class="code" href="classDeriv__Elem__geom__base.html#a384b487459a33f9f521fb16539ec81de">valeur</a>().<a class="code" href="classElem__geom__base.html#a9993267e98ef97472d3a5ef9c3c67882" title="remplit le tableau faces_som_local(i,j) qui donne pour 0 &lt;= i &lt; nb_faces() et 0 &lt;= j &lt; nb_som_face(i) le ...">get_tab_faces_sommets_locaux</a>(<a class="code" href="classFaces__builder.html#a202081564197f53d95fe6a3a2ace2caa">faces_element_reference_old_</a>);
<span class="comment">// Tableau de taille (nb_faces, nb_sommets par face),</span>
<span class="comment">// pour chaque face, les indices de ses sommets dans le domaine.</span>
<span class="comment">// L&#39;ordre des sommets est celui donne par l&#39;element de reference,</span>
<span class="comment">// pour celui des elements voisins de la face qui a le plus petit</span>
<span class="comment">// indice.</span>
  <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; faces_sommets = les_faces.<a class="code" href="classFaces.html#a07b8d8db9e3d656b93a21a49c063430c">les_sommets</a>();

<span class="comment">// Tableau de taille (nb_faces, 2) contenant pour chaque face</span>
<span class="comment">// les indices des deux elements voisins. Si &quot;i_face&quot; a un seul voisin,</span>
<span class="comment">// faces_voisins_(i_face, 1) = -1;</span>
  <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; faces_voisins = les_faces.<a class="code" href="classFaces.html#af49c4448e67aa7c732c2cc1dc237b442" title="Renvoie le tableau des voisins (des faces).">voisins</a>();

<span class="comment">// Initialisation des references utilisees dans check_erreur_faces</span>
  <a class="code" href="classFaces__builder.html#ae34616daf8a3bff24ad1673b447e3655">faces_sommets_</a> = faces_sommets;
  <a class="code" href="classFaces__builder.html#ae6a50f5e178055468ccd61d1b03dd496">face_elem_</a> = faces_voisins;
  <a class="code" href="classFaces__builder.html#a4da2e2efdd507fd9db4977dfad555fcf">ref_zone_</a> = zone;

<span class="comment">// Le tableau des faces des elements:</span>
<span class="comment">// dimension(0) = nombre d&#39;elements,</span>
<span class="comment">// dimension(1) = nombre de faces par element</span>
<span class="comment">// elem_faces(i,j) = indice de la face j de l&#39;element i dans les</span>
<span class="comment">// tableaux faces_sommets et faces_voisins</span>
<span class="comment">// (les faces de l&#39;element sont dans l&#39;ordre donne par faces_element_reference)</span>
<span class="comment">// espaces distants et virtuels appropries pour les elements</span>
  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_elements          = <a class="code" href="classFaces__builder.html#a30ad4fbd88a8069b4cfd093d1da1116c">les_elements</a>().<a class="code" href="classIntTab.html#abc3b32c94925a82f69d5b153a356e359" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(0);
  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_faces_par_element = <a class="code" href="classFaces__builder.html#aa173ce9252eff3fb6981b4c199137c32" title="redonne les faces pour un element, dans le cas des polyhedres cela depend du numero de l&#39;element...">faces_element_reference</a>(0).<a class="code" href="classIntTab.html#abc3b32c94925a82f69d5b153a356e359" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(0) ? <a class="code" href="classFaces__builder.html#aa173ce9252eff3fb6981b4c199137c32" title="redonne les faces pour un element, dans le cas des polyhedres cela depend du numero de l&#39;element...">faces_element_reference</a>(0).<a class="code" href="classIntTab.html#abc3b32c94925a82f69d5b153a356e359" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(0) : 4;
  elem_faces.<a class="code" href="classIntTab.html#a22e6bed6826b3688d4d0181cbf3b7a38" title="Change la taille du vecteur (identique a resize_array() pour le traitement des anciennes valeurs et d...">resize</a>(nb_elements, nb_faces_par_element);
  elem_faces = -1;

  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_sommets_par_face = <a class="code" href="classFaces__builder.html#aa173ce9252eff3fb6981b4c199137c32" title="redonne les faces pour un element, dans le cas des polyhedres cela depend du numero de l&#39;element...">faces_element_reference</a>(0).<a class="code" href="classIntTab.html#abc3b32c94925a82f69d5b153a356e359" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(0) ? <a class="code" href="classFaces__builder.html#aa173ce9252eff3fb6981b4c199137c32" title="redonne les faces pour un element, dans le cas des polyhedres cela depend du numero de l&#39;element...">faces_element_reference</a>(0).<a class="code" href="classIntTab.html#abc3b32c94925a82f69d5b153a356e359" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(1) : 3;
<span class="comment">// On ajoute chaque face avec resize(n+1,...), donc smart_resize:</span>
<span class="comment">// Calcul du nombre theorique de faces:</span>
  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_faces_front = zone.<a class="code" href="classZone.html#adb3970b0289aa1b0a38772011fd5d915" title="Renvoie le nombre de faces frontiere de la zone du type specifie. C&#39;est la somme des nombres de bords...">nb_faces_frontiere</a>() + zone.<a class="code" href="classZone.html#aff77b437f8c58064cc80a3221a0b6130" title="Renvoie le nombre de joints de la zone.">nb_faces_joint</a>();
  <span class="keywordtype">int</span> nb_faces_prevision = (nb_elements * nb_faces_par_element + nb_faces_front) / 2;
  <span class="keywordflow">if</span> (is_polyedre_)
    {
<span class="comment">// les faces sont toutes deja connues....</span>
      <span class="keyword">const</span> <a class="code" href="classPoly__geom__base.html" title=": class Poly_geom_base &lt;Description of class Poly_geom_base&gt;">Poly_geom_base</a>&amp; poly=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classPoly__geom__base.html" title=": class Poly_geom_base &lt;Description of class Poly_geom_base&gt;">Poly_geom_base</a>,<a class="code" href="classFaces__builder.html#a4da2e2efdd507fd9db4977dfad555fcf">ref_zone_</a>-&gt;type_elem().<a class="code" href="classRef__Zone.html#ab4ba0de67809ff502efeb24c1e43bfe1">valeur</a>());
      nb_faces_prevision=(poly.<a class="code" href="classPoly__geom__base.html#aa5aae399947d9858e81d2bd6c4edf812">get_somme_nb_faces_elem</a>()+ nb_faces_front) / 2;;
    }
<span class="comment">// Allocation memoire pour le nombre de faces prevu pour eviter de reallouer</span>
<span class="comment">// de la memoire n fois (voir set_smart_resize)</span>
  faces_sommets.<a class="code" href="classArrOfInt.html#a22d744bcd452d039580d1d9186f02b4e" title="Change le mode l&#39;allocation memoire: reallocation d&#39;un tableau a chaque changement de taille (flag = ...">set_smart_resize</a>(1);
  faces_sommets.<a class="code" href="classIntTab.html#a22e6bed6826b3688d4d0181cbf3b7a38" title="Change la taille du vecteur (identique a resize_array() pour le traitement des anciennes valeurs et d...">resize</a>(nb_faces_prevision, nb_sommets_par_face);
  faces_sommets.<a class="code" href="classIntTab.html#a22e6bed6826b3688d4d0181cbf3b7a38" title="Change la taille du vecteur (identique a resize_array() pour le traitement des anciennes valeurs et d...">resize</a>(0, nb_sommets_par_face);
  faces_voisins.<a class="code" href="classArrOfInt.html#a22d744bcd452d039580d1d9186f02b4e" title="Change le mode l&#39;allocation memoire: reallocation d&#39;un tableau a chaque changement de taille (flag = ...">set_smart_resize</a>(1);
  faces_voisins.<a class="code" href="classIntTab.html#a22e6bed6826b3688d4d0181cbf3b7a38" title="Change la taille du vecteur (identique a resize_array() pour le traitement des anciennes valeurs et d...">resize</a>(nb_faces_prevision, 2);
  faces_voisins.<a class="code" href="classIntTab.html#a22e6bed6826b3688d4d0181cbf3b7a38" title="Change la taille du vecteur (identique a resize_array() pour le traitement des anciennes valeurs et d...">resize</a>(0, 2);

<span class="comment">// ******** Traitement des frontieres **********</span>
<span class="comment">// attention, on initialise &quot;num_premiere_face&quot; pour les frontieres !</span>

<span class="comment">// Creation des faces de bord</span>
  {
    <a class="code" href="classBords.html" title="Classe Bords Cette classe represente une liste d&#39;objets de type Bord.">Bords</a>&amp; bords = zone.<a class="code" href="classZone.html#a4bc04163903c004c5c1383eaa5fa844d" title="Renvoie la liste des bords de la zone. (version const)">faces_bord</a>();
    <span class="keyword">const</span> <span class="keywordtype">int</span> n = bords.<a class="code" href="classliste.html#ab47f280662ff68f9aa2e00e50431c5dc" title="Renvoie la taille de la liste Une liste vide est de taille nulle.">size</a>();
    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; n; i++)
      {
        <a class="code" href="classFrontiere.html" title="Classe Frontiere. Une Frontiere decrit une partie de la frontiere d&#39;une Zone, elle possede un Nom...">Frontiere</a>&amp; frontiere = bords[i];
        <a class="code" href="classFaces__builder.html#a451a0948864cba2c5cc5022a2013c83c" title="Insere les faces de la frontiere donnee dans les trois tableaux, a la suite des faces deja presentes ...">creer_faces_frontiere</a>(1, <span class="comment">/* un element voisin par face */</span>
                              frontiere,
                              faces_sommets,
                              faces_voisins,
                              elem_faces);
      }
  }
<span class="comment">// Raccords</span>
  {
    <a class="code" href="classRaccords.html" title="Classe Raccords Cette represente une liste d&#39;objets de type Raccord.">Raccords</a>&amp; raccords = zone.<a class="code" href="classZone.html#ac2a20fe8fa5529c7eefd418b43c0131c" title="Renvoie la liste des racoords de la zone. (version const)">faces_raccord</a>();
    <span class="keyword">const</span> <span class="keywordtype">int</span> n = raccords.<a class="code" href="classliste.html#ab47f280662ff68f9aa2e00e50431c5dc" title="Renvoie la taille de la liste Une liste vide est de taille nulle.">size</a>();
    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; n; i++)
      {
        <a class="code" href="classFrontiere.html" title="Classe Frontiere. Une Frontiere decrit une partie de la frontiere d&#39;une Zone, elle possede un Nom...">Frontiere</a>&amp; frontiere = raccords[i].<a class="code" href="classList__Raccord.html#aa4dce0dae3e5e35c2a4faca1a2ce1bae" title="Retourne l&#39;Objet_U associe a la cellule de la liste.">valeur</a>();
        <a class="code" href="classFaces__builder.html#a451a0948864cba2c5cc5022a2013c83c" title="Insere les faces de la frontiere donnee dans les trois tableaux, a la suite des faces deja presentes ...">creer_faces_frontiere</a>(1, <span class="comment">/* un element voisin par face */</span>
                              frontiere,
                              faces_sommets,
                              faces_voisins,
                              elem_faces);
      }
  }

<span class="comment">// Faces de bord &quot;internes&quot;</span>
  {
    <a class="code" href="classFaces__Internes.html" title="Class Faces_Internes Cette classe represente une liste d&#39;objets de type Faces_Interne.">Faces_Internes</a>&amp; faces_int = zone.<a class="code" href="classZone.html#ad1d5f91adfa5e56003ce778cab9610e8" title="Renvoie la liste des faces internes de la zone. (version const)">faces_int</a>();
    <span class="keyword">const</span> <span class="keywordtype">int</span> n = faces_int.<a class="code" href="classliste.html#ab47f280662ff68f9aa2e00e50431c5dc" title="Renvoie la taille de la liste Une liste vide est de taille nulle.">size</a>();
    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; n; i++)
      {
        <a class="code" href="classFrontiere.html" title="Classe Frontiere. Une Frontiere decrit une partie de la frontiere d&#39;une Zone, elle possede un Nom...">Frontiere</a>&amp; frontiere = faces_int[i];
        <a class="code" href="classFaces__builder.html#a451a0948864cba2c5cc5022a2013c83c" title="Insere les faces de la frontiere donnee dans les trois tableaux, a la suite des faces deja presentes ...">creer_faces_frontiere</a>(2, <span class="comment">/* deux elements voisin par face */</span>
                              frontiere,
                              faces_sommets,
                              faces_voisins,
                              elem_faces);
      }

<span class="comment">// On duplique les faces internes : pour chaque face qui a deux</span>
<span class="comment">// voisins, on cree une deuxieme face identique avec le deuxieme voisin,</span>
<span class="comment">// on efface le deuxieme voisin de la face d&#39;origine et on change</span>
<span class="comment">// la face voisins de deuxieme voisin:</span>
    <span class="keywordflow">if</span> (n &gt; 0)
      {
        <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Faces_builder::creer_faces_reeles not coded for the internal faces of boundary&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
        <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">Process::exit</a>();
<span class="comment">// A faire selon l&#39;ancienne version de zone2... et a tester !</span>
      }
  }

<span class="comment">// Faces de joint</span>
  {
    <a class="code" href="classJoints.html" title="Classe Joints Cette classe represente une liste d&#39;objet de type Joint.">Joints</a>&amp; joints = zone.<a class="code" href="classZone.html#a16f273a76321d31435995cdad664285a" title="Renvoie la liste des joints de la zone. (version const)">faces_joint</a>();
    <span class="keyword">const</span> <span class="keywordtype">int</span> n = joints.<a class="code" href="classliste.html#ab47f280662ff68f9aa2e00e50431c5dc" title="Renvoie la taille de la liste Une liste vide est de taille nulle.">size</a>();
    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; n; i++)
      {
        <a class="code" href="classFrontiere.html" title="Classe Frontiere. Une Frontiere decrit une partie de la frontiere d&#39;une Zone, elle possede un Nom...">Frontiere</a>&amp; frontiere = joints[i];
        <a class="code" href="classFaces__builder.html#a451a0948864cba2c5cc5022a2013c83c" title="Insere les faces de la frontiere donnee dans les trois tableaux, a la suite des faces deja presentes ...">creer_faces_frontiere</a>(2, <span class="comment">/* elements voisins par face */</span>
                              frontiere,
                              faces_sommets,
                              faces_voisins,
                              elem_faces);
<span class="comment">// Remplissage de items_communs(FACE)</span>
<span class="comment">// Les faces de joint sont dans le meme ordre en local et sur le voisin.</span>
        <a class="code" href="classJoint.html" title="La classe Joint est une Frontiere qui contient les faces et les sommets de joint avec la zone PEvoisi...">Joint</a>&amp; joint = joints[i];
        <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; indices_faces =
          joint.<a class="code" href="classJoint.html#aa1c4d729a3017082d26907d82ad1d7de" title="Renvoie les informations de joint pour un type d&#39;item geometrique donne, pour remplissage des structu...">set_joint_item</a>(<a class="code" href="classJoint.html#a1e2d15d088c27c9b7b11c02bf4d2c926ab255b88987fc7f64c215c958cbe2af6b">Joint::FACE</a>).<a class="code" href="classJoint__Items.html#aa01c4601d506c658f4f1d45e66951ce0" title="Renvoie le tableau items_communs_ pour le remplir. (BM: ce tableau n&#39;est pas encore rempli)...">set_items_communs</a>();
        <span class="keyword">const</span> <span class="keywordtype">int</span> nb_faces  = joint.<a class="code" href="classFrontiere.html#aa073fe9dbdddde59471ee7032b256aa2" title="Renvoie le nombre de faces de la frontiere.">nb_faces</a>();
        indices_faces.<a class="code" href="classArrOfInt.html#a9b3afbb46b16870dbd36236c8935b535">resize_array</a>(nb_faces);
        <span class="keyword">const</span> <span class="keywordtype">int</span> num_premiere_face = joint.<a class="code" href="classFrontiere.html#a2a41c319a1530c984c356121e5ca2383">num_premiere_face</a>();
        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i2 = 0; i2 &lt; nb_faces; i2++)
          indices_faces[i2] = num_premiere_face + i2;
      }
  }

<span class="comment">// *********************************************</span>
<span class="comment">// Faces internes</span>

  <a class="code" href="classFaces__builder.html#ae52612e6c9aff57afbe490c910930516" title="Construction des faces interieures au domaine (faces qui ont deux voisins et qui ne sont pas des &quot;fac...">creer_faces_internes</a>(faces_sommets,
                       elem_faces,
                       faces_voisins);

<span class="comment">// *********************************************</span>
<span class="comment">// C&#39;est fini: on verifie qu&#39;on a bien le nombre de faces prevu</span>
  <span class="keywordflow">if</span> (faces_sommets.<a class="code" href="classIntTab.html#abc3b32c94925a82f69d5b153a356e359" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(0) != nb_faces_prevision)
    {
      <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Error in Faces_builder::creer_faces_reeles:\n&quot;</span>
           &lt;&lt; <span class="stringliteral">&quot; number of faces does not match predicted number of faces.\n&quot;</span>
           &lt;&lt; <span class="stringliteral">&quot; (problem with faces_internes ?)&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
      <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">Process::exit</a>();
    }

<span class="comment">// RAZ attribut smart_resize des tableaux faces_sommets et faces_voisins.</span>
  faces_sommets.<a class="code" href="classArrOfInt.html#a22d744bcd452d039580d1d9186f02b4e" title="Change le mode l&#39;allocation memoire: reallocation d&#39;un tableau a chaque changement de taille (flag = ...">set_smart_resize</a>(0);
  faces_voisins.<a class="code" href="classArrOfInt.html#a22d744bcd452d039580d1d9186f02b4e" title="Change le mode l&#39;allocation memoire: reallocation d&#39;un tableau a chaque changement de taille (flag = ...">set_smart_resize</a>(0);
<span class="comment">// RAZ des attributs de la classe</span>
  <a class="code" href="classFaces__builder.html#aecd26cae77aa00884a228ab14b57ddb8">reset</a>();
}
</pre></div>
</div>
</div>
<a class="anchor" id="aa173ce9252eff3fb6981b4c199137c32"></a><!-- doxytag: member="Faces_builder::faces_element_reference" ref="aa173ce9252eff3fb6981b4c199137c32" args="(int elem) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classIntTab.html">IntTab</a> &amp; Faces_builder::faces_element_reference </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>elem</em></td><td>)</td>
          <td> const<code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>redonne les faces pour un element, dans le cas des polyhedres cela depend du numero de l'element. </p>

<p>Definition at line <a class="el" href="Faces__builder_8cpp_source.html#l00374">374</a> of file <a class="el" href="Faces__builder_8cpp_source.html">Faces_builder.cpp</a>.</p>

<p>References <a class="el" href="IntTab_8h_source.html#l00233">IntTab::dimension()</a>, <a class="el" href="Faces__builder_8h_source.html#l00093">faces_element_reference_old_</a>, <a class="el" href="classPoly__geom__base.html#a1357e4033dba242d8a899bcb87d9f6f3">Poly_geom_base::get_tab_faces_sommets_locaux()</a>, <a class="el" href="Faces__builder_8h_source.html#l00094">is_polyedre_</a>, <a class="el" href="Faces__builder_8h_source.html#l00087">les_elements_ptr_</a>, <a class="el" href="Cast_8h_source.html#l00059">ref_cast</a>, <a class="el" href="Cast_8h_source.html#l00062">ref_cast_non_const</a>, <a class="el" href="Faces__builder_8h_source.html#l00096">ref_zone_</a>, and <a class="el" href="Ref__Zone_8h_source.html#l00033">Ref_Zone::valeur()</a>.</p>

<p>Referenced by <a class="el" href="Faces__builder_8cpp_source.html#l00396">chercher_face_element()</a>, <a class="el" href="Faces__builder_8cpp_source.html#l00414">creer_faces_frontiere()</a>, <a class="el" href="Faces__builder_8cpp_source.html#l00562">creer_faces_internes()</a>, and <a class="el" href="Faces__builder_8cpp_source.html#l00070">creer_faces_reeles()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">if</span> (<a class="code" href="classFaces__builder.html#a8998f284fc8c1071af65de5ba552aed0">is_polyedre_</a>==1 &amp;&amp; <a class="code" href="classFaces__builder.html#ad20059c937f9dd87de32f49c15c60202">les_elements_ptr_</a>-&gt;<a class="code" href="classIntTab.html#abc3b32c94925a82f69d5b153a356e359" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(0))
    {
      assert(<a class="code" href="classFaces__builder.html#a8998f284fc8c1071af65de5ba552aed0">is_polyedre_</a>==1);
      <span class="keyword">const</span> <a class="code" href="classPoly__geom__base.html" title=": class Poly_geom_base &lt;Description of class Poly_geom_base&gt;">Poly_geom_base</a>&amp; poly=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classPoly__geom__base.html" title=": class Poly_geom_base &lt;Description of class Poly_geom_base&gt;">Poly_geom_base</a>,<a class="code" href="classFaces__builder.html#a4da2e2efdd507fd9db4977dfad555fcf">ref_zone_</a>-&gt;type_elem().<a class="code" href="classRef__Zone.html#ab4ba0de67809ff502efeb24c1e43bfe1">valeur</a>());
      <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; elem_ref_mod=<a class="code" href="Cast_8h.html#ad3836a067c92103af8df5ad8f35959a6">ref_cast_non_const</a>(<a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>,<a class="code" href="classFaces__builder.html#a202081564197f53d95fe6a3a2ace2caa">faces_element_reference_old_</a>);
      poly.<a class="code" href="classPoly__geom__base.html#a1357e4033dba242d8a899bcb87d9f6f3" title="remplit le tableau faces_som_local(i,j) qui donne pour 0 &lt;= i &lt; nb_faces() et 0 &lt;= j &lt; nb_som_face(i) le ...">get_tab_faces_sommets_locaux</a>(elem_ref_mod,elem);

<span class="comment">// abort();</span>
<span class="comment">// return faces_element_reference(0);</span>
    }
  <span class="keywordflow">return</span> <a class="code" href="classFaces__builder.html#a202081564197f53d95fe6a3a2ace2caa">faces_element_reference_old_</a>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a30ad4fbd88a8069b4cfd093d1da1116c"></a><!-- doxytag: member="Faces_builder::les_elements" ref="a30ad4fbd88a8069b4cfd093d1da1116c" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classIntTab.html">IntTab</a>&amp; Faces_builder::les_elements </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Faces__builder_8h_source.html#l00073">73</a> of file <a class="el" href="Faces__builder_8h_source.html">Faces_builder.h</a>.</p>

<p>References <a class="el" href="Faces__builder_8h_source.html#l00087">les_elements_ptr_</a>.</p>

<p>Referenced by <a class="el" href="Faces__builder_8cpp_source.html#l00396">chercher_face_element()</a>, <a class="el" href="Faces__builder_8cpp_source.html#l00562">creer_faces_internes()</a>, and <a class="el" href="Faces__builder_8cpp_source.html#l00070">creer_faces_reeles()</a>.</p>
<div class="fragment"><pre class="fragment">  {
    <span class="keywordflow">return</span> *<a class="code" href="classFaces__builder.html#ad20059c937f9dd87de32f49c15c60202">les_elements_ptr_</a>;
  };
</pre></div>
</div>
</div>
<a class="anchor" id="aecd26cae77aa00884a228ab14b57ddb8"></a><!-- doxytag: member="Faces_builder::reset" ref="aecd26cae77aa00884a228ab14b57ddb8" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Faces_builder::reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Faces__builder_8cpp_source.html#l00050">50</a> of file <a class="el" href="Faces__builder_8cpp_source.html">Faces_builder.cpp</a>.</p>

<p>References <a class="el" href="Faces__builder_8h_source.html#l00090">connectivite_som_elem_ptr_</a>, <a class="el" href="Faces__builder_8h_source.html#l00098">face_elem_</a>, <a class="el" href="Faces__builder_8h_source.html#l00093">faces_element_reference_old_</a>, <a class="el" href="Faces__builder_8h_source.html#l00097">faces_sommets_</a>, <a class="el" href="Faces__builder_8h_source.html#l00087">les_elements_ptr_</a>, <a class="el" href="Faces__builder_8h_source.html#l00096">ref_zone_</a>, <a class="el" href="Ref___8cpp_source.html#l00072">Ref_::reset()</a>, and <a class="el" href="IntTab_8cpp_source.html#l00325">IntTab::reset()</a>.</p>

<p>Referenced by <a class="el" href="Faces__builder_8cpp_source.html#l00070">creer_faces_reeles()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <a class="code" href="classFaces__builder.html#ad20059c937f9dd87de32f49c15c60202">les_elements_ptr_</a> = 0;
  <a class="code" href="classFaces__builder.html#a63465157f176a5ff77aba327d5438f14">connectivite_som_elem_ptr_</a> = 0;
  <a class="code" href="classFaces__builder.html#a202081564197f53d95fe6a3a2ace2caa">faces_element_reference_old_</a>.<a class="code" href="classIntTab.html#ac66710ddde96fe2745f341a0166b3b34" title="met le tableau dans l&#39;etat obtenu par le constructeur par defaut voir IntVect::reset()">reset</a>();
  <a class="code" href="classFaces__builder.html#a4da2e2efdd507fd9db4977dfad555fcf">ref_zone_</a>.<a class="code" href="classRef__.html#aefc8130f02e22c692853dd435cbd1c18" title="Annule la ref.">reset</a>();
  <a class="code" href="classFaces__builder.html#ae34616daf8a3bff24ad1673b447e3655">faces_sommets_</a>.<a class="code" href="classRef__.html#aefc8130f02e22c692853dd435cbd1c18" title="Annule la ref.">reset</a>();
  <a class="code" href="classFaces__builder.html#ae6a50f5e178055468ccd61d1b03dd496">face_elem_</a>.<a class="code" href="classRef__.html#aefc8130f02e22c692853dd435cbd1c18" title="Annule la ref.">reset</a>();
}
</pre></div>
</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="a63465157f176a5ff77aba327d5438f14"></a><!-- doxytag: member="Faces_builder::connectivite_som_elem_ptr_" ref="a63465157f176a5ff77aba327d5438f14" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classStatic__Int__Lists.html">Static_Int_Lists</a>* <a class="el" href="classFaces__builder.html#a63465157f176a5ff77aba327d5438f14">Faces_builder::connectivite_som_elem_ptr_</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Faces__builder_8h_source.html#l00090">90</a> of file <a class="el" href="Faces__builder_8h_source.html">Faces_builder.h</a>.</p>

<p>Referenced by <a class="el" href="Faces__builder_8h_source.html#l00077">connectivite_som_elem()</a>, <a class="el" href="Faces__builder_8cpp_source.html#l00070">creer_faces_reeles()</a>, and <a class="el" href="Faces__builder_8cpp_source.html#l00050">reset()</a>.</p>

</div>
</div>
<a class="anchor" id="ae6a50f5e178055468ccd61d1b03dd496"></a><!-- doxytag: member="Faces_builder::face_elem_" ref="ae6a50f5e178055468ccd61d1b03dd496" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRef__IntTab.html">Ref_IntTab</a> <a class="el" href="classFaces__builder.html#ae6a50f5e178055468ccd61d1b03dd496">Faces_builder::face_elem_</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Faces__builder_8h_source.html#l00098">98</a> of file <a class="el" href="Faces__builder_8h_source.html">Faces_builder.h</a>.</p>

<p>Referenced by <a class="el" href="Faces__builder_8cpp_source.html#l00248">check_erreur_faces()</a>, <a class="el" href="Faces__builder_8cpp_source.html#l00070">creer_faces_reeles()</a>, and <a class="el" href="Faces__builder_8cpp_source.html#l00050">reset()</a>.</p>

</div>
</div>
<a class="anchor" id="a202081564197f53d95fe6a3a2ace2caa"></a><!-- doxytag: member="Faces_builder::faces_element_reference_old_" ref="a202081564197f53d95fe6a3a2ace2caa" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIntTab.html">IntTab</a> <a class="el" href="classFaces__builder.html#a202081564197f53d95fe6a3a2ace2caa">Faces_builder::faces_element_reference_old_</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Faces__builder_8h_source.html#l00093">93</a> of file <a class="el" href="Faces__builder_8h_source.html">Faces_builder.h</a>.</p>

<p>Referenced by <a class="el" href="Faces__builder_8cpp_source.html#l00070">creer_faces_reeles()</a>, <a class="el" href="Faces__builder_8cpp_source.html#l00374">faces_element_reference()</a>, and <a class="el" href="Faces__builder_8cpp_source.html#l00050">reset()</a>.</p>

</div>
</div>
<a class="anchor" id="ae34616daf8a3bff24ad1673b447e3655"></a><!-- doxytag: member="Faces_builder::faces_sommets_" ref="ae34616daf8a3bff24ad1673b447e3655" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRef__IntTab.html">Ref_IntTab</a> <a class="el" href="classFaces__builder.html#ae34616daf8a3bff24ad1673b447e3655">Faces_builder::faces_sommets_</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Faces__builder_8h_source.html#l00097">97</a> of file <a class="el" href="Faces__builder_8h_source.html">Faces_builder.h</a>.</p>

<p>Referenced by <a class="el" href="Faces__builder_8cpp_source.html#l00248">check_erreur_faces()</a>, <a class="el" href="Faces__builder_8cpp_source.html#l00070">creer_faces_reeles()</a>, and <a class="el" href="Faces__builder_8cpp_source.html#l00050">reset()</a>.</p>

</div>
</div>
<a class="anchor" id="a8998f284fc8c1071af65de5ba552aed0"></a><!-- doxytag: member="Faces_builder::is_polyedre_" ref="a8998f284fc8c1071af65de5ba552aed0" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classFaces__builder.html#a8998f284fc8c1071af65de5ba552aed0">Faces_builder::is_polyedre_</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Faces__builder_8h_source.html#l00094">94</a> of file <a class="el" href="Faces__builder_8h_source.html">Faces_builder.h</a>.</p>

<p>Referenced by <a class="el" href="Faces__builder_8cpp_source.html#l00070">creer_faces_reeles()</a>, and <a class="el" href="Faces__builder_8cpp_source.html#l00374">faces_element_reference()</a>.</p>

</div>
</div>
<a class="anchor" id="ad20059c937f9dd87de32f49c15c60202"></a><!-- doxytag: member="Faces_builder::les_elements_ptr_" ref="ad20059c937f9dd87de32f49c15c60202" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classIntTab.html">IntTab</a>* <a class="el" href="classFaces__builder.html#ad20059c937f9dd87de32f49c15c60202">Faces_builder::les_elements_ptr_</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Faces__builder_8h_source.html#l00087">87</a> of file <a class="el" href="Faces__builder_8h_source.html">Faces_builder.h</a>.</p>

<p>Referenced by <a class="el" href="Faces__builder_8cpp_source.html#l00070">creer_faces_reeles()</a>, <a class="el" href="Faces__builder_8cpp_source.html#l00374">faces_element_reference()</a>, <a class="el" href="Faces__builder_8h_source.html#l00073">les_elements()</a>, and <a class="el" href="Faces__builder_8cpp_source.html#l00050">reset()</a>.</p>

</div>
</div>
<a class="anchor" id="a4da2e2efdd507fd9db4977dfad555fcf"></a><!-- doxytag: member="Faces_builder::ref_zone_" ref="a4da2e2efdd507fd9db4977dfad555fcf" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRef__Zone.html">Ref_Zone</a> <a class="el" href="classFaces__builder.html#a4da2e2efdd507fd9db4977dfad555fcf">Faces_builder::ref_zone_</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Faces__builder_8h_source.html#l00096">96</a> of file <a class="el" href="Faces__builder_8h_source.html">Faces_builder.h</a>.</p>

<p>Referenced by <a class="el" href="Faces__builder_8cpp_source.html#l00248">check_erreur_faces()</a>, <a class="el" href="Faces__builder_8cpp_source.html#l00070">creer_faces_reeles()</a>, <a class="el" href="Faces__builder_8cpp_source.html#l00374">faces_element_reference()</a>, and <a class="el" href="Faces__builder_8cpp_source.html#l00050">reset()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/Kernel/Geometrie/<a class="el" href="Faces__builder_8h_source.html">Faces_builder.h</a></li>
<li>src/Kernel/Geometrie/<a class="el" href="Faces__builder_8cpp_source.html">Faces_builder.cpp</a></li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Tue Dec 14 2021 19:36:47 for TRUST by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
