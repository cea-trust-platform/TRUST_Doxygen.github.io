<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>TRUST: src/PolyMAC/Operateurs/Conv_iterateur/Op_PolyMAC_Elem.cpp Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">TRUST&#160;<span id="projectnumber">1.8.4</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
<div class="header">
  <div class="headertitle">
<div class="title">src/PolyMAC/Operateurs/Conv_iterateur/Op_PolyMAC_Elem.cpp</div>  </div>
</div>
<div class="contents">
<a href="Op__PolyMAC__Elem_8cpp.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/****************************************************************************</span>
<a name="l00002"></a>00002 <span class="comment">* Copyright (c) 2019, CEA</span>
<a name="l00003"></a>00003 <span class="comment">* All rights reserved.</span>
<a name="l00004"></a>00004 <span class="comment">*</span>
<a name="l00005"></a>00005 <span class="comment">* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</span>
<a name="l00006"></a>00006 <span class="comment">* 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.</span>
<a name="l00007"></a>00007 <span class="comment">* 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.</span>
<a name="l00008"></a>00008 <span class="comment">* 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.</span>
<a name="l00009"></a>00009 <span class="comment">*</span>
<a name="l00010"></a>00010 <span class="comment">* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.</span>
<a name="l00011"></a>00011 <span class="comment">* IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;</span>
<a name="l00012"></a>00012 <span class="comment">* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>
<a name="l00013"></a>00013 <span class="comment">*</span>
<a name="l00014"></a>00014 <span class="comment">*****************************************************************************/</span>
<a name="l00015"></a>00015 <span class="comment">//</span>
<a name="l00016"></a>00016 <span class="comment">// </span>
<a name="l00017"></a>00017 <span class="comment">// File:        Op_PolyMAC_Elem.cpp</span>
<a name="l00018"></a>00018 <span class="comment">// Directory:   $TRUST_ROOT/src/PolyMAC/Operateurs/Conv_iterateur</span>
<a name="l00019"></a>00019 <span class="comment">// Version:     /main/10</span>
<a name="l00020"></a>00020 <span class="comment">// </span>
<a name="l00021"></a>00021 <span class="comment">//</span>
<a name="l00022"></a>00022 
<a name="l00023"></a>00023 <span class="preprocessor">#include &lt;<a class="code" href="Op__PolyMAC__Elem_8h.html">Op_PolyMAC_Elem.h</a>&gt;</span>
<a name="l00024"></a>00024 <span class="preprocessor">#include &lt;<a class="code" href="Zone__PolyMAC_8h.html">Zone_PolyMAC.h</a>&gt;</span>
<a name="l00025"></a>00025 <span class="preprocessor">#include &lt;<a class="code" href="Zone__Cl__PolyMAC_8h.html">Zone_Cl_PolyMAC.h</a>&gt;</span>
<a name="l00026"></a>00026 <span class="preprocessor">#include &lt;<a class="code" href="Periodique_8h.html">Periodique.h</a>&gt;</span>
<a name="l00027"></a>00027 <span class="preprocessor">#include &lt;<a class="code" href="Matrice__Morse_8h.html">Matrice_Morse.h</a>&gt;</span>
<a name="l00028"></a>00028 <span class="preprocessor">#include &lt;<a class="code" href="Equation__base_8h.html">Equation_base.h</a>&gt;</span>
<a name="l00029"></a>00029 <span class="preprocessor">#include &lt;<a class="code" href="Champ__Inc_8h.html">Champ_Inc.h</a>&gt;</span>
<a name="l00030"></a>00030 <span class="preprocessor">#include &lt;<a class="code" href="Matrix__tools_8h.html">Matrix_tools.h</a>&gt;</span>
<a name="l00031"></a>00031 <span class="preprocessor">#include &lt;<a class="code" href="Array__tools_8h.html">Array_tools.h</a>&gt;</span>
<a name="l00032"></a>00032 
<a name="l00033"></a><a class="code" href="classOp__PolyMAC__Elem.html#a98f45c9ae1a6b49a0ae5d1804d7ad982">00033</a> <span class="keywordtype">void</span> <a class="code" href="classOp__PolyMAC__Elem.html#a98f45c9ae1a6b49a0ae5d1804d7ad982">Op_PolyMAC_Elem::dimensionner</a>(<span class="keyword">const</span> <a class="code" href="classZone__PolyMAC.html" title="class Zone_PolyMAC Classe instanciable qui derive de Zone_VF. Cette classe contient les informations ...">Zone_PolyMAC</a>&amp; la_zone,
<a name="l00034"></a>00034                                    <span class="keyword">const</span> <a class="code" href="classZone__Cl__PolyMAC.html">Zone_Cl_PolyMAC</a>&amp; la_zone_cl,
<a name="l00035"></a>00035                                    <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; la_matrice)<span class="keyword"> const</span>
<a name="l00036"></a>00036 <span class="keyword"></span>{
<a name="l00037"></a>00037 <span class="comment">// Dimensionnement de la matrice qui devra recevoir les coefficients provenant de</span>
<a name="l00038"></a>00038 <span class="comment">// la convection, de la diffusion pour le cas des elements.</span>
<a name="l00039"></a>00039 <span class="comment">// Cette matrice a une structure de matrice morse.</span>
<a name="l00040"></a>00040 <span class="comment">// Nous commencons par calculer les tailles des tableaux tab1 et tab2.</span>
<a name="l00041"></a>00041 
<a name="l00042"></a>00042   <span class="keywordtype">int</span> num_face,face,k;
<a name="l00043"></a>00043   <span class="keywordtype">int</span> n1 = la_zone.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#aa3a33e8b723618b9092460007153e42d" title="Renvoie le nombre total d&#39;elements de la zone.">nb_elem_tot</a>(), n2 = la_zone.<a class="code" href="classZone__VF.html#a50fd21c9535680489015a3c8b88c685a" title="renvoie le nombre total de faces. C&#39;est-a-dire faces reelles + faces virtuelles">nb_faces_tot</a>();
<a name="l00044"></a>00044   <span class="keywordtype">int</span> elem1,elem2, i;
<a name="l00045"></a>00045   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; face_voisins = la_zone.<a class="code" href="classZone__VF.html#a49d4322f5585a8fa95748ca785b70702" title="renvoie l&#39;element voisin de numface dans la direction i. i=0 : dans le sens oppose de l&#39;axe orthogona...">face_voisins</a>();
<a name="l00046"></a>00046 <span class="comment">// const DoubleVect&amp; face_surfaces = la_zone.face_surfaces();</span>
<a name="l00047"></a>00047 <span class="comment">// const DoubleVect&amp; volumes_entrelaces = la_zone.volumes_entrelaces();</span>
<a name="l00048"></a>00048 <span class="comment">// const DoubleVect&amp; porosite_face = la_zone.porosite_face();</span>
<a name="l00049"></a>00049   <span class="keyword">const</span> <a class="code" href="classConds__lim.html">Conds_lim</a>&amp; les_cl = la_zone_cl.<a class="code" href="classZone__Cl__dis__base.html#af75e0ed7786863e4d333bfb29d67c323" title="Renvoie la i-ieme condition aux limites. (version const)">les_conditions_limites</a>();
<a name="l00050"></a>00050   <span class="keywordtype">int</span> nb_comp = 1;
<a name="l00051"></a>00051 
<a name="l00052"></a>00052   <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; champ_inconnue = la_zone_cl.<a class="code" href="classMorEqn.html#a615dd9abff96edcb625fa0424a489864" title="Renvoie la reference sur l&#39;equation pointe par MorEqn::mon_equation. (version const)">equation</a>().<a class="code" href="classEquation__base.html#a5a1fce9487b9a8dd17020914100c2c89">inconnue</a>().<a class="code" href="classChamp__Inc.html#a28ef3d411d12cb5684ac5e799efb7d24" title="Appel a l&#39;objet sous-jacent Renvoie le tableau des valeurs au temps courant.">valeurs</a>();
<a name="l00053"></a>00053   <span class="keywordflow">if</span> (champ_inconnue.<a class="code" href="classDoubleTab.html#ae6dda48778e7107e1beb723beef1f75b" title="Returns the number of dimensions of the array (&gt;= 1)">nb_dim</a>() == 2) nb_comp = champ_inconnue.<a class="code" href="classDoubleTab.html#ac3805e2637a3b880ba2d3e650c69dac4" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(1);
<a name="l00054"></a>00054 <span class="comment">// Cerr &lt;&lt; &quot;nb_compo de Op_PolyMAC_Elem::dimensionner&quot; &lt;&lt; nb_comp &lt;&lt; finl;</span>
<a name="l00055"></a>00055 <span class="comment">// Cerr &lt;&lt; &quot; nombre d&#39;elements de Op_PolyMAC_Elem::dimensionner&quot; &lt;&lt; n1 &lt;&lt; finl;</span>
<a name="l00056"></a>00056 
<a name="l00057"></a>00057   la_matrice.<a class="code" href="classMatrice__Morse.html#ae95f9ed88a8a3fc637cd2a705cead9c8" title="Size the matrix with n lines and n columns and nnz zero-values coefficients.">dimensionner</a>((n1 + n2) * nb_comp, (n1 + n2) * nb_comp, 0);
<a name="l00058"></a>00058 
<a name="l00059"></a>00059   <a class="code" href="classIntVect.html">IntVect</a>&amp; tab1=la_matrice.<a class="code" href="classMatrice__Morse.html#a7a49c763706dcfaed900f9d2cbb68716">get_set_tab1</a>();
<a name="l00060"></a>00060   <a class="code" href="classIntVect.html">IntVect</a>&amp; tab2=la_matrice.<a class="code" href="classMatrice__Morse.html#af11c5853518e9e6db4c7e6e6acc8d7fd">get_set_tab2</a>();
<a name="l00061"></a>00061 
<a name="l00062"></a>00062   <span class="keywordtype">int</span> ndeb = la_zone.<a class="code" href="classZone__VF.html#a12869806fa4834aca8f2964e16509dfd" title="une face est interne ssi elle separe deux elements. renvoie le numero de la premiere face interne...">premiere_face_int</a>();
<a name="l00063"></a>00063   <span class="keywordtype">int</span> nfin = la_zone.<a class="code" href="classZone__VF.html#aede27992d9f2eedd52c24d4a80ff7ffb" title="renvoie le nombre global de faces.">nb_faces</a>();
<a name="l00064"></a>00064   <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; <a class="code" href="Champ__P1iP1B__implementation_8cpp.html#aa8c8f49390c3cf7c702d71a71bc977e3">coeff</a> = la_matrice.<a class="code" href="classMatrice__Morse.html#acd067e8514e5741f52b18a1d99746d11">get_set_coeff</a>();
<a name="l00065"></a>00065   coeff=0;
<a name="l00066"></a>00066 
<a name="l00067"></a>00067   <a class="code" href="classIntVect.html">IntVect</a> rang_voisin(n1*nb_comp);
<a name="l00068"></a>00068   rang_voisin=1;
<a name="l00069"></a>00069 
<a name="l00070"></a>00070   <span class="keywordflow">for</span> (num_face=ndeb; num_face&lt;nfin; num_face++)
<a name="l00071"></a>00071     {
<a name="l00072"></a>00072       elem1 = face_voisins(num_face,0);
<a name="l00073"></a>00073       elem2 = face_voisins(num_face,1);
<a name="l00074"></a>00074       (rang_voisin(elem2))++;
<a name="l00075"></a>00075       (rang_voisin(elem1))++;
<a name="l00076"></a>00076     }
<a name="l00077"></a>00077 
<a name="l00078"></a>00078 <span class="comment">// Prise en compte des conditions de type periodicite</span>
<a name="l00079"></a>00079 
<a name="l00080"></a>00080   <span class="keywordflow">for</span> (i=0; i&lt;les_cl.<a class="code" href="classvect__impl.html#a78155bfbd6b61f4710b9830641ed1694">size</a>(); i++)
<a name="l00081"></a>00081     {
<a name="l00082"></a>00082       <span class="keyword">const</span> <a class="code" href="classCond__lim.html" title="classe Cond_lim Classe generique servant a representer n&#39;importe quelle classe derivee de la classe C...">Cond_lim</a>&amp; la_cl = les_cl[i];
<a name="l00083"></a>00083 
<a name="l00084"></a>00084       <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>()))
<a name="l00085"></a>00085         {
<a name="l00086"></a>00086           <span class="keyword">const</span> <a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>&amp; la_cl_perio = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>());
<a name="l00087"></a>00087           <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp; la_front_dis = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>,la_cl.<a class="code" href="classCond__lim.html#a5b2d24809cee07727006a891d4ce8d22" title="Appel a l&#39;objet sous-jacent Renvoie la frontiere discretisee associee a la condition aux limites...">frontiere_dis</a>());
<a name="l00088"></a>00088           <span class="keywordtype">int</span> numdeb = la_front_dis.num_premiere_face();
<a name="l00089"></a>00089           <span class="keywordtype">int</span> nfaces = la_front_dis.nb_faces();
<a name="l00090"></a>00090           <span class="keywordtype">int</span> ind_face_global;
<a name="l00091"></a>00091           <a class="code" href="classIntVect.html">IntVect</a> fait(nfaces);
<a name="l00092"></a>00092           fait = 0;
<a name="l00093"></a>00093           <span class="keywordflow">for</span> (face=0; face&lt;nfaces; face++)
<a name="l00094"></a>00094             {
<a name="l00095"></a>00095               <span class="keywordflow">if</span> (fait[face] == 0)
<a name="l00096"></a>00096                 {
<a name="l00097"></a>00097                   fait[face] = 1;
<a name="l00098"></a>00098                   fait[la_cl_perio.<a class="code" href="classPeriodique.html#a207b86556f199a63ea059b841851ca6a">face_associee</a>(face)] = 1;
<a name="l00099"></a>00099                   ind_face_global = face+numdeb;
<a name="l00100"></a>00100 
<a name="l00101"></a>00101                   elem1 = face_voisins(ind_face_global,0);
<a name="l00102"></a>00102                   elem2 = face_voisins(ind_face_global,1);
<a name="l00103"></a>00103 
<a name="l00104"></a>00104                   (rang_voisin(elem2))++;
<a name="l00105"></a>00105                   (rang_voisin(elem1))++;
<a name="l00106"></a>00106                 }
<a name="l00107"></a>00107             }
<a name="l00108"></a>00108         }
<a name="l00109"></a>00109     }
<a name="l00110"></a>00110 
<a name="l00111"></a>00111 <span class="comment">// on balaye les elements pour dimensionner tab1 et tab2</span>
<a name="l00112"></a>00112 
<a name="l00113"></a>00113   tab1(0)=1;
<a name="l00114"></a>00114   <span class="keywordflow">for</span>(i=0; i&lt;n1; i++)
<a name="l00115"></a>00115     <span class="keywordflow">for</span> (k=0; k&lt; nb_comp; k++)
<a name="l00116"></a>00116       tab1(i*nb_comp+1+k)=rang_voisin(i) +  tab1(i*nb_comp+k);
<a name="l00117"></a>00117   <span class="keywordflow">for</span>(i = n1; i &lt; n1 + n2; i++)
<a name="l00118"></a>00118     <span class="keywordflow">for</span> (k = 0; k &lt; nb_comp; k++)
<a name="l00119"></a>00119       tab1(i*nb_comp+1+k)=tab1(i*nb_comp+k);
<a name="l00120"></a>00120 
<a name="l00121"></a>00121 <span class="comment">// Cerr &lt;&lt; &quot; dimension de la matrice &quot; &lt;&lt; n1*nb_comp</span>
<a name="l00122"></a>00122 <span class="comment">// &lt;&lt; &quot;   &quot; &lt;&lt; tab1(n1*nb_comp)-1 &lt;&lt;finl;</span>
<a name="l00123"></a>00123   la_matrice.<a class="code" href="classMatrice__Morse.html#ae95f9ed88a8a3fc637cd2a705cead9c8" title="Size the matrix with n lines and n columns and nnz zero-values coefficients.">dimensionner</a>((n1 + n2) * nb_comp,tab1(n1*nb_comp)-1);
<a name="l00124"></a>00124 
<a name="l00125"></a>00125   <span class="keywordflow">for</span>(i=0; i&lt;n1*nb_comp; i++)
<a name="l00126"></a>00126     {
<a name="l00127"></a>00127       tab2[tab1[i]-1]=i+1;
<a name="l00128"></a>00128       rang_voisin[i]=tab1[i];
<a name="l00129"></a>00129     }
<a name="l00130"></a>00130 
<a name="l00131"></a>00131 <span class="comment">// on traite les faces internes pour les voisins</span>
<a name="l00132"></a>00132 
<a name="l00133"></a>00133   <span class="keywordflow">for</span> (num_face=ndeb; num_face&lt;nfin; num_face++)
<a name="l00134"></a>00134     {
<a name="l00135"></a>00135       elem1 = face_voisins(num_face,0);
<a name="l00136"></a>00136       elem2 = face_voisins(num_face,1);
<a name="l00137"></a>00137 
<a name="l00138"></a>00138       <span class="keywordflow">for</span> (k=0; k&lt;nb_comp; k++)
<a name="l00139"></a>00139         {
<a name="l00140"></a>00140           tab2[rang_voisin[elem2*nb_comp+k]]=elem1*nb_comp+1+k;
<a name="l00141"></a>00141           rang_voisin[elem2*nb_comp+k]++;
<a name="l00142"></a>00142 
<a name="l00143"></a>00143           tab2[rang_voisin[elem1*nb_comp+k]]=elem2*nb_comp+1+k;
<a name="l00144"></a>00144           rang_voisin[elem1*nb_comp+k]++;
<a name="l00145"></a>00145         }
<a name="l00146"></a>00146     }
<a name="l00147"></a>00147 <span class="comment">// Cerr &lt;&lt; &quot;tab2 = &quot; &lt;&lt; tab2 &lt;&lt; finl;</span>
<a name="l00148"></a>00148 <span class="comment">// on traite la condition de periodicite</span>
<a name="l00149"></a>00149   <span class="keywordflow">for</span> (i=0; i&lt;les_cl.<a class="code" href="classvect__impl.html#a78155bfbd6b61f4710b9830641ed1694">size</a>(); i++)
<a name="l00150"></a>00150     {
<a name="l00151"></a>00151       <span class="keyword">const</span> <a class="code" href="classCond__lim.html" title="classe Cond_lim Classe generique servant a representer n&#39;importe quelle classe derivee de la classe C...">Cond_lim</a>&amp; la_cl = les_cl[i];
<a name="l00152"></a>00152       <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>()) )
<a name="l00153"></a>00153         {
<a name="l00154"></a>00154           <span class="keyword">const</span> <a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>&amp; la_cl_perio = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>());
<a name="l00155"></a>00155           <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp; la_front_dis = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>,la_cl.<a class="code" href="classCond__lim.html#a5b2d24809cee07727006a891d4ce8d22" title="Appel a l&#39;objet sous-jacent Renvoie la frontiere discretisee associee a la condition aux limites...">frontiere_dis</a>());
<a name="l00156"></a>00156           <span class="keywordtype">int</span> numdeb = la_front_dis.num_premiere_face();
<a name="l00157"></a>00157           <span class="keywordtype">int</span> nfaces = la_front_dis.nb_faces();
<a name="l00158"></a>00158           <span class="keywordtype">int</span> ind_face_local;
<a name="l00159"></a>00159           <a class="code" href="classIntVect.html">IntVect</a> fait(nfaces);
<a name="l00160"></a>00160           fait = 0;
<a name="l00161"></a>00161           <span class="keywordflow">for</span> (ind_face_local=0; ind_face_local&lt;nfaces; ind_face_local++)
<a name="l00162"></a>00162             {
<a name="l00163"></a>00163 <span class="comment">// ind_face_local = num_face - ndeb;</span>
<a name="l00164"></a>00164               <span class="keywordflow">if</span> (fait[ind_face_local] == 0)
<a name="l00165"></a>00165                 {
<a name="l00166"></a>00166                   num_face = numdeb + ind_face_local;
<a name="l00167"></a>00167                   fait[ind_face_local] = 1;
<a name="l00168"></a>00168                   fait[la_cl_perio.<a class="code" href="classPeriodique.html#a207b86556f199a63ea059b841851ca6a">face_associee</a>(ind_face_local)] = 1;
<a name="l00169"></a>00169 
<a name="l00170"></a>00170                   elem1 = face_voisins(num_face,0);
<a name="l00171"></a>00171                   elem2 = face_voisins(num_face,1);
<a name="l00172"></a>00172 
<a name="l00173"></a>00173                   <span class="keywordflow">for</span> (k=0; k&lt;nb_comp; k++)
<a name="l00174"></a>00174                     {
<a name="l00175"></a>00175                       tab2[rang_voisin[elem2*nb_comp+k]]=elem1*nb_comp+1+k;
<a name="l00176"></a>00176                       rang_voisin[elem2*nb_comp+k]++;
<a name="l00177"></a>00177 
<a name="l00178"></a>00178                       tab2[rang_voisin[elem1*nb_comp+k]]=elem2*nb_comp+1+k;
<a name="l00179"></a>00179                       rang_voisin[elem1*nb_comp+k]++;
<a name="l00180"></a>00180                     }
<a name="l00181"></a>00181                 }
<a name="l00182"></a>00182             }
<a name="l00183"></a>00183         }
<a name="l00184"></a>00184     }
<a name="l00185"></a>00185 <span class="comment">// Cerr &lt;&lt; &quot;tab2 = &quot; &lt;&lt; tab2 &lt;&lt; finl;</span>
<a name="l00186"></a>00186 }
<a name="l00187"></a>00187 
<a name="l00188"></a><a class="code" href="classOp__PolyMAC__Elem.html#a8804ee21edf6ea29c616757b19609628">00188</a> <span class="keywordtype">void</span> <a class="code" href="classOp__PolyMAC__Elem.html#a8804ee21edf6ea29c616757b19609628">Op_PolyMAC_Elem::dimensionner_bloc_vitesse</a>(<span class="keyword">const</span> <a class="code" href="classZone__PolyMAC.html" title="class Zone_PolyMAC Classe instanciable qui derive de Zone_VF. Cette classe contient les informations ...">Zone_PolyMAC</a>&amp; la_zone,
<a name="l00189"></a>00189                                                 <span class="keyword">const</span> <a class="code" href="classZone__Cl__PolyMAC.html">Zone_Cl_PolyMAC</a>&amp; la_zone_cl,
<a name="l00190"></a>00190                                                 <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; matrice)<span class="keyword"> const</span>
<a name="l00191"></a>00191 <span class="keyword"></span>{
<a name="l00192"></a>00192 
<a name="l00193"></a>00193   <span class="keywordtype">int</span> nb_faces=la_zone.<a class="code" href="classZone__VF.html#aede27992d9f2eedd52c24d4a80ff7ffb" title="renvoie le nombre global de faces.">nb_faces</a>();
<a name="l00194"></a>00194   <span class="keywordtype">int</span> nb_faces_tot=la_zone.<a class="code" href="classZone__VF.html#a50fd21c9535680489015a3c8b88c685a" title="renvoie le nombre total de faces. C&#39;est-a-dire faces reelles + faces virtuelles">nb_faces_tot</a>();
<a name="l00195"></a>00195   <span class="keywordtype">int</span> nb_elem_tot=la_zone.<a class="code" href="classZone__dis__base.html#a4d6aa445f152aa6dc54d66ea7a071147">nb_elem_tot</a>();
<a name="l00196"></a>00196   <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a> stencyl(0,2);
<a name="l00197"></a>00197   stencyl.<a class="code" href="classArrOfInt.html#a22d744bcd452d039580d1d9186f02b4e" title="Change le mode l&#39;allocation memoire: reallocation d&#39;un tableau a chaque changement de taille (flag = ...">set_smart_resize</a>(1);
<a name="l00198"></a>00198   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; face_voisins = la_zone.<a class="code" href="classZone__VF.html#a49d4322f5585a8fa95748ca785b70702" title="renvoie l&#39;element voisin de numface dans la direction i. i=0 : dans le sens oppose de l&#39;axe orthogona...">face_voisins</a>();
<a name="l00199"></a>00199 
<a name="l00200"></a>00200   <span class="keywordtype">int</span> nb_coef=0;
<a name="l00201"></a>00201   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> face=0; face&lt;nb_faces; face++)
<a name="l00202"></a>00202     {
<a name="l00203"></a>00203       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> dir=0; dir&lt;2; dir++)
<a name="l00204"></a>00204         {
<a name="l00205"></a>00205           <span class="keywordtype">int</span> elem=face_voisins(face,dir);
<a name="l00206"></a>00206           <span class="keywordflow">if</span> (elem!=-1)
<a name="l00207"></a>00207             {
<a name="l00208"></a>00208               stencyl.<a class="code" href="classIntTab.html#a22e6bed6826b3688d4d0181cbf3b7a38" title="Change la taille du vecteur (identique a resize_array() pour le traitement des anciennes valeurs et d...">resize</a>(nb_coef+1,2);
<a name="l00209"></a>00209               stencyl(nb_coef,0)=elem;
<a name="l00210"></a>00210               stencyl(nb_coef,1)=face;
<a name="l00211"></a>00211               nb_coef++;
<a name="l00212"></a>00212             }
<a name="l00213"></a>00213         }
<a name="l00214"></a>00214     }
<a name="l00215"></a>00215   <a class="code" href="Array__tools_8cpp.html#a07eed4c823b0632bdbf353fdab2a3c6b" title="Trie le tableau tab dans l&#39;ordre lexicographique et retire les doublons (attention [1...">tableau_trier_retirer_doublons</a>(stencyl);
<a name="l00216"></a>00216   <a class="code" href="classMatrix__tools.html#a481961691c1dbee5372da25777e5c1e8">Matrix_tools::allocate_morse_matrix</a>(nb_elem_tot,nb_faces_tot,stencyl,matrice);
<a name="l00217"></a>00217 
<a name="l00218"></a>00218 }
<a name="l00219"></a>00219 
<a name="l00220"></a>00220 
<a name="l00221"></a><a class="code" href="classOp__PolyMAC__Elem.html#ad0294dd8aad7be38527fcf31898b88af">00221</a> <span class="keywordtype">void</span> <a class="code" href="classOp__PolyMAC__Elem.html#ad0294dd8aad7be38527fcf31898b88af">Op_PolyMAC_Elem:: modifier_pour_Cl</a>(<span class="keyword">const</span> <a class="code" href="classZone__PolyMAC.html" title="class Zone_PolyMAC Classe instanciable qui derive de Zone_VF. Cette classe contient les informations ...">Zone_PolyMAC</a>&amp; la_zone,
<a name="l00222"></a>00222                                         <span class="keyword">const</span> <a class="code" href="classZone__Cl__PolyMAC.html">Zone_Cl_PolyMAC</a>&amp; la_zone_cl,
<a name="l00223"></a>00223                                         <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; la_matrice, <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; secmem)<span class="keyword"> const</span>
<a name="l00224"></a>00224 <span class="keyword"></span>{
<a name="l00225"></a>00225 <span class="comment">// Dimensionnement de la matrice qui devra recevoir les coefficients provenant de</span>
<a name="l00226"></a>00226 <span class="comment">// la convection, de la diffusion pour le cas des faces.</span>
<a name="l00227"></a>00227 <span class="comment">// Cette matrice a une structure de matrice morse.</span>
<a name="l00228"></a>00228 <span class="comment">// Nous commencons par calculer les tailles des tableaux tab1 et tab2.</span>
<a name="l00229"></a>00229 
<a name="l00230"></a>00230 <span class="comment">// int nfin = la_zone.nb_faces();</span>
<a name="l00231"></a>00231 <span class="comment">// const Conds_lim&amp; les_cl = la_zone_cl.les_conditions_limites();</span>
<a name="l00232"></a>00232 <span class="comment">// const IntVect&amp; orientation=la_zone.orientation();</span>
<a name="l00233"></a>00233 
<a name="l00234"></a>00234 <span class="comment">// Prise en compte des conditions de type periodicite</span>
<a name="l00235"></a>00235 <span class="comment">// Cerr &lt;&lt; &quot;dans Op_PolyMAC_Elem:: modifier_pour_Cl&quot; &lt;&lt; finl;</span>
<a name="l00236"></a>00236 
<a name="l00237"></a>00237 }
<a name="l00238"></a>00238 
</pre></div></div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Tue Dec 14 2021 19:35:30 for TRUST by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
