<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>TRUST: src/VEF/Operateurs/Op_Conv_VEF_Face.cpp Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">TRUST&#160;<span id="projectnumber">1.8.4</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
<div class="header">
  <div class="headertitle">
<div class="title">src/VEF/Operateurs/Op_Conv_VEF_Face.cpp</div>  </div>
</div>
<div class="contents">
<a href="Op__Conv__VEF__Face_8cpp.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/****************************************************************************</span>
<a name="l00002"></a>00002 <span class="comment">* Copyright (c) 2019, CEA</span>
<a name="l00003"></a>00003 <span class="comment">* All rights reserved.</span>
<a name="l00004"></a>00004 <span class="comment">*</span>
<a name="l00005"></a>00005 <span class="comment">* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</span>
<a name="l00006"></a>00006 <span class="comment">* 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.</span>
<a name="l00007"></a>00007 <span class="comment">* 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.</span>
<a name="l00008"></a>00008 <span class="comment">* 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.</span>
<a name="l00009"></a>00009 <span class="comment">*</span>
<a name="l00010"></a>00010 <span class="comment">* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.</span>
<a name="l00011"></a>00011 <span class="comment">* IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;</span>
<a name="l00012"></a>00012 <span class="comment">* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>
<a name="l00013"></a>00013 <span class="comment">*</span>
<a name="l00014"></a>00014 <span class="comment">*****************************************************************************/</span>
<a name="l00015"></a>00015 <span class="comment">//</span>
<a name="l00016"></a>00016 <span class="comment">// </span>
<a name="l00017"></a>00017 <span class="comment">// File:        Op_Conv_VEF_Face.cpp</span>
<a name="l00018"></a>00018 <span class="comment">// Directory:   $TRUST_ROOT/src/VEF/Operateurs</span>
<a name="l00019"></a>00019 <span class="comment">// Version:     /main/46</span>
<a name="l00020"></a>00020 <span class="comment">// </span>
<a name="l00021"></a>00021 <span class="comment">//</span>
<a name="l00022"></a>00022 
<a name="l00023"></a>00023 <span class="preprocessor">#include &lt;<a class="code" href="Op__Conv__VEF__Face_8h.html">Op_Conv_VEF_Face.h</a>&gt;</span>
<a name="l00024"></a>00024 <span class="preprocessor">#include &lt;<a class="code" href="Champ__P1NC_8h.html">Champ_P1NC.h</a>&gt;</span>
<a name="l00025"></a>00025 <span class="preprocessor">#include &lt;<a class="code" href="Porosites__champ_8h.html">Porosites_champ.h</a>&gt;</span>
<a name="l00026"></a>00026 <span class="preprocessor">#include &lt;<a class="code" href="Debog_8h.html">Debog.h</a>&gt;</span>
<a name="l00027"></a>00027 <span class="preprocessor">#include &lt;<a class="code" href="stat__counters_8h.html">stat_counters.h</a>&gt;</span>
<a name="l00028"></a>00028 <span class="preprocessor">#include &lt;<a class="code" href="Convection__tools_8h.html">Convection_tools.h</a>&gt;</span>
<a name="l00029"></a><a class="code" href="Op__Conv__VEF__Face_8cpp.html#a6078457e0369b0892d3f0949c9e16f7d">00029</a> <a class="code" href="Declare__Inst_8h.html#afcab3f7633508e92f2077d767e19bc60">Implemente_instanciable_sans_constructeur</a>(<a class="code" href="classOp__Conv__VEF__Face.html" title="class Op_Conv_VEF_Face Cette classe represente l&#39;operateur de convection associe a une equation de tr...">Op_Conv_VEF_Face</a>,<span class="stringliteral">&quot;Op_Conv_Generic_VEF_P1NC&quot;</span>,<a class="code" href="classOp__Conv__VEF__base.html" title="class Op_Conv_VEF_base Classe de base des operateurs de convection VEF">Op_Conv_VEF_base</a>);
<a name="l00030"></a>00030 
<a name="l00031"></a>00031 <span class="comment"></span>
<a name="l00032"></a>00032 <span class="comment">////!&lt; printOn </span>
<a name="l00033"></a>00033 <span class="comment"></span><span class="comment">//</span>
<a name="l00034"></a><a class="code" href="classOp__Conv__VEF__Face.html#a8eacb11670d5ea5cc15ed16632d15360">00034</a> <a class="code" href="classSortie.html" title="Classe de base des flux de sortie. Elle sait ecrire des types simples&lt;br&gt;(entiers, flottants) et des Ob...">Sortie</a>&amp; <a class="code" href="classOp__Conv__VEF__Face.html#a8eacb11670d5ea5cc15ed16632d15360" title="NE FAIT RIEN A surcharger dans les classes derivees.">Op_Conv_VEF_Face::printOn</a>(<a class="code" href="classSortie.html" title="Classe de base des flux de sortie. Elle sait ecrire des types simples&lt;br&gt;(entiers, flottants) et des Ob...">Sortie</a>&amp; s )<span class="keyword"> const</span>
<a name="l00035"></a>00035 <span class="keyword"></span>{
<a name="l00036"></a>00036   <span class="keywordflow">return</span> s &lt;&lt; <a class="code" href="classObjet__U.html#aa58e9a81c0ddc2c1149053b8f96698ac" title="renvoie la chaine identifiant la classe.">que_suis_je</a>() ;
<a name="l00037"></a>00037 }
<a name="l00038"></a>00038 <span class="comment"></span>
<a name="l00039"></a>00039 <span class="comment">////!&lt; readOn </span>
<a name="l00040"></a>00040 <span class="comment"></span><span class="comment">//</span>
<a name="l00041"></a><a class="code" href="classOp__Conv__VEF__Face.html#a20514a9862bc5e8a557eadc1b8860a2a">00041</a> <a class="code" href="classEntree.html" title="Classe de definition des operateurs et methodes pour toute lecture dans un flot d&#39;entree (fichier...">Entree</a>&amp; <a class="code" href="classOp__Conv__VEF__Face.html#a20514a9862bc5e8a557eadc1b8860a2a" title="NE FAIT RIEN A surcharger dans les classes derivees.">Op_Conv_VEF_Face::readOn</a>(<a class="code" href="classEntree.html" title="Classe de definition des operateurs et methodes pour toute lecture dans un flot d&#39;entree (fichier...">Entree</a>&amp; s )
<a name="l00042"></a>00042 {
<a name="l00043"></a>00043   <a class="code" href="classMotcle.html" title="Une chaine de caractere (Nom) en majuscules.">Motcle</a> type_op_lu;
<a name="l00044"></a>00044   s &gt;&gt; type_op_lu;
<a name="l00045"></a>00045 
<a name="l00046"></a>00046   <span class="keywordflow">if</span> (!(type_op_lu==<span class="stringliteral">&quot;amont&quot;</span>) &amp;&amp; !(type_op_lu==<span class="stringliteral">&quot;muscl&quot;</span>) &amp;&amp; !(type_op_lu==<span class="stringliteral">&quot;centre&quot;</span>))
<a name="l00047"></a>00047     {
<a name="l00048"></a>00048       <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; type_op_lu &lt;&lt; <span class="stringliteral">&quot; n&#39;est pas compris par &quot;</span> &lt;&lt; <a class="code" href="classObjet__U.html#aa58e9a81c0ddc2c1149053b8f96698ac" title="renvoie la chaine identifiant la classe.">que_suis_je</a>() &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
<a name="l00049"></a>00049       <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot; choisir parmi : amont - muscl - centre &quot;</span> &lt;&lt; finl;
<a name="l00050"></a>00050       <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">exit</a>();
<a name="l00051"></a>00051     }
<a name="l00052"></a>00052 
<a name="l00053"></a>00053   <span class="keywordflow">if</span> (type_op_lu==<span class="stringliteral">&quot;muscl&quot;</span>)
<a name="l00054"></a>00054     {
<a name="l00055"></a>00055       <a class="code" href="classOp__Conv__VEF__Face.html#aac6bde5c9421ce149a3f28a11709b1f6">type_op</a> = <a class="code" href="classOp__Conv__VEF__Face.html#abbf17549ccbad9c64780dcca7a3e2634af9bc4313cad73dd46e9d5364c4f001b3">muscl</a>;
<a name="l00056"></a>00056       s &gt;&gt; <a class="code" href="classOp__Conv__VEF__Face.html#a070e3e30a22b79bd58ac3bd36f7802f6">type_lim</a>;
<a name="l00057"></a>00057 
<a name="l00058"></a>00058       <span class="keywordflow">if</span> ( !(type_lim==<span class="stringliteral">&quot;minmod&quot;</span>) &amp;&amp; !(type_lim==<span class="stringliteral">&quot;vanleer&quot;</span>) &amp;&amp; !(type_lim==<span class="stringliteral">&quot;vanalbada&quot;</span>)
<a name="l00059"></a>00059            &amp;&amp;  !(type_lim==<span class="stringliteral">&quot;chakravarthy&quot;</span>) &amp;&amp; !(type_lim==<span class="stringliteral">&quot;superbee&quot;</span>) )
<a name="l00060"></a>00060         {
<a name="l00061"></a>00061           <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; type_lim &lt;&lt; <span class="stringliteral">&quot; n&#39;est pas compris par &quot;</span> &lt;&lt; <a class="code" href="classObjet__U.html#aa58e9a81c0ddc2c1149053b8f96698ac" title="renvoie la chaine identifiant la classe.">que_suis_je</a>() &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
<a name="l00062"></a>00062           <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot; choisir parmi : minmod - vanleer - vanalbada - chakravarthy - superbee &quot;</span> &lt;&lt; finl;
<a name="l00063"></a>00063           <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">exit</a>();
<a name="l00064"></a>00064         }
<a name="l00065"></a>00065 
<a name="l00066"></a>00066       <span class="keywordflow">if</span> (type_lim==<span class="stringliteral">&quot;minmod&quot;</span>) <a class="code" href="classOp__Conv__VEF__Face.html#a5a58e90633d9d06d20e898980ab9c4da">LIMITEUR</a>=&amp;<a class="code" href="Convection__tools_8cpp.html#acd40757070ae472ea829cf1cb522d91a">minmod</a>;
<a name="l00067"></a>00067       <span class="keywordflow">if</span> (type_lim==<span class="stringliteral">&quot;vanleer&quot;</span>) <a class="code" href="classOp__Conv__VEF__Face.html#a5a58e90633d9d06d20e898980ab9c4da">LIMITEUR</a>=&amp;<a class="code" href="Convection__tools_8cpp.html#a1a4e56eba2ab02a6dc14150e0c64aaa9">vanleer</a>;
<a name="l00068"></a>00068       <span class="keywordflow">if</span> (type_lim==<span class="stringliteral">&quot;vanalbada&quot;</span>) <a class="code" href="classOp__Conv__VEF__Face.html#a5a58e90633d9d06d20e898980ab9c4da">LIMITEUR</a>=&amp;<a class="code" href="Convection__tools_8cpp.html#a76960377768725078abb6c302d998684">vanalbada</a>;
<a name="l00069"></a>00069       <span class="keywordflow">if</span> (type_lim==<span class="stringliteral">&quot;chakravarthy&quot;</span>) <a class="code" href="classOp__Conv__VEF__Face.html#a5a58e90633d9d06d20e898980ab9c4da">LIMITEUR</a>=&amp;<a class="code" href="Convection__tools_8cpp.html#a87e787b999612072da5bb5d40d9af9c7">chakravarthy</a>;
<a name="l00070"></a>00070       <span class="keywordflow">if</span> (type_lim==<span class="stringliteral">&quot;superbee&quot;</span>) <a class="code" href="classOp__Conv__VEF__Face.html#a5a58e90633d9d06d20e898980ab9c4da">LIMITEUR</a>=&amp;<a class="code" href="Convection__tools_8cpp.html#acb830b6dc6f01da7073bcd2336e9b621">superbee</a>;
<a name="l00071"></a>00071 
<a name="l00072"></a>00072       s &gt;&gt; <a class="code" href="classOp__Conv__VEF__Face.html#ad30e1a556295f226b7ef1215dc0030e5">ordre</a>;
<a name="l00073"></a>00073 
<a name="l00074"></a>00074       <span class="keywordflow">if</span> (ordre!=1 &amp;&amp; ordre!=2 &amp;&amp; ordre!=3)
<a name="l00075"></a>00075         {
<a name="l00076"></a>00076           <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;l&#39;ordre apres &quot;</span> &lt;&lt; type_lim &lt;&lt; <span class="stringliteral">&quot; dans &quot;</span> &lt;&lt; <a class="code" href="classObjet__U.html#aa58e9a81c0ddc2c1149053b8f96698ac" title="renvoie la chaine identifiant la classe.">que_suis_je</a>() &lt;&lt; <span class="stringliteral">&quot; doit etre soit 1, soit 2, soit 3&quot;</span> &lt;&lt;  <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
<a name="l00077"></a>00077           <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">exit</a>();
<a name="l00078"></a>00078         }
<a name="l00079"></a>00079       <span class="keywordflow">if</span> (ordre==3)
<a name="l00080"></a>00080         {
<a name="l00081"></a>00081 <span class="comment">// Lecture de alpha_</span>
<a name="l00082"></a>00082           s &gt;&gt; <a class="code" href="classOp__Conv__VEF__Face.html#aebc1771cc4608fc51a8b6d15b93c8d3d">alpha_</a>;
<a name="l00083"></a>00083         }
<a name="l00084"></a>00084     }
<a name="l00085"></a>00085 
<a name="l00086"></a>00086   <span class="keywordflow">if</span> (type_op_lu==<span class="stringliteral">&quot;centre&quot;</span>)
<a name="l00087"></a>00087     {
<a name="l00088"></a>00088       <a class="code" href="classOp__Conv__VEF__Face.html#aac6bde5c9421ce149a3f28a11709b1f6">type_op</a> = <a class="code" href="classOp__Conv__VEF__Face.html#abbf17549ccbad9c64780dcca7a3e2634aeb4b20f4ab0bb61c69bfbf25d47d219d">centre</a>;
<a name="l00089"></a>00089       s &gt;&gt; <a class="code" href="classOp__Conv__VEF__Face.html#ad30e1a556295f226b7ef1215dc0030e5">ordre</a>;
<a name="l00090"></a>00090 
<a name="l00091"></a>00091       <span class="keywordflow">if</span> (ordre!=1 &amp;&amp; ordre!=2)
<a name="l00092"></a>00092         {
<a name="l00093"></a>00093           <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;l&#39;ordre apres &quot;</span> &lt;&lt; type_op_lu &lt;&lt; <span class="stringliteral">&quot; dans &quot;</span> &lt;&lt; <a class="code" href="classObjet__U.html#aa58e9a81c0ddc2c1149053b8f96698ac" title="renvoie la chaine identifiant la classe.">que_suis_je</a>() &lt;&lt; <span class="stringliteral">&quot; doit etre soit 1, soit 2 &quot;</span> &lt;&lt;  <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
<a name="l00094"></a>00094           <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">exit</a>();
<a name="l00095"></a>00095         }
<a name="l00096"></a>00096     }
<a name="l00097"></a>00097 
<a name="l00098"></a>00098   <span class="keywordflow">if</span> (type_op_lu==<span class="stringliteral">&quot;amont&quot;</span>)
<a name="l00099"></a>00099     {
<a name="l00100"></a>00100       <a class="code" href="classOp__Conv__VEF__Face.html#aac6bde5c9421ce149a3f28a11709b1f6">type_op</a> = <a class="code" href="classOp__Conv__VEF__Face.html#abbf17549ccbad9c64780dcca7a3e2634a1192ae3f2c2a1d9d734f4cc495b58a44">amont</a>;
<a name="l00101"></a>00101       <a class="code" href="classOp__Conv__VEF__Face.html#ad30e1a556295f226b7ef1215dc0030e5">ordre</a> = 1;
<a name="l00102"></a>00102     }
<a name="l00103"></a>00103 
<a name="l00104"></a>00104   <span class="keywordflow">return</span> s ;
<a name="l00105"></a>00105 }
<a name="l00106"></a>00106 
<a name="l00107"></a>00107 <span class="comment">// </span>
<a name="l00108"></a>00108 <span class="comment">// Fonctions de la classe Op_Conv_VEF_Face</span>
<a name="l00109"></a>00109 <span class="comment">// </span>
<a name="l00110"></a>00110 <span class="comment">//</span>
<a name="l00111"></a>00111 <span class="comment">// </span>
<a name="l00112"></a>00112 <span class="comment">// Implementation des fonctions</span>
<a name="l00113"></a>00113 <span class="comment">// </span>
<a name="l00114"></a>00114 <span class="comment">// de la classe Op_Conv_VEF_Face</span>
<a name="l00115"></a>00115 <span class="comment">// </span>
<a name="l00116"></a>00116 <span class="comment">//</span>
<a name="l00117"></a>00117 
<a name="l00118"></a>00118 
<a name="l00119"></a>00119 
<a name="l00120"></a>00120 
<a name="l00121"></a><a class="code" href="classOp__Conv__VEF__Face.html#a88409d0b56b9e0db3d4f241a09930f82">00121</a> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; <a class="code" href="classOp__Conv__VEF__Face.html#a88409d0b56b9e0db3d4f241a09930f82">Op_Conv_VEF_Face::ajouter</a>(<span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; transporte,
<a name="l00122"></a>00122                                      <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; resu)<span class="keyword"> const</span>
<a name="l00123"></a>00123 <span class="keyword"></span>{
<a name="l00124"></a>00124 <span class="comment">// statistiques().begin_count(m1);</span>
<a name="l00125"></a>00125   assert((<a class="code" href="classOp__Conv__VEF__Face.html#aac6bde5c9421ce149a3f28a11709b1f6">type_op</a>==<a class="code" href="classOp__Conv__VEF__Face.html#abbf17549ccbad9c64780dcca7a3e2634a1192ae3f2c2a1d9d734f4cc495b58a44">amont</a>) || (<a class="code" href="classOp__Conv__VEF__Face.html#aac6bde5c9421ce149a3f28a11709b1f6">type_op</a>==<a class="code" href="classOp__Conv__VEF__Face.html#abbf17549ccbad9c64780dcca7a3e2634af9bc4313cad73dd46e9d5364c4f001b3">muscl</a>) || (<a class="code" href="classOp__Conv__VEF__Face.html#aac6bde5c9421ce149a3f28a11709b1f6">type_op</a>==<a class="code" href="classOp__Conv__VEF__Face.html#abbf17549ccbad9c64780dcca7a3e2634aeb4b20f4ab0bb61c69bfbf25d47d219d">centre</a>));
<a name="l00126"></a>00126   <span class="keyword">const</span> <a class="code" href="classZone__Cl__VEF.html">Zone_Cl_VEF</a>&amp; zone_Cl_VEF = <a class="code" href="classOp__Conv__VEF__base.html#a03f677ee7911706a4f85cd37e0ca4535">la_zcl_vef</a>.<a class="code" href="classRef__Zone__Cl__VEF.html#a0970d7253def65ad4f0c5ce1830fd243">valeur</a>();
<a name="l00127"></a>00127   <span class="keyword">const</span> <a class="code" href="classZone__VEF.html" title="class Zone_VEF Classe instanciable qui derive de Zone_VF. Cette classe contient les informations geom...">Zone_VEF</a>&amp; zone_VEF = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classZone__VEF.html" title="class Zone_VEF Classe instanciable qui derive de Zone_VF. Cette classe contient les informations geom...">Zone_VEF</a>, <a class="code" href="classOp__Conv__VEF__base.html#a6c29a488a6805ba4a9f2f059cdba77ae">la_zone_vef</a>.<a class="code" href="classRef__Zone__VEF.html#aafd9a5ee1a76f290c9c6b5447b0c8d30">valeur</a>());
<a name="l00128"></a>00128   <span class="keyword">const</span> <a class="code" href="classChamp__Inc__base.html" title="Classe Champ_Inc_base Classe de base des champs inconnues qui sont les champs calcules par une equati...">Champ_Inc_base</a>&amp; la_vitesse=<a class="code" href="classOp__Conv__VEF__base.html#a4872ffd7c638ecc415191d92d7f5f507">vitesse</a>();
<a name="l00129"></a>00129   <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; vitesse_face_absolue=la_vitesse.valeurs();
<a name="l00130"></a>00130   <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; porosite_face = zone_VEF.<a class="code" href="classZone__VF.html#ad9d74d1d9da9f50ab26768dbbca7711b">porosite_face</a>();
<a name="l00131"></a>00131 
<a name="l00132"></a>00132   <span class="keywordtype">int</span> marq=<a class="code" href="classOp__Conv__VEF__base.html#ad380b9b9ca1d70282b289838a604a4b0" title="definit si l&#39;on convecte psi avec phi*u ou avec u">phi_u_transportant</a>(<a class="code" href="classMorEqn.html#a615dd9abff96edcb625fa0424a489864" title="Renvoie la reference sur l&#39;equation pointe par MorEqn::mon_equation. (version const)">equation</a>());
<a name="l00133"></a>00133   <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a> transporte_face_;
<a name="l00134"></a>00134   <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a> vitesse_face_;
<a name="l00135"></a>00135 <span class="comment">// soit on a transporte_face=phi*transporte et vitesse_face=vitesse</span>
<a name="l00136"></a>00136 <span class="comment">// soit on a transporte_face=transporte et vitesse_face=phi*vitesse</span>
<a name="l00137"></a>00137 <span class="comment">// cela depend si on transporte avec phi*u ou avec u.</span>
<a name="l00138"></a>00138   <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; transporte_face = <a class="code" href="Porosites__champ_8cpp.html#a2340e7d73d0f9d34926d012fe1b1d884" title="renvoit le tableau res, res=org si flag=0, res= porosite*org sinon attention ne pas modifier res car ...">modif_par_porosite_si_flag</a>(transporte,transporte_face_,!marq,porosite_face);
<a name="l00139"></a>00139   <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; vitesse_face    = <a class="code" href="Porosites__champ_8cpp.html#a2340e7d73d0f9d34926d012fe1b1d884" title="renvoit le tableau res, res=org si flag=0, res= porosite*org sinon attention ne pas modifier res car ...">modif_par_porosite_si_flag</a>(vitesse_face_absolue,vitesse_face_,marq,porosite_face);
<a name="l00140"></a>00140 
<a name="l00141"></a>00141   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; elem_faces = zone_VEF.<a class="code" href="classZone__VF.html#a067e462dcd3ab92b0f6d945b19e4eb37" title="renvoie le numero de le ieme face de la maille num_elem la facon dont ces faces sont numerotees est l...">elem_faces</a>();
<a name="l00142"></a>00142   <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; facenormales = zone_VEF.<a class="code" href="classZone__VEF.html#a5742d75972e4846bf9fbb6ed5715053e">face_normales</a>();
<a name="l00143"></a>00143   <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; facette_normales = zone_VEF.<a class="code" href="classZone__VEF.html#a581b1ca0e62c668c92f104351d19fda6">facette_normales</a>();
<a name="l00144"></a>00144   <span class="keyword">const</span> <a class="code" href="classZone.html" title="classe Zone Une Zone est un maillage compose d&#39;un ensemble d&#39;elements geometriques de meme type...">Zone</a>&amp; zone = zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>();
<a name="l00145"></a>00145   <span class="keyword">const</span> <span class="keywordtype">int</span> nfa7 = zone_VEF.<a class="code" href="classZone__VEF.html#a46693c060b8096fb2595ca72192eea2a">type_elem</a>().<a class="code" href="classElem__VEF.html#a4a34777c0083b38dd34c8a400d5b4e90">nb_facette</a>();
<a name="l00146"></a>00146   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_elem_tot = zone_VEF.<a class="code" href="classZone__dis__base.html#a4d6aa445f152aa6dc54d66ea7a071147">nb_elem_tot</a>();
<a name="l00147"></a>00147   <span class="keyword">const</span> <a class="code" href="classIntVect.html">IntVect</a>&amp; rang_elem_non_std = zone_VEF.<a class="code" href="classZone__VEF.html#a4b2171a85e5fc33663a3366acb713584">rang_elem_non_std</a>();
<a name="l00148"></a>00148   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; face_voisins = zone_VEF.<a class="code" href="classZone__VF.html#a49d4322f5585a8fa95748ca785b70702" title="renvoie l&#39;element voisin de numface dans la direction i. i=0 : dans le sens oppose de l&#39;axe orthogona...">face_voisins</a>();
<a name="l00149"></a>00149   <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; normales_facettes_Cl = zone_Cl_VEF.<a class="code" href="classZone__Cl__VEF.html#a83c05e82370553470ed05f10932e0f3f">normales_facettes_Cl</a>();
<a name="l00150"></a>00150   <span class="keywordtype">int</span> premiere_face_int = zone_VEF.<a class="code" href="classZone__VF.html#a12869806fa4834aca8f2964e16509dfd" title="une face est interne ssi elle separe deux elements. renvoie le numero de la premiere face interne...">premiere_face_int</a>();
<a name="l00151"></a>00151   <span class="keywordtype">int</span> nfac = zone.<a class="code" href="classZone.html#a548fbc7518be2f122b1a5c9589a443c2" title="Renvoie le nombre de face de type i des elements geometriques constituants la zone. Ex: les objets de la classe Prisme ont 2 types de faces: triangle ou quadrangle.">nb_faces_elem</a>();
<a name="l00152"></a>00152   <span class="keywordtype">int</span> nsom = zone.<a class="code" href="classZone.html#ae0b34a93b9ae8146df2d1884157afe9f" title="Renvoie le nombre de sommets des elements geometriques constituants la zone. Tous les elements de la ...">nb_som_elem</a>();
<a name="l00153"></a>00153   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; sommet_elem = zone.<a class="code" href="classZone.html#ac115e8342be89afb882b7b61cc343267" title="Renvoie le tableau des sommets des elements.">les_elems</a>();
<a name="l00154"></a>00154   <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; vecteur_face_facette = <a class="code" href="Cast_8h.html#ad3836a067c92103af8df5ad8f35959a6">ref_cast_non_const</a>(<a class="code" href="classZone__VEF.html" title="class Zone_VEF Classe instanciable qui derive de Zone_VF. Cette classe contient les informations geom...">Zone_VEF</a>,zone_VEF).vecteur_face_facette();
<a name="l00155"></a>00155   <span class="keyword">const</span>  <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; vecteur_face_facette_Cl = zone_Cl_VEF.<a class="code" href="classZone__Cl__VEF.html#aa7acf4bf79e075ba2488e2ee9051c6fe">vecteur_face_facette_Cl</a>();
<a name="l00156"></a>00156   <span class="keywordtype">int</span> nb_bord = zone_VEF.<a class="code" href="classZone__dis__base.html#af22167d614644f55591a29c77eb1c009">nb_front_Cl</a>();
<a name="l00157"></a>00157   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; les_elems=zone.<a class="code" href="classZone.html#ac115e8342be89afb882b7b61cc343267" title="Renvoie le tableau des sommets des elements.">les_elems</a>();
<a name="l00158"></a>00158 
<a name="l00159"></a>00159 <span class="comment">// Permet d&#39;avoir un flux_bord coherent avec les CLs (mais parfois diverge?)</span>
<a name="l00160"></a>00160 <span class="comment">// Active uniquement pour ordre 3</span>
<a name="l00161"></a>00161   <span class="keywordtype">int</span> option_appliquer_cl_dirichlet = (<a class="code" href="classOp__Conv__VEF__Face.html#ad30e1a556295f226b7ef1215dc0030e5">ordre</a>==3 ? 1 : 0);
<a name="l00162"></a>00162   <span class="keywordtype">int</span> option_calcul_flux_en_un_point = 0;<span class="comment">//(ordre==3 ? 1 : 0);</span>
<a name="l00163"></a>00163 <span class="comment">// Definition d&#39;un tableau pour un traitement special des schemas pres des bords</span>
<a name="l00164"></a>00164   <span class="keywordflow">if</span> (<a class="code" href="classOp__Conv__VEF__Face.html#a4adb50fa6ba0bee8a6fbbc0a2655fe86">traitement_pres_bord_</a>.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>()!=nb_elem_tot)
<a name="l00165"></a>00165     {
<a name="l00166"></a>00166       <a class="code" href="classOp__Conv__VEF__Face.html#a4adb50fa6ba0bee8a6fbbc0a2655fe86">traitement_pres_bord_</a>.<a class="code" href="classArrOfInt.html#a9b3afbb46b16870dbd36236c8935b535">resize_array</a>(nb_elem_tot);
<a name="l00167"></a>00167       <a class="code" href="classOp__Conv__VEF__Face.html#a4adb50fa6ba0bee8a6fbbc0a2655fe86">traitement_pres_bord_</a>=0;
<a name="l00168"></a>00168 <span class="comment">// Pour muscl3 on applique le minmod sur les elements ayant une face de Dirichlet</span>
<a name="l00169"></a>00169       <span class="keywordflow">if</span> (<a class="code" href="classOp__Conv__VEF__Face.html#ad30e1a556295f226b7ef1215dc0030e5">ordre</a>==3)
<a name="l00170"></a>00170         {
<a name="l00171"></a>00171           <span class="keywordflow">for</span> (<span class="keywordtype">int</span> n_bord=0; n_bord&lt;nb_bord; n_bord++)
<a name="l00172"></a>00172             {
<a name="l00173"></a>00173               <span class="keyword">const</span> <a class="code" href="classCond__lim__base.html" title="classe Cond_lim_base Classe de base pour la hierarchie des classes qui representent les differentes c...">Cond_lim_base</a>&amp; la_cl = zone_Cl_VEF.<a class="code" href="classZone__Cl__dis__base.html#af75e0ed7786863e4d333bfb29d67c323" title="Renvoie la i-ieme condition aux limites. (version const)">les_conditions_limites</a>(n_bord).<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>();
<a name="l00174"></a>00174               <span class="keywordflow">if</span> ( <a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classDirichlet.html" title="classe Dirichlet Cette classe est la classe de base de la hierarchie des conditions aux limites de ty...">Dirichlet</a>,la_cl) || <a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classDirichlet__homogene.html" title="Classe Dirichlet_homogene Cette classe est la classe de base de la hierarchie des conditions aux limi...">Dirichlet_homogene</a>,la_cl) )
<a name="l00175"></a>00175                 {
<a name="l00176"></a>00176                   <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp; le_bord = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>,la_cl.<a class="code" href="classCond__lim__base.html#ad88b3b516351146c85e8fce1df0f691a" title="Renvoie la frontiere discretisee a laquelle les conditions aux limites s&#39;appliquent.">frontiere_dis</a>());
<a name="l00177"></a>00177                   <span class="keywordtype">int</span> nb_faces_tot = le_bord.<a class="code" href="classFront__VF.html#aed4006d91bf2ef3af2b9f7933d863a09" title="Nombre de faces reelles et virtuelles du bord.">nb_faces_tot</a>();
<a name="l00178"></a>00178                   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> ind_face=0; ind_face&lt;nb_faces_tot; ind_face++)
<a name="l00179"></a>00179                     {
<a name="l00180"></a>00180                       <span class="keywordtype">int</span> num_face = le_bord.<a class="code" href="classFront__VF.html#a3402a19d7e54ed797d2b18e9a47ead1e" title="Renvoie le numero de face de la ieme face du bord.">num_face</a>(ind_face);
<a name="l00181"></a>00181                       <span class="keywordtype">int</span> elem = face_voisins(num_face,0);
<a name="l00182"></a>00182                       <a class="code" href="classOp__Conv__VEF__Face.html#a4adb50fa6ba0bee8a6fbbc0a2655fe86">traitement_pres_bord_</a>(elem)=1;
<a name="l00183"></a>00183                     }
<a name="l00184"></a>00184                 }
<a name="l00185"></a>00185             }
<a name="l00186"></a>00186         }
<a name="l00187"></a>00187       <span class="keywordflow">else</span>
<a name="l00188"></a>00188         {
<a name="l00189"></a>00189 <span class="comment">// Pour le muscl/centre actuels on utilise un calcul de flux a l&#39;ordre 1</span>
<a name="l00190"></a>00190 <span class="comment">// aux mailles de bord ou aux mailles ayant un sommet de Dirichlet</span>
<a name="l00191"></a>00191           <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> est_un_sommet_de_bord_(zone_VEF.<a class="code" href="classZone__dis__base.html#a8f793341b7a41d67561ba563ae0f69a0">nb_som_tot</a>());
<a name="l00192"></a>00192           <span class="keywordflow">for</span> (<span class="keywordtype">int</span> n_bord=0; n_bord&lt;nb_bord; n_bord++)
<a name="l00193"></a>00193             {
<a name="l00194"></a>00194               <span class="keyword">const</span> <a class="code" href="classCond__lim__base.html" title="classe Cond_lim_base Classe de base pour la hierarchie des classes qui representent les differentes c...">Cond_lim_base</a>&amp; la_cl = zone_Cl_VEF.<a class="code" href="classZone__Cl__dis__base.html#af75e0ed7786863e4d333bfb29d67c323" title="Renvoie la i-ieme condition aux limites. (version const)">les_conditions_limites</a>(n_bord).<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>();
<a name="l00195"></a>00195               <span class="keywordflow">if</span> ( <a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classDirichlet.html" title="classe Dirichlet Cette classe est la classe de base de la hierarchie des conditions aux limites de ty...">Dirichlet</a>,la_cl) || <a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classDirichlet__homogene.html" title="Classe Dirichlet_homogene Cette classe est la classe de base de la hierarchie des conditions aux limi...">Dirichlet_homogene</a>,la_cl) )
<a name="l00196"></a>00196                 {
<a name="l00197"></a>00197                   <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp; le_bord = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>,la_cl.<a class="code" href="classCond__lim__base.html#ad88b3b516351146c85e8fce1df0f691a" title="Renvoie la frontiere discretisee a laquelle les conditions aux limites s&#39;appliquent.">frontiere_dis</a>());
<a name="l00198"></a>00198                   <span class="keywordtype">int</span> nb_faces_tot = le_bord.<a class="code" href="classFront__VF.html#aed4006d91bf2ef3af2b9f7933d863a09" title="Nombre de faces reelles et virtuelles du bord.">nb_faces_tot</a>();
<a name="l00199"></a>00199                   <span class="keywordtype">int</span> size = zone_VEF.<a class="code" href="classZone__VF.html#a298e73b18e17da55f421b1fb0879bd46" title="renvoie le numero du ieme sommet de la face num_face.">face_sommets</a>().dimension(1);
<a name="l00200"></a>00200                   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> ind_face=0; ind_face&lt;nb_faces_tot; ind_face++)
<a name="l00201"></a>00201                     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> som=0; som&lt;size; som++)
<a name="l00202"></a>00202                       {
<a name="l00203"></a>00203                         <span class="keywordtype">int</span> face = le_bord.<a class="code" href="classFront__VF.html#a3402a19d7e54ed797d2b18e9a47ead1e" title="Renvoie le numero de face de la ieme face du bord.">num_face</a>(ind_face);
<a name="l00204"></a>00204                         est_un_sommet_de_bord_(zone_VEF.<a class="code" href="classZone__VF.html#a298e73b18e17da55f421b1fb0879bd46" title="renvoie le numero du ieme sommet de la face num_face.">face_sommets</a>(face,som))=1;
<a name="l00205"></a>00205                       }
<a name="l00206"></a>00206                 }
<a name="l00207"></a>00207             }
<a name="l00208"></a>00208           <span class="keywordflow">for</span> (<span class="keywordtype">int</span> elem=0; elem&lt;nb_elem_tot; elem++)
<a name="l00209"></a>00209             {
<a name="l00210"></a>00210               <span class="keywordflow">if</span> (rang_elem_non_std(elem)!=-1)
<a name="l00211"></a>00211                 <a class="code" href="classOp__Conv__VEF__Face.html#a4adb50fa6ba0bee8a6fbbc0a2655fe86">traitement_pres_bord_</a>(elem)=1;
<a name="l00212"></a>00212               <span class="keywordflow">else</span>
<a name="l00213"></a>00213                 {
<a name="l00214"></a>00214                   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> n_som=0; n_som&lt;nsom; n_som++)
<a name="l00215"></a>00215                     <span class="keywordflow">if</span> (est_un_sommet_de_bord_(les_elems(elem,n_som)))
<a name="l00216"></a>00216                       <a class="code" href="classOp__Conv__VEF__Face.html#a4adb50fa6ba0bee8a6fbbc0a2655fe86">traitement_pres_bord_</a>(elem)=1;
<a name="l00217"></a>00217                 }
<a name="l00218"></a>00218             }
<a name="l00219"></a>00219         }
<a name="l00220"></a>00220 <span class="comment">// Construction du tableau est_une_face_de_dirichlet_</span>
<a name="l00221"></a>00221       <a class="code" href="classOp__Conv__VEF__Face.html#a17766a9e6e2a57fde63def2595fbc6ca">est_une_face_de_dirichlet_</a>.<a class="code" href="classArrOfInt.html#a9b3afbb46b16870dbd36236c8935b535">resize_array</a>(zone_VEF.<a class="code" href="classZone__VF.html#a50fd21c9535680489015a3c8b88c685a" title="renvoie le nombre total de faces. C&#39;est-a-dire faces reelles + faces virtuelles">nb_faces_tot</a>());
<a name="l00222"></a>00222       <a class="code" href="classOp__Conv__VEF__Face.html#a17766a9e6e2a57fde63def2595fbc6ca">est_une_face_de_dirichlet_</a>=0;
<a name="l00223"></a>00223       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> n_bord=0; n_bord&lt;nb_bord; n_bord++)
<a name="l00224"></a>00224         {
<a name="l00225"></a>00225           <span class="keyword">const</span> <a class="code" href="classCond__lim__base.html" title="classe Cond_lim_base Classe de base pour la hierarchie des classes qui representent les differentes c...">Cond_lim_base</a>&amp; la_cl = zone_Cl_VEF.<a class="code" href="classZone__Cl__dis__base.html#af75e0ed7786863e4d333bfb29d67c323" title="Renvoie la i-ieme condition aux limites. (version const)">les_conditions_limites</a>(n_bord).<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>();
<a name="l00226"></a>00226           <span class="keywordflow">if</span> ( <a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classDirichlet.html" title="classe Dirichlet Cette classe est la classe de base de la hierarchie des conditions aux limites de ty...">Dirichlet</a>,la_cl) || <a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classDirichlet__homogene.html" title="Classe Dirichlet_homogene Cette classe est la classe de base de la hierarchie des conditions aux limi...">Dirichlet_homogene</a>,la_cl) )
<a name="l00227"></a>00227             {
<a name="l00228"></a>00228               <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp; le_bord = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>,la_cl.<a class="code" href="classCond__lim__base.html#ad88b3b516351146c85e8fce1df0f691a" title="Renvoie la frontiere discretisee a laquelle les conditions aux limites s&#39;appliquent.">frontiere_dis</a>());
<a name="l00229"></a>00229               <span class="keywordtype">int</span> nb_faces_tot = le_bord.<a class="code" href="classFront__VF.html#aed4006d91bf2ef3af2b9f7933d863a09" title="Nombre de faces reelles et virtuelles du bord.">nb_faces_tot</a>();
<a name="l00230"></a>00230               <span class="keywordflow">for</span> (<span class="keywordtype">int</span> ind_face=0; ind_face&lt;nb_faces_tot; ind_face++)
<a name="l00231"></a>00231                 {
<a name="l00232"></a>00232                   <span class="keywordtype">int</span> num_face = le_bord.<a class="code" href="classFront__VF.html#a3402a19d7e54ed797d2b18e9a47ead1e" title="Renvoie le numero de face de la ieme face du bord.">num_face</a>(ind_face);
<a name="l00233"></a>00233                   <a class="code" href="classOp__Conv__VEF__Face.html#a17766a9e6e2a57fde63def2595fbc6ca">est_une_face_de_dirichlet_</a>(num_face) = 1;
<a name="l00234"></a>00234                 }
<a name="l00235"></a>00235             }
<a name="l00236"></a>00236         }
<a name="l00237"></a>00237     }
<a name="l00238"></a>00238 
<a name="l00239"></a>00239 <span class="comment">// Pour le traitement de la convection on distingue les polyedres</span>
<a name="l00240"></a>00240 <span class="comment">// standard qui ne &quot;voient&quot; pas les conditions aux limites et les</span>
<a name="l00241"></a>00241 <span class="comment">// polyedres non standard qui ont au moins une face sur le bord.</span>
<a name="l00242"></a>00242 <span class="comment">// Un polyedre standard a n facettes sur lesquelles on applique le</span>
<a name="l00243"></a>00243 <span class="comment">// schema de convection.</span>
<a name="l00244"></a>00244 <span class="comment">// Pour un polyedre non standard qui porte des conditions aux limites</span>
<a name="l00245"></a>00245 <span class="comment">// de Dirichlet, une partie des facettes sont portees par les faces.</span>
<a name="l00246"></a>00246 <span class="comment">// En bref pour un polyedre le traitement de la convection depend</span>
<a name="l00247"></a>00247 <span class="comment">// du type (triangle, tetraedre ...) et du nombre de faces de Dirichlet.</span>
<a name="l00248"></a>00248 
<a name="l00249"></a>00249   <span class="keyword">const</span> <a class="code" href="classElem__VEF__base.html">Elem_VEF_base</a>&amp; type_elemvef= zone_VEF.<a class="code" href="classZone__VEF.html#a46693c060b8096fb2595ca72192eea2a">type_elem</a>().<a class="code" href="classDeriv__Elem__VEF__base.html#a2886905d5071be902c77248b69ca0b7b">valeur</a>();
<a name="l00250"></a>00250   <span class="keywordtype">int</span> istetra=0;
<a name="l00251"></a>00251   <a class="code" href="classNom.html" title="class Nom Une chaine de caractere pour nommer les objets de TRUST">Nom</a> nom_elem=type_elemvef.<a class="code" href="classObjet__U.html#aa58e9a81c0ddc2c1149053b8f96698ac" title="renvoie la chaine identifiant la classe.">que_suis_je</a>();
<a name="l00252"></a>00252   <span class="keywordflow">if</span> ((nom_elem==<span class="stringliteral">&quot;Tetra_VEF&quot;</span>)||(nom_elem==<span class="stringliteral">&quot;Tri_VEF&quot;</span>))
<a name="l00253"></a>00253     istetra=1;
<a name="l00254"></a>00254 
<a name="l00255"></a>00255   <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; porosite_elem = zone_VEF.<a class="code" href="classZone__VF.html#afd135a1b227731193b1a97b7ed525435">porosite_elem</a>();
<a name="l00256"></a>00256   <span class="keywordtype">double</span> psc;
<a name="l00257"></a>00257   <span class="keywordtype">int</span> poly,face_adj,fa7,i,j,n_bord;
<a name="l00258"></a>00258   <span class="keywordtype">int</span> num_face, rang;
<a name="l00259"></a>00259   <span class="keywordtype">int</span> num10,num20,num_som;
<a name="l00260"></a>00260   <span class="keywordtype">int</span> ncomp_ch_transporte=(transporte_face.<a class="code" href="classDoubleTab.html#ae6dda48778e7107e1beb723beef1f75b" title="Returns the number of dimensions of the array (&gt;= 1)">nb_dim</a>() == 1?1:transporte_face.<a class="code" href="classDoubleTab.html#ac3805e2637a3b880ba2d3e650c69dac4" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(1));
<a name="l00261"></a>00261 
<a name="l00262"></a>00262 <span class="comment">// Traitement particulier pour les faces de periodicite</span>
<a name="l00263"></a>00263   <span class="keywordtype">int</span> nb_faces_perio = 0;
<a name="l00264"></a>00264   <span class="keywordflow">for</span> (n_bord=0; n_bord&lt;nb_bord; n_bord++)
<a name="l00265"></a>00265     {
<a name="l00266"></a>00266       <span class="keyword">const</span> <a class="code" href="classCond__lim.html" title="classe Cond_lim Classe generique servant a representer n&#39;importe quelle classe derivee de la classe C...">Cond_lim</a>&amp; la_cl = zone_Cl_VEF.<a class="code" href="classZone__Cl__dis__base.html#af75e0ed7786863e4d333bfb29d67c323" title="Renvoie la i-ieme condition aux limites. (version const)">les_conditions_limites</a>(n_bord);
<a name="l00267"></a>00267       <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>()))
<a name="l00268"></a>00268         {
<a name="l00269"></a>00269           <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp; le_bord = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>,la_cl.<a class="code" href="classCond__lim.html#a5b2d24809cee07727006a891d4ce8d22" title="Appel a l&#39;objet sous-jacent Renvoie la frontiere discretisee associee a la condition aux limites...">frontiere_dis</a>());
<a name="l00270"></a>00270           nb_faces_perio+=le_bord.<a class="code" href="classFront__VF.html#a341e2fcb5117b96e745fd7078ba86bab" title="Nombre de faces reelles du bord.">nb_faces</a>();
<a name="l00271"></a>00271         }
<a name="l00272"></a>00272     }
<a name="l00273"></a>00273 
<a name="l00274"></a>00274   <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a> tab;
<a name="l00275"></a>00275   <span class="keywordflow">if</span> (ncomp_ch_transporte == 1)
<a name="l00276"></a>00276     tab.<a class="code" href="classDoubleTab.html#ae83b4d31205c53d9c8d2b43da178ce75" title="Change la taille du vecteur (identique a resize_array() pour le traitement des anciennes valeurs et d...">resize</a>(nb_faces_perio);
<a name="l00277"></a>00277   <span class="keywordflow">else</span>
<a name="l00278"></a>00278     tab.<a class="code" href="classDoubleTab.html#ae83b4d31205c53d9c8d2b43da178ce75" title="Change la taille du vecteur (identique a resize_array() pour le traitement des anciennes valeurs et d...">resize</a>(nb_faces_perio,ncomp_ch_transporte);
<a name="l00279"></a>00279 
<a name="l00280"></a>00280   nb_faces_perio=0;
<a name="l00281"></a>00281   <span class="keywordflow">for</span> (n_bord=0; n_bord&lt;nb_bord; n_bord++)
<a name="l00282"></a>00282     {
<a name="l00283"></a>00283       <span class="keyword">const</span> <a class="code" href="classCond__lim.html" title="classe Cond_lim Classe generique servant a representer n&#39;importe quelle classe derivee de la classe C...">Cond_lim</a>&amp; la_cl = zone_Cl_VEF.<a class="code" href="classZone__Cl__dis__base.html#af75e0ed7786863e4d333bfb29d67c323" title="Renvoie la i-ieme condition aux limites. (version const)">les_conditions_limites</a>(n_bord);
<a name="l00284"></a>00284       <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>()))
<a name="l00285"></a>00285         {
<a name="l00286"></a>00286           <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp; le_bord = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>,la_cl.<a class="code" href="classCond__lim.html#a5b2d24809cee07727006a891d4ce8d22" title="Appel a l&#39;objet sous-jacent Renvoie la frontiere discretisee associee a la condition aux limites...">frontiere_dis</a>());
<a name="l00287"></a>00287           <span class="keywordtype">int</span> num1 = le_bord.<a class="code" href="classFront__VF.html#a4986f0c65653fe9eb40bbbff5a97bf16" title="Numero de la premiere face du bord dans la liste des faces.">num_premiere_face</a>();
<a name="l00288"></a>00288           <span class="keywordtype">int</span> num2 = num1 + le_bord.<a class="code" href="classFront__VF.html#a341e2fcb5117b96e745fd7078ba86bab" title="Nombre de faces reelles du bord.">nb_faces</a>();
<a name="l00289"></a>00289           <span class="keywordflow">for</span> (num_face=num1; num_face&lt;num2; num_face++)
<a name="l00290"></a>00290             {
<a name="l00291"></a>00291               <span class="keywordflow">if</span> (ncomp_ch_transporte == 1)
<a name="l00292"></a>00292                 tab(nb_faces_perio) = resu(num_face);
<a name="l00293"></a>00293               <span class="keywordflow">else</span>
<a name="l00294"></a>00294                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> comp=0; comp&lt;ncomp_ch_transporte; comp++)
<a name="l00295"></a>00295                   tab(nb_faces_perio,comp) = resu(num_face,comp);
<a name="l00296"></a>00296               nb_faces_perio++;
<a name="l00297"></a>00297             }
<a name="l00298"></a>00298         }
<a name="l00299"></a>00299     }
<a name="l00300"></a>00300 
<a name="l00301"></a>00301   <span class="keywordtype">int</span> fac=0,elem1,elem2,comp0;
<a name="l00302"></a>00302   <span class="keywordtype">int</span> nb_faces_ = zone_VEF.<a class="code" href="classZone__VF.html#aede27992d9f2eedd52c24d4a80ff7ffb" title="renvoie le nombre global de faces.">nb_faces</a>();
<a name="l00303"></a>00303   <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> face(nfac);
<a name="l00304"></a>00304 <span class="comment">// statistiques().end_count(m1);</span>
<a name="l00305"></a>00305 <span class="comment">// statistiques().begin_count(m2);</span>
<a name="l00306"></a>00306 
<a name="l00307"></a>00307 <span class="comment">// Tableau gradient base sur gradient_elem selon schema</span>
<a name="l00308"></a>00308   <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a> gradient_elem(nb_elem_tot,ncomp_ch_transporte,<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>);  <span class="comment">//!&lt; (du/dx du/dy dv/dx dv/dy) pour un poly</span>
<a name="l00309"></a>00309 <span class="comment"></span>  <span class="keywordflow">if</span>(<a class="code" href="classOp__Conv__VEF__Face.html#aac6bde5c9421ce149a3f28a11709b1f6">type_op</a>==<a class="code" href="classOp__Conv__VEF__Face.html#abbf17549ccbad9c64780dcca7a3e2634aeb4b20f4ab0bb61c69bfbf25d47d219d">centre</a> || <a class="code" href="classOp__Conv__VEF__Face.html#aac6bde5c9421ce149a3f28a11709b1f6">type_op</a>==<a class="code" href="classOp__Conv__VEF__Face.html#abbf17549ccbad9c64780dcca7a3e2634af9bc4313cad73dd46e9d5364c4f001b3">muscl</a>)
<a name="l00310"></a>00310     {
<a name="l00311"></a>00311       <a class="code" href="classChamp__P1NC.html#a87d96c073d3c127684934610f9a1e407">Champ_P1NC::calcul_gradient</a>(transporte_face,gradient_elem,zone_Cl_VEF);
<a name="l00312"></a>00312     }
<a name="l00313"></a>00313   <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a> gradient;
<a name="l00314"></a>00314   <span class="keywordflow">if</span> (<a class="code" href="classOp__Conv__VEF__Face.html#aac6bde5c9421ce149a3f28a11709b1f6">type_op</a>==<a class="code" href="classOp__Conv__VEF__Face.html#abbf17549ccbad9c64780dcca7a3e2634aeb4b20f4ab0bb61c69bfbf25d47d219d">centre</a>)
<a name="l00315"></a>00315     {
<a name="l00316"></a>00316       gradient.<a class="code" href="classDoubleTab.html#afc7cddeeec2c80636e54eaf330ac41ad" title="fait pointer le tableau sur le vecteur v et en associant la meme structure parallele. Attention, si line_size du vecteur v est different de 1, on cree un tableau bidimensionnel (on peut avoir un vecteur de ce type si on copie un Tab dans un Vect puis on prend une ref sur ce Vect).">ref</a>(gradient_elem);
<a name="l00317"></a>00317     }
<a name="l00318"></a>00318   <span class="keywordflow">else</span> <span class="keywordflow">if</span>(<a class="code" href="classOp__Conv__VEF__Face.html#aac6bde5c9421ce149a3f28a11709b1f6">type_op</a>==<a class="code" href="classOp__Conv__VEF__Face.html#abbf17549ccbad9c64780dcca7a3e2634af9bc4313cad73dd46e9d5364c4f001b3">muscl</a>)
<a name="l00319"></a>00319     {
<a name="l00320"></a>00320 <span class="comment">// application du limiteur</span>
<a name="l00321"></a>00321       gradient.<a class="code" href="classDoubleTab.html#ae83b4d31205c53d9c8d2b43da178ce75" title="Change la taille du vecteur (identique a resize_array() pour le traitement des anciennes valeurs et d...">resize</a>(0, ncomp_ch_transporte, <a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>);     <span class="comment">//!&lt; (du/dx du/dy dv/dx dv/dy) pour une face</span>
<a name="l00322"></a>00322 <span class="comment"></span>      zone_VEF.<a class="code" href="classZone__VF.html#a8e02e68f236356f72728b82536538ac5">creer_tableau_faces</a>(gradient);
<a name="l00323"></a>00323       <span class="keywordflow">for</span> (n_bord=0; n_bord&lt;nb_bord; n_bord++)
<a name="l00324"></a>00324         {
<a name="l00325"></a>00325           <span class="keyword">const</span> <a class="code" href="classCond__lim.html" title="classe Cond_lim Classe generique servant a representer n&#39;importe quelle classe derivee de la classe C...">Cond_lim</a>&amp; la_cl = zone_Cl_VEF.<a class="code" href="classZone__Cl__dis__base.html#af75e0ed7786863e4d333bfb29d67c323" title="Renvoie la i-ieme condition aux limites. (version const)">les_conditions_limites</a>(n_bord);
<a name="l00326"></a>00326           <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp; le_bord = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>,la_cl.<a class="code" href="classCond__lim.html#a5b2d24809cee07727006a891d4ce8d22" title="Appel a l&#39;objet sous-jacent Renvoie la frontiere discretisee associee a la condition aux limites...">frontiere_dis</a>());
<a name="l00327"></a>00327           <span class="keywordtype">int</span> num1 = le_bord.<a class="code" href="classFront__VF.html#a4986f0c65653fe9eb40bbbff5a97bf16" title="Numero de la premiere face du bord dans la liste des faces.">num_premiere_face</a>();
<a name="l00328"></a>00328           <span class="keywordtype">int</span> num2 = num1 + le_bord.<a class="code" href="classFront__VF.html#a341e2fcb5117b96e745fd7078ba86bab" title="Nombre de faces reelles du bord.">nb_faces</a>();
<a name="l00329"></a>00329           <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>()))
<a name="l00330"></a>00330             {
<a name="l00331"></a>00331               <span class="keywordflow">for</span> (fac=num1; fac&lt;num2; fac++)
<a name="l00332"></a>00332                 {
<a name="l00333"></a>00333                   elem1=face_voisins(fac,0);
<a name="l00334"></a>00334                   elem2=face_voisins(fac,1);
<a name="l00335"></a>00335                   <span class="keywordflow">for</span> (comp0=0; comp0&lt;ncomp_ch_transporte; comp0++)
<a name="l00336"></a>00336                     <span class="keywordflow">for</span> (i=0; i&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; i++)
<a name="l00337"></a>00337                       {
<a name="l00338"></a>00338                         <span class="keywordtype">double</span> grad1=gradient_elem(elem1, comp0, i);
<a name="l00339"></a>00339                         <span class="keywordtype">double</span> grad2=gradient_elem(elem2, comp0, i);
<a name="l00340"></a>00340                         gradient(fac, comp0, i) =(*LIMITEUR)(grad1, grad2);
<a name="l00341"></a>00341                       }
<a name="l00342"></a>00342                 }
<a name="l00343"></a>00343             }
<a name="l00344"></a>00344           <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classSymetrie.html" title="classe Symetrie Sur les faces de symetrie on a les proprietes suivantes: - composante normale de la v...">Symetrie</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>()))
<a name="l00345"></a>00345             {
<a name="l00346"></a>00346               <span class="keywordflow">for</span> (fac=num1; fac&lt;num2; fac++)
<a name="l00347"></a>00347                 {
<a name="l00348"></a>00348                   elem1=face_voisins(fac,0);
<a name="l00349"></a>00349                   <span class="keywordflow">for</span> (comp0=0; comp0&lt;ncomp_ch_transporte; comp0++)
<a name="l00350"></a>00350                     <span class="keywordflow">for</span> (i=0; i&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; i++)
<a name="l00351"></a>00351                       gradient(fac, comp0, i) = gradient_elem(elem1, comp0, i);
<a name="l00352"></a>00352 
<a name="l00353"></a>00353                   <span class="keywordflow">if</span> (<a class="code" href="classOp__Conv__VEF__Face.html#ad30e1a556295f226b7ef1215dc0030e5">ordre</a>==3)
<a name="l00354"></a>00354                     {
<a name="l00355"></a>00355 <span class="comment">// On enleve la composante normale (on pourrait le faire pour les autres schemas...)</span>
<a name="l00356"></a>00356 <span class="comment">// mais pour le moment, on ne veut pas changer le comportement par defaut du muscl...</span>
<a name="l00357"></a>00357 <span class="comment">// const DoubleTab&amp; facenormales = zone_VEF.face_normales();</span>
<a name="l00358"></a>00358                       <span class="keywordflow">for</span> (comp0=0; comp0&lt;ncomp_ch_transporte; comp0++)
<a name="l00359"></a>00359                         <span class="keywordflow">for</span> (i=0; i&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; i++)
<a name="l00360"></a>00360                           {
<a name="l00361"></a>00361                             <span class="keywordtype">double</span> carre_surface=0;
<a name="l00362"></a>00362                             <span class="keywordtype">double</span> tmp=0;
<a name="l00363"></a>00363                             <span class="keywordflow">for</span> (j=0; j&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; j++)
<a name="l00364"></a>00364                               {
<a name="l00365"></a>00365                                 <span class="keywordtype">double</span> ndS=facenormales(fac,j);
<a name="l00366"></a>00366                                 carre_surface += ndS*ndS;
<a name="l00367"></a>00367                                 tmp += gradient(fac, comp0, j)*ndS;
<a name="l00368"></a>00368                               }
<a name="l00369"></a>00369                             gradient(fac, comp0, i) -= tmp*facenormales(fac,i)/carre_surface;
<a name="l00370"></a>00370                           }
<a name="l00371"></a>00371                     }
<a name="l00372"></a>00372                 }
<a name="l00373"></a>00373             }
<a name="l00374"></a>00374         }
<a name="l00375"></a>00375 
<a name="l00376"></a>00376       <span class="keywordflow">for</span> (fac=premiere_face_int; fac&lt;nb_faces_; fac++)
<a name="l00377"></a>00377         {
<a name="l00378"></a>00378           elem1=face_voisins(fac,0);
<a name="l00379"></a>00379           elem2=face_voisins(fac,1);
<a name="l00380"></a>00380           <span class="keywordtype">int</span> minmod_pres_du_bord = 0;
<a name="l00381"></a>00381           <span class="keywordflow">if</span> (<a class="code" href="classOp__Conv__VEF__Face.html#ad30e1a556295f226b7ef1215dc0030e5">ordre</a>==3 &amp;&amp; (<a class="code" href="classOp__Conv__VEF__Face.html#a4adb50fa6ba0bee8a6fbbc0a2655fe86">traitement_pres_bord_</a>(elem1) || <a class="code" href="classOp__Conv__VEF__Face.html#a4adb50fa6ba0bee8a6fbbc0a2655fe86">traitement_pres_bord_</a>(elem2))) minmod_pres_du_bord = 1;
<a name="l00382"></a>00382           <span class="keywordflow">for</span> (comp0=0; comp0&lt;ncomp_ch_transporte; comp0++)
<a name="l00383"></a>00383             <span class="keywordflow">for</span> (i=0; i&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; i++)
<a name="l00384"></a>00384               {
<a name="l00385"></a>00385                 <span class="keywordtype">double</span> grad1=gradient_elem(elem1, comp0, i);
<a name="l00386"></a>00386                 <span class="keywordtype">double</span> grad2=gradient_elem(elem2, comp0, i);
<a name="l00387"></a>00387                 <span class="keywordflow">if</span> (minmod_pres_du_bord)
<a name="l00388"></a>00388                   gradient(fac, comp0, i) = <a class="code" href="Convection__tools_8cpp.html#acd40757070ae472ea829cf1cb522d91a">minmod</a>(grad1, grad2);
<a name="l00389"></a>00389                 <span class="keywordflow">else</span>
<a name="l00390"></a>00390                   gradient(fac, comp0, i) = (*LIMITEUR)(grad1, grad2);
<a name="l00391"></a>00391               }
<a name="l00392"></a>00392         } <span class="comment">//!&lt; fin du for faces</span>
<a name="l00393"></a>00393 <span class="comment"></span>      gradient.<a class="code" href="classDoubleVect.html#abfebbc2f685ce7bc4b80c720d7da9bf3">echange_espace_virtuel</a>();
<a name="l00394"></a>00394     }<span class="comment">//!&lt; fin if(type_op==muscl)</span>
<a name="l00395"></a>00395 <span class="comment"></span>
<a name="l00396"></a>00396   <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a> vs(<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>);
<a name="l00397"></a>00397   <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a> vc(<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>);
<a name="l00398"></a>00398   <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a> cc(<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>);
<a name="l00399"></a>00399   <a class="code" href="classDoubleVect.html">DoubleVect</a> xc(<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>);
<a name="l00400"></a>00400   <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a> vsom(nsom,<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>);
<a name="l00401"></a>00401   <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a> xsom(nsom,<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>);
<a name="l00402"></a>00402 
<a name="l00403"></a>00403 <span class="comment">// Dimensionnement du tableau des flux convectifs au bord du domaine de calcul</span>
<a name="l00404"></a>00404   <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; flux_b = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>,<a class="code" href="classOperateur__base.html#a451f51b41518ddbc0d3f586a8177d319" title="Tableau contenant les flux sur les bords de l&#39;operateur.">flux_bords_</a>);
<a name="l00405"></a>00405   <span class="keywordtype">int</span> nb_faces_bord=zone_VEF.<a class="code" href="classZone__VF.html#a8815e2276637c0db23868f043dc43e58" title="renvoie le nombre de faces sur lesquelles sont appliquees les conditions limites : bords...">nb_faces_bord</a>();
<a name="l00406"></a>00406   flux_b.<a class="code" href="classDoubleTab.html#ae83b4d31205c53d9c8d2b43da178ce75" title="Change la taille du vecteur (identique a resize_array() pour le traitement des anciennes valeurs et d...">resize</a>(nb_faces_bord,ncomp_ch_transporte);
<a name="l00407"></a>00407   flux_b = 0.;
<a name="l00408"></a>00408 
<a name="l00409"></a>00409   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; KEL=type_elemvef.<a class="code" href="classElem__VEF__base.html#ab129610ef702aa8c9c98dcb4c7551172">KEL</a>();
<a name="l00410"></a>00410   <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; xv=zone_VEF.<a class="code" href="classZone__VF.html#a918c0885a9b67317fcce3a0535306542">xv</a>();
<a name="l00411"></a>00411   <span class="keyword">const</span> <a class="code" href="classDomaine.html" title="Classe Domaine Un Domaine represente le domaine (spatial) de resolution d&#39;un Probleme. Un Domaine a un Nom, il est constitue d&#39;une ou plusieurs Zone qui peuvent etre eventuellement decoupees en Sous_Zone. Un Domaine porte l&#39;ensemble des sommets utilises par ses Zones. On peut vouloir resoudre des problemes de type different sur plusieurs domaines, geometriquement les domaines sont alors couples par des surfaces qu&#39;on appelle Raccord.">Domaine</a>&amp; domaine=zone.<a class="code" href="classZone.html#a379ad2206b5a13a4f4f3df6d44c7546a" title="Renvoie le domaine dont la zone fait partie. (version const)">domaine</a>();
<a name="l00412"></a>00412   <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; coord_sommets=domaine.<a class="code" href="classDomaine.html#aecd32c3eecc15cce7d1a0e468dadbf96" title="Renvoie le tableau des coordonnees des noeuds (sommets). (acces en lecture)">coord_sommets</a>();
<a name="l00413"></a>00413 
<a name="l00414"></a>00414 <span class="comment">// Boucle ou non selon la valeur de alpha (uniquement a l&#39;ordre 3 pour le moment)</span>
<a name="l00415"></a>00415 <span class="comment">// Si alpha=1, la boucle se limite a une simple passe avec le schema choisi (muscl, amont, centre)</span>
<a name="l00416"></a>00416 <span class="comment">// Si alpha&lt;1, la boucle se compose de 2 passes:</span>
<a name="l00417"></a>00417 <span class="comment">// -la premiere avec le schema choisi et une ponderation de alpha</span>
<a name="l00418"></a>00418 <span class="comment">// -la seconde avec le schema centre et une ponderation de 1-alpha</span>
<a name="l00419"></a>00419   <span class="keywordtype">double</span> alpha = <a class="code" href="classOp__Conv__VEF__Face.html#aebc1771cc4608fc51a8b6d15b93c8d3d">alpha_</a>;
<a name="l00420"></a>00420   <span class="keywordtype">int</span> nombre_passes = (alpha==1 ? 1 : 2);
<a name="l00421"></a>00421   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> passe=1; passe&lt;=nombre_passes; passe++)
<a name="l00422"></a>00422     {
<a name="l00423"></a>00423       <a class="code" href="classOp__Conv__VEF__Face.html#abbf17549ccbad9c64780dcca7a3e2634">type_operateur</a> type_op_boucle = <a class="code" href="classOp__Conv__VEF__Face.html#aac6bde5c9421ce149a3f28a11709b1f6">type_op</a>;
<a name="l00424"></a>00424       <span class="keywordflow">if</span> (passe==2)
<a name="l00425"></a>00425         {
<a name="l00426"></a>00426           type_op_boucle = <a class="code" href="classOp__Conv__VEF__Face.html#abbf17549ccbad9c64780dcca7a3e2634aeb4b20f4ab0bb61c69bfbf25d47d219d">centre</a>;
<a name="l00427"></a>00427           gradient.<a class="code" href="classDoubleTab.html#afc7cddeeec2c80636e54eaf330ac41ad" title="fait pointer le tableau sur le vecteur v et en associant la meme structure parallele. Attention, si line_size du vecteur v est different de 1, on cree un tableau bidimensionnel (on peut avoir un vecteur de ce type si on copie un Tab dans un Vect puis on prend une ref sur ce Vect).">ref</a>(gradient_elem);
<a name="l00428"></a>00428         }
<a name="l00429"></a>00429 <span class="comment">// Les polyedres non standard sont ranges en 2 groupes dans la Zone_VEF:</span>
<a name="l00430"></a>00430 <span class="comment">// - polyedres bords et joints</span>
<a name="l00431"></a>00431 <span class="comment">// - polyedres bords et non joints</span>
<a name="l00432"></a>00432 <span class="comment">// On traite les polyedres en suivant l&#39;ordre dans lequel ils figurent</span>
<a name="l00433"></a>00433 <span class="comment">// dans la zone</span>
<a name="l00434"></a>00434 <span class="comment">// boucle sur les polys</span>
<a name="l00435"></a>00435       <span class="keywordflow">for</span> (poly=0; poly&lt;nb_elem_tot; poly++)
<a name="l00436"></a>00436         {
<a name="l00437"></a>00437           <span class="keywordtype">int</span> contrib = 0;
<a name="l00438"></a>00438 <span class="comment">// calcul des numeros des faces du polyedre</span>
<a name="l00439"></a>00439           <span class="keywordflow">for</span> (face_adj=0; face_adj&lt;nfac; face_adj++)
<a name="l00440"></a>00440             {
<a name="l00441"></a>00441               <span class="keywordtype">int</span> face_ = elem_faces(poly,face_adj);
<a name="l00442"></a>00442               face(face_adj)= face_;
<a name="l00443"></a>00443               <span class="keywordflow">if</span> (face_&lt;nb_faces_) contrib=1; <span class="comment">//!&lt; Une face reelle sur l&#39;element virtuel</span>
<a name="l00444"></a>00444 <span class="comment"></span>            }
<a name="l00445"></a>00445 <span class="comment">// </span>
<a name="l00446"></a>00446           <span class="keywordflow">if</span> (contrib)
<a name="l00447"></a>00447             {
<a name="l00448"></a>00448               <span class="keywordtype">int</span> calcul_flux_en_un_point = (<a class="code" href="classOp__Conv__VEF__Face.html#ad30e1a556295f226b7ef1215dc0030e5">ordre</a> != 3) &amp;&amp; (<a class="code" href="classOp__Conv__VEF__Face.html#ad30e1a556295f226b7ef1215dc0030e5">ordre</a>==1 || <a class="code" href="classOp__Conv__VEF__Face.html#a4adb50fa6ba0bee8a6fbbc0a2655fe86">traitement_pres_bord_</a>(poly));
<a name="l00449"></a>00449               <span class="keywordflow">for</span> (j=0; j&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; j++)
<a name="l00450"></a>00450                 {
<a name="l00451"></a>00451                   vs(j) = vitesse_face_absolue(face(0),j)*porosite_face(face(0));
<a name="l00452"></a>00452                   <span class="keywordflow">for</span> (i=1; i&lt;nfac; i++)
<a name="l00453"></a>00453                     vs(j)+= vitesse_face_absolue(face(i),j)*porosite_face(face(i));
<a name="l00454"></a>00454                 }
<a name="l00455"></a>00455 <span class="comment">// calcul de la vitesse aux sommets des polyedres</span>
<a name="l00456"></a>00456 <span class="comment">// On va utliser les fonctions de forme implementees dans la classe Champs_P1_impl ou Champs_Q1_impl</span>
<a name="l00457"></a>00457               <span class="keywordflow">if</span> (istetra==1)
<a name="l00458"></a>00458                 {
<a name="l00459"></a>00459                   <span class="keywordflow">for</span> (i=0; i&lt;nsom; i++)
<a name="l00460"></a>00460                     <span class="keywordflow">for</span> (j=0; j&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; j++)
<a name="l00461"></a>00461                       vsom(i,j) = (vs(j) - dimension*vitesse_face_absolue(face(i),j)*porosite_face(face(i)));
<a name="l00462"></a>00462                 }
<a name="l00463"></a>00463               <span class="keywordflow">else</span>
<a name="l00464"></a>00464                 {
<a name="l00465"></a>00465 <span class="comment">// pour que cela soit valide avec les hexa (c&#39;est + lent a calculer...)</span>
<a name="l00466"></a>00466                   <span class="keywordflow">for</span> (j=0; j&lt;nsom; j++)
<a name="l00467"></a>00467                     {
<a name="l00468"></a>00468                       num_som = sommet_elem(poly,j);
<a name="l00469"></a>00469                       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> ncomp=0; ncomp&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; ncomp++)
<a name="l00470"></a>00470                         vsom(j,ncomp) = la_vitesse.valeur_a_sommet_compo(num_som,poly,ncomp);
<a name="l00471"></a>00471                     }
<a name="l00472"></a>00472                 }
<a name="l00473"></a>00473 
<a name="l00474"></a>00474 <span class="comment">// Determination du type de CL selon le rang</span>
<a name="l00475"></a>00475               rang = rang_elem_non_std(poly);
<a name="l00476"></a>00476               <span class="keywordtype">int</span> itypcl = (rang==-1 ? 0 : zone_Cl_VEF.<a class="code" href="classZone__Cl__VEF.html#a483bdab7690f844ed04e3defe04ec70a">type_elem_Cl</a>(rang));
<a name="l00477"></a>00477 
<a name="l00478"></a>00478 <span class="comment">// calcul de vc (a l&#39;intersection des 3 facettes) vc vs vsom proportionnelles a la porosite</span>
<a name="l00479"></a>00479               type_elemvef.<a class="code" href="classElem__VEF__base.html#a02b712675ec9d8bbb6571ddbbec33417">calcul_vc</a>(face,vc,vs,vsom,<a class="code" href="classOp__Conv__VEF__base.html#a4872ffd7c638ecc415191d92d7f5f507">vitesse</a>(),itypcl,porosite_face);
<a name="l00480"></a>00480 
<a name="l00481"></a>00481 <span class="comment">// calcul de xc (a l&#39;intersection des 3 facettes) necessaire pour muscl3</span>
<a name="l00482"></a>00482               <span class="keywordflow">if</span> (<a class="code" href="classOp__Conv__VEF__Face.html#ad30e1a556295f226b7ef1215dc0030e5">ordre</a>==3)
<a name="l00483"></a>00483                 {
<a name="l00484"></a>00484                   <span class="keywordtype">int</span> idirichlet;
<a name="l00485"></a>00485                   <span class="keywordtype">int</span> n1,n2,n3;
<a name="l00486"></a>00486                   <span class="keywordflow">for</span> (i=0; i&lt;nsom; i++)
<a name="l00487"></a>00487                     <span class="keywordflow">for</span> (j=0; j&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; j++)
<a name="l00488"></a>00488                       xsom(i,j) = coord_sommets(les_elems(poly,i),j);
<a name="l00489"></a>00489                   type_elemvef.<a class="code" href="classElem__VEF__base.html#a00c120f0da0a535610698bd8f2999f4c">calcul_xg</a>(xc,xsom,itypcl,idirichlet,n1,n2,n3);
<a name="l00490"></a>00490                 }
<a name="l00491"></a>00491 
<a name="l00492"></a>00492 <span class="comment">// Gestion de la porosite</span>
<a name="l00493"></a>00493               <span class="keywordflow">if</span> (marq==0)
<a name="l00494"></a>00494                 {
<a name="l00495"></a>00495                   <span class="keywordtype">double</span> <a class="code" href="Champ__P1iP1B__implementation_8cpp.html#aa8c8f49390c3cf7c702d71a71bc977e3">coeff</a>=1./porosite_elem(poly);
<a name="l00496"></a>00496                   vsom*=<a class="code" href="Champ__P1iP1B__implementation_8cpp.html#aa8c8f49390c3cf7c702d71a71bc977e3">coeff</a>;
<a name="l00497"></a>00497                   vc*=<a class="code" href="Champ__P1iP1B__implementation_8cpp.html#aa8c8f49390c3cf7c702d71a71bc977e3">coeff</a>;
<a name="l00498"></a>00498                 }
<a name="l00499"></a>00499 <span class="comment">// Boucle sur les facettes du polyedre non standard:</span>
<a name="l00500"></a>00500               <span class="keywordflow">for</span> (fa7=0; fa7&lt;nfa7; fa7++)
<a name="l00501"></a>00501                 {
<a name="l00502"></a>00502                   num10 = face(KEL(0,fa7));
<a name="l00503"></a>00503                   num20 = face(KEL(1,fa7));
<a name="l00504"></a>00504 <span class="comment">// normales aux facettes</span>
<a name="l00505"></a>00505                   <span class="keywordflow">if</span> (rang==-1)
<a name="l00506"></a>00506                     <span class="keywordflow">for</span> (i=0; i&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; i++)
<a name="l00507"></a>00507                       cc[i] = facette_normales(poly, fa7, i);
<a name="l00508"></a>00508                   <span class="keywordflow">else</span>
<a name="l00509"></a>00509                     <span class="keywordflow">for</span> (i=0; i&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; i++)
<a name="l00510"></a>00510                       cc[i] = normales_facettes_Cl(rang,fa7,i);
<a name="l00511"></a>00511 
<a name="l00512"></a>00512 <span class="comment">// Calcul des vitesses en C,S,S2 les 3 extremites de la fa7 et M le centre de la fa7</span>
<a name="l00513"></a>00513                   <span class="keywordtype">double</span> psc_c=0,psc_s=0,psc_m,psc_s2=0;
<a name="l00514"></a>00514                   <span class="keywordflow">if</span> (dimension==2)
<a name="l00515"></a>00515                     {
<a name="l00516"></a>00516                       <span class="keywordflow">for</span> (i=0; i&lt;2; i++)
<a name="l00517"></a>00517                         {
<a name="l00518"></a>00518                           psc_c+=vc[i]*cc[i];
<a name="l00519"></a>00519                           psc_s+=vsom(KEL(2,fa7),i)*cc[i];
<a name="l00520"></a>00520                         }
<a name="l00521"></a>00521                       psc_m=(psc_c+psc_s)/2.;
<a name="l00522"></a>00522                     }
<a name="l00523"></a>00523                   <span class="keywordflow">else</span>
<a name="l00524"></a>00524                     {
<a name="l00525"></a>00525                       <span class="keywordflow">for</span> (i=0; i&lt;3; i++)
<a name="l00526"></a>00526                         {
<a name="l00527"></a>00527                           psc_c+=vc[i]*cc[i];
<a name="l00528"></a>00528                           psc_s+=vsom(KEL(2,fa7),i)*cc[i];
<a name="l00529"></a>00529                           psc_s2+=vsom(KEL(3,fa7),i)*cc[i];
<a name="l00530"></a>00530                         }
<a name="l00531"></a>00531                       psc_m=(psc_c+psc_s+psc_s2)/3.;
<a name="l00532"></a>00532                     }
<a name="l00533"></a>00533 <span class="comment">// On applique les CL de Dirichlet si num1 ou num2 est une face avec CL de Dirichlet</span>
<a name="l00534"></a>00534 <span class="comment">// auquel cas la fa7 coincide avec la face num1 ou num2 -&gt; C est au centre de la face</span>
<a name="l00535"></a>00535                   <span class="keywordtype">int</span> appliquer_cl_dirichlet=0;
<a name="l00536"></a>00536                   <span class="keywordflow">if</span> (option_appliquer_cl_dirichlet)
<a name="l00537"></a>00537                     <span class="keywordflow">if</span> (<a class="code" href="classOp__Conv__VEF__Face.html#a17766a9e6e2a57fde63def2595fbc6ca">est_une_face_de_dirichlet_</a>(num10) || <a class="code" href="classOp__Conv__VEF__Face.html#a17766a9e6e2a57fde63def2595fbc6ca">est_une_face_de_dirichlet_</a>(num20))
<a name="l00538"></a>00538                       {
<a name="l00539"></a>00539                         appliquer_cl_dirichlet = 1;
<a name="l00540"></a>00540                         psc_m = psc_c;
<a name="l00541"></a>00541                       }
<a name="l00542"></a>00542 
<a name="l00543"></a>00543 <span class="comment">// Determination de la face amont pour M</span>
<a name="l00544"></a>00544                   <span class="keywordtype">int</span> face_amont_m,dir;
<a name="l00545"></a>00545                   <span class="keywordflow">if</span> (psc_m &gt;= 0)
<a name="l00546"></a>00546                     {
<a name="l00547"></a>00547                       face_amont_m = num10;
<a name="l00548"></a>00548                       dir=0;
<a name="l00549"></a>00549                     }
<a name="l00550"></a>00550                   <span class="keywordflow">else</span>
<a name="l00551"></a>00551                     {
<a name="l00552"></a>00552                       face_amont_m = num20;
<a name="l00553"></a>00553                       dir=1;
<a name="l00554"></a>00554                     }
<a name="l00555"></a>00555 <span class="comment">// Determination des faces amont pour les points C,S,S2</span>
<a name="l00556"></a>00556                   <span class="keywordtype">int</span> face_amont_c=face_amont_m;
<a name="l00557"></a>00557                   <span class="keywordtype">int</span> face_amont_s=face_amont_m;
<a name="l00558"></a>00558                   <span class="keywordtype">int</span> face_amont_s2=face_amont_m;
<a name="l00559"></a>00559                   <span class="keywordflow">if</span> (type_op_boucle==<a class="code" href="classOp__Conv__VEF__Face.html#abbf17549ccbad9c64780dcca7a3e2634af9bc4313cad73dd46e9d5364c4f001b3">muscl</a> &amp;&amp; <a class="code" href="classOp__Conv__VEF__Face.html#ad30e1a556295f226b7ef1215dc0030e5">ordre</a>==3)
<a name="l00560"></a>00560                     {
<a name="l00561"></a>00561                       face_amont_c  = (psc_c &gt;= 0)  ? num10 : num20;
<a name="l00562"></a>00562                       face_amont_s  = (psc_s &gt;= 0)  ? num10 : num20;
<a name="l00563"></a>00563                       face_amont_s2 = (psc_s2 &gt;= 0) ? num10 : num20;
<a name="l00564"></a>00564                     }
<a name="l00565"></a>00565 <span class="comment">// gradient aux items element (schema centre) ou aux items face (schemas muscl)</span>
<a name="l00566"></a>00566                   <span class="keywordtype">int</span> item_m=poly;
<a name="l00567"></a>00567                   <span class="keywordtype">int</span> item_c=poly;
<a name="l00568"></a>00568                   <span class="keywordtype">int</span> item_s=poly;
<a name="l00569"></a>00569                   <span class="keywordtype">int</span> item_s2=poly;
<a name="l00570"></a>00570                   <span class="keywordflow">if</span> (type_op_boucle==<a class="code" href="classOp__Conv__VEF__Face.html#abbf17549ccbad9c64780dcca7a3e2634af9bc4313cad73dd46e9d5364c4f001b3">muscl</a>)
<a name="l00571"></a>00571                     {
<a name="l00572"></a>00572                       item_m = face_amont_m;
<a name="l00573"></a>00573                       item_c = face_amont_c;
<a name="l00574"></a>00574                       item_s = face_amont_s;
<a name="l00575"></a>00575                       item_s2 = face_amont_s2;
<a name="l00576"></a>00576                     }
<a name="l00577"></a>00577 
<a name="l00578"></a>00578                   <span class="keywordflow">for</span> (comp0=0; comp0&lt;ncomp_ch_transporte; comp0++)
<a name="l00579"></a>00579                     {
<a name="l00580"></a>00580                       <span class="keywordtype">double</span> flux;
<a name="l00581"></a>00581                       <span class="keywordtype">double</span> inco_m = (ncomp_ch_transporte==1?transporte_face(face_amont_m):transporte_face(face_amont_m,comp0));
<a name="l00582"></a>00582                       <span class="keywordflow">if</span> (type_op_boucle==<a class="code" href="classOp__Conv__VEF__Face.html#abbf17549ccbad9c64780dcca7a3e2634a1192ae3f2c2a1d9d734f4cc495b58a44">amont</a> || appliquer_cl_dirichlet)
<a name="l00583"></a>00583                         {
<a name="l00584"></a>00584                           flux = inco_m*psc_m;
<a name="l00585"></a>00585                         }
<a name="l00586"></a>00586                       <span class="keywordflow">else</span> <span class="comment">//!&lt; muscl ou centre</span>
<a name="l00587"></a>00587 <span class="comment"></span>                        {
<a name="l00588"></a>00588 <span class="comment">// Calcul de l&#39;inconnue au centre M de la fa7</span>
<a name="l00589"></a>00589                           <span class="keywordflow">if</span> (rang==-1)
<a name="l00590"></a>00590                             <span class="keywordflow">for</span> (j=0; j&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; j++)
<a name="l00591"></a>00591                               inco_m+= gradient(item_m,comp0,j)*vecteur_face_facette(poly,fa7,j,dir);
<a name="l00592"></a>00592                           <span class="keywordflow">else</span>
<a name="l00593"></a>00593                             <span class="keywordflow">for</span> (j=0; j&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; j++)
<a name="l00594"></a>00594                               inco_m+= gradient(item_m,comp0,j)*vecteur_face_facette_Cl(rang,fa7,j,dir);
<a name="l00595"></a>00595 
<a name="l00596"></a>00596 <span class="comment">// Calcul de l&#39;inconnue au sommet S, une premiere extremite de la fa7</span>
<a name="l00597"></a>00597                           <span class="keywordtype">double</span> inco_s = (ncomp_ch_transporte==1?transporte_face(face_amont_s):transporte_face(face_amont_s,comp0));
<a name="l00598"></a>00598                           <span class="keywordtype">int</span> sommet_s = sommet_elem(poly,KEL(2,fa7));
<a name="l00599"></a>00599                           <span class="keywordflow">for</span> (j=0; j&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; j++)
<a name="l00600"></a>00600                             inco_s+= gradient(item_s,comp0,j)*(-xv(face_amont_s,j)+coord_sommets(sommet_s,j));
<a name="l00601"></a>00601 
<a name="l00602"></a>00602 <span class="comment">// Calcul de l&#39;inconnue au sommet S2, la derniere extremite de la fa7 en 3D</span>
<a name="l00603"></a>00603                           <span class="keywordtype">double</span> inco_s2=0;
<a name="l00604"></a>00604                           <span class="keywordflow">if</span> (dimension==3)
<a name="l00605"></a>00605                             {
<a name="l00606"></a>00606                               inco_s2 = (ncomp_ch_transporte==1?transporte_face(face_amont_s2):transporte_face(face_amont_s2,comp0));
<a name="l00607"></a>00607                               <span class="keywordtype">int</span> sommet_s2 = sommet_elem(poly,KEL(3,fa7));
<a name="l00608"></a>00608                               <span class="keywordflow">for</span> (j=0; j&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; j++)
<a name="l00609"></a>00609                                 inco_s2+= gradient(item_s2,comp0,j)*(-xv(face_amont_s2,j)+coord_sommets(sommet_s2,j));
<a name="l00610"></a>00610                             }
<a name="l00611"></a>00611 
<a name="l00612"></a>00612 <span class="comment">// Calcul de l&#39;inconnue a C, une autre extremite de la fa7, intersection avec les autres fa7</span>
<a name="l00613"></a>00613 <span class="comment">// du polyedre. C=G centre du polyedre si volume non etendu</span>
<a name="l00614"></a>00614 <span class="comment">// xc donne par elemvef.calcul_xg()</span>
<a name="l00615"></a>00615                           <span class="keywordtype">double</span> inco_c;
<a name="l00616"></a>00616                           <span class="keywordflow">if</span> (<a class="code" href="classOp__Conv__VEF__Face.html#ad30e1a556295f226b7ef1215dc0030e5">ordre</a>==3)
<a name="l00617"></a>00617                             {
<a name="l00618"></a>00618                               inco_c = (ncomp_ch_transporte==1?transporte_face(face_amont_c):transporte_face(face_amont_c,comp0));
<a name="l00619"></a>00619                               <span class="keywordflow">for</span> (j=0; j&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; j++)
<a name="l00620"></a>00620                                 inco_c+= gradient(item_c,comp0,j)*(-xv(face_amont_c,j)+xc(j));
<a name="l00621"></a>00621                             }
<a name="l00622"></a>00622                           <span class="keywordflow">else</span>
<a name="l00623"></a>00623                             {
<a name="l00624"></a>00624                               inco_c = dimension*inco_m-inco_s-inco_s2;
<a name="l00625"></a>00625                             }
<a name="l00626"></a>00626 
<a name="l00627"></a>00627 <span class="comment">// Calcul du flux sur 1 point</span>
<a name="l00628"></a>00628                           <span class="keywordflow">if</span> (calcul_flux_en_un_point || option_calcul_flux_en_un_point)
<a name="l00629"></a>00629                             {
<a name="l00630"></a>00630                               flux = inco_m*psc_m;
<a name="l00631"></a>00631                             }
<a name="l00632"></a>00632                           <span class="keywordflow">else</span>
<a name="l00633"></a>00633                             {
<a name="l00634"></a>00634 <span class="comment">// Calcul du flux sur 3 points</span>
<a name="l00635"></a>00635                               flux = (dimension==2) ? (inco_c*psc_c + inco_s*psc_s + 4*inco_m*psc_m)/6
<a name="l00636"></a>00636                                      : (inco_c*psc_c + inco_s*psc_s + inco_s2*psc_s2 + 9*inco_m*psc_m)/12;
<a name="l00637"></a>00637                             }
<a name="l00638"></a>00638                         }
<a name="l00639"></a>00639 
<a name="l00640"></a>00640 <span class="comment">// Ponderation par coefficient alpha</span>
<a name="l00641"></a>00641                       flux*=alpha;
<a name="l00642"></a>00642 
<a name="l00643"></a>00643                       <span class="keywordflow">if</span> (ncomp_ch_transporte == 1)
<a name="l00644"></a>00644                         {
<a name="l00645"></a>00645                           resu(num10) -= flux;
<a name="l00646"></a>00646                           resu(num20) += flux;
<a name="l00647"></a>00647                           <span class="keywordflow">if</span> (num10&lt;nb_faces_bord) flux_b(num10,0) += flux;
<a name="l00648"></a>00648                           <span class="keywordflow">if</span> (num20&lt;nb_faces_bord) flux_b(num20,0) -= flux;
<a name="l00649"></a>00649                         }
<a name="l00650"></a>00650                       <span class="keywordflow">else</span>
<a name="l00651"></a>00651                         {
<a name="l00652"></a>00652                           resu(num10,comp0) -= flux;
<a name="l00653"></a>00653                           resu(num20,comp0) += flux;
<a name="l00654"></a>00654                           <span class="keywordflow">if</span> (num10&lt;nb_faces_bord) flux_b(num10,comp0) += flux;
<a name="l00655"></a>00655                           <span class="keywordflow">if</span> (num20&lt;nb_faces_bord) flux_b(num20,comp0) -= flux;
<a name="l00656"></a>00656                         }
<a name="l00657"></a>00657 
<a name="l00658"></a>00658                     }<span class="comment">//!&lt; boucle sur comp</span>
<a name="l00659"></a>00659 <span class="comment"></span>                } <span class="comment">//!&lt; fin de la boucle sur les facettes</span>
<a name="l00660"></a>00660 <span class="comment"></span>            }
<a name="l00661"></a>00661         } <span class="comment">//!&lt; fin de la boucle</span>
<a name="l00662"></a>00662 <span class="comment"></span>      alpha = 1 - alpha;
<a name="l00663"></a>00663     } <span class="comment">//!&lt; fin de la boucle statistiques().end_count(m2); statistiques().begin_count(m3);</span>
<a name="l00664"></a>00664 <span class="comment"></span><span class="comment">//</span>
<a name="l00665"></a>00665 <span class="comment">//</span>
<a name="l00666"></a>00666   <span class="keywordtype">int</span> voisine;
<a name="l00667"></a>00667   nb_faces_perio = 0;
<a name="l00668"></a>00668   <span class="keywordtype">double</span> diff1,diff2;
<a name="l00669"></a>00669 
<a name="l00670"></a>00670 <span class="comment">// Boucle sur les bords pour traiter les conditions aux limites</span>
<a name="l00671"></a>00671 <span class="comment">// il y a prise en compte d&#39;un terme de convection pour les</span>
<a name="l00672"></a>00672 <span class="comment">// conditions aux limites de Neumann_sortie_libre seulement</span>
<a name="l00673"></a>00673   <span class="keywordflow">for</span> (n_bord=0; n_bord&lt;nb_bord; n_bord++)
<a name="l00674"></a>00674     {
<a name="l00675"></a>00675       <span class="keyword">const</span> <a class="code" href="classCond__lim.html" title="classe Cond_lim Classe generique servant a representer n&#39;importe quelle classe derivee de la classe C...">Cond_lim</a>&amp; la_cl = zone_Cl_VEF.<a class="code" href="classZone__Cl__dis__base.html#af75e0ed7786863e4d333bfb29d67c323" title="Renvoie la i-ieme condition aux limites. (version const)">les_conditions_limites</a>(n_bord);
<a name="l00676"></a>00676 
<a name="l00677"></a>00677       <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classNeumann__sortie__libre.html" title="classe Neumann_sortie_libre Cette classe represente une frontiere ouverte sans vitesse imposee Pour l...">Neumann_sortie_libre</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>()))
<a name="l00678"></a>00678         {
<a name="l00679"></a>00679           <span class="keyword">const</span> <a class="code" href="classNeumann__sortie__libre.html" title="classe Neumann_sortie_libre Cette classe represente une frontiere ouverte sans vitesse imposee Pour l...">Neumann_sortie_libre</a>&amp; la_sortie_libre = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classNeumann__sortie__libre.html" title="classe Neumann_sortie_libre Cette classe represente une frontiere ouverte sans vitesse imposee Pour l...">Neumann_sortie_libre</a>, la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>());
<a name="l00680"></a>00680           <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp; le_bord = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>,la_cl.<a class="code" href="classCond__lim.html#a5b2d24809cee07727006a891d4ce8d22" title="Appel a l&#39;objet sous-jacent Renvoie la frontiere discretisee associee a la condition aux limites...">frontiere_dis</a>());
<a name="l00681"></a>00681           <span class="keywordtype">int</span> num1 = le_bord.num_premiere_face();
<a name="l00682"></a>00682           <span class="keywordtype">int</span> num2 = num1 + le_bord.nb_faces();
<a name="l00683"></a>00683           <span class="keywordflow">for</span> (num_face=num1; num_face&lt;num2; num_face++)
<a name="l00684"></a>00684             {
<a name="l00685"></a>00685               psc =0;
<a name="l00686"></a>00686               <span class="keywordflow">for</span> (i=0; i&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; i++)
<a name="l00687"></a>00687                 psc += vitesse_face(num_face,i)*facenormales(num_face,i);
<a name="l00688"></a>00688               <span class="keywordflow">if</span> (psc&gt;0)
<a name="l00689"></a>00689                 <span class="keywordflow">if</span> (ncomp_ch_transporte == 1)
<a name="l00690"></a>00690                   {
<a name="l00691"></a>00691                     resu(num_face) -= psc*transporte_face(num_face);
<a name="l00692"></a>00692                     flux_b(num_face,0) = -psc*transporte_face(num_face);
<a name="l00693"></a>00693                   }
<a name="l00694"></a>00694                 <span class="keywordflow">else</span>
<a name="l00695"></a>00695                   <span class="keywordflow">for</span> (i=0; i&lt;ncomp_ch_transporte; i++)
<a name="l00696"></a>00696                     {
<a name="l00697"></a>00697                       resu(num_face,i) -= psc*transporte_face(num_face,i);
<a name="l00698"></a>00698                       flux_b(num_face,i) = -psc*transporte_face(num_face,i);
<a name="l00699"></a>00699                     }
<a name="l00700"></a>00700               <span class="keywordflow">else</span>
<a name="l00701"></a>00701                 {
<a name="l00702"></a>00702                   <span class="keywordflow">if</span> (ncomp_ch_transporte == 1)
<a name="l00703"></a>00703                     {
<a name="l00704"></a>00704                       resu(num_face) -= psc*la_sortie_libre.<a class="code" href="classNeumann__sortie__libre.html#a886f1804fa2a9028fc56a0778a72a75d" title="Renvoie la valeur de la i-eme composante du champ impose a l&#39;exterieur de la frontiere.">val_ext</a>(num_face-num1);
<a name="l00705"></a>00705                       flux_b(num_face,0) = -psc*la_sortie_libre.<a class="code" href="classNeumann__sortie__libre.html#a886f1804fa2a9028fc56a0778a72a75d" title="Renvoie la valeur de la i-eme composante du champ impose a l&#39;exterieur de la frontiere.">val_ext</a>(num_face-num1);
<a name="l00706"></a>00706                     }
<a name="l00707"></a>00707                   <span class="keywordflow">else</span>
<a name="l00708"></a>00708                     <span class="keywordflow">for</span> (i=0; i&lt;ncomp_ch_transporte; i++)
<a name="l00709"></a>00709                       {
<a name="l00710"></a>00710                         resu(num_face,i) -= psc*la_sortie_libre.<a class="code" href="classNeumann__sortie__libre.html#a886f1804fa2a9028fc56a0778a72a75d" title="Renvoie la valeur de la i-eme composante du champ impose a l&#39;exterieur de la frontiere.">val_ext</a>(num_face-num1,i);
<a name="l00711"></a>00711                         flux_b(num_face,i) = -psc*la_sortie_libre.<a class="code" href="classNeumann__sortie__libre.html#a886f1804fa2a9028fc56a0778a72a75d" title="Renvoie la valeur de la i-eme composante du champ impose a l&#39;exterieur de la frontiere.">val_ext</a>(num_face-num1,i);
<a name="l00712"></a>00712                       }
<a name="l00713"></a>00713                 }
<a name="l00714"></a>00714             }
<a name="l00715"></a>00715         }
<a name="l00716"></a>00716       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>()))
<a name="l00717"></a>00717         {
<a name="l00718"></a>00718           <span class="keyword">const</span> <a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>&amp; la_cl_perio = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>, la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>());
<a name="l00719"></a>00719           <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp; le_bord = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>,la_cl.<a class="code" href="classCond__lim.html#a5b2d24809cee07727006a891d4ce8d22" title="Appel a l&#39;objet sous-jacent Renvoie la frontiere discretisee associee a la condition aux limites...">frontiere_dis</a>());
<a name="l00720"></a>00720           <span class="keywordtype">int</span> num1 = le_bord.num_premiere_face();
<a name="l00721"></a>00721           <span class="keywordtype">int</span> num2 = num1 + le_bord.nb_faces();
<a name="l00722"></a>00722           <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> fait(le_bord.nb_faces());
<a name="l00723"></a>00723           fait = 0;
<a name="l00724"></a>00724           <span class="keywordflow">for</span> (num_face=num1; num_face&lt;num2; num_face++)
<a name="l00725"></a>00725             {
<a name="l00726"></a>00726               <span class="keywordflow">if</span> (fait[num_face-num1] == 0)
<a name="l00727"></a>00727                 {
<a name="l00728"></a>00728                   voisine = la_cl_perio.<a class="code" href="classPeriodique.html#a207b86556f199a63ea059b841851ca6a">face_associee</a>(num_face-num1) + num1;
<a name="l00729"></a>00729 
<a name="l00730"></a>00730                   <span class="keywordflow">if</span> (ncomp_ch_transporte == 1)
<a name="l00731"></a>00731                     {
<a name="l00732"></a>00732                       diff1 = resu(num_face)-tab(nb_faces_perio);
<a name="l00733"></a>00733                       diff2 = resu(voisine)-tab(nb_faces_perio+voisine-num_face);
<a name="l00734"></a>00734                       resu(voisine)  += diff1;
<a name="l00735"></a>00735                       resu(num_face) += diff2;
<a name="l00736"></a>00736                       <span class="comment">/* On ne doit pas ajouter a flux_b, c&#39;est deja calcule au dessus</span>
<a name="l00737"></a>00737 <span class="comment">                         flux_b(voisine,0) += diff1;</span>
<a name="l00738"></a>00738 <span class="comment">                         flux_b(num_face,0) += diff2;*/</span>
<a name="l00739"></a>00739                     }
<a name="l00740"></a>00740                   <span class="keywordflow">else</span>
<a name="l00741"></a>00741                     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> comp=0; comp&lt;ncomp_ch_transporte; comp++)
<a name="l00742"></a>00742                       {
<a name="l00743"></a>00743                         diff1 = resu(num_face,comp)-tab(nb_faces_perio,comp);
<a name="l00744"></a>00744                         diff2 = resu(voisine,comp)-tab(nb_faces_perio+voisine-num_face,comp);
<a name="l00745"></a>00745                         resu(voisine,comp)  += diff1;
<a name="l00746"></a>00746                         resu(num_face,comp) += diff2;
<a name="l00747"></a>00747                         <span class="comment">/* On ne doit pas ajouter a flux_b, c&#39;est deja calcule au dessus</span>
<a name="l00748"></a>00748 <span class="comment">                           flux_b(voisine,comp) += diff1;</span>
<a name="l00749"></a>00749 <span class="comment">                           flux_b(num_face,comp) += diff2; */</span>
<a name="l00750"></a>00750                       }
<a name="l00751"></a>00751 
<a name="l00752"></a>00752                   fait[num_face-num1]= 1;
<a name="l00753"></a>00753                   fait[voisine-num1] = 1;
<a name="l00754"></a>00754                 }
<a name="l00755"></a>00755               nb_faces_perio++;
<a name="l00756"></a>00756             }
<a name="l00757"></a>00757         }
<a name="l00758"></a>00758     }
<a name="l00759"></a>00759 
<a name="l00760"></a>00760   <a class="code" href="classOp__VEF__Face.html#a6c8ce571769b4f2e20b07cbb7a6944f2">modifier_flux</a>(*<span class="keyword">this</span>);
<a name="l00761"></a>00761 <span class="comment">// statistiques().end_count(m3);</span>
<a name="l00762"></a>00762   <span class="keywordflow">return</span> resu;
<a name="l00763"></a>00763 }
<a name="l00764"></a>00764 
<a name="l00765"></a>00765 <span class="comment">// methodes recuperes de l&#39;ancien OpVEFFaAmont</span>
<a name="l00766"></a><a class="code" href="Op__Conv__VEF__Face_8cpp.html#a59458e475a218a4b9bc7832d508dcf0b">00766</a> <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="Op__Conv__VEF__Face_8cpp.html#a59458e475a218a4b9bc7832d508dcf0b">convbisimplicite_dec</a>(<span class="keyword">const</span> <span class="keywordtype">double</span>&amp; psc_, <span class="keyword">const</span> <span class="keywordtype">int</span> num1, <span class="keyword">const</span> <span class="keywordtype">int</span> num2,
<a name="l00767"></a>00767                                  <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; transporte, <span class="keyword">const</span> <span class="keywordtype">int</span> ncomp,
<a name="l00768"></a>00768                                  <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; <a class="code" href="Champ__P1iP1B__implementation_8cpp.html#aa8c8f49390c3cf7c702d71a71bc977e3">coeff</a>, <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; matrice,
<a name="l00769"></a>00769                                  <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; porosite_face, <span class="keywordtype">int</span> phi_u_transportant)
<a name="l00770"></a>00770 {
<a name="l00771"></a>00771   <span class="keywordtype">double</span> psc=psc_;
<a name="l00772"></a>00772   <span class="keywordflow">if</span> (psc&gt;=0)
<a name="l00773"></a>00773     {
<a name="l00774"></a>00774       <span class="keywordflow">if</span> (!phi_u_transportant)
<a name="l00775"></a>00775         psc*=porosite_face(num1);
<a name="l00776"></a>00776       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> comp=0; comp&lt;ncomp; comp++)
<a name="l00777"></a>00777         {
<a name="l00778"></a>00778           <span class="keywordtype">int</span> n0=num1*ncomp+comp;
<a name="l00779"></a>00779           <span class="keywordtype">int</span> j0=num2*ncomp+comp;
<a name="l00780"></a>00780           matrice(n0,n0)+=psc;
<a name="l00781"></a>00781           matrice(j0,n0)-=psc;
<a name="l00782"></a>00782         }
<a name="l00783"></a>00783     }
<a name="l00784"></a>00784   <span class="keywordflow">else</span>
<a name="l00785"></a>00785     {
<a name="l00786"></a>00786       <span class="keywordflow">if</span> (!phi_u_transportant)
<a name="l00787"></a>00787         psc*=porosite_face(num2);
<a name="l00788"></a>00788       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> comp=0; comp&lt;ncomp; comp++)
<a name="l00789"></a>00789         {
<a name="l00790"></a>00790           <span class="keywordtype">int</span> n0=num1*ncomp+comp;
<a name="l00791"></a>00791           <span class="keywordtype">int</span> j0=num2*ncomp+comp;
<a name="l00792"></a>00792           matrice(n0,j0)+=psc;
<a name="l00793"></a>00793           matrice(j0,j0)-=psc;
<a name="l00794"></a>00794         }
<a name="l00795"></a>00795     }
<a name="l00796"></a>00796 }
<a name="l00797"></a>00797 
<a name="l00798"></a><a class="code" href="classOp__Conv__VEF__Face.html#ad46bfa5e97653f57e64fb7f890d15e1b">00798</a> <span class="keywordtype">void</span> <a class="code" href="classOp__Conv__VEF__Face.html#ad46bfa5e97653f57e64fb7f890d15e1b">Op_Conv_VEF_Face::ajouter_contribution</a>(<span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; transporte, <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; matrice )<span class="keyword"> const</span>
<a name="l00799"></a>00799 <span class="keyword"></span>{
<a name="l00800"></a>00800   <a class="code" href="classOp__VEF__Face.html#ab66c49a837d41ba7e304a0efc484a5d5" title="divise les coefficients sur les ligne des faces periodiques par 2 en prevision de l&#39;application modif...">modifier_matrice_pour_periodique_avant_contribuer</a>(matrice,<a class="code" href="classMorEqn.html#a615dd9abff96edcb625fa0424a489864" title="Renvoie la reference sur l&#39;equation pointe par MorEqn::mon_equation. (version const)">equation</a>());
<a name="l00801"></a>00801   <span class="keyword">const</span> <a class="code" href="classZone__Cl__VEF.html">Zone_Cl_VEF</a>&amp; zone_Cl_VEF = <a class="code" href="classOp__Conv__VEF__base.html#a03f677ee7911706a4f85cd37e0ca4535">la_zcl_vef</a>.<a class="code" href="classRef__Zone__Cl__VEF.html#a0970d7253def65ad4f0c5ce1830fd243">valeur</a>();
<a name="l00802"></a>00802   <span class="keyword">const</span> <a class="code" href="classZone__VEF.html" title="class Zone_VEF Classe instanciable qui derive de Zone_VF. Cette classe contient les informations geom...">Zone_VEF</a>&amp; zone_VEF = <a class="code" href="classOp__Conv__VEF__base.html#a6c29a488a6805ba4a9f2f059cdba77ae">la_zone_vef</a>.<a class="code" href="classRef__Zone__VEF.html#aafd9a5ee1a76f290c9c6b5447b0c8d30">valeur</a>();
<a name="l00803"></a>00803   <span class="keyword">const</span> <a class="code" href="classChamp__Inc__base.html" title="Classe Champ_Inc_base Classe de base des champs inconnues qui sont les champs calcules par une equati...">Champ_Inc_base</a>&amp; la_vitesse=<a class="code" href="classOp__Conv__VEF__base.html#a4872ffd7c638ecc415191d92d7f5f507">vitesse</a>();
<a name="l00804"></a>00804   <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; vitesse_face_absolue=la_vitesse.<a class="code" href="classChamp__Inc__base.html#adb537f43f1649e103a8980314c7ed175" title="Renvoie le tableau des valeurs du champ au temps courant.">valeurs</a>();
<a name="l00805"></a>00805   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; elem_faces = zone_VEF.<a class="code" href="classZone__VF.html#a067e462dcd3ab92b0f6d945b19e4eb37" title="renvoie le numero de le ieme face de la maille num_elem la facon dont ces faces sont numerotees est l...">elem_faces</a>();
<a name="l00806"></a>00806   <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; face_normales = zone_VEF.<a class="code" href="classZone__VEF.html#a5742d75972e4846bf9fbb6ed5715053e">face_normales</a>();
<a name="l00807"></a>00807   <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; facette_normales = zone_VEF.<a class="code" href="classZone__VEF.html#a581b1ca0e62c668c92f104351d19fda6">facette_normales</a>();
<a name="l00808"></a>00808   <span class="keyword">const</span> <a class="code" href="classZone.html" title="classe Zone Une Zone est un maillage compose d&#39;un ensemble d&#39;elements geometriques de meme type...">Zone</a>&amp; zone = zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>();
<a name="l00809"></a>00809   <span class="keyword">const</span> <a class="code" href="classElem__VEF.html">Elem_VEF</a>&amp; <a class="code" href="Raffiner__Simplexes_8cpp.html#a358dc168d8905bbafc12587204bc9fb8">type_elem</a> = zone_VEF.<a class="code" href="classZone__VEF.html#a46693c060b8096fb2595ca72192eea2a">type_elem</a>();
<a name="l00810"></a>00810   <span class="keyword">const</span> <span class="keywordtype">int</span> nfa7 = type_elem.<a class="code" href="classElem__VEF.html#a4a34777c0083b38dd34c8a400d5b4e90">nb_facette</a>();
<a name="l00811"></a>00811   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_elem_tot = zone_VEF.<a class="code" href="classZone__dis__base.html#a4d6aa445f152aa6dc54d66ea7a071147">nb_elem_tot</a>();
<a name="l00812"></a>00812   <span class="keyword">const</span> <a class="code" href="classIntVect.html">IntVect</a>&amp; rang_elem_non_std = zone_VEF.<a class="code" href="classZone__VEF.html#a4b2171a85e5fc33663a3366acb713584">rang_elem_non_std</a>();
<a name="l00813"></a>00813 
<a name="l00814"></a>00814 
<a name="l00815"></a>00815   <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; porosite_face = zone_VEF.<a class="code" href="classZone__VF.html#ad9d74d1d9da9f50ab26768dbbca7711b">porosite_face</a>();
<a name="l00816"></a>00816   <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; porosite_elem = zone_VEF.<a class="code" href="classZone__VF.html#afd135a1b227731193b1a97b7ed525435">porosite_elem</a>();
<a name="l00817"></a>00817   <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; normales_facettes_Cl = zone_Cl_VEF.<a class="code" href="classZone__Cl__VEF.html#a83c05e82370553470ed05f10932e0f3f">normales_facettes_Cl</a>();
<a name="l00818"></a>00818 
<a name="l00819"></a>00819   <span class="keywordtype">int</span> nfac = zone.<a class="code" href="classZone.html#a548fbc7518be2f122b1a5c9589a443c2" title="Renvoie le nombre de face de type i des elements geometriques constituants la zone. Ex: les objets de la classe Prisme ont 2 types de faces: triangle ou quadrangle.">nb_faces_elem</a>();
<a name="l00820"></a>00820   <span class="keywordtype">int</span> nsom = zone.<a class="code" href="classZone.html#ae0b34a93b9ae8146df2d1884157afe9f" title="Renvoie le nombre de sommets des elements geometriques constituants la zone. Tous les elements de la ...">nb_som_elem</a>();
<a name="l00821"></a>00821   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; sommet_elem = zone.<a class="code" href="classZone.html#ac115e8342be89afb882b7b61cc343267" title="Renvoie le tableau des sommets des elements.">les_elems</a>();
<a name="l00822"></a>00822 
<a name="l00823"></a>00823 <span class="comment">// Pour le traitement de la convection on distingue les polyedres</span>
<a name="l00824"></a>00824 <span class="comment">// standard qui ne &quot;voient&quot; pas les conditions aux limites et les</span>
<a name="l00825"></a>00825 <span class="comment">// polyedres non standard qui ont au moins une face sur le bord.</span>
<a name="l00826"></a>00826 <span class="comment">// Un polyedre standard a n facettes sur lesquelles on applique le</span>
<a name="l00827"></a>00827 <span class="comment">// schema de convection.</span>
<a name="l00828"></a>00828 <span class="comment">// Pour un polyedre non standard qui porte des conditions aux limites</span>
<a name="l00829"></a>00829 <span class="comment">// de Dirichlet, une partie des facettes sont portees par les faces.</span>
<a name="l00830"></a>00830 <span class="comment">// En bref pour un polyedre le traitement de la convection depend</span>
<a name="l00831"></a>00831 <span class="comment">// du type (triangle, tetraedre ...) et du nombre de faces de Dirichlet.</span>
<a name="l00832"></a>00832 
<a name="l00833"></a>00833   <span class="keywordtype">double</span> psc;
<a name="l00834"></a>00834   <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a> pscl=0;
<a name="l00835"></a>00835   <span class="keywordtype">int</span> poly,face_adj,fa7,i,j,n_bord;
<a name="l00836"></a>00836   <span class="keywordtype">int</span> num_face, rang ,itypcl;
<a name="l00837"></a>00837   <span class="keywordtype">int</span> num10,num20,num_som;
<a name="l00838"></a>00838   <span class="keywordtype">int</span> ncomp_ch_transporte;
<a name="l00839"></a>00839   <span class="keywordflow">if</span> (transporte.<a class="code" href="classDoubleTab.html#ae6dda48778e7107e1beb723beef1f75b" title="Returns the number of dimensions of the array (&gt;= 1)">nb_dim</a>() == 1)
<a name="l00840"></a>00840     ncomp_ch_transporte=1;
<a name="l00841"></a>00841   <span class="keywordflow">else</span>
<a name="l00842"></a>00842     ncomp_ch_transporte= transporte.<a class="code" href="classDoubleTab.html#ac3805e2637a3b880ba2d3e650c69dac4" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(1);
<a name="l00843"></a>00843 
<a name="l00844"></a>00844 
<a name="l00845"></a>00845   <span class="keywordtype">int</span> marq=<a class="code" href="classOp__Conv__VEF__base.html#ad380b9b9ca1d70282b289838a604a4b0" title="definit si l&#39;on convecte psi avec phi*u ou avec u">phi_u_transportant</a>(<a class="code" href="classMorEqn.html#a615dd9abff96edcb625fa0424a489864" title="Renvoie la reference sur l&#39;equation pointe par MorEqn::mon_equation. (version const)">equation</a>());
<a name="l00846"></a>00846 
<a name="l00847"></a>00847   <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a> vitesse_face_;
<a name="l00848"></a>00848 <span class="comment">// soit on a transporte=phi*transporte_ et vitesse_face=vitesse_</span>
<a name="l00849"></a>00849 <span class="comment">// soit transporte=transporte_ et vitesse_face=phi*vitesse_</span>
<a name="l00850"></a>00850 <span class="comment">// cela depend si on transporte avec phi u ou avec u.</span>
<a name="l00851"></a>00851   <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; vitesse_face=<a class="code" href="Porosites__champ_8cpp.html#a2340e7d73d0f9d34926d012fe1b1d884" title="renvoit le tableau res, res=org si flag=0, res= porosite*org sinon attention ne pas modifier res car ...">modif_par_porosite_si_flag</a>(vitesse_face_absolue,vitesse_face_,marq,porosite_face);
<a name="l00852"></a>00852   <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> face(nfac);
<a name="l00853"></a>00853   <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a> vs(<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>);
<a name="l00854"></a>00854   <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a> vc(<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>);
<a name="l00855"></a>00855   <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a> vsom(nsom,<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>);
<a name="l00856"></a>00856   <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a> cc(<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>);
<a name="l00857"></a>00857   <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; <a class="code" href="Champ__P1iP1B__implementation_8cpp.html#aa8c8f49390c3cf7c702d71a71bc977e3">coeff</a> = matrice.<a class="code" href="classMatrice__Morse.html#acd067e8514e5741f52b18a1d99746d11">get_set_coeff</a>();
<a name="l00858"></a>00858   <span class="keyword">const</span> <a class="code" href="classElem__VEF__base.html">Elem_VEF_base</a>&amp; type_elemvef= zone_VEF.<a class="code" href="classZone__VEF.html#a46693c060b8096fb2595ca72192eea2a">type_elem</a>().<a class="code" href="classDeriv__Elem__VEF__base.html#a2886905d5071be902c77248b69ca0b7b">valeur</a>();
<a name="l00859"></a>00859   <span class="keywordtype">int</span> istetra=0;
<a name="l00860"></a>00860   <a class="code" href="classNom.html" title="class Nom Une chaine de caractere pour nommer les objets de TRUST">Nom</a> nom_elem=type_elemvef.<a class="code" href="classObjet__U.html#aa58e9a81c0ddc2c1149053b8f96698ac" title="renvoie la chaine identifiant la classe.">que_suis_je</a>();
<a name="l00861"></a>00861   <span class="keywordflow">if</span> ((nom_elem==<span class="stringliteral">&quot;Tetra_VEF&quot;</span>)||(nom_elem==<span class="stringliteral">&quot;Tri_VEF&quot;</span>))
<a name="l00862"></a>00862     istetra=1;
<a name="l00863"></a>00863 
<a name="l00864"></a>00864 
<a name="l00865"></a>00865 <span class="comment">// Les polyedres non standard sont ranges en 2 groupes dans la Zone_VEF:</span>
<a name="l00866"></a>00866 <span class="comment">// - polyedres bords et joints</span>
<a name="l00867"></a>00867 <span class="comment">// - polyedres bords et non joints</span>
<a name="l00868"></a>00868 <span class="comment">// On traite les polyedres en suivant l&#39;ordre dans lequel ils figurent</span>
<a name="l00869"></a>00869 <span class="comment">// dans la zone</span>
<a name="l00870"></a>00870 
<a name="l00871"></a>00871 <span class="comment">// boucle sur les polys</span>
<a name="l00872"></a>00872   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; KEL=zone_VEF.<a class="code" href="classZone__VEF.html#a46693c060b8096fb2595ca72192eea2a">type_elem</a>().<a class="code" href="classDeriv__Elem__VEF__base.html#a2886905d5071be902c77248b69ca0b7b">valeur</a>().<a class="code" href="classElem__VEF__base.html#ab129610ef702aa8c9c98dcb4c7551172">KEL</a>();
<a name="l00873"></a>00873   <span class="keywordtype">int</span> phi_u_transportant_yes=<a class="code" href="classOp__Conv__VEF__base.html#ad380b9b9ca1d70282b289838a604a4b0" title="definit si l&#39;on convecte psi avec phi*u ou avec u">phi_u_transportant</a>(<a class="code" href="classMorEqn.html#a615dd9abff96edcb625fa0424a489864" title="Renvoie la reference sur l&#39;equation pointe par MorEqn::mon_equation. (version const)">equation</a>());
<a name="l00874"></a>00874   <span class="keywordflow">for</span> (poly=0; poly&lt;nb_elem_tot; poly++)
<a name="l00875"></a>00875     {
<a name="l00876"></a>00876 
<a name="l00877"></a>00877       rang = rang_elem_non_std(poly);
<a name="l00878"></a>00878       <span class="keywordflow">if</span> (rang==-1)
<a name="l00879"></a>00879         itypcl=0;
<a name="l00880"></a>00880       <span class="keywordflow">else</span>
<a name="l00881"></a>00881         itypcl=zone_Cl_VEF.<a class="code" href="classZone__Cl__VEF.html#a483bdab7690f844ed04e3defe04ec70a">type_elem_Cl</a>(rang);
<a name="l00882"></a>00882 
<a name="l00883"></a>00883 <span class="comment">// calcul des numeros des faces du polyedre</span>
<a name="l00884"></a>00884       <span class="keywordflow">for</span> (face_adj=0; face_adj&lt;nfac; face_adj++)
<a name="l00885"></a>00885         face(face_adj)= elem_faces(poly,face_adj);
<a name="l00886"></a>00886 
<a name="l00887"></a>00887       <span class="keywordflow">for</span> (j=0; j&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; j++)
<a name="l00888"></a>00888         {
<a name="l00889"></a>00889           vs(j) = vitesse_face_absolue(face(0),j)*porosite_face(face(0));
<a name="l00890"></a>00890           <span class="keywordflow">for</span> (i=1; i&lt;nfac; i++)
<a name="l00891"></a>00891             vs(j)+= vitesse_face_absolue(face(i),j)*porosite_face(face(i));
<a name="l00892"></a>00892         }
<a name="l00893"></a>00893 <span class="comment">// calcul de la vitesse aux sommets des polyedres</span>
<a name="l00894"></a>00894 <span class="comment">// On va utliser les fonctions de forme implementees dans la classe Champs_P1_impl ou Champs_Q1_impl</span>
<a name="l00895"></a>00895       <span class="keywordflow">if</span> (istetra==1)
<a name="l00896"></a>00896         {
<a name="l00897"></a>00897           <span class="keywordflow">for</span> (i=0; i&lt;nsom; i++)
<a name="l00898"></a>00898             <span class="keywordflow">for</span> (j=0; j&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; j++)
<a name="l00899"></a>00899               vsom(i,j) = (vs(j) - dimension*vitesse_face_absolue(face(i),j)*porosite_face(face(i)));
<a name="l00900"></a>00900         }
<a name="l00901"></a>00901       <span class="keywordflow">else</span>
<a name="l00902"></a>00902         {
<a name="l00903"></a>00903 <span class="comment">// pour que cela soit valide avec les hexa (c&#39;est + lent a calculer...)</span>
<a name="l00904"></a>00904           <span class="keywordtype">int</span> ncomp;
<a name="l00905"></a>00905           <span class="keywordflow">for</span> (j=0; j&lt;nsom; j++)
<a name="l00906"></a>00906             {
<a name="l00907"></a>00907               num_som = sommet_elem(poly,j);
<a name="l00908"></a>00908               <span class="keywordflow">for</span> (ncomp=0; ncomp&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; ncomp++)
<a name="l00909"></a>00909                 vsom(j,ncomp) = la_vitesse.<a class="code" href="classChamp__base.html#ad78f84c898b6fca623a30a9ae665c269" title="renvoi la compo eme corrdonne des valeurs a l&#39;element le_poly au sommet sommet">valeur_a_sommet_compo</a>(num_som,poly,ncomp);
<a name="l00910"></a>00910             }
<a name="l00911"></a>00911         }
<a name="l00912"></a>00912 
<a name="l00913"></a>00913 
<a name="l00914"></a>00914 <span class="comment">// calcul de vc (a l&#39;intersection des 3 facettes) vc vs vsom proportionnelles a la prosite</span>
<a name="l00915"></a>00915       type_elemvef.<a class="code" href="classElem__VEF__base.html#a02b712675ec9d8bbb6571ddbbec33417">calcul_vc</a>(face,vc,vs,vsom,<a class="code" href="classOp__Conv__VEF__base.html#a4872ffd7c638ecc415191d92d7f5f507">vitesse</a>(),itypcl,porosite_face);
<a name="l00916"></a>00916       <span class="keywordflow">if</span> (marq==0)
<a name="l00917"></a>00917         {
<a name="l00918"></a>00918           <span class="keywordtype">double</span> porosite_poly=porosite_elem(poly);
<a name="l00919"></a>00919           <span class="keywordflow">for</span> (i=0; i&lt;nsom; i++)
<a name="l00920"></a>00920             <span class="keywordflow">for</span> (j=0; j&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; j++)
<a name="l00921"></a>00921               vsom(i,j)/=porosite_poly;
<a name="l00922"></a>00922           <span class="keywordflow">for</span> (j=0; j&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; j++)
<a name="l00923"></a>00923             {
<a name="l00924"></a>00924               vs(j)/= porosite_elem(poly);
<a name="l00925"></a>00925               vc(j)/=porosite_elem(poly);
<a name="l00926"></a>00926             }
<a name="l00927"></a>00927         }
<a name="l00928"></a>00928 <span class="comment">// Boucle sur les facettes du polyedre non standard:</span>
<a name="l00929"></a>00929       <span class="keywordflow">for</span> (fa7=0; fa7&lt;nfa7; fa7++)
<a name="l00930"></a>00930         {
<a name="l00931"></a>00931           num10 = face(KEL(0,fa7));
<a name="l00932"></a>00932           num20 = face(KEL(1,fa7));
<a name="l00933"></a>00933 <span class="comment">// normales aux facettes</span>
<a name="l00934"></a>00934           <span class="keywordflow">if</span> (rang==-1)
<a name="l00935"></a>00935             {
<a name="l00936"></a>00936               <span class="keywordflow">for</span> (i=0; i&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; i++)
<a name="l00937"></a>00937                 cc[i] = facette_normales(poly, fa7, i);
<a name="l00938"></a>00938             }
<a name="l00939"></a>00939           <span class="keywordflow">else</span>
<a name="l00940"></a>00940             {
<a name="l00941"></a>00941               <span class="keywordflow">for</span> (i=0; i&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; i++)
<a name="l00942"></a>00942                 cc[i] = normales_facettes_Cl(rang,fa7,i);
<a name="l00943"></a>00943             }
<a name="l00944"></a>00944 <span class="comment">// On applique le schema de convection a chaque sommet de la facette</span>
<a name="l00945"></a>00945 
<a name="l00946"></a>00946 
<a name="l00947"></a>00947           <span class="keywordtype">double</span> psc_c=0,psc_s=0,psc_m,psc_s2=0;
<a name="l00948"></a>00948           <span class="keywordflow">if</span> (dimension==2)
<a name="l00949"></a>00949             {
<a name="l00950"></a>00950               <span class="keywordflow">for</span> (i=0; i&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; i++)
<a name="l00951"></a>00951                 {
<a name="l00952"></a>00952                   psc_c+=vc[i]*cc[i];
<a name="l00953"></a>00953                   psc_s+=vsom(KEL(2,fa7),i)*cc[i];
<a name="l00954"></a>00954                 }
<a name="l00955"></a>00955               psc_m=(psc_c+psc_s)/2.;
<a name="l00956"></a>00956             }
<a name="l00957"></a>00957           <span class="keywordflow">else</span>
<a name="l00958"></a>00958             {
<a name="l00959"></a>00959               <span class="keywordflow">for</span> (i=0; i&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; i++)
<a name="l00960"></a>00960                 {
<a name="l00961"></a>00961                   psc_c+=vc[i]*cc[i];
<a name="l00962"></a>00962                   psc_s+=vsom(KEL(2,fa7),i)*cc[i];
<a name="l00963"></a>00963                   psc_s2+=vsom(KEL(3,fa7),i)*cc[i];
<a name="l00964"></a>00964                 }
<a name="l00965"></a>00965               psc_m=(psc_c+psc_s+psc_s2)/3.;
<a name="l00966"></a>00966             }
<a name="l00967"></a>00967           <a class="code" href="Op__Conv__VEF__Face_8cpp.html#a59458e475a218a4b9bc7832d508dcf0b">convbisimplicite_dec</a>(psc_m,num10,num20,transporte,ncomp_ch_transporte,coeff,matrice,porosite_face,phi_u_transportant_yes);
<a name="l00968"></a>00968         } <span class="comment">//!&lt; fin de boucle sur les facettes.</span>
<a name="l00969"></a>00969 <span class="comment"></span>
<a name="l00970"></a>00970     } <span class="comment">//!&lt; fin de boucle sur les polyedres.</span>
<a name="l00971"></a>00971 <span class="comment"></span>
<a name="l00972"></a>00972 <span class="comment">// Boucle sur les bords pour traiter les conditions aux limites</span>
<a name="l00973"></a>00973 <span class="comment">// il y a prise en compte d&#39;un terme de convection pour les</span>
<a name="l00974"></a>00974 <span class="comment">// conditions aux limites de Neumann_sortie_libre seulement</span>
<a name="l00975"></a>00975   <span class="keywordtype">int</span> nb_bord = zone_VEF.<a class="code" href="classZone__dis__base.html#af22167d614644f55591a29c77eb1c009">nb_front_Cl</a>();
<a name="l00976"></a>00976   <span class="keywordflow">for</span> (n_bord=0; n_bord&lt;nb_bord; n_bord++)
<a name="l00977"></a>00977     {
<a name="l00978"></a>00978 
<a name="l00979"></a>00979       <span class="keyword">const</span> <a class="code" href="classCond__lim.html" title="classe Cond_lim Classe generique servant a representer n&#39;importe quelle classe derivee de la classe C...">Cond_lim</a>&amp; la_cl = zone_Cl_VEF.<a class="code" href="classZone__Cl__dis__base.html#af75e0ed7786863e4d333bfb29d67c323" title="Renvoie la i-ieme condition aux limites. (version const)">les_conditions_limites</a>(n_bord);
<a name="l00980"></a>00980 
<a name="l00981"></a>00981       <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classNeumann__sortie__libre.html" title="classe Neumann_sortie_libre Cette classe represente une frontiere ouverte sans vitesse imposee Pour l...">Neumann_sortie_libre</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>()))
<a name="l00982"></a>00982         {
<a name="l00983"></a>00983           <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp; le_bord = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>,la_cl.<a class="code" href="classCond__lim.html#a5b2d24809cee07727006a891d4ce8d22" title="Appel a l&#39;objet sous-jacent Renvoie la frontiere discretisee associee a la condition aux limites...">frontiere_dis</a>());
<a name="l00984"></a>00984           <span class="keywordtype">int</span> num1 = le_bord.<a class="code" href="classFront__VF.html#a4986f0c65653fe9eb40bbbff5a97bf16" title="Numero de la premiere face du bord dans la liste des faces.">num_premiere_face</a>();
<a name="l00985"></a>00985           <span class="keywordtype">int</span> num2 = num1 + le_bord.<a class="code" href="classFront__VF.html#a341e2fcb5117b96e745fd7078ba86bab" title="Nombre de faces reelles du bord.">nb_faces</a>();
<a name="l00986"></a>00986           <span class="keywordflow">for</span> (num_face=num1; num_face&lt;num2; num_face++)
<a name="l00987"></a>00987             {
<a name="l00988"></a>00988               psc =0;
<a name="l00989"></a>00989               <span class="keywordflow">for</span> (i=0; i&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; i++)
<a name="l00990"></a>00990                 psc += vitesse_face(num_face,i)*face_normales(num_face,i);
<a name="l00991"></a>00991               <span class="keywordflow">if</span> (!phi_u_transportant_yes)
<a name="l00992"></a>00992                 psc*=porosite_face(num_face);
<a name="l00993"></a>00993               <span class="keywordflow">if</span> (psc&gt;0)
<a name="l00994"></a>00994                 {
<a name="l00995"></a>00995                   <span class="keywordflow">for</span> (j=0; j&lt;ncomp_ch_transporte; j++)
<a name="l00996"></a>00996                     {
<a name="l00997"></a>00997                       <span class="keywordtype">int</span> n0=num_face*ncomp_ch_transporte+j;
<a name="l00998"></a>00998                       matrice(n0,n0)+=psc;
<a name="l00999"></a>00999                     }
<a name="l01000"></a>01000                 }
<a name="l01001"></a>01001             }
<a name="l01002"></a>01002         }
<a name="l01003"></a>01003     }
<a name="l01004"></a>01004   <a class="code" href="classOp__VEF__Face.html#a00a9703ef92c279f100fa3872cc8ec09" title="Somme les 2 lignes des faces periodiques associees permet de calculer dans le code sans se poser de q...">modifier_matrice_pour_periodique_apres_contribuer</a>(matrice,<a class="code" href="classMorEqn.html#a615dd9abff96edcb625fa0424a489864" title="Renvoie la reference sur l&#39;equation pointe par MorEqn::mon_equation. (version const)">equation</a>());
<a name="l01005"></a>01005 }
<a name="l01006"></a>01006 
<a name="l01007"></a><a class="code" href="classOp__Conv__VEF__Face.html#a1ba01f3a164ec599e2eb12fea246fac7">01007</a> <span class="keywordtype">void</span> <a class="code" href="classOp__Conv__VEF__Face.html#a1ba01f3a164ec599e2eb12fea246fac7">Op_Conv_VEF_Face::contribue_au_second_membre</a>(<a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; resu )<span class="keyword"> const</span>
<a name="l01008"></a>01008 <span class="keyword"></span>{
<a name="l01009"></a>01009   <span class="keyword">const</span> <a class="code" href="classZone__Cl__VEF.html">Zone_Cl_VEF</a>&amp; zone_Cl_VEF = <a class="code" href="classOp__Conv__VEF__base.html#a03f677ee7911706a4f85cd37e0ca4535">la_zcl_vef</a>.<a class="code" href="classRef__Zone__Cl__VEF.html#a0970d7253def65ad4f0c5ce1830fd243">valeur</a>();
<a name="l01010"></a>01010   <span class="keyword">const</span> <a class="code" href="classZone__VEF.html" title="class Zone_VEF Classe instanciable qui derive de Zone_VF. Cette classe contient les informations geom...">Zone_VEF</a>&amp; zone_VEF = <a class="code" href="classOp__Conv__VEF__base.html#a6c29a488a6805ba4a9f2f059cdba77ae">la_zone_vef</a>.<a class="code" href="classRef__Zone__VEF.html#aafd9a5ee1a76f290c9c6b5447b0c8d30">valeur</a>();
<a name="l01011"></a>01011   <span class="keyword">const</span> <a class="code" href="classChamp__Inc__base.html" title="Classe Champ_Inc_base Classe de base des champs inconnues qui sont les champs calcules par une equati...">Champ_Inc_base</a>&amp; la_vitesse=<a class="code" href="classOp__Conv__VEF__base.html#a4872ffd7c638ecc415191d92d7f5f507">vitesse</a>();
<a name="l01012"></a>01012   <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; face_normales = zone_VEF.<a class="code" href="classZone__VEF.html#a5742d75972e4846bf9fbb6ed5715053e">face_normales</a>();
<a name="l01013"></a>01013   <span class="keyword">const</span> <a class="code" href="classZone.html" title="classe Zone Une Zone est un maillage compose d&#39;un ensemble d&#39;elements geometriques de meme type...">Zone</a>&amp; zone = zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>();
<a name="l01014"></a>01014   <span class="keywordtype">int</span> nfac = zone.<a class="code" href="classZone.html#a548fbc7518be2f122b1a5c9589a443c2" title="Renvoie le nombre de face de type i des elements geometriques constituants la zone. Ex: les objets de la classe Prisme ont 2 types de faces: triangle ou quadrangle.">nb_faces_elem</a>();
<a name="l01015"></a>01015 
<a name="l01016"></a>01016   <span class="keywordtype">double</span> psc;
<a name="l01017"></a>01017   <span class="keywordtype">int</span> i,n_bord;
<a name="l01018"></a>01018   <span class="keywordtype">int</span> num_face;
<a name="l01019"></a>01019   <span class="keywordtype">int</span> ncomp;
<a name="l01020"></a>01020   <span class="keywordflow">if</span> (resu.<a class="code" href="classDoubleTab.html#ae6dda48778e7107e1beb723beef1f75b" title="Returns the number of dimensions of the array (&gt;= 1)">nb_dim</a>() == 1)
<a name="l01021"></a>01021     ncomp=1;
<a name="l01022"></a>01022   <span class="keywordflow">else</span>
<a name="l01023"></a>01023     ncomp= resu.<a class="code" href="classDoubleTab.html#ac3805e2637a3b880ba2d3e650c69dac4" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(1);
<a name="l01024"></a>01024 
<a name="l01025"></a>01025   <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> face(nfac);
<a name="l01026"></a>01026 
<a name="l01027"></a>01027 
<a name="l01028"></a>01028 <span class="comment">// Traitement particulier pour les faces de periodicite</span>
<a name="l01029"></a>01029 
<a name="l01030"></a>01030   <span class="keywordtype">int</span> nb_faces_perio = 0;
<a name="l01031"></a>01031   <span class="keywordtype">int</span> voisine;
<a name="l01032"></a>01032   <span class="keywordtype">double</span> diff1,diff2;
<a name="l01033"></a>01033 
<a name="l01034"></a>01034 <span class="comment">// Boucle pour compter le nombre de faces de periodicite</span>
<a name="l01035"></a>01035   <span class="keywordflow">for</span> (n_bord=0; n_bord&lt;zone_VEF.<a class="code" href="classZone__dis__base.html#af22167d614644f55591a29c77eb1c009">nb_front_Cl</a>(); n_bord++)
<a name="l01036"></a>01036     {
<a name="l01037"></a>01037       <span class="keyword">const</span> <a class="code" href="classCond__lim.html" title="classe Cond_lim Classe generique servant a representer n&#39;importe quelle classe derivee de la classe C...">Cond_lim</a>&amp; la_cl = zone_Cl_VEF.<a class="code" href="classZone__Cl__dis__base.html#af75e0ed7786863e4d333bfb29d67c323" title="Renvoie la i-ieme condition aux limites. (version const)">les_conditions_limites</a>(n_bord);
<a name="l01038"></a>01038       <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>()))
<a name="l01039"></a>01039         {
<a name="l01040"></a>01040           <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp; le_bord = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>,la_cl.<a class="code" href="classCond__lim.html#a5b2d24809cee07727006a891d4ce8d22" title="Appel a l&#39;objet sous-jacent Renvoie la frontiere discretisee associee a la condition aux limites...">frontiere_dis</a>());
<a name="l01041"></a>01041           nb_faces_perio += le_bord.<a class="code" href="classFront__VF.html#a341e2fcb5117b96e745fd7078ba86bab" title="Nombre de faces reelles du bord.">nb_faces</a>();
<a name="l01042"></a>01042         }
<a name="l01043"></a>01043     }
<a name="l01044"></a>01044 
<a name="l01045"></a>01045   <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a> tab;
<a name="l01046"></a>01046   <span class="keywordflow">if</span> (ncomp == 1)
<a name="l01047"></a>01047     tab.<a class="code" href="classDoubleTab.html#ae83b4d31205c53d9c8d2b43da178ce75" title="Change la taille du vecteur (identique a resize_array() pour le traitement des anciennes valeurs et d...">resize</a>(nb_faces_perio);
<a name="l01048"></a>01048   <span class="keywordflow">else</span>
<a name="l01049"></a>01049     tab.<a class="code" href="classDoubleTab.html#ae83b4d31205c53d9c8d2b43da178ce75" title="Change la taille du vecteur (identique a resize_array() pour le traitement des anciennes valeurs et d...">resize</a>(nb_faces_perio,ncomp);
<a name="l01050"></a>01050 
<a name="l01051"></a>01051 <span class="comment">// Boucle pour remplir tab</span>
<a name="l01052"></a>01052   nb_faces_perio=0;
<a name="l01053"></a>01053   <span class="keywordflow">for</span> (n_bord=0; n_bord&lt;zone_VEF.<a class="code" href="classZone__dis__base.html#af22167d614644f55591a29c77eb1c009">nb_front_Cl</a>(); n_bord++)
<a name="l01054"></a>01054     {
<a name="l01055"></a>01055       <span class="keyword">const</span> <a class="code" href="classCond__lim.html" title="classe Cond_lim Classe generique servant a representer n&#39;importe quelle classe derivee de la classe C...">Cond_lim</a>&amp; la_cl = zone_Cl_VEF.<a class="code" href="classZone__Cl__dis__base.html#af75e0ed7786863e4d333bfb29d67c323" title="Renvoie la i-ieme condition aux limites. (version const)">les_conditions_limites</a>(n_bord);
<a name="l01056"></a>01056       <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>()))
<a name="l01057"></a>01057         {
<a name="l01058"></a>01058           <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp; le_bord = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>,la_cl.<a class="code" href="classCond__lim.html#a5b2d24809cee07727006a891d4ce8d22" title="Appel a l&#39;objet sous-jacent Renvoie la frontiere discretisee associee a la condition aux limites...">frontiere_dis</a>());
<a name="l01059"></a>01059           <span class="keywordtype">int</span> num1 = le_bord.<a class="code" href="classFront__VF.html#a4986f0c65653fe9eb40bbbff5a97bf16" title="Numero de la premiere face du bord dans la liste des faces.">num_premiere_face</a>();
<a name="l01060"></a>01060           <span class="keywordtype">int</span> num2 = num1 + le_bord.<a class="code" href="classFront__VF.html#a341e2fcb5117b96e745fd7078ba86bab" title="Nombre de faces reelles du bord.">nb_faces</a>();
<a name="l01061"></a>01061           <span class="keywordflow">for</span> (num_face=num1; num_face&lt;num2; num_face++)
<a name="l01062"></a>01062             {
<a name="l01063"></a>01063               <span class="keywordflow">if</span> (ncomp == 1)
<a name="l01064"></a>01064                 tab(nb_faces_perio) = resu(num_face);
<a name="l01065"></a>01065               <span class="keywordflow">else</span>
<a name="l01066"></a>01066                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> comp=0; comp&lt;ncomp; comp++)
<a name="l01067"></a>01067                   tab(nb_faces_perio,comp) = resu(num_face,comp);
<a name="l01068"></a>01068               nb_faces_perio++;
<a name="l01069"></a>01069             }
<a name="l01070"></a>01070         }
<a name="l01071"></a>01071     }
<a name="l01072"></a>01072 <span class="comment">// Boucle sur les bords pour traiter les conditions aux limites</span>
<a name="l01073"></a>01073 <span class="comment">// il y a prise en compte d&#39;un terme de convection pour les</span>
<a name="l01074"></a>01074 <span class="comment">// conditions aux limites de Neumann_sortie_libre seulement</span>
<a name="l01075"></a>01075   nb_faces_perio=0;
<a name="l01076"></a>01076   <span class="keywordflow">for</span> (n_bord=0; n_bord&lt;zone_VEF.<a class="code" href="classZone__dis__base.html#af22167d614644f55591a29c77eb1c009">nb_front_Cl</a>(); n_bord++)
<a name="l01077"></a>01077     {
<a name="l01078"></a>01078 
<a name="l01079"></a>01079       <span class="keyword">const</span> <a class="code" href="classCond__lim.html" title="classe Cond_lim Classe generique servant a representer n&#39;importe quelle classe derivee de la classe C...">Cond_lim</a>&amp; la_cl = zone_Cl_VEF.<a class="code" href="classZone__Cl__dis__base.html#af75e0ed7786863e4d333bfb29d67c323" title="Renvoie la i-ieme condition aux limites. (version const)">les_conditions_limites</a>(n_bord);
<a name="l01080"></a>01080 
<a name="l01081"></a>01081       <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classNeumann__sortie__libre.html" title="classe Neumann_sortie_libre Cette classe represente une frontiere ouverte sans vitesse imposee Pour l...">Neumann_sortie_libre</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>()))
<a name="l01082"></a>01082         {
<a name="l01083"></a>01083           <span class="keyword">const</span> <a class="code" href="classNeumann__sortie__libre.html" title="classe Neumann_sortie_libre Cette classe represente une frontiere ouverte sans vitesse imposee Pour l...">Neumann_sortie_libre</a>&amp; la_sortie_libre = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classNeumann__sortie__libre.html" title="classe Neumann_sortie_libre Cette classe represente une frontiere ouverte sans vitesse imposee Pour l...">Neumann_sortie_libre</a>, la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>());
<a name="l01084"></a>01084           <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp; le_bord = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>,la_cl.<a class="code" href="classCond__lim.html#a5b2d24809cee07727006a891d4ce8d22" title="Appel a l&#39;objet sous-jacent Renvoie la frontiere discretisee associee a la condition aux limites...">frontiere_dis</a>());
<a name="l01085"></a>01085           <span class="keywordtype">int</span> num1 = le_bord.num_premiere_face();
<a name="l01086"></a>01086           <span class="keywordtype">int</span> num2 = num1 + le_bord.nb_faces();
<a name="l01087"></a>01087           <span class="keywordflow">for</span> (num_face=num1; num_face&lt;num2; num_face++)
<a name="l01088"></a>01088             {
<a name="l01089"></a>01089               psc =0;
<a name="l01090"></a>01090               <span class="keywordflow">for</span> (i=0; i&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; i++)
<a name="l01091"></a>01091                 psc += la_vitesse(num_face,i)*face_normales(num_face,i);
<a name="l01092"></a>01092               <span class="keywordflow">if</span> (psc&gt;0)
<a name="l01093"></a>01093                 <span class="keywordflow">if</span> (ncomp == 1)
<a name="l01094"></a>01094                   resu(num_face) += 0;
<a name="l01095"></a>01095                 <span class="keywordflow">else</span>
<a name="l01096"></a>01096                   <span class="keywordflow">for</span> (i=0; i&lt;ncomp; i++)
<a name="l01097"></a>01097                     resu(num_face,i) += 0;
<a name="l01098"></a>01098               <span class="keywordflow">else</span>
<a name="l01099"></a>01099                 {
<a name="l01100"></a>01100                   <span class="keywordflow">if</span> (ncomp == 1)
<a name="l01101"></a>01101                     resu(num_face) -= psc*la_sortie_libre.<a class="code" href="classNeumann__sortie__libre.html#a886f1804fa2a9028fc56a0778a72a75d" title="Renvoie la valeur de la i-eme composante du champ impose a l&#39;exterieur de la frontiere.">val_ext</a>(num_face-num1);
<a name="l01102"></a>01102                   <span class="keywordflow">else</span>
<a name="l01103"></a>01103                     <span class="keywordflow">for</span> (i=0; i&lt;ncomp; i++)
<a name="l01104"></a>01104                       resu(num_face,i) -= psc*la_sortie_libre.<a class="code" href="classNeumann__sortie__libre.html#a886f1804fa2a9028fc56a0778a72a75d" title="Renvoie la valeur de la i-eme composante du champ impose a l&#39;exterieur de la frontiere.">val_ext</a>(num_face-num1,i);
<a name="l01105"></a>01105                 }
<a name="l01106"></a>01106             }
<a name="l01107"></a>01107         }
<a name="l01108"></a>01108       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>()))
<a name="l01109"></a>01109         {
<a name="l01110"></a>01110           <span class="keyword">const</span> <a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>&amp; la_cl_perio = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>, la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>());
<a name="l01111"></a>01111           <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp; le_bord = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>,la_cl.<a class="code" href="classCond__lim.html#a5b2d24809cee07727006a891d4ce8d22" title="Appel a l&#39;objet sous-jacent Renvoie la frontiere discretisee associee a la condition aux limites...">frontiere_dis</a>());
<a name="l01112"></a>01112           <span class="keywordtype">int</span> num1 = le_bord.num_premiere_face();
<a name="l01113"></a>01113           <span class="keywordtype">int</span> num2 = num1 + le_bord.nb_faces();
<a name="l01114"></a>01114           <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> fait(le_bord.nb_faces());
<a name="l01115"></a>01115           fait = 0;
<a name="l01116"></a>01116           <span class="keywordflow">for</span> (num_face=num1; num_face&lt;num2; num_face++)
<a name="l01117"></a>01117             {
<a name="l01118"></a>01118               <span class="keywordflow">if</span> (fait[num_face-num1] == 0)
<a name="l01119"></a>01119                 {
<a name="l01120"></a>01120                   voisine = la_cl_perio.<a class="code" href="classPeriodique.html#a207b86556f199a63ea059b841851ca6a">face_associee</a>(num_face-num1) + num1;
<a name="l01121"></a>01121 
<a name="l01122"></a>01122                   <span class="keywordflow">if</span> (ncomp == 1)
<a name="l01123"></a>01123                     {
<a name="l01124"></a>01124                       diff1 = resu(num_face)-tab(nb_faces_perio);
<a name="l01125"></a>01125                       diff2 = resu(voisine)-tab(nb_faces_perio+voisine-num_face);
<a name="l01126"></a>01126                       resu(voisine)  += diff1;
<a name="l01127"></a>01127                       resu(num_face) += diff2;
<a name="l01128"></a>01128                     }
<a name="l01129"></a>01129                   <span class="keywordflow">else</span>
<a name="l01130"></a>01130                     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> comp=0; comp&lt;ncomp; comp++)
<a name="l01131"></a>01131                       {
<a name="l01132"></a>01132                         diff1 = resu(num_face,comp)-tab(nb_faces_perio,comp);
<a name="l01133"></a>01133                         diff2 = resu(voisine,comp)-tab(nb_faces_perio+voisine-num_face,comp);
<a name="l01134"></a>01134                         resu(voisine,comp)  += diff1;
<a name="l01135"></a>01135                         resu(num_face,comp) += diff2;
<a name="l01136"></a>01136                       }
<a name="l01137"></a>01137 
<a name="l01138"></a>01138                   fait[num_face-num1]= 1;
<a name="l01139"></a>01139                   fait[voisine-num1] = 1;
<a name="l01140"></a>01140                 }
<a name="l01141"></a>01141               nb_faces_perio++;
<a name="l01142"></a>01142             }
<a name="l01143"></a>01143         }
<a name="l01144"></a>01144     }
<a name="l01145"></a>01145 }
<a name="l01146"></a>01146 
<a name="l01147"></a>01147 
<a name="l01148"></a>01148 
<a name="l01149"></a><a class="code" href="classOp__Conv__VEF__Face.html#a1fcf6b33ff3ee706ffef89a117e2f54a">01149</a> <span class="keywordtype">void</span>  <a class="code" href="classOp__Conv__VEF__Face.html#a1fcf6b33ff3ee706ffef89a117e2f54a">Op_Conv_VEF_Face::remplir_fluent</a>(<a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; tab_fluent)<span class="keyword"> const</span>
<a name="l01150"></a>01150 <span class="keyword"></span>{
<a name="l01151"></a>01151 
<a name="l01152"></a>01152   assert((<a class="code" href="classOp__Conv__VEF__Face.html#aac6bde5c9421ce149a3f28a11709b1f6">type_op</a>==<a class="code" href="classOp__Conv__VEF__Face.html#abbf17549ccbad9c64780dcca7a3e2634a1192ae3f2c2a1d9d734f4cc495b58a44">amont</a>) || (<a class="code" href="classOp__Conv__VEF__Face.html#aac6bde5c9421ce149a3f28a11709b1f6">type_op</a>==<a class="code" href="classOp__Conv__VEF__Face.html#abbf17549ccbad9c64780dcca7a3e2634af9bc4313cad73dd46e9d5364c4f001b3">muscl</a>) || (<a class="code" href="classOp__Conv__VEF__Face.html#aac6bde5c9421ce149a3f28a11709b1f6">type_op</a>==<a class="code" href="classOp__Conv__VEF__Face.html#abbf17549ccbad9c64780dcca7a3e2634aeb4b20f4ab0bb61c69bfbf25d47d219d">centre</a>));
<a name="l01153"></a>01153   <span class="keyword">const</span> <a class="code" href="classZone__Cl__VEF.html">Zone_Cl_VEF</a>&amp; zone_Cl_VEF = <a class="code" href="classOp__Conv__VEF__base.html#a03f677ee7911706a4f85cd37e0ca4535">la_zcl_vef</a>.<a class="code" href="classRef__Zone__Cl__VEF.html#a0970d7253def65ad4f0c5ce1830fd243">valeur</a>();
<a name="l01154"></a>01154   <span class="keyword">const</span> <a class="code" href="classZone__VEF.html" title="class Zone_VEF Classe instanciable qui derive de Zone_VF. Cette classe contient les informations geom...">Zone_VEF</a>&amp; zone_VEF = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classZone__VEF.html" title="class Zone_VEF Classe instanciable qui derive de Zone_VF. Cette classe contient les informations geom...">Zone_VEF</a>, <a class="code" href="classOp__Conv__VEF__base.html#a6c29a488a6805ba4a9f2f059cdba77ae">la_zone_vef</a>.<a class="code" href="classRef__Zone__VEF.html#aafd9a5ee1a76f290c9c6b5447b0c8d30">valeur</a>());
<a name="l01155"></a>01155   <span class="keyword">const</span> <a class="code" href="classChamp__Inc__base.html" title="Classe Champ_Inc_base Classe de base des champs inconnues qui sont les champs calcules par une equati...">Champ_Inc_base</a>&amp; la_vitesse=<a class="code" href="classOp__Conv__VEF__base.html#a4872ffd7c638ecc415191d92d7f5f507">vitesse</a>();
<a name="l01156"></a>01156   <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; vitesse_face_absolue=la_vitesse.valeurs();
<a name="l01157"></a>01157 
<a name="l01158"></a>01158   <span class="keywordtype">int</span> marq=<a class="code" href="classOp__Conv__VEF__base.html#ad380b9b9ca1d70282b289838a604a4b0" title="definit si l&#39;on convecte psi avec phi*u ou avec u">phi_u_transportant</a>(<a class="code" href="classMorEqn.html#a615dd9abff96edcb625fa0424a489864" title="Renvoie la reference sur l&#39;equation pointe par MorEqn::mon_equation. (version const)">equation</a>());
<a name="l01159"></a>01159 <span class="comment">// on force a calculer un pas de temps sans &quot;porosite&quot;</span>
<a name="l01160"></a>01160   marq=0;
<a name="l01161"></a>01161 
<a name="l01162"></a>01162   <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; porosite_face = zone_VEF.<a class="code" href="classZone__VF.html#ad9d74d1d9da9f50ab26768dbbca7711b">porosite_face</a>();
<a name="l01163"></a>01163 
<a name="l01164"></a>01164 
<a name="l01165"></a>01165   <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; vitesse_face=vitesse_face_absolue;
<a name="l01166"></a>01166 
<a name="l01167"></a>01167   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; elem_faces = zone_VEF.<a class="code" href="classZone__VF.html#a067e462dcd3ab92b0f6d945b19e4eb37" title="renvoie le numero de le ieme face de la maille num_elem la facon dont ces faces sont numerotees est l...">elem_faces</a>();
<a name="l01168"></a>01168   <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; face_normales = zone_VEF.<a class="code" href="classZone__VEF.html#a5742d75972e4846bf9fbb6ed5715053e">face_normales</a>();
<a name="l01169"></a>01169   <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; facette_normales = zone_VEF.<a class="code" href="classZone__VEF.html#a581b1ca0e62c668c92f104351d19fda6">facette_normales</a>();
<a name="l01170"></a>01170   <span class="keyword">const</span> <a class="code" href="classZone.html" title="classe Zone Une Zone est un maillage compose d&#39;un ensemble d&#39;elements geometriques de meme type...">Zone</a>&amp; zone = zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>();
<a name="l01171"></a>01171   <span class="keyword">const</span> <span class="keywordtype">int</span> nfa7 = zone_VEF.<a class="code" href="classZone__VEF.html#a46693c060b8096fb2595ca72192eea2a">type_elem</a>().<a class="code" href="classElem__VEF.html#a4a34777c0083b38dd34c8a400d5b4e90">nb_facette</a>();
<a name="l01172"></a>01172   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_elem_tot = zone_VEF.<a class="code" href="classZone__dis__base.html#a4d6aa445f152aa6dc54d66ea7a071147">nb_elem_tot</a>();
<a name="l01173"></a>01173   <span class="keyword">const</span> <a class="code" href="classIntVect.html">IntVect</a>&amp; rang_elem_non_std = zone_VEF.<a class="code" href="classZone__VEF.html#a4b2171a85e5fc33663a3366acb713584">rang_elem_non_std</a>();
<a name="l01174"></a>01174   <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; normales_facettes_Cl = zone_Cl_VEF.<a class="code" href="classZone__Cl__VEF.html#a83c05e82370553470ed05f10932e0f3f">normales_facettes_Cl</a>();
<a name="l01175"></a>01175   <span class="keywordtype">int</span> nfac = zone.<a class="code" href="classZone.html#a548fbc7518be2f122b1a5c9589a443c2" title="Renvoie le nombre de face de type i des elements geometriques constituants la zone. Ex: les objets de la classe Prisme ont 2 types de faces: triangle ou quadrangle.">nb_faces_elem</a>();
<a name="l01176"></a>01176   <span class="keywordtype">int</span> nsom = zone.<a class="code" href="classZone.html#ae0b34a93b9ae8146df2d1884157afe9f" title="Renvoie le nombre de sommets des elements geometriques constituants la zone. Tous les elements de la ...">nb_som_elem</a>();
<a name="l01177"></a>01177   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; sommet_elem = zone.<a class="code" href="classZone.html#ac115e8342be89afb882b7b61cc343267" title="Renvoie le tableau des sommets des elements.">les_elems</a>();
<a name="l01178"></a>01178   <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; fluent_ = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classDoubleVect.html">DoubleVect</a>, tab_fluent);
<a name="l01179"></a>01179 
<a name="l01180"></a>01180 <span class="comment">// On definit le tableau des sommets:(C MALOD 17/07/2007)</span>
<a name="l01181"></a>01181 
<a name="l01182"></a>01182 <span class="comment">// Pour le traitement de la convection on distingue les polyedres</span>
<a name="l01183"></a>01183 <span class="comment">// standard qui ne &quot;voient&quot; pas les conditions aux limites et les</span>
<a name="l01184"></a>01184 <span class="comment">// polyedres non standard qui ont au moins une face sur le bord.</span>
<a name="l01185"></a>01185 <span class="comment">// Un polyedre standard a n facettes sur lesquelles on applique le</span>
<a name="l01186"></a>01186 <span class="comment">// schema de convection.</span>
<a name="l01187"></a>01187 <span class="comment">// Pour un polyedre non standard qui porte des conditions aux limites</span>
<a name="l01188"></a>01188 <span class="comment">// de Dirichlet, une partie des facettes sont portees par les faces.</span>
<a name="l01189"></a>01189 <span class="comment">// En bref pour un polyedre le traitement de la convection depend</span>
<a name="l01190"></a>01190 <span class="comment">// du type (triangle, tetraedre ...) et du nombre de faces de Dirichlet.</span>
<a name="l01191"></a>01191 
<a name="l01192"></a>01192   <span class="keyword">const</span> <a class="code" href="classElem__VEF__base.html">Elem_VEF_base</a>&amp; type_elemvef= zone_VEF.<a class="code" href="classZone__VEF.html#a46693c060b8096fb2595ca72192eea2a">type_elem</a>().<a class="code" href="classDeriv__Elem__VEF__base.html#a2886905d5071be902c77248b69ca0b7b">valeur</a>();
<a name="l01193"></a>01193   <span class="keywordtype">int</span> istetra=0;
<a name="l01194"></a>01194   <a class="code" href="classNom.html" title="class Nom Une chaine de caractere pour nommer les objets de TRUST">Nom</a> nom_elem=type_elemvef.<a class="code" href="classObjet__U.html#aa58e9a81c0ddc2c1149053b8f96698ac" title="renvoie la chaine identifiant la classe.">que_suis_je</a>();
<a name="l01195"></a>01195   <span class="keywordflow">if</span> ((nom_elem==<span class="stringliteral">&quot;Tetra_VEF&quot;</span>)||(nom_elem==<span class="stringliteral">&quot;Tri_VEF&quot;</span>))
<a name="l01196"></a>01196     istetra=1;
<a name="l01197"></a>01197   <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; porosite_elem = zone_VEF.<a class="code" href="classZone__VF.html#afd135a1b227731193b1a97b7ed525435">porosite_elem</a>();
<a name="l01198"></a>01198 
<a name="l01199"></a>01199   <span class="keywordtype">double</span> psc;
<a name="l01200"></a>01200   <span class="keywordtype">int</span> poly,face_adj,fa7,i,j,n_bord;
<a name="l01201"></a>01201   <span class="keywordtype">int</span> num_face, rang ,itypcl;
<a name="l01202"></a>01202   <span class="keywordtype">int</span> num1,num2,num_som;
<a name="l01203"></a>01203 
<a name="l01204"></a>01204   <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> face(nfac);
<a name="l01205"></a>01205   <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a> vs(<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>);
<a name="l01206"></a>01206   <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a> vc(<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>);
<a name="l01207"></a>01207   <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a> vsom(nsom,<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>);
<a name="l01208"></a>01208   <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a> cc(<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>);
<a name="l01209"></a>01209 
<a name="l01210"></a>01210 <span class="comment">// Dimensionnement du tableau des flux convectifs au bord du domaine de calcul</span>
<a name="l01211"></a>01211   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; KEL=type_elemvef.<a class="code" href="classElem__VEF__base.html#ab129610ef702aa8c9c98dcb4c7551172">KEL</a>();
<a name="l01212"></a>01212 
<a name="l01213"></a>01213 <span class="comment">// On remet a zero le tableau qui sert pour</span>
<a name="l01214"></a>01214 <span class="comment">// le calcul du pas de temps de stabilite</span>
<a name="l01215"></a>01215   fluent_ = 0;
<a name="l01216"></a>01216 
<a name="l01217"></a>01217 <span class="comment">// Les polyedres non standard sont ranges en 2 groupes dans la Zone_VEF:</span>
<a name="l01218"></a>01218 <span class="comment">// - polyedres bords et joints</span>
<a name="l01219"></a>01219 <span class="comment">// - polyedres bords et non joints</span>
<a name="l01220"></a>01220 <span class="comment">// On traite les polyedres en suivant l&#39;ordre dans lequel ils figurent</span>
<a name="l01221"></a>01221 <span class="comment">// dans la zone</span>
<a name="l01222"></a>01222 
<a name="l01223"></a>01223 <span class="comment">// boucle sur les polys</span>
<a name="l01224"></a>01224   <span class="keywordflow">for</span> (poly=0; poly&lt;nb_elem_tot; poly++)
<a name="l01225"></a>01225     {
<a name="l01226"></a>01226       rang = rang_elem_non_std(poly);
<a name="l01227"></a>01227 <span class="comment">// On cherche, pour un elem qui n&#39;est pas de bord (rang==-1),</span>
<a name="l01228"></a>01228 <span class="comment">// si un des sommets est sur un bord (tableau des sommets) (C MALOD 17/07/2007)</span>
<a name="l01229"></a>01229 
<a name="l01230"></a>01230       <span class="keywordflow">if</span> (rang==-1)
<a name="l01231"></a>01231         itypcl=0;
<a name="l01232"></a>01232       <span class="keywordflow">else</span>
<a name="l01233"></a>01233         itypcl=zone_Cl_VEF.<a class="code" href="classZone__Cl__VEF.html#a483bdab7690f844ed04e3defe04ec70a">type_elem_Cl</a>(rang);
<a name="l01234"></a>01234 
<a name="l01235"></a>01235 <span class="comment">// calcul des numeros des faces du polyedre</span>
<a name="l01236"></a>01236       <span class="keywordflow">for</span> (face_adj=0; face_adj&lt;nfac; face_adj++)
<a name="l01237"></a>01237         face(face_adj)= elem_faces(poly,face_adj);
<a name="l01238"></a>01238 
<a name="l01239"></a>01239       <span class="keywordflow">for</span> (j=0; j&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; j++)
<a name="l01240"></a>01240         {
<a name="l01241"></a>01241           vs(j) = vitesse_face_absolue(face(0),j)*porosite_face(face(0));
<a name="l01242"></a>01242           <span class="keywordflow">for</span> (i=1; i&lt;nfac; i++)
<a name="l01243"></a>01243             vs(j)+= vitesse_face_absolue(face(i),j)*porosite_face(face(i));
<a name="l01244"></a>01244         }
<a name="l01245"></a>01245 <span class="comment">// calcul de la vitesse aux sommets des polyedres</span>
<a name="l01246"></a>01246 <span class="comment">// On va utliser les fonctions de forme implementees dans la classe Champs_P1_impl ou Champs_Q1_impl</span>
<a name="l01247"></a>01247       <span class="keywordflow">if</span> (istetra==1)
<a name="l01248"></a>01248         {
<a name="l01249"></a>01249           <span class="keywordflow">for</span> (i=0; i&lt;nsom; i++)
<a name="l01250"></a>01250             <span class="keywordflow">for</span> (j=0; j&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; j++)
<a name="l01251"></a>01251               vsom(i,j) = (vs(j) - dimension*vitesse_face_absolue(face(i),j)*porosite_face(face(i)));
<a name="l01252"></a>01252         }
<a name="l01253"></a>01253       <span class="keywordflow">else</span>
<a name="l01254"></a>01254         {
<a name="l01255"></a>01255 <span class="comment">// pour que cela soit valide avec les hexa (c&#39;est + lent a calculer...)</span>
<a name="l01256"></a>01256           <span class="keywordtype">int</span> ncomp;
<a name="l01257"></a>01257           <span class="keywordflow">for</span> (j=0; j&lt;nsom; j++)
<a name="l01258"></a>01258             {
<a name="l01259"></a>01259               num_som = sommet_elem(poly,j);
<a name="l01260"></a>01260               <span class="keywordflow">for</span> (ncomp=0; ncomp&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; ncomp++)
<a name="l01261"></a>01261                 vsom(j,ncomp) = la_vitesse.valeur_a_sommet_compo(num_som,poly,ncomp);
<a name="l01262"></a>01262             }
<a name="l01263"></a>01263         }
<a name="l01264"></a>01264 
<a name="l01265"></a>01265 <span class="comment">// calcul de vc (a l&#39;intersection des 3 facettes) vc vs vsom proportionnelles a la prosite</span>
<a name="l01266"></a>01266       type_elemvef.<a class="code" href="classElem__VEF__base.html#a02b712675ec9d8bbb6571ddbbec33417">calcul_vc</a>(face,vc,vs,vsom,<a class="code" href="classOp__Conv__VEF__base.html#a4872ffd7c638ecc415191d92d7f5f507">vitesse</a>(),itypcl,porosite_face);
<a name="l01267"></a>01267       <span class="keywordflow">if</span> (marq==0)
<a name="l01268"></a>01268         {
<a name="l01269"></a>01269           <span class="keywordtype">double</span> porosite_poly=porosite_elem(poly);
<a name="l01270"></a>01270           <span class="keywordflow">for</span> (i=0; i&lt;nsom; i++)
<a name="l01271"></a>01271             <span class="keywordflow">for</span> (j=0; j&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; j++)
<a name="l01272"></a>01272               vsom(i,j)/=porosite_poly;
<a name="l01273"></a>01273           <span class="keywordflow">for</span> (j=0; j&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; j++)
<a name="l01274"></a>01274             {
<a name="l01275"></a>01275               vs(j)/= porosite_poly;
<a name="l01276"></a>01276               vc(j)/=porosite_poly;
<a name="l01277"></a>01277             }
<a name="l01278"></a>01278         }
<a name="l01279"></a>01279 <span class="comment">// Boucle sur les facettes du polyedre non standard:</span>
<a name="l01280"></a>01280       <span class="keywordflow">for</span> (fa7=0; fa7&lt;nfa7; fa7++)
<a name="l01281"></a>01281         {
<a name="l01282"></a>01282           num1 = face(KEL(0,fa7));
<a name="l01283"></a>01283           num2 = face(KEL(1,fa7));
<a name="l01284"></a>01284 <span class="comment">// normales aux facettes</span>
<a name="l01285"></a>01285           <span class="keywordflow">if</span> (rang==-1)
<a name="l01286"></a>01286             {
<a name="l01287"></a>01287               <span class="keywordflow">for</span> (i=0; i&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; i++)
<a name="l01288"></a>01288                 cc[i] = facette_normales(poly, fa7, i);
<a name="l01289"></a>01289             }
<a name="l01290"></a>01290           <span class="keywordflow">else</span>
<a name="l01291"></a>01291             {
<a name="l01292"></a>01292               <span class="keywordflow">for</span> (i=0; i&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; i++)
<a name="l01293"></a>01293                 cc[i] = normales_facettes_Cl(rang,fa7,i);
<a name="l01294"></a>01294             }
<a name="l01295"></a>01295 <span class="comment">// On applique le schema de convection a chaque sommet de la facette</span>
<a name="l01296"></a>01296 
<a name="l01297"></a>01297           <span class="keywordtype">double</span> psc_c=0,psc_s=0,psc_m,psc_s2=0;
<a name="l01298"></a>01298           <span class="keywordflow">if</span> (dimension==2)
<a name="l01299"></a>01299             {
<a name="l01300"></a>01300               <span class="keywordflow">for</span> (i=0; i&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; i++)
<a name="l01301"></a>01301                 {
<a name="l01302"></a>01302                   psc_c+=vc[i]*cc[i];
<a name="l01303"></a>01303                   psc_s+=vsom(KEL(2,fa7),i)*cc[i];
<a name="l01304"></a>01304                 }
<a name="l01305"></a>01305               psc_m=(psc_c+psc_s)/2.;
<a name="l01306"></a>01306             }
<a name="l01307"></a>01307           <span class="keywordflow">else</span>
<a name="l01308"></a>01308             {
<a name="l01309"></a>01309               <span class="keywordflow">for</span> (i=0; i&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; i++)
<a name="l01310"></a>01310                 {
<a name="l01311"></a>01311                   psc_c+=vc[i]*cc[i];
<a name="l01312"></a>01312                   psc_s+=vsom(KEL(2,fa7),i)*cc[i];
<a name="l01313"></a>01313                   psc_s2+=vsom(KEL(3,fa7),i)*cc[i];
<a name="l01314"></a>01314                 }
<a name="l01315"></a>01315               psc_m=(psc_c+psc_s+psc_s2)/3.;
<a name="l01316"></a>01316             }
<a name="l01317"></a>01317 
<a name="l01318"></a>01318 <span class="comment">// int amont,dir;</span>
<a name="l01319"></a>01319           <span class="keywordflow">if</span> (psc_m &gt;= 0)
<a name="l01320"></a>01320             {
<a name="l01321"></a>01321 <span class="comment">// amont = num1;</span>
<a name="l01322"></a>01322               fluent_(num2)  += psc_m;
<a name="l01323"></a>01323 <span class="comment">// dir=0;</span>
<a name="l01324"></a>01324             }
<a name="l01325"></a>01325           <span class="keywordflow">else</span>
<a name="l01326"></a>01326             {
<a name="l01327"></a>01327 <span class="comment">// amont = num2;</span>
<a name="l01328"></a>01328               fluent_(num1)  -= psc_m;
<a name="l01329"></a>01329 <span class="comment">// dir=1;</span>
<a name="l01330"></a>01330             }
<a name="l01331"></a>01331 
<a name="l01332"></a>01332         } <span class="comment">//!&lt; fin de la boucle sur les facettes</span>
<a name="l01333"></a>01333 <span class="comment"></span>    } <span class="comment">//!&lt; fin de la boucle</span>
<a name="l01334"></a>01334 <span class="comment"></span>
<a name="l01335"></a>01335 <span class="comment">// Boucle sur les bords pour traiter les conditions aux limites</span>
<a name="l01336"></a>01336 <span class="comment">// il y a prise en compte d&#39;un terme de convection pour les</span>
<a name="l01337"></a>01337 <span class="comment">// conditions aux limites de Neumann_sortie_libre seulement</span>
<a name="l01338"></a>01338   <span class="keywordtype">int</span> nb_bord = zone_VEF.<a class="code" href="classZone__dis__base.html#af22167d614644f55591a29c77eb1c009">nb_front_Cl</a>();
<a name="l01339"></a>01339   <span class="keywordflow">for</span> (n_bord=0; n_bord&lt;nb_bord; n_bord++)
<a name="l01340"></a>01340     {
<a name="l01341"></a>01341       <span class="keyword">const</span> <a class="code" href="classCond__lim.html" title="classe Cond_lim Classe generique servant a representer n&#39;importe quelle classe derivee de la classe C...">Cond_lim</a>&amp; la_cl = zone_Cl_VEF.<a class="code" href="classZone__Cl__dis__base.html#af75e0ed7786863e4d333bfb29d67c323" title="Renvoie la i-ieme condition aux limites. (version const)">les_conditions_limites</a>(n_bord);
<a name="l01342"></a>01342       <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classNeumann__sortie__libre.html" title="classe Neumann_sortie_libre Cette classe represente une frontiere ouverte sans vitesse imposee Pour l...">Neumann_sortie_libre</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>()))
<a name="l01343"></a>01343         {
<a name="l01344"></a>01344           <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp; le_bord = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>,la_cl.<a class="code" href="classCond__lim.html#a5b2d24809cee07727006a891d4ce8d22" title="Appel a l&#39;objet sous-jacent Renvoie la frontiere discretisee associee a la condition aux limites...">frontiere_dis</a>());
<a name="l01345"></a>01345           <span class="keywordtype">int</span> num1b = le_bord.<a class="code" href="classFront__VF.html#a4986f0c65653fe9eb40bbbff5a97bf16" title="Numero de la premiere face du bord dans la liste des faces.">num_premiere_face</a>();
<a name="l01346"></a>01346           <span class="keywordtype">int</span> num2b = num1b + le_bord.<a class="code" href="classFront__VF.html#a341e2fcb5117b96e745fd7078ba86bab" title="Nombre de faces reelles du bord.">nb_faces</a>();
<a name="l01347"></a>01347           <span class="keywordflow">for</span> (num_face=num1b; num_face&lt;num2b; num_face++)
<a name="l01348"></a>01348             {
<a name="l01349"></a>01349               psc = 0;
<a name="l01350"></a>01350               <span class="keywordflow">for</span> (i=0; i&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; i++)
<a name="l01351"></a>01351                 psc += vitesse_face(num_face,i)*face_normales(num_face,i);
<a name="l01352"></a>01352               <span class="keywordflow">if</span> (psc&gt;0)
<a name="l01353"></a>01353                 ;
<a name="l01354"></a>01354               <span class="keywordflow">else</span>
<a name="l01355"></a>01355                 fluent_(num_face) -= psc;
<a name="l01356"></a>01356             }
<a name="l01357"></a>01357         }
<a name="l01358"></a>01358     }
<a name="l01359"></a>01359 }
<a name="l01360"></a>01360 
<a name="l01361"></a><a class="code" href="classOp__Conv__VEF__Face.html#a80256cc6352e925934a4d1233f7378ea">01361</a> <span class="keywordtype">void</span> <a class="code" href="classOp__Conv__VEF__Face.html#a80256cc6352e925934a4d1233f7378ea">Op_Conv_VEF_Face::get_ordre</a>(<span class="keywordtype">int</span>&amp; ord)<span class="keyword"> const</span>
<a name="l01362"></a>01362 <span class="keyword"></span>{
<a name="l01363"></a>01363   ord=<a class="code" href="classOp__Conv__VEF__Face.html#ad30e1a556295f226b7ef1215dc0030e5">ordre</a>;
<a name="l01364"></a>01364 }
<a name="l01365"></a><a class="code" href="classOp__Conv__VEF__Face.html#a2e291bb90398522c5bbd1a08fb03f693">01365</a> <span class="keywordtype">void</span> <a class="code" href="classOp__Conv__VEF__Face.html#a2e291bb90398522c5bbd1a08fb03f693">Op_Conv_VEF_Face::get_type_lim</a>(<a class="code" href="classMotcle.html" title="Une chaine de caractere (Nom) en majuscules.">Motcle</a>&amp; typelim)<span class="keyword"> const</span>
<a name="l01366"></a>01366 <span class="keyword"></span>{
<a name="l01367"></a>01367   typelim=<a class="code" href="classOp__Conv__VEF__Face.html#a070e3e30a22b79bd58ac3bd36f7802f6">type_lim</a>;
<a name="l01368"></a>01368 }
<a name="l01369"></a><a class="code" href="classOp__Conv__VEF__Face.html#ab2a0e04ea2fa8b2f9880d2e43ac49fc3">01369</a> <span class="keywordtype">void</span> <a class="code" href="classOp__Conv__VEF__Face.html#ab2a0e04ea2fa8b2f9880d2e43ac49fc3">Op_Conv_VEF_Face::get_alpha</a>(<span class="keywordtype">double</span>&amp; alp)<span class="keyword"> const</span>
<a name="l01370"></a>01370 <span class="keyword"></span>{
<a name="l01371"></a>01371   alp=<a class="code" href="classOp__Conv__VEF__Face.html#aebc1771cc4608fc51a8b6d15b93c8d3d">alpha_</a>;
<a name="l01372"></a>01372 }
<a name="l01373"></a>01373 
<a name="l01374"></a><a class="code" href="classOp__Conv__VEF__Face.html#a0c5603c7c6d4d7eba5897a472b607e32">01374</a> <span class="keywordtype">void</span> <a class="code" href="classOp__Conv__VEF__Face.html#a0c5603c7c6d4d7eba5897a472b607e32">Op_Conv_VEF_Face::get_type_op</a>(<span class="keywordtype">int</span>&amp; typeop)<span class="keyword"> const</span>
<a name="l01375"></a>01375 <span class="keyword"></span>{
<a name="l01376"></a>01376   typeop=<a class="code" href="classOp__Conv__VEF__Face.html#aac6bde5c9421ce149a3f28a11709b1f6">type_op</a>;
<a name="l01377"></a>01377 }
<a name="l01378"></a>01378 
</pre></div></div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Tue Dec 14 2021 19:35:43 for TRUST by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
