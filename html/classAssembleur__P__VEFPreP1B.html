<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>TRUST: Assembleur_P_VEFPreP1B Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">TRUST&#160;<span id="projectnumber">1.8.4</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a>  </div>
  <div class="headertitle">
<div class="title">Assembleur_P_VEFPreP1B Class Reference</div>  </div>
</div>
<div class="contents">
<!-- doxytag: class="Assembleur_P_VEFPreP1B" --><!-- doxytag: inherits="Assembleur_P_VEF" -->
<p><code>#include &lt;<a class="el" href="Assembleur__P__VEFPreP1B_8h_source.html">Assembleur_P_VEFPreP1B.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Assembleur_P_VEFPreP1B:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classAssembleur__P__VEFPreP1B.png" usemap="#Assembleur_P_VEFPreP1B_map" alt=""/>
  <map id="Assembleur_P_VEFPreP1B_map" name="Assembleur_P_VEFPreP1B_map">
<area href="classAssembleur__P__VEF.html" alt="Assembleur_P_VEF" shape="rect" coords="0,168,168,192"/>
<area href="classAssembleur__base.html" alt="Assembleur_base" shape="rect" coords="0,112,168,136"/>
<area href="classObjet__U.html" title="classe Objet_U Cette classe est la classe de base des Objets de TRUST Dans les classes derivees de Ob..." alt="Objet_U" shape="rect" coords="0,56,168,80"/>
<area href="classProcess.html" title="Classe de base de TRUST (notamment Objet_U). Elle fournit quelques services de base accessibles de pa..." alt="Process" shape="rect" coords="0,0,168,24"/>
</map>
 </div></div>

<p><a href="classAssembleur__P__VEFPreP1B-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAssembleur__P__VEFPreP1B.html#a25a8fd40ca183e27c263a603dd58fa10">Assembleur_P_VEFPreP1B</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAssembleur__P__VEFPreP1B.html#a3cacb0bc322712ad5d242f44cef95a1d">~Assembleur_P_VEFPreP1B</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAssembleur__P__VEFPreP1B.html#ab1128243c69096b51e7b16ff8a029fb3">taille_memoire</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAssembleur__P__VEFPreP1B.html#acde8b56bb8b7ff6b7e399e66b4376147">duplique</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classType__info.html">Type_info</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAssembleur__P__VEFPreP1B.html#a02a1a5944a64f58381a56137a7703893">get_info</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Donne des informations sur le type de l'Objet_U.  <a href="#a02a1a5944a64f58381a56137a7703893"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAssembleur__P__VEFPreP1B.html#a3b4a812a062b850be5966f8c6e201cee">zone_Vef</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAssembleur__P__VEFPreP1B.html#a67c7c35807840ac7243b7bf56666d46c">assembler</a> (<a class="el" href="classMatrice.html">Matrice</a> &amp;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAssembleur__P__VEFPreP1B.html#a051253f0b99e1c73b27eb007dcd1e117">assembler_rho_variable</a> (<a class="el" href="classMatrice.html">Matrice</a> &amp;, const <a class="el" href="classChamp__Don__base.html">Champ_Don_base</a> &amp;)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Assemblage de la matrice div( porosite/rho * grad P )<br/>
Le type du champ "rho" a fournir depend de la discretisation (vdf, vef, p1b, ...)<br/>
Pour le front-tracking par exemple.  <a href="#a051253f0b99e1c73b27eb007dcd1e117"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAssembleur__P__VEFPreP1B.html#a0cf6d0a6eeb99619a2c40e5a4a573c0d">assembler_mat</a> (<a class="el" href="classMatrice.html">Matrice</a> &amp;, const <a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;, int incr_pression, int resoudre_en_u)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAssembleur__P__VEFPreP1B.html#a492bdeef134441bb3358ea66c771c783">modifier_secmem</a> (<a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAssembleur__P__VEFPreP1B.html#aa5ae1ebda95ccd3d5fa2da3292d2a74c">preparer_solution</a> (<a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAssembleur__P__VEFPreP1B.html#a2925a6f043f3422988739a550efb9a4d">modifier_solution</a> (<a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAssembleur__P__VEFPreP1B.html#a4f5ed51e7785455c9ddeb94d1978799a">modifier_matrice</a> (<a class="el" href="classMatrice.html">Matrice</a> &amp;)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Modifier eventuellement la matrice pour la rendre definie si elle ne l'est pas<br/>
Valeurs par defaut:<br/>
Contraintes:<br/>
Acces: lecture.  <a href="#a4f5ed51e7785455c9ddeb94d1978799a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAssembleur__P__VEFPreP1B.html#acdeef94a4da9a426b6baf0042d9bf2b6">verifier_dirichlet</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAssembleur__P__VEFPreP1B.html#aeecf2e110cf38f394e6fb78fefb51f31">completer</a> (const <a class="el" href="classEquation__base.html">Equation_base</a> &amp;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEquation__base.html">Equation_base</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAssembleur__P__VEFPreP1B.html#a9a85837c29e80d1bcbc3a7f740f93807">equation</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAssembleur__P__VEFPreP1B.html#a68c56f1db1d79a34135f8f46c293dc83">modifier_secmem_elem</a> (const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;, <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAssembleur__P__VEFPreP1B.html#a6e9aef242858ae25dde40c58c30791b8">modifier_secmem_som</a> (const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;, <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAssembleur__P__VEFPreP1B.html#a671dcfc1aa964152dbc04bc5c31d196c">modifier_secmem_aretes</a> (const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;, <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAssembleur__P__VEFPreP1B.html#aa0ae226ce031b9410e951a4e95a393d8">changement_base</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAssembleur__P__VEFPreP1B.html#a1aebbbfd89e1ef2e187eca8c32a976f2">changer_base_matrice</a> (<a class="el" href="classMatrice.html">Matrice</a> &amp;)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A-&gt;A~ (P0+P1-&gt;P1Bulle)  <a href="#a1aebbbfd89e1ef2e187eca8c32a976f2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAssembleur__P__VEFPreP1B.html#a163d9e93dac32382f803926e4cde4660">changer_base_second_membre</a> (<a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">y-&gt;y~ (P0+P1-&gt;P1Bulle)  <a href="#a163d9e93dac32382f803926e4cde4660"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAssembleur__P__VEFPreP1B.html#a4e57094c4613e2cd895f9fb52d47a233">changer_base_pression_inverse</a> (<a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">x~-&gt;x (P1Bulle-&gt;P0+P1)  <a href="#a4e57094c4613e2cd895f9fb52d47a233"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAssembleur__P__VEFPreP1B.html#a3f12c572633ef578d9a0f9d2d0f3506e">changer_base_pression</a> (<a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">x-&gt;x~ (P0+P1-&gt;P1Bulle) Ne sert que pour les tests  <a href="#a3f12c572633ef578d9a0f9d2d0f3506e"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classObjet__U.html">Objet_U</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAssembleur__P__VEFPreP1B.html#a98bf7b93f310a3d9a8317937e8dfe198">cree_instance</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classType__info.html">Type_info</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAssembleur__P__VEFPreP1B.html#a6abcea83b31bc157fa6766b84e7f2133">info</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Donne des informations sur le type de l'Objet_U.  <a href="#a6abcea83b31bc157fa6766b84e7f2133"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classAssembleur__P__VEFPreP1B.html">Assembleur_P_VEFPreP1B</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAssembleur__P__VEFPreP1B.html#aed8cf8feed6a9b7e17142d967662fabe">self_cast</a> (<a class="el" href="classObjet__U.html">Objet_U</a> &amp;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const <br class="typebreak"/>
<a class="el" href="classAssembleur__P__VEFPreP1B.html">Assembleur_P_VEFPreP1B</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAssembleur__P__VEFPreP1B.html#ac30d27370b49bb28d3bf677ee2dafdf0">self_cast</a> (const <a class="el" href="classObjet__U.html">Objet_U</a> &amp;)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">methode ajoutee pour caster en python  <a href="#ac30d27370b49bb28d3bf677ee2dafdf0"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMatrice.html">Matrice</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAssembleur__P__VEFPreP1B.html#a5d22f81d5f579074de9324230e3ff45f">la_matrice_de_travail_</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classMatrice.html">Matrice</a> de travail.  <a href="#a5d22f81d5f579074de9324230e3ff45f"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classType__info.html">Type_info</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAssembleur__P__VEFPreP1B.html#aff05bc1b054979ca8b6c7a2ab8aa9d2c">info_obj</a></td></tr>
<tr><td colspan="2"><h2><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classSortie.html">Sortie</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAssembleur__P__VEFPreP1B.html#abc6e9cb293d2b22bf8cc58714062aac2">printOn</a> (<a class="el" href="classSortie.html">Sortie</a> &amp;x) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Ecriture de l'objet sur un flot de sortie<br/>
Methode a surcharger.  <a href="#abc6e9cb293d2b22bf8cc58714062aac2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classEntree.html">Entree</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAssembleur__P__VEFPreP1B.html#afbf05fd27ad04d93fc5396a8a9dd0bd7">readOn</a> (<a class="el" href="classEntree.html">Entree</a> &amp;)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Lecture d'un <a class="el" href="classObjet__U.html" title="classe Objet_U Cette classe est la classe de base des Objets de TRUST Dans les classes derivees de Ob...">Objet_U</a> sur un flot d'entree<br/>
Methode a surcharger.  <a href="#afbf05fd27ad04d93fc5396a8a9dd0bd7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAssembleur__P__VEFPreP1B.html#ad322061530a77e3541d562700b900641">projete_L2</a> (<a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;)</td></tr>
<tr><td colspan="2"><h2><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAssembleur__P__VEFPreP1B.html#a0b6f503b0a0af64037b281637f170661">init</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRef__Equation__base.html">Ref_Equation_base</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAssembleur__P__VEFPreP1B.html#a75f504c4171787bdeb487a8dd98e2a00">mon_equation</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAssembleur__P__VEFPreP1B.html#ae3dad2978525b28edcb08db30d0ce641">alpha</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAssembleur__P__VEFPreP1B.html#a411ad82b856d17a1c8d942728a48f9a0">beta</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Coefficients du changement de base P0+P1&lt;-&gt;P1Bulle.  <a href="#a411ad82b856d17a1c8d942728a48f9a0"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock">
<p>Definition at line <a class="el" href="Assembleur__P__VEFPreP1B_8h_source.html#l00031">31</a> of file <a class="el" href="Assembleur__P__VEFPreP1B_8h_source.html">Assembleur_P_VEFPreP1B.h</a>.</p>
</div><hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a25a8fd40ca183e27c263a603dd58fa10"></a><!-- doxytag: member="Assembleur_P_VEFPreP1B::Assembleur_P_VEFPreP1B" ref="a25a8fd40ca183e27c263a603dd58fa10" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Assembleur_P_VEFPreP1B::Assembleur_P_VEFPreP1B </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Assembleur__P__VEFPreP1B_8cpp_source.html#l00049">49</a> of file <a class="el" href="Assembleur__P__VEFPreP1B_8cpp_source.html">Assembleur_P_VEFPreP1B.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3cacb0bc322712ad5d242f44cef95a1d"></a><!-- doxytag: member="Assembleur_P_VEFPreP1B::~Assembleur_P_VEFPreP1B" ref="a3cacb0bc322712ad5d242f44cef95a1d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Assembleur_P_VEFPreP1B::~Assembleur_P_VEFPreP1B </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Assembleur__P__VEFPreP1B_8cpp_source.html#l00049">49</a> of file <a class="el" href="Assembleur__P__VEFPreP1B_8cpp_source.html">Assembleur_P_VEFPreP1B.cpp</a>.</p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a67c7c35807840ac7243b7bf56666d46c"></a><!-- doxytag: member="Assembleur_P_VEFPreP1B::assembler" ref="a67c7c35807840ac7243b7bf56666d46c" args="(Matrice &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Assembleur_P_VEFPreP1B::assembler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMatrice.html">Matrice</a> &amp;&#160;</td>
          <td class="paramname"><em>la_matrice</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="classAssembleur__P__VEF.html#ac43e09a90f13d319fba3f821b625029c">Assembleur_P_VEF</a>.</p>

<p>Definition at line <a class="el" href="Assembleur__P__VEFPreP1B_8cpp_source.html#l00187">187</a> of file <a class="el" href="Assembleur__P__VEFPreP1B_8cpp_source.html">Assembleur_P_VEFPreP1B.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">return</span> <a class="code" href="classAssembleur__P__VEFPreP1B.html#a67c7c35807840ac7243b7bf56666d46c">Assembleur_P_VEF::assembler</a>(la_matrice);
}
</pre></div>
</div>
</div>
<a class="anchor" id="a0cf6d0a6eeb99619a2c40e5a4a573c0d"></a><!-- doxytag: member="Assembleur_P_VEFPreP1B::assembler_mat" ref="a0cf6d0a6eeb99619a2c40e5a4a573c0d" args="(Matrice &amp;, const DoubleVect &amp;, int incr_pression, int resoudre_en_u)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Assembleur_P_VEFPreP1B::assembler_mat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMatrice.html">Matrice</a> &amp;&#160;</td>
          <td class="paramname"><em>la_matrice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;&#160;</td>
          <td class="paramname"><em>quantitee_entrelacee</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>incr_pression</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>resoudre_en_u</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>&lt; Lecture de la matrice dans un fichier</p>
<p>&lt; Assemblage de la matrice</p>
<p>&lt; A-&gt;A~</p>
<p>&lt; On n'est pas en P0</p>
<p>&lt; Suppression des coefficients nuls et quasi non nuls</p>
<p>&lt; Suppression des coefficients nuls et quasi non nuls </p>
</p>

<p>Reimplemented from <a class="el" href="classAssembleur__P__VEF.html#aa1846fa36106f467ddf527ad98748d65">Assembleur_P_VEF</a>.</p>

<p>Definition at line <a class="el" href="Assembleur__P__VEFPreP1B_8cpp_source.html#l00230">230</a> of file <a class="el" href="Assembleur__P__VEFPreP1B_8cpp_source.html">Assembleur_P_VEFPreP1B.cpp</a>.</p>

<p>References <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l02222">assemblerP0P0()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l02968">assemblerP0P1()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l02655">assemblerP0Pa()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l02247">assemblerP1P1()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l02803">assemblerP1Pa()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l02477">assemblerPaPa()</a>, <a class="el" href="SolveurPP1B_8cpp_source.html#l00070">SolveurPP1B::associer()</a>, <a class="el" href="Op__Grad__VEF__P1B__Face_8cpp_source.html#l00539">Op_Grad_VEF_P1B_Face::calculer_coef_som()</a>, <a class="el" href="Assembleur__P__VEF_8cpp_source.html#l00076">Assembleur_P_VEF::calculer_inv_volume()</a>, <a class="el" href="EntreeSortie_8h_source.html#l00032">Cerr</a>, <a class="el" href="Assembleur__P__VEFPreP1B_8h_source.html#l00062">changement_base()</a>, <a class="el" href="Assembleur__P__VEFPreP1B_8cpp_source.html#l01172">changer_base_matrice()</a>, <a class="el" href="EntreeSortie_8h_source.html#l00033">Cout</a>, <a class="el" href="Zone_8cpp_source.html#l01600">Zone::creer_tableau_elements()</a>, <a class="el" href="Matrice__Bloc__Sym_8cpp_source.html#l00267">Matrice_Bloc_Sym::dimensionner()</a>, <a class="el" href="DoubleVect_8cpp_source.html#l00277">DoubleVect::echange_espace_virtuel()</a>, <a class="el" href="Joint_8cpp_source.html#l00106">Joint::epaisseur()</a>, <a class="el" href="Assembleur__P__VEFPreP1B_8cpp_source.html#l00063">estim_cond()</a>, <a class="el" href="Process_8cpp_source.html#l00223">Process::exit()</a>, <a class="el" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>, <a class="el" href="Zone__VEF__PreP1b_8h_source.html#l00071">Zone_VEF_PreP1b::get_alphaA()</a>, <a class="el" href="Zone__VEF__PreP1b_8h_source.html#l00061">Zone_VEF_PreP1b::get_alphaE()</a>, <a class="el" href="Zone__VEF__PreP1b_8h_source.html#l00066">Zone_VEF_PreP1b::get_alphaS()</a>, <a class="el" href="Matrice__Bloc__Sym_8cpp_source.html#l00281">Matrice_Bloc_Sym::get_bloc()</a>, <a class="el" href="Zone__VEF__PreP1b_8h_source.html#l00081">Zone_VEF_PreP1b::get_cl_pression_sommet_faible()</a>, <a class="el" href="Zone_8h_source.html#l00909">Zone::joint()</a>, <a class="el" href="Assembleur__P__VEFPreP1B_8h_source.html#l00072">la_matrice_de_travail_</a>, <a class="el" href="Assembleur__P__VEF_8h_source.html#l00066">Assembleur_P_VEF::la_zone_Cl_VEF</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l02429">modifieP1P1neumann()</a>, <a class="el" href="Assembleur__P__VEFPreP1B_8cpp_source.html#l00880">modifier_matrice()</a>, <a class="el" href="Assembleur__P__VEFPreP1B_8h_source.html#l00077">mon_equation</a>, <a class="el" href="Process_8cpp_source.html#l00178">Process::mp_sum()</a>, <a class="el" href="Matrice__Bloc_8cpp_source.html#l00624">Matrice_Bloc::nb_bloc_lignes()</a>, <a class="el" href="Zone_8h_source.html#l00550">Zone::nb_joints()</a>, <a class="el" href="Matrice__Bloc_8cpp_source.html#l00094">Matrice_Bloc::nb_lignes()</a>, <a class="el" href="Process_8cpp_source.html#l00109">Process::nproc()</a>, <a class="el" href="Objet__U_8cpp_source.html#l00132">Objet_U::que_suis_je()</a>, <a class="el" href="Cast_8h_source.html#l00059">ref_cast</a>, <a class="el" href="Assembleur__base_8cpp_source.html#l00077">Assembleur_base::set_resoudre_en_u()</a>, <a class="el" href="Assembleur__base_8cpp_source.html#l00055">Assembleur_base::set_resoudre_increment_pression()</a>, <a class="el" href="DoubleVect_8h_source.html#l00159">DoubleVect::size_totale()</a>, <a class="el" href="Cast_8h_source.html#l00054">sub_type</a>, <a class="el" href="SolveurSys_8h_source.html#l00056">SolveurSys::supporte_matrice_morse_sym()</a>, <a class="el" href="Deriv___8cpp_source.html#l00091">Deriv_::typer()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l02235">updateP0P0()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l03048">updateP0P1()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l02730">updateP0Pa()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l02339">updateP1P1()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l02885">updateP1Pa()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l02567">updatePaPa()</a>, <a class="el" href="Deriv__Matrice__Base_8h_source.html#l00028">Deriv_Matrice_Base::valeur()</a>, <a class="el" href="Ref__Zone__Cl__VEF_8h_source.html#l00028">Ref_Zone_Cl_VEF::valeur()</a>, <a class="el" href="SolveurSys_8h_source.html#l00038">Deriv_SolveurSys_base::valeur()</a>, <a class="el" href="Ref__Equation__base_8h_source.html#l00028">Ref_Equation_base::valeur()</a>, <a class="el" href="Op__Div__VEFP1B__Elem_8cpp_source.html#l00081">verifier()</a>, <a class="el" href="Assembleur__P__VEFPreP1B_8cpp_source.html#l00211">zero()</a>, <a class="el" href="Zone__dis__base_8h_source.html#l00106">Zone_dis_base::zone()</a>, and <a class="el" href="Assembleur__P__VEFPreP1B_8cpp_source.html#l00116">zone_Vef()</a>.</p>

<p>Referenced by <a class="el" href="Assembleur__P__VEFPreP1B_8cpp_source.html#l00192">assembler_rho_variable()</a>.</p>
<div class="fragment"><pre class="fragment">{
<span class="comment">// On fixe les drapeaux de Assembleur_base</span>
  <a class="code" href="classAssembleur__base.html#ad134c3371f3ced3768a1704be52e0fe8" title="Definit la valeur du drapeau resoudre_increment_pression_. Ce drapeau determine si le solveur en pres...">set_resoudre_increment_pression</a>(incr_pression);
  <a class="code" href="classAssembleur__base.html#a9cdaa49e5340da74de179c2f22f08605" title="Definit la valeur du drapeau resoudre_en_u__. Ce drapeau determine si le solveur en pression resou en...">set_resoudre_en_u</a>(resoudre_en_u);

  <a class="code" href="classSolveurSys.html">SolveurSys</a>&amp; solveur_pression = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classNavier__Stokes__std.html" title="classe Navier_Stokes_std Cette classe porte les termes de l&#39;equation de la dynamique pour un fluide s...">Navier_Stokes_std</a>, <a class="code" href="classAssembleur__P__VEFPreP1B.html#a75f504c4171787bdeb487a8dd98e2a00">mon_equation</a>.<a class="code" href="classRef__Equation__base.html#a7bb6fb60cb55bef0eef1b0e8718300a4">valeur</a>()).solveur_pression();
  <span class="keywordtype">bool</span> read_matrix = <span class="keyword">false</span>;
  <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classSolv__Petsc.html">Solv_Petsc</a>, solveur_pression.<a class="code" href="classDeriv__SolveurSys__base.html#aa1f67fc10fc25960d05d484a67d1bb54">valeur</a>()))
    read_matrix = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classSolv__Petsc.html">Solv_Petsc</a>, solveur_pression.<a class="code" href="classDeriv__SolveurSys__base.html#aa1f67fc10fc25960d05d484a67d1bb54">valeur</a>()).read_matrix();
  <span class="keywordflow">if</span> (read_matrix) <span class="comment">//!&lt; Lecture de la matrice dans un fichier</span>
<span class="comment"></span>    {
      la_matrice.<a class="code" href="classDeriv__.html#ad1d33400ed15b6ff96579ed82d9e2719" title="Essaie de creer une instance du type &quot;type&quot;. si type n&#39;est pas un type ou type n&#39;est pas instanciab...">typer</a>(<span class="stringliteral">&quot;Matrice_Petsc&quot;</span>);
<span class="comment">// ref_cast(Matrice_Petsc, la_matrice.valeur()).RestoreMatrixFromFile();</span>
    }
  <span class="keywordflow">else</span> <span class="comment">//!&lt; Assemblage de la matrice</span>
<span class="comment"></span>    {
      <span class="keyword">const</span> <a class="code" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a>&amp; zone_vef = <a class="code" href="classAssembleur__P__VEFPreP1B.html#a3b4a812a062b850be5966f8c6e201cee">zone_Vef</a>();
      <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Assemblage de la matrice de pression&quot;</span> &lt;&lt; (zone_vef.<a class="code" href="classZone__VEF__PreP1b.html#aee2def53aa92584d7945e7c3d0d98963">get_alphaE</a>() ? <span class="stringliteral">&quot; P0&quot;</span> : <span class="stringliteral">&quot;&quot;</span>)
           &lt;&lt; (zone_vef.<a class="code" href="classZone__VEF__PreP1b.html#ad7fbcb5567dcc2e6f0a0ed85ce90a4fa">get_alphaS</a>() ? <span class="stringliteral">&quot; P1&quot;</span> : <span class="stringliteral">&quot;&quot;</span>) &lt;&lt; (zone_vef.<a class="code" href="classZone__VEF__PreP1b.html#a9d02e2431efb6e75c3d733ff06f89549">get_alphaA</a>() ? <span class="stringliteral">&quot; Pa&quot;</span> : <span class="stringliteral">&quot;&quot;</span>) &lt;&lt; <span class="stringliteral">&quot; en cours...&quot;</span> &lt;&lt; finl;

<span class="comment">// Les decoupages doivent etre de largeur de joint de 2</span>
<span class="comment">// si le support P1 ou Pa est utilise...</span>
      <span class="keywordflow">if</span> (<a class="code" href="classProcess.html#a6bf692ce58d9578aa62ac3c07b8caaa1" title="renvoie le nombre de processeurs dans le groupe courant Voir Comm_Group::nproc() et PE_Groups::curren...">Process::nproc</a>() &gt; 1 &amp;&amp;
          zone_vef.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#ab096afb61e89705709a4ae6d3576a644" title="Renvoie le nombre de joints de la zone.">nb_joints</a>() &amp;&amp;
          zone_vef.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#acec4c61032df8b55a95f9e7197ef6e3c" title="Renvoie le i-ieme joint de la zone&lt;br&gt;(version const)">joint</a>(0).<a class="code" href="classJoint.html#a67445a0294ff0e77d2d990ba0f493a17" title="Renvoie l&#39;epaisseur du joint.">epaisseur</a>() &lt; 2 &amp;&amp;
          (zone_vef.<a class="code" href="classZone__VEF__PreP1b.html#ad7fbcb5567dcc2e6f0a0ed85ce90a4fa">get_alphaS</a>() || zone_vef.<a class="code" href="classZone__VEF__PreP1b.html#a9d02e2431efb6e75c3d733ff06f89549">get_alphaA</a>()))
        {
          <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Ghost cells width of &quot;</span> &lt;&lt; zone_vef.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#acec4c61032df8b55a95f9e7197ef6e3c" title="Renvoie le i-ieme joint de la zone&lt;br&gt;(version const)">joint</a>(0).<a class="code" href="classJoint.html#a67445a0294ff0e77d2d990ba0f493a17" title="Renvoie l&#39;epaisseur du joint.">epaisseur</a>()
               &lt;&lt; <span class="stringliteral">&quot; is not enough for assembling VEFPreP1B pressure matrix&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
          <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;for parallel calculation. Partition your mesh with larg_joint option set to 2.&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
          <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">Process::exit</a>();
        }

      <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a> inverse_quantitee_entrelacee;
      <span class="keyword">const</span> <a class="code" href="classZone__Cl__VEF.html">Zone_Cl_VEF</a>&amp; zone_Cl_VEF = <a class="code" href="classAssembleur__P__VEF.html#af06d2fedcae0282000a96ddd444ec7a2">la_zone_Cl_VEF</a>.<a class="code" href="classRef__Zone__Cl__VEF.html#a0970d7253def65ad4f0c5ce1830fd243">valeur</a>();
      <a class="code" href="classAssembleur__P__VEF.html#a7260acd8453511a0aaffe9c685df5bb7">calculer_inv_volume</a>(inverse_quantitee_entrelacee, zone_Cl_VEF, quantitee_entrelacee);
      <span class="keywordtype">int</span> P0 = 0;
      <span class="keywordtype">int</span> P1 = P0 + zone_vef.<a class="code" href="classZone__VEF__PreP1b.html#aee2def53aa92584d7945e7c3d0d98963">get_alphaE</a>();
      <span class="keywordtype">int</span> Pa = P1 + zone_vef.<a class="code" href="classZone__VEF__PreP1b.html#ad7fbcb5567dcc2e6f0a0ed85ce90a4fa">get_alphaS</a>();
      <span class="keywordtype">int</span> nombre_supports = Pa + zone_vef.<a class="code" href="classZone__VEF__PreP1b.html#a9d02e2431efb6e75c3d733ff06f89549">get_alphaA</a>();
      <a class="code" href="classDoubleVect.html">DoubleVect</a> coef_som;
      <span class="keywordflow">if</span> (zone_vef.<a class="code" href="classZone__VEF__PreP1b.html#ad7fbcb5567dcc2e6f0a0ed85ce90a4fa">get_alphaS</a>())
        {
          zone_vef.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#a600fa15a19c7e1384564dffd83ecab4d" title="creation d&#39;un tableau parallele de valeurs aux elements. Voir MD_Vector_tools::creer_tableau_distribu...">creer_tableau_elements</a>(coef_som);
          <span class="keywordflow">for</span> (<span class="keywordtype">int</span> elem = 0; elem &lt; coef_som.<a class="code" href="classDoubleVect.html#ad2d21b364e1c6559771970596a25c006" title="Identique a size_array()">size_totale</a>(); elem++)
            coef_som[elem] = <a class="code" href="classOp__Grad__VEF__P1B__Face.html#aa1b669139e643d29cff74806e14d3e3e">Op_Grad_VEF_P1B_Face::calculer_coef_som</a>(elem, zone_Cl_VEF, zone_vef);
          coef_som.<a class="code" href="classDoubleVect.html#abfebbc2f685ce7bc4b80c720d7da9bf3">echange_espace_virtuel</a>();
        }

<span class="comment">// Assemblage de la matrice complete selon les supports choisis</span>
      <a class="code" href="classMatrice__Bloc__Sym.html">Matrice_Bloc_Sym</a>&amp; la_matrice_bloc_sym_de_travail = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Bloc__Sym.html">Matrice_Bloc_Sym</a>, <a class="code" href="classAssembleur__P__VEFPreP1B.html#a5d22f81d5f579074de9324230e3ff45f" title="Matrice de travail.">la_matrice_de_travail_</a>.<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>());
      <span class="keywordflow">if</span> (la_matrice_bloc_sym_de_travail.<a class="code" href="classMatrice__Bloc.html#a02193255787b0ecae7988ca4eada3b4b" title="retourne N_">nb_bloc_lignes</a>()==0)
        {
          la_matrice_bloc_sym_de_travail.<a class="code" href="classMatrice__Bloc__Sym.html#a1afda96c64b026b5e26ff31572c0234a" title="dimensionnement de blocs_">dimensionner</a>(nombre_supports, nombre_supports);
          <span class="keywordflow">if</span> (zone_vef.<a class="code" href="classZone__VEF__PreP1b.html#aee2def53aa92584d7945e7c3d0d98963">get_alphaE</a>())
            <a class="code" href="Assembleur__P__VEFPreP1B_8cpp.html#a31e2d4bc38d5bc0bbf9e2c36d15b589b">assemblerP0P0</a>(zone_vef, zone_Cl_VEF, la_matrice_bloc_sym_de_travail.<a class="code" href="classMatrice__Bloc__Sym.html#a1002ce880ea2b2fb48dae444097c9f7a" title="(0&lt;=i&lt;N , i&lt;=j&lt;M)">get_bloc</a>(P0, P0),
                          inverse_quantitee_entrelacee);

          <span class="keywordflow">if</span> (zone_vef.<a class="code" href="classZone__VEF__PreP1b.html#ad7fbcb5567dcc2e6f0a0ed85ce90a4fa">get_alphaS</a>())
            <a class="code" href="Assembleur__P__VEFPreP1B_8cpp.html#a31f132f3fda04d8428de212c63fd902f">assemblerP1P1</a>(zone_vef, zone_Cl_VEF, la_matrice_bloc_sym_de_travail.<a class="code" href="classMatrice__Bloc__Sym.html#a1002ce880ea2b2fb48dae444097c9f7a" title="(0&lt;=i&lt;N , i&lt;=j&lt;M)">get_bloc</a>(P1, P1),
                          inverse_quantitee_entrelacee, coef_som);

          <span class="keywordflow">if</span> (zone_vef.<a class="code" href="classZone__VEF__PreP1b.html#aee2def53aa92584d7945e7c3d0d98963">get_alphaE</a>() &amp;&amp; zone_vef.<a class="code" href="classZone__VEF__PreP1b.html#ad7fbcb5567dcc2e6f0a0ed85ce90a4fa">get_alphaS</a>())
            <a class="code" href="Assembleur__P__VEFPreP1B_8cpp.html#a3774b1608aeee56152e7e1e5f385bfe1">assemblerP0P1</a>(zone_vef, zone_Cl_VEF, la_matrice_bloc_sym_de_travail.<a class="code" href="classMatrice__Bloc__Sym.html#a1002ce880ea2b2fb48dae444097c9f7a" title="(0&lt;=i&lt;N , i&lt;=j&lt;M)">get_bloc</a>(P0, P1),
                          inverse_quantitee_entrelacee, coef_som);

          <span class="keywordflow">if</span> (zone_vef.<a class="code" href="classZone__VEF__PreP1b.html#a9d02e2431efb6e75c3d733ff06f89549">get_alphaA</a>())
            <a class="code" href="Assembleur__P__VEFPreP1B_8cpp.html#a7840f924363ed7d3fbd50a59d9d990c0">assemblerPaPa</a>(zone_vef, zone_Cl_VEF, la_matrice_bloc_sym_de_travail.<a class="code" href="classMatrice__Bloc__Sym.html#a1002ce880ea2b2fb48dae444097c9f7a" title="(0&lt;=i&lt;N , i&lt;=j&lt;M)">get_bloc</a>(Pa, Pa),
                          inverse_quantitee_entrelacee);

          <span class="keywordflow">if</span> (zone_vef.<a class="code" href="classZone__VEF__PreP1b.html#ad7fbcb5567dcc2e6f0a0ed85ce90a4fa">get_alphaS</a>() &amp;&amp; zone_vef.<a class="code" href="classZone__VEF__PreP1b.html#a9d02e2431efb6e75c3d733ff06f89549">get_alphaA</a>())
            <a class="code" href="Assembleur__P__VEFPreP1B_8cpp.html#a5dcfee4400f896bcbb100259f53a5de1">assemblerP1Pa</a>(zone_vef, zone_Cl_VEF, la_matrice_bloc_sym_de_travail.<a class="code" href="classMatrice__Bloc__Sym.html#a1002ce880ea2b2fb48dae444097c9f7a" title="(0&lt;=i&lt;N , i&lt;=j&lt;M)">get_bloc</a>(P1, Pa),
                          inverse_quantitee_entrelacee, coef_som);

          <span class="keywordflow">if</span> (zone_vef.<a class="code" href="classZone__VEF__PreP1b.html#aee2def53aa92584d7945e7c3d0d98963">get_alphaE</a>() &amp;&amp; zone_vef.<a class="code" href="classZone__VEF__PreP1b.html#a9d02e2431efb6e75c3d733ff06f89549">get_alphaA</a>())
            <a class="code" href="Assembleur__P__VEFPreP1B_8cpp.html#a30b5e404b46e2a239584ee19835c88bf">assemblerP0Pa</a>(zone_vef, zone_Cl_VEF, la_matrice_bloc_sym_de_travail.<a class="code" href="classMatrice__Bloc__Sym.html#a1002ce880ea2b2fb48dae444097c9f7a" title="(0&lt;=i&lt;N , i&lt;=j&lt;M)">get_bloc</a>(P0, Pa),
                          inverse_quantitee_entrelacee);
        }
<span class="comment">// On met a zero la matrice meme si elle a ete correctement construite et remplie dans les methodes</span>
<span class="comment">// assemblerPiPi et on la remplit a nouveau. Pourquoi? Pour avoir une couverture de tests</span>
<span class="comment">// suffisante des methodes updatePiPi en attendant de factoriser correctement les</span>
<span class="comment">// methodes assemblerPiPi et updatePiPi</span>
      <a class="code" href="Assembleur__P__VEFPreP1B_8cpp.html#a6e2318de58fc55873393f2dccdbd9d6c">zero</a>(la_matrice_bloc_sym_de_travail);
      {
        <span class="keywordflow">if</span> (zone_vef.<a class="code" href="classZone__VEF__PreP1b.html#aee2def53aa92584d7945e7c3d0d98963">get_alphaE</a>())
          <a class="code" href="Assembleur__P__VEFPreP1B_8cpp.html#a48eaaecaa31bdde228ea5e3995db4771">updateP0P0</a>(zone_vef, zone_Cl_VEF, la_matrice_bloc_sym_de_travail.<a class="code" href="classMatrice__Bloc__Sym.html#a1002ce880ea2b2fb48dae444097c9f7a" title="(0&lt;=i&lt;N , i&lt;=j&lt;M)">get_bloc</a>(P0, P0),
                     inverse_quantitee_entrelacee);

        <span class="keywordflow">if</span> (zone_vef.<a class="code" href="classZone__VEF__PreP1b.html#ad7fbcb5567dcc2e6f0a0ed85ce90a4fa">get_alphaS</a>())
          {
            <a class="code" href="Assembleur__P__VEFPreP1B_8cpp.html#ab3c25c4172223f48fd2f9d433b005e0c">updateP1P1</a>(zone_vef, zone_Cl_VEF, la_matrice_bloc_sym_de_travail.<a class="code" href="classMatrice__Bloc__Sym.html#a1002ce880ea2b2fb48dae444097c9f7a" title="(0&lt;=i&lt;N , i&lt;=j&lt;M)">get_bloc</a>(P1, P1),
                       inverse_quantitee_entrelacee, coef_som);
            <span class="keywordflow">if</span> (zone_vef.<a class="code" href="classZone__VEF__PreP1b.html#aed6f98596f13c0c4df7a7d9f57235b56">get_cl_pression_sommet_faible</a>() == 0)
              <a class="code" href="Assembleur__P__VEFPreP1B_8cpp.html#a1ce15acad922bef2d305d970c13c68c8">modifieP1P1neumann</a>(zone_vef, zone_Cl_VEF, la_matrice_bloc_sym_de_travail.<a class="code" href="classMatrice__Bloc__Sym.html#a1002ce880ea2b2fb48dae444097c9f7a" title="(0&lt;=i&lt;N , i&lt;=j&lt;M)">get_bloc</a>(P1, P1),
                                 inverse_quantitee_entrelacee, coef_som);
          }
        <span class="keywordflow">if</span> (zone_vef.<a class="code" href="classZone__VEF__PreP1b.html#aee2def53aa92584d7945e7c3d0d98963">get_alphaE</a>() &amp;&amp; zone_vef.<a class="code" href="classZone__VEF__PreP1b.html#ad7fbcb5567dcc2e6f0a0ed85ce90a4fa">get_alphaS</a>())
          <a class="code" href="Assembleur__P__VEFPreP1B_8cpp.html#af30661e8e1b45bf522a5595f65ecc741">updateP0P1</a>(zone_vef, zone_Cl_VEF, la_matrice_bloc_sym_de_travail.<a class="code" href="classMatrice__Bloc__Sym.html#a1002ce880ea2b2fb48dae444097c9f7a" title="(0&lt;=i&lt;N , i&lt;=j&lt;M)">get_bloc</a>(P0, P1),
                     inverse_quantitee_entrelacee, coef_som);

        <span class="keywordflow">if</span> (zone_vef.<a class="code" href="classZone__VEF__PreP1b.html#a9d02e2431efb6e75c3d733ff06f89549">get_alphaA</a>())
          <a class="code" href="Assembleur__P__VEFPreP1B_8cpp.html#a4e0c0752e80915fd8b0143b70f08e718">updatePaPa</a>(zone_vef, zone_Cl_VEF, la_matrice_bloc_sym_de_travail.<a class="code" href="classMatrice__Bloc__Sym.html#a1002ce880ea2b2fb48dae444097c9f7a" title="(0&lt;=i&lt;N , i&lt;=j&lt;M)">get_bloc</a>(Pa, Pa),
                     inverse_quantitee_entrelacee);

        <span class="keywordflow">if</span> (zone_vef.<a class="code" href="classZone__VEF__PreP1b.html#ad7fbcb5567dcc2e6f0a0ed85ce90a4fa">get_alphaS</a>() &amp;&amp; zone_vef.<a class="code" href="classZone__VEF__PreP1b.html#a9d02e2431efb6e75c3d733ff06f89549">get_alphaA</a>())
          <a class="code" href="Assembleur__P__VEFPreP1B_8cpp.html#a8d9349eb29399f4ac72dc10543a4005a">updateP1Pa</a>(zone_vef, zone_Cl_VEF, la_matrice_bloc_sym_de_travail.<a class="code" href="classMatrice__Bloc__Sym.html#a1002ce880ea2b2fb48dae444097c9f7a" title="(0&lt;=i&lt;N , i&lt;=j&lt;M)">get_bloc</a>(P1, Pa),
                     inverse_quantitee_entrelacee, coef_som);

        <span class="keywordflow">if</span> (zone_vef.<a class="code" href="classZone__VEF__PreP1b.html#aee2def53aa92584d7945e7c3d0d98963">get_alphaE</a>() &amp;&amp; zone_vef.<a class="code" href="classZone__VEF__PreP1b.html#a9d02e2431efb6e75c3d733ff06f89549">get_alphaA</a>())
          <a class="code" href="Assembleur__P__VEFPreP1B_8cpp.html#aacede92ea2595a5546e6357fbd1e1498">updateP0Pa</a>(zone_vef, zone_Cl_VEF, la_matrice_bloc_sym_de_travail.<a class="code" href="classMatrice__Bloc__Sym.html#a1002ce880ea2b2fb48dae444097c9f7a" title="(0&lt;=i&lt;N , i&lt;=j&lt;M)">get_bloc</a>(P0, Pa),
                     inverse_quantitee_entrelacee);
      }
      <span class="keywordtype">int</span> ordre_matrice = <a class="code" href="classProcess.html#a7d23bc1ef94b3f0623fbc79d034c27fd" title="Calcule la somme de x sur tous les processeurs du groupe courant. Voir aussi mp_max()">mp_sum</a>(la_matrice_bloc_sym_de_travail.<a class="code" href="classMatrice__Bloc.html#aa282a8298b08603722d97704cf98c8cc">nb_lignes</a>());
      <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Order of the matrix = &quot;</span> &lt;&lt; ordre_matrice &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;

<span class="comment">// Methode verifier</span>
      <span class="keywordtype">char</span> *theValue = getenv(<span class="stringliteral">&quot;TRUST_VERIFIE_MATRICE_VEF&quot;</span>);
      <span class="keywordflow">if</span> (theValue != NULL) <a class="code" href="Op__Div__VEFP1B__Elem_8cpp.html#a45261662b3b88d5db461b3fc99246e5a">verifier</a>(*<span class="keyword">this</span>, la_matrice_bloc_sym_de_travail, zone_vef, inverse_quantitee_entrelacee);

<span class="comment">//</span>
<span class="comment">// Changement de base eventuel P0P1-&gt;P1Bulle</span>
<span class="comment">//</span>
      <span class="keywordflow">if</span> (<a class="code" href="classAssembleur__P__VEFPreP1B.html#aa0ae226ce031b9410e951a4e95a393d8">changement_base</a>())
        <a class="code" href="classAssembleur__P__VEFPreP1B.html#a1aebbbfd89e1ef2e187eca8c32a976f2" title="A-&gt;A~ (P0+P1-&gt;P1Bulle)">changer_base_matrice</a>(<a class="code" href="classAssembleur__P__VEFPreP1B.html#a5d22f81d5f579074de9324230e3ff45f" title="Matrice de travail.">la_matrice_de_travail_</a>); <span class="comment">//!&lt; A-&gt;A~</span>
<span class="comment"></span>
<span class="comment">//</span>
<span class="comment">// Modification de la matrice si pas de pression de reference</span>
<span class="comment">//</span>
      <a class="code" href="classAssembleur__P__VEFPreP1B.html#a4f5ed51e7785455c9ddeb94d1978799a" title="Modifier eventuellement la matrice pour la rendre definie si elle ne l&#39;est pas Valeurs par defaut: Co...">modifier_matrice</a>(<a class="code" href="classAssembleur__P__VEFPreP1B.html#a5d22f81d5f579074de9324230e3ff45f" title="Matrice de travail.">la_matrice_de_travail_</a>);

<span class="comment">// Conversion eventuelle en Matrice_Morse_Sym</span>
      <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classNavier__Stokes__std.html" title="classe Navier_Stokes_std Cette classe porte les termes de l&#39;equation de la dynamique pour un fluide s...">Navier_Stokes_std</a>, <a class="code" href="classAssembleur__P__VEFPreP1B.html#a75f504c4171787bdeb487a8dd98e2a00">mon_equation</a>.<a class="code" href="classRef__Equation__base.html#a7bb6fb60cb55bef0eef1b0e8718300a4">valeur</a>()).solveur_pression().<a class="code" href="classSolveurSys.html#a90e3df61815652dccd9c8bf240d46ddc">supporte_matrice_morse_sym</a>() &amp;&amp;
          zone_vef.<a class="code" href="classZone__VEF__PreP1b.html#aee2def53aa92584d7945e7c3d0d98963">get_alphaE</a>() != nombre_supports) <span class="comment">//!&lt; On n&#39;est pas en P0</span>
<span class="comment"></span>        {
<span class="comment">//</span>
<span class="comment">// La matrice retournee est une Matrice_Morse_Sym nettoyee</span>
<span class="comment">// si le solveur utilisee supporte ce type de matrice</span>
<span class="comment">// et si on n&#39;est pas en P0 seulement (dans ce cas la, la</span>
<span class="comment">// conversion en Mat_Morse_Sym n&#39;apporte rien, et plante le SSOR</span>
<span class="comment">// car la matrice morse contient alors des parties virtuelles</span>
<span class="comment">// alors qu&#39;il n&#39;y a pas d&#39;items communs et on tombe sur</span>
<span class="comment">// l&#39;assert assert(*tab2_ptr&lt;=n); Deux autres solutions:</span>
<span class="comment">// -Modifier le SSOR pour ne resoudre que la partie reelle</span>
<span class="comment">// -Dans le cas de P0 seul, il faudrait vider VV et RV dans la Mat_Bloc_Sym</span>
<span class="comment">//</span>
          la_matrice.<a class="code" href="classDeriv__.html#ad1d33400ed15b6ff96579ed82d9e2719" title="Essaie de creer une instance du type &quot;type&quot;. si type n&#39;est pas un type ou type n&#39;est pas instanciab...">typer</a>(<span class="stringliteral">&quot;Matrice_Morse_Sym&quot;</span>);
          <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Bloc__Sym.html">Matrice_Bloc_Sym</a>, <a class="code" href="classAssembleur__P__VEFPreP1B.html#a5d22f81d5f579074de9324230e3ff45f" title="Matrice de travail.">la_matrice_de_travail_</a>.<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>()).BlocSymToMatMorseSym(
            <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Morse__Sym.html" title="Classe Matrice_Morse_Sym Represente une matrice M (creuse) symetrique stockee au format Morse Symetri...">Matrice_Morse_Sym</a>, la_matrice.<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>()));
          <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Morse__Sym.html" title="Classe Matrice_Morse_Sym Represente une matrice M (creuse) symetrique stockee au format Morse Symetri...">Matrice_Morse_Sym</a>, la_matrice.<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>()).compacte(
            2);<span class="comment">//!&lt; Suppression des coefficients nuls et quasi non nuls</span>
<span class="comment"></span>        }
      <span class="keywordflow">else</span>
        {
<span class="comment">//</span>
<span class="comment">// La matrice retournee est une Matrice_Bloc_Sym nettoyee</span>
<span class="comment">//</span>
          la_matrice = <a class="code" href="classAssembleur__P__VEFPreP1B.html#a5d22f81d5f579074de9324230e3ff45f" title="Matrice de travail.">la_matrice_de_travail_</a>;
          <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; nombre_supports; i++)
            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = i; j &lt; nombre_supports; j++)
              {
                <a class="code" href="classMatrice__Bloc__Sym.html">Matrice_Bloc_Sym</a>&amp; mat_bloc_sym = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Bloc__Sym.html">Matrice_Bloc_Sym</a>, la_matrice.<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>());
                <a class="code" href="classMatrice__Bloc.html">Matrice_Bloc</a>&amp; bloc_ij = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Bloc.html">Matrice_Bloc</a>, mat_bloc_sym.<a class="code" href="classMatrice__Bloc__Sym.html#a1002ce880ea2b2fb48dae444097c9f7a" title="(0&lt;=i&lt;N , i&lt;=j&lt;M)">get_bloc</a>(i, j).<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>());
                <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>, bloc_ij.get_bloc(0, 0).valeur()).compacte(
                  2); <span class="comment">//!&lt; Suppression des coefficients nuls et quasi non nuls</span>
<span class="comment"></span>              }
        }
    }

<span class="comment">// Si pas deja fait, on prends un solveur (SolveurPP1B) qui fera les changements de base pour la solution et le second membre</span>
  <span class="keywordflow">if</span> (<a class="code" href="classAssembleur__P__VEFPreP1B.html#aa0ae226ce031b9410e951a4e95a393d8">changement_base</a>() &amp;&amp; solveur_pression.<a class="code" href="classDeriv__SolveurSys__base.html#aa1f67fc10fc25960d05d484a67d1bb54">valeur</a>().<a class="code" href="classObjet__U.html#aa58e9a81c0ddc2c1149053b8f96698ac" title="renvoie la chaine identifiant la classe.">que_suis_je</a>() != <span class="stringliteral">&quot;SolveurPP1B&quot;</span>)
    {
      <a class="code" href="classSolveurSys.html">SolveurSys</a> solveur_pression_lu = solveur_pression;
      solveur_pression.<a class="code" href="classDeriv__.html#ad1d33400ed15b6ff96579ed82d9e2719" title="Essaie de creer une instance du type &quot;type&quot;. si type n&#39;est pas un type ou type n&#39;est pas instanciab...">typer</a>(<span class="stringliteral">&quot;SolveurPP1B&quot;</span>);
      <a class="code" href="classSolveurPP1B.html">SolveurPP1B</a>&amp; solveur_pression_PP1B = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classSolveurPP1B.html">SolveurPP1B</a>, solveur_pression.<a class="code" href="classDeriv__SolveurSys__base.html#aa1f67fc10fc25960d05d484a67d1bb54">valeur</a>());
      solveur_pression_PP1B.<a class="code" href="classSolveurPP1B.html#a33ff8b6f192454d73472aebadb506a98">associer</a>(*<span class="keyword">this</span>, solveur_pression_lu);
    }

<span class="comment">//</span>
<span class="comment">// Affichage eventuel du conditionnement de la matrice</span>
<span class="comment">//</span>
  <span class="keywordtype">char</span>* theValue2 = getenv(<span class="stringliteral">&quot;TRUST_CONDITIONNEMENT_MATRICE&quot;</span>);
  <span class="keywordflow">if</span>(theValue2 != NULL)
    <a class="code" href="EntreeSortie_8h.html#a1007c2f57f1c8fc7334a3f62aab08414">Cout</a> &lt;&lt; <span class="stringliteral">&quot;Estimation du conditionnement de la matrice: &quot;</span> &lt;&lt; <a class="code" href="Assembleur__P__VEFPreP1B_8cpp.html#ad6ea924b20e311b70fc786906b53805b">estim_cond</a>(la_matrice)&lt;&lt;finl;

  <span class="keywordflow">return</span> 1;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a051253f0b99e1c73b27eb007dcd1e117"></a><!-- doxytag: member="Assembleur_P_VEFPreP1B::assembler_rho_variable" ref="a051253f0b99e1c73b27eb007dcd1e117" args="(Matrice &amp;, const Champ_Don_base &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Assembleur_P_VEFPreP1B::assembler_rho_variable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMatrice.html">Matrice</a> &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classChamp__Don__base.html">Champ_Don_base</a> &amp;&#160;</td>
          <td class="paramname"><em>rho</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assemblage de la matrice div( porosite/rho * grad P )<br/>
Le type du champ "rho" a fournir depend de la discretisation (vdf, vef, p1b, ...)<br/>
Pour le front-tracking par exemple. </p>

<p>Reimplemented from <a class="el" href="classAssembleur__base.html#a22607eed0ff59b926b346c632cd629f5">Assembleur_base</a>.</p>

<p>Definition at line <a class="el" href="Assembleur__P__VEFPreP1B_8cpp_source.html#l00192">192</a> of file <a class="el" href="Assembleur__P__VEFPreP1B_8cpp_source.html">Assembleur_P_VEFPreP1B.cpp</a>.</p>

<p>References <a class="el" href="Assembleur__P__VEFPreP1B_8cpp_source.html#l00230">assembler_mat()</a>, <a class="el" href="EntreeSortie_8h_source.html#l00032">Cerr</a>, <a class="el" href="Process_8cpp_source.html#l00223">Process::exit()</a>, <a class="el" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>, <a class="el" href="ArrOfDouble_8h_source.html#l00350">ArrOfDouble::size_array()</a>, <a class="el" href="Cast_8h_source.html#l00054">sub_type</a>, <a class="el" href="Champ__Don__base_8cpp_source.html#l00271">Champ_Don_base::valeurs()</a>, <a class="el" href="Zone__VF_8h_source.html#l00736">Zone_VF::volumes_entrelaces()</a>, and <a class="el" href="Assembleur__P__VEFPreP1B_8cpp_source.html#l00116">zone_Vef()</a>.</p>
<div class="fragment"><pre class="fragment">{
<span class="comment">// On multiplie par la masse volumique aux faces</span>
  <span class="keywordflow">if</span> (!<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classChamp__Fonc__P1NC.html" title="classe Champ_Fonc_P1NC">Champ_Fonc_P1NC</a>, rho))
    {
      <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;La masse volumique n&#39;est pas aux faces dans Assembleur_P_VEFPreP1B::assembler_rho_variable.&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
      <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">Process::exit</a>();
    }
  <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; volumes_entrelaces=<a class="code" href="classAssembleur__P__VEFPreP1B.html#a3b4a812a062b850be5966f8c6e201cee">zone_Vef</a>().<a class="code" href="classZone__VF.html#a64f0b549e5aea1656855113e3510f418">volumes_entrelaces</a>();
  <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; masse_volumique=rho.<a class="code" href="classChamp__Don__base.html#ac0ac51817e03e27c28d2b96bb15db9a0" title="Surcharge Champ_base::valeurs() Renvoie le tableau des valeurs.">valeurs</a>();
  <a class="code" href="classDoubleVect.html">DoubleVect</a> quantitee_entrelacee(volumes_entrelaces);
  <span class="keywordtype">int</span> size=quantitee_entrelacee.size_array();
  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;size; i++)
    quantitee_entrelacee(i)=(volumes_entrelaces(i)*masse_volumique(i));

<span class="comment">// On assemble la matrice</span>
  <span class="keywordflow">return</span> <a class="code" href="classAssembleur__P__VEFPreP1B.html#a0cf6d0a6eeb99619a2c40e5a4a573c0d">assembler_mat</a>(la_matrice,quantitee_entrelacee,1,1);
}
</pre></div>
</div>
</div>
<a class="anchor" id="aa0ae226ce031b9410e951a4e95a393d8"></a><!-- doxytag: member="Assembleur_P_VEFPreP1B::changement_base" ref="aa0ae226ce031b9410e951a4e95a393d8" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Assembleur_P_VEFPreP1B::changement_base </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Assembleur__P__VEFPreP1B_8h_source.html#l00062">62</a> of file <a class="el" href="Assembleur__P__VEFPreP1B_8h_source.html">Assembleur_P_VEFPreP1B.h</a>.</p>

<p>References <a class="el" href="Assembleur__P__VEFPreP1B_8h_source.html#l00079">beta</a>.</p>

<p>Referenced by <a class="el" href="Assembleur__P__VEFPreP1B_8cpp_source.html#l00230">assembler_mat()</a>.</p>
<div class="fragment"><pre class="fragment">  {
    <span class="keywordflow">return</span> (<a class="code" href="classAssembleur__P__VEFPreP1B.html#a411ad82b856d17a1c8d942728a48f9a0" title="Coefficients du changement de base P0+P1&lt;-&gt;P1Bulle.">beta</a>!=0);
  };
</pre></div>
</div>
</div>
<a class="anchor" id="a1aebbbfd89e1ef2e187eca8c32a976f2"></a><!-- doxytag: member="Assembleur_P_VEFPreP1B::changer_base_matrice" ref="a1aebbbfd89e1ef2e187eca8c32a976f2" args="(Matrice &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Assembleur_P_VEFPreP1B::changer_base_matrice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMatrice.html">Matrice</a> &amp;&#160;</td>
          <td class="paramname"><em>la_matrice</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A-&gt;A~ (P0+P1-&gt;P1Bulle) </p>

<p><p>&lt; P0+P1 uniquement </p>
</p>

<p>Definition at line <a class="el" href="Assembleur__P__VEFPreP1B_8cpp_source.html#l01172">1172</a> of file <a class="el" href="Assembleur__P__VEFPreP1B_8cpp_source.html">Assembleur_P_VEFPreP1B.cpp</a>.</p>

<p>References <a class="el" href="Assembleur__P__VEFPreP1B_8h_source.html#l00079">alpha</a>, <a class="el" href="Assembleur__P__VEFPreP1B_8h_source.html#l00079">beta</a>, <a class="el" href="EntreeSortie_8h_source.html#l00032">Cerr</a>, <a class="el" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>, <a class="el" href="Matrice__Bloc__Sym_8cpp_source.html#l00281">Matrice_Bloc_Sym::get_bloc()</a>, <a class="el" href="Assembleur__P__VEFPreP1B_8cpp_source.html#l01117">operation01()</a>, <a class="el" href="Assembleur__P__VEFPreP1B_8cpp_source.html#l01018">operation11()</a>, <a class="el" href="Cast_8h_source.html#l00059">ref_cast</a>, <a class="el" href="Deriv__Matrice__Base_8h_source.html#l00028">Deriv_Matrice_Base::valeur()</a>, and <a class="el" href="Assembleur__P__VEFPreP1B_8cpp_source.html#l00116">zone_Vef()</a>.</p>

<p>Referenced by <a class="el" href="Assembleur__P__VEFPreP1B_8cpp_source.html#l00230">assembler_mat()</a>.</p>
<div class="fragment"><pre class="fragment">{
  assert(<a class="code" href="classAssembleur__P__VEFPreP1B.html#a3b4a812a062b850be5966f8c6e201cee">zone_Vef</a>().get_alphaE() &amp;&amp; <a class="code" href="classAssembleur__P__VEFPreP1B.html#a3b4a812a062b850be5966f8c6e201cee">zone_Vef</a>().get_alphaS() &amp;&amp; !<a class="code" href="classAssembleur__P__VEFPreP1B.html#a3b4a812a062b850be5966f8c6e201cee">zone_Vef</a>().get_alphaA()); <span class="comment">//!&lt; P0+P1 uniquement</span>
<span class="comment"></span>  <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Changement de base pour la matrice: P0+P1-&gt;P1Bulle&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
  <a class="code" href="classMatrice__Bloc__Sym.html">Matrice_Bloc_Sym</a>&amp; matrice=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Bloc__Sym.html">Matrice_Bloc_Sym</a>, la_matrice.<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>());
  <a class="code" href="classMatrice__Bloc.html">Matrice_Bloc</a>&amp; A00=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Bloc.html">Matrice_Bloc</a>, matrice.<a class="code" href="classMatrice__Bloc__Sym.html#a1002ce880ea2b2fb48dae444097c9f7a" title="(0&lt;=i&lt;N , i&lt;=j&lt;M)">get_bloc</a>(0,0).<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>());
  <a class="code" href="classMatrice__Bloc.html">Matrice_Bloc</a>&amp; A01=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Bloc.html">Matrice_Bloc</a>, matrice.<a class="code" href="classMatrice__Bloc__Sym.html#a1002ce880ea2b2fb48dae444097c9f7a" title="(0&lt;=i&lt;N , i&lt;=j&lt;M)">get_bloc</a>(0,1).<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>());
  <a class="code" href="classMatrice__Bloc.html">Matrice_Bloc</a>&amp; A11=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Bloc.html">Matrice_Bloc</a>, matrice.<a class="code" href="classMatrice__Bloc__Sym.html#a1002ce880ea2b2fb48dae444097c9f7a" title="(0&lt;=i&lt;N , i&lt;=j&lt;M)">get_bloc</a>(1,1).<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>());

<span class="comment">// Modification du bloc A11</span>
<span class="comment">// As1s2~=As1s2-beta*[somme(Ak1s2)(s1 appartient a k1)+somme(Ak1s1)(s2 appartenant a k1)]+beta*beta*somme(Ak1k2)(s1 appartenant a k1 et s2 appartenant a k2)</span>
  <a class="code" href="Assembleur__P__VEFPreP1B_8cpp.html#ad34510dd4da2194051998525655e62f9">operation11</a>(A00,A01,A11,<a class="code" href="classAssembleur__P__VEFPreP1B.html#a411ad82b856d17a1c8d942728a48f9a0" title="Coefficients du changement de base P0+P1&lt;-&gt;P1Bulle.">beta</a>,<a class="code" href="classAssembleur__P__VEFPreP1B.html#a3b4a812a062b850be5966f8c6e201cee">zone_Vef</a>().zone());

<span class="comment">// Modification du bloc A01</span>
<span class="comment">// Ak1s~=alpha*Ak1s - alpha*beta*somme(Ak1k2)(s appartenant a k2)</span>
  A01*=<a class="code" href="classAssembleur__P__VEFPreP1B.html#ae3dad2978525b28edcb08db30d0ce641">alpha</a>;
  <a class="code" href="Assembleur__P__VEFPreP1B_8cpp.html#a092a07cbd42b28d79c8d8d04e835fd91">operation01</a>(A00,A01,<a class="code" href="classAssembleur__P__VEFPreP1B.html#ae3dad2978525b28edcb08db30d0ce641">alpha</a>,<a class="code" href="classAssembleur__P__VEFPreP1B.html#a411ad82b856d17a1c8d942728a48f9a0" title="Coefficients du changement de base P0+P1&lt;-&gt;P1Bulle.">beta</a>,<a class="code" href="classAssembleur__P__VEFPreP1B.html#a3b4a812a062b850be5966f8c6e201cee">zone_Vef</a>().zone());

<span class="comment">// Modification du bloc A00</span>
<span class="comment">// Ak1k2~ = alpha * alpha * Ak1k2</span>
  A00*=<a class="code" href="classAssembleur__P__VEFPreP1B.html#ae3dad2978525b28edcb08db30d0ce641">alpha</a>*<a class="code" href="classAssembleur__P__VEFPreP1B.html#ae3dad2978525b28edcb08db30d0ce641">alpha</a>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a3f12c572633ef578d9a0f9d2d0f3506e"></a><!-- doxytag: member="Assembleur_P_VEFPreP1B::changer_base_pression" ref="a3f12c572633ef578d9a0f9d2d0f3506e" args="(DoubleVect &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Assembleur_P_VEFPreP1B::changer_base_pression </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>x-&gt;x~ (P0+P1-&gt;P1Bulle) Ne sert que pour les tests </p>

<p><p>&lt; P0+P1 uniquement xk~ = xk / alpha + beta / alpha * somme(xs)(s appartenant a k) xs~ = xs </p>
</p>

<p>Definition at line <a class="el" href="Assembleur__P__VEFPreP1B_8cpp_source.html#l01239">1239</a> of file <a class="el" href="Assembleur__P__VEFPreP1B_8cpp_source.html">Assembleur_P_VEFPreP1B.cpp</a>.</p>

<p>References <a class="el" href="Assembleur__P__VEFPreP1B_8h_source.html#l00079">alpha</a>, <a class="el" href="Assembleur__P__VEFPreP1B_8h_source.html#l00079">beta</a>, <a class="el" href="Check__espace__virtuel_8cpp_source.html#l00033">check_espace_virtuel_vect()</a>, <a class="el" href="IntTab_8h_source.html#l00233">IntTab::dimension()</a>, <a class="el" href="Zone_8cpp_source.html#l00262">Zone::domaine()</a>, <a class="el" href="Domaine_8h_source.html#l00613">Domaine::get_renum_som_perio()</a>, <a class="el" href="Zone_8h_source.html#l00402">Zone::les_elems()</a>, <a class="el" href="Zone__dis__base_8h_source.html#l00144">Zone_dis_base::nb_elem_tot()</a>, <a class="el" href="Zone__dis__base_8h_source.html#l00106">Zone_dis_base::zone()</a>, and <a class="el" href="Assembleur__P__VEFPreP1B_8cpp_source.html#l00116">zone_Vef()</a>.</p>

<p>Referenced by <a class="el" href="SolveurPP1B_8cpp_source.html#l00042">SolveurPP1B::resoudre_systeme()</a>.</p>
<div class="fragment"><pre class="fragment">{
  assert(<a class="code" href="classAssembleur__P__VEFPreP1B.html#a3b4a812a062b850be5966f8c6e201cee">zone_Vef</a>().get_alphaE() &amp;&amp; <a class="code" href="classAssembleur__P__VEFPreP1B.html#a3b4a812a062b850be5966f8c6e201cee">zone_Vef</a>().get_alphaS() &amp;&amp; !<a class="code" href="classAssembleur__P__VEFPreP1B.html#a3b4a812a062b850be5966f8c6e201cee">zone_Vef</a>().get_alphaA()); <span class="comment">//!&lt; P0+P1 uniquement xk~ = xk / alpha + beta / alpha * somme(xs)(s appartenant a k) xs~ = xs</span>
<span class="comment"></span><span class="comment">//</span>
<span class="comment">//</span>
  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; les_elems=<a class="code" href="classAssembleur__P__VEFPreP1B.html#a3b4a812a062b850be5966f8c6e201cee">zone_Vef</a>().<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#ac115e8342be89afb882b7b61cc343267" title="Renvoie le tableau des sommets des elements.">les_elems</a>();
  <span class="keyword">const</span> <a class="code" href="classDomaine.html" title="Classe Domaine Un Domaine represente le domaine (spatial) de resolution d&#39;un Probleme. Un Domaine a un Nom, il est constitue d&#39;une ou plusieurs Zone qui peuvent etre eventuellement decoupees en Sous_Zone. Un Domaine porte l&#39;ensemble des sommets utilises par ses Zones. On peut vouloir resoudre des problemes de type different sur plusieurs domaines, geometriquement les domaines sont alors couples par des surfaces qu&#39;on appelle Raccord.">Domaine</a>&amp; dom=<a class="code" href="classAssembleur__P__VEFPreP1B.html#a3b4a812a062b850be5966f8c6e201cee">zone_Vef</a>().<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#a379ad2206b5a13a4f4f3df6d44c7546a" title="Renvoie le domaine dont la zone fait partie. (version const)">domaine</a>();
  <span class="keywordtype">int</span> nb_elem_tot=<a class="code" href="classAssembleur__P__VEFPreP1B.html#a3b4a812a062b850be5966f8c6e201cee">zone_Vef</a>().<a class="code" href="classZone__dis__base.html#a4d6aa445f152aa6dc54d66ea7a071147">nb_elem_tot</a>();
  <span class="keywordtype">int</span> nb_som_elem=les_elems.<a class="code" href="classIntTab.html#abc3b32c94925a82f69d5b153a356e359" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(1);
  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k=0; k&lt;nb_elem_tot; k++)
    {
      x(k) /= <a class="code" href="classAssembleur__P__VEFPreP1B.html#ae3dad2978525b28edcb08db30d0ce641">alpha</a>;
      <span class="keywordtype">double</span> somme=0;
      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> som=0; som&lt;nb_som_elem; som++)
        {
          <span class="keywordtype">int</span> s = nb_elem_tot+dom.<a class="code" href="classDomaine.html#a37cc657f1907d53b0d5a573da862af80">get_renum_som_perio</a>(les_elems(k,som));
          somme += x(s);
        }
      x(k) += <a class="code" href="classAssembleur__P__VEFPreP1B.html#a411ad82b856d17a1c8d942728a48f9a0" title="Coefficients du changement de base P0+P1&lt;-&gt;P1Bulle.">beta</a> / <a class="code" href="classAssembleur__P__VEFPreP1B.html#ae3dad2978525b28edcb08db30d0ce641">alpha</a> * somme;
    }
  assert(<a class="code" href="Check__espace__virtuel_8cpp.html#ab72bd6ba208050e04da28b8365e95b94" title="Verifie si le vecteur v a son espace virtuel a jour. Cette fonction doit etre appelee simultanement p...">check_espace_virtuel_vect</a>(x));
}
</pre></div>
</div>
</div>
<a class="anchor" id="a4e57094c4613e2cd895f9fb52d47a233"></a><!-- doxytag: member="Assembleur_P_VEFPreP1B::changer_base_pression_inverse" ref="a4e57094c4613e2cd895f9fb52d47a233" args="(DoubleVect &amp;) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Assembleur_P_VEFPreP1B::changer_base_pression_inverse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>x~-&gt;x (P1Bulle-&gt;P0+P1) </p>

<p><p>&lt; P0+P1 uniquement xk = alpha * xk~ - beta * somme(xs~)(s appartenant a k) xs = xs~ </p>
</p>

<p>Definition at line <a class="el" href="Assembleur__P__VEFPreP1B_8cpp_source.html#l01217">1217</a> of file <a class="el" href="Assembleur__P__VEFPreP1B_8cpp_source.html">Assembleur_P_VEFPreP1B.cpp</a>.</p>

<p>References <a class="el" href="Assembleur__P__VEFPreP1B_8h_source.html#l00079">alpha</a>, <a class="el" href="Assembleur__P__VEFPreP1B_8h_source.html#l00079">beta</a>, <a class="el" href="Check__espace__virtuel_8cpp_source.html#l00033">check_espace_virtuel_vect()</a>, <a class="el" href="IntTab_8h_source.html#l00233">IntTab::dimension()</a>, <a class="el" href="Zone_8cpp_source.html#l00262">Zone::domaine()</a>, <a class="el" href="Domaine_8h_source.html#l00613">Domaine::get_renum_som_perio()</a>, <a class="el" href="Zone_8h_source.html#l00402">Zone::les_elems()</a>, <a class="el" href="Zone__dis__base_8h_source.html#l00144">Zone_dis_base::nb_elem_tot()</a>, <a class="el" href="Zone__dis__base_8h_source.html#l00106">Zone_dis_base::zone()</a>, and <a class="el" href="Assembleur__P__VEFPreP1B_8cpp_source.html#l00116">zone_Vef()</a>.</p>

<p>Referenced by <a class="el" href="SolveurPP1B_8cpp_source.html#l00042">SolveurPP1B::resoudre_systeme()</a>.</p>
<div class="fragment"><pre class="fragment">{
  assert(<a class="code" href="classAssembleur__P__VEFPreP1B.html#a3b4a812a062b850be5966f8c6e201cee">zone_Vef</a>().get_alphaE() &amp;&amp; <a class="code" href="classAssembleur__P__VEFPreP1B.html#a3b4a812a062b850be5966f8c6e201cee">zone_Vef</a>().get_alphaS() &amp;&amp; !<a class="code" href="classAssembleur__P__VEFPreP1B.html#a3b4a812a062b850be5966f8c6e201cee">zone_Vef</a>().get_alphaA()); <span class="comment">//!&lt; P0+P1 uniquement xk = alpha * xk~ - beta * somme(xs~)(s appartenant a k) xs = xs~</span>
<span class="comment"></span><span class="comment">//</span>
<span class="comment">//</span>
  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; les_elems=<a class="code" href="classAssembleur__P__VEFPreP1B.html#a3b4a812a062b850be5966f8c6e201cee">zone_Vef</a>().<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#ac115e8342be89afb882b7b61cc343267" title="Renvoie le tableau des sommets des elements.">les_elems</a>();
  <span class="keyword">const</span> <a class="code" href="classDomaine.html" title="Classe Domaine Un Domaine represente le domaine (spatial) de resolution d&#39;un Probleme. Un Domaine a un Nom, il est constitue d&#39;une ou plusieurs Zone qui peuvent etre eventuellement decoupees en Sous_Zone. Un Domaine porte l&#39;ensemble des sommets utilises par ses Zones. On peut vouloir resoudre des problemes de type different sur plusieurs domaines, geometriquement les domaines sont alors couples par des surfaces qu&#39;on appelle Raccord.">Domaine</a>&amp; dom=<a class="code" href="classAssembleur__P__VEFPreP1B.html#a3b4a812a062b850be5966f8c6e201cee">zone_Vef</a>().<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#a379ad2206b5a13a4f4f3df6d44c7546a" title="Renvoie le domaine dont la zone fait partie. (version const)">domaine</a>();
  <span class="keywordtype">int</span> nb_elem_tot=<a class="code" href="classAssembleur__P__VEFPreP1B.html#a3b4a812a062b850be5966f8c6e201cee">zone_Vef</a>().<a class="code" href="classZone__dis__base.html#a4d6aa445f152aa6dc54d66ea7a071147">nb_elem_tot</a>();
  <span class="keywordtype">int</span> nb_som_elem=les_elems.<a class="code" href="classIntTab.html#abc3b32c94925a82f69d5b153a356e359" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(1);
  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k=0; k&lt;nb_elem_tot; k++)
    {
      <span class="keywordtype">double</span> somme=0;
      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> som=0; som&lt;nb_som_elem; som++)
        {
          <span class="keywordtype">int</span> s = nb_elem_tot+dom.<a class="code" href="classDomaine.html#a37cc657f1907d53b0d5a573da862af80">get_renum_som_perio</a>(les_elems(k,som));
          somme += x(s);
        }
      x(k) = <a class="code" href="classAssembleur__P__VEFPreP1B.html#ae3dad2978525b28edcb08db30d0ce641">alpha</a> * x(k) - <a class="code" href="classAssembleur__P__VEFPreP1B.html#a411ad82b856d17a1c8d942728a48f9a0" title="Coefficients du changement de base P0+P1&lt;-&gt;P1Bulle.">beta</a> * somme;
    }
  assert(<a class="code" href="Check__espace__virtuel_8cpp.html#ab72bd6ba208050e04da28b8365e95b94" title="Verifie si le vecteur v a son espace virtuel a jour. Cette fonction doit etre appelee simultanement p...">check_espace_virtuel_vect</a>(x));
}
</pre></div>
</div>
</div>
<a class="anchor" id="a163d9e93dac32382f803926e4cde4660"></a><!-- doxytag: member="Assembleur_P_VEFPreP1B::changer_base_second_membre" ref="a163d9e93dac32382f803926e4cde4660" args="(DoubleVect &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Assembleur_P_VEFPreP1B::changer_base_second_membre </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;&#160;</td>
          <td class="paramname"><em>y</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>y-&gt;y~ (P0+P1-&gt;P1Bulle) </p>

<p><p>&lt; P0+P1 uniquement ys~ = ys - beta * somme(yk)(s appartenant a k) yk~ = alpha * yk </p>
</p>

<p>Definition at line <a class="el" href="Assembleur__P__VEFPreP1B_8cpp_source.html#l01196">1196</a> of file <a class="el" href="Assembleur__P__VEFPreP1B_8cpp_source.html">Assembleur_P_VEFPreP1B.cpp</a>.</p>

<p>References <a class="el" href="Assembleur__P__VEFPreP1B_8h_source.html#l00079">alpha</a>, <a class="el" href="Assembleur__P__VEFPreP1B_8h_source.html#l00079">beta</a>, <a class="el" href="IntTab_8h_source.html#l00233">IntTab::dimension()</a>, <a class="el" href="Zone_8cpp_source.html#l00262">Zone::domaine()</a>, <a class="el" href="DoubleVect_8cpp_source.html#l00277">DoubleVect::echange_espace_virtuel()</a>, <a class="el" href="Domaine_8h_source.html#l00613">Domaine::get_renum_som_perio()</a>, <a class="el" href="Zone_8h_source.html#l00402">Zone::les_elems()</a>, <a class="el" href="Zone__dis__base_8h_source.html#l00144">Zone_dis_base::nb_elem_tot()</a>, <a class="el" href="Zone__dis__base_8h_source.html#l00106">Zone_dis_base::zone()</a>, and <a class="el" href="Assembleur__P__VEFPreP1B_8cpp_source.html#l00116">zone_Vef()</a>.</p>

<p>Referenced by <a class="el" href="SolveurPP1B_8cpp_source.html#l00042">SolveurPP1B::resoudre_systeme()</a>.</p>
<div class="fragment"><pre class="fragment">{
  assert(<a class="code" href="classAssembleur__P__VEFPreP1B.html#a3b4a812a062b850be5966f8c6e201cee">zone_Vef</a>().get_alphaE() &amp;&amp; <a class="code" href="classAssembleur__P__VEFPreP1B.html#a3b4a812a062b850be5966f8c6e201cee">zone_Vef</a>().get_alphaS() &amp;&amp; !<a class="code" href="classAssembleur__P__VEFPreP1B.html#a3b4a812a062b850be5966f8c6e201cee">zone_Vef</a>().get_alphaA()); <span class="comment">//!&lt; P0+P1 uniquement ys~ = ys - beta * somme(yk)(s appartenant a k) yk~ = alpha * yk</span>
<span class="comment"></span><span class="comment">//</span>
<span class="comment">//</span>
  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; les_elems=<a class="code" href="classAssembleur__P__VEFPreP1B.html#a3b4a812a062b850be5966f8c6e201cee">zone_Vef</a>().<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#ac115e8342be89afb882b7b61cc343267" title="Renvoie le tableau des sommets des elements.">les_elems</a>();
  <span class="keyword">const</span> <a class="code" href="classDomaine.html" title="Classe Domaine Un Domaine represente le domaine (spatial) de resolution d&#39;un Probleme. Un Domaine a un Nom, il est constitue d&#39;une ou plusieurs Zone qui peuvent etre eventuellement decoupees en Sous_Zone. Un Domaine porte l&#39;ensemble des sommets utilises par ses Zones. On peut vouloir resoudre des problemes de type different sur plusieurs domaines, geometriquement les domaines sont alors couples par des surfaces qu&#39;on appelle Raccord.">Domaine</a>&amp; dom=<a class="code" href="classAssembleur__P__VEFPreP1B.html#a3b4a812a062b850be5966f8c6e201cee">zone_Vef</a>().<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#a379ad2206b5a13a4f4f3df6d44c7546a" title="Renvoie le domaine dont la zone fait partie. (version const)">domaine</a>();
  <span class="keywordtype">int</span> nb_elem_tot=<a class="code" href="classAssembleur__P__VEFPreP1B.html#a3b4a812a062b850be5966f8c6e201cee">zone_Vef</a>().<a class="code" href="classZone__dis__base.html#a4d6aa445f152aa6dc54d66ea7a071147">nb_elem_tot</a>();
  <span class="keywordtype">int</span> nb_som_elem=les_elems.<a class="code" href="classIntTab.html#abc3b32c94925a82f69d5b153a356e359" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(1);
  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k=0; k&lt;nb_elem_tot; k++)
    {
      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> som=0; som&lt;nb_som_elem; som++)
        {
          <span class="keywordtype">int</span> s = nb_elem_tot+dom.<a class="code" href="classDomaine.html#a37cc657f1907d53b0d5a573da862af80">get_renum_som_perio</a>(les_elems(k,som));
          y(s) -= <a class="code" href="classAssembleur__P__VEFPreP1B.html#a411ad82b856d17a1c8d942728a48f9a0" title="Coefficients du changement de base P0+P1&lt;-&gt;P1Bulle.">beta</a> * y(k);
        }
      y(k) *= <a class="code" href="classAssembleur__P__VEFPreP1B.html#ae3dad2978525b28edcb08db30d0ce641">alpha</a>;
    }
  y.<a class="code" href="classDoubleVect.html#abfebbc2f685ce7bc4b80c720d7da9bf3">echange_espace_virtuel</a>();
}
</pre></div>
</div>
</div>
<a class="anchor" id="aeecf2e110cf38f394e6fb78fefb51f31"></a><!-- doxytag: member="Assembleur_P_VEFPreP1B::completer" ref="aeecf2e110cf38f394e6fb78fefb51f31" args="(const Equation_base &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Assembleur_P_VEFPreP1B::completer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEquation__base.html">Equation_base</a> &amp;&#160;</td>
          <td class="paramname"><em>eqn</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="classAssembleur__P__VEF.html#a447747a3066cbc0aacdad552a77680ac">Assembleur_P_VEF</a>.</p>

<p>Definition at line <a class="el" href="Assembleur__P__VEFPreP1B_8cpp_source.html#l00100">100</a> of file <a class="el" href="Assembleur__P__VEFPreP1B_8cpp_source.html">Assembleur_P_VEFPreP1B.cpp</a>.</p>

<p>References <a class="el" href="Assembleur__P__VEFPreP1B_8h_source.html#l00079">alpha</a>, <a class="el" href="Assembleur__P__VEFPreP1B_8h_source.html#l00079">beta</a>, <a class="el" href="Objet__U_8h_source.html#l00079">Objet_U::dimension</a>, <a class="el" href="Assembleur__P__VEFPreP1B_8h_source.html#l00072">la_matrice_de_travail_</a>, <a class="el" href="Assembleur__P__VEFPreP1B_8h_source.html#l00077">mon_equation</a>, <a class="el" href="Deriv___8cpp_source.html#l00091">Deriv_::typer()</a>, and <a class="el" href="Assembleur__P__VEFPreP1B_8cpp_source.html#l00116">zone_Vef()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <a class="code" href="classAssembleur__P__VEFPreP1B.html#a75f504c4171787bdeb487a8dd98e2a00">mon_equation</a>=eqn;
  <a class="code" href="classAssembleur__P__VEFPreP1B.html#aeecf2e110cf38f394e6fb78fefb51f31">Assembleur_P_VEF::completer</a>(eqn);
<span class="comment">// Initialisation de alpha, beta</span>
  <a class="code" href="classAssembleur__P__VEFPreP1B.html#ae3dad2978525b28edcb08db30d0ce641">alpha</a>=0.;
  <a class="code" href="classAssembleur__P__VEFPreP1B.html#a411ad82b856d17a1c8d942728a48f9a0" title="Coefficients du changement de base P0+P1&lt;-&gt;P1Bulle.">beta</a>=0.;
  <span class="keywordflow">if</span> (<a class="code" href="classAssembleur__P__VEFPreP1B.html#a3b4a812a062b850be5966f8c6e201cee">zone_Vef</a>().get_P1Bulle())
    {
<span class="comment">// Pour changer de base et retrouver le P1Bulle</span>
      <a class="code" href="classAssembleur__P__VEFPreP1B.html#ae3dad2978525b28edcb08db30d0ce641">alpha</a>=1./<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>;
      <a class="code" href="classAssembleur__P__VEFPreP1B.html#a411ad82b856d17a1c8d942728a48f9a0" title="Coefficients du changement de base P0+P1&lt;-&gt;P1Bulle.">beta</a>=1./(<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>*(<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>+1));
    }
  <a class="code" href="classAssembleur__P__VEFPreP1B.html#a5d22f81d5f579074de9324230e3ff45f" title="Matrice de travail.">la_matrice_de_travail_</a>.<a class="code" href="classDeriv__.html#ad1d33400ed15b6ff96579ed82d9e2719" title="Essaie de creer une instance du type &quot;type&quot;. si type n&#39;est pas un type ou type n&#39;est pas instanciab...">typer</a>(<span class="stringliteral">&quot;Matrice_Bloc_Sym&quot;</span>);
}
</pre></div>
</div>
</div>
<a class="anchor" id="a98bf7b93f310a3d9a8317937e8dfe198"></a><!-- doxytag: member="Assembleur_P_VEFPreP1B::cree_instance" ref="a98bf7b93f310a3d9a8317937e8dfe198" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classObjet__U.html">Objet_U</a> * Assembleur_P_VEFPreP1B::cree_instance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="classAssembleur__P__VEF.html#a9f0ca181c8ebe7a4cf0e102bae3f13db">Assembleur_P_VEF</a>.</p>

<p>Definition at line <a class="el" href="Assembleur__P__VEFPreP1B_8cpp_source.html#l00049">49</a> of file <a class="el" href="Assembleur__P__VEFPreP1B_8cpp_source.html">Assembleur_P_VEFPreP1B.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="acde8b56bb8b7ff6b7e399e66b4376147"></a><!-- doxytag: member="Assembleur_P_VEFPreP1B::duplique" ref="acde8b56bb8b7ff6b7e399e66b4376147" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Assembleur_P_VEFPreP1B::duplique </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="classAssembleur__P__VEF.html#ac69be65b8e906e81bf8951fbd8fe2150">Assembleur_P_VEF</a>.</p>

<p>Definition at line <a class="el" href="Assembleur__P__VEFPreP1B_8cpp_source.html#l00049">49</a> of file <a class="el" href="Assembleur__P__VEFPreP1B_8cpp_source.html">Assembleur_P_VEFPreP1B.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9a85837c29e80d1bcbc3a7f740f93807"></a><!-- doxytag: member="Assembleur_P_VEFPreP1B::equation" ref="a9a85837c29e80d1bcbc3a7f740f93807" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEquation__base.html">Equation_base</a>&amp; Assembleur_P_VEFPreP1B::equation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="classAssembleur__P__VEF.html#a3f6f394a6d2d764360750644d0d832f8">Assembleur_P_VEF</a>.</p>

<p>Definition at line <a class="el" href="Assembleur__P__VEFPreP1B_8h_source.html#l00047">47</a> of file <a class="el" href="Assembleur__P__VEFPreP1B_8h_source.html">Assembleur_P_VEFPreP1B.h</a>.</p>

<p>References <a class="el" href="EntreeSortie_8h_source.html#l00032">Cerr</a>, <a class="el" href="Process_8cpp_source.html#l00223">Process::exit()</a>, <a class="el" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>, <a class="el" href="Assembleur__P__VEFPreP1B_8h_source.html#l00077">mon_equation</a>, <a class="el" href="O__U__Ptr_8cpp_source.html#l00098">O_U_Ptr::non_nul()</a>, and <a class="el" href="Ref__Equation__base_8h_source.html#l00028">Ref_Equation_base::valeur()</a>.</p>

<p>Referenced by <a class="el" href="Assembleur__P__VEFPreP1B_8cpp_source.html#l00418">modifier_secmem()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00146">verifier()</a>, and <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00118">verifier_complet()</a>.</p>
<div class="fragment"><pre class="fragment">  {
    <span class="keywordflow">if</span> (<a class="code" href="classAssembleur__P__VEFPreP1B.html#a75f504c4171787bdeb487a8dd98e2a00">mon_equation</a>.<a class="code" href="classO__U__Ptr.html#a16f216b2d169e885876419182658ddcc" title="Renvoie 1 si le pointeur est non_nul Renvoie 0 sinon.">non_nul</a>()==0)
      {
        <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;\nError in Assembleur_P_VEFPreP1B::equation() : The equation is unknown !&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
        <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">Process::exit</a>();
      }
    <span class="keywordflow">return</span> <a class="code" href="classAssembleur__P__VEFPreP1B.html#a75f504c4171787bdeb487a8dd98e2a00">mon_equation</a>.<a class="code" href="classRef__Equation__base.html#a7bb6fb60cb55bef0eef1b0e8718300a4">valeur</a>();
  };
</pre></div>
</div>
</div>
<a class="anchor" id="a02a1a5944a64f58381a56137a7703893"></a><!-- doxytag: member="Assembleur_P_VEFPreP1B::get_info" ref="a02a1a5944a64f58381a56137a7703893" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classType__info.html">Type_info</a> * Assembleur_P_VEFPreP1B::get_info </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Donne des informations sur le type de l'Objet_U. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>const Type_info*<br/>
 Signification: structure regroupant les informations sur le type de l'Objet_U<br/>
 Contraintes: </dd></dl>

<p>Reimplemented from <a class="el" href="classAssembleur__P__VEF.html#aa187a8611fca41d5dcdd87c04d8f5616">Assembleur_P_VEF</a>.</p>

<p>Definition at line <a class="el" href="Assembleur__P__VEFPreP1B_8cpp_source.html#l00049">49</a> of file <a class="el" href="Assembleur__P__VEFPreP1B_8cpp_source.html">Assembleur_P_VEFPreP1B.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6abcea83b31bc157fa6766b84e7f2133"></a><!-- doxytag: member="Assembleur_P_VEFPreP1B::info" ref="a6abcea83b31bc157fa6766b84e7f2133" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classType__info.html">Type_info</a> * Assembleur_P_VEFPreP1B::info </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Donne des informations sur le type de l'Objet_U. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>const Type_info*<br/>
 Signification: structure regroupant les informations sur le type de l'Objet_U<br/>
 Contraintes: </dd></dl>

<p>Reimplemented from <a class="el" href="classAssembleur__P__VEF.html#a4edab792365d27df8ae0c5322e578397">Assembleur_P_VEF</a>.</p>

<p>Definition at line <a class="el" href="Assembleur__P__VEFPreP1B_8cpp_source.html#l00049">49</a> of file <a class="el" href="Assembleur__P__VEFPreP1B_8cpp_source.html">Assembleur_P_VEFPreP1B.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4f5ed51e7785455c9ddeb94d1978799a"></a><!-- doxytag: member="Assembleur_P_VEFPreP1B::modifier_matrice" ref="a4f5ed51e7785455c9ddeb94d1978799a" args="(Matrice &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Assembleur_P_VEFPreP1B::modifier_matrice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMatrice.html">Matrice</a> &amp;&#160;</td>
          <td class="paramname"><em>la_matrice</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Modifier eventuellement la matrice pour la rendre definie si elle ne l'est pas<br/>
Valeurs par defaut:<br/>
Contraintes:<br/>
Acces: lecture. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>int<br/>
 Signification: renvoie 1 si la matrice est modifiee 0 sinon<br/>
 Contraintes: </dd></dl>

<p>Reimplemented from <a class="el" href="classAssembleur__P__VEF.html#a283c94d70a1af06e3d904dc4fd8f5319">Assembleur_P_VEF</a>.</p>

<p>Definition at line <a class="el" href="Assembleur__P__VEFPreP1B_8cpp_source.html#l00880">880</a> of file <a class="el" href="Assembleur__P__VEFPreP1B_8cpp_source.html">Assembleur_P_VEFPreP1B.cpp</a>.</p>

<p>References <a class="el" href="EntreeSortie_8h_source.html#l00032">Cerr</a>, <a class="el" href="Domaine_8h_source.html#l00500">Domaine::coord_sommets()</a>, <a class="el" href="Objet__U_8h_source.html#l00079">Objet_U::dimension</a>, <a class="el" href="DoubleTab_8h_source.html#l00243">DoubleTab::dimension()</a>, <a class="el" href="Double_8h_source.html#l00072">DMAXFLOAT</a>, <a class="el" href="Zone_8cpp_source.html#l00262">Zone::domaine()</a>, <a class="el" href="Double_8h_source.html#l00273">est_egal()</a>, <a class="el" href="Process_8cpp_source.html#l00223">Process::exit()</a>, <a class="el" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>, <a class="el" href="Zone__VEF__PreP1b_8h_source.html#l00071">Zone_VEF_PreP1b::get_alphaA()</a>, <a class="el" href="Zone__VEF__PreP1b_8h_source.html#l00061">Zone_VEF_PreP1b::get_alphaE()</a>, <a class="el" href="Zone__VEF__PreP1b_8h_source.html#l00066">Zone_VEF_PreP1b::get_alphaS()</a>, <a class="el" href="Matrice__Bloc_8cpp_source.html#l00568">Matrice_Bloc::get_bloc()</a>, <a class="el" href="Matrice__Bloc__Sym_8cpp_source.html#l00281">Matrice_Bloc_Sym::get_bloc()</a>, <a class="el" href="Zone__VEF__PreP1b_8h_source.html#l00081">Zone_VEF_PreP1b::get_cl_pression_sommet_faible()</a>, <a class="el" href="Assembleur__P__VEF_8h_source.html#l00068">Assembleur_P_VEF::has_P_ref</a>, <a class="el" href="Double_8h_source.html#l00345">inf_strict()</a>, <a class="el" href="Process_8cpp_source.html#l00095">Process::je_suis_maitre()</a>, <a class="el" href="Assembleur__P__VEF_8h_source.html#l00066">Assembleur_P_VEF::la_zone_Cl_VEF</a>, <a class="el" href="Zone__Cl__dis__base_8cpp_source.html#l00522">Zone_Cl_dis_base::les_conditions_limites()</a>, <a class="el" href="Process_8cpp_source.html#l00156">Process::mp_max()</a>, <a class="el" href="Zone_8h_source.html#l01258">Zone::nb_aretes()</a>, <a class="el" href="Zone_8cpp_source.html#l00586">Zone::nb_som()</a>, <a class="el" href="Cast_8h_source.html#l00059">ref_cast</a>, <a class="el" href="Matrice__Sym_8cpp_source.html#l00032">Matrice_Sym::set_est_definie()</a>, <a class="el" href="vect__impl_8h_source.html#l00057">vect_impl::size()</a>, <a class="el" href="Cast_8h_source.html#l00054">sub_type</a>, <a class="el" href="Deriv__Matrice__Base_8h_source.html#l00028">Deriv_Matrice_Base::valeur()</a>, <a class="el" href="Source__Generique__Face__PolyMAC_8cpp_source.html#l00045">valeur()</a>, <a class="el" href="Ref__Zone__Cl__VEF_8h_source.html#l00028">Ref_Zone_Cl_VEF::valeur()</a>, <a class="el" href="Zone__VF_8h_source.html#l00718">Zone_VF::xa()</a>, <a class="el" href="Zone__dis__base_8h_source.html#l00106">Zone_dis_base::zone()</a>, and <a class="el" href="Assembleur__P__VEFPreP1B_8cpp_source.html#l00116">zone_Vef()</a>.</p>

<p>Referenced by <a class="el" href="Assembleur__P__VEFPreP1B_8cpp_source.html#l00230">assembler_mat()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">int</span> matrice_modifiee=0;
  <a class="code" href="classAssembleur__P__VEF.html#a23daed7e2fca571504eabe445c920be1">has_P_ref</a>=0;
  <span class="keyword">const</span> <a class="code" href="classConds__lim.html">Conds_lim</a>&amp; les_cl = <a class="code" href="classAssembleur__P__VEF.html#af06d2fedcae0282000a96ddd444ec7a2">la_zone_Cl_VEF</a>.<a class="code" href="classRef__Zone__Cl__VEF.html#a0970d7253def65ad4f0c5ce1830fd243">valeur</a>().<a class="code" href="classZone__Cl__dis__base.html#af75e0ed7786863e4d333bfb29d67c323" title="Renvoie la i-ieme condition aux limites. (version const)">les_conditions_limites</a>();
  <span class="keyword">const</span> <a class="code" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a>&amp; zone_VEF = <a class="code" href="classAssembleur__P__VEFPreP1B.html#a3b4a812a062b850be5966f8c6e201cee">zone_Vef</a>();
<span class="comment">// Recherche s&#39;il y&#39;a une pression de reference, et si oui la matrice n&#39;est pas modifiee</span>
  <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;les_cl.<a class="code" href="classvect__impl.html#a78155bfbd6b61f4710b9830641ed1694">size</a>(); i++)
    <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classNeumann__sortie__libre.html" title="classe Neumann_sortie_libre Cette classe represente une frontiere ouverte sans vitesse imposee Pour l...">Neumann_sortie_libre</a>,les_cl[i].<a class="code" href="Source__Generique__Face__PolyMAC_8cpp.html#a7d7b5d77a3caa1af70f5e1c9108de5a1">valeur</a>()))
      {
        <a class="code" href="classAssembleur__P__VEF.html#a23daed7e2fca571504eabe445c920be1">has_P_ref</a>=1;
        <span class="keywordflow">if</span> (zone_VEF.<a class="code" href="classZone__VEF__PreP1b.html#a9d02e2431efb6e75c3d733ff06f89549">get_alphaA</a>())
          {
<span class="comment">// On en profite pour verifier si la pression est bien nulle si support Pa</span>
            <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; val=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classNeumann__sortie__libre.html" title="classe Neumann_sortie_libre Cette classe represente une frontiere ouverte sans vitesse imposee Pour l...">Neumann_sortie_libre</a>,les_cl[i].<a class="code" href="Source__Generique__Face__PolyMAC_8cpp.html#a7d7b5d77a3caa1af70f5e1c9108de5a1">valeur</a>()).champ_front().valeurs();
            <span class="keywordtype">int</span> nbval=val.<a class="code" href="classDoubleTab.html#ac3805e2637a3b880ba2d3e650c69dac4" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(0);
            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> n=0; n&lt;nbval; n++)
              <span class="keywordflow">if</span> (val(n,0)!=0)
                {
                  <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;La condition limite pression imposee non nulle n&#39;est pas encore&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
                  <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;supportee en VEF avec support arete Pa.&quot;</span> &lt;&lt; finl;
<span class="comment">// Le travail est a faire dans Assembleur_P_VEFPreP1B::modifier_secmem_aretes</span>
                  <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">Process::exit</a>();
                }
          }
      }

  <a class="code" href="classMatrice__Bloc__Sym.html">Matrice_Bloc_Sym</a>&amp; matrice=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Bloc__Sym.html">Matrice_Bloc_Sym</a>, la_matrice.<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>());
  <span class="keywordtype">int</span> P0 = 0;
  <span class="keywordtype">int</span> P1 = P0 + zone_VEF.<a class="code" href="classZone__VEF__PreP1b.html#aee2def53aa92584d7945e7c3d0d98963">get_alphaE</a>();
  <span class="keywordtype">int</span> Pa = P1 + zone_VEF.<a class="code" href="classZone__VEF__PreP1b.html#ad7fbcb5567dcc2e6f0a0ed85ce90a4fa">get_alphaS</a>();



  <span class="keywordtype">int</span> CL_neumann=<a class="code" href="classAssembleur__P__VEF.html#a23daed7e2fca571504eabe445c920be1">has_P_ref</a>;
<span class="comment">//</span>
<span class="comment">// Partie P0</span>
<span class="comment">//</span>
  <span class="keywordflow">if</span> (zone_VEF.<a class="code" href="classZone__VEF__PreP1b.html#aee2def53aa92584d7945e7c3d0d98963">get_alphaE</a>())
    {
<span class="comment">// On impose une pression de reference sur un element si pas de CL de Neumann</span>
      <span class="keywordflow">if</span> (<a class="code" href="classAssembleur__P__VEF.html#a23daed7e2fca571504eabe445c920be1">has_P_ref</a>)
        {
          <a class="code" href="classMatrice__Bloc.html">Matrice_Bloc</a>&amp; mat_bloc=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Bloc.html">Matrice_Bloc</a>,matrice.<a class="code" href="classMatrice__Bloc__Sym.html#a1002ce880ea2b2fb48dae444097c9f7a" title="(0&lt;=i&lt;N , i&lt;=j&lt;M)">get_bloc</a>(P0,P0).<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>());
          <a class="code" href="classMatrice__Morse__Sym.html" title="Classe Matrice_Morse_Sym Represente une matrice M (creuse) symetrique stockee au format Morse Symetri...">Matrice_Morse_Sym</a>&amp; A00RR = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Morse__Sym.html" title="Classe Matrice_Morse_Sym Represente une matrice M (creuse) symetrique stockee au format Morse Symetri...">Matrice_Morse_Sym</a>,mat_bloc.<a class="code" href="classMatrice__Bloc.html#a7ffa38f7b93454432b2df7c616ed0a4e">get_bloc</a>(0,0).<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>());
          A00RR.set_est_definie(1);
        }
      matrice_modifiee=<a class="code" href="classAssembleur__P__VEFPreP1B.html#a4f5ed51e7785455c9ddeb94d1978799a" title="Modifier eventuellement la matrice pour la rendre definie si elle ne l&#39;est pas Valeurs par defaut: Co...">Assembleur_P_VEF::modifier_matrice</a>(matrice.<a class="code" href="classMatrice__Bloc__Sym.html#a1002ce880ea2b2fb48dae444097c9f7a" title="(0&lt;=i&lt;N , i&lt;=j&lt;M)">get_bloc</a>(P0,P0));
    }

<span class="comment">//</span>
<span class="comment">// Partie P1</span>
<span class="comment">//</span>
  <span class="keywordflow">if</span> (zone_VEF.<a class="code" href="classZone__VEF__PreP1b.html#ad7fbcb5567dcc2e6f0a0ed85ce90a4fa">get_alphaS</a>())
    {
      <a class="code" href="classMatrice__Bloc.html">Matrice_Bloc</a>&amp; mat_bloc_p1_p1 = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Bloc.html">Matrice_Bloc</a>, matrice.<a class="code" href="classMatrice__Bloc__Sym.html#a1002ce880ea2b2fb48dae444097c9f7a" title="(0&lt;=i&lt;N , i&lt;=j&lt;M)">get_bloc</a>(P1,P1).<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>());
      <a class="code" href="classMatrice__Morse__Sym.html" title="Classe Matrice_Morse_Sym Represente une matrice M (creuse) symetrique stockee au format Morse Symetri...">Matrice_Morse_Sym</a>&amp; A11RR = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Morse__Sym.html" title="Classe Matrice_Morse_Sym Represente une matrice M (creuse) symetrique stockee au format Morse Symetri...">Matrice_Morse_Sym</a>,mat_bloc_p1_p1.<a class="code" href="classMatrice__Bloc.html#a7ffa38f7b93454432b2df7c616ed0a4e">get_bloc</a>(0,0).<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>());
<span class="comment">// On impose une pression de reference sur un sommet si support P0 ou si pas de CL de Neumann</span>
      <span class="keywordflow">if</span> (((!(<a class="code" href="classProcess.html#a1e9d9f9899b71927cfafae14c7bd048d" title="Calcule le max de x sur tous les processeurs du groupe courant. Remarques : Cette methode doit etre a...">Process::mp_max</a>(CL_neumann))) || ((zone_VEF.<a class="code" href="classZone__VEF__PreP1b.html#aee2def53aa92584d7945e7c3d0d98963">get_alphaE</a>()) &amp;&amp; (zone_VEF.<a class="code" href="classZone__VEF__PreP1b.html#aed6f98596f13c0c4df7a7d9f57235b56">get_cl_pression_sommet_faible</a>()==1) ) ) &amp;&amp; <a class="code" href="classProcess.html#acd052b99706c577f8a5b6656217cf4c2" title="renvoie 1 si on est sur le processeur maitre du groupe courant (c&#39;est a dire me() == 0)...">Process::je_suis_maitre</a>())
        {
          <span class="keywordtype">int</span> sommet_referent=0;
          <span class="keywordtype">double</span> distance=<a class="code" href="Double_8h.html#ae0ee0cebfad5968da0ad6cc7a49e16b6">DMAXFLOAT</a>;
          <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; coord=zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#a379ad2206b5a13a4f4f3df6d44c7546a" title="Renvoie le domaine dont la zone fait partie. (version const)">domaine</a>().<a class="code" href="classDomaine.html#aecd32c3eecc15cce7d1a0e468dadbf96" title="Renvoie le tableau des coordonnees des noeuds (sommets). (acces en lecture)">coord_sommets</a>();
          <span class="keywordtype">int</span> nb_som=zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#ad340f571f81fa5c2e028b88c00b5c2ca" title="Renvoie le nombre de sommets de la zone.">nb_som</a>();
          <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;nb_som; i++)
            {
              <span class="keywordtype">double</span> tmp=0;
              <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j=0; j&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; j++)
                tmp+=coord(i,j)*coord(i,j);
              <span class="keywordflow">if</span> (<a class="code" href="Double_8h.html#ad7e27600604265379936210d7f9dfdd5">inf_strict</a>(tmp,distance) &amp;&amp; !<a class="code" href="Double_8h.html#ac86f5f350b0f95fd8c34b0ac8d720f6f">est_egal</a>(A11RR(i,i),0.))
                {
                  distance=tmp;
                  sommet_referent=i;
                }
            }
<span class="comment">// Cerr &lt;&lt; &quot;On modifie la ligne (sommet) &quot; &lt;&lt; sommet_referent &lt;&lt; finl;</span>
          A11RR(sommet_referent,sommet_referent)*=2;
<span class="comment">// has_P_ref=1;</span>
          matrice_modifiee=1;
        }
      A11RR.set_est_definie(1);
    }

<span class="comment">//</span>
<span class="comment">// Partie Pa</span>
<span class="comment">//</span>
  <span class="keywordflow">if</span> (zone_VEF.<a class="code" href="classZone__VEF__PreP1b.html#a9d02e2431efb6e75c3d733ff06f89549">get_alphaA</a>())
    {
      <a class="code" href="classMatrice__Bloc.html">Matrice_Bloc</a>&amp; mat_bloc_pa_pa = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Bloc.html">Matrice_Bloc</a>, matrice.<a class="code" href="classMatrice__Bloc__Sym.html#a1002ce880ea2b2fb48dae444097c9f7a" title="(0&lt;=i&lt;N , i&lt;=j&lt;M)">get_bloc</a>(Pa,Pa).<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>());
      <a class="code" href="classMatrice__Morse__Sym.html" title="Classe Matrice_Morse_Sym Represente une matrice M (creuse) symetrique stockee au format Morse Symetri...">Matrice_Morse_Sym</a>&amp; A22RR = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Morse__Sym.html" title="Classe Matrice_Morse_Sym Represente une matrice M (creuse) symetrique stockee au format Morse Symetri...">Matrice_Morse_Sym</a>,mat_bloc_pa_pa.<a class="code" href="classMatrice__Bloc.html#a7ffa38f7b93454432b2df7c616ed0a4e">get_bloc</a>(0,0).<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>());
<span class="comment">// On impose une pression de reference sur une arete en P0+Pa uniquement</span>
      <span class="keywordflow">if</span> ((zone_VEF.<a class="code" href="classZone__VEF__PreP1b.html#aee2def53aa92584d7945e7c3d0d98963">get_alphaE</a>() &amp;&amp; !zone_VEF.<a class="code" href="classZone__VEF__PreP1b.html#ad7fbcb5567dcc2e6f0a0ed85ce90a4fa">get_alphaS</a>()) &amp;&amp; <a class="code" href="classProcess.html#acd052b99706c577f8a5b6656217cf4c2" title="renvoie 1 si on est sur le processeur maitre du groupe courant (c&#39;est a dire me() == 0)...">Process::je_suis_maitre</a>())
        {
          <span class="keywordtype">int</span> arete_referente=0;
          <span class="keywordtype">double</span> distance=<a class="code" href="Double_8h.html#ae0ee0cebfad5968da0ad6cc7a49e16b6">DMAXFLOAT</a>;
          <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; coord=zone_VEF.<a class="code" href="classZone__VF.html#a6ad5a2a03fc2cba4247a6ebe662b1320">xa</a>();
          <span class="keywordtype">int</span> nb_aretes=zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#a3e3b48691911fd85574c7bc10a1a4fb8" title="renvoie le nombre d&#39;aretes reelles.">nb_aretes</a>();
          <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;nb_aretes; i++)
            {
              <span class="keywordtype">double</span> tmp=0;
              <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j=0; j&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; j++)
                tmp+=coord(i,j)*coord(i,j);
              <span class="keywordflow">if</span> (tmp&lt;distance &amp;&amp; A22RR(i,i)!=0)
                {
                  distance=tmp;
                  arete_referente=i;
                }
            }
<span class="comment">// Cerr &lt;&lt; &quot;On modifie la ligne (arete) &quot; &lt;&lt; arete_referente &lt;&lt; finl;</span>
          A22RR(arete_referente,arete_referente)*=2;
<span class="comment">// has_P_ref=1;</span>
          matrice_modifiee=1;
        }
      A22RR.set_est_definie(1);
    }

  {
    <a class="code" href="classMatrice__Bloc.html">Matrice_Bloc</a>&amp; bloc_P0_P0 = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>( <a class="code" href="classMatrice__Bloc.html">Matrice_Bloc</a>,matrice.<a class="code" href="classMatrice__Bloc__Sym.html#a1002ce880ea2b2fb48dae444097c9f7a" title="(0&lt;=i&lt;N , i&lt;=j&lt;M)">get_bloc</a>(P0,P0).<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>( ) );
    <a class="code" href="classMatrice__Morse__Sym.html" title="Classe Matrice_Morse_Sym Represente une matrice M (creuse) symetrique stockee au format Morse Symetri...">Matrice_Morse_Sym</a>&amp; A00RR = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>( <a class="code" href="classMatrice__Morse__Sym.html" title="Classe Matrice_Morse_Sym Represente une matrice M (creuse) symetrique stockee au format Morse Symetri...">Matrice_Morse_Sym</a>, bloc_P0_P0.<a class="code" href="classMatrice__Bloc.html#a7ffa38f7b93454432b2df7c616ed0a4e">get_bloc</a>(0,0).<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>() );
    matrice.<a class="code" href="classMatrice__Sym.html#a532cf830aed3865010c9977b545927c0">set_est_definie</a>( A00RR.get_est_definie( ) );
  }

  <span class="keywordflow">return</span> matrice_modifiee;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a492bdeef134441bb3358ea66c771c783"></a><!-- doxytag: member="Assembleur_P_VEFPreP1B::modifier_secmem" ref="a492bdeef134441bb3358ea66c771c783" args="(DoubleTab &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Assembleur_P_VEFPreP1B::modifier_secmem </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>&lt; Les aretes superflues ont une valeur nulle</p>
<p>&lt; Les aretes periodiques ont une valeur nulle</p>
<p>&lt; Drapeau pour economiser potentiellement un echange_espace_virtuel </p>
</p>

<p>Reimplemented from <a class="el" href="classAssembleur__P__VEF.html#a26b4f0b0864f90c143915d80e36560fd">Assembleur_P_VEF</a>.</p>

<p>Definition at line <a class="el" href="Assembleur__P__VEFPreP1B_8cpp_source.html#l00418">418</a> of file <a class="el" href="Assembleur__P__VEFPreP1B_8cpp_source.html">Assembleur_P_VEFPreP1B.cpp</a>.</p>

<p>References <a class="el" href="EntreeSortie_8h_source.html#l00032">Cerr</a>, <a class="el" href="Cond__lim__base_8h_source.html#l00196">Cond_lim_base::champ_front()</a>, <a class="el" href="Objet__U_8h_source.html#l00079">Objet_U::dimension</a>, <a class="el" href="Zone_8cpp_source.html#l00262">Zone::domaine()</a>, <a class="el" href="DoubleVect_8cpp_source.html#l00277">DoubleVect::echange_espace_virtuel()</a>, <a class="el" href="Assembleur__P__VEFPreP1B_8h_source.html#l00047">equation()</a>, <a class="el" href="Process_8cpp_source.html#l00223">Process::exit()</a>, <a class="el" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>, <a class="el" href="Cond__lim__base_8h_source.html#l00123">Cond_lim_base::frontiere_dis()</a>, <a class="el" href="Zone__VEF__PreP1b_8h_source.html#l00071">Zone_VEF_PreP1b::get_alphaA()</a>, <a class="el" href="Zone__VEF__PreP1b_8h_source.html#l00061">Zone_VEF_PreP1b::get_alphaE()</a>, <a class="el" href="Zone__VEF__PreP1b_8h_source.html#l00066">Zone_VEF_PreP1b::get_alphaS()</a>, <a class="el" href="Zone__VEF__PreP1b_8h_source.html#l00090">Zone_VEF_PreP1b::get_ok_arete()</a>, <a class="el" href="Zone__VEF__PreP1b_8h_source.html#l00086">Zone_VEF_PreP1b::get_renum_arete_perio()</a>, <a class="el" href="Domaine_8h_source.html#l00613">Domaine::get_renum_som_perio()</a>, <a class="el" href="Assembleur__base_8cpp_source.html#l00087">Assembleur_base::get_resoudre_en_u()</a>, <a class="el" href="Assembleur__P__VEF_8h_source.html#l00066">Assembleur_P_VEF::la_zone_Cl_VEF</a>, <a class="el" href="Zone__Cl__dis__base_8cpp_source.html#l00522">Zone_Cl_dis_base::les_conditions_limites()</a>, <a class="el" href="Assembleur__P__VEFPreP1B_8cpp_source.html#l00691">modifier_secmem_aretes()</a>, <a class="el" href="Assembleur__P__VEFPreP1B_8cpp_source.html#l00555">modifier_secmem_elem()</a>, <a class="el" href="Assembleur__P__VEFPreP1B_8cpp_source.html#l00599">modifier_secmem_som()</a>, <a class="el" href="Zone_8h_source.html#l01258">Zone::nb_aretes()</a>, <a class="el" href="Zone__Cl__dis__base_8cpp_source.html#l00603">Zone_Cl_dis_base::nb_cond_lim()</a>, <a class="el" href="DoubleTab_8h_source.html#l00264">DoubleTab::nb_dim()</a>, <a class="el" href="Front__VF_8h_source.html#l00061">Front_VF::nb_faces()</a>, <a class="el" href="Zone_8cpp_source.html#l00586">Zone::nb_som()</a>, <a class="el" href="Front__VF_8h_source.html#l00071">Front_VF::num_premiere_face()</a>, <a class="el" href="Zone__VEF__PreP1b_8h_source.html#l00137">Zone_VEF_PreP1b::numero_premier_sommet()</a>, <a class="el" href="Zone__VEF__PreP1b_8h_source.html#l00146">Zone_VEF_PreP1b::numero_premiere_arete()</a>, <a class="el" href="Zone__VF_8h_source.html#l00285">Zone_VF::porosite_face()</a>, <a class="el" href="Cast_8h_source.html#l00059">ref_cast</a>, <a class="el" href="Cast_8h_source.html#l00054">sub_type</a>, <a class="el" href="Champ__front_8h_source.html#l00030">Deriv_Champ_front_base::valeur()</a>, <a class="el" href="Cond__lim_8h_source.html#l00031">Deriv_Cond_lim_base::valeur()</a>, <a class="el" href="Ref__Zone__Cl__VEF_8h_source.html#l00028">Ref_Zone_Cl_VEF::valeur()</a>, <a class="el" href="Zone__dis__base_8h_source.html#l00106">Zone_dis_base::zone()</a>, and <a class="el" href="Assembleur__P__VEFPreP1B_8cpp_source.html#l00116">zone_Vef()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">const</span> <a class="code" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a>&amp; la_zone = <a class="code" href="classAssembleur__P__VEFPreP1B.html#a3b4a812a062b850be5966f8c6e201cee">zone_Vef</a>();

<span class="comment">// Verification sur le support Pa</span>
  <span class="keywordflow">if</span> (la_zone.<a class="code" href="classZone__VEF__PreP1b.html#a9d02e2431efb6e75c3d733ff06f89549">get_alphaA</a>())
    {
<span class="comment">// Verification sur les aretes que:</span>
      <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; renum_arete_perio=la_zone.<a class="code" href="classZone__VEF__PreP1b.html#a43767f8684512d1ee950dc07eea76c5b">get_renum_arete_perio</a>();
      <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; ok_arete=la_zone.<a class="code" href="classZone__VEF__PreP1b.html#a83771f784d487e346b2ef22a389472a2">get_ok_arete</a>();
      <span class="keywordtype">int</span> npa=la_zone.<a class="code" href="classZone__VEF__PreP1b.html#aa0033e533851a80e958050a0b892e9a8">numero_premiere_arete</a>();
<span class="comment">// b n&#39;a pas forcement son espace virtuel a jour</span>
      <span class="keywordtype">int</span> nb_aretes=la_zone.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#a3e3b48691911fd85574c7bc10a1a4fb8" title="renvoie le nombre d&#39;aretes reelles.">nb_aretes</a>();
      <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;nb_aretes; i++)
        <span class="keywordflow">if</span>(!ok_arete(i) &amp;&amp; b(npa+i)!=0.) <span class="comment">//!&lt; Les aretes superflues ont une valeur nulle</span>
<span class="comment"></span>          {
            <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Pb div Aretes, la pression sur l&#39;arete &quot;</span> &lt;&lt; i &lt;&lt; <span class="stringliteral">&quot; (qui est superflue) n&#39;est pas nulle.&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
            <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">Process::exit</a>();
          }
        <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( (renum_arete_perio(i)!=i) &amp;&amp; b(npa+i)!=0.) <span class="comment">//!&lt; Les aretes periodiques ont une valeur nulle</span>
<span class="comment"></span>          {
            <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Pb div Aretes Perio, la pression sur l&#39;arete &quot;</span> &lt;&lt; i &lt;&lt; <span class="stringliteral">&quot; (qui est periodique) n&#39;est pas nulle.&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
            <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">Process::exit</a>();
          }
    }

<span class="comment">// Verification sur le support P1</span>
  <span class="keywordflow">if</span> (la_zone.<a class="code" href="classZone__VEF__PreP1b.html#ad7fbcb5567dcc2e6f0a0ed85ce90a4fa">get_alphaS</a>())
    {
<span class="comment">// Verification que la pression sur les sommets periodiques est nulle</span>
      <span class="keyword">const</span> <a class="code" href="classDomaine.html" title="Classe Domaine Un Domaine represente le domaine (spatial) de resolution d&#39;un Probleme. Un Domaine a un Nom, il est constitue d&#39;une ou plusieurs Zone qui peuvent etre eventuellement decoupees en Sous_Zone. Un Domaine porte l&#39;ensemble des sommets utilises par ses Zones. On peut vouloir resoudre des problemes de type different sur plusieurs domaines, geometriquement les domaines sont alors couples par des surfaces qu&#39;on appelle Raccord.">Domaine</a>&amp; dom=la_zone.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#a379ad2206b5a13a4f4f3df6d44c7546a" title="Renvoie le domaine dont la zone fait partie. (version const)">domaine</a>();
      <span class="keywordtype">int</span> nps=la_zone.<a class="code" href="classZone__VEF__PreP1b.html#ab469e7b0d67ddcc27e5cf16c3c85e8f4">numero_premier_sommet</a>();
      <span class="keywordtype">int</span> ns=la_zone.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#ad340f571f81fa5c2e028b88c00b5c2ca" title="Renvoie le nombre de sommets de la zone.">nb_som</a>();
      <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;ns; i++)
        {
          <span class="keywordtype">int</span> k=dom.<a class="code" href="classDomaine.html#a37cc657f1907d53b0d5a573da862af80">get_renum_som_perio</a>(i);
          <span class="keywordflow">if</span>((k!=i)&amp;&amp; b(nps+i)!=0.)
            {
              <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Pb div Som, la pression sur le sommet &quot;</span> &lt;&lt; i &lt;&lt; <span class="stringliteral">&quot; (qui est periodique) n&#39;est pas nulle.&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
              <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;En terme clair, le second membre n&#39;est pas nul sur un sommet periodique.&quot;</span> &lt;&lt; finl;
              <span class="keywordflow">if</span> (b(nps+i)!=b(nps+k))
                {
                  <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;En outre, le second membre n&#39;a pas la meme valeur sur les 2 sommets periodiques.&quot;</span> &lt;&lt; finl;
                  <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;b(nps+i)=&quot;</span> &lt;&lt; b(nps+i) &lt;&lt; <span class="stringliteral">&quot; &lt;&gt; b(nps+k)=&quot;</span> &lt;&lt; b(nps+k) &lt;&lt; finl;
                }
              <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Il y&#39;a probabilite que le modele utilise soit mal implemente pour&quot;</span> &lt;&lt; finl;
              <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;une condition de periodicite. Contacter le support TRUST.&quot;</span> &lt;&lt; finl;
              <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">Process::exit</a>();
            }
        }
    }

  <span class="keywordflow">if</span> (<a class="code" href="classAssembleur__base.html#a3744c3df3886e9fc65246c2eb1abb794" title="Renvoie la valeur du drapeau resoudre_en_u_ (0 ou 1) Renvoie -1 si le drapeau n&#39;a pas ete initialise...">get_resoudre_en_u</a>())
    {
      <span class="keyword">const</span> <a class="code" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a>&amp; zone_VEF =  <a class="code" href="classAssembleur__P__VEFPreP1B.html#a3b4a812a062b850be5966f8c6e201cee">zone_Vef</a>();
      <span class="keyword">const</span> <a class="code" href="classZone__Cl__VEF.html">Zone_Cl_VEF</a>&amp; zone_Cl = <a class="code" href="classAssembleur__P__VEF.html#af06d2fedcae0282000a96ddd444ec7a2">la_zone_Cl_VEF</a>.<a class="code" href="classRef__Zone__Cl__VEF.html#a0970d7253def65ad4f0c5ce1830fd243">valeur</a>();

      <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; porosite_face = zone_VEF.<a class="code" href="classZone__VF.html#ad9d74d1d9da9f50ab26768dbbca7711b">porosite_face</a>();

      <span class="keyword">const</span> <span class="keywordtype">int</span> nb_cond_lim = zone_Cl.<a class="code" href="classZone__Cl__dis__base.html#aa6f1df56cfd6e2eae83cc991c7cc9b41" title="Renvoie le nombre de conditions aux limites.">nb_cond_lim</a>();

      <span class="comment">/**************************/</span>
      <span class="comment">/* Recuperation de Gpoint */</span>
      <span class="comment">/**************************/</span>
      <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a> Gpoint(<a class="code" href="classAssembleur__P__VEFPreP1B.html#a9a85837c29e80d1bcbc3a7f740f93807">equation</a>().inconnue().valeurs());
      Gpoint=0.;
      <span class="keywordtype">int</span> Gpoint_nul = 1; <span class="comment">//!&lt; Drapeau pour economiser potentiellement un echange_espace_virtuel</span>
<span class="comment"></span>      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> cond_lim=0; cond_lim&lt;nb_cond_lim; cond_lim++)
        {
          <span class="keyword">const</span> <a class="code" href="classCond__lim__base.html" title="classe Cond_lim_base Classe de base pour la hierarchie des classes qui representent les differentes c...">Cond_lim_base</a>&amp; cl_base = zone_Cl.<a class="code" href="classZone__Cl__dis__base.html#af75e0ed7786863e4d333bfb29d67c323" title="Renvoie la i-ieme condition aux limites. (version const)">les_conditions_limites</a>(cond_lim).<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>();

          <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp; front_VF = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>,cl_base.<a class="code" href="classCond__lim__base.html#ad88b3b516351146c85e8fce1df0f691a" title="Renvoie la frontiere discretisee a laquelle les conditions aux limites s&#39;appliquent.">frontiere_dis</a>());
          <span class="keyword">const</span> <a class="code" href="classChamp__front__base.html" title="classe Champ_front_base Classe de base pour la hierarchie des champs aux frontieres. Un objet Champ_front_base definit un champ sur la frontiere d&#39;un domaine. Un objet de type Champ_front_base sera associe a chaque condition aux limites. Champ_front_base derive de Champ_Proto, afin d&#39;avoir une interface conforme a tous les champs, et d&#39;heriter des operations courantes sur les Champs. Les deux methodes principales sont initialiser et mettre_a_jour. Ce sont les deux seules qui peuvent modifier les valeurs du champ. La methode initialiser est appelee une fois au debut du calcul. Elle ne doit pas dependre de donnees exterieures a l&#39;equation qui porte la CL (en effet, rien ne garantit que ces donnees sont initialisees). En revanche, les valeurs de l&#39;inconnue sur laquelle porte la CL peuvent etre utiles pour l&#39;initialisation =&gt; l&#39;inconnue est passee en parametre en lecture seule. La methode mettre_a_jour est appelee au debut de chaque pas de temps ou sous-pas-de-temps, elle peut utiliser des donnees exterieures a l&#39;equation. A charge a l&#39;algorithme de s&#39;assurer que ces donnees sont pertinentes... Dans le cas de champs stationnaires, la methode mettre_a_jour n&#39;a rien a faire et les valeurs sont remplies une fois pour toutes par la methode initialiser. Dans le cas de champs instationnaires, il y a plusieurs valeurs en temps et chacune peut etre mise a jour. Les Champ_front sont divises en : * Champ_front_uniforme, constant dans le temps et l&#39;espace * Champ_front_instationnaire_base, uniformes en espace mais variables en temps * Champ_front_var, variables en espace. Les Champ_front_var sont ensuite classes selon qu&#39;ils sont stationnaires ou instationnaires. Les valeurs sont stockees dans une roue de DoubleTab. Si le champ est uniforme en espace, les DoubleTab sont dimensionnes a 1. S&#39;il est stationnaire, la roue n&#39;a qu&#39;une valeur temporelle et le temps qui lui est assigne n&#39;a pas de sens. S&#39;il est instationnaire, les valeurs temporelles sont celles de l&#39;inconnue de l&#39;equation a laquelle se rapporte le champ.">Champ_front_base</a>&amp; champ_front = cl_base.<a class="code" href="classCond__lim__base.html#a8cddc02f544ee44bebd5bae0e6a9581c">champ_front</a>().<a class="code" href="classDeriv__Champ__front__base.html#a5405a20c106b868a23805a45c4436a53">valeur</a>();

          <span class="keyword">const</span> <span class="keywordtype">int</span> ndeb = front_VF.<a class="code" href="classFront__VF.html#a4986f0c65653fe9eb40bbbff5a97bf16" title="Numero de la premiere face du bord dans la liste des faces.">num_premiere_face</a>();
          <span class="keyword">const</span> <span class="keywordtype">int</span> nfin = ndeb+front_VF.<a class="code" href="classFront__VF.html#a341e2fcb5117b96e745fd7078ba86bab" title="Nombre de faces reelles du bord.">nb_faces</a>();

          <span class="comment">/* Test sur la nature du champ au bord du domaine */</span>
          <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classEntree__fluide__vitesse__imposee.html" title="classe Entree_fluide_vitesse_imposee Cas particulier de la classe Dirichlet_entree_fluide pour la vit...">Entree_fluide_vitesse_imposee</a>, cl_base))
            {
              <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classChamp__front__instationnaire__base.html" title="classe Champ_front_base Classe de base pour les Champs aux frontieres instationnaires, mais uniformes en espace. Les aspects temporels sont equivalents a ceux de Ch_front_var_instationnaire. En revanche, le tableau de valeurs est dimensionne a une seule valeur et n&#39;a pas d&#39;espace virtuel.">Champ_front_instationnaire_base</a>,champ_front))
                {
                  Gpoint_nul = 0;
                  <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; gpoint =
                    <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classChamp__front__instationnaire__base.html" title="classe Champ_front_base Classe de base pour les Champs aux frontieres instationnaires, mais uniformes en espace. Les aspects temporels sont equivalents a ceux de Ch_front_var_instationnaire. En revanche, le tableau de valeurs est dimensionne a une seule valeur et n&#39;a pas d&#39;espace virtuel.">Champ_front_instationnaire_base</a>,champ_front).Gpoint();

                  assert(gpoint.<a class="code" href="classDoubleTab.html#ae6dda48778e7107e1beb723beef1f75b" title="Returns the number of dimensions of the array (&gt;= 1)">nb_dim</a>()==1);

                  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> num_face=ndeb; num_face&lt;nfin; num_face++)
                    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> dim=0; dim&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>; dim++)
                      Gpoint(num_face,dim)=porosite_face(num_face)*gpoint(dim);

                }<span class="comment">//fin du if sur &quot;sub_type(Champ_front_instationnaire_base)&quot;</span>

              <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classChamp__front__var__instationnaire.html" title="classe Champ_front_var_instationnaire Classe derivee de Champ_front_var qui represente les champs aux...">Champ_front_var_instationnaire</a>,champ_front))
                {
                  Gpoint_nul = 0;
                  <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; gpoint =
                    <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classChamp__front__var__instationnaire.html" title="classe Champ_front_var_instationnaire Classe derivee de Champ_front_var qui represente les champs aux...">Champ_front_var_instationnaire</a>,champ_front).Gpoint();

                  assert(gpoint.<a class="code" href="classDoubleTab.html#ae6dda48778e7107e1beb723beef1f75b" title="Returns the number of dimensions of the array (&gt;= 1)">nb_dim</a>()==2);

                  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> num_face=ndeb; num_face&lt;nfin; num_face++)
                    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> dim=0; dim&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>; dim++)
                      Gpoint(num_face,dim)=porosite_face(num_face)*gpoint(num_face-ndeb,dim);

                }<span class="comment">//fin du if sur &quot;sub_type(Champ_front_var_instationnaire)&quot;</span>

            }<span class="comment">//fin du if sur &quot;sub_type(Entree_fluide_vitesse_imposee)&quot;</span>

        }<span class="comment">//fin du for sur &quot;cond_lim&quot;</span>

<span class="comment">// Pour le parallele</span>
      <span class="keywordflow">if</span> (!Gpoint_nul) Gpoint.echange_espace_virtuel();

      <span class="comment">/******************************/</span>
      <span class="comment">/* Fin recuperation de Gpoint */</span>
      <span class="comment">/******************************/</span>

      <span class="comment">/*********************************/</span>
      <span class="comment">/* Modification du second membre */</span>
      <span class="comment">/*********************************/</span>

      <span class="keywordflow">if</span> (zone_VEF.<a class="code" href="classZone__VEF__PreP1b.html#aee2def53aa92584d7945e7c3d0d98963">get_alphaE</a>()) <a class="code" href="classAssembleur__P__VEFPreP1B.html#a68c56f1db1d79a34135f8f46c293dc83">modifier_secmem_elem</a>(Gpoint,b);
      <span class="keywordflow">if</span> (zone_VEF.<a class="code" href="classZone__VEF__PreP1b.html#ad7fbcb5567dcc2e6f0a0ed85ce90a4fa">get_alphaS</a>()) <a class="code" href="classAssembleur__P__VEFPreP1B.html#a6e9aef242858ae25dde40c58c30791b8">modifier_secmem_som</a>(Gpoint,b);
      <span class="keywordflow">if</span> (zone_VEF.<a class="code" href="classZone__VEF__PreP1b.html#a9d02e2431efb6e75c3d733ff06f89549">get_alphaA</a>()) <a class="code" href="classAssembleur__P__VEFPreP1B.html#a671dcfc1aa964152dbc04bc5c31d196c">modifier_secmem_aretes</a>(Gpoint,b);

      <span class="comment">/**********************************/</span>
      <span class="comment">/* Fin modification second membre */</span>
      <span class="comment">/**********************************/</span>

      b.<a class="code" href="classDoubleVect.html#abfebbc2f685ce7bc4b80c720d7da9bf3">echange_espace_virtuel</a>();
    }

  <span class="keywordflow">return</span> 1;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a671dcfc1aa964152dbc04bc5c31d196c"></a><!-- doxytag: member="Assembleur_P_VEFPreP1B::modifier_secmem_aretes" ref="a671dcfc1aa964152dbc04bc5c31d196c" args="(const DoubleTab &amp;, DoubleTab &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Assembleur_P_VEFPreP1B::modifier_secmem_aretes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>Gpoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Assembleur__P__VEFPreP1B_8cpp_source.html#l00691">691</a> of file <a class="el" href="Assembleur__P__VEFPreP1B_8cpp_source.html">Assembleur_P_VEFPreP1B.cpp</a>.</p>

<p>Referenced by <a class="el" href="Assembleur__P__VEFPreP1B_8cpp_source.html#l00418">modifier_secmem()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">return</span> 1;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a68c56f1db1d79a34135f8f46c293dc83"></a><!-- doxytag: member="Assembleur_P_VEFPreP1B::modifier_secmem_elem" ref="a68c56f1db1d79a34135f8f46c293dc83" args="(const DoubleTab &amp;, DoubleTab &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Assembleur_P_VEFPreP1B::modifier_secmem_elem </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>Gpoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Assembleur__P__VEFPreP1B_8cpp_source.html#l00555">555</a> of file <a class="el" href="Assembleur__P__VEFPreP1B_8cpp_source.html">Assembleur_P_VEFPreP1B.cpp</a>.</p>

<p>References <a class="el" href="Cond__lim__base_8h_source.html#l00196">Cond_lim_base::champ_front()</a>, <a class="el" href="Objet__U_8h_source.html#l00079">Objet_U::dimension</a>, <a class="el" href="Zone__VEF_8h_source.html#l00145">Zone_VEF::face_normales()</a>, <a class="el" href="Zone__VF_8h_source.html#l00458">Zone_VF::face_voisins()</a>, <a class="el" href="Cond__lim__base_8h_source.html#l00123">Cond_lim_base::frontiere_dis()</a>, <a class="el" href="Assembleur__P__VEF_8h_source.html#l00066">Assembleur_P_VEF::la_zone_Cl_VEF</a>, <a class="el" href="Zone__Cl__dis__base_8cpp_source.html#l00522">Zone_Cl_dis_base::les_conditions_limites()</a>, <a class="el" href="Zone__Cl__dis__base_8cpp_source.html#l00603">Zone_Cl_dis_base::nb_cond_lim()</a>, <a class="el" href="Front__VF_8h_source.html#l00066">Front_VF::nb_faces_tot()</a>, <a class="el" href="Front__VF_8h_source.html#l00076">Front_VF::num_face()</a>, <a class="el" href="Cast_8h_source.html#l00059">ref_cast</a>, <a class="el" href="Cast_8h_source.html#l00054">sub_type</a>, <a class="el" href="Champ__front_8h_source.html#l00030">Deriv_Champ_front_base::valeur()</a>, <a class="el" href="Cond__lim_8h_source.html#l00031">Deriv_Cond_lim_base::valeur()</a>, <a class="el" href="Ref__Zone__Cl__VEF_8h_source.html#l00028">Ref_Zone_Cl_VEF::valeur()</a>, and <a class="el" href="Assembleur__P__VEFPreP1B_8cpp_source.html#l00116">zone_Vef()</a>.</p>

<p>Referenced by <a class="el" href="Assembleur__P__VEFPreP1B_8cpp_source.html#l00418">modifier_secmem()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">const</span> <a class="code" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a>&amp; zone_VEF =  <a class="code" href="classAssembleur__P__VEFPreP1B.html#a3b4a812a062b850be5966f8c6e201cee">zone_Vef</a>();
  <span class="keyword">const</span> <a class="code" href="classZone__Cl__VEF.html">Zone_Cl_VEF</a>&amp; zone_Cl = <a class="code" href="classAssembleur__P__VEF.html#af06d2fedcae0282000a96ddd444ec7a2">la_zone_Cl_VEF</a>.<a class="code" href="classRef__Zone__Cl__VEF.html#a0970d7253def65ad4f0c5ce1830fd243">valeur</a>();

  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_cond_lim = zone_Cl.<a class="code" href="classZone__Cl__dis__base.html#aa6f1df56cfd6e2eae83cc991c7cc9b41" title="Renvoie le nombre de conditions aux limites.">nb_cond_lim</a>();

  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; face_voisins = zone_VEF.<a class="code" href="classZone__VF.html#a49d4322f5585a8fa95748ca785b70702" title="renvoie l&#39;element voisin de numface dans la direction i. i=0 : dans le sens oppose de l&#39;axe orthogona...">face_voisins</a>();
  <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; face_normales = zone_VEF.<a class="code" href="classZone__VEF.html#a5742d75972e4846bf9fbb6ed5715053e">face_normales</a>();

  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> cond_lim=0; cond_lim&lt;nb_cond_lim; cond_lim++)
    {
      <span class="keyword">const</span> <a class="code" href="classCond__lim__base.html" title="classe Cond_lim_base Classe de base pour la hierarchie des classes qui representent les differentes c...">Cond_lim_base</a>&amp; cl_base = zone_Cl.<a class="code" href="classZone__Cl__dis__base.html#af75e0ed7786863e4d333bfb29d67c323" title="Renvoie la i-ieme condition aux limites. (version const)">les_conditions_limites</a>(cond_lim).<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>();

      <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp; front_VF = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>,cl_base.<a class="code" href="classCond__lim__base.html#ad88b3b516351146c85e8fce1df0f691a" title="Renvoie la frontiere discretisee a laquelle les conditions aux limites s&#39;appliquent.">frontiere_dis</a>());
      <span class="keyword">const</span> <a class="code" href="classChamp__front__base.html" title="classe Champ_front_base Classe de base pour la hierarchie des champs aux frontieres. Un objet Champ_front_base definit un champ sur la frontiere d&#39;un domaine. Un objet de type Champ_front_base sera associe a chaque condition aux limites. Champ_front_base derive de Champ_Proto, afin d&#39;avoir une interface conforme a tous les champs, et d&#39;heriter des operations courantes sur les Champs. Les deux methodes principales sont initialiser et mettre_a_jour. Ce sont les deux seules qui peuvent modifier les valeurs du champ. La methode initialiser est appelee une fois au debut du calcul. Elle ne doit pas dependre de donnees exterieures a l&#39;equation qui porte la CL (en effet, rien ne garantit que ces donnees sont initialisees). En revanche, les valeurs de l&#39;inconnue sur laquelle porte la CL peuvent etre utiles pour l&#39;initialisation =&gt; l&#39;inconnue est passee en parametre en lecture seule. La methode mettre_a_jour est appelee au debut de chaque pas de temps ou sous-pas-de-temps, elle peut utiliser des donnees exterieures a l&#39;equation. A charge a l&#39;algorithme de s&#39;assurer que ces donnees sont pertinentes... Dans le cas de champs stationnaires, la methode mettre_a_jour n&#39;a rien a faire et les valeurs sont remplies une fois pour toutes par la methode initialiser. Dans le cas de champs instationnaires, il y a plusieurs valeurs en temps et chacune peut etre mise a jour. Les Champ_front sont divises en : * Champ_front_uniforme, constant dans le temps et l&#39;espace * Champ_front_instationnaire_base, uniformes en espace mais variables en temps * Champ_front_var, variables en espace. Les Champ_front_var sont ensuite classes selon qu&#39;ils sont stationnaires ou instationnaires. Les valeurs sont stockees dans une roue de DoubleTab. Si le champ est uniforme en espace, les DoubleTab sont dimensionnes a 1. S&#39;il est stationnaire, la roue n&#39;a qu&#39;une valeur temporelle et le temps qui lui est assigne n&#39;a pas de sens. S&#39;il est instationnaire, les valeurs temporelles sont celles de l&#39;inconnue de l&#39;equation a laquelle se rapporte le champ.">Champ_front_base</a>&amp; champ_front = cl_base.<a class="code" href="classCond__lim__base.html#a8cddc02f544ee44bebd5bae0e6a9581c">champ_front</a>().<a class="code" href="classDeriv__Champ__front__base.html#a5405a20c106b868a23805a45c4436a53">valeur</a>();

      <span class="comment">/* Test sur la nature du champ au bord du domaine */</span>
      <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classEntree__fluide__vitesse__imposee.html" title="classe Entree_fluide_vitesse_imposee Cas particulier de la classe Dirichlet_entree_fluide pour la vit...">Entree_fluide_vitesse_imposee</a>, cl_base))
        {
          <span class="keywordflow">if</span> ( <a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classChamp__front__instationnaire__base.html" title="classe Champ_front_base Classe de base pour les Champs aux frontieres instationnaires, mais uniformes en espace. Les aspects temporels sont equivalents a ceux de Ch_front_var_instationnaire. En revanche, le tableau de valeurs est dimensionne a une seule valeur et n&#39;a pas d&#39;espace virtuel.">Champ_front_instationnaire_base</a>,champ_front) ||
               <a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classChamp__front__var__instationnaire.html" title="classe Champ_front_var_instationnaire Classe derivee de Champ_front_var qui represente les champs aux...">Champ_front_var_instationnaire</a>,champ_front)
             )

            {
<span class="comment">// Construction de la liste des faces a traiter (reelles + virtuelles)</span>
              <span class="keyword">const</span> <span class="keywordtype">int</span> nb_faces_bord_tot = front_VF.<a class="code" href="classFront__VF.html#aed4006d91bf2ef3af2b9f7933d863a09" title="Nombre de faces reelles et virtuelles du bord.">nb_faces_tot</a>();

              <span class="keywordflow">for</span> (<span class="keywordtype">int</span> ind_face=0; ind_face&lt;nb_faces_bord_tot; ind_face++)
                {
                  <span class="keyword">const</span> <span class="keywordtype">int</span> num_face =  front_VF.<a class="code" href="classFront__VF.html#a3402a19d7e54ed797d2b18e9a47ead1e" title="Renvoie le numero de face de la ieme face du bord.">num_face</a>(ind_face);
                  <span class="keyword">const</span> <span class="keywordtype">int</span> elem = face_voisins(num_face,0);
                  assert(elem!=-1);

                  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> dim=0; dim&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>; dim++)
                    b(elem)-=Gpoint(num_face,dim)*face_normales(num_face,dim);
                }
            }
        }
    }

  <span class="keywordflow">return</span> 1;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a6e9aef242858ae25dde40c58c30791b8"></a><!-- doxytag: member="Assembleur_P_VEFPreP1B::modifier_secmem_som" ref="a6e9aef242858ae25dde40c58c30791b8" args="(const DoubleTab &amp;, DoubleTab &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Assembleur_P_VEFPreP1B::modifier_secmem_som </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>Gpoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Assembleur__P__VEFPreP1B_8cpp_source.html#l00599">599</a> of file <a class="el" href="Assembleur__P__VEFPreP1B_8cpp_source.html">Assembleur_P_VEFPreP1B.cpp</a>.</p>

<p>References <a class="el" href="Cond__lim__base_8h_source.html#l00196">Cond_lim_base::champ_front()</a>, <a class="el" href="Objet__U_8h_source.html#l00079">Objet_U::dimension</a>, <a class="el" href="Zone_8cpp_source.html#l00262">Zone::domaine()</a>, <a class="el" href="Zone__VF_8h_source.html#l00574">Zone_VF::elem_faces()</a>, <a class="el" href="Zone__VEF_8h_source.html#l00145">Zone_VEF::face_normales()</a>, <a class="el" href="Zone__VF_8h_source.html#l00609">Zone_VF::face_sommets()</a>, <a class="el" href="Zone__VF_8h_source.html#l00458">Zone_VF::face_voisins()</a>, <a class="el" href="Cond__lim__base_8h_source.html#l00123">Cond_lim_base::frontiere_dis()</a>, <a class="el" href="Zone__VEF__PreP1b_8h_source.html#l00061">Zone_VEF_PreP1b::get_alphaE()</a>, <a class="el" href="Domaine_8h_source.html#l00613">Domaine::get_renum_som_perio()</a>, <a class="el" href="Assembleur__P__VEF_8h_source.html#l00066">Assembleur_P_VEF::la_zone_Cl_VEF</a>, <a class="el" href="Zone__Cl__dis__base_8cpp_source.html#l00522">Zone_Cl_dis_base::les_conditions_limites()</a>, <a class="el" href="Zone_8h_source.html#l00402">Zone::les_elems()</a>, <a class="el" href="Zone__Cl__dis__base_8cpp_source.html#l00603">Zone_Cl_dis_base::nb_cond_lim()</a>, <a class="el" href="Zone_8h_source.html#l00319">Zone::nb_elem_tot()</a>, <a class="el" href="Zone_8h_source.html#l00469">Zone::nb_faces_elem()</a>, <a class="el" href="Front__VF_8h_source.html#l00066">Front_VF::nb_faces_tot()</a>, <a class="el" href="Front__VF_8h_source.html#l00076">Front_VF::num_face()</a>, <a class="el" href="Cast_8h_source.html#l00059">ref_cast</a>, <a class="el" href="Cast_8h_source.html#l00054">sub_type</a>, <a class="el" href="Champ__front_8h_source.html#l00030">Deriv_Champ_front_base::valeur()</a>, <a class="el" href="Cond__lim_8h_source.html#l00031">Deriv_Cond_lim_base::valeur()</a>, <a class="el" href="Ref__Zone__Cl__VEF_8h_source.html#l00028">Ref_Zone_Cl_VEF::valeur()</a>, <a class="el" href="Zone__dis__base_8h_source.html#l00106">Zone_dis_base::zone()</a>, and <a class="el" href="Assembleur__P__VEFPreP1B_8cpp_source.html#l00116">zone_Vef()</a>.</p>

<p>Referenced by <a class="el" href="Assembleur__P__VEFPreP1B_8cpp_source.html#l00418">modifier_secmem()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">const</span> <a class="code" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a>&amp; zone_VEF =  <a class="code" href="classAssembleur__P__VEFPreP1B.html#a3b4a812a062b850be5966f8c6e201cee">zone_Vef</a>();
  <span class="keyword">const</span> <a class="code" href="classZone__Cl__VEF.html">Zone_Cl_VEF</a>&amp; zone_Cl = <a class="code" href="classAssembleur__P__VEF.html#af06d2fedcae0282000a96ddd444ec7a2">la_zone_Cl_VEF</a>.<a class="code" href="classRef__Zone__Cl__VEF.html#a0970d7253def65ad4f0c5ce1830fd243">valeur</a>();
  <span class="keyword">const</span> <a class="code" href="classZone.html" title="classe Zone Une Zone est un maillage compose d&#39;un ensemble d&#39;elements geometriques de meme type...">Zone</a>&amp; zone = zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>();
  <span class="keyword">const</span> <a class="code" href="classDomaine.html" title="Classe Domaine Un Domaine represente le domaine (spatial) de resolution d&#39;un Probleme. Un Domaine a un Nom, il est constitue d&#39;une ou plusieurs Zone qui peuvent etre eventuellement decoupees en Sous_Zone. Un Domaine porte l&#39;ensemble des sommets utilises par ses Zones. On peut vouloir resoudre des problemes de type different sur plusieurs domaines, geometriquement les domaines sont alors couples par des surfaces qu&#39;on appelle Raccord.">Domaine</a>&amp; domaine = zone.<a class="code" href="classZone.html#a379ad2206b5a13a4f4f3df6d44c7546a" title="Renvoie le domaine dont la zone fait partie. (version const)">domaine</a>();

  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_cond_lim = zone_Cl.<a class="code" href="classZone__Cl__dis__base.html#aa6f1df56cfd6e2eae83cc991c7cc9b41" title="Renvoie le nombre de conditions aux limites.">nb_cond_lim</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_elem_tot = (zone_VEF.<a class="code" href="classZone__VEF__PreP1b.html#aee2def53aa92584d7945e7c3d0d98963">get_alphaE</a>()?zone.<a class="code" href="classZone.html#aa3a33e8b723618b9092460007153e42d" title="Renvoie le nombre total d&#39;elements de la zone.">nb_elem_tot</a>():0);
  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_faces_elem = zone.<a class="code" href="classZone.html#a548fbc7518be2f122b1a5c9589a443c2" title="Renvoie le nombre de face de type i des elements geometriques constituants la zone. Ex: les objets de la classe Prisme ont 2 types de faces: triangle ou quadrangle.">nb_faces_elem</a>();

  <span class="keyword">const</span> <span class="keywordtype">double</span> coeff_dim = <a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>*(<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>+1);

  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; elem_faces = zone_VEF.<a class="code" href="classZone__VF.html#a067e462dcd3ab92b0f6d945b19e4eb37" title="renvoie le numero de le ieme face de la maille num_elem la facon dont ces faces sont numerotees est l...">elem_faces</a>();
  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; face_sommets = zone_VEF.<a class="code" href="classZone__VF.html#a298e73b18e17da55f421b1fb0879bd46" title="renvoie le numero du ieme sommet de la face num_face.">face_sommets</a>();
  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; face_voisins = zone_VEF.<a class="code" href="classZone__VF.html#a49d4322f5585a8fa95748ca785b70702" title="renvoie l&#39;element voisin de numface dans la direction i. i=0 : dans le sens oppose de l&#39;axe orthogona...">face_voisins</a>();
  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; elem_sommets = zone.<a class="code" href="classZone.html#ac115e8342be89afb882b7b61cc343267" title="Renvoie le tableau des sommets des elements.">les_elems</a>();

  <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; face_normales = zone_VEF.<a class="code" href="classZone__VEF.html#a5742d75972e4846bf9fbb6ed5715053e">face_normales</a>();
  <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a> sigma(<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>);

  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> cond_lim=0; cond_lim&lt;nb_cond_lim; cond_lim++)
    {
      <span class="keyword">const</span> <a class="code" href="classCond__lim__base.html" title="classe Cond_lim_base Classe de base pour la hierarchie des classes qui representent les differentes c...">Cond_lim_base</a>&amp; cl_base = zone_Cl.<a class="code" href="classZone__Cl__dis__base.html#af75e0ed7786863e4d333bfb29d67c323" title="Renvoie la i-ieme condition aux limites. (version const)">les_conditions_limites</a>(cond_lim).<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>();

      <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp; front_VF = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>,cl_base.<a class="code" href="classCond__lim__base.html#ad88b3b516351146c85e8fce1df0f691a" title="Renvoie la frontiere discretisee a laquelle les conditions aux limites s&#39;appliquent.">frontiere_dis</a>());
      <span class="keyword">const</span> <a class="code" href="classChamp__front__base.html" title="classe Champ_front_base Classe de base pour la hierarchie des champs aux frontieres. Un objet Champ_front_base definit un champ sur la frontiere d&#39;un domaine. Un objet de type Champ_front_base sera associe a chaque condition aux limites. Champ_front_base derive de Champ_Proto, afin d&#39;avoir une interface conforme a tous les champs, et d&#39;heriter des operations courantes sur les Champs. Les deux methodes principales sont initialiser et mettre_a_jour. Ce sont les deux seules qui peuvent modifier les valeurs du champ. La methode initialiser est appelee une fois au debut du calcul. Elle ne doit pas dependre de donnees exterieures a l&#39;equation qui porte la CL (en effet, rien ne garantit que ces donnees sont initialisees). En revanche, les valeurs de l&#39;inconnue sur laquelle porte la CL peuvent etre utiles pour l&#39;initialisation =&gt; l&#39;inconnue est passee en parametre en lecture seule. La methode mettre_a_jour est appelee au debut de chaque pas de temps ou sous-pas-de-temps, elle peut utiliser des donnees exterieures a l&#39;equation. A charge a l&#39;algorithme de s&#39;assurer que ces donnees sont pertinentes... Dans le cas de champs stationnaires, la methode mettre_a_jour n&#39;a rien a faire et les valeurs sont remplies une fois pour toutes par la methode initialiser. Dans le cas de champs instationnaires, il y a plusieurs valeurs en temps et chacune peut etre mise a jour. Les Champ_front sont divises en : * Champ_front_uniforme, constant dans le temps et l&#39;espace * Champ_front_instationnaire_base, uniformes en espace mais variables en temps * Champ_front_var, variables en espace. Les Champ_front_var sont ensuite classes selon qu&#39;ils sont stationnaires ou instationnaires. Les valeurs sont stockees dans une roue de DoubleTab. Si le champ est uniforme en espace, les DoubleTab sont dimensionnes a 1. S&#39;il est stationnaire, la roue n&#39;a qu&#39;une valeur temporelle et le temps qui lui est assigne n&#39;a pas de sens. S&#39;il est instationnaire, les valeurs temporelles sont celles de l&#39;inconnue de l&#39;equation a laquelle se rapporte le champ.">Champ_front_base</a>&amp; champ_front = cl_base.<a class="code" href="classCond__lim__base.html#a8cddc02f544ee44bebd5bae0e6a9581c">champ_front</a>().<a class="code" href="classDeriv__Champ__front__base.html#a5405a20c106b868a23805a45c4436a53">valeur</a>();

      <span class="comment">/* Test sur la nature du champ au bord du domaine */</span>
      <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classEntree__fluide__vitesse__imposee.html" title="classe Entree_fluide_vitesse_imposee Cas particulier de la classe Dirichlet_entree_fluide pour la vit...">Entree_fluide_vitesse_imposee</a>, cl_base))
        {
          <span class="keywordflow">if</span> ( <a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classChamp__front__instationnaire__base.html" title="classe Champ_front_base Classe de base pour les Champs aux frontieres instationnaires, mais uniformes en espace. Les aspects temporels sont equivalents a ceux de Ch_front_var_instationnaire. En revanche, le tableau de valeurs est dimensionne a une seule valeur et n&#39;a pas d&#39;espace virtuel.">Champ_front_instationnaire_base</a>,champ_front) ||
               <a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classChamp__front__var__instationnaire.html" title="classe Champ_front_var_instationnaire Classe derivee de Champ_front_var qui represente les champs aux...">Champ_front_var_instationnaire</a>,champ_front)
             )

            {
<span class="comment">// Construction de la liste des faces a traiter (reelles + virtuelles)</span>
              <span class="keyword">const</span> <span class="keywordtype">int</span> nb_faces_bord_tot = front_VF.<a class="code" href="classFront__VF.html#aed4006d91bf2ef3af2b9f7933d863a09" title="Nombre de faces reelles et virtuelles du bord.">nb_faces_tot</a>();

              <span class="keywordflow">for</span> (<span class="keywordtype">int</span> ind_face=0; ind_face&lt;nb_faces_bord_tot; ind_face++)
                {
                  <span class="keyword">const</span> <span class="keywordtype">int</span> num_face =  front_VF.<a class="code" href="classFront__VF.html#a3402a19d7e54ed797d2b18e9a47ead1e" title="Renvoie le numero de face de la ieme face du bord.">num_face</a>(ind_face);
                  <span class="keyword">const</span> <span class="keywordtype">int</span> elem = face_voisins(num_face,0);
                  assert(elem!=-1);

<span class="comment">// Calcul de la vitesse au centre de l&#39;element</span>
                  sigma=0.;
                  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> face_loc=0; face_loc&lt;nb_faces_elem; face_loc++)
                    {
                      <span class="keyword">const</span> <span class="keywordtype">int</span> face = elem_faces(elem,face_loc);

                      <span class="keywordflow">for</span>(<span class="keywordtype">int</span> comp=0; comp&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; comp++)
                        sigma[comp]+=Gpoint(face,comp);
                    }

<span class="comment">// Calcul de la divergence de la vitesse</span>
                  <span class="keywordflow">for</span>(<span class="keywordtype">int</span> face_loc=0; face_loc&lt;nb_faces_elem; face_loc++)
                    {
                      <span class="keyword">const</span> <span class="keywordtype">int</span> som = nb_elem_tot+domaine.<a class="code" href="classDomaine.html#a37cc657f1907d53b0d5a573da862af80">get_renum_som_perio</a>(elem_sommets(elem,face_loc));
                      <span class="keyword">const</span> <span class="keywordtype">int</span> face = elem_faces(elem,face_loc);

                      <span class="keywordtype">double</span> psc=0;
                      <span class="keywordtype">double</span> signe=1.;
                      <span class="keywordflow">if</span>(elem!=face_voisins(face,0)) signe=-1.;

                      <span class="keywordflow">for</span>(<span class="keywordtype">int</span> comp=0; comp&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; comp++)
                        psc+=sigma[comp]*face_normales(face,comp);

                      b(som)-=signe*psc/coeff_dim;
                    }

                  <span class="keywordtype">double</span> flux = 0. ;
                  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> comp=0; comp&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; comp++)
                    flux += Gpoint(num_face,comp) * face_normales(num_face,comp) ;

                  flux*=1./<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>;
                  <span class="keywordflow">for</span>(<span class="keywordtype">int</span> som_loc=0; som_loc&lt;nb_faces_elem-1; som_loc++)
                    {
                      <span class="keyword">const</span> <span class="keywordtype">int</span> som=domaine.<a class="code" href="classDomaine.html#a37cc657f1907d53b0d5a573da862af80">get_renum_som_perio</a>(face_sommets(num_face,som_loc));
                      b(nb_elem_tot+som)-=flux;
                    }
<span class="comment">// Fin du calcul de la divergence de la vitesse</span>

                }

            }
        }
    }

  <span class="keywordflow">return</span> 1;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a2925a6f043f3422988739a550efb9a4d"></a><!-- doxytag: member="Assembleur_P_VEFPreP1B::modifier_solution" ref="a2925a6f043f3422988739a550efb9a4d" args="(DoubleTab &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Assembleur_P_VEFPreP1B::modifier_solution </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>pression</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="classAssembleur__P__VEF.html#adaac0bfffe8475ab0d133010a4b73c93">Assembleur_P_VEF</a>.</p>

<p>Definition at line <a class="el" href="Assembleur__P__VEFPreP1B_8cpp_source.html#l00696">696</a> of file <a class="el" href="Assembleur__P__VEFPreP1B_8cpp_source.html">Assembleur_P_VEFPreP1B.cpp</a>.</p>

<p>References <a class="el" href="EntreeSortie_8h_source.html#l00032">Cerr</a>, <a class="el" href="Zone_8cpp_source.html#l00262">Zone::domaine()</a>, <a class="el" href="Process_8cpp_source.html#l00223">Process::exit()</a>, <a class="el" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>, <a class="el" href="Zone__VEF__PreP1b_8h_source.html#l00071">Zone_VEF_PreP1b::get_alphaA()</a>, <a class="el" href="Zone__VEF__PreP1b_8h_source.html#l00061">Zone_VEF_PreP1b::get_alphaE()</a>, <a class="el" href="Zone__VEF__PreP1b_8h_source.html#l00066">Zone_VEF_PreP1b::get_alphaS()</a>, <a class="el" href="Zone__VEF__PreP1b_8h_source.html#l00090">Zone_VEF_PreP1b::get_ok_arete()</a>, <a class="el" href="Zone__VEF__PreP1b_8h_source.html#l00086">Zone_VEF_PreP1b::get_renum_arete_perio()</a>, <a class="el" href="Domaine_8h_source.html#l00613">Domaine::get_renum_som_perio()</a>, <a class="el" href="Zone_8cpp_source.html#l00586">Zone::nb_som()</a>, <a class="el" href="Zone__VEF__PreP1b_8h_source.html#l00137">Zone_VEF_PreP1b::numero_premier_sommet()</a>, <a class="el" href="Zone__VEF__PreP1b_8h_source.html#l00146">Zone_VEF_PreP1b::numero_premiere_arete()</a>, <a class="el" href="IntVect_8h_source.html#l00139">IntVect::size()</a>, <a class="el" href="Assembleur__P__VEFPreP1B_8cpp_source.html#l00751">verifier_dirichlet()</a>, <a class="el" href="Zone__dis__base_8h_source.html#l00106">Zone_dis_base::zone()</a>, and <a class="el" href="Assembleur__P__VEFPreP1B_8cpp_source.html#l00116">zone_Vef()</a>.</p>
<div class="fragment"><pre class="fragment">{

<span class="comment">// if (!has_P_ref) exit();</span>
  <span class="keyword">const</span> <a class="code" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a>&amp; la_zone = <a class="code" href="classAssembleur__P__VEFPreP1B.html#a3b4a812a062b850be5966f8c6e201cee">zone_Vef</a>();

<span class="comment">// Verification sur les aretes</span>
  <span class="keywordflow">if</span> (la_zone.<a class="code" href="classZone__VEF__PreP1b.html#a9d02e2431efb6e75c3d733ff06f89549">get_alphaA</a>())
    {
<span class="comment">// On impose la pression a 0 sur les aretes superflues:</span>
      <span class="keyword">const</span> <a class="code" href="classIntVect.html">IntVect</a>&amp; ok_arete=la_zone.<a class="code" href="classZone__VEF__PreP1b.html#a83771f784d487e346b2ef22a389472a2">get_ok_arete</a>();
      <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; renum_arete_perio=la_zone.<a class="code" href="classZone__VEF__PreP1b.html#a43767f8684512d1ee950dc07eea76c5b">get_renum_arete_perio</a>();
<span class="comment">// Nombre d&#39;aretes reelles</span>
      <span class="keywordtype">int</span> nb_aretes=ok_arete.<a class="code" href="classIntVect.html#ad90cfd411cbbd631ccf1935bb36f7c40" title="Identique a size_reelle()">size</a>();
      <span class="keywordtype">int</span> npa=la_zone.<a class="code" href="classZone__VEF__PreP1b.html#aa0033e533851a80e958050a0b892e9a8">numero_premiere_arete</a>();
      <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;nb_aretes; i++)
        {
          <span class="keywordflow">if</span>(!ok_arete(i) &amp;&amp; pression(npa+i)!=0.)
            {
              <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Pb pression arete superflue, P(&quot;</span> &lt;&lt; npa+i &lt;&lt; <span class="stringliteral">&quot;)=&quot;</span> &lt;&lt; pression(npa+i) &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
              pression(npa+i)=0;
              <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">Process::exit</a>();
            }
          <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( (renum_arete_perio(i)!=i) &amp;&amp; pression(npa+i)!=0.)
            {
              <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Pb pression arete superflue periodique, P(&quot;</span> &lt;&lt; npa+i &lt;&lt; <span class="stringliteral">&quot;)=&quot;</span> &lt;&lt; pression(npa+i) &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
              pression(npa+i)=0;
              <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">Process::exit</a>();
            }
        }
    }

<span class="comment">// On applique la periodicite sur les sommets pour la pression:</span>
  <span class="keywordflow">if</span> (la_zone.<a class="code" href="classZone__VEF__PreP1b.html#ad7fbcb5567dcc2e6f0a0ed85ce90a4fa">get_alphaS</a>())
    {
      <span class="keyword">const</span> <a class="code" href="classDomaine.html" title="Classe Domaine Un Domaine represente le domaine (spatial) de resolution d&#39;un Probleme. Un Domaine a un Nom, il est constitue d&#39;une ou plusieurs Zone qui peuvent etre eventuellement decoupees en Sous_Zone. Un Domaine porte l&#39;ensemble des sommets utilises par ses Zones. On peut vouloir resoudre des problemes de type different sur plusieurs domaines, geometriquement les domaines sont alors couples par des surfaces qu&#39;on appelle Raccord.">Domaine</a>&amp; dom=la_zone.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#a379ad2206b5a13a4f4f3df6d44c7546a" title="Renvoie le domaine dont la zone fait partie. (version const)">domaine</a>();
      <span class="keywordtype">int</span> nps=la_zone.<a class="code" href="classZone__VEF__PreP1b.html#ab469e7b0d67ddcc27e5cf16c3c85e8f4">numero_premier_sommet</a>();
      <span class="keywordtype">int</span> ns=la_zone.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#ad340f571f81fa5c2e028b88c00b5c2ca" title="Renvoie le nombre de sommets de la zone.">nb_som</a>();
      <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;ns; i++)
        {
          <span class="keywordtype">int</span> k=dom.<a class="code" href="classDomaine.html#a37cc657f1907d53b0d5a573da862af80">get_renum_som_perio</a>(i);
          <span class="keywordflow">if</span> (k!=i) pression(nps+i)=pression(nps+k);
        }
    }
<span class="comment">// pression.echange_espace_virtuel();</span>
<span class="comment">// pour retirer le min de la pression si pas de Pref et si que PO sinon on filtre plus tard</span>
  <span class="keywordflow">if</span> (la_zone.<a class="code" href="classZone__VEF__PreP1b.html#aee2def53aa92584d7945e7c3d0d98963">get_alphaE</a>() &amp;&amp; (la_zone.<a class="code" href="classZone__VEF__PreP1b.html#ad7fbcb5567dcc2e6f0a0ed85ce90a4fa">get_alphaS</a>()==0) &amp;&amp; (la_zone.<a class="code" href="classZone__VEF__PreP1b.html#a9d02e2431efb6e75c3d733ff06f89549">get_alphaA</a>()==0) )
    <a class="code" href="classAssembleur__P__VEFPreP1B.html#a2925a6f043f3422988739a550efb9a4d">Assembleur_P_VEF::modifier_solution</a>( pression);
<span class="comment">// Verification possible par variable d&#39;environnement:</span>
  <span class="keywordtype">char</span>* theValue = getenv(<span class="stringliteral">&quot;TRUST_VERIFIE_DIRICHLET&quot;</span>);
  <span class="keywordflow">if</span>(theValue != NULL) <a class="code" href="classAssembleur__P__VEFPreP1B.html#acdeef94a4da9a426b6baf0042d9bf2b6">verifier_dirichlet</a>();

  <span class="keywordflow">return</span> 1;
}
</pre></div>
</div>
</div>
<a class="anchor" id="aa5ae1ebda95ccd3d5fa2da3292d2a74c"></a><!-- doxytag: member="Assembleur_P_VEFPreP1B::preparer_solution" ref="aa5ae1ebda95ccd3d5fa2da3292d2a74c" args="(DoubleTab &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Assembleur_P_VEFPreP1B::preparer_solution </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="abc6e9cb293d2b22bf8cc58714062aac2"></a><!-- doxytag: member="Assembleur_P_VEFPreP1B::printOn" ref="abc6e9cb293d2b22bf8cc58714062aac2" args="(Sortie &amp;x) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSortie.html">Sortie</a> &amp; Assembleur_P_VEFPreP1B::printOn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSortie.html">Sortie</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td> const<code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Ecriture de l'objet sur un flot de sortie<br/>
Methode a surcharger. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="classSortie.html" title="Classe de base des flux de sortie. Elle sait ecrire des types simples&lt;br&gt;(entiers, flottants) et des Ob...">Sortie</a>&amp;<br/>
 Signification: flot de sortie modifie<br/>
 Contraintes: </dd></dl>

<p>Reimplemented from <a class="el" href="classAssembleur__P__VEF.html#a464da73b1b9f394966987002c49fc8aa">Assembleur_P_VEF</a>.</p>

<p>Definition at line <a class="el" href="Assembleur__P__VEFPreP1B_8cpp_source.html#l00053">53</a> of file <a class="el" href="Assembleur__P__VEFPreP1B_8cpp_source.html">Assembleur_P_VEFPreP1B.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">return</span> <a class="code" href="classAssembleur__P__VEFPreP1B.html#abc6e9cb293d2b22bf8cc58714062aac2" title="Ecriture de l&#39;objet sur un flot de sortie Methode a surcharger.">Assembleur_base::printOn</a>(s);
}
</pre></div>
</div>
</div>
<a class="anchor" id="ad322061530a77e3541d562700b900641"></a><!-- doxytag: member="Assembleur_P_VEFPreP1B::projete_L2" ref="ad322061530a77e3541d562700b900641" args="(DoubleTab &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Assembleur_P_VEFPreP1B::projete_L2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>pression</em></td><td>)</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Assembleur__P__VEFPreP1B_8cpp_source.html#l00828">828</a> of file <a class="el" href="Assembleur__P__VEFPreP1B_8cpp_source.html">Assembleur_P_VEFPreP1B.cpp</a>.</p>

<p>References <a class="el" href="EntreeSortie_8h_source.html#l00032">Cerr</a>, <a class="el" href="Objet__U_8h_source.html#l00079">Objet_U::dimension</a>, <a class="el" href="Process_8cpp_source.html#l00223">Process::exit()</a>, <a class="el" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>, <a class="el" href="Zone_8h_source.html#l00402">Zone::les_elems()</a>, <a class="el" href="Zone_8h_source.html#l00300">Zone::nb_elem()</a>, <a class="el" href="Zone_8h_source.html#l00319">Zone::nb_elem_tot()</a>, <a class="el" href="Zone_8h_source.html#l00445">Zone::nb_som_elem()</a>, <a class="el" href="Zone_8cpp_source.html#l00608">Zone::nb_som_tot()</a>, <a class="el" href="Zone__VF_8h_source.html#l00419">Zone_VF::volumes()</a>, <a class="el" href="Zone__dis__base_8h_source.html#l00106">Zone_dis_base::zone()</a>, and <a class="el" href="Assembleur__P__VEFPreP1B_8cpp_source.html#l00116">zone_Vef()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">if</span> (<a class="code" href="classAssembleur__P__VEFPreP1B.html#a3b4a812a062b850be5966f8c6e201cee">zone_Vef</a>().get_alphaE()+<a class="code" href="classAssembleur__P__VEFPreP1B.html#a3b4a812a062b850be5966f8c6e201cee">zone_Vef</a>().get_alphaS()+<a class="code" href="classAssembleur__P__VEFPreP1B.html#a3b4a812a062b850be5966f8c6e201cee">zone_Vef</a>().get_alphaA()!=3)
    {
      <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Assembleur_P_VEFPreP1B::projete_L2 ne fonctionne qu&#39;en P0+P1+Pa&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
      <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">Process::exit</a>();
    }
<span class="comment">// Cerr &lt;&lt; &quot;Projection L2&quot; &lt;&lt; finl;</span>
  <span class="keyword">const</span> <a class="code" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a>&amp; zone_vef = <a class="code" href="classAssembleur__P__VEFPreP1B.html#a3b4a812a062b850be5966f8c6e201cee">zone_Vef</a>();
  <span class="keyword">const</span> <a class="code" href="classZone.html" title="classe Zone Une Zone est un maillage compose d&#39;un ensemble d&#39;elements geometriques de meme type...">Zone</a>&amp; zone = zone_vef.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>();
  <span class="keywordtype">int</span> nb_elem_tot=zone.<a class="code" href="classZone.html#aa3a33e8b723618b9092460007153e42d" title="Renvoie le nombre total d&#39;elements de la zone.">nb_elem_tot</a>();
  <span class="keywordtype">int</span> ns=zone.<a class="code" href="classZone.html#a01ed67af826d6045ef4eacfb87a663e8" title="Renvoie le nombre total de sommets de la zone. i.e. le nombre de sommets reels et virtuels sur le pro...">nb_som_tot</a>();
  <span class="keywordtype">int</span> nb_elem=zone.<a class="code" href="classZone.html#a7f249429803b27139a1c54436f6164a5" title="Renvoie le nombre d&#39;elements de la zone.">nb_elem</a>();
  <span class="keywordtype">int</span> i,j;
  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; som_elem=zone_vef.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#ac115e8342be89afb882b7b61cc343267" title="Renvoie le tableau des sommets des elements.">les_elems</a>();
  <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; volumes=zone_vef.<a class="code" href="classZone__VF.html#aea771c835e561469d2d21dbca5fac1cf" title="renvoie le volume de la maille i.">volumes</a>();
  <span class="keywordtype">double</span> volume_tot=0;
  <span class="keywordtype">double</span> somme=0;
  <span class="keywordtype">int</span> nsr=nb_elem_tot+ns;
  <span class="keywordtype">int</span> nse=zone.<a class="code" href="classZone.html#ae0b34a93b9ae8146df2d1884157afe9f" title="Renvoie le nombre de sommets des elements geometriques constituants la zone. Tous les elements de la ...">nb_som_elem</a>();
  <span class="keywordflow">for</span>(i=nb_elem_tot; i&lt;nsr; i++)
    somme+=pression(i);
  somme/=ns;
  <span class="keywordflow">for</span>(i=nb_elem_tot; i&lt;nsr; i++)
    pression(i)-=somme;
  <span class="keyword">static</span> <span class="keywordtype">double</span> dalpha =(1./<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>*(<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>+1));
  <span class="keywordtype">double</span> pmoy=0;
  <span class="keywordflow">for</span>(i=0; i&lt;nb_elem; i++)
    {
      <span class="keywordtype">double</span> p=pression(i);
      <span class="keywordtype">double</span> v=volumes(i);
      <span class="keywordflow">for</span>(j=0; j&lt;nse; j++)
        p+=pression(nb_elem_tot+som_elem(i,j))*dalpha;
      pmoy+=p*v;
      volume_tot+=v;
    }
  pmoy/=volume_tot;
  <span class="keywordflow">for</span>(i=0; i&lt;nb_elem; i++)
    pression(i)-=pmoy;
}
</pre></div>
</div>
</div>
<a class="anchor" id="afbf05fd27ad04d93fc5396a8a9dd0bd7"></a><!-- doxytag: member="Assembleur_P_VEFPreP1B::readOn" ref="afbf05fd27ad04d93fc5396a8a9dd0bd7" args="(Entree &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEntree.html">Entree</a> &amp; Assembleur_P_VEFPreP1B::readOn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEntree.html">Entree</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Lecture d'un <a class="el" href="classObjet__U.html" title="classe Objet_U Cette classe est la classe de base des Objets de TRUST Dans les classes derivees de Ob...">Objet_U</a> sur un flot d'entree<br/>
Methode a surcharger. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="classEntree.html" title="Classe de definition des operateurs et methodes pour toute lecture dans un flot d&#39;entree (fichier...">Entree</a>&amp; s<br/>
 Signification: flot d'entree modifie<br/>
 Contraintes: </dd></dl>

<p>Reimplemented from <a class="el" href="classAssembleur__P__VEF.html#a94600719cd0128f8641649e5efb2bbd0">Assembleur_P_VEF</a>.</p>

<p>Definition at line <a class="el" href="Assembleur__P__VEFPreP1B_8cpp_source.html#l00058">58</a> of file <a class="el" href="Assembleur__P__VEFPreP1B_8cpp_source.html">Assembleur_P_VEFPreP1B.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">return</span> <a class="code" href="classAssembleur__P__VEFPreP1B.html#afbf05fd27ad04d93fc5396a8a9dd0bd7" title="Lecture d&#39;un Objet_U sur un flot d&#39;entree Methode a surcharger.">Assembleur_base::readOn</a>(is);
}
</pre></div>
</div>
</div>
<a class="anchor" id="ac30d27370b49bb28d3bf677ee2dafdf0"></a><!-- doxytag: member="Assembleur_P_VEFPreP1B::self_cast" ref="ac30d27370b49bb28d3bf677ee2dafdf0" args="(const Objet_U &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classAssembleur__P__VEFPreP1B.html">Assembleur_P_VEFPreP1B</a> &amp; Assembleur_P_VEFPreP1B::self_cast </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classObjet__U.html">Objet_U</a> &amp;&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>methode ajoutee pour caster en python </p>

<p>Reimplemented from <a class="el" href="classAssembleur__P__VEF.html#aaef0b156f29e247a4b9c2a693e982f58">Assembleur_P_VEF</a>.</p>

<p>Definition at line <a class="el" href="Assembleur__P__VEFPreP1B_8cpp_source.html#l00049">49</a> of file <a class="el" href="Assembleur__P__VEFPreP1B_8cpp_source.html">Assembleur_P_VEFPreP1B.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="aed8cf8feed6a9b7e17142d967662fabe"></a><!-- doxytag: member="Assembleur_P_VEFPreP1B::self_cast" ref="aed8cf8feed6a9b7e17142d967662fabe" args="(Objet_U &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAssembleur__P__VEFPreP1B.html">Assembleur_P_VEFPreP1B</a> &amp; Assembleur_P_VEFPreP1B::self_cast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classObjet__U.html">Objet_U</a> &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="classAssembleur__P__VEF.html#a2deb32007ca9222731321c446be69409">Assembleur_P_VEF</a>.</p>

<p>Definition at line <a class="el" href="Assembleur__P__VEFPreP1B_8cpp_source.html#l00049">49</a> of file <a class="el" href="Assembleur__P__VEFPreP1B_8cpp_source.html">Assembleur_P_VEFPreP1B.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab1128243c69096b51e7b16ff8a029fb3"></a><!-- doxytag: member="Assembleur_P_VEFPreP1B::taille_memoire" ref="ab1128243c69096b51e7b16ff8a029fb3" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned Assembleur_P_VEFPreP1B::taille_memoire </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="classAssembleur__P__VEF.html#aa6b9c4f3ab041b02f173917a33d11e19">Assembleur_P_VEF</a>.</p>

<p>Definition at line <a class="el" href="Assembleur__P__VEFPreP1B_8cpp_source.html#l00049">49</a> of file <a class="el" href="Assembleur__P__VEFPreP1B_8cpp_source.html">Assembleur_P_VEFPreP1B.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="acdeef94a4da9a426b6baf0042d9bf2b6"></a><!-- doxytag: member="Assembleur_P_VEFPreP1B::verifier_dirichlet" ref="acdeef94a4da9a426b6baf0042d9bf2b6" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Assembleur_P_VEFPreP1B::verifier_dirichlet </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Assembleur__P__VEFPreP1B_8cpp_source.html#l00751">751</a> of file <a class="el" href="Assembleur__P__VEFPreP1B_8cpp_source.html">Assembleur_P_VEFPreP1B.cpp</a>.</p>

<p>References <a class="el" href="Zone_8h_source.html#l01290">Zone::aretes_som()</a>, <a class="el" href="EntreeSortie_8h_source.html#l00032">Cerr</a>, <a class="el" href="Objet__U_8h_source.html#l00079">Objet_U::dimension</a>, <a class="el" href="Zone_8h_source.html#l01282">Zone::elem_aretes()</a>, <a class="el" href="Process_8cpp_source.html#l00223">Process::exit()</a>, <a class="el" href="Zone__VF_8h_source.html#l00609">Zone_VF::face_sommets()</a>, <a class="el" href="Zone__VF_8h_source.html#l00458">Zone_VF::face_voisins()</a>, <a class="el" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>, <a class="el" href="Cond__lim_8h_source.html#l00130">Cond_lim::frontiere_dis()</a>, <a class="el" href="Zone__VEF__PreP1b_8h_source.html#l00090">Zone_VEF_PreP1b::get_ok_arete()</a>, <a class="el" href="Assembleur__P__VEF_8h_source.html#l00066">Assembleur_P_VEF::la_zone_Cl_VEF</a>, <a class="el" href="Zone__Cl__dis__base_8cpp_source.html#l00522">Zone_Cl_dis_base::les_conditions_limites()</a>, <a class="el" href="Assembleur__P__VEFPreP1B_8h_source.html#l00077">mon_equation</a>, <a class="el" href="Front__VF_8h_source.html#l00061">Front_VF::nb_faces()</a>, <a class="el" href="Front__VF_8h_source.html#l00071">Front_VF::num_premiere_face()</a>, <a class="el" href="Cast_8h_source.html#l00059">ref_cast</a>, <a class="el" href="vect__impl_8h_source.html#l00057">vect_impl::size()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00342">ArrOfInt::size_array()</a>, <a class="el" href="Cast_8h_source.html#l00054">sub_type</a>, <a class="el" href="Ref__Equation__base_8h_source.html#l00028">Ref_Equation_base::valeur()</a>, <a class="el" href="Cond__lim_8h_source.html#l00031">Deriv_Cond_lim_base::valeur()</a>, <a class="el" href="Ref__Zone__Cl__VEF_8h_source.html#l00028">Ref_Zone_Cl_VEF::valeur()</a>, <a class="el" href="Zone__dis__base_8h_source.html#l00106">Zone_dis_base::zone()</a>, and <a class="el" href="Assembleur__P__VEFPreP1B_8cpp_source.html#l00116">zone_Vef()</a>.</p>

<p>Referenced by <a class="el" href="Assembleur__P__VEFPreP1B_8cpp_source.html#l00696">modifier_solution()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">if</span> (<a class="code" href="classAssembleur__P__VEFPreP1B.html#a3b4a812a062b850be5966f8c6e201cee">zone_Vef</a>().get_alphaE()+<a class="code" href="classAssembleur__P__VEFPreP1B.html#a3b4a812a062b850be5966f8c6e201cee">zone_Vef</a>().get_alphaS()+<a class="code" href="classAssembleur__P__VEFPreP1B.html#a3b4a812a062b850be5966f8c6e201cee">zone_Vef</a>().get_alphaA()!=<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>)
    {
      <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Assembleur_P_VEFPreP1B::verifier_dirichlet ne fonctionne pas encore avec votre discretisation&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
      <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">Process::exit</a>();
    }
<span class="comment">// Verifications diverses des conditions limites</span>
<span class="comment">// en postraitant le resultat dans le champ Divergence_U</span>
  <a class="code" href="classIntVect.html">IntVect</a> Faces_de_Dirichlet(<a class="code" href="classAssembleur__P__VEFPreP1B.html#a3b4a812a062b850be5966f8c6e201cee">zone_Vef</a>().nb_elem_tot());
  <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a> faces(<a class="code" href="classAssembleur__P__VEFPreP1B.html#a3b4a812a062b850be5966f8c6e201cee">zone_Vef</a>().nb_elem_tot(),2);
  faces=-1;
  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; face_sommets=<a class="code" href="classAssembleur__P__VEFPreP1B.html#a3b4a812a062b850be5966f8c6e201cee">zone_Vef</a>().<a class="code" href="classZone__VF.html#a298e73b18e17da55f421b1fb0879bd46" title="renvoie le numero du ieme sommet de la face num_face.">face_sommets</a>();
  Faces_de_Dirichlet=0;
  <span class="keyword">const</span> <a class="code" href="classConds__lim.html">Conds_lim</a>&amp; les_cl = <a class="code" href="classAssembleur__P__VEF.html#af06d2fedcae0282000a96ddd444ec7a2">la_zone_Cl_VEF</a>.<a class="code" href="classRef__Zone__Cl__VEF.html#a0970d7253def65ad4f0c5ce1830fd243">valeur</a>().<a class="code" href="classZone__Cl__dis__base.html#af75e0ed7786863e4d333bfb29d67c323" title="Renvoie la i-ieme condition aux limites. (version const)">les_conditions_limites</a>();
  <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;les_cl.<a class="code" href="classvect__impl.html#a78155bfbd6b61f4710b9830641ed1694">size</a>(); i++)
    {
      <span class="keyword">const</span> <a class="code" href="classCond__lim.html" title="classe Cond_lim Classe generique servant a representer n&#39;importe quelle classe derivee de la classe C...">Cond_lim</a>&amp; la_cl = les_cl[i];
      <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp; le_bord = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>,la_cl.<a class="code" href="classCond__lim.html#a5b2d24809cee07727006a891d4ce8d22" title="Appel a l&#39;objet sous-jacent Renvoie la frontiere discretisee associee a la condition aux limites...">frontiere_dis</a>());
      <span class="keywordtype">int</span> num1 = le_bord.<a class="code" href="classFront__VF.html#a4986f0c65653fe9eb40bbbff5a97bf16" title="Numero de la premiere face du bord dans la liste des faces.">num_premiere_face</a>();
      <span class="keywordtype">int</span> num2 = num1 + le_bord.<a class="code" href="classFront__VF.html#a341e2fcb5117b96e745fd7078ba86bab" title="Nombre de faces reelles du bord.">nb_faces</a>();
      <span class="keywordflow">if</span> ((<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classDirichlet.html" title="classe Dirichlet Cette classe est la classe de base de la hierarchie des conditions aux limites de ty...">Dirichlet</a>, la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>()))
          || (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classDirichlet__homogene.html" title="Classe Dirichlet_homogene Cette classe est la classe de base de la hierarchie des conditions aux limi...">Dirichlet_homogene</a>, la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>())))
        {
          <span class="keywordflow">for</span> (<span class="keywordtype">int</span> face=num1; face&lt;num2; face++)
            {
              <span class="keywordtype">int</span> elem=<a class="code" href="classAssembleur__P__VEFPreP1B.html#a3b4a812a062b850be5966f8c6e201cee">zone_Vef</a>().<a class="code" href="classZone__VF.html#a49d4322f5585a8fa95748ca785b70702" title="renvoie l&#39;element voisin de numface dans la direction i. i=0 : dans le sens oppose de l&#39;axe orthogona...">face_voisins</a>(face,0);
              <span class="keywordflow">if</span> (elem!=-1)
                {
                  Faces_de_Dirichlet(elem)++;
                  <span class="keywordflow">if</span> (faces(elem,0)==-1) faces(elem,0)=face;
                  <span class="keywordflow">else</span> faces(elem,1)=face;

                }
              elem=<a class="code" href="classAssembleur__P__VEFPreP1B.html#a3b4a812a062b850be5966f8c6e201cee">zone_Vef</a>().<a class="code" href="classZone__VF.html#a49d4322f5585a8fa95748ca785b70702" title="renvoie l&#39;element voisin de numface dans la direction i. i=0 : dans le sens oppose de l&#39;axe orthogona...">face_voisins</a>(face,1);
              <span class="keywordflow">if</span> (elem!=-1) Faces_de_Dirichlet(elem)++;
            }
        }
    }
  <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; post=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classNavier__Stokes__std.html" title="classe Navier_Stokes_std Cette classe porte les termes de l&#39;equation de la dynamique pour un fluide s...">Navier_Stokes_std</a>,<a class="code" href="classAssembleur__P__VEFPreP1B.html#a75f504c4171787bdeb487a8dd98e2a00">mon_equation</a>.<a class="code" href="classRef__Equation__base.html#a7bb6fb60cb55bef0eef1b0e8718300a4">valeur</a>()).div().valeurs();
  post=0;
  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> elem=0; elem&lt;Faces_de_Dirichlet.size_array(); elem++)
    {
<span class="comment">// post(elem)=Faces_de_Dirichlet(elem);</span>
      <span class="keywordflow">if</span> (Faces_de_Dirichlet(elem)&gt;1)
        {
          <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;L&#39;element &quot;</span> &lt;&lt; elem &lt;&lt; <span class="stringliteral">&quot; a &quot;</span> &lt;&lt; Faces_de_Dirichlet(elem) &lt;&lt; <span class="stringliteral">&quot; faces de Dirichlet separees par une &quot;</span>;
          <span class="keyword">const</span> <a class="code" href="classIntVect.html">IntVect</a>&amp; ok_arete=<a class="code" href="classAssembleur__P__VEFPreP1B.html#a3b4a812a062b850be5966f8c6e201cee">zone_Vef</a>().<a class="code" href="classZone__VEF__PreP1b.html#a83771f784d487e346b2ef22a389472a2">get_ok_arete</a>();
          <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; aretes_som=<a class="code" href="classAssembleur__P__VEFPreP1B.html#a3b4a812a062b850be5966f8c6e201cee">zone_Vef</a>().<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#affa60690e1b372fa4c01d6088267dbe4" title="renvoie le tableau de connectivite aretes/sommets.">aretes_som</a>();
<span class="comment">// Parcours des aretes pour verifier les aretes de bord</span>
          <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k=0; k&lt;6; k++)
            {
              <span class="keywordtype">int</span> arete=<a class="code" href="classAssembleur__P__VEFPreP1B.html#a3b4a812a062b850be5966f8c6e201cee">zone_Vef</a>().<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#a1e1e86ef5b088c4d33d42cd38a967b4a" title="renvoie le numero de la jeme arete du ieme element.">elem_aretes</a>(elem,k);
<span class="comment">// Les 2 sommets de l&#39;arete</span>
              <span class="keywordtype">int</span> S0=aretes_som(arete,0);
              <span class="keywordtype">int</span> S1=aretes_som(arete,1);
<span class="comment">// On verifie s&#39;ils sont 2 fois dans les sommets des faces</span>
<span class="comment">// auquels cas c&#39;est l&#39;arete qui partage 2 faces de Dirichlet</span>
              <span class="keywordtype">int</span> ok=0;
              <span class="keywordflow">for</span> (<span class="keywordtype">int</span> l=0; l&lt;2; l++)
                {
                  <span class="keywordtype">int</span> face=faces(elem,l);
                  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> s=0; s&lt;3; s++)
                    {
                      <span class="keywordflow">if</span> (face_sommets(face,s)==S0) ok++;
                      <span class="keywordflow">if</span> (face_sommets(face,s)==S1) ok++;
                    }
                }
              <span class="keywordflow">if</span> (ok==4) <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;arete &quot;</span> &lt;&lt; (ok_arete(arete)==0?<span class="stringliteral">&quot;superflue&quot;</span>:<span class="stringliteral">&quot;&quot;</span>) &lt;&lt; finl;
<span class="comment">// On compte les aretes superflues</span>
              post(elem)+=(ok_arete(arete)==0);
            }
<span class="comment">// Process::exit();</span>
        }
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a3b4a812a062b850be5966f8c6e201cee"></a><!-- doxytag: member="Assembleur_P_VEFPreP1B::zone_Vef" ref="a3b4a812a062b850be5966f8c6e201cee" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a> &amp; Assembleur_P_VEFPreP1B::zone_Vef </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Assembleur__P__VEFPreP1B_8cpp_source.html#l00116">116</a> of file <a class="el" href="Assembleur__P__VEFPreP1B_8cpp_source.html">Assembleur_P_VEFPreP1B.cpp</a>.</p>

<p>References <a class="el" href="Assembleur__P__VEF_8h_source.html#l00065">Assembleur_P_VEF::la_zone_VEF</a>, <a class="el" href="Cast_8h_source.html#l00059">ref_cast</a>, and <a class="el" href="Ref__Zone__VEF_8h_source.html#l00028">Ref_Zone_VEF::valeur()</a>.</p>

<p>Referenced by <a class="el" href="Assembleur__P__VEFPreP1B_8cpp_source.html#l00230">assembler_mat()</a>, <a class="el" href="Assembleur__P__VEFPreP1B_8cpp_source.html#l00192">assembler_rho_variable()</a>, <a class="el" href="Assembleur__P__VEFPreP1B_8cpp_source.html#l01172">changer_base_matrice()</a>, <a class="el" href="Assembleur__P__VEFPreP1B_8cpp_source.html#l01239">changer_base_pression()</a>, <a class="el" href="Assembleur__P__VEFPreP1B_8cpp_source.html#l01217">changer_base_pression_inverse()</a>, <a class="el" href="Assembleur__P__VEFPreP1B_8cpp_source.html#l01196">changer_base_second_membre()</a>, <a class="el" href="Assembleur__P__VEFPreP1B_8cpp_source.html#l00100">completer()</a>, <a class="el" href="Assembleur__P__VEFPreP1B_8cpp_source.html#l00880">modifier_matrice()</a>, <a class="el" href="Assembleur__P__VEFPreP1B_8cpp_source.html#l00418">modifier_secmem()</a>, <a class="el" href="Assembleur__P__VEFPreP1B_8cpp_source.html#l00555">modifier_secmem_elem()</a>, <a class="el" href="Assembleur__P__VEFPreP1B_8cpp_source.html#l00599">modifier_secmem_som()</a>, <a class="el" href="Assembleur__P__VEFPreP1B_8cpp_source.html#l00696">modifier_solution()</a>, <a class="el" href="Assembleur__P__VEFPreP1B_8cpp_source.html#l00828">projete_L2()</a>, and <a class="el" href="Assembleur__P__VEFPreP1B_8cpp_source.html#l00751">verifier_dirichlet()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">return</span> <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a>, <a class="code" href="classAssembleur__P__VEF.html#ae16d976e530b6785006bf62384354ea7">la_zone_VEF</a>.<a class="code" href="classRef__Zone__VEF.html#aafd9a5ee1a76f290c9c6b5447b0c8d30">valeur</a>());
}
</pre></div>
</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="ae3dad2978525b28edcb08db30d0ce641"></a><!-- doxytag: member="Assembleur_P_VEFPreP1B::alpha" ref="ae3dad2978525b28edcb08db30d0ce641" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classAssembleur__P__VEFPreP1B.html#ae3dad2978525b28edcb08db30d0ce641">Assembleur_P_VEFPreP1B::alpha</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Assembleur__P__VEFPreP1B_8h_source.html#l00079">79</a> of file <a class="el" href="Assembleur__P__VEFPreP1B_8h_source.html">Assembleur_P_VEFPreP1B.h</a>.</p>

<p>Referenced by <a class="el" href="Assembleur__P__VEFPreP1B_8cpp_source.html#l01172">changer_base_matrice()</a>, <a class="el" href="Assembleur__P__VEFPreP1B_8cpp_source.html#l01239">changer_base_pression()</a>, <a class="el" href="Assembleur__P__VEFPreP1B_8cpp_source.html#l01217">changer_base_pression_inverse()</a>, <a class="el" href="Assembleur__P__VEFPreP1B_8cpp_source.html#l01196">changer_base_second_membre()</a>, and <a class="el" href="Assembleur__P__VEFPreP1B_8cpp_source.html#l00100">completer()</a>.</p>

</div>
</div>
<a class="anchor" id="a411ad82b856d17a1c8d942728a48f9a0"></a><!-- doxytag: member="Assembleur_P_VEFPreP1B::beta" ref="a411ad82b856d17a1c8d942728a48f9a0" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classAssembleur__P__VEFPreP1B.html#a411ad82b856d17a1c8d942728a48f9a0">Assembleur_P_VEFPreP1B::beta</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Coefficients du changement de base P0+P1&lt;-&gt;P1Bulle. </p>

<p>Definition at line <a class="el" href="Assembleur__P__VEFPreP1B_8h_source.html#l00079">79</a> of file <a class="el" href="Assembleur__P__VEFPreP1B_8h_source.html">Assembleur_P_VEFPreP1B.h</a>.</p>

<p>Referenced by <a class="el" href="Assembleur__P__VEFPreP1B_8h_source.html#l00062">changement_base()</a>, <a class="el" href="Assembleur__P__VEFPreP1B_8cpp_source.html#l01172">changer_base_matrice()</a>, <a class="el" href="Assembleur__P__VEFPreP1B_8cpp_source.html#l01239">changer_base_pression()</a>, <a class="el" href="Assembleur__P__VEFPreP1B_8cpp_source.html#l01217">changer_base_pression_inverse()</a>, <a class="el" href="Assembleur__P__VEFPreP1B_8cpp_source.html#l01196">changer_base_second_membre()</a>, and <a class="el" href="Assembleur__P__VEFPreP1B_8cpp_source.html#l00100">completer()</a>.</p>

</div>
</div>
<a class="anchor" id="aff05bc1b054979ca8b6c7a2ab8aa9d2c"></a><!-- doxytag: member="Assembleur_P_VEFPreP1B::info_obj" ref="aff05bc1b054979ca8b6c7a2ab8aa9d2c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classType__info.html">Type_info</a> <a class="el" href="classAssembleur__P__VEFPreP1B.html#aff05bc1b054979ca8b6c7a2ab8aa9d2c">Assembleur_P_VEFPreP1B::info_obj</a><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="classAssembleur__P__VEF.html#a6af5cb9211b1bbc524aa9dcece727ae3">Assembleur_P_VEF</a>.</p>

<p>Definition at line <a class="el" href="Assembleur__P__VEFPreP1B_8h_source.html#l00034">34</a> of file <a class="el" href="Assembleur__P__VEFPreP1B_8h_source.html">Assembleur_P_VEFPreP1B.h</a>.</p>

</div>
</div>
<a class="anchor" id="a0b6f503b0a0af64037b281637f170661"></a><!-- doxytag: member="Assembleur_P_VEFPreP1B::init" ref="a0b6f503b0a0af64037b281637f170661" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classAssembleur__P__VEFPreP1B.html#a0b6f503b0a0af64037b281637f170661">Assembleur_P_VEFPreP1B::init</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Assembleur__P__VEFPreP1B_8h_source.html#l00076">76</a> of file <a class="el" href="Assembleur__P__VEFPreP1B_8h_source.html">Assembleur_P_VEFPreP1B.h</a>.</p>

</div>
</div>
<a class="anchor" id="a5d22f81d5f579074de9324230e3ff45f"></a><!-- doxytag: member="Assembleur_P_VEFPreP1B::la_matrice_de_travail_" ref="a5d22f81d5f579074de9324230e3ff45f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMatrice.html">Matrice</a> <a class="el" href="classAssembleur__P__VEFPreP1B.html#a5d22f81d5f579074de9324230e3ff45f">Assembleur_P_VEFPreP1B::la_matrice_de_travail_</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><a class="el" href="classMatrice.html">Matrice</a> de travail. </p>

<p>Definition at line <a class="el" href="Assembleur__P__VEFPreP1B_8h_source.html#l00072">72</a> of file <a class="el" href="Assembleur__P__VEFPreP1B_8h_source.html">Assembleur_P_VEFPreP1B.h</a>.</p>

<p>Referenced by <a class="el" href="Assembleur__P__VEFPreP1B_8cpp_source.html#l00230">assembler_mat()</a>, and <a class="el" href="Assembleur__P__VEFPreP1B_8cpp_source.html#l00100">completer()</a>.</p>

</div>
</div>
<a class="anchor" id="a75f504c4171787bdeb487a8dd98e2a00"></a><!-- doxytag: member="Assembleur_P_VEFPreP1B::mon_equation" ref="a75f504c4171787bdeb487a8dd98e2a00" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRef__Equation__base.html">Ref_Equation_base</a> <a class="el" href="classAssembleur__P__VEFPreP1B.html#a75f504c4171787bdeb487a8dd98e2a00">Assembleur_P_VEFPreP1B::mon_equation</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="classAssembleur__P__VEF.html#a2f14021e95e9428386904fbf666d84b6">Assembleur_P_VEF</a>.</p>

<p>Definition at line <a class="el" href="Assembleur__P__VEFPreP1B_8h_source.html#l00077">77</a> of file <a class="el" href="Assembleur__P__VEFPreP1B_8h_source.html">Assembleur_P_VEFPreP1B.h</a>.</p>

<p>Referenced by <a class="el" href="Assembleur__P__VEFPreP1B_8cpp_source.html#l00230">assembler_mat()</a>, <a class="el" href="Assembleur__P__VEFPreP1B_8cpp_source.html#l00100">completer()</a>, <a class="el" href="Assembleur__P__VEFPreP1B_8h_source.html#l00047">equation()</a>, and <a class="el" href="Assembleur__P__VEFPreP1B_8cpp_source.html#l00751">verifier_dirichlet()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/P1NCP1B/Solveurs/<a class="el" href="Assembleur__P__VEFPreP1B_8h_source.html">Assembleur_P_VEFPreP1B.h</a></li>
<li>src/P1NCP1B/Solveurs/<a class="el" href="Assembleur__P__VEFPreP1B_8cpp_source.html">Assembleur_P_VEFPreP1B.cpp</a></li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Tue Dec 14 2021 19:36:07 for TRUST by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
