<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>TRUST: src/Kernel/Geometrie/DomaineCutter.cpp File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">TRUST&#160;<span id="projectnumber">1.8.4</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">src/Kernel/Geometrie/DomaineCutter.cpp File Reference</div>  </div>
</div>
<div class="contents">
<div class="textblock"><code>#include &lt;<a class="el" href="DomaineCutter_8h_source.html">DomaineCutter.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="ArrOfBit_8h_source.html">ArrOfBit.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="Domaine_8h_source.html">Domaine.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="Connectivite__som__elem_8h_source.html">Connectivite_som_elem.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="SFichierBin_8h_source.html">SFichierBin.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="Array__tools_8h_source.html">Array_tools.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="Scatter_8h_source.html">Scatter.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="Vect__ArrOfInt_8h_source.html">Vect_ArrOfInt.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="Sous__Zone_8h_source.html">Sous_Zone.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="Sparskit_8h_source.html">Sparskit.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="Poly__geom__base_8h_source.html">Poly_geom_base.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="Sortie__Brute_8h_source.html">Sortie_Brute.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="IntVect_8h_source.html">IntVect.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="FichierHDFPar_8h_source.html">FichierHDFPar.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="communications_8h_source.html">communications.h</a>&gt;</code><br/>
</div>
<p><a href="DomaineCutter_8cpp_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="DomaineCutter_8cpp.html#a864ba9bfc1dd181f22111636ac9cd45d">construire_liste_sommets_sousdomaine</a> (const int nb_sommets, const <a class="el" href="classIntTab.html">IntTab</a> &amp;les_elems, const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;liste_elements, const int i_part, const <a class="el" href="classStatic__Int__Lists.html">Static_Int_Lists</a> *som_raccord, <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;liste_sommets, <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;liste_inverse_sommets)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creation de la liste des sommets du sous-domaine "partie".<br/>
C'est l'ensemble des sommets des elements appartenant a ce sous-domaine.<br/>
On ne traite que les elements reels.<br/>
Parametre: nb_sommets<br/>
Signification: nombre de sommets de la zone globale<br/>
Parametre: les_elems<br/>
Signification tableau des elements de la zone globale (pour chaque element, numeros de ses sommets)<br/>
Parametre: elem_part<br/>
Signification: tableau de decoupage (pour chaque element i du domaine global,<br/>
elem_part[i] est le numero du sous-domaine auquel il est affecte)<br/>
Parametre: partie<br/>
Signification: le numero du sous-domaine a construire<br/>
Parametre: liste_sommets<br/>
Signification: en sortie : liste des sommets du sous-domaine: liste_sommets[i] est<br/>
l'indice dans la zone_globale du i-ieme sommet du sous-domaine.<br/>
Les indices sont classes dans l'ordre croissant.<br/>
Parametre: liste_inverse_sommets<br/>
Signification: en sortie : on lui donne la taille nb_sommets et on l'initialise.<br/>
liste_inverse_sommet[i] est l'indice du sommet dans le sous-domaine<br/>
ou -1 si le sommet i n'est pas dans le sous-domaine)  <a href="#a864ba9bfc1dd181f22111636ac9cd45d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="DomaineCutter_8cpp.html#adf74c004dd180d3a955e02b71acd8c52">remplir_coordsommets_sous_domaine</a> (const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;sommets_glob, const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;liste_sommets, <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;sommets_loc)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="DomaineCutter_8cpp.html#a0182ac071592d0b622994493f6c2a9a3">construire_elems_sous_domaine</a> (const <a class="el" href="classIntTab.html">IntTab</a> &amp;elems_zone_globale, const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;liste_elements, const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;liste_inverse_sommets, <a class="el" href="classIntTab.html">IntTab</a> &amp;elems_zone_locale, <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;liste_inverse_elements)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="DomaineCutter_8cpp.html#a343028ad4896bd87bade3f9076b098b5">construire_liste_faces_sous_domaine</a> (const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;elements_voisins, const <a class="el" href="classIntVect.html">IntVect</a> &amp;elem_part, const int partie, const <a class="el" href="classIntTab.html">IntTab</a> &amp;faces_sommets, const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;liste_inverse_sommets, <a class="el" href="classIntTab.html">IntTab</a> &amp;faces_sommets_partie)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Pour une liste de "faces" de la zone globale, compter le nombre de<br/>
faces incluses dans la partie "part" et les copier dans la structure<br/>
faces_partie en remplacant les numeros de sommets par les numeros locaux<br/>
dans le sous-domaine.<br/>
L'ordre des faces est conserve (si une face apparait avant une autre dans<br/>
la liste du domaine complet et si elles sont toutes les deux dans la sous-partie,<br/>
alors leur ordre est conserve). C'est important pour le periodique<br/>
(hypothese qu'il y a correspondance entre la face i et la face i+n/2 du bord<br/>
periodique).<br/>
Attention: la condition pour qu'une face soit incluse est "la face appartient&lt;br&gt;a un element de la partie voisine". La condition "les sommets des faces sont&lt;br&gt;des sommets de joint" n'est PAS suffisante.  <a href="#a343028ad4896bd87bade3f9076b098b5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="DomaineCutter_8cpp.html#aa231b6022b4a942b392a39d991b8ffd3">ajouter_joints</a> (<a class="el" href="classZone.html">Zone</a> &amp;zone, const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;voisins, const int epaisseur)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Pour chaque pe mentionne dans le tableau "voisins", si un joint avec ce pe<br/>
n'existe par encore dans la zone, ajoute un joint et initialise ce joint avec "epaisseur".  <a href="#aa231b6022b4a942b392a39d991b8ffd3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="DomaineCutter_8cpp.html#ad7049d16e9165a0d702924537dffe3e3">parcourir_epaisseurs_elements</a> (const <a class="el" href="classIntTab.html">IntTab</a> &amp;elements, const <a class="el" href="classStatic__Int__Lists.html">Static_Int_Lists</a> &amp;elem_som, const <a class="el" href="classIntVect.html">IntVect</a> &amp;elem_part, <a class="el" href="classArrOfInt.html">ArrOfInt</a> liste_sommets_depart, const int partie_a_ignorer, const int epaisseur, <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;liste_elements_trouves)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A partir d'une liste de sommets de depart (liste_sommets_depart), on<br/>
parcourt les elements voisins de ces sommets (si epaisseur &lt;= 1),<br/>
puis les voisins de ces elements (voisins par un sommet de l'element) si epaisseur &lt;= 2,<br/>
puis les voisins des voisins si epaisseur &lt;= 3, etc<br/>
Les elements appartenant a la "partie_a_ignorer" ne sont pas parcourus.<br/>
Les indices des elements parcourus sont ranges dans liste_elements_trouves.<br/>
Cette methode a ete codee pour construire_elements_distants_ssdom()  <a href="#ad7049d16e9165a0d702924537dffe3e3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="DomaineCutter_8cpp.html#a89001120b42a3a2021e912f973f795b9">calculer_listes_elements_sous_domaines</a> (const <a class="el" href="classIntVect.html">IntVect</a> &amp;elem_part, const int nb_parts, const int nbelem, <a class="el" href="classStatic__Int__Lists.html">Static_Int_Lists</a> &amp;liste_elems_sous_domaines)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="DomaineCutter_8cpp.html#ad5a2c9a3de10b2385c5d6387060dc628">calculer_elements_voisins_bords</a> (const <a class="el" href="classDomaine.html">Domaine</a> &amp;dom, const <a class="el" href="classStatic__Int__Lists.html">Static_Int_Lists</a> &amp;som_elem, <a class="el" href="classStatic__Int__Lists.html">Static_Int_Lists</a> &amp;voisins, const <a class="el" href="classIntVect.html">IntVect</a> &amp;elem_part, const int permissif, <a class="el" href="classNoms.html">Noms</a> &amp;bords_a_pb_)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="DomaineCutter_8cpp.html#a9e5238b7b86ba22c11d18274d708a57d">construire_nom_fichier_sous_domaine</a> (const <a class="el" href="classNom.html">Nom</a> &amp;basename, const int partie, const int nb_parties_, const int original_proc, <a class="el" href="classNom.html">Nom</a> &amp;fichier)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Build the name of the ".Zones" file for a given proc and a domain.<br/>
If partie == -1 a single filename is returned. For example<br/>
DOM.Zones<br/>
instead of<br/>
DOM_0001.Zones.  <a href="#a9e5238b7b86ba22c11d18274d708a57d"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="var-members"></a>
Variables</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classType__info.html">Type_info</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="DomaineCutter_8cpp.html#a9049ebf5e07a2e8a81abb3af73ffac66">DomaineCutterbases</a> [1] = { &amp;( <a class="el" href="classObjet__U.html">Objet_U</a> ::info_obj)}</td></tr>
</table>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="aa231b6022b4a942b392a39d991b8ffd3"></a><!-- doxytag: member="DomaineCutter.cpp::ajouter_joints" ref="aa231b6022b4a942b392a39d991b8ffd3" args="(Zone &amp;zone, const ArrOfInt &amp;voisins, const int epaisseur)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void ajouter_joints </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classZone.html">Zone</a> &amp;&#160;</td>
          <td class="paramname"><em>zone</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>voisins</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>epaisseur</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Pour chaque pe mentionne dans le tableau "voisins", si un joint avec ce pe<br/>
n'existe par encore dans la zone, ajoute un joint et initialise ce joint avec "epaisseur". </p>

<p>Definition at line <a class="el" href="DomaineCutter_8cpp_source.html#l00396">396</a> of file <a class="el" href="DomaineCutter_8cpp_source.html">DomaineCutter.cpp</a>.</p>

<p>References <a class="el" href="Joints_8h_source.html#l00028">List_Joint::add()</a>, <a class="el" href="Joint_8cpp_source.html#l00092">Joint::affecte_epaisseur()</a>, <a class="el" href="Joint_8cpp_source.html#l00085">Joint::affecte_PEvoisin()</a>, <a class="el" href="Frontiere_8cpp_source.html#l00093">Frontiere::associer_zone()</a>, <a class="el" href="EntreeSortie_8h_source.html#l00032">Cerr</a>, <a class="el" href="Zone_8h_source.html#l01098">Zone::faces_joint()</a>, <a class="el" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>, <a class="el" href="Frontiere_8cpp_source.html#l00113">Frontiere::nommer()</a>, <a class="el" href="Joint__Items_8cpp_source.html#l00056">Joint_Items::set_items_communs()</a>, <a class="el" href="Joint_8cpp_source.html#l00159">Joint::set_joint_item()</a>, <a class="el" href="liste_8cpp_source.html#l00175">liste::size()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00342">ArrOfInt::size_array()</a>, and <a class="el" href="Joint_8h_source.html#l00066">Joint::SOMMET</a>.</p>

<p>Referenced by <a class="el" href="DomaineCutter_8cpp_source.html#l00517">DomaineCutter::construire_elements_distants_ssdom()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <a class="code" href="classJoints.html" title="Classe Joints Cette classe represente une liste d&#39;objet de type Joint.">Joints</a>&amp; joints = zone.<a class="code" href="classZone.html#a16f273a76321d31435995cdad664285a" title="Renvoie la liste des joints de la zone. (version const)">faces_joint</a>();

  <span class="keyword">const</span> <span class="keywordtype">int</span> n = voisins.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>();
  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; n; i++)
    {
      <span class="keyword">const</span> <span class="keywordtype">int</span> pe = voisins[i];
      <span class="keywordtype">int</span> j;
      <span class="keyword">const</span> <span class="keywordtype">int</span> nb_joints = joints.<a class="code" href="classliste.html#ab47f280662ff68f9aa2e00e50431c5dc" title="Renvoie la taille de la liste Une liste vide est de taille nulle.">size</a>();
      <span class="keywordflow">for</span> (j = 0; j &lt; nb_joints; j++)
        <span class="keywordflow">if</span> (joints[j].PEvoisin() == pe)
          <span class="keywordflow">break</span>;
      <span class="keywordflow">if</span> (j == nb_joints)
        {
          <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot; Adding of a new joint : &quot;</span> &lt;&lt; pe &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
          <a class="code" href="classJoint.html" title="La classe Joint est une Frontiere qui contient les faces et les sommets de joint avec la zone PEvoisi...">Joint</a>&amp; joint = joints.<a class="code" href="classList__Joint.html#af5bca88a907fbe4086842805696cfe2f">add</a>(<a class="code" href="classJoint.html" title="La classe Joint est une Frontiere qui contient les faces et les sommets de joint avec la zone PEvoisi...">Joint</a>());
          joint.<a class="code" href="classFrontiere.html#a714e3cc26d7e59f3a65d80de23ea21ac" title="Donne un nom a la frontiere.">nommer</a>(<a class="code" href="classNom.html" title="class Nom Une chaine de caractere pour nommer les objets de TRUST">Nom</a>(<span class="stringliteral">&quot;Joint_&quot;</span>)+<a class="code" href="classNom.html" title="class Nom Une chaine de caractere pour nommer les objets de TRUST">Nom</a>(pe));
          joint.<a class="code" href="classFrontiere.html#af927b5d4fc1fd086ba91e916f61badee" title="Associe la frontiere a la zone dont elle depend.">associer_zone</a>(zone);
          joint.<a class="code" href="classJoint.html#a130c206de5fddabf173bb3e4604cefa3" title="Fixe l&#39;epaisseur du joint.">affecte_epaisseur</a>(epaisseur);
          joint.<a class="code" href="classJoint.html#a3c4ef6a648dd0b5d4aa072a1f4e3c64e" title="Fixe le numero du PE voisin.">affecte_PEvoisin</a>(pe);
<span class="comment">// Ces joints n&#39;auront pas de sommets communs. Met le flag</span>
<span class="comment">// d&#39;initialisation a 1.</span>
          joint.<a class="code" href="classJoint.html#aa1c4d729a3017082d26907d82ad1d7de" title="Renvoie les informations de joint pour un type d&#39;item geometrique donne, pour remplissage des structu...">set_joint_item</a>(<a class="code" href="classJoint.html#a1e2d15d088c27c9b7b11c02bf4d2c926a050aa4faf237e25faef6fff15ffc20f8">Joint::SOMMET</a>).<a class="code" href="classJoint__Items.html#aa01c4601d506c658f4f1d45e66951ce0" title="Renvoie le tableau items_communs_ pour le remplir. (BM: ce tableau n&#39;est pas encore rempli)...">set_items_communs</a>();
        }
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="ad5a2c9a3de10b2385c5d6387060dc628"></a><!-- doxytag: member="DomaineCutter.cpp::calculer_elements_voisins_bords" ref="ad5a2c9a3de10b2385c5d6387060dc628" args="(const Domaine &amp;dom, const Static_Int_Lists &amp;som_elem, Static_Int_Lists &amp;voisins, const IntVect &amp;elem_part, const int permissif, Noms &amp;bords_a_pb_)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void calculer_elements_voisins_bords </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDomaine.html">Domaine</a> &amp;&#160;</td>
          <td class="paramname"><em>dom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classStatic__Int__Lists.html">Static_Int_Lists</a> &amp;&#160;</td>
          <td class="paramname"><em>som_elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classStatic__Int__Lists.html">Static_Int_Lists</a> &amp;&#160;</td>
          <td class="paramname"><em>voisins</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIntVect.html">IntVect</a> &amp;&#160;</td>
          <td class="paramname"><em>elem_part</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>permissif</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classNoms.html">Noms</a> &amp;&#160;</td>
          <td class="paramname"><em>bords_a_pb_</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="DomaineCutter_8cpp_source.html#l01002">1002</a> of file <a class="el" href="DomaineCutter_8cpp_source.html">DomaineCutter.cpp</a>.</p>

<p>References <a class="el" href="Noms_8cpp_source.html#l00024">Vect_Nom::add()</a>, <a class="el" href="EntreeSortie_8h_source.html#l00032">Cerr</a>, <a class="el" href="Process_8cpp_source.html#l00223">Process::exit()</a>, <a class="el" href="Frontiere_8h_source.html#l00175">Frontiere::faces()</a>, <a class="el" href="Connectivite__som__elem_8cpp_source.html#l00108">find_adjacent_elements()</a>, <a class="el" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>, <a class="el" href="Zone_8h_source.html#l00840">Zone::frontiere()</a>, <a class="el" href="Frontiere_8h_source.html#l00155">Frontiere::le_nom()</a>, <a class="el" href="Frontiere_8cpp_source.html#l00197">Frontiere::les_sommets_des_faces()</a>, <a class="el" href="Frontiere_8h_source.html#l00114">Frontiere::nb_faces()</a>, <a class="el" href="Zone_8h_source.html#l00618">Zone::nb_front_Cl()</a>, <a class="el" href="Faces_8h_source.html#l00242">Faces::nb_som_faces()</a>, <a class="el" href="Static__Int__Lists_8cpp_source.html#l00036">Static_Int_Lists::set_list_sizes()</a>, <a class="el" href="ArrOfInt_8cpp_source.html#l00443">ArrOfInt::set_smart_resize()</a>, <a class="el" href="Static__Int__Lists_8h_source.html#l00088">Static_Int_Lists::set_value()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00342">ArrOfInt::size_array()</a>, and <a class="el" href="Domaine_8h_source.html#l00272">Domaine::zone()</a>.</p>

<p>Referenced by <a class="el" href="DomaineCutter_8cpp_source.html#l01066">DomaineCutter::initialiser()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">const</span> <a class="code" href="classZone.html" title="classe Zone Une Zone est un maillage compose d&#39;un ensemble d&#39;elements geometriques de meme type...">Zone</a>&amp; zone = dom.<a class="code" href="classDomaine.html#a0e62f2bc829542fafa29e3f2c614159c" title="Renvoie la i-ieme zone du domaine. (version const)">zone</a>(0);
  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_front = zone.<a class="code" href="classZone.html#a9bf185c52ad1809d954bba670d9aed8a" title="Renvoie le nombre de bords + le nombre de raccords + le nombre de faces frontieres internes...">nb_front_Cl</a>();
  <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> nb_faces(nb_front);
  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; nb_front; i++)
    nb_faces[i] = zone.<a class="code" href="classZone.html#ac338b119d4b0bc4f510a223b9086fe5e">frontiere</a>(i).<a class="code" href="classFrontiere.html#aa073fe9dbdddde59471ee7032b256aa2" title="Renvoie le nombre de faces de la frontiere.">nb_faces</a>();
  voisins.<a class="code" href="classStatic__Int__Lists.html#a60da63cb1970f5b87d1e1fdf6d65dcb2" title="detruit les listes existantes et en cree de nouvelles. On cree autant de listes que d&#39;elements dans l...">set_list_sizes</a>(nb_faces);
  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_som_face = zone.<a class="code" href="classZone.html#ac338b119d4b0bc4f510a223b9086fe5e">frontiere</a>(0).<a class="code" href="classFrontiere.html#ac64479069f0c43a17cb5766a39ce5ba8" title="Renvoie les faces de la frontiere&lt;br&gt;(version const)">faces</a>().<a class="code" href="classFaces.html#a1361d27e4c8b239c48de671fad23428c" title="Renvoie le nombre de sommet par face.">nb_som_faces</a>();
  <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> une_face(nb_som_face);
  <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> elems_voisins;
  elems_voisins.<a class="code" href="classArrOfInt.html#a22d744bcd452d039580d1d9186f02b4e" title="Change le mode l&#39;allocation memoire: reallocation d&#39;un tableau a chaque changement de taille (flag = ...">set_smart_resize</a>(1);
  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; nb_front; i++)
    {
      <span class="keywordtype">int</span> drap=0;
      <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; faces = zone.<a class="code" href="classZone.html#ac338b119d4b0bc4f510a223b9086fe5e">frontiere</a>(i).<a class="code" href="classFrontiere.html#a6d1f96137ddae39a46985a8c3e53bcf5" title="Renvoie les sommets des faces de la frontiere.">les_sommets_des_faces</a>();
      <span class="keyword">const</span> <span class="keywordtype">int</span> n = nb_faces[i];
      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; n; j++)
        {
          <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k = 0; k &lt; nb_som_face; k++)
            une_face[k] = faces(j, k);
          <a class="code" href="Connectivite__som__elem_8cpp.html#afccbadf5344a16154a56b33dbddf88c1" title="Cherche les elements qui contiennent tous les sommets du tableau sommets_to_find (permet de trouver l...">find_adjacent_elements</a>(som_elem, une_face, elems_voisins);

          <span class="keyword">const</span> <span class="keywordtype">int</span> n_voisins = elems_voisins.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>();
          <span class="keywordflow">if</span> (n_voisins != 1)
            {
              <span class="keywordflow">if</span> (drap==0)
                {
                  <span class="keywordflow">if</span> (permissif)
                    <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Message from DomaineCutter.cpp : calculer_elements_voisins_bords\n&quot;</span>
                         &lt;&lt; <span class="stringliteral">&quot; boundary face &quot;</span>&lt;&lt;  zone.<a class="code" href="classZone.html#ac338b119d4b0bc4f510a223b9086fe5e">frontiere</a>(i).<a class="code" href="classFrontiere.html#a2868774681d6f050479a95cbc7cd6fc9" title="Renvoie le nom de la frontiere.">le_nom</a>()&lt;&lt;<span class="stringliteral">&quot; with &quot;</span> &lt;&lt; n_voisins &lt;&lt; <span class="stringliteral">&quot; neighbors.&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
                  <span class="keywordflow">else</span>
                    <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Error in DomaineCutter.cpp : calculer_elements_voisins_bords\n&quot;</span>
                         &lt;&lt; <span class="stringliteral">&quot; boundary face &quot;</span>&lt;&lt;  zone.<a class="code" href="classZone.html#ac338b119d4b0bc4f510a223b9086fe5e">frontiere</a>(i).<a class="code" href="classFrontiere.html#a2868774681d6f050479a95cbc7cd6fc9" title="Renvoie le nom de la frontiere.">le_nom</a>()&lt;&lt;<span class="stringliteral">&quot; with &quot;</span> &lt;&lt; n_voisins &lt;&lt; <span class="stringliteral">&quot; neighbors.&quot;</span> &lt;&lt; finl;
                  bords_a_pb_.<a class="code" href="classVect__Nom.html#ae20c0d0842c00756c1a2610fe0ca471f">add</a>( zone.<a class="code" href="classZone.html#ac338b119d4b0bc4f510a223b9086fe5e">frontiere</a>(i).<a class="code" href="classFrontiere.html#a2868774681d6f050479a95cbc7cd6fc9" title="Renvoie le nom de la frontiere.">le_nom</a>());
                  <span class="keywordflow">if</span> (elems_voisins.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>()==0) <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">Process::exit</a>();
                }
              drap=1;
              <span class="keywordflow">if</span> (elem_part(elems_voisins[1])==1)
                elems_voisins[0]=elems_voisins[1];
              <span class="keywordflow">if</span> (permissif==0)
                <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">Process::exit</a>();
            }
          voisins.<a class="code" href="classStatic__Int__Lists.html#ab56f42945e3057185cc1086e1cbc1bbb" title="affecte la &quot;valeur&quot; au j-ieme element de la i-ieme liste avec 0 &lt;= i &lt; get_nb_lists() et 0 &lt;= j &lt; get...">set_value</a>(i, j, elems_voisins[0]);
        }
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a89001120b42a3a2021e912f973f795b9"></a><!-- doxytag: member="DomaineCutter.cpp::calculer_listes_elements_sous_domaines" ref="a89001120b42a3a2021e912f973f795b9" args="(const IntVect &amp;elem_part, const int nb_parts, const int nbelem, Static_Int_Lists &amp;liste_elems_sous_domaines)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void calculer_listes_elements_sous_domaines </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIntVect.html">IntVect</a> &amp;&#160;</td>
          <td class="paramname"><em>elem_part</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>nb_parts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>nbelem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classStatic__Int__Lists.html">Static_Int_Lists</a> &amp;&#160;</td>
          <td class="paramname"><em>liste_elems_sous_domaines</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="DomaineCutter_8cpp_source.html#l00978">978</a> of file <a class="el" href="DomaineCutter_8cpp_source.html">DomaineCutter.cpp</a>.</p>

<p>References <a class="el" href="Static__Int__Lists_8cpp_source.html#l00036">Static_Int_Lists::set_list_sizes()</a>, and <a class="el" href="Static__Int__Lists_8h_source.html#l00088">Static_Int_Lists::set_value()</a>.</p>

<p>Referenced by <a class="el" href="DomaineCutter_8cpp_source.html#l01268">DomaineCutter::ecrire_zones()</a>, and <a class="el" href="DomaineCutter_8cpp_source.html#l01066">DomaineCutter::initialiser()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> sizes(nb_parts);
<span class="comment">// Premier passage : comptage</span>
  <span class="keywordtype">int</span> i;
  <span class="keywordflow">for</span> (i = 0; i &lt; nbelem; i++)
    {
      <span class="keyword">const</span> <span class="keywordtype">int</span> part = elem_part[i];
      sizes[part]++;
    }
  liste_elems_sous_domaines.<a class="code" href="classStatic__Int__Lists.html#a60da63cb1970f5b87d1e1fdf6d65dcb2" title="detruit les listes existantes et en cree de nouvelles. On cree autant de listes que d&#39;elements dans l...">set_list_sizes</a>(sizes);
<span class="comment">// Deuxieme passage : remplissage</span>
  sizes = 0;
  <span class="keywordflow">for</span> (i = 0; i &lt; nbelem; i++)
    {
      <span class="keyword">const</span> <span class="keywordtype">int</span> part = elem_part[i];
      <span class="keyword">const</span> <span class="keywordtype">int</span> index = sizes[part]++;
      liste_elems_sous_domaines.<a class="code" href="classStatic__Int__Lists.html#ab56f42945e3057185cc1086e1cbc1bbb" title="affecte la &quot;valeur&quot; au j-ieme element de la i-ieme liste avec 0 &lt;= i &lt; get_nb_lists() et 0 &lt;= j &lt; get...">set_value</a>(part, index, i);
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a0182ac071592d0b622994493f6c2a9a3"></a><!-- doxytag: member="DomaineCutter.cpp::construire_elems_sous_domaine" ref="a0182ac071592d0b622994493f6c2a9a3" args="(const IntTab &amp;elems_zone_globale, const ArrOfInt &amp;liste_elements, const ArrOfInt &amp;liste_inverse_sommets, IntTab &amp;elems_zone_locale, ArrOfInt &amp;liste_inverse_elements)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void construire_elems_sous_domaine </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIntTab.html">IntTab</a> &amp;&#160;</td>
          <td class="paramname"><em>elems_zone_globale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>liste_elements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>liste_inverse_sommets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classIntTab.html">IntTab</a> &amp;&#160;</td>
          <td class="paramname"><em>elems_zone_locale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>liste_inverse_elements</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="DomaineCutter_8cpp_source.html#l00192">192</a> of file <a class="el" href="DomaineCutter_8cpp_source.html">DomaineCutter.cpp</a>.</p>

<p>References <a class="el" href="IntTab_8h_source.html#l00233">IntTab::dimension()</a>, <a class="el" href="IntTab_8h_source.html#l00244">IntTab::dimension_tot()</a>, <a class="el" href="Array__base_8h_source.html#l00038">Array_base::NOCOPY_NOINIT</a>, <a class="el" href="IntTab_8cpp_source.html#l00353">IntTab::resize()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00248">ArrOfInt::resize()</a>, and <a class="el" href="ArrOfInt_8h_source.html#l00342">ArrOfInt::size_array()</a>.</p>

<p>Referenced by <a class="el" href="DomaineCutter_8cpp_source.html#l01115">DomaineCutter::construire_sous_domaine()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_elem_tot                = elems_zone_globale.<a class="code" href="classIntTab.html#a71e9b9ddc1793094b1b3f109377952b1" title="Returns the total dimensions of the multi-dimensionnal array, including virtual items (used in parall...">dimension_tot</a>(0);
  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_sommets_par_element = elems_zone_globale.<a class="code" href="classIntTab.html#abc3b32c94925a82f69d5b153a356e359" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(1);

  liste_inverse_elements.<a class="code" href="classArrOfInt.html#a15fc7e3958f02cb38d3106eeb919f6fc" title="appel a ArrOfInt::resize_array()">resize</a>(nb_elem_tot,<a class="code" href="classArray__base.html#abee342aa9ac59623c4c782dc9d7877ffaf6ae9ba7eb51c5f298ce693345b3ec68">Array_base::NOCOPY_NOINIT</a>);
  liste_inverse_elements = -1;

<span class="comment">// Premier passage: comptage du nombre d&#39;elements de la partie</span>
  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_elem_part = liste_elements.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>();
  elems_zone_locale.<a class="code" href="classIntTab.html#a22e6bed6826b3688d4d0181cbf3b7a38" title="Change la taille du vecteur (identique a resize_array() pour le traitement des anciennes valeurs et d...">resize</a>(nb_elem_part, nb_sommets_par_element);

<span class="comment">// Deuxieme passage: remplissage du tableau</span>
  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i_elem = 0; i_elem &lt; nb_elem_part; i_elem++)
    {
      <span class="keywordtype">int</span> elem = liste_elements[i_elem];

<span class="comment">// Nouveau numero de l&#39;element dans la partie</span>
      liste_inverse_elements[elem] = i_elem;
<span class="comment">// Copie de l&#39;element avec traduction du numero des sommets en</span>
<span class="comment">// numero local dans le sous-domaine</span>
      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; nb_sommets_par_element; i++)
        {
          <span class="keywordtype">int</span> sommet = elems_zone_globale(elem, i);
          <span class="keywordflow">if</span> (sommet&lt;0)
            elems_zone_locale(i_elem, i) =sommet;
          <span class="keywordflow">else</span>
            {
              <span class="keywordtype">int</span> new_num = liste_inverse_sommets[sommet];
              assert(new_num &gt;= 0);
              elems_zone_locale(i_elem, i) = new_num;
            }
        }
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a343028ad4896bd87bade3f9076b098b5"></a><!-- doxytag: member="DomaineCutter.cpp::construire_liste_faces_sous_domaine" ref="a343028ad4896bd87bade3f9076b098b5" args="(const ArrOfInt &amp;elements_voisins, const IntVect &amp;elem_part, const int partie, const IntTab &amp;faces_sommets, const ArrOfInt &amp;liste_inverse_sommets, IntTab &amp;faces_sommets_partie)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void construire_liste_faces_sous_domaine </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>elements_voisins</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIntVect.html">IntVect</a> &amp;&#160;</td>
          <td class="paramname"><em>elem_part</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>partie</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIntTab.html">IntTab</a> &amp;&#160;</td>
          <td class="paramname"><em>faces_sommets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>liste_inverse_sommets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classIntTab.html">IntTab</a> &amp;&#160;</td>
          <td class="paramname"><em>faces_sommets_partie</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Pour une liste de "faces" de la zone globale, compter le nombre de<br/>
faces incluses dans la partie "part" et les copier dans la structure<br/>
faces_partie en remplacant les numeros de sommets par les numeros locaux<br/>
dans le sous-domaine.<br/>
L'ordre des faces est conserve (si une face apparait avant une autre dans<br/>
la liste du domaine complet et si elles sont toutes les deux dans la sous-partie,<br/>
alors leur ordre est conserve). C'est important pour le periodique<br/>
(hypothese qu'il y a correspondance entre la face i et la face i+n/2 du bord<br/>
periodique).<br/>
Attention: la condition pour qu'une face soit incluse est "la face appartient&lt;br&gt;a un element de la partie voisine". La condition "les sommets des faces sont&lt;br&gt;des sommets de joint" n'est PAS suffisante. </p>

<p><p>&lt; Pour faire append_array... </p>
</p>

<p>Definition at line <a class="el" href="DomaineCutter_8cpp_source.html#l00245">245</a> of file <a class="el" href="DomaineCutter_8cpp_source.html">DomaineCutter.cpp</a>.</p>

<p>References <a class="el" href="ArrOfInt_8h_source.html#l00355">ArrOfInt::append_array()</a>, <a class="el" href="IntTab_8h_source.html#l00233">IntTab::dimension()</a>, <a class="el" href="IntTab_8cpp_source.html#l00353">IntTab::resize()</a>, <a class="el" href="ArrOfInt_8cpp_source.html#l00443">ArrOfInt::set_smart_resize()</a>, and <a class="el" href="ArrOfInt_8h_source.html#l00342">ArrOfInt::size_array()</a>.</p>

<p>Referenced by <a class="el" href="DomaineCutter_8cpp_source.html#l00298">DomaineCutter::construire_faces_bords_ssdom()</a>, <a class="el" href="DomaineCutter_8cpp_source.html#l00362">DomaineCutter::construire_faces_internes_ssdom()</a>, and <a class="el" href="DomaineCutter_8cpp_source.html#l00329">DomaineCutter::construire_faces_raccords_ssdom()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_faces = faces_sommets.<a class="code" href="classIntTab.html#abc3b32c94925a82f69d5b153a356e359" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(0);
  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_sommets_par_face = faces_sommets.<a class="code" href="classIntTab.html#abc3b32c94925a82f69d5b153a356e359" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(1);
  <span class="keywordtype">int</span> i;

  assert(elements_voisins.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() == nb_faces);
<span class="comment">// La liste des faces du tableau faces_sommets a inclure dans le sous-domaine</span>
  <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> liste_faces;
  liste_faces.<a class="code" href="classArrOfInt.html#a22d744bcd452d039580d1d9186f02b4e" title="Change le mode l&#39;allocation memoire: reallocation d&#39;un tableau a chaque changement de taille (flag = ...">set_smart_resize</a>(1); <span class="comment">//!&lt; Pour faire append_array...</span>
<span class="comment"></span>
<span class="comment">// Premier passage : on cherche les faces a inclure</span>
  {
    <span class="keywordflow">for</span> (i = 0; i &lt; nb_faces; i++)
      {
        <span class="keywordtype">int</span> elem = elements_voisins[i];
        <span class="keyword">const</span> <span class="keywordtype">int</span> part = elem_part[elem];
        <span class="keywordflow">if</span> (part == partie)
          liste_faces.<a class="code" href="classArrOfInt.html#a3f39d0966599416e7b1f7cd8159d8d01" title="Ajoute une case en fin de tableau et y stocke la &quot;valeur&quot;.">append_array</a>(i);
      }
  }

  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_faces_part = liste_faces.size_array();
  faces_sommets_partie.<a class="code" href="classIntTab.html#a22e6bed6826b3688d4d0181cbf3b7a38" title="Change la taille du vecteur (identique a resize_array() pour le traitement des anciennes valeurs et d...">resize</a>(nb_faces_part, nb_sommets_par_face);

<span class="comment">// Deuxieme passage : stockage des faces et conversion des numeros</span>
<span class="comment">// de sommets des faces en numeros locaux dans le sous-domaine.</span>
  <span class="keywordflow">for</span> (i = 0; i &lt; nb_faces_part; i++)
    {
      <span class="keyword">const</span> <span class="keywordtype">int</span> i_face = liste_faces[i];
      <span class="keywordtype">int</span> j;
      <span class="keywordflow">for</span> (j = 0; j &lt; nb_sommets_par_face; j++)
        {
          <span class="keywordtype">int</span> sommet = faces_sommets(i_face, j);
          <span class="keywordflow">if</span> (sommet&gt;-1)
            {
              <span class="keywordtype">int</span> new_num = liste_inverse_sommets[sommet];
              assert(new_num &gt;= 0);
              faces_sommets_partie(i, j) = new_num;
            }
          <span class="keywordflow">else</span>
            faces_sommets_partie(i, j) = -1;
        }
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a864ba9bfc1dd181f22111636ac9cd45d"></a><!-- doxytag: member="DomaineCutter.cpp::construire_liste_sommets_sousdomaine" ref="a864ba9bfc1dd181f22111636ac9cd45d" args="(const int nb_sommets, const IntTab &amp;les_elems, const ArrOfInt &amp;liste_elements, const int i_part, const Static_Int_Lists *som_raccord, ArrOfInt &amp;liste_sommets, ArrOfInt &amp;liste_inverse_sommets)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void construire_liste_sommets_sousdomaine </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>nb_sommets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIntTab.html">IntTab</a> &amp;&#160;</td>
          <td class="paramname"><em>les_elems</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>liste_elements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>i_part</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classStatic__Int__Lists.html">Static_Int_Lists</a> *&#160;</td>
          <td class="paramname"><em>som_raccord</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>liste_sommets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>liste_inverse_sommets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creation de la liste des sommets du sous-domaine "partie".<br/>
C'est l'ensemble des sommets des elements appartenant a ce sous-domaine.<br/>
On ne traite que les elements reels.<br/>
Parametre: nb_sommets<br/>
Signification: nombre de sommets de la zone globale<br/>
Parametre: les_elems<br/>
Signification tableau des elements de la zone globale (pour chaque element, numeros de ses sommets)<br/>
Parametre: elem_part<br/>
Signification: tableau de decoupage (pour chaque element i du domaine global,<br/>
elem_part[i] est le numero du sous-domaine auquel il est affecte)<br/>
Parametre: partie<br/>
Signification: le numero du sous-domaine a construire<br/>
Parametre: liste_sommets<br/>
Signification: en sortie : liste des sommets du sous-domaine: liste_sommets[i] est<br/>
l'indice dans la zone_globale du i-ieme sommet du sous-domaine.<br/>
Les indices sont classes dans l'ordre croissant.<br/>
Parametre: liste_inverse_sommets<br/>
Signification: en sortie : on lui donne la taille nb_sommets et on l'initialise.<br/>
liste_inverse_sommet[i] est l'indice du sommet dans le sous-domaine<br/>
ou -1 si le sommet i n'est pas dans le sous-domaine) </p>

<p><p>&lt; On oublie les valeurs precedentes</p>
<p>&lt; On oublie les valeurs precedentes </p>
</p>

<p>Definition at line <a class="el" href="DomaineCutter_8cpp_source.html#l00091">91</a> of file <a class="el" href="DomaineCutter_8cpp_source.html">DomaineCutter.cpp</a>.</p>

<p>References <a class="el" href="IntTab_8h_source.html#l00233">IntTab::dimension()</a>, <a class="el" href="Static__Int__Lists_8h_source.html#l00106">Static_Int_Lists::get_list_size()</a>, <a class="el" href="Static__Int__Lists_8h_source.html#l00113">Static_Int_Lists::get_nb_lists()</a>, <a class="el" href="Array__base_8h_source.html#l00038">Array_base::NOCOPY_NOINIT</a>, <a class="el" href="ArrOfInt_8h_source.html#l00240">ArrOfInt::resize_array()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00342">ArrOfInt::size_array()</a>, and <a class="el" href="ArrOfBit_8h_source.html#l00073">ArrOfBit::testsetbit()</a>.</p>

<p>Referenced by <a class="el" href="DomaineCutter_8cpp_source.html#l01115">DomaineCutter::construire_sous_domaine()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_elem_part = liste_elements.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_sommets_par_element = les_elems.<a class="code" href="classIntTab.html#abc3b32c94925a82f69d5b153a356e359" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(1);

<span class="comment">// Algorithme : on parcourt les elements: pour les elements de la partie,</span>
<span class="comment">// on marque les sommets de l&#39;element par un drapeau.</span>
<span class="comment">// Puis on fait une boucle sur les sommets, et ceux dont le drapeau</span>
<span class="comment">// est mis sont mis dans la liste.</span>

<span class="comment">// D&#39;abord, on compte les sommets de la partie et on</span>
<span class="comment">// remplit drapeau_sommet</span>
  <a class="code" href="classArrOfBit.html">ArrOfBit</a> drapeau_sommet(nb_sommets);

  drapeau_sommet = 0;
<span class="comment">// Nombre de sommets de la partie &quot;part&quot;</span>
  <span class="keywordtype">int</span> nb_sommets_part = 0;
  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i_elem = 0; i_elem &lt; nb_elem_part; i_elem++)
    {
      <span class="keyword">const</span> <span class="keywordtype">int</span> elem = liste_elements[i_elem];
      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; nb_sommets_par_element; j++)
        {
          <span class="keywordtype">int</span> sommet = les_elems(elem, j);
          <span class="keywordflow">if</span> (sommet&gt;-1)
            {
              <span class="keywordtype">int</span> bit = drapeau_sommet.testsetbit(sommet);
<span class="comment">// Si le drapeau n&#39;etait pas mis, cela fait un sommet de plus</span>
              <span class="keywordflow">if</span> (! bit)
                nb_sommets_part++;
            }
        }
    }
<span class="comment">// sommets a ajouter a cause de som_raccord</span>
  <span class="keywordflow">if</span> (som_raccord) <span class="keywordflow">for</span> (<span class="keywordtype">int</span> s = 0; s &lt; som_raccord-&gt;<a class="code" href="classStatic__Int__Lists.html#a5872636466919b2cb8efe715c315d7ca" title="renvoie le nombre de listes stockees">get_nb_lists</a>(); s++)
      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; som_raccord-&gt;<a class="code" href="classStatic__Int__Lists.html#adbf6903737c3c30bf87e05b29f5a5b56" title="renvoie le nombre d&#39;elements de la liste i">get_list_size</a>(s); i++)
        <span class="keywordflow">if</span> ((*som_raccord)(s, i) == i_part &amp;&amp; !drapeau_sommet.testsetbit(s)) <span class="comment">//le sommet est demande par ce proc</span>
          nb_sommets_part++; <span class="comment">//si on ne l&#39;a pas deja, on le rajoute</span>

<span class="comment">// Remplissage de liste_sommets et liste_inverse_sommets</span>
  liste_sommets.<a class="code" href="classArrOfInt.html#a9b3afbb46b16870dbd36236c8935b535">resize_array</a>(0); <span class="comment">//!&lt; On oublie les valeurs precedentes</span>
<span class="comment"></span>  liste_sommets.<a class="code" href="classArrOfInt.html#a9b3afbb46b16870dbd36236c8935b535">resize_array</a>(nb_sommets_part);

  liste_inverse_sommets.<a class="code" href="classArrOfInt.html#a9b3afbb46b16870dbd36236c8935b535">resize_array</a>(0); <span class="comment">//!&lt; On oublie les valeurs precedentes</span>
<span class="comment"></span>  liste_inverse_sommets.<a class="code" href="classArrOfInt.html#a9b3afbb46b16870dbd36236c8935b535">resize_array</a>(nb_sommets,<a class="code" href="classArray__base.html#abee342aa9ac59623c4c782dc9d7877ffaf6ae9ba7eb51c5f298ce693345b3ec68">Array_base::NOCOPY_NOINIT</a>);
  liste_inverse_sommets = -1;

  <span class="keywordtype">int</span> n = 0;
  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; nb_sommets; i++)
    {
      <span class="keywordflow">if</span> (drapeau_sommet[i])
        {
          liste_sommets[n] = i;
          liste_inverse_sommets[i] = n;
          n++;
        }
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a9e5238b7b86ba22c11d18274d708a57d"></a><!-- doxytag: member="DomaineCutter.cpp::construire_nom_fichier_sous_domaine" ref="a9e5238b7b86ba22c11d18274d708a57d" args="(const Nom &amp;basename, const int partie, const int nb_parties_, const int original_proc, Nom &amp;fichier)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void construire_nom_fichier_sous_domaine </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classNom.html">Nom</a> &amp;&#160;</td>
          <td class="paramname"><em>basename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>partie</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>nb_parties_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>original_proc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classNom.html">Nom</a> &amp;&#160;</td>
          <td class="paramname"><em>fichier</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Build the name of the ".Zones" file for a given proc and a domain.<br/>
If partie == -1 a single filename is returned. For example<br/>
DOM.Zones<br/>
instead of<br/>
DOM_0001.Zones. </p>

<p>Definition at line <a class="el" href="DomaineCutter_8cpp_source.html#l01210">1210</a> of file <a class="el" href="DomaineCutter_8cpp_source.html">DomaineCutter.cpp</a>.</p>

<p>References <a class="el" href="EntreeSortie_8h_source.html#l00032">Cerr</a>, <a class="el" href="Process_8cpp_source.html#l00223">Process::exit()</a>, and <a class="el" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>.</p>

<p>Referenced by <a class="el" href="DomaineCutter_8cpp_source.html#l01268">DomaineCutter::ecrire_zones()</a>.</p>
<div class="fragment"><pre class="fragment">{
  fichier = basename;

  <span class="keywordflow">if</span> (partie &gt; 100000)
    {
      <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Error while generating filename: nb_parties_ too large&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
      <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">Process::exit</a>();
    }
  <span class="keywordtype">char</span> s[30];
<span class="comment">// single file name for all procs (HDF5)</span>
<span class="comment">// the number of parts is still included in the file name</span>
<span class="comment">// (make_PAR.data needs to know how many zones there are)</span>
  <span class="keywordflow">if</span> (partie &lt; 0)
    {
      <span class="keywordflow">if</span> (nb_parties_ &gt; 10000)
        sprintf(s, <span class="stringliteral">&quot;_p%05d.Zones&quot;</span>, (<a class="code" href="arch_8h.html#a1caaf369d9c5f0817dbaa76b43b8d87b">True_int</a>)nb_parties_);
      <span class="keywordflow">else</span>
        sprintf(s, <span class="stringliteral">&quot;_p%04d.Zones&quot;</span>,(<a class="code" href="arch_8h.html#a1caaf369d9c5f0817dbaa76b43b8d87b">True_int</a>) nb_parties_);
    }
  <span class="keywordflow">else</span>
    {
      <span class="keywordflow">if</span> (nb_parties_ &gt; 10000)
        {
          <span class="keywordflow">if</span>(original_proc &lt; 0)
            sprintf(s, <span class="stringliteral">&quot;_%05d.Zones&quot;</span>, (<a class="code" href="arch_8h.html#a1caaf369d9c5f0817dbaa76b43b8d87b">True_int</a>)partie);
          <span class="keywordflow">else</span>
            sprintf(s, <span class="stringliteral">&quot;_%05d_%d.Zones&quot;</span>, (<a class="code" href="arch_8h.html#a1caaf369d9c5f0817dbaa76b43b8d87b">True_int</a>)partie, (<a class="code" href="arch_8h.html#a1caaf369d9c5f0817dbaa76b43b8d87b">True_int</a>)original_proc);
        }
      <span class="keywordflow">else</span>
        {
          <span class="keywordflow">if</span>(original_proc &lt; 0)
            sprintf(s, <span class="stringliteral">&quot;_%04d.Zones&quot;</span>, (<a class="code" href="arch_8h.html#a1caaf369d9c5f0817dbaa76b43b8d87b">True_int</a>)partie);
          <span class="keywordflow">else</span>
            sprintf(s, <span class="stringliteral">&quot;_%04d_%d.Zones&quot;</span>, (<a class="code" href="arch_8h.html#a1caaf369d9c5f0817dbaa76b43b8d87b">True_int</a>)partie, (<a class="code" href="arch_8h.html#a1caaf369d9c5f0817dbaa76b43b8d87b">True_int</a>)original_proc);
        }
    }
  fichier += <a class="code" href="classNom.html" title="class Nom Une chaine de caractere pour nommer les objets de TRUST">Nom</a>(s);
}
</pre></div>
</div>
</div>
<a class="anchor" id="ad7049d16e9165a0d702924537dffe3e3"></a><!-- doxytag: member="DomaineCutter.cpp::parcourir_epaisseurs_elements" ref="ad7049d16e9165a0d702924537dffe3e3" args="(const IntTab &amp;elements, const Static_Int_Lists &amp;elem_som, const IntVect &amp;elem_part, ArrOfInt liste_sommets_depart, const int partie_a_ignorer, const int epaisseur, ArrOfInt &amp;liste_elements_trouves)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void parcourir_epaisseurs_elements </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIntTab.html">IntTab</a> &amp;&#160;</td>
          <td class="paramname"><em>elements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classStatic__Int__Lists.html">Static_Int_Lists</a> &amp;&#160;</td>
          <td class="paramname"><em>elem_som</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIntVect.html">IntVect</a> &amp;&#160;</td>
          <td class="paramname"><em>elem_part</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArrOfInt.html">ArrOfInt</a>&#160;</td>
          <td class="paramname"><em>liste_sommets_depart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>partie_a_ignorer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>epaisseur</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>liste_elements_trouves</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A partir d'une liste de sommets de depart (liste_sommets_depart), on<br/>
parcourt les elements voisins de ces sommets (si epaisseur &lt;= 1),<br/>
puis les voisins de ces elements (voisins par un sommet de l'element) si epaisseur &lt;= 2,<br/>
puis les voisins des voisins si epaisseur &lt;= 3, etc<br/>
Les elements appartenant a la "partie_a_ignorer" ne sont pas parcourus.<br/>
Les indices des elements parcourus sont ranges dans liste_elements_trouves.<br/>
Cette methode a ete codee pour construire_elements_distants_ssdom() </p>

<p><p>&lt; Cet element a deja ete visite Numero de zone de l'element voisin:</p>
<p>&lt; Ne traiter que les elements des autres parties </p>
</p>

<p>Definition at line <a class="el" href="DomaineCutter_8cpp_source.html#l00432">432</a> of file <a class="el" href="DomaineCutter_8cpp_source.html">DomaineCutter.cpp</a>.</p>

<p>References <a class="el" href="ArrOfInt_8h_source.html#l00355">ArrOfInt::append_array()</a>, <a class="el" href="IntTab_8h_source.html#l00233">IntTab::dimension()</a>, <a class="el" href="IntTab_8h_source.html#l00244">IntTab::dimension_tot()</a>, <a class="el" href="Static__Int__Lists_8h_source.html#l00106">Static_Int_Lists::get_list_size()</a>, <a class="el" href="Static__Int__Lists_8h_source.html#l00113">Static_Int_Lists::get_nb_lists()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00240">ArrOfInt::resize_array()</a>, <a class="el" href="ArrOfInt_8cpp_source.html#l00443">ArrOfInt::set_smart_resize()</a>, <a class="el" href="ArrOfBit_8h_source.html#l00064">ArrOfBit::setbit()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00342">ArrOfInt::size_array()</a>, and <a class="el" href="ArrOfBit_8h_source.html#l00073">ArrOfBit::testsetbit()</a>.</p>

<p>Referenced by <a class="el" href="DomaineCutter_8cpp_source.html#l00517">DomaineCutter::construire_elements_distants_ssdom()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_sommets = elem_som.<a class="code" href="classStatic__Int__Lists.html#a5872636466919b2cb8efe715c315d7ca" title="renvoie le nombre de listes stockees">get_nb_lists</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_elements = elements.<a class="code" href="classIntTab.html#a71e9b9ddc1793094b1b3f109377952b1" title="Returns the total dimensions of the multi-dimensionnal array, including virtual items (used in parall...">dimension_tot</a>(0);
  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_som_elem = elements.<a class="code" href="classIntTab.html#abc3b32c94925a82f69d5b153a356e359" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(1);

  liste_elements_trouves.<a class="code" href="classArrOfInt.html#a22d744bcd452d039580d1d9186f02b4e" title="Change le mode l&#39;allocation memoire: reallocation d&#39;un tableau a chaque changement de taille (flag = ...">set_smart_resize</a>(1);
  liste_elements_trouves.<a class="code" href="classArrOfInt.html#a9b3afbb46b16870dbd36236c8935b535">resize_array</a>(0);

  <a class="code" href="classArrOfBit.html">ArrOfBit</a> sommets_parcourus(nb_sommets);
  <a class="code" href="classArrOfBit.html">ArrOfBit</a> elements_parcourus(nb_elements);
  <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> new_liste;
  liste_sommets_depart.<a class="code" href="classArrOfInt.html#a22d744bcd452d039580d1d9186f02b4e" title="Change le mode l&#39;allocation memoire: reallocation d&#39;un tableau a chaque changement de taille (flag = ...">set_smart_resize</a>(1);
  new_liste.<a class="code" href="classArrOfInt.html#a22d744bcd452d039580d1d9186f02b4e" title="Change le mode l&#39;allocation memoire: reallocation d&#39;un tableau a chaque changement de taille (flag = ...">set_smart_resize</a>(1);
  sommets_parcourus = 0;
  elements_parcourus = 0;

  {
<span class="comment">// Marquage des sommets de depart et construction d&#39;une liste de sommets uniques</span>
    <span class="keyword">const</span> <span class="keywordtype">int</span> sz_liste = liste_sommets_depart.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>();
    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; sz_liste; i++)
      {
        <span class="keyword">const</span> <span class="keywordtype">int</span> sommet = liste_sommets_depart[i];
        <span class="keywordflow">if</span> (sommet&gt;-1)
          <span class="keywordflow">if</span> (!sommets_parcourus.testsetbit(sommet))
            new_liste.<a class="code" href="classArrOfInt.html#a3f39d0966599416e7b1f7cd8159d8d01" title="Ajoute une case en fin de tableau et y stocke la &quot;valeur&quot;.">append_array</a>(sommet);
      }
  }

<span class="comment">// Boucle sur les epaisseurs successives d&#39;elements autour des sommets de joint.</span>
  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> ep = 1; ep &lt;= epaisseur; ep++)
    {
      liste_sommets_depart = new_liste;
      new_liste.<a class="code" href="classArrOfInt.html#a9b3afbb46b16870dbd36236c8935b535">resize_array</a>(0);
      <span class="keyword">const</span> <span class="keywordtype">int</span> sz_liste = liste_sommets_depart.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>();
      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i_sommet = 0; i_sommet &lt; sz_liste; i_sommet++)
        {
          <span class="keyword">const</span> <span class="keywordtype">int</span> sommet = liste_sommets_depart[i_sommet];
<span class="comment">// Parcours des elements voisins de ce sommet :</span>
          <span class="keyword">const</span> <span class="keywordtype">int</span> nb_elems_voisins = elem_som.<a class="code" href="classStatic__Int__Lists.html#adbf6903737c3c30bf87e05b29f5a5b56" title="renvoie le nombre d&#39;elements de la liste i">get_list_size</a>(sommet);
          <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i_elem = 0; i_elem &lt; nb_elems_voisins; i_elem++)
            {
              <span class="keyword">const</span> <span class="keywordtype">int</span> elem = elem_som(sommet, i_elem);
              <span class="keywordflow">if</span> (elements_parcourus[elem])
                <span class="keywordflow">continue</span>; <span class="comment">//!&lt; Cet element a deja ete visite Numero de zone de l&#39;element voisin:</span>
<span class="comment"></span><span class="comment">//</span>
              <span class="keyword">const</span> <span class="keywordtype">int</span> part = elem_part[elem];
              <span class="keywordflow">if</span> (part == partie_a_ignorer)
                <span class="keywordflow">continue</span>; <span class="comment">//!&lt; Ne traiter que les elements des autres parties</span>
<span class="comment"></span>
              liste_elements_trouves.<a class="code" href="classArrOfInt.html#a3f39d0966599416e7b1f7cd8159d8d01" title="Ajoute une case en fin de tableau et y stocke la &quot;valeur&quot;.">append_array</a>(elem);
              elements_parcourus.setbit(elem);

<span class="comment">// Ajout a la prochaine liste de sommets a traiter les sommets de cet element:</span>
              <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; nb_som_elem; i++)
                {
                  <span class="keyword">const</span> <span class="keywordtype">int</span> sommet2 = elements(elem, i);
                  <span class="keywordflow">if</span> (sommet2&gt;-1)
                    {
                      <span class="keywordflow">if</span> (sommets_parcourus.testsetbit(sommet2) == 0)
                        new_liste.<a class="code" href="classArrOfInt.html#a3f39d0966599416e7b1f7cd8159d8d01" title="Ajoute une case en fin de tableau et y stocke la &quot;valeur&quot;.">append_array</a>(sommet2);
                    }
                }
            }
        }
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="adf74c004dd180d3a955e02b71acd8c52"></a><!-- doxytag: member="DomaineCutter.cpp::remplir_coordsommets_sous_domaine" ref="adf74c004dd180d3a955e02b71acd8c52" args="(const DoubleTab &amp;sommets_glob, const ArrOfInt &amp;liste_sommets, DoubleTab &amp;sommets_loc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void remplir_coordsommets_sous_domaine </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>sommets_glob</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>liste_sommets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>sommets_loc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="DomaineCutter_8cpp_source.html#l00167">167</a> of file <a class="el" href="DomaineCutter_8cpp_source.html">DomaineCutter.cpp</a>.</p>

<p>References <a class="el" href="DoubleTab_8h_source.html#l00243">DoubleTab::dimension()</a>, <a class="el" href="DoubleTab_8cpp_source.html#l00335">DoubleTab::resize()</a>, and <a class="el" href="ArrOfInt_8h_source.html#l00342">ArrOfInt::size_array()</a>.</p>

<p>Referenced by <a class="el" href="DomaineCutter_8cpp_source.html#l01115">DomaineCutter::construire_sous_domaine()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_som = liste_sommets.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> dim = sommets_glob.<a class="code" href="classDoubleTab.html#ac3805e2637a3b880ba2d3e650c69dac4" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(1);
  sommets_loc.<a class="code" href="classDoubleTab.html#ae83b4d31205c53d9c8d2b43da178ce75" title="Change la taille du vecteur (identique a resize_array() pour le traitement des anciennes valeurs et d...">resize</a>(nb_som, dim);

  <span class="keywordtype">int</span> i;
  <span class="keywordflow">for</span> (i = 0; i &lt; nb_som; i++)
    {
      <span class="keywordtype">int</span> indice = liste_sommets[i];
      <span class="keywordtype">int</span> j;
      <span class="keywordflow">for</span> (j = 0; j &lt; dim; j++)
        sommets_loc(i, j) = sommets_glob(indice, j);
    }
}
</pre></div>
</div>
</div>
<hr/><h2>Variable Documentation</h2>
<a class="anchor" id="a9049ebf5e07a2e8a81abb3af73ffac66"></a><!-- doxytag: member="DomaineCutter.cpp::DomaineCutterbases" ref="a9049ebf5e07a2e8a81abb3af73ffac66" args="[1]" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classType__info.html">Type_info</a>* <a class="el" href="DomaineCutter_8cpp.html#a9049ebf5e07a2e8a81abb3af73ffac66">DomaineCutterbases</a>[1] = { &amp;( <a class="el" href="classObjet__U.html">Objet_U</a> ::info_obj)}</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="DomaineCutter_8cpp_source.html#l00039">39</a> of file <a class="el" href="DomaineCutter_8cpp_source.html">DomaineCutter.cpp</a>.</p>

</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Tue Dec 14 2021 19:35:49 for TRUST by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
