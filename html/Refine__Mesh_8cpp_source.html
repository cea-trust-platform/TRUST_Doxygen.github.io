<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>TRUST: src/Kernel/Geometrie/Refine_Mesh.cpp Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">TRUST&#160;<span id="projectnumber">1.8.4</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
<div class="header">
  <div class="headertitle">
<div class="title">src/Kernel/Geometrie/Refine_Mesh.cpp</div>  </div>
</div>
<div class="contents">
<a href="Refine__Mesh_8cpp.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/****************************************************************************</span>
<a name="l00002"></a>00002 <span class="comment">* Copyright (c) 2019, CEA</span>
<a name="l00003"></a>00003 <span class="comment">* All rights reserved.</span>
<a name="l00004"></a>00004 <span class="comment">*</span>
<a name="l00005"></a>00005 <span class="comment">* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</span>
<a name="l00006"></a>00006 <span class="comment">* 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.</span>
<a name="l00007"></a>00007 <span class="comment">* 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.</span>
<a name="l00008"></a>00008 <span class="comment">* 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.</span>
<a name="l00009"></a>00009 <span class="comment">*</span>
<a name="l00010"></a>00010 <span class="comment">* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.</span>
<a name="l00011"></a>00011 <span class="comment">* IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;</span>
<a name="l00012"></a>00012 <span class="comment">* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>
<a name="l00013"></a>00013 <span class="comment">*</span>
<a name="l00014"></a>00014 <span class="comment">*****************************************************************************/</span>
<a name="l00015"></a>00015 <span class="comment">//</span>
<a name="l00016"></a>00016 <span class="comment">// </span>
<a name="l00017"></a>00017 <span class="comment">// File:        Refine_Mesh.cpp</span>
<a name="l00018"></a>00018 <span class="comment">// Directory:   $TRUST_ROOT/src/Kernel/Geometrie</span>
<a name="l00019"></a>00019 <span class="comment">// Version:     /main/1</span>
<a name="l00020"></a>00020 <span class="comment">// </span>
<a name="l00021"></a>00021 <span class="comment">//</span>
<a name="l00022"></a>00022 
<a name="l00023"></a>00023 <span class="preprocessor">#include &lt;<a class="code" href="Refine__Mesh_8h.html">Refine_Mesh.h</a>&gt;</span>
<a name="l00024"></a>00024 <span class="preprocessor">#include &lt;<a class="code" href="Domaine_8h.html">Domaine.h</a>&gt;</span>
<a name="l00025"></a>00025 <span class="preprocessor">#include &lt;<a class="code" href="Scatter_8h.html">Scatter.h</a>&gt;</span>
<a name="l00026"></a>00026 <span class="preprocessor">#include &lt;<a class="code" href="Static__Int__Lists_8h.html">Static_Int_Lists.h</a>&gt;</span>
<a name="l00027"></a>00027 <span class="preprocessor">#include &lt;<a class="code" href="Array__tools_8h.html">Array_tools.h</a>&gt;</span>
<a name="l00028"></a>00028 <span class="preprocessor">#include &lt;<a class="code" href="Sous__Zone_8h.html">Sous_Zone.h</a>&gt;</span>
<a name="l00029"></a>00029 <span class="preprocessor">#include &lt;<a class="code" href="SChaine_8h.html">SChaine.h</a>&gt;</span>
<a name="l00030"></a>00030 <span class="preprocessor">#include &lt;<a class="code" href="EChaine_8h.html">EChaine.h</a>&gt;</span>
<a name="l00031"></a>00031 
<a name="l00032"></a><a class="code" href="Refine__Mesh_8cpp.html#ae9ce68d5a3100cfd19804863b5ec393a">00032</a> <a class="code" href="Op__Diff__CoviMAC__Face_8cpp.html#aa86ec8ba612a969d9b4370b775037144">Implemente_instanciable</a>(<a class="code" href="classRefine__Mesh.html">Refine_Mesh</a>,<span class="stringliteral">&quot;Refine_Mesh&quot;</span>,<a class="code" href="classInterprete__geometrique__base.html" title="classe Interprete_geometrique_base .">Interprete_geometrique_base</a>) ;
<a name="l00033"></a>00033 
<a name="l00034"></a><a class="code" href="classRefine__Mesh.html#abf034b874be35bfdde63c91f7b711ed4">00034</a> <a class="code" href="classSortie.html" title="Classe de base des flux de sortie. Elle sait ecrire des types simples&lt;br&gt;(entiers, flottants) et des Ob...">Sortie</a>&amp; <a class="code" href="classRefine__Mesh.html#abf034b874be35bfdde63c91f7b711ed4" title="Ecriture de l&#39;objet sur un flot de sortie Methode a surcharger.">Refine_Mesh::printOn</a>(<a class="code" href="classSortie.html" title="Classe de base des flux de sortie. Elle sait ecrire des types simples&lt;br&gt;(entiers, flottants) et des Ob...">Sortie</a>&amp; os)<span class="keyword"> const</span>
<a name="l00035"></a>00035 <span class="keyword"></span>{
<a name="l00036"></a>00036   <a class="code" href="classRefine__Mesh.html#abf034b874be35bfdde63c91f7b711ed4" title="Ecriture de l&#39;objet sur un flot de sortie Methode a surcharger.">Interprete::printOn</a>(os);
<a name="l00037"></a>00037   <span class="keywordflow">return</span> os;
<a name="l00038"></a>00038 }
<a name="l00039"></a>00039 
<a name="l00040"></a><a class="code" href="classRefine__Mesh.html#a2e15b530f3f0c5f5586862b208c9e854">00040</a> <a class="code" href="classEntree.html" title="Classe de definition des operateurs et methodes pour toute lecture dans un flot d&#39;entree (fichier...">Entree</a>&amp; <a class="code" href="classRefine__Mesh.html#a2e15b530f3f0c5f5586862b208c9e854" title="Lecture d&#39;un Objet_U sur un flot d&#39;entree Methode a surcharger.">Refine_Mesh::readOn</a>(<a class="code" href="classEntree.html" title="Classe de definition des operateurs et methodes pour toute lecture dans un flot d&#39;entree (fichier...">Entree</a>&amp; is)
<a name="l00041"></a>00041 {
<a name="l00042"></a>00042   <a class="code" href="classRefine__Mesh.html#a2e15b530f3f0c5f5586862b208c9e854" title="Lecture d&#39;un Objet_U sur un flot d&#39;entree Methode a surcharger.">Interprete::readOn</a>(is);
<a name="l00043"></a>00043   <span class="keywordflow">return</span> is;
<a name="l00044"></a>00044 }
<a name="l00045"></a>00045 <span class="comment">// XD refine_mesh interprete refine_mesh 0 not_set</span>
<a name="l00046"></a>00046 <span class="comment">// XD attr domaine ref_domaine domaine 0 not_set</span>
<a name="l00047"></a><a class="code" href="classRefine__Mesh.html#ab7496a18050b1ff001b6157cac59cc6c">00047</a> <a class="code" href="classEntree.html" title="Classe de definition des operateurs et methodes pour toute lecture dans un flot d&#39;entree (fichier...">Entree</a>&amp; <a class="code" href="classRefine__Mesh.html#ab7496a18050b1ff001b6157cac59cc6c">Refine_Mesh::interpreter_</a>(<a class="code" href="classEntree.html" title="Classe de definition des operateurs et methodes pour toute lecture dans un flot d&#39;entree (fichier...">Entree</a>&amp; is)
<a name="l00048"></a>00048 {
<a name="l00049"></a>00049   <a class="code" href="classInterprete__geometrique__base.html#ac0d2fd316a4bb1585ec579f473684caa">associer_domaine</a>(is);
<a name="l00050"></a>00050   <a class="code" href="classRefine__Mesh.html#a5ee9bbe4b4000cda23a0ada7474735af">apply</a>();
<a name="l00051"></a>00051   <span class="keywordflow">return</span> is;
<a name="l00052"></a>00052 }
<a name="l00053"></a>00053 
<a name="l00054"></a><a class="code" href="classRefine__Mesh.html#a5ee9bbe4b4000cda23a0ada7474735af">00054</a> <span class="keywordtype">void</span> <a class="code" href="classRefine__Mesh.html#a5ee9bbe4b4000cda23a0ada7474735af">Refine_Mesh::apply</a>(<span class="keywordtype">void</span>)
<a name="l00055"></a>00055 {
<a name="l00056"></a>00056   <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Refining domain &quot;</span> &lt;&lt; <a class="code" href="classInterprete__geometrique__base.html#adeeb544dc732989761fb466c0d9cbcbe">domaine</a>().<a class="code" href="classDomaine.html#a87e2cdc035a26565e6fe481446aa4cd3" title="Renvoie le nom du domaine.">le_nom</a>() &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
<a name="l00057"></a>00057 
<a name="l00058"></a>00058   <a class="code" href="classRefine__Mesh.html#afa2fd5ad5d3349b874398f11c74a6e6a">check_dimension</a>();
<a name="l00059"></a>00059   <a class="code" href="classRefine__Mesh.html#a6dfd2353c4b191403885dd9e773eeab1">check_nb_zones</a>();
<a name="l00060"></a>00060   <a class="code" href="classRefine__Mesh.html#a33317f7aa36b6ed9bf1c2519e27d3cf3">check_cell_type</a>();
<a name="l00061"></a>00061 
<a name="l00062"></a>00062   <span class="keywordflow">if</span> ( <a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a> == 2 )
<a name="l00063"></a>00063     {
<a name="l00064"></a>00064       <a class="code" href="classRefine__Mesh.html#a677f6c4f073165ed947bf8a618df8253">apply_2D</a>();
<a name="l00065"></a>00065     }
<a name="l00066"></a>00066   <span class="keywordflow">else</span>
<a name="l00067"></a>00067     {
<a name="l00068"></a>00068       <a class="code" href="classRefine__Mesh.html#a3708a6a10b1b0c66aeadcdbb0bde2237">apply_3D</a>();
<a name="l00069"></a>00069     }
<a name="l00070"></a>00070 
<a name="l00071"></a>00071   <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Refinement... OK&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
<a name="l00072"></a>00072 }
<a name="l00073"></a>00073 
<a name="l00074"></a><a class="code" href="classRefine__Mesh.html#afa2fd5ad5d3349b874398f11c74a6e6a">00074</a> <span class="keywordtype">void</span> <a class="code" href="classRefine__Mesh.html#afa2fd5ad5d3349b874398f11c74a6e6a">Refine_Mesh::check_dimension</a>(<span class="keywordtype">void</span>)<span class="keyword"> const</span>
<a name="l00075"></a>00075 <span class="keyword"></span>{
<a name="l00076"></a>00076   <span class="keywordflow">if</span> ( ! ( (<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a> == 2) || (<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a> == 3) ) )
<a name="l00077"></a>00077     {
<a name="l00078"></a>00078       <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Error in &#39;Refine_Mesh::check_dimension()&#39;:&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
<a name="l00079"></a>00079       <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;  Invalid dimension: &quot;</span> &lt;&lt; <a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a> &lt;&lt; finl;
<a name="l00080"></a>00080       <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;  Refine_Mesh can only deal 2D or 3D domains&quot;</span> &lt;&lt; finl;
<a name="l00081"></a>00081       <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">Process::exit</a>();
<a name="l00082"></a>00082     }
<a name="l00083"></a>00083 }
<a name="l00084"></a>00084 
<a name="l00085"></a><a class="code" href="classRefine__Mesh.html#a6dfd2353c4b191403885dd9e773eeab1">00085</a> <span class="keywordtype">void</span> <a class="code" href="classRefine__Mesh.html#a6dfd2353c4b191403885dd9e773eeab1">Refine_Mesh::check_nb_zones</a>(<span class="keywordtype">void</span>)<span class="keyword"> const</span>
<a name="l00086"></a>00086 <span class="keyword"></span>{
<a name="l00087"></a>00087   <span class="keywordflow">if</span> ( <a class="code" href="classInterprete__geometrique__base.html#adeeb544dc732989761fb466c0d9cbcbe">domaine</a>().nb_zones() != 1 )
<a name="l00088"></a>00088     {
<a name="l00089"></a>00089       <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Error in &#39;Refine_Mesh::check_nb_zones()&#39;:&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
<a name="l00090"></a>00090       <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;  Invalid number of zones: &quot;</span> &lt;&lt; <a class="code" href="classInterprete__geometrique__base.html#adeeb544dc732989761fb466c0d9cbcbe">domaine</a>().<a class="code" href="classDomaine.html#a9f3fc389a1310d1fc8b4b27976855376" title="Renvoie le nombre de zone du domaine.">nb_zones</a>() &lt;&lt; finl;
<a name="l00091"></a>00091       <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;  Refine_Mesh cannot deal with domains having more than one zone&quot;</span> &lt;&lt; finl;
<a name="l00092"></a>00092       <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">Process::exit</a>();
<a name="l00093"></a>00093     }
<a name="l00094"></a>00094 }
<a name="l00095"></a>00095 
<a name="l00096"></a><a class="code" href="classRefine__Mesh.html#a33317f7aa36b6ed9bf1c2519e27d3cf3">00096</a> <span class="keywordtype">void</span> <a class="code" href="classRefine__Mesh.html#a33317f7aa36b6ed9bf1c2519e27d3cf3">Refine_Mesh::check_cell_type</a>(<span class="keywordtype">void</span>)<span class="keyword"> const</span>
<a name="l00097"></a>00097 <span class="keyword"></span>{
<a name="l00098"></a>00098   <span class="keyword">const</span> <a class="code" href="classNom.html" title="class Nom Une chaine de caractere pour nommer les objets de TRUST">Nom</a>&amp; cell_type = <a class="code" href="classInterprete__geometrique__base.html#adeeb544dc732989761fb466c0d9cbcbe">domaine</a>().<a class="code" href="classDomaine.html#a0e62f2bc829542fafa29e3f2c614159c" title="Renvoie la i-ieme zone du domaine. (version const)">zone</a>(0).<a class="code" href="classZone.html#a18cf83cd0f9c368dcfa32fb802a0ac94" title="Renvoie un element geometrique du type de ceux qui constituent la zone. (version const)">type_elem</a>().<a class="code" href="classDeriv__Elem__geom__base.html#a384b487459a33f9f521fb16539ec81de">valeur</a>().<a class="code" href="classObjet__U.html#aa58e9a81c0ddc2c1149053b8f96698ac" title="renvoie la chaine identifiant la classe.">que_suis_je</a>();
<a name="l00099"></a>00099 
<a name="l00100"></a>00100   <span class="keywordflow">if</span> ( ! ( (cell_type == <a class="code" href="classMotcle.html" title="Une chaine de caractere (Nom) en majuscules.">Motcle</a>(<span class="stringliteral">&quot;Triangle&quot;</span>)) || (cell_type == <a class="code" href="classMotcle.html" title="Une chaine de caractere (Nom) en majuscules.">Motcle</a>(<span class="stringliteral">&quot;Tetraedre&quot;</span>)) ) )
<a name="l00101"></a>00101     {
<a name="l00102"></a>00102       <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Error in &#39;Refine_Mesh::check_cell_type()&#39;:&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
<a name="l00103"></a>00103       <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;  Invalid cell type: &quot;</span> &lt;&lt; cell_type &lt;&lt; finl;
<a name="l00104"></a>00104       <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;  Refine_Mesh can only deal with triangles and tetrahedrons&quot;</span> &lt;&lt; finl;
<a name="l00105"></a>00105       <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">Process::exit</a>();
<a name="l00106"></a>00106     }
<a name="l00107"></a>00107 }
<a name="l00108"></a>00108 
<a name="l00109"></a>00109 
<a name="l00110"></a><a class="code" href="classRefine__Mesh.html#a677f6c4f073165ed947bf8a618df8253">00110</a> <span class="keywordtype">void</span> <a class="code" href="classRefine__Mesh.html#a677f6c4f073165ed947bf8a618df8253">Refine_Mesh::apply_2D</a>(<span class="keywordtype">void</span>)
<a name="l00111"></a>00111 {
<a name="l00112"></a>00112   <a class="code" href="classDomaine.html" title="Classe Domaine Un Domaine represente le domaine (spatial) de resolution d&#39;un Probleme. Un Domaine a un Nom, il est constitue d&#39;une ou plusieurs Zone qui peuvent etre eventuellement decoupees en Sous_Zone. Un Domaine porte l&#39;ensemble des sommets utilises par ses Zones. On peut vouloir resoudre des problemes de type different sur plusieurs domaines, geometriquement les domaines sont alors couples par des surfaces qu&#39;on appelle Raccord.">Domaine</a>&amp; domain = <a class="code" href="classInterprete__geometrique__base.html#adeeb544dc732989761fb466c0d9cbcbe">domaine</a>();
<a name="l00113"></a>00113   <a class="code" href="classScatter.html#a8cf934a9b5f7ecb7ef89f61c09804f45" title="methode utilisee par les interpretes qui modifient le domaine&lt;br&gt;(sequentiel), detruit les descripteu...">Scatter::uninit_sequential_domain</a>(domain);
<a name="l00114"></a>00114 
<a name="l00115"></a>00115   assert( domain.<a class="code" href="classDomaine.html#a0e62f2bc829542fafa29e3f2c614159c" title="Renvoie la i-ieme zone du domaine. (version const)">zone</a>(0).<a class="code" href="classZone.html#a18cf83cd0f9c368dcfa32fb802a0ac94" title="Renvoie un element geometrique du type de ceux qui constituent la zone. (version const)">type_elem</a>().<a class="code" href="classDeriv__Elem__geom__base.html#a384b487459a33f9f521fb16539ec81de">valeur</a>().<a class="code" href="classObjet__U.html#aa58e9a81c0ddc2c1149053b8f96698ac" title="renvoie la chaine identifiant la classe.">que_suis_je</a>() == <a class="code" href="classMotcle.html" title="Une chaine de caractere (Nom) en majuscules.">Motcle</a>(<span class="stringliteral">&quot;Triangle&quot;</span>) );
<a name="l00116"></a>00116 
<a name="l00117"></a>00117   <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a> nodes_of_edges;
<a name="l00118"></a>00118   <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a> edges_of_cells;
<a name="l00119"></a>00119   <a class="code" href="classRefine__Mesh.html#a074d8e0266ee2112abae79d79560fd05">build_edges_2D</a>(nodes_of_edges, edges_of_cells);
<a name="l00120"></a>00120 
<a name="l00121"></a>00121   <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a> new_nodes;
<a name="l00122"></a>00122   <a class="code" href="classRefine__Mesh.html#a54d46f98dec0b978b7ff74dc7f3ff33b">build_new_nodes</a>(new_nodes, nodes_of_edges);
<a name="l00123"></a>00123 
<a name="l00124"></a>00124   <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a> new_cells;
<a name="l00125"></a>00125   <a class="code" href="classRefine__Mesh.html#a877f320b09d8c556ffb21fc3ac1a212f">build_new_cells_2D</a>(new_cells, edges_of_cells);
<a name="l00126"></a>00126 
<a name="l00127"></a>00127   <a class="code" href="classNoms.html" title="Un tableau de chaine de caracteres (VECT(Nom))">Noms</a> new_sub_zones_descriptions;
<a name="l00128"></a>00128   <a class="code" href="classRefine__Mesh.html#a64bf7230a3b5e030181c7854f955bc07">build_new_sub_zones_descriptions</a>(new_sub_zones_descriptions);
<a name="l00129"></a>00129 
<a name="l00130"></a>00130   <a class="code" href="classStatic__Int__Lists.html" title="Cette classe permet de stocker des listes d&#39;entiers accessibles en temps constant. La taille des listes ne peut pas changer sans perdre le contenu (ce sont des listes statiques). Exemple: Static_Int_List l; ArrOfInt tailles(3); tailles[0] = 2; tailles[1] = 3; tailles[2] = 0; // On reserve la memoire pour trois listes de taille 2, 3 et 0: l.set_list_sizes(tailles); // On affecte une valeur au deuxieme element de la premiere liste: l.set_value(0,1,765); // Affiche la valeur Cout &lt;&lt; l(0,1);.">Static_Int_Lists</a> incidence_from_node_to_edges;
<a name="l00131"></a>00131   <a class="code" href="classRefine__Mesh.html#a53223e9859b7f16b1ae39c25375c3e60">build_incidence_from_node_to_edges</a>(new_nodes.<a class="code" href="classDoubleTab.html#ac3805e2637a3b880ba2d3e650c69dac4" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(0),nodes_of_edges,incidence_from_node_to_edges);
<a name="l00132"></a>00132 
<a name="l00133"></a>00133   <a class="code" href="Vect_8h.html#adc7c7b04809c9aec2cb897cd2ef06378">VECT</a>(<a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>) new_nodes_of_boundary_faces;
<a name="l00134"></a>00134   <a class="code" href="Vect_8h.html#adc7c7b04809c9aec2cb897cd2ef06378">VECT</a>(<a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>) new_cells_of_boundary_faces;
<a name="l00135"></a>00135   <a class="code" href="classRefine__Mesh.html#ad3acbcaf7686c70c633e52b8d76ec9de">build_new_boundary_faces_2D</a>(new_nodes_of_boundary_faces, new_cells_of_boundary_faces, incidence_from_node_to_edges);
<a name="l00136"></a>00136 
<a name="l00137"></a>00137   <a class="code" href="Vect_8h.html#adc7c7b04809c9aec2cb897cd2ef06378">VECT</a>(<a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>) new_nodes_of_connector_faces;
<a name="l00138"></a>00138   <a class="code" href="Vect_8h.html#adc7c7b04809c9aec2cb897cd2ef06378">VECT</a>(<a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>) new_cells_of_connector_faces;
<a name="l00139"></a>00139   <a class="code" href="classRefine__Mesh.html#a82bcbfaf7cf97e78222056ddd8563937">build_new_connector_faces_2D</a>(new_nodes_of_connector_faces, new_cells_of_connector_faces, incidence_from_node_to_edges);
<a name="l00140"></a>00140 
<a name="l00141"></a>00141   <a class="code" href="Vect_8h.html#adc7c7b04809c9aec2cb897cd2ef06378">VECT</a>(<a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>) new_nodes_of_internal_frontier_faces;
<a name="l00142"></a>00142   <a class="code" href="Vect_8h.html#adc7c7b04809c9aec2cb897cd2ef06378">VECT</a>(<a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>) new_cells_of_internal_frontier_faces;
<a name="l00143"></a>00143   <a class="code" href="classRefine__Mesh.html#a5460eada3cbf31b55fbc1737cb79bc44">build_new_internal_frontier_faces_2D</a>(new_nodes_of_internal_frontier_faces, new_cells_of_internal_frontier_faces, incidence_from_node_to_edges);
<a name="l00144"></a>00144 
<a name="l00145"></a>00145   <a class="code" href="classRefine__Mesh.html#a620588cae22d80d0b570d53548819220">update_domain</a>(<a class="code" href="classNom.html" title="class Nom Une chaine de caractere pour nommer les objets de TRUST">Nom</a>(<span class="stringliteral">&quot;Triangle&quot;</span>),
<a name="l00146"></a>00146                 <a class="code" href="classFaces.html#a62b7dbd959f99b997dc8111210ec8458ae7a86ec0ef1d9a27992dece86ab45ba6">Faces::segment_2D</a>,
<a name="l00147"></a>00147                 new_nodes,
<a name="l00148"></a>00148                 new_cells,
<a name="l00149"></a>00149                 new_sub_zones_descriptions,
<a name="l00150"></a>00150                 new_nodes_of_boundary_faces,
<a name="l00151"></a>00151                 new_cells_of_boundary_faces,
<a name="l00152"></a>00152                 new_nodes_of_connector_faces,
<a name="l00153"></a>00153                 new_cells_of_connector_faces,
<a name="l00154"></a>00154                 new_nodes_of_internal_frontier_faces,
<a name="l00155"></a>00155                 new_cells_of_internal_frontier_faces);
<a name="l00156"></a>00156 
<a name="l00157"></a>00157   <a class="code" href="classScatter.html#a1874139ffd29d5a68191bc7828d3a5bd" title="cree des descripteurs sequentiels pour les tableaux sommets et elements du domaine (necessaire car Sc...">Scatter::init_sequential_domain</a>(domain);
<a name="l00158"></a>00158 }
<a name="l00159"></a>00159 
<a name="l00160"></a><a class="code" href="classRefine__Mesh.html#a3708a6a10b1b0c66aeadcdbb0bde2237">00160</a> <span class="keywordtype">void</span> <a class="code" href="classRefine__Mesh.html#a3708a6a10b1b0c66aeadcdbb0bde2237">Refine_Mesh::apply_3D</a>(<span class="keywordtype">void</span>)
<a name="l00161"></a>00161 {
<a name="l00162"></a>00162   <a class="code" href="classDomaine.html" title="Classe Domaine Un Domaine represente le domaine (spatial) de resolution d&#39;un Probleme. Un Domaine a un Nom, il est constitue d&#39;une ou plusieurs Zone qui peuvent etre eventuellement decoupees en Sous_Zone. Un Domaine porte l&#39;ensemble des sommets utilises par ses Zones. On peut vouloir resoudre des problemes de type different sur plusieurs domaines, geometriquement les domaines sont alors couples par des surfaces qu&#39;on appelle Raccord.">Domaine</a>&amp; domain = <a class="code" href="classInterprete__geometrique__base.html#adeeb544dc732989761fb466c0d9cbcbe">domaine</a>();
<a name="l00163"></a>00163   <a class="code" href="classScatter.html#a8cf934a9b5f7ecb7ef89f61c09804f45" title="methode utilisee par les interpretes qui modifient le domaine&lt;br&gt;(sequentiel), detruit les descripteu...">Scatter::uninit_sequential_domain</a>(domain);
<a name="l00164"></a>00164 
<a name="l00165"></a>00165   assert( domain.<a class="code" href="classDomaine.html#a0e62f2bc829542fafa29e3f2c614159c" title="Renvoie la i-ieme zone du domaine. (version const)">zone</a>(0).<a class="code" href="classZone.html#a18cf83cd0f9c368dcfa32fb802a0ac94" title="Renvoie un element geometrique du type de ceux qui constituent la zone. (version const)">type_elem</a>().<a class="code" href="classDeriv__Elem__geom__base.html#a384b487459a33f9f521fb16539ec81de">valeur</a>().<a class="code" href="classObjet__U.html#aa58e9a81c0ddc2c1149053b8f96698ac" title="renvoie la chaine identifiant la classe.">que_suis_je</a>() == <a class="code" href="classMotcle.html" title="Une chaine de caractere (Nom) en majuscules.">Motcle</a>(<span class="stringliteral">&quot;Tetraedre&quot;</span>) );
<a name="l00166"></a>00166 
<a name="l00167"></a>00167   <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a> nodes_of_edges;
<a name="l00168"></a>00168   <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a> edges_of_cells;
<a name="l00169"></a>00169   <a class="code" href="classRefine__Mesh.html#a13d2266b3d150c63ee07f2eec89d464b">build_edges_3D</a>(nodes_of_edges, edges_of_cells);
<a name="l00170"></a>00170 
<a name="l00171"></a>00171   <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a> new_nodes;
<a name="l00172"></a>00172   <a class="code" href="classRefine__Mesh.html#a54d46f98dec0b978b7ff74dc7f3ff33b">build_new_nodes</a>(new_nodes, nodes_of_edges);
<a name="l00173"></a>00173 
<a name="l00174"></a>00174   <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a> new_cells;
<a name="l00175"></a>00175   <a class="code" href="classRefine__Mesh.html#aa70276800ed649d930fe5ff20e99b4c3">build_new_cells_3D</a>(new_cells, edges_of_cells);
<a name="l00176"></a>00176 
<a name="l00177"></a>00177   <a class="code" href="classNoms.html" title="Un tableau de chaine de caracteres (VECT(Nom))">Noms</a> new_sub_zones_descriptions;
<a name="l00178"></a>00178   <a class="code" href="classRefine__Mesh.html#a64bf7230a3b5e030181c7854f955bc07">build_new_sub_zones_descriptions</a>(new_sub_zones_descriptions);
<a name="l00179"></a>00179 
<a name="l00180"></a>00180   <a class="code" href="classStatic__Int__Lists.html" title="Cette classe permet de stocker des listes d&#39;entiers accessibles en temps constant. La taille des listes ne peut pas changer sans perdre le contenu (ce sont des listes statiques). Exemple: Static_Int_List l; ArrOfInt tailles(3); tailles[0] = 2; tailles[1] = 3; tailles[2] = 0; // On reserve la memoire pour trois listes de taille 2, 3 et 0: l.set_list_sizes(tailles); // On affecte une valeur au deuxieme element de la premiere liste: l.set_value(0,1,765); // Affiche la valeur Cout &lt;&lt; l(0,1);.">Static_Int_Lists</a> incidence_from_node_to_edges;
<a name="l00181"></a>00181   <a class="code" href="classRefine__Mesh.html#a53223e9859b7f16b1ae39c25375c3e60">build_incidence_from_node_to_edges</a>(new_nodes.<a class="code" href="classDoubleTab.html#ac3805e2637a3b880ba2d3e650c69dac4" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(0),nodes_of_edges,incidence_from_node_to_edges);
<a name="l00182"></a>00182 
<a name="l00183"></a>00183   <a class="code" href="Vect_8h.html#adc7c7b04809c9aec2cb897cd2ef06378">VECT</a>(<a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>) new_nodes_of_boundary_faces;
<a name="l00184"></a>00184   <a class="code" href="Vect_8h.html#adc7c7b04809c9aec2cb897cd2ef06378">VECT</a>(<a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>) new_cells_of_boundary_faces;
<a name="l00185"></a>00185   <a class="code" href="classRefine__Mesh.html#ae5a18cc4817b947a39102bfad6dded0d">build_new_boundary_faces_3D</a>(new_nodes_of_boundary_faces, new_cells_of_boundary_faces, incidence_from_node_to_edges);
<a name="l00186"></a>00186 
<a name="l00187"></a>00187   <a class="code" href="Vect_8h.html#adc7c7b04809c9aec2cb897cd2ef06378">VECT</a>(<a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>) new_nodes_of_connector_faces;
<a name="l00188"></a>00188   <a class="code" href="Vect_8h.html#adc7c7b04809c9aec2cb897cd2ef06378">VECT</a>(<a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>) new_cells_of_connector_faces;
<a name="l00189"></a>00189   <a class="code" href="classRefine__Mesh.html#ab8ba9b4eb579026a491944c157c8ced8">build_new_connector_faces_3D</a>(new_nodes_of_connector_faces, new_cells_of_connector_faces, incidence_from_node_to_edges);
<a name="l00190"></a>00190 
<a name="l00191"></a>00191   <a class="code" href="Vect_8h.html#adc7c7b04809c9aec2cb897cd2ef06378">VECT</a>(<a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>) new_nodes_of_internal_frontier_faces;
<a name="l00192"></a>00192   <a class="code" href="Vect_8h.html#adc7c7b04809c9aec2cb897cd2ef06378">VECT</a>(<a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>) new_cells_of_internal_frontier_faces;
<a name="l00193"></a>00193   <a class="code" href="classRefine__Mesh.html#a750b4f0d0f84353e73db1625d2cb625b">build_new_internal_frontier_faces_3D</a>(new_nodes_of_internal_frontier_faces, new_cells_of_internal_frontier_faces, incidence_from_node_to_edges);
<a name="l00194"></a>00194 
<a name="l00195"></a>00195   <a class="code" href="classRefine__Mesh.html#a620588cae22d80d0b570d53548819220">update_domain</a>(<a class="code" href="classNom.html" title="class Nom Une chaine de caractere pour nommer les objets de TRUST">Nom</a>(<span class="stringliteral">&quot;Tetraedre&quot;</span>),
<a name="l00196"></a>00196                 <a class="code" href="classFaces.html#a62b7dbd959f99b997dc8111210ec8458a8d0ad1b612ea277393c4ce895b4ce0af">Faces::triangle_3D</a>,
<a name="l00197"></a>00197                 new_nodes,
<a name="l00198"></a>00198                 new_cells,
<a name="l00199"></a>00199                 new_sub_zones_descriptions,
<a name="l00200"></a>00200                 new_nodes_of_boundary_faces,
<a name="l00201"></a>00201                 new_cells_of_boundary_faces,
<a name="l00202"></a>00202                 new_nodes_of_connector_faces,
<a name="l00203"></a>00203                 new_cells_of_connector_faces,
<a name="l00204"></a>00204                 new_nodes_of_internal_frontier_faces,
<a name="l00205"></a>00205                 new_cells_of_internal_frontier_faces);
<a name="l00206"></a>00206 
<a name="l00207"></a>00207   <a class="code" href="classScatter.html#a1874139ffd29d5a68191bc7828d3a5bd" title="cree des descripteurs sequentiels pour les tableaux sommets et elements du domaine (necessaire car Sc...">Scatter::init_sequential_domain</a>(domain);
<a name="l00208"></a>00208 }
<a name="l00209"></a>00209 
<a name="l00210"></a><a class="code" href="classRefine__Mesh.html#a074d8e0266ee2112abae79d79560fd05">00210</a> <span class="keywordtype">void</span> <a class="code" href="classRefine__Mesh.html#a074d8e0266ee2112abae79d79560fd05">Refine_Mesh::build_edges_2D</a>(<a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; nodes_of_edges, <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; edges_of_cells)<span class="keyword"> const</span>
<a name="l00211"></a>00211 <span class="keyword"></span>{
<a name="l00212"></a>00212   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_edges_per_cell = 3;
<a name="l00213"></a>00213   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_nodes_per_edge = 2;
<a name="l00214"></a>00214 
<a name="l00215"></a>00215   <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a> local_nodes_of_edges(nb_edges_per_cell,nb_nodes_per_edge);
<a name="l00216"></a>00216   local_nodes_of_edges(0,0) = 0;
<a name="l00217"></a>00217   local_nodes_of_edges(0,1) = 1;
<a name="l00218"></a>00218   local_nodes_of_edges(1,0) = 0;
<a name="l00219"></a>00219   local_nodes_of_edges(1,1) = 2;
<a name="l00220"></a>00220   local_nodes_of_edges(2,0) = 1;
<a name="l00221"></a>00221   local_nodes_of_edges(2,1) = 2;
<a name="l00222"></a>00222 
<a name="l00223"></a>00223   <a class="code" href="classRefine__Mesh.html#ae93509a7d0e4fec5af30dce921cd3c55">build_edges</a>(nodes_of_edges, edges_of_cells, nb_edges_per_cell, nb_nodes_per_edge, local_nodes_of_edges);
<a name="l00224"></a>00224 }
<a name="l00225"></a>00225 
<a name="l00226"></a><a class="code" href="classRefine__Mesh.html#a13d2266b3d150c63ee07f2eec89d464b">00226</a> <span class="keywordtype">void</span> <a class="code" href="classRefine__Mesh.html#a13d2266b3d150c63ee07f2eec89d464b">Refine_Mesh::build_edges_3D</a>(<a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; nodes_of_edges, <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; edges_of_cells)<span class="keyword"> const</span>
<a name="l00227"></a>00227 <span class="keyword"></span>{
<a name="l00228"></a>00228   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_edges_per_cell = 6;
<a name="l00229"></a>00229   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_nodes_per_edge = 2;
<a name="l00230"></a>00230 
<a name="l00231"></a>00231   <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a> local_nodes_of_edges(nb_edges_per_cell,nb_nodes_per_edge);
<a name="l00232"></a>00232   local_nodes_of_edges(0,0) = 0;
<a name="l00233"></a>00233   local_nodes_of_edges(0,1) = 1;
<a name="l00234"></a>00234   local_nodes_of_edges(1,0) = 0;
<a name="l00235"></a>00235   local_nodes_of_edges(1,1) = 2;
<a name="l00236"></a>00236   local_nodes_of_edges(2,0) = 0;
<a name="l00237"></a>00237   local_nodes_of_edges(2,1) = 3;
<a name="l00238"></a>00238   local_nodes_of_edges(3,0) = 1;
<a name="l00239"></a>00239   local_nodes_of_edges(3,1) = 2;
<a name="l00240"></a>00240   local_nodes_of_edges(4,0) = 1;
<a name="l00241"></a>00241   local_nodes_of_edges(4,1) = 3;
<a name="l00242"></a>00242   local_nodes_of_edges(5,0) = 2;
<a name="l00243"></a>00243   local_nodes_of_edges(5,1) = 3;
<a name="l00244"></a>00244 
<a name="l00245"></a>00245   <a class="code" href="classRefine__Mesh.html#ae93509a7d0e4fec5af30dce921cd3c55">build_edges</a>(nodes_of_edges, edges_of_cells, nb_edges_per_cell, nb_nodes_per_edge, local_nodes_of_edges);
<a name="l00246"></a>00246 }
<a name="l00247"></a>00247 
<a name="l00248"></a><a class="code" href="classRefine__Mesh.html#ae93509a7d0e4fec5af30dce921cd3c55">00248</a> <span class="keywordtype">void</span> <a class="code" href="classRefine__Mesh.html#ae93509a7d0e4fec5af30dce921cd3c55">Refine_Mesh::build_edges</a>(<a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; nodes_of_edges, <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; edges_of_cells, <span class="keywordtype">int</span> nb_edges_per_cell, <span class="keywordtype">int</span> nb_nodes_per_edge, <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; local_nodes_of_edges)<span class="keyword"> const</span>
<a name="l00249"></a>00249 <span class="keyword"></span>{
<a name="l00250"></a>00250   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; cells = <a class="code" href="classInterprete__geometrique__base.html#adeeb544dc732989761fb466c0d9cbcbe">domaine</a>().<a class="code" href="classDomaine.html#a0e62f2bc829542fafa29e3f2c614159c" title="Renvoie la i-ieme zone du domaine. (version const)">zone</a>(0).<a class="code" href="classZone.html#ac115e8342be89afb882b7b61cc343267" title="Renvoie le tableau des sommets des elements.">les_elems</a>();
<a name="l00251"></a>00251 
<a name="l00252"></a>00252   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_cells = cells.<a class="code" href="classIntTab.html#abc3b32c94925a82f69d5b153a356e359" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(0);
<a name="l00253"></a>00253 
<a name="l00254"></a>00254   <span class="keywordtype">int</span> size = nb_cells * nb_edges_per_cell;
<a name="l00255"></a>00255   <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a> nodes_of_edges_tmp(size,nb_nodes_per_edge);
<a name="l00256"></a>00256   edges_of_cells.<a class="code" href="classIntTab.html#a22e6bed6826b3688d4d0181cbf3b7a38" title="Change la taille du vecteur (identique a resize_array() pour le traitement des anciennes valeurs et d...">resize</a>(nb_cells, nb_edges_per_cell);
<a name="l00257"></a>00257   <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> global_nodes_of_edge(nb_nodes_per_edge);
<a name="l00258"></a>00258 
<a name="l00259"></a>00259   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> c=0; c&lt;nb_cells; ++c)
<a name="l00260"></a>00260     {
<a name="l00261"></a>00261       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> e=0; e&lt;nb_edges_per_cell; ++e)
<a name="l00262"></a>00262         {
<a name="l00263"></a>00263           <span class="keyword">const</span> <span class="keywordtype">int</span> idx = c * nb_edges_per_cell + e;
<a name="l00264"></a>00264 
<a name="l00265"></a>00265           <span class="keywordflow">for</span> (<span class="keywordtype">int</span> n=0; n&lt;nb_nodes_per_edge; ++n)
<a name="l00266"></a>00266             {
<a name="l00267"></a>00267               global_nodes_of_edge[n] = cells(c,local_nodes_of_edges(e,n));
<a name="l00268"></a>00268             }
<a name="l00269"></a>00269 
<a name="l00270"></a>00270           nodes_of_edges_tmp(idx,0) = (global_nodes_of_edge[0]&lt;global_nodes_of_edge[1]) ? global_nodes_of_edge[0] : global_nodes_of_edge[1];
<a name="l00271"></a>00271           nodes_of_edges_tmp(idx,1) = (global_nodes_of_edge[0]&lt;global_nodes_of_edge[1]) ? global_nodes_of_edge[1] : global_nodes_of_edge[0];
<a name="l00272"></a>00272 
<a name="l00273"></a>00273           edges_of_cells(c,e) = idx;
<a name="l00274"></a>00274         }
<a name="l00275"></a>00275     }
<a name="l00276"></a>00276 
<a name="l00277"></a>00277   <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> <a class="code" href="classFrontiere.html#ad40c43f5ed65bfb4a9782e335d72a3d9" title="Renumerote les noeuds (sommets) des faces. Le noeud de numero k devient le noeud de numero Les_Nums[k...">renum</a>;
<a name="l00278"></a>00278   <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> renum_inverse;
<a name="l00279"></a>00279   <a class="code" href="Array__tools_8cpp.html#adba59ffed2ffdd0bfbb9f71307e81533" title="cherche par un tri lexicographique les lignes identiques de &quot;tab&quot; et initialise les tailles et cont...">calculer_renum_sans_doublons</a>(nodes_of_edges_tmp,renum,renum_inverse);
<a name="l00280"></a>00280 
<a name="l00281"></a>00281   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_edges = renum_inverse.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>();
<a name="l00282"></a>00282   nodes_of_edges.<a class="code" href="classIntTab.html#a22e6bed6826b3688d4d0181cbf3b7a38" title="Change la taille du vecteur (identique a resize_array() pour le traitement des anciennes valeurs et d...">resize</a>(nb_edges,nb_nodes_per_edge);
<a name="l00283"></a>00283   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> e=0; e&lt;nb_edges; ++e)
<a name="l00284"></a>00284     {
<a name="l00285"></a>00285       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> n=0; n&lt;nb_nodes_per_edge; ++n)
<a name="l00286"></a>00286         {
<a name="l00287"></a>00287           nodes_of_edges(e,n) = nodes_of_edges_tmp(renum_inverse[e],n);
<a name="l00288"></a>00288         }
<a name="l00289"></a>00289     }
<a name="l00290"></a>00290 
<a name="l00291"></a>00291   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> c=0; c&lt;nb_cells; ++c)
<a name="l00292"></a>00292     {
<a name="l00293"></a>00293       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> e=0; e&lt;nb_edges_per_cell; ++e)
<a name="l00294"></a>00294         {
<a name="l00295"></a>00295           edges_of_cells(c,e) = renum[edges_of_cells(c,e)];
<a name="l00296"></a>00296         }
<a name="l00297"></a>00297     }
<a name="l00298"></a>00298 }
<a name="l00299"></a>00299 
<a name="l00300"></a><a class="code" href="classRefine__Mesh.html#a54d46f98dec0b978b7ff74dc7f3ff33b">00300</a> <span class="keywordtype">void</span> <a class="code" href="classRefine__Mesh.html#a54d46f98dec0b978b7ff74dc7f3ff33b">Refine_Mesh::build_new_nodes</a>(<a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; new_nodes, <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; nodes_of_edges)<span class="keyword"> const</span>
<a name="l00301"></a>00301 <span class="keyword"></span>{
<a name="l00302"></a>00302   <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; nodes = <a class="code" href="classInterprete__geometrique__base.html#adeeb544dc732989761fb466c0d9cbcbe">domaine</a>().<a class="code" href="classDomaine.html#a0846ac03a10b65c4df911fe35a19c02f" title="Renvoie le nombre total de sommets.">les_sommets</a>();
<a name="l00303"></a>00303 
<a name="l00304"></a>00304   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_nodes = nodes.<a class="code" href="classDoubleTab.html#ac3805e2637a3b880ba2d3e650c69dac4" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(0);
<a name="l00305"></a>00305   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_edges = nodes_of_edges.<a class="code" href="classIntTab.html#abc3b32c94925a82f69d5b153a356e359" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(0);
<a name="l00306"></a>00306 
<a name="l00307"></a>00307   new_nodes.<a class="code" href="classDoubleTab.html#ae83b4d31205c53d9c8d2b43da178ce75" title="Change la taille du vecteur (identique a resize_array() pour le traitement des anciennes valeurs et d...">resize</a>(nb_nodes+nb_edges,<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>);
<a name="l00308"></a>00308   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> n=0; n&lt;nb_nodes; ++n)
<a name="l00309"></a>00309     {
<a name="l00310"></a>00310       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>; ++i)
<a name="l00311"></a>00311         {
<a name="l00312"></a>00312           new_nodes(n,i) = nodes(n,i);
<a name="l00313"></a>00313         }
<a name="l00314"></a>00314     }
<a name="l00315"></a>00315 
<a name="l00316"></a>00316   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> e=0; e&lt;nb_edges; ++e)
<a name="l00317"></a>00317     {
<a name="l00318"></a>00318       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>; ++i)
<a name="l00319"></a>00319         {
<a name="l00320"></a>00320           new_nodes(e+nb_nodes,i) = 0.5 * (nodes(nodes_of_edges(e,0),i) + nodes(nodes_of_edges(e,1),i));
<a name="l00321"></a>00321         }
<a name="l00322"></a>00322     }
<a name="l00323"></a>00323 }
<a name="l00324"></a>00324 
<a name="l00325"></a><a class="code" href="classRefine__Mesh.html#a877f320b09d8c556ffb21fc3ac1a212f">00325</a> <span class="keywordtype">void</span> <a class="code" href="classRefine__Mesh.html#a877f320b09d8c556ffb21fc3ac1a212f">Refine_Mesh::build_new_cells_2D</a>(<a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; new_cells, <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; edges_of_cells)<span class="keyword"> const</span>
<a name="l00326"></a>00326 <span class="keyword"></span>{
<a name="l00327"></a>00327   <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; nodes = <a class="code" href="classInterprete__geometrique__base.html#adeeb544dc732989761fb466c0d9cbcbe">domaine</a>().<a class="code" href="classDomaine.html#a0846ac03a10b65c4df911fe35a19c02f" title="Renvoie le nombre total de sommets.">les_sommets</a>();
<a name="l00328"></a>00328   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp;    cells = <a class="code" href="classInterprete__geometrique__base.html#adeeb544dc732989761fb466c0d9cbcbe">domaine</a>().<a class="code" href="classDomaine.html#a0e62f2bc829542fafa29e3f2c614159c" title="Renvoie la i-ieme zone du domaine. (version const)">zone</a>(0).<a class="code" href="classZone.html#ac115e8342be89afb882b7b61cc343267" title="Renvoie le tableau des sommets des elements.">les_elems</a>();
<a name="l00329"></a>00329 
<a name="l00330"></a>00330   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_cells = cells.<a class="code" href="classIntTab.html#abc3b32c94925a82f69d5b153a356e359" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(0);
<a name="l00331"></a>00331   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_nodes = nodes.<a class="code" href="classDoubleTab.html#ac3805e2637a3b880ba2d3e650c69dac4" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(0);
<a name="l00332"></a>00332 
<a name="l00333"></a>00333   new_cells.<a class="code" href="classIntTab.html#a22e6bed6826b3688d4d0181cbf3b7a38" title="Change la taille du vecteur (identique a resize_array() pour le traitement des anciennes valeurs et d...">resize</a>(4*nb_cells,3);
<a name="l00334"></a>00334 
<a name="l00335"></a>00335   <span class="keywordtype">int</span> n0, n1, n2, n01, n02, n12;
<a name="l00336"></a>00336   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> c=0; c&lt;nb_cells; ++c)
<a name="l00337"></a>00337     {
<a name="l00338"></a>00338       n0  = cells(c,0);
<a name="l00339"></a>00339       n1  = cells(c,1);
<a name="l00340"></a>00340       n2  = cells(c,2);
<a name="l00341"></a>00341       n01 = nb_nodes + edges_of_cells(c,0);
<a name="l00342"></a>00342       n02 = nb_nodes + edges_of_cells(c,1);
<a name="l00343"></a>00343       n12 = nb_nodes + edges_of_cells(c,2);
<a name="l00344"></a>00344 
<a name="l00345"></a>00345       new_cells(4*c+0,0) = n0;
<a name="l00346"></a>00346       new_cells(4*c+0,1) = n01;
<a name="l00347"></a>00347       new_cells(4*c+0,2) = n02;
<a name="l00348"></a>00348       new_cells(4*c+1,0) = n01;
<a name="l00349"></a>00349       new_cells(4*c+1,1) = n1;
<a name="l00350"></a>00350       new_cells(4*c+1,2) = n12;
<a name="l00351"></a>00351       new_cells(4*c+2,0) = n02;
<a name="l00352"></a>00352       new_cells(4*c+2,1) = n12;
<a name="l00353"></a>00353       new_cells(4*c+2,2) = n2;
<a name="l00354"></a>00354       new_cells(4*c+3,0) = n12;
<a name="l00355"></a>00355       new_cells(4*c+3,1) = n02;
<a name="l00356"></a>00356       new_cells(4*c+3,2) = n01;
<a name="l00357"></a>00357     }
<a name="l00358"></a>00358 }
<a name="l00359"></a>00359 
<a name="l00360"></a><a class="code" href="classRefine__Mesh.html#aa70276800ed649d930fe5ff20e99b4c3">00360</a> <span class="keywordtype">void</span> <a class="code" href="classRefine__Mesh.html#aa70276800ed649d930fe5ff20e99b4c3">Refine_Mesh::build_new_cells_3D</a>(<a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; new_cells, <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; edges_of_cells)<span class="keyword"> const</span>
<a name="l00361"></a>00361 <span class="keyword"></span>{
<a name="l00362"></a>00362   <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; nodes = <a class="code" href="classInterprete__geometrique__base.html#adeeb544dc732989761fb466c0d9cbcbe">domaine</a>().<a class="code" href="classDomaine.html#a0846ac03a10b65c4df911fe35a19c02f" title="Renvoie le nombre total de sommets.">les_sommets</a>();
<a name="l00363"></a>00363   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp;    cells = <a class="code" href="classInterprete__geometrique__base.html#adeeb544dc732989761fb466c0d9cbcbe">domaine</a>().<a class="code" href="classDomaine.html#a0e62f2bc829542fafa29e3f2c614159c" title="Renvoie la i-ieme zone du domaine. (version const)">zone</a>(0).<a class="code" href="classZone.html#ac115e8342be89afb882b7b61cc343267" title="Renvoie le tableau des sommets des elements.">les_elems</a>();
<a name="l00364"></a>00364 
<a name="l00365"></a>00365   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_cells = cells.<a class="code" href="classIntTab.html#abc3b32c94925a82f69d5b153a356e359" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(0);
<a name="l00366"></a>00366   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_nodes = nodes.<a class="code" href="classDoubleTab.html#ac3805e2637a3b880ba2d3e650c69dac4" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(0);
<a name="l00367"></a>00367 
<a name="l00368"></a>00368   new_cells.<a class="code" href="classIntTab.html#a22e6bed6826b3688d4d0181cbf3b7a38" title="Change la taille du vecteur (identique a resize_array() pour le traitement des anciennes valeurs et d...">resize</a>(8*nb_cells,4);
<a name="l00369"></a>00369 
<a name="l00370"></a>00370   <span class="keywordtype">int</span> n0, n1, n2, n3, n01, n02, n03, n12, n13, n23;
<a name="l00371"></a>00371   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> c=0; c&lt;nb_cells; ++c)
<a name="l00372"></a>00372     {
<a name="l00373"></a>00373       n0  = cells(c,0);
<a name="l00374"></a>00374       n1  = cells(c,1);
<a name="l00375"></a>00375       n2  = cells(c,2);
<a name="l00376"></a>00376       n3  = cells(c,3);
<a name="l00377"></a>00377       n01 = nb_nodes + edges_of_cells(c,0);
<a name="l00378"></a>00378       n02 = nb_nodes + edges_of_cells(c,1);
<a name="l00379"></a>00379       n03 = nb_nodes + edges_of_cells(c,2);
<a name="l00380"></a>00380       n12 = nb_nodes + edges_of_cells(c,3);
<a name="l00381"></a>00381       n13 = nb_nodes + edges_of_cells(c,4);
<a name="l00382"></a>00382       n23 = nb_nodes + edges_of_cells(c,5);
<a name="l00383"></a>00383 
<a name="l00384"></a>00384 
<a name="l00385"></a>00385       new_cells(8*c+0,0) = n0;
<a name="l00386"></a>00386       new_cells(8*c+0,1) = n01;
<a name="l00387"></a>00387       new_cells(8*c+0,2) = n02;
<a name="l00388"></a>00388       new_cells(8*c+0,3) = n03;
<a name="l00389"></a>00389       new_cells(8*c+1,0) = n01;
<a name="l00390"></a>00390       new_cells(8*c+1,1) = n1;
<a name="l00391"></a>00391       new_cells(8*c+1,2) = n12;
<a name="l00392"></a>00392       new_cells(8*c+1,3) = n13;
<a name="l00393"></a>00393       new_cells(8*c+2,0) = n02;
<a name="l00394"></a>00394       new_cells(8*c+2,1) = n12;
<a name="l00395"></a>00395       new_cells(8*c+2,2) = n2;
<a name="l00396"></a>00396       new_cells(8*c+2,3) = n23;
<a name="l00397"></a>00397       new_cells(8*c+3,0) = n03;
<a name="l00398"></a>00398       new_cells(8*c+3,1) = n13;
<a name="l00399"></a>00399       new_cells(8*c+3,2) = n23;
<a name="l00400"></a>00400       new_cells(8*c+3,3) = n3;
<a name="l00401"></a>00401       new_cells(8*c+4,0) = n02;
<a name="l00402"></a>00402       new_cells(8*c+4,1) = n23;
<a name="l00403"></a>00403       new_cells(8*c+4,2) = n13;
<a name="l00404"></a>00404       new_cells(8*c+4,3) = n12;
<a name="l00405"></a>00405       new_cells(8*c+5,0) = n23;
<a name="l00406"></a>00406       new_cells(8*c+5,1) = n13;
<a name="l00407"></a>00407       new_cells(8*c+5,2) = n03;
<a name="l00408"></a>00408       new_cells(8*c+5,3) = n02;
<a name="l00409"></a>00409       new_cells(8*c+6,0) = n13;
<a name="l00410"></a>00410       new_cells(8*c+6,1) = n03;
<a name="l00411"></a>00411       new_cells(8*c+6,2) = n02;
<a name="l00412"></a>00412       new_cells(8*c+6,3) = n01;
<a name="l00413"></a>00413       new_cells(8*c+7,0) = n12;
<a name="l00414"></a>00414       new_cells(8*c+7,1) = n02;
<a name="l00415"></a>00415       new_cells(8*c+7,2) = n01;
<a name="l00416"></a>00416       new_cells(8*c+7,3) = n13;
<a name="l00417"></a>00417     }
<a name="l00418"></a>00418 }
<a name="l00419"></a>00419 
<a name="l00420"></a><a class="code" href="classRefine__Mesh.html#a64bf7230a3b5e030181c7854f955bc07">00420</a> <span class="keywordtype">void</span> <a class="code" href="classRefine__Mesh.html#a64bf7230a3b5e030181c7854f955bc07">Refine_Mesh::build_new_sub_zones_descriptions</a>(<a class="code" href="classNoms.html" title="Un tableau de chaine de caracteres (VECT(Nom))">Noms</a>&amp; sub_zones_descriptions)<span class="keyword"> const</span>
<a name="l00421"></a>00421 <span class="keyword"></span>{
<a name="l00422"></a>00422   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_sub_zones = <a class="code" href="classInterprete__geometrique__base.html#adeeb544dc732989761fb466c0d9cbcbe">domaine</a>().<a class="code" href="classDomaine.html#a247a66a1ad882b7d223f963767cdfe8b" title="Renvoie le nombre de sous-zone.">nb_ss_zones</a>();
<a name="l00423"></a>00423   sub_zones_descriptions.<a class="code" href="classvect__impl.html#ad841d6b676a796bae26ed2566b7b3b41">dimensionner</a>(nb_sub_zones);
<a name="l00424"></a>00424 
<a name="l00425"></a>00425   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_new_cells_per_old_cell = (<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a> == 2) ? 4 : 8;
<a name="l00426"></a>00426 
<a name="l00427"></a>00427   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;nb_sub_zones; ++i)
<a name="l00428"></a>00428     {
<a name="l00429"></a>00429       <span class="keyword">const</span> <a class="code" href="classSous__Zone.html" title="Classe Sous_Zone Represente une sous zone volumique i.e un sous ensemble de polyedres d&#39;un objet de t...">Sous_Zone</a>&amp; sub_zone = <a class="code" href="classInterprete__geometrique__base.html#adeeb544dc732989761fb466c0d9cbcbe">domaine</a>().<a class="code" href="classDomaine.html#ad38f4fc3c0e1b44dc9fdc947985178a5" title="Renvoie la i-ieme sous-zone. (version const)">ss_zone</a>(i);
<a name="l00430"></a>00430       <span class="keyword">const</span> <span class="keywordtype">int</span> old_nb_cells_in_sub_zone = sub_zone.<a class="code" href="classSous__Zone.html#a4266863124b1b4ce971ac57a6ec746e9" title="Returns the subzone number of elements (real+virtual elements in parallel)">nb_elem_tot</a>();
<a name="l00431"></a>00431       <span class="keyword">const</span> <span class="keywordtype">int</span> new_nb_cells_in_sub_zone = old_nb_cells_in_sub_zone * nb_new_cells_per_old_cell;
<a name="l00432"></a>00432       <a class="code" href="classIntVect.html">IntVect</a> new_sub_zone_cells(new_nb_cells_in_sub_zone);
<a name="l00433"></a>00433       <span class="keywordtype">int</span> idx = 0;
<a name="l00434"></a>00434       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> c=0; c&lt;old_nb_cells_in_sub_zone; ++c)
<a name="l00435"></a>00435         {
<a name="l00436"></a>00436           <span class="keyword">const</span> <span class="keywordtype">int</span> old_cell = sub_zone[c];
<a name="l00437"></a>00437           <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j=0; j&lt;nb_new_cells_per_old_cell; ++j)
<a name="l00438"></a>00438             {
<a name="l00439"></a>00439               new_sub_zone_cells[idx] = old_cell*nb_new_cells_per_old_cell+j;
<a name="l00440"></a>00440               ++idx;
<a name="l00441"></a>00441             }
<a name="l00442"></a>00442         }
<a name="l00443"></a>00443 
<a name="l00444"></a>00444       <a class="code" href="classSChaine.html" title="Cette classe derivee de Sortie empile ce qu&#39;on lui envoie dans une chaine de caracteres. On recupere le contenu de la chaine avec get_str().">SChaine</a> os;
<a name="l00445"></a>00445       os &lt;&lt; <span class="stringliteral">&quot; { Liste &quot;</span> &lt;&lt; new_sub_zone_cells &lt;&lt; <span class="stringliteral">&quot; } &quot;</span>;
<a name="l00446"></a>00446       sub_zones_descriptions[i] = <a class="code" href="classNom.html" title="class Nom Une chaine de caractere pour nommer les objets de TRUST">Nom</a>(os.<a class="code" href="classSChaine.html#a8ed820eca8d79e52fb50520d02637315" title="returns a copy of the string stored by the SChaine">get_str</a>());
<a name="l00447"></a>00447     }
<a name="l00448"></a>00448 }
<a name="l00449"></a>00449 
<a name="l00450"></a><a class="code" href="classRefine__Mesh.html#a53223e9859b7f16b1ae39c25375c3e60">00450</a> <span class="keywordtype">void</span> <a class="code" href="classRefine__Mesh.html#a53223e9859b7f16b1ae39c25375c3e60">Refine_Mesh::build_incidence_from_node_to_edges</a>(<span class="keywordtype">int</span>            nb_nodes,
<a name="l00451"></a>00451                                                      <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp;     nodes_of_edges,
<a name="l00452"></a>00452                                                      <a class="code" href="classStatic__Int__Lists.html" title="Cette classe permet de stocker des listes d&#39;entiers accessibles en temps constant. La taille des listes ne peut pas changer sans perdre le contenu (ce sont des listes statiques). Exemple: Static_Int_List l; ArrOfInt tailles(3); tailles[0] = 2; tailles[1] = 3; tailles[2] = 0; // On reserve la memoire pour trois listes de taille 2, 3 et 0: l.set_list_sizes(tailles); // On affecte une valeur au deuxieme element de la premiere liste: l.set_value(0,1,765); // Affiche la valeur Cout &lt;&lt; l(0,1);.">Static_Int_Lists</a>&amp; incidence)<span class="keyword"> const</span>
<a name="l00453"></a>00453 <span class="keyword"></span>{
<a name="l00454"></a>00454   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_edges          = nodes_of_edges.<a class="code" href="classIntTab.html#abc3b32c94925a82f69d5b153a356e359" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(0);
<a name="l00455"></a>00455   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_nodes_per_edge = nodes_of_edges.<a class="code" href="classIntTab.html#abc3b32c94925a82f69d5b153a356e359" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(1);
<a name="l00456"></a>00456 
<a name="l00457"></a>00457   <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> nb_incident_edges(nb_nodes);
<a name="l00458"></a>00458 
<a name="l00459"></a>00459   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> edge=0; edge&lt;nb_edges; ++edge)
<a name="l00460"></a>00460     {
<a name="l00461"></a>00461       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> n=0; n&lt;nb_nodes_per_edge; ++n)
<a name="l00462"></a>00462         {
<a name="l00463"></a>00463           <span class="keyword">const</span> <span class="keywordtype">int</span> node = nodes_of_edges(edge,n);
<a name="l00464"></a>00464           ++nb_incident_edges[node];
<a name="l00465"></a>00465         }
<a name="l00466"></a>00466     }
<a name="l00467"></a>00467 
<a name="l00468"></a>00468   incidence.<a class="code" href="classStatic__Int__Lists.html#a60da63cb1970f5b87d1e1fdf6d65dcb2" title="detruit les listes existantes et en cree de nouvelles. On cree autant de listes que d&#39;elements dans l...">set_list_sizes</a>(nb_incident_edges);
<a name="l00469"></a>00469 
<a name="l00470"></a>00470   nb_incident_edges = 0;
<a name="l00471"></a>00471   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> edge=0; edge&lt;nb_edges; ++edge)
<a name="l00472"></a>00472     {
<a name="l00473"></a>00473       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> n=0; n&lt;nb_nodes_per_edge; ++n)
<a name="l00474"></a>00474         {
<a name="l00475"></a>00475           <span class="keyword">const</span> <span class="keywordtype">int</span> node  = nodes_of_edges(edge,n);
<a name="l00476"></a>00476           <span class="keyword">const</span> <span class="keywordtype">int</span> index = nb_incident_edges[node];
<a name="l00477"></a>00477           incidence.<a class="code" href="classStatic__Int__Lists.html#ab56f42945e3057185cc1086e1cbc1bbb" title="affecte la &quot;valeur&quot; au j-ieme element de la i-ieme liste avec 0 &lt;= i &lt; get_nb_lists() et 0 &lt;= j &lt; get...">set_value</a>(node, index, edge);
<a name="l00478"></a>00478           ++nb_incident_edges[node];
<a name="l00479"></a>00479         }
<a name="l00480"></a>00480     }
<a name="l00481"></a>00481 
<a name="l00482"></a>00482   incidence.<a class="code" href="classStatic__Int__Lists.html#ac6174c2ad8e64329eb7a90538cdf8c9c" title="tri par ordre croissant des valeurs de la i-ieme liste. Si num_liste &lt; 0, on trie toutes les listes...">trier_liste</a>(-1);
<a name="l00483"></a>00483 }
<a name="l00484"></a>00484 
<a name="l00485"></a><a class="code" href="classRefine__Mesh.html#ad3acbcaf7686c70c633e52b8d76ec9de">00485</a> <span class="keywordtype">void</span> <a class="code" href="classRefine__Mesh.html#ad3acbcaf7686c70c633e52b8d76ec9de">Refine_Mesh::build_new_boundary_faces_2D</a>(<a class="code" href="Vect_8h.html#adc7c7b04809c9aec2cb897cd2ef06378">VECT</a>(<a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>)&amp;           new_nodes_of_boundary_faces,
<a name="l00486"></a>00486                                               <a class="code" href="Vect_8h.html#adc7c7b04809c9aec2cb897cd2ef06378">VECT</a>(<a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>)&amp;           new_cells_of_boundary_faces,
<a name="l00487"></a>00487                                               <span class="keyword">const</span> <a class="code" href="classStatic__Int__Lists.html" title="Cette classe permet de stocker des listes d&#39;entiers accessibles en temps constant. La taille des listes ne peut pas changer sans perdre le contenu (ce sont des listes statiques). Exemple: Static_Int_List l; ArrOfInt tailles(3); tailles[0] = 2; tailles[1] = 3; tailles[2] = 0; // On reserve la memoire pour trois listes de taille 2, 3 et 0: l.set_list_sizes(tailles); // On affecte une valeur au deuxieme element de la premiere liste: l.set_value(0,1,765); // Affiche la valeur Cout &lt;&lt; l(0,1);.">Static_Int_Lists</a>&amp; incidence_from_node_to_edges)<span class="keyword"> const</span>
<a name="l00488"></a>00488 <span class="keyword"></span>{
<a name="l00489"></a>00489   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_boundaries = <a class="code" href="classInterprete__geometrique__base.html#adeeb544dc732989761fb466c0d9cbcbe">domaine</a>().<a class="code" href="classDomaine.html#a0e62f2bc829542fafa29e3f2c614159c" title="Renvoie la i-ieme zone du domaine. (version const)">zone</a>(0).<a class="code" href="classZone.html#a7d6ba9a2216d306cb0a0bf3dfff6f170" title="Renvoie le nombre de bords de la zone.">nb_bords</a>();
<a name="l00490"></a>00490   new_nodes_of_boundary_faces.dimensionner(nb_boundaries);
<a name="l00491"></a>00491   new_cells_of_boundary_faces.dimensionner(nb_boundaries);
<a name="l00492"></a>00492 
<a name="l00493"></a>00493   <span class="keywordtype">int</span> boundary = 0;
<a name="l00494"></a>00494   <a class="code" href="List_8h.html#add189d7375e577842ac891b09afc6d4b">CONST_LIST_CURSEUR</a>(<a class="code" href="classBord.html" title="Classe Bord Cette classe represente un bord d&#39;une zone, c&#39;est un type de frontiere&lt;br&gt;(derive de Fronti...">Bord</a>) cursor(<a class="code" href="classInterprete__geometrique__base.html#adeeb544dc732989761fb466c0d9cbcbe">domaine</a>().<a class="code" href="classFrontiere.html#a510866aace5f3ed9482553db1a08a3c9" title="Renvoie la Zone associee a la frontiere. (version const)">zone</a>(0).faces_bord());
<a name="l00495"></a>00495   <span class="keywordflow">while</span> (cursor)
<a name="l00496"></a>00496     {
<a name="l00497"></a>00497       <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; nodes = new_nodes_of_boundary_faces[boundary];
<a name="l00498"></a>00498       <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; cells = new_cells_of_boundary_faces[boundary];
<a name="l00499"></a>00499       <a class="code" href="classRefine__Mesh.html#ab6e54652e5457c10890866e7d4552992">build_new_frontier_faces_2D</a>(nodes,cells,incidence_from_node_to_edges,cursor.valeur().faces());
<a name="l00500"></a>00500       ++cursor;
<a name="l00501"></a>00501       ++boundary;
<a name="l00502"></a>00502     }
<a name="l00503"></a>00503 }
<a name="l00504"></a>00504 
<a name="l00505"></a><a class="code" href="classRefine__Mesh.html#ae5a18cc4817b947a39102bfad6dded0d">00505</a> <span class="keywordtype">void</span> <a class="code" href="classRefine__Mesh.html#ae5a18cc4817b947a39102bfad6dded0d">Refine_Mesh::build_new_boundary_faces_3D</a>(<a class="code" href="Vect_8h.html#adc7c7b04809c9aec2cb897cd2ef06378">VECT</a>(<a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>)&amp;           new_nodes_of_boundary_faces,
<a name="l00506"></a>00506                                               <a class="code" href="Vect_8h.html#adc7c7b04809c9aec2cb897cd2ef06378">VECT</a>(<a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>)&amp;           new_cells_of_boundary_faces,
<a name="l00507"></a>00507                                               <span class="keyword">const</span> <a class="code" href="classStatic__Int__Lists.html" title="Cette classe permet de stocker des listes d&#39;entiers accessibles en temps constant. La taille des listes ne peut pas changer sans perdre le contenu (ce sont des listes statiques). Exemple: Static_Int_List l; ArrOfInt tailles(3); tailles[0] = 2; tailles[1] = 3; tailles[2] = 0; // On reserve la memoire pour trois listes de taille 2, 3 et 0: l.set_list_sizes(tailles); // On affecte une valeur au deuxieme element de la premiere liste: l.set_value(0,1,765); // Affiche la valeur Cout &lt;&lt; l(0,1);.">Static_Int_Lists</a>&amp; incidence_from_node_to_edges)<span class="keyword"> const</span>
<a name="l00508"></a>00508 <span class="keyword"></span>{
<a name="l00509"></a>00509   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_boundaries = <a class="code" href="classInterprete__geometrique__base.html#adeeb544dc732989761fb466c0d9cbcbe">domaine</a>().<a class="code" href="classDomaine.html#a0e62f2bc829542fafa29e3f2c614159c" title="Renvoie la i-ieme zone du domaine. (version const)">zone</a>(0).<a class="code" href="classZone.html#a7d6ba9a2216d306cb0a0bf3dfff6f170" title="Renvoie le nombre de bords de la zone.">nb_bords</a>();
<a name="l00510"></a>00510   new_nodes_of_boundary_faces.dimensionner(nb_boundaries);
<a name="l00511"></a>00511   new_cells_of_boundary_faces.dimensionner(nb_boundaries);
<a name="l00512"></a>00512 
<a name="l00513"></a>00513   <span class="keywordtype">int</span> boundary = 0;
<a name="l00514"></a>00514   <a class="code" href="List_8h.html#add189d7375e577842ac891b09afc6d4b">CONST_LIST_CURSEUR</a>(<a class="code" href="classBord.html" title="Classe Bord Cette classe represente un bord d&#39;une zone, c&#39;est un type de frontiere&lt;br&gt;(derive de Fronti...">Bord</a>) cursor(<a class="code" href="classInterprete__geometrique__base.html#adeeb544dc732989761fb466c0d9cbcbe">domaine</a>().<a class="code" href="classFrontiere.html#a510866aace5f3ed9482553db1a08a3c9" title="Renvoie la Zone associee a la frontiere. (version const)">zone</a>(0).faces_bord());
<a name="l00515"></a>00515   <span class="keywordflow">while</span> (cursor)
<a name="l00516"></a>00516     {
<a name="l00517"></a>00517       <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; nodes = new_nodes_of_boundary_faces[boundary];
<a name="l00518"></a>00518       <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; cells = new_cells_of_boundary_faces[boundary];
<a name="l00519"></a>00519       <a class="code" href="classRefine__Mesh.html#a83db22e27c80654ebf08628416864fcc">build_new_frontier_faces_3D</a>(nodes,cells,incidence_from_node_to_edges,cursor.valeur().faces());
<a name="l00520"></a>00520       ++cursor;
<a name="l00521"></a>00521       ++boundary;
<a name="l00522"></a>00522     }
<a name="l00523"></a>00523 }
<a name="l00524"></a>00524 
<a name="l00525"></a><a class="code" href="classRefine__Mesh.html#a82bcbfaf7cf97e78222056ddd8563937">00525</a> <span class="keywordtype">void</span> <a class="code" href="classRefine__Mesh.html#a82bcbfaf7cf97e78222056ddd8563937">Refine_Mesh::build_new_connector_faces_2D</a>(<a class="code" href="Vect_8h.html#adc7c7b04809c9aec2cb897cd2ef06378">VECT</a>(<a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>)&amp;           new_nodes_of_connector_faces,
<a name="l00526"></a>00526                                                <a class="code" href="Vect_8h.html#adc7c7b04809c9aec2cb897cd2ef06378">VECT</a>(<a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>)&amp;           new_cells_of_connector_faces,
<a name="l00527"></a>00527                                                <span class="keyword">const</span> <a class="code" href="classStatic__Int__Lists.html" title="Cette classe permet de stocker des listes d&#39;entiers accessibles en temps constant. La taille des listes ne peut pas changer sans perdre le contenu (ce sont des listes statiques). Exemple: Static_Int_List l; ArrOfInt tailles(3); tailles[0] = 2; tailles[1] = 3; tailles[2] = 0; // On reserve la memoire pour trois listes de taille 2, 3 et 0: l.set_list_sizes(tailles); // On affecte une valeur au deuxieme element de la premiere liste: l.set_value(0,1,765); // Affiche la valeur Cout &lt;&lt; l(0,1);.">Static_Int_Lists</a>&amp; incidence_from_node_to_edges)<span class="keyword"> const</span>
<a name="l00528"></a>00528 <span class="keyword"></span>{
<a name="l00529"></a>00529   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_connectors = <a class="code" href="classInterprete__geometrique__base.html#adeeb544dc732989761fb466c0d9cbcbe">domaine</a>().<a class="code" href="classDomaine.html#a0e62f2bc829542fafa29e3f2c614159c" title="Renvoie la i-ieme zone du domaine. (version const)">zone</a>(0).<a class="code" href="classZone.html#a150d1dac14da48d5f22abdae26fd85f3" title="Renvoie le nombre de raccords de la zone.">nb_raccords</a>();
<a name="l00530"></a>00530   new_nodes_of_connector_faces.dimensionner(nb_connectors);
<a name="l00531"></a>00531   new_cells_of_connector_faces.dimensionner(nb_connectors);
<a name="l00532"></a>00532 
<a name="l00533"></a>00533   <span class="keywordtype">int</span> connector = 0;
<a name="l00534"></a>00534   <a class="code" href="List_8h.html#add189d7375e577842ac891b09afc6d4b">CONST_LIST_CURSEUR</a>(<a class="code" href="classRaccord.html" title="Classe Raccord Classe generique de la hierarchie des raccords, un objet Raccord peut referencer n&#39;imp...">Raccord</a>) cursor(<a class="code" href="classInterprete__geometrique__base.html#adeeb544dc732989761fb466c0d9cbcbe">domaine</a>().<a class="code" href="classFrontiere.html#a510866aace5f3ed9482553db1a08a3c9" title="Renvoie la Zone associee a la frontiere. (version const)">zone</a>(0).faces_raccord());
<a name="l00535"></a>00535   <span class="keywordflow">while</span> (cursor)
<a name="l00536"></a>00536     {
<a name="l00537"></a>00537       <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; nodes = new_nodes_of_connector_faces[connector];
<a name="l00538"></a>00538       <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; cells = new_cells_of_connector_faces[connector];
<a name="l00539"></a>00539       <a class="code" href="classRefine__Mesh.html#ab6e54652e5457c10890866e7d4552992">build_new_frontier_faces_2D</a>(nodes,cells,incidence_from_node_to_edges,cursor.valeur().valeur().faces());
<a name="l00540"></a>00540       ++cursor;
<a name="l00541"></a>00541       ++connector;
<a name="l00542"></a>00542     }
<a name="l00543"></a>00543 }
<a name="l00544"></a>00544 
<a name="l00545"></a><a class="code" href="classRefine__Mesh.html#ab8ba9b4eb579026a491944c157c8ced8">00545</a> <span class="keywordtype">void</span> <a class="code" href="classRefine__Mesh.html#ab8ba9b4eb579026a491944c157c8ced8">Refine_Mesh::build_new_connector_faces_3D</a>(<a class="code" href="Vect_8h.html#adc7c7b04809c9aec2cb897cd2ef06378">VECT</a>(<a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>)&amp;           new_nodes_of_connector_faces,
<a name="l00546"></a>00546                                                <a class="code" href="Vect_8h.html#adc7c7b04809c9aec2cb897cd2ef06378">VECT</a>(<a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>)&amp;           new_cells_of_connector_faces,
<a name="l00547"></a>00547                                                <span class="keyword">const</span> <a class="code" href="classStatic__Int__Lists.html" title="Cette classe permet de stocker des listes d&#39;entiers accessibles en temps constant. La taille des listes ne peut pas changer sans perdre le contenu (ce sont des listes statiques). Exemple: Static_Int_List l; ArrOfInt tailles(3); tailles[0] = 2; tailles[1] = 3; tailles[2] = 0; // On reserve la memoire pour trois listes de taille 2, 3 et 0: l.set_list_sizes(tailles); // On affecte une valeur au deuxieme element de la premiere liste: l.set_value(0,1,765); // Affiche la valeur Cout &lt;&lt; l(0,1);.">Static_Int_Lists</a>&amp; incidence_from_node_to_edges)<span class="keyword"> const</span>
<a name="l00548"></a>00548 <span class="keyword"></span>{
<a name="l00549"></a>00549   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_connectors = <a class="code" href="classInterprete__geometrique__base.html#adeeb544dc732989761fb466c0d9cbcbe">domaine</a>().<a class="code" href="classDomaine.html#a0e62f2bc829542fafa29e3f2c614159c" title="Renvoie la i-ieme zone du domaine. (version const)">zone</a>(0).<a class="code" href="classZone.html#a150d1dac14da48d5f22abdae26fd85f3" title="Renvoie le nombre de raccords de la zone.">nb_raccords</a>();
<a name="l00550"></a>00550   new_nodes_of_connector_faces.dimensionner(nb_connectors);
<a name="l00551"></a>00551   new_cells_of_connector_faces.dimensionner(nb_connectors);
<a name="l00552"></a>00552 
<a name="l00553"></a>00553   <span class="keywordtype">int</span> connector = 0;
<a name="l00554"></a>00554   <a class="code" href="List_8h.html#add189d7375e577842ac891b09afc6d4b">CONST_LIST_CURSEUR</a>(<a class="code" href="classRaccord.html" title="Classe Raccord Classe generique de la hierarchie des raccords, un objet Raccord peut referencer n&#39;imp...">Raccord</a>) cursor(<a class="code" href="classInterprete__geometrique__base.html#adeeb544dc732989761fb466c0d9cbcbe">domaine</a>().<a class="code" href="classFrontiere.html#a510866aace5f3ed9482553db1a08a3c9" title="Renvoie la Zone associee a la frontiere. (version const)">zone</a>(0).faces_raccord());
<a name="l00555"></a>00555   <span class="keywordflow">while</span> (cursor)
<a name="l00556"></a>00556     {
<a name="l00557"></a>00557       <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; nodes = new_nodes_of_connector_faces[connector];
<a name="l00558"></a>00558       <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; cells = new_cells_of_connector_faces[connector];
<a name="l00559"></a>00559       <a class="code" href="classRefine__Mesh.html#a83db22e27c80654ebf08628416864fcc">build_new_frontier_faces_3D</a>(nodes,cells,incidence_from_node_to_edges,cursor.valeur().valeur().faces());
<a name="l00560"></a>00560       ++cursor;
<a name="l00561"></a>00561       ++connector;
<a name="l00562"></a>00562     }
<a name="l00563"></a>00563 }
<a name="l00564"></a>00564 
<a name="l00565"></a>00565 
<a name="l00566"></a><a class="code" href="classRefine__Mesh.html#a5460eada3cbf31b55fbc1737cb79bc44">00566</a> <span class="keywordtype">void</span> <a class="code" href="classRefine__Mesh.html#a5460eada3cbf31b55fbc1737cb79bc44">Refine_Mesh::build_new_internal_frontier_faces_2D</a>(<a class="code" href="Vect_8h.html#adc7c7b04809c9aec2cb897cd2ef06378">VECT</a>(<a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>)&amp;           new_nodes_of_internal_frontier_faces,
<a name="l00567"></a>00567                                                        <a class="code" href="Vect_8h.html#adc7c7b04809c9aec2cb897cd2ef06378">VECT</a>(<a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>)&amp;           new_cells_of_internal_frontier_faces,
<a name="l00568"></a>00568                                                        <span class="keyword">const</span> <a class="code" href="classStatic__Int__Lists.html" title="Cette classe permet de stocker des listes d&#39;entiers accessibles en temps constant. La taille des listes ne peut pas changer sans perdre le contenu (ce sont des listes statiques). Exemple: Static_Int_List l; ArrOfInt tailles(3); tailles[0] = 2; tailles[1] = 3; tailles[2] = 0; // On reserve la memoire pour trois listes de taille 2, 3 et 0: l.set_list_sizes(tailles); // On affecte une valeur au deuxieme element de la premiere liste: l.set_value(0,1,765); // Affiche la valeur Cout &lt;&lt; l(0,1);.">Static_Int_Lists</a>&amp; incidence_from_node_to_edges)<span class="keyword"> const</span>
<a name="l00569"></a>00569 <span class="keyword"></span>{
<a name="l00570"></a>00570   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_internal_frontier = <a class="code" href="classInterprete__geometrique__base.html#adeeb544dc732989761fb466c0d9cbcbe">domaine</a>().<a class="code" href="classDomaine.html#a0e62f2bc829542fafa29e3f2c614159c" title="Renvoie la i-ieme zone du domaine. (version const)">zone</a>(0).<a class="code" href="classZone.html#a7b5f5bf35f453887740c1729d7e9e492" title="Renvoie le nombre de frontieres internes de la zone.">nb_frontieres_internes</a>();
<a name="l00571"></a>00571   new_nodes_of_internal_frontier_faces.dimensionner(nb_internal_frontier);
<a name="l00572"></a>00572   new_cells_of_internal_frontier_faces.dimensionner(nb_internal_frontier);
<a name="l00573"></a>00573 
<a name="l00574"></a>00574   <span class="keywordtype">int</span> internal_frontier = 0;
<a name="l00575"></a>00575   <a class="code" href="List_8h.html#add189d7375e577842ac891b09afc6d4b">CONST_LIST_CURSEUR</a>(<a class="code" href="classFaces__Interne.html" title="Classe Faces_Interne La classe sert a representer un ensemble de faces qui sont internes d&#39;un point d...">Faces_Interne</a>) cursor(<a class="code" href="classInterprete__geometrique__base.html#adeeb544dc732989761fb466c0d9cbcbe">domaine</a>().<a class="code" href="classFrontiere.html#a510866aace5f3ed9482553db1a08a3c9" title="Renvoie la Zone associee a la frontiere. (version const)">zone</a>(0).faces_int());
<a name="l00576"></a>00576   <span class="keywordflow">while</span> (cursor)
<a name="l00577"></a>00577     {
<a name="l00578"></a>00578       <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; nodes = new_nodes_of_internal_frontier_faces[internal_frontier];
<a name="l00579"></a>00579       <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; cells = new_cells_of_internal_frontier_faces[internal_frontier];
<a name="l00580"></a>00580       <a class="code" href="classRefine__Mesh.html#ab6e54652e5457c10890866e7d4552992">build_new_frontier_faces_2D</a>(nodes,cells,incidence_from_node_to_edges,cursor.valeur().faces());
<a name="l00581"></a>00581       ++cursor;
<a name="l00582"></a>00582       ++internal_frontier;
<a name="l00583"></a>00583     }
<a name="l00584"></a>00584 }
<a name="l00585"></a>00585 
<a name="l00586"></a>00586 
<a name="l00587"></a><a class="code" href="classRefine__Mesh.html#a750b4f0d0f84353e73db1625d2cb625b">00587</a> <span class="keywordtype">void</span> <a class="code" href="classRefine__Mesh.html#a750b4f0d0f84353e73db1625d2cb625b">Refine_Mesh::build_new_internal_frontier_faces_3D</a>(<a class="code" href="Vect_8h.html#adc7c7b04809c9aec2cb897cd2ef06378">VECT</a>(<a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>)&amp;           new_nodes_of_internal_frontier_faces,
<a name="l00588"></a>00588                                                        <a class="code" href="Vect_8h.html#adc7c7b04809c9aec2cb897cd2ef06378">VECT</a>(<a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>)&amp;           new_cells_of_internal_frontier_faces,
<a name="l00589"></a>00589                                                        <span class="keyword">const</span> <a class="code" href="classStatic__Int__Lists.html" title="Cette classe permet de stocker des listes d&#39;entiers accessibles en temps constant. La taille des listes ne peut pas changer sans perdre le contenu (ce sont des listes statiques). Exemple: Static_Int_List l; ArrOfInt tailles(3); tailles[0] = 2; tailles[1] = 3; tailles[2] = 0; // On reserve la memoire pour trois listes de taille 2, 3 et 0: l.set_list_sizes(tailles); // On affecte une valeur au deuxieme element de la premiere liste: l.set_value(0,1,765); // Affiche la valeur Cout &lt;&lt; l(0,1);.">Static_Int_Lists</a>&amp; incidence_from_node_to_edges)<span class="keyword"> const</span>
<a name="l00590"></a>00590 <span class="keyword"></span>{
<a name="l00591"></a>00591   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_internal_frontier = <a class="code" href="classInterprete__geometrique__base.html#adeeb544dc732989761fb466c0d9cbcbe">domaine</a>().<a class="code" href="classDomaine.html#a0e62f2bc829542fafa29e3f2c614159c" title="Renvoie la i-ieme zone du domaine. (version const)">zone</a>(0).<a class="code" href="classZone.html#a7b5f5bf35f453887740c1729d7e9e492" title="Renvoie le nombre de frontieres internes de la zone.">nb_frontieres_internes</a>();
<a name="l00592"></a>00592   new_nodes_of_internal_frontier_faces.dimensionner(nb_internal_frontier);
<a name="l00593"></a>00593   new_cells_of_internal_frontier_faces.dimensionner(nb_internal_frontier);
<a name="l00594"></a>00594 
<a name="l00595"></a>00595   <span class="keywordtype">int</span> internal_frontier = 0;
<a name="l00596"></a>00596   <a class="code" href="List_8h.html#add189d7375e577842ac891b09afc6d4b">CONST_LIST_CURSEUR</a>(<a class="code" href="classFaces__Interne.html" title="Classe Faces_Interne La classe sert a representer un ensemble de faces qui sont internes d&#39;un point d...">Faces_Interne</a>) cursor(<a class="code" href="classInterprete__geometrique__base.html#adeeb544dc732989761fb466c0d9cbcbe">domaine</a>().<a class="code" href="classFrontiere.html#a510866aace5f3ed9482553db1a08a3c9" title="Renvoie la Zone associee a la frontiere. (version const)">zone</a>(0).faces_int());
<a name="l00597"></a>00597   <span class="keywordflow">while</span> (cursor)
<a name="l00598"></a>00598     {
<a name="l00599"></a>00599       <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; nodes = new_nodes_of_internal_frontier_faces[internal_frontier];
<a name="l00600"></a>00600       <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; cells = new_cells_of_internal_frontier_faces[internal_frontier];
<a name="l00601"></a>00601       <a class="code" href="classRefine__Mesh.html#a83db22e27c80654ebf08628416864fcc">build_new_frontier_faces_3D</a>(nodes,cells,incidence_from_node_to_edges,cursor.valeur().faces());
<a name="l00602"></a>00602       ++cursor;
<a name="l00603"></a>00603       ++internal_frontier;
<a name="l00604"></a>00604     }
<a name="l00605"></a>00605 }
<a name="l00606"></a>00606 
<a name="l00607"></a><a class="code" href="classRefine__Mesh.html#ab6e54652e5457c10890866e7d4552992">00607</a> <span class="keywordtype">void</span> <a class="code" href="classRefine__Mesh.html#ab6e54652e5457c10890866e7d4552992">Refine_Mesh::build_new_frontier_faces_2D</a>(<a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp;                 new_nodes_of_frontier_faces,
<a name="l00608"></a>00608                                               <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp;                 new_cells_of_frontier_faces,
<a name="l00609"></a>00609                                               <span class="keyword">const</span> <a class="code" href="classStatic__Int__Lists.html" title="Cette classe permet de stocker des listes d&#39;entiers accessibles en temps constant. La taille des listes ne peut pas changer sans perdre le contenu (ce sont des listes statiques). Exemple: Static_Int_List l; ArrOfInt tailles(3); tailles[0] = 2; tailles[1] = 3; tailles[2] = 0; // On reserve la memoire pour trois listes de taille 2, 3 et 0: l.set_list_sizes(tailles); // On affecte une valeur au deuxieme element de la premiere liste: l.set_value(0,1,765); // Affiche la valeur Cout &lt;&lt; l(0,1);.">Static_Int_Lists</a>&amp; incidence_from_node_to_edges,
<a name="l00610"></a>00610                                               <span class="keyword">const</span> <a class="code" href="classFaces.html" title="enum Type_Face Les differents types geometriques de faces.">Faces</a>&amp;            old_frontier_faces)<span class="keyword"> const</span>
<a name="l00611"></a>00611 <span class="keyword"></span>{
<a name="l00612"></a>00612   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_nodes = <a class="code" href="classInterprete__geometrique__base.html#adeeb544dc732989761fb466c0d9cbcbe">domaine</a>().<a class="code" href="classDomaine.html#a0846ac03a10b65c4df911fe35a19c02f" title="Renvoie le nombre total de sommets.">les_sommets</a>().<a class="code" href="classDoubleTab.html#ac3805e2637a3b880ba2d3e650c69dac4" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(0);
<a name="l00613"></a>00613 
<a name="l00614"></a>00614   <span class="keyword">const</span> <span class="keywordtype">int</span> old_nb_faces = old_frontier_faces.<a class="code" href="classFaces.html#a64d898edb20c3687d357018f1821c50a" title="Renvoie le nombre de Faces.">nb_faces</a>();
<a name="l00615"></a>00615   <span class="keyword">const</span> <span class="keywordtype">int</span> new_nb_faces = old_nb_faces * 2;
<a name="l00616"></a>00616 
<a name="l00617"></a>00617   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; old_nodes_of_frontier_faces = old_frontier_faces.<a class="code" href="classFaces.html#a07b8d8db9e3d656b93a21a49c063430c">les_sommets</a>();
<a name="l00618"></a>00618 
<a name="l00619"></a>00619   new_nodes_of_frontier_faces.<a class="code" href="classIntTab.html#a22e6bed6826b3688d4d0181cbf3b7a38" title="Change la taille du vecteur (identique a resize_array() pour le traitement des anciennes valeurs et d...">resize</a>(new_nb_faces,2);
<a name="l00620"></a>00620   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> f=0; f&lt;old_nb_faces; ++f)
<a name="l00621"></a>00621     {
<a name="l00622"></a>00622       <span class="keyword">const</span> <span class="keywordtype">int</span> node0 = old_nodes_of_frontier_faces(f,0);
<a name="l00623"></a>00623       <span class="keyword">const</span> <span class="keywordtype">int</span> node1 = old_nodes_of_frontier_faces(f,1);
<a name="l00624"></a>00624       <span class="keyword">const</span> <span class="keywordtype">int</span> edge  = <a class="code" href="classRefine__Mesh.html#a8e3c73baf60e021e63f0ccdd61351347">find_edge</a>(incidence_from_node_to_edges,node0,node1);
<a name="l00625"></a>00625 
<a name="l00626"></a>00626       new_nodes_of_frontier_faces(2*f+0,0) = node0;
<a name="l00627"></a>00627       new_nodes_of_frontier_faces(2*f+0,1) = nb_nodes + edge;
<a name="l00628"></a>00628 
<a name="l00629"></a>00629       new_nodes_of_frontier_faces(2*f+1,0) = nb_nodes + edge;
<a name="l00630"></a>00630       new_nodes_of_frontier_faces(2*f+1,1) = node1;
<a name="l00631"></a>00631     }
<a name="l00632"></a>00632 
<a name="l00633"></a>00633   new_cells_of_frontier_faces.<a class="code" href="classIntTab.html#a22e6bed6826b3688d4d0181cbf3b7a38" title="Change la taille du vecteur (identique a resize_array() pour le traitement des anciennes valeurs et d...">resize</a>(new_nb_faces,2);
<a name="l00634"></a>00634   new_cells_of_frontier_faces = -1;
<a name="l00635"></a>00635 }
<a name="l00636"></a>00636 
<a name="l00637"></a><a class="code" href="classRefine__Mesh.html#a83db22e27c80654ebf08628416864fcc">00637</a> <span class="keywordtype">void</span> <a class="code" href="classRefine__Mesh.html#a83db22e27c80654ebf08628416864fcc">Refine_Mesh::build_new_frontier_faces_3D</a>(<a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp;                 new_nodes_of_frontier_faces,
<a name="l00638"></a>00638                                               <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp;                 new_cells_of_frontier_faces,
<a name="l00639"></a>00639                                               <span class="keyword">const</span> <a class="code" href="classStatic__Int__Lists.html" title="Cette classe permet de stocker des listes d&#39;entiers accessibles en temps constant. La taille des listes ne peut pas changer sans perdre le contenu (ce sont des listes statiques). Exemple: Static_Int_List l; ArrOfInt tailles(3); tailles[0] = 2; tailles[1] = 3; tailles[2] = 0; // On reserve la memoire pour trois listes de taille 2, 3 et 0: l.set_list_sizes(tailles); // On affecte une valeur au deuxieme element de la premiere liste: l.set_value(0,1,765); // Affiche la valeur Cout &lt;&lt; l(0,1);.">Static_Int_Lists</a>&amp; incidence_from_node_to_edges,
<a name="l00640"></a>00640                                               <span class="keyword">const</span> <a class="code" href="classFaces.html" title="enum Type_Face Les differents types geometriques de faces.">Faces</a>&amp;            old_frontier_faces)<span class="keyword"> const</span>
<a name="l00641"></a>00641 <span class="keyword"></span>{
<a name="l00642"></a>00642   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_nodes = <a class="code" href="classInterprete__geometrique__base.html#adeeb544dc732989761fb466c0d9cbcbe">domaine</a>().<a class="code" href="classDomaine.html#a0846ac03a10b65c4df911fe35a19c02f" title="Renvoie le nombre total de sommets.">les_sommets</a>().<a class="code" href="classDoubleTab.html#ac3805e2637a3b880ba2d3e650c69dac4" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(0);
<a name="l00643"></a>00643 
<a name="l00644"></a>00644   <span class="keyword">const</span> <span class="keywordtype">int</span> old_nb_faces = old_frontier_faces.<a class="code" href="classFaces.html#a64d898edb20c3687d357018f1821c50a" title="Renvoie le nombre de Faces.">nb_faces</a>();
<a name="l00645"></a>00645   <span class="keyword">const</span> <span class="keywordtype">int</span> new_nb_faces = old_nb_faces * 4;
<a name="l00646"></a>00646 
<a name="l00647"></a>00647   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a> old_nodes_of_frontier_faces = old_frontier_faces.<a class="code" href="classFaces.html#a07b8d8db9e3d656b93a21a49c063430c">les_sommets</a>();
<a name="l00648"></a>00648 
<a name="l00649"></a>00649   new_nodes_of_frontier_faces.<a class="code" href="classIntTab.html#a22e6bed6826b3688d4d0181cbf3b7a38" title="Change la taille du vecteur (identique a resize_array() pour le traitement des anciennes valeurs et d...">resize</a>(new_nb_faces,3);
<a name="l00650"></a>00650   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> f=0; f&lt;old_nb_faces; ++f)
<a name="l00651"></a>00651     {
<a name="l00652"></a>00652       <span class="keyword">const</span> <span class="keywordtype">int</span> node0 = old_nodes_of_frontier_faces(f,0);
<a name="l00653"></a>00653       <span class="keyword">const</span> <span class="keywordtype">int</span> node1 = old_nodes_of_frontier_faces(f,1);
<a name="l00654"></a>00654       <span class="keyword">const</span> <span class="keywordtype">int</span> node2 = old_nodes_of_frontier_faces(f,2);
<a name="l00655"></a>00655 
<a name="l00656"></a>00656       <span class="keyword">const</span> <span class="keywordtype">int</span> edge0  = <a class="code" href="classRefine__Mesh.html#a8e3c73baf60e021e63f0ccdd61351347">find_edge</a>(incidence_from_node_to_edges,node1,node2);
<a name="l00657"></a>00657       <span class="keyword">const</span> <span class="keywordtype">int</span> edge1  = <a class="code" href="classRefine__Mesh.html#a8e3c73baf60e021e63f0ccdd61351347">find_edge</a>(incidence_from_node_to_edges,node2,node0);
<a name="l00658"></a>00658       <span class="keyword">const</span> <span class="keywordtype">int</span> edge2  = <a class="code" href="classRefine__Mesh.html#a8e3c73baf60e021e63f0ccdd61351347">find_edge</a>(incidence_from_node_to_edges,node0,node1);
<a name="l00659"></a>00659 
<a name="l00660"></a>00660       new_nodes_of_frontier_faces(4*f+0,0) = node0;
<a name="l00661"></a>00661       new_nodes_of_frontier_faces(4*f+0,1) = nb_nodes + edge2;
<a name="l00662"></a>00662       new_nodes_of_frontier_faces(4*f+0,2) = nb_nodes + edge1;
<a name="l00663"></a>00663 
<a name="l00664"></a>00664       new_nodes_of_frontier_faces(4*f+1,0) = nb_nodes + edge2;
<a name="l00665"></a>00665       new_nodes_of_frontier_faces(4*f+1,1) = node1;
<a name="l00666"></a>00666       new_nodes_of_frontier_faces(4*f+1,2) = nb_nodes + edge0;
<a name="l00667"></a>00667 
<a name="l00668"></a>00668       new_nodes_of_frontier_faces(4*f+2,0) = nb_nodes + edge1;
<a name="l00669"></a>00669       new_nodes_of_frontier_faces(4*f+2,1) = nb_nodes + edge0;
<a name="l00670"></a>00670       new_nodes_of_frontier_faces(4*f+2,2) = node2;
<a name="l00671"></a>00671 
<a name="l00672"></a>00672       new_nodes_of_frontier_faces(4*f+3,0) = nb_nodes +edge0;
<a name="l00673"></a>00673       new_nodes_of_frontier_faces(4*f+3,1) = nb_nodes +edge1;
<a name="l00674"></a>00674       new_nodes_of_frontier_faces(4*f+3,2) = nb_nodes +edge2;
<a name="l00675"></a>00675     }
<a name="l00676"></a>00676 
<a name="l00677"></a>00677   new_cells_of_frontier_faces.<a class="code" href="classIntTab.html#a22e6bed6826b3688d4d0181cbf3b7a38" title="Change la taille du vecteur (identique a resize_array() pour le traitement des anciennes valeurs et d...">resize</a>(new_nb_faces,2);
<a name="l00678"></a>00678   new_cells_of_frontier_faces = -1;
<a name="l00679"></a>00679 }
<a name="l00680"></a>00680 
<a name="l00681"></a><a class="code" href="classRefine__Mesh.html#a8e3c73baf60e021e63f0ccdd61351347">00681</a> <span class="keywordtype">int</span> <a class="code" href="classRefine__Mesh.html#a8e3c73baf60e021e63f0ccdd61351347">Refine_Mesh::find_edge</a>(<span class="keyword">const</span> <a class="code" href="classStatic__Int__Lists.html" title="Cette classe permet de stocker des listes d&#39;entiers accessibles en temps constant. La taille des listes ne peut pas changer sans perdre le contenu (ce sont des listes statiques). Exemple: Static_Int_List l; ArrOfInt tailles(3); tailles[0] = 2; tailles[1] = 3; tailles[2] = 0; // On reserve la memoire pour trois listes de taille 2, 3 et 0: l.set_list_sizes(tailles); // On affecte une valeur au deuxieme element de la premiere liste: l.set_value(0,1,765); // Affiche la valeur Cout &lt;&lt; l(0,1);.">Static_Int_Lists</a>&amp; incidence_from_node_to_edges, <span class="keywordtype">int</span> node0, <span class="keywordtype">int</span> node1)<span class="keyword"> const</span>
<a name="l00682"></a>00682 <span class="keyword"></span>{
<a name="l00683"></a>00683   <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> edges0;
<a name="l00684"></a>00684   incidence_from_node_to_edges.<a class="code" href="classStatic__Int__Lists.html#ac5f80aca1def83653c95221f391b916d" title="copie la i-ieme liste dans le tableau fourni Le tableau array doit etre resizable.">copy_list_to_array</a>(node0, edges0);
<a name="l00685"></a>00685 
<a name="l00686"></a>00686   <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> edges1;
<a name="l00687"></a>00687   incidence_from_node_to_edges.<a class="code" href="classStatic__Int__Lists.html#ac5f80aca1def83653c95221f391b916d" title="copie la i-ieme liste dans le tableau fourni Le tableau array doit etre resizable.">copy_list_to_array</a>(node1, edges1);
<a name="l00688"></a>00688 
<a name="l00689"></a>00689   <a class="code" href="Array__tools_8cpp.html#a7bcdb4c1fbdd4b5318fe1159fb303dc2" title="calcule l&#39;intersection entre les deux listes d&#39;entiers liste1 et liste2. Le resultat est mis dans lis...">array_calculer_intersection</a>(edges0,edges1);
<a name="l00690"></a>00690 
<a name="l00691"></a>00691   assert( edges0.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() == 1 );
<a name="l00692"></a>00692   <span class="keywordflow">return</span> edges0[0];
<a name="l00693"></a>00693 }
<a name="l00694"></a>00694 
<a name="l00695"></a><a class="code" href="classRefine__Mesh.html#a620588cae22d80d0b570d53548819220">00695</a> <span class="keywordtype">void</span> <a class="code" href="classRefine__Mesh.html#a620588cae22d80d0b570d53548819220">Refine_Mesh::update_domain</a>(<span class="keyword">const</span> <a class="code" href="classNom.html" title="class Nom Une chaine de caractere pour nommer les objets de TRUST">Nom</a>&amp;          cell_type,
<a name="l00696"></a>00696                                 <span class="keyword">const</span> <a class="code" href="classFaces.html#a62b7dbd959f99b997dc8111210ec8458">Type_Face</a>&amp;    face_type,
<a name="l00697"></a>00697                                 <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp;    new_nodes,
<a name="l00698"></a>00698                                 <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp;       new_cells,
<a name="l00699"></a>00699                                 <span class="keyword">const</span> <a class="code" href="classNoms.html" title="Un tableau de chaine de caracteres (VECT(Nom))">Noms</a>&amp;         new_sub_zones_descriptions,
<a name="l00700"></a>00700                                 <span class="keyword">const</span> <a class="code" href="Vect_8h.html#adc7c7b04809c9aec2cb897cd2ef06378">VECT</a>(<a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>)&amp; new_nodes_of_boundary_faces,
<a name="l00701"></a>00701                                 <span class="keyword">const</span> <a class="code" href="Vect_8h.html#adc7c7b04809c9aec2cb897cd2ef06378">VECT</a>(<a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>)&amp; new_cells_of_boundary_faces,
<a name="l00702"></a>00702                                 <span class="keyword">const</span> <a class="code" href="Vect_8h.html#adc7c7b04809c9aec2cb897cd2ef06378">VECT</a>(<a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>)&amp; new_nodes_of_connector_faces,
<a name="l00703"></a>00703                                 <span class="keyword">const</span> <a class="code" href="Vect_8h.html#adc7c7b04809c9aec2cb897cd2ef06378">VECT</a>(<a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>)&amp; new_cells_of_connector_faces,
<a name="l00704"></a>00704                                 <span class="keyword">const</span> <a class="code" href="Vect_8h.html#adc7c7b04809c9aec2cb897cd2ef06378">VECT</a>(<a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>)&amp; new_nodes_of_internal_frontier_faces,
<a name="l00705"></a>00705                                 <span class="keyword">const</span> <a class="code" href="Vect_8h.html#adc7c7b04809c9aec2cb897cd2ef06378">VECT</a>(<a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>)&amp; new_cells_of_internal_frontier_faces)
<a name="l00706"></a>00706 {
<a name="l00707"></a>00707   <a class="code" href="classRefine__Mesh.html#a87bebc14e9d7def612170d405617174e">update_nodes</a>(new_nodes);
<a name="l00708"></a>00708   <a class="code" href="classRefine__Mesh.html#a05300d9f137cf184740915bdcde4f753">update_cells</a>(new_cells);
<a name="l00709"></a>00709   <a class="code" href="classRefine__Mesh.html#a59298f42acd5bc897eb4bf871130b3ee">update_octree</a>(cell_type);
<a name="l00710"></a>00710   <a class="code" href="classRefine__Mesh.html#ac7147612fdd00d68aa8caa3a46a5d3cb">update_sub_zones</a>(new_sub_zones_descriptions);
<a name="l00711"></a>00711   <a class="code" href="classRefine__Mesh.html#a595f07a82fab2faee118fe88c71811fe">update_boundary_faces</a>(face_type,new_nodes_of_boundary_faces,new_cells_of_boundary_faces);
<a name="l00712"></a>00712   <a class="code" href="classRefine__Mesh.html#a4c50bfca9c0203bda8cdb46ec7586ba0">update_connector_faces</a>(face_type,new_nodes_of_connector_faces,new_cells_of_connector_faces);
<a name="l00713"></a>00713   <a class="code" href="classRefine__Mesh.html#a74faa91eaa36a96f70cf55778c39f7e8">update_internal_frontier_faces</a>(face_type,new_nodes_of_internal_frontier_faces,new_cells_of_internal_frontier_faces);
<a name="l00714"></a>00714 }
<a name="l00715"></a>00715 
<a name="l00716"></a><a class="code" href="classRefine__Mesh.html#a87bebc14e9d7def612170d405617174e">00716</a> <span class="keywordtype">void</span> <a class="code" href="classRefine__Mesh.html#a87bebc14e9d7def612170d405617174e">Refine_Mesh::update_nodes</a>(<span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; new_nodes)
<a name="l00717"></a>00717 {
<a name="l00718"></a>00718   <a class="code" href="classInterprete__geometrique__base.html#adeeb544dc732989761fb466c0d9cbcbe">domaine</a>().<a class="code" href="classDomaine.html#a0846ac03a10b65c4df911fe35a19c02f" title="Renvoie le nombre total de sommets.">les_sommets</a>().<a class="code" href="classDoubleTab.html#afc7cddeeec2c80636e54eaf330ac41ad" title="fait pointer le tableau sur le vecteur v et en associant la meme structure parallele. Attention, si line_size du vecteur v est different de 1, on cree un tableau bidimensionnel (on peut avoir un vecteur de ce type si on copie un Tab dans un Vect puis on prend une ref sur ce Vect).">ref</a>(new_nodes);
<a name="l00719"></a>00719 }
<a name="l00720"></a>00720 
<a name="l00721"></a><a class="code" href="classRefine__Mesh.html#a05300d9f137cf184740915bdcde4f753">00721</a> <span class="keywordtype">void</span> <a class="code" href="classRefine__Mesh.html#a05300d9f137cf184740915bdcde4f753">Refine_Mesh::update_cells</a>(<span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; new_cells)
<a name="l00722"></a>00722 {
<a name="l00723"></a>00723   <a class="code" href="classInterprete__geometrique__base.html#adeeb544dc732989761fb466c0d9cbcbe">domaine</a>().<a class="code" href="classDomaine.html#a0e62f2bc829542fafa29e3f2c614159c" title="Renvoie la i-ieme zone du domaine. (version const)">zone</a>(0).<a class="code" href="classZone.html#ac115e8342be89afb882b7b61cc343267" title="Renvoie le tableau des sommets des elements.">les_elems</a>().<a class="code" href="classIntTab.html#ae9ae8fefb1fda4a5c035229ab420a96d" title="fait pointer le tableau sur le vecteur v et en associant la meme structure parallele. Attention, si line_size du vecteur v est different de 1, on cree un tableau bidimensionnel (on peut avoir un vecteur de ce type si on copie un Tab dans un Vect puis on prend une ref sur ce Vect).">ref</a>(new_cells);
<a name="l00724"></a>00724 }
<a name="l00725"></a>00725 
<a name="l00726"></a><a class="code" href="classRefine__Mesh.html#a59298f42acd5bc897eb4bf871130b3ee">00726</a> <span class="keywordtype">void</span> <a class="code" href="classRefine__Mesh.html#a59298f42acd5bc897eb4bf871130b3ee">Refine_Mesh::update_octree</a>(<span class="keyword">const</span> <a class="code" href="classNom.html" title="class Nom Une chaine de caractere pour nommer les objets de TRUST">Nom</a>&amp; cell_type)
<a name="l00727"></a>00727 {
<a name="l00728"></a>00728   <a class="code" href="classInterprete__geometrique__base.html#adeeb544dc732989761fb466c0d9cbcbe">domaine</a>().<a class="code" href="classDomaine.html#a0e62f2bc829542fafa29e3f2c614159c" title="Renvoie la i-ieme zone du domaine. (version const)">zone</a>(0).<a class="code" href="classZone.html#a8ee51194c663be29651925c88f904d76">invalide_octree</a>();
<a name="l00729"></a>00729   <a class="code" href="classInterprete__geometrique__base.html#adeeb544dc732989761fb466c0d9cbcbe">domaine</a>().<a class="code" href="classDomaine.html#a0e62f2bc829542fafa29e3f2c614159c" title="Renvoie la i-ieme zone du domaine. (version const)">zone</a>(0).<a class="code" href="classZone.html#ac1ff391994a372815b7f88c3fdc39f55" title="Type les elements de la zone avec le nom passe en parametre. Et associe le type d&#39;element a la zone...">typer</a>(cell_type);
<a name="l00730"></a>00730   <a class="code" href="classInterprete__geometrique__base.html#adeeb544dc732989761fb466c0d9cbcbe">domaine</a>().<a class="code" href="classDomaine.html#a0e62f2bc829542fafa29e3f2c614159c" title="Renvoie la i-ieme zone du domaine. (version const)">zone</a>(0).<a class="code" href="classZone.html#a492c53ea54616079fb65c18f7726ebc9">construit_octree</a>();
<a name="l00731"></a>00731 }
<a name="l00732"></a>00732 
<a name="l00733"></a><a class="code" href="classRefine__Mesh.html#ac7147612fdd00d68aa8caa3a46a5d3cb">00733</a> <span class="keywordtype">void</span> <a class="code" href="classRefine__Mesh.html#ac7147612fdd00d68aa8caa3a46a5d3cb">Refine_Mesh::update_sub_zones</a>(<span class="keyword">const</span> <a class="code" href="classNoms.html" title="Un tableau de chaine de caracteres (VECT(Nom))">Noms</a>&amp; new_sub_zones_descriptions)
<a name="l00734"></a>00734 {
<a name="l00735"></a>00735   <span class="keyword">const</span> <span class="keywordtype">int</span> nb_sub_zones = <a class="code" href="classInterprete__geometrique__base.html#adeeb544dc732989761fb466c0d9cbcbe">domaine</a>().<a class="code" href="classDomaine.html#a247a66a1ad882b7d223f963767cdfe8b" title="Renvoie le nombre de sous-zone.">nb_ss_zones</a>();
<a name="l00736"></a>00736   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;nb_sub_zones; ++i)
<a name="l00737"></a>00737     {
<a name="l00738"></a>00738       <a class="code" href="classSous__Zone.html" title="Classe Sous_Zone Represente une sous zone volumique i.e un sous ensemble de polyedres d&#39;un objet de t...">Sous_Zone</a>&amp; sub_zone    = <a class="code" href="classInterprete__geometrique__base.html#adeeb544dc732989761fb466c0d9cbcbe">domaine</a>().<a class="code" href="classDomaine.html#ad38f4fc3c0e1b44dc9fdc947985178a5" title="Renvoie la i-ieme sous-zone. (version const)">ss_zone</a>(i);
<a name="l00739"></a>00739       <span class="keyword">const</span> <a class="code" href="classNom.html" title="class Nom Une chaine de caractere pour nommer les objets de TRUST">Nom</a>&amp; description = new_sub_zones_descriptions[i];
<a name="l00740"></a>00740       <a class="code" href="classEChaine.html" title="Une entree dont la source est une chaine de caracteres. Le constructeur cree sa propre copie de la ch...">EChaine</a> is(description.<a class="code" href="classNom.html#aa9f24bd3370b5f1c66666e65252eea05">getChar</a>());
<a name="l00741"></a>00741       is &gt;&gt; sub_zone;
<a name="l00742"></a>00742     }
<a name="l00743"></a>00743 }
<a name="l00744"></a>00744 
<a name="l00745"></a><a class="code" href="classRefine__Mesh.html#a595f07a82fab2faee118fe88c71811fe">00745</a> <span class="keywordtype">void</span> <a class="code" href="classRefine__Mesh.html#a595f07a82fab2faee118fe88c71811fe">Refine_Mesh::update_boundary_faces</a>(<span class="keyword">const</span> <a class="code" href="classFaces.html#a62b7dbd959f99b997dc8111210ec8458">Type_Face</a>&amp;    face_type,
<a name="l00746"></a>00746                                         <span class="keyword">const</span> <a class="code" href="Vect_8h.html#adc7c7b04809c9aec2cb897cd2ef06378">VECT</a>(<a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>)&amp; new_nodes_of_boundary_faces,
<a name="l00747"></a>00747                                         <span class="keyword">const</span> <a class="code" href="Vect_8h.html#adc7c7b04809c9aec2cb897cd2ef06378">VECT</a>(<a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>)&amp; new_cells_of_boundary_faces)
<a name="l00748"></a>00748 {
<a name="l00749"></a>00749   <span class="keywordtype">int</span> boundary = 0;
<a name="l00750"></a>00750   <a class="code" href="List_8h.html#a300f34d06c3e9d9918e439ede00ad7f4">LIST_CURSEUR</a>(<a class="code" href="classBord.html" title="Classe Bord Cette classe represente un bord d&#39;une zone, c&#39;est un type de frontiere&lt;br&gt;(derive de Fronti...">Bord</a>) cursor(<a class="code" href="classInterprete__geometrique__base.html#adeeb544dc732989761fb466c0d9cbcbe">domaine</a>().<a class="code" href="classFrontiere.html#a510866aace5f3ed9482553db1a08a3c9" title="Renvoie la Zone associee a la frontiere. (version const)">zone</a>(0).faces_bord());
<a name="l00751"></a>00751   <span class="keywordflow">while</span> (cursor)
<a name="l00752"></a>00752     {
<a name="l00753"></a>00753       <a class="code" href="classFaces.html" title="enum Type_Face Les differents types geometriques de faces.">Faces</a>&amp; <a class="code" href="classFrontiere.html#ac64479069f0c43a17cb5766a39ce5ba8" title="Renvoie les faces de la frontiere&lt;br&gt;(version const)">faces</a> = cursor.valeur().faces();
<a name="l00754"></a>00754       faces.<a class="code" href="classFaces.html#a503fe687811445373b75dd8ac0991ec2" title="Type les faces.">typer</a>(face_type);
<a name="l00755"></a>00755       faces.<a class="code" href="classFaces.html#a07b8d8db9e3d656b93a21a49c063430c">les_sommets</a>().<a class="code" href="classIntTab.html#ae9ae8fefb1fda4a5c035229ab420a96d" title="fait pointer le tableau sur le vecteur v et en associant la meme structure parallele. Attention, si line_size du vecteur v est different de 1, on cree un tableau bidimensionnel (on peut avoir un vecteur de ce type si on copie un Tab dans un Vect puis on prend une ref sur ce Vect).">ref</a>(new_nodes_of_boundary_faces[boundary]);
<a name="l00756"></a>00756       faces.<a class="code" href="classFaces.html#af49c4448e67aa7c732c2cc1dc237b442" title="Renvoie le tableau des voisins (des faces).">voisins</a>().<a class="code" href="classIntTab.html#ae9ae8fefb1fda4a5c035229ab420a96d" title="fait pointer le tableau sur le vecteur v et en associant la meme structure parallele. Attention, si line_size du vecteur v est different de 1, on cree un tableau bidimensionnel (on peut avoir un vecteur de ce type si on copie un Tab dans un Vect puis on prend une ref sur ce Vect).">ref</a>(new_cells_of_boundary_faces[boundary]);
<a name="l00757"></a>00757       ++cursor;
<a name="l00758"></a>00758       ++boundary;
<a name="l00759"></a>00759     }
<a name="l00760"></a>00760 }
<a name="l00761"></a>00761 
<a name="l00762"></a><a class="code" href="classRefine__Mesh.html#a4c50bfca9c0203bda8cdb46ec7586ba0">00762</a> <span class="keywordtype">void</span> <a class="code" href="classRefine__Mesh.html#a4c50bfca9c0203bda8cdb46ec7586ba0">Refine_Mesh::update_connector_faces</a>(<span class="keyword">const</span> <a class="code" href="classFaces.html#a62b7dbd959f99b997dc8111210ec8458">Type_Face</a>&amp;    face_type,
<a name="l00763"></a>00763                                          <span class="keyword">const</span> <a class="code" href="Vect_8h.html#adc7c7b04809c9aec2cb897cd2ef06378">VECT</a>(<a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>)&amp; new_nodes_of_connector_faces,
<a name="l00764"></a>00764                                          <span class="keyword">const</span> <a class="code" href="Vect_8h.html#adc7c7b04809c9aec2cb897cd2ef06378">VECT</a>(<a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>)&amp; new_cells_of_connector_faces)
<a name="l00765"></a>00765 {
<a name="l00766"></a>00766   <span class="keywordtype">int</span> connector = 0;
<a name="l00767"></a>00767   <a class="code" href="List_8h.html#a300f34d06c3e9d9918e439ede00ad7f4">LIST_CURSEUR</a>(<a class="code" href="classRaccord.html" title="Classe Raccord Classe generique de la hierarchie des raccords, un objet Raccord peut referencer n&#39;imp...">Raccord</a>) cursor(<a class="code" href="classInterprete__geometrique__base.html#adeeb544dc732989761fb466c0d9cbcbe">domaine</a>().<a class="code" href="classFrontiere.html#a510866aace5f3ed9482553db1a08a3c9" title="Renvoie la Zone associee a la frontiere. (version const)">zone</a>(0).faces_raccord());
<a name="l00768"></a>00768   <span class="keywordflow">while</span> (cursor)
<a name="l00769"></a>00769     {
<a name="l00770"></a>00770       <a class="code" href="classFaces.html" title="enum Type_Face Les differents types geometriques de faces.">Faces</a>&amp; <a class="code" href="classFrontiere.html#ac64479069f0c43a17cb5766a39ce5ba8" title="Renvoie les faces de la frontiere&lt;br&gt;(version const)">faces</a> = cursor.valeur().valeur().faces();
<a name="l00771"></a>00771       faces.<a class="code" href="classFaces.html#a503fe687811445373b75dd8ac0991ec2" title="Type les faces.">typer</a>(face_type);
<a name="l00772"></a>00772       faces.<a class="code" href="classFaces.html#a07b8d8db9e3d656b93a21a49c063430c">les_sommets</a>().<a class="code" href="classIntTab.html#ae9ae8fefb1fda4a5c035229ab420a96d" title="fait pointer le tableau sur le vecteur v et en associant la meme structure parallele. Attention, si line_size du vecteur v est different de 1, on cree un tableau bidimensionnel (on peut avoir un vecteur de ce type si on copie un Tab dans un Vect puis on prend une ref sur ce Vect).">ref</a>(new_nodes_of_connector_faces[connector]);
<a name="l00773"></a>00773       faces.<a class="code" href="classFaces.html#af49c4448e67aa7c732c2cc1dc237b442" title="Renvoie le tableau des voisins (des faces).">voisins</a>().<a class="code" href="classIntTab.html#ae9ae8fefb1fda4a5c035229ab420a96d" title="fait pointer le tableau sur le vecteur v et en associant la meme structure parallele. Attention, si line_size du vecteur v est different de 1, on cree un tableau bidimensionnel (on peut avoir un vecteur de ce type si on copie un Tab dans un Vect puis on prend une ref sur ce Vect).">ref</a>(new_cells_of_connector_faces[connector]);
<a name="l00774"></a>00774       ++cursor;
<a name="l00775"></a>00775       ++connector;
<a name="l00776"></a>00776     }
<a name="l00777"></a>00777 }
<a name="l00778"></a>00778 
<a name="l00779"></a><a class="code" href="classRefine__Mesh.html#a74faa91eaa36a96f70cf55778c39f7e8">00779</a> <span class="keywordtype">void</span> <a class="code" href="classRefine__Mesh.html#a74faa91eaa36a96f70cf55778c39f7e8">Refine_Mesh::update_internal_frontier_faces</a>(<span class="keyword">const</span> <a class="code" href="classFaces.html#a62b7dbd959f99b997dc8111210ec8458">Type_Face</a>&amp;    face_type,
<a name="l00780"></a>00780                                                  <span class="keyword">const</span> <a class="code" href="Vect_8h.html#adc7c7b04809c9aec2cb897cd2ef06378">VECT</a>(<a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>)&amp; new_nodes_of_internal_frontier_faces,
<a name="l00781"></a>00781                                                  <span class="keyword">const</span> <a class="code" href="Vect_8h.html#adc7c7b04809c9aec2cb897cd2ef06378">VECT</a>(<a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>)&amp; new_cells_of_internal_frontier_faces)
<a name="l00782"></a>00782 {
<a name="l00783"></a>00783   <span class="keywordtype">int</span> internal_frontier = 0;
<a name="l00784"></a>00784   <a class="code" href="List_8h.html#a300f34d06c3e9d9918e439ede00ad7f4">LIST_CURSEUR</a>(<a class="code" href="classFaces__Interne.html" title="Classe Faces_Interne La classe sert a representer un ensemble de faces qui sont internes d&#39;un point d...">Faces_Interne</a>) cursor(<a class="code" href="classInterprete__geometrique__base.html#adeeb544dc732989761fb466c0d9cbcbe">domaine</a>().<a class="code" href="classFrontiere.html#a510866aace5f3ed9482553db1a08a3c9" title="Renvoie la Zone associee a la frontiere. (version const)">zone</a>(0).faces_int());
<a name="l00785"></a>00785   <span class="keywordflow">while</span> (cursor)
<a name="l00786"></a>00786     {
<a name="l00787"></a>00787       <a class="code" href="classFaces.html" title="enum Type_Face Les differents types geometriques de faces.">Faces</a>&amp; <a class="code" href="classFrontiere.html#ac64479069f0c43a17cb5766a39ce5ba8" title="Renvoie les faces de la frontiere&lt;br&gt;(version const)">faces</a> = cursor.valeur().faces();
<a name="l00788"></a>00788       faces.<a class="code" href="classFaces.html#a503fe687811445373b75dd8ac0991ec2" title="Type les faces.">typer</a>(face_type);
<a name="l00789"></a>00789       faces.<a class="code" href="classFaces.html#a07b8d8db9e3d656b93a21a49c063430c">les_sommets</a>().<a class="code" href="classIntTab.html#ae9ae8fefb1fda4a5c035229ab420a96d" title="fait pointer le tableau sur le vecteur v et en associant la meme structure parallele. Attention, si line_size du vecteur v est different de 1, on cree un tableau bidimensionnel (on peut avoir un vecteur de ce type si on copie un Tab dans un Vect puis on prend une ref sur ce Vect).">ref</a>(new_nodes_of_internal_frontier_faces[internal_frontier]);
<a name="l00790"></a>00790       faces.<a class="code" href="classFaces.html#af49c4448e67aa7c732c2cc1dc237b442" title="Renvoie le tableau des voisins (des faces).">voisins</a>().<a class="code" href="classIntTab.html#ae9ae8fefb1fda4a5c035229ab420a96d" title="fait pointer le tableau sur le vecteur v et en associant la meme structure parallele. Attention, si line_size du vecteur v est different de 1, on cree un tableau bidimensionnel (on peut avoir un vecteur de ce type si on copie un Tab dans un Vect puis on prend une ref sur ce Vect).">ref</a>(new_cells_of_internal_frontier_faces[internal_frontier]);
<a name="l00791"></a>00791       ++cursor;
<a name="l00792"></a>00792       ++internal_frontier;
<a name="l00793"></a>00793     }
<a name="l00794"></a>00794 }
<a name="l00795"></a>00795 
</pre></div></div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Tue Dec 14 2021 19:35:20 for TRUST by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
