<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>TRUST: Op_Conv_Muscl_New_VEF_Face Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">TRUST&#160;<span id="projectnumber">1.8.4</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a>  </div>
  <div class="headertitle">
<div class="title">Op_Conv_Muscl_New_VEF_Face Class Reference</div>  </div>
</div>
<div class="contents">
<!-- doxytag: class="Op_Conv_Muscl_New_VEF_Face" --><!-- doxytag: inherits="Op_Conv_VEF_Face" -->
<p>class <a class="el" href="classOp__Conv__Muscl__New__VEF__Face.html" title="class Op_Conv_Muscl_New_VEF_Face Cette classe represente l&#39;operateur de convection associe a une equa...">Op_Conv_Muscl_New_VEF_Face</a><br/>
Cette classe represente l'operateur de convection associe a une equation de<br/>
transport d'un scalaire.<br/>
La discretisation est VEF<br/>
Le champ convecte est scalaire ou vecteur de type <a class="el" href="classChamp__P1NC.html">Champ_P1NC</a><br/>
Le schema de convection est isu du papier<br/>
"High-resolution FEM-TVD schemes based on a fully multidimensional flux limiter"<br/>
D.Kuzmin and S.Turek.<br/>
On herite de Op pour recuperer l'implicitation amont  
 <a href="classOp__Conv__Muscl__New__VEF__Face.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="Op__Conv__Muscl__New__VEF__Face_8h_source.html">Op_Conv_Muscl_New_VEF_Face.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Op_Conv_Muscl_New_VEF_Face:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classOp__Conv__Muscl__New__VEF__Face.png" usemap="#Op_Conv_Muscl_New_VEF_Face_map" alt=""/>
  <map id="Op_Conv_Muscl_New_VEF_Face_map" name="Op_Conv_Muscl_New_VEF_Face_map">
<area href="classOp__Conv__VEF__Face.html" title="class Op_Conv_VEF_Face Cette classe represente l&#39;operateur de convection associe a une equation de tr..." alt="Op_Conv_VEF_Face" shape="rect" coords="325,280,532,304"/>
<area href="classOp__Conv__VEF__base.html" title="class Op_Conv_VEF_base Classe de base des operateurs de convection VEF" alt="Op_Conv_VEF_base" shape="rect" coords="325,224,532,248"/>
<area href="classOperateur__Conv__base.html" title="classe Operateur_Conv_base Cette classe est la base de la hierarchie des operateurs representant un t..." alt="Operateur_Conv_base" shape="rect" coords="217,168,424,192"/>
<area href="classOp__VEF__Face.html" alt="Op_VEF_Face" shape="rect" coords="434,168,641,192"/>
<area href="classOperateur__base.html" title="classe Operateur_base Classe est la base de la hierarchie des objets representant un operateur utilis..." alt="Operateur_base" shape="rect" coords="217,112,424,136"/>
<area href="classObjet__U.html" title="classe Objet_U Cette classe est la classe de base des Objets de TRUST Dans les classes derivees de Ob..." alt="Objet_U" shape="rect" coords="0,56,207,80"/>
<area href="classMorEqn.html" title="classe MorEqn Classe qui regroupe les fonctionnalites de liaison avec une Equation. Le membre MorEqn::mon_equation contient une reference vers un objet Equation_base. Les classes qui sont des &quot;Morceaux d&#39;equation&quot; sont associe par une liaison 1-1 a leur equation en heritant de MorEqn, par exemple: Operateur_base, Solveur_Masse, Source_base ..." alt="MorEqn" shape="rect" coords="217,56,424,80"/>
<area href="classChamps__compris__interface.html" title="classe Champs_compris_interface Cette classe contient une interface de methodes destinees a gerer les..." alt="Champs_compris_interface" shape="rect" coords="434,56,641,80"/>
<area href="classProcess.html" title="Classe de base de TRUST (notamment Objet_U). Elle fournit quelques services de base accessibles de pa..." alt="Process" shape="rect" coords="0,0,207,24"/>
</map>
 </div></div>

<p><a href="classOp__Conv__Muscl__New__VEF__Face-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOp__Conv__Muscl__New__VEF__Face.html#ad1f5c6da15acd62d296afbc15482220c">Op_Conv_Muscl_New_VEF_Face</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOp__Conv__Muscl__New__VEF__Face.html#ac9460f75b6e97168e0b0dadecd411616">~Op_Conv_Muscl_New_VEF_Face</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOp__Conv__Muscl__New__VEF__Face.html#ac77cc14784ce355125d44a3af42dcba0">taille_memoire</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOp__Conv__Muscl__New__VEF__Face.html#a8cb4fcb38968e497474dad4fdd1a9190">duplique</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classType__info.html">Type_info</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOp__Conv__Muscl__New__VEF__Face.html#a4bf8a3114c691efecfc752810cc524e0">get_info</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Donne des informations sur le type de l'Objet_U.  <a href="#a4bf8a3114c691efecfc752810cc524e0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOp__Conv__Muscl__New__VEF__Face.html#a3bd2f8fbc0e634221c7df74db0bca01d">remplir_fluent</a> (<a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOp__Conv__Muscl__New__VEF__Face.html#a8c4ed1e4af546190554416a6129a730c">is_compressible</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOp__Conv__Muscl__New__VEF__Face.html#aa314b43d428161f096acbd9dfb8b6634">completer</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Associe l'operateur a la zone_dis, la zone_Cl_dis,<br/>
et a l'inconnue de son equation.  <a href="#aa314b43d428161f096acbd9dfb8b6634"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOp__Conv__Muscl__New__VEF__Face.html#a51a3ed81dae9a408009dad9e3104f7de">ajouter</a> (const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;, <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOp__Conv__Muscl__New__VEF__Face.html#a6c66104c0f7419cdf6a126d2266d4720">calculer_dt_stab</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calcul dt_stab.  <a href="#a6c66104c0f7419cdf6a126d2266d4720"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOp__Conv__Muscl__New__VEF__Face.html#acb80c8643054dda4979c7b94d6f28bbf">contribuer_a_avec</a> (const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;, <a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">on assemble la matrice des inconnues implicite.  <a href="#acb80c8643054dda4979c7b94d6f28bbf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOp__Conv__Muscl__New__VEF__Face.html#abac773d46607384fdecf846d33a9c3c5">ajouter_contribution</a> (const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;, <a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOp__Conv__Muscl__New__VEF__Face.html#a9aa7c75c67bd0c800683b833d35eab0f">modifier_pour_Cl</a> (<a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;, <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">On modifie le second membre et la matrice dans le cas des<br/>
conditions de dirichlet.  <a href="#a9aa7c75c67bd0c800683b833d35eab0f"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classObjet__U.html">Objet_U</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOp__Conv__Muscl__New__VEF__Face.html#ad2aaff32ae487ec536e6fba1361558b6">cree_instance</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classType__info.html">Type_info</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOp__Conv__Muscl__New__VEF__Face.html#a8bf367586ce23a9a6c8f77d4db6bfb77">info</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Donne des informations sur le type de l'Objet_U.  <a href="#a8bf367586ce23a9a6c8f77d4db6bfb77"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classOp__Conv__Muscl__New__VEF__Face.html">Op_Conv_Muscl_New_VEF_Face</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOp__Conv__Muscl__New__VEF__Face.html#ae3051e6ae4326900ce530965a9e382cc">self_cast</a> (<a class="el" href="classObjet__U.html">Objet_U</a> &amp;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const <br class="typebreak"/>
<a class="el" href="classOp__Conv__Muscl__New__VEF__Face.html">Op_Conv_Muscl_New_VEF_Face</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOp__Conv__Muscl__New__VEF__Face.html#a92c196702032a60e9e1c8085bf0109fb">self_cast</a> (const <a class="el" href="classObjet__U.html">Objet_U</a> &amp;)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">methode ajoutee pour caster en python  <a href="#a92c196702032a60e9e1c8085bf0109fb"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classType__info.html">Type_info</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOp__Conv__Muscl__New__VEF__Face.html#a3de84e25f40003eae5fb33eaf0fde4b4">info_obj</a></td></tr>
<tr><td colspan="2"><h2><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classSortie.html">Sortie</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOp__Conv__Muscl__New__VEF__Face.html#af69550ea7cba363dae2162d2ff994fe0">printOn</a> (<a class="el" href="classSortie.html">Sortie</a> &amp;x) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">NE FAIT RIEN<br/>
A surcharger dans les classes derivees.  <a href="#af69550ea7cba363dae2162d2ff994fe0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classEntree.html">Entree</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOp__Conv__Muscl__New__VEF__Face.html#a8bfb304871cfa825d460dd1bdc8f6594">readOn</a> (<a class="el" href="classEntree.html">Entree</a> &amp;)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">NE FAIT RIEN<br/>
A surcharger dans les classes derivees.  <a href="#a8bfb304871cfa825d460dd1bdc8f6594"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOp__Conv__Muscl__New__VEF__Face.html#ad9cd682b100057d3019ba30b61a9b469">calculer_flux_bords</a> (const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;, const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;, const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOp__Conv__Muscl__New__VEF__Face.html#afde9a8f6daffddcc35a097fd68674797">calculer_coefficients_operateur_centre</a> (<a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;, <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;, <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;, <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;, const int &amp;, const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;vitesse) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOp__Conv__Muscl__New__VEF__Face.html#aaf6d31030b81017b92df85d3377d6ae9">calculer_flux_operateur_centre</a> (<a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;, const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;, const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;, const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;, const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;, const int &amp;, const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;, const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOp__Conv__Muscl__New__VEF__Face.html#aea685b2416b3023598d337ab366512cb">modifier_flux_operateur_centre</a> (<a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;, const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;, const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;, const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;, const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;, const int &amp;, const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;, const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOp__Conv__Muscl__New__VEF__Face.html#a141336115c6ef5ebfb3b4bc9d2a0863a">ajouter_partie_compressible</a> (const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;, <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;, const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;vitesse) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOp__Conv__Muscl__New__VEF__Face.html#a0cd4001abc6587f38b6e3f23d251bc68">ajouter_operateur_centre</a> (const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;, const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;, const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;, <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOp__Conv__Muscl__New__VEF__Face.html#a7a5c2445abefb22846ad5eec13fde90d">ajouter_diffusion</a> (const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;, const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;, const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;, <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOp__Conv__Muscl__New__VEF__Face.html#a0a4d5294bb89871b05c740fa867841b9">ajouter_antidiffusion</a> (const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;, const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;, const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;, <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOp__Conv__Muscl__New__VEF__Face.html#a97cd8ef9b333f725b08b769aa6bd846e">ajouter_antidiffusion_v1</a> (const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;, const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;, const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;, <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOp__Conv__Muscl__New__VEF__Face.html#a78488062b4b9cb57b6b63b1fdbd9895c">ajouter_antidiffusion_v2</a> (const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;, const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;, const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;, <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOp__Conv__Muscl__New__VEF__Face.html#a62e58f1cd47b3865342a3b37fb1a06df">calculer_senseur_v1</a> (const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;, const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;, const <a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;, const int &amp;, const int &amp;, const <a class="el" href="classIntTab.html">IntTab</a> &amp;, const <a class="el" href="classIntTab.html">IntTab</a> &amp;, const <a class="el" href="classIntTab.html">IntTab</a> &amp;, <a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;, <a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;, <a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;, <a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOp__Conv__Muscl__New__VEF__Face.html#a2032486fe36dd90a3ae2bffcc16569c0">calculer_senseur_v2</a> (const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;, const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;, const <a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;, const int &amp;, const int &amp;, const <a class="el" href="classIntTab.html">IntTab</a> &amp;, const <a class="el" href="classIntTab.html">IntTab</a> &amp;, const <a class="el" href="classIntTab.html">IntTab</a> &amp;, <a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;, <a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;, <a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;, <a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOp__Conv__Muscl__New__VEF__Face.html#a98bafc0524994d1bba96aff4b28540b8">mettre_a_jour_pour_periodicite</a> (const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;, const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;, <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOp__Conv__Muscl__New__VEF__Face.html#af0ae6f8bcbe698e8ddc0b0a83f67604c">ajouter_old</a> (const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;, <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;, const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;vitesse) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOp__Conv__Muscl__New__VEF__Face.html#a4ff4bc26b4f14df5174c4682f2ec580b">calculer_data_pour_dirichlet</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOp__Conv__Muscl__New__VEF__Face.html#af94ae9e4b02bc730600d17589ecb74f0">ajouter_contribution_operateur_centre</a> (const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;, const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;, <a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOp__Conv__Muscl__New__VEF__Face.html#a6410a4c4150029025579edfe38a37d75">ajouter_contribution_diffusion</a> (const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;, const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;, <a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOp__Conv__Muscl__New__VEF__Face.html#ae8449f75326ce9bb64f44c8a67906916">ajouter_contribution_antidiffusion</a> (const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;, const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;, <a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOp__Conv__Muscl__New__VEF__Face.html#a026e368e5d3d1af6bbb0f1be6d802fac">ajouter_contribution_partie_compressible</a> (const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;, const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;, <a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOp__Conv__Muscl__New__VEF__Face.html#a6709414bd989ff2c3e4a377bb7efe084">test</a> (const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;, const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;, const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;vitesse) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOp__Conv__Muscl__New__VEF__Face.html#a1acd183f7ead04c1c937df139024bea4">test_difference_Kij</a> (const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;, <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;, <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;, const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;vitesse) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOp__Conv__Muscl__New__VEF__Face.html#afc6c7aed9be880d6426a3a1be6d87d38">test_difference_resu</a> (const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;, const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;, const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;, const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;, const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;vitesse) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOp__Conv__Muscl__New__VEF__Face.html#ab68a8db5c6dc0e66de1ca5c9ab610364">test_implicite</a> () const </td></tr>
<tr><td colspan="2"><h2><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIntTab.html">IntTab</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOp__Conv__Muscl__New__VEF__Face.html#a93e226d752c2b31d4b63e08840aea2cb">is_element_for_upwinding_</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIntTab.html">IntTab</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOp__Conv__Muscl__New__VEF__Face.html#a1e7b0db2325d8e59bbaa9460ed6f3826">is_dirichlet_faces_</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classArrOfDouble.html">ArrOfDouble</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOp__Conv__Muscl__New__VEF__Face.html#a5477f9154396fb7e43a71d40c0689e78">alpha_tab</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classArrOfDouble.html">ArrOfDouble</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOp__Conv__Muscl__New__VEF__Face.html#a809512967978e8fbb8cb99a54cd17594">beta</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">vaut zero pour les faces ou l'on souhaite degenerer en Amont. mutable <a class="el" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a> limiteurs_;//tableau stockant pour chaque face la moyenne algebrique du limiteur  <a href="#a809512967978e8fbb8cb99a54cd17594"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOp__Conv__Muscl__New__VEF__Face.html#aba93a9d2fdc68f373410c6439c95074c">alpha_</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOp__Conv__Muscl__New__VEF__Face.html#ae5e76d1a00689f96fe333745b2a6c2ef">max_limiteur_</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOp__Conv__Muscl__New__VEF__Face.html#af79e661742c516fb1f0945636d84f900">centered_</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOp__Conv__Muscl__New__VEF__Face.html#ad596610363f5610f9ab6517b977b3122">upwind_</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOp__Conv__Muscl__New__VEF__Face.html#a2b88ace4b5e403aacf90ce4a6787b76c">stabilized_</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOp__Conv__Muscl__New__VEF__Face.html#af27e616d4be292efae0dcd25ef29278c">old_centered_</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOp__Conv__Muscl__New__VEF__Face.html#a628f5f0e8616ec26b0541bdd128238c8">version_</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOp__Conv__Muscl__New__VEF__Face.html#a55d9e35f60df86eecbcc895f3cb72d3c">facsec_auto_</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classNom.html">Nom</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOp__Conv__Muscl__New__VEF__Face.html#ad2275b65e44a3a588e3897c24e5166c7">nom_sous_zone</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRef__Sous__zone__VF.html">Ref_Sous_zone_VF</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOp__Conv__Muscl__New__VEF__Face.html#ad4906f5a407729870b58f21924914ad7">la_sous_zone_dis</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOp__Conv__Muscl__New__VEF__Face.html#a1265605bb264c308aa56d6ace2e187a3">limiteur_</a> )(double)</td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>class <a class="el" href="classOp__Conv__Muscl__New__VEF__Face.html" title="class Op_Conv_Muscl_New_VEF_Face Cette classe represente l&#39;operateur de convection associe a une equa...">Op_Conv_Muscl_New_VEF_Face</a><br/>
Cette classe represente l'operateur de convection associe a une equation de<br/>
transport d'un scalaire.<br/>
La discretisation est VEF<br/>
Le champ convecte est scalaire ou vecteur de type <a class="el" href="classChamp__P1NC.html">Champ_P1NC</a><br/>
Le schema de convection est isu du papier<br/>
"High-resolution FEM-TVD schemes based on a fully multidimensional flux limiter"<br/>
D.Kuzmin and S.Turek.<br/>
On herite de Op pour recuperer l'implicitation amont </p>

<p>Definition at line <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8h_source.html#l00050">50</a> of file <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8h_source.html">Op_Conv_Muscl_New_VEF_Face.h</a>.</p>
</div><hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ad1f5c6da15acd62d296afbc15482220c"></a><!-- doxytag: member="Op_Conv_Muscl_New_VEF_Face::Op_Conv_Muscl_New_VEF_Face" ref="ad1f5c6da15acd62d296afbc15482220c" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Op_Conv_Muscl_New_VEF_Face::Op_Conv_Muscl_New_VEF_Face </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8cpp_source.html#l00074">74</a> of file <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8cpp_source.html">Op_Conv_Muscl_New_VEF_Face.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac9460f75b6e97168e0b0dadecd411616"></a><!-- doxytag: member="Op_Conv_Muscl_New_VEF_Face::~Op_Conv_Muscl_New_VEF_Face" ref="ac9460f75b6e97168e0b0dadecd411616" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Op_Conv_Muscl_New_VEF_Face::~Op_Conv_Muscl_New_VEF_Face </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8cpp_source.html#l00074">74</a> of file <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8cpp_source.html">Op_Conv_Muscl_New_VEF_Face.cpp</a>.</p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a51a3ed81dae9a408009dad9e3104f7de"></a><!-- doxytag: member="Op_Conv_Muscl_New_VEF_Face::ajouter" ref="a51a3ed81dae9a408009dad9e3104f7de" args="(const DoubleTab &amp;, DoubleTab &amp;) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDoubleTab.html">DoubleTab</a> &amp; Op_Conv_Muscl_New_VEF_Face::ajouter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>transporte_2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>resu</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="classOp__Conv__VEF__Face.html#a88409d0b56b9e0db3d4f241a09930f82">Op_Conv_VEF_Face</a>.</p>

<p>Definition at line <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8cpp_source.html#l01029">1029</a> of file <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8cpp_source.html">Op_Conv_Muscl_New_VEF_Face.cpp</a>.</p>

<p>References <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8cpp_source.html#l01670">ajouter_antidiffusion()</a>, <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8cpp_source.html#l01603">ajouter_diffusion()</a>, <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8cpp_source.html#l01468">ajouter_operateur_centre()</a>, <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8cpp_source.html#l00314">calculer_coefficients_operateur_centre()</a>, <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8cpp_source.html#l01316">calculer_flux_bords()</a>, <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8cpp_source.html#l00566">calculer_flux_operateur_centre()</a>, <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8h_source.html#l00121">centered_</a>, <a class="el" href="DoubleTab_8h_source.html#l00243">DoubleTab::dimension()</a>, <a class="el" href="Objet__U_8h_source.html#l00079">Objet_U::dimension</a>, <a class="el" href="IntTab_8h_source.html#l00233">IntTab::dimension()</a>, <a class="el" href="Zone__VF_8h_source.html#l00574">Zone_VF::elem_faces()</a>, <a class="el" href="MorEqn_8h_source.html#l00082">MorEqn::equation()</a>, <a class="el" href="Operateur__base_8h_source.html#l00168">Operateur_base::flux_bords_</a>, <a class="el" href="Op__Conv__VEF__base_8h_source.html#l00092">Op_Conv_VEF_base::la_zone_vef</a>, <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8cpp_source.html#l02128">mettre_a_jour_pour_periodicite()</a>, <a class="el" href="Porosites__champ_8cpp_source.html#l00035">modif_par_porosite_si_flag()</a>, <a class="el" href="Op__VEF__Face_8cpp_source.html#l00384">Op_VEF_Face::modifier_flux()</a>, <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8cpp_source.html#l00859">modifier_flux_operateur_centre()</a>, <a class="el" href="DoubleTab_8h_source.html#l00264">DoubleTab::nb_dim()</a>, <a class="el" href="Zone__dis__base_8h_source.html#l00144">Zone_dis_base::nb_elem_tot()</a>, <a class="el" href="Zone__VF_8h_source.html#l00547">Zone_VF::nb_faces_bord()</a>, <a class="el" href="Elem__VEF_8h_source.html#l00083">Elem_VEF::nb_facette()</a>, <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8h_source.html#l00124">old_centered_</a>, <a class="el" href="Op__Conv__VEF__base_8cpp_source.html#l00053">Op_Conv_VEF_base::phi_u_transportant()</a>, <a class="el" href="Zone__VF_8h_source.html#l00285">Zone_VF::porosite_face()</a>, <a class="el" href="Cast_8h_source.html#l00059">ref_cast</a>, <a class="el" href="DoubleTab_8cpp_source.html#l00335">DoubleTab::resize()</a>, <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8h_source.html#l00123">stabilized_</a>, <a class="el" href="Op__Conv__EF_8cpp.html#aec139ab06c54f3c620f1e9944627c994">transporte_</a>, <a class="el" href="Zone__VEF_8h_source.html#l00138">Zone_VEF::type_elem()</a>, <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8h_source.html#l00122">upwind_</a>, <a class="el" href="Ref__Champ__Inc__base_8h_source.html#l00028">Ref_Champ_Inc_base::valeur()</a>, <a class="el" href="Ref__Zone__VEF_8h_source.html#l00028">Ref_Zone_VEF::valeur()</a>, <a class="el" href="Champ__Inc__base_8cpp_source.html#l00221">Champ_Inc_base::valeurs()</a>, and <a class="el" href="Op__Conv__VEF__base_8h_source.html#l00094">Op_Conv_VEF_base::vitesse_</a>.</p>
<div class="fragment"><pre class="fragment">{
  <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a> sauv(resu);
  resu=0;

  <span class="keyword">const</span> <a class="code" href="classZone__VEF.html" title="class Zone_VEF Classe instanciable qui derive de Zone_VF. Cette classe contient les informations geom...">Zone_VEF</a>&amp; zone_VEF = <a class="code" href="classOp__Conv__VEF__base.html#a6c29a488a6805ba4a9f2f059cdba77ae">la_zone_vef</a>.<a class="code" href="classRef__Zone__VEF.html#aafd9a5ee1a76f290c9c6b5447b0c8d30">valeur</a>();
  <span class="keyword">const</span> <a class="code" href="classChamp__P1NC.html">Champ_P1NC</a>&amp; la_vitesse=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>( <a class="code" href="classChamp__P1NC.html">Champ_P1NC</a>, <a class="code" href="classOp__Conv__VEF__base.html#a5547875832fb45e09b1115372fb76ffd">vitesse_</a>.<a class="code" href="classRef__Champ__Inc__base.html#a17553641a4c06730e1562125e07b3490">valeur</a>());
  <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; vitesse_2=la_vitesse.<a class="code" href="classChamp__Inc__base.html#adb537f43f1649e103a8980314c7ed175" title="Renvoie le tableau des valeurs du champ au temps courant.">valeurs</a>();
  <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; porosite_face = zone_VEF.<a class="code" href="classZone__VF.html#ad9d74d1d9da9f50ab26768dbbca7711b">porosite_face</a>();

  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; elem_faces = zone_VEF.<a class="code" href="classZone__VF.html#a067e462dcd3ab92b0f6d945b19e4eb37" title="renvoie le numero de le ieme face de la maille num_elem la facon dont ces faces sont numerotees est l...">elem_faces</a>();

  <span class="keyword">const</span> <span class="keywordtype">int</span> marq=<a class="code" href="classOp__Conv__VEF__base.html#ad380b9b9ca1d70282b289838a604a4b0" title="definit si l&#39;on convecte psi avec phi*u ou avec u">phi_u_transportant</a>(<a class="code" href="classMorEqn.html#a615dd9abff96edcb625fa0424a489864" title="Renvoie la reference sur l&#39;equation pointe par MorEqn::mon_equation. (version const)">equation</a>());
  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_faces_elem=elem_faces.<a class="code" href="classIntTab.html#abc3b32c94925a82f69d5b153a356e359" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(1);
  assert(nb_faces_elem==(<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>+1));
  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_elem_tot = zone_VEF.<a class="code" href="classZone__dis__base.html#a4d6aa445f152aa6dc54d66ea7a071147">nb_elem_tot</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> nfa7 = zone_VEF.<a class="code" href="classZone__VEF.html#a46693c060b8096fb2595ca72192eea2a">type_elem</a>().<a class="code" href="classElem__VEF.html#a4a34777c0083b38dd34c8a400d5b4e90">nb_facette</a>();

  <span class="keywordtype">int</span> nb_comp=1;
  <span class="keywordflow">if</span>(resu.<a class="code" href="classDoubleTab.html#ae6dda48778e7107e1beb723beef1f75b" title="Returns the number of dimensions of the array (&gt;= 1)">nb_dim</a>()!=1)
    nb_comp=resu.<a class="code" href="classDoubleTab.html#ac3805e2637a3b880ba2d3e650c69dac4" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(1);

  <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a> <a class="code" href="Op__Conv__EF_8cpp.html#aec139ab06c54f3c620f1e9944627c994">transporte_</a>;
  <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a> vitesse_face_;
<span class="comment">// soit on a transporte=phi*transporte_ et vitesse=vitesse_</span>
<span class="comment">// soit transporte=transporte_ et vitesse=phi*vitesse_</span>
<span class="comment">// cela depend si on transporte avec phi u ou avec u.</span>
  <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; velocity=<a class="code" href="Porosites__champ_8cpp.html#a2340e7d73d0f9d34926d012fe1b1d884" title="renvoit le tableau res, res=org si flag=0, res= porosite*org sinon attention ne pas modifier res car ...">modif_par_porosite_si_flag</a>(vitesse_2,vitesse_face_,marq,porosite_face);

  <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a> Kij(nb_elem_tot,nb_faces_elem,nb_faces_elem);
  <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a> Fij(nb_elem_tot,nb_faces_elem,nb_faces_elem,nb_comp);
  <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a> Cij(nb_elem_tot,nfa7);
  <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a> Sij(nb_elem_tot,nfa7);
  <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a> Sij2;
  <span class="keywordflow">if</span> (<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>==3)
    {
      Sij2.<a class="code" href="classDoubleTab.html#ae83b4d31205c53d9c8d2b43da178ce75" title="Change la taille du vecteur (identique a resize_array() pour le traitement des anciennes valeurs et d...">resize</a>(nb_elem_tot,nfa7);
      Sij2=0.;
    }

<span class="comment">// Pour tenir compte des conditions de Neumann sortie libre</span>

<span class="comment">// soit on a transporte=phi*transporte_ et vitesse=vitesse_</span>
<span class="comment">// soit transporte=transporte_ et vitesse=phi*vitesse_</span>
<span class="comment">// cela depend si on transporte avec phi u ou avec u.</span>
  <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; transporte=<a class="code" href="Porosites__champ_8cpp.html#a2340e7d73d0f9d34926d012fe1b1d884" title="renvoit le tableau res, res=org si flag=0, res= porosite*org sinon attention ne pas modifier res car ...">modif_par_porosite_si_flag</a>(transporte_2,transporte_,!marq,porosite_face);

<span class="comment">// Initialisation du tableau flux_bords_ pour le calcul des pertes de charge</span>
  <a class="code" href="classOperateur__base.html#a451f51b41518ddbc0d3f586a8177d319" title="Tableau contenant les flux sur les bords de l&#39;operateur.">flux_bords_</a>.<a class="code" href="classDoubleTab.html#ae83b4d31205c53d9c8d2b43da178ce75" title="Change la taille du vecteur (identique a resize_array() pour le traitement des anciennes valeurs et d...">resize</a>(zone_VEF.<a class="code" href="classZone__VF.html#a8815e2276637c0db23868f043dc43e58" title="renvoie le nombre de faces sur lesquelles sont appliquees les conditions limites : bords...">nb_faces_bord</a>(),nb_comp);
  <a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#ad9cd682b100057d3019ba30b61a9b469">calculer_flux_bords</a>(Kij,velocity,transporte);


<span class="comment">// statistiques().begin_count(m1);</span>
  <a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#afde9a8f6daffddcc35a097fd68674797">calculer_coefficients_operateur_centre</a>(Kij,Cij,Sij,Sij2,nb_comp,velocity);
  <a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#aaf6d31030b81017b92df85d3377d6ae9">calculer_flux_operateur_centre</a>(Fij,Kij,Cij,Sij,Sij2,nb_comp,velocity,transporte);
  <span class="keywordflow">if</span> (<a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#af27e616d4be292efae0dcd25ef29278c">old_centered_</a>) <a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#aea685b2416b3023598d337ab366512cb">modifier_flux_operateur_centre</a>(Fij,Kij,Cij,Sij,Sij2,nb_comp,velocity,transporte);
<span class="comment">// statistiques().end_count(m1);</span>
<span class="comment">// statistiques().begin_count(m2);</span>

  <span class="keywordflow">if</span> (<a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#af79e661742c516fb1f0945636d84f900">centered_</a>) <a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#a0cd4001abc6587f38b6e3f23d251bc68">ajouter_operateur_centre</a>(Kij,Fij,transporte,resu);
  <span class="keywordflow">if</span> (<a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#ad596610363f5610f9ab6517b977b3122">upwind_</a>) <a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#a7a5c2445abefb22846ad5eec13fde90d">ajouter_diffusion</a>(Kij,Fij,transporte,resu);
<span class="comment">// statistiques().end_count(m2);</span>
<span class="comment">// statistiques().begin_count(m3);</span>
  <span class="keywordflow">if</span> (<a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#a2b88ace4b5e403aacf90ce4a6787b76c">stabilized_</a>) <a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#a0a4d5294bb89871b05c740fa867841b9">ajouter_antidiffusion</a>(Kij,Fij,transporte,resu);

<span class="comment">// statistiques().end_count(m3);</span>
  <a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#a98bafc0524994d1bba96aff4b28540b8">mettre_a_jour_pour_periodicite</a>(Kij,transporte,resu);

  resu*=-1.;<span class="comment">//car l&#39;operateur de convection est construit en tant que terme source</span>
  resu+=sauv;

  <a class="code" href="classOp__VEF__Face.html#a6c8ce571769b4f2e20b07cbb7a6944f2">modifier_flux</a>(*<span class="keyword">this</span>);

  <span class="keywordflow">return</span> resu;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a0a4d5294bb89871b05c740fa867841b9"></a><!-- doxytag: member="Op_Conv_Muscl_New_VEF_Face::ajouter_antidiffusion" ref="a0a4d5294bb89871b05c740fa867841b9" args="(const DoubleTab &amp;, const DoubleTab &amp;, const DoubleTab &amp;, DoubleTab &amp;) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDoubleTab.html">DoubleTab</a> &amp; Op_Conv_Muscl_New_VEF_Face::ajouter_antidiffusion </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>Kij</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>Fij</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>transporte</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>resu</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8cpp_source.html#l01670">1670</a> of file <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8cpp_source.html">Op_Conv_Muscl_New_VEF_Face.cpp</a>.</p>

<p>References <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8cpp_source.html#l01828">ajouter_antidiffusion_v1()</a>, <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8cpp_source.html#l01699">ajouter_antidiffusion_v2()</a>, <a class="el" href="EntreeSortie_8h_source.html#l00032">Cerr</a>, <a class="el" href="Process_8cpp_source.html#l00223">Process::exit()</a>, <a class="el" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>, <a class="el" href="Process_8cpp_source.html#l00095">Process::je_suis_maitre()</a>, and <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8h_source.html#l00125">version_</a>.</p>

<p>Referenced by <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8cpp_source.html#l01029">ajouter()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">switch</span>(<a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#a628f5f0e8616ec26b0541bdd128238c8">version_</a>)
    {
    <span class="keywordflow">case</span> 1 :

      <span class="keywordflow">return</span> <a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#a97cd8ef9b333f725b08b769aa6bd846e">ajouter_antidiffusion_v1</a>(Kij,Fij,transporte,resu);
      <span class="keywordflow">break</span>;

    <span class="keywordflow">case</span> 2 :

      <span class="keywordflow">return</span> <a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#a78488062b4b9cb57b6b63b1fdbd9895c">ajouter_antidiffusion_v2</a>(Kij,Fij,transporte,resu);
      <span class="keywordflow">break</span>;

    <span class="keywordflow">default</span> :

      <span class="keywordflow">if</span> (<a class="code" href="classProcess.html#acd052b99706c577f8a5b6656217cf4c2" title="renvoie 1 si on est sur le processeur maitre du groupe courant (c&#39;est a dire me() == 0)...">Process::je_suis_maitre</a>())
        {
          <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a>&lt;&lt;<span class="stringliteral">&quot;Error in Op_Conv_Muscl_New_VEF_Face::ajouter_antidiffusion()&quot;</span>&lt;&lt;<a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
          <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a>&lt;&lt;<span class="stringliteral">&quot;Version number &quot;</span>&lt;&lt;<a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#a628f5f0e8616ec26b0541bdd128238c8">version_</a>&lt;&lt;<span class="stringliteral">&quot; of antidiffusive operator does not exist&quot;</span>&lt;&lt;finl;
        }
      <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">Process::exit</a>();
      <span class="keywordflow">break</span>;
    }

  <span class="keywordflow">return</span> resu;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a97cd8ef9b333f725b08b769aa6bd846e"></a><!-- doxytag: member="Op_Conv_Muscl_New_VEF_Face::ajouter_antidiffusion_v1" ref="a97cd8ef9b333f725b08b769aa6bd846e" args="(const DoubleTab &amp;, const DoubleTab &amp;, const DoubleTab &amp;, DoubleTab &amp;) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDoubleTab.html">DoubleTab</a> &amp; Op_Conv_Muscl_New_VEF_Face::ajouter_antidiffusion_v1 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>Kij</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>Fij</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>transporte</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>resu</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8cpp_source.html#l01828">1828</a> of file <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8cpp_source.html">Op_Conv_Muscl_New_VEF_Face.cpp</a>.</p>

<p>References <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8h_source.html#l00119">alpha_</a>, <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8cpp_source.html#l02043">calculer_senseur_v1()</a>, <a class="el" href="Double_8h_source.html#l00255">dabs()</a>, <a class="el" href="DoubleTab_8h_source.html#l00243">DoubleTab::dimension()</a>, <a class="el" href="Double_8h_source.html#l00072">DMAXFLOAT</a>, <a class="el" href="Double_8h_source.html#l00075">DMINFLOAT</a>, <a class="el" href="Zone__VF_8h_source.html#l00574">Zone_VF::elem_faces()</a>, <a class="el" href="Zone__VF_8h_source.html#l00458">Zone_VF::face_voisins()</a>, <a class="el" href="Zone__VF_8h_source.html#l00176">Zone_VF::get_num_fac_loc()</a>, <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8h_source.html#l00112">is_dirichlet_faces_</a>, <a class="el" href="Elem__VEF__base_8h_source.html#l00047">Elem_VEF_base::KEL()</a>, <a class="el" href="Op__Conv__VEF__base_8h_source.html#l00092">Op_Conv_VEF_base::la_zone_vef</a>, <a class="el" href="DoubleTab_8h_source.html#l00264">DoubleTab::nb_dim()</a>, <a class="el" href="Zone__dis__base_8h_source.html#l00144">Zone_dis_base::nb_elem_tot()</a>, <a class="el" href="Elem__VEF_8h_source.html#l00083">Elem_VEF::nb_facette()</a>, <a class="el" href="Cast_8h_source.html#l00059">ref_cast</a>, <a class="el" href="Zone__VEF_8h_source.html#l00138">Zone_VEF::type_elem()</a>, <a class="el" href="Elem__VEF_8h_source.html#l00041">Deriv_Elem_VEF_base::valeur()</a>, and <a class="el" href="Ref__Zone__VEF_8h_source.html#l00028">Ref_Zone_VEF::valeur()</a>.</p>

<p>Referenced by <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8cpp_source.html#l01670">ajouter_antidiffusion()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">const</span> <a class="code" href="classZone__VEF.html" title="class Zone_VEF Classe instanciable qui derive de Zone_VF. Cette classe contient les informations geom...">Zone_VEF</a>&amp; zone_VEF=<a class="code" href="classOp__Conv__VEF__base.html#a6c29a488a6805ba4a9f2f059cdba77ae">la_zone_vef</a>.<a class="code" href="classRef__Zone__VEF.html#aafd9a5ee1a76f290c9c6b5447b0c8d30">valeur</a>();

  <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; transporteV=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classDoubleVect.html">DoubleVect</a>,transporte);

  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; elem_faces=zone_VEF.<a class="code" href="classZone__VF.html#a067e462dcd3ab92b0f6d945b19e4eb37" title="renvoie le numero de le ieme face de la maille num_elem la facon dont ces faces sont numerotees est l...">elem_faces</a>();
  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; KEL=zone_VEF.<a class="code" href="classZone__VEF.html#a46693c060b8096fb2595ca72192eea2a">type_elem</a>().<a class="code" href="classDeriv__Elem__VEF__base.html#a2886905d5071be902c77248b69ca0b7b">valeur</a>().<a class="code" href="classElem__VEF__base.html#ab129610ef702aa8c9c98dcb4c7551172">KEL</a>();
  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; face_voisins=zone_VEF.<a class="code" href="classZone__VF.html#a49d4322f5585a8fa95748ca785b70702" title="renvoie l&#39;element voisin de numface dans la direction i. i=0 : dans le sens oppose de l&#39;axe orthogona...">face_voisins</a>();
  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; num_fac_loc = zone_VEF.<a class="code" href="classZone__VF.html#a95113b10f16f37600ba81d3fb41102b2">get_num_fac_loc</a>();

  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_elem_tot=zone_VEF.<a class="code" href="classZone__dis__base.html#a4d6aa445f152aa6dc54d66ea7a071147">nb_elem_tot</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> nfa7 = zone_VEF.<a class="code" href="classZone__VEF.html#a46693c060b8096fb2595ca72192eea2a">type_elem</a>().<a class="code" href="classElem__VEF.html#a4a34777c0083b38dd34c8a400d5b4e90">nb_facette</a>();

  <span class="keywordtype">int</span> nb_comp=1;
  <span class="keywordflow">if</span> (transporte.<a class="code" href="classDoubleTab.html#ae6dda48778e7107e1beb723beef1f75b" title="Returns the number of dimensions of the array (&gt;= 1)">nb_dim</a>()!=1) nb_comp=transporte.<a class="code" href="classDoubleTab.html#ac3805e2637a3b880ba2d3e650c69dac4" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(1);

  <span class="keywordtype">int</span> elem=0;
  <span class="keywordtype">int</span> facei=0,facei_loc=0;
  <span class="keywordtype">int</span> facej=0,facej_loc=0;
  <span class="keywordtype">int</span> ligne=0,colonne=0;
  <span class="keywordtype">int</span> dim=0;
  <span class="keywordtype">int</span> fa7=0;

<span class="comment">// Pour le limiteur</span>
  <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a> Pi_plus(nb_comp),Pi_moins(nb_comp);
  <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a> Qi_plus(nb_comp),Qi_moins(nb_comp);
  Pi_plus=0., Pi_moins=0.;
  Qi_plus=0., Qi_moins=0.;

<span class="comment">// Pour le limiteur</span>
  <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a> Pj_plus(nb_comp),Pj_moins(nb_comp);
  <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a> Qj_plus(nb_comp),Qj_moins(nb_comp);
  Pj_plus=0., Pj_moins=0.;
  Qj_plus=0., Qj_moins=0.;

<span class="comment">// double coeffij=0.,coeffji=0.;</span>
  <span class="keywordtype">double</span> fij=0.,fji=0.;
  <span class="keywordtype">double</span> kij=0.;
  <span class="keywordtype">double</span> R=0.;
  <span class="keywordtype">double</span> Ri=0.;
  <span class="keywordtype">double</span> Rj=0.;
  <span class="keywordtype">double</span> tmp=0.;

  <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; resuV=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classDoubleVect.html">DoubleVect</a>,resu);

<span class="comment">// Pour les faces internes</span>
  <span class="keywordflow">for</span> (elem=0; elem&lt;nb_elem_tot; elem++)
    <span class="keywordflow">for</span> (fa7=0; fa7&lt;nfa7; fa7++)
      {
        facei_loc=KEL(0,fa7);
        facej_loc=KEL(1,fa7);

        facei=elem_faces(elem,facei_loc);
        facej=elem_faces(elem,facej_loc);

        kij=Kij(elem,facei_loc,facej_loc);

        Pi_plus=0., Pi_moins=0.;
        Qi_plus=0., Qi_moins=0.;
        <a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#a62e58f1cd47b3865342a3b37fb1a06df">calculer_senseur_v1</a>(Kij,Fij,transporteV,nb_comp,facei,elem_faces,face_voisins,num_fac_loc,Pi_plus,Pi_moins,Qi_plus,Qi_moins);

        Pj_plus=0., Pj_moins=0.;
        Qj_plus=0., Qj_moins=0.;
        <a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#a62e58f1cd47b3865342a3b37fb1a06df">calculer_senseur_v1</a>(Kij,Fij,transporteV,nb_comp,facej,elem_faces,face_voisins,num_fac_loc,Pj_plus,Pj_moins,Qj_plus,Qj_moins);

        <span class="keywordflow">for</span> (dim=0; dim&lt;nb_comp; dim++)
          {
            fij=<a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#aba93a9d2fdc68f373410c6439c95074c">alpha_</a>*Fij(elem,facei_loc,facej_loc,dim);
            fji=<a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#aba93a9d2fdc68f373410c6439c95074c">alpha_</a>*Fij(elem,facej_loc,facei_loc,dim);

            ligne=facei*nb_comp+dim;
            colonne=facej*nb_comp+dim;

            <span class="keywordflow">if</span> (kij&gt;=0.)
              {
<span class="comment">// Face amont : facei</span>
                <span class="keywordflow">if</span> (fij&gt;=0.)
                  {
<span class="comment">// Ri=(Pi_plus(dim)==0.)?0.:Qi_plus(dim)/Pi_plus(dim);</span>
<span class="comment">// Rj=(Pj_moins(dim)==0.)?0.:Qj_moins(dim)/Pj_moins(dim);//car fji=-fij</span>

<span class="comment">// Ri=(Pi_plus(dim)==0.)?0.:Qi_plus(dim)/(Pi_plus(dim)+DMINFLOAT);</span>
<span class="comment">// Rj=(Pj_moins(dim)==0.)?0.:Qj_moins(dim)/(Pj_moins(dim)+DMINFLOAT);//car fji=-fij</span>

                    Ri=(<a class="code" href="Double_8h.html#aaecd4ca8a2fe69cc6568af2938b94d2e">dabs</a>(Pi_plus(dim))&lt;<a class="code" href="Double_8h.html#a0a3fffa6d17ad8f7de4bb337c6266561">DMINFLOAT</a>)?0.:Qi_plus(dim)/Pi_plus(dim);
                    Rj=(<a class="code" href="Double_8h.html#aaecd4ca8a2fe69cc6568af2938b94d2e">dabs</a>(Pj_moins(dim))&lt;<a class="code" href="Double_8h.html#a0a3fffa6d17ad8f7de4bb337c6266561">DMINFLOAT</a>)?0.:Qj_moins(dim)/Pj_moins(dim);<span class="comment">//car fji=-fij</span>
                  }
                <span class="keywordflow">else</span>
                  {
<span class="comment">// Ri=(Pi_moins(dim)==0.)?0.:Qi_moins(dim)/Pi_moins(dim);</span>
<span class="comment">// Rj=(Pj_plus(dim)==0.)?0.:Qj_plus(dim)/Pj_plus(dim);//car fji=-fij</span>

<span class="comment">// Ri=(Pi_moins(dim)==0.)?0.:Qi_moins(dim)/(Pi_moins(dim)+DMINFLOAT);</span>
<span class="comment">// Rj=(Pj_plus(dim)==0.)?0.:Qj_plus(dim)/(Pj_plus(dim)+DMINFLOAT);//car fji=-fij</span>

                    Ri=(<a class="code" href="Double_8h.html#aaecd4ca8a2fe69cc6568af2938b94d2e">dabs</a>(Pi_moins(dim))&lt;<a class="code" href="Double_8h.html#a0a3fffa6d17ad8f7de4bb337c6266561">DMINFLOAT</a>)?0.:Qi_moins(dim)/Pi_moins(dim);
                    Rj=(<a class="code" href="Double_8h.html#aaecd4ca8a2fe69cc6568af2938b94d2e">dabs</a>(Pj_plus(dim))&lt;<a class="code" href="Double_8h.html#a0a3fffa6d17ad8f7de4bb337c6266561">DMINFLOAT</a>)?0.:Qj_plus(dim)/Pj_plus(dim);<span class="comment">//car fji=-fij</span>
                  }

                <span class="keywordflow">if</span> (<a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#a1e7b0db2325d8e59bbaa9460ed6f3826">is_dirichlet_faces_</a>(facej)) Rj=<a class="code" href="Double_8h.html#ae0ee0cebfad5968da0ad6cc7a49e16b6">DMAXFLOAT</a>;<span class="comment">//on n&#39;a pas besoin de prendre le min quand il y a une face de Dirichlet</span>
                R=(Ri&lt;=Rj)?Ri:Rj;
                R=(*limiteur_)(R);

                tmp=R*fij;
                resuV[ligne]+=tmp;
                resuV[colonne]-=tmp;
              }
            <span class="keywordflow">else</span>
              {
<span class="comment">// Face amont : facej</span>
                <span class="keywordflow">if</span> (fji&lt;=0.)
                  {
<span class="comment">// Rj=(Pj_moins(dim)==0.)?0.:Qj_moins(dim)/Pj_moins(dim);</span>
<span class="comment">// Ri=(Pi_plus(dim)==0.)?0.:Qi_plus(dim)/Pi_plus(dim);</span>

<span class="comment">// Rj=(Pj_moins(dim)==0.)?0.:Qj_moins(dim)/(Pj_moins(dim)+DMINFLOAT);</span>
<span class="comment">// Ri=(Pi_plus(dim)==0.)?0.:Qi_plus(dim)/(Pi_plus(dim)+DMINFLOAT);</span>

                    Rj=(<a class="code" href="Double_8h.html#aaecd4ca8a2fe69cc6568af2938b94d2e">dabs</a>(Pj_moins(dim))&lt;<a class="code" href="Double_8h.html#a0a3fffa6d17ad8f7de4bb337c6266561">DMINFLOAT</a>)?0.:Qj_moins(dim)/Pj_moins(dim);
                    Ri=(<a class="code" href="Double_8h.html#aaecd4ca8a2fe69cc6568af2938b94d2e">dabs</a>(Pi_plus(dim))&lt;<a class="code" href="Double_8h.html#a0a3fffa6d17ad8f7de4bb337c6266561">DMINFLOAT</a>)?0.:Qi_plus(dim)/Pi_plus(dim);
                  }
                <span class="keywordflow">else</span>
                  {
<span class="comment">// Rj=(Pj_plus(dim)==0.)?0.:Qj_plus(dim)/Pj_plus(dim);</span>
<span class="comment">// Ri=(Pi_moins(dim)==0.)?0.:Qi_moins(dim)/Pi_moins(dim);</span>

<span class="comment">// Rj=(Pj_plus(dim)==0.)?0.:Qj_plus(dim)/(Pj_plus(dim)+DMINFLOAT);</span>
<span class="comment">// Ri=(Pi_moins(dim)==0.)?0.:Qi_moins(dim)/(Pi_moins(dim)+DMINFLOAT);</span>

                    Rj=(<a class="code" href="Double_8h.html#aaecd4ca8a2fe69cc6568af2938b94d2e">dabs</a>(Pj_plus(dim))&lt;<a class="code" href="Double_8h.html#a0a3fffa6d17ad8f7de4bb337c6266561">DMINFLOAT</a>)?0.:Qj_plus(dim)/Pj_plus(dim);
                    Ri=(<a class="code" href="Double_8h.html#aaecd4ca8a2fe69cc6568af2938b94d2e">dabs</a>(Pi_moins(dim))&lt;<a class="code" href="Double_8h.html#a0a3fffa6d17ad8f7de4bb337c6266561">DMINFLOAT</a>)?0.:Qi_moins(dim)/Pi_moins(dim);
                  }

                <span class="keywordflow">if</span> (<a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#a1e7b0db2325d8e59bbaa9460ed6f3826">is_dirichlet_faces_</a>(facei)) Ri=<a class="code" href="Double_8h.html#ae0ee0cebfad5968da0ad6cc7a49e16b6">DMAXFLOAT</a>;<span class="comment">//on n&#39;a pas besoin de prendre le min quand il y a une face de Dirichlet</span>
                R=(Ri&lt;=Rj)?Ri:Rj;
                R=(*limiteur_)(R);

                tmp=R*fji;
                resuV[ligne]-=tmp;
                resuV[colonne]+=tmp;
              }
          }
      }

<span class="comment">// Pour les faces de bord</span>
<span class="comment">// IL N&#39;Y A RIEN a FAIRE TOUT EST FAIT DANS LA FONCTION AJOUTER_DIFFUSION</span>
<span class="comment">// QUI EST PARFAITEMENT COMPLeTER PAR LA FONCTION AJOUTER_ANTIDIFFUSION</span>

<span class="comment">// Retour du resultat</span>
<span class="comment">// resuV+=antidiff;</span>
  <span class="keywordflow">return</span> resu;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a78488062b4b9cb57b6b63b1fdbd9895c"></a><!-- doxytag: member="Op_Conv_Muscl_New_VEF_Face::ajouter_antidiffusion_v2" ref="a78488062b4b9cb57b6b63b1fdbd9895c" args="(const DoubleTab &amp;, const DoubleTab &amp;, const DoubleTab &amp;, DoubleTab &amp;) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDoubleTab.html">DoubleTab</a> &amp; Op_Conv_Muscl_New_VEF_Face::ajouter_antidiffusion_v2 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>Kij</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>Fij</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>transporte</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>resu</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8cpp_source.html#l01699">1699</a> of file <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8cpp_source.html">Op_Conv_Muscl_New_VEF_Face.cpp</a>.</p>

<p>References <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8h_source.html#l00119">alpha_</a>, <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8cpp_source.html#l01984">calculer_senseur_v2()</a>, <a class="el" href="Double_8h_source.html#l00255">dabs()</a>, <a class="el" href="DoubleTab_8h_source.html#l00243">DoubleTab::dimension()</a>, <a class="el" href="Double_8h_source.html#l00075">DMINFLOAT</a>, <a class="el" href="Zone__VF_8h_source.html#l00574">Zone_VF::elem_faces()</a>, <a class="el" href="Zone__VF_8h_source.html#l00458">Zone_VF::face_voisins()</a>, <a class="el" href="Zone__VF_8h_source.html#l00176">Zone_VF::get_num_fac_loc()</a>, <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8h_source.html#l00112">is_dirichlet_faces_</a>, <a class="el" href="Elem__VEF__base_8h_source.html#l00047">Elem_VEF_base::KEL()</a>, <a class="el" href="Op__Conv__VEF__base_8h_source.html#l00092">Op_Conv_VEF_base::la_zone_vef</a>, <a class="el" href="DoubleTab_8h_source.html#l00264">DoubleTab::nb_dim()</a>, <a class="el" href="Zone__dis__base_8h_source.html#l00144">Zone_dis_base::nb_elem_tot()</a>, <a class="el" href="Elem__VEF_8h_source.html#l00083">Elem_VEF::nb_facette()</a>, <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8cpp_source.html#l00061">optimum()</a>, <a class="el" href="Cast_8h_source.html#l00059">ref_cast</a>, <a class="el" href="Zone__VEF_8h_source.html#l00138">Zone_VEF::type_elem()</a>, <a class="el" href="Elem__VEF_8h_source.html#l00041">Deriv_Elem_VEF_base::valeur()</a>, and <a class="el" href="Ref__Zone__VEF_8h_source.html#l00028">Ref_Zone_VEF::valeur()</a>.</p>

<p>Referenced by <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8cpp_source.html#l01670">ajouter_antidiffusion()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">const</span> <a class="code" href="classZone__VEF.html" title="class Zone_VEF Classe instanciable qui derive de Zone_VF. Cette classe contient les informations geom...">Zone_VEF</a>&amp; zone_VEF=<a class="code" href="classOp__Conv__VEF__base.html#a6c29a488a6805ba4a9f2f059cdba77ae">la_zone_vef</a>.<a class="code" href="classRef__Zone__VEF.html#aafd9a5ee1a76f290c9c6b5447b0c8d30">valeur</a>();

  <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; transporteV=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classDoubleVect.html">DoubleVect</a>,transporte);

  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; elem_faces=zone_VEF.<a class="code" href="classZone__VF.html#a067e462dcd3ab92b0f6d945b19e4eb37" title="renvoie le numero de le ieme face de la maille num_elem la facon dont ces faces sont numerotees est l...">elem_faces</a>();
  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; KEL=zone_VEF.<a class="code" href="classZone__VEF.html#a46693c060b8096fb2595ca72192eea2a">type_elem</a>().<a class="code" href="classDeriv__Elem__VEF__base.html#a2886905d5071be902c77248b69ca0b7b">valeur</a>().<a class="code" href="classElem__VEF__base.html#ab129610ef702aa8c9c98dcb4c7551172">KEL</a>();
  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; face_voisins=zone_VEF.<a class="code" href="classZone__VF.html#a49d4322f5585a8fa95748ca785b70702" title="renvoie l&#39;element voisin de numface dans la direction i. i=0 : dans le sens oppose de l&#39;axe orthogona...">face_voisins</a>();
  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; num_fac_loc = zone_VEF.<a class="code" href="classZone__VF.html#a95113b10f16f37600ba81d3fb41102b2">get_num_fac_loc</a>();

  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_elem_tot=zone_VEF.<a class="code" href="classZone__dis__base.html#a4d6aa445f152aa6dc54d66ea7a071147">nb_elem_tot</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> nfa7 = zone_VEF.<a class="code" href="classZone__VEF.html#a46693c060b8096fb2595ca72192eea2a">type_elem</a>().<a class="code" href="classElem__VEF.html#a4a34777c0083b38dd34c8a400d5b4e90">nb_facette</a>();

  <span class="keywordtype">int</span> nb_comp=1;
  <span class="keywordflow">if</span> (transporte.<a class="code" href="classDoubleTab.html#ae6dda48778e7107e1beb723beef1f75b" title="Returns the number of dimensions of the array (&gt;= 1)">nb_dim</a>()!=1) nb_comp=transporte.<a class="code" href="classDoubleTab.html#ac3805e2637a3b880ba2d3e650c69dac4" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(1);

  <span class="keywordtype">int</span> elem=0;
  <span class="keywordtype">int</span> facei=0,facei_loc=0;
  <span class="keywordtype">int</span> facej=0,facej_loc=0;
  <span class="keywordtype">int</span> ligne=0,colonne=0;
  <span class="keywordtype">int</span> dim=0;
  <span class="keywordtype">int</span> fa7=0;

<span class="comment">// Pour le limiteur</span>
  <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a> P_plus(nb_comp),P_moins(nb_comp);
  <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a> Q_plus(nb_comp),Q_moins(nb_comp);
  P_plus=0., P_moins=0.;
  Q_plus=0., Q_moins=0.;

<span class="comment">// double coeffij=0.,coeffji=0.;</span>
  <span class="keywordtype">double</span> fij=0.,fji=0.;
  <span class="keywordtype">double</span> kij=0.;
  <span class="keywordtype">double</span> R=0.;
  <span class="keywordtype">double</span> tmp=0.;
  <span class="keywordtype">double</span> fij_low=0.,fji_low=0.;

  <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; resuV=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classDoubleVect.html">DoubleVect</a>,resu);

<span class="comment">// Pour les faces internes</span>
  <span class="keywordflow">for</span> (elem=0; elem&lt;nb_elem_tot; elem++)
    <span class="keywordflow">for</span> (fa7=0; fa7&lt;nfa7; fa7++)
      {
        facei_loc=KEL(0,fa7);
        facej_loc=KEL(1,fa7);

        facei=elem_faces(elem,facei_loc);
        facej=elem_faces(elem,facej_loc);

        kij=Kij(elem,facei_loc,facej_loc);

        P_plus=0., P_moins=0.;
        Q_plus=0., Q_moins=0.;
        <span class="keywordflow">if</span> (kij&gt;=0.) <span class="comment">//facei amont</span>
          <a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#a2032486fe36dd90a3ae2bffcc16569c0">calculer_senseur_v2</a>(Kij,Fij,transporteV,nb_comp,facei,elem_faces,face_voisins,num_fac_loc,P_plus,P_moins,Q_plus,Q_moins);<span class="comment">//La face i est amont</span>
        <span class="keywordflow">else</span> <span class="comment">//facej amont</span>
          <a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#a2032486fe36dd90a3ae2bffcc16569c0">calculer_senseur_v2</a>(Kij,Fij,transporteV,nb_comp,facej,elem_faces,face_voisins,num_fac_loc,P_plus,P_moins,Q_plus,Q_moins);<span class="comment">//La face j est amont</span>

        <span class="keywordflow">for</span> (dim=0; dim&lt;nb_comp; dim++)
          {
            fij=<a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#aba93a9d2fdc68f373410c6439c95074c">alpha_</a>*Fij(elem,facei_loc,facej_loc,dim);
            fji=<a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#aba93a9d2fdc68f373410c6439c95074c">alpha_</a>*Fij(elem,facej_loc,facei_loc,dim);

            ligne=facei*nb_comp+dim;
            colonne=facej*nb_comp+dim;

            fij_low=transporteV[colonne]-transporteV[ligne];
            fij_low*=kij;
            fji_low=fij_low;

            <span class="keywordflow">if</span> (kij&gt;=0.) <span class="comment">//facei amont</span>
              {
<span class="comment">// if (fij&gt;=0.) R=(P_plus(dim)==0.)?0.:Q_plus(dim)/P_plus(dim);</span>
<span class="comment">// else R=(P_moins(dim)==0.)?0.:Q_moins(dim)/P_moins(dim);</span>

<span class="comment">// if (fij&gt;=0.) R=(P_plus(dim)==0.)?0.:Q_plus(dim)/(P_plus(dim)+DMINFLOAT);</span>
<span class="comment">// else R=(P_moins(dim)==0.)?0.:Q_moins(dim)/(P_moins(dim)+DMINFLOAT);</span>

                <span class="keywordflow">if</span> (fij&gt;=0.) R=(<a class="code" href="Double_8h.html#aaecd4ca8a2fe69cc6568af2938b94d2e">dabs</a>(P_plus(dim))&lt;<a class="code" href="Double_8h.html#a0a3fffa6d17ad8f7de4bb337c6266561">DMINFLOAT</a>)?0.:Q_plus(dim)/P_plus(dim);
                <span class="keywordflow">else</span> R=(<a class="code" href="Double_8h.html#aaecd4ca8a2fe69cc6568af2938b94d2e">dabs</a>(P_moins(dim))&lt;<a class="code" href="Double_8h.html#a0a3fffa6d17ad8f7de4bb337c6266561">DMINFLOAT</a>)?0.:Q_moins(dim)/P_moins(dim);


                R=(*limiteur_)(R);
                R*=fij;

                <span class="keywordflow">if</span> (!<a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#a1e7b0db2325d8e59bbaa9460ed6f3826">is_dirichlet_faces_</a>(facej))
                  tmp=<a class="code" href="Op__Conv__Muscl__New__VEF__Face_8cpp.html#abd18971dfe4f2b2333aaf0203d859ca6">optimum</a>(R,fji_low);
                <span class="keywordflow">else</span>
                  tmp=R;

                resuV[ligne]+=tmp;
                resuV[colonne]-=tmp;
              }
            <span class="keywordflow">else</span> <span class="comment">//facej amont</span>
              {
<span class="comment">// if (fji&lt;=0.) R=(P_moins(dim)==0.)?0.:Q_moins(dim)/P_moins(dim);</span>
<span class="comment">// else R=(P_plus(dim)==0.)?0.:Q_plus(dim)/P_plus(dim);</span>

<span class="comment">// if (fji&lt;=0.) R=(P_moins(dim)==0.)?0.:Q_moins(dim)/(P_moins(dim)+DMINFLOAT);</span>
<span class="comment">// else R=(P_plus(dim)==0.)?0.:Q_plus(dim)/(P_plus(dim)+DMINFLOAT);</span>

                <span class="keywordflow">if</span> (fji&lt;=0.) R=(<a class="code" href="Double_8h.html#aaecd4ca8a2fe69cc6568af2938b94d2e">dabs</a>(P_moins(dim))&lt;<a class="code" href="Double_8h.html#a0a3fffa6d17ad8f7de4bb337c6266561">DMINFLOAT</a>)?0.:Q_moins(dim)/P_moins(dim);
                <span class="keywordflow">else</span> R=(<a class="code" href="Double_8h.html#aaecd4ca8a2fe69cc6568af2938b94d2e">dabs</a>(P_plus(dim))&lt;<a class="code" href="Double_8h.html#a0a3fffa6d17ad8f7de4bb337c6266561">DMINFLOAT</a>)?0.:Q_plus(dim)/P_plus(dim);


                R=(*limiteur_)(R);
                R*=fji;

                <span class="keywordflow">if</span> (!<a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#a1e7b0db2325d8e59bbaa9460ed6f3826">is_dirichlet_faces_</a>(facei))
                  tmp=<a class="code" href="Op__Conv__Muscl__New__VEF__Face_8cpp.html#abd18971dfe4f2b2333aaf0203d859ca6">optimum</a>(R,fij_low);
                <span class="keywordflow">else</span>
                  tmp=R;

                resuV[ligne]-=tmp;
                resuV[colonne]+=tmp;
              }
          }
      }


<span class="comment">// Pour les faces de bord</span>
<span class="comment">// IL N&#39;Y A RIEN a FAIRE TOUT EST FAIT DANS LA FONCTION AJOUTER_DIFFUSION</span>
<span class="comment">// QUI EST PARFAITEMENT COMPLeTER PAR LA FONCTION AJOUTER_ANTIDIFFUSION</span>

<span class="comment">// Retour du resultat</span>
  <span class="keywordflow">return</span> resu;
}
</pre></div>
</div>
</div>
<a class="anchor" id="abac773d46607384fdecf846d33a9c3c5"></a><!-- doxytag: member="Op_Conv_Muscl_New_VEF_Face::ajouter_contribution" ref="abac773d46607384fdecf846d33a9c3c5" args="(const DoubleTab &amp;, Matrice_Morse &amp;) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Op_Conv_Muscl_New_VEF_Face::ajouter_contribution </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>transporte_2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;&#160;</td>
          <td class="paramname"><em>matrice</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="classOp__Conv__VEF__Face.html#ad46bfa5e97653f57e64fb7f890d15e1b">Op_Conv_VEF_Face</a>.</p>

<p>Definition at line <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8cpp_source.html#l02357">2357</a> of file <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8cpp_source.html">Op_Conv_Muscl_New_VEF_Face.cpp</a>.</p>

<p>Referenced by <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8h_source.html#l00136">contribuer_a_avec()</a>.</p>
<div class="fragment"><pre class="fragment">{
}
</pre></div>
</div>
</div>
<a class="anchor" id="ae8449f75326ce9bb64f44c8a67906916"></a><!-- doxytag: member="Op_Conv_Muscl_New_VEF_Face::ajouter_contribution_antidiffusion" ref="ae8449f75326ce9bb64f44c8a67906916" args="(const DoubleTab &amp;, const DoubleTab &amp;, Matrice_Morse &amp;) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Op_Conv_Muscl_New_VEF_Face::ajouter_contribution_antidiffusion </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>Kij</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>transporte</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;&#160;</td>
          <td class="paramname"><em>matrice</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8cpp_source.html#l02778">2778</a> of file <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8cpp_source.html">Op_Conv_Muscl_New_VEF_Face.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{
<span class="comment">// const Zone_VEF&amp; zone_VEF=la_zone_vef.valeur();</span>
<span class="comment">// const Zone_Cl_VEF&amp; zone_Cl_VEF = la_zcl_vef.valeur();</span>

<span class="comment">// const IntTab&amp; elem_faces=zone_VEF.elem_faces();</span>
<span class="comment">// const IntTab&amp; face_voisins = zone_VEF.face_voisins();</span>

<span class="comment">// const int nb_elem_tot=zone_VEF.nb_elem_tot();</span>
<span class="comment">// const int nb_faces_elem=elem_faces.dimension(1);</span>
<span class="comment">// const int nb_bord=zone_Cl_VEF.nb_cond_lim();</span>

<span class="comment">// int nb_comp=1;</span>
<span class="comment">// if (transporte.nb_dim()!=1) nb_comp=transporte.dimension(1);</span>

<span class="comment">// int elem=0;</span>
<span class="comment">// int elem_loc=0;</span>
<span class="comment">// int facei=0,facei_loc=0;</span>
<span class="comment">// int faceiAss=0;</span>
<span class="comment">// int ind_face=0,ind_faceiAss=0;</span>
<span class="comment">// int facej=0,facej_loc=0;</span>
<span class="comment">// int ligne=0,colonne=0;</span>
<span class="comment">// int dim=0;</span>
<span class="comment">// int face_amont=0,face_aval=0;</span>
<span class="comment">// int faceToComplete=0;</span>
<span class="comment">// int num1=0,num2=0;</span>
<span class="comment">// int n_bord=0;</span>

<span class="comment">// double kij=0.,kji=0.,dij=0.;</span>
<span class="comment">// double lij=0.,lji=0.;</span>
<span class="comment">// double daij=0.;</span>
<span class="comment">// double delta=0.;</span>
<span class="comment">// double coeffij=0.,coeffji=0.;</span>
<span class="comment">// double coeff=0.;</span>
<span class="comment">// double R=0.;</span>

<span class="comment">// //Pour le limiteur</span>
<span class="comment">// ArrOfDouble P_plus(nb_comp),P_moins(nb_comp);</span>
<span class="comment">// ArrOfDouble Q_plus(nb_comp),Q_moins(nb_comp);</span>
<span class="comment">// P_plus=0., P_moins=0.;</span>
<span class="comment">// Q_plus=0., Q_moins=0.;</span>

<span class="comment">// const DoubleVect&amp; transporteV=ref_cast(DoubleVect,transporte);</span>
<span class="comment">// const IntTab&amp; num_fac_loc = zone_VEF.get_num_fac_loc();</span>
<span class="comment">// for (elem=0; elem&lt;nb_elem_tot; elem++)</span>
<span class="comment">// for (facei_loc=0; facei_loc&lt;nb_faces_elem; facei_loc++)</span>
<span class="comment">// {</span>
<span class="comment">// facei=elem_faces(elem,facei_loc);</span>

<span class="comment">// P_plus=0., P_moins=0.;</span>
<span class="comment">// Q_plus=0., Q_moins=0.;</span>
<span class="comment">// calculer_senseur(Kij,transporteV,nb_comp,facei,elem_faces,face_voisins,num_fac_loc,P_plus,P_moins,Q_plus,Q_moins);</span>
<span class="comment">// for (facej_loc=0; facej_loc&lt;nb_faces_elem; facej_loc++)</span>
<span class="comment">// if (facej_loc!=facei_loc)</span>
<span class="comment">// {</span>
<span class="comment">// facej=elem_faces(elem,facej_loc);</span>

<span class="comment">// kij = Kij(elem,facei_loc,facej_loc);</span>
<span class="comment">// kji = Kij(elem,facej_loc,facei_loc);</span>
<span class="comment">// dij = Dij(elem,facei_loc,facej_loc,Kij);</span>
<span class="comment">// lij = kij+dij;</span>
<span class="comment">// lji = kji+dij;</span>
<span class="comment">// assert(lij&gt;=0);</span>
<span class="comment">// assert(lji&gt;=0);</span>

<span class="comment">// if (lij&lt;=lji) //facei est amont</span>
<span class="comment">// {</span>
<span class="comment">// face_amont = facei;</span>
<span class="comment">// face_aval = facej;</span>

<span class="comment">// //Si lij==lji, on passe deux foix dans la boucle</span>
<span class="comment">// //d&#39;ou la presence du coefficient 1/2</span>
<span class="comment">// coeff = 1.*(lij&lt;lji)+0.5*(lij==lji);</span>
<span class="comment">// assert(coeff==1. || coeff==0.5);</span>

<span class="comment">// for (dim=0; dim&lt;nb_comp; dim++)</span>
<span class="comment">// {</span>
<span class="comment">// ligne=face_amont*nb_comp+dim;</span>
<span class="comment">// colonne=face_aval*nb_comp+dim;</span>

<span class="comment">// delta=transporteV[ligne]-transporteV[colonne];</span>

<span class="comment">// //Limiteur de pente</span>
<span class="comment">// if (delta&gt;=0.) R=(P_plus(dim)==0.) ? 0. : Q_plus(dim)/P_plus(dim);</span>
<span class="comment">// else  R=(P_moins(dim)==0.) ? 0. : Q_moins(dim)/P_moins(dim);</span>

<span class="comment">// daij=minimum(limiteur(R)*dij,lji);</span>
<span class="comment">// assert(daij&gt;=0);</span>
<span class="comment">// assert(daij&lt;=lji);</span>
<span class="comment">// coeffij=alpha_tab(face_amont)*beta(face_amont)*daij;</span>
<span class="comment">// coeffji=alpha_tab(face_aval)*beta(face_aval)*daij;</span>

<span class="comment">// //Calcul de la matrice</span>
<span class="comment">// matrice(ligne,ligne)-=coeffij*coeff;</span>
<span class="comment">// matrice(ligne,colonne)+=coeffij*coeff;</span>
<span class="comment">// matrice(colonne,colonne)-=coeffji*coeff;</span>
<span class="comment">// matrice(colonne,ligne)+=coeffji*coeff;</span>
<span class="comment">// }</span>
<span class="comment">// }</span>
<span class="comment">// }</span>
<span class="comment">// }</span>

<span class="comment">// //</span>
<span class="comment">// //Pour la periodicite</span>
<span class="comment">// //</span>
<span class="comment">// for (n_bord=0; n_bord&lt;nb_bord; n_bord++)</span>
<span class="comment">// {</span>
<span class="comment">// const Cond_lim&amp; la_cl = zone_Cl_VEF.les_conditions_limites(n_bord);</span>
<span class="comment">// const Front_VF&amp; le_bord = ref_cast(Front_VF,la_cl.frontiere_dis());</span>
<span class="comment">// num1 = 0;</span>
<span class="comment">// num2=le_bord.nb_faces();//pour ne parcourir que les faces reelles</span>

<span class="comment">// if (sub_type(Periodique,la_cl.valeur()))</span>
<span class="comment">// {</span>
<span class="comment">// const Periodique&amp; la_cl_perio = ref_cast(Periodique,la_cl.valeur());</span>

<span class="comment">// //Pour le limiteur</span>
<span class="comment">// ArrOfDouble Pj_plus(nb_comp),Pj_moins(nb_comp);</span>
<span class="comment">// ArrOfDouble Qj_plus(nb_comp),Qj_moins(nb_comp);</span>
<span class="comment">// Pj_plus=0., Pj_moins=0.;</span>
<span class="comment">// Qj_plus=0., Qj_moins=0.;</span>

<span class="comment">// for (ind_face=num1; ind_face&lt;num2; ind_face++)</span>
<span class="comment">// {</span>
<span class="comment">// facei=le_bord.num_face(ind_face);</span>
<span class="comment">// ind_faceiAss=la_cl_perio.face_associee(ind_face);</span>
<span class="comment">// faceiAss=le_bord.num_face(ind_faceiAss);</span>

<span class="comment">// //Pour ne parcourir qu&#39;une seule fois les faces perio</span>
<span class="comment">// if (facei&lt;faceiAss)</span>
<span class="comment">// for (elem_loc=0;elem_loc&lt;2;elem_loc++)</span>
<span class="comment">// {</span>
<span class="comment">// elem=face_voisins(facei,elem_loc);</span>
<span class="comment">// assert(elem!=-1);</span>

<span class="comment">// //Calcul du numero local de la face dans &quot;elem&quot;</span>
<span class="comment">// facei_loc=num_fac_loc(facei,elem_loc);</span>
<span class="comment">// if (facei_loc!=-1)</span>
<span class="comment">// faceToComplete=faceiAss;</span>
<span class="comment">// else</span>
<span class="comment">// {</span>
<span class="comment">// faceToComplete=facei;</span>
<span class="comment">// facei_loc=num_fac_loc(faceiAss,elem_loc);</span>
<span class="comment">// assert(facei_loc!=-1);</span>
<span class="comment">// }</span>

<span class="comment">// //Calcul du coefficient a rajouter dans la matrice</span>
<span class="comment">// P_plus=0., P_moins=0.;</span>
<span class="comment">// Q_plus=0., Q_moins=0.;</span>
<span class="comment">// calculer_senseur(Kij,transporteV,nb_comp,faceToComplete,elem_faces,face_voisins,num_fac_loc,P_plus,P_moins,Q_plus,Q_moins);</span>

<span class="comment">// for (facej_loc=0; facej_loc&lt;nb_faces_elem; facej_loc++)</span>
<span class="comment">// if (facej_loc!=facei_loc)</span>
<span class="comment">// {</span>
<span class="comment">// facej=elem_faces(elem,facej_loc);</span>

<span class="comment">// kij = Kij(elem,facei_loc,facej_loc);</span>
<span class="comment">// kji = Kij(elem,facej_loc,facei_loc);</span>
<span class="comment">// dij = Dij(elem,facei_loc,facej_loc,Kij);</span>
<span class="comment">// lij = kij+dij;</span>
<span class="comment">// lji = kji+dij;</span>
<span class="comment">// assert(lij&gt;=0);</span>
<span class="comment">// assert(lji&gt;=0);</span>

<span class="comment">// if (lij&lt;=lji) //faceToComplete est amont</span>
<span class="comment">// {</span>
<span class="comment">// face_amont=faceToComplete;</span>
<span class="comment">// face_aval=facej;</span>

<span class="comment">// //Si lij==lji, on passe deux foix dans la boucle</span>
<span class="comment">// //d&#39;ou la presence du coefficient 1/2</span>
<span class="comment">// coeff = 1.*(lij&lt;lji)+0.5*(lij==lji);</span>
<span class="comment">// assert(coeff==1. || coeff==0.5);</span>

<span class="comment">// for (dim=0; dim&lt;nb_comp; dim++)</span>
<span class="comment">// {</span>
<span class="comment">// ligne=face_amont*nb_comp+dim;</span>
<span class="comment">// colonne=face_aval*nb_comp+dim;</span>

<span class="comment">// delta=transporteV[ligne]-transporteV[colonne];</span>

<span class="comment">// //Limiteur de pente</span>
<span class="comment">// if (delta&gt;=0.) R=(P_plus(dim)==0.) ? 0. : Q_plus(dim)/P_plus(dim);</span>
<span class="comment">// else  R=(P_moins(dim)==0.) ? 0. : Q_moins(dim)/P_moins(dim);</span>

<span class="comment">// daij=minimum(limiteur(R)*dij,lji);</span>
<span class="comment">// assert(daij&gt;=0);</span>
<span class="comment">// assert(daij&lt;=lji);</span>
<span class="comment">// coeffij=alpha_tab(face_amont)*beta(face_amont)*daij;</span>

<span class="comment">// //Calcul de la matrice</span>
<span class="comment">// matrice(ligne,ligne)-=coeffij*coeff;</span>
<span class="comment">// matrice(ligne,colonne)+=coeffij*coeff;</span>
<span class="comment">// }</span>
<span class="comment">// }</span>
<span class="comment">// else  //faceToComplete est aval</span>
<span class="comment">// {</span>
<span class="comment">// face_aval=faceToComplete;</span>
<span class="comment">// face_amont=facej;</span>

<span class="comment">// coeff=1.;</span>

<span class="comment">// Pj_plus=0., Pj_moins=0.;</span>
<span class="comment">// Qj_plus=0., Qj_moins=0.;</span>
<span class="comment">// calculer_senseur(Kij,transporteV,nb_comp,facej,elem_faces,face_voisins,num_fac_loc,Pj_plus,Pj_moins,Qj_plus,Qj_moins);</span>

<span class="comment">// for (dim=0; dim&lt;nb_comp; dim++)</span>
<span class="comment">// {</span>
<span class="comment">// ligne=face_amont*nb_comp+dim;</span>
<span class="comment">// colonne=face_aval*nb_comp+dim;</span>

<span class="comment">// delta=transporteV[ligne]-transporteV[colonne];</span>

<span class="comment">// //Limiteur de pente</span>
<span class="comment">// if (delta&gt;=0.) R=(Pj_plus(dim)==0.) ? 0. : Qj_plus(dim)/Pj_plus(dim);</span>
<span class="comment">// else  R=(Pj_moins(dim)==0.) ? 0. : Qj_moins(dim)/Pj_moins(dim);</span>

<span class="comment">// daij=minimum(limiteur(R)*dij,lij);</span>
<span class="comment">// assert(daij&gt;=0);</span>
<span class="comment">// assert(daij&lt;=lij);</span>
<span class="comment">// coeffij=alpha_tab(face_aval)*beta(face_aval)*daij;</span>

<span class="comment">// //Calcul de la matrice</span>
<span class="comment">// matrice(colonne,colonne)-=coeffij*coeff;</span>
<span class="comment">// matrice(colonne,ligne)+=coeffij*coeff;</span>
<span class="comment">// }</span>
<span class="comment">// }</span>
<span class="comment">// }</span>
<span class="comment">// }</span>
<span class="comment">// }</span>
<span class="comment">// }</span>
<span class="comment">// }</span>
}
</pre></div>
</div>
</div>
<a class="anchor" id="a6410a4c4150029025579edfe38a37d75"></a><!-- doxytag: member="Op_Conv_Muscl_New_VEF_Face::ajouter_contribution_diffusion" ref="a6410a4c4150029025579edfe38a37d75" args="(const DoubleTab &amp;, const DoubleTab &amp;, Matrice_Morse &amp;) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Op_Conv_Muscl_New_VEF_Face::ajouter_contribution_diffusion </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>Kij</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>transporte</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;&#160;</td>
          <td class="paramname"><em>matrice</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8cpp_source.html#l02488">2488</a> of file <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8cpp_source.html">Op_Conv_Muscl_New_VEF_Face.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{
<span class="comment">// const Zone_VEF&amp; zone_VEF=la_zone_vef.valeur();</span>
<span class="comment">// const Zone_Cl_VEF&amp; zone_Cl_VEF = la_zcl_vef.valeur();</span>

<span class="comment">// const IntTab&amp; elem_faces=zone_VEF.elem_faces();</span>
<span class="comment">// const IntTab&amp; face_voisins = zone_VEF.face_voisins();</span>

<span class="comment">// const int nb_elem_tot=zone_VEF.nb_elem_tot();</span>
<span class="comment">// const int nb_faces_elem=elem_faces.dimension(1);</span>
<span class="comment">// const int nb_bord=zone_Cl_VEF.nb_cond_lim();</span>

<span class="comment">// int nb_comp=1;</span>
<span class="comment">// if (transporte.nb_dim()!=1) nb_comp=transporte.dimension(1);</span>

<span class="comment">// int elem=0;</span>
<span class="comment">// int facei=0,facei_loc=0;</span>
<span class="comment">// int facej=0,facej_loc=0;</span>
<span class="comment">// int ligne=0,colonne=0;</span>
<span class="comment">// int dim=0;</span>
<span class="comment">// int ind_face=0;</span>
<span class="comment">// int num1=0,num2=0;</span>
<span class="comment">// int faceToComplete=0;</span>
<span class="comment">// int elem_loc=0;</span>

<span class="comment">// double dij=0.;</span>
<span class="comment">// double coeffij=0.,coeffji=0.;</span>

<span class="comment">// for (elem=0; elem&lt;nb_elem_tot; elem++)</span>
<span class="comment">// for (facei_loc=0; facei_loc&lt;nb_faces_elem; facei_loc++)</span>
<span class="comment">// {</span>
<span class="comment">// facei=elem_faces(elem,facei_loc);</span>

<span class="comment">// for (facej_loc=facei_loc+1; facej_loc&lt;nb_faces_elem; facej_loc++)</span>
<span class="comment">// {</span>
<span class="comment">// facej=elem_faces(elem,facej_loc);</span>
<span class="comment">// assert(facej!=facei);</span>

<span class="comment">// dij=Dij(elem,facei_loc,facej_loc,Kij);</span>
<span class="comment">// assert(dij&gt;=0);</span>

<span class="comment">// coeffij=alpha_tab(facei)*dij;</span>
<span class="comment">// coeffji=alpha_tab(facej)*dij;</span>

<span class="comment">// for (dim=0; dim&lt;nb_comp; dim++)</span>
<span class="comment">// {</span>
<span class="comment">// ligne=facei*nb_comp+dim;</span>
<span class="comment">// colonne=facej*nb_comp+dim;</span>

<span class="comment">// //ATTENTION AU SIGNE : ici on code +div(uT)</span>
<span class="comment">// //REMARQUE : on utilise la symetrie de l&#39;operateur</span>
<span class="comment">// matrice(ligne,ligne)+=coeffij;</span>
<span class="comment">// matrice(ligne,colonne)-=coeffij;</span>
<span class="comment">// matrice(colonne,colonne)+=coeffji;</span>
<span class="comment">// matrice(colonne,ligne)-=coeffji;</span>
<span class="comment">// }</span>
<span class="comment">// }</span>
<span class="comment">// }</span>

<span class="comment">// //</span>
<span class="comment">// //Pour la periodicite</span>
<span class="comment">// //</span>
<span class="comment">// const IntTab&amp; num_fac_loc = zone_VEF.get_num_fac_loc();</span>
<span class="comment">// for (int n_bord=0; n_bord&lt;nb_bord; n_bord++)</span>
<span class="comment">// {</span>
<span class="comment">// const Cond_lim&amp; la_cl = zone_Cl_VEF.les_conditions_limites(n_bord);</span>
<span class="comment">// const Front_VF&amp; le_bord = ref_cast(Front_VF,la_cl.frontiere_dis());</span>
<span class="comment">// num1 = 0;</span>
<span class="comment">// num2=le_bord.nb_faces_tot();//et surtout pas nb_faces() sinon on oublie certains coefficiens</span>

<span class="comment">// if (sub_type(Periodique,la_cl.valeur()))</span>
<span class="comment">// {</span>
<span class="comment">// const Periodique&amp; la_cl_perio = ref_cast(Periodique,la_cl.valeur());</span>
<span class="comment">// int faceiAss=0,ind_faceiAss=0;</span>

<span class="comment">// for (ind_face=num1; ind_face&lt;num2; ind_face++)</span>
<span class="comment">// {</span>
<span class="comment">// facei=le_bord.num_face(ind_face);</span>
<span class="comment">// ind_faceiAss=la_cl_perio.face_associee(ind_face);</span>
<span class="comment">// faceiAss=le_bord.num_face(ind_faceiAss);</span>

<span class="comment">// //Pour ne parcourir qu&#39;une seule fois les faces perio</span>
<span class="comment">// if (facei&lt;faceiAss)</span>
<span class="comment">// for (elem_loc=0;elem_loc&lt;2;elem_loc++)</span>
<span class="comment">// {</span>
<span class="comment">// elem=face_voisins(facei,elem_loc);</span>
<span class="comment">// assert(elem!=-1);</span>

<span class="comment">// //Calcul du numero local de la face dans &quot;elem&quot;</span>
<span class="comment">// facei_loc=num_fac_loc(facei,elem_loc);</span>
<span class="comment">// if (facei_loc!=-1)</span>
<span class="comment">// faceToComplete=faceiAss;</span>
<span class="comment">// else</span>
<span class="comment">// {</span>
<span class="comment">// faceToComplete=facei;</span>
<span class="comment">// facei_loc=num_fac_loc(faceiAss,elem_loc);</span>
<span class="comment">// assert(facei_loc!=-1);</span>
<span class="comment">// }</span>

<span class="comment">// //Calcul des coefficients de la matrice dus a &quot;elem&quot;</span>
<span class="comment">// for (facej_loc=0; facej_loc&lt;nb_faces_elem; facej_loc++)</span>
<span class="comment">// {</span>
<span class="comment">// facej=elem_faces(elem,facej_loc);</span>

<span class="comment">// if (facej_loc!=facei_loc)</span>
<span class="comment">// {</span>
<span class="comment">// dij=Dij(elem,facei_loc,facej_loc,Kij);</span>
<span class="comment">// assert(dij&gt;=0);</span>

<span class="comment">// coeffij=alpha_tab(faceToComplete)*dij;</span>
<span class="comment">// coeffji=alpha_tab(facej)*dij;</span>

<span class="comment">// for (dim=0; dim&lt;nb_comp; dim++)</span>
<span class="comment">// {</span>
<span class="comment">// ligne=faceToComplete*nb_comp+dim;</span>
<span class="comment">// colonne=facej*nb_comp+dim;</span>

<span class="comment">// //ATTENTION AU SIGNE : ici on code +div(uT)</span>
<span class="comment">// matrice(ligne,ligne)+=coeffij;</span>
<span class="comment">// matrice(ligne,colonne)-=coeffij;</span>
<span class="comment">// }</span>
<span class="comment">// }</span>
<span class="comment">// }</span>
<span class="comment">// }</span>
<span class="comment">// }</span>
<span class="comment">// }</span>
<span class="comment">// }</span>
}
</pre></div>
</div>
</div>
<a class="anchor" id="af94ae9e4b02bc730600d17589ecb74f0"></a><!-- doxytag: member="Op_Conv_Muscl_New_VEF_Face::ajouter_contribution_operateur_centre" ref="af94ae9e4b02bc730600d17589ecb74f0" args="(const DoubleTab &amp;, const DoubleTab &amp;, Matrice_Morse &amp;) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Op_Conv_Muscl_New_VEF_Face::ajouter_contribution_operateur_centre </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>Kij</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>transporte</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;&#160;</td>
          <td class="paramname"><em>matrice</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8cpp_source.html#l02366">2366</a> of file <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8cpp_source.html">Op_Conv_Muscl_New_VEF_Face.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{
<span class="comment">// const Zone_VEF&amp; zone_VEF=la_zone_vef.valeur();</span>
<span class="comment">// const Zone_Cl_VEF&amp; zone_Cl_VEF = la_zcl_vef.valeur();</span>

<span class="comment">// const IntTab&amp; elem_faces=zone_VEF.elem_faces();</span>
<span class="comment">// const IntTab&amp; face_voisins = zone_VEF.face_voisins();</span>

<span class="comment">// const int nb_elem_tot=zone_VEF.nb_elem_tot();</span>
<span class="comment">// const int nb_faces_elem=elem_faces.dimension(1);</span>
<span class="comment">// const int nb_bord=zone_Cl_VEF.nb_cond_lim();</span>

<span class="comment">// int nb_comp=1;</span>
<span class="comment">// if (transporte.nb_dim()!=1) nb_comp=transporte.dimension(1);</span>

<span class="comment">// int elem=0;</span>
<span class="comment">// int facei=0,facei_loc=0;</span>
<span class="comment">// int facej=0,facej_loc=0;</span>
<span class="comment">// int ligne=0,colonne=0;</span>
<span class="comment">// int dim=0;</span>
<span class="comment">// int ind_face=0;</span>
<span class="comment">// int num1=0,num2=0;</span>
<span class="comment">// int faceToComplete=0;</span>
<span class="comment">// int elem_loc=0;</span>

<span class="comment">// double kij=0.,kji=0.;</span>

<span class="comment">// for (elem=0; elem&lt;nb_elem_tot; elem++)</span>
<span class="comment">// for (facei_loc=0; facei_loc&lt;nb_faces_elem; facei_loc++)</span>
<span class="comment">// {</span>
<span class="comment">// facei=elem_faces(elem,facei_loc);</span>

<span class="comment">// for (facej_loc=facei_loc+1; facej_loc&lt;nb_faces_elem; facej_loc++)</span>
<span class="comment">// {</span>
<span class="comment">// facej=elem_faces(elem,facej_loc);</span>
<span class="comment">// assert(facej!=facei);</span>

<span class="comment">// kij=Kij(elem,facei_loc,facej_loc);</span>
<span class="comment">// kji=Kij(elem,facej_loc,facei_loc);</span>

<span class="comment">// for (dim=0; dim&lt;nb_comp; dim++)</span>
<span class="comment">// {</span>
<span class="comment">// ligne=facei*nb_comp+dim;</span>
<span class="comment">// colonne=facej*nb_comp+dim;</span>

<span class="comment">// //ATTENTION AU SIGNE : ici on code +div(uT)</span>
<span class="comment">// matrice(ligne,ligne)+=kij;</span>
<span class="comment">// matrice(ligne,colonne)-=kij;</span>
<span class="comment">// matrice(colonne,colonne)+=kji;</span>
<span class="comment">// matrice(colonne,ligne)-=kji;</span>
<span class="comment">// }</span>
<span class="comment">// }</span>
<span class="comment">// }</span>

<span class="comment">// //</span>
<span class="comment">// //Pour la periodicite</span>
<span class="comment">// //</span>
<span class="comment">// const IntTab&amp; num_fac_loc = zone_VEF.get_num_fac_loc();</span>
<span class="comment">// for (int n_bord=0; n_bord&lt;nb_bord; n_bord++)</span>
<span class="comment">// {</span>
<span class="comment">// const Cond_lim&amp; la_cl = zone_Cl_VEF.les_conditions_limites(n_bord);</span>
<span class="comment">// const Front_VF&amp; le_bord = ref_cast(Front_VF,la_cl.frontiere_dis());</span>
<span class="comment">// num1 = 0;</span>
<span class="comment">// num2=le_bord.nb_faces_tot();//et surtout pas nb_faces sinon on oublie certains coefficients</span>

<span class="comment">// if (sub_type(Periodique,la_cl.valeur()))</span>
<span class="comment">// {</span>
<span class="comment">// const Periodique&amp; la_cl_perio = ref_cast(Periodique,la_cl.valeur());</span>
<span class="comment">// int faceiAss=0,ind_faceiAss=0;</span>

<span class="comment">// for (ind_face=num1; ind_face&lt;num2; ind_face++)</span>
<span class="comment">// {</span>
<span class="comment">// ind_faceiAss=la_cl_perio.face_associee(ind_face);</span>

<span class="comment">// facei=le_bord.num_face(ind_face);</span>
<span class="comment">// faceiAss=le_bord.num_face(ind_faceiAss);</span>

<span class="comment">// //Pour ne parcourir qu&#39;une seule fois les faces perio</span>
<span class="comment">// if (facei&lt;faceiAss)</span>
<span class="comment">// for (elem_loc=0;elem_loc&lt;2;elem_loc++)</span>
<span class="comment">// {</span>
<span class="comment">// elem=face_voisins(facei,elem_loc);</span>
<span class="comment">// assert(elem!=-1);</span>

<span class="comment">// //Calcul du numero local de la face dans &quot;elem&quot;</span>
<span class="comment">// facei_loc=num_fac_loc(facei,elem_loc);</span>
<span class="comment">// if (facei_loc!=-1)</span>
<span class="comment">// faceToComplete=faceiAss;</span>
<span class="comment">// else</span>
<span class="comment">// {</span>
<span class="comment">// faceToComplete=facei;</span>
<span class="comment">// facei_loc=num_fac_loc(faceiAss,elem_loc);</span>
<span class="comment">// assert(facei_loc!=-1);</span>
<span class="comment">// }</span>

<span class="comment">// //Calcul des coefficients de la matrice dus a &quot;elem&quot;</span>
<span class="comment">// for (facej_loc=0; facej_loc&lt;nb_faces_elem; facej_loc++)</span>
<span class="comment">// {</span>
<span class="comment">// facej=elem_faces(elem,facej_loc);</span>

<span class="comment">// if (facej_loc!=facei_loc)</span>
<span class="comment">// {</span>
<span class="comment">// kij=Kij(elem,facei_loc,facej_loc);</span>
<span class="comment">// kji=Kij(elem,facej_loc,facei_loc);</span>

<span class="comment">// for (dim=0; dim&lt;nb_comp; dim++)</span>
<span class="comment">// {</span>
<span class="comment">// ligne=faceToComplete*nb_comp+dim;</span>
<span class="comment">// colonne=facej*nb_comp+dim;</span>

<span class="comment">// //ATTENTION AU SIGNE : ici on code +div(uT)</span>
<span class="comment">// matrice(ligne,ligne)+=kij;</span>
<span class="comment">// matrice(ligne,colonne)-=kij;</span>
<span class="comment">// }</span>
<span class="comment">// }</span>
<span class="comment">// }</span>
<span class="comment">// }</span>
<span class="comment">// }</span>
<span class="comment">// }</span>
<span class="comment">// }</span>
}
</pre></div>
</div>
</div>
<a class="anchor" id="a026e368e5d3d1af6bbb0f1be6d802fac"></a><!-- doxytag: member="Op_Conv_Muscl_New_VEF_Face::ajouter_contribution_partie_compressible" ref="a026e368e5d3d1af6bbb0f1be6d802fac" args="(const DoubleTab &amp;, const DoubleTab &amp;, Matrice_Morse &amp;) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Op_Conv_Muscl_New_VEF_Face::ajouter_contribution_partie_compressible </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>transporte</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>vitesse_2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;&#160;</td>
          <td class="paramname"><em>matrice</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8cpp_source.html#l02624">2624</a> of file <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8cpp_source.html">Op_Conv_Muscl_New_VEF_Face.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{
<span class="comment">// const Zone_VEF&amp; zone_VEF=la_zone_vef.valeur();</span>
<span class="comment">// const Zone_Cl_VEF&amp; zone_Cl_VEF = la_zcl_vef.valeur();</span>

<span class="comment">// const IntTab&amp; elem_faces=zone_VEF.elem_faces();</span>
<span class="comment">// const IntTab&amp; face_voisins = zone_VEF.face_voisins();</span>

<span class="comment">// const DoubleTab&amp; face_normales=zone_VEF.face_normales();</span>

<span class="comment">// const int nb_elem_tot=zone_VEF.nb_elem_tot();</span>
<span class="comment">// const int nb_faces_elem=elem_faces.dimension(1);</span>
<span class="comment">// const int nb_bord=zone_Cl_VEF.nb_cond_lim();</span>

<span class="comment">// //Pour tenir compte de la porosite</span>
<span class="comment">// const int marq = phi_u_transportant(equation());</span>

<span class="comment">// const DoubleVect&amp; porosite_elem = zone_VEF.porosite_elem();</span>
<span class="comment">// const DoubleVect&amp; porosite_face = zone_VEF.porosite_face();</span>

<span class="comment">// DoubleTab vitesse(vitesse_.valeur().valeurs());</span>
<span class="comment">// for (int i=0; i&lt;vitesse.dimension(0); i++)</span>
<span class="comment">// for (int j=0; j&lt;vitesse.dimension(1); j++)</span>
<span class="comment">// vitesse(i,j)*=porosite_face(i);</span>

<span class="comment">// int nb_comp=1;</span>
<span class="comment">// if (transporte.nb_dim()!=1) nb_comp=transporte.dimension(1);</span>

<span class="comment">// int elem=0,type_elem=0;</span>
<span class="comment">// int facei=0,facei_loc=0;</span>
<span class="comment">// int faceiAss=0,ind_faceiAss=0;</span>
<span class="comment">// int ligne=0;</span>
<span class="comment">// int dim=0;</span>
<span class="comment">// int ind_face=0;</span>
<span class="comment">// int num1=0,num2=0;</span>
<span class="comment">// int faceToComplete=0;</span>
<span class="comment">// int elem_loc=0;</span>
<span class="comment">// int n_bord=0;</span>

<span class="comment">// double coeff=0.;</span>
<span class="comment">// double signe=0.;</span>
<span class="comment">// double div=0.;</span>

<span class="comment">// double (*formule)(int);</span>
<span class="comment">// if (!volumes_etendus_)</span>
<span class="comment">// if (dimension==2) formule=&amp;formule_Id_2D;</span>
<span class="comment">// else formule=&amp;formule_Id_3D;</span>
<span class="comment">// else</span>
<span class="comment">// if (dimension==2) formule=&amp;formule_2D;</span>
<span class="comment">// else formule=&amp;formule_3D;</span>

<span class="comment">// for (elem=0; elem&lt;nb_elem_tot; elem++)</span>
<span class="comment">// {</span>
<span class="comment">// //Type de l&#39;element : le nombre de faces de Dirichlet</span>
<span class="comment">// //qu&#39;il contient</span>
<span class="comment">// type_elem=elem_nb_faces_dirichlet_(elem);</span>
<span class="comment">// coeff=formule(type_elem);</span>

<span class="comment">// //Calcul de la divergence par element</span>
<span class="comment">// div=0.;</span>
<span class="comment">// for (facei_loc=0; facei_loc&lt;nb_faces_elem; facei_loc++)</span>
<span class="comment">// {</span>
<span class="comment">// facei=elem_faces(elem,facei_loc);</span>
<span class="comment">// signe=(face_voisins(facei,0)==elem)? 1.:-1.;</span>

<span class="comment">// for (dim=0; dim&lt;dimension; dim++)</span>
<span class="comment">// div+=signe*face_normales(facei,dim)*vitesse(facei,dim);</span>
<span class="comment">// }</span>
<span class="comment">// div*=coeff;</span>
<span class="comment">// if (!marq) div/=porosite_elem(elem);</span>

<span class="comment">// //Calcul de la partie compressible</span>
<span class="comment">// for (facei_loc=0; facei_loc&lt;nb_faces_elem; facei_loc++)</span>
<span class="comment">// {</span>
<span class="comment">// facei=elem_faces(elem,facei_loc);</span>

<span class="comment">// for (dim=0; dim&lt;nb_comp; dim++)</span>
<span class="comment">// {</span>
<span class="comment">// ligne=facei*nb_comp+dim;</span>
<span class="comment">// matrice(ligne,ligne)+=div;</span>
<span class="comment">// }</span>
<span class="comment">// }</span>
<span class="comment">// }</span>

<span class="comment">// //</span>
<span class="comment">// //Pour la periodicite</span>
<span class="comment">// //</span>
<span class="comment">// const IntTab&amp; num_fac_loc = zone_VEF.get_num_fac_loc();</span>
<span class="comment">// for (n_bord=0; n_bord&lt;nb_bord; n_bord++)</span>
<span class="comment">// {</span>
<span class="comment">// const Cond_lim&amp; la_cl = zone_Cl_VEF.les_conditions_limites(n_bord);</span>
<span class="comment">// const Front_VF&amp; le_bord = ref_cast(Front_VF,la_cl.frontiere_dis());</span>
<span class="comment">// num1 = 0;</span>
<span class="comment">// num2=le_bord.nb_faces();//pour ne parcourir que les faces reelles</span>

<span class="comment">// if (sub_type(Periodique,la_cl.valeur()))</span>
<span class="comment">// {</span>
<span class="comment">// const Periodique&amp; la_cl_perio = ref_cast(Periodique,la_cl.valeur());</span>

<span class="comment">// for (ind_face=num1; ind_face&lt;num2; ind_face++)</span>
<span class="comment">// {</span>
<span class="comment">// facei=le_bord.num_face(ind_face);</span>
<span class="comment">// ind_faceiAss=la_cl_perio.face_associee(ind_face);</span>
<span class="comment">// faceiAss=le_bord.num_face(ind_faceiAss);</span>

<span class="comment">// //Pour ne parcourir qu&#39;une seule fois les faces perio</span>
<span class="comment">// if (facei&lt;faceiAss)</span>
<span class="comment">// for (elem_loc=0;elem_loc&lt;2;elem_loc++)</span>
<span class="comment">// {</span>
<span class="comment">// elem=face_voisins(facei,elem_loc);</span>
<span class="comment">// assert(elem!=-1);</span>

<span class="comment">// //Calcul du numero local de la face dans &quot;elem&quot;</span>
<span class="comment">// facei_loc=num_fac_loc(facei,elem_loc);</span>
<span class="comment">// if (facei_loc!=-1)</span>
<span class="comment">// faceToComplete=faceiAss;</span>
<span class="comment">// else</span>
<span class="comment">// {</span>
<span class="comment">// faceToComplete=facei;</span>
<span class="comment">// facei_loc=num_fac_loc(faceiAss,elem_loc);</span>
<span class="comment">// assert(facei_loc!=-1);</span>
<span class="comment">// }</span>

<span class="comment">// //Type de l&#39;element : le nombre de faces de Dirichlet</span>
<span class="comment">// //qu&#39;il contient</span>
<span class="comment">// type_elem=elem_nb_faces_dirichlet_(elem);</span>
<span class="comment">// coeff=formule(type_elem);</span>

<span class="comment">// //Calcul de la divergence par element</span>
<span class="comment">// div=0.;</span>
<span class="comment">// for (facei_loc=0; facei_loc&lt;nb_faces_elem; facei_loc++)</span>
<span class="comment">// {</span>
<span class="comment">// facei=elem_faces(elem,facei_loc);</span>
<span class="comment">// signe=(face_voisins(facei,0)==elem)? 1.:-1.;</span>

<span class="comment">// for (dim=0; dim&lt;dimension; dim++)</span>
<span class="comment">// div+=signe*face_normales(facei,dim)*vitesse(facei,dim);</span>
<span class="comment">// }</span>
<span class="comment">// div*=coeff;</span>
<span class="comment">// if (!marq) div/=porosite_elem(elem);</span>

<span class="comment">// //Calcul de la partie compressible</span>
<span class="comment">// for (dim=0; dim&lt;nb_comp; dim++)</span>
<span class="comment">// {</span>
<span class="comment">// ligne=faceToComplete*nb_comp+dim;</span>
<span class="comment">// matrice(ligne,ligne)+=div;</span>
<span class="comment">// }</span>
<span class="comment">// }</span>
<span class="comment">// }</span>
<span class="comment">// }</span>
<span class="comment">// }</span>
}
</pre></div>
</div>
</div>
<a class="anchor" id="a7a5c2445abefb22846ad5eec13fde90d"></a><!-- doxytag: member="Op_Conv_Muscl_New_VEF_Face::ajouter_diffusion" ref="a7a5c2445abefb22846ad5eec13fde90d" args="(const DoubleTab &amp;, const DoubleTab &amp;, const DoubleTab &amp;, DoubleTab &amp;) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDoubleTab.html">DoubleTab</a> &amp; Op_Conv_Muscl_New_VEF_Face::ajouter_diffusion </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>Kij</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>Fij</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>transporte</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>resu</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8cpp_source.html#l01603">1603</a> of file <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8cpp_source.html">Op_Conv_Muscl_New_VEF_Face.cpp</a>.</p>

<p>References <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8h_source.html#l00119">alpha_</a>, <a class="el" href="DoubleTab_8h_source.html#l00243">DoubleTab::dimension()</a>, <a class="el" href="Zone__VF_8h_source.html#l00574">Zone_VF::elem_faces()</a>, <a class="el" href="Elem__VEF__base_8h_source.html#l00047">Elem_VEF_base::KEL()</a>, <a class="el" href="Op__Conv__VEF__base_8h_source.html#l00092">Op_Conv_VEF_base::la_zone_vef</a>, <a class="el" href="DoubleTab_8h_source.html#l00264">DoubleTab::nb_dim()</a>, <a class="el" href="Zone__dis__base_8h_source.html#l00144">Zone_dis_base::nb_elem_tot()</a>, <a class="el" href="Elem__VEF_8h_source.html#l00083">Elem_VEF::nb_facette()</a>, <a class="el" href="Cast_8h_source.html#l00059">ref_cast</a>, <a class="el" href="Zone__VEF_8h_source.html#l00138">Zone_VEF::type_elem()</a>, <a class="el" href="Elem__VEF_8h_source.html#l00041">Deriv_Elem_VEF_base::valeur()</a>, and <a class="el" href="Ref__Zone__VEF_8h_source.html#l00028">Ref_Zone_VEF::valeur()</a>.</p>

<p>Referenced by <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8cpp_source.html#l01029">ajouter()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">const</span> <a class="code" href="classZone__VEF.html" title="class Zone_VEF Classe instanciable qui derive de Zone_VF. Cette classe contient les informations geom...">Zone_VEF</a>&amp; zone_VEF=<a class="code" href="classOp__Conv__VEF__base.html#a6c29a488a6805ba4a9f2f059cdba77ae">la_zone_vef</a>.<a class="code" href="classRef__Zone__VEF.html#aafd9a5ee1a76f290c9c6b5447b0c8d30">valeur</a>();

  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; elem_faces=zone_VEF.<a class="code" href="classZone__VF.html#a067e462dcd3ab92b0f6d945b19e4eb37" title="renvoie le numero de le ieme face de la maille num_elem la facon dont ces faces sont numerotees est l...">elem_faces</a>();
  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; KEL=zone_VEF.<a class="code" href="classZone__VEF.html#a46693c060b8096fb2595ca72192eea2a">type_elem</a>().<a class="code" href="classDeriv__Elem__VEF__base.html#a2886905d5071be902c77248b69ca0b7b">valeur</a>().<a class="code" href="classElem__VEF__base.html#ab129610ef702aa8c9c98dcb4c7551172">KEL</a>();

  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_elem_tot=zone_VEF.<a class="code" href="classZone__dis__base.html#a4d6aa445f152aa6dc54d66ea7a071147">nb_elem_tot</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> nfa7 = zone_VEF.<a class="code" href="classZone__VEF.html#a46693c060b8096fb2595ca72192eea2a">type_elem</a>().<a class="code" href="classElem__VEF.html#a4a34777c0083b38dd34c8a400d5b4e90">nb_facette</a>();

  <span class="keywordtype">int</span> nb_comp=1;
  <span class="keywordflow">if</span> (transporte.<a class="code" href="classDoubleTab.html#ae6dda48778e7107e1beb723beef1f75b" title="Returns the number of dimensions of the array (&gt;= 1)">nb_dim</a>()!=1) nb_comp=transporte.<a class="code" href="classDoubleTab.html#ac3805e2637a3b880ba2d3e650c69dac4" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(1);

  <span class="keywordtype">int</span> elem=0;
  <span class="keywordtype">int</span> facei=0,facei_loc=0;
  <span class="keywordtype">int</span> facej=0,facej_loc=0;
  <span class="keywordtype">int</span> ligne=0,colonne=0;
  <span class="keywordtype">int</span> dim=0;
  <span class="keywordtype">int</span> fa7=0;

<span class="comment">// double coeffij=0.,coeffji=0.;</span>
  <span class="keywordtype">double</span> fij=0.,fji=0.;
  <span class="keywordtype">double</span> psc=0.;

  <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; resuV=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classDoubleVect.html">DoubleVect</a>,resu);

<span class="comment">// Pour les faces internes</span>
  <span class="keywordflow">for</span> (elem=0; elem&lt;nb_elem_tot; elem++)
    <span class="keywordflow">for</span> (fa7=0; fa7&lt;nfa7; fa7++)
      {
        facei_loc=KEL(0,fa7);
        facej_loc=KEL(1,fa7);

        facei=elem_faces(elem,facei_loc);
        facej=elem_faces(elem,facej_loc);

        psc=Kij(elem,facei_loc,facej_loc);

        <span class="keywordflow">for</span> (dim=0; dim&lt;nb_comp; dim++)
          {
            fij=<a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#aba93a9d2fdc68f373410c6439c95074c">alpha_</a>*Fij(elem,facei_loc,facej_loc,dim);
            fji=<a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#aba93a9d2fdc68f373410c6439c95074c">alpha_</a>*Fij(elem,facej_loc,facei_loc,dim);

            ligne=facei*nb_comp+dim;
            colonne=facej*nb_comp+dim;

            <span class="keywordflow">if</span> (psc&gt;=0.)
              {
                resuV[ligne]-=fij;
                resuV[colonne]+=fij;
              }
            <span class="keywordflow">else</span>
              {
                resuV[ligne]+=fji;
                resuV[colonne]-=fji;
              }
          }
      }

<span class="comment">// Pour les faces de bord :</span>
<span class="comment">// ON N&#39;A RIEN a FAIRE</span>

<span class="comment">// Retour du resultat</span>
  <span class="keywordflow">return</span> resu;
}
</pre></div>
</div>
</div>
<a class="anchor" id="af0ae6f8bcbe698e8ddc0b0a83f67604c"></a><!-- doxytag: member="Op_Conv_Muscl_New_VEF_Face::ajouter_old" ref="af0ae6f8bcbe698e8ddc0b0a83f67604c" args="(const DoubleTab &amp;, DoubleTab &amp;, const DoubleTab &amp;vitesse) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Op_Conv_Muscl_New_VEF_Face::ajouter_old </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>transporte</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>resu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>vitesse</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8cpp_source.html#l02216">2216</a> of file <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8cpp_source.html">Op_Conv_Muscl_New_VEF_Face.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{
}
</pre></div>
</div>
</div>
<a class="anchor" id="a0cd4001abc6587f38b6e3f23d251bc68"></a><!-- doxytag: member="Op_Conv_Muscl_New_VEF_Face::ajouter_operateur_centre" ref="a0cd4001abc6587f38b6e3f23d251bc68" args="(const DoubleTab &amp;, const DoubleTab &amp;, const DoubleTab &amp;, DoubleTab &amp;) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDoubleTab.html">DoubleTab</a> &amp; Op_Conv_Muscl_New_VEF_Face::ajouter_operateur_centre </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>Kij</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>Fij</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>transporte</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>resu</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8cpp_source.html#l01468">1468</a> of file <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8cpp_source.html">Op_Conv_Muscl_New_VEF_Face.cpp</a>.</p>

<p>References <a class="el" href="DoubleTab_8h_source.html#l00243">DoubleTab::dimension()</a>, <a class="el" href="Zone__VF_8h_source.html#l00574">Zone_VF::elem_faces()</a>, <a class="el" href="Zone__VF_8h_source.html#l00458">Zone_VF::face_voisins()</a>, <a class="el" href="Cond__lim_8h_source.html#l00130">Cond_lim::frontiere_dis()</a>, <a class="el" href="Zone__VF_8h_source.html#l00176">Zone_VF::get_num_fac_loc()</a>, <a class="el" href="Elem__VEF__base_8h_source.html#l00047">Elem_VEF_base::KEL()</a>, <a class="el" href="Op__Conv__VEF__base_8h_source.html#l00093">Op_Conv_VEF_base::la_zcl_vef</a>, <a class="el" href="Op__Conv__VEF__base_8h_source.html#l00092">Op_Conv_VEF_base::la_zone_vef</a>, <a class="el" href="Zone__Cl__dis__base_8cpp_source.html#l00522">Zone_Cl_dis_base::les_conditions_limites()</a>, <a class="el" href="Zone__Cl__dis__base_8cpp_source.html#l00603">Zone_Cl_dis_base::nb_cond_lim()</a>, <a class="el" href="DoubleTab_8h_source.html#l00264">DoubleTab::nb_dim()</a>, <a class="el" href="Zone__dis__base_8h_source.html#l00144">Zone_dis_base::nb_elem_tot()</a>, <a class="el" href="Front__VF_8h_source.html#l00061">Front_VF::nb_faces()</a>, <a class="el" href="Zone__VF_8h_source.html#l00519">Zone_VF::nb_faces()</a>, <a class="el" href="Elem__VEF_8h_source.html#l00083">Elem_VEF::nb_facette()</a>, <a class="el" href="Front__VF_8h_source.html#l00076">Front_VF::num_face()</a>, <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8h_source.html#l00124">old_centered_</a>, <a class="el" href="Zone__VF_8h_source.html#l00512">Zone_VF::premiere_face_int()</a>, <a class="el" href="Cast_8h_source.html#l00059">ref_cast</a>, <a class="el" href="Cast_8h_source.html#l00054">sub_type</a>, <a class="el" href="Zone__VEF_8h_source.html#l00138">Zone_VEF::type_elem()</a>, <a class="el" href="Neumann__sortie__libre_8cpp_source.html#l00138">Neumann_sortie_libre::val_ext()</a>, <a class="el" href="Cond__lim_8h_source.html#l00031">Deriv_Cond_lim_base::valeur()</a>, <a class="el" href="Ref__Zone__Cl__VEF_8h_source.html#l00028">Ref_Zone_Cl_VEF::valeur()</a>, <a class="el" href="Elem__VEF_8h_source.html#l00041">Deriv_Elem_VEF_base::valeur()</a>, and <a class="el" href="Ref__Zone__VEF_8h_source.html#l00028">Ref_Zone_VEF::valeur()</a>.</p>

<p>Referenced by <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8cpp_source.html#l01029">ajouter()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">const</span> <a class="code" href="classZone__VEF.html" title="class Zone_VEF Classe instanciable qui derive de Zone_VF. Cette classe contient les informations geom...">Zone_VEF</a>&amp; zone_VEF=<a class="code" href="classOp__Conv__VEF__base.html#a6c29a488a6805ba4a9f2f059cdba77ae">la_zone_vef</a>.<a class="code" href="classRef__Zone__VEF.html#aafd9a5ee1a76f290c9c6b5447b0c8d30">valeur</a>();

  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; elem_faces=zone_VEF.<a class="code" href="classZone__VF.html#a067e462dcd3ab92b0f6d945b19e4eb37" title="renvoie le numero de le ieme face de la maille num_elem la facon dont ces faces sont numerotees est l...">elem_faces</a>();
  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; KEL=zone_VEF.<a class="code" href="classZone__VEF.html#a46693c060b8096fb2595ca72192eea2a">type_elem</a>().<a class="code" href="classDeriv__Elem__VEF__base.html#a2886905d5071be902c77248b69ca0b7b">valeur</a>().<a class="code" href="classElem__VEF__base.html#ab129610ef702aa8c9c98dcb4c7551172">KEL</a>();
  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; face_voisins=zone_VEF.<a class="code" href="classZone__VF.html#a49d4322f5585a8fa95748ca785b70702" title="renvoie l&#39;element voisin de numface dans la direction i. i=0 : dans le sens oppose de l&#39;axe orthogona...">face_voisins</a>();
  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; num_fac_loc = zone_VEF.<a class="code" href="classZone__VF.html#a95113b10f16f37600ba81d3fb41102b2">get_num_fac_loc</a>();

  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_elem_tot=zone_VEF.<a class="code" href="classZone__dis__base.html#a4d6aa445f152aa6dc54d66ea7a071147">nb_elem_tot</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> nfa7 = zone_VEF.<a class="code" href="classZone__VEF.html#a46693c060b8096fb2595ca72192eea2a">type_elem</a>().<a class="code" href="classElem__VEF.html#a4a34777c0083b38dd34c8a400d5b4e90">nb_facette</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> premiere_face_int = zone_VEF.<a class="code" href="classZone__VF.html#a12869806fa4834aca8f2964e16509dfd" title="une face est interne ssi elle separe deux elements. renvoie le numero de la premiere face interne...">premiere_face_int</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_faces = zone_VEF.<a class="code" href="classZone__VF.html#aede27992d9f2eedd52c24d4a80ff7ffb" title="renvoie le nombre global de faces.">nb_faces</a>();

  <span class="keywordtype">int</span> nb_comp=1;
  <span class="keywordflow">if</span> (transporte.<a class="code" href="classDoubleTab.html#ae6dda48778e7107e1beb723beef1f75b" title="Returns the number of dimensions of the array (&gt;= 1)">nb_dim</a>()!=1) nb_comp=transporte.<a class="code" href="classDoubleTab.html#ac3805e2637a3b880ba2d3e650c69dac4" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(1);

  <span class="keywordtype">int</span> elem=0;
  <span class="keywordtype">int</span> facei=0,facei_loc=0;
  <span class="keywordtype">int</span> facej=0,facej_loc=0;
  <span class="keywordtype">int</span> ligne=0,colonne=0;
  <span class="keywordtype">int</span> dim=0;
  <span class="keywordtype">int</span> fa7=0;

  <span class="keywordtype">double</span> fij=0.;
  <span class="keywordtype">double</span> fji=0.;

  <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; transporteV = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classDoubleVect.html">DoubleVect</a>,transporte);
  <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; resuV=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classDoubleVect.html">DoubleVect</a>,resu);

<span class="comment">// Faces internes</span>
  <span class="keywordflow">for</span> (elem=0; elem&lt;nb_elem_tot; elem++)
    <span class="keywordflow">for</span> (fa7=0; fa7&lt;nfa7; fa7++)
      {
        facei_loc=KEL(0,fa7);
        facej_loc=KEL(1,fa7);

        facei=elem_faces(elem,facei_loc);
        facej=elem_faces(elem,facej_loc);

        <span class="keywordflow">for</span> (dim=0; dim&lt;nb_comp; dim++)
          {
            fij=Fij(elem,facei_loc,facej_loc,dim);
            fji=Fij(elem,facej_loc,facei_loc,dim);

            ligne=facei*nb_comp+dim;
            colonne=facej*nb_comp+dim;

            resuV[ligne]+=fij;
            resuV[colonne]+=fji;
          }
      }

  <span class="keywordflow">if</span> (<a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#af27e616d4be292efae0dcd25ef29278c">old_centered_</a>)
    <span class="keywordflow">for</span> (facei=premiere_face_int; facei&lt;nb_faces; facei++)
      {
<span class="comment">// Premier voisin</span>
        elem=face_voisins(facei,0);
        facei_loc=num_fac_loc(facei,0);
        assert(elem_faces(elem,facei_loc)==facei);

        fij=Kij(elem,facei_loc,facei_loc);

<span class="comment">// Deuxieme voisin</span>
        elem=face_voisins(facei,1);
        facei_loc=num_fac_loc(facei,1);
        assert(elem_faces(elem,facei_loc)==facei);

        fij+=Kij(elem,facei_loc,facei_loc);

        <span class="keywordflow">for</span> (dim=0; dim&lt;nb_comp; dim++)
          {
            ligne=facei*nb_comp+dim;
            resuV[ligne]-=fij*transporteV[ligne];
          }
      }


<span class="comment">// Faces de bord</span>
  <span class="keyword">const</span> <a class="code" href="classZone__Cl__VEF.html">Zone_Cl_VEF</a>&amp; zone_Cl_VEF = <a class="code" href="classOp__Conv__VEF__base.html#a03f677ee7911706a4f85cd37e0ca4535">la_zcl_vef</a>.<a class="code" href="classRef__Zone__Cl__VEF.html#a0970d7253def65ad4f0c5ce1830fd243">valeur</a>();

  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_bord = zone_Cl_VEF.<a class="code" href="classZone__Cl__dis__base.html#aa6f1df56cfd6e2eae83cc991c7cc9b41" title="Renvoie le nombre de conditions aux limites.">nb_cond_lim</a>();

  <span class="keywordtype">int</span> n_bord=-1;
  <span class="keywordtype">int</span> num1=0;
  <span class="keywordtype">int</span> num2=0;
  <span class="keywordtype">int</span> ind_face=-1;

  <span class="keywordtype">double</span> psc=0.;

  <span class="keywordflow">for</span> (n_bord=0; n_bord&lt;nb_bord; n_bord++)
    {
      <span class="keyword">const</span> <a class="code" href="classCond__lim.html" title="classe Cond_lim Classe generique servant a representer n&#39;importe quelle classe derivee de la classe C...">Cond_lim</a>&amp; la_cl = zone_Cl_VEF.<a class="code" href="classZone__Cl__dis__base.html#af75e0ed7786863e4d333bfb29d67c323" title="Renvoie la i-ieme condition aux limites. (version const)">les_conditions_limites</a>(n_bord);
      <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp; le_bord = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>,la_cl.<a class="code" href="classCond__lim.html#a5b2d24809cee07727006a891d4ce8d22" title="Appel a l&#39;objet sous-jacent Renvoie la frontiere discretisee associee a la condition aux limites...">frontiere_dis</a>());
      num1=0;
      num2=le_bord.<a class="code" href="classFront__VF.html#a341e2fcb5117b96e745fd7078ba86bab" title="Nombre de faces reelles du bord.">nb_faces</a>();

      <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classNeumann__sortie__libre.html" title="classe Neumann_sortie_libre Cette classe represente une frontiere ouverte sans vitesse imposee Pour l...">Neumann_sortie_libre</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>()))
        {
          <span class="keyword">const</span> <a class="code" href="classNeumann__sortie__libre.html" title="classe Neumann_sortie_libre Cette classe represente une frontiere ouverte sans vitesse imposee Pour l...">Neumann_sortie_libre</a>&amp; la_sortie_libre = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classNeumann__sortie__libre.html" title="classe Neumann_sortie_libre Cette classe represente une frontiere ouverte sans vitesse imposee Pour l...">Neumann_sortie_libre</a>, la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>());

          <span class="keywordflow">for</span> (ind_face=num1; ind_face&lt;num2; ind_face++)
            {
              facei=le_bord.<a class="code" href="classFront__VF.html#a3402a19d7e54ed797d2b18e9a47ead1e" title="Renvoie le numero de face de la ieme face du bord.">num_face</a>(ind_face);
              facei_loc=num_fac_loc(facei,0);
              elem=face_voisins(facei,0);
              assert(elem_faces(elem,facei_loc)==facei);


              psc=Kij(elem,facei_loc,facei_loc);<span class="comment">//ATTENTION : SUPPOSE QU&#39;ON EST a DIVERGENCE NULLE</span>

              <span class="keywordflow">if</span> (psc&gt;=0.)
                {
<span class="comment">// On ne fait rien car on en a deja tenu compte dans l&#39;operateur centre</span>
                }
              <span class="keywordflow">else</span>
                <span class="keywordflow">for</span> (dim=0; dim&lt;nb_comp; dim++)
                  {
<span class="comment">// On modifie car on a tenu compte dans l&#39;operateur centre de psc*tansporteV[ligne]</span>
                    ligne=facei*nb_comp+dim;
                    resuV[ligne]+=psc*(la_sortie_libre.<a class="code" href="classNeumann__sortie__libre.html#a886f1804fa2a9028fc56a0778a72a75d" title="Renvoie la valeur de la i-eme composante du champ impose a l&#39;exterieur de la frontiere.">val_ext</a>(facei,dim)-transporteV[ligne]);
                  }

            }<span class="comment">//fin du for sur &quot;face_i&quot;</span>

        }<span class="comment">//fin du if sur &quot;Neumann&quot;</span>

    }<span class="comment">//fin du for sur &quot;n_bord&quot;</span>


<span class="comment">// Retour du resultat</span>
  <span class="keywordflow">return</span> resu;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a141336115c6ef5ebfb3b4bc9d2a0863a"></a><!-- doxytag: member="Op_Conv_Muscl_New_VEF_Face::ajouter_partie_compressible" ref="a141336115c6ef5ebfb3b4bc9d2a0863a" args="(const DoubleTab &amp;, DoubleTab &amp;, const DoubleTab &amp;vitesse) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDoubleTab.html">DoubleTab</a> &amp; Op_Conv_Muscl_New_VEF_Face::ajouter_partie_compressible </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>transporte</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>resu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>vitesse</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8cpp_source.html#l01233">1233</a> of file <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8cpp_source.html">Op_Conv_Muscl_New_VEF_Face.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{
<span class="comment">// const Zone_VEF&amp; zone_VEF=la_zone_vef.valeur();</span>

<span class="comment">// const IntTab&amp; elem_faces=zone_VEF.elem_faces();</span>
<span class="comment">// const IntTab&amp; face_voisins = zone_VEF.face_voisins();</span>

<span class="comment">// const DoubleTab&amp; face_normales=zone_VEF.face_normales();</span>

<span class="comment">// const int nb_elem_tot=zone_VEF.nb_elem_tot();</span>
<span class="comment">// const int nb_faces_elem=elem_faces.dimension(1);</span>

<span class="comment">// //Pour tenir compte de la porosite</span>
<span class="comment">// const int marq = phi_u_transportant(equation());</span>

<span class="comment">// const DoubleVect&amp; porosite_elem = zone_VEF.porosite_elem();</span>
<span class="comment">// const DoubleVect&amp; porosite_face = zone_VEF.porosite_face();</span>

<span class="comment">// DoubleTab vitesse(vitesse_.valeur().valeurs());</span>
<span class="comment">// for (int i=0; i&lt;vitesse.dimension(0); i++)</span>
<span class="comment">// for (int j=0; j&lt;vitesse.dimension(1); j++)</span>
<span class="comment">// vitesse(i,j)*=porosite_face(i);</span>

<span class="comment">// int nb_comp=1;</span>
<span class="comment">// if (transporte.nb_dim()!=1) nb_comp=transporte.dimension(1);</span>

<span class="comment">// int elem=0,type_elem=0;</span>
<span class="comment">// int facei=0,facei_loc=0;</span>
<span class="comment">// int ligne=0;</span>
<span class="comment">// int dim=0;</span>

<span class="comment">// double coeff=0.;</span>
<span class="comment">// double signe=0.;</span>
<span class="comment">// double div=0.;</span>

<span class="comment">// const DoubleVect&amp; transporteV=ref_cast(DoubleVect,transporte);</span>
<span class="comment">// DoubleVect&amp; resuV=ref_cast(DoubleVect,resu);</span>

<span class="comment">// double (*formule)(int);</span>
<span class="comment">// if (!volumes_etendus_)</span>
<span class="comment">// if (dimension==2) formule=&amp;formule_Id_2D;</span>
<span class="comment">// else formule=&amp;formule_Id_3D;</span>
<span class="comment">// else</span>
<span class="comment">// if (dimension==2) formule=&amp;formule_2D;</span>
<span class="comment">// else formule=&amp;formule_3D;</span>

<span class="comment">// for (elem=0; elem&lt;nb_elem_tot; elem++)</span>
<span class="comment">// {</span>
<span class="comment">// //Type de l&#39;element : le nombre de faces de Dirichlet</span>
<span class="comment">// //qu&#39;il contient</span>
<span class="comment">// type_elem=elem_nb_faces_dirichlet_(elem);</span>
<span class="comment">// coeff=formule(type_elem);</span>

<span class="comment">// //Calcul de la divergence par element</span>
<span class="comment">// div=0.;</span>
<span class="comment">// for (facei_loc=0; facei_loc&lt;nb_faces_elem; facei_loc++)</span>
<span class="comment">// {</span>
<span class="comment">// facei=elem_faces(elem,facei_loc);</span>
<span class="comment">// signe=(face_voisins(facei,0)==elem)? 1.:-1.;</span>

<span class="comment">// for (dim=0; dim&lt;dimension; dim++)</span>
<span class="comment">// div+=signe*face_normales(facei,dim)*vitesse(facei,dim);</span>
<span class="comment">// }</span>
<span class="comment">// div*=coeff;</span>
<span class="comment">// if (!marq) div/=porosite_elem(elem);</span>

<span class="comment">// //Calcul de la partie compressible</span>
<span class="comment">// for (facei_loc=0; facei_loc&lt;nb_faces_elem; facei_loc++)</span>
<span class="comment">// {</span>
<span class="comment">// facei=elem_faces(elem,facei_loc);</span>

<span class="comment">// for (dim=0; dim&lt;nb_comp; dim++)</span>
<span class="comment">// {</span>
<span class="comment">// ligne=facei*nb_comp+dim;</span>
<span class="comment">// resuV[ligne]-=div*transporteV[ligne];</span>
<span class="comment">// }</span>
<span class="comment">// }</span>
<span class="comment">// }</span>

  <span class="keywordflow">return</span> resu;
}
</pre></div>
</div>
</div>
<a class="anchor" id="afde9a8f6daffddcc35a097fd68674797"></a><!-- doxytag: member="Op_Conv_Muscl_New_VEF_Face::calculer_coefficients_operateur_centre" ref="afde9a8f6daffddcc35a097fd68674797" args="(DoubleTab &amp;, DoubleTab &amp;, DoubleTab &amp;, DoubleTab &amp;, const int &amp;, const DoubleTab &amp;vitesse) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Op_Conv_Muscl_New_VEF_Face::calculer_coefficients_operateur_centre </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>Kij</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>Cij</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>Sij</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>Sij2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>nb_comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>vitesse</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8cpp_source.html#l00314">314</a> of file <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8cpp_source.html">Op_Conv_Muscl_New_VEF_Face.cpp</a>.</p>

<p>References <a class="el" href="classElem__VEF__base.html#a02b712675ec9d8bbb6571ddbbec33417">Elem_VEF_base::calcul_vc()</a>, <a class="el" href="EntreeSortie_8h_source.html#l00032">Cerr</a>, <a class="el" href="DoubleTab_8h_source.html#l00243">DoubleTab::dimension()</a>, <a class="el" href="Objet__U_8h_source.html#l00079">Objet_U::dimension</a>, <a class="el" href="IntTab_8h_source.html#l00233">IntTab::dimension()</a>, <a class="el" href="Zone__VF_8h_source.html#l00574">Zone_VF::elem_faces()</a>, <a class="el" href="MorEqn_8h_source.html#l00082">MorEqn::equation()</a>, <a class="el" href="Process_8cpp_source.html#l00223">Process::exit()</a>, <a class="el" href="Zone__VEF_8h_source.html#l00152">Zone_VEF::facette_normales()</a>, <a class="el" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>, <a class="el" href="Process_8cpp_source.html#l00095">Process::je_suis_maitre()</a>, <a class="el" href="Elem__VEF__base_8h_source.html#l00047">Elem_VEF_base::KEL()</a>, <a class="el" href="Op__Conv__VEF__base_8h_source.html#l00093">Op_Conv_VEF_base::la_zcl_vef</a>, <a class="el" href="Op__Conv__VEF__base_8h_source.html#l00092">Op_Conv_VEF_base::la_zone_vef</a>, <a class="el" href="Zone__Cl__dis__base_8cpp_source.html#l00522">Zone_Cl_dis_base::les_conditions_limites()</a>, <a class="el" href="Zone__Cl__dis__base_8cpp_source.html#l00603">Zone_Cl_dis_base::nb_cond_lim()</a>, <a class="el" href="DoubleTab_8h_source.html#l00264">DoubleTab::nb_dim()</a>, <a class="el" href="Zone__dis__base_8h_source.html#l00144">Zone_dis_base::nb_elem_tot()</a>, <a class="el" href="Elem__VEF_8h_source.html#l00083">Elem_VEF::nb_facette()</a>, <a class="el" href="Zone_8h_source.html#l00445">Zone::nb_som_elem()</a>, <a class="el" href="Zone__Cl__VEF_8h_source.html#l00130">Zone_Cl_VEF::normales_facettes_Cl()</a>, <a class="el" href="Op__Conv__VEF__base_8cpp_source.html#l00053">Op_Conv_VEF_base::phi_u_transportant()</a>, <a class="el" href="Zone__VF_8h_source.html#l00315">Zone_VF::porosite_elem()</a>, <a class="el" href="Zone__VF_8h_source.html#l00285">Zone_VF::porosite_face()</a>, <a class="el" href="Objet__U_8cpp_source.html#l00132">Objet_U::que_suis_je()</a>, <a class="el" href="Zone__VEF_8h_source.html#l00165">Zone_VEF::rang_elem_non_std()</a>, <a class="el" href="Cast_8h_source.html#l00054">sub_type</a>, <a class="el" href="Zone__VEF_8h_source.html#l00138">Zone_VEF::type_elem()</a>, <a class="el" href="Zone__Cl__VEF_8h_source.html#l00167">Zone_Cl_VEF::type_elem_Cl()</a>, <a class="el" href="Cond__lim_8h_source.html#l00031">Deriv_Cond_lim_base::valeur()</a>, <a class="el" href="Elem__VEF_8h_source.html#l00041">Deriv_Elem_VEF_base::valeur()</a>, <a class="el" href="Ref__Zone__Cl__VEF_8h_source.html#l00028">Ref_Zone_Cl_VEF::valeur()</a>, <a class="el" href="Ref__Zone__VEF_8h_source.html#l00028">Ref_Zone_VEF::valeur()</a>, and <a class="el" href="Zone__dis__base_8h_source.html#l00106">Zone_dis_base::zone()</a>.</p>

<p>Referenced by <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8cpp_source.html#l01029">ajouter()</a>, and <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8cpp_source.html#l01107">calculer_dt_stab()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">const</span> <a class="code" href="classZone__VEF.html" title="class Zone_VEF Classe instanciable qui derive de Zone_VF. Cette classe contient les informations geom...">Zone_VEF</a>&amp; zone_VEF = <a class="code" href="classOp__Conv__VEF__base.html#a6c29a488a6805ba4a9f2f059cdba77ae">la_zone_vef</a>.<a class="code" href="classRef__Zone__VEF.html#aafd9a5ee1a76f290c9c6b5447b0c8d30">valeur</a>();
  <span class="keyword">const</span> <a class="code" href="classZone__Cl__VEF.html">Zone_Cl_VEF</a>&amp; zone_Cl_VEF = <a class="code" href="classOp__Conv__VEF__base.html#a03f677ee7911706a4f85cd37e0ca4535">la_zcl_vef</a>.<a class="code" href="classRef__Zone__Cl__VEF.html#a0970d7253def65ad4f0c5ce1830fd243">valeur</a>();

  <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; facette_normales = zone_VEF.<a class="code" href="classZone__VEF.html#a581b1ca0e62c668c92f104351d19fda6">facette_normales</a>();
  <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; facette_normales_Cl = zone_Cl_VEF.<a class="code" href="classZone__Cl__VEF.html#a83c05e82370553470ed05f10932e0f3f">normales_facettes_Cl</a>();
  <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; porosite_elem = zone_VEF.<a class="code" href="classZone__VF.html#afd135a1b227731193b1a97b7ed525435">porosite_elem</a>();
  <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; porosite_face = zone_VEF.<a class="code" href="classZone__VF.html#ad9d74d1d9da9f50ab26768dbbca7711b">porosite_face</a>();

  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; elem_faces = zone_VEF.<a class="code" href="classZone__VF.html#a067e462dcd3ab92b0f6d945b19e4eb37" title="renvoie le numero de le ieme face de la maille num_elem la facon dont ces faces sont numerotees est l...">elem_faces</a>();
  <span class="keyword">const</span> <a class="code" href="classIntVect.html">IntVect</a>&amp; rang_elem_non_std = zone_VEF.<a class="code" href="classZone__VEF.html#a4b2171a85e5fc33663a3366acb713584">rang_elem_non_std</a>();
  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; KEL=zone_VEF.<a class="code" href="classZone__VEF.html#a46693c060b8096fb2595ca72192eea2a">type_elem</a>().<a class="code" href="classDeriv__Elem__VEF__base.html#a2886905d5071be902c77248b69ca0b7b">valeur</a>().<a class="code" href="classElem__VEF__base.html#ab129610ef702aa8c9c98dcb4c7551172">KEL</a>();

  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_elem_tot = zone_VEF.<a class="code" href="classZone__dis__base.html#a4d6aa445f152aa6dc54d66ea7a071147">nb_elem_tot</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_faces_elem=elem_faces.<a class="code" href="classIntTab.html#abc3b32c94925a82f69d5b153a356e359" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(1);
  <span class="keyword">const</span> <span class="keywordtype">int</span> nfa7 = zone_VEF.<a class="code" href="classZone__VEF.html#a46693c060b8096fb2595ca72192eea2a">type_elem</a>().<a class="code" href="classElem__VEF.html#a4a34777c0083b38dd34c8a400d5b4e90">nb_facette</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_som_elem = zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#ae0b34a93b9ae8146df2d1884157afe9f" title="Renvoie le nombre de sommets des elements geometriques constituants la zone. Tous les elements de la ...">nb_som_elem</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> marq = <a class="code" href="classOp__Conv__VEF__base.html#ad380b9b9ca1d70282b289838a604a4b0" title="definit si l&#39;on convecte psi avec phi*u ou avec u">phi_u_transportant</a>(<a class="code" href="classMorEqn.html#a615dd9abff96edcb625fa0424a489864" title="Renvoie la reference sur l&#39;equation pointe par MorEqn::mon_equation. (version const)">equation</a>());

  <span class="keywordtype">int</span> rang=-2;
  <span class="keywordtype">int</span> fa7=0;
  <span class="keywordtype">int</span> dim=-1;
  <span class="keywordtype">int</span> itypcl=-2;
  <span class="keywordtype">int</span> elem=0;
  <span class="keywordtype">int</span> facei_loc=-1;
  <span class="keywordtype">int</span> facej_loc=-1;

  <span class="keywordtype">double</span> psc=0.;
  <span class="keywordtype">double</span> porosite=0.;

  <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a> vc(<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>);
  <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a> vs(<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>);
  <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a> vsom(nb_som_elem,<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>);

  <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> face(<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>+1);

  assert(Kij.<a class="code" href="classDoubleTab.html#ae6dda48778e7107e1beb723beef1f75b" title="Returns the number of dimensions of the array (&gt;= 1)">nb_dim</a>()==3);
  assert(Kij.<a class="code" href="classDoubleTab.html#ac3805e2637a3b880ba2d3e650c69dac4" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(0)==nb_elem_tot);
  assert(Kij.<a class="code" href="classDoubleTab.html#ac3805e2637a3b880ba2d3e650c69dac4" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(1)==Kij.<a class="code" href="classDoubleTab.html#ac3805e2637a3b880ba2d3e650c69dac4" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(2));
  assert(Kij.<a class="code" href="classDoubleTab.html#ac3805e2637a3b880ba2d3e650c69dac4" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(1)==nb_faces_elem);

  assert(Cij.<a class="code" href="classDoubleTab.html#ae6dda48778e7107e1beb723beef1f75b" title="Returns the number of dimensions of the array (&gt;= 1)">nb_dim</a>()==2);
  assert(Cij.<a class="code" href="classDoubleTab.html#ac3805e2637a3b880ba2d3e650c69dac4" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(0)==nb_elem_tot);
  assert(Cij.<a class="code" href="classDoubleTab.html#ac3805e2637a3b880ba2d3e650c69dac4" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(1)==nfa7);

  assert(Sij.<a class="code" href="classDoubleTab.html#ae6dda48778e7107e1beb723beef1f75b" title="Returns the number of dimensions of the array (&gt;= 1)">nb_dim</a>()==2);
  assert(Sij.<a class="code" href="classDoubleTab.html#ac3805e2637a3b880ba2d3e650c69dac4" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(0)==nb_elem_tot);
  assert(Sij.<a class="code" href="classDoubleTab.html#ac3805e2637a3b880ba2d3e650c69dac4" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(1)==nfa7);

  <span class="keywordflow">if</span> (<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>==3)
    {
      assert(Sij2.<a class="code" href="classDoubleTab.html#ae6dda48778e7107e1beb723beef1f75b" title="Returns the number of dimensions of the array (&gt;= 1)">nb_dim</a>()==2);
      assert(Sij2.<a class="code" href="classDoubleTab.html#ac3805e2637a3b880ba2d3e650c69dac4" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(0)==nb_elem_tot);
      assert(Sij2.<a class="code" href="classDoubleTab.html#ac3805e2637a3b880ba2d3e650c69dac4" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(1)==nfa7);
    }

<span class="comment">// </span>
<span class="comment">// Calcul des coefficients de l&#39;operateur</span>
<span class="comment">// </span>
  <span class="keywordflow">for</span>(elem=0; elem&lt;nb_elem_tot; elem++)
    {
      rang=rang_elem_non_std(elem);
      itypcl=(rang==-1)?0:zone_Cl_VEF.<a class="code" href="classZone__Cl__VEF.html#a483bdab7690f844ed04e3defe04ec70a">type_elem_Cl</a>(rang);

      <span class="keywordflow">for</span> (facei_loc=0; facei_loc&lt;nb_faces_elem; facei_loc++)
        face(facei_loc)=elem_faces(elem,facei_loc);

      vs=0.;
      <span class="keywordflow">for</span> (dim=0; dim&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>; dim++)
        <span class="keywordflow">for</span> (facei_loc=0; facei_loc&lt;nb_faces_elem; facei_loc++)
          vs(dim)+=velocity(face(facei_loc),dim);

      vsom=0;
      <span class="keywordflow">for</span> (dim=0; dim&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>; dim++)
        <span class="keywordflow">for</span> (facei_loc=0; facei_loc&lt;nb_faces_elem; facei_loc++)
          vsom(facei_loc,dim)=vs(dim)-Objet_U::dimension*velocity(face(facei_loc),dim);

      vc=0.;
      zone_VEF.<a class="code" href="classZone__VEF.html#a46693c060b8096fb2595ca72192eea2a">type_elem</a>().<a class="code" href="classDeriv__Elem__VEF__base.html#a2886905d5071be902c77248b69ca0b7b">valeur</a>().<a class="code" href="classElem__VEF__base.html#a02b712675ec9d8bbb6571ddbbec33417">calcul_vc</a>(face,vc,vs,vsom,(*this).vitesse(),itypcl,porosite_face);
      <span class="keywordflow">if</span> (marq==0)
        {
          porosite=1./porosite_elem(elem);

          vsom*=porosite;
          vs*=porosite;
          vc*=porosite;
        }

      <span class="keywordflow">if</span> (Objet_U::dimension==2)
        {
          <span class="keywordflow">if</span> (rang==-1)
            <span class="keywordflow">for</span> (fa7=0; fa7&lt;nfa7; fa7++)
              {
                facei_loc=KEL(0,fa7);
                facej_loc=KEL(1,fa7);

                Cij(elem,fa7)=0.;
                <span class="keywordflow">for</span> (dim=0; dim&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>; dim++)
                  Cij(elem,fa7)+=vc(dim)*facette_normales(elem,fa7,dim);

                Sij(elem,fa7)=0.;
                <span class="keywordflow">for</span> (dim=0; dim&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>; dim++)
                  Sij(elem,fa7)+=vsom(KEL(2,fa7),dim)*facette_normales(elem,fa7,dim);

                psc=Cij(elem,fa7)+Sij(elem,fa7);
                psc*=0.5;

                Kij(elem,facei_loc,facej_loc)=psc;
                Kij(elem,facei_loc,facei_loc)-=psc;<span class="comment">//pour l&#39;aspect LED</span>
                Kij(elem,facej_loc,facei_loc)=-psc;
                Kij(elem,facej_loc,facej_loc)+=psc;<span class="comment">//pour l&#39;aspect LED</span>
              }
          <span class="keywordflow">else</span> <span class="comment">//rang!=-1</span>
            <span class="keywordflow">for</span> (fa7=0; fa7&lt;nfa7; fa7++)
              {
                facei_loc=KEL(0,fa7);
                facej_loc=KEL(1,fa7);

                Cij(elem,fa7)=0.;
                <span class="keywordflow">for</span> (dim=0; dim&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>; dim++)
                  Cij(elem,fa7)+=vc(dim)*facette_normales_Cl(rang,fa7,dim);

                Sij(elem,fa7)=0.;
                <span class="keywordflow">for</span> (dim=0; dim&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>; dim++)
                  Sij(elem,fa7)+=vsom(KEL(2,fa7),dim)*facette_normales_Cl(rang,fa7,dim);

                psc=Cij(elem,fa7)+Sij(elem,fa7);
                psc*=0.5;

                Kij(elem,facei_loc,facej_loc)=psc;
                Kij(elem,facei_loc,facei_loc)-=psc;<span class="comment">//pour l&#39;aspect LED</span>
                Kij(elem,facej_loc,facei_loc)=-psc;
                Kij(elem,facej_loc,facej_loc)+=psc;<span class="comment">//pour l&#39;aspect LED</span>
              }
        }<span class="comment">//fin Objet_U::dimension==2</span>
      <span class="keywordflow">else</span> <span class="comment">//Objet_U::dimension==3</span>
        {
          <span class="keywordflow">if</span> (rang==-1)
            <span class="keywordflow">for</span> (fa7=0; fa7&lt;nfa7; fa7++)
              {
                facei_loc=KEL(0,fa7);
                facej_loc=KEL(1,fa7);

                Cij(elem,fa7)=0.;
                <span class="keywordflow">for</span> (dim=0; dim&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>; dim++)
                  Cij(elem,fa7)+=vc(dim)*facette_normales(elem,fa7,dim);

                Sij(elem,fa7)=0.;
                <span class="keywordflow">for</span> (dim=0; dim&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>; dim++)
                  Sij(elem,fa7)+=vsom(KEL(2,fa7),dim)*facette_normales(elem,fa7,dim);

                Sij2(elem,fa7)=0.;
                <span class="keywordflow">for</span> (dim=0; dim&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>; dim++)
                  Sij2(elem,fa7)+=vsom(KEL(3,fa7),dim)*facette_normales(elem,fa7,dim);

                psc=Cij(elem,fa7)+Sij(elem,fa7)+Sij2(elem,fa7);
                psc/=3.;

                Kij(elem,facei_loc,facej_loc)=psc;
                Kij(elem,facei_loc,facei_loc)-=psc;<span class="comment">//pour l&#39;aspect LED</span>
                Kij(elem,facej_loc,facei_loc)=-psc;
                Kij(elem,facej_loc,facej_loc)+=psc;<span class="comment">//pour l&#39;aspect LED</span>
              }
          <span class="keywordflow">else</span> <span class="comment">//rang!=-1</span>
            <span class="keywordflow">for</span> (fa7=0; fa7&lt;nfa7; fa7++)
              {
                facei_loc=KEL(0,fa7);
                facej_loc=KEL(1,fa7);

                Cij(elem,fa7)=0.;
                <span class="keywordflow">for</span> (dim=0; dim&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>; dim++)
                  Cij(elem,fa7)+=vc(dim)*facette_normales_Cl(rang,fa7,dim);

                Sij(elem,fa7)=0.;
                <span class="keywordflow">for</span> (dim=0; dim&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>; dim++)
                  Sij(elem,fa7)+=vsom(KEL(2,fa7),dim)*facette_normales_Cl(rang,fa7,dim);

                Sij2(elem,fa7)=0.;
                <span class="keywordflow">for</span> (dim=0; dim&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>; dim++)
                  Sij2(elem,fa7)+=vsom(KEL(3,fa7),dim)*facette_normales_Cl(rang,fa7,dim);

                psc=Cij(elem,fa7)+Sij(elem,fa7)+Sij2(elem,fa7);
                psc/=3.;

                Kij(elem,facei_loc,facej_loc)=psc;
                Kij(elem,facei_loc,facei_loc)-=psc;<span class="comment">//pour l&#39;aspect LED</span>
                Kij(elem,facej_loc,facei_loc)=-psc;
                Kij(elem,facej_loc,facej_loc)+=psc;<span class="comment">//pour l&#39;aspect LED</span>
              }
        }<span class="comment">//fin Objet_U::dimension==3</span>
    }

<span class="comment">// </span>
<span class="comment">// Correction des Kij pour Dirichlet !</span>
<span class="comment">// </span>
  {
    <span class="keywordtype">int</span> nb_bord=zone_Cl_VEF.<a class="code" href="classZone__Cl__dis__base.html#aa6f1df56cfd6e2eae83cc991c7cc9b41" title="Renvoie le nombre de conditions aux limites.">nb_cond_lim</a>();

    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> n_bord=0; n_bord&lt;nb_bord; n_bord++)
      {
        <span class="keyword">const</span> <a class="code" href="classCond__lim.html" title="classe Cond_lim Classe generique servant a representer n&#39;importe quelle classe derivee de la classe C...">Cond_lim</a>&amp; la_cl = zone_Cl_VEF.<a class="code" href="classZone__Cl__dis__base.html#af75e0ed7786863e4d333bfb29d67c323" title="Renvoie la i-ieme condition aux limites. (version const)">les_conditions_limites</a>(n_bord);

        <span class="keywordflow">if</span> ( (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classDirichlet.html" title="classe Dirichlet Cette classe est la classe de base de la hierarchie des conditions aux limites de ty...">Dirichlet</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>()))
             || (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classDirichlet__homogene.html" title="Classe Dirichlet_homogene Cette classe est la classe de base de la hierarchie des conditions aux limi...">Dirichlet_homogene</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>()))
           )
          {
<span class="comment">// On ne fait rien</span>
          }<span class="comment">//!&lt; sub_type Dirichlet</span>
<span class="comment"></span>

        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classNeumann.html" title="Classe Neumann Cette classe est la classe de base de la hierarchie des conditions aux limites de type...">Neumann</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>()) || <a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classNeumann__homogene.html" title="Classe Neumann_homogene Cette classe est la classe de base de la hierarchie des conditions aux limite...">Neumann_homogene</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>()))
          {
<span class="comment">// On ne fait rien</span>
          }<span class="comment">//fin du if sur Neumann</span>

        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classSymetrie.html" title="classe Symetrie Sur les faces de symetrie on a les proprietes suivantes: - composante normale de la v...">Symetrie</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>()))
          {
<span class="comment">// On ne fait rien</span>
          }<span class="comment">//fin du if sur Symetrie</span>

        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>()))
          {
<span class="comment">// On ne fait rien</span>
          }<span class="comment">//fin du if sur Periodique</span>

        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classEchange__impose__base.html" title="classe Echange_impose_base: Cette condition limite sert uniquement pour l&#39;equation d&#39;energie...">Echange_impose_base</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>()))
          {
<span class="comment">// On ne fait rien</span>
          }<span class="comment">//fin du if sur Echange_impose_base</span>

        <span class="keywordflow">else</span>
          {
            <span class="keywordflow">if</span> (<a class="code" href="classProcess.html#acd052b99706c577f8a5b6656217cf4c2" title="renvoie 1 si on est sur le processeur maitre du groupe courant (c&#39;est a dire me() == 0)...">Process::je_suis_maitre</a>())
              {
                <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Erreur Op_Conv_Muscl_New_VEF_Face::calculer_coefficients_operateur_centre()&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
                <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Condition aux limites &quot;</span> &lt;&lt; la_cl.<a class="code" href="classObjet__U.html#aa58e9a81c0ddc2c1149053b8f96698ac" title="renvoie la chaine identifiant la classe.">que_suis_je</a>() &lt;&lt; <span class="stringliteral">&quot; non codee.&quot;</span>   &lt;&lt; finl;
                <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Sortie du programme.&quot;</span> &lt;&lt; finl;
              }
            <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">Process::exit</a>();
          }<span class="comment">//fin du else sur les autres conditions aux limites</span>

      }<span class="comment">//fin des conditions aux limites</span>
  }

<span class="comment">// </span>
<span class="comment">// Fin de la correction des Kij</span>
<span class="comment">// </span>
}
</pre></div>
</div>
</div>
<a class="anchor" id="a4ff4bc26b4f14df5174c4682f2ec580b"></a><!-- doxytag: member="Op_Conv_Muscl_New_VEF_Face::calculer_data_pour_dirichlet" ref="a4ff4bc26b4f14df5174c4682f2ec580b" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Op_Conv_Muscl_New_VEF_Face::calculer_data_pour_dirichlet </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8cpp_source.html#l02226">2226</a> of file <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8cpp_source.html">Op_Conv_Muscl_New_VEF_Face.cpp</a>.</p>

<p>References <a class="el" href="Zone__VF_8h_source.html#l00609">Zone_VF::face_sommets()</a>, <a class="el" href="Cond__lim_8h_source.html#l00130">Cond_lim::frontiere_dis()</a>, <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8h_source.html#l00112">is_dirichlet_faces_</a>, <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8h_source.html#l00111">is_element_for_upwinding_</a>, <a class="el" href="Op__Conv__VEF__base_8h_source.html#l00093">Op_Conv_VEF_base::la_zcl_vef</a>, <a class="el" href="Op__Conv__VEF__base_8h_source.html#l00092">Op_Conv_VEF_base::la_zone_vef</a>, <a class="el" href="Zone__Cl__dis__base_8cpp_source.html#l00522">Zone_Cl_dis_base::les_conditions_limites()</a>, <a class="el" href="Zone_8h_source.html#l00402">Zone::les_elems()</a>, <a class="el" href="Zone__Cl__dis__base_8cpp_source.html#l00603">Zone_Cl_dis_base::nb_cond_lim()</a>, <a class="el" href="Zone__dis__base_8h_source.html#l00144">Zone_dis_base::nb_elem_tot()</a>, <a class="el" href="Zone__VF_8h_source.html#l00527">Zone_VF::nb_faces_tot()</a>, <a class="el" href="Front__VF_8h_source.html#l00066">Front_VF::nb_faces_tot()</a>, <a class="el" href="Zone_8h_source.html#l00445">Zone::nb_som_elem()</a>, <a class="el" href="Zone__VF_8h_source.html#l00538">Zone_VF::nb_som_face()</a>, <a class="el" href="Zone__dis__base_8h_source.html#l00152">Zone_dis_base::nb_som_tot()</a>, <a class="el" href="Front__VF_8h_source.html#l00076">Front_VF::num_face()</a>, <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8h_source.html#l00124">old_centered_</a>, <a class="el" href="Zone__VEF_8h_source.html#l00165">Zone_VEF::rang_elem_non_std()</a>, <a class="el" href="Cast_8h_source.html#l00059">ref_cast</a>, <a class="el" href="IntTab_8cpp_source.html#l00353">IntTab::resize()</a>, <a class="el" href="Cast_8h_source.html#l00054">sub_type</a>, <a class="el" href="Cond__lim_8h_source.html#l00031">Deriv_Cond_lim_base::valeur()</a>, <a class="el" href="Ref__Zone__Cl__VEF_8h_source.html#l00028">Ref_Zone_Cl_VEF::valeur()</a>, <a class="el" href="Ref__Zone__VEF_8h_source.html#l00028">Ref_Zone_VEF::valeur()</a>, and <a class="el" href="Zone__dis__base_8h_source.html#l00106">Zone_dis_base::zone()</a>.</p>

<p>Referenced by <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8cpp_source.html#l02311">completer()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">const</span> <a class="code" href="classZone__VEF.html" title="class Zone_VEF Classe instanciable qui derive de Zone_VF. Cette classe contient les informations geom...">Zone_VEF</a>&amp; zone_VEF = <a class="code" href="classOp__Conv__VEF__base.html#a6c29a488a6805ba4a9f2f059cdba77ae">la_zone_vef</a>.<a class="code" href="classRef__Zone__VEF.html#aafd9a5ee1a76f290c9c6b5447b0c8d30">valeur</a>();
  <span class="keyword">const</span> <a class="code" href="classZone__Cl__VEF.html">Zone_Cl_VEF</a>&amp; zone_Cl_VEF = <a class="code" href="classOp__Conv__VEF__base.html#a03f677ee7911706a4f85cd37e0ca4535">la_zcl_vef</a>.<a class="code" href="classRef__Zone__Cl__VEF.html#a0970d7253def65ad4f0c5ce1830fd243">valeur</a>();

  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; face_sommets = zone_VEF.<a class="code" href="classZone__VF.html#a298e73b18e17da55f421b1fb0879bd46" title="renvoie le numero du ieme sommet de la face num_face.">face_sommets</a>();
  <span class="keyword">const</span> <a class="code" href="classIntVect.html">IntVect</a>&amp; rang_elem_non_std = zone_VEF.<a class="code" href="classZone__VEF.html#a4b2171a85e5fc33663a3366acb713584">rang_elem_non_std</a>();
  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; elem_sommets = zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#ac115e8342be89afb882b7b61cc343267" title="Renvoie le tableau des sommets des elements.">les_elems</a>();

  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_elem_tot = zone_VEF.<a class="code" href="classZone__dis__base.html#a4d6aa445f152aa6dc54d66ea7a071147">nb_elem_tot</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_bord = zone_Cl_VEF.<a class="code" href="classZone__Cl__dis__base.html#aa6f1df56cfd6e2eae83cc991c7cc9b41" title="Renvoie le nombre de conditions aux limites.">nb_cond_lim</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_som_faces = zone_VEF.<a class="code" href="classZone__VF.html#a990808f967f351edbb83ff11d60b7445" title="renvoie le nombre de sommets par face. Rque : on a suppose que toutes les faces avait le meme nombre ...">nb_som_face</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_som_elem = zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#ae0b34a93b9ae8146df2d1884157afe9f" title="Renvoie le nombre de sommets des elements geometriques constituants la zone. Tous les elements de la ...">nb_som_elem</a>();

  <span class="keywordtype">int</span> som_loc=-1;
  <span class="keywordtype">int</span> som=-1;
  <span class="keywordtype">int</span> ind_face=-1;
  <span class="keywordtype">int</span> elem=-1;
  <span class="keywordtype">int</span> rang=-2;

<span class="comment">// On rajoute un flag aux elements qui ont au moins un sommet qui appartient</span>
<span class="comment">// une face de Dirichlet ou Dirichlet_homogene</span>
  <span class="keywordflow">if</span> (<a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#af27e616d4be292efae0dcd25ef29278c">old_centered_</a>)
    {
      <a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#a93e226d752c2b31d4b63e08840aea2cb">is_element_for_upwinding_</a>.<a class="code" href="classIntTab.html#a22e6bed6826b3688d4d0181cbf3b7a38" title="Change la taille du vecteur (identique a resize_array() pour le traitement des anciennes valeurs et d...">resize</a>(nb_elem_tot);
      <a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#a93e226d752c2b31d4b63e08840aea2cb">is_element_for_upwinding_</a>=0;

      <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a> est_un_sommet_de_bord(zone_VEF.<a class="code" href="classZone__dis__base.html#a8f793341b7a41d67561ba563ae0f69a0">nb_som_tot</a>());
      est_un_sommet_de_bord=0;

      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> n_bord=0; n_bord&lt;nb_bord; n_bord++)
        {
          <span class="keyword">const</span> <a class="code" href="classCond__lim.html" title="classe Cond_lim Classe generique servant a representer n&#39;importe quelle classe derivee de la classe C...">Cond_lim</a>&amp; la_cl = zone_Cl_VEF.<a class="code" href="classZone__Cl__dis__base.html#af75e0ed7786863e4d333bfb29d67c323" title="Renvoie la i-ieme condition aux limites. (version const)">les_conditions_limites</a>(n_bord);
          <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp; le_bord = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>,la_cl.<a class="code" href="classCond__lim.html#a5b2d24809cee07727006a891d4ce8d22" title="Appel a l&#39;objet sous-jacent Renvoie la frontiere discretisee associee a la condition aux limites...">frontiere_dis</a>());
          <span class="keywordtype">int</span> nb_faces_tot=le_bord.<a class="code" href="classFront__VF.html#aed4006d91bf2ef3af2b9f7933d863a09" title="Nombre de faces reelles et virtuelles du bord.">nb_faces_tot</a>();
          <span class="keywordtype">int</span> face=-1;

          <span class="keywordflow">if</span> ( (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classDirichlet.html" title="classe Dirichlet Cette classe est la classe de base de la hierarchie des conditions aux limites de ty...">Dirichlet</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>()))
               || (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classDirichlet__homogene.html" title="Classe Dirichlet_homogene Cette classe est la classe de base de la hierarchie des conditions aux limi...">Dirichlet_homogene</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>()))
             )
            <span class="keywordflow">for</span> (ind_face=0; ind_face&lt;nb_faces_tot; ind_face++)
              {
                face = le_bord.<a class="code" href="classFront__VF.html#a3402a19d7e54ed797d2b18e9a47ead1e" title="Renvoie le numero de face de la ieme face du bord.">num_face</a>(ind_face);
                <span class="keywordflow">for</span> (som_loc=0; som_loc&lt;nb_som_faces; som_loc++)
                  {
                    som=face_sommets(face,som_loc);
                    est_un_sommet_de_bord(som)=1;
                  }
              }
        }

      <span class="keywordflow">for</span> (elem=0; elem&lt;nb_elem_tot; elem++)
        {
          rang=rang_elem_non_std(elem);
          <span class="keywordflow">if</span> (rang!=-1) <a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#a93e226d752c2b31d4b63e08840aea2cb">is_element_for_upwinding_</a>(elem)=1;
          <span class="keywordflow">else</span>
            <span class="keywordflow">for</span> (som_loc=0; som_loc&lt;nb_som_elem; som_loc++)
              {
                som=elem_sommets(elem,som_loc);
                <span class="keywordflow">if</span> (est_un_sommet_de_bord(som))
                  <a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#a93e226d752c2b31d4b63e08840aea2cb">is_element_for_upwinding_</a>(elem)=1;
              }
        }
    }
  <a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#a1e7b0db2325d8e59bbaa9460ed6f3826">is_dirichlet_faces_</a>.<a class="code" href="classIntTab.html#a22e6bed6826b3688d4d0181cbf3b7a38" title="Change la taille du vecteur (identique a resize_array() pour le traitement des anciennes valeurs et d...">resize</a>(zone_VEF.<a class="code" href="classZone__VF.html#a50fd21c9535680489015a3c8b88c685a" title="renvoie le nombre total de faces. C&#39;est-a-dire faces reelles + faces virtuelles">nb_faces_tot</a>());
  <a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#a1e7b0db2325d8e59bbaa9460ed6f3826">is_dirichlet_faces_</a>=0;

  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> n_bord=0; n_bord&lt;nb_bord; n_bord++)
    {
      <span class="keyword">const</span> <a class="code" href="classCond__lim.html" title="classe Cond_lim Classe generique servant a representer n&#39;importe quelle classe derivee de la classe C...">Cond_lim</a>&amp; la_cl = zone_Cl_VEF.<a class="code" href="classZone__Cl__dis__base.html#af75e0ed7786863e4d333bfb29d67c323" title="Renvoie la i-ieme condition aux limites. (version const)">les_conditions_limites</a>(n_bord);
      <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp; le_bord = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>,la_cl.<a class="code" href="classCond__lim.html#a5b2d24809cee07727006a891d4ce8d22" title="Appel a l&#39;objet sous-jacent Renvoie la frontiere discretisee associee a la condition aux limites...">frontiere_dis</a>());
      <span class="keywordtype">int</span> nb_faces_tot=le_bord.<a class="code" href="classFront__VF.html#aed4006d91bf2ef3af2b9f7933d863a09" title="Nombre de faces reelles et virtuelles du bord.">nb_faces_tot</a>();
      <span class="keywordtype">int</span> face=-1;

      <span class="keywordflow">if</span> ( (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classDirichlet.html" title="classe Dirichlet Cette classe est la classe de base de la hierarchie des conditions aux limites de ty...">Dirichlet</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>()))
           || (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classDirichlet__homogene.html" title="Classe Dirichlet_homogene Cette classe est la classe de base de la hierarchie des conditions aux limi...">Dirichlet_homogene</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>()))
         )
        <span class="keywordflow">for</span> (ind_face=0; ind_face&lt;nb_faces_tot; ind_face++)
          {
            face = le_bord.<a class="code" href="classFront__VF.html#a3402a19d7e54ed797d2b18e9a47ead1e" title="Renvoie le numero de face de la ieme face du bord.">num_face</a>(ind_face);
            <a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#a1e7b0db2325d8e59bbaa9460ed6f3826">is_dirichlet_faces_</a>(face)=1;
          }
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a6c66104c0f7419cdf6a126d2266d4720"></a><!-- doxytag: member="Op_Conv_Muscl_New_VEF_Face::calculer_dt_stab" ref="a6c66104c0f7419cdf6a126d2266d4720" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Op_Conv_Muscl_New_VEF_Face::calculer_dt_stab </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calcul dt_stab. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>double<br/>
 Signification: renvoie toujours 1.e30<br/>
 Contraintes: </dd></dl>

<p>Reimplemented from <a class="el" href="classOp__Conv__VEF__base.html#a3cfda6bf27063ef486304efa3967e464">Op_Conv_VEF_base</a>.</p>

<p>Definition at line <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8cpp_source.html#l01107">1107</a> of file <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8cpp_source.html">Op_Conv_Muscl_New_VEF_Face.cpp</a>.</p>

<p>References <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8cpp_source.html#l00314">calculer_coefficients_operateur_centre()</a>, <a class="el" href="Objet__U_8h_source.html#l00079">Objet_U::dimension</a>, <a class="el" href="DoubleTab_8h_source.html#l00243">DoubleTab::dimension()</a>, <a class="el" href="IntTab_8h_source.html#l00233">IntTab::dimension()</a>, <a class="el" href="Zone__VF_8h_source.html#l00574">Zone_VF::elem_faces()</a>, <a class="el" href="MorEqn_8h_source.html#l00082">MorEqn::equation()</a>, <a class="el" href="Periodique_8h_source.html#l00056">Periodique::face_associee()</a>, <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8h_source.html#l00126">facsec_auto_</a>, <a class="el" href="Operateur__Conv__base_8h_source.html#l00072">Operateur_Conv_base::fixer_dt_stab_conv()</a>, <a class="el" href="Cond__lim_8h_source.html#l00130">Cond_lim::frontiere_dis()</a>, <a class="el" href="classEquation__base.html#a5a1fce9487b9a8dd17020914100c2c89">Equation_base::inconnue()</a>, <a class="el" href="Op__Conv__VEF__base_8h_source.html#l00093">Op_Conv_VEF_base::la_zcl_vef</a>, <a class="el" href="Op__Conv__VEF__base_8h_source.html#l00092">Op_Conv_VEF_base::la_zone_vef</a>, <a class="el" href="Zone__Cl__dis__base_8cpp_source.html#l00522">Zone_Cl_dis_base::les_conditions_limites()</a>, <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8h_source.html#l00120">max_limiteur_</a>, <a class="el" href="Porosites__champ_8cpp_source.html#l00035">modif_par_porosite_si_flag()</a>, <a class="el" href="Process_8cpp_source.html#l00156">Process::mp_max()</a>, <a class="el" href="IntVect_8cpp_source.html#l01593">IntVect::mp_max_vect()</a>, <a class="el" href="Zone__Cl__dis__base_8cpp_source.html#l00603">Zone_Cl_dis_base::nb_cond_lim()</a>, <a class="el" href="Zone__dis__base_8h_source.html#l00144">Zone_dis_base::nb_elem_tot()</a>, <a class="el" href="Front__VF_8h_source.html#l00066">Front_VF::nb_faces_tot()</a>, <a class="el" href="Zone__VF_8h_source.html#l00527">Zone_VF::nb_faces_tot()</a>, <a class="el" href="Elem__VEF_8h_source.html#l00083">Elem_VEF::nb_facette()</a>, <a class="el" href="Front__VF_8h_source.html#l00076">Front_VF::num_face()</a>, <a class="el" href="Op__Conv__VEF__base_8cpp_source.html#l00053">Op_Conv_VEF_base::phi_u_transportant()</a>, <a class="el" href="Zone__VF_8h_source.html#l00285">Zone_VF::porosite_face()</a>, <a class="el" href="Cast_8h_source.html#l00059">ref_cast</a>, <a class="el" href="Cast_8h_source.html#l00062">ref_cast_non_const</a>, <a class="el" href="DoubleTab_8cpp_source.html#l00335">DoubleTab::resize()</a>, <a class="el" href="Cast_8h_source.html#l00054">sub_type</a>, <a class="el" href="Zone__VEF_8h_source.html#l00138">Zone_VEF::type_elem()</a>, <a class="el" href="Cond__lim_8h_source.html#l00031">Deriv_Cond_lim_base::valeur()</a>, <a class="el" href="Ref__Champ__Inc__base_8h_source.html#l00028">Ref_Champ_Inc_base::valeur()</a>, <a class="el" href="Ref__Zone__Cl__VEF_8h_source.html#l00028">Ref_Zone_Cl_VEF::valeur()</a>, <a class="el" href="Ref__Zone__VEF_8h_source.html#l00028">Ref_Zone_VEF::valeur()</a>, <a class="el" href="Champ__Inc_8cpp_source.html#l00245">Champ_Inc::valeurs()</a>, <a class="el" href="Champ__Inc__base_8cpp_source.html#l00221">Champ_Inc_base::valeurs()</a>, and <a class="el" href="Op__Conv__VEF__base_8h_source.html#l00094">Op_Conv_VEF_base::vitesse_</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">if</span> (!<a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#a55d9e35f60df86eecbcc895f3cb72d3c">facsec_auto_</a>)
    <span class="keywordflow">return</span> <a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#a6c66104c0f7419cdf6a126d2266d4720" title="Calcul dt_stab.">Op_Conv_VEF_Face::calculer_dt_stab</a>();
  <span class="keywordflow">else</span>
    {
      <span class="keyword">const</span> <a class="code" href="classZone__VEF.html" title="class Zone_VEF Classe instanciable qui derive de Zone_VF. Cette classe contient les informations geom...">Zone_VEF</a>&amp; zone_VEF = <a class="code" href="classOp__Conv__VEF__base.html#a6c29a488a6805ba4a9f2f059cdba77ae">la_zone_vef</a>.<a class="code" href="classRef__Zone__VEF.html#aafd9a5ee1a76f290c9c6b5447b0c8d30">valeur</a>();
      <span class="keyword">const</span> <a class="code" href="classZone__Cl__VEF.html">Zone_Cl_VEF</a>&amp; zone_Cl_VEF = <a class="code" href="classOp__Conv__VEF__base.html#a03f677ee7911706a4f85cd37e0ca4535">la_zcl_vef</a>.<a class="code" href="classRef__Zone__Cl__VEF.html#a0970d7253def65ad4f0c5ce1830fd243">valeur</a>();
      <span class="keyword">const</span> <a class="code" href="classChamp__P1NC.html">Champ_P1NC</a>&amp; la_vitesse=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>( <a class="code" href="classChamp__P1NC.html">Champ_P1NC</a>, <a class="code" href="classOp__Conv__VEF__base.html#a5547875832fb45e09b1115372fb76ffd">vitesse_</a>.<a class="code" href="classRef__Champ__Inc__base.html#a17553641a4c06730e1562125e07b3490">valeur</a>());
      <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; vitesse_2=la_vitesse.<a class="code" href="classChamp__Inc__base.html#adb537f43f1649e103a8980314c7ed175" title="Renvoie le tableau des valeurs du champ au temps courant.">valeurs</a>();
      <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; porosite_face = zone_VEF.<a class="code" href="classZone__VF.html#ad9d74d1d9da9f50ab26768dbbca7711b">porosite_face</a>();

      <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; elem_faces = zone_VEF.<a class="code" href="classZone__VF.html#a067e462dcd3ab92b0f6d945b19e4eb37" title="renvoie le numero de le ieme face de la maille num_elem la facon dont ces faces sont numerotees est l...">elem_faces</a>();

      <span class="keyword">const</span> <span class="keywordtype">int</span> marq=<a class="code" href="classOp__Conv__VEF__base.html#ad380b9b9ca1d70282b289838a604a4b0" title="definit si l&#39;on convecte psi avec phi*u ou avec u">phi_u_transportant</a>(<a class="code" href="classMorEqn.html#a615dd9abff96edcb625fa0424a489864" title="Renvoie la reference sur l&#39;equation pointe par MorEqn::mon_equation. (version const)">equation</a>());
      <span class="keyword">const</span> <span class="keywordtype">int</span> nb_faces_elem=elem_faces.<a class="code" href="classIntTab.html#abc3b32c94925a82f69d5b153a356e359" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(1);
      <span class="keyword">const</span> <span class="keywordtype">int</span> nb_elem_tot = zone_VEF.<a class="code" href="classZone__dis__base.html#a4d6aa445f152aa6dc54d66ea7a071147">nb_elem_tot</a>();
      <span class="keyword">const</span> <span class="keywordtype">int</span> nfa7 = zone_VEF.<a class="code" href="classZone__VEF.html#a46693c060b8096fb2595ca72192eea2a">type_elem</a>().<a class="code" href="classElem__VEF.html#a4a34777c0083b38dd34c8a400d5b4e90">nb_facette</a>();
      <span class="keyword">const</span> <span class="keywordtype">int</span> nb_faces_tot = zone_VEF.<a class="code" href="classZone__VF.html#a50fd21c9535680489015a3c8b88c685a" title="renvoie le nombre total de faces. C&#39;est-a-dire faces reelles + faces virtuelles">nb_faces_tot</a>();
      <span class="keyword">const</span> <span class="keywordtype">int</span> nb_bord = zone_Cl_VEF.<a class="code" href="classZone__Cl__dis__base.html#aa6f1df56cfd6e2eae83cc991c7cc9b41" title="Renvoie le nombre de conditions aux limites.">nb_cond_lim</a>();

      <span class="keywordtype">int</span> nb_comp=1;
      <span class="keywordflow">if</span>(<a class="code" href="classMorEqn.html#a615dd9abff96edcb625fa0424a489864" title="Renvoie la reference sur l&#39;equation pointe par MorEqn::mon_equation. (version const)">equation</a>().inconnue().valeurs().nb_dim()!=1)
        nb_comp=<a class="code" href="classMorEqn.html#a615dd9abff96edcb625fa0424a489864" title="Renvoie la reference sur l&#39;equation pointe par MorEqn::mon_equation. (version const)">equation</a>().<a class="code" href="classEquation__base.html#a5a1fce9487b9a8dd17020914100c2c89">inconnue</a>().<a class="code" href="classChamp__Inc.html#a28ef3d411d12cb5684ac5e799efb7d24" title="Appel a l&#39;objet sous-jacent Renvoie le tableau des valeurs au temps courant.">valeurs</a>().<a class="code" href="classDoubleTab.html#ac3805e2637a3b880ba2d3e650c69dac4" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(1);

      <span class="keywordtype">int</span> elem=-1;
      <span class="keywordtype">int</span> facei_loc=-1;
      <span class="keywordtype">int</span> facei=-1;
      <span class="keywordtype">int</span> faceiAss=-1;
      <span class="keywordtype">int</span> facej_loc=-1;
      <span class="keywordtype">int</span> facej=-1;
      <span class="keywordtype">int</span> n_bord=-1;
      <span class="keywordtype">int</span> num1=-1,num2=-1;
      <span class="keywordtype">int</span> ind_face=-1;
      <span class="keywordtype">int</span> ind_face_associee=-1;
      <span class="keywordtype">int</span> max_int=-1;

      <span class="keywordtype">double</span> dt_stab = <a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#a6c66104c0f7419cdf6a126d2266d4720" title="Calcul dt_stab.">Op_Conv_VEF_Face::calculer_dt_stab</a>();
      <span class="keywordtype">double</span> security_coeff=0.95;
      <span class="keywordtype">double</span> dt_corrector=-1.;
      <span class="keywordtype">double</span> kij=0.;

<span class="comment">// soit on a transporte=phi*transporte_ et vitesse=vitesse_</span>
<span class="comment">// soit transporte=transporte_ et vitesse=phi*vitesse_</span>
<span class="comment">// cela depend si on transporte avec phi u ou avec u.</span>
      <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a> vitesse_face_;
      <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; velocity=<a class="code" href="Porosites__champ_8cpp.html#a2340e7d73d0f9d34926d012fe1b1d884" title="renvoit le tableau res, res=org si flag=0, res= porosite*org sinon attention ne pas modifier res car ...">modif_par_porosite_si_flag</a>(vitesse_2,vitesse_face_,marq,porosite_face);

<span class="comment">// statistiques().begin_count(m1);</span>
      <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a> Kij(nb_elem_tot,nb_faces_elem,nb_faces_elem);
      <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a> Cij(nb_elem_tot,nfa7);
      <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a> Sij(nb_elem_tot,nfa7);
      <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a> Sij2;
      <span class="keywordflow">if</span> (<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>==3)
        {
          Sij2.<a class="code" href="classDoubleTab.html#ae83b4d31205c53d9c8d2b43da178ce75" title="Change la taille du vecteur (identique a resize_array() pour le traitement des anciennes valeurs et d...">resize</a>(nb_elem_tot,nfa7);
          Sij2=0.;
        }
      <a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#afde9a8f6daffddcc35a097fd68674797">calculer_coefficients_operateur_centre</a>(Kij,Cij,Sij,Sij2,nb_comp,velocity);

<span class="comment">// Debut du calcul</span>
      <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a> plus_tab(nb_faces_tot);
      <span class="keywordflow">for</span> (elem=0; elem&lt;nb_elem_tot; elem++)
        <span class="keywordflow">for</span> (facei_loc=0; facei_loc&lt;nb_faces_elem; facei_loc++)
          {
            facei=elem_faces(elem,facei_loc);
            <span class="keywordflow">for</span> (facej_loc=facei_loc+1; facej_loc&lt;nb_faces_elem; facej_loc++)
              {
                kij=Kij(elem,facei_loc,facej_loc);
                facej=elem_faces(elem,facej_loc);

                <span class="keywordflow">if</span> (kij&gt;=0.)
                  plus_tab(facei)+=1;
                <span class="keywordflow">else</span>
                  plus_tab(facej)+=1;
              }
          }
      <span class="keywordflow">for</span> (n_bord=0; n_bord&lt;nb_bord; n_bord++)
        {
          <span class="keyword">const</span> <a class="code" href="classCond__lim.html" title="classe Cond_lim Classe generique servant a representer n&#39;importe quelle classe derivee de la classe C...">Cond_lim</a>&amp; la_cl = zone_Cl_VEF.<a class="code" href="classZone__Cl__dis__base.html#af75e0ed7786863e4d333bfb29d67c323" title="Renvoie la i-ieme condition aux limites. (version const)">les_conditions_limites</a>(n_bord);
          <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp; le_bord = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>,la_cl.<a class="code" href="classCond__lim.html#a5b2d24809cee07727006a891d4ce8d22" title="Appel a l&#39;objet sous-jacent Renvoie la frontiere discretisee associee a la condition aux limites...">frontiere_dis</a>());
          num1=0;
          num2=le_bord.<a class="code" href="classFront__VF.html#aed4006d91bf2ef3af2b9f7933d863a09" title="Nombre de faces reelles et virtuelles du bord.">nb_faces_tot</a>();

          <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>()))
            {
              <span class="keyword">const</span> <a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>&amp; la_cl_perio = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>());

              <span class="keywordflow">for</span> (ind_face=num1; ind_face&lt;num2; ind_face++)
                {
                  facei=le_bord.<a class="code" href="classFront__VF.html#a3402a19d7e54ed797d2b18e9a47ead1e" title="Renvoie le numero de face de la ieme face du bord.">num_face</a>(ind_face);
                  ind_face_associee=la_cl_perio.<a class="code" href="classPeriodique.html#a207b86556f199a63ea059b841851ca6a">face_associee</a>(ind_face);
                  faceiAss=le_bord.<a class="code" href="classFront__VF.html#a3402a19d7e54ed797d2b18e9a47ead1e" title="Renvoie le numero de face de la ieme face du bord.">num_face</a>(ind_face_associee);

                  <span class="keywordflow">if</span> (facei&lt;faceiAss)
                    {
                      plus_tab[faceiAss]+=plus_tab[facei];
                      plus_tab[facei]=plus_tab[faceiAss];
                    }

                }<span class="comment">//fin du for sur &quot;ind_face&quot;</span>

            }<span class="comment">//fin du if sur &quot;Periodique&quot;</span>

        }<span class="comment">//fin du for sur &quot;n_bord&quot;</span>
      max_int=plus_tab.mp_max_vect();
      max_int=(int)<a class="code" href="classProcess.html#a1e9d9f9899b71927cfafae14c7bd048d" title="Calcule le max de x sur tous les processeurs du groupe courant. Remarques : Cette methode doit etre a...">Process::mp_max</a>(max_int);

      dt_corrector=1./(1+<a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#ae5e76d1a00689f96fe333745b2a6c2ef">max_limiteur_</a>*max_int);
      dt_corrector*=security_coeff;
      dt_stab*=dt_corrector;

      <a class="code" href="classOp__Conv__VEF__base.html" title="class Op_Conv_VEF_base Classe de base des operateurs de convection VEF">Op_Conv_VEF_base</a>&amp; op = <a class="code" href="Cast_8h.html#ad3836a067c92103af8df5ad8f35959a6">ref_cast_non_const</a>(<a class="code" href="classOp__Conv__VEF__base.html" title="class Op_Conv_VEF_base Classe de base des operateurs de convection VEF">Op_Conv_VEF_base</a>,*<span class="keyword">this</span>);
      op.<a class="code" href="classOperateur__Conv__base.html#a868dd39f29b4f613ec620fe5ada95977">fixer_dt_stab_conv</a>(dt_stab);

      <span class="keywordflow">return</span> dt_stab;
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="ad9cd682b100057d3019ba30b61a9b469"></a><!-- doxytag: member="Op_Conv_Muscl_New_VEF_Face::calculer_flux_bords" ref="ad9cd682b100057d3019ba30b61a9b469" args="(const DoubleTab &amp;, const DoubleTab &amp;, const DoubleTab &amp;) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Op_Conv_Muscl_New_VEF_Face::calculer_flux_bords </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>Kij</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>velocity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>transporte</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8cpp_source.html#l01316">1316</a> of file <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8cpp_source.html">Op_Conv_Muscl_New_VEF_Face.cpp</a>.</p>

<p>References <a class="el" href="EntreeSortie_8h_source.html#l00032">Cerr</a>, <a class="el" href="Objet__U_8h_source.html#l00079">Objet_U::dimension</a>, <a class="el" href="DoubleTab_8h_source.html#l00243">DoubleTab::dimension()</a>, <a class="el" href="Process_8cpp_source.html#l00223">Process::exit()</a>, <a class="el" href="Periodique_8h_source.html#l00056">Periodique::face_associee()</a>, <a class="el" href="Zone__VEF_8h_source.html#l00145">Zone_VEF::face_normales()</a>, <a class="el" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>, <a class="el" href="Operateur__base_8h_source.html#l00168">Operateur_base::flux_bords_</a>, <a class="el" href="Cond__lim_8h_source.html#l00130">Cond_lim::frontiere_dis()</a>, <a class="el" href="Process_8cpp_source.html#l00095">Process::je_suis_maitre()</a>, <a class="el" href="Op__Conv__VEF__base_8h_source.html#l00093">Op_Conv_VEF_base::la_zcl_vef</a>, <a class="el" href="Op__Conv__VEF__base_8h_source.html#l00092">Op_Conv_VEF_base::la_zone_vef</a>, <a class="el" href="Zone__Cl__dis__base_8cpp_source.html#l00522">Zone_Cl_dis_base::les_conditions_limites()</a>, <a class="el" href="Zone__Cl__dis__base_8cpp_source.html#l00603">Zone_Cl_dis_base::nb_cond_lim()</a>, <a class="el" href="DoubleTab_8h_source.html#l00264">DoubleTab::nb_dim()</a>, <a class="el" href="Front__VF_8h_source.html#l00061">Front_VF::nb_faces()</a>, <a class="el" href="Front__VF_8h_source.html#l00076">Front_VF::num_face()</a>, <a class="el" href="Objet__U_8cpp_source.html#l00132">Objet_U::que_suis_je()</a>, <a class="el" href="Cast_8h_source.html#l00059">ref_cast</a>, <a class="el" href="Cast_8h_source.html#l00054">sub_type</a>, <a class="el" href="Neumann__sortie__libre_8cpp_source.html#l00138">Neumann_sortie_libre::val_ext()</a>, <a class="el" href="Cond__lim_8h_source.html#l00031">Deriv_Cond_lim_base::valeur()</a>, <a class="el" href="Ref__Zone__Cl__VEF_8h_source.html#l00028">Ref_Zone_Cl_VEF::valeur()</a>, and <a class="el" href="Ref__Zone__VEF_8h_source.html#l00028">Ref_Zone_VEF::valeur()</a>.</p>

<p>Referenced by <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8cpp_source.html#l01029">ajouter()</a>.</p>
<div class="fragment"><pre class="fragment">{

  <span class="keyword">const</span> <a class="code" href="classZone__VEF.html" title="class Zone_VEF Classe instanciable qui derive de Zone_VF. Cette classe contient les informations geom...">Zone_VEF</a>&amp; zone_VEF=<a class="code" href="classOp__Conv__VEF__base.html#a6c29a488a6805ba4a9f2f059cdba77ae">la_zone_vef</a>.<a class="code" href="classRef__Zone__VEF.html#aafd9a5ee1a76f290c9c6b5447b0c8d30">valeur</a>();
  <span class="keyword">const</span> <a class="code" href="classZone__Cl__VEF.html">Zone_Cl_VEF</a>&amp; zone_Cl_VEF = <a class="code" href="classOp__Conv__VEF__base.html#a03f677ee7911706a4f85cd37e0ca4535">la_zcl_vef</a>.<a class="code" href="classRef__Zone__Cl__VEF.html#a0970d7253def65ad4f0c5ce1830fd243">valeur</a>();


  <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; transporteV=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classDoubleVect.html">DoubleVect</a>,transporte);
  <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; face_normales=zone_VEF.<a class="code" href="classZone__VEF.html#a5742d75972e4846bf9fbb6ed5715053e">face_normales</a>();

  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_bord = zone_Cl_VEF.<a class="code" href="classZone__Cl__dis__base.html#aa6f1df56cfd6e2eae83cc991c7cc9b41" title="Renvoie le nombre de conditions aux limites.">nb_cond_lim</a>();

  <span class="keywordtype">int</span> nb_comp=1;
  <span class="keywordflow">if</span> (transporte.<a class="code" href="classDoubleTab.html#ae6dda48778e7107e1beb723beef1f75b" title="Returns the number of dimensions of the array (&gt;= 1)">nb_dim</a>()!=1) nb_comp=transporte.<a class="code" href="classDoubleTab.html#ac3805e2637a3b880ba2d3e650c69dac4" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(1);

  <span class="keywordtype">int</span> facei=0;
  <span class="keywordtype">int</span> dim=0;
  <span class="keywordtype">int</span> n_bord=0;
  <span class="keywordtype">int</span> num1=0,num2=0;
  <span class="keywordtype">int</span> ind_face=0;

  <span class="keywordtype">double</span> psc=0.;

  <span class="keywordflow">for</span> (n_bord=0; n_bord&lt;nb_bord; n_bord++)
    {
      <span class="keyword">const</span> <a class="code" href="classCond__lim.html" title="classe Cond_lim Classe generique servant a representer n&#39;importe quelle classe derivee de la classe C...">Cond_lim</a>&amp; la_cl = zone_Cl_VEF.<a class="code" href="classZone__Cl__dis__base.html#af75e0ed7786863e4d333bfb29d67c323" title="Renvoie la i-ieme condition aux limites. (version const)">les_conditions_limites</a>(n_bord);
      <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp; le_bord = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>,la_cl.<a class="code" href="classCond__lim.html#a5b2d24809cee07727006a891d4ce8d22" title="Appel a l&#39;objet sous-jacent Renvoie la frontiere discretisee associee a la condition aux limites...">frontiere_dis</a>());
      num1 = 0;
      num2 = le_bord.<a class="code" href="classFront__VF.html#a341e2fcb5117b96e745fd7078ba86bab" title="Nombre de faces reelles du bord.">nb_faces</a>();<span class="comment">//il ne faut boucler que sur les faces reelles ici</span>

      <span class="keywordflow">if</span> ( <a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classDirichlet__homogene.html" title="Classe Dirichlet_homogene Cette classe est la classe de base de la hierarchie des conditions aux limi...">Dirichlet_homogene</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>()) )
        {
<span class="comment">// On ne calcule pas le flux aux bords de Dirichlet_homogene</span>
        }<span class="comment">//fin du if sur &quot;Dirichlet&quot;</span>
      <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( <a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classDirichlet.html" title="classe Dirichlet Cette classe est la classe de base de la hierarchie des conditions aux limites de ty...">Dirichlet</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>() ))
        {
          <span class="keywordflow">for</span> (ind_face=num1; ind_face&lt;num2; ind_face++)
            {
              facei = le_bord.<a class="code" href="classFront__VF.html#a3402a19d7e54ed797d2b18e9a47ead1e" title="Renvoie le numero de face de la ieme face du bord.">num_face</a>(ind_face);

              psc=0.;
              <span class="keywordflow">for</span> (dim=0; dim&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; dim++)
                psc-=velocity(facei,dim)*face_normales(facei,dim);

              <span class="keywordflow">for</span> (dim=0; dim&lt;nb_comp; dim++)
                <a class="code" href="classOperateur__base.html#a451f51b41518ddbc0d3f586a8177d319" title="Tableau contenant les flux sur les bords de l&#39;operateur.">flux_bords_</a>(facei,dim)=psc*transporteV[facei*nb_comp+dim];
            }
        }
      <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( ( <a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classNeumann.html" title="Classe Neumann Cette classe est la classe de base de la hierarchie des conditions aux limites de type...">Neumann</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>()) &amp;&amp;
                  !( <a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classNeumann__sortie__libre.html" title="classe Neumann_sortie_libre Cette classe represente une frontiere ouverte sans vitesse imposee Pour l...">Neumann_sortie_libre</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>())) )
                || <a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classNeumann__homogene.html" title="Classe Neumann_homogene Cette classe est la classe de base de la hierarchie des conditions aux limite...">Neumann_homogene</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>())
                || <a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classSymetrie.html" title="classe Symetrie Sur les faces de symetrie on a les proprietes suivantes: - composante normale de la v...">Symetrie</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>())
                || <a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classEchange__impose__base.html" title="classe Echange_impose_base: Cette condition limite sert uniquement pour l&#39;equation d&#39;energie...">Echange_impose_base</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>())
              )
        {
          <span class="keywordflow">for</span> (ind_face=num1; ind_face&lt;num2; ind_face++)
            {
              facei = le_bord.<a class="code" href="classFront__VF.html#a3402a19d7e54ed797d2b18e9a47ead1e" title="Renvoie le numero de face de la ieme face du bord.">num_face</a>(ind_face);

              psc=0.;
              <span class="keywordflow">for</span> (dim=0; dim&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; dim++)
                psc-=velocity(facei,dim)*face_normales(facei,dim);

              <span class="keywordflow">for</span> (dim=0; dim&lt;nb_comp; dim++)
                <a class="code" href="classOperateur__base.html#a451f51b41518ddbc0d3f586a8177d319" title="Tableau contenant les flux sur les bords de l&#39;operateur.">flux_bords_</a>(facei,dim)=psc*transporteV[facei*nb_comp+dim];
            }

        }<span class="comment">//fin du if sur &quot;Neumann&quot;, &quot;Neumann_homogene&quot;, &quot;Symetrie&quot;, &quot;Echange_impose_base&quot;</span>
      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classNeumann__sortie__libre.html" title="classe Neumann_sortie_libre Cette classe represente une frontiere ouverte sans vitesse imposee Pour l...">Neumann_sortie_libre</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>()))
        {
          <span class="keyword">const</span> <a class="code" href="classNeumann__sortie__libre.html" title="classe Neumann_sortie_libre Cette classe represente une frontiere ouverte sans vitesse imposee Pour l...">Neumann_sortie_libre</a>&amp; la_sortie_libre = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classNeumann__sortie__libre.html" title="classe Neumann_sortie_libre Cette classe represente une frontiere ouverte sans vitesse imposee Pour l...">Neumann_sortie_libre</a>, la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>());

          <span class="keywordflow">for</span> (ind_face=num1; ind_face&lt;num2; ind_face++)
            {
              facei = le_bord.<a class="code" href="classFront__VF.html#a3402a19d7e54ed797d2b18e9a47ead1e" title="Renvoie le numero de face de la ieme face du bord.">num_face</a>(ind_face);

              psc=0.;
              <span class="keywordflow">for</span> (dim=0; dim&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; dim++)
                psc-=velocity(facei,dim)*face_normales(facei,dim);

              <span class="keywordflow">if</span> (psc&lt;0.)
                {
                  <span class="keywordflow">for</span> (dim=0; dim&lt;nb_comp; dim++)
                    {
                      <a class="code" href="classOperateur__base.html#a451f51b41518ddbc0d3f586a8177d319" title="Tableau contenant les flux sur les bords de l&#39;operateur.">flux_bords_</a>(facei,dim) = psc*transporteV[facei*nb_comp+dim];
                    }
                }
              <span class="keywordflow">else</span>
                {
                  <span class="keywordflow">if</span> (nb_comp == 1)
                    {
                      <a class="code" href="classOperateur__base.html#a451f51b41518ddbc0d3f586a8177d319" title="Tableau contenant les flux sur les bords de l&#39;operateur.">flux_bords_</a>(facei,0) = psc*la_sortie_libre.<a class="code" href="classNeumann__sortie__libre.html#a886f1804fa2a9028fc56a0778a72a75d" title="Renvoie la valeur de la i-eme composante du champ impose a l&#39;exterieur de la frontiere.">val_ext</a>(ind_face);
                    }
                  <span class="keywordflow">else</span>
                    {
                      <span class="keywordflow">for</span> (dim=0; dim&lt;nb_comp; dim++)
                        {
                          <a class="code" href="classOperateur__base.html#a451f51b41518ddbc0d3f586a8177d319" title="Tableau contenant les flux sur les bords de l&#39;operateur.">flux_bords_</a>(facei,dim) = psc*la_sortie_libre.<a class="code" href="classNeumann__sortie__libre.html#a886f1804fa2a9028fc56a0778a72a75d" title="Renvoie la valeur de la i-eme composante du champ impose a l&#39;exterieur de la frontiere.">val_ext</a>(ind_face,dim);
                        }
                    }
                }
            }
        }
      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>()))
        {
          <span class="keyword">const</span> <a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>&amp; la_cl_perio = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>, la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>());

          <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> fait(num2);
          fait = 0;

          <span class="keywordtype">int</span> ind_face_voisine = -1;
          <span class="keywordtype">int</span> facei_voisine    = -1;
          <span class="keywordtype">double</span> flux             = 0.;

          <span class="keywordflow">for</span> (ind_face=num1; ind_face&lt;num2; ind_face++)
            {
              <span class="keywordflow">if</span> (fait[ind_face] == 0)
                {
                  facei            = le_bord.<a class="code" href="classFront__VF.html#a3402a19d7e54ed797d2b18e9a47ead1e" title="Renvoie le numero de face de la ieme face du bord.">num_face</a>(ind_face);
                  ind_face_voisine = la_cl_perio.<a class="code" href="classPeriodique.html#a207b86556f199a63ea059b841851ca6a">face_associee</a>(ind_face);
                  facei_voisine    = le_bord.<a class="code" href="classFront__VF.html#a3402a19d7e54ed797d2b18e9a47ead1e" title="Renvoie le numero de face de la ieme face du bord.">num_face</a>(ind_face_voisine);

                  psc=0.;
                  <span class="keywordflow">for</span> (dim=0; dim&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; dim++)
                    psc-=velocity(facei,dim)*face_normales(facei,dim);

                  <span class="keywordflow">for</span> (dim=0; dim&lt;nb_comp; dim++)
                    {
                      flux                           = psc*transporteV[facei*nb_comp+dim];
                      <a class="code" href="classOperateur__base.html#a451f51b41518ddbc0d3f586a8177d319" title="Tableau contenant les flux sur les bords de l&#39;operateur.">flux_bords_</a>(facei,dim)         =  flux;
                      <a class="code" href="classOperateur__base.html#a451f51b41518ddbc0d3f586a8177d319" title="Tableau contenant les flux sur les bords de l&#39;operateur.">flux_bords_</a>(facei_voisine,dim) = -flux;
                    }

                  fait[ind_face]         = 1;
                  fait[ind_face_voisine] = 1;
                }
            }
        }
      <span class="keywordflow">else</span>
        {
          <span class="keywordflow">if</span> (<a class="code" href="classProcess.html#acd052b99706c577f8a5b6656217cf4c2" title="renvoie 1 si on est sur le processeur maitre du groupe courant (c&#39;est a dire me() == 0)...">Process::je_suis_maitre</a>())
            {
              <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Erreur Op_Conv_Muscl_New_VEF_Face::calculer_flux_bords()&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
              <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Condition aux limites &quot;</span> &lt;&lt; la_cl.<a class="code" href="classObjet__U.html#aa58e9a81c0ddc2c1149053b8f96698ac" title="renvoie la chaine identifiant la classe.">que_suis_je</a>() &lt;&lt; <span class="stringliteral">&quot; non codee.&quot;</span>   &lt;&lt; finl;
              <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Sortie du programme.&quot;</span> &lt;&lt; finl;
            }
          <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">Process::exit</a>();
        }<span class="comment">//fin du else sur les autres conditions aux limites</span>
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="aaf6d31030b81017b92df85d3377d6ae9"></a><!-- doxytag: member="Op_Conv_Muscl_New_VEF_Face::calculer_flux_operateur_centre" ref="aaf6d31030b81017b92df85d3377d6ae9" args="(DoubleTab &amp;, const DoubleTab &amp;, const DoubleTab &amp;, const DoubleTab &amp;, const DoubleTab &amp;, const int &amp;, const DoubleTab &amp;, const DoubleTab &amp;) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Op_Conv_Muscl_New_VEF_Face::calculer_flux_operateur_centre </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>Fij</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>Kij</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>Cij</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>Sij</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>Sij2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>nb_comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>velocity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>transporte</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>&lt; (du/dx du/dy dv/dx dv/dy) pour un poly gradient_elem=0.; </p>
</p>

<p>Definition at line <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8cpp_source.html#l00566">566</a> of file <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8cpp_source.html">Op_Conv_Muscl_New_VEF_Face.cpp</a>.</p>

<p>References <a class="el" href="Champ__P1NC_8cpp_source.html#l00940">Champ_P1NC::calcul_gradient()</a>, <a class="el" href="Domaine_8h_source.html#l00500">Domaine::coord_sommets()</a>, <a class="el" href="DoubleTab_8h_source.html#l00243">DoubleTab::dimension()</a>, <a class="el" href="Objet__U_8h_source.html#l00079">Objet_U::dimension</a>, <a class="el" href="IntTab_8h_source.html#l00233">IntTab::dimension()</a>, <a class="el" href="Zone_8cpp_source.html#l00262">Zone::domaine()</a>, <a class="el" href="Zone__VF_8h_source.html#l00574">Zone_VF::elem_faces()</a>, <a class="el" href="Elem__VEF__base_8h_source.html#l00047">Elem_VEF_base::KEL()</a>, <a class="el" href="Op__Conv__VEF__base_8h_source.html#l00093">Op_Conv_VEF_base::la_zcl_vef</a>, <a class="el" href="Op__Conv__VEF__base_8h_source.html#l00092">Op_Conv_VEF_base::la_zone_vef</a>, <a class="el" href="DoubleTab_8h_source.html#l00264">DoubleTab::nb_dim()</a>, <a class="el" href="Zone__dis__base_8h_source.html#l00144">Zone_dis_base::nb_elem_tot()</a>, <a class="el" href="Elem__VEF_8h_source.html#l00083">Elem_VEF::nb_facette()</a>, <a class="el" href="Zone__VEF_8h_source.html#l00165">Zone_VEF::rang_elem_non_std()</a>, <a class="el" href="Cast_8h_source.html#l00059">ref_cast</a>, <a class="el" href="Cast_8h_source.html#l00062">ref_cast_non_const</a>, <a class="el" href="Zone_8h_source.html#l00344">Zone::sommet_elem()</a>, <a class="el" href="Zone__VEF_8h_source.html#l00138">Zone_VEF::type_elem()</a>, <a class="el" href="Elem__VEF_8h_source.html#l00041">Deriv_Elem_VEF_base::valeur()</a>, <a class="el" href="Ref__Zone__Cl__VEF_8h_source.html#l00028">Ref_Zone_Cl_VEF::valeur()</a>, <a class="el" href="Ref__Zone__VEF_8h_source.html#l00028">Ref_Zone_VEF::valeur()</a>, <a class="el" href="Zone__Cl__VEF_8h_source.html#l00140">Zone_Cl_VEF::vecteur_face_facette_Cl()</a>, <a class="el" href="Zone__VF_8h_source.html#l00650">Zone_VF::xv()</a>, and <a class="el" href="Zone__dis__base_8h_source.html#l00106">Zone_dis_base::zone()</a>.</p>

<p>Referenced by <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8cpp_source.html#l01029">ajouter()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">const</span> <a class="code" href="classZone__VEF.html" title="class Zone_VEF Classe instanciable qui derive de Zone_VF. Cette classe contient les informations geom...">Zone_VEF</a>&amp; zone_VEF = <a class="code" href="classOp__Conv__VEF__base.html#a6c29a488a6805ba4a9f2f059cdba77ae">la_zone_vef</a>.<a class="code" href="classRef__Zone__VEF.html#aafd9a5ee1a76f290c9c6b5447b0c8d30">valeur</a>();
  <span class="keyword">const</span> <a class="code" href="classZone__Cl__VEF.html">Zone_Cl_VEF</a>&amp; zone_Cl_VEF = <a class="code" href="classOp__Conv__VEF__base.html#a03f677ee7911706a4f85cd37e0ca4535">la_zcl_vef</a>.<a class="code" href="classRef__Zone__Cl__VEF.html#a0970d7253def65ad4f0c5ce1830fd243">valeur</a>();
  <span class="keyword">const</span> <a class="code" href="classDomaine.html" title="Classe Domaine Un Domaine represente le domaine (spatial) de resolution d&#39;un Probleme. Un Domaine a un Nom, il est constitue d&#39;une ou plusieurs Zone qui peuvent etre eventuellement decoupees en Sous_Zone. Un Domaine porte l&#39;ensemble des sommets utilises par ses Zones. On peut vouloir resoudre des problemes de type different sur plusieurs domaines, geometriquement les domaines sont alors couples par des surfaces qu&#39;on appelle Raccord.">Domaine</a>&amp; domaine = zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#a379ad2206b5a13a4f4f3df6d44c7546a" title="Renvoie le domaine dont la zone fait partie. (version const)">domaine</a>();

  <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; vecteur_face_facette = <a class="code" href="Cast_8h.html#ad3836a067c92103af8df5ad8f35959a6">ref_cast_non_const</a>(<a class="code" href="classZone__VEF.html" title="class Zone_VEF Classe instanciable qui derive de Zone_VF. Cette classe contient les informations geom...">Zone_VEF</a>,zone_VEF).vecteur_face_facette();
  <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; vecteur_face_facette_Cl = zone_Cl_VEF.<a class="code" href="classZone__Cl__VEF.html#aa7acf4bf79e075ba2488e2ee9051c6fe">vecteur_face_facette_Cl</a>();
  <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; coord_sommets = domaine.<a class="code" href="classDomaine.html#aecd32c3eecc15cce7d1a0e468dadbf96" title="Renvoie le tableau des coordonnees des noeuds (sommets). (acces en lecture)">coord_sommets</a>();
  <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; xv = zone_VEF.<a class="code" href="classZone__VF.html#a918c0885a9b67317fcce3a0535306542">xv</a>();

  <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; transporteVect=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classDoubleVect.html">DoubleVect</a>,transporte);

  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; elem_faces = zone_VEF.<a class="code" href="classZone__VF.html#a067e462dcd3ab92b0f6d945b19e4eb37" title="renvoie le numero de le ieme face de la maille num_elem la facon dont ces faces sont numerotees est l...">elem_faces</a>();
<span class="comment">// const IntTab&amp; face_voisins = zone_VEF.face_voisins();</span>
  <span class="keyword">const</span> <a class="code" href="classIntVect.html">IntVect</a>&amp; rang_elem_non_std = zone_VEF.<a class="code" href="classZone__VEF.html#a4b2171a85e5fc33663a3366acb713584">rang_elem_non_std</a>();
  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; KEL=zone_VEF.<a class="code" href="classZone__VEF.html#a46693c060b8096fb2595ca72192eea2a">type_elem</a>().<a class="code" href="classDeriv__Elem__VEF__base.html#a2886905d5071be902c77248b69ca0b7b">valeur</a>().<a class="code" href="classElem__VEF__base.html#ab129610ef702aa8c9c98dcb4c7551172">KEL</a>();

  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_elem_tot = zone_VEF.<a class="code" href="classZone__dis__base.html#a4d6aa445f152aa6dc54d66ea7a071147">nb_elem_tot</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_faces_elem=elem_faces.<a class="code" href="classIntTab.html#abc3b32c94925a82f69d5b153a356e359" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(1);
  <span class="keyword">const</span> <span class="keywordtype">int</span> nfa7 = zone_VEF.<a class="code" href="classZone__VEF.html#a46693c060b8096fb2595ca72192eea2a">type_elem</a>().<a class="code" href="classElem__VEF.html#a4a34777c0083b38dd34c8a400d5b4e90">nb_facette</a>();

  <span class="keywordtype">int</span> rang=-2;
  <span class="keywordtype">int</span> fa7=0;
  <span class="keywordtype">int</span> dim=-1;
  <span class="keywordtype">int</span> elem=0;
  <span class="keywordtype">int</span> face_amont=-1;
  <span class="keywordtype">int</span> dir=-1;
  <span class="keywordtype">int</span> comp=-1;
  <span class="keywordtype">int</span> s=-1;
  <span class="keywordtype">int</span> s2=-1;
  <span class="keywordtype">int</span> facei=-1;
  <span class="keywordtype">int</span> facej=-1;
  <span class="keywordtype">int</span> facei_loc=-1;
  <span class="keywordtype">int</span> facej_loc=-1;

  <span class="keywordtype">double</span> inco_m=0.;
  <span class="keywordtype">double</span> inco_s=0.;
  <span class="keywordtype">double</span> inco_s2=0.;
  <span class="keywordtype">double</span> inco_c=0.;
  <span class="keywordtype">double</span> flux=0.;

  <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a> gradient_elem(nb_elem_tot,nb_comp,<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>);  <span class="comment">//!&lt; (du/dx du/dy dv/dx dv/dy) pour un poly  gradient_elem=0.;</span>
<span class="comment"></span>  <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a> face(<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>+1);

  assert(Fij.<a class="code" href="classDoubleTab.html#ae6dda48778e7107e1beb723beef1f75b" title="Returns the number of dimensions of the array (&gt;= 1)">nb_dim</a>()==4);
  assert(Fij.<a class="code" href="classDoubleTab.html#ac3805e2637a3b880ba2d3e650c69dac4" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(0)==nb_elem_tot);
  assert(Fij.<a class="code" href="classDoubleTab.html#ac3805e2637a3b880ba2d3e650c69dac4" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(1)==Fij.<a class="code" href="classDoubleTab.html#ac3805e2637a3b880ba2d3e650c69dac4" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(2));
  assert(Fij.<a class="code" href="classDoubleTab.html#ac3805e2637a3b880ba2d3e650c69dac4" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(1)==nb_faces_elem);
  assert(Fij.<a class="code" href="classDoubleTab.html#ac3805e2637a3b880ba2d3e650c69dac4" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(3)==nb_comp);

<span class="comment">// </span>
<span class="comment">// Calcul des flux de l&#39;operateur</span>
<span class="comment">// </span>
  <a class="code" href="classChamp__P1NC.html#a87d96c073d3c127684934610f9a1e407">Champ_P1NC::calcul_gradient</a>(transporte,gradient_elem,zone_Cl_VEF);

  <span class="keywordflow">for</span>(elem=0; elem&lt;nb_elem_tot; elem++)
    {
      rang=rang_elem_non_std(elem);

      <span class="keywordflow">for</span> (facei_loc=0; facei_loc&lt;nb_faces_elem; facei_loc++)
        face(facei_loc)=elem_faces(elem,facei_loc);

      <span class="keywordflow">if</span> (<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>==2)
        {
          <span class="keywordflow">if</span> (rang==-1)
            <span class="keywordflow">for</span> (fa7=0; fa7&lt;nfa7; fa7++)
              {
                facei_loc=KEL(0,fa7);
                facej_loc=KEL(1,fa7);

                facei=face(facei_loc);
                facej=face(facej_loc);

<span class="comment">// REMARQUE : ON N&#39;OUBLIE PAS QUE LES NORMALES FA7 SONT ORIENTeES DE FACE_LOCI VERS FACE_LOCJ PAR DEFAUT</span>
<span class="comment">// LES PRODUITS SCALAIRES PSC_M, PSC_C, PSC_S SONT DONC CALCULeS POUR OBTENIR LE FLUX REcU PAR LA FACE FACE_LOCI</span>
<span class="comment">// ET EMIS PAR LA FACE_LOCJ</span>
<span class="comment">// SI L&#39;ON VEUT OBTENIR LE FLUX REcU PAR LA FACE FACE_LOCJ ET EMIS PAR LA FACE_LOCI, IL FAUT MULTIPLIER LES</span>
<span class="comment">// PRODUITS SCALAIRES PSC_M, PSC_C, PSC_S PAR -1 POUR IMPLICITEMENT ReORIENTER LES NORMALES FA7 DE FACE_LOCJ VERS</span>
<span class="comment">// FACE_LOCI</span>
<span class="comment">// MEME REMARQUE POUR LE SCALAIRE &quot;FLUX&quot;</span>
                <span class="keyword">const</span> <span class="keywordtype">double</span>&amp; psc_m = Kij(elem,facei_loc,facej_loc);
                <span class="keyword">const</span> <span class="keywordtype">double</span>&amp; psc_c = Cij(elem,fa7);
                <span class="keyword">const</span> <span class="keywordtype">double</span>&amp; psc_s = Sij(elem,fa7);

                <span class="keywordflow">if</span> (psc_m&gt;=0.)
                  face_amont=facei,dir=0;
                <span class="keywordflow">else</span>
                  face_amont=facej,dir=1;

                s=zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#aa164c00997bc77a365a6da57bbec29ce" title="Renvoie le numero (global) j-ieme sommet du i-ieme element.">sommet_elem</a>(elem,KEL(2,fa7));

                <span class="keywordflow">for</span> (comp=0; comp&lt;nb_comp; comp++)
                  {
<span class="comment">// Calcul de la valeur de l&#39;inconnue aux points d&#39;integration de la formule de Simspon</span>
                    inco_m=transporteVect[face_amont*nb_comp+comp];
                    <span class="keywordflow">for</span>(dim=0; dim&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>; dim++)
                      inco_m+=gradient_elem(elem,comp,dim)*vecteur_face_facette(elem,fa7,dim,dir);

                    inco_s=transporteVect[face_amont*nb_comp+comp];
                    <span class="keywordflow">for</span>(dim=0; dim&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>; dim++)
                      inco_s+=gradient_elem(elem,comp,dim)*(coord_sommets(s,dim)-xv(face_amont,dim));

                    inco_c=2.*inco_m-inco_s;

<span class="comment">// Calcul du flux final : formule d&#39;integration de Simpson</span>
                    flux=inco_c*psc_c;
                    flux+=4*inco_m*psc_m;
                    flux+=inco_s*psc_s;
                    flux/=6.;

<span class="comment">// Fij(elem,facei_loc,facej_loc,comp) est le flux recu par la facei_loc dans elem</span>
<span class="comment">// envoye par la face facej_loc dans elem pour la composante comp de l&#39;inconnue</span>
                    Fij(elem,facei_loc,facej_loc,comp)=flux-psc_m*transporteVect[facei*nb_comp+comp];
                    Fij(elem,facej_loc,facei_loc,comp)=psc_m*transporteVect[facej*nb_comp+comp]-flux;
                  }
              }
          <span class="keywordflow">else</span> <span class="comment">//rang!=-1</span>
            <span class="keywordflow">for</span> (fa7=0; fa7&lt;nfa7; fa7++)
              {
                facei_loc=KEL(0,fa7);
                facej_loc=KEL(1,fa7);

                facei=face(facei_loc);
                facej=face(facej_loc);

<span class="comment">// REMARQUE : ON N&#39;OUBLIE PAS QUE LES NORMALES FA7 SONT ORIENTeES DE FACE_LOCI VERS FACE_LOCJ PAR DEFAUT</span>
<span class="comment">// LES PRODUITS SCALAIRES PSC_M, PSC_C, PSC_S SONT DONC CALCULeS POUR OBTENIR LE FLUX REcU PAR LA FACE FACE_LOCI</span>
<span class="comment">// ET EMIS PAR LA FACE_LOCJ</span>
<span class="comment">// SI L&#39;ON VEUT OBTENIR LE FLUX REcU PAR LA FACE FACE_LOCJ ET EMIS PAR LA FACE_LOCI, IL FAUT MULTIPLIER LES</span>
<span class="comment">// PRODUITS SCALAIRES PSC_M, PSC_C, PSC_S PAR -1 POUR IMPLICITEMENT ReORIENTER LES NORMALES FA7 DE FACE_LOCJ VERS</span>
<span class="comment">// FACE_LOCI</span>
<span class="comment">// MEME REMARQUE POUR LE SCALAIRE &quot;FLUX&quot;</span>
                <span class="keyword">const</span> <span class="keywordtype">double</span>&amp; psc_m = Kij(elem,facei_loc,facej_loc);
                <span class="keyword">const</span> <span class="keywordtype">double</span>&amp; psc_c = Cij(elem,fa7);
                <span class="keyword">const</span> <span class="keywordtype">double</span>&amp; psc_s = Sij(elem,fa7);

                <span class="keywordflow">if</span> (psc_m&gt;=0.)
                  face_amont=facei,dir=0;
                <span class="keywordflow">else</span>
                  face_amont=facej,dir=1;

                s=zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#aa164c00997bc77a365a6da57bbec29ce" title="Renvoie le numero (global) j-ieme sommet du i-ieme element.">sommet_elem</a>(elem,KEL(2,fa7));

                <span class="keywordflow">for</span> (comp=0; comp&lt;nb_comp; comp++)
                  {
<span class="comment">// Calcul de la valeur de l&#39;inconnue aux points d&#39;integration de la formule de Simspon</span>
                    inco_m=transporteVect[face_amont*nb_comp+comp];
                    <span class="keywordflow">for</span>(dim=0; dim&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>; dim++)
                      inco_m+=gradient_elem(elem,comp,dim)*vecteur_face_facette_Cl(rang,fa7,dim,dir);

                    inco_s=transporteVect[face_amont*nb_comp+comp];
                    <span class="keywordflow">for</span>(dim=0; dim&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>; dim++)
                      inco_s+=gradient_elem(elem,comp,dim)*(coord_sommets(s,dim)-xv(face_amont,dim));

                    inco_c=2.*inco_m-inco_s;

<span class="comment">// Calcul du flux final : formule d&#39;integration de Simpson</span>
                    flux=inco_c*psc_c;
                    flux+=4*inco_m*psc_m;
                    flux+=inco_s*psc_s;
                    flux/=6.;

<span class="comment">// Fij(elem,facei_loc,facej_loc,comp) est le flux recu par la facei_loc dans elem</span>
<span class="comment">// envoye par la face facej_loc dans elem pour la composante comp de l&#39;inconnue</span>
                    Fij(elem,facei_loc,facej_loc,comp)=flux-psc_m*transporteVect[facei*nb_comp+comp];
                    Fij(elem,facej_loc,facei_loc,comp)=psc_m*transporteVect[facej*nb_comp+comp]-flux;
                  }
              }
        }<span class="comment">//fin Objet_U::dimension==2</span>
      <span class="keywordflow">else</span> <span class="comment">//Objet_U::dimension==3</span>
        {
          <span class="keywordflow">if</span> (rang==-1)
            <span class="keywordflow">for</span> (fa7=0; fa7&lt;nfa7; fa7++)
              {
                facei_loc=KEL(0,fa7);
                facej_loc=KEL(1,fa7);

                facei=face(facei_loc);
                facej=face(facej_loc);

<span class="comment">// REMARQUE : ON N&#39;OUBLIE PAS QUE LES NORMALES FA7 SONT ORIENTeES DE FACE_LOCI VERS FACE_LOCJ PAR DEFAUT</span>
<span class="comment">// LES PRODUITS SCALAIRES PSC_M, PSC_C, PSC_S, PSC_S2 SONT DONC CALCULeS POUR OBTENIR LE FLUX REcU PAR LA FACE FACE_LOCI</span>
<span class="comment">// ET EMIS PAR LA FACE_LOCJ</span>
<span class="comment">// SI L&#39;ON VEUT OBTENIR LE FLUX REcU PAR LA FACE FACE_LOCJ ET EMIS PAR LA FACE_LOCI, IL FAUT MULTIPLIER LES</span>
<span class="comment">// PRODUITS SCALAIRES PSC_M, PSC_C, PSC_S, PSC_S2 PAR -1 POUR IMPLICITEMENT ReORIENTER LES NORMALES FA7 DE FACE_LOCJ VERS</span>
<span class="comment">// FACE_LOCI</span>
<span class="comment">// MEME REMARQUE POUR LE SCALAIRE &quot;FLUX&quot;</span>
                <span class="keyword">const</span> <span class="keywordtype">double</span>&amp; psc_c = Cij(elem,fa7);
                <span class="keyword">const</span> <span class="keywordtype">double</span>&amp; psc_s = Sij(elem,fa7);
                <span class="keyword">const</span> <span class="keywordtype">double</span>&amp; psc_s2 = Sij2(elem,fa7);
                <span class="keyword">const</span> <span class="keywordtype">double</span>&amp; psc_m = Kij(elem,facei_loc,facej_loc);

                <span class="keywordflow">if</span> (psc_m&gt;=0.)
                  face_amont=facei,dir=0;
                <span class="keywordflow">else</span>
                  face_amont=facej,dir=1;

                s=zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#aa164c00997bc77a365a6da57bbec29ce" title="Renvoie le numero (global) j-ieme sommet du i-ieme element.">sommet_elem</a>(elem,KEL(2,fa7));
                s2=zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#aa164c00997bc77a365a6da57bbec29ce" title="Renvoie le numero (global) j-ieme sommet du i-ieme element.">sommet_elem</a>(elem,KEL(3,fa7));

                <span class="keywordflow">for</span> (comp=0; comp&lt;nb_comp; comp++)
                  {
<span class="comment">// Calcul de la valeur de l&#39;inconnue aux points d&#39;integration de la formule 3D</span>
                    inco_m=transporteVect[face_amont*nb_comp+comp];
                    <span class="keywordflow">for</span>(dim=0; dim&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>; dim++)
                      inco_m+=gradient_elem(elem,comp,dim)*vecteur_face_facette(elem,fa7,dim,dir);

                    inco_s=transporteVect[face_amont*nb_comp+comp];
                    <span class="keywordflow">for</span>(dim=0; dim&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>; dim++)
                      inco_s+=gradient_elem(elem,comp,dim)*(coord_sommets(s,dim)-xv(face_amont,dim));

                    inco_s2=transporteVect[face_amont*nb_comp+comp];
                    <span class="keywordflow">for</span>(dim=0; dim&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>; dim++)
                      inco_s2+=gradient_elem(elem,comp,dim)*(coord_sommets(s2,dim)-xv(face_amont,dim));

                    inco_c=3.*inco_m-inco_s-inco_s2;

<span class="comment">// Calcul du flux final : formule d&#39;integration 3D exacte pour les polynomes de degre 2</span>
                    flux=(inco_s+inco_s2)*(psc_s+psc_s2);
                    flux+=(inco_s+inco_c)*(psc_s+psc_c);
                    flux+=(inco_s2+inco_c)*(psc_s2+psc_c);
                    flux/=12.;

<span class="comment">// Fij(elem,facei_loc,facej_loc,comp) est le flux recu par la facei_loc dans elem</span>
<span class="comment">// envoye par la face facej_loc dans elem pour la composante comp de l&#39;inconnue</span>
                    Fij(elem,facei_loc,facej_loc,comp)=flux-psc_m*transporteVect[facei*nb_comp+comp];
                    Fij(elem,facej_loc,facei_loc,comp)=psc_m*transporteVect[facej*nb_comp+comp]-flux;
                  }
              }
          <span class="keywordflow">else</span> <span class="comment">//rang!=-1</span>
            <span class="keywordflow">for</span> (fa7=0; fa7&lt;nfa7; fa7++)
              {
                facei_loc=KEL(0,fa7);
                facej_loc=KEL(1,fa7);

                facei=face(facei_loc);
                facej=face(facej_loc);

<span class="comment">// REMARQUE : ON N&#39;OUBLIE PAS QUE LES NORMALES FA7 SONT ORIENTeES DE FACE_LOCI VERS FACE_LOCJ PAR DEFAUT</span>
<span class="comment">// LES PRODUITS SCALAIRES PSC_M, PSC_C, PSC_S, PSC_S2 SONT DONC CALCULeS POUR OBTENIR LE FLUX REcU PAR LA FACE FACE_LOCI</span>
<span class="comment">// ET EMIS PAR LA FACE_LOCJ</span>
<span class="comment">// SI L&#39;ON VEUT OBTENIR LE FLUX REcU PAR LA FACE FACE_LOCJ ET EMIS PAR LA FACE_LOCI, IL FAUT MULTIPLIER LES</span>
<span class="comment">// PRODUITS SCALAIRES PSC_M, PSC_C, PSC_S, PSC_S2 PAR -1 POUR IMPLICITEMENT ReORIENTER LES NORMALES FA7 DE FACE_LOCJ VERS</span>
<span class="comment">// FACE_LOCI</span>
<span class="comment">// MEME REMARQUE POUR LE SCALAIRE &quot;FLUX&quot;</span>
                <span class="keyword">const</span> <span class="keywordtype">double</span>&amp; psc_c = Cij(elem,fa7);
                <span class="keyword">const</span> <span class="keywordtype">double</span>&amp; psc_s = Sij(elem,fa7);
                <span class="keyword">const</span> <span class="keywordtype">double</span>&amp; psc_s2 = Sij2(elem,fa7);
                <span class="keyword">const</span> <span class="keywordtype">double</span>&amp; psc_m = Kij(elem,facei_loc,facej_loc);

                <span class="keywordflow">if</span> (psc_m&gt;=0.)
                  face_amont=facei,dir=0;
                <span class="keywordflow">else</span>
                  face_amont=facej,dir=1;

                s=zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#aa164c00997bc77a365a6da57bbec29ce" title="Renvoie le numero (global) j-ieme sommet du i-ieme element.">sommet_elem</a>(elem,KEL(2,fa7));
                s2=zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#aa164c00997bc77a365a6da57bbec29ce" title="Renvoie le numero (global) j-ieme sommet du i-ieme element.">sommet_elem</a>(elem,KEL(3,fa7));

                <span class="keywordflow">for</span> (comp=0; comp&lt;nb_comp; comp++)
                  {
<span class="comment">// Calcul de la valeur de l&#39;inconnue aux points d&#39;integration de la formule 3D</span>
                    inco_m=transporteVect[face_amont*nb_comp+comp];
                    <span class="keywordflow">for</span>(dim=0; dim&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>; dim++)
                      inco_m+=gradient_elem(elem,comp,dim)*vecteur_face_facette_Cl(rang,fa7,dim,dir);

                    inco_s=transporteVect[face_amont*nb_comp+comp];
                    <span class="keywordflow">for</span>(dim=0; dim&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>; dim++)
                      inco_s+=gradient_elem(elem,comp,dim)*(coord_sommets(s,dim)-xv(face_amont,dim));

                    inco_s2=transporteVect[face_amont*nb_comp+comp];
                    <span class="keywordflow">for</span>(dim=0; dim&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>; dim++)
                      inco_s2+=gradient_elem(elem,comp,dim)*(coord_sommets(s2,dim)-xv(face_amont,dim));

                    inco_c=3.*inco_m-inco_s-inco_s2;

<span class="comment">// Calcul du flux final : formule d&#39;integration 3D exacte pour les polynomes de degre 2</span>
                    flux=(inco_s+inco_s2)*(psc_s+psc_s2);
                    flux+=(inco_s+inco_c)*(psc_s+psc_c);
                    flux+=(inco_s2+inco_c)*(psc_s2+psc_c);
                    flux/=12.;

<span class="comment">// Fij(elem,facei_loc,facej_loc,comp) est le flux recu par la facei_loc dans elem</span>
<span class="comment">// envoye par la face facej_loc dans elem pour la composante comp de l&#39;inconnue</span>
                    Fij(elem,facei_loc,facej_loc,comp)=flux-psc_m*transporteVect[facei*nb_comp+comp];
                    Fij(elem,facej_loc,facei_loc,comp)=psc_m*transporteVect[facej*nb_comp+comp]-flux;
                  }
              }
        }<span class="comment">//fin Objet_U::dimension==3</span>
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a62e58f1cd47b3865342a3b37fb1a06df"></a><!-- doxytag: member="Op_Conv_Muscl_New_VEF_Face::calculer_senseur_v1" ref="a62e58f1cd47b3865342a3b37fb1a06df" args="(const DoubleTab &amp;, const DoubleTab &amp;, const DoubleVect &amp;, const int &amp;, const int &amp;, const IntTab &amp;, const IntTab &amp;, const IntTab &amp;, ArrOfDouble &amp;, ArrOfDouble &amp;, ArrOfDouble &amp;, ArrOfDouble &amp;) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Op_Conv_Muscl_New_VEF_Face::calculer_senseur_v1 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>Kij</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>Fij</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;&#160;</td>
          <td class="paramname"><em>transporteV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>nb_comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>face_i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIntTab.html">IntTab</a> &amp;&#160;</td>
          <td class="paramname"><em>elem_faces</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIntTab.html">IntTab</a> &amp;&#160;</td>
          <td class="paramname"><em>face_voisins</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIntTab.html">IntTab</a> &amp;&#160;</td>
          <td class="paramname"><em>num_fac_loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;&#160;</td>
          <td class="paramname"><em>P_plus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;&#160;</td>
          <td class="paramname"><em>P_moins</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;&#160;</td>
          <td class="paramname"><em>Q_plus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;&#160;</td>
          <td class="paramname"><em>Q_moins</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inline, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8cpp_source.html#l02043">2043</a> of file <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8cpp_source.html">Op_Conv_Muscl_New_VEF_Face.cpp</a>.</p>

<p>References <a class="el" href="IntTab_8h_source.html#l00233">IntTab::dimension()</a>, and <a class="el" href="ArrOfDouble_8h_source.html#l00350">ArrOfDouble::size_array()</a>.</p>

<p>Referenced by <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8cpp_source.html#l01828">ajouter_antidiffusion_v1()</a>, and <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8cpp_source.html#l01984">calculer_senseur_v2()</a>.</p>
<div class="fragment"><pre class="fragment">{
  assert(P_plus.<a class="code" href="classArrOfDouble.html#a3c3b33bea0e88b87315c21ee94bee05f" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>()==nb_comp);
  assert(Q_plus.<a class="code" href="classArrOfDouble.html#a3c3b33bea0e88b87315c21ee94bee05f" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>()==nb_comp);
  assert(P_moins.<a class="code" href="classArrOfDouble.html#a3c3b33bea0e88b87315c21ee94bee05f" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>()==nb_comp);
  assert(Q_moins.<a class="code" href="classArrOfDouble.html#a3c3b33bea0e88b87315c21ee94bee05f" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>()==nb_comp);

  <span class="keywordtype">double</span> inci=0.;
  <span class="keywordtype">double</span> inck=0.;

  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_faces_elem=elem_faces.<a class="code" href="classIntTab.html#abc3b32c94925a82f69d5b153a356e359" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(1);
  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> elem_voisin=0; elem_voisin&lt;2; elem_voisin++)
    {
      <span class="keywordtype">int</span> elem = face_voisins(face_i,elem_voisin);
      <span class="keywordflow">if</span> (elem!=-1)
        {
          <span class="keywordtype">int</span> face_i_loc = num_fac_loc(face_i,elem_voisin);
          assert(face_i_loc&gt;=0);
          assert(face_i_loc&lt;nb_faces_elem);

<span class="comment">// On travaille sur les faces de &quot;elem&quot;</span>
          <span class="keywordflow">for</span> (<span class="keywordtype">int</span> face_k_loc=0; face_k_loc&lt;nb_faces_elem; face_k_loc++)
            {
              <span class="keywordtype">int</span> face_k=elem_faces(elem,face_k_loc);
              <span class="keywordtype">double</span> kik=Kij(elem,face_i_loc,face_k_loc);
<span class="comment">// </span>
<span class="comment">// Calcul des variables intermediaires</span>
<span class="comment">// </span>
              <span class="keywordflow">for</span> (<span class="keywordtype">int</span> dim=0; dim&lt;nb_comp; dim++)
                {
                  inci=transporteV[face_i*nb_comp+dim];
                  inck=transporteV[face_k*nb_comp+dim];

                  <span class="keywordtype">double</span> fik_low=kik*(inck-inci);
                  <span class="keywordtype">double</span> fik_high=Fij(elem,face_i_loc,face_k_loc,dim);

<span class="comment">// Codage optimise:</span>
                  <span class="keywordflow">if</span> (kik&lt;0)
                    {
                      <span class="keywordflow">if</span> (fik_low&gt;0) Q_plus(dim)+=fik_low;
                      <span class="keywordflow">else</span>       Q_moins(dim)+=fik_low;
                    }
                  <span class="keywordflow">else</span>
                    {
                      <span class="keywordflow">if</span> (fik_high&gt;0) P_plus(dim)+=fik_high;
                      <span class="keywordflow">else</span>       P_moins(dim)+=fik_high;
                    }
                  assert(P_plus(dim)&gt;=0);
                  assert(Q_plus(dim)&gt;=0);
                  assert(P_moins(dim)&lt;=0);
                  assert(Q_moins(dim)&lt;=0);
                }<span class="comment">//fin du for sur &quot;dim&quot;</span>
<span class="comment">// </span>
<span class="comment">// Fin du calcul des variables intermediaires</span>
<span class="comment">// </span>
            }<span class="comment">//fin du for sur &quot;face_k_loc&quot;</span>
        }<span class="comment">//fin du if sur &quot;elem!=-1&quot;</span>
    }<span class="comment">//fin du for sur &quot;elem_voisin&quot;</span>
}
</pre></div>
</div>
</div>
<a class="anchor" id="a2032486fe36dd90a3ae2bffcc16569c0"></a><!-- doxytag: member="Op_Conv_Muscl_New_VEF_Face::calculer_senseur_v2" ref="a2032486fe36dd90a3ae2bffcc16569c0" args="(const DoubleTab &amp;, const DoubleTab &amp;, const DoubleVect &amp;, const int &amp;, const int &amp;, const IntTab &amp;, const IntTab &amp;, const IntTab &amp;, ArrOfDouble &amp;, ArrOfDouble &amp;, ArrOfDouble &amp;, ArrOfDouble &amp;) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Op_Conv_Muscl_New_VEF_Face::calculer_senseur_v2 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>Kij</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>Fij</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;&#160;</td>
          <td class="paramname"><em>transporteV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>nb_comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>face_i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIntTab.html">IntTab</a> &amp;&#160;</td>
          <td class="paramname"><em>elem_faces</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIntTab.html">IntTab</a> &amp;&#160;</td>
          <td class="paramname"><em>face_voisins</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIntTab.html">IntTab</a> &amp;&#160;</td>
          <td class="paramname"><em>num_fac_loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;&#160;</td>
          <td class="paramname"><em>P_plus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;&#160;</td>
          <td class="paramname"><em>P_moins</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;&#160;</td>
          <td class="paramname"><em>Q_plus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;&#160;</td>
          <td class="paramname"><em>Q_moins</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inline, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8cpp_source.html#l01984">1984</a> of file <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8cpp_source.html">Op_Conv_Muscl_New_VEF_Face.cpp</a>.</p>

<p>References <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8cpp_source.html#l02043">calculer_senseur_v1()</a>.</p>

<p>Referenced by <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8cpp_source.html#l01699">ajouter_antidiffusion_v2()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#a62e58f1cd47b3865342a3b37fb1a06df">calculer_senseur_v1</a>(Kij,Fij,transporteV,nb_comp,face_i,elem_faces,face_voisins,num_fac_loc,P_plus,P_moins,Q_plus,Q_moins);

<span class="comment">// assert(P_plus.size_array()==nb_comp);</span>
<span class="comment">// assert(Q_plus.size_array()==nb_comp);</span>
<span class="comment">// assert(P_moins.size_array()==nb_comp);</span>
<span class="comment">// assert(Q_moins.size_array()==nb_comp);</span>

<span class="comment">// const int nb_faces_elem=elem_faces.dimension(1);</span>
<span class="comment">// for (int elem_voisin=0; elem_voisin&lt;2; elem_voisin++)</span>
<span class="comment">// {</span>
<span class="comment">// int elem = face_voisins(face_i,elem_voisin);</span>
<span class="comment">// if (elem!=-1)</span>
<span class="comment">// {</span>
<span class="comment">// int face_i_loc = num_fac_loc(face_i,elem_voisin);</span>
<span class="comment">// assert(face_i_loc&gt;=0);</span>
<span class="comment">// assert(face_i_loc&lt;nb_faces_elem);</span>
<span class="comment">// //On travaille sur les faces de &quot;elem&quot;</span>
<span class="comment">// for (int face_k_loc=0; face_k_loc&lt;nb_faces_elem; face_k_loc++)</span>
<span class="comment">// {</span>
<span class="comment">// double kik=Kij(elem,face_i_loc,face_k_loc);</span>
<span class="comment">// //</span>
<span class="comment">// //Calcul des variables intermediaires</span>
<span class="comment">// //</span>
<span class="comment">// for (int dim=0; dim&lt;nb_comp; dim++)</span>
<span class="comment">// {</span>
<span class="comment">// double fik=Fij(elem,face_i_loc,face_k_loc,dim);</span>

<span class="comment">// // Codage optimise:</span>
<span class="comment">// if (kik&lt;0)</span>
<span class="comment">// {</span>
<span class="comment">// if (fik&gt;0) Q_plus(dim)+=fik;</span>
<span class="comment">// else       Q_moins(dim)+=fik;</span>
<span class="comment">// }</span>
<span class="comment">// else</span>
<span class="comment">// {</span>
<span class="comment">// if (fik&gt;0) P_plus(dim)+=fik;</span>
<span class="comment">// else       P_moins(dim)+=fik;</span>
<span class="comment">// }</span>
<span class="comment">// assert(P_plus(dim)&gt;=0);</span>
<span class="comment">// assert(Q_plus(dim)&gt;=0);</span>
<span class="comment">// assert(P_moins(dim)&lt;=0);</span>
<span class="comment">// assert(Q_moins(dim)&lt;=0);</span>
<span class="comment">// }//fin du for sur &quot;dim&quot;</span>
<span class="comment">// //</span>
<span class="comment">// //Fin du calcul des variables intermediaires</span>
<span class="comment">// //</span>
<span class="comment">// }//fin du for sur &quot;face_k_loc&quot;</span>
<span class="comment">// }//fin du if sur &quot;elem!=-1&quot;</span>
<span class="comment">// }//fin du for sur &quot;elem_voisin&quot;</span>
}
</pre></div>
</div>
</div>
<a class="anchor" id="aa314b43d428161f096acbd9dfb8b6634"></a><!-- doxytag: member="Op_Conv_Muscl_New_VEF_Face::completer" ref="aa314b43d428161f096acbd9dfb8b6634" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Op_Conv_Muscl_New_VEF_Face::completer </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Associe l'operateur a la zone_dis, la zone_Cl_dis,<br/>
et a l'inconnue de son equation. </p>

<p><p>&lt; pour ajout _Mx (moment) </p>
</p>

<p>Reimplemented from <a class="el" href="classOperateur__base.html#a9560967884361b918b12a67813476608">Operateur_base</a>.</p>

<p>Definition at line <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8cpp_source.html#l02311">2311</a> of file <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8cpp_source.html">Op_Conv_Muscl_New_VEF_Face.cpp</a>.</p>

<p>References <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8h_source.html#l00119">alpha_</a>, <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8h_source.html#l00115">alpha_tab</a>, <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8h_source.html#l00116">beta</a>, <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8cpp_source.html#l02226">calculer_data_pour_dirichlet()</a>, <a class="el" href="Op__Conv__VEF__base_8h_source.html#l00092">Op_Conv_VEF_base::la_zone_vef</a>, and <a class="el" href="ArrOfDouble_8h_source.html#l00244">ArrOfDouble::resize_array()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#aa314b43d428161f096acbd9dfb8b6634" title="Associe l&#39;operateur a la zone_dis, la zone_Cl_dis, et a l&#39;inconnue de son equation.">Op_Conv_VEF_Face::completer</a>();
  <a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#a4ff4bc26b4f14df5174c4682f2ec580b">calculer_data_pour_dirichlet</a>();

<span class="comment">// int nb_comp=1;</span>
<span class="comment">// if (equation().inconnue().valeurs().nb_dim()&gt;1)</span>
<span class="comment">// nb_comp=equation().inconnue().valeurs().dimension(1);</span>

<span class="comment">// limiteurs_.resize(la_zone_vef-&gt;nb_faces_tot(),nb_comp);</span>
<span class="comment">// limiteurs_=0.;</span>

  <a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#a5477f9154396fb7e43a71d40c0689e78">alpha_tab</a>.<a class="code" href="classArrOfDouble.html#a610464f4b3dccac6f814915b526783ed">resize_array</a>(<a class="code" href="classOp__Conv__VEF__base.html#a6c29a488a6805ba4a9f2f059cdba77ae">la_zone_vef</a>-&gt;nb_faces_tot());
  <a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#a5477f9154396fb7e43a71d40c0689e78">alpha_tab</a> = <a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#aba93a9d2fdc68f373410c6439c95074c">alpha_</a>;

  <a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#a809512967978e8fbb8cb99a54cd17594" title="vaut zero pour les faces ou l&#39;on souhaite degenerer en Amont. mutable DoubleTab limiteurs_;//tableau ...">beta</a>.<a class="code" href="classArrOfDouble.html#a610464f4b3dccac6f814915b526783ed">resize_array</a>(<a class="code" href="classOp__Conv__VEF__base.html#a6c29a488a6805ba4a9f2f059cdba77ae">la_zone_vef</a>-&gt;nb_faces_tot());
  <a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#a809512967978e8fbb8cb99a54cd17594" title="vaut zero pour les faces ou l&#39;on souhaite degenerer en Amont. mutable DoubleTab limiteurs_;//tableau ...">beta</a>=1.;

<span class="comment">// if (sous_zone) {</span>
<span class="comment">// sous_zone=false;</span>
<span class="comment">// const Sous_Zone&amp; la_sous_zone=equation().probleme().domaine().ss_zone(nom_sous_zone);</span>
<span class="comment">// const Domaine_dis&amp; le_domaine_dis=la_zone_vef-&gt;domaine_dis();</span>
<span class="comment">// for (int ssz=0;ssz&lt;le_domaine_dis.nombre_de_sous_zones_dis();ssz++) {</span>
<span class="comment">// if (le_domaine_dis.sous_zone_dis(ssz)-&gt;sous_zone().est_egal_a(la_sous_zone)) {</span>
<span class="comment">// sous_zone=true;</span>
<span class="comment">// la_sous_zone_dis=ref_cast(Sous_zone_VF,le_domaine_dis.sous_zone_dis(ssz).valeur());</span>
<span class="comment">// }</span>
<span class="comment">// }</span>

<span class="comment">// if(!sous_zone) {</span>
<span class="comment">// Cerr &lt;&lt; &quot;On ne trouve pas la sous_zone discretisee associee a &quot; &lt;&lt; nom_sous_zone &lt;&lt; finl;</span>
<span class="comment">// Process::exit();</span>
<span class="comment">// }</span>

<span class="comment">// const Sous_zone_VF&amp; ssz=la_sous_zone_dis.valeur();</span>
<span class="comment">// int nb_faces = ssz.les_faces().size();</span>

<span class="comment">// for (int face=0;face&lt;nb_faces;face++) {</span>
<span class="comment">// int la_face=ssz.les_faces()[face];</span>
<span class="comment">// beta(la_face) = 0.;</span>
<span class="comment">// alpha_tab(la_face) = 1.;</span>
<span class="comment">// }</span>
<span class="comment">// }</span>

}
</pre></div>
</div>
</div>
<a class="anchor" id="acb80c8643054dda4979c7b94d6f28bbf"></a><!-- doxytag: member="Op_Conv_Muscl_New_VEF_Face::contribuer_a_avec" ref="acb80c8643054dda4979c7b94d6f28bbf" args="(const DoubleTab &amp;, Matrice_Morse &amp;) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Op_Conv_Muscl_New_VEF_Face::contribuer_a_avec </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>inco</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;&#160;</td>
          <td class="paramname"><em>matrice</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>on assemble la matrice des inconnues implicite. </p>

<p>Reimplemented from <a class="el" href="classOp__Conv__VEF__Face.html#a27f891883f7b38b525b59d38d3f97ef3">Op_Conv_VEF_Face</a>.</p>

<p>Definition at line <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8h_source.html#l00136">136</a> of file <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8h_source.html">Op_Conv_Muscl_New_VEF_Face.h</a>.</p>

<p>References <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8cpp_source.html#l02357">ajouter_contribution()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#abac773d46607384fdecf846d33a9c3c5">ajouter_contribution</a>(inco, matrice);
}
</pre></div>
</div>
</div>
<a class="anchor" id="ad2aaff32ae487ec536e6fba1361558b6"></a><!-- doxytag: member="Op_Conv_Muscl_New_VEF_Face::cree_instance" ref="ad2aaff32ae487ec536e6fba1361558b6" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classObjet__U.html">Objet_U</a> * Op_Conv_Muscl_New_VEF_Face::cree_instance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="classOp__Conv__VEF__Face.html#a95e421a79f78a63f6fc31001e480b801">Op_Conv_VEF_Face</a>.</p>

<p>Definition at line <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8cpp_source.html#l00074">74</a> of file <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8cpp_source.html">Op_Conv_Muscl_New_VEF_Face.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8cb4fcb38968e497474dad4fdd1a9190"></a><!-- doxytag: member="Op_Conv_Muscl_New_VEF_Face::duplique" ref="a8cb4fcb38968e497474dad4fdd1a9190" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Op_Conv_Muscl_New_VEF_Face::duplique </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="classOp__Conv__VEF__Face.html#a730ff7f720a85346c2e64d887d2e83a3">Op_Conv_VEF_Face</a>.</p>

<p>Definition at line <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8cpp_source.html#l00074">74</a> of file <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8cpp_source.html">Op_Conv_Muscl_New_VEF_Face.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4bf8a3114c691efecfc752810cc524e0"></a><!-- doxytag: member="Op_Conv_Muscl_New_VEF_Face::get_info" ref="a4bf8a3114c691efecfc752810cc524e0" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classType__info.html">Type_info</a> * Op_Conv_Muscl_New_VEF_Face::get_info </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Donne des informations sur le type de l'Objet_U. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>const Type_info*<br/>
 Signification: structure regroupant les informations sur le type de l'Objet_U<br/>
 Contraintes: </dd></dl>

<p>Reimplemented from <a class="el" href="classOp__Conv__VEF__Face.html#a7956413d25ad3f47537c18be89fa8a93">Op_Conv_VEF_Face</a>.</p>

<p>Definition at line <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8cpp_source.html#l00074">74</a> of file <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8cpp_source.html">Op_Conv_Muscl_New_VEF_Face.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8bf367586ce23a9a6c8f77d4db6bfb77"></a><!-- doxytag: member="Op_Conv_Muscl_New_VEF_Face::info" ref="a8bf367586ce23a9a6c8f77d4db6bfb77" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classType__info.html">Type_info</a> * Op_Conv_Muscl_New_VEF_Face::info </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Donne des informations sur le type de l'Objet_U. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>const Type_info*<br/>
 Signification: structure regroupant les informations sur le type de l'Objet_U<br/>
 Contraintes: </dd></dl>

<p>Reimplemented from <a class="el" href="classOp__Conv__VEF__Face.html#a96dd257161111f4a1bc7028456c16da4">Op_Conv_VEF_Face</a>.</p>

<p>Definition at line <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8cpp_source.html#l00074">74</a> of file <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8cpp_source.html">Op_Conv_Muscl_New_VEF_Face.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8c4ed1e4af546190554416a6129a730c"></a><!-- doxytag: member="Op_Conv_Muscl_New_VEF_Face::is_compressible" ref="a8c4ed1e4af546190554416a6129a730c" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Op_Conv_Muscl_New_VEF_Face::is_compressible </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8h_source.html#l00142">142</a> of file <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8h_source.html">Op_Conv_Muscl_New_VEF_Face.h</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">return</span> 1;<span class="comment">/* is_compressible_; */</span>
}
</pre></div>
</div>
</div>
<a class="anchor" id="a98bafc0524994d1bba96aff4b28540b8"></a><!-- doxytag: member="Op_Conv_Muscl_New_VEF_Face::mettre_a_jour_pour_periodicite" ref="a98bafc0524994d1bba96aff4b28540b8" args="(const DoubleTab &amp;, const DoubleTab &amp;, DoubleTab &amp;) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Op_Conv_Muscl_New_VEF_Face::mettre_a_jour_pour_periodicite </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>Kij</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>transporte</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>resu</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8cpp_source.html#l02128">2128</a> of file <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8cpp_source.html">Op_Conv_Muscl_New_VEF_Face.cpp</a>.</p>

<p>References <a class="el" href="DoubleTab_8h_source.html#l00243">DoubleTab::dimension()</a>, <a class="el" href="Periodique_8h_source.html#l00056">Periodique::face_associee()</a>, <a class="el" href="Zone__VF_8h_source.html#l00458">Zone_VF::face_voisins()</a>, <a class="el" href="Cond__lim_8h_source.html#l00130">Cond_lim::frontiere_dis()</a>, <a class="el" href="Zone__VF_8h_source.html#l00176">Zone_VF::get_num_fac_loc()</a>, <a class="el" href="Op__Conv__VEF__base_8h_source.html#l00093">Op_Conv_VEF_base::la_zcl_vef</a>, <a class="el" href="Op__Conv__VEF__base_8h_source.html#l00092">Op_Conv_VEF_base::la_zone_vef</a>, <a class="el" href="Zone__Cl__dis__base_8cpp_source.html#l00522">Zone_Cl_dis_base::les_conditions_limites()</a>, <a class="el" href="Zone__Cl__dis__base_8cpp_source.html#l00603">Zone_Cl_dis_base::nb_cond_lim()</a>, <a class="el" href="DoubleTab_8h_source.html#l00264">DoubleTab::nb_dim()</a>, <a class="el" href="Front__VF_8h_source.html#l00061">Front_VF::nb_faces()</a>, <a class="el" href="Front__VF_8h_source.html#l00076">Front_VF::num_face()</a>, <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8h_source.html#l00124">old_centered_</a>, <a class="el" href="Cast_8h_source.html#l00059">ref_cast</a>, <a class="el" href="Cast_8h_source.html#l00054">sub_type</a>, <a class="el" href="Cond__lim_8h_source.html#l00031">Deriv_Cond_lim_base::valeur()</a>, <a class="el" href="Ref__Zone__Cl__VEF_8h_source.html#l00028">Ref_Zone_Cl_VEF::valeur()</a>, and <a class="el" href="Ref__Zone__VEF_8h_source.html#l00028">Ref_Zone_VEF::valeur()</a>.</p>

<p>Referenced by <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8cpp_source.html#l01029">ajouter()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">const</span> <a class="code" href="classZone__VEF.html" title="class Zone_VEF Classe instanciable qui derive de Zone_VF. Cette classe contient les informations geom...">Zone_VEF</a>&amp; zone_VEF=<a class="code" href="classOp__Conv__VEF__base.html#a6c29a488a6805ba4a9f2f059cdba77ae">la_zone_vef</a>.<a class="code" href="classRef__Zone__VEF.html#aafd9a5ee1a76f290c9c6b5447b0c8d30">valeur</a>();
  <span class="keyword">const</span> <a class="code" href="classZone__Cl__VEF.html">Zone_Cl_VEF</a>&amp; zone_Cl_VEF = <a class="code" href="classOp__Conv__VEF__base.html#a03f677ee7911706a4f85cd37e0ca4535">la_zcl_vef</a>.<a class="code" href="classRef__Zone__Cl__VEF.html#a0970d7253def65ad4f0c5ce1830fd243">valeur</a>();

  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_bord = zone_Cl_VEF.<a class="code" href="classZone__Cl__dis__base.html#aa6f1df56cfd6e2eae83cc991c7cc9b41" title="Renvoie le nombre de conditions aux limites.">nb_cond_lim</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_comp = (resu.<a class="code" href="classDoubleTab.html#ae6dda48778e7107e1beb723beef1f75b" title="Returns the number of dimensions of the array (&gt;= 1)">nb_dim</a>()==1) ? 1 : resu.<a class="code" href="classDoubleTab.html#ac3805e2637a3b880ba2d3e650c69dac4" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(1);

  <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; transporteV=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classDoubleVect.html">DoubleVect</a>,transporte);
  <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; resuV=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classDoubleVect.html">DoubleVect</a>,resu);

  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; face_voisins=zone_VEF.<a class="code" href="classZone__VF.html#a49d4322f5585a8fa95748ca785b70702" title="renvoie l&#39;element voisin de numface dans la direction i. i=0 : dans le sens oppose de l&#39;axe orthogona...">face_voisins</a>();
  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; num_fac_loc = zone_VEF.<a class="code" href="classZone__VF.html#a95113b10f16f37600ba81d3fb41102b2">get_num_fac_loc</a>();

  <span class="keywordtype">int</span> ligne=0,ligneAss=0;
  <span class="keywordtype">int</span> facei=0,faceiAss=0;
  <span class="keywordtype">int</span> ind_face=0;
  <span class="keywordtype">int</span> num1=0,num2=0;
  <span class="keywordtype">int</span> ind_face_associee=0;
  <span class="keywordtype">int</span> dim=0;
  <span class="keywordtype">int</span> elem=-1;
  <span class="keywordtype">int</span> facei_loc=-1;

  <span class="keywordtype">double</span> kii=0.;
  <span class="keywordtype">double</span> tmp=0.;

<span class="comment">// Faces de bord</span>
  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> n_bord=0; n_bord&lt;nb_bord; n_bord++)
    {
      <span class="keyword">const</span> <a class="code" href="classCond__lim.html" title="classe Cond_lim Classe generique servant a representer n&#39;importe quelle classe derivee de la classe C...">Cond_lim</a>&amp; la_cl = zone_Cl_VEF.<a class="code" href="classZone__Cl__dis__base.html#af75e0ed7786863e4d333bfb29d67c323" title="Renvoie la i-ieme condition aux limites. (version const)">les_conditions_limites</a>(n_bord);
      <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp; le_bord = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>,la_cl.<a class="code" href="classCond__lim.html#a5b2d24809cee07727006a891d4ce8d22" title="Appel a l&#39;objet sous-jacent Renvoie la frontiere discretisee associee a la condition aux limites...">frontiere_dis</a>());
      num1=0;
      num2=le_bord.<a class="code" href="classFront__VF.html#a341e2fcb5117b96e745fd7078ba86bab" title="Nombre de faces reelles du bord.">nb_faces</a>();

      <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>()))
        {
          <span class="keyword">const</span> <a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>&amp; la_cl_perio = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>());

          <span class="keywordflow">for</span> (ind_face=num1; ind_face&lt;num2; ind_face++)
            {
              facei=le_bord.<a class="code" href="classFront__VF.html#a3402a19d7e54ed797d2b18e9a47ead1e" title="Renvoie le numero de face de la ieme face du bord.">num_face</a>(ind_face);
              ind_face_associee=la_cl_perio.<a class="code" href="classPeriodique.html#a207b86556f199a63ea059b841851ca6a">face_associee</a>(ind_face);
              faceiAss=le_bord.<a class="code" href="classFront__VF.html#a3402a19d7e54ed797d2b18e9a47ead1e" title="Renvoie le numero de face de la ieme face du bord.">num_face</a>(ind_face_associee);

              <span class="keywordflow">if</span> (facei&lt;faceiAss)
                <span class="keywordflow">for</span> (dim=0; dim&lt;nb_comp; dim++)
                  {
                    ligne=facei*nb_comp+dim;
                    ligneAss=faceiAss*nb_comp+dim;

                    resuV[ligneAss]+=resuV[ligne];
                    resuV[ligne]=resuV[ligneAss];
                  }

              <span class="keywordflow">if</span> (<a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#af27e616d4be292efae0dcd25ef29278c">old_centered_</a>)
                {
<span class="comment">// Pour le 1er element voisin</span>
                  elem=face_voisins(facei,0);
                  facei_loc=-1;
                  facei_loc=num_fac_loc(facei,0);
                  assert(facei_loc!=-1);
                  kii=Kij(elem,facei_loc,facei_loc);

<span class="comment">// Pour le 2eme element voisin</span>
                  elem=face_voisins(facei,1);
                  facei_loc=-1;
                  facei_loc=num_fac_loc(facei,1);
                  assert(facei_loc!=-1);
                  kii+=Kij(elem,facei_loc,facei_loc);

                  <span class="keywordflow">for</span> (dim=0; dim&lt;nb_comp; dim++)
                    {
                      ligne=facei*nb_comp+dim;
                      ligneAss=faceiAss*nb_comp+dim;

                      tmp=kii*transporteV[ligneAss];
                      resuV[ligneAss]-=tmp;
                      resuV[ligne]-=tmp;
                    }
                }

            }<span class="comment">//fin du for sur &quot;face_i&quot;</span>

        }<span class="comment">//fin du if sur &quot;Periodique&quot;</span>

    }<span class="comment">//fin du for sur &quot;n_bord&quot;</span>
}
</pre></div>
</div>
</div>
<a class="anchor" id="aea685b2416b3023598d337ab366512cb"></a><!-- doxytag: member="Op_Conv_Muscl_New_VEF_Face::modifier_flux_operateur_centre" ref="aea685b2416b3023598d337ab366512cb" args="(DoubleTab &amp;, const DoubleTab &amp;, const DoubleTab &amp;, const DoubleTab &amp;, const DoubleTab &amp;, const int &amp;, const DoubleTab &amp;, const DoubleTab &amp;) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Op_Conv_Muscl_New_VEF_Face::modifier_flux_operateur_centre </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>Fij</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>Kij</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>Cij</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>Sij</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>Sij2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>nb_comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>velocity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>transporte</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>&lt; (du/dx du/dy dv/dx dv/dy) pour un poly gradient_elem=0.; </p>
</p>

<p>Definition at line <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8cpp_source.html#l00859">859</a> of file <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8cpp_source.html">Op_Conv_Muscl_New_VEF_Face.cpp</a>.</p>

<p>References <a class="el" href="Champ__P1NC_8cpp_source.html#l00940">Champ_P1NC::calcul_gradient()</a>, <a class="el" href="DoubleTab_8h_source.html#l00243">DoubleTab::dimension()</a>, <a class="el" href="Objet__U_8h_source.html#l00079">Objet_U::dimension</a>, <a class="el" href="IntTab_8h_source.html#l00233">IntTab::dimension()</a>, <a class="el" href="Zone__VF_8h_source.html#l00574">Zone_VF::elem_faces()</a>, <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8h_source.html#l00111">is_element_for_upwinding_</a>, <a class="el" href="Elem__VEF__base_8h_source.html#l00047">Elem_VEF_base::KEL()</a>, <a class="el" href="Op__Conv__VEF__base_8h_source.html#l00093">Op_Conv_VEF_base::la_zcl_vef</a>, <a class="el" href="Op__Conv__VEF__base_8h_source.html#l00092">Op_Conv_VEF_base::la_zone_vef</a>, <a class="el" href="DoubleTab_8h_source.html#l00264">DoubleTab::nb_dim()</a>, <a class="el" href="Zone__dis__base_8h_source.html#l00144">Zone_dis_base::nb_elem_tot()</a>, <a class="el" href="Elem__VEF_8h_source.html#l00083">Elem_VEF::nb_facette()</a>, <a class="el" href="Zone__VEF_8h_source.html#l00165">Zone_VEF::rang_elem_non_std()</a>, <a class="el" href="Cast_8h_source.html#l00059">ref_cast</a>, <a class="el" href="Cast_8h_source.html#l00062">ref_cast_non_const</a>, <a class="el" href="Zone__VEF_8h_source.html#l00138">Zone_VEF::type_elem()</a>, <a class="el" href="Elem__VEF_8h_source.html#l00041">Deriv_Elem_VEF_base::valeur()</a>, <a class="el" href="Ref__Zone__Cl__VEF_8h_source.html#l00028">Ref_Zone_Cl_VEF::valeur()</a>, <a class="el" href="Ref__Zone__VEF_8h_source.html#l00028">Ref_Zone_VEF::valeur()</a>, and <a class="el" href="Zone__Cl__VEF_8h_source.html#l00140">Zone_Cl_VEF::vecteur_face_facette_Cl()</a>.</p>

<p>Referenced by <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8cpp_source.html#l01029">ajouter()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">const</span> <a class="code" href="classZone__VEF.html" title="class Zone_VEF Classe instanciable qui derive de Zone_VF. Cette classe contient les informations geom...">Zone_VEF</a>&amp; zone_VEF = <a class="code" href="classOp__Conv__VEF__base.html#a6c29a488a6805ba4a9f2f059cdba77ae">la_zone_vef</a>.<a class="code" href="classRef__Zone__VEF.html#aafd9a5ee1a76f290c9c6b5447b0c8d30">valeur</a>();
  <span class="keyword">const</span> <a class="code" href="classZone__Cl__VEF.html">Zone_Cl_VEF</a>&amp; zone_Cl_VEF = <a class="code" href="classOp__Conv__VEF__base.html#a03f677ee7911706a4f85cd37e0ca4535">la_zcl_vef</a>.<a class="code" href="classRef__Zone__Cl__VEF.html#a0970d7253def65ad4f0c5ce1830fd243">valeur</a>();

  <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; vecteur_face_facette = <a class="code" href="Cast_8h.html#ad3836a067c92103af8df5ad8f35959a6">ref_cast_non_const</a>(<a class="code" href="classZone__VEF.html" title="class Zone_VEF Classe instanciable qui derive de Zone_VF. Cette classe contient les informations geom...">Zone_VEF</a>,zone_VEF).vecteur_face_facette();
  <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; vecteur_face_facette_Cl = zone_Cl_VEF.<a class="code" href="classZone__Cl__VEF.html#aa7acf4bf79e075ba2488e2ee9051c6fe">vecteur_face_facette_Cl</a>();

  <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; transporteVect=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classDoubleVect.html">DoubleVect</a>,transporte);

  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; elem_faces = zone_VEF.<a class="code" href="classZone__VF.html#a067e462dcd3ab92b0f6d945b19e4eb37" title="renvoie le numero de le ieme face de la maille num_elem la facon dont ces faces sont numerotees est l...">elem_faces</a>();
  <span class="keyword">const</span> <a class="code" href="classIntVect.html">IntVect</a>&amp; rang_elem_non_std = zone_VEF.<a class="code" href="classZone__VEF.html#a4b2171a85e5fc33663a3366acb713584">rang_elem_non_std</a>();
  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; KEL=zone_VEF.<a class="code" href="classZone__VEF.html#a46693c060b8096fb2595ca72192eea2a">type_elem</a>().<a class="code" href="classDeriv__Elem__VEF__base.html#a2886905d5071be902c77248b69ca0b7b">valeur</a>().<a class="code" href="classElem__VEF__base.html#ab129610ef702aa8c9c98dcb4c7551172">KEL</a>();

  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_elem_tot = zone_VEF.<a class="code" href="classZone__dis__base.html#a4d6aa445f152aa6dc54d66ea7a071147">nb_elem_tot</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_faces_elem=elem_faces.<a class="code" href="classIntTab.html#abc3b32c94925a82f69d5b153a356e359" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(1);
  <span class="keyword">const</span> <span class="keywordtype">int</span> nfa7 = zone_VEF.<a class="code" href="classZone__VEF.html#a46693c060b8096fb2595ca72192eea2a">type_elem</a>().<a class="code" href="classElem__VEF.html#a4a34777c0083b38dd34c8a400d5b4e90">nb_facette</a>();

  <span class="keywordtype">int</span> rang=-2;
  <span class="keywordtype">int</span> fa7=0;
  <span class="keywordtype">int</span> dim=-1;
  <span class="keywordtype">int</span> elem=0;
  <span class="keywordtype">int</span> face_amont=-1;
  <span class="keywordtype">int</span> dir=-1;
  <span class="keywordtype">int</span> comp=-1;
  <span class="keywordtype">int</span> facei=-1;
  <span class="keywordtype">int</span> facej=-1;
  <span class="keywordtype">int</span> facei_loc=-1;
  <span class="keywordtype">int</span> facej_loc=-1;

  <span class="keywordtype">double</span> inco_m=0.;
  <span class="keywordtype">double</span> flux=0.;

  <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a> gradient_elem(nb_elem_tot,nb_comp,<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>);  <span class="comment">//!&lt; (du/dx du/dy dv/dx dv/dy) pour un poly  gradient_elem=0.;</span>
<span class="comment"></span>  <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a> face(<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>+1);

  assert(Fij.<a class="code" href="classDoubleTab.html#ae6dda48778e7107e1beb723beef1f75b" title="Returns the number of dimensions of the array (&gt;= 1)">nb_dim</a>()==4);
  assert(Fij.<a class="code" href="classDoubleTab.html#ac3805e2637a3b880ba2d3e650c69dac4" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(0)==nb_elem_tot);
  assert(Fij.<a class="code" href="classDoubleTab.html#ac3805e2637a3b880ba2d3e650c69dac4" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(1)==Fij.<a class="code" href="classDoubleTab.html#ac3805e2637a3b880ba2d3e650c69dac4" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(2));
  assert(Fij.<a class="code" href="classDoubleTab.html#ac3805e2637a3b880ba2d3e650c69dac4" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(1)==nb_faces_elem);
  assert(Fij.<a class="code" href="classDoubleTab.html#ac3805e2637a3b880ba2d3e650c69dac4" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(3)==nb_comp);

<span class="comment">// </span>
<span class="comment">// Calcul des flux de l&#39;operateur</span>
<span class="comment">// </span>
  <a class="code" href="classChamp__P1NC.html#a87d96c073d3c127684934610f9a1e407">Champ_P1NC::calcul_gradient</a>(transporte,gradient_elem,zone_Cl_VEF);

  <span class="keywordflow">for</span>(elem=0; elem&lt;nb_elem_tot; elem++)
    {
      rang=rang_elem_non_std(elem);

      <span class="keywordflow">for</span> (facei_loc=0; facei_loc&lt;nb_faces_elem; facei_loc++)
        face(facei_loc)=elem_faces(elem,facei_loc);

<span class="comment">// RAZ des flux des elements a modifier</span>
      <span class="keywordflow">if</span> (<a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#a93e226d752c2b31d4b63e08840aea2cb">is_element_for_upwinding_</a>(elem))
        <span class="keywordflow">for</span> (facei_loc=0; facei_loc&lt;nb_faces_elem; facei_loc++)
          <span class="keywordflow">for</span> (facej_loc=0; facej_loc&lt;nb_faces_elem; facej_loc++)
            <span class="keywordflow">for</span> (comp=0; comp&lt;nb_comp; comp++)
              Fij(elem,facei_loc,facej_loc,comp)=0.;

      <span class="keywordflow">if</span> (<a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#a93e226d752c2b31d4b63e08840aea2cb">is_element_for_upwinding_</a>(elem))
        {
          <span class="keywordflow">if</span> (rang==-1)
            <span class="keywordflow">for</span> (fa7=0; fa7&lt;nfa7; fa7++)
              {
                facei_loc=KEL(0,fa7);
                facej_loc=KEL(1,fa7);

                facei=face(facei_loc);
                facej=face(facej_loc);

<span class="comment">// REMARQUE : ON N&#39;OUBLIE PAS QUE LES NORMALES FA7 SONT ORIENTeES DE FACE_LOCI VERS FACE_LOCJ PAR DEFAUT</span>
<span class="comment">// LE PRODUIT SCALAIRE PSC_M EST DONC CALCULe POUR OBTENIR LE FLUX REcU PAR LA FACE FACE_LOCI</span>
<span class="comment">// ET EMIS PAR LA FACE_LOCJ</span>
<span class="comment">// SI L&#39;ON VEUT OBTENIR LE FLUX REcU PAR LA FACE FACE_LOCJ ET EMIS PAR LA FACE_LOCI, IL FAUT MULTIPLIER LE</span>
<span class="comment">// PRODUIT SCALAIRE PSC_M PAR -1 POUR IMPLICITEMENT ReORIENTER LES NORMALES FA7 DE FACE_LOCJ VERS</span>
<span class="comment">// FACE_LOCI</span>
<span class="comment">// MEME REMARQUE POUR LE SCALAIRE &quot;FLUX&quot;</span>
                <span class="keyword">const</span> <span class="keywordtype">double</span>&amp; psc_m = Kij(elem,facei_loc,facej_loc);

                <span class="keywordflow">if</span> (psc_m&gt;=0.)
                  face_amont=facei,dir=0;
                <span class="keywordflow">else</span>
                  face_amont=facej,dir=1;

                <span class="keywordflow">for</span> (comp=0; comp&lt;nb_comp; comp++)
                  {
<span class="comment">// Calcul de la valeur de l&#39;inconnue aux points d&#39;integration de la formule du point milieu</span>
                    inco_m=transporteVect[face_amont*nb_comp+comp];
                    <span class="keywordflow">for</span>(dim=0; dim&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>; dim++)
                      inco_m+=gradient_elem(elem,comp,dim)*vecteur_face_facette(elem,fa7,dim,dir);

<span class="comment">// Calcul du flux final : formule du point milieu</span>
                    flux=inco_m*psc_m;

<span class="comment">// Fij(elem,facei_loc,facej_loc,comp) est le flux recu par la facei_loc dans elem</span>
<span class="comment">// envoye par la face facej_loc dans elem pour la composante comp de l&#39;inconnue</span>
                    Fij(elem,facei_loc,facej_loc,comp)=flux-psc_m*transporteVect[facei*nb_comp+comp];
                    Fij(elem,facej_loc,facei_loc,comp)=psc_m*transporteVect[facej*nb_comp+comp]-flux;
                  }
              }
        }
      <span class="keywordflow">else</span> <span class="comment">//rang!=-1</span>
        {
          <span class="keywordflow">for</span> (fa7=0; fa7&lt;nfa7; fa7++)
            {
              facei_loc=KEL(0,fa7);
              facej_loc=KEL(1,fa7);

              facei=face(facei_loc);
              facej=face(facej_loc);

<span class="comment">// REMARQUE : ON N&#39;OUBLIE PAS QUE LES NORMALES FA7 SONT ORIENTeES DE FACE_LOCI VERS FACE_LOCJ PAR DEFAUT</span>
<span class="comment">// LE PRODUIT SCALAIRE PSC_M EST DONC CALCULe POUR OBTENIR LE FLUX REcU PAR LA FACE FACE_LOCI</span>
<span class="comment">// ET EMIS PAR LA FACE_LOCJ</span>
<span class="comment">// SI L&#39;ON VEUT OBTENIR LE FLUX REcU PAR LA FACE FACE_LOCJ ET EMIS PAR LA FACE_LOCI, IL FAUT MULTIPLIER LE</span>
<span class="comment">// PRODUIT SCALAIRE PSC_M PAR -1 POUR IMPLICITEMENT ReORIENTER LES NORMALES FA7 DE FACE_LOCJ VERS</span>
<span class="comment">// FACE_LOCI</span>
<span class="comment">// MEME REMARQUE POUR LE SCALAIRE &quot;FLUX&quot;</span>
              <span class="keyword">const</span> <span class="keywordtype">double</span>&amp; psc_m = Kij(elem,facei_loc,facej_loc);

              <span class="keywordflow">if</span> (psc_m&gt;=0.)
                face_amont=facei,dir=0;
              <span class="keywordflow">else</span>
                face_amont=facej,dir=1;

              <span class="keywordflow">for</span> (comp=0; comp&lt;nb_comp; comp++)
                {
<span class="comment">// Calcul de la valeur de l&#39;inconnue aux points d&#39;integration de la formule du point milieu</span>
                  inco_m=transporteVect[face_amont*nb_comp+comp];
                  <span class="keywordflow">for</span>(dim=0; dim&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>; dim++)
                    inco_m+=gradient_elem(elem,comp,dim)*vecteur_face_facette_Cl(rang,fa7,dim,dir);

<span class="comment">// Calcul du flux final : formule d&#39;integration du point milieu</span>
                  flux=inco_m*psc_m;

<span class="comment">// Fij(elem,facei_loc,facej_loc,comp) est le flux recu par la facei_loc dans elem</span>
<span class="comment">// envoye par la face facej_loc dans elem pour la composante comp de l&#39;inconnue</span>
                  Fij(elem,facei_loc,facej_loc,comp)=flux-psc_m*transporteVect[facei*nb_comp+comp];
                  Fij(elem,facej_loc,facei_loc,comp)=psc_m*transporteVect[facej*nb_comp+comp]-flux;
                }
            }
        }
    }<span class="comment">//for sur elem</span>
}
</pre></div>
</div>
</div>
<a class="anchor" id="a9aa7c75c67bd0c800683b833d35eab0f"></a><!-- doxytag: member="Op_Conv_Muscl_New_VEF_Face::modifier_pour_Cl" ref="a9aa7c75c67bd0c800683b833d35eab0f" args="(Matrice_Morse &amp;, DoubleTab &amp;) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Op_Conv_Muscl_New_VEF_Face::modifier_pour_Cl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;&#160;</td>
          <td class="paramname"><em>matrice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>secmem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>On modifie le second membre et la matrice dans le cas des<br/>
conditions de dirichlet. </p>

<p>Reimplemented from <a class="el" href="classOp__Conv__VEF__Face.html#aa087b349430a7cd7fd4ef64670dad088">Op_Conv_VEF_Face</a>.</p>

<p>Definition at line <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8cpp_source.html#l02361">2361</a> of file <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8cpp_source.html">Op_Conv_Muscl_New_VEF_Face.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{
  <a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#a9aa7c75c67bd0c800683b833d35eab0f" title="On modifie le second membre et la matrice dans le cas des conditions de dirichlet.">Op_Conv_VEF_Face::modifier_pour_Cl</a>(matrice,secmem);
}
</pre></div>
</div>
</div>
<a class="anchor" id="af69550ea7cba363dae2162d2ff994fe0"></a><!-- doxytag: member="Op_Conv_Muscl_New_VEF_Face::printOn" ref="af69550ea7cba363dae2162d2ff994fe0" args="(Sortie &amp;x) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSortie.html">Sortie</a> &amp; Op_Conv_Muscl_New_VEF_Face::printOn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSortie.html">Sortie</a> &amp;&#160;</td>
          <td class="paramname"><em>os</em></td><td>)</td>
          <td> const<code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>NE FAIT RIEN<br/>
A surcharger dans les classes derivees. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="classSortie.html" title="Classe de base des flux de sortie. Elle sait ecrire des types simples&lt;br&gt;(entiers, flottants) et des Ob...">Sortie</a>&amp;<br/>
 Signification: le flot de sortie<br/>
 Contraintes: </dd></dl>

<p>Reimplemented from <a class="el" href="classOp__Conv__VEF__Face.html#a8eacb11670d5ea5cc15ed16632d15360">Op_Conv_VEF_Face</a>.</p>

<p>Definition at line <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8cpp_source.html#l00080">80</a> of file <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8cpp_source.html">Op_Conv_Muscl_New_VEF_Face.cpp</a>.</p>

<p>References <a class="el" href="Objet__U_8cpp_source.html#l00132">Objet_U::que_suis_je()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">return</span> s &lt;&lt; <a class="code" href="classObjet__U.html#aa58e9a81c0ddc2c1149053b8f96698ac" title="renvoie la chaine identifiant la classe.">que_suis_je</a>();
}
</pre></div>
</div>
</div>
<a class="anchor" id="a8bfb304871cfa825d460dd1bdc8f6594"></a><!-- doxytag: member="Op_Conv_Muscl_New_VEF_Face::readOn" ref="a8bfb304871cfa825d460dd1bdc8f6594" args="(Entree &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEntree.html">Entree</a> &amp; Op_Conv_Muscl_New_VEF_Face::readOn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEntree.html">Entree</a> &amp;&#160;</td>
          <td class="paramname"><em>is</em></td><td>)</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>NE FAIT RIEN<br/>
A surcharger dans les classes derivees. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="classEntree.html" title="Classe de definition des operateurs et methodes pour toute lecture dans un flot d&#39;entree (fichier...">Entree</a>&amp;<br/>
 Signification: le flot d'entree<br/>
 Contraintes: </dd></dl>

<p>Reimplemented from <a class="el" href="classOp__Conv__VEF__Face.html#a20514a9862bc5e8a557eadc1b8860a2a">Op_Conv_VEF_Face</a>.</p>

<p>Definition at line <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8cpp_source.html#l00088">88</a> of file <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8cpp_source.html">Op_Conv_Muscl_New_VEF_Face.cpp</a>.</p>

<p>References <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8h_source.html#l00119">alpha_</a>, <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8h_source.html#l00121">centered_</a>, <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8h_source.html#l00126">facsec_auto_</a>, <a class="el" href="Op__Conv__EF__VEF__P1NC__Stab_8cpp_source.html#l00200">limiteur()</a>, <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8h_source.html#l00132">limiteur_</a>, <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8h_source.html#l00120">max_limiteur_</a>, <a class="el" href="Convection__tools_8cpp_source.html#l00031">minmod()</a>, <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8h_source.html#l00124">old_centered_</a>, <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8h_source.html#l00123">stabilized_</a>, <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8h_source.html#l00122">upwind_</a>, and <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8h_source.html#l00125">version_</a>.</p>
<div class="fragment"><pre class="fragment">{
<span class="comment">// Les mots a reconnaitre</span>
  <a class="code" href="classMotcle.html" title="Une chaine de caractere (Nom) en majuscules.">Motcle</a> motlu, accouverte = <span class="stringliteral">&quot;{&quot;</span> , accfermee = <span class="stringliteral">&quot;}&quot;</span> ;
  <a class="code" href="classMotcle.html" title="Une chaine de caractere (Nom) en majuscules.">Motcle</a> <a class="code" href="Op__Conv__EF__VEF__P1NC__Stab_8cpp.html#a36b674f178bc8694c4bc14686f6f17bb">limiteur</a>;
  <a class="code" href="classMotcles.html" title="Un tableau d&#39;objets de la classe Motcle.">Motcles</a> les_mots(8);
  {
    les_mots[0] = <span class="stringliteral">&quot;centre&quot;</span>;
    les_mots[1] = <span class="stringliteral">&quot;amont&quot;</span>;
    les_mots[2] = <span class="stringliteral">&quot;stab&quot;</span>;
    les_mots[3] = <span class="stringliteral">&quot;alpha&quot;</span>;
    les_mots[4] = <span class="stringliteral">&quot;centre_old&quot;</span>;
    les_mots[5] = <span class="stringliteral">&quot;version&quot;</span>;
    les_mots[6] = <span class="stringliteral">&quot;limiteur&quot;</span>;
    les_mots[7] = <span class="stringliteral">&quot;facsec_auto&quot;</span>;
  }
  <a class="code" href="classMotcles.html" title="Un tableau d&#39;objets de la classe Motcle.">Motcles</a> les_mots2(3);
  {
    les_mots2[0] = <span class="stringliteral">&quot;vanleer&quot;</span>;
    les_mots2[1] = <span class="stringliteral">&quot;minmod&quot;</span>;
    les_mots2[2] = <span class="stringliteral">&quot;superbee&quot;</span>;
  }

<span class="comment">// Les variables a instancier</span>
  <a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#aba93a9d2fdc68f373410c6439c95074c">alpha_</a>=1.;
  <a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#af79e661742c516fb1f0945636d84f900">centered_</a>=1;
  <a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#ad596610363f5610f9ab6517b977b3122">upwind_</a>=1;
  <a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#a2b88ace4b5e403aacf90ce4a6787b76c">stabilized_</a>=1;
  <a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#af27e616d4be292efae0dcd25ef29278c">old_centered_</a>=0;
  <a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#a628f5f0e8616ec26b0541bdd128238c8">version_</a>=2;
  <a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#a1265605bb264c308aa56d6ace2e187a3">limiteur_</a>=&amp;<a class="code" href="Convection__tools_8cpp.html#acd40757070ae472ea829cf1cb522d91a">minmod</a>;
  <a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#a55d9e35f60df86eecbcc895f3cb72d3c">facsec_auto_</a>=0;
  <a class="code" href="classOp__Conv__Muscl__New__VEF__Face.html#ae5e76d1a00689f96fe333745b2a6c2ef">max_limiteur_</a>=1.;

<span class="comment">// Temporaire</span>
<span class="comment">// s &gt;&gt; motlu;</span>
<span class="comment">// if (motlu!=accouverte)</span>
<span class="comment">// {</span>
<span class="comment">// if (Process::je_suis_maitre())</span>
<span class="comment">// {</span>
<span class="comment">// Cerr &lt;&lt; &quot;Erreur Op_Conv_Muscl_New_VEF_Face::readOn()&quot; &lt;&lt; finl;</span>
<span class="comment">// Cerr &lt;&lt; &quot;Depuis la 1.6.1, la syntaxe du mot cle MUSCL a change.&quot; &lt;&lt; finl;</span>
<span class="comment">// Cerr &lt;&lt; &quot;Il faut commencer par une accolade ouvrante {&quot; &lt;&lt; finl;</span>
<span class="comment">// Cerr &lt;&lt; &quot;et les options eventuelles sont entre les accolades:&quot; &lt;&lt; finl;</span>
<span class="comment">// Cerr &lt;&lt; &quot;Convection { muscl } -&gt; Convection { muscl { } }&quot; &lt;&lt; finl;</span>

<span class="comment">// }</span>
<span class="comment">// Process::exit();</span>
<span class="comment">// }</span>
<span class="comment">// s &gt;&gt; motlu;</span>

<span class="comment">// while(motlu!=accfermee)</span>
<span class="comment">// {</span>
<span class="comment">// int rang=les_mots.search(motlu);</span>

<span class="comment">// switch(rang)</span>
<span class="comment">// {</span>
<span class="comment">// case 0 :</span>

<span class="comment">// centered_=1;</span>
<span class="comment">// upwind_=0;</span>
<span class="comment">// stabilized_=0;</span>
<span class="comment">// break;</span>

<span class="comment">// case 1 :</span>

<span class="comment">// centered_=1;</span>
<span class="comment">// upwind_=1;</span>
<span class="comment">// stabilized_=0;</span>
<span class="comment">// break;</span>

<span class="comment">// case 2 :</span>

<span class="comment">// centered_=1;</span>
<span class="comment">// upwind_=1;</span>
<span class="comment">// stabilized_=1;</span>
<span class="comment">// break;</span>

<span class="comment">// case 3 :</span>

<span class="comment">// s &gt;&gt; alpha_;</span>
<span class="comment">// break;</span>

<span class="comment">// case 4 :</span>

<span class="comment">// centered_=1;</span>
<span class="comment">// upwind_=0;</span>
<span class="comment">// stabilized_=0;</span>
<span class="comment">// old_centered_=1;</span>
<span class="comment">// break;</span>

<span class="comment">// case 5 :</span>

<span class="comment">// s&gt;&gt;version_;</span>
<span class="comment">// break;</span>

<span class="comment">// case 6 :</span>

<span class="comment">// s&gt;&gt;limiteur;</span>

<span class="comment">// int rang2=les_mots2.search(limiteur);</span>

<span class="comment">// switch(rang2)</span>
<span class="comment">// {</span>
<span class="comment">// case 0 :</span>

<span class="comment">// limiteur_=&amp;vanleer;</span>
<span class="comment">// max_limiteur_=2.;</span>
<span class="comment">// break;</span>

<span class="comment">// case 1 :</span>

<span class="comment">// limiteur_=&amp;minmod;</span>
<span class="comment">// max_limiteur_=1.;</span>
<span class="comment">// break;</span>

<span class="comment">// case 2 :</span>

<span class="comment">// limiteur_=&amp;superbee;</span>
<span class="comment">// max_limiteur_=2.;</span>
<span class="comment">// break;</span>

<span class="comment">// default :</span>

<span class="comment">// if (Process::je_suis_maitre())</span>
<span class="comment">// {</span>
<span class="comment">// Cerr &lt;&lt; &quot;Erreur Op_Conv_Muscl_New_VEF_Face::readOn()&quot; &lt;&lt; finl;</span>
<span class="comment">// Cerr &lt;&lt; &quot;Limiteur &quot;&lt;&lt;limiteur&lt;&lt;&quot; non code&quot; &lt;&lt; finl;</span>
<span class="comment">// Cerr &lt;&lt; &quot;Sortie du programme&quot; &lt;&lt; finl;</span>
<span class="comment">// }</span>
<span class="comment">// Process::exit();</span>
<span class="comment">// break;</span>
<span class="comment">// }</span>

<span class="comment">// break;</span>

<span class="comment">// case 7 :</span>

<span class="comment">// s&gt;&gt;facsec_auto_;</span>
<span class="comment">// break;</span>

<span class="comment">// default :</span>

<span class="comment">// if (Process::je_suis_maitre())</span>
<span class="comment">// {</span>
<span class="comment">// Cerr &lt;&lt; &quot;Erreur Op_Conv_Muscl_New_VEF_Face::readOn()&quot; &lt;&lt; finl;</span>
<span class="comment">// Cerr &lt;&lt; &quot;Mot clef &quot; &lt;&lt; motlu &lt;&lt; &quot; non connu.&quot; &lt;&lt; finl;</span>
<span class="comment">// Cerr &lt;&lt; &quot;Sortie du programme.&quot; &lt;&lt; finl;</span>
<span class="comment">// }</span>
<span class="comment">// Process::exit();</span>
<span class="comment">// break;</span>

<span class="comment">// }//fin du switch</span>

<span class="comment">// //Suite de la lecture</span>
<span class="comment">// s &gt;&gt; motlu;</span>

<span class="comment">// }//fin du while</span>
<span class="comment">// Fin du temporaire</span>


  <span class="keywordflow">return</span> s;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a3bd2f8fbc0e634221c7df74db0bca01d"></a><!-- doxytag: member="Op_Conv_Muscl_New_VEF_Face::remplir_fluent" ref="a3bd2f8fbc0e634221c7df74db0bca01d" args="(DoubleVect &amp;) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Op_Conv_Muscl_New_VEF_Face::remplir_fluent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;&#160;</td>
          <td class="paramname"><em>fluent_</em></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="classOp__Conv__VEF__Face.html#a1fcf6b33ff3ee706ffef89a117e2f54a">Op_Conv_VEF_Face</a>.</p>

<p>Definition at line <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8cpp_source.html#l01006">1006</a> of file <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8cpp_source.html">Op_Conv_Muscl_New_VEF_Face.cpp</a>.</p>

<p>References <a class="el" href="Double_8h_source.html#l00255">dabs()</a>, <a class="el" href="Objet__U_8h_source.html#l00079">Objet_U::dimension</a>, <a class="el" href="Zone__VEF_8h_source.html#l00145">Zone_VEF::face_normales()</a>, <a class="el" href="Op__Conv__VEF__base_8h_source.html#l00092">Op_Conv_VEF_base::la_zone_vef</a>, <a class="el" href="Zone__VF_8h_source.html#l00519">Zone_VF::nb_faces()</a>, <a class="el" href="Ref__Champ__Inc__base_8h_source.html#l00028">Ref_Champ_Inc_base::valeur()</a>, <a class="el" href="Ref__Zone__VEF_8h_source.html#l00028">Ref_Zone_VEF::valeur()</a>, <a class="el" href="Champ__Inc__base_8cpp_source.html#l00221">Champ_Inc_base::valeurs()</a>, and <a class="el" href="Op__Conv__VEF__base_8h_source.html#l00094">Op_Conv_VEF_base::vitesse_</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">const</span> <a class="code" href="classZone__VEF.html" title="class Zone_VEF Classe instanciable qui derive de Zone_VF. Cette classe contient les informations geom...">Zone_VEF</a>&amp; zone_VEF = <a class="code" href="classOp__Conv__VEF__base.html#a6c29a488a6805ba4a9f2f059cdba77ae">la_zone_vef</a>.<a class="code" href="classRef__Zone__VEF.html#aafd9a5ee1a76f290c9c6b5447b0c8d30">valeur</a>();
  <span class="keyword">const</span> <a class="code" href="classChamp__Inc__base.html" title="Classe Champ_Inc_base Classe de base des champs inconnues qui sont les champs calcules par une equati...">Champ_Inc_base</a>&amp; la_vitesse=<a class="code" href="classOp__Conv__VEF__base.html#a5547875832fb45e09b1115372fb76ffd">vitesse_</a>.<a class="code" href="classRef__Champ__Inc__base.html#a17553641a4c06730e1562125e07b3490">valeur</a>();
  <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; velocity=la_vitesse.<a class="code" href="classChamp__Inc__base.html#adb537f43f1649e103a8980314c7ed175" title="Renvoie le tableau des valeurs du champ au temps courant.">valeurs</a>();
  <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; face_normales=zone_VEF.<a class="code" href="classZone__VEF.html#a5742d75972e4846bf9fbb6ed5715053e">face_normales</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_faces = zone_VEF.<a class="code" href="classZone__VF.html#aede27992d9f2eedd52c24d4a80ff7ffb" title="renvoie le nombre global de faces.">nb_faces</a>();
<span class="comment">// calcul de la CFL.</span>
  <span class="keywordtype">double</span> psc;
<span class="comment">// On remet a zero le tableau qui sert pour</span>
<span class="comment">// le calcul du pas de temps de stabilite</span>
  fluent_ = 0;

  <span class="keywordflow">for</span>(<span class="keywordtype">int</span> num_face=0; num_face&lt;nb_faces; num_face++)
    {
      psc=0.;
      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; i++)
        psc+=velocity(num_face,i)*face_normales(num_face,i);
      fluent_(num_face)=<a class="code" href="Double_8h.html#aaecd4ca8a2fe69cc6568af2938b94d2e">dabs</a>(psc);
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="ae3051e6ae4326900ce530965a9e382cc"></a><!-- doxytag: member="Op_Conv_Muscl_New_VEF_Face::self_cast" ref="ae3051e6ae4326900ce530965a9e382cc" args="(Objet_U &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOp__Conv__Muscl__New__VEF__Face.html">Op_Conv_Muscl_New_VEF_Face</a> &amp; Op_Conv_Muscl_New_VEF_Face::self_cast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classObjet__U.html">Objet_U</a> &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="classOp__Conv__VEF__Face.html#aaf796aa5e9861e15db4afb2db07d6e12">Op_Conv_VEF_Face</a>.</p>

<p>Definition at line <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8cpp_source.html#l00074">74</a> of file <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8cpp_source.html">Op_Conv_Muscl_New_VEF_Face.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a92c196702032a60e9e1c8085bf0109fb"></a><!-- doxytag: member="Op_Conv_Muscl_New_VEF_Face::self_cast" ref="a92c196702032a60e9e1c8085bf0109fb" args="(const Objet_U &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classOp__Conv__Muscl__New__VEF__Face.html">Op_Conv_Muscl_New_VEF_Face</a> &amp; Op_Conv_Muscl_New_VEF_Face::self_cast </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classObjet__U.html">Objet_U</a> &amp;&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>methode ajoutee pour caster en python </p>

<p>Reimplemented from <a class="el" href="classOp__Conv__VEF__Face.html#a137b0427f8ba4a591de409481c8e54d4">Op_Conv_VEF_Face</a>.</p>

<p>Definition at line <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8cpp_source.html#l00074">74</a> of file <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8cpp_source.html">Op_Conv_Muscl_New_VEF_Face.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac77cc14784ce355125d44a3af42dcba0"></a><!-- doxytag: member="Op_Conv_Muscl_New_VEF_Face::taille_memoire" ref="ac77cc14784ce355125d44a3af42dcba0" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned Op_Conv_Muscl_New_VEF_Face::taille_memoire </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="classOp__Conv__VEF__Face.html#a0425dbae6b4c7a815392e6e4ae50861d">Op_Conv_VEF_Face</a>.</p>

<p>Definition at line <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8cpp_source.html#l00074">74</a> of file <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8cpp_source.html">Op_Conv_Muscl_New_VEF_Face.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6709414bd989ff2c3e4a377bb7efe084"></a><!-- doxytag: member="Op_Conv_Muscl_New_VEF_Face::test" ref="a6709414bd989ff2c3e4a377bb7efe084" args="(const DoubleTab &amp;, const DoubleTab &amp;, const DoubleTab &amp;vitesse) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Op_Conv_Muscl_New_VEF_Face::test </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>transporte</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>resu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>vitesse</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8cpp_source.html#l02107">2107</a> of file <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8cpp_source.html">Op_Conv_Muscl_New_VEF_Face.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{
}
</pre></div>
</div>
</div>
<a class="anchor" id="a1acd183f7ead04c1c937df139024bea4"></a><!-- doxytag: member="Op_Conv_Muscl_New_VEF_Face::test_difference_Kij" ref="a1acd183f7ead04c1c937df139024bea4" args="(const DoubleTab &amp;, DoubleTab &amp;, DoubleTab &amp;, const DoubleTab &amp;vitesse) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Op_Conv_Muscl_New_VEF_Face::test_difference_Kij </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>transporte</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>Kij</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>Kij_ancien</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>vitesse</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8cpp_source.html#l02111">2111</a> of file <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8cpp_source.html">Op_Conv_Muscl_New_VEF_Face.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{
}
</pre></div>
</div>
</div>
<a class="anchor" id="afc6c7aed9be880d6426a3a1be6d87d38"></a><!-- doxytag: member="Op_Conv_Muscl_New_VEF_Face::test_difference_resu" ref="afc6c7aed9be880d6426a3a1be6d87d38" args="(const DoubleTab &amp;, const DoubleTab &amp;, const DoubleTab &amp;, const DoubleTab &amp;, const DoubleTab &amp;vitesse) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Op_Conv_Muscl_New_VEF_Face::test_difference_resu </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>Kij</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>Kij_ancien</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>transporte</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>resu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>vitesse</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8cpp_source.html#l02115">2115</a> of file <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8cpp_source.html">Op_Conv_Muscl_New_VEF_Face.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{
<span class="comment">// DoubleTab resu1(resu);</span>
<span class="comment">// resu1=0;</span>

<span class="comment">// if (is_compressible_) ajouter_partie_compressible(transporte,resu1,velocity);</span>
<span class="comment">// ajouter_operateur_centre(Kij,transporte,resu1);</span>
<span class="comment">// ajouter_diffusion(Kij,transporte,resu1);</span>
<span class="comment">// ajouter_antidiffusion(Kij,transporte,resu1);</span>
<span class="comment">// mettre_a_jour_pour_periodicite(resu1);</span>
}
</pre></div>
</div>
</div>
<a class="anchor" id="ab68a8db5c6dc0e66de1ca5c9ab610364"></a><!-- doxytag: member="Op_Conv_Muscl_New_VEF_Face::test_implicite" ref="ab68a8db5c6dc0e66de1ca5c9ab610364" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Op_Conv_Muscl_New_VEF_Face::test_implicite </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8cpp_source.html#l03013">3013</a> of file <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8cpp_source.html">Op_Conv_Muscl_New_VEF_Face.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{
}
</pre></div>
</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="aba93a9d2fdc68f373410c6439c95074c"></a><!-- doxytag: member="Op_Conv_Muscl_New_VEF_Face::alpha_" ref="aba93a9d2fdc68f373410c6439c95074c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classOp__Conv__Muscl__New__VEF__Face.html#aba93a9d2fdc68f373410c6439c95074c">Op_Conv_Muscl_New_VEF_Face::alpha_</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="classOp__Conv__VEF__Face.html#aebc1771cc4608fc51a8b6d15b93c8d3d">Op_Conv_VEF_Face</a>.</p>

<p>Definition at line <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8h_source.html#l00119">119</a> of file <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8h_source.html">Op_Conv_Muscl_New_VEF_Face.h</a>.</p>

<p>Referenced by <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8cpp_source.html#l01828">ajouter_antidiffusion_v1()</a>, <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8cpp_source.html#l01699">ajouter_antidiffusion_v2()</a>, <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8cpp_source.html#l01603">ajouter_diffusion()</a>, <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8cpp_source.html#l02311">completer()</a>, and <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8cpp_source.html#l00088">readOn()</a>.</p>

</div>
</div>
<a class="anchor" id="a5477f9154396fb7e43a71d40c0689e78"></a><!-- doxytag: member="Op_Conv_Muscl_New_VEF_Face::alpha_tab" ref="a5477f9154396fb7e43a71d40c0689e78" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classArrOfDouble.html">ArrOfDouble</a> <a class="el" href="classOp__Conv__Muscl__New__VEF__Face.html#a5477f9154396fb7e43a71d40c0689e78">Op_Conv_Muscl_New_VEF_Face::alpha_tab</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8h_source.html#l00115">115</a> of file <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8h_source.html">Op_Conv_Muscl_New_VEF_Face.h</a>.</p>

<p>Referenced by <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8cpp_source.html#l02311">completer()</a>.</p>

</div>
</div>
<a class="anchor" id="a809512967978e8fbb8cb99a54cd17594"></a><!-- doxytag: member="Op_Conv_Muscl_New_VEF_Face::beta" ref="a809512967978e8fbb8cb99a54cd17594" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classArrOfDouble.html">ArrOfDouble</a> <a class="el" href="classOp__Conv__Muscl__New__VEF__Face.html#a809512967978e8fbb8cb99a54cd17594">Op_Conv_Muscl_New_VEF_Face::beta</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>vaut zero pour les faces ou l'on souhaite degenerer en Amont. mutable <a class="el" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a> limiteurs_;//tableau stockant pour chaque face la moyenne algebrique du limiteur </p>

<p>Definition at line <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8h_source.html#l00116">116</a> of file <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8h_source.html">Op_Conv_Muscl_New_VEF_Face.h</a>.</p>

<p>Referenced by <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8cpp_source.html#l02311">completer()</a>.</p>

</div>
</div>
<a class="anchor" id="af79e661742c516fb1f0945636d84f900"></a><!-- doxytag: member="Op_Conv_Muscl_New_VEF_Face::centered_" ref="af79e661742c516fb1f0945636d84f900" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classOp__Conv__Muscl__New__VEF__Face.html#af79e661742c516fb1f0945636d84f900">Op_Conv_Muscl_New_VEF_Face::centered_</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8h_source.html#l00121">121</a> of file <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8h_source.html">Op_Conv_Muscl_New_VEF_Face.h</a>.</p>

<p>Referenced by <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8cpp_source.html#l01029">ajouter()</a>, and <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8cpp_source.html#l00088">readOn()</a>.</p>

</div>
</div>
<a class="anchor" id="a55d9e35f60df86eecbcc895f3cb72d3c"></a><!-- doxytag: member="Op_Conv_Muscl_New_VEF_Face::facsec_auto_" ref="a55d9e35f60df86eecbcc895f3cb72d3c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classOp__Conv__Muscl__New__VEF__Face.html#a55d9e35f60df86eecbcc895f3cb72d3c">Op_Conv_Muscl_New_VEF_Face::facsec_auto_</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8h_source.html#l00126">126</a> of file <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8h_source.html">Op_Conv_Muscl_New_VEF_Face.h</a>.</p>

<p>Referenced by <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8cpp_source.html#l01107">calculer_dt_stab()</a>, and <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8cpp_source.html#l00088">readOn()</a>.</p>

</div>
</div>
<a class="anchor" id="a3de84e25f40003eae5fb33eaf0fde4b4"></a><!-- doxytag: member="Op_Conv_Muscl_New_VEF_Face::info_obj" ref="a3de84e25f40003eae5fb33eaf0fde4b4" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classType__info.html">Type_info</a> <a class="el" href="classOp__Conv__Muscl__New__VEF__Face.html#a3de84e25f40003eae5fb33eaf0fde4b4">Op_Conv_Muscl_New_VEF_Face::info_obj</a><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="classOp__Conv__VEF__Face.html#ab04ee3b4166df4eea5ee4afa9bf25d43">Op_Conv_VEF_Face</a>.</p>

<p>Definition at line <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8h_source.html#l00053">53</a> of file <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8h_source.html">Op_Conv_Muscl_New_VEF_Face.h</a>.</p>

</div>
</div>
<a class="anchor" id="a1e7b0db2325d8e59bbaa9460ed6f3826"></a><!-- doxytag: member="Op_Conv_Muscl_New_VEF_Face::is_dirichlet_faces_" ref="a1e7b0db2325d8e59bbaa9460ed6f3826" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIntTab.html">IntTab</a> <a class="el" href="classOp__Conv__Muscl__New__VEF__Face.html#a1e7b0db2325d8e59bbaa9460ed6f3826">Op_Conv_Muscl_New_VEF_Face::is_dirichlet_faces_</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8h_source.html#l00112">112</a> of file <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8h_source.html">Op_Conv_Muscl_New_VEF_Face.h</a>.</p>

<p>Referenced by <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8cpp_source.html#l01828">ajouter_antidiffusion_v1()</a>, <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8cpp_source.html#l01699">ajouter_antidiffusion_v2()</a>, and <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8cpp_source.html#l02226">calculer_data_pour_dirichlet()</a>.</p>

</div>
</div>
<a class="anchor" id="a93e226d752c2b31d4b63e08840aea2cb"></a><!-- doxytag: member="Op_Conv_Muscl_New_VEF_Face::is_element_for_upwinding_" ref="a93e226d752c2b31d4b63e08840aea2cb" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIntTab.html">IntTab</a> <a class="el" href="classOp__Conv__Muscl__New__VEF__Face.html#a93e226d752c2b31d4b63e08840aea2cb">Op_Conv_Muscl_New_VEF_Face::is_element_for_upwinding_</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8h_source.html#l00111">111</a> of file <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8h_source.html">Op_Conv_Muscl_New_VEF_Face.h</a>.</p>

<p>Referenced by <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8cpp_source.html#l02226">calculer_data_pour_dirichlet()</a>, and <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8cpp_source.html#l00859">modifier_flux_operateur_centre()</a>.</p>

</div>
</div>
<a class="anchor" id="ad4906f5a407729870b58f21924914ad7"></a><!-- doxytag: member="Op_Conv_Muscl_New_VEF_Face::la_sous_zone_dis" ref="ad4906f5a407729870b58f21924914ad7" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRef__Sous__zone__VF.html">Ref_Sous_zone_VF</a> <a class="el" href="classOp__Conv__Muscl__New__VEF__Face.html#ad4906f5a407729870b58f21924914ad7">Op_Conv_Muscl_New_VEF_Face::la_sous_zone_dis</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8h_source.html#l00130">130</a> of file <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8h_source.html">Op_Conv_Muscl_New_VEF_Face.h</a>.</p>

</div>
</div>
<a class="anchor" id="a1265605bb264c308aa56d6ace2e187a3"></a><!-- doxytag: member="Op_Conv_Muscl_New_VEF_Face::limiteur_" ref="a1265605bb264c308aa56d6ace2e187a3" args=")(double)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double(* <a class="el" href="classOp__Conv__Muscl__New__VEF__Face.html#a1265605bb264c308aa56d6ace2e187a3">Op_Conv_Muscl_New_VEF_Face::limiteur_</a>)(double)<code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8h_source.html#l00132">132</a> of file <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8h_source.html">Op_Conv_Muscl_New_VEF_Face.h</a>.</p>

<p>Referenced by <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8cpp_source.html#l00088">readOn()</a>.</p>

</div>
</div>
<a class="anchor" id="ae5e76d1a00689f96fe333745b2a6c2ef"></a><!-- doxytag: member="Op_Conv_Muscl_New_VEF_Face::max_limiteur_" ref="ae5e76d1a00689f96fe333745b2a6c2ef" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classOp__Conv__Muscl__New__VEF__Face.html#ae5e76d1a00689f96fe333745b2a6c2ef">Op_Conv_Muscl_New_VEF_Face::max_limiteur_</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8h_source.html#l00120">120</a> of file <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8h_source.html">Op_Conv_Muscl_New_VEF_Face.h</a>.</p>

<p>Referenced by <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8cpp_source.html#l01107">calculer_dt_stab()</a>, and <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8cpp_source.html#l00088">readOn()</a>.</p>

</div>
</div>
<a class="anchor" id="ad2275b65e44a3a588e3897c24e5166c7"></a><!-- doxytag: member="Op_Conv_Muscl_New_VEF_Face::nom_sous_zone" ref="ad2275b65e44a3a588e3897c24e5166c7" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNom.html">Nom</a> <a class="el" href="classOp__Conv__Muscl__New__VEF__Face.html#ad2275b65e44a3a588e3897c24e5166c7">Op_Conv_Muscl_New_VEF_Face::nom_sous_zone</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8h_source.html#l00129">129</a> of file <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8h_source.html">Op_Conv_Muscl_New_VEF_Face.h</a>.</p>

</div>
</div>
<a class="anchor" id="af27e616d4be292efae0dcd25ef29278c"></a><!-- doxytag: member="Op_Conv_Muscl_New_VEF_Face::old_centered_" ref="af27e616d4be292efae0dcd25ef29278c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classOp__Conv__Muscl__New__VEF__Face.html#af27e616d4be292efae0dcd25ef29278c">Op_Conv_Muscl_New_VEF_Face::old_centered_</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8h_source.html#l00124">124</a> of file <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8h_source.html">Op_Conv_Muscl_New_VEF_Face.h</a>.</p>

<p>Referenced by <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8cpp_source.html#l01029">ajouter()</a>, <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8cpp_source.html#l01468">ajouter_operateur_centre()</a>, <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8cpp_source.html#l02226">calculer_data_pour_dirichlet()</a>, <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8cpp_source.html#l02128">mettre_a_jour_pour_periodicite()</a>, and <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8cpp_source.html#l00088">readOn()</a>.</p>

</div>
</div>
<a class="anchor" id="a2b88ace4b5e403aacf90ce4a6787b76c"></a><!-- doxytag: member="Op_Conv_Muscl_New_VEF_Face::stabilized_" ref="a2b88ace4b5e403aacf90ce4a6787b76c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classOp__Conv__Muscl__New__VEF__Face.html#a2b88ace4b5e403aacf90ce4a6787b76c">Op_Conv_Muscl_New_VEF_Face::stabilized_</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8h_source.html#l00123">123</a> of file <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8h_source.html">Op_Conv_Muscl_New_VEF_Face.h</a>.</p>

<p>Referenced by <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8cpp_source.html#l01029">ajouter()</a>, and <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8cpp_source.html#l00088">readOn()</a>.</p>

</div>
</div>
<a class="anchor" id="ad596610363f5610f9ab6517b977b3122"></a><!-- doxytag: member="Op_Conv_Muscl_New_VEF_Face::upwind_" ref="ad596610363f5610f9ab6517b977b3122" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classOp__Conv__Muscl__New__VEF__Face.html#ad596610363f5610f9ab6517b977b3122">Op_Conv_Muscl_New_VEF_Face::upwind_</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8h_source.html#l00122">122</a> of file <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8h_source.html">Op_Conv_Muscl_New_VEF_Face.h</a>.</p>

<p>Referenced by <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8cpp_source.html#l01029">ajouter()</a>, and <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8cpp_source.html#l00088">readOn()</a>.</p>

</div>
</div>
<a class="anchor" id="a628f5f0e8616ec26b0541bdd128238c8"></a><!-- doxytag: member="Op_Conv_Muscl_New_VEF_Face::version_" ref="a628f5f0e8616ec26b0541bdd128238c8" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classOp__Conv__Muscl__New__VEF__Face.html#a628f5f0e8616ec26b0541bdd128238c8">Op_Conv_Muscl_New_VEF_Face::version_</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8h_source.html#l00125">125</a> of file <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8h_source.html">Op_Conv_Muscl_New_VEF_Face.h</a>.</p>

<p>Referenced by <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8cpp_source.html#l01670">ajouter_antidiffusion()</a>, and <a class="el" href="Op__Conv__Muscl__New__VEF__Face_8cpp_source.html#l00088">readOn()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/VEF/Operateurs/<a class="el" href="Op__Conv__Muscl__New__VEF__Face_8h_source.html">Op_Conv_Muscl_New_VEF_Face.h</a></li>
<li>src/VEF/Operateurs/<a class="el" href="Op__Conv__Muscl__New__VEF__Face_8cpp_source.html">Op_Conv_Muscl_New_VEF_Face.cpp</a></li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Tue Dec 14 2021 19:37:15 for TRUST by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
