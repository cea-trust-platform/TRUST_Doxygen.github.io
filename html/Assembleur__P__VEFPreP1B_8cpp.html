<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>TRUST: src/P1NCP1B/Solveurs/Assembleur_P_VEFPreP1B.cpp File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">TRUST&#160;<span id="projectnumber">1.8.4</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">src/P1NCP1B/Solveurs/Assembleur_P_VEFPreP1B.cpp File Reference</div>  </div>
</div>
<div class="contents">
<div class="textblock"><code>#include &lt;<a class="el" href="Assembleur__P__VEFPreP1B_8h_source.html">Assembleur_P_VEFPreP1B.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="Matrice__Bloc__Sym_8h_source.html">Matrice_Bloc_Sym.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="Domaine_8h_source.html">Domaine.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="Dirichlet_8h_source.html">Dirichlet.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="Dirichlet__homogene_8h_source.html">Dirichlet_homogene.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="Entree__fluide__vitesse__imposee_8h_source.html">Entree_fluide_vitesse_imposee.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="Neumann__sortie__libre_8h_source.html">Neumann_sortie_libre.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="LecFicDistribueBin_8h_source.html">LecFicDistribueBin.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="Champ__front__instationnaire__base_8h_source.html">Champ_front_instationnaire_base.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="Champ__front__var_8h_source.html">Champ_front_var.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="EcrFicCollecteBin_8h_source.html">EcrFicCollecteBin.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="Milieu__base_8h_source.html">Milieu_base.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="Navier__Stokes__std_8h_source.html">Navier_Stokes_std.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="Debog_8h_source.html">Debog.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="IntLists_8h_source.html">IntLists.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="Op__Grad__VEF__P1B__Face_8h_source.html">Op_Grad_VEF_P1B_Face.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="Op__Div__VEFP1B__Elem_8h_source.html">Op_Div_VEFP1B_Elem.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="SFichier_8h_source.html">SFichier.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="Champ__Fonc__P1NC_8h_source.html">Champ_Fonc_P1NC.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="SolveurPP1B_8h_source.html">SolveurPP1B.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="Scatter_8h_source.html">Scatter.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="Check__espace__virtuel_8h_source.html">Check_espace_virtuel.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="Champ__front__var__instationnaire_8h_source.html">Champ_front_var_instationnaire.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="Solv__Petsc_8h_source.html">Solv_Petsc.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="Matrice__Petsc_8h_source.html">Matrice_Petsc.h</a>&gt;</code><br/>
</div>
<p><a href="Assembleur__P__VEFPreP1B_8cpp_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Assembleur__P__VEFPreP1B_8cpp.html#ad6ea924b20e311b70fc786906b53805b">estim_cond</a> (<a class="el" href="classMatrice.html">Matrice</a> &amp;A)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Assembleur__P__VEFPreP1B_8cpp.html#a31e2d4bc38d5bc0bbf9e2c36d15b589b">assemblerP0P0</a> (const <a class="el" href="classZone__dis__base.html">Zone_dis_base</a> &amp;z, const <a class="el" href="classZone__Cl__dis__base.html">Zone_Cl_dis_base</a> &amp;zcl, <a class="el" href="classMatrice.html">Matrice</a> &amp;matrice, const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;inverse_quantitee_entrelacee)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Assembleur__P__VEFPreP1B_8cpp.html#a31f132f3fda04d8428de212c63fd902f">assemblerP1P1</a> (const <a class="el" href="classZone__dis__base.html">Zone_dis_base</a> &amp;z, const <a class="el" href="classZone__Cl__dis__base.html">Zone_Cl_dis_base</a> &amp;zcl, <a class="el" href="classMatrice.html">Matrice</a> &amp;matrice, const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;inverse_quantitee_entrelacee, const <a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;coef_som)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Assembleur__P__VEFPreP1B_8cpp.html#a7840f924363ed7d3fbd50a59d9d990c0">assemblerPaPa</a> (const <a class="el" href="classZone__dis__base.html">Zone_dis_base</a> &amp;z, const <a class="el" href="classZone__Cl__dis__base.html">Zone_Cl_dis_base</a> &amp;zcl, <a class="el" href="classMatrice.html">Matrice</a> &amp;matrice, const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;inverse_quantitee_entrelacee)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Assembleur__P__VEFPreP1B_8cpp.html#a3774b1608aeee56152e7e1e5f385bfe1">assemblerP0P1</a> (const <a class="el" href="classZone__dis__base.html">Zone_dis_base</a> &amp;z, const <a class="el" href="classZone__Cl__dis__base.html">Zone_Cl_dis_base</a> &amp;zcl, <a class="el" href="classMatrice.html">Matrice</a> &amp;matrice, const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;inverse_quantitee_entrelacee, const <a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;coef_som)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Assembleur__P__VEFPreP1B_8cpp.html#a30b5e404b46e2a239584ee19835c88bf">assemblerP0Pa</a> (const <a class="el" href="classZone__dis__base.html">Zone_dis_base</a> &amp;z, const <a class="el" href="classZone__Cl__dis__base.html">Zone_Cl_dis_base</a> &amp;zcl, <a class="el" href="classMatrice.html">Matrice</a> &amp;matrice, const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;inverse_quantitee_entrelacee)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Assembleur__P__VEFPreP1B_8cpp.html#a5dcfee4400f896bcbb100259f53a5de1">assemblerP1Pa</a> (const <a class="el" href="classZone__dis__base.html">Zone_dis_base</a> &amp;z, const <a class="el" href="classZone__Cl__dis__base.html">Zone_Cl_dis_base</a> &amp;zcl, <a class="el" href="classMatrice.html">Matrice</a> &amp;matrice, const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;inverse_quantitee_entrelacee, const <a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;coef_som)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Assembleur__P__VEFPreP1B_8cpp.html#a48eaaecaa31bdde228ea5e3995db4771">updateP0P0</a> (const <a class="el" href="classZone__dis__base.html">Zone_dis_base</a> &amp;z, const <a class="el" href="classZone__Cl__dis__base.html">Zone_Cl_dis_base</a> &amp;zcl, <a class="el" href="classMatrice.html">Matrice</a> &amp;matrice, const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;inverse_quantitee_entrelacee)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Assembleur__P__VEFPreP1B_8cpp.html#ab3c25c4172223f48fd2f9d433b005e0c">updateP1P1</a> (const <a class="el" href="classZone__dis__base.html">Zone_dis_base</a> &amp;z, const <a class="el" href="classZone__Cl__dis__base.html">Zone_Cl_dis_base</a> &amp;zcl, <a class="el" href="classMatrice.html">Matrice</a> &amp;matrice, const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;inverse_quantitee_entrelacee, const <a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;coef_som)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Assembleur__P__VEFPreP1B_8cpp.html#a1ce15acad922bef2d305d970c13c68c8">modifieP1P1neumann</a> (const <a class="el" href="classZone__dis__base.html">Zone_dis_base</a> &amp;z, const <a class="el" href="classZone__Cl__dis__base.html">Zone_Cl_dis_base</a> &amp;zcl, <a class="el" href="classMatrice.html">Matrice</a> &amp;matrice, const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;inverse_quantitee_entrelacee, const <a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;coef_som)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Assembleur__P__VEFPreP1B_8cpp.html#a4e0c0752e80915fd8b0143b70f08e718">updatePaPa</a> (const <a class="el" href="classZone__dis__base.html">Zone_dis_base</a> &amp;z, const <a class="el" href="classZone__Cl__dis__base.html">Zone_Cl_dis_base</a> &amp;zcl, <a class="el" href="classMatrice.html">Matrice</a> &amp;matrice, const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;inverse_quantitee_entrelacee)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Assembleur__P__VEFPreP1B_8cpp.html#af30661e8e1b45bf522a5595f65ecc741">updateP0P1</a> (const <a class="el" href="classZone__dis__base.html">Zone_dis_base</a> &amp;z, const <a class="el" href="classZone__Cl__dis__base.html">Zone_Cl_dis_base</a> &amp;zcl, <a class="el" href="classMatrice.html">Matrice</a> &amp;matrice, const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;inverse_quantitee_entrelacee, const <a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;coef_som)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Assembleur__P__VEFPreP1B_8cpp.html#aacede92ea2595a5546e6357fbd1e1498">updateP0Pa</a> (const <a class="el" href="classZone__dis__base.html">Zone_dis_base</a> &amp;z, const <a class="el" href="classZone__Cl__dis__base.html">Zone_Cl_dis_base</a> &amp;zcl, <a class="el" href="classMatrice.html">Matrice</a> &amp;matrice, const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;inverse_quantitee_entrelacee)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Assembleur__P__VEFPreP1B_8cpp.html#a8d9349eb29399f4ac72dc10543a4005a">updateP1Pa</a> (const <a class="el" href="classZone__dis__base.html">Zone_dis_base</a> &amp;z, const <a class="el" href="classZone__Cl__dis__base.html">Zone_Cl_dis_base</a> &amp;zcl, <a class="el" href="classMatrice.html">Matrice</a> &amp;matrice, const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;inverse_quantitee_entrelacee, const <a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;coef_som)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Assembleur__P__VEFPreP1B_8cpp.html#ab3f0bf1b466f4f73f7c106a25a0ce950">verifier</a> (const <a class="el" href="classAssembleur__P__VEFPreP1B.html">Assembleur_P_VEFPreP1B</a> &amp;ass, const <a class="el" href="classMatrice__Bloc__Sym.html">Matrice_Bloc_Sym</a> &amp;matrice, const <a class="el" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a> &amp;zone_VEF, const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;inverse_quantitee_entrelacee)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Assembleur__P__VEFPreP1B_8cpp.html#a6e2318de58fc55873393f2dccdbd9d6c">zero</a> (<a class="el" href="classMatrice__Bloc__Sym.html">Matrice_Bloc_Sym</a> &amp;matrice)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Assembleur__P__VEFPreP1B_8cpp.html#a1ba6a21d7cd10f7974541a879696c5db">range</a> (double &amp;prod, int &amp;i, int &amp;n, int &amp;j, int &amp;m, <a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;ARR, <a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;ARV, <a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;AVR, <a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;AVV)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Assembleur__P__VEFPreP1B_8cpp.html#ad34510dd4da2194051998525655e62f9">operation11</a> (<a class="el" href="classMatrice__Bloc.html">Matrice_Bloc</a> &amp;A00, <a class="el" href="classMatrice__Bloc.html">Matrice_Bloc</a> &amp;A01, <a class="el" href="classMatrice__Bloc.html">Matrice_Bloc</a> &amp;A11, double beta, const <a class="el" href="classZone.html">Zone</a> &amp;zone)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Assembleur__P__VEFPreP1B_8cpp.html#a092a07cbd42b28d79c8d8d04e835fd91">operation01</a> (<a class="el" href="classMatrice__Bloc.html">Matrice_Bloc</a> &amp;A00, <a class="el" href="classMatrice__Bloc.html">Matrice_Bloc</a> &amp;A01, double alpha, double beta, const <a class="el" href="classZone.html">Zone</a> &amp;zone)</td></tr>
<tr><td colspan="2"><h2><a name="var-members"></a>
Variables</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classType__info.html">Type_info</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Assembleur__P__VEFPreP1B_8cpp.html#aae09693578a6a3e0fde3f6d35fe36da0">Assembleur_P_VEFPreP1Bbases</a> [1] = { &amp;( <a class="el" href="classAssembleur__P__VEF.html">Assembleur_P_VEF</a> ::info_obj)}</td></tr>
</table>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a31e2d4bc38d5bc0bbf9e2c36d15b589b"></a><!-- doxytag: member="Assembleur_P_VEFPreP1B.cpp::assemblerP0P0" ref="a31e2d4bc38d5bc0bbf9e2c36d15b589b" args="(const Zone_dis_base &amp;z, const Zone_Cl_dis_base &amp;zcl, Matrice &amp;matrice, const DoubleTab &amp;inverse_quantitee_entrelacee)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void assemblerP0P0 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classZone__dis__base.html">Zone_dis_base</a> &amp;&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classZone__Cl__dis__base.html">Zone_Cl_dis_base</a> &amp;&#160;</td>
          <td class="paramname"><em>zcl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatrice.html">Matrice</a> &amp;&#160;</td>
          <td class="paramname"><em>matrice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>inverse_quantitee_entrelacee</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l02222">2222</a> of file <a class="el" href="AssembleurPP1BUtil_8cpp_source.html">AssembleurPP1BUtil.cpp</a>.</p>

<p>References <a class="el" href="Assembleur__P__VEF_8cpp_source.html#l00755">Assembleur_P_VEF::associer_zone_cl_dis_base()</a>, <a class="el" href="Assembleur__P__VEF_8cpp_source.html#l00750">Assembleur_P_VEF::associer_zone_dis_base()</a>, <a class="el" href="EntreeSortie_8h_source.html#l00032">Cerr</a>, <a class="el" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>, and <a class="el" href="Assembleur__P__VEF_8cpp_source.html#l00134">Assembleur_P_VEF::remplir()</a>.</p>

<p>Referenced by <a class="el" href="Assembleur__P__VEFPreP1B_8cpp_source.html#l00230">Assembleur_P_VEFPreP1B::assembler_mat()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <a class="code" href="classAssembleur__P__VEF.html">Assembleur_P_VEF</a> Assembleur_P0;
  Assembleur_P0.<a class="code" href="classAssembleur__P__VEF.html#a5b2a8af584466c11399b032515921978">associer_zone_dis_base</a>(z);
  Assembleur_P0.<a class="code" href="classAssembleur__P__VEF.html#a69468e49c8496eda05508c8e8477493b">associer_zone_cl_dis_base</a>(zcl);
  Assembleur_P0.<a class="code" href="classAssembleur__P__VEF.html#abe02c31a6c1ada8d05996def7f43ea58">remplir</a>(matrice,inverse_quantitee_entrelacee);
  <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Assemblage P0 OK&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a3774b1608aeee56152e7e1e5f385bfe1"></a><!-- doxytag: member="Assembleur_P_VEFPreP1B.cpp::assemblerP0P1" ref="a3774b1608aeee56152e7e1e5f385bfe1" args="(const Zone_dis_base &amp;z, const Zone_Cl_dis_base &amp;zcl, Matrice &amp;matrice, const DoubleTab &amp;inverse_quantitee_entrelacee, const ArrOfDouble &amp;coef_som)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void assemblerP0P1 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classZone__dis__base.html">Zone_dis_base</a> &amp;&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classZone__Cl__dis__base.html">Zone_Cl_dis_base</a> &amp;&#160;</td>
          <td class="paramname"><em>zcl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatrice.html">Matrice</a> &amp;&#160;</td>
          <td class="paramname"><em>matrice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>inverse_quantitee_entrelacee</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;&#160;</td>
          <td class="paramname"><em>coef_som</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>&lt; RIEN</p>
<p>&lt; On ne traite que les faces internes </p>
</p>

<p>Definition at line <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l02968">2968</a> of file <a class="el" href="AssembleurPP1BUtil_8cpp_source.html">AssembleurPP1BUtil.cpp</a>.</p>

<p>References <a class="el" href="EntreeSortie_8h_source.html#l00032">Cerr</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00939">contribuer_matrice_NeumannP0P1()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00528">contribuer_matriceP0P1()</a>, <a class="el" href="Objet__U_8h_source.html#l00079">Objet_U::dimension</a>, <a class="el" href="Zone__VF_8h_source.html#l00773">Zone_VF::est_une_face_virt_bord()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00046">face_associee</a>, <a class="el" href="Zone__VF_8h_source.html#l00458">Zone_VF::face_voisins()</a>, <a class="el" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>, <a class="el" href="Cond__lim_8h_source.html#l00130">Cond_lim::frontiere_dis()</a>, <a class="el" href="Zone__Cl__dis__base_8cpp_source.html#l00522">Zone_Cl_dis_base::les_conditions_limites()</a>, <a class="el" href="Zone_8h_source.html#l00300">Zone::nb_elem()</a>, <a class="el" href="Zone_8h_source.html#l00319">Zone::nb_elem_tot()</a>, <a class="el" href="Front__VF_8h_source.html#l00066">Front_VF::nb_faces_tot()</a>, <a class="el" href="Zone__VF_8h_source.html#l00527">Zone_VF::nb_faces_tot()</a>, <a class="el" href="Zone_8cpp_source.html#l00586">Zone::nb_som()</a>, <a class="el" href="Zone_8cpp_source.html#l00608">Zone::nb_som_tot()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00081">okface()</a>, <a class="el" href="Zone__VF_8h_source.html#l00512">Zone_VF::premiere_face_int()</a>, <a class="el" href="Cast_8h_source.html#l00059">ref_cast</a>, <a class="el" href="Matrice__Bloc_8cpp_source.html#l00647">Matrice_Bloc::remplir()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00349">remplir_sommets()</a>, <a class="el" href="vect__impl_8h_source.html#l00057">vect_impl::size()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00286">sort()</a>, <a class="el" href="Deriv___8cpp_source.html#l00091">Deriv_::typer()</a>, <a class="el" href="Deriv__Matrice__Base_8h_source.html#l00028">Deriv_Matrice_Base::valeur()</a>, and <a class="el" href="Zone__dis__base_8h_source.html#l00106">Zone_dis_base::zone()</a>.</p>

<p>Referenced by <a class="el" href="Assembleur__P__VEFPreP1B_8cpp_source.html#l00230">Assembleur_P_VEFPreP1B::assembler_mat()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">int</span> dimension=<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>;
  <span class="keyword">const</span> <a class="code" href="classZone__VEF.html" title="class Zone_VEF Classe instanciable qui derive de Zone_VF. Cette classe contient les informations geom...">Zone_VEF</a>&amp; zone_VEF=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a>, z);
  <span class="keyword">const</span> <a class="code" href="classZone.html" title="classe Zone Une Zone est un maillage compose d&#39;un ensemble d&#39;elements geometriques de meme type...">Zone</a>&amp; zone=zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>();
  <span class="keyword">const</span> <a class="code" href="classZone__Cl__VEF.html">Zone_Cl_VEF</a>&amp; zone_Cl_VEF=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classZone__Cl__VEF.html">Zone_Cl_VEF</a>, zcl);
  <span class="keyword">const</span> <a class="code" href="classConds__lim.html">Conds_lim</a>&amp; les_cl = zone_Cl_VEF.<a class="code" href="classZone__Cl__dis__base.html#af75e0ed7786863e4d333bfb29d67c323" title="Renvoie la i-ieme condition aux limites. (version const)">les_conditions_limites</a>();
  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; face_voisins = zone_VEF.<a class="code" href="classZone__VF.html#a49d4322f5585a8fa95748ca785b70702" title="renvoie l&#39;element voisin de numface dans la direction i. i=0 : dans le sens oppose de l&#39;axe orthogona...">face_voisins</a>();
  <span class="keywordtype">int</span> nint = zone_VEF.<a class="code" href="classZone__VF.html#a12869806fa4834aca8f2964e16509dfd" title="une face est interne ssi elle separe deux elements. renvoie le numero de la premiere face interne...">premiere_face_int</a>();
  <span class="keywordtype">int</span> nb_faces = zone_VEF.<a class="code" href="classZone__VF.html#a50fd21c9535680489015a3c8b88c685a" title="renvoie le nombre total de faces. C&#39;est-a-dire faces reelles + faces virtuelles">nb_faces_tot</a>();
  <span class="keywordtype">int</span> nb_elem = zone.<a class="code" href="classZone.html#aa3a33e8b723618b9092460007153e42d" title="Renvoie le nombre total d&#39;elements de la zone.">nb_elem_tot</a>();
  <span class="keywordtype">int</span> elem1, elem2, face, ok;
  <span class="keywordtype">int</span> nnz=0;
  <a class="code" href="classIntLists.html" title="Un tableau de listes de type IntList.">IntLists</a> voisins(nb_elem);
  <a class="code" href="classDoubleLists.html" title="Un tableau de listes de type DoubleList.">DoubleLists</a> coeffs(nb_elem);
  <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> sommets(dimension+2);
  <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> face_opp1(dimension+2);
  <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> face_opp2(dimension+2);
<span class="comment">// Faces de bord :</span>
  <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;les_cl.<a class="code" href="classvect__impl.html#a78155bfbd6b61f4710b9830641ed1694">size</a>(); i++)
    {
      <span class="keyword">const</span> <a class="code" href="classCond__lim.html" title="classe Cond_lim Classe generique servant a representer n&#39;importe quelle classe derivee de la classe C...">Cond_lim</a>&amp; la_cl = les_cl[i];
      <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp; le_bord = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>,la_cl.<a class="code" href="classCond__lim.html#a5b2d24809cee07727006a891d4ce8d22" title="Appel a l&#39;objet sous-jacent Renvoie la frontiere discretisee associee a la condition aux limites...">frontiere_dis</a>());
      <span class="keywordtype">int</span> nb_faces_bord_tot = le_bord.<a class="code" href="classFront__VF.html#aed4006d91bf2ef3af2b9f7933d863a09" title="Nombre de faces reelles et virtuelles du bord.">nb_faces_tot</a>();
      <span class="keywordflow">for</span>(<span class="keywordtype">int</span> ind_face=0; ind_face&lt;nb_faces_bord_tot; ind_face++)
        {
          ok=<a class="code" href="AssembleurPP1BUtil_8cpp.html#a40cf40213663174bb24649e51832bf3e">okface</a>(ind_face, face, la_cl);
          <span class="keywordflow">if</span> (ok==-1) <span class="keywordflow">break</span>;
          elem1=face_voisins(face, 0);
          elem2=face_voisins(face, 1);
          <a class="code" href="AssembleurPP1BUtil_8cpp.html#afd0a249a235b161c5267e7574e199a82">remplir_sommets</a>(zone_VEF, face, elem1, elem2, sommets,
                          face_opp1, face_opp2);
          <a class="code" href="AssembleurPP1BUtil_8cpp.html#acff816d35f8d4ce978f860e0cd958b8a">sort</a>(sommets, face_opp1, face_opp2);
          <span class="keywordflow">if</span>(ok==3)
            {
              <a class="code" href="AssembleurPP1BUtil_8cpp.html#a5e6fc2e2157dce70a345b3d8c1294477">contribuer_matrice_NeumannP0P1</a>(zone_VEF,
                                             inverse_quantitee_entrelacee,
                                             face, elem1, sommets,
                                             face_opp1, coef_som,
                                             voisins, coeffs, nnz);
            }
          <span class="keywordflow">else</span> <span class="keywordflow">if</span>(ok==4)
            {
              ;<span class="comment">//!&lt; RIEN</span>
<span class="comment"></span>            }
          <span class="keywordflow">else</span>
            <a class="code" href="AssembleurPP1BUtil_8cpp.html#ae2056e931f2d24d03da578b6af30cd54">contribuer_matriceP0P1</a>(zone_VEF,
                                   inverse_quantitee_entrelacee,
                                   face, elem1, elem2, sommets,
                                   face_opp1, face_opp2, coef_som,
                                   voisins, coeffs, nnz);
        }
    }
  <a class="code" href="AssembleurPP1BUtil_8cpp.html#a3e374d53ebc7860e1c2f0b7906f2936d">face_associee</a>=-1;
  <span class="keywordflow">for</span>(face=nint; face&lt;nb_faces; face++)
    {
      elem1=face_voisins(face, 0);
      elem2=face_voisins(face, 1);
      <span class="keywordflow">if</span> (!zone_VEF.<a class="code" href="classZone__VF.html#a33909d3880435e82e84639b51482d2c6" title="renvoie 1 si face est une face virtuelle de bord, 0 sinon">est_une_face_virt_bord</a>(face)) <span class="comment">//!&lt; On ne traite que les faces internes</span>
<span class="comment"></span>        {
          <a class="code" href="AssembleurPP1BUtil_8cpp.html#afd0a249a235b161c5267e7574e199a82">remplir_sommets</a>(zone_VEF, face, elem1, elem2, sommets,
                          face_opp1, face_opp2);
          <a class="code" href="AssembleurPP1BUtil_8cpp.html#acff816d35f8d4ce978f860e0cd958b8a">sort</a>(sommets, face_opp1, face_opp2);
          <a class="code" href="AssembleurPP1BUtil_8cpp.html#ae2056e931f2d24d03da578b6af30cd54">contribuer_matriceP0P1</a>(zone_VEF,
                                 inverse_quantitee_entrelacee,
                                 face, elem1, elem2, sommets,
                                 face_opp1, face_opp2, coef_som,
                                 voisins, coeffs, nnz);
        }
    }

  matrice.<a class="code" href="classDeriv__.html#ad1d33400ed15b6ff96579ed82d9e2719" title="Essaie de creer une instance du type &quot;type&quot;. si type n&#39;est pas un type ou type n&#39;est pas instanciab...">typer</a>(<span class="stringliteral">&quot;Matrice_Bloc&quot;</span>);
  <a class="code" href="classMatrice__Bloc.html">Matrice_Bloc</a>&amp; matrice_bloc=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Bloc.html">Matrice_Bloc</a>, matrice.<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>());
  matrice_bloc.<a class="code" href="classMatrice__Bloc.html#a7d624ebd3f141e34502e59f6d1b1d601">remplir</a>(voisins, coeffs, zone.<a class="code" href="classZone.html#a7f249429803b27139a1c54436f6164a5" title="Renvoie le nombre d&#39;elements de la zone.">nb_elem</a>(), zone.<a class="code" href="classZone.html#aa3a33e8b723618b9092460007153e42d" title="Renvoie le nombre total d&#39;elements de la zone.">nb_elem_tot</a>(), zone.<a class="code" href="classZone.html#ad340f571f81fa5c2e028b88c00b5c2ca" title="Renvoie le nombre de sommets de la zone.">nb_som</a>(), zone.<a class="code" href="classZone.html#a01ed67af826d6045ef4eacfb87a663e8" title="Renvoie le nombre total de sommets de la zone. i.e. le nombre de sommets reels et virtuels sur le pro...">nb_som_tot</a>());
  <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Assemblage POP1 OK&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a30b5e404b46e2a239584ee19835c88bf"></a><!-- doxytag: member="Assembleur_P_VEFPreP1B.cpp::assemblerP0Pa" ref="a30b5e404b46e2a239584ee19835c88bf" args="(const Zone_dis_base &amp;z, const Zone_Cl_dis_base &amp;zcl, Matrice &amp;matrice, const DoubleTab &amp;inverse_quantitee_entrelacee)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void assemblerP0Pa </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classZone__dis__base.html">Zone_dis_base</a> &amp;&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classZone__Cl__dis__base.html">Zone_Cl_dis_base</a> &amp;&#160;</td>
          <td class="paramname"><em>zcl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatrice.html">Matrice</a> &amp;&#160;</td>
          <td class="paramname"><em>matrice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>inverse_quantitee_entrelacee</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>&lt; RIEN</p>
<p>&lt; On ne traite que les faces internes </p>
</p>

<p>Definition at line <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l02655">2655</a> of file <a class="el" href="AssembleurPP1BUtil_8cpp_source.html">AssembleurPP1BUtil.cpp</a>.</p>

<p>References <a class="el" href="EntreeSortie_8h_source.html#l00032">Cerr</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l01710">contribuer_matrice_NeumannP0Pa()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l01558">contribuer_matriceP0Pa()</a>, <a class="el" href="Objet__U_8h_source.html#l00079">Objet_U::dimension</a>, <a class="el" href="Zone__VF_8h_source.html#l00773">Zone_VF::est_une_face_virt_bord()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00046">face_associee</a>, <a class="el" href="Zone__VF_8h_source.html#l00458">Zone_VF::face_voisins()</a>, <a class="el" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>, <a class="el" href="Cond__lim_8h_source.html#l00130">Cond_lim::frontiere_dis()</a>, <a class="el" href="Zone__Cl__dis__base_8cpp_source.html#l00522">Zone_Cl_dis_base::les_conditions_limites()</a>, <a class="el" href="Zone_8h_source.html#l01258">Zone::nb_aretes()</a>, <a class="el" href="Zone_8h_source.html#l01266">Zone::nb_aretes_tot()</a>, <a class="el" href="Zone_8h_source.html#l00300">Zone::nb_elem()</a>, <a class="el" href="Zone_8h_source.html#l00319">Zone::nb_elem_tot()</a>, <a class="el" href="Front__VF_8h_source.html#l00066">Front_VF::nb_faces_tot()</a>, <a class="el" href="Zone__VF_8h_source.html#l00527">Zone_VF::nb_faces_tot()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00081">okface()</a>, <a class="el" href="Zone__VF_8h_source.html#l00512">Zone_VF::premiere_face_int()</a>, <a class="el" href="Cast_8h_source.html#l00059">ref_cast</a>, <a class="el" href="Matrice__Bloc_8cpp_source.html#l00647">Matrice_Bloc::remplir()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00349">remplir_sommets()</a>, <a class="el" href="vect__impl_8h_source.html#l00057">vect_impl::size()</a>, <a class="el" href="Deriv___8cpp_source.html#l00091">Deriv_::typer()</a>, <a class="el" href="Deriv__Matrice__Base_8h_source.html#l00028">Deriv_Matrice_Base::valeur()</a>, and <a class="el" href="Zone__dis__base_8h_source.html#l00106">Zone_dis_base::zone()</a>.</p>

<p>Referenced by <a class="el" href="Assembleur__P__VEFPreP1B_8cpp_source.html#l00230">Assembleur_P_VEFPreP1B::assembler_mat()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">int</span> dimension=<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>;
  <span class="keyword">const</span> <a class="code" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a>&amp; zone_VEF=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a>, z);
  <span class="keyword">const</span> <a class="code" href="classZone.html" title="classe Zone Une Zone est un maillage compose d&#39;un ensemble d&#39;elements geometriques de meme type...">Zone</a>&amp; zone=zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>();
  <span class="keyword">const</span> <a class="code" href="classZone__Cl__VEF.html">Zone_Cl_VEF</a>&amp; zone_Cl_VEF=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classZone__Cl__VEF.html">Zone_Cl_VEF</a>, zcl);
  <span class="keyword">const</span> <a class="code" href="classConds__lim.html">Conds_lim</a>&amp; les_cl = zone_Cl_VEF.<a class="code" href="classZone__Cl__dis__base.html#af75e0ed7786863e4d333bfb29d67c323" title="Renvoie la i-ieme condition aux limites. (version const)">les_conditions_limites</a>();
  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; face_voisins = zone_VEF.<a class="code" href="classZone__VF.html#a49d4322f5585a8fa95748ca785b70702" title="renvoie l&#39;element voisin de numface dans la direction i. i=0 : dans le sens oppose de l&#39;axe orthogona...">face_voisins</a>();
  <span class="keywordtype">int</span> nint = zone_VEF.<a class="code" href="classZone__VF.html#a12869806fa4834aca8f2964e16509dfd" title="une face est interne ssi elle separe deux elements. renvoie le numero de la premiere face interne...">premiere_face_int</a>();
  <span class="keywordtype">int</span> nb_faces = zone_VEF.<a class="code" href="classZone__VF.html#a50fd21c9535680489015a3c8b88c685a" title="renvoie le nombre total de faces. C&#39;est-a-dire faces reelles + faces virtuelles">nb_faces_tot</a>();
  <span class="keywordtype">int</span> nb_elem = zone.<a class="code" href="classZone.html#aa3a33e8b723618b9092460007153e42d" title="Renvoie le nombre total d&#39;elements de la zone.">nb_elem_tot</a>();
  <span class="keywordtype">int</span> elem1, elem2, face, ok;
  <span class="keywordtype">int</span> nnz=0;
  <a class="code" href="classIntLists.html" title="Un tableau de listes de type IntList.">IntLists</a> voisins(nb_elem);
  <a class="code" href="classDoubleLists.html" title="Un tableau de listes de type DoubleList.">DoubleLists</a> coeffs(nb_elem);
  <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> sommets(dimension+2);
  <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> face_opp1(dimension+2);
  <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> face_opp2(dimension+2);
<span class="comment">// Faces de bord :</span>
  <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;les_cl.<a class="code" href="classvect__impl.html#a78155bfbd6b61f4710b9830641ed1694">size</a>(); i++)
    {
      <span class="keyword">const</span> <a class="code" href="classCond__lim.html" title="classe Cond_lim Classe generique servant a representer n&#39;importe quelle classe derivee de la classe C...">Cond_lim</a>&amp; la_cl = les_cl[i];
      <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp; le_bord = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>,la_cl.<a class="code" href="classCond__lim.html#a5b2d24809cee07727006a891d4ce8d22" title="Appel a l&#39;objet sous-jacent Renvoie la frontiere discretisee associee a la condition aux limites...">frontiere_dis</a>());
      <span class="keywordtype">int</span> nb_faces_bord_tot = le_bord.<a class="code" href="classFront__VF.html#aed4006d91bf2ef3af2b9f7933d863a09" title="Nombre de faces reelles et virtuelles du bord.">nb_faces_tot</a>();
      <span class="keywordflow">for</span>(<span class="keywordtype">int</span> ind_face=0; ind_face&lt;nb_faces_bord_tot; ind_face++)
        {
          ok=<a class="code" href="AssembleurPP1BUtil_8cpp.html#a40cf40213663174bb24649e51832bf3e">okface</a>(ind_face, face, la_cl);
          <span class="keywordflow">if</span> (ok==-1) <span class="keywordflow">break</span>;
          elem1=face_voisins(face, 0);
          elem2=face_voisins(face, 1);
          <a class="code" href="AssembleurPP1BUtil_8cpp.html#afd0a249a235b161c5267e7574e199a82">remplir_sommets</a>(zone_VEF, face, elem1, elem2, sommets,
                          face_opp1, face_opp2);
          <span class="keywordflow">if</span>(ok==3)
            {
              <a class="code" href="AssembleurPP1BUtil_8cpp.html#ae709048ec2f850b47b8601c013ed8550">contribuer_matrice_NeumannP0Pa</a>(zone_VEF,
                                             inverse_quantitee_entrelacee,
                                             face, elem1, sommets,
                                             face_opp1,
                                             voisins, coeffs, nnz);
            }
          <span class="keywordflow">else</span> <span class="keywordflow">if</span>(ok==4)
            {
              ; <span class="comment">//!&lt; RIEN</span>
<span class="comment"></span>            }
          <span class="keywordflow">else</span>
            <a class="code" href="AssembleurPP1BUtil_8cpp.html#a36c4cdf9e6baa421844cf7cffa1396df">contribuer_matriceP0Pa</a>(zone_VEF, inverse_quantitee_entrelacee, face, elem1, elem2, sommets,
                                   face_opp1, face_opp2,
                                   voisins, coeffs, nnz);
        }
    }
  <a class="code" href="AssembleurPP1BUtil_8cpp.html#a3e374d53ebc7860e1c2f0b7906f2936d">face_associee</a>=-1;
  <span class="keywordflow">for</span>(face=nint; face&lt;nb_faces; face++)
    {
      elem1=face_voisins(face, 0);
      elem2=face_voisins(face, 1);
      <span class="keywordflow">if</span> (!zone_VEF.<a class="code" href="classZone__VF.html#a33909d3880435e82e84639b51482d2c6" title="renvoie 1 si face est une face virtuelle de bord, 0 sinon">est_une_face_virt_bord</a>(face)) <span class="comment">//!&lt; On ne traite que les faces internes</span>
<span class="comment"></span>        {
          <a class="code" href="AssembleurPP1BUtil_8cpp.html#afd0a249a235b161c5267e7574e199a82">remplir_sommets</a>(zone_VEF, face, elem1, elem2, sommets,
                          face_opp1, face_opp2);
          <a class="code" href="AssembleurPP1BUtil_8cpp.html#a36c4cdf9e6baa421844cf7cffa1396df">contribuer_matriceP0Pa</a>(zone_VEF,
                                 inverse_quantitee_entrelacee,
                                 face, elem1, elem2, sommets,
                                 face_opp1, face_opp2,
                                 voisins, coeffs, nnz);
        }
    }
  matrice.<a class="code" href="classDeriv__.html#ad1d33400ed15b6ff96579ed82d9e2719" title="Essaie de creer une instance du type &quot;type&quot;. si type n&#39;est pas un type ou type n&#39;est pas instanciab...">typer</a>(<span class="stringliteral">&quot;Matrice_Bloc&quot;</span>);
  <a class="code" href="classMatrice__Bloc.html">Matrice_Bloc</a>&amp; matrice_bloc=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Bloc.html">Matrice_Bloc</a>, matrice.<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>());
  matrice_bloc.<a class="code" href="classMatrice__Bloc.html#a7d624ebd3f141e34502e59f6d1b1d601">remplir</a>(voisins, coeffs, zone.<a class="code" href="classZone.html#a7f249429803b27139a1c54436f6164a5" title="Renvoie le nombre d&#39;elements de la zone.">nb_elem</a>(), zone.<a class="code" href="classZone.html#aa3a33e8b723618b9092460007153e42d" title="Renvoie le nombre total d&#39;elements de la zone.">nb_elem_tot</a>(), zone.<a class="code" href="classZone.html#a3e3b48691911fd85574c7bc10a1a4fb8" title="renvoie le nombre d&#39;aretes reelles.">nb_aretes</a>(), zone.<a class="code" href="classZone.html#a59ae0ababf85ce303a7c6f339430e335" title="renvoie le nombre d&#39;aretes total (reelles+virtuelles).">nb_aretes_tot</a>());
  <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Assemblage P0Pa OK&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a31f132f3fda04d8428de212c63fd902f"></a><!-- doxytag: member="Assembleur_P_VEFPreP1B.cpp::assemblerP1P1" ref="a31f132f3fda04d8428de212c63fd902f" args="(const Zone_dis_base &amp;z, const Zone_Cl_dis_base &amp;zcl, Matrice &amp;matrice, const DoubleTab &amp;inverse_quantitee_entrelacee, const ArrOfDouble &amp;coef_som)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void assemblerP1P1 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classZone__dis__base.html">Zone_dis_base</a> &amp;&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classZone__Cl__dis__base.html">Zone_Cl_dis_base</a> &amp;&#160;</td>
          <td class="paramname"><em>zcl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatrice.html">Matrice</a> &amp;&#160;</td>
          <td class="paramname"><em>matrice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>inverse_quantitee_entrelacee</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;&#160;</td>
          <td class="paramname"><em>coef_som</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>&lt; On ne traite que les faces internes </p>
</p>

<p>Definition at line <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l02247">2247</a> of file <a class="el" href="AssembleurPP1BUtil_8cpp_source.html">AssembleurPP1BUtil.cpp</a>.</p>

<p>References <a class="el" href="EntreeSortie_8h_source.html#l00032">Cerr</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l01028">contribuer_matrice_NeumannP1P1()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l01138">contribuer_matrice_SymetrieP1P1()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00638">contribuer_matriceP1P1()</a>, <a class="el" href="Objet__U_8h_source.html#l00079">Objet_U::dimension</a>, <a class="el" href="Zone__VF_8h_source.html#l00773">Zone_VF::est_une_face_virt_bord()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00046">face_associee</a>, <a class="el" href="Zone__VF_8h_source.html#l00458">Zone_VF::face_voisins()</a>, <a class="el" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>, <a class="el" href="Cond__lim_8h_source.html#l00130">Cond_lim::frontiere_dis()</a>, <a class="el" href="Zone__Cl__dis__base_8cpp_source.html#l00522">Zone_Cl_dis_base::les_conditions_limites()</a>, <a class="el" href="Front__VF_8h_source.html#l00066">Front_VF::nb_faces_tot()</a>, <a class="el" href="Zone__VF_8h_source.html#l00527">Zone_VF::nb_faces_tot()</a>, <a class="el" href="Zone_8cpp_source.html#l00586">Zone::nb_som()</a>, <a class="el" href="Zone_8cpp_source.html#l00608">Zone::nb_som_tot()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00081">okface()</a>, <a class="el" href="Zone__VF_8h_source.html#l00512">Zone_VF::premiere_face_int()</a>, <a class="el" href="Cast_8h_source.html#l00059">ref_cast</a>, <a class="el" href="Matrice__Bloc_8cpp_source.html#l00647">Matrice_Bloc::remplir()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00349">remplir_sommets()</a>, <a class="el" href="vect__impl_8h_source.html#l00057">vect_impl::size()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00286">sort()</a>, <a class="el" href="Deriv___8cpp_source.html#l00091">Deriv_::typer()</a>, <a class="el" href="Deriv__Matrice__Base_8h_source.html#l00028">Deriv_Matrice_Base::valeur()</a>, and <a class="el" href="Zone__dis__base_8h_source.html#l00106">Zone_dis_base::zone()</a>.</p>

<p>Referenced by <a class="el" href="Assembleur__P__VEFPreP1B_8cpp_source.html#l00230">Assembleur_P_VEFPreP1B::assembler_mat()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">int</span> dimension=<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>;
  <span class="keyword">const</span> <a class="code" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a>&amp; zone_VEF=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a>, z);
  <span class="keyword">const</span> <a class="code" href="classZone.html" title="classe Zone Une Zone est un maillage compose d&#39;un ensemble d&#39;elements geometriques de meme type...">Zone</a>&amp; zone=zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>();
  <span class="keyword">const</span> <a class="code" href="classZone__Cl__VEF.html">Zone_Cl_VEF</a>&amp; zone_Cl_VEF=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classZone__Cl__VEF.html">Zone_Cl_VEF</a>, zcl);
  <span class="keyword">const</span> <a class="code" href="classConds__lim.html">Conds_lim</a>&amp; les_cl = zone_Cl_VEF.<a class="code" href="classZone__Cl__dis__base.html#af75e0ed7786863e4d333bfb29d67c323" title="Renvoie la i-ieme condition aux limites. (version const)">les_conditions_limites</a>();
  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; face_voisins = zone_VEF.<a class="code" href="classZone__VF.html#a49d4322f5585a8fa95748ca785b70702" title="renvoie l&#39;element voisin de numface dans la direction i. i=0 : dans le sens oppose de l&#39;axe orthogona...">face_voisins</a>();
  <span class="keywordtype">int</span> nint = zone_VEF.<a class="code" href="classZone__VF.html#a12869806fa4834aca8f2964e16509dfd" title="une face est interne ssi elle separe deux elements. renvoie le numero de la premiere face interne...">premiere_face_int</a>();
  <span class="keywordtype">int</span> nb_faces = zone_VEF.<a class="code" href="classZone__VF.html#a50fd21c9535680489015a3c8b88c685a" title="renvoie le nombre total de faces. C&#39;est-a-dire faces reelles + faces virtuelles">nb_faces_tot</a>();
  <span class="keywordtype">int</span> nb_som = zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#a01ed67af826d6045ef4eacfb87a663e8" title="Renvoie le nombre total de sommets de la zone. i.e. le nombre de sommets reels et virtuels sur le pro...">nb_som_tot</a>();
  <span class="keywordtype">int</span> elem1, elem2, face, ok;
  <span class="keywordtype">int</span> nnz=nb_som;
  <a class="code" href="classIntLists.html" title="Un tableau de listes de type IntList.">IntLists</a> voisins(nb_som);
  <a class="code" href="classDoubleLists.html" title="Un tableau de listes de type DoubleList.">DoubleLists</a> coeffs(nb_som);
  <a class="code" href="classDoubleVect.html">DoubleVect</a> diag(nb_som);
  <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> sommets(dimension+2);
  <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> face_opp1(dimension+2);
  <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> face_opp2(dimension+2);
<span class="comment">// Faces de bord :</span>
  <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;les_cl.<a class="code" href="classvect__impl.html#a78155bfbd6b61f4710b9830641ed1694">size</a>(); i++)
    {
      <span class="keyword">const</span> <a class="code" href="classCond__lim.html" title="classe Cond_lim Classe generique servant a representer n&#39;importe quelle classe derivee de la classe C...">Cond_lim</a>&amp; la_cl = les_cl[i];
      <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp; le_bord = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>,la_cl.<a class="code" href="classCond__lim.html#a5b2d24809cee07727006a891d4ce8d22" title="Appel a l&#39;objet sous-jacent Renvoie la frontiere discretisee associee a la condition aux limites...">frontiere_dis</a>());
      <span class="keywordtype">int</span> nb_faces_bord_tot = le_bord.<a class="code" href="classFront__VF.html#aed4006d91bf2ef3af2b9f7933d863a09" title="Nombre de faces reelles et virtuelles du bord.">nb_faces_tot</a>();
      <span class="keywordflow">for</span>(<span class="keywordtype">int</span> ind_face=0; ind_face&lt;nb_faces_bord_tot; ind_face++)
        {
          ok=<a class="code" href="AssembleurPP1BUtil_8cpp.html#a40cf40213663174bb24649e51832bf3e">okface</a>(ind_face, face, la_cl);
          <span class="keywordflow">if</span> (ok==-1) <span class="keywordflow">break</span>;
          elem1=face_voisins(face, 0);
          elem2=face_voisins(face, 1);
          <a class="code" href="AssembleurPP1BUtil_8cpp.html#afd0a249a235b161c5267e7574e199a82">remplir_sommets</a>(zone_VEF, face, elem1, elem2, sommets,
                          face_opp1, face_opp2);
          <a class="code" href="AssembleurPP1BUtil_8cpp.html#acff816d35f8d4ce978f860e0cd958b8a">sort</a>(sommets, face_opp1, face_opp2);
          <span class="keywordflow">if</span>(ok==3)
            {
              <a class="code" href="AssembleurPP1BUtil_8cpp.html#ad9eeb295c62a30fa2305edf29ad7cfd5">contribuer_matrice_NeumannP1P1</a>(zone_VEF,
                                             inverse_quantitee_entrelacee,
                                             face, elem1, sommets,
                                             face_opp1, coef_som,
                                             voisins, coeffs, diag, nnz);
            }
          <span class="keywordflow">else</span> <span class="keywordflow">if</span>(ok==4)
            {
              <a class="code" href="AssembleurPP1BUtil_8cpp.html#a9568a5e0cbf3b9e2b60ad3f3bdac25df">contribuer_matrice_SymetrieP1P1</a>(zone_VEF,
                                              inverse_quantitee_entrelacee,
                                              face, elem1, sommets,
                                              face_opp1, coef_som,
                                              voisins, coeffs, diag, nnz);
            }
          <span class="keywordflow">else</span>
            <a class="code" href="AssembleurPP1BUtil_8cpp.html#ae9226a0247d37eab885c3915814c82c7">contribuer_matriceP1P1</a>(zone_VEF,
                                   inverse_quantitee_entrelacee,
                                   face, elem1, elem2, sommets,
                                   face_opp1, face_opp2, coef_som,
                                   voisins, coeffs, diag, nnz);
        }
    }
  <a class="code" href="AssembleurPP1BUtil_8cpp.html#a3e374d53ebc7860e1c2f0b7906f2936d">face_associee</a>=-1;
  <span class="keywordflow">for</span>(face=nint; face&lt;nb_faces; face++)
    {
      elem1=face_voisins(face, 0);
      elem2=face_voisins(face, 1);
      <span class="keywordflow">if</span> (!zone_VEF.<a class="code" href="classZone__VF.html#a33909d3880435e82e84639b51482d2c6" title="renvoie 1 si face est une face virtuelle de bord, 0 sinon">est_une_face_virt_bord</a>(face)) <span class="comment">//!&lt; On ne traite que les faces internes</span>
<span class="comment"></span>        {
          <a class="code" href="AssembleurPP1BUtil_8cpp.html#afd0a249a235b161c5267e7574e199a82">remplir_sommets</a>(zone_VEF, face, elem1, elem2, sommets,
                          face_opp1, face_opp2);
          <a class="code" href="AssembleurPP1BUtil_8cpp.html#acff816d35f8d4ce978f860e0cd958b8a">sort</a>(sommets, face_opp1, face_opp2);
          <a class="code" href="AssembleurPP1BUtil_8cpp.html#ae9226a0247d37eab885c3915814c82c7">contribuer_matriceP1P1</a>(zone_VEF,
                                 inverse_quantitee_entrelacee,
                                 face, elem1, elem2, sommets,
                                 face_opp1, face_opp2, coef_som,
                                 voisins, coeffs, diag, nnz);
        }
    }

  <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;nb_som; i++)
    <span class="keywordflow">if</span>(diag(i)==0)
      {
<span class="comment">// Cerr &lt;&lt; &quot;On modifie la ligne (sommet) orpheline &quot; &lt;&lt; i &lt;&lt; finl;</span>
        diag(i)=1.;
      }

  matrice.<a class="code" href="classDeriv__.html#ad1d33400ed15b6ff96579ed82d9e2719" title="Essaie de creer une instance du type &quot;type&quot;. si type n&#39;est pas un type ou type n&#39;est pas instanciab...">typer</a>(<span class="stringliteral">&quot;Matrice_Bloc&quot;</span>);
  <a class="code" href="classMatrice__Bloc.html">Matrice_Bloc</a>&amp; matrice_bloc=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Bloc.html">Matrice_Bloc</a>, matrice.<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>());
  matrice_bloc.<a class="code" href="classMatrice__Bloc.html#a7d624ebd3f141e34502e59f6d1b1d601">remplir</a>(voisins, coeffs, diag, zone.<a class="code" href="classZone.html#ad340f571f81fa5c2e028b88c00b5c2ca" title="Renvoie le nombre de sommets de la zone.">nb_som</a>(), zone.<a class="code" href="classZone.html#a01ed67af826d6045ef4eacfb87a663e8" title="Renvoie le nombre total de sommets de la zone. i.e. le nombre de sommets reels et virtuels sur le pro...">nb_som_tot</a>());
  <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Assemblage P1 OK&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a5dcfee4400f896bcbb100259f53a5de1"></a><!-- doxytag: member="Assembleur_P_VEFPreP1B.cpp::assemblerP1Pa" ref="a5dcfee4400f896bcbb100259f53a5de1" args="(const Zone_dis_base &amp;z, const Zone_Cl_dis_base &amp;zcl, Matrice &amp;matrice, const DoubleTab &amp;inverse_quantitee_entrelacee, const ArrOfDouble &amp;coef_som)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void assemblerP1Pa </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classZone__dis__base.html">Zone_dis_base</a> &amp;&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classZone__Cl__dis__base.html">Zone_Cl_dis_base</a> &amp;&#160;</td>
          <td class="paramname"><em>zcl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatrice.html">Matrice</a> &amp;&#160;</td>
          <td class="paramname"><em>matrice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>inverse_quantitee_entrelacee</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;&#160;</td>
          <td class="paramname"><em>coef_som</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>&lt; On ne traite que les faces internes </p>
</p>

<p>Definition at line <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l02803">2803</a> of file <a class="el" href="AssembleurPP1BUtil_8cpp_source.html">AssembleurPP1BUtil.cpp</a>.</p>

<p>References <a class="el" href="EntreeSortie_8h_source.html#l00032">Cerr</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l01958">contribuer_matrice_NeumannP1Pa()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l02092">contribuer_matrice_SymetrieP1Pa()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l01819">contribuer_matriceP1Pa()</a>, <a class="el" href="Objet__U_8h_source.html#l00079">Objet_U::dimension</a>, <a class="el" href="Zone__VF_8h_source.html#l00773">Zone_VF::est_une_face_virt_bord()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00046">face_associee</a>, <a class="el" href="Zone__VF_8h_source.html#l00458">Zone_VF::face_voisins()</a>, <a class="el" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>, <a class="el" href="Cond__lim_8h_source.html#l00130">Cond_lim::frontiere_dis()</a>, <a class="el" href="Zone__Cl__dis__base_8cpp_source.html#l00522">Zone_Cl_dis_base::les_conditions_limites()</a>, <a class="el" href="Zone_8h_source.html#l01258">Zone::nb_aretes()</a>, <a class="el" href="Zone_8h_source.html#l01266">Zone::nb_aretes_tot()</a>, <a class="el" href="Front__VF_8h_source.html#l00066">Front_VF::nb_faces_tot()</a>, <a class="el" href="Zone__VF_8h_source.html#l00527">Zone_VF::nb_faces_tot()</a>, <a class="el" href="Zone_8cpp_source.html#l00586">Zone::nb_som()</a>, <a class="el" href="Zone_8cpp_source.html#l00608">Zone::nb_som_tot()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00081">okface()</a>, <a class="el" href="Zone__VF_8h_source.html#l00512">Zone_VF::premiere_face_int()</a>, <a class="el" href="Cast_8h_source.html#l00059">ref_cast</a>, <a class="el" href="Matrice__Bloc_8cpp_source.html#l00647">Matrice_Bloc::remplir()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00349">remplir_sommets()</a>, <a class="el" href="vect__impl_8h_source.html#l00057">vect_impl::size()</a>, <a class="el" href="Deriv___8cpp_source.html#l00091">Deriv_::typer()</a>, <a class="el" href="Deriv__Matrice__Base_8h_source.html#l00028">Deriv_Matrice_Base::valeur()</a>, and <a class="el" href="Zone__dis__base_8h_source.html#l00106">Zone_dis_base::zone()</a>.</p>

<p>Referenced by <a class="el" href="Assembleur__P__VEFPreP1B_8cpp_source.html#l00230">Assembleur_P_VEFPreP1B::assembler_mat()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">int</span> dimension=<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>;
  <span class="keyword">const</span> <a class="code" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a>&amp; zone_VEF=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a>, z);
  <span class="keyword">const</span> <a class="code" href="classZone.html" title="classe Zone Une Zone est un maillage compose d&#39;un ensemble d&#39;elements geometriques de meme type...">Zone</a>&amp; zone=zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>();
  <span class="keyword">const</span> <a class="code" href="classZone__Cl__VEF.html">Zone_Cl_VEF</a>&amp; zone_Cl_VEF=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classZone__Cl__VEF.html">Zone_Cl_VEF</a>, zcl);
  <span class="keyword">const</span> <a class="code" href="classConds__lim.html">Conds_lim</a>&amp; les_cl = zone_Cl_VEF.<a class="code" href="classZone__Cl__dis__base.html#af75e0ed7786863e4d333bfb29d67c323" title="Renvoie la i-ieme condition aux limites. (version const)">les_conditions_limites</a>();
  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; face_voisins = zone_VEF.<a class="code" href="classZone__VF.html#a49d4322f5585a8fa95748ca785b70702" title="renvoie l&#39;element voisin de numface dans la direction i. i=0 : dans le sens oppose de l&#39;axe orthogona...">face_voisins</a>();
  <span class="keywordtype">int</span> nint = zone_VEF.<a class="code" href="classZone__VF.html#a12869806fa4834aca8f2964e16509dfd" title="une face est interne ssi elle separe deux elements. renvoie le numero de la premiere face interne...">premiere_face_int</a>();
  <span class="keywordtype">int</span> nb_faces = zone_VEF.<a class="code" href="classZone__VF.html#a50fd21c9535680489015a3c8b88c685a" title="renvoie le nombre total de faces. C&#39;est-a-dire faces reelles + faces virtuelles">nb_faces_tot</a>();
  <span class="keywordtype">int</span> elem1, elem2, face, ok;
  <span class="keywordtype">int</span> nnz=0;
  <span class="keywordtype">int</span> nb_som = zone.<a class="code" href="classZone.html#a01ed67af826d6045ef4eacfb87a663e8" title="Renvoie le nombre total de sommets de la zone. i.e. le nombre de sommets reels et virtuels sur le pro...">nb_som_tot</a>();
  <a class="code" href="classIntLists.html" title="Un tableau de listes de type IntList.">IntLists</a> voisins(nb_som);
  <a class="code" href="classDoubleLists.html" title="Un tableau de listes de type DoubleList.">DoubleLists</a> coeffs(nb_som);
  <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> sommets(dimension+2);
  <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> face_opp1(dimension+2);
  <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> face_opp2(dimension+2);
<span class="comment">// Faces de bord :</span>
  <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;les_cl.<a class="code" href="classvect__impl.html#a78155bfbd6b61f4710b9830641ed1694">size</a>(); i++)
    {
      <span class="keyword">const</span> <a class="code" href="classCond__lim.html" title="classe Cond_lim Classe generique servant a representer n&#39;importe quelle classe derivee de la classe C...">Cond_lim</a>&amp; la_cl = les_cl[i];
      <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp; le_bord = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>,la_cl.<a class="code" href="classCond__lim.html#a5b2d24809cee07727006a891d4ce8d22" title="Appel a l&#39;objet sous-jacent Renvoie la frontiere discretisee associee a la condition aux limites...">frontiere_dis</a>());
      <span class="keywordtype">int</span> nb_faces_bord_tot = le_bord.<a class="code" href="classFront__VF.html#aed4006d91bf2ef3af2b9f7933d863a09" title="Nombre de faces reelles et virtuelles du bord.">nb_faces_tot</a>();
      <span class="keywordflow">for</span>(<span class="keywordtype">int</span> ind_face=0; ind_face&lt;nb_faces_bord_tot; ind_face++)
        {
          ok=<a class="code" href="AssembleurPP1BUtil_8cpp.html#a40cf40213663174bb24649e51832bf3e">okface</a>(ind_face, face, la_cl);
          <span class="keywordflow">if</span> (ok==-1) <span class="keywordflow">break</span>;
          elem1=face_voisins(face, 0);
          elem2=face_voisins(face, 1);
          <a class="code" href="AssembleurPP1BUtil_8cpp.html#afd0a249a235b161c5267e7574e199a82">remplir_sommets</a>(zone_VEF, face, elem1, elem2, sommets,
                          face_opp1, face_opp2);
          <span class="keywordflow">if</span>(ok==3)
            {
              <a class="code" href="AssembleurPP1BUtil_8cpp.html#a1ee529d67fc174bfe005efe590812122">contribuer_matrice_NeumannP1Pa</a>(zone_VEF,
                                             inverse_quantitee_entrelacee,
                                             face, elem1, sommets,
                                             face_opp1,coef_som,
                                             voisins, coeffs, nnz);
            }
          <span class="keywordflow">else</span> <span class="keywordflow">if</span>(ok==4)
            {
              <a class="code" href="AssembleurPP1BUtil_8cpp.html#ae3056a39c9c01f3a2727f0dbf4b5e331">contribuer_matrice_SymetrieP1Pa</a>(zone_VEF,
                                              inverse_quantitee_entrelacee,
                                              face, elem1, sommets,
                                              face_opp1, coef_som,
                                              voisins, coeffs, nnz);
            }
          <span class="keywordflow">else</span>
            <a class="code" href="AssembleurPP1BUtil_8cpp.html#a0000fbbb1165039c7071352be4a35877">contribuer_matriceP1Pa</a>(zone_VEF,
                                   inverse_quantitee_entrelacee,
                                   face, elem1, elem2, sommets,
                                   face_opp1, face_opp2, coef_som,
                                   voisins, coeffs, nnz);
        }
    }
  <a class="code" href="AssembleurPP1BUtil_8cpp.html#a3e374d53ebc7860e1c2f0b7906f2936d">face_associee</a>=-1;
  <span class="keywordflow">for</span>(face=nint; face&lt;nb_faces; face++)
    {
      elem1=face_voisins(face, 0);
      elem2=face_voisins(face, 1);
      <span class="keywordflow">if</span> (!zone_VEF.<a class="code" href="classZone__VF.html#a33909d3880435e82e84639b51482d2c6" title="renvoie 1 si face est une face virtuelle de bord, 0 sinon">est_une_face_virt_bord</a>(face)) <span class="comment">//!&lt; On ne traite que les faces internes</span>
<span class="comment"></span>        {
          <a class="code" href="AssembleurPP1BUtil_8cpp.html#afd0a249a235b161c5267e7574e199a82">remplir_sommets</a>(zone_VEF, face, elem1, elem2, sommets,
                          face_opp1, face_opp2);
          <a class="code" href="AssembleurPP1BUtil_8cpp.html#a0000fbbb1165039c7071352be4a35877">contribuer_matriceP1Pa</a>(zone_VEF,
                                 inverse_quantitee_entrelacee,
                                 face, elem1, elem2, sommets,
                                 face_opp1, face_opp2, coef_som,
                                 voisins, coeffs, nnz);
        }
    }

  matrice.<a class="code" href="classDeriv__.html#ad1d33400ed15b6ff96579ed82d9e2719" title="Essaie de creer une instance du type &quot;type&quot;. si type n&#39;est pas un type ou type n&#39;est pas instanciab...">typer</a>(<span class="stringliteral">&quot;Matrice_Bloc&quot;</span>);
  <a class="code" href="classMatrice__Bloc.html">Matrice_Bloc</a>&amp; matrice_bloc=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Bloc.html">Matrice_Bloc</a>, matrice.<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>());
  matrice_bloc.<a class="code" href="classMatrice__Bloc.html#a7d624ebd3f141e34502e59f6d1b1d601">remplir</a>(voisins, coeffs, zone.<a class="code" href="classZone.html#ad340f571f81fa5c2e028b88c00b5c2ca" title="Renvoie le nombre de sommets de la zone.">nb_som</a>(), zone.<a class="code" href="classZone.html#a01ed67af826d6045ef4eacfb87a663e8" title="Renvoie le nombre total de sommets de la zone. i.e. le nombre de sommets reels et virtuels sur le pro...">nb_som_tot</a>(), zone.<a class="code" href="classZone.html#a3e3b48691911fd85574c7bc10a1a4fb8" title="renvoie le nombre d&#39;aretes reelles.">nb_aretes</a>(), zone.<a class="code" href="classZone.html#a59ae0ababf85ce303a7c6f339430e335" title="renvoie le nombre d&#39;aretes total (reelles+virtuelles).">nb_aretes_tot</a>());
  <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Assemblage P1Pa OK&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a7840f924363ed7d3fbd50a59d9d990c0"></a><!-- doxytag: member="Assembleur_P_VEFPreP1B.cpp::assemblerPaPa" ref="a7840f924363ed7d3fbd50a59d9d990c0" args="(const Zone_dis_base &amp;z, const Zone_Cl_dis_base &amp;zcl, Matrice &amp;matrice, const DoubleTab &amp;inverse_quantitee_entrelacee)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void assemblerPaPa </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classZone__dis__base.html">Zone_dis_base</a> &amp;&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classZone__Cl__dis__base.html">Zone_Cl_dis_base</a> &amp;&#160;</td>
          <td class="paramname"><em>zcl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatrice.html">Matrice</a> &amp;&#160;</td>
          <td class="paramname"><em>matrice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>inverse_quantitee_entrelacee</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>&lt; On ne traite que les faces internes </p>
</p>

<p>Definition at line <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l02477">2477</a> of file <a class="el" href="AssembleurPP1BUtil_8cpp_source.html">AssembleurPP1BUtil.cpp</a>.</p>

<p>References <a class="el" href="EntreeSortie_8h_source.html#l00032">Cerr</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l01241">contribuer_matrice_NeumannPaPa()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l01398">contribuer_matrice_SymetriePaPa()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00748">contribuer_matricePaPa()</a>, <a class="el" href="Objet__U_8h_source.html#l00079">Objet_U::dimension</a>, <a class="el" href="Zone__VF_8h_source.html#l00773">Zone_VF::est_une_face_virt_bord()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00046">face_associee</a>, <a class="el" href="Zone__VF_8h_source.html#l00458">Zone_VF::face_voisins()</a>, <a class="el" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>, <a class="el" href="Cond__lim_8h_source.html#l00130">Cond_lim::frontiere_dis()</a>, <a class="el" href="Zone__Cl__dis__base_8cpp_source.html#l00522">Zone_Cl_dis_base::les_conditions_limites()</a>, <a class="el" href="Zone_8h_source.html#l01258">Zone::nb_aretes()</a>, <a class="el" href="Zone_8h_source.html#l01266">Zone::nb_aretes_tot()</a>, <a class="el" href="Front__VF_8h_source.html#l00066">Front_VF::nb_faces_tot()</a>, <a class="el" href="Zone__VF_8h_source.html#l00527">Zone_VF::nb_faces_tot()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00081">okface()</a>, <a class="el" href="Zone__VF_8h_source.html#l00512">Zone_VF::premiere_face_int()</a>, <a class="el" href="Cast_8h_source.html#l00059">ref_cast</a>, <a class="el" href="Matrice__Bloc_8cpp_source.html#l00647">Matrice_Bloc::remplir()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00349">remplir_sommets()</a>, <a class="el" href="vect__impl_8h_source.html#l00057">vect_impl::size()</a>, <a class="el" href="Deriv___8cpp_source.html#l00091">Deriv_::typer()</a>, <a class="el" href="Deriv__Matrice__Base_8h_source.html#l00028">Deriv_Matrice_Base::valeur()</a>, and <a class="el" href="Zone__dis__base_8h_source.html#l00106">Zone_dis_base::zone()</a>.</p>

<p>Referenced by <a class="el" href="Assembleur__P__VEFPreP1B_8cpp_source.html#l00230">Assembleur_P_VEFPreP1B::assembler_mat()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">int</span> dimension=<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>;
  <span class="keyword">const</span> <a class="code" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a>&amp; zone_VEF=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a>, z);
  <span class="keyword">const</span> <a class="code" href="classZone.html" title="classe Zone Une Zone est un maillage compose d&#39;un ensemble d&#39;elements geometriques de meme type...">Zone</a>&amp; zone=zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>();
  <span class="keyword">const</span> <a class="code" href="classZone__Cl__VEF.html">Zone_Cl_VEF</a>&amp; zone_Cl_VEF=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classZone__Cl__VEF.html">Zone_Cl_VEF</a>, zcl);
  <span class="keyword">const</span> <a class="code" href="classConds__lim.html">Conds_lim</a>&amp; les_cl = zone_Cl_VEF.<a class="code" href="classZone__Cl__dis__base.html#af75e0ed7786863e4d333bfb29d67c323" title="Renvoie la i-ieme condition aux limites. (version const)">les_conditions_limites</a>();
  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; face_voisins = zone_VEF.<a class="code" href="classZone__VF.html#a49d4322f5585a8fa95748ca785b70702" title="renvoie l&#39;element voisin de numface dans la direction i. i=0 : dans le sens oppose de l&#39;axe orthogona...">face_voisins</a>();
  <span class="keywordtype">int</span> nint = zone_VEF.<a class="code" href="classZone__VF.html#a12869806fa4834aca8f2964e16509dfd" title="une face est interne ssi elle separe deux elements. renvoie le numero de la premiere face interne...">premiere_face_int</a>();
  <span class="keywordtype">int</span> nb_faces = zone_VEF.<a class="code" href="classZone__VF.html#a50fd21c9535680489015a3c8b88c685a" title="renvoie le nombre total de faces. C&#39;est-a-dire faces reelles + faces virtuelles">nb_faces_tot</a>();
  <span class="keywordtype">int</span> nb_arete = zone.<a class="code" href="classZone.html#a59ae0ababf85ce303a7c6f339430e335" title="renvoie le nombre d&#39;aretes total (reelles+virtuelles).">nb_aretes_tot</a>();
  <span class="keywordtype">int</span> elem1, elem2, face, ok;
  <span class="keywordtype">int</span> nnz=nb_arete;
  <a class="code" href="classIntLists.html" title="Un tableau de listes de type IntList.">IntLists</a> voisins(nb_arete);
  <a class="code" href="classDoubleLists.html" title="Un tableau de listes de type DoubleList.">DoubleLists</a> coeffs(nb_arete);
  <a class="code" href="classDoubleVect.html">DoubleVect</a> diag(nb_arete);
  <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> sommets(dimension+2);
  <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> face_opp1(dimension+2);
  <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> face_opp2(dimension+2);
<span class="comment">// Faces de bord :</span>
  <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;les_cl.<a class="code" href="classvect__impl.html#a78155bfbd6b61f4710b9830641ed1694">size</a>(); i++)
    {
      <span class="keyword">const</span> <a class="code" href="classCond__lim.html" title="classe Cond_lim Classe generique servant a representer n&#39;importe quelle classe derivee de la classe C...">Cond_lim</a>&amp; la_cl = les_cl[i];
      <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp; le_bord = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>,la_cl.<a class="code" href="classCond__lim.html#a5b2d24809cee07727006a891d4ce8d22" title="Appel a l&#39;objet sous-jacent Renvoie la frontiere discretisee associee a la condition aux limites...">frontiere_dis</a>());
      <span class="keywordtype">int</span> nb_faces_bord_tot = le_bord.<a class="code" href="classFront__VF.html#aed4006d91bf2ef3af2b9f7933d863a09" title="Nombre de faces reelles et virtuelles du bord.">nb_faces_tot</a>();
      <span class="keywordflow">for</span>(<span class="keywordtype">int</span> ind_face=0; ind_face&lt;nb_faces_bord_tot; ind_face++)
        {
          ok=<a class="code" href="AssembleurPP1BUtil_8cpp.html#a40cf40213663174bb24649e51832bf3e">okface</a>(ind_face, face, la_cl);
          <span class="keywordflow">if</span> (ok==-1) <span class="keywordflow">break</span>;
          elem1=face_voisins(face, 0);
          elem2=face_voisins(face, 1);
          <a class="code" href="AssembleurPP1BUtil_8cpp.html#afd0a249a235b161c5267e7574e199a82">remplir_sommets</a>(zone_VEF, face, elem1, elem2, sommets,
                          face_opp1, face_opp2);
          <span class="keywordflow">if</span>(ok==3)
            {
              <a class="code" href="AssembleurPP1BUtil_8cpp.html#a80033228b3ed99e778b70c35cda5e4e6">contribuer_matrice_NeumannPaPa</a>(zone_VEF,
                                             inverse_quantitee_entrelacee,
                                             face, elem1, sommets,
                                             face_opp1,
                                             voisins, coeffs, diag, nnz);
            }
          <span class="keywordflow">else</span> <span class="keywordflow">if</span>(ok==4)
            {
              <a class="code" href="AssembleurPP1BUtil_8cpp.html#ac51ccb6fe9aac0200f1b08da9d81c65b">contribuer_matrice_SymetriePaPa</a>(zone_VEF,
                                              inverse_quantitee_entrelacee,
                                              face, elem1, sommets,
                                              face_opp1,
                                              voisins, coeffs, diag, nnz);
            }
          <span class="keywordflow">else</span>
            <a class="code" href="AssembleurPP1BUtil_8cpp.html#a59992a437cf7e18b4b9ce353d77d0bda">contribuer_matricePaPa</a>(zone_VEF,
                                   inverse_quantitee_entrelacee,
                                   face, elem1, elem2, sommets,
                                   face_opp1, face_opp2,
                                   voisins, coeffs, diag, nnz);
        }
    }
  <a class="code" href="AssembleurPP1BUtil_8cpp.html#a3e374d53ebc7860e1c2f0b7906f2936d">face_associee</a>=-1;
  <span class="keywordflow">for</span>(face=nint; face&lt;nb_faces; face++)
    {
      elem1=face_voisins(face, 0);
      elem2=face_voisins(face, 1);
      <span class="keywordflow">if</span> (!zone_VEF.<a class="code" href="classZone__VF.html#a33909d3880435e82e84639b51482d2c6" title="renvoie 1 si face est une face virtuelle de bord, 0 sinon">est_une_face_virt_bord</a>(face)) <span class="comment">//!&lt; On ne traite que les faces internes</span>
<span class="comment"></span>        {
          <a class="code" href="AssembleurPP1BUtil_8cpp.html#afd0a249a235b161c5267e7574e199a82">remplir_sommets</a>(zone_VEF, face, elem1, elem2, sommets,
                          face_opp1, face_opp2);
          <a class="code" href="AssembleurPP1BUtil_8cpp.html#a59992a437cf7e18b4b9ce353d77d0bda">contribuer_matricePaPa</a>(zone_VEF,
                                 inverse_quantitee_entrelacee,
                                 face, elem1, elem2, sommets,
                                 face_opp1, face_opp2,
                                 voisins, coeffs, diag, nnz);
        }
    }
  <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;nb_arete; i++)
    <span class="keywordflow">if</span>(diag(i)==0)
      {
<span class="comment">// On n&#39;affiche pas car trop sur de gros maillages</span>
<span class="comment">// Cerr &lt;&lt; &quot;On modifie la ligne (arete) orpheline &quot; &lt;&lt; i &lt;&lt; finl;</span>
        diag(i)=1;
      }

  matrice.<a class="code" href="classDeriv__.html#ad1d33400ed15b6ff96579ed82d9e2719" title="Essaie de creer une instance du type &quot;type&quot;. si type n&#39;est pas un type ou type n&#39;est pas instanciab...">typer</a>(<span class="stringliteral">&quot;Matrice_Bloc&quot;</span>);
  <a class="code" href="classMatrice__Bloc.html">Matrice_Bloc</a>&amp; matrice_bloc=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Bloc.html">Matrice_Bloc</a>, matrice.<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>());
  matrice_bloc.<a class="code" href="classMatrice__Bloc.html#a7d624ebd3f141e34502e59f6d1b1d601">remplir</a>(voisins, coeffs, diag, zone.<a class="code" href="classZone.html#a3e3b48691911fd85574c7bc10a1a4fb8" title="renvoie le nombre d&#39;aretes reelles.">nb_aretes</a>(), zone.<a class="code" href="classZone.html#a59ae0ababf85ce303a7c6f339430e335" title="renvoie le nombre d&#39;aretes total (reelles+virtuelles).">nb_aretes_tot</a>());
  <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Assemblage Pa OK&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="ad6ea924b20e311b70fc786906b53805b"></a><!-- doxytag: member="Assembleur_P_VEFPreP1B.cpp::estim_cond" ref="ad6ea924b20e311b70fc786906b53805b" args="(Matrice &amp;A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static double estim_cond </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMatrice.html">Matrice</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Assembleur__P__VEFPreP1B_8cpp_source.html#l00063">63</a> of file <a class="el" href="Assembleur__P__VEFPreP1B_8cpp_source.html">Assembleur_P_VEFPreP1B.cpp</a>.</p>

<p>References <a class="el" href="EntreeSortie_8h_source.html#l00032">Cerr</a>, <a class="el" href="Matrice__Base_8h_source.html#l00324">Matrice_Base::imprimer_formatte()</a>, <a class="el" href="DoubleVect_8cpp_source.html#l02342">mp_prodscal()</a>, <a class="el" href="Matrice__Base_8h_source.html#l00127">Matrice_Base::multvect()</a>, <a class="el" href="classMatrice__Base.html#a78420d19112a02c5808daa50151bbb09">Matrice_Base::nb_lignes()</a>, and <a class="el" href="Deriv__Matrice__Base_8h_source.html#l00028">Deriv_Matrice_Base::valeur()</a>.</p>

<p>Referenced by <a class="el" href="Assembleur__P__VEFPreP1B_8cpp_source.html#l00230">Assembleur_P_VEFPreP1B::assembler_mat()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">int</span> i=A.<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>( ).<a class="code" href="classMatrice__Base.html#a78420d19112a02c5808daa50151bbb09">nb_lignes</a>();
<span class="comment">// Cout &lt;&lt; &quot;rang &quot; &lt;&lt; i &lt;&lt; finl;</span>
  <a class="code" href="classDoubleVect.html">DoubleVect</a> p(A.<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>( ).<a class="code" href="classMatrice__Base.html#a78420d19112a02c5808daa50151bbb09">nb_lignes</a>());
  <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j=0; j&lt;i; j++)
    p(j)=drand48();
  <span class="keywordtype">double</span> normep=sqrt(<a class="code" href="DoubleVect_8cpp.html#a07d13cbdadca6b60d5e128653f52a4bb">mp_prodscal</a>(p,p));
  p/=normep;
  <a class="code" href="classDoubleVect.html">DoubleVect</a> r(A.<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>( ).<a class="code" href="classMatrice__Base.html#a78420d19112a02c5808daa50151bbb09">nb_lignes</a>());
  <span class="keywordtype">double</span> lmax=1.e-36, lmin=1.e24;
<span class="comment">// double cond=-1;</span>
  i=10000;
  <span class="keywordflow">while</span>(i-- )
    {
<span class="comment">// cond=lmax/lmin;</span>
      A.<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>( ).<a class="code" href="classMatrice__Base.html#a05caa487a25a6d5e7fbd38d4b2f4ee1e" title="Multiplication d&#39;un vecteur par la matrice. Operation: r = A*x.">multvect</a>(p,r);
      <span class="keywordtype">double</span> pscpr=<a class="code" href="DoubleVect_8cpp.html#a07d13cbdadca6b60d5e128653f52a4bb">mp_prodscal</a>(p,r);
<span class="comment">// Cout &lt;&lt; &quot;lambda &quot; &lt;&lt; i &lt;&lt; &quot; : &quot; &lt;&lt; pscpr &lt;&lt; &quot; , &quot; &lt;&lt; lmax/lmin &lt;&lt; finl;</span>
      <span class="keywordtype">double</span> pscrr=<a class="code" href="DoubleVect_8cpp.html#a07d13cbdadca6b60d5e128653f52a4bb">mp_prodscal</a>(r,r);
      <span class="keywordtype">double</span> epsilon=-pscpr/pscrr;
      p.ajoute(epsilon,r);
      <span class="keywordtype">double</span> normepbis=sqrt(<a class="code" href="DoubleVect_8cpp.html#a07d13cbdadca6b60d5e128653f52a4bb">mp_prodscal</a>(p,p));
<span class="comment">// Cout &lt;&lt; &quot;normep : &quot; &lt;&lt; normep &lt;&lt; finl;</span>
      p/=normepbis;
      <span class="keywordflow">if</span>(pscpr&gt;lmax)
        lmax=pscpr;
      <span class="keywordflow">else</span> <span class="keywordflow">if</span>(pscpr&lt;lmin)
        lmin=pscpr;
    }
<span class="comment">// Cout &lt;&lt; &quot;lmax &quot; &lt;&lt; lmax &lt;&lt; &quot; lmin = &quot; &lt;&lt; lmin &lt;&lt; finl;</span>
<span class="comment">// Cout &lt;&lt; p &lt;&lt; finl;</span>
  <span class="keywordflow">if</span> (A.<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>( ).<a class="code" href="classMatrice__Base.html#a78420d19112a02c5808daa50151bbb09">nb_lignes</a>()&lt;30) A.<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>( ).<a class="code" href="classMatrice__Base.html#a2167f10f0e4efb71013a18aa44403f4e">imprimer_formatte</a>(<a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a>);

  <span class="keywordflow">return</span>(lmax/lmin);
}
</pre></div>
</div>
</div>
<a class="anchor" id="a1ce15acad922bef2d305d970c13c68c8"></a><!-- doxytag: member="Assembleur_P_VEFPreP1B.cpp::modifieP1P1neumann" ref="a1ce15acad922bef2d305d970c13c68c8" args="(const Zone_dis_base &amp;z, const Zone_Cl_dis_base &amp;zcl, Matrice &amp;matrice, const DoubleTab &amp;inverse_quantitee_entrelacee, const ArrOfDouble &amp;coef_som)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void modifieP1P1neumann </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classZone__dis__base.html">Zone_dis_base</a> &amp;&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classZone__Cl__dis__base.html">Zone_Cl_dis_base</a> &amp;&#160;</td>
          <td class="paramname"><em>zcl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatrice.html">Matrice</a> &amp;&#160;</td>
          <td class="paramname"><em>matrice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>inverse_quantitee_entrelacee</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;&#160;</td>
          <td class="paramname"><em>coef_som</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l02429">2429</a> of file <a class="el" href="AssembleurPP1BUtil_8cpp_source.html">AssembleurPP1BUtil.cpp</a>.</p>

<p>References <a class="el" href="EntreeSortie_8h_source.html#l00032">Cerr</a>, <a class="el" href="IntTab_8h_source.html#l00233">IntTab::dimension()</a>, <a class="el" href="Objet__U_8h_source.html#l00079">Objet_U::dimension</a>, <a class="el" href="Zone__VF_8h_source.html#l00609">Zone_VF::face_sommets()</a>, <a class="el" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>, <a class="el" href="Cond__lim__base_8h_source.html#l00123">Cond_lim_base::frontiere_dis()</a>, <a class="el" href="Matrice__Bloc_8cpp_source.html#l00568">Matrice_Bloc::get_bloc()</a>, <a class="el" href="Zone__Cl__dis__base_8cpp_source.html#l00522">Zone_Cl_dis_base::les_conditions_limites()</a>, <a class="el" href="Front__VF_8h_source.html#l00066">Front_VF::nb_faces_tot()</a>, <a class="el" href="Zone__dis__base_8h_source.html#l00148">Zone_dis_base::nb_som()</a>, <a class="el" href="Front__VF_8h_source.html#l00076">Front_VF::num_face()</a>, <a class="el" href="Cast_8h_source.html#l00059">ref_cast</a>, <a class="el" href="vect__impl_8h_source.html#l00057">vect_impl::size()</a>, <a class="el" href="Cast_8h_source.html#l00054">sub_type</a>, and <a class="el" href="Deriv__Matrice__Base_8h_source.html#l00028">Deriv_Matrice_Base::valeur()</a>.</p>

<p>Referenced by <a class="el" href="Assembleur__P__VEFPreP1B_8cpp_source.html#l00230">Assembleur_P_VEFPreP1B::assembler_mat()</a>.</p>
<div class="fragment"><pre class="fragment">{

  <span class="keywordtype">int</span> dimension=<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>;
  <span class="keyword">const</span> <a class="code" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a>&amp; zone_VEF=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a>, z);
<span class="comment">// const Zone&amp; zone=zone_VEF.zone();</span>
  <span class="keyword">const</span> <a class="code" href="classZone__Cl__VEF.html">Zone_Cl_VEF</a>&amp; zone_Cl_VEF=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classZone__Cl__VEF.html">Zone_Cl_VEF</a>, zcl);
  <span class="keyword">const</span> <a class="code" href="classConds__lim.html">Conds_lim</a>&amp; les_cl = zone_Cl_VEF.<a class="code" href="classZone__Cl__dis__base.html#af75e0ed7786863e4d333bfb29d67c323" title="Renvoie la i-ieme condition aux limites. (version const)">les_conditions_limites</a>();

<span class="comment">// int nnz=nb_som;</span>
  <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> sommets(dimension+2);
  <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> face_opp1(dimension+2);
  <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> face_opp2(dimension+2);
  <a class="code" href="classMatrice__Bloc.html">Matrice_Bloc</a>&amp; A=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Bloc.html">Matrice_Bloc</a>, matrice.<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>());
  <a class="code" href="classMatrice__Morse__Sym.html" title="Classe Matrice_Morse_Sym Represente une matrice M (creuse) symetrique stockee au format Morse Symetri...">Matrice_Morse_Sym</a>&amp; ARR=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Morse__Sym.html" title="Classe Matrice_Morse_Sym Represente une matrice M (creuse) symetrique stockee au format Morse Symetri...">Matrice_Morse_Sym</a>, A.<a class="code" href="classMatrice__Bloc.html#a7ffa38f7b93454432b2df7c616ed0a4e">get_bloc</a>(0,0).<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>());
<span class="comment">// Faces de bord :</span>
  assert(<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a>, z).get_cl_pression_sommet_faible()==0);
  <span class="keywordtype">int</span> nb_som_tot=z.<a class="code" href="classZone__dis__base.html#acc9921d6a29cb719fd832fd573e47825">nb_som</a>();
  <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;les_cl.<a class="code" href="classvect__impl.html#a78155bfbd6b61f4710b9830641ed1694">size</a>(); i++)
    {

      <span class="keyword">const</span> <a class="code" href="classCond__lim__base.html" title="classe Cond_lim_base Classe de base pour la hierarchie des classes qui representent les differentes c...">Cond_lim_base</a>&amp; la_cl = les_cl[i].valeur();
      <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classNeumann__sortie__libre.html" title="classe Neumann_sortie_libre Cette classe represente une frontiere ouverte sans vitesse imposee Pour l...">Neumann_sortie_libre</a>,la_cl))
        {
          <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp; le_bord = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>,la_cl.<a class="code" href="classCond__lim__base.html#ad88b3b516351146c85e8fce1df0f691a" title="Renvoie la frontiere discretisee a laquelle les conditions aux limites s&#39;appliquent.">frontiere_dis</a>());
          <span class="keywordtype">int</span> nb_faces_bord = le_bord.<a class="code" href="classFront__VF.html#aed4006d91bf2ef3af2b9f7933d863a09" title="Nombre de faces reelles et virtuelles du bord.">nb_faces_tot</a>();
          <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; faces=zone_VEF.<a class="code" href="classZone__VF.html#a298e73b18e17da55f421b1fb0879bd46" title="renvoie le numero du ieme sommet de la face num_face.">face_sommets</a>();
          <span class="keywordtype">int</span> nbsf=faces.<a class="code" href="classIntTab.html#abc3b32c94925a82f69d5b153a356e359" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(1);
          <span class="keywordflow">for</span>(<span class="keywordtype">int</span> ind_face=0; ind_face&lt;nb_faces_bord; ind_face++)
            {
              <span class="keywordtype">int</span> face=le_bord.<a class="code" href="classFront__VF.html#a3402a19d7e54ed797d2b18e9a47ead1e" title="Renvoie le numero de face de la ieme face du bord.">num_face</a>(ind_face);
              <span class="keywordflow">for</span>(<span class="keywordtype">int</span> som=0; som&lt;nbsf; som++)
                {

                  <span class="keywordtype">int</span> som_glob=faces(face,som);
                  <span class="keywordflow">if</span> (som_glob&lt;nb_som_tot)
                    ARR(som_glob,som_glob)=1e12;
<span class="comment">// Cout&lt;&lt;ref_cast(Zone_VEF_PreP1b, z).numero_premier_sommet()&lt;&lt;&quot; ici &quot;&lt;&lt;som_glob&lt;&lt;finl;</span>
                }
            }
        }
    }
  <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Modifie P1P1 Neumann OK&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a092a07cbd42b28d79c8d8d04e835fd91"></a><!-- doxytag: member="Assembleur_P_VEFPreP1B.cpp::operation01" ref="a092a07cbd42b28d79c8d8d04e835fd91" args="(Matrice_Bloc &amp;A00, Matrice_Bloc &amp;A01, double alpha, double beta, const Zone &amp;zone)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operation01 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMatrice__Bloc.html">Matrice_Bloc</a> &amp;&#160;</td>
          <td class="paramname"><em>A00</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatrice__Bloc.html">Matrice_Bloc</a> &amp;&#160;</td>
          <td class="paramname"><em>A01</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classZone.html">Zone</a> &amp;&#160;</td>
          <td class="paramname"><em>zone</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>&lt; Element k1</p>
<p>&lt; Element k2</p>
<p>&lt; Calcul de -alpha*beta*Ak1k2 </p>
</p>

<p>Definition at line <a class="el" href="Assembleur__P__VEFPreP1B_8cpp_source.html#l01117">1117</a> of file <a class="el" href="Assembleur__P__VEFPreP1B_8cpp_source.html">Assembleur_P_VEFPreP1B.cpp</a>.</p>

<p>References <a class="el" href="ArrOfDouble_8h_source.html#l00379">ArrOfDouble::addr()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00371">ArrOfInt::addr()</a>, <a class="el" href="Champ__P1iP1B__implementation_8cpp_source.html#l00331">coeff</a>, <a class="el" href="Zone_8cpp_source.html#l00262">Zone::domaine()</a>, <a class="el" href="Matrice__Bloc_8cpp_source.html#l00568">Matrice_Bloc::get_bloc()</a>, <a class="el" href="Matrice__Morse_8h_source.html#l00142">Matrice_Morse::get_coeff()</a>, <a class="el" href="Domaine_8h_source.html#l00613">Domaine::get_renum_som_perio()</a>, <a class="el" href="Matrice__Morse_8h_source.html#l00134">Matrice_Morse::get_tab1()</a>, <a class="el" href="Matrice__Morse_8h_source.html#l00138">Matrice_Morse::get_tab2()</a>, <a class="el" href="Zone_8h_source.html#l00402">Zone::les_elems()</a>, <a class="el" href="Matrice__Bloc_8cpp_source.html#l00629">Matrice_Bloc::nb_bloc_colonnes()</a>, <a class="el" href="Matrice__Bloc_8cpp_source.html#l00624">Matrice_Bloc::nb_bloc_lignes()</a>, <a class="el" href="Matrice__Morse_8h_source.html#l00103">Matrice_Morse::nb_colonnes()</a>, <a class="el" href="Matrice__Morse_8h_source.html#l00099">Matrice_Morse::nb_lignes()</a>, <a class="el" href="Zone__CoviMAC_8h_source.html#l00342">prod()</a>, <a class="el" href="Assembleur__P__VEFPreP1B_8cpp_source.html#l01005">range()</a>, <a class="el" href="Cast_8h_source.html#l00059">ref_cast</a>, and <a class="el" href="Deriv__Matrice__Base_8h_source.html#l00028">Deriv_Matrice_Base::valeur()</a>.</p>

<p>Referenced by <a class="el" href="Assembleur__P__VEFPreP1B_8cpp_source.html#l01172">Assembleur_P_VEFPreP1B::changer_base_matrice()</a>.</p>
<div class="fragment"><pre class="fragment">{
<span class="comment">// Cerr &lt;&lt; &quot;[&quot; &lt;&lt; Process::me() &lt;&lt; &quot;] Operation01&quot; &lt;&lt; finl;</span>
  <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; A01RR=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>, A01.<a class="code" href="classMatrice__Bloc.html#a7ffa38f7b93454432b2df7c616ed0a4e">get_bloc</a>(0,0).<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>());
  <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; A01RV=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>, A01.<a class="code" href="classMatrice__Bloc.html#a7ffa38f7b93454432b2df7c616ed0a4e">get_bloc</a>(0,1).<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>());
  <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; A01VR=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>, A01.<a class="code" href="classMatrice__Bloc.html#a7ffa38f7b93454432b2df7c616ed0a4e">get_bloc</a>(1,0).<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>());
  <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; A01VV=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>, A01.<a class="code" href="classMatrice__Bloc.html#a7ffa38f7b93454432b2df7c616ed0a4e">get_bloc</a>(1,1).<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>());
  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; les_elems=zone.<a class="code" href="classZone.html#ac115e8342be89afb882b7b61cc343267" title="Renvoie le tableau des sommets des elements.">les_elems</a>();
  <span class="keyword">const</span> <a class="code" href="classDomaine.html" title="Classe Domaine Un Domaine represente le domaine (spatial) de resolution d&#39;un Probleme. Un Domaine a un Nom, il est constitue d&#39;une ou plusieurs Zone qui peuvent etre eventuellement decoupees en Sous_Zone. Un Domaine porte l&#39;ensemble des sommets utilises par ses Zones. On peut vouloir resoudre des problemes de type different sur plusieurs domaines, geometriquement les domaines sont alors couples par des surfaces qu&#39;on appelle Raccord.">Domaine</a>&amp; dom=zone.<a class="code" href="classZone.html#a379ad2206b5a13a4f4f3df6d44c7546a" title="Renvoie le domaine dont la zone fait partie. (version const)">domaine</a>();
  <span class="keywordtype">int</span> nb_elem=A01RR.<a class="code" href="classMatrice__Morse.html#a1f9bd6aedb226c86b7299689fa5b821a">nb_lignes</a>();
  <span class="keywordtype">int</span> nb_som=A01RR.<a class="code" href="classMatrice__Morse.html#a94caf9937bc5a110a7179cb3e9eaa9d9">nb_colonnes</a>();
  <span class="keywordtype">int</span> nb_som_elem=les_elems.dimension(1);
<span class="comment">// On parcours les coefficients de A00</span>
  <span class="keywordtype">int</span> ligne=0;
  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i_bloc=0; i_bloc&lt;A00.<a class="code" href="classMatrice__Bloc.html#a02193255787b0ecae7988ca4eada3b4b" title="retourne N_">nb_bloc_lignes</a>(); i_bloc++)
    {
      <span class="keywordtype">int</span> colonne=0;
      <span class="keywordtype">int</span> nb_lignes=0;
      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j_bloc=0; j_bloc&lt;A00.<a class="code" href="classMatrice__Bloc.html#a2436d61e9c5d9e364d22fd106349cf9a" title="retourne M_">nb_bloc_colonnes</a>(); j_bloc++)
        {
          <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; A00ij=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>, A00.<a class="code" href="classMatrice__Bloc.html#a7ffa38f7b93454432b2df7c616ed0a4e">get_bloc</a>(i_bloc,j_bloc).<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>());
          <span class="keyword">const</span> <span class="keywordtype">int</span>* tab1=A00ij.<a class="code" href="classMatrice__Morse.html#a79b4e334152850bd36e53478debf3061">get_tab1</a>().<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
          <span class="keyword">const</span> <span class="keywordtype">int</span>* tab2=A00ij.<a class="code" href="classMatrice__Morse.html#a787b5a63f27063f9c891243d8f188cda">get_tab2</a>().<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
          <span class="keyword">const</span> <span class="keywordtype">double</span>* <a class="code" href="Champ__P1iP1B__implementation_8cpp.html#aa8c8f49390c3cf7c702d71a71bc977e3">coeff</a>=A00ij.<a class="code" href="classMatrice__Morse.html#aacb80dd518dcc0812e3b34edac6ab67e">get_coeff</a>().<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
          nb_lignes=A00ij.<a class="code" href="classMatrice__Morse.html#a1f9bd6aedb226c86b7299689fa5b821a">nb_lignes</a>();
          <span class="keywordtype">int</span> nb_colonnes=A00ij.<a class="code" href="classMatrice__Morse.html#a94caf9937bc5a110a7179cb3e9eaa9d9">nb_colonnes</a>();
          <span class="keywordtype">int</span> s;
          <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;nb_lignes; i++)
            {
              <span class="keywordtype">int</span> k1=ligne+i; <span class="comment">//!&lt; Element k1</span>
<span class="comment"></span>              <span class="keywordflow">for</span> (<span class="keywordtype">int</span> n=tab1[i]-1; n&lt;tab1[i+1]-1; n++)
                {
                  <span class="keywordtype">int</span> k2=colonne+tab2[n]-1; <span class="comment">//!&lt; Element k2</span>
<span class="comment"></span>                  <span class="keywordflow">if</span> (k2&gt;=k1)
                    {
                      <span class="keywordtype">double</span> <a class="code" href="Zone__CoviMAC_8h.html#aa24d8c7ee8fd93e2360821d3636ec69d">prod</a> = -alpha * beta * coeff[n];        <span class="comment">//!&lt; Calcul de -alpha*beta*Ak1k2</span>
<span class="comment"></span>                      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> som=0; som&lt;nb_som_elem; som++)
                        {
                          s = dom.<a class="code" href="classDomaine.html#a37cc657f1907d53b0d5a573da862af80">get_renum_som_perio</a>(les_elems(k2,som));
                          <a class="code" href="Assembleur__P__VEFPreP1B_8cpp.html#a1ba6a21d7cd10f7974541a879696c5db">range</a>(prod,k1,nb_elem,s,nb_som,A01RR,A01RV,A01VR,A01VV);
                          <span class="keywordflow">if</span> (k1!=k2)
                            {
                              s = dom.<a class="code" href="classDomaine.html#a37cc657f1907d53b0d5a573da862af80">get_renum_som_perio</a>(les_elems(k1,som));
                              <a class="code" href="Assembleur__P__VEFPreP1B_8cpp.html#a1ba6a21d7cd10f7974541a879696c5db">range</a>(prod,k2,nb_elem,s,nb_som,A01RR,A01RV,A01VR,A01VV);
                            }
                        }
                    }
                }
            }
          colonne+=nb_colonnes;
        }
      ligne+=nb_lignes;
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="ad34510dd4da2194051998525655e62f9"></a><!-- doxytag: member="Assembleur_P_VEFPreP1B.cpp::operation11" ref="ad34510dd4da2194051998525655e62f9" args="(Matrice_Bloc &amp;A00, Matrice_Bloc &amp;A01, Matrice_Bloc &amp;A11, double beta, const Zone &amp;zone)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operation11 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMatrice__Bloc.html">Matrice_Bloc</a> &amp;&#160;</td>
          <td class="paramname"><em>A00</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatrice__Bloc.html">Matrice_Bloc</a> &amp;&#160;</td>
          <td class="paramname"><em>A01</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatrice__Bloc.html">Matrice_Bloc</a> &amp;&#160;</td>
          <td class="paramname"><em>A11</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classZone.html">Zone</a> &amp;&#160;</td>
          <td class="paramname"><em>zone</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>&lt; Element k1</p>
<p>&lt; Element k2</p>
<p>&lt; Calcul de beta*beta*Ak1k2</p>
<p>&lt; Element k</p>
<p>&lt; Sommet s1</p>
<p>&lt; Calcul de -beta*Aks</p>
<p>&lt; Sommet s2 </p>
</p>

<p>Definition at line <a class="el" href="Assembleur__P__VEFPreP1B_8cpp_source.html#l01018">1018</a> of file <a class="el" href="Assembleur__P__VEFPreP1B_8cpp_source.html">Assembleur_P_VEFPreP1B.cpp</a>.</p>

<p>References <a class="el" href="ArrOfDouble_8h_source.html#l00379">ArrOfDouble::addr()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00371">ArrOfInt::addr()</a>, <a class="el" href="Champ__P1iP1B__implementation_8cpp_source.html#l00331">coeff</a>, <a class="el" href="Zone_8cpp_source.html#l00262">Zone::domaine()</a>, <a class="el" href="Matrice__Bloc_8cpp_source.html#l00568">Matrice_Bloc::get_bloc()</a>, <a class="el" href="Matrice__Morse_8h_source.html#l00142">Matrice_Morse::get_coeff()</a>, <a class="el" href="Domaine_8h_source.html#l00613">Domaine::get_renum_som_perio()</a>, <a class="el" href="Matrice__Morse_8h_source.html#l00134">Matrice_Morse::get_tab1()</a>, <a class="el" href="Matrice__Morse_8h_source.html#l00138">Matrice_Morse::get_tab2()</a>, <a class="el" href="Zone_8h_source.html#l00402">Zone::les_elems()</a>, <a class="el" href="Matrice__Bloc_8cpp_source.html#l00629">Matrice_Bloc::nb_bloc_colonnes()</a>, <a class="el" href="Matrice__Bloc_8cpp_source.html#l00624">Matrice_Bloc::nb_bloc_lignes()</a>, <a class="el" href="Matrice__Morse_8h_source.html#l00103">Matrice_Morse::nb_colonnes()</a>, <a class="el" href="Matrice__Morse_8h_source.html#l00099">Matrice_Morse::nb_lignes()</a>, <a class="el" href="Zone__CoviMAC_8h_source.html#l00342">prod()</a>, <a class="el" href="Assembleur__P__VEFPreP1B_8cpp_source.html#l01005">range()</a>, <a class="el" href="Cast_8h_source.html#l00059">ref_cast</a>, and <a class="el" href="Deriv__Matrice__Base_8h_source.html#l00028">Deriv_Matrice_Base::valeur()</a>.</p>

<p>Referenced by <a class="el" href="Assembleur__P__VEFPreP1B_8cpp_source.html#l01172">Assembleur_P_VEFPreP1B::changer_base_matrice()</a>.</p>
<div class="fragment"><pre class="fragment">{
<span class="comment">// Cerr &lt;&lt; &quot;Operation11&quot; &lt;&lt; finl;</span>
  <a class="code" href="classMatrice__Morse__Sym.html" title="Classe Matrice_Morse_Sym Represente une matrice M (creuse) symetrique stockee au format Morse Symetri...">Matrice_Morse_Sym</a>&amp; A11RR=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Morse__Sym.html" title="Classe Matrice_Morse_Sym Represente une matrice M (creuse) symetrique stockee au format Morse Symetri...">Matrice_Morse_Sym</a>, A11.<a class="code" href="classMatrice__Bloc.html#a7ffa38f7b93454432b2df7c616ed0a4e">get_bloc</a>(0,0).<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>());
  <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; A11RV=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>, A11.<a class="code" href="classMatrice__Bloc.html#a7ffa38f7b93454432b2df7c616ed0a4e">get_bloc</a>(0,1).<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>());
  <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; A11VR=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>, A11.<a class="code" href="classMatrice__Bloc.html#a7ffa38f7b93454432b2df7c616ed0a4e">get_bloc</a>(1,0).<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>());
  <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; A11VV=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>, A11.<a class="code" href="classMatrice__Bloc.html#a7ffa38f7b93454432b2df7c616ed0a4e">get_bloc</a>(1,1).<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>());
  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; les_elems=zone.<a class="code" href="classZone.html#ac115e8342be89afb882b7b61cc343267" title="Renvoie le tableau des sommets des elements.">les_elems</a>();
  <span class="keyword">const</span> <a class="code" href="classDomaine.html" title="Classe Domaine Un Domaine represente le domaine (spatial) de resolution d&#39;un Probleme. Un Domaine a un Nom, il est constitue d&#39;une ou plusieurs Zone qui peuvent etre eventuellement decoupees en Sous_Zone. Un Domaine porte l&#39;ensemble des sommets utilises par ses Zones. On peut vouloir resoudre des problemes de type different sur plusieurs domaines, geometriquement les domaines sont alors couples par des surfaces qu&#39;on appelle Raccord.">Domaine</a>&amp; dom=zone.<a class="code" href="classZone.html#a379ad2206b5a13a4f4f3df6d44c7546a" title="Renvoie le domaine dont la zone fait partie. (version const)">domaine</a>();
  <span class="keywordtype">int</span> nb_som=A11RR.<a class="code" href="classMatrice__Morse.html#a1f9bd6aedb226c86b7299689fa5b821a">nb_lignes</a>();
  <span class="keywordtype">int</span> nb_som_elem=les_elems.dimension(1);
<span class="comment">// On parcours les elements de la matrice A00</span>
<span class="comment">// Cerr &lt;&lt; &quot;[&quot; &lt;&lt; Process::me() &lt;&lt; &quot;] Contribution de A00 dans A11~&quot; &lt;&lt; finl;</span>
  <span class="keywordtype">int</span> ligne=0;
  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i_bloc=0; i_bloc&lt;A00.<a class="code" href="classMatrice__Bloc.html#a02193255787b0ecae7988ca4eada3b4b" title="retourne N_">nb_bloc_lignes</a>(); i_bloc++)
    {
      <span class="keywordtype">int</span> colonne=0;
      <span class="keywordtype">int</span> nb_lignes=0;
      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j_bloc=0; j_bloc&lt;A00.<a class="code" href="classMatrice__Bloc.html#a2436d61e9c5d9e364d22fd106349cf9a" title="retourne M_">nb_bloc_colonnes</a>(); j_bloc++)
        {
          <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; A00ij=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>, A00.<a class="code" href="classMatrice__Bloc.html#a7ffa38f7b93454432b2df7c616ed0a4e">get_bloc</a>(i_bloc,j_bloc).<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>());
          <span class="keyword">const</span> <span class="keywordtype">int</span>* tab1=A00ij.<a class="code" href="classMatrice__Morse.html#a79b4e334152850bd36e53478debf3061">get_tab1</a>().<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
          <span class="keyword">const</span> <span class="keywordtype">int</span>* tab2=A00ij.<a class="code" href="classMatrice__Morse.html#a787b5a63f27063f9c891243d8f188cda">get_tab2</a>().<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
          <span class="keyword">const</span> <span class="keywordtype">double</span>* <a class="code" href="Champ__P1iP1B__implementation_8cpp.html#aa8c8f49390c3cf7c702d71a71bc977e3">coeff</a>=A00ij.<a class="code" href="classMatrice__Morse.html#aacb80dd518dcc0812e3b34edac6ab67e">get_coeff</a>().<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
          nb_lignes=A00ij.<a class="code" href="classMatrice__Morse.html#a1f9bd6aedb226c86b7299689fa5b821a">nb_lignes</a>();
          <span class="keywordtype">int</span> nb_colonnes=A00ij.<a class="code" href="classMatrice__Morse.html#a94caf9937bc5a110a7179cb3e9eaa9d9">nb_colonnes</a>();
          <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;nb_lignes; i++)
            {
              <span class="keywordtype">int</span> k1=ligne+i; <span class="comment">//!&lt; Element k1</span>
<span class="comment"></span>              <span class="keywordflow">for</span> (<span class="keywordtype">int</span> n=tab1[i]-1; n&lt;tab1[i+1]-1; n++)
                {
                  <span class="keywordtype">int</span> k2=colonne+tab2[n]-1; <span class="comment">//!&lt; Element k2</span>
<span class="comment"></span>                  <span class="keywordflow">if</span> (k2&gt;=k1)
                    {
                      <span class="keywordtype">double</span> <a class="code" href="Zone__CoviMAC_8h.html#aa24d8c7ee8fd93e2360821d3636ec69d">prod</a> = beta * beta * coeff[n];        <span class="comment">//!&lt; Calcul de beta*beta*Ak1k2</span>
<span class="comment"></span>                      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> som1=0; som1&lt;nb_som_elem; som1++)
                        {
                          <span class="keywordtype">int</span> s1 = dom.<a class="code" href="classDomaine.html#a37cc657f1907d53b0d5a573da862af80">get_renum_som_perio</a>(les_elems(k1,som1));
                          <span class="keywordflow">for</span> (<span class="keywordtype">int</span> som2=0; som2&lt;nb_som_elem; som2++)
                            {
                              <span class="keywordtype">int</span> s2 = dom.<a class="code" href="classDomaine.html#a37cc657f1907d53b0d5a573da862af80">get_renum_som_perio</a>(les_elems(k2,som2));
                              <span class="keywordflow">if</span> (s2&gt;=s1) <a class="code" href="Assembleur__P__VEFPreP1B_8cpp.html#a1ba6a21d7cd10f7974541a879696c5db">range</a>(prod,s1,nb_som,s2,nb_som,A11RR,A11RV,A11VR,A11VV);
                            }
                        }
                      <span class="keywordflow">if</span> (k1!=k2)
                        {
                          <span class="keywordflow">for</span> (<span class="keywordtype">int</span> som1=0; som1&lt;nb_som_elem; som1++)
                            {
                              <span class="keywordtype">int</span> s1 = dom.<a class="code" href="classDomaine.html#a37cc657f1907d53b0d5a573da862af80">get_renum_som_perio</a>(les_elems(k2,som1));
                              <span class="keywordflow">for</span> (<span class="keywordtype">int</span> som2=0; som2&lt;nb_som_elem; som2++)
                                {
                                  <span class="keywordtype">int</span> s2 = dom.<a class="code" href="classDomaine.html#a37cc657f1907d53b0d5a573da862af80">get_renum_som_perio</a>(les_elems(k1,som2));
                                  <span class="keywordflow">if</span> (s2&gt;=s1) <a class="code" href="Assembleur__P__VEFPreP1B_8cpp.html#a1ba6a21d7cd10f7974541a879696c5db">range</a>(prod,s1,nb_som,s2,nb_som,A11RR,A11RV,A11VR,A11VV);
                                }
                            }
                        }
                    }
                }
            }
          colonne+=nb_colonnes;
        }
      ligne+=nb_lignes;
    }
<span class="comment">// On parcours les elements de la matrice A01</span>
<span class="comment">// Cerr &lt;&lt; &quot;[&quot; &lt;&lt; Process::me() &lt;&lt; &quot;] Contribution de A01 dans A11~&quot; &lt;&lt; finl;</span>
  ligne=0;
  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i_bloc=0; i_bloc&lt;A01.<a class="code" href="classMatrice__Bloc.html#a02193255787b0ecae7988ca4eada3b4b" title="retourne N_">nb_bloc_lignes</a>(); i_bloc++)
    {
      <span class="keywordtype">int</span> colonne=0;
      <span class="keywordtype">int</span> nb_lignes=0;
      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j_bloc=0; j_bloc&lt;A01.<a class="code" href="classMatrice__Bloc.html#a2436d61e9c5d9e364d22fd106349cf9a" title="retourne M_">nb_bloc_colonnes</a>(); j_bloc++)
        {
          <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; A01ij=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>, A01.<a class="code" href="classMatrice__Bloc.html#a7ffa38f7b93454432b2df7c616ed0a4e">get_bloc</a>(i_bloc,j_bloc).<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>());
          <span class="keyword">const</span> <span class="keywordtype">int</span>* tab1=A01ij.<a class="code" href="classMatrice__Morse.html#a79b4e334152850bd36e53478debf3061">get_tab1</a>().<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
          <span class="keyword">const</span> <span class="keywordtype">int</span>* tab2=A01ij.<a class="code" href="classMatrice__Morse.html#a787b5a63f27063f9c891243d8f188cda">get_tab2</a>().<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
          <span class="keyword">const</span> <span class="keywordtype">double</span>* coeff=A01ij.<a class="code" href="classMatrice__Morse.html#aacb80dd518dcc0812e3b34edac6ab67e">get_coeff</a>().<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
          nb_lignes=A01ij.<a class="code" href="classMatrice__Morse.html#a1f9bd6aedb226c86b7299689fa5b821a">nb_lignes</a>();
          <span class="keywordtype">int</span> nb_colonnes=A01ij.<a class="code" href="classMatrice__Morse.html#a94caf9937bc5a110a7179cb3e9eaa9d9">nb_colonnes</a>();
          <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;nb_lignes; i++)
            {
              <span class="keywordtype">int</span> k=ligne+i; <span class="comment">//!&lt; Element k</span>
<span class="comment"></span>              <span class="keywordflow">for</span> (<span class="keywordtype">int</span> n=tab1[i]-1; n&lt;tab1[i+1]-1; n++)
                {
                  <span class="keywordtype">int</span> s1 = dom.<a class="code" href="classDomaine.html#a37cc657f1907d53b0d5a573da862af80">get_renum_som_perio</a>(colonne+tab2[n]-1); <span class="comment">//!&lt; Sommet s1</span>
<span class="comment"></span>                  <span class="keywordtype">double</span> prod = -beta * coeff[n];        <span class="comment">//!&lt; Calcul de -beta*Aks</span>
<span class="comment"></span>                  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> som=0; som&lt;nb_som_elem; som++)
                    {
                      <span class="keywordtype">int</span> s2 = dom.<a class="code" href="classDomaine.html#a37cc657f1907d53b0d5a573da862af80">get_renum_som_perio</a>(les_elems(k,som)); <span class="comment">//!&lt; Sommet s2</span>
<span class="comment"></span>                      <span class="keywordflow">if</span> (s2&gt;=s1) <a class="code" href="Assembleur__P__VEFPreP1B_8cpp.html#a1ba6a21d7cd10f7974541a879696c5db">range</a>(prod,s1,nb_som,s2,nb_som,A11RR,A11RV,A11VR,A11VV);
                      <span class="keywordflow">if</span> (s1&gt;=s2) <a class="code" href="Assembleur__P__VEFPreP1B_8cpp.html#a1ba6a21d7cd10f7974541a879696c5db">range</a>(prod,s2,nb_som,s1,nb_som,A11RR,A11RV,A11VR,A11VV);
                    }
                }
            }
          colonne+=nb_colonnes;
        }
      ligne+=nb_lignes;
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a1ba6a21d7cd10f7974541a879696c5db"></a><!-- doxytag: member="Assembleur_P_VEFPreP1B.cpp::range" ref="a1ba6a21d7cd10f7974541a879696c5db" args="(double &amp;prod, int &amp;i, int &amp;n, int &amp;j, int &amp;m, Matrice_Morse &amp;ARR, Matrice_Morse &amp;ARV, Matrice_Morse &amp;AVR, Matrice_Morse &amp;AVV)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void range </td>
          <td>(</td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>prod</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;&#160;</td>
          <td class="paramname"><em>ARR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;&#160;</td>
          <td class="paramname"><em>ARV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;&#160;</td>
          <td class="paramname"><em>AVR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;&#160;</td>
          <td class="paramname"><em>AVV</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Assembleur__P__VEFPreP1B_8cpp_source.html#l01005">1005</a> of file <a class="el" href="Assembleur__P__VEFPreP1B_8cpp_source.html">Assembleur_P_VEFPreP1B.cpp</a>.</p>

<p>References <a class="el" href="Zone__CoviMAC_8h_source.html#l00342">prod()</a>.</p>

<p>Referenced by <a class="el" href="Assembleur__P__VEFPreP1B_8cpp_source.html#l01117">operation01()</a>, <a class="el" href="Assembleur__P__VEFPreP1B_8cpp_source.html#l01018">operation11()</a>, and <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00600">update_matriceP0P1()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">if</span> (i&lt;n)
    <span class="keywordflow">if</span> (j&lt;m)
      ARR(i,j)+=<a class="code" href="Zone__CoviMAC_8h.html#aa24d8c7ee8fd93e2360821d3636ec69d">prod</a>;
    <span class="keywordflow">else</span>
      ARV(i,j-m)+=<a class="code" href="Zone__CoviMAC_8h.html#aa24d8c7ee8fd93e2360821d3636ec69d">prod</a>;
  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (j&lt;m)
    AVR(i-n,j)+=<a class="code" href="Zone__CoviMAC_8h.html#aa24d8c7ee8fd93e2360821d3636ec69d">prod</a>;
  <span class="keywordflow">else</span>
    AVV(i-n,j-m)+=<a class="code" href="Zone__CoviMAC_8h.html#aa24d8c7ee8fd93e2360821d3636ec69d">prod</a>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a48eaaecaa31bdde228ea5e3995db4771"></a><!-- doxytag: member="Assembleur_P_VEFPreP1B.cpp::updateP0P0" ref="a48eaaecaa31bdde228ea5e3995db4771" args="(const Zone_dis_base &amp;z, const Zone_Cl_dis_base &amp;zcl, Matrice &amp;matrice, const DoubleTab &amp;inverse_quantitee_entrelacee)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void updateP0P0 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classZone__dis__base.html">Zone_dis_base</a> &amp;&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classZone__Cl__dis__base.html">Zone_Cl_dis_base</a> &amp;&#160;</td>
          <td class="paramname"><em>zcl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatrice.html">Matrice</a> &amp;&#160;</td>
          <td class="paramname"><em>matrice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>inverse_quantitee_entrelacee</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l02235">2235</a> of file <a class="el" href="AssembleurPP1BUtil_8cpp_source.html">AssembleurPP1BUtil.cpp</a>.</p>

<p>References <a class="el" href="Assembleur__P__VEF_8cpp_source.html#l00755">Assembleur_P_VEF::associer_zone_cl_dis_base()</a>, <a class="el" href="Assembleur__P__VEF_8cpp_source.html#l00750">Assembleur_P_VEF::associer_zone_dis_base()</a>, <a class="el" href="EntreeSortie_8h_source.html#l00032">Cerr</a>, <a class="el" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>, and <a class="el" href="Assembleur__P__VEF_8cpp_source.html#l00134">Assembleur_P_VEF::remplir()</a>.</p>

<p>Referenced by <a class="el" href="Assembleur__P__VEFPreP1B_8cpp_source.html#l00230">Assembleur_P_VEFPreP1B::assembler_mat()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <a class="code" href="classAssembleur__P__VEF.html">Assembleur_P_VEF</a> Assembleur_P0;
  Assembleur_P0.<a class="code" href="classAssembleur__P__VEF.html#a5b2a8af584466c11399b032515921978">associer_zone_dis_base</a>(z);
  Assembleur_P0.<a class="code" href="classAssembleur__P__VEF.html#a69468e49c8496eda05508c8e8477493b">associer_zone_cl_dis_base</a>(zcl);
  Assembleur_P0.<a class="code" href="classAssembleur__P__VEF.html#abe02c31a6c1ada8d05996def7f43ea58">remplir</a>(matrice,inverse_quantitee_entrelacee);
  <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Update P0 OK&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="af30661e8e1b45bf522a5595f65ecc741"></a><!-- doxytag: member="Assembleur_P_VEFPreP1B.cpp::updateP0P1" ref="af30661e8e1b45bf522a5595f65ecc741" args="(const Zone_dis_base &amp;z, const Zone_Cl_dis_base &amp;zcl, Matrice &amp;matrice, const DoubleTab &amp;inverse_quantitee_entrelacee, const ArrOfDouble &amp;coef_som)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void updateP0P1 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classZone__dis__base.html">Zone_dis_base</a> &amp;&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classZone__Cl__dis__base.html">Zone_Cl_dis_base</a> &amp;&#160;</td>
          <td class="paramname"><em>zcl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatrice.html">Matrice</a> &amp;&#160;</td>
          <td class="paramname"><em>matrice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>inverse_quantitee_entrelacee</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;&#160;</td>
          <td class="paramname"><em>coef_som</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>&lt; RIEN</p>
<p>&lt; On ne traite que les faces internes </p>
</p>

<p>Definition at line <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l03048">3048</a> of file <a class="el" href="AssembleurPP1BUtil_8cpp_source.html">AssembleurPP1BUtil.cpp</a>.</p>

<p>References <a class="el" href="EntreeSortie_8h_source.html#l00032">Cerr</a>, <a class="el" href="Objet__U_8h_source.html#l00079">Objet_U::dimension</a>, <a class="el" href="Zone__VF_8h_source.html#l00773">Zone_VF::est_une_face_virt_bord()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00046">face_associee</a>, <a class="el" href="Zone__VF_8h_source.html#l00458">Zone_VF::face_voisins()</a>, <a class="el" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>, <a class="el" href="Cond__lim_8h_source.html#l00130">Cond_lim::frontiere_dis()</a>, <a class="el" href="Matrice__Bloc_8cpp_source.html#l00568">Matrice_Bloc::get_bloc()</a>, <a class="el" href="Zone__Cl__dis__base_8cpp_source.html#l00522">Zone_Cl_dis_base::les_conditions_limites()</a>, <a class="el" href="Front__VF_8h_source.html#l00066">Front_VF::nb_faces_tot()</a>, <a class="el" href="Zone__VF_8h_source.html#l00527">Zone_VF::nb_faces_tot()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00081">okface()</a>, <a class="el" href="Zone__VF_8h_source.html#l00512">Zone_VF::premiere_face_int()</a>, <a class="el" href="Cast_8h_source.html#l00059">ref_cast</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00349">remplir_sommets()</a>, <a class="el" href="vect__impl_8h_source.html#l00057">vect_impl::size()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00286">sort()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00983">update_matrice_NeumannP0P1()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00600">update_matriceP0P1()</a>, and <a class="el" href="Deriv__Matrice__Base_8h_source.html#l00028">Deriv_Matrice_Base::valeur()</a>.</p>

<p>Referenced by <a class="el" href="Assembleur__P__VEFPreP1B_8cpp_source.html#l00230">Assembleur_P_VEFPreP1B::assembler_mat()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">int</span> dimension=<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>;
  <span class="keyword">const</span> <a class="code" href="classZone__VEF.html" title="class Zone_VEF Classe instanciable qui derive de Zone_VF. Cette classe contient les informations geom...">Zone_VEF</a>&amp; zone_VEF=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a>, z);
  <span class="keyword">const</span> <a class="code" href="classZone__Cl__VEF.html">Zone_Cl_VEF</a>&amp; zone_Cl_VEF=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classZone__Cl__VEF.html">Zone_Cl_VEF</a>, zcl);
  <span class="keyword">const</span> <a class="code" href="classConds__lim.html">Conds_lim</a>&amp; les_cl = zone_Cl_VEF.<a class="code" href="classZone__Cl__dis__base.html#af75e0ed7786863e4d333bfb29d67c323" title="Renvoie la i-ieme condition aux limites. (version const)">les_conditions_limites</a>();
  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; face_voisins = zone_VEF.<a class="code" href="classZone__VF.html#a49d4322f5585a8fa95748ca785b70702" title="renvoie l&#39;element voisin de numface dans la direction i. i=0 : dans le sens oppose de l&#39;axe orthogona...">face_voisins</a>();
  <span class="keywordtype">int</span> nint = zone_VEF.<a class="code" href="classZone__VF.html#a12869806fa4834aca8f2964e16509dfd" title="une face est interne ssi elle separe deux elements. renvoie le numero de la premiere face interne...">premiere_face_int</a>();
  <span class="keywordtype">int</span> nb_faces = zone_VEF.<a class="code" href="classZone__VF.html#a50fd21c9535680489015a3c8b88c685a" title="renvoie le nombre total de faces. C&#39;est-a-dire faces reelles + faces virtuelles">nb_faces_tot</a>();
  <span class="keywordtype">int</span> elem1, elem2, face, ok;
  <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> sommets(dimension+2);
  <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> face_opp1(dimension+2);
  <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> face_opp2(dimension+2);
  <a class="code" href="classMatrice__Bloc.html">Matrice_Bloc</a>&amp; A=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Bloc.html">Matrice_Bloc</a>, matrice.<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>());
  <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; ARR=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>, A.<a class="code" href="classMatrice__Bloc.html#a7ffa38f7b93454432b2df7c616ed0a4e">get_bloc</a>(0,0).<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>());
  <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; ARV=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>, A.<a class="code" href="classMatrice__Bloc.html#a7ffa38f7b93454432b2df7c616ed0a4e">get_bloc</a>(0,1).<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>());
  <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; AVR=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>, A.<a class="code" href="classMatrice__Bloc.html#a7ffa38f7b93454432b2df7c616ed0a4e">get_bloc</a>(1,0).<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>());
  <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; AVV=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>, A.<a class="code" href="classMatrice__Bloc.html#a7ffa38f7b93454432b2df7c616ed0a4e">get_bloc</a>(1,1).<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>());
<span class="comment">// Faces de bord :</span>
  <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;les_cl.<a class="code" href="classvect__impl.html#a78155bfbd6b61f4710b9830641ed1694">size</a>(); i++)
    {
      <span class="keyword">const</span> <a class="code" href="classCond__lim.html" title="classe Cond_lim Classe generique servant a representer n&#39;importe quelle classe derivee de la classe C...">Cond_lim</a>&amp; la_cl = les_cl[i];
      <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp; le_bord = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>,la_cl.<a class="code" href="classCond__lim.html#a5b2d24809cee07727006a891d4ce8d22" title="Appel a l&#39;objet sous-jacent Renvoie la frontiere discretisee associee a la condition aux limites...">frontiere_dis</a>());
      <span class="keywordtype">int</span> nb_faces_bord_tot = le_bord.<a class="code" href="classFront__VF.html#aed4006d91bf2ef3af2b9f7933d863a09" title="Nombre de faces reelles et virtuelles du bord.">nb_faces_tot</a>();
      <span class="keywordflow">for</span>(<span class="keywordtype">int</span> ind_face=0; ind_face&lt;nb_faces_bord_tot; ind_face++)
        {
          ok=<a class="code" href="AssembleurPP1BUtil_8cpp.html#a40cf40213663174bb24649e51832bf3e">okface</a>(ind_face, face, la_cl);
          <span class="keywordflow">if</span> (ok==-1) <span class="keywordflow">break</span>;
          elem1=face_voisins(face, 0);
          elem2=face_voisins(face, 1);
          <a class="code" href="AssembleurPP1BUtil_8cpp.html#afd0a249a235b161c5267e7574e199a82">remplir_sommets</a>(zone_VEF, face, elem1, elem2, sommets,
                          face_opp1, face_opp2);
          <a class="code" href="AssembleurPP1BUtil_8cpp.html#acff816d35f8d4ce978f860e0cd958b8a">sort</a>(sommets, face_opp1, face_opp2);
          <span class="keywordflow">if</span>(ok==3)
            {
              <a class="code" href="AssembleurPP1BUtil_8cpp.html#a1aa97c31d5b8f95ae899f599d606a1da">update_matrice_NeumannP0P1</a>(zone_VEF,
                                         inverse_quantitee_entrelacee,
                                         face, elem1, sommets,
                                         face_opp1, coef_som,
                                         ARR,ARV,AVR,AVV);
            }
          <span class="keywordflow">else</span> <span class="keywordflow">if</span>(ok==4)
            {
              ;<span class="comment">//!&lt; RIEN</span>
<span class="comment"></span>            }
          <span class="keywordflow">else</span>
            <a class="code" href="AssembleurPP1BUtil_8cpp.html#aa7aef5562f5fe1f2d5b1eeb6664bca53">update_matriceP0P1</a>(zone_VEF,
                               inverse_quantitee_entrelacee,
                               face, elem1, elem2, sommets,
                               face_opp1, face_opp2, coef_som,
                               ARR,ARV,AVR,AVV);
        }
    }
  <a class="code" href="AssembleurPP1BUtil_8cpp.html#a3e374d53ebc7860e1c2f0b7906f2936d">face_associee</a>=-1;
  <span class="keywordflow">for</span>(face=nint; face&lt;nb_faces; face++)
    {
      elem1=face_voisins(face, 0);
      elem2=face_voisins(face, 1);
      <span class="keywordflow">if</span> (!zone_VEF.<a class="code" href="classZone__VF.html#a33909d3880435e82e84639b51482d2c6" title="renvoie 1 si face est une face virtuelle de bord, 0 sinon">est_une_face_virt_bord</a>(face)) <span class="comment">//!&lt; On ne traite que les faces internes</span>
<span class="comment"></span>        {
          <a class="code" href="AssembleurPP1BUtil_8cpp.html#afd0a249a235b161c5267e7574e199a82">remplir_sommets</a>(zone_VEF, face, elem1, elem2, sommets,
                          face_opp1, face_opp2);
          <a class="code" href="AssembleurPP1BUtil_8cpp.html#acff816d35f8d4ce978f860e0cd958b8a">sort</a>(sommets, face_opp1, face_opp2);
          <a class="code" href="AssembleurPP1BUtil_8cpp.html#aa7aef5562f5fe1f2d5b1eeb6664bca53">update_matriceP0P1</a>(zone_VEF,
                             inverse_quantitee_entrelacee,
                             face, elem1, elem2, sommets,
                             face_opp1, face_opp2, coef_som,
                             ARR,ARV,AVR,AVV);
        }
    }
  <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Update POP1 OK&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="aacede92ea2595a5546e6357fbd1e1498"></a><!-- doxytag: member="Assembleur_P_VEFPreP1B.cpp::updateP0Pa" ref="aacede92ea2595a5546e6357fbd1e1498" args="(const Zone_dis_base &amp;z, const Zone_Cl_dis_base &amp;zcl, Matrice &amp;matrice, const DoubleTab &amp;inverse_quantitee_entrelacee)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void updateP0Pa </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classZone__dis__base.html">Zone_dis_base</a> &amp;&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classZone__Cl__dis__base.html">Zone_Cl_dis_base</a> &amp;&#160;</td>
          <td class="paramname"><em>zcl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatrice.html">Matrice</a> &amp;&#160;</td>
          <td class="paramname"><em>matrice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>inverse_quantitee_entrelacee</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>&lt; RIEN</p>
<p>&lt; On ne traite que les faces internes </p>
</p>

<p>Definition at line <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l02730">2730</a> of file <a class="el" href="AssembleurPP1BUtil_8cpp_source.html">AssembleurPP1BUtil.cpp</a>.</p>

<p>References <a class="el" href="EntreeSortie_8h_source.html#l00032">Cerr</a>, <a class="el" href="Objet__U_8h_source.html#l00079">Objet_U::dimension</a>, <a class="el" href="Zone__VF_8h_source.html#l00773">Zone_VF::est_une_face_virt_bord()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00046">face_associee</a>, <a class="el" href="Zone__VF_8h_source.html#l00458">Zone_VF::face_voisins()</a>, <a class="el" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>, <a class="el" href="Cond__lim_8h_source.html#l00130">Cond_lim::frontiere_dis()</a>, <a class="el" href="Matrice__Bloc_8cpp_source.html#l00568">Matrice_Bloc::get_bloc()</a>, <a class="el" href="Zone__Cl__dis__base_8cpp_source.html#l00522">Zone_Cl_dis_base::les_conditions_limites()</a>, <a class="el" href="Front__VF_8h_source.html#l00066">Front_VF::nb_faces_tot()</a>, <a class="el" href="Zone__VF_8h_source.html#l00527">Zone_VF::nb_faces_tot()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00081">okface()</a>, <a class="el" href="Zone__VF_8h_source.html#l00512">Zone_VF::premiere_face_int()</a>, <a class="el" href="Cast_8h_source.html#l00059">ref_cast</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00349">remplir_sommets()</a>, <a class="el" href="vect__impl_8h_source.html#l00057">vect_impl::size()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l01765">update_matrice_NeumannP0Pa()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l01634">update_matriceP0Pa()</a>, and <a class="el" href="Deriv__Matrice__Base_8h_source.html#l00028">Deriv_Matrice_Base::valeur()</a>.</p>

<p>Referenced by <a class="el" href="Assembleur__P__VEFPreP1B_8cpp_source.html#l00230">Assembleur_P_VEFPreP1B::assembler_mat()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">int</span> dimension=<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>;
  <span class="keyword">const</span> <a class="code" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a>&amp; zone_VEF=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a>, z);
  <span class="keyword">const</span> <a class="code" href="classZone__Cl__VEF.html">Zone_Cl_VEF</a>&amp; zone_Cl_VEF=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classZone__Cl__VEF.html">Zone_Cl_VEF</a>, zcl);
  <span class="keyword">const</span> <a class="code" href="classConds__lim.html">Conds_lim</a>&amp; les_cl = zone_Cl_VEF.<a class="code" href="classZone__Cl__dis__base.html#af75e0ed7786863e4d333bfb29d67c323" title="Renvoie la i-ieme condition aux limites. (version const)">les_conditions_limites</a>();
  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; face_voisins = zone_VEF.<a class="code" href="classZone__VF.html#a49d4322f5585a8fa95748ca785b70702" title="renvoie l&#39;element voisin de numface dans la direction i. i=0 : dans le sens oppose de l&#39;axe orthogona...">face_voisins</a>();
  <span class="keywordtype">int</span> nint = zone_VEF.<a class="code" href="classZone__VF.html#a12869806fa4834aca8f2964e16509dfd" title="une face est interne ssi elle separe deux elements. renvoie le numero de la premiere face interne...">premiere_face_int</a>();
  <span class="keywordtype">int</span> nb_faces = zone_VEF.<a class="code" href="classZone__VF.html#a50fd21c9535680489015a3c8b88c685a" title="renvoie le nombre total de faces. C&#39;est-a-dire faces reelles + faces virtuelles">nb_faces_tot</a>();
  <span class="keywordtype">int</span> elem1, elem2, face, ok;
  <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> sommets(dimension+2);
  <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> face_opp1(dimension+2);
  <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> face_opp2(dimension+2);
  <a class="code" href="classMatrice__Bloc.html">Matrice_Bloc</a>&amp; A=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Bloc.html">Matrice_Bloc</a>, matrice.<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>());
  <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; ARR=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>, A.<a class="code" href="classMatrice__Bloc.html#a7ffa38f7b93454432b2df7c616ed0a4e">get_bloc</a>(0,0).<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>());
  <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; ARV=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>, A.<a class="code" href="classMatrice__Bloc.html#a7ffa38f7b93454432b2df7c616ed0a4e">get_bloc</a>(0,1).<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>());
  <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; AVR=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>, A.<a class="code" href="classMatrice__Bloc.html#a7ffa38f7b93454432b2df7c616ed0a4e">get_bloc</a>(1,0).<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>());
  <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; AVV=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>, A.<a class="code" href="classMatrice__Bloc.html#a7ffa38f7b93454432b2df7c616ed0a4e">get_bloc</a>(1,1).<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>());
<span class="comment">// Faces de bord :</span>
  <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;les_cl.<a class="code" href="classvect__impl.html#a78155bfbd6b61f4710b9830641ed1694">size</a>(); i++)
    {
      <span class="keyword">const</span> <a class="code" href="classCond__lim.html" title="classe Cond_lim Classe generique servant a representer n&#39;importe quelle classe derivee de la classe C...">Cond_lim</a>&amp; la_cl = les_cl[i];
      <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp; le_bord = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>,la_cl.<a class="code" href="classCond__lim.html#a5b2d24809cee07727006a891d4ce8d22" title="Appel a l&#39;objet sous-jacent Renvoie la frontiere discretisee associee a la condition aux limites...">frontiere_dis</a>());
      <span class="keywordtype">int</span> nb_faces_bord_tot = le_bord.<a class="code" href="classFront__VF.html#aed4006d91bf2ef3af2b9f7933d863a09" title="Nombre de faces reelles et virtuelles du bord.">nb_faces_tot</a>();
      <span class="keywordflow">for</span>(<span class="keywordtype">int</span> ind_face=0; ind_face&lt;nb_faces_bord_tot; ind_face++)
        {
          ok=<a class="code" href="AssembleurPP1BUtil_8cpp.html#a40cf40213663174bb24649e51832bf3e">okface</a>(ind_face, face, la_cl);
          <span class="keywordflow">if</span> (ok==-1) <span class="keywordflow">break</span>;
          elem1=face_voisins(face, 0);
          elem2=face_voisins(face, 1);
          <a class="code" href="AssembleurPP1BUtil_8cpp.html#afd0a249a235b161c5267e7574e199a82">remplir_sommets</a>(zone_VEF, face, elem1, elem2, sommets,
                          face_opp1, face_opp2);
          <span class="keywordflow">if</span>(ok==3)
            {
              <a class="code" href="AssembleurPP1BUtil_8cpp.html#a45b45851ba59992d7eb7a25c002a9f73">update_matrice_NeumannP0Pa</a>(zone_VEF,
                                         inverse_quantitee_entrelacee,
                                         face, elem1, sommets,
                                         face_opp1,
                                         ARR,ARV,AVR,AVV);
            }
          <span class="keywordflow">else</span> <span class="keywordflow">if</span>(ok==4)
            {
              ; <span class="comment">//!&lt; RIEN</span>
<span class="comment"></span>            }
          <span class="keywordflow">else</span>
            <a class="code" href="AssembleurPP1BUtil_8cpp.html#a68f4b5d510b37d5518ed576764da2611">update_matriceP0Pa</a>(zone_VEF, inverse_quantitee_entrelacee,
                               face, elem1, elem2, sommets,
                               face_opp1, face_opp2,
                               ARR,ARV,AVR,AVV);
        }
    }
  <a class="code" href="AssembleurPP1BUtil_8cpp.html#a3e374d53ebc7860e1c2f0b7906f2936d">face_associee</a>=-1;
  <span class="keywordflow">for</span>(face=nint; face&lt;nb_faces; face++)
    {
      elem1=face_voisins(face, 0);
      elem2=face_voisins(face, 1);
      <span class="keywordflow">if</span> (!zone_VEF.<a class="code" href="classZone__VF.html#a33909d3880435e82e84639b51482d2c6" title="renvoie 1 si face est une face virtuelle de bord, 0 sinon">est_une_face_virt_bord</a>(face)) <span class="comment">//!&lt; On ne traite que les faces internes</span>
<span class="comment"></span>        {
          <a class="code" href="AssembleurPP1BUtil_8cpp.html#afd0a249a235b161c5267e7574e199a82">remplir_sommets</a>(zone_VEF, face, elem1, elem2, sommets,
                          face_opp1, face_opp2);
          <a class="code" href="AssembleurPP1BUtil_8cpp.html#a68f4b5d510b37d5518ed576764da2611">update_matriceP0Pa</a>(zone_VEF,
                             inverse_quantitee_entrelacee,
                             face, elem1, elem2, sommets,
                             face_opp1, face_opp2,
                             ARR,ARV,AVR,AVV);
        }
    }
  <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Update P0Pa OK&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="ab3c25c4172223f48fd2f9d433b005e0c"></a><!-- doxytag: member="Assembleur_P_VEFPreP1B.cpp::updateP1P1" ref="ab3c25c4172223f48fd2f9d433b005e0c" args="(const Zone_dis_base &amp;z, const Zone_Cl_dis_base &amp;zcl, Matrice &amp;matrice, const DoubleTab &amp;inverse_quantitee_entrelacee, const ArrOfDouble &amp;coef_som)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void updateP1P1 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classZone__dis__base.html">Zone_dis_base</a> &amp;&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classZone__Cl__dis__base.html">Zone_Cl_dis_base</a> &amp;&#160;</td>
          <td class="paramname"><em>zcl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatrice.html">Matrice</a> &amp;&#160;</td>
          <td class="paramname"><em>matrice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>inverse_quantitee_entrelacee</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;&#160;</td>
          <td class="paramname"><em>coef_som</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>&lt; On ne traite que les faces internes </p>
</p>

<p>Definition at line <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l02339">2339</a> of file <a class="el" href="AssembleurPP1BUtil_8cpp_source.html">AssembleurPP1BUtil.cpp</a>.</p>

<p>References <a class="el" href="EntreeSortie_8h_source.html#l00032">Cerr</a>, <a class="el" href="Objet__U_8h_source.html#l00079">Objet_U::dimension</a>, <a class="el" href="Zone__VF_8h_source.html#l00773">Zone_VF::est_une_face_virt_bord()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00046">face_associee</a>, <a class="el" href="Zone__VF_8h_source.html#l00458">Zone_VF::face_voisins()</a>, <a class="el" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>, <a class="el" href="Cond__lim_8h_source.html#l00130">Cond_lim::frontiere_dis()</a>, <a class="el" href="Matrice__Bloc_8cpp_source.html#l00568">Matrice_Bloc::get_bloc()</a>, <a class="el" href="Zone__Cl__dis__base_8cpp_source.html#l00522">Zone_Cl_dis_base::les_conditions_limites()</a>, <a class="el" href="Front__VF_8h_source.html#l00066">Front_VF::nb_faces_tot()</a>, <a class="el" href="Zone__VF_8h_source.html#l00527">Zone_VF::nb_faces_tot()</a>, <a class="el" href="Zone_8cpp_source.html#l00586">Zone::nb_som()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00081">okface()</a>, <a class="el" href="Zone__VF_8h_source.html#l00512">Zone_VF::premiere_face_int()</a>, <a class="el" href="Cast_8h_source.html#l00059">ref_cast</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00349">remplir_sommets()</a>, <a class="el" href="vect__impl_8h_source.html#l00057">vect_impl::size()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00286">sort()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l01084">update_matrice_NeumannP1P1()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l01191">update_matrice_SymetrieP1P1()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00694">update_matriceP1P1()</a>, <a class="el" href="Deriv__Matrice__Base_8h_source.html#l00028">Deriv_Matrice_Base::valeur()</a>, and <a class="el" href="Zone__dis__base_8h_source.html#l00106">Zone_dis_base::zone()</a>.</p>

<p>Referenced by <a class="el" href="Assembleur__P__VEFPreP1B_8cpp_source.html#l00230">Assembleur_P_VEFPreP1B::assembler_mat()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">int</span> dimension=<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>;
  <span class="keyword">const</span> <a class="code" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a>&amp; zone_VEF=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a>, z);
<span class="comment">// const Zone&amp; zone=zone_VEF.zone();</span>
  <span class="keyword">const</span> <a class="code" href="classZone__Cl__VEF.html">Zone_Cl_VEF</a>&amp; zone_Cl_VEF=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classZone__Cl__VEF.html">Zone_Cl_VEF</a>, zcl);
  <span class="keyword">const</span> <a class="code" href="classConds__lim.html">Conds_lim</a>&amp; les_cl = zone_Cl_VEF.<a class="code" href="classZone__Cl__dis__base.html#af75e0ed7786863e4d333bfb29d67c323" title="Renvoie la i-ieme condition aux limites. (version const)">les_conditions_limites</a>();
  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; face_voisins = zone_VEF.<a class="code" href="classZone__VF.html#a49d4322f5585a8fa95748ca785b70702" title="renvoie l&#39;element voisin de numface dans la direction i. i=0 : dans le sens oppose de l&#39;axe orthogona...">face_voisins</a>();
  <span class="keywordtype">int</span> nint = zone_VEF.<a class="code" href="classZone__VF.html#a12869806fa4834aca8f2964e16509dfd" title="une face est interne ssi elle separe deux elements. renvoie le numero de la premiere face interne...">premiere_face_int</a>();
  <span class="keywordtype">int</span> nb_faces = zone_VEF.<a class="code" href="classZone__VF.html#a50fd21c9535680489015a3c8b88c685a" title="renvoie le nombre total de faces. C&#39;est-a-dire faces reelles + faces virtuelles">nb_faces_tot</a>();
<span class="comment">// int nb_som = zone_VEF.zone().nb_som_tot();</span>
  <span class="keywordtype">int</span> elem1, elem2, face, ok;
<span class="comment">// int nnz=nb_som;</span>
  <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> sommets(dimension+2);
  <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> face_opp1(dimension+2);
  <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> face_opp2(dimension+2);
  <a class="code" href="classMatrice__Bloc.html">Matrice_Bloc</a>&amp; A=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Bloc.html">Matrice_Bloc</a>, matrice.<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>());
  <a class="code" href="classMatrice__Morse__Sym.html" title="Classe Matrice_Morse_Sym Represente une matrice M (creuse) symetrique stockee au format Morse Symetri...">Matrice_Morse_Sym</a>&amp; ARR=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Morse__Sym.html" title="Classe Matrice_Morse_Sym Represente une matrice M (creuse) symetrique stockee au format Morse Symetri...">Matrice_Morse_Sym</a>, A.<a class="code" href="classMatrice__Bloc.html#a7ffa38f7b93454432b2df7c616ed0a4e">get_bloc</a>(0,0).<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>());
  <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; ARV=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>, A.<a class="code" href="classMatrice__Bloc.html#a7ffa38f7b93454432b2df7c616ed0a4e">get_bloc</a>(0,1).<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>());
  <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; AVR=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>, A.<a class="code" href="classMatrice__Bloc.html#a7ffa38f7b93454432b2df7c616ed0a4e">get_bloc</a>(1,0).<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>());
  <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; AVV=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>, A.<a class="code" href="classMatrice__Bloc.html#a7ffa38f7b93454432b2df7c616ed0a4e">get_bloc</a>(1,1).<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>());
<span class="comment">// Faces de bord :</span>
  <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;les_cl.<a class="code" href="classvect__impl.html#a78155bfbd6b61f4710b9830641ed1694">size</a>(); i++)
    {
      <span class="keyword">const</span> <a class="code" href="classCond__lim.html" title="classe Cond_lim Classe generique servant a representer n&#39;importe quelle classe derivee de la classe C...">Cond_lim</a>&amp; la_cl = les_cl[i];
      <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp; le_bord = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>,la_cl.<a class="code" href="classCond__lim.html#a5b2d24809cee07727006a891d4ce8d22" title="Appel a l&#39;objet sous-jacent Renvoie la frontiere discretisee associee a la condition aux limites...">frontiere_dis</a>());
      <span class="keywordtype">int</span> nb_faces_bord_tot = le_bord.<a class="code" href="classFront__VF.html#aed4006d91bf2ef3af2b9f7933d863a09" title="Nombre de faces reelles et virtuelles du bord.">nb_faces_tot</a>();
      <span class="keywordflow">for</span>(<span class="keywordtype">int</span> ind_face=0; ind_face&lt;nb_faces_bord_tot; ind_face++)
        {
          ok=<a class="code" href="AssembleurPP1BUtil_8cpp.html#a40cf40213663174bb24649e51832bf3e">okface</a>(ind_face, face, la_cl);
          <span class="keywordflow">if</span> (ok==-1) <span class="keywordflow">break</span>;
          elem1=face_voisins(face, 0);
          elem2=face_voisins(face, 1);
          <a class="code" href="AssembleurPP1BUtil_8cpp.html#afd0a249a235b161c5267e7574e199a82">remplir_sommets</a>(zone_VEF, face, elem1, elem2, sommets,
                          face_opp1, face_opp2);
          <a class="code" href="AssembleurPP1BUtil_8cpp.html#acff816d35f8d4ce978f860e0cd958b8a">sort</a>(sommets, face_opp1, face_opp2);
          <span class="keywordflow">if</span>(ok==3)
            {
              <a class="code" href="AssembleurPP1BUtil_8cpp.html#affe9938bfd355c4e19b608c286c0293b">update_matrice_NeumannP1P1</a>(zone_VEF,
                                         inverse_quantitee_entrelacee,
                                         face, elem1, sommets,
                                         face_opp1, coef_som,
                                         ARR,ARV,AVR,AVV);
            }
          <span class="keywordflow">else</span> <span class="keywordflow">if</span>(ok==4)
            {
              <a class="code" href="AssembleurPP1BUtil_8cpp.html#ade1c92b286a861f3920664b658ba3fb1">update_matrice_SymetrieP1P1</a>(zone_VEF,
                                          inverse_quantitee_entrelacee,
                                          face, elem1, sommets,
                                          face_opp1, coef_som,
                                          ARR,ARV,AVR,AVV);
            }
          <span class="keywordflow">else</span>
            <a class="code" href="AssembleurPP1BUtil_8cpp.html#a77351839245012751e4d90a39922356a">update_matriceP1P1</a>(zone_VEF,
                               inverse_quantitee_entrelacee,
                               face, elem1, elem2, sommets,
                               face_opp1, face_opp2, coef_som,
                               ARR,ARV,AVR,AVV);
        }
    }
  <a class="code" href="AssembleurPP1BUtil_8cpp.html#a3e374d53ebc7860e1c2f0b7906f2936d">face_associee</a>=-1;
  <span class="keywordflow">for</span>(face=nint; face&lt;nb_faces; face++)
    {
      elem1=face_voisins(face, 0);
      elem2=face_voisins(face, 1);
      <span class="keywordflow">if</span> (!zone_VEF.<a class="code" href="classZone__VF.html#a33909d3880435e82e84639b51482d2c6" title="renvoie 1 si face est une face virtuelle de bord, 0 sinon">est_une_face_virt_bord</a>(face)) <span class="comment">//!&lt; On ne traite que les faces internes</span>
<span class="comment"></span>        {
          <a class="code" href="AssembleurPP1BUtil_8cpp.html#afd0a249a235b161c5267e7574e199a82">remplir_sommets</a>(zone_VEF, face, elem1, elem2, sommets,
                          face_opp1, face_opp2);
          <a class="code" href="AssembleurPP1BUtil_8cpp.html#acff816d35f8d4ce978f860e0cd958b8a">sort</a>(sommets, face_opp1, face_opp2);
          <a class="code" href="AssembleurPP1BUtil_8cpp.html#a77351839245012751e4d90a39922356a">update_matriceP1P1</a>(zone_VEF, inverse_quantitee_entrelacee,
                             face, elem1, elem2, sommets,
                             face_opp1, face_opp2, coef_som,
                             ARR,ARV,AVR,AVV);
        }
    }
  <span class="keywordtype">int</span> nb_som=zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#ad340f571f81fa5c2e028b88c00b5c2ca" title="Renvoie le nombre de sommets de la zone.">nb_som</a>();
  <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;nb_som; i++)
    <span class="keywordflow">if</span>(ARR(i,i)==0)
      {
<span class="comment">// Cerr &lt;&lt; &quot;On modifie la ligne (sommet) orpheline &quot; &lt;&lt; i &lt;&lt; finl;</span>
        ARR(i,i)=1.;
      }
  <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Update P1 OK&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a8d9349eb29399f4ac72dc10543a4005a"></a><!-- doxytag: member="Assembleur_P_VEFPreP1B.cpp::updateP1Pa" ref="a8d9349eb29399f4ac72dc10543a4005a" args="(const Zone_dis_base &amp;z, const Zone_Cl_dis_base &amp;zcl, Matrice &amp;matrice, const DoubleTab &amp;inverse_quantitee_entrelacee, const ArrOfDouble &amp;coef_som)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void updateP1Pa </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classZone__dis__base.html">Zone_dis_base</a> &amp;&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classZone__Cl__dis__base.html">Zone_Cl_dis_base</a> &amp;&#160;</td>
          <td class="paramname"><em>zcl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatrice.html">Matrice</a> &amp;&#160;</td>
          <td class="paramname"><em>matrice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>inverse_quantitee_entrelacee</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;&#160;</td>
          <td class="paramname"><em>coef_som</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>&lt; On ne traite que les faces internes </p>
</p>

<p>Definition at line <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l02885">2885</a> of file <a class="el" href="AssembleurPP1BUtil_8cpp_source.html">AssembleurPP1BUtil.cpp</a>.</p>

<p>References <a class="el" href="EntreeSortie_8h_source.html#l00032">Cerr</a>, <a class="el" href="Objet__U_8h_source.html#l00079">Objet_U::dimension</a>, <a class="el" href="Zone__VF_8h_source.html#l00773">Zone_VF::est_une_face_virt_bord()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00046">face_associee</a>, <a class="el" href="Zone__VF_8h_source.html#l00458">Zone_VF::face_voisins()</a>, <a class="el" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>, <a class="el" href="Cond__lim_8h_source.html#l00130">Cond_lim::frontiere_dis()</a>, <a class="el" href="Matrice__Bloc_8cpp_source.html#l00568">Matrice_Bloc::get_bloc()</a>, <a class="el" href="Zone__Cl__dis__base_8cpp_source.html#l00522">Zone_Cl_dis_base::les_conditions_limites()</a>, <a class="el" href="Front__VF_8h_source.html#l00066">Front_VF::nb_faces_tot()</a>, <a class="el" href="Zone__VF_8h_source.html#l00527">Zone_VF::nb_faces_tot()</a>, <a class="el" href="Zone_8cpp_source.html#l00608">Zone::nb_som_tot()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00081">okface()</a>, <a class="el" href="Zone__VF_8h_source.html#l00512">Zone_VF::premiere_face_int()</a>, <a class="el" href="Cast_8h_source.html#l00059">ref_cast</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00349">remplir_sommets()</a>, <a class="el" href="vect__impl_8h_source.html#l00057">vect_impl::size()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l02025">update_matrice_NeumannP1Pa()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l02157">update_matrice_SymetrieP1Pa()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l01888">update_matriceP1Pa()</a>, <a class="el" href="Deriv__Matrice__Base_8h_source.html#l00028">Deriv_Matrice_Base::valeur()</a>, and <a class="el" href="Zone__dis__base_8h_source.html#l00106">Zone_dis_base::zone()</a>.</p>

<p>Referenced by <a class="el" href="Assembleur__P__VEFPreP1B_8cpp_source.html#l00230">Assembleur_P_VEFPreP1B::assembler_mat()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">int</span> dimension=<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>;
  <span class="keyword">const</span> <a class="code" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a>&amp; zone_VEF=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a>, z);
  <span class="keyword">const</span> <a class="code" href="classZone.html" title="classe Zone Une Zone est un maillage compose d&#39;un ensemble d&#39;elements geometriques de meme type...">Zone</a>&amp; zone=zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>();
  <span class="keyword">const</span> <a class="code" href="classZone__Cl__VEF.html">Zone_Cl_VEF</a>&amp; zone_Cl_VEF=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classZone__Cl__VEF.html">Zone_Cl_VEF</a>, zcl);
  <span class="keyword">const</span> <a class="code" href="classConds__lim.html">Conds_lim</a>&amp; les_cl = zone_Cl_VEF.<a class="code" href="classZone__Cl__dis__base.html#af75e0ed7786863e4d333bfb29d67c323" title="Renvoie la i-ieme condition aux limites. (version const)">les_conditions_limites</a>();
  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; face_voisins = zone_VEF.<a class="code" href="classZone__VF.html#a49d4322f5585a8fa95748ca785b70702" title="renvoie l&#39;element voisin de numface dans la direction i. i=0 : dans le sens oppose de l&#39;axe orthogona...">face_voisins</a>();
  <span class="keywordtype">int</span> nint = zone_VEF.<a class="code" href="classZone__VF.html#a12869806fa4834aca8f2964e16509dfd" title="une face est interne ssi elle separe deux elements. renvoie le numero de la premiere face interne...">premiere_face_int</a>();
  <span class="keywordtype">int</span> nb_faces = zone_VEF.<a class="code" href="classZone__VF.html#a50fd21c9535680489015a3c8b88c685a" title="renvoie le nombre total de faces. C&#39;est-a-dire faces reelles + faces virtuelles">nb_faces_tot</a>();
  <span class="keywordtype">int</span> elem1, elem2, face, ok;
  <span class="keywordtype">int</span> nb_som = zone.<a class="code" href="classZone.html#a01ed67af826d6045ef4eacfb87a663e8" title="Renvoie le nombre total de sommets de la zone. i.e. le nombre de sommets reels et virtuels sur le pro...">nb_som_tot</a>();
  <a class="code" href="classIntLists.html" title="Un tableau de listes de type IntList.">IntLists</a> voisins(nb_som);
  <a class="code" href="classDoubleLists.html" title="Un tableau de listes de type DoubleList.">DoubleLists</a> coeffs(nb_som);
  <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> sommets(dimension+2);
  <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> face_opp1(dimension+2);
  <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> face_opp2(dimension+2);
  <a class="code" href="classMatrice__Bloc.html">Matrice_Bloc</a>&amp; A=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Bloc.html">Matrice_Bloc</a>, matrice.<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>());
  <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; ARR=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>, A.<a class="code" href="classMatrice__Bloc.html#a7ffa38f7b93454432b2df7c616ed0a4e">get_bloc</a>(0,0).<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>());
  <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; ARV=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>, A.<a class="code" href="classMatrice__Bloc.html#a7ffa38f7b93454432b2df7c616ed0a4e">get_bloc</a>(0,1).<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>());
  <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; AVR=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>, A.<a class="code" href="classMatrice__Bloc.html#a7ffa38f7b93454432b2df7c616ed0a4e">get_bloc</a>(1,0).<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>());
  <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; AVV=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>, A.<a class="code" href="classMatrice__Bloc.html#a7ffa38f7b93454432b2df7c616ed0a4e">get_bloc</a>(1,1).<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>());
<span class="comment">// Faces de bord :</span>
  <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;les_cl.<a class="code" href="classvect__impl.html#a78155bfbd6b61f4710b9830641ed1694">size</a>(); i++)
    {
      <span class="keyword">const</span> <a class="code" href="classCond__lim.html" title="classe Cond_lim Classe generique servant a representer n&#39;importe quelle classe derivee de la classe C...">Cond_lim</a>&amp; la_cl = les_cl[i];
      <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp; le_bord = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>,la_cl.<a class="code" href="classCond__lim.html#a5b2d24809cee07727006a891d4ce8d22" title="Appel a l&#39;objet sous-jacent Renvoie la frontiere discretisee associee a la condition aux limites...">frontiere_dis</a>());
      <span class="keywordtype">int</span> nb_faces_bord_tot = le_bord.<a class="code" href="classFront__VF.html#aed4006d91bf2ef3af2b9f7933d863a09" title="Nombre de faces reelles et virtuelles du bord.">nb_faces_tot</a>();
      <span class="keywordflow">for</span>(<span class="keywordtype">int</span> ind_face=0; ind_face&lt;nb_faces_bord_tot; ind_face++)
        {
          ok=<a class="code" href="AssembleurPP1BUtil_8cpp.html#a40cf40213663174bb24649e51832bf3e">okface</a>(ind_face, face, la_cl);
          <span class="keywordflow">if</span> (ok==-1) <span class="keywordflow">break</span>;
          elem1=face_voisins(face, 0);
          elem2=face_voisins(face, 1);
          <a class="code" href="AssembleurPP1BUtil_8cpp.html#afd0a249a235b161c5267e7574e199a82">remplir_sommets</a>(zone_VEF, face, elem1, elem2, sommets,
                          face_opp1, face_opp2);
          <span class="keywordflow">if</span>(ok==3)
            {
              <a class="code" href="AssembleurPP1BUtil_8cpp.html#a7da454ba757d1b7ed7ccc39954e6cab5">update_matrice_NeumannP1Pa</a>(zone_VEF,
                                         inverse_quantitee_entrelacee,
                                         face, elem1, sommets,
                                         face_opp1, coef_som,
                                         ARR,ARV,AVR,AVV);
            }
          <span class="keywordflow">else</span> <span class="keywordflow">if</span>(ok==4)
            {
              <a class="code" href="AssembleurPP1BUtil_8cpp.html#aa18f9eabe40c3c77172253c07802c05f">update_matrice_SymetrieP1Pa</a>(zone_VEF,
                                          inverse_quantitee_entrelacee,
                                          face, elem1, sommets,
                                          face_opp1, coef_som,
                                          ARR,ARV,AVR,AVV);
            }
          <span class="keywordflow">else</span>
            <a class="code" href="AssembleurPP1BUtil_8cpp.html#ac499159b3caa7be06c8c9fddfdb5c8c1">update_matriceP1Pa</a>(zone_VEF,
                               inverse_quantitee_entrelacee,
                               face, elem1, elem2, sommets,
                               face_opp1, face_opp2, coef_som,
                               ARR,ARV,AVR,AVV);
        }
    }
  <a class="code" href="AssembleurPP1BUtil_8cpp.html#a3e374d53ebc7860e1c2f0b7906f2936d">face_associee</a>=-1;
  <span class="keywordflow">for</span>(face=nint; face&lt;nb_faces; face++)
    {
      elem1=face_voisins(face, 0);
      elem2=face_voisins(face, 1);
      <span class="keywordflow">if</span> (!zone_VEF.<a class="code" href="classZone__VF.html#a33909d3880435e82e84639b51482d2c6" title="renvoie 1 si face est une face virtuelle de bord, 0 sinon">est_une_face_virt_bord</a>(face)) <span class="comment">//!&lt; On ne traite que les faces internes</span>
<span class="comment"></span>        {
          <a class="code" href="AssembleurPP1BUtil_8cpp.html#afd0a249a235b161c5267e7574e199a82">remplir_sommets</a>(zone_VEF, face, elem1, elem2, sommets,
                          face_opp1, face_opp2);
          <a class="code" href="AssembleurPP1BUtil_8cpp.html#ac499159b3caa7be06c8c9fddfdb5c8c1">update_matriceP1Pa</a>(zone_VEF,
                             inverse_quantitee_entrelacee,
                             face, elem1, elem2, sommets,
                             face_opp1, face_opp2,coef_som,
                             ARR,ARV,AVR,AVV);
        }
    }

  <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Update P1Pa OK&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a4e0c0752e80915fd8b0143b70f08e718"></a><!-- doxytag: member="Assembleur_P_VEFPreP1B.cpp::updatePaPa" ref="a4e0c0752e80915fd8b0143b70f08e718" args="(const Zone_dis_base &amp;z, const Zone_Cl_dis_base &amp;zcl, Matrice &amp;matrice, const DoubleTab &amp;inverse_quantitee_entrelacee)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void updatePaPa </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classZone__dis__base.html">Zone_dis_base</a> &amp;&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classZone__Cl__dis__base.html">Zone_Cl_dis_base</a> &amp;&#160;</td>
          <td class="paramname"><em>zcl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatrice.html">Matrice</a> &amp;&#160;</td>
          <td class="paramname"><em>matrice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>inverse_quantitee_entrelacee</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>&lt; On ne traite que les faces internes </p>
</p>

<p>Definition at line <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l02567">2567</a> of file <a class="el" href="AssembleurPP1BUtil_8cpp_source.html">AssembleurPP1BUtil.cpp</a>.</p>

<p>References <a class="el" href="EntreeSortie_8h_source.html#l00032">Cerr</a>, <a class="el" href="Objet__U_8h_source.html#l00079">Objet_U::dimension</a>, <a class="el" href="Zone__VF_8h_source.html#l00773">Zone_VF::est_une_face_virt_bord()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00046">face_associee</a>, <a class="el" href="Zone__VF_8h_source.html#l00458">Zone_VF::face_voisins()</a>, <a class="el" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>, <a class="el" href="Cond__lim_8h_source.html#l00130">Cond_lim::frontiere_dis()</a>, <a class="el" href="Matrice__Bloc_8cpp_source.html#l00568">Matrice_Bloc::get_bloc()</a>, <a class="el" href="Zone__Cl__dis__base_8cpp_source.html#l00522">Zone_Cl_dis_base::les_conditions_limites()</a>, <a class="el" href="Zone_8h_source.html#l01258">Zone::nb_aretes()</a>, <a class="el" href="Front__VF_8h_source.html#l00066">Front_VF::nb_faces_tot()</a>, <a class="el" href="Zone__VF_8h_source.html#l00527">Zone_VF::nb_faces_tot()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00081">okface()</a>, <a class="el" href="Zone__VF_8h_source.html#l00512">Zone_VF::premiere_face_int()</a>, <a class="el" href="Cast_8h_source.html#l00059">ref_cast</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00349">remplir_sommets()</a>, <a class="el" href="vect__impl_8h_source.html#l00057">vect_impl::size()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l01319">update_matrice_NeumannPaPa()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l01478">update_matrice_SymetriePaPa()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00843">update_matricePaPa()</a>, <a class="el" href="Deriv__Matrice__Base_8h_source.html#l00028">Deriv_Matrice_Base::valeur()</a>, and <a class="el" href="Zone__dis__base_8h_source.html#l00106">Zone_dis_base::zone()</a>.</p>

<p>Referenced by <a class="el" href="Assembleur__P__VEFPreP1B_8cpp_source.html#l00230">Assembleur_P_VEFPreP1B::assembler_mat()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">int</span> dimension=<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>;
  <span class="keyword">const</span> <a class="code" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a>&amp; zone_VEF=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a>, z);
  <span class="keyword">const</span> <a class="code" href="classZone.html" title="classe Zone Une Zone est un maillage compose d&#39;un ensemble d&#39;elements geometriques de meme type...">Zone</a>&amp; zone=zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>();
  <span class="keyword">const</span> <a class="code" href="classZone__Cl__VEF.html">Zone_Cl_VEF</a>&amp; zone_Cl_VEF=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classZone__Cl__VEF.html">Zone_Cl_VEF</a>, zcl);
  <span class="keyword">const</span> <a class="code" href="classConds__lim.html">Conds_lim</a>&amp; les_cl = zone_Cl_VEF.<a class="code" href="classZone__Cl__dis__base.html#af75e0ed7786863e4d333bfb29d67c323" title="Renvoie la i-ieme condition aux limites. (version const)">les_conditions_limites</a>();
  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; face_voisins = zone_VEF.<a class="code" href="classZone__VF.html#a49d4322f5585a8fa95748ca785b70702" title="renvoie l&#39;element voisin de numface dans la direction i. i=0 : dans le sens oppose de l&#39;axe orthogona...">face_voisins</a>();
  <span class="keywordtype">int</span> nint = zone_VEF.<a class="code" href="classZone__VF.html#a12869806fa4834aca8f2964e16509dfd" title="une face est interne ssi elle separe deux elements. renvoie le numero de la premiere face interne...">premiere_face_int</a>();
  <span class="keywordtype">int</span> nb_faces = zone_VEF.<a class="code" href="classZone__VF.html#a50fd21c9535680489015a3c8b88c685a" title="renvoie le nombre total de faces. C&#39;est-a-dire faces reelles + faces virtuelles">nb_faces_tot</a>();
  <span class="keywordtype">int</span> nb_arete = zone.<a class="code" href="classZone.html#a3e3b48691911fd85574c7bc10a1a4fb8" title="renvoie le nombre d&#39;aretes reelles.">nb_aretes</a>();
  <span class="keywordtype">int</span> elem1, elem2, face, ok;
  <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> sommets(dimension+2);
  <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> face_opp1(dimension+2);
  <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> face_opp2(dimension+2);
  <a class="code" href="classMatrice__Bloc.html">Matrice_Bloc</a>&amp; A=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Bloc.html">Matrice_Bloc</a>, matrice.<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>());
  <a class="code" href="classMatrice__Morse__Sym.html" title="Classe Matrice_Morse_Sym Represente une matrice M (creuse) symetrique stockee au format Morse Symetri...">Matrice_Morse_Sym</a>&amp; ARR=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Morse__Sym.html" title="Classe Matrice_Morse_Sym Represente une matrice M (creuse) symetrique stockee au format Morse Symetri...">Matrice_Morse_Sym</a>, A.<a class="code" href="classMatrice__Bloc.html#a7ffa38f7b93454432b2df7c616ed0a4e">get_bloc</a>(0,0).<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>());
  <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; ARV=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>, A.<a class="code" href="classMatrice__Bloc.html#a7ffa38f7b93454432b2df7c616ed0a4e">get_bloc</a>(0,1).<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>());
  <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; AVR=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>, A.<a class="code" href="classMatrice__Bloc.html#a7ffa38f7b93454432b2df7c616ed0a4e">get_bloc</a>(1,0).<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>());
  <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; AVV=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>, A.<a class="code" href="classMatrice__Bloc.html#a7ffa38f7b93454432b2df7c616ed0a4e">get_bloc</a>(1,1).<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>());
<span class="comment">// Faces de bord :</span>
  <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;les_cl.<a class="code" href="classvect__impl.html#a78155bfbd6b61f4710b9830641ed1694">size</a>(); i++)
    {
      <span class="keyword">const</span> <a class="code" href="classCond__lim.html" title="classe Cond_lim Classe generique servant a representer n&#39;importe quelle classe derivee de la classe C...">Cond_lim</a>&amp; la_cl = les_cl[i];
      <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp; le_bord = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>,la_cl.<a class="code" href="classCond__lim.html#a5b2d24809cee07727006a891d4ce8d22" title="Appel a l&#39;objet sous-jacent Renvoie la frontiere discretisee associee a la condition aux limites...">frontiere_dis</a>());
      <span class="keywordtype">int</span> nb_faces_bord_tot = le_bord.<a class="code" href="classFront__VF.html#aed4006d91bf2ef3af2b9f7933d863a09" title="Nombre de faces reelles et virtuelles du bord.">nb_faces_tot</a>();
      <span class="keywordflow">for</span>(<span class="keywordtype">int</span> ind_face=0; ind_face&lt;nb_faces_bord_tot; ind_face++)
        {
          ok=<a class="code" href="AssembleurPP1BUtil_8cpp.html#a40cf40213663174bb24649e51832bf3e">okface</a>(ind_face, face, la_cl);
          <span class="keywordflow">if</span> (ok==-1) <span class="keywordflow">break</span>;
          elem1=face_voisins(face, 0);
          elem2=face_voisins(face, 1);
          <a class="code" href="AssembleurPP1BUtil_8cpp.html#afd0a249a235b161c5267e7574e199a82">remplir_sommets</a>(zone_VEF, face, elem1, elem2, sommets,
                          face_opp1, face_opp2);
          <span class="keywordflow">if</span>(ok==3)
            {
              <a class="code" href="AssembleurPP1BUtil_8cpp.html#a6a26a390dab2336113f60275e5978aaf">update_matrice_NeumannPaPa</a>(zone_VEF,
                                         inverse_quantitee_entrelacee,
                                         face, elem1, sommets,
                                         face_opp1,
                                         ARR, ARV, AVR, AVV);
            }
          <span class="keywordflow">else</span> <span class="keywordflow">if</span>(ok==4)
            {
              <a class="code" href="AssembleurPP1BUtil_8cpp.html#a6e9d49381847c5756d002970ca6441b8">update_matrice_SymetriePaPa</a>(zone_VEF,
                                          inverse_quantitee_entrelacee,
                                          face, elem1, sommets,
                                          face_opp1,
                                          ARR, ARV, AVR, AVV);
            }
          <span class="keywordflow">else</span>
            <a class="code" href="AssembleurPP1BUtil_8cpp.html#a76d676949fb80bc3c7f1ab5f7f8078c0">update_matricePaPa</a>(zone_VEF,
                               inverse_quantitee_entrelacee,
                               face, elem1, elem2, sommets,
                               face_opp1, face_opp2,
                               ARR, ARV, AVR, AVV);
        }
    }
  <a class="code" href="AssembleurPP1BUtil_8cpp.html#a3e374d53ebc7860e1c2f0b7906f2936d">face_associee</a>=-1;
  <span class="keywordflow">for</span>(face=nint; face&lt;nb_faces; face++)
    {
      elem1=face_voisins(face, 0);
      elem2=face_voisins(face, 1);
      <span class="keywordflow">if</span> (!zone_VEF.<a class="code" href="classZone__VF.html#a33909d3880435e82e84639b51482d2c6" title="renvoie 1 si face est une face virtuelle de bord, 0 sinon">est_une_face_virt_bord</a>(face)) <span class="comment">//!&lt; On ne traite que les faces internes</span>
<span class="comment"></span>        {
          <a class="code" href="AssembleurPP1BUtil_8cpp.html#afd0a249a235b161c5267e7574e199a82">remplir_sommets</a>(zone_VEF, face, elem1, elem2, sommets,
                          face_opp1, face_opp2);
          <a class="code" href="AssembleurPP1BUtil_8cpp.html#a76d676949fb80bc3c7f1ab5f7f8078c0">update_matricePaPa</a>(zone_VEF,
                             inverse_quantitee_entrelacee,
                             face, elem1, elem2, sommets,
                             face_opp1, face_opp2,
                             ARR,ARV,AVR,AVV);
        }
    }
  <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;nb_arete; i++)
    <span class="keywordflow">if</span>(ARR(i,i)==0)
      {
<span class="comment">// On n&#39;affiche pas car trop sur de gros maillages</span>
<span class="comment">// Cerr &lt;&lt; &quot;On modifie la ligne (arete) orpheline &quot; &lt;&lt; i &lt;&lt; finl;</span>
        ARR(i,i)=1;
      }

  <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Update Pa OK&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="ab3f0bf1b466f4f73f7c106a25a0ce950"></a><!-- doxytag: member="Assembleur_P_VEFPreP1B.cpp::verifier" ref="ab3f0bf1b466f4f73f7c106a25a0ce950" args="(const Assembleur_P_VEFPreP1B &amp;ass, const Matrice_Bloc_Sym &amp;matrice, const Zone_VEF_PreP1b &amp;zone_VEF, const DoubleTab &amp;inverse_quantitee_entrelacee)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int verifier </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAssembleur__P__VEFPreP1B.html">Assembleur_P_VEFPreP1B</a> &amp;&#160;</td>
          <td class="paramname"><em>ass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMatrice__Bloc__Sym.html">Matrice_Bloc_Sym</a> &amp;&#160;</td>
          <td class="paramname"><em>matrice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a> &amp;&#160;</td>
          <td class="paramname"><em>zone_VEF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>inverse_quantitee_entrelacee</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00146">146</a> of file <a class="el" href="AssembleurPP1BUtil_8cpp_source.html">AssembleurPP1BUtil.cpp</a>.</p>

<p>References <a class="el" href="Op__Div__VEF__Elem_8cpp_source.html#l00072">Op_Div_VEF_Elem::calculer()</a>, <a class="el" href="Op__Grad__VEF__Face_8cpp_source.html#l00069">Op_Grad_VEF_Face::calculer()</a>, <a class="el" href="EntreeSortie_8h_source.html#l00032">Cerr</a>, <a class="el" href="Objet__U_8h_source.html#l00079">Objet_U::dimension</a>, <a class="el" href="DoubleTab_8h_source.html#l00254">DoubleTab::dimension_tot()</a>, <a class="el" href="Double_8h_source.html#l00075">DMINFLOAT</a>, <a class="el" href="DoubleVect_8cpp_source.html#l00277">DoubleVect::echange_espace_virtuel()</a>, <a class="el" href="DoubleTab_8cpp_source.html#l00534">DoubleTab::ecrit()</a>, <a class="el" href="communications_8cpp_source.html#l00375">envoyer_broadcast()</a>, <a class="el" href="Assembleur__P__VEFPreP1B_8h_source.html#l00047">Assembleur_P_VEFPreP1B::equation()</a>, <a class="el" href="Solv__GCP__NS_8cpp_source.html#l00141">erreur()</a>, <a class="el" href="Double_8h_source.html#l00273">est_egal()</a>, <a class="el" href="Process_8cpp_source.html#l00223">Process::exit()</a>, <a class="el" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>, <a class="el" href="Zone__VEF__PreP1b_8h_source.html#l00071">Zone_VEF_PreP1b::get_alphaA()</a>, <a class="el" href="Zone__VEF__PreP1b_8h_source.html#l00061">Zone_VEF_PreP1b::get_alphaE()</a>, <a class="el" href="Zone__VEF__PreP1b_8h_source.html#l00066">Zone_VEF_PreP1b::get_alphaS()</a>, <a class="el" href="Zone__VEF__PreP1b_8h_source.html#l00090">Zone_VEF_PreP1b::get_ok_arete()</a>, <a class="el" href="Zone__VEF__PreP1b_8h_source.html#l00086">Zone_VEF_PreP1b::get_renum_arete_perio()</a>, <a class="el" href="Matrice__Bloc__Sym_8cpp_source.html#l00064">Matrice_Bloc_Sym::imprimer_formatte()</a>, <a class="el" href="Navier__Stokes__std_8cpp_source.html#l00748">Navier_Stokes_std::inconnue()</a>, <a class="el" href="Process_8cpp_source.html#l00117">Process::me()</a>, <a class="el" href="DoubleVect_8cpp_source.html#l02265">mp_max_vect()</a>, <a class="el" href="DoubleVect_8cpp_source.html#l02353">mp_norme_vect()</a>, <a class="el" href="DoubleVect_8cpp_source.html#l02342">mp_prodscal()</a>, <a class="el" href="Matrice__Base_8h_source.html#l00127">Matrice_Base::multvect()</a>, <a class="el" href="Zone_8h_source.html#l00300">Zone::nb_elem()</a>, <a class="el" href="Process_8cpp_source.html#l00109">Process::nproc()</a>, <a class="el" href="Navier__Stokes__std_8cpp_source.html#l00665">Navier_Stokes_std::operateur_divergence()</a>, <a class="el" href="Navier__Stokes__std_8cpp_source.html#l00706">Navier_Stokes_std::operateur_gradient()</a>, <a class="el" href="Navier__Stokes__std_8h_source.html#l00268">Navier_Stokes_std::pression()</a>, <a class="el" href="Cast_8h_source.html#l00059">ref_cast</a>, <a class="el" href="DoubleVect_8h_source.html#l00153">DoubleVect::size()</a>, <a class="el" href="Champ__Inc_8cpp_source.html#l00245">Champ_Inc::valeurs()</a>, <a class="el" href="Type__Verifie_8cpp_source.html#l00029">verifie()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00118">verifier_complet()</a>, and <a class="el" href="Zone__dis__base_8h_source.html#l00106">Zone_dis_base::zone()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">if</span> (zone_VEF.<a class="code" href="classZone__VEF__PreP1b.html#aee2def53aa92584d7945e7c3d0d98963">get_alphaE</a>()+zone_VEF.<a class="code" href="classZone__VEF__PreP1b.html#ad7fbcb5567dcc2e6f0a0ed85ce90a4fa">get_alphaS</a>()+zone_VEF.<a class="code" href="classZone__VEF__PreP1b.html#a9d02e2431efb6e75c3d733ff06f89549">get_alphaA</a>()!=<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>)
    {
      <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Assembleur_P_VEFPreP1B::verifier n&#39;est pas prevu pour verifier votre discretisation.&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
      <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">Process::exit</a>();
    }
  <span class="keyword">const</span> <a class="code" href="classNavier__Stokes__std.html" title="classe Navier_Stokes_std Cette classe porte les termes de l&#39;equation de la dynamique pour un fluide s...">Navier_Stokes_std</a>&amp; eqn=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classNavier__Stokes__std.html" title="classe Navier_Stokes_std Cette classe porte les termes de l&#39;equation de la dynamique pour un fluide s...">Navier_Stokes_std</a>, ass.<a class="code" href="classAssembleur__P__VEFPreP1B.html#a9a85837c29e80d1bcbc3a7f740f93807">equation</a>());
  <span class="keyword">const</span> <a class="code" href="classOperateur__Div.html" title="classe Operateur_Div Classe generique de la hierarchie des operateurs calculant la divergence d&#39;un ch...">Operateur_Div</a>&amp; opdiv=eqn.<a class="code" href="classNavier__Stokes__std.html#a614d41350181667ee295b87a72779c1a" title="Renvoie l&#39;operateur de calcul de la divergence associe a l&#39;equation.">operateur_divergence</a>();
  <span class="keyword">const</span> <a class="code" href="classOp__Div__VEFP1B__Elem.html">Op_Div_VEFP1B_Elem</a>&amp; div=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classOp__Div__VEFP1B__Elem.html">Op_Div_VEFP1B_Elem</a>,
                                         opdiv.valeur());
<span class="comment">// div.verifier();</span>
  <span class="keyword">const</span> <a class="code" href="classOperateur__Grad.html" title="Classe Operateur_Grad Classe generique de la hierarchie des operateurs calculant le gradient d&#39;un cha...">Operateur_Grad</a>&amp; opgrad=eqn.<a class="code" href="classNavier__Stokes__std.html#a840295836fce939b7861f1353da595ff" title="Renvoie l&#39;operateur de calcul du gradient associe a l&#39;equation.">operateur_gradient</a>();
  <span class="keyword">const</span> <a class="code" href="classOp__Grad__VEF__P1B__Face.html">Op_Grad_VEF_P1B_Face</a>&amp; grad=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classOp__Grad__VEF__P1B__Face.html">Op_Grad_VEF_P1B_Face</a>,
                                            opgrad.valeur());
<span class="comment">// grad.verifier();</span>
<span class="comment">// const Solveur_Masse&amp; solvm=eqn.solv_masse();</span>
  <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; pression=eqn.<a class="code" href="classNavier__Stokes__std.html#afbb8f39bdfd70328dfad21bf2b9dd45a" title="Renvoie le champ de pression.">pression</a>().<a class="code" href="classChamp__Inc.html#a28ef3d411d12cb5684ac5e799efb7d24" title="Appel a l&#39;objet sous-jacent Renvoie le tableau des valeurs au temps courant.">valeurs</a>();
  <span class="keywordtype">int</span> ko=0;
  ko=<a class="code" href="AssembleurPP1BUtil_8cpp.html#add6cc8459f10f15a9a6bac24d1727880">verifier_complet</a>(ass, matrice, zone_VEF);
  <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a> pre(pression);
  <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a> resu(pre), resu2(pre), <a class="code" href="Solv__GCP__NS_8cpp.html#ab6aa1075b965c7713d8db20dd3a8e09b">erreur</a>(pre);
  <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a> gradP(eqn.<a class="code" href="classNavier__Stokes__std.html#a743b777e6185faee7837326844c8fca1" title="Renvoie la vitesse (champ inconnue de l&#39;equation) (version const)">inconnue</a>().<a class="code" href="classChamp__Inc.html#a28ef3d411d12cb5684ac5e799efb7d24" title="Appel a l&#39;objet sous-jacent Renvoie le tableau des valeurs au temps courant.">valeurs</a>());
  <span class="keyword">const</span> <a class="code" href="classZone.html" title="classe Zone Une Zone est un maillage compose d&#39;un ensemble d&#39;elements geometriques de meme type...">Zone</a>&amp; zone=zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>();
  <span class="keywordtype">int</span> nb_elem=zone.<a class="code" href="classZone.html#a7f249429803b27139a1c54436f6164a5" title="Renvoie le nombre d&#39;elements de la zone.">nb_elem</a>();
  <span class="keywordtype">int</span> nb_elem_tot=zone.nb_elem_tot();
  <span class="keywordtype">int</span> nb_som=zone.domaine().nb_som();
  <span class="keywordtype">int</span> nb_som_tot=zone.domaine().nb_som_tot();
  <span class="keywordtype">int</span> nb_aretes=zone.nb_aretes();
  <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; ok_arete=zone_VEF.<a class="code" href="classZone__VEF__PreP1b.html#a83771f784d487e346b2ef22a389472a2">get_ok_arete</a>();
  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> proc=0; proc&lt;<a class="code" href="classProcess.html#a6bf692ce58d9578aa62ac3c07b8caaa1" title="renvoie le nombre de processeurs dans le groupe courant Voir Comm_Group::nproc() et PE_Groups::curren...">Process::nproc</a>(); proc++)
    {
      <span class="keywordtype">int</span> n = pre.dimension_tot(0);
<span class="comment">// Le processeur proc impose sa valeur de n a tout le monde</span>
      <a class="code" href="communications_8cpp.html#a2335b36078ae87e23dab400a6e129a3c">envoyer_broadcast</a>(n, proc);

      <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;n; i++)
        {
<span class="comment">// Cerr &lt;&lt; &quot;[&quot; &lt;&lt; Process::me() &lt;&lt; &quot;] On verifie la ligne &quot; &lt;&lt; i &lt;&lt; &quot; de la matrice.&quot; &lt;&lt; finl;</span>
          pre=0;
          <span class="keywordflow">if</span> (<a class="code" href="classProcess.html#ab55ba07167ec807ed3a145cac0f5dca4" title="renvoie mon rang dans le groupe de communication courant. Voir Comm_Group::rank() et PE_Groups::curre...">Process::me</a>()==proc)
            {
              <span class="keywordflow">if</span> (0&lt;=i &amp;&amp; i&lt;nb_elem)
                {
                  <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;On verifie l&#39;element reel &quot;</span> &lt;&lt; i &lt;&lt; <span class="stringliteral">&quot; du processeur &quot;</span> &lt;&lt; proc;
                  pre(i)=1;
                }
              <span class="keywordflow">else</span> <span class="keywordflow">if</span> (nb_elem_tot&lt;=i &amp;&amp; i&lt;nb_elem_tot+nb_som)
                {
                  <span class="keywordtype">int</span> sommet=i-nb_elem_tot;
                  <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;On verifie le sommet reel &quot;</span>;
                  <span class="keywordflow">if</span> (zone.domaine().get_renum_som_perio(sommet)!=sommet) <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;periodique &quot;</span>;
                  <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; i-nb_elem_tot &lt;&lt; <span class="stringliteral">&quot; du processeur &quot;</span> &lt;&lt; proc;
                  pre(i)=1;
                }
              <span class="keywordflow">else</span> <span class="keywordflow">if</span> (nb_elem_tot+nb_som_tot&lt;=i &amp;&amp; i&lt;nb_elem_tot+nb_som_tot+nb_aretes &amp;&amp; ok_arete(i-nb_elem_tot-nb_som_tot))
                {
                  <span class="keywordtype">int</span> arete=i-nb_elem_tot-nb_som_tot;
                  <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; renum_arete_perio=zone_VEF.<a class="code" href="classZone__VEF__PreP1b.html#a43767f8684512d1ee950dc07eea76c5b">get_renum_arete_perio</a>();
                  <span class="keywordflow">if</span> (renum_arete_perio(arete)==arete)
                    {
                      <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;On verifie l&#39;arete reelle non superflue et non periodique &quot;</span> &lt;&lt; arete &lt;&lt; <span class="stringliteral">&quot; du processeur &quot;</span> &lt;&lt; proc;
                      pre(i)=1;
                    }
                }
              <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot; &quot;</span>;
<span class="comment">// Cerr &lt;&lt; finl;</span>
            }
          <span class="keywordtype">double</span> <a class="code" href="Type__Verifie_8cpp.html#ad3531c82596e15d1af86ea6b2713ef51">verifie</a>=<a class="code" href="DoubleVect_8cpp.html#adcc29a107bd1ad77828da317da293203">mp_max_vect</a>(pre);
<span class="comment">// verifie=1;pre(i)=1; // On teste tout</span>
          <span class="keywordflow">if</span> (verifie)
            {
              pre.echange_espace_virtuel();
              <span class="comment">/* Inutile le debog ce n&#39;est pas comparable le sequentiel et le parallele</span>
<span class="comment">                 Nom ch;</span>
<span class="comment">                 ch=&quot;pre pour la ligne &quot;;</span>
<span class="comment">                 ch+=(Nom)i+&quot; du processeur &quot;;</span>
<span class="comment">                 ch+=(Nom)proc+&quot; =&quot;;</span>
<span class="comment">                 Debog::verifier(ch,pre);</span>
<span class="comment">              */</span>
<span class="comment">// Calcul par Div(Grad(P))</span>
              grad.<a class="code" href="classOp__Grad__VEF__Face.html#a06e2a3259889b939f7a0b8d7420d16f3">calculer</a>(pre, gradP);
              {
                <span class="keywordtype">int</span> nbf=inverse_quantitee_entrelacee.<a class="code" href="classDoubleVect.html#a392c1f20b462563365389d28e0853867" title="Identique a size_reelle()">size</a>();
                <span class="keywordtype">int</span> d = <a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>;
                <span class="keywordflow">for</span> (<span class="keywordtype">int</span> face=0; face&lt;nbf; face++)
                  <span class="keywordflow">for</span>(<span class="keywordtype">int</span> k=0; k&lt;d; k++)
                    gradP(face,k)*=inverse_quantitee_entrelacee(face,k);
              }
<span class="comment">// solvm.appliquer(gradP);</span>
              div.<a class="code" href="classOp__Div__VEF__Elem.html#ab28b31e5146e5774e799093c3aaffa19">calculer</a>(gradP, resu);
<span class="comment">// Calcul par -Lap(P)</span>
              matrice.<a class="code" href="classMatrice__Base.html#a05caa487a25a6d5e7fbd38d4b2f4ee1e" title="Multiplication d&#39;un vecteur par la matrice. Operation: r = A*x.">multvect</a>(pre, resu2);
<span class="comment">// On doit trouver erreur nul</span>
              <a class="code" href="Solv__GCP__NS_8cpp.html#ab6aa1075b965c7713d8db20dd3a8e09b">erreur</a>=resu2;
              <a class="code" href="Solv__GCP__NS_8cpp.html#ab6aa1075b965c7713d8db20dd3a8e09b">erreur</a>+=resu;
              resu*=-1;
<span class="comment">// Cas ou la diagonale est *2, on corrige:</span>
              <span class="keywordflow">if</span> (<a class="code" href="Double_8h.html#ac86f5f350b0f95fd8c34b0ac8d720f6f">est_egal</a>(2*resu(i),resu2(i))) <a class="code" href="Solv__GCP__NS_8cpp.html#ab6aa1075b965c7713d8db20dd3a8e09b">erreur</a>(i)=0;
              <span class="keywordtype">double</span> erreur_absolue=<a class="code" href="DoubleVect_8cpp.html#afaa33f0032aa927d8d54ff9fb002b749">mp_norme_vect</a>(<a class="code" href="Solv__GCP__NS_8cpp.html#ab6aa1075b965c7713d8db20dd3a8e09b">erreur</a>);
              <span class="keywordtype">double</span> erreur_relative=erreur_absolue/(<a class="code" href="DoubleVect_8cpp.html#afaa33f0032aa927d8d54ff9fb002b749">mp_norme_vect</a>(resu2)+<a class="code" href="DoubleVect_8cpp.html#afaa33f0032aa927d8d54ff9fb002b749">mp_norme_vect</a>(resu)+<a class="code" href="Double_8h.html#a0a3fffa6d17ad8f7de4bb337c6266561">DMINFLOAT</a>);
              <span class="keywordtype">double</span> app=<a class="code" href="DoubleVect_8cpp.html#a07d13cbdadca6b60d5e128653f52a4bb">mp_prodscal</a>(resu,pre);
              <span class="keywordflow">if</span>(erreur_absolue&gt;1.e-12 &amp;&amp; erreur_relative&gt;1.e-6)
                {
                  <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;[&quot;</span> &lt;&lt; <a class="code" href="classProcess.html#ab55ba07167ec807ed3a145cac0f5dca4" title="renvoie mon rang dans le groupe de communication courant. Voir Comm_Group::rank() et PE_Groups::curre...">Process::me</a>() &lt;&lt; <span class="stringliteral">&quot;] KO a la ligne &quot;</span> &lt;&lt; i &lt;&lt; <span class="stringliteral">&quot; pour le proc &quot;</span> &lt;&lt; proc &lt;&lt; <span class="stringliteral">&quot; (AP,P)= &quot;</span> &lt;&lt; app &lt;&lt; <span class="stringliteral">&quot; erreur= &quot;</span> &lt;&lt; erreur_absolue &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
                  ko=1;
                  <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;[&quot;</span> &lt;&lt; <a class="code" href="classProcess.html#ab55ba07167ec807ed3a145cac0f5dca4" title="renvoie mon rang dans le groupe de communication courant. Voir Comm_Group::rank() et PE_Groups::curre...">Process::me</a>() &lt;&lt; <span class="stringliteral">&quot;] pre= &quot;</span>;
                  pre.ecrit(<a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a>);
                  <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;[&quot;</span> &lt;&lt; <a class="code" href="classProcess.html#ab55ba07167ec807ed3a145cac0f5dca4" title="renvoie mon rang dans le groupe de communication courant. Voir Comm_Group::rank() et PE_Groups::curre...">Process::me</a>() &lt;&lt; <span class="stringliteral">&quot;] Div(gradP) = &quot;</span>;
                  resu.ecrit(<a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a>);
                  <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;[&quot;</span> &lt;&lt; <a class="code" href="classProcess.html#ab55ba07167ec807ed3a145cac0f5dca4" title="renvoie mon rang dans le groupe de communication courant. Voir Comm_Group::rank() et PE_Groups::curre...">Process::me</a>() &lt;&lt; <span class="stringliteral">&quot;] Lap(P) = &quot;</span>;
                  resu2.ecrit(<a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a>);
                  <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;[&quot;</span> &lt;&lt; <a class="code" href="classProcess.html#ab55ba07167ec807ed3a145cac0f5dca4" title="renvoie mon rang dans le groupe de communication courant. Voir Comm_Group::rank() et PE_Groups::curre...">Process::me</a>() &lt;&lt; <span class="stringliteral">&quot;] erreur = &quot;</span>;
                  <a class="code" href="Solv__GCP__NS_8cpp.html#ab6aa1075b965c7713d8db20dd3a8e09b">erreur</a>.ecrit(<a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a>);
                  <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;[&quot;</span> &lt;&lt; <a class="code" href="classProcess.html#ab55ba07167ec807ed3a145cac0f5dca4" title="renvoie mon rang dans le groupe de communication courant. Voir Comm_Group::rank() et PE_Groups::curre...">Process::me</a>() &lt;&lt; <span class="stringliteral">&quot;] invqtentrelacee = &quot;</span>;
                  inverse_quantitee_entrelacee.<a class="code" href="classDoubleTab.html#ab7588e94792cc0be3a3288573c44ca18" title="ecriture des valeurs du tableau &quot;raw&quot; sans structure parallele">ecrit</a>(<a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a>);
                }
              <span class="keywordflow">else</span>
                {
                  <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;[&quot;</span> &lt;&lt; <a class="code" href="classProcess.html#ab55ba07167ec807ed3a145cac0f5dca4" title="renvoie mon rang dans le groupe de communication courant. Voir Comm_Group::rank() et PE_Groups::curre...">Process::me</a>() &lt;&lt; <span class="stringliteral">&quot;] OK a la ligne &quot;</span> &lt;&lt; i &lt;&lt; <span class="stringliteral">&quot; pour le proc &quot;</span> &lt;&lt; proc &lt;&lt; <span class="stringliteral">&quot; (AP,P)= &quot;</span> &lt;&lt; app &lt;&lt; <span class="stringliteral">&quot; erreur= &quot;</span> &lt;&lt; erreur_absolue &lt;&lt; finl;
                }
            }
        }
    }
  <span class="keywordflow">if</span> (ko)
    {
      <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;[&quot;</span> &lt;&lt; <a class="code" href="classProcess.html#ab55ba07167ec807ed3a145cac0f5dca4" title="renvoie mon rang dans le groupe de communication courant. Voir Comm_Group::rank() et PE_Groups::curre...">Process::me</a>() &lt;&lt; <span class="stringliteral">&quot;] Matrice en pression:&quot;</span> &lt;&lt; finl;
      matrice.<a class="code" href="classMatrice__Bloc__Sym.html#a6218305c5024cbfa78d29c229cb6340f">imprimer_formatte</a>(<a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a>);
      <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Echec de la methode verifier de l&#39;assembleur. Voir les KO.&quot;</span> &lt;&lt; finl;
      <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">Process::exit</a>();
    }
  <span class="keywordflow">return</span> 1;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a6e2318de58fc55873393f2dccdbd9d6c"></a><!-- doxytag: member="Assembleur_P_VEFPreP1B.cpp::zero" ref="a6e2318de58fc55873393f2dccdbd9d6c" args="(Matrice_Bloc_Sym &amp;matrice)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void zero </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMatrice__Bloc__Sym.html">Matrice_Bloc_Sym</a> &amp;&#160;</td>
          <td class="paramname"><em>matrice</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Assembleur__P__VEFPreP1B_8cpp_source.html#l00211">211</a> of file <a class="el" href="Assembleur__P__VEFPreP1B_8cpp_source.html">Assembleur_P_VEFPreP1B.cpp</a>.</p>

<p>References <a class="el" href="Matrice__Bloc_8cpp_source.html#l00568">Matrice_Bloc::get_bloc()</a>, <a class="el" href="Matrice__Bloc__Sym_8cpp_source.html#l00281">Matrice_Bloc_Sym::get_bloc()</a>, <a class="el" href="Process_8cpp_source.html#l00109">Process::nproc()</a>, <a class="el" href="Matrice__Bloc_8cpp_source.html#l00085">Matrice_Bloc::ordre()</a>, <a class="el" href="Cast_8h_source.html#l00059">ref_cast</a>, and <a class="el" href="Deriv__Matrice__Base_8h_source.html#l00028">Deriv_Matrice_Base::valeur()</a>.</p>

<p>Referenced by <a class="el" href="Assembleur__P__VEFPreP1B_8cpp_source.html#l00230">Assembleur_P_VEFPreP1B::assembler_mat()</a>, <a class="el" href="Read__unsupported__ASCII__file__from__ICEM_8cpp_source.html#l00116">check_ICEM_binary_file()</a>, <a class="el" href="Champ__front__lu_8cpp_source.html#l00093">erreur_chfront()</a>, <a class="el" href="Extraire__plan_8cpp_source.html#l00105">Extraire_plan::interpreter_()</a>, and <a class="el" href="Read__unsupported__ASCII__file__from__ICEM_8cpp_source.html#l00046">read_write_string_from()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">int</span> nombre_supports = matrice.<a class="code" href="classMatrice__Bloc.html#aa0ef2e295d67f7d325914bdcff9409d4">ordre</a>();
  <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;nombre_supports; i++)
    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j=i; j&lt;nombre_supports; j++)
      {
        <a class="code" href="classMatrice__Bloc.html">Matrice_Bloc</a>&amp; bloc_ij=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Bloc.html">Matrice_Bloc</a>, matrice.<a class="code" href="classMatrice__Bloc__Sym.html#a1002ce880ea2b2fb48dae444097c9f7a" title="(0&lt;=i&lt;N , i&lt;=j&lt;M)">get_bloc</a>(i,j).<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>());
        <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>, bloc_ij.<a class="code" href="classMatrice__Bloc.html#a7ffa38f7b93454432b2df7c616ed0a4e">get_bloc</a>(0,0).<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>()).clean();
        <span class="keywordflow">if</span>(<a class="code" href="classProcess.html#a6bf692ce58d9578aa62ac3c07b8caaa1" title="renvoie le nombre de processeurs dans le groupe courant Voir Comm_Group::nproc() et PE_Groups::curren...">Process::nproc</a>()&gt;1)
          {
            <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>, bloc_ij.<a class="code" href="classMatrice__Bloc.html#a7ffa38f7b93454432b2df7c616ed0a4e">get_bloc</a>(0,1).<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>()).clean();
            <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>, bloc_ij.<a class="code" href="classMatrice__Bloc.html#a7ffa38f7b93454432b2df7c616ed0a4e">get_bloc</a>(1,0).<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>()).clean();
            <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>, bloc_ij.<a class="code" href="classMatrice__Bloc.html#a7ffa38f7b93454432b2df7c616ed0a4e">get_bloc</a>(1,1).<a class="code" href="classDeriv__Matrice__Base.html#ae43f3a90ca16518c191f9e7d5ebef912">valeur</a>()).clean();
          }
      }
}
</pre></div>
</div>
</div>
<hr/><h2>Variable Documentation</h2>
<a class="anchor" id="aae09693578a6a3e0fde3f6d35fe36da0"></a><!-- doxytag: member="Assembleur_P_VEFPreP1B.cpp::Assembleur_P_VEFPreP1Bbases" ref="aae09693578a6a3e0fde3f6d35fe36da0" args="[1]" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classType__info.html">Type_info</a>* <a class="el" href="Assembleur__P__VEFPreP1B_8cpp.html#aae09693578a6a3e0fde3f6d35fe36da0">Assembleur_P_VEFPreP1Bbases</a>[1] = { &amp;( <a class="el" href="classAssembleur__P__VEF.html">Assembleur_P_VEF</a> ::info_obj)}</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Assembleur__P__VEFPreP1B_8cpp_source.html#l00049">49</a> of file <a class="el" href="Assembleur__P__VEFPreP1B_8cpp_source.html">Assembleur_P_VEFPreP1B.cpp</a>.</p>

</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Tue Dec 14 2021 19:35:56 for TRUST by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
